<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="3018ad27db79c39f8145afd228804aab3254e82a" translate="yes" xml:space="preserve">
          <source>For a type like &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, both possibilites (structural pinning or not) make sense. A &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; with structural pinning could have &lt;code&gt;get_pin&lt;/code&gt;/&lt;code&gt;get_pin_mut&lt;/code&gt; methods to get pinned references to elements. However, it could &lt;em&gt;not&lt;/em&gt; allow calling &lt;code&gt;pop&lt;/code&gt; on a pinned &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; because that would move the (structurally pinned) contents! Nor could it allow &lt;code&gt;push&lt;/code&gt;, which might reallocate and thus also move the contents. A &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; without structural pinning could &lt;code&gt;impl&amp;lt;T&amp;gt; Unpin for Vec&amp;lt;T&amp;gt;&lt;/code&gt;, because the contents are never pinned and the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; itself is fine with being moved as well. At that point pinning just has no effect on the vector at all.</source>
          <target state="translated">Para un tipo como &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; , ambas posibilidades (fijaci&amp;oacute;n estructural o no) tienen sentido. Un &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; con fijaci&amp;oacute;n estructural podr&amp;iacute;a tener m&amp;eacute;todos &lt;code&gt;get_pin&lt;/code&gt; / &lt;code&gt;get_pin_mut&lt;/code&gt; para obtener referencias fijadas a elementos. Sin embargo, podr&amp;iacute;a &lt;em&gt;no&lt;/em&gt; permitir que llamar &lt;code&gt;pop&lt;/code&gt; en un Pinned &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; porque eso ser&amp;iacute;a mover el contenido (estructuralmente) puestas! Tampoco podr&amp;iacute;a permitir el &lt;code&gt;push&lt;/code&gt; , que podr&amp;iacute;a reasignar y, por lo tanto, tambi&amp;eacute;n mover los contenidos. Un &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; sin fijaci&amp;oacute;n estructural podr&amp;iacute;a &lt;code&gt;impl&amp;lt;T&amp;gt; Unpin for Vec&amp;lt;T&amp;gt;&lt;/code&gt; , porque el contenido nunca se fija y &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; s&amp;iacute; mismo est&amp;aacute; bien con ser movido tambi&amp;eacute;n. En ese punto, la fijaci&amp;oacute;n simplemente no tiene ning&amp;uacute;n efecto sobre el vector.</target>
        </trans-unit>
        <trans-unit id="8f35186e1bcfe1224be1716d0530b7876d335108" translate="yes" xml:space="preserve">
          <source>For a type like &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, both possibilities (structural pinning or not) make sense. A &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; with structural pinning could have &lt;code&gt;get_pin&lt;/code&gt;/&lt;code&gt;get_pin_mut&lt;/code&gt; methods to get pinned references to elements. However, it could &lt;em&gt;not&lt;/em&gt; allow calling &lt;a href=&quot;../vec/struct.vec#method.pop&quot;&gt;&lt;code&gt;pop&lt;/code&gt;&lt;/a&gt; on a pinned &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; because that would move the (structurally pinned) contents! Nor could it allow &lt;a href=&quot;../vec/struct.vec#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt;, which might reallocate and thus also move the contents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67d296f2a80f5db17e16b446a5a9cfb39f9637e3" translate="yes" xml:space="preserve">
          <source>For active Rust users, a new edition brings together incremental changes into an easy-to-understand package.</source>
          <target state="translated">Para los usuarios activos de Rust,una nueva edición reúne los cambios incrementales en un paquete fácil de entender.</target>
        </trans-unit>
        <trans-unit id="73ca74581814e147e2e3595a2c92e5345d58125c" translate="yes" xml:space="preserve">
          <source>For additional practice, add an &lt;code&gt;add-two&lt;/code&gt; crate to this workspace in a similar way as the &lt;code&gt;add-one&lt;/code&gt; crate!</source>
          <target state="translated">Para practicar adicional, agregue una caja para &lt;code&gt;add-two&lt;/code&gt; a este espacio de trabajo de una manera similar a la caja para &lt;code&gt;add-one&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6837630c0df8773ee6d141d026932e22f322a94" translate="yes" xml:space="preserve">
          <source>For all other enumerations, the layout is unspecified.</source>
          <target state="translated">Para todas las demás enumeraciones,la disposición no está especificada.</target>
        </trans-unit>
        <trans-unit id="f839518ecde1e4d473a1e1391c3cecd147a2688f" translate="yes" xml:space="preserve">
          <source>For all types, the &lt;code&gt;replace&lt;/code&gt; method replaces the current interior value and returns the replaced value and the &lt;code&gt;into_inner&lt;/code&gt; method consumes the &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; and returns the interior value. Additionally, the &lt;code&gt;set&lt;/code&gt; method replaces the interior value, dropping the replaced value.</source>
          <target state="translated">Para todos los tipos, el m&amp;eacute;todo &lt;code&gt;replace&lt;/code&gt; reemplaza el valor interior actual y devuelve el valor reemplazado y el m&amp;eacute;todo &lt;code&gt;into_inner&lt;/code&gt; consume &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; y devuelve el valor interior. Adem&amp;aacute;s, el m&amp;eacute;todo &lt;code&gt;set&lt;/code&gt; reemplaza el valor interior, eliminando el valor reemplazado.</target>
        </trans-unit>
        <trans-unit id="4a74f1f69aa81d61ed79104423a7e929d2a5e90f" translate="yes" xml:space="preserve">
          <source>For an unsafe version of this function which ignores these checks, see &lt;a href=&quot;#method.from_u32_unchecked&quot;&gt;&lt;code&gt;from_u32_unchecked&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="476b6d833d40fa72a41a7850a15d62e625fad288" translate="yes" xml:space="preserve">
          <source>For an unsafe version of this function which ignores these checks, see &lt;a href=&quot;fn.from_u32_unchecked&quot;&gt;&lt;code&gt;from_u32_unchecked&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para ver una versi&amp;oacute;n insegura de esta funci&amp;oacute;n que ignora estas comprobaciones, consulte &lt;a href=&quot;fn.from_u32_unchecked&quot;&gt; &lt;code&gt;from_u32_unchecked&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="deac77531516e2593df857782566c5a6bc6ab633" translate="yes" xml:space="preserve">
          <source>For an unseparated complex NT in a matcher, &lt;code&gt;M = ... $(tt ...) OP ...&lt;/code&gt;, if OP = &lt;code&gt;\*&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt;, we must have FOLLOW(&lt;code&gt;tt ...&lt;/code&gt;) &amp;supe; FIRST(&lt;code&gt;tt ...&lt;/code&gt;).</source>
          <target state="translated">Para un NT complejo no separado en un comparador, &lt;code&gt;M = ... $(tt ...) OP ...&lt;/code&gt; , si OP = &lt;code&gt;\*&lt;/code&gt; o &lt;code&gt;+&lt;/code&gt; , debemos tener FOLLOW ( &lt;code&gt;tt ...&lt;/code&gt; ) &amp;supe; FIRST ( &lt;code&gt;tt ...&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="567c47b2126f9c8ec60a221bb903f23b7c59a470" translate="yes" xml:space="preserve">
          <source>For another enhancement, let&amp;rsquo;s add a test of the &lt;code&gt;add_one::add_one&lt;/code&gt; function within the &lt;code&gt;add_one&lt;/code&gt; crate:</source>
          <target state="translated">Para otra mejora, agreguemos una prueba de la funci&amp;oacute;n &lt;code&gt;add_one::add_one&lt;/code&gt; dentro de la caja &lt;code&gt;add_one&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a452ba88131c8535dae1f914470890abc9e80f80" translate="yes" xml:space="preserve">
          <source>For another example of an error, suppose there's another trait defined in &lt;code&gt;foo&lt;/code&gt; named &lt;code&gt;ForeignTrait2&lt;/code&gt; that takes two type parameters. Then this &lt;code&gt;impl&lt;/code&gt; results in the same rule violation:</source>
          <target state="translated">Para ver otro ejemplo de error, suponga que hay otro rasgo definido en &lt;code&gt;foo&lt;/code&gt; llamado &lt;code&gt;ForeignTrait2&lt;/code&gt; que toma dos par&amp;aacute;metros de tipo. Entonces, esta &lt;code&gt;impl&lt;/code&gt; icaci&amp;oacute;n da como resultado la misma violaci&amp;oacute;n de la regla:</target>
        </trans-unit>
        <trans-unit id="b298ee6634f789f7504bbe56b35081e11b1776b3" translate="yes" xml:space="preserve">
          <source>For any &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt;, where no overflow occurs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e967e04cf21f07d7428cc8f9d5d43b5223ad6b6" translate="yes" xml:space="preserve">
          <source>For any &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7177439b1c102fad0f955acbe04d8571f3bc735" translate="yes" xml:space="preserve">
          <source>For any &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;n&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0400fbd14de605a36ca6850ba610aa532b5ec511" translate="yes" xml:space="preserve">
          <source>For any &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt;, and &lt;code&gt;m&lt;/code&gt; where &lt;code&gt;n + m&lt;/code&gt; does not overflow:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3a4733d0f33a5abdaf576d0946acf68336e9c47" translate="yes" xml:space="preserve">
          <source>For any &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt;, and &lt;code&gt;m&lt;/code&gt;, where no overflow occurs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b420862395f4311806121a428bcf8094fcd87366" translate="yes" xml:space="preserve">
          <source>For any &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt;, and &lt;code&gt;m&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="283c28e21e5d022c297a84900d000ac8c19d139f" translate="yes" xml:space="preserve">
          <source>For any &lt;code&gt;a&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b45cf56ca7c18d52ba90d4d864763045b8b7c39" translate="yes" xml:space="preserve">
          <source>For any lint check &lt;code&gt;C&lt;/code&gt;:</source>
          <target state="translated">Para cualquier pelusa, verifique &lt;code&gt;C&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="056c0dacdd55194f54d5847447d6f623af23b2c3" translate="yes" xml:space="preserve">
          <source>For any separated complex NT in a matcher, &lt;code&gt;M = ... $(tt ...) SEP OP ...&lt;/code&gt;, we must have &lt;code&gt;SEP&lt;/code&gt; &amp;isin; FOLLOW(&lt;code&gt;tt ...&lt;/code&gt;).</source>
          <target state="translated">Para cualquier NT complejo separado en un comparador, &lt;code&gt;M = ... $(tt ...) SEP OP ...&lt;/code&gt; , debemos tener &lt;code&gt;SEP&lt;/code&gt; &amp;isin; FOLLOW ( &lt;code&gt;tt ...&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1d2f6725c963b627309938adf90568e934652249" translate="yes" xml:space="preserve">
          <source>For any two successive token tree sequences in a matcher &lt;code&gt;M&lt;/code&gt; (i.e. &lt;code&gt;M = ... tt uu ...&lt;/code&gt;) with &lt;code&gt;uu ...&lt;/code&gt; nonempty, we must have FOLLOW(&lt;code&gt;... tt&lt;/code&gt;) &amp;cup; {&amp;epsilon;} &amp;supe; FIRST(&lt;code&gt;uu ...&lt;/code&gt;).</source>
          <target state="translated">Para dos secuencias sucesivas de &amp;aacute;rboles de tokens en un emparejador &lt;code&gt;M&lt;/code&gt; (es decir, &lt;code&gt;M = ... tt uu ...&lt;/code&gt; ) con &lt;code&gt;uu ...&lt;/code&gt; no vac&amp;iacute;o, debemos tener FOLLOW ( &lt;code&gt;... tt&lt;/code&gt; ) &amp;cup; {&amp;epsilon;} &amp;supe; FIRST ( &lt;code&gt;uu ...&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6cdbdbd6c13dc2fb6d28991d433130904066520c" translate="yes" xml:space="preserve">
          <source>For associated functions, there would not be a &lt;code&gt;receiver&lt;/code&gt;: there would only be the list of other arguments. You could use fully qualified syntax everywhere that you call functions or methods. However, you&amp;rsquo;re allowed to omit any part of this syntax that Rust can figure out from other information in the program. You only need to use this more verbose syntax in cases where there are multiple implementations that use the same name and Rust needs help to identify which implementation you want to call.</source>
          <target state="translated">Para las funciones asociadas, no habr&amp;iacute;a un &lt;code&gt;receiver&lt;/code&gt; : solo existir&amp;iacute;a la lista de otros argumentos. Puede usar una sintaxis totalmente calificada en todos los lugares donde llame a funciones o m&amp;eacute;todos. Sin embargo, puede omitir cualquier parte de esta sintaxis que Rust pueda descubrir a partir de otra informaci&amp;oacute;n del programa. Solo necesita usar esta sintaxis m&amp;aacute;s detallada en los casos en que hay varias implementaciones que usan el mismo nombre y Rust necesita ayuda para identificar a qu&amp;eacute; implementaci&amp;oacute;n desea llamar.</target>
        </trans-unit>
        <trans-unit id="a482aec762a0ae7cc8035a9d32a39718410a1d01" translate="yes" xml:space="preserve">
          <source>For builtin pointer types, pointers to &lt;code&gt;T&lt;/code&gt; will coerce to pointers to &lt;code&gt;U&lt;/code&gt; if &lt;code&gt;T: Unsize&amp;lt;U&amp;gt;&lt;/code&gt; by converting from a thin pointer to a fat pointer.</source>
          <target state="translated">Para los tipos de puntero integrados, los punteros a &lt;code&gt;T&lt;/code&gt; forzar&amp;aacute;n a los punteros a &lt;code&gt;U&lt;/code&gt; si &lt;code&gt;T: Unsize&amp;lt;U&amp;gt;&lt;/code&gt; convirtiendo de un puntero delgado a un puntero grueso.</target>
        </trans-unit>
        <trans-unit id="cd4e266e3c4d23a572f017e57b60117e05b20fc7" translate="yes" xml:space="preserve">
          <source>For cases when one does need thread-safe interior mutability, Rust provides &lt;a href=&quot;../sync/atomic/index&quot;&gt;atomic data types&lt;/a&gt;, as well as explicit locking via &lt;a href=&quot;../sync/struct.mutex&quot;&gt;&lt;code&gt;sync::Mutex&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../sync/struct.rwlock&quot;&gt;&lt;code&gt;sync::RwLock&lt;/code&gt;&lt;/a&gt;. These types ensure that any mutation cannot cause data races, hence the types are &lt;code&gt;Sync&lt;/code&gt;. Likewise, &lt;a href=&quot;../sync/struct.arc&quot;&gt;&lt;code&gt;sync::Arc&lt;/code&gt;&lt;/a&gt; provides a thread-safe analogue of &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para los casos en los que se necesita mutabilidad interior segura para subprocesos, Rust proporciona &lt;a href=&quot;../sync/atomic/index&quot;&gt;tipos de datos at&amp;oacute;micos&lt;/a&gt; , as&amp;iacute; como bloqueo expl&amp;iacute;cito a trav&amp;eacute;s de &lt;a href=&quot;../sync/struct.mutex&quot;&gt; &lt;code&gt;sync::Mutex&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../sync/struct.rwlock&quot;&gt; &lt;code&gt;sync::RwLock&lt;/code&gt; &lt;/a&gt; . Estos tipos garantizan que cualquier mutaci&amp;oacute;n no pueda causar carreras de datos, por lo tanto, los tipos son &lt;code&gt;Sync&lt;/code&gt; . Asimismo, &lt;a href=&quot;../sync/struct.arc&quot;&gt; &lt;code&gt;sync::Arc&lt;/code&gt; &lt;/a&gt; proporciona un an&amp;aacute;logo seguro para subprocesos de &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="862c6a0aebea1113158c46f1472b585a3d948023" translate="yes" xml:space="preserve">
          <source>For convenience and historical reasons, the tuple type with no elements (&lt;code&gt;()&lt;/code&gt;) is often called &lt;em&gt;unit&lt;/em&gt; or &lt;em&gt;the unit type&lt;/em&gt;. It's one value is also called &lt;em&gt;unit&lt;/em&gt; or &lt;em&gt;the unit value&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95ce88c6063c5e04848b361d4df1470f061a981a" translate="yes" xml:space="preserve">
          <source>For convenience, running &lt;code&gt;cargo doc --open&lt;/code&gt; will build the HTML for your current crate&amp;rsquo;s documentation (as well as the documentation for all of your crate&amp;rsquo;s dependencies) and open the result in a web browser. Navigate to the &lt;code&gt;add_one&lt;/code&gt; function and you&amp;rsquo;ll see how the text in the documentation comments is rendered, as shown in Figure 14-1:</source>
          <target state="translated">Para mayor comodidad, ejecutar &lt;code&gt;cargo doc --open&lt;/code&gt; crear&amp;aacute; el HTML para la documentaci&amp;oacute;n de su caja actual (as&amp;iacute; como la documentaci&amp;oacute;n para todas las dependencias de su caja) y abrir&amp;aacute; el resultado en un navegador web. Navegue a la funci&amp;oacute;n &lt;code&gt;add_one&lt;/code&gt; y ver&amp;aacute; c&amp;oacute;mo se representa el texto en los comentarios de la documentaci&amp;oacute;n, como se muestra en la Figura 14-1:</target>
        </trans-unit>
        <trans-unit id="066c1d6d346620b3bed514578530bbc0f4c88848" translate="yes" xml:space="preserve">
          <source>For converting to strings use the &lt;a href=&quot;macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt; macro, and for converting from strings use the &lt;a href=&quot;str/trait.fromstr&quot;&gt;&lt;code&gt;FromStr&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">Para convertir a cadenas, use el &lt;a href=&quot;macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt; macro, y para convertir de cadenas use el rasgo &lt;a href=&quot;str/trait.fromstr&quot;&gt; &lt;code&gt;FromStr&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b495fc173ff830e38cba8fae0764e0cd7d19620b" translate="yes" xml:space="preserve">
          <source>For custom types, the coercion here works by coercing &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; to &lt;code&gt;Foo&amp;lt;U&amp;gt;&lt;/code&gt; provided an impl of &lt;code&gt;CoerceUnsized&amp;lt;Foo&amp;lt;U&amp;gt;&amp;gt; for Foo&amp;lt;T&amp;gt;&lt;/code&gt; exists. Such an impl can only be written if &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; has only a single non-phantomdata field involving &lt;code&gt;T&lt;/code&gt;. If the type of that field is &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt;, an implementation of &lt;code&gt;CoerceUnsized&amp;lt;Bar&amp;lt;U&amp;gt;&amp;gt; for Bar&amp;lt;T&amp;gt;&lt;/code&gt; must exist. The coercion will work by coercing the &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; field into &lt;code&gt;Bar&amp;lt;U&amp;gt;&lt;/code&gt; and filling in the rest of the fields from &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; to create a &lt;code&gt;Foo&amp;lt;U&amp;gt;&lt;/code&gt;. This will effectively drill down to a pointer field and coerce that.</source>
          <target state="translated">Para tipos personalizados, la coerci&amp;oacute;n aqu&amp;iacute; funciona coaccionando a &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; a &lt;code&gt;Foo&amp;lt;U&amp;gt;&lt;/code&gt; siempre que &lt;code&gt;CoerceUnsized&amp;lt;Foo&amp;lt;U&amp;gt;&amp;gt; for Foo&amp;lt;T&amp;gt;&lt;/code&gt; una impl de CoerceUnsized &amp;lt;Foo &amp;lt;U&amp;gt;&amp;gt; para Foo &amp;lt;T&amp;gt; . Tal impl s&amp;oacute;lo puede ser escrito si &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; s&amp;oacute;lo tiene un &amp;uacute;nico campo no phantomdata implica &lt;code&gt;T&lt;/code&gt; . Si el tipo de ese campo es &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; , debe existir una implementaci&amp;oacute;n de &lt;code&gt;CoerceUnsized&amp;lt;Bar&amp;lt;U&amp;gt;&amp;gt; for Bar&amp;lt;T&amp;gt;&lt;/code&gt; . La coerci&amp;oacute;n funcionar&amp;aacute; coaccionando el campo &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; en &lt;code&gt;Bar&amp;lt;U&amp;gt;&lt;/code&gt; y completando el resto de los campos de &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; para crear un &lt;code&gt;Foo&amp;lt;U&amp;gt;&lt;/code&gt; .Esto efectivamente profundizar&amp;aacute; en un campo de puntero y lo coaccionar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="60d481b314010be795197eaef3eeb1b40bbbd1e2" translate="yes" xml:space="preserve">
          <source>For default impls in traits, the private helper solution won't work, however closures or copying the parameters should still work.</source>
          <target state="translated">Para los implícitos por defecto en los rasgos,la solución del ayudante privado no funcionará,sin embargo los cierres o la copia de los parámetros deberían seguir funcionando.</target>
        </trans-unit>
        <trans-unit id="18fd7ffece3fe76bf6c6f04f78a662dc5e132236" translate="yes" xml:space="preserve">
          <source>For detailed semantics of this method, see the documentation on &lt;a href=&quot;trait.bufread#method.read_line&quot;&gt;&lt;code&gt;BufRead::read_line&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para conocer la sem&amp;aacute;ntica detallada de este m&amp;eacute;todo, consulte la documentaci&amp;oacute;n en &lt;a href=&quot;trait.bufread#method.read_line&quot;&gt; &lt;code&gt;BufRead::read_line&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4cf690f8462a72a3256098f14214a450a9f6aa92" translate="yes" xml:space="preserve">
          <source>For each field in declaration order in the struct, first determine the size and alignment of the field. If the current offset is not a multiple of the field's alignment, then add padding bytes to the current offset until it is a multiple of the field's alignment. The offset for the field is what the current offset is now. Then increase the current offset by the size of the field.</source>
          <target state="translated">Para cada campo en orden de declaración en la estructura,primero determine el tamaño y la alineación del campo.Si el desplazamiento actual no es un múltiplo de la alineación del campo,entonces añada bytes de relleno al desplazamiento actual hasta que sea un múltiplo de la alineación del campo.El desplazamiento del campo es lo que es el desplazamiento actual.Luego aumente el desplazamiento actual por el tamaño del campo.</target>
        </trans-unit>
        <trans-unit id="72130935b2d001683aa85f003dc696305f2bc73d" translate="yes" xml:space="preserve">
          <source>For each field in the struct ordered by declaration order:</source>
          <target state="translated">Para cada campo de la estructura ordenada por orden de declaración:</target>
        </trans-unit>
        <trans-unit id="0b3508d4624d79af6901523f5a605066ff78ea42" translate="yes" xml:space="preserve">
          <source>For each instance of &lt;code&gt;BuildHasher&lt;/code&gt;, the &lt;a href=&quot;trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt;s created by &lt;a href=&quot;#tymethod.build_hasher&quot;&gt;&lt;code&gt;build_hasher&lt;/code&gt;&lt;/a&gt; should be identical. That is, if the same stream of bytes is fed into each hasher, the same output will also be generated.</source>
          <target state="translated">Para cada instancia de &lt;code&gt;BuildHasher&lt;/code&gt; , los &lt;a href=&quot;trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt; creados por &lt;a href=&quot;#tymethod.build_hasher&quot;&gt; &lt;code&gt;build_hasher&lt;/code&gt; &lt;/a&gt; deben ser id&amp;eacute;nticos. Es decir, si se alimenta el mismo flujo de bytes en cada hash, tambi&amp;eacute;n se generar&amp;aacute; la misma salida.</target>
        </trans-unit>
        <trans-unit id="840895a2afaae6a7f348dca1ec8fcc81fdac329e" translate="yes" xml:space="preserve">
          <source>For each instance of &lt;code&gt;BuildHasher&lt;/code&gt;, the &lt;a href=&quot;trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt;s created by &lt;a href=&quot;trait.buildhasher#tymethod.build_hasher&quot;&gt;&lt;code&gt;build_hasher&lt;/code&gt;&lt;/a&gt; should be identical. That is, if the same stream of bytes is fed into each hasher, the same output will also be generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc391d5855b94ebf31185098078b770ff17af670" translate="yes" xml:space="preserve">
          <source>For enum variants without any data, like &lt;code&gt;Message::Quit&lt;/code&gt;, we can&amp;rsquo;t destructure the value any further. We can only match on the literal &lt;code&gt;Message::Quit&lt;/code&gt; value, and no variables are in that pattern.</source>
          <target state="translated">Para las variantes de enumeraci&amp;oacute;n sin ning&amp;uacute;n dato, como &lt;code&gt;Message::Quit&lt;/code&gt; , no podemos desestructurar el valor m&amp;aacute;s. Solo podemos hacer coincidir el valor literal &lt;code&gt;Message::Quit&lt;/code&gt; , y no hay variables en ese patr&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="2444658cffe28e2cc2f850d1658b58b1e1a36719" translate="yes" xml:space="preserve">
          <source>For enums with fields, it is also possible to combine &lt;code&gt;repr(C)&lt;/code&gt; and a primitive representation (e.g., &lt;code&gt;repr(C, u8)&lt;/code&gt;). This modifies the &lt;a href=&quot;#reprc-enums-with-fields&quot;&gt;&lt;code&gt;repr(C)&lt;/code&gt;&lt;/a&gt; by changing the representation of the discriminant enum to the chosen primitive instead. So, if you chose the &lt;code&gt;u8&lt;/code&gt; representation, then the discriminant enum would have a size and alignment of 1 byte.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e01828e4ae2c2ba5ffc6317469f77820dbf8111b" translate="yes" xml:space="preserve">
          <source>For example when polling on a resource, it is common to check that it is available, and if not to yield in order to avoid busy waiting.</source>
          <target state="translated">Por ejemplo,cuando se hace un sondeo sobre un recurso,es común comprobar que está disponible y,si no,ceder el paso para evitar una espera ocupada.</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="4cd230a3a552ee68ec4ba47f5a2564073dbae972" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;../fs/struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; implements &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt;, but not &lt;code&gt;BufRead&lt;/code&gt;. &lt;a href=&quot;struct.bufreader&quot;&gt;&lt;code&gt;BufReader&lt;/code&gt;&lt;/a&gt; to the rescue!</source>
          <target state="translated">Por ejemplo, &lt;a href=&quot;../fs/struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; implementa &lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; , pero no &lt;code&gt;BufRead&lt;/code&gt; . &lt;a href=&quot;struct.bufreader&quot;&gt; &lt;code&gt;BufReader&lt;/code&gt; &lt;/a&gt; al rescate!</target>
        </trans-unit>
        <trans-unit id="361121404b53f092e2a50ba865c6a4b2bee21aac" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;struct.bufreader&quot;&gt;&lt;code&gt;BufReader&lt;/code&gt;&lt;/a&gt; works with the &lt;a href=&quot;trait.bufread&quot;&gt;&lt;code&gt;BufRead&lt;/code&gt;&lt;/a&gt; trait to add extra methods to any reader:</source>
          <target state="translated">Por ejemplo, &lt;a href=&quot;struct.bufreader&quot;&gt; &lt;code&gt;BufReader&lt;/code&gt; &lt;/a&gt; trabaja con el rasgo &lt;a href=&quot;trait.bufread&quot;&gt; &lt;code&gt;BufRead&lt;/code&gt; &lt;/a&gt; para agregar m&amp;eacute;todos adicionales a cualquier lector:</target>
        </trans-unit>
        <trans-unit id="6b55b0abb99e67319bb61c01d86a93c08d513103" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;&amp;amp;mut 42&lt;/code&gt; is coerced to have type &lt;code&gt;&amp;amp;i8&lt;/code&gt; in the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67eaa2d704432ad951e8c12a7692afce83f73e05" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;/&lt;/code&gt; on Unix and  on Windows.</source>
          <target state="translated">Por ejemplo, &lt;code&gt;/&lt;/code&gt; en Unix y en Windows.</target>
        </trans-unit>
        <trans-unit id="5bb29cde4c0e0fc335df372cebebbd7ecb1d0966" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;/&lt;/code&gt; on Unix and &lt;code&gt;\&lt;/code&gt; on Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbee0db43e5b9a6c95b5e074429ae3b04c296c30" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;2 + (3 * 4)&lt;/code&gt; is an expression that returns the value 14.</source>
          <target state="translated">Por ejemplo, &lt;code&gt;2 + (3 * 4)&lt;/code&gt; es una expresi&amp;oacute;n que devuelve el valor 14.</target>
        </trans-unit>
        <trans-unit id="ca7ec8e9d4ad8d1018c384f60f3aa9bf305dff15" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;42&lt;/code&gt; is coerced to have type &lt;code&gt;i8&lt;/code&gt; in the following:</source>
          <target state="translated">Por ejemplo, &lt;code&gt;42&lt;/code&gt; est&amp;aacute; obligado a tener el tipo &lt;code&gt;i8&lt;/code&gt; en lo siguiente:</target>
        </trans-unit>
        <trans-unit id="5371c62b3b65397d993bded38544b14c041e769c" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;match&lt;/code&gt; is a keyword. If you try to compile the following function that uses &lt;code&gt;match&lt;/code&gt; as its name:</source>
          <target state="translated">Por ejemplo, la &lt;code&gt;match&lt;/code&gt; es una palabra clave. Si intenta compilar la siguiente funci&amp;oacute;n que usa &lt;code&gt;match&lt;/code&gt; como su nombre:</target>
        </trans-unit>
        <trans-unit id="5e5ca1f4b6c9ffec30148620048c12e2abed5a4e" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;x&lt;/code&gt; is coerced to have type &lt;code&gt;&amp;amp;dyn Display&lt;/code&gt; in the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fce0a6199428243d121ad738edca52d7c9b01aad" translate="yes" xml:space="preserve">
          <source>For example, Listing 17-10 shows what happens if we try to create a &lt;code&gt;Screen&lt;/code&gt; with a &lt;code&gt;String&lt;/code&gt; as a component:</source>
          <target state="translated">Por ejemplo, el Listado 17-10 muestra lo que sucede si intentamos crear una &lt;code&gt;Screen&lt;/code&gt; con una &lt;code&gt;String&lt;/code&gt; como componente:</target>
        </trans-unit>
        <trans-unit id="7ae1a94372a4d885d5d7e8da154bdfbd122ab503" translate="yes" xml:space="preserve">
          <source>For example, Listing 9-6 shows a function that reads a username from a file. If the file doesn&amp;rsquo;t exist or can&amp;rsquo;t be read, this function will return those errors to the code that called this function.</source>
          <target state="translated">Por ejemplo, el Listado 9-6 muestra una funci&amp;oacute;n que lee un nombre de usuario de un archivo. Si el archivo no existe o no se puede leer, esta funci&amp;oacute;n devolver&amp;aacute; esos errores al c&amp;oacute;digo que llam&amp;oacute; a esta funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ef753a93b41984ab0e06400f8bb2fb5a5a2abf4c" translate="yes" xml:space="preserve">
          <source>For example, a function like:</source>
          <target state="translated">Por ejemplo,una función como:</target>
        </trans-unit>
        <trans-unit id="3f4165e8867ad36b5f552b0f32d954c181e56a0b" translate="yes" xml:space="preserve">
          <source>For example, a function that reads a file into a string will error with &lt;code&gt;InvalidData&lt;/code&gt; if the file's contents are not valid UTF-8.</source>
          <target state="translated">Por ejemplo, una funci&amp;oacute;n que lee un archivo en una cadena generar&amp;aacute; un error con &lt;code&gt;InvalidData&lt;/code&gt; si el contenido del archivo no es UTF-8 v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="8e2494ae56a52ee6df403aa3b61355ff286423ad" translate="yes" xml:space="preserve">
          <source>For example, a logging library could use the standard formatting syntax, but it would internally pass around this structure until it has been determined where output should go to.</source>
          <target state="translated">Por ejemplo,una biblioteca de registro podría utilizar la sintaxis de formato estándar,pero pasaría internamente alrededor de esta estructura hasta que se haya determinado a dónde debe ir la salida.</target>
        </trans-unit>
        <trans-unit id="5e2c5e436747dc3d24355943f34ee57e52844d68" translate="yes" xml:space="preserve">
          <source>For example, a vector with capacity 10 and length 0 would be an empty vector with space for 10 more elements. Pushing 10 or fewer elements onto the vector will not change its capacity or cause reallocation to occur. However, if the vector's length is increased to 11, it will have to reallocate, which can be slow. For this reason, it is recommended to use &lt;a href=&quot;struct.vec#method.with_capacity&quot;&gt;&lt;code&gt;Vec::with_capacity&lt;/code&gt;&lt;/a&gt; whenever possible to specify how big the vector is expected to get.</source>
          <target state="translated">Por ejemplo, un vector con capacidad 10 y longitud 0 ser&amp;iacute;a un vector vac&amp;iacute;o con espacio para 10 elementos m&amp;aacute;s. Empujar 10 o menos elementos en el vector no cambiar&amp;aacute; su capacidad ni provocar&amp;aacute; la reasignaci&amp;oacute;n. Sin embargo, si la longitud del vector aumenta a 11, tendr&amp;aacute; que reasignarse, lo que puede ser lento. Por esta raz&amp;oacute;n, se recomienda usar &lt;a href=&quot;struct.vec#method.with_capacity&quot;&gt; &lt;code&gt;Vec::with_capacity&lt;/code&gt; &lt;/a&gt; siempre que sea posible para especificar qu&amp;eacute; tan grande se espera que sea el vector.</target>
        </trans-unit>
        <trans-unit id="15c054116144a3608c09f73dba885ef5e0021d4e" translate="yes" xml:space="preserve">
          <source>For example, both &lt;code&gt;'a'&lt;/code&gt; and &lt;code&gt;&quot;aa&quot;&lt;/code&gt; are patterns that would match at index &lt;code&gt;1&lt;/code&gt; in the string &lt;code&gt;&quot;baaaab&quot;&lt;/code&gt;.</source>
          <target state="translated">Por ejemplo, tanto &lt;code&gt;'a'&lt;/code&gt; como &lt;code&gt;&quot;aa&quot;&lt;/code&gt; son patrones que coincidir&amp;iacute;an en el &amp;iacute;ndice &lt;code&gt;1&lt;/code&gt; en la cadena &lt;code&gt;&quot;baaaab&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdda7fdae278a2fce4f5c887aa83a373c5a696fb" translate="yes" xml:space="preserve">
          <source>For example, calling &lt;code&gt;Pin::new_unchecked&lt;/code&gt; on an &lt;code&gt;&amp;amp;'a mut T&lt;/code&gt; is unsafe because while you are able to pin it for the given lifetime &lt;code&gt;'a&lt;/code&gt;, you have no control over whether it is kept pinned once &lt;code&gt;'a&lt;/code&gt; ends:</source>
          <target state="translated">Por ejemplo, llamar a &lt;code&gt;Pin::new_unchecked&lt;/code&gt; en un &lt;code&gt;&amp;amp;'a mut T&lt;/code&gt; no es seguro porque si bien puede fijarlo durante la vida &amp;uacute;til determinada &lt;code&gt;'a&lt;/code&gt; , no tiene control sobre si se mantiene fijo una vez que &lt;code&gt;'a&lt;/code&gt; finaliza:</target>
        </trans-unit>
        <trans-unit id="bfbfcca5281911965a5b0e44815f304c140950c7" translate="yes" xml:space="preserve">
          <source>For example, consider the case of a simple web server, which can be simplified to:</source>
          <target state="translated">Por ejemplo,consideremos el caso de un simple servidor web,que puede ser simplificado a:</target>
        </trans-unit>
        <trans-unit id="77381e13d866eca11479a03b8f4821b0157f9d3e" translate="yes" xml:space="preserve">
          <source>For example, dataflow uses this to inject static assertions so that &lt;code&gt;rustc_peek(potentially_uninitialized)&lt;/code&gt; would actually double-check that dataflow did indeed compute that it is uninitialized at that point in the control flow.</source>
          <target state="translated">Por ejemplo, el flujo de datos usa esto para inyectar afirmaciones est&amp;aacute;ticas para que &lt;code&gt;rustc_peek(potentially_uninitialized)&lt;/code&gt; realmente verifique dos veces que el flujo de datos realmente calcul&amp;oacute; que no est&amp;aacute; inicializado en ese punto del flujo de control.</target>
        </trans-unit>
        <trans-unit id="95fe2e68803fedf130f77f394bc5d434187ebbd8" translate="yes" xml:space="preserve">
          <source>For example, given a trait &lt;code&gt;Trait&lt;/code&gt;, the following are all trait objects:</source>
          <target state="translated">Por ejemplo, dado un rasgo &lt;code&gt;Trait&lt;/code&gt; , los siguientes son todos objetos de rasgo:</target>
        </trans-unit>
        <trans-unit id="072c7bf2984ac36fc73c1e383853c5c169bc7a47" translate="yes" xml:space="preserve">
          <source>For example, if for some reason we wanted to take the values produced by an instance of &lt;code&gt;Counter&lt;/code&gt;, pair them with values produced by another &lt;code&gt;Counter&lt;/code&gt; instance after skipping the first value, multiply each pair together, keep only those results that are divisible by 3, and add all the resulting values together, we could do so, as shown in the test in Listing 13-23:</source>
          <target state="translated">Por ejemplo, si por alguna raz&amp;oacute;n quisi&amp;eacute;ramos tomar los valores producidos por una instancia de &lt;code&gt;Counter&lt;/code&gt; , emparejarlos con los valores producidos por otra instancia de &lt;code&gt;Counter&lt;/code&gt; despu&amp;eacute;s de omitir el primer valor, multiplicar cada par, mantener solo los resultados que son divisibles por 3 y sumar todos los valores resultantes, podr&amp;iacute;amos hacerlo, como se muestra en la prueba del Listado 13-23:</target>
        </trans-unit>
        <trans-unit id="d1649808c8d99c391bdbb77f15f15e2efe15c030" translate="yes" xml:space="preserve">
          <source>For example, if we want to add documentation that describes the purpose of the &lt;code&gt;my_crate&lt;/code&gt; crate that contains the &lt;code&gt;add_one&lt;/code&gt; function, we can add documentation comments that start with &lt;code&gt;//!&lt;/code&gt; to the beginning of the &lt;em&gt;src/lib.rs&lt;/em&gt; file, as shown in Listing 14-2:</source>
          <target state="translated">Por ejemplo, si queremos agregar documentaci&amp;oacute;n que describa el prop&amp;oacute;sito de &lt;code&gt;my_crate&lt;/code&gt; crate que contiene la funci&amp;oacute;n &lt;code&gt;add_one&lt;/code&gt; , podemos agregar comentarios de documentaci&amp;oacute;n que comiencen con &lt;code&gt;//!&lt;/code&gt; al comienzo del archivo &lt;em&gt;src / lib.rs&lt;/em&gt; , como se muestra en el Listado 14-2:</target>
        </trans-unit>
        <trans-unit id="018dcc20bfe547cf343634d4cd949c5d217b88cd" translate="yes" xml:space="preserve">
          <source>For example, if you want to make sure that a specific field is dropped after the others, make it the last field of a struct:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed038364c42a5f7e182a80d72dbd7c44cb810818" translate="yes" xml:space="preserve">
          <source>For example, if you wanted to get a &lt;code&gt;Pin&lt;/code&gt; of a field of something, you could use this to get access to that field in one line of code. However, there are several gotchas with these &quot;pinning projections&quot;; see the &lt;a href=&quot;index#projections-and-structural-pinning&quot;&gt;&lt;code&gt;pin&lt;/code&gt; module&lt;/a&gt; documentation for further details on that topic.</source>
          <target state="translated">Por ejemplo, si desea obtener un &lt;code&gt;Pin&lt;/code&gt; de un campo de algo, puede usar esto para obtener acceso a ese campo en una l&amp;iacute;nea de c&amp;oacute;digo. Sin embargo, hay varias trampas con estas &quot;proyecciones de fijaci&amp;oacute;n&quot;; consulte la documentaci&amp;oacute;n del &lt;a href=&quot;index#projections-and-structural-pinning&quot;&gt;m&amp;oacute;dulo &lt;/a&gt; &lt;code&gt;pin&lt;/code&gt; para obtener m&amp;aacute;s detalles sobre ese tema.</target>
        </trans-unit>
        <trans-unit id="571bf6c61d49ae11d24afcb576448263d3d5f7ca" translate="yes" xml:space="preserve">
          <source>For example, in Chapter 12 we mentioned that there&amp;rsquo;s a Rust implementation of the &lt;code&gt;grep&lt;/code&gt; tool called &lt;code&gt;ripgrep&lt;/code&gt; for searching files. If we want to install &lt;code&gt;ripgrep&lt;/code&gt;, we can run the following:</source>
          <target state="translated">Por ejemplo, en el Cap&amp;iacute;tulo 12 mencionamos que hay una implementaci&amp;oacute;n de Rust de la herramienta &lt;code&gt;grep&lt;/code&gt; llamada &lt;code&gt;ripgrep&lt;/code&gt; para buscar archivos. Si queremos instalar &lt;code&gt;ripgrep&lt;/code&gt; , podemos ejecutar lo siguiente:</target>
        </trans-unit>
        <trans-unit id="7823fda3f1a738b0793d510efb6630e193e80753" translate="yes" xml:space="preserve">
          <source>For example, in Listing 10-13, we implemented the &lt;code&gt;Summary&lt;/code&gt; trait on the &lt;code&gt;NewsArticle&lt;/code&gt; and &lt;code&gt;Tweet&lt;/code&gt; types. We can define a &lt;code&gt;notify&lt;/code&gt; function that calls the &lt;code&gt;summarize&lt;/code&gt; method on its &lt;code&gt;item&lt;/code&gt; parameter, which is of some type that implements the &lt;code&gt;Summary&lt;/code&gt; trait. To do this, we can use the &lt;code&gt;impl Trait&lt;/code&gt; syntax, like this:</source>
          <target state="translated">Por ejemplo, en el Listado 10-13, implementamos el rasgo &lt;code&gt;Summary&lt;/code&gt; en los tipos &lt;code&gt;NewsArticle&lt;/code&gt; y &lt;code&gt;Tweet&lt;/code&gt; . Podemos definir una funci&amp;oacute;n de &lt;code&gt;notify&lt;/code&gt; que llame al m&amp;eacute;todo de &lt;code&gt;summarize&lt;/code&gt; en su par&amp;aacute;metro de &lt;code&gt;item&lt;/code&gt; , que es de alg&amp;uacute;n tipo que implementa el rasgo de &lt;code&gt;Summary&lt;/code&gt; . Para hacer esto, podemos usar la sintaxis &lt;code&gt;impl Trait&lt;/code&gt; , como esta:</target>
        </trans-unit>
        <trans-unit id="486ea7dfb7b30caa97edaa5c45c8d899d49328bd" translate="yes" xml:space="preserve">
          <source>For example, in the below example, since the enum is marked as &lt;code&gt;non_exhaustive&lt;/code&gt;, it is required that downstream crates match non-exhaustively on it.</source>
          <target state="translated">Por ejemplo, en el siguiente ejemplo, dado que la enumeraci&amp;oacute;n est&amp;aacute; marcada como &lt;code&gt;non_exhaustive&lt;/code&gt; , se requiere que las cajas posteriores coincidan de forma no exhaustiva.</target>
        </trans-unit>
        <trans-unit id="ef1242010b70221ef0947673271efa44f22329d9" translate="yes" xml:space="preserve">
          <source>For example, in the code in Listing 3-4, if you changed the definition of the &lt;code&gt;a&lt;/code&gt; array to have four elements but forgot to update the condition to &lt;code&gt;while index &amp;lt; 4&lt;/code&gt;, the code would panic. Using the &lt;code&gt;for&lt;/code&gt; loop, you wouldn&amp;rsquo;t need to remember to change any other code if you changed the number of values in the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ef6c4c588de41928f2df858cbeb2e205bc6fd49" translate="yes" xml:space="preserve">
          <source>For example, in the code in Listing 3-4, if you removed an item from the &lt;code&gt;a&lt;/code&gt; array but forgot to update the condition to &lt;code&gt;while index &amp;lt; 4&lt;/code&gt;, the code would panic. Using the &lt;code&gt;for&lt;/code&gt; loop, you wouldn&amp;rsquo;t need to remember to change any other code if you changed the number of values in the array.</source>
          <target state="translated">Por ejemplo, en el c&amp;oacute;digo del listado 3-4, si ha quitado un elemento de la &lt;code&gt;a&lt;/code&gt; matriz, pero se olvid&amp;oacute; de actualizar la condici&amp;oacute;n de que &lt;code&gt;while index &amp;lt; 4&lt;/code&gt; , el c&amp;oacute;digo de p&amp;aacute;nico. Al usar el ciclo &lt;code&gt;for&lt;/code&gt; , no necesitar&amp;iacute;a recordar cambiar ning&amp;uacute;n otro c&amp;oacute;digo si cambia el n&amp;uacute;mero de valores en la matriz.</target>
        </trans-unit>
        <trans-unit id="e1af9e58057bb08d42a00f959d4a9482b5211903" translate="yes" xml:space="preserve">
          <source>For example, in the following code:</source>
          <target state="translated">Por ejemplo,en el siguiente código:</target>
        </trans-unit>
        <trans-unit id="fa8a840ae5de7e7d26ee293da2703a78a823f744" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s change &lt;em&gt;src/main.rs&lt;/em&gt; to the following:</source>
          <target state="translated">Por ejemplo, cambiemos &lt;em&gt;src / main.rs&lt;/em&gt; a lo siguiente:</target>
        </trans-unit>
        <trans-unit id="bb34889b7e2a2e1630ad6fd19ca5c05805b4edf0" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say we have a function that greets people by name and we want to test that the name we pass into the function appears in the output:</source>
          <target state="translated">Por ejemplo, digamos que tenemos una funci&amp;oacute;n que saluda a las personas por su nombre y queremos probar que el nombre que pasamos a la funci&amp;oacute;n aparece en la salida:</target>
        </trans-unit>
        <trans-unit id="df2b03fc7d0094e8a94e4730123f2cb77700187c" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say we have multiple structs that hold various kinds and amounts of text: a &lt;code&gt;NewsArticle&lt;/code&gt; struct that holds a news story filed in a particular location and a &lt;code&gt;Tweet&lt;/code&gt; that can have at most 280 characters along with metadata that indicates whether it was a new tweet, a retweet, or a reply to another tweet.</source>
          <target state="translated">Por ejemplo, digamos que tenemos m&amp;uacute;ltiples estructuras que contienen varios tipos y cantidades de texto: una estructura &lt;code&gt;NewsArticle&lt;/code&gt; que contiene una noticia archivada en una ubicaci&amp;oacute;n particular y un &lt;code&gt;Tweet&lt;/code&gt; que puede tener como m&amp;aacute;ximo 280 caracteres junto con metadatos que indican si se trataba de un nuevo tweet, retweet o respuesta a otro tweet.</target>
        </trans-unit>
        <trans-unit id="5beb741830fde205d90a1dcb79133d20364520e1" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say we want to make an &lt;code&gt;OutlinePrint&lt;/code&gt; trait with an &lt;code&gt;outline_print&lt;/code&gt; method that will print a value framed in asterisks. That is, given a &lt;code&gt;Point&lt;/code&gt; struct that implements &lt;code&gt;Display&lt;/code&gt; to result in &lt;code&gt;(x, y)&lt;/code&gt;, when we call &lt;code&gt;outline_print&lt;/code&gt; on a &lt;code&gt;Point&lt;/code&gt; instance that has &lt;code&gt;1&lt;/code&gt; for &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; for &lt;code&gt;y&lt;/code&gt;, it should print the following:</source>
          <target state="translated">Por ejemplo, digamos que queremos crear un rasgo &lt;code&gt;OutlinePrint&lt;/code&gt; con un m&amp;eacute;todo &lt;code&gt;outline_print&lt;/code&gt; que imprimir&amp;aacute; un valor enmarcado en asteriscos. Es decir, dada una estructura &lt;code&gt;Point&lt;/code&gt; que implementa &lt;code&gt;Display&lt;/code&gt; para dar como resultado &lt;code&gt;(x, y)&lt;/code&gt; , cuando llamamos a &lt;code&gt;outline_print&lt;/code&gt; en una instancia de &lt;code&gt;Point&lt;/code&gt; que tiene &lt;code&gt;1&lt;/code&gt; para &lt;code&gt;x&lt;/code&gt; y &lt;code&gt;3&lt;/code&gt; para &lt;code&gt;y&lt;/code&gt; , deber&amp;iacute;a imprimir lo siguiente:</target>
        </trans-unit>
        <trans-unit id="67eefc842f1334a9710cea463d2936fc943cb35a" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s start from the code in Listing 7-17 and move the &lt;code&gt;front_of_house&lt;/code&gt; module to its own file &lt;em&gt;src/front_of_house.rs&lt;/em&gt; by changing the crate root file so it contains the code shown in Listing 7-21. In this case, the crate root file is &lt;em&gt;src/lib.rs&lt;/em&gt;, but this procedure also works with binary crates whose crate root file is &lt;em&gt;src/main.rs&lt;/em&gt;.</source>
          <target state="translated">Por ejemplo, comencemos con el c&amp;oacute;digo del Listado 7-17 y mueva el m&amp;oacute;dulo &lt;code&gt;front_of_house&lt;/code&gt; a su propio archivo &lt;em&gt;src / front_of_house.rs&lt;/em&gt; cambiando el archivo ra&amp;iacute;z de la caja para que contenga el c&amp;oacute;digo que se muestra en el Listado 7-21. En este caso, el archivo ra&amp;iacute;z caj&amp;oacute;n es &lt;em&gt;src / lib.rs&lt;/em&gt; , pero este procedimiento tambi&amp;eacute;n funciona con cajas binarios cuyo caj&amp;oacute;n de archivos ra&amp;iacute;z es &lt;em&gt;src / main.rs&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="79ba89b628a47ae9fac2bb7b0ff7554c4c375147" translate="yes" xml:space="preserve">
          <source>For example, reading line-by-line is inefficient without using a buffer, so if you want to read by line, you'll need &lt;code&gt;BufRead&lt;/code&gt;, which includes a &lt;a href=&quot;#method.read_line&quot;&gt;&lt;code&gt;read_line&lt;/code&gt;&lt;/a&gt; method as well as a &lt;a href=&quot;#method.lines&quot;&gt;&lt;code&gt;lines&lt;/code&gt;&lt;/a&gt; iterator.</source>
          <target state="translated">Por ejemplo, leer l&amp;iacute;nea por l&amp;iacute;nea es ineficiente sin usar un b&amp;uacute;fer, por lo que si desea leer por l&amp;iacute;nea, necesitar&amp;aacute; &lt;code&gt;BufRead&lt;/code&gt; , que incluye un m&amp;eacute;todo &lt;a href=&quot;#method.read_line&quot;&gt; &lt;code&gt;read_line&lt;/code&gt; &lt;/a&gt; as&amp;iacute; como un iterador de &lt;a href=&quot;#method.lines&quot;&gt; &lt;code&gt;lines&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7ee5d959d1301ac8a3ca0cb560c0412e0eaf4ece" translate="yes" xml:space="preserve">
          <source>For example, reading line-by-line is inefficient without using a buffer, so if you want to read by line, you'll need &lt;code&gt;BufRead&lt;/code&gt;, which includes a &lt;a href=&quot;trait.bufread#method.read_line&quot;&gt;&lt;code&gt;read_line&lt;/code&gt;&lt;/a&gt; method as well as a &lt;a href=&quot;trait.bufread#method.lines&quot;&gt;&lt;code&gt;lines&lt;/code&gt;&lt;/a&gt; iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d283913d102f25021490de7addfaf1023c5a559" translate="yes" xml:space="preserve">
          <source>For example, recall the cons list example in Listing 15-18 where we used &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; to allow multiple lists to share ownership of another list. Because &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; holds only immutable values, we can&amp;rsquo;t change any of the values in the list once we&amp;rsquo;ve created them. Let&amp;rsquo;s add in &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; to gain the ability to change the values in the lists. Listing 15-24 shows that by using a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; in the &lt;code&gt;Cons&lt;/code&gt; definition, we can modify the value stored in all the lists:</source>
          <target state="translated">Por ejemplo, recuerde el ejemplo de la lista de contras en el Listado 15-18 donde usamos &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; para permitir que m&amp;uacute;ltiples listas compartan la propiedad de otra lista. Debido a que &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; solo contiene valores inmutables, no podemos cambiar ninguno de los valores de la lista una vez que los hemos creado. Vamos a a&amp;ntilde;adir en &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; para obtener la capacidad de cambiar los valores en las listas. El Listado 15-24 muestra que al usar un &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; en la definici&amp;oacute;n de &lt;code&gt;Cons&lt;/code&gt; , podemos modificar el valor almacenado en todas las listas:</target>
        </trans-unit>
        <trans-unit id="55a0a06bf1a6582afc9c911dda23940db684b038" translate="yes" xml:space="preserve">
          <source>For example, say each of your tests runs some code that creates a file on disk named &lt;em&gt;test-output.txt&lt;/em&gt; and writes some data to that file. Then each test reads the data in that file and asserts that the file contains a particular value, which is different in each test. Because the tests run at the same time, one test might overwrite the file between when another test writes and reads the file. The second test will then fail, not because the code is incorrect but because the tests have interfered with each other while running in parallel. One solution is to make sure each test writes to a different file; another solution is to run the tests one at a time.</source>
          <target state="translated">Por ejemplo, supongamos que cada una de sus pruebas ejecuta alg&amp;uacute;n c&amp;oacute;digo que crea un archivo en el disco llamado &lt;em&gt;test-output.txt&lt;/em&gt; y escribe algunos datos en ese archivo. Luego, cada prueba lee los datos de ese archivo y afirma que el archivo contiene un valor particular, que es diferente en cada prueba. Debido a que las pruebas se ejecutan al mismo tiempo, una prueba puede sobrescribir el archivo cuando otra prueba escribe y lee el archivo. La segunda prueba fallar&amp;aacute;, no porque el c&amp;oacute;digo sea incorrecto, sino porque las pruebas han interferido entre s&amp;iacute; mientras se ejecutan en paralelo. Una soluci&amp;oacute;n es asegurarse de que cada prueba escriba en un archivo diferente; otra soluci&amp;oacute;n es ejecutar las pruebas una por una.</target>
        </trans-unit>
        <trans-unit id="4814345fbf007312eaa1283d22f4721e9e65da7f" translate="yes" xml:space="preserve">
          <source>For example, say we had two functions: one that finds the largest item in a slice of &lt;code&gt;i32&lt;/code&gt; values and one that finds the largest item in a slice of &lt;code&gt;char&lt;/code&gt; values. How would we eliminate that duplication? Let&amp;rsquo;s find out!</source>
          <target state="translated">Por ejemplo, digamos que ten&amp;iacute;amos dos funciones: una que encuentra el elemento m&amp;aacute;s grande en un segmento de valores &lt;code&gt;i32&lt;/code&gt; y otra que encuentra el elemento m&amp;aacute;s grande en un segmento de valores &lt;code&gt;char&lt;/code&gt; . &amp;iquest;C&amp;oacute;mo eliminar&amp;iacute;amos esa duplicaci&amp;oacute;n? &amp;iexcl;Vamos a averiguar!</target>
        </trans-unit>
        <trans-unit id="4cba319e8cf72cafc05de924ba069b585b2c709d" translate="yes" xml:space="preserve">
          <source>For example, say we made a library named &lt;code&gt;art&lt;/code&gt; for modeling artistic concepts. Within this library are two modules: a &lt;code&gt;kinds&lt;/code&gt; module containing two enums named &lt;code&gt;PrimaryColor&lt;/code&gt; and &lt;code&gt;SecondaryColor&lt;/code&gt; and a &lt;code&gt;utils&lt;/code&gt; module containing a function named &lt;code&gt;mix&lt;/code&gt;, as shown in Listing 14-3:</source>
          <target state="translated">Por ejemplo, digamos que hicimos una biblioteca llamada &lt;code&gt;art&lt;/code&gt; e para modelar conceptos art&amp;iacute;sticos. Dentro de esta biblioteca hay dos m&amp;oacute;dulos: un m&amp;oacute;dulo de &lt;code&gt;kinds&lt;/code&gt; que contiene dos enumeraciones llamadas &lt;code&gt;PrimaryColor&lt;/code&gt; y &lt;code&gt;SecondaryColor&lt;/code&gt; y un m&amp;oacute;dulo de &lt;code&gt;utils&lt;/code&gt; que contiene una funci&amp;oacute;n llamada &lt;code&gt;mix&lt;/code&gt; , como se muestra en el Listado 14-3:</target>
        </trans-unit>
        <trans-unit id="6034956f55199745f53b082e0813b66b3ccd59d0" translate="yes" xml:space="preserve">
          <source>For example, say we want to get values from a row in a spreadsheet in which some of the columns in the row contain integers, some floating-point numbers, and some strings. We can define an enum whose variants will hold the different value types, and then all the enum variants will be considered the same type: that of the enum. Then we can create a vector that holds that enum and so, ultimately, holds different types. We&amp;rsquo;ve demonstrated this in Listing 8-10.</source>
          <target state="translated">Por ejemplo, digamos que queremos obtener valores de una fila en una hoja de c&amp;aacute;lculo en la que algunas de las columnas de la fila contienen n&amp;uacute;meros enteros, algunos n&amp;uacute;meros de punto flotante y algunas cadenas. Podemos definir una enumeraci&amp;oacute;n cuyas variantes contendr&amp;aacute;n los diferentes tipos de valor, y luego todas las variantes de la enumeraci&amp;oacute;n se considerar&amp;aacute;n del mismo tipo: la de la enumeraci&amp;oacute;n. Luego, podemos crear un vector que contenga esa enumeraci&amp;oacute;n y, en &amp;uacute;ltima instancia, contenga diferentes tipos. Hemos demostrado esto en el Listado 8-10.</target>
        </trans-unit>
        <trans-unit id="fa13929a3b270eef2878bd884ac068ec70c4ce69" translate="yes" xml:space="preserve">
          <source>For example, say you write a program that uses an approximation of a mathematical constant, such as pi, as this program does:</source>
          <target state="translated">Por ejemplo,digamos que escribes un programa que usa una aproximación de una constante matemática,como pi,como lo hace este programa:</target>
        </trans-unit>
        <trans-unit id="6a1d451b5816383f70b638071c7a253213366d2b" translate="yes" xml:space="preserve">
          <source>For example, the &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&lt;/code&gt;&lt;/a&gt; trait (conversion that returns a &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;) has a blanket implementation for all types where a reverse &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; implementation exists.</source>
          <target state="translated">Por ejemplo, el &lt;a href=&quot;trait.tryfrom&quot;&gt; &lt;code&gt;TryFrom&lt;/code&gt; &lt;/a&gt; rasgo (conversi&amp;oacute;n que devuelve una &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; ) tiene una aplicaci&amp;oacute;n general para todos los tipos en un rev&amp;eacute;s &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; exista aplicaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="151702debd099e963ea8f32f250d147e3f891b7b" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;Foo&lt;/code&gt; struct below has no type parameters, but is supplied with two in the definition of &lt;code&gt;Bar&lt;/code&gt;:</source>
          <target state="translated">Por ejemplo, la estructura &lt;code&gt;Foo&lt;/code&gt; a continuaci&amp;oacute;n no tiene par&amp;aacute;metros de tipo, pero se suministra con dos en la definici&amp;oacute;n de &lt;code&gt;Bar&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="55ee334160f14fc8439e8031cfca7e75b754c140" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;Foo&lt;/code&gt; struct below is defined to be generic in &lt;code&gt;T&lt;/code&gt;, but the type parameter is missing in the definition of &lt;code&gt;Bar&lt;/code&gt;:</source>
          <target state="translated">Por ejemplo, la estructura &lt;code&gt;Foo&lt;/code&gt; a continuaci&amp;oacute;n se define como gen&amp;eacute;rica en &lt;code&gt;T&lt;/code&gt; , pero el par&amp;aacute;metro de tipo falta en la definici&amp;oacute;n de &lt;code&gt;Bar&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c5ce73524ef8f36dbf496c73993c1de5644cb594" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;Foo&lt;/code&gt; trait has a method &lt;code&gt;foo&lt;/code&gt; with a type parameter &lt;code&gt;T&lt;/code&gt;, but the implementation of &lt;code&gt;foo&lt;/code&gt; for the type &lt;code&gt;Bar&lt;/code&gt; is missing this parameter. To fix this error, they must have the same type parameters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f472151ef9c4c8e584f48b10f04fca2193dee33" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;Foo&lt;/code&gt; trait has a method &lt;code&gt;foo&lt;/code&gt; with two function parameters (&lt;code&gt;&amp;amp;self&lt;/code&gt; and &lt;code&gt;u8&lt;/code&gt;), but the implementation of &lt;code&gt;foo&lt;/code&gt; for the type &lt;code&gt;Bar&lt;/code&gt; omits the &lt;code&gt;u8&lt;/code&gt; parameter. To fix this error, they must have the same parameters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28582c1af9d66b47d8b372c20e239e80fd1b954e" translate="yes" xml:space="preserve">
          <source>For example, the code above can be fixed to:</source>
          <target state="translated">Por ejemplo,el código anterior se puede fijar en:</target>
        </trans-unit>
        <trans-unit id="d4ec33ffd8a400e8731c3959c2108ca0e6ee81ff" translate="yes" xml:space="preserve">
          <source>For example, the following &lt;a href=&quot;../macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt; expressions all use named argument:</source>
          <target state="translated">Por ejemplo, &amp;iexcl;el siguiente &lt;a href=&quot;../macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt;todas las expresiones usan argumentos con nombre:</target>
        </trans-unit>
        <trans-unit id="00c40dd32be2ecfc7a31834a5b9e57d6d91eabce" translate="yes" xml:space="preserve">
          <source>For example, the following &lt;code&gt;match&lt;/code&gt; block has too many arms:</source>
          <target state="translated">Por ejemplo, el siguiente bloque de &lt;code&gt;match&lt;/code&gt; tiene demasiados brazos:</target>
        </trans-unit>
        <trans-unit id="ccff2a62302aec83d3032aa28ffe87629cd5d301" translate="yes" xml:space="preserve">
          <source>For example, the following calls all print the same thing &lt;code&gt;Hello x is 0.01000&lt;/code&gt;:</source>
          <target state="translated">Por ejemplo, las siguientes llamadas imprimen lo mismo &lt;code&gt;Hello x is 0.01000&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f8410f740d252ba94b087c65dca435d74ad4c130" translate="yes" xml:space="preserve">
          <source>For example, the following code defines an inert &lt;code&gt;some_inert_attribute&lt;/code&gt; attribute that is not formally defined anywhere and the &lt;code&gt;some_proc_macro_attribute&lt;/code&gt; procedural macro is responsible for detecting its presence and removing it from the output token stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aea53cb95724623abd128d3eeb0328ecf14aacb1" translate="yes" xml:space="preserve">
          <source>For example, the following code will always print &lt;code&gt;1.5&lt;/code&gt; even if the system locale uses a decimal separator other than a dot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="885017323eb28c594e76743a2b0d28eacb31ef45" translate="yes" xml:space="preserve">
          <source>For example, the following defines the type &lt;code&gt;Point&lt;/code&gt; as a synonym for the type &lt;code&gt;(u8, u8)&lt;/code&gt;, the type of pairs of unsigned 8 bit integers:</source>
          <target state="translated">Por ejemplo, lo siguiente define el tipo &lt;code&gt;Point&lt;/code&gt; como sin&amp;oacute;nimo del tipo &lt;code&gt;(u8, u8)&lt;/code&gt; , el tipo de pares de enteros de 8 bits sin signo:</target>
        </trans-unit>
        <trans-unit id="7cf92604c65fd608b9bab83d5d85641029aff675" translate="yes" xml:space="preserve">
          <source>For example, the following derive macro defines a helper attribute &lt;code&gt;helper&lt;/code&gt;, but ultimately doesn't do anything with it.</source>
          <target state="translated">Por ejemplo, la siguiente macro de derivaci&amp;oacute;n define un ayudante de atributo &lt;code&gt;helper&lt;/code&gt; , pero en &amp;uacute;ltima instancia no hace nada con &amp;eacute;l.</target>
        </trans-unit>
        <trans-unit id="b4bc188ed3ec55a280f2bbbfb77e3725b58a7535" translate="yes" xml:space="preserve">
          <source>For example, the following macro definition ignores its input and outputs a function &lt;code&gt;answer&lt;/code&gt; into its scope.</source>
          <target state="translated">Por ejemplo, la siguiente definici&amp;oacute;n de macro ignora su entrada y genera una &lt;code&gt;answer&lt;/code&gt; funci&amp;oacute;n en su alcance.</target>
        </trans-unit>
        <trans-unit id="57464fd8804b2cf7021000e159e4c26bf42d7d2e" translate="yes" xml:space="preserve">
          <source>For example, the following will create an &lt;a href=&quot;../items/implementations&quot;&gt;&lt;code&gt;impl&lt;/code&gt; item&lt;/a&gt; for the &lt;a href=&quot;../../std/cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../std/clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; traits for &lt;code&gt;Foo&lt;/code&gt;, and the type parameter &lt;code&gt;T&lt;/code&gt; will be given the &lt;code&gt;PartialEq&lt;/code&gt; or &lt;code&gt;Clone&lt;/code&gt; constraints for the appropriate &lt;code&gt;impl&lt;/code&gt;:</source>
          <target state="translated">Por ejemplo, el siguiente crear&amp;aacute; un &lt;a href=&quot;../items/implementations&quot;&gt; &lt;code&gt;impl&lt;/code&gt; art&amp;iacute;culo&lt;/a&gt; para los &lt;a href=&quot;../../std/cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../../std/clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; rasgos para &lt;code&gt;Foo&lt;/code&gt; , y el tipo de par&amp;aacute;metro &lt;code&gt;T&lt;/code&gt; se les dar&amp;aacute; la &lt;code&gt;PartialEq&lt;/code&gt; o &lt;code&gt;Clone&lt;/code&gt; restricciones para el apropiado &lt;code&gt;impl&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="54f0cc8d17f1c6f2f1e67596b770e99d8f237e11" translate="yes" xml:space="preserve">
          <source>For example, the function above behaves as if it was written as:</source>
          <target state="translated">Por ejemplo,la función anterior se comporta como si estuviera escrita como:</target>
        </trans-unit>
        <trans-unit id="6c27c96db626276f442777ef3f3477feae99f3a5" translate="yes" xml:space="preserve">
          <source>For example, the sized array type &lt;code&gt;[i8; 2]&lt;/code&gt; implements &lt;code&gt;Unsize&amp;lt;[i8]&amp;gt;&lt;/code&gt; and &lt;code&gt;Unsize&amp;lt;dyn fmt::Debug&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="366340c67c059c204db621f7eae2415b246044b0" translate="yes" xml:space="preserve">
          <source>For example, the sized array type &lt;code&gt;[i8; 2]&lt;/code&gt; implements &lt;code&gt;Unsize&amp;lt;[i8]&amp;gt;&lt;/code&gt; and &lt;code&gt;Unsize&amp;lt;fmt::Debug&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Por ejemplo, el tipo de matriz de tama&amp;ntilde;o &lt;code&gt;[i8; 2]&lt;/code&gt; implementa &lt;code&gt;Unsize&amp;lt;[i8]&amp;gt;&lt;/code&gt; y &lt;code&gt;Unsize&amp;lt;fmt::Debug&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9fd0eff00179b77af92d43c41f240143cf69cdfa" translate="yes" xml:space="preserve">
          <source>For example, the trait below has a method &lt;code&gt;foo&lt;/code&gt; with a type parameter &lt;code&gt;T&lt;/code&gt;, but the implementation of &lt;code&gt;foo&lt;/code&gt; for the type &lt;code&gt;Bar&lt;/code&gt; is missing this parameter:</source>
          <target state="translated">Por ejemplo, el rasgo siguiente tiene un m&amp;eacute;todo &lt;code&gt;foo&lt;/code&gt; con un par&amp;aacute;metro de tipo &lt;code&gt;T&lt;/code&gt; , pero a la implementaci&amp;oacute;n de &lt;code&gt;foo&lt;/code&gt; para el tipo &lt;code&gt;Bar&lt;/code&gt; le falta este par&amp;aacute;metro:</target>
        </trans-unit>
        <trans-unit id="8b644523186dc68fa33f4525c4f5b85593ff99b3" translate="yes" xml:space="preserve">
          <source>For example, the trait below has a method &lt;code&gt;foo&lt;/code&gt; with two function parameters (&lt;code&gt;&amp;amp;self&lt;/code&gt; and &lt;code&gt;u8&lt;/code&gt;), but the implementation of &lt;code&gt;foo&lt;/code&gt; for the type &lt;code&gt;Bar&lt;/code&gt; omits the &lt;code&gt;u8&lt;/code&gt; parameter:</source>
          <target state="translated">Por ejemplo, el rasgo siguiente tiene un m&amp;eacute;todo &lt;code&gt;foo&lt;/code&gt; con dos par&amp;aacute;metros de funci&amp;oacute;n ( &lt;code&gt;&amp;amp;self&lt;/code&gt; y &lt;code&gt;u8&lt;/code&gt; ), pero la implementaci&amp;oacute;n de &lt;code&gt;foo&lt;/code&gt; para el tipo &lt;code&gt;Bar&lt;/code&gt; omite el par&amp;aacute;metro &lt;code&gt;u8&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b2054ac7104ff8f94e8f0fe677bda5de864b59e2" translate="yes" xml:space="preserve">
          <source>For example, these two matches on &lt;code&gt;x: &amp;amp;i32&lt;/code&gt; are equivalent:</source>
          <target state="translated">Por ejemplo, estas dos coincidencias en &lt;code&gt;x: &amp;amp;i32&lt;/code&gt; son equivalentes:</target>
        </trans-unit>
        <trans-unit id="0f0ebafee793ef772176055bfbe1e63d094aa7f0" translate="yes" xml:space="preserve">
          <source>For example, this attribute macro takes the input stream and returns it as is, effectively being the no-op of attributes.</source>
          <target state="translated">Por ejemplo,esta macro de atributos toma el flujo de entrada y lo devuelve tal cual,siendo efectivamente el no-op de atributos.</target>
        </trans-unit>
        <trans-unit id="3b2d902f733498146c7d79ff0d4666385f011551" translate="yes" xml:space="preserve">
          <source>For example, this can happen when a drop has taken place:</source>
          <target state="translated">Por ejemplo,esto puede suceder cuando se ha producido una caída:</target>
        </trans-unit>
        <trans-unit id="d7dedeceba4a8900e43a594ae72dc887e0a2e3eb" translate="yes" xml:space="preserve">
          <source>For example, this can happen when storing a &lt;code&gt;&amp;amp;mut&lt;/code&gt; inside an immutable &lt;code&gt;Box&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5807b7a347e69661509cba501c2fe0d4b703ef04" translate="yes" xml:space="preserve">
          <source>For example, this function returns &lt;code&gt;true&lt;/code&gt; on unix platforms and &lt;code&gt;false&lt;/code&gt; on other platforms.</source>
          <target state="translated">Por ejemplo, esta funci&amp;oacute;n devuelve &lt;code&gt;true&lt;/code&gt; en plataformas Unix y &lt;code&gt;false&lt;/code&gt; en otras plataformas.</target>
        </trans-unit>
        <trans-unit id="bfe3e762f0308c232acfe535a85b5bf692d7a562" translate="yes" xml:space="preserve">
          <source>For example, this is a simple function:</source>
          <target state="translated">Por ejemplo,esta es una función simple:</target>
        </trans-unit>
        <trans-unit id="574f015c9f879de83a47af30c961f0cb2ef98124" translate="yes" xml:space="preserve">
          <source>For example, we can refactor the code in Listing 18-15 to support RGB and HSV colors in the &lt;code&gt;ChangeColor&lt;/code&gt; message, as shown in Listing 18-16.</source>
          <target state="translated">Por ejemplo, podemos refactorizar el c&amp;oacute;digo del Listado 18-15 para que admita colores RGB y HSV en el mensaje &lt;code&gt;ChangeColor&lt;/code&gt; , como se muestra en el Listado 18-16.</target>
        </trans-unit>
        <trans-unit id="f82030bd7f1111a5c705663c05195d4bd4d79595" translate="yes" xml:space="preserve">
          <source>For example, while &lt;a href=&quot;../f64/index&quot;&gt;&lt;code&gt;f64&lt;/code&gt;&lt;/a&gt; doesn't implement &lt;a href=&quot;../cmp/trait.ord&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt; because &lt;code&gt;NaN != NaN&lt;/code&gt;, we can use &lt;code&gt;partial_cmp&lt;/code&gt; as our sort function when we know the slice doesn't contain a &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">Por ejemplo, mientras que &lt;a href=&quot;../f64/index&quot;&gt; &lt;code&gt;f64&lt;/code&gt; &lt;/a&gt; no implementa &lt;a href=&quot;../cmp/trait.ord&quot;&gt; &lt;code&gt;Ord&lt;/code&gt; &lt;/a&gt; porque &lt;code&gt;NaN != NaN&lt;/code&gt; , podemos usar &lt;code&gt;partial_cmp&lt;/code&gt; como nuestra funci&amp;oacute;n de clasificaci&amp;oacute;n cuando sabemos que el segmento no contiene un &lt;code&gt;NaN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6422942d92b193786388ab0bda397e05164540c1" translate="yes" xml:space="preserve">
          <source>For example, while &lt;a href=&quot;../primitive.f64&quot;&gt;&lt;code&gt;f64&lt;/code&gt;&lt;/a&gt; doesn't implement &lt;a href=&quot;../cmp/trait.ord&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt; because &lt;code&gt;NaN != NaN&lt;/code&gt;, we can use &lt;code&gt;partial_cmp&lt;/code&gt; as our sort function when we know the slice doesn't contain a &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b764d8204b44c3e5e2540dd303c676cd8f62e40" translate="yes" xml:space="preserve">
          <source>For example, while &lt;a href=&quot;f64/index&quot;&gt;&lt;code&gt;f64&lt;/code&gt;&lt;/a&gt; doesn't implement &lt;a href=&quot;cmp/trait.ord&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt; because &lt;code&gt;NaN != NaN&lt;/code&gt;, we can use &lt;code&gt;partial_cmp&lt;/code&gt; as our sort function when we know the slice doesn't contain a &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">Por ejemplo, mientras que &lt;a href=&quot;f64/index&quot;&gt; &lt;code&gt;f64&lt;/code&gt; &lt;/a&gt; no implementa &lt;a href=&quot;cmp/trait.ord&quot;&gt; &lt;code&gt;Ord&lt;/code&gt; &lt;/a&gt; porque &lt;code&gt;NaN != NaN&lt;/code&gt; , podemos usar &lt;code&gt;partial_cmp&lt;/code&gt; como nuestra funci&amp;oacute;n de clasificaci&amp;oacute;n cuando sabemos que el segmento no contiene un &lt;code&gt;NaN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e424d677e36813abb83127c7379735d7c5273964" translate="yes" xml:space="preserve">
          <source>For example, while &lt;a href=&quot;primitive.f64&quot;&gt;&lt;code&gt;f64&lt;/code&gt;&lt;/a&gt; doesn't implement &lt;a href=&quot;cmp/trait.ord&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt; because &lt;code&gt;NaN != NaN&lt;/code&gt;, we can use &lt;code&gt;partial_cmp&lt;/code&gt; as our sort function when we know the slice doesn't contain a &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8dc8734abe186200131ed8ac632d434e048366c" translate="yes" xml:space="preserve">
          <source>For example, with a &lt;code&gt;repr(C, u8)&lt;/code&gt; enum it is not possible to have 257 unique discriminants (&quot;tags&quot;) whereas the same enum with only a &lt;code&gt;repr(C)&lt;/code&gt; attribute will compile without any problems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c94d1535c10da4f2821748f9ce38729f26e00dbe" translate="yes" xml:space="preserve">
          <source>For example, with:</source>
          <target state="translated">Por ejemplo,con:</target>
        </trans-unit>
        <trans-unit id="17eeedca2613fada694d9a21076a8833ab19837f" translate="yes" xml:space="preserve">
          <source>For example, you could implement &lt;code&gt;Drop&lt;/code&gt; as follows:</source>
          <target state="translated">Por ejemplo, puede implementar &lt;code&gt;Drop&lt;/code&gt; de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="0e89540393294fb9755a8c7be8446018477b85f9" translate="yes" xml:space="preserve">
          <source>For example, you may have done something like:</source>
          <target state="translated">Por ejemplo,puede que hayas hecho algo como:</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="e2ec009e5911b36cd0b755b32a4d4072a53597da" translate="yes" xml:space="preserve">
          <source>For example: By creating a generic function that takes an &lt;code&gt;AsRef&amp;lt;str&amp;gt;&lt;/code&gt; we express that we want to accept all references that can be converted to &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; as an argument. Since both &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; implement &lt;code&gt;AsRef&amp;lt;str&amp;gt;&lt;/code&gt; we can accept both as input argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c67a863b99ff7d27d3808154564c3bc4114136bc" translate="yes" xml:space="preserve">
          <source>For example: By creating a generic function that takes an &lt;code&gt;AsRef&amp;lt;str&amp;gt;&lt;/code&gt; we express that we want to accept all references that can be converted to &lt;code&gt;&amp;amp;str&lt;/code&gt; as an argument. Since both &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;&amp;amp;str&lt;/code&gt; implement &lt;code&gt;AsRef&amp;lt;str&amp;gt;&lt;/code&gt; we can accept both as input argument.</source>
          <target state="translated">Por ejemplo: al crear una funci&amp;oacute;n gen&amp;eacute;rica que toma un &lt;code&gt;AsRef&amp;lt;str&amp;gt;&lt;/code&gt; , expresamos que queremos aceptar todas las referencias que se pueden convertir en &lt;code&gt;&amp;amp;str&lt;/code&gt; como argumento. Dado que tanto &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; como &lt;code&gt;&amp;amp;str&lt;/code&gt; implementan &lt;code&gt;AsRef&amp;lt;str&amp;gt;&lt;/code&gt; , podemos aceptar ambos como argumento de entrada.</target>
        </trans-unit>
        <trans-unit id="7b85128b7000b81f6830c4ca37b9c6350ef69882" translate="yes" xml:space="preserve">
          <source>For example: By creating a generic function that takes an &lt;code&gt;AsRef&amp;lt;str&amp;gt;&lt;/code&gt; we express that we want to accept all references that can be converted to [&lt;code&gt;&amp;amp;str&lt;/code&gt;] as an argument. Since both &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and [&lt;code&gt;&amp;amp;str&lt;/code&gt;] implement &lt;code&gt;AsRef&amp;lt;str&amp;gt;&lt;/code&gt; we can accept both as input argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c242c0b4118acc9ccca5d9ffb3d5007ec8e99339" translate="yes" xml:space="preserve">
          <source>For expensive key functions (e.g. functions that are not simple property accesses or basic operations), &lt;a href=&quot;#method.sort_by_cached_key&quot;&gt;&lt;code&gt;sort_by_cached_key&lt;/code&gt;&lt;/a&gt; is likely to be significantly faster, as it does not recompute element keys.</source>
          <target state="translated">Para funciones de teclas costosas (por ejemplo, funciones que no son simples accesos a propiedades u operaciones b&amp;aacute;sicas), es probable que &lt;a href=&quot;#method.sort_by_cached_key&quot;&gt; &lt;code&gt;sort_by_cached_key&lt;/code&gt; &lt;/a&gt; sea ​​significativamente m&amp;aacute;s r&amp;aacute;pido, ya que no recalcula las claves de los elementos.</target>
        </trans-unit>
        <trans-unit id="fac202d9a81aa406cb4f2aa07e7d19ccd78a9e21" translate="yes" xml:space="preserve">
          <source>For floating-point types, this indicates how many digits after the decimal point should be printed.</source>
          <target state="translated">Para los tipos de punto flotante,esto indica cuántos dígitos después del punto decimal deben imprimirse.</target>
        </trans-unit>
        <trans-unit id="60a97f7f70b38aec22b5767907484329e4b88190" translate="yes" xml:space="preserve">
          <source>For generic types (counting the built-in types above as generic over &lt;code&gt;T&lt;/code&gt;), if a generic implementation is available, then the compiler does not automatically implement it for types that could use the implementation except that they do not meet the requisite trait bounds. For instance, the standard library implements &lt;code&gt;Send&lt;/code&gt; for all &lt;code&gt;&amp;amp;T&lt;/code&gt; where &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt;; this means that the compiler will not implement &lt;code&gt;Send&lt;/code&gt; for &lt;code&gt;&amp;amp;T&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Send&lt;/code&gt; but not &lt;code&gt;Sync&lt;/code&gt;.</source>
          <target state="translated">Para los tipos gen&amp;eacute;ricos (contando los tipos incorporados arriba como gen&amp;eacute;ricos sobre &lt;code&gt;T&lt;/code&gt; ), si una implementaci&amp;oacute;n gen&amp;eacute;rica est&amp;aacute; disponible, entonces el compilador no la implementa autom&amp;aacute;ticamente para los tipos que podr&amp;iacute;an usar la implementaci&amp;oacute;n excepto que no cumplen con los l&amp;iacute;mites de rasgos requeridos. Por ejemplo, la biblioteca est&amp;aacute;ndar implementa &lt;code&gt;Send&lt;/code&gt; for all &lt;code&gt;&amp;amp;T&lt;/code&gt; donde &lt;code&gt;T&lt;/code&gt; es &lt;code&gt;Sync&lt;/code&gt; ; esto significa que el compilador no implementar&amp;aacute; &lt;code&gt;Send&lt;/code&gt; for &lt;code&gt;&amp;amp;T&lt;/code&gt; si &lt;code&gt;T&lt;/code&gt; es &lt;code&gt;Send&lt;/code&gt; pero no &lt;code&gt;Sync&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9bb6b1fc5ac516815924015fa9742f7f462b2df" translate="yes" xml:space="preserve">
          <source>For historical reasons and convenience, the tuple type with no elements (&lt;code&gt;()&lt;/code&gt;) is often called &amp;lsquo;unit&amp;rsquo; or &amp;lsquo;the unit type&amp;rsquo;.</source>
          <target state="translated">Por razones hist&amp;oacute;ricas y por conveniencia, el tipo de tupla sin elementos ( &lt;code&gt;()&lt;/code&gt; ) a menudo se denomina &quot;unidad&quot; o &quot;tipo de unidad&quot;.</target>
        </trans-unit>
        <trans-unit id="0cae8f11b3fc955cca56e9644b85da41554bc0c8" translate="yes" xml:space="preserve">
          <source>For historical reasons, the Windows API uses a form of potentially ill-formed UTF-16 encoding for strings. Specifically, the 16-bit code units in Windows strings may contain &lt;a href=&quot;https://simonsapin.github.io/wtf-8/#ill-formed-utf-16&quot;&gt;isolated surrogate code points which are not paired together&lt;/a&gt;. The Unicode standard requires that surrogate code points (those in the range U+D800 to U+DFFF) always be &lt;em&gt;paired&lt;/em&gt;, because in the UTF-16 encoding a &lt;em&gt;surrogate code unit pair&lt;/em&gt; is used to encode a single character. For compatibility with code that does not enforce these pairings, Windows does not enforce them, either.</source>
          <target state="translated">Por razones hist&amp;oacute;ricas, la API de Windows utiliza una forma de codificaci&amp;oacute;n UTF-16 potencialmente mal formada para cadenas. Espec&amp;iacute;ficamente, las unidades de c&amp;oacute;digo de 16 bits en las cadenas de Windows pueden contener &lt;a href=&quot;https://simonsapin.github.io/wtf-8/#ill-formed-utf-16&quot;&gt;puntos de c&amp;oacute;digo sustitutos aislados que no est&amp;aacute;n emparejados&lt;/a&gt; . El est&amp;aacute;ndar Unicode requiere que los puntos de c&amp;oacute;digo sustitutos (aquellos en el rango U + D800 a U + DFFF) siempre est&amp;eacute;n &lt;em&gt;emparejados&lt;/em&gt; , porque en la codificaci&amp;oacute;n UTF-16 se usa un &lt;em&gt;par de unidades de c&amp;oacute;digo sustituto&lt;/em&gt; para codificar un solo car&amp;aacute;cter. Por compatibilidad con el c&amp;oacute;digo que no hace cumplir estos emparejamientos, Windows tampoco los hace cumplir.</target>
        </trans-unit>
        <trans-unit id="8916c85db1ffc957e4227acdfffd5e1133284b2f" translate="yes" xml:space="preserve">
          <source>For historical reasons, the scoping of macros by example does not work entirely like items. Macros have two forms of scope: textual scope, and path-based scope. Textual scope is based on the order that things appear in source files, or even across multiple files, and is the default scoping. It is explained further below. Path-based scope works exactly the same way that item scoping does. The scoping, exporting, and importing of macros is controlled largely by attributes.</source>
          <target state="translated">Por razones históricas,el alcance de las macros por ejemplo no funciona del todo como los objetos.Las macros tienen dos formas de alcance:alcance textual y alcance basado en la ruta.El alcance textual se basa en el orden en que aparecen las cosas en los archivos de origen,o incluso a través de varios archivos,y es el alcance predeterminado.Se explica más adelante.El alcance basado en rutas funciona exactamente de la misma manera que el alcance de los objetos.El alcance,la exportación y la importación de macros se controla en gran medida por medio de atributos.</target>
        </trans-unit>
        <trans-unit id="710b4db2d0c9327d5cbb0b2974185ecea3b00d3d" translate="yes" xml:space="preserve">
          <source>For information about possible values, see &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/winnt/ne-winnt-security_impersonation_level&quot;&gt;Impersonation Levels&lt;/a&gt; on the Windows Dev Center site. The &lt;code&gt;SECURITY_SQOS_PRESENT&lt;/code&gt; flag is set automatically when using this method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a1e7857364d8e31bcd2215cbf664f2f9ca1f5e2" translate="yes" xml:space="preserve">
          <source>For information about possible values, see &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa379572.aspx&quot;&gt;Impersonation Levels&lt;/a&gt; on the Windows Dev Center site. The &lt;code&gt;SECURITY_SQOS_PRESENT&lt;/code&gt; flag is set automatically when using this method.</source>
          <target state="translated">Para obtener informaci&amp;oacute;n sobre posibles valores, consulte &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa379572.aspx&quot;&gt;Niveles de suplantaci&amp;oacute;n&lt;/a&gt; en el sitio del Centro de desarrollo de Windows. La bandera &lt;code&gt;SECURITY_SQOS_PRESENT&lt;/code&gt; se establece autom&amp;aacute;ticamente cuando se utiliza este m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="1b51d9cd63e79117823cb3a5577ae76f76a648aa" translate="yes" xml:space="preserve">
          <source>For information on the design of the orphan rules, see &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md&quot;&gt;RFC 1023&lt;/a&gt;.</source>
          <target state="translated">Para obtener informaci&amp;oacute;n sobre el dise&amp;ntilde;o de las reglas hu&amp;eacute;rfanas, consulte &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md&quot;&gt;RFC 1023&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f4337d5c37f28afdc9f6e968d52d47c802b104d" translate="yes" xml:space="preserve">
          <source>For information on the design of the orphan rules, see &lt;a href=&quot;https://rust-lang.github.io/rfcs/2451-re-rebalancing-coherence.html&quot;&gt;RFC 2451&lt;/a&gt; and &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md&quot;&gt;RFC 1023&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="225b6b46a542b54e86029105be58c6f2b15b07b2" translate="yes" xml:space="preserve">
          <source>For instance, if the receiver has type &lt;code&gt;Box&amp;lt;[i32;2]&amp;gt;&lt;/code&gt;, then the candidate types will be &lt;code&gt;Box&amp;lt;[i32;2]&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;amp;Box&amp;lt;[i32;2]&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;amp;mut Box&amp;lt;[i32;2]&amp;gt;&lt;/code&gt;, &lt;code&gt;[i32; 2]&lt;/code&gt; (by dereferencing), &lt;code&gt;&amp;amp;[i32; 2]&lt;/code&gt;, &lt;code&gt;&amp;amp;mut [i32; 2]&lt;/code&gt;, &lt;code&gt;[i32]&lt;/code&gt; (by unsized coercion), &lt;code&gt;&amp;amp;[i32]&lt;/code&gt;, and finally &lt;code&gt;&amp;amp;mut [i32]&lt;/code&gt;.</source>
          <target state="translated">Por ejemplo, si el receptor tiene el tipo &lt;code&gt;Box&amp;lt;[i32;2]&amp;gt;&lt;/code&gt; , entonces los tipos candidatos ser&amp;aacute;n &lt;code&gt;Box&amp;lt;[i32;2]&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;amp;Box&amp;lt;[i32;2]&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;amp;mut Box&amp;lt;[i32;2]&amp;gt;&lt;/code&gt; , &lt;code&gt;[i32; 2]&lt;/code&gt; (desreferenciando), &lt;code&gt;&amp;amp;[i32; 2]&lt;/code&gt; , &lt;code&gt;&amp;amp;mut [i32; 2]&lt;/code&gt; , &lt;code&gt;[i32]&lt;/code&gt; (por coerci&amp;oacute;n sin tama&amp;ntilde;o), &lt;code&gt;&amp;amp;[i32]&lt;/code&gt; , y finalmente &lt;code&gt;&amp;amp;mut [i32]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2cd16941ca5e3ae0d133c47349cf0b4a2aebe81d" translate="yes" xml:space="preserve">
          <source>For instance, you cannot &lt;a href=&quot;../io/trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; into an uninitialized buffer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baaaebe339d6ce17ed6cfc031733bf141b61b1fd" translate="yes" xml:space="preserve">
          <source>For integral types, this is ignored.</source>
          <target state="translated">Para los tipos integrales,esto se ignora.</target>
        </trans-unit>
        <trans-unit id="6b107823eaed82b9e1f15dcd767296d37bccac20" translate="yes" xml:space="preserve">
          <source>For iterating from the front, the &lt;a href=&quot;#method.match_indices&quot;&gt;&lt;code&gt;match_indices&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">Para iterar desde el frente, se puede utilizar el m&amp;eacute;todo &lt;a href=&quot;#method.match_indices&quot;&gt; &lt;code&gt;match_indices&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d88445f2a62566b0d770ee0bdb5ade912a95ab77" translate="yes" xml:space="preserve">
          <source>For iterating from the front, the &lt;a href=&quot;#method.matches&quot;&gt;&lt;code&gt;matches&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">Para iterar desde el frente, se puede utilizar el m&amp;eacute;todo de &lt;a href=&quot;#method.matches&quot;&gt; &lt;code&gt;matches&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b7f9b888e8aa5560f84815a010ccb71f10239c27" translate="yes" xml:space="preserve">
          <source>For iterating from the front, the &lt;a href=&quot;#method.split&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">Para iterar desde el frente, se puede utilizar el m&amp;eacute;todo &lt;a href=&quot;#method.split&quot;&gt; &lt;code&gt;split&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e0637745021a8ec9092d57748f466adfb249ea99" translate="yes" xml:space="preserve">
          <source>For iterating from the front, the &lt;a href=&quot;#method.split_terminator&quot;&gt;&lt;code&gt;split_terminator&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">Para iterar desde el frente, se puede utilizar el m&amp;eacute;todo &lt;a href=&quot;#method.split_terminator&quot;&gt; &lt;code&gt;split_terminator&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1e9e4dafbc9ce6c65b15e4c57d7f5f65e014a32e" translate="yes" xml:space="preserve">
          <source>For iterating from the front, the &lt;a href=&quot;../primitive.str#method.match_indices&quot;&gt;&lt;code&gt;match_indices&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb60863336a5828341624e45c853be30e7540908" translate="yes" xml:space="preserve">
          <source>For iterating from the front, the &lt;a href=&quot;../primitive.str#method.matches&quot;&gt;&lt;code&gt;matches&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e1a5e53ef176500cb5cc5c96f0c172831e17377" translate="yes" xml:space="preserve">
          <source>For iterating from the front, the &lt;a href=&quot;../primitive.str#method.split&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f1664e44bf9c6ccc6fd225330d68f0d37f3ab44" translate="yes" xml:space="preserve">
          <source>For iterating from the front, the &lt;a href=&quot;../primitive.str#method.split_terminator&quot;&gt;&lt;code&gt;split_terminator&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11475214701d372b10cbf16754495bc1940945f6" translate="yes" xml:space="preserve">
          <source>For iterating from the front, the &lt;a href=&quot;primitive.str#method.match_indices&quot;&gt;&lt;code&gt;match_indices&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e160ba151777d5c8f04b9b2dbd5d16202c6f385d" translate="yes" xml:space="preserve">
          <source>For iterating from the front, the &lt;a href=&quot;primitive.str#method.matches&quot;&gt;&lt;code&gt;matches&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e8ad82d7847387c51f38511c2d2151c6a8665e2" translate="yes" xml:space="preserve">
          <source>For iterating from the front, the &lt;a href=&quot;primitive.str#method.split&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18d8ce67fc7ac86d26b31c3c26679d8b19f654bc" translate="yes" xml:space="preserve">
          <source>For iterating from the front, the &lt;a href=&quot;primitive.str#method.split_terminator&quot;&gt;&lt;code&gt;split_terminator&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e44fb98adc45057811caa8d42750cc0e5fe8aeb" translate="yes" xml:space="preserve">
          <source>For matches of &lt;code&gt;pat&lt;/code&gt; within &lt;code&gt;self&lt;/code&gt; that overlap, only the indices corresponding to the first match are returned.</source>
          <target state="translated">Para coincidencias de &lt;code&gt;pat&lt;/code&gt; dentro de &lt;code&gt;self&lt;/code&gt; que se superponen, solo se devuelven los &amp;iacute;ndices correspondientes a la primera coincidencia.</target>
        </trans-unit>
        <trans-unit id="abfb993550ab741f151661d1422d9018d04e9a77" translate="yes" xml:space="preserve">
          <source>For matches of &lt;code&gt;pat&lt;/code&gt; within &lt;code&gt;self&lt;/code&gt; that overlap, only the indices corresponding to the last match are returned.</source>
          <target state="translated">Para coincidencias de &lt;code&gt;pat&lt;/code&gt; dentro de &lt;code&gt;self&lt;/code&gt; que se superponen, solo se devuelven los &amp;iacute;ndices correspondientes a la &amp;uacute;ltima coincidencia.</target>
        </trans-unit>
        <trans-unit id="30e29f2a7f5a8332281828c6f9dfcd0e797d1dad" translate="yes" xml:space="preserve">
          <source>For method calls, the receiver (&lt;code&gt;self&lt;/code&gt; parameter) can only take advantage of &lt;a href=&quot;#unsized-coercions&quot;&gt;unsized coercions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e2f959308ccc06c3abbb26c45f8c6f0b3f855b0" translate="yes" xml:space="preserve">
          <source>For method calls, the receiver (&lt;code&gt;self&lt;/code&gt; parameter) can only take advantage of &lt;a href=&quot;type-coercions#unsized-coercions&quot;&gt;unsized coercions&lt;/a&gt;.</source>
          <target state="translated">Para las llamadas a m&amp;eacute;todos, el receptor ( par&amp;aacute;metro &lt;code&gt;self&lt;/code&gt; ) solo puede aprovechar &lt;a href=&quot;type-coercions#unsized-coercions&quot;&gt;coacciones sin tama&amp;ntilde;o&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bd5dd94d6e8475bf5fd070eb97a21cb66eb1d253" translate="yes" xml:space="preserve">
          <source>For more about tuples, see &lt;a href=&quot;../book/ch03-02-data-types#the-tuple-type&quot;&gt;the book&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre las tuplas, consulte &lt;a href=&quot;../book/ch03-02-data-types#the-tuple-type&quot;&gt;el libro&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8eb606573f263490abda0eae447840de1fd6312f" translate="yes" xml:space="preserve">
          <source>For more detail on &lt;code&gt;const&lt;/code&gt;, see the &lt;a href=&quot;../book/ch03-01-variables-and-mutability#differences-between-variables-and-constants&quot;&gt;Rust Book&lt;/a&gt; or the &lt;a href=&quot;../reference/items/constant-items&quot;&gt;Reference&lt;/a&gt;</source>
          <target state="translated">Para obtener m&amp;aacute;s detalles sobre &lt;code&gt;const&lt;/code&gt; , consulte el &lt;a href=&quot;../book/ch03-01-variables-and-mutability#differences-between-variables-and-constants&quot;&gt;libro Rust&lt;/a&gt; o la &lt;a href=&quot;../reference/items/constant-items&quot;&gt;referencia&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="34901312029c002d808f1bf7b19bb2453b8fe980" translate="yes" xml:space="preserve">
          <source>For more detail on &lt;code&gt;const&lt;/code&gt;, see the &lt;a href=&quot;../book/ch03-01-variables-and-mutability#differences-between-variables-and-constants&quot;&gt;Rust Book&lt;/a&gt; or the &lt;a href=&quot;../reference/items/constant-items&quot;&gt;Reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e291c473e6cc9b335b99368f64cbc1d71a0d4c0" translate="yes" xml:space="preserve">
          <source>For more detail, see the &lt;a href=&quot;macro-ambiguity&quot;&gt;formal specification&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s detalles, consulte la &lt;a href=&quot;macro-ambiguity&quot;&gt;especificaci&amp;oacute;n formal&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="22cc9134960646cae2e564ac06646cd0ebd7a8d6" translate="yes" xml:space="preserve">
          <source>For more details consult the &lt;a href=&quot;../reference/expressions/loop-expr#break-expressions&quot;&gt;Reference on &quot;break expression&quot;&lt;/a&gt; and the &lt;a href=&quot;../reference/expressions/loop-expr#break-and-loop-values&quot;&gt;Reference on &quot;break and loop values&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a550b344fcc2f00c8b16595ecc991ab71ffaa66" translate="yes" xml:space="preserve">
          <source>For more details, see the respective documentation of each item in the list.</source>
          <target state="translated">Para más detalles,véase la documentación respectiva de cada elemento de la lista.</target>
        </trans-unit>
        <trans-unit id="8026e54bc7efbcbe76562e4e5409a24d75961350" translate="yes" xml:space="preserve">
          <source>For more details, see the traits &lt;a href=&quot;trait.pattern&quot;&gt;&lt;code&gt;Pattern&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trait.searcher&quot;&gt;&lt;code&gt;Searcher&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trait.reversesearcher&quot;&gt;&lt;code&gt;ReverseSearcher&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;trait.doubleendedsearcher&quot;&gt;&lt;code&gt;DoubleEndedSearcher&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c2fb50eba7ae83c8f13df4bd900c89c668818e9" translate="yes" xml:space="preserve">
          <source>For more details, see the traits [&lt;code&gt;Pattern&lt;/code&gt;], [&lt;code&gt;Searcher&lt;/code&gt;], [&lt;code&gt;ReverseSearcher&lt;/code&gt;], and [&lt;code&gt;DoubleEndedSearcher&lt;/code&gt;].</source>
          <target state="translated">Para obtener m&amp;aacute;s detalles, consulte los rasgos [ &lt;code&gt;Pattern&lt;/code&gt; ], [ &lt;code&gt;Searcher&lt;/code&gt; ], [ &lt;code&gt;ReverseSearcher&lt;/code&gt; ] y [ &lt;code&gt;DoubleEndedSearcher&lt;/code&gt; ].</target>
        </trans-unit>
        <trans-unit id="89263bf3e6beb75e4571e90b66b3c70d0427828c" translate="yes" xml:space="preserve">
          <source>For more details, the &lt;a href=&quot;https://doc.rust-lang.org/stable/edition-guide/index.html&quot;&gt;&lt;em&gt;Edition Guide&lt;/em&gt;&lt;/a&gt; is a complete book about editions that enumerates the differences between editions and explains how to automatically upgrade your code to a new edition via &lt;code&gt;cargo fix&lt;/code&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s detalles, la &lt;a href=&quot;https://doc.rust-lang.org/stable/edition-guide/index.html&quot;&gt;&lt;em&gt;Gu&amp;iacute;a&lt;/em&gt;&lt;/a&gt; de ediciones es un libro completo sobre ediciones que enumera las diferencias entre las ediciones y explica c&amp;oacute;mo actualizar autom&amp;aacute;ticamente su c&amp;oacute;digo a una nueva edici&amp;oacute;n mediante &lt;code&gt;cargo fix&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6e6c205cbf7db8578d92757926cdfff233ef1ca" translate="yes" xml:space="preserve">
          <source>For more details, visit &lt;a href=&quot;../../book/ch15-02-deref&quot;&gt;the chapter in &lt;em&gt;The Rust Programming Language&lt;/em&gt;&lt;/a&gt; as well as the reference sections on &lt;a href=&quot;../../reference/expressions/operator-expr#the-dereference-operator&quot;&gt;the dereference operator&lt;/a&gt;, &lt;a href=&quot;../../reference/expressions/method-call-expr&quot;&gt;method resolution&lt;/a&gt; and &lt;a href=&quot;../../reference/type-coercions&quot;&gt;type coercions&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s detalles, visite &lt;a href=&quot;../../book/ch15-02-deref&quot;&gt;el cap&amp;iacute;tulo de &lt;em&gt;The Rust Programming Language&lt;/em&gt;&lt;/a&gt; , as&amp;iacute; como las secciones de referencia sobre &lt;a href=&quot;../../reference/expressions/operator-expr#the-dereference-operator&quot;&gt;el operador de desreferencia&lt;/a&gt; , la &lt;a href=&quot;../../reference/expressions/method-call-expr&quot;&gt;resoluci&amp;oacute;n de m&amp;eacute;todos&lt;/a&gt; y las &lt;a href=&quot;../../reference/type-coercions&quot;&gt;coacciones de tipo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c7b389f333511523f6507959ed7a6c82c5ac6a24" translate="yes" xml:space="preserve">
          <source>For more information about &lt;a href=&quot;book/ch03-02-data-types&quot;&gt;primitives&lt;/a&gt; and &lt;a href=&quot;book/ch05-00-structs&quot;&gt;structs&lt;/a&gt;, take a look at the Book.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc5cd9e3e865afa46a350086d1b1c96c19d01d7c" translate="yes" xml:space="preserve">
          <source>For more information about Cargo, check out &lt;a href=&quot;https://doc.rust-lang.org/cargo/index.html&quot;&gt;its documentation&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre Cargo, consulte &lt;a href=&quot;https://doc.rust-lang.org/cargo/index.html&quot;&gt;su documentaci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fa0a4fd36684df6f8397d7fa9786ae835418c592" translate="yes" xml:space="preserve">
          <source>For more information about associated types, see &lt;a href=&quot;book/ch19-03-advanced-traits#specifying-placeholder-types-in-trait-definitions-with-associated-types&quot;&gt;the book&lt;/a&gt;. For more information on associated type bounds, see &lt;a href=&quot;https://rust-lang.github.io/rfcs/2289-associated-type-bounds.html&quot;&gt;RFC 2289&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8da00a231113177386f7e47cc0a2389ab7cc277" translate="yes" xml:space="preserve">
          <source>For more information about casts, take a look at the Type cast section in &lt;a href=&quot;reference/expressions/operator-expr#type-cast-expressions&quot;&gt;The Reference Book&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre los moldes, eche un vistazo a la secci&amp;oacute;n Tipo de moldes en &lt;a href=&quot;reference/expressions/operator-expr#type-cast-expressions&quot;&gt;The Reference Book&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6cd0c62441350987a4762127fe18207f874a343a" translate="yes" xml:space="preserve">
          <source>For more information about named threads, see &lt;a href=&quot;index#naming-threads&quot;&gt;this module-level documentation&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre subprocesos con nombre, consulte &lt;a href=&quot;index#naming-threads&quot;&gt;esta documentaci&amp;oacute;n a nivel de m&amp;oacute;dulo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="102d4511f19624e4e594eba5e2a713f736f94403" translate="yes" xml:space="preserve">
          <source>For more information about primitives and structs, take a look at The Book: https://doc.rust-lang.org/book/ch03-02-data-types.html https://doc.rust-lang.org/book/ch05-00-structs.html</source>
          <target state="translated">Para obtener más información sobre los primitivos y las estructuras,eche un vistazo a El Libro:https://doc.rust-lang.org/book/ch03-02-data-types.html https://doc.rust-lang.org/book/ch05-00-structs.html</target>
        </trans-unit>
        <trans-unit id="c3bf4058fb0bfe3a7675bbb543b62e5dee4c6887" translate="yes" xml:space="preserve">
          <source>For more information about specifying representations, see the &lt;a href=&quot;https://doc.rust-lang.org/nomicon/other-reprs.html&quot;&gt;&quot;Alternative Representations&quot; section&lt;/a&gt; of the Rustonomicon.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre c&amp;oacute;mo especificar representaciones, consulte la &lt;a href=&quot;https://doc.rust-lang.org/nomicon/other-reprs.html&quot;&gt;secci&amp;oacute;n &quot;Representaciones alternativas&quot;&lt;/a&gt; del Rustonomicon.</target>
        </trans-unit>
        <trans-unit id="8bd1cbeb47b7decd82b7fd7ecf8bae1087ce674f" translate="yes" xml:space="preserve">
          <source>For more information about the &lt;code&gt;cfg&lt;/code&gt; attribute, read the section on &lt;a href=&quot;reference/conditional-compilation&quot;&gt;Conditional Compilation&lt;/a&gt; in the Reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4442c14c85c92ae0273cf16c727092964e793917" translate="yes" xml:space="preserve">
          <source>For more information about the cfg attribute, read: https://doc.rust-lang.org/reference.html#conditional-compilation</source>
          <target state="translated">Para más información sobre el atributo cfg,lea:https://doc.rust-lang.org/reference.html#conditional-compilation</target>
        </trans-unit>
        <trans-unit id="992fc2eeb08dc25782d2fddc6c0b6015bc376de5" translate="yes" xml:space="preserve">
          <source>For more information about the inline attribute, https: read://doc.rust-lang.org/reference.html#inline-attributes</source>
          <target state="translated">Para más información sobre el atributo inline,https:read://doc.rust-lang.org/reference.html#inline-attributes</target>
        </trans-unit>
        <trans-unit id="9db48592ab4095960e3e44f8b09079a0c0259f44" translate="yes" xml:space="preserve">
          <source>For more information about the inline attribute, read: https://doc.rust-lang.org/reference.html#inline-attributes</source>
          <target state="translated">Para más información sobre el atributo en línea,lea:https://doc.rust-lang.org/reference.html#inline-attributes</target>
        </trans-unit>
        <trans-unit id="cfa646f3fb3a336d8ee248174c90b109ddf1ff5a" translate="yes" xml:space="preserve">
          <source>For more information about the particulars of how the path is separated into components, see &lt;a href=&quot;#method.components&quot;&gt;&lt;code&gt;components&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre los detalles de c&amp;oacute;mo se divide la ruta en componentes, consulte &lt;a href=&quot;#method.components&quot;&gt; &lt;code&gt;components&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d208a7a00016bd80eb36abc405d4d67532f3f3f6" translate="yes" xml:space="preserve">
          <source>For more information about the particulars of how the path is separated into components, see &lt;a href=&quot;struct.path#method.components&quot;&gt;&lt;code&gt;components&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd76571f2b2b3e596e0b9a91b81882353dbf69b8" translate="yes" xml:space="preserve">
          <source>For more information about the stack size for threads, see &lt;a href=&quot;index#stack-size&quot;&gt;this module-level documentation&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre el tama&amp;ntilde;o de la pila de subprocesos, consulte &lt;a href=&quot;index#stack-size&quot;&gt;esta documentaci&amp;oacute;n a nivel de m&amp;oacute;dulo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7fb8ee866c1b39714e1dcfd554e8800ff32ff81a" translate="yes" xml:space="preserve">
          <source>For more information about this option, see &lt;a href=&quot;#method.join_multicast_v4&quot;&gt;&lt;code&gt;join_multicast_v4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre esta opci&amp;oacute;n, consulte &lt;a href=&quot;#method.join_multicast_v4&quot;&gt; &lt;code&gt;join_multicast_v4&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="57833ee07247599f44cb309fde1124280eb648a4" translate="yes" xml:space="preserve">
          <source>For more information about this option, see &lt;a href=&quot;#method.join_multicast_v6&quot;&gt;&lt;code&gt;join_multicast_v6&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre esta opci&amp;oacute;n, consulte &lt;a href=&quot;#method.join_multicast_v6&quot;&gt; &lt;code&gt;join_multicast_v6&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3ce681618c57caf981736423d26acc94ae89b21d" translate="yes" xml:space="preserve">
          <source>For more information about this option, see &lt;a href=&quot;#method.set_broadcast&quot;&gt;&lt;code&gt;set_broadcast&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre esta opci&amp;oacute;n, consulte &lt;a href=&quot;#method.set_broadcast&quot;&gt; &lt;code&gt;set_broadcast&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="395c58ec3f6bc027abde9bbf9fad1f4f5468d568" translate="yes" xml:space="preserve">
          <source>For more information about this option, see &lt;a href=&quot;#method.set_multicast_loop_v4&quot;&gt;&lt;code&gt;set_multicast_loop_v4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre esta opci&amp;oacute;n, consulte &lt;a href=&quot;#method.set_multicast_loop_v4&quot;&gt; &lt;code&gt;set_multicast_loop_v4&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="19a25d5021da7a65fa90afdcaa8c94b2d240f4ea" translate="yes" xml:space="preserve">
          <source>For more information about this option, see &lt;a href=&quot;#method.set_multicast_loop_v6&quot;&gt;&lt;code&gt;set_multicast_loop_v6&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre esta opci&amp;oacute;n, consulte &lt;a href=&quot;#method.set_multicast_loop_v6&quot;&gt; &lt;code&gt;set_multicast_loop_v6&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="df749fde579be395be3ce58123ceffc9653388c3" translate="yes" xml:space="preserve">
          <source>For more information about this option, see &lt;a href=&quot;#method.set_multicast_ttl_v4&quot;&gt;&lt;code&gt;set_multicast_ttl_v4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre esta opci&amp;oacute;n, consulte &lt;a href=&quot;#method.set_multicast_ttl_v4&quot;&gt; &lt;code&gt;set_multicast_ttl_v4&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6c0d794b98dbf3eac083b7075a715bd37c850949" translate="yes" xml:space="preserve">
          <source>For more information about this option, see &lt;a href=&quot;#method.set_nodelay&quot;&gt;&lt;code&gt;set_nodelay&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre esta opci&amp;oacute;n, consulte &lt;a href=&quot;#method.set_nodelay&quot;&gt; &lt;code&gt;set_nodelay&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f6e7cb5f78e58ab89345b5ca811fb23b56f9162d" translate="yes" xml:space="preserve">
          <source>For more information about this option, see &lt;a href=&quot;#method.set_ttl&quot;&gt;&lt;code&gt;set_ttl&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre esta opci&amp;oacute;n, consulte &lt;a href=&quot;#method.set_ttl&quot;&gt; &lt;code&gt;set_ttl&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2a394bc2e818a902cb20ef60be1aacfb5b6bed5f" translate="yes" xml:space="preserve">
          <source>For more information about this option, see &lt;a href=&quot;struct.tcplistener#method.set_ttl&quot;&gt;&lt;code&gt;TcpListener::set_ttl&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aa7c5c36f089ee6dcc230b22a43e81dfd29e6b2" translate="yes" xml:space="preserve">
          <source>For more information about this option, see &lt;a href=&quot;struct.tcpstream#method.set_nodelay&quot;&gt;&lt;code&gt;TcpStream::set_nodelay&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f687f34df5c1fceb0c2f349452aeb54b4703e77" translate="yes" xml:space="preserve">
          <source>For more information about this option, see &lt;a href=&quot;struct.tcpstream#method.set_ttl&quot;&gt;&lt;code&gt;TcpStream::set_ttl&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e3059868c3caa8fd899a2dfbced1ef7fac82dec" translate="yes" xml:space="preserve">
          <source>For more information about this option, see &lt;a href=&quot;struct.udpsocket#method.join_multicast_v4&quot;&gt;&lt;code&gt;UdpSocket::join_multicast_v4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3a6b546e03443d3c886b47248d82d04304e9248" translate="yes" xml:space="preserve">
          <source>For more information about this option, see &lt;a href=&quot;struct.udpsocket#method.join_multicast_v6&quot;&gt;&lt;code&gt;UdpSocket::join_multicast_v6&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8976685aa3713d913257de37c43c4da5f4633071" translate="yes" xml:space="preserve">
          <source>For more information about this option, see &lt;a href=&quot;struct.udpsocket#method.set_broadcast&quot;&gt;&lt;code&gt;UdpSocket::set_broadcast&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07036701bb4372022b206f78e36755f596630148" translate="yes" xml:space="preserve">
          <source>For more information about this option, see &lt;a href=&quot;struct.udpsocket#method.set_multicast_loop_v4&quot;&gt;&lt;code&gt;UdpSocket::set_multicast_loop_v4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35ff8940232500740f176ac52d9cff14d41ab14b" translate="yes" xml:space="preserve">
          <source>For more information about this option, see &lt;a href=&quot;struct.udpsocket#method.set_multicast_loop_v6&quot;&gt;&lt;code&gt;UdpSocket::set_multicast_loop_v6&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4078ff38e27b60f80025612aee1ce51e84fa1526" translate="yes" xml:space="preserve">
          <source>For more information about this option, see &lt;a href=&quot;struct.udpsocket#method.set_multicast_ttl_v4&quot;&gt;&lt;code&gt;UdpSocket::set_multicast_ttl_v4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec0b5493666a5b9737f7e29ab01f3a736aa6fac1" translate="yes" xml:space="preserve">
          <source>For more information about this option, see &lt;a href=&quot;struct.udpsocket#method.set_ttl&quot;&gt;&lt;code&gt;UdpSocket::set_ttl&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5fe57c8b77795ff593ae38ee9a6c491d030bcba" translate="yes" xml:space="preserve">
          <source>For more information about type casts, take a look at the section of the &lt;a href=&quot;reference/expressions/operator-expr#type-cast-expressions&quot;&gt;The Rust Reference&lt;/a&gt; on type cast expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a26525f8ef356116ef471c0be5406f813dea377a" translate="yes" xml:space="preserve">
          <source>For more information and a list of supported ABIs, see &lt;a href=&quot;https://doc.rust-lang.org/nomicon/ffi.html#foreign-calling-conventions&quot;&gt;the nomicon's section on foreign calling conventions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16217596c793a9bbadfbe3ea0e828a9914e8bd03" translate="yes" xml:space="preserve">
          <source>For more information and a list of supported ABIs, see [the nomicon's section on foreign calling conventions][nomicon-abi].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5bf128360e21745d96296482aa04348caf9fa97" translate="yes" xml:space="preserve">
          <source>For more information on &lt;code&gt;if&lt;/code&gt; expressions, see the &lt;a href=&quot;../book/ch03-05-control-flow#if-expressions&quot;&gt;Rust book&lt;/a&gt; or the &lt;a href=&quot;../reference/expressions/if-expr&quot;&gt;Reference&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre las expresiones &lt;code&gt;if&lt;/code&gt; , consulte el &lt;a href=&quot;../book/ch03-05-control-flow#if-expressions&quot;&gt;libro de Rust&lt;/a&gt; o la &lt;a href=&quot;../reference/expressions/if-expr&quot;&gt;Referencia&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="26c4f344d22bc81326bce9f0d84393a6ba5329dd" translate="yes" xml:space="preserve">
          <source>For more information on &lt;code&gt;impl Trait&lt;/code&gt; syntax, see the &lt;a href=&quot;../book/ch10-02-traits#returning-types-that-implement-traits&quot;&gt;Rust book&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre la sintaxis &lt;code&gt;impl Trait&lt;/code&gt; , consulte el &lt;a href=&quot;../book/ch10-02-traits#returning-types-that-implement-traits&quot;&gt;libro de Rust&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8baad10e10ead72e523430c806f5046d53166956" translate="yes" xml:space="preserve">
          <source>For more information on &lt;code&gt;loop&lt;/code&gt; and loops in general, see the &lt;a href=&quot;../reference/expressions/loop-expr&quot;&gt;Reference&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre &lt;code&gt;loop&lt;/code&gt; y bucles en general, consulte la &lt;a href=&quot;../reference/expressions/loop-expr&quot;&gt;Referencia&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0d9e2e99793fab9dd3626d998768ee865c474bfd" translate="yes" xml:space="preserve">
          <source>For more information on &lt;code&gt;match&lt;/code&gt; and matching in general, see the &lt;a href=&quot;../reference/expressions/match-expr&quot;&gt;Reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0710e2e1ea383271033954b11a70c7bad7ea2cb4" translate="yes" xml:space="preserve">
          <source>For more information on &lt;code&gt;use&lt;/code&gt; and paths in general, see the &lt;a href=&quot;../reference/items/use-declarations&quot;&gt;Reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3d8b3ebb20cee3aad696e4716ebdeb83e61bc82" translate="yes" xml:space="preserve">
          <source>For more information on &lt;code&gt;while&lt;/code&gt; and loops in general, see the &lt;a href=&quot;../reference/expressions/loop-expr#predicate-loops&quot;&gt;reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f290aa363db2393559b1506887c6b8507f90da13" translate="yes" xml:space="preserve">
          <source>For more information on Clippy, see &lt;a href=&quot;https://github.com/rust-lang/rust-clippy&quot;&gt;its documentation&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre Clippy, consulte &lt;a href=&quot;https://github.com/rust-lang/rust-clippy&quot;&gt;su documentaci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="38db950fcbbf4fcba31dce2f10974dd6a5fef98a" translate="yes" xml:space="preserve">
          <source>For more information on FFI, check the &lt;a href=&quot;../book/ch19-01-unsafe-rust#using-extern-functions-to-call-external-code&quot;&gt;Rust book&lt;/a&gt; or the &lt;a href=&quot;../reference/items/external-blocks&quot;&gt;Reference&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre FFI, consulte el &lt;a href=&quot;../book/ch19-01-unsafe-rust#using-extern-functions-to-call-external-code&quot;&gt;libro de Rust&lt;/a&gt; o la &lt;a href=&quot;../reference/items/external-blocks&quot;&gt;Referencia&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d641d6c32a05462a1486b1dc6324213dda8812b9" translate="yes" xml:space="preserve">
          <source>For more information on Rust's ownership system, take a look at the &lt;a href=&quot;book/ch04-02-references-and-borrowing&quot;&gt;References &amp;amp; Borrowing&lt;/a&gt; section of the Book.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="285f1b877490199173d757dddff730450bb4b01f" translate="yes" xml:space="preserve">
          <source>For more information on floating point numbers, see &lt;a href=&quot;https://en.wikipedia.org/wiki/Single-precision_floating-point_format&quot;&gt;Wikipedia&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee24777d534cc43d3f116683cebd1988effa8023" translate="yes" xml:space="preserve">
          <source>For more information on for-loops, see the &lt;a href=&quot;../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;Rust book&lt;/a&gt; or the &lt;a href=&quot;../reference/expressions/loop-expr#iterator-loops&quot;&gt;Reference&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre los bucles for, consulte el &lt;a href=&quot;../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;libro de Rust&lt;/a&gt; o la &lt;a href=&quot;../reference/expressions/loop-expr#iterator-loops&quot;&gt;Referencia&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a24996038d4cee454655450978dea7d8a2b46904" translate="yes" xml:space="preserve">
          <source>For more information on formatters, see &lt;a href=&quot;https://doc.rust-lang.org/core/fmt/index.html&quot;&gt;the module-level documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53ad00a80543ba5ff60480a82f25b9b9fc2fe15a" translate="yes" xml:space="preserve">
          <source>For more information on formatters, see &lt;a href=&quot;index&quot;&gt;the module-level documentation&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre los formateadores, consulte &lt;a href=&quot;index&quot;&gt;la documentaci&amp;oacute;n a nivel de m&amp;oacute;dulo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ff3812b259ec258484f134f2413ea468207c8e57" translate="yes" xml:space="preserve">
          <source>For more information on how to use references, see &lt;a href=&quot;../book/ch04-02-references-and-borrowing&quot;&gt;the book's section on &quot;References and Borrowing&quot;&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre c&amp;oacute;mo utilizar las referencias, consulte &lt;a href=&quot;../book/ch04-02-references-and-borrowing&quot;&gt;la secci&amp;oacute;n del libro sobre &quot;Referencias y pr&amp;eacute;stamos&quot;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ab47fbe22d48e3b8af90238a1671382c62540270" translate="yes" xml:space="preserve">
          <source>For more information on implementations, see the &lt;a href=&quot;../book/ch05-03-method-syntax&quot;&gt;Rust book&lt;/a&gt; or the &lt;a href=&quot;../reference/items/implementations&quot;&gt;Reference&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre las implementaciones, consulte el &lt;a href=&quot;../book/ch05-03-method-syntax&quot;&gt;libro de Rust&lt;/a&gt; o la &lt;a href=&quot;../reference/items/implementations&quot;&gt;Referencia&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cd2bcc840b6d179d8b0cd5dcc59be377dcf31780" translate="yes" xml:space="preserve">
          <source>For more information on structs, take a look at the &lt;a href=&quot;../book/ch05-01-defining-structs&quot;&gt;Rust Book&lt;/a&gt; or the &lt;a href=&quot;../reference/items/structs&quot;&gt;Reference&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre estructuras, consulte el &lt;a href=&quot;../book/ch05-01-defining-structs&quot;&gt;Libro de Rust&lt;/a&gt; o la &lt;a href=&quot;../reference/items/structs&quot;&gt;Referencia&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5ce49c995bb1152375ebd2c5ecd45128ba41cc83" translate="yes" xml:space="preserve">
          <source>For more information on the &lt;code&gt;let&lt;/code&gt; keyword, see the &lt;a href=&quot;../book/ch18-01-all-the-places-for-patterns#let-statements&quot;&gt;Rust book&lt;/a&gt; or the &lt;a href=&quot;../reference/statements#let-statements&quot;&gt;Reference&lt;/a&gt;</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre la palabra clave &lt;code&gt;let&lt;/code&gt; , consulte el &lt;a href=&quot;../book/ch18-01-all-the-places-for-patterns#let-statements&quot;&gt;libro de Rust&lt;/a&gt; o la &lt;a href=&quot;../reference/statements#let-statements&quot;&gt;Referencia&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="55f4ff0283f817ff45a08f2d5b8976730a7bb67c" translate="yes" xml:space="preserve">
          <source>For more information on the &lt;code&gt;move&lt;/code&gt; keyword, see the &lt;a href=&quot;../book/ch13-01-closures&quot;&gt;closure&lt;/a&gt;'s section of the Rust book or the &lt;a href=&quot;../book/ch16-01-threads#using-move-closures-with-threads&quot;&gt;threads&lt;/a&gt; section</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5404b7f8ed3a8699d7f7e7b750cd0c12cdb64a72" translate="yes" xml:space="preserve">
          <source>For more information on the &lt;code&gt;pub&lt;/code&gt; keyword, please see the visibility section of the &lt;a href=&quot;../reference/visibility-and-privacy?highlight=pub#visibility-and-privacy&quot;&gt;reference&lt;/a&gt; and for some examples, see &lt;a href=&quot;https://doc.rust-lang.org/rust-by-example/mod/visibility.html&quot;&gt;Rust by Example&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cc632ff0cf0c0731c6a179ab2eab0a11d96c7a4" translate="yes" xml:space="preserve">
          <source>For more information on the &lt;code&gt;rls&lt;/code&gt;, see &lt;a href=&quot;https://github.com/rust-lang/rls&quot;&gt;its documentation&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre &lt;code&gt;rls&lt;/code&gt; , consulte &lt;a href=&quot;https://github.com/rust-lang/rls&quot;&gt;su documentaci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e3863c21d325c3c3d855add8a948767200d6c9d5" translate="yes" xml:space="preserve">
          <source>For more information on the effect of async, see &lt;a href=&quot;../expressions/block-expr#async-blocks&quot;&gt;&lt;code&gt;async&lt;/code&gt; blocks&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5291eb6d53f544698352ae404ca44de78b99df0" translate="yes" xml:space="preserve">
          <source>For more information on the meaning and layout of the &lt;code&gt;flowinfo&lt;/code&gt; and &lt;code&gt;scope_id&lt;/code&gt; parameters, see &lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;IETF RFC 2553, Section 3.3&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre el significado y el dise&amp;ntilde;o de los par&amp;aacute;metros &lt;code&gt;flowinfo&lt;/code&gt; y &lt;code&gt;scope_id&lt;/code&gt; , consulte &lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;IETF RFC 2553, Secci&amp;oacute;n 3.3&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e9e3e7095c9863573782cdbe8dd1a7bbcbf2fb4f" translate="yes" xml:space="preserve">
          <source>For more information on the rust ownership system, take a look at https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html.</source>
          <target state="translated">Para más información sobre el sistema de propiedad de la herrumbre,consulte https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html.</target>
        </trans-unit>
        <trans-unit id="dd65d29db2c0c0e3fa4010b1a534ac28777bc593" translate="yes" xml:space="preserve">
          <source>For more information on the various types of functions and how they're used, consult the &lt;a href=&quot;../book/ch03-03-how-functions-work&quot;&gt;Rust book&lt;/a&gt; or the &lt;a href=&quot;../reference/items/functions&quot;&gt;Reference&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre los distintos tipos de funciones y c&amp;oacute;mo se utilizan, consulte el &lt;a href=&quot;../book/ch03-03-how-functions-work&quot;&gt;libro de Rust&lt;/a&gt; o la &lt;a href=&quot;../reference/items/functions&quot;&gt;Referencia&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ba53489dfe57a910985fb20af8e3e6d3e80de7b1" translate="yes" xml:space="preserve">
          <source>For more information on what &lt;code&gt;as&lt;/code&gt; is capable of, see the &lt;a href=&quot;../reference/expressions/operator-expr#type-cast-expressions&quot;&gt;Reference&lt;/a&gt;</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre lo &lt;code&gt;as&lt;/code&gt; es capaz de hacer, consulte la &lt;a href=&quot;../reference/expressions/operator-expr#type-cast-expressions&quot;&gt;Referencia&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="200342727dbc618ada8e648e6bb5b49b50685bf3" translate="yes" xml:space="preserve">
          <source>For more information on what &lt;code&gt;as&lt;/code&gt; is capable of, see the &lt;a href=&quot;../reference/expressions/operator-expr#type-cast-expressions&quot;&gt;Reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1294a54cecd68adbf06bcf29dd93bf0d7224b50a" translate="yes" xml:space="preserve">
          <source>For more information see the &lt;a href=&quot;https://doc.rust-lang.org/nomicon/atomics.html&quot;&gt;nomicon&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n, consulte &lt;a href=&quot;https://doc.rust-lang.org/nomicon/atomics.html&quot;&gt;nomicon&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8515ff7c1a2ff91adff1550ef7c0680acfebc183" translate="yes" xml:space="preserve">
          <source>For more information see the &lt;a href=&quot;reference/attributes/codegen&quot;&gt;&lt;code&gt;instruction_set&lt;/code&gt; attribute&lt;/a&gt; section of the Reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2722cfdeb47cf791bc768e784fd872da493e862a" translate="yes" xml:space="preserve">
          <source>For more information see the &lt;a href=&quot;reference/attributes/codegen#the-inline-attribute&quot;&gt;&lt;code&gt;inline&lt;/code&gt; Attribute&lt;/a&gt; section of the Reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="430f53d43ce499b5fc6e5944890296c5d6682bce" translate="yes" xml:space="preserve">
          <source>For more information see the &lt;a href=&quot;reference/attributes/codegen#the-inline-attribute&quot;&gt;&lt;code&gt;inline&lt;/code&gt; attribute&lt;/a&gt; section of the Reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7be2448b1c40c0c0e54b5bb192d0485e421966fb" translate="yes" xml:space="preserve">
          <source>For more information see the Rust Reference on &lt;a href=&quot;reference/visibility-and-privacy&quot;&gt;Visibility&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n, consulte la Referencia de Rust sobre &lt;a href=&quot;reference/visibility-and-privacy&quot;&gt;visibilidad&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8d5d738749a358bd9c9bd1e06a8750768118877d" translate="yes" xml:space="preserve">
          <source>For more information, please see &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0447-no-unused-impl-parameters.md&quot;&gt;RFC 447&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n, consulte &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0447-no-unused-impl-parameters.md&quot;&gt;RFC 447&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="81e4e160a9649ee9d3702198e8d0083beee65f16" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;#capacity-and-reallocation&quot;&gt;Capacity and Reallocation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad517b06e20ad9092f17ffc60fe635ca1c292a27" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md&quot;&gt;RFC 599&lt;/a&gt; and its amendment &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md&quot;&gt;RFC 1156&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9be296727789507d09db0e50484a6ee533f9b657" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;https://github.com/rust-lang/rust/issues/74052&quot;&gt;GitHub issue #74052&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13280a26e699d624818597363ac11248df07682b" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt;. For information on the format string syntax, see &lt;a href=&quot;fmt/index&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n, consulte &lt;a href=&quot;macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt;. Para obtener informaci&amp;oacute;n sobre la sintaxis de cadenas de formato, consulte &lt;a href=&quot;fmt/index&quot;&gt; &lt;code&gt;std::fmt&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8b67eca63270d5078808d08322ebcadad733aa46" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt;. For information on the format string syntax, see &lt;a href=&quot;https://doc.rust-lang.org/core/fmt/index.html&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="105a7b06489677dc75af87ff58131cb813821718" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;type.lockresult&quot;&gt;&lt;code&gt;LockResult&lt;/code&gt;&lt;/a&gt;. A &lt;code&gt;TryLockResult&lt;/code&gt; doesn't necessarily hold the associated guard in the &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; type as the lock may not have been acquired for other reasons.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n, consulte &lt;a href=&quot;type.lockresult&quot;&gt; &lt;code&gt;LockResult&lt;/code&gt; &lt;/a&gt; . Un &lt;code&gt;TryLockResult&lt;/code&gt; no tiene necesariamente la protecci&amp;oacute;n asociada en el tipo &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; ya que es posible que el bloqueo no se haya adquirido por otras razones.</target>
        </trans-unit>
        <trans-unit id="061ee0b6c46c6f1de9b553ef8ec0ea2c4506aea3" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;a href=&quot;fn.stderr&quot;&gt;&lt;code&gt;io::stderr&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n, consulte el m&amp;eacute;todo &lt;a href=&quot;fn.stderr&quot;&gt; &lt;code&gt;io::stderr&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2d8d91c96fdfd1707d627d52a81e7ba2e66f436d" translate="yes" xml:space="preserve">
          <source>For more information, see the documentation in &lt;a href=&quot;fmt/index&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n, consulte la documentaci&amp;oacute;n en &lt;a href=&quot;fmt/index&quot;&gt; &lt;code&gt;std::fmt&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b075f87a0aa0ececd35398edb04098f5381d1784" translate="yes" xml:space="preserve">
          <source>For more information, see the documentation in &lt;a href=&quot;https://doc.rust-lang.org/core/fmt/index.html&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22b73ddcf768c9c706f3f5ce7c0719488d3f3d0b" translate="yes" xml:space="preserve">
          <source>For more information, take a look at the &lt;a href=&quot;../book/ch06-01-defining-an-enum&quot;&gt;Rust Book&lt;/a&gt; or the &lt;a href=&quot;../reference/items/enumerations&quot;&gt;Reference&lt;/a&gt;</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n, consulte el &lt;a href=&quot;../book/ch06-01-defining-an-enum&quot;&gt;libro Rust&lt;/a&gt; o la &lt;a href=&quot;../reference/items/enumerations&quot;&gt;referencia&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1dcd53adc5b18c6de5c84d7a2eea62c7f636c8a4" translate="yes" xml:space="preserve">
          <source>For most filesystems, the operating system guarantees that all writes are atomic: no writes get mangled because another process writes at the same time.</source>
          <target state="translated">Para la mayoría de los sistemas de archivos,el sistema operativo garantiza que todas las escrituras son atómicas:ninguna escritura se estropea porque otro proceso escribe al mismo tiempo.</target>
        </trans-unit>
        <trans-unit id="e69c5be27e4e91243d49f0a635a88ca5efc30bd8" translate="yes" xml:space="preserve">
          <source>For most platforms a backtrace with a filename/line number requires that programs be compiled with debug information. Without debug information filenames/line numbers will not be reported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c93ed371993f23b715f83d6c14f6a2845f0553e" translate="yes" xml:space="preserve">
          <source>For most situations, having all libraries available as a dylib is recommended if dynamically linking. For other situations, the compiler will emit a warning if it is unable to determine which formats to link each library with.</source>
          <target state="translated">Para la mayoría de las situaciones,se recomienda tener todas las bibliotecas disponibles como un dylib si se enlazan dinámicamente.Para otras situaciones,el compilador emitirá una advertencia si no puede determinar con qué formatos enlazar cada biblioteca.</target>
        </trans-unit>
        <trans-unit id="f60bc833f920bbe05de763c3c4c66d6c4df0a446" translate="yes" xml:space="preserve">
          <source>For non-numeric types, this can be considered a &quot;maximum width&quot;. If the resulting string is longer than this width, then it is truncated down to this many characters and that truncated value is emitted with proper &lt;code&gt;fill&lt;/code&gt;, &lt;code&gt;alignment&lt;/code&gt; and &lt;code&gt;width&lt;/code&gt; if those parameters are set.</source>
          <target state="translated">Para los tipos no num&amp;eacute;ricos, esto se puede considerar un &quot;ancho m&amp;aacute;ximo&quot;. Si la cadena resultante es m&amp;aacute;s larga que este ancho, entonces se trunca a esta cantidad de caracteres y ese valor truncado se emite con el &lt;code&gt;fill&lt;/code&gt; , la &lt;code&gt;alignment&lt;/code&gt; y el &lt;code&gt;width&lt;/code&gt; adecuados si se establecen esos par&amp;aacute;metros.</target>
        </trans-unit>
        <trans-unit id="759891ff1588306215a2ec66ea4ffdf3b900cc9a" translate="yes" xml:space="preserve">
          <source>For non-users, a new edition signals that some major advancements have landed, which might make Rust worth another look.</source>
          <target state="translated">Para los no usuarios,una nueva edición señala que algunos avances importantes han aterrizado,lo que podría hacer que el óxido merezca otra mirada.</target>
        </trans-unit>
        <trans-unit id="032e9d1e38ac32b8d4f9cea98bf791c06db59c12" translate="yes" xml:space="preserve">
          <source>For non-zero-sized values, a &lt;a href=&quot;struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt; will use the &lt;a href=&quot;../alloc/struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; allocator for its allocation. It is valid to convert both ways between a &lt;a href=&quot;struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt; and a raw pointer allocated with the &lt;a href=&quot;../alloc/struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; allocator, given that the &lt;a href=&quot;../alloc/struct.layout&quot;&gt;&lt;code&gt;Layout&lt;/code&gt;&lt;/a&gt; used with the allocator is correct for the type. More precisely, a &lt;code&gt;value: *mut T&lt;/code&gt; that has been allocated with the &lt;a href=&quot;../alloc/struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; allocator with &lt;code&gt;Layout::for_value(&amp;amp;*value)&lt;/code&gt; may be converted into a box using &lt;a href=&quot;struct.box#method.from_raw&quot;&gt;&lt;code&gt;Box::&amp;lt;T&amp;gt;::from_raw(value)&lt;/code&gt;&lt;/a&gt;. Conversely, the memory backing a &lt;code&gt;value: *mut T&lt;/code&gt; obtained from &lt;a href=&quot;struct.box#method.into_raw&quot;&gt;&lt;code&gt;Box::&amp;lt;T&amp;gt;::into_raw&lt;/code&gt;&lt;/a&gt; may be deallocated using the &lt;a href=&quot;../alloc/struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; allocator with &lt;a href=&quot;../alloc/struct.layout#method.for_value&quot;&gt;&lt;code&gt;Layout::for_value(&amp;amp;*value)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8be924402e1b9e352b3e21f3848f1b4490ef1405" translate="yes" xml:space="preserve">
          <source>For non-zero-sized values, a &lt;a href=&quot;struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt; will use the &lt;a href=&quot;../alloc/struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; allocator for its allocation. It is valid to convert both ways between a &lt;a href=&quot;struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt; and a raw pointer allocated with the &lt;a href=&quot;../alloc/struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; allocator, given that the &lt;a href=&quot;../alloc/struct.layout&quot;&gt;&lt;code&gt;Layout&lt;/code&gt;&lt;/a&gt; used with the allocator is correct for the type. More precisely, a &lt;code&gt;value: *mut T&lt;/code&gt; that has been allocated with the &lt;a href=&quot;../alloc/struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; allocator with &lt;code&gt;Layout::for_value(&amp;amp;*value)&lt;/code&gt; may be converted into a box using &lt;code&gt;Box::&amp;lt;T&amp;gt;::from_raw(value)&lt;/code&gt;. Conversely, the memory backing a &lt;code&gt;value: *mut T&lt;/code&gt; obtained from &lt;code&gt;Box::&amp;lt;T&amp;gt;::into_raw&lt;/code&gt; may be deallocated using the &lt;a href=&quot;../alloc/struct.global&quot;&gt;&lt;code&gt;Global&lt;/code&gt;&lt;/a&gt; allocator with &lt;code&gt;Layout::for_value(&amp;amp;*value)&lt;/code&gt;.</source>
          <target state="translated">Para valores de tama&amp;ntilde;o distinto de cero, una &lt;a href=&quot;struct.box&quot;&gt; &lt;code&gt;Box&lt;/code&gt; &lt;/a&gt; utilizar&amp;aacute; el asignador &lt;a href=&quot;../alloc/struct.global&quot;&gt; &lt;code&gt;Global&lt;/code&gt; &lt;/a&gt; para su asignaci&amp;oacute;n. Es v&amp;aacute;lido convertir en ambos sentidos entre una &lt;a href=&quot;struct.box&quot;&gt; &lt;code&gt;Box&lt;/code&gt; &lt;/a&gt; y un puntero sin procesar asignado con el asignador &lt;a href=&quot;../alloc/struct.global&quot;&gt; &lt;code&gt;Global&lt;/code&gt; &lt;/a&gt; , dado que el &lt;a href=&quot;../alloc/struct.layout&quot;&gt; &lt;code&gt;Layout&lt;/code&gt; &lt;/a&gt; utilizado con el asignador es correcto para el tipo. M&amp;aacute;s precisamente, un &lt;code&gt;value: *mut T&lt;/code&gt; que se ha asignado con el asignador &lt;a href=&quot;../alloc/struct.global&quot;&gt; &lt;code&gt;Global&lt;/code&gt; &lt;/a&gt; con &lt;code&gt;Layout::for_value(&amp;amp;*value)&lt;/code&gt; se puede convertir en un cuadro usando &lt;code&gt;Box::&amp;lt;T&amp;gt;::from_raw(value)&lt;/code&gt; . Por el contrario, la memoria que respalda un &lt;code&gt;value: *mut T&lt;/code&gt; obtenido de &lt;code&gt;Box::&amp;lt;T&amp;gt;::into_raw&lt;/code&gt; puede desasignarse usando el &lt;a href=&quot;../alloc/struct.global&quot;&gt; &lt;code&gt;Global&lt;/code&gt; &lt;/a&gt;asignador con &lt;code&gt;Layout::for_value(&amp;amp;*value)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54643b534ba092bdf13786f2ee7895ae533d1d71" translate="yes" xml:space="preserve">
          <source>For now, let&amp;rsquo;s ignore the top two lines and focus on the function to see how it works. Note the &lt;code&gt;#[test]&lt;/code&gt; annotation before the &lt;code&gt;fn&lt;/code&gt; line: this attribute indicates this is a test function, so the test runner knows to treat this function as a test. We could also have non-test functions in the &lt;code&gt;tests&lt;/code&gt; module to help set up common scenarios or perform common operations, so we need to indicate which functions are tests by using the &lt;code&gt;#[test]&lt;/code&gt; attribute.</source>
          <target state="translated">Por ahora, ignoremos las dos l&amp;iacute;neas superiores y centr&amp;eacute;monos en la funci&amp;oacute;n para ver c&amp;oacute;mo funciona. Tenga en cuenta la anotaci&amp;oacute;n &lt;code&gt;#[test]&lt;/code&gt; antes de la l&amp;iacute;nea &lt;code&gt;fn&lt;/code&gt; : este atributo indica que se trata de una funci&amp;oacute;n de prueba, por lo que el ejecutor de pruebas sabe que debe tratar esta funci&amp;oacute;n como una prueba. Tambi&amp;eacute;n podr&amp;iacute;amos tener funciones que no sean de prueba en el m&amp;oacute;dulo de &lt;code&gt;tests&lt;/code&gt; para ayudar a configurar escenarios comunes o realizar operaciones comunes, por lo que debemos indicar qu&amp;eacute; funciones son pruebas mediante el atributo &lt;code&gt;#[test]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e33cfb6813b2ec50a1428dbe54a0333feee6ab7" translate="yes" xml:space="preserve">
          <source>For now, our handling of the stream consists of calling &lt;code&gt;unwrap&lt;/code&gt; to terminate our program if the stream has any errors; if there aren&amp;rsquo;t any errors, the program prints a message. We&amp;rsquo;ll add more functionality for the success case in the next listing. The reason we might receive errors from the &lt;code&gt;incoming&lt;/code&gt; method when a client connects to the server is that we&amp;rsquo;re not actually iterating over connections. Instead, we&amp;rsquo;re iterating over &lt;em&gt;connection attempts&lt;/em&gt;. The connection might not be successful for a number of reasons, many of them operating system specific. For example, many operating systems have a limit to the number of simultaneous open connections they can support; new connection attempts beyond that number will produce an error until some of the open connections are closed.</source>
          <target state="translated">Por ahora, nuestro manejo del flujo consiste en llamar a &lt;code&gt;unwrap&lt;/code&gt; para finalizar nuestro programa si el flujo tiene alg&amp;uacute;n error; si no hay errores, el programa imprime un mensaje. Agregaremos m&amp;aacute;s funcionalidad para el caso de &amp;eacute;xito en la siguiente lista. La raz&amp;oacute;n por la que podemos recibir errores del m&amp;eacute;todo &lt;code&gt;incoming&lt;/code&gt; cuando un cliente se conecta al servidor es que en realidad no estamos iterando sobre las conexiones. En cambio, estamos iterando sobre los &lt;em&gt;intentos de conexi&amp;oacute;n.&lt;/em&gt;. Es posible que la conexi&amp;oacute;n no se realice correctamente por varias razones, muchas de ellas espec&amp;iacute;ficas del sistema operativo. Por ejemplo, muchos sistemas operativos tienen un l&amp;iacute;mite en la cantidad de conexiones abiertas simult&amp;aacute;neas que pueden admitir; los nuevos intentos de conexi&amp;oacute;n m&amp;aacute;s all&amp;aacute; de ese n&amp;uacute;mero producir&amp;aacute;n un error hasta que se cierren algunas de las conexiones abiertas.</target>
        </trans-unit>
        <trans-unit id="a1f6c1be5a9e80f33cd381d2dcb445e8ff860c04" translate="yes" xml:space="preserve">
          <source>For optimal performance, collections will generally avoid shrinking themselves. If you believe that a collection will not soon contain any more elements, or just really need the memory, the &lt;code&gt;shrink_to_fit&lt;/code&gt; method prompts the collection to shrink the backing array to the minimum size capable of holding its elements.</source>
          <target state="translated">Para un rendimiento &amp;oacute;ptimo, las colecciones generalmente evitar&amp;aacute;n encogerse. Si cree que una colecci&amp;oacute;n pronto no contendr&amp;aacute; m&amp;aacute;s elementos, o simplemente necesita la memoria, el m&amp;eacute;todo &lt;code&gt;shrink_to_fit&lt;/code&gt; solicita a la colecci&amp;oacute;n que reduzca la matriz de respaldo al tama&amp;ntilde;o m&amp;iacute;nimo capaz de contener sus elementos.</target>
        </trans-unit>
        <trans-unit id="cd7c16642fc855b86a6681106c12d1bc5cae24fe" translate="yes" xml:space="preserve">
          <source>For other types an index expression &lt;code&gt;a[b]&lt;/code&gt; is equivalent to &lt;code&gt;*std::ops::Index::index(&amp;amp;a, b)&lt;/code&gt;, or &lt;code&gt;*std::ops::IndexMut::index_mut(&amp;amp;mut a, b)&lt;/code&gt; in a mutable place expression context. Just as with methods, Rust will also insert dereference operations on &lt;code&gt;a&lt;/code&gt; repeatedly to find an implementation.</source>
          <target state="translated">Para otros tipos, una expresi&amp;oacute;n de &amp;iacute;ndice &lt;code&gt;a[b]&lt;/code&gt; es equivalente a &lt;code&gt;*std::ops::Index::index(&amp;amp;a, b)&lt;/code&gt; , o &lt;code&gt;*std::ops::IndexMut::index_mut(&amp;amp;mut a, b)&lt;/code&gt; en a contexto de expresi&amp;oacute;n de lugar mutable. Al igual que con los m&amp;eacute;todos, Rust tambi&amp;eacute;n insertar&amp;aacute; operaciones dereference en &lt;code&gt;a&lt;/code&gt; varias veces para encontrar una implementaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="13c849dda2f0ae7e001d50a92c5a1d89fda3d6fe" translate="yes" xml:space="preserve">
          <source>For our final project, we&amp;rsquo;ll make a web server that says &amp;ldquo;hello&amp;rdquo; and looks like Figure 20-1 in a web browser.</source>
          <target state="translated">Para nuestro proyecto final, crearemos un servidor web que diga &quot;hola&quot; y se vea como la Figura 20-1 en un navegador web.</target>
        </trans-unit>
        <trans-unit id="d255769548dbb0d1d2dd3966fe6705e70e8ba063" translate="yes" xml:space="preserve">
          <source>For primitive signed integers (&lt;a href=&quot;../primitive.i8&quot;&gt;&lt;code&gt;i8&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;../primitive.i128&quot;&gt;&lt;code&gt;i128&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../primitive.isize&quot;&gt;&lt;code&gt;isize&lt;/code&gt;&lt;/a&gt;), negative values are formatted as the two&amp;rsquo;s complement representation.</source>
          <target state="translated">Para enteros primitivos con signo ( &lt;a href=&quot;../primitive.i8&quot;&gt; &lt;code&gt;i8&lt;/code&gt; &lt;/a&gt; a &lt;a href=&quot;../primitive.i128&quot;&gt; &lt;code&gt;i128&lt;/code&gt; &lt;/a&gt; e &lt;a href=&quot;../primitive.isize&quot;&gt; &lt;code&gt;isize&lt;/code&gt; &lt;/a&gt; ), los valores negativos se formatean como la representaci&amp;oacute;n del complemento a dos.</target>
        </trans-unit>
        <trans-unit id="aac9f771ea2b1ce33ddd4c4adcf5da0c753c4439" translate="yes" xml:space="preserve">
          <source>For primitive signed integers (&lt;code&gt;i8&lt;/code&gt; to &lt;code&gt;i128&lt;/code&gt;, and &lt;code&gt;isize&lt;/code&gt;), negative values are formatted as the two&amp;rsquo;s complement representation.</source>
          <target state="translated">Para enteros primitivos con signo ( &lt;code&gt;i8&lt;/code&gt; a &lt;code&gt;i128&lt;/code&gt; e &lt;code&gt;isize&lt;/code&gt; ), los valores negativos se formatean como la representaci&amp;oacute;n del complemento a dos.</target>
        </trans-unit>
        <trans-unit id="ce2928dd11d16b979a65e7e0873fbf1de3498202" translate="yes" xml:space="preserve">
          <source>For regions of memory which might overlap, use &lt;a href=&quot;../ptr/fn.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3f7e3e69f692e2801e97c9dcecae515bd256300" translate="yes" xml:space="preserve">
          <source>For regions of memory which might overlap, use &lt;a href=&quot;fn.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Para las regiones de la memoria que pueden superponerse, utilice &lt;a href=&quot;fn.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="699bb35cf747c434fb017049f75ca63a96555a2f" translate="yes" xml:space="preserve">
          <source>For resources in languages other than English. Most are still in progress; see &lt;a href=&quot;https://github.com/rust-lang/book/issues?q=is%3Aopen+is%3Aissue+label%3ATranslations&quot;&gt;the Translations label&lt;/a&gt; to help or let us know about a new translation!</source>
          <target state="translated">Para recursos en idiomas distintos al ingl&amp;eacute;s. La mayor&amp;iacute;a a&amp;uacute;n est&amp;aacute;n en progreso; &amp;iexcl;Consulte &lt;a href=&quot;https://github.com/rust-lang/book/issues?q=is%3Aopen+is%3Aissue+label%3ATranslations&quot;&gt;la etiqueta Traducciones&lt;/a&gt; para ayudarnos o h&amp;aacute;ganos saber sobre una nueva traducci&amp;oacute;n!</target>
        </trans-unit>
        <trans-unit id="b3ace2755d26172c16b8f52be41575cb599f9217" translate="yes" xml:space="preserve">
          <source>For similar reasons, &lt;strong&gt;this trait should never fail&lt;/strong&gt;. Failure during dereferencing can be extremely confusing when &lt;code&gt;Deref&lt;/code&gt; is invoked implicitly.</source>
          <target state="translated">Por razones similares, &lt;strong&gt;este rasgo nunca deber&amp;iacute;a fallar&lt;/strong&gt; . La falla durante la eliminaci&amp;oacute;n de referencias puede ser extremadamente confusa cuando se invoca a &lt;code&gt;Deref&lt;/code&gt; impl&amp;iacute;citamente.</target>
        </trans-unit>
        <trans-unit id="f143a2f7cb6b7d643f9e55d76c2173dbf1fa2576" translate="yes" xml:space="preserve">
          <source>For similar reasons, &lt;strong&gt;this trait should never fail&lt;/strong&gt;. Failure during dereferencing can be extremely confusing when &lt;code&gt;DerefMut&lt;/code&gt; is invoked implicitly.</source>
          <target state="translated">Por razones similares, &lt;strong&gt;este rasgo nunca deber&amp;iacute;a fallar&lt;/strong&gt; . Fallar durante la eliminaci&amp;oacute;n de referencias puede ser extremadamente confuso cuando &lt;code&gt;DerefMut&lt;/code&gt; se invoca impl&amp;iacute;citamente.</target>
        </trans-unit>
        <trans-unit id="651693930e4ce9c887254d6c0684024c66f33563" translate="yes" xml:space="preserve">
          <source>For simple key functions (e.g., functions that are property accesses or basic operations), &lt;a href=&quot;#method.sort_by_key&quot;&gt;&lt;code&gt;sort_by_key&lt;/code&gt;&lt;/a&gt; is likely to be faster.</source>
          <target state="translated">Para funciones de teclas simples (por ejemplo, funciones que son accesos a propiedades u operaciones b&amp;aacute;sicas), es probable que &lt;a href=&quot;#method.sort_by_key&quot;&gt; &lt;code&gt;sort_by_key&lt;/code&gt; &lt;/a&gt; sea ​​m&amp;aacute;s r&amp;aacute;pido.</target>
        </trans-unit>
        <trans-unit id="89523ea381daa16404e1b923b1eb9b76ace1d71b" translate="yes" xml:space="preserve">
          <source>For splitting from the front, the &lt;a href=&quot;#method.splitn&quot;&gt;&lt;code&gt;splitn&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">Para dividir desde el frente, se puede utilizar el m&amp;eacute;todo &lt;a href=&quot;#method.splitn&quot;&gt; &lt;code&gt;splitn&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="11e6e81fe37e9ab31f7eacdfb8dae37e44c66a22" translate="yes" xml:space="preserve">
          <source>For splitting from the front, the &lt;a href=&quot;../primitive.str#method.splitn&quot;&gt;&lt;code&gt;splitn&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3c0abfb259f7386ec06ccced34dac985722f5e3" translate="yes" xml:space="preserve">
          <source>For splitting from the front, the &lt;a href=&quot;primitive.str#method.splitn&quot;&gt;&lt;code&gt;splitn&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ad7e92077f13212fee670b70ee5343cc7564f8c" translate="yes" xml:space="preserve">
          <source>For struct-like enum variants, such as &lt;code&gt;Message::Move&lt;/code&gt;, we can use a pattern similar to the pattern we specify to match structs. After the variant name, we place curly brackets and then list the fields with variables so we break apart the pieces to use in the code for this arm. Here we use the shorthand form as we did in Listing 18-13.</source>
          <target state="translated">Para variantes de enumeraci&amp;oacute;n similares a estructuras, como &lt;code&gt;Message::Move&lt;/code&gt; , podemos usar un patr&amp;oacute;n similar al patr&amp;oacute;n que especificamos para hacer coincidir estructuras. Despu&amp;eacute;s del nombre de la variante, colocamos corchetes y luego enumeramos los campos con variables para separar las piezas para usar en el c&amp;oacute;digo para este brazo. Aqu&amp;iacute; usamos la forma abreviada como hicimos en el Listado 18-13.</target>
        </trans-unit>
        <trans-unit id="5810f8b96156118100100f4ed7849dc0cd2c9c1a" translate="yes" xml:space="preserve">
          <source>For such a small example, a &lt;code&gt;for&lt;/code&gt; loop may be cleaner, but &lt;code&gt;for_each&lt;/code&gt; might be preferable to keep a functional style with longer iterators:</source>
          <target state="translated">Para un ejemplo tan peque&amp;ntilde;o, un bucle &lt;code&gt;for&lt;/code&gt; puede ser m&amp;aacute;s limpio, pero &lt;code&gt;for_each&lt;/code&gt; podr&amp;iacute;a ser preferible para mantener un estilo funcional con iteradores m&amp;aacute;s largos:</target>
        </trans-unit>
        <trans-unit id="e8118375098fa91fd1336cc1a1d200113a068697" translate="yes" xml:space="preserve">
          <source>For the error type, we used the &lt;em&gt;trait object&lt;/em&gt;&lt;code&gt;Box&amp;lt;dyn Error&amp;gt;&lt;/code&gt; (and we&amp;rsquo;ve brought &lt;code&gt;std::error::Error&lt;/code&gt; into scope with a &lt;code&gt;use&lt;/code&gt; statement at the top). We&amp;rsquo;ll cover trait objects in &lt;a href=&quot;ch17-00-oop&quot;&gt;Chapter 17&lt;/a&gt;. For now, just know that &lt;code&gt;Box&amp;lt;dyn Error&amp;gt;&lt;/code&gt; means the function will return a type that implements the &lt;code&gt;Error&lt;/code&gt; trait, but we don&amp;rsquo;t have to specify what particular type the return value will be. This gives us flexibility to return error values that may be of different types in different error cases. The &lt;code&gt;dyn&lt;/code&gt; keyword is short for &amp;ldquo;dynamic.&amp;rdquo;</source>
          <target state="translated">Para el tipo de error, usamos el &lt;em&gt;objeto de rasgo &lt;/em&gt; &lt;code&gt;Box&amp;lt;dyn Error&amp;gt;&lt;/code&gt; (y hemos tra&amp;iacute;do &lt;code&gt;std::error::Error&lt;/code&gt; al alcance con una declaraci&amp;oacute;n de &lt;code&gt;use&lt;/code&gt; en la parte superior). Cubriremos los objetos de rasgo en el &lt;a href=&quot;ch17-00-oop&quot;&gt;Cap&amp;iacute;tulo 17&lt;/a&gt; . Por ahora, solo sepa que &lt;code&gt;Box&amp;lt;dyn Error&amp;gt;&lt;/code&gt; significa que la funci&amp;oacute;n devolver&amp;aacute; un tipo que implementa el rasgo &lt;code&gt;Error&lt;/code&gt; , pero no tenemos que especificar qu&amp;eacute; tipo particular ser&amp;aacute; el valor de retorno. Esto nos da flexibilidad para devolver valores de error que pueden ser de diferentes tipos en diferentes casos de error. La palabra clave &lt;code&gt;dyn&lt;/code&gt; es la abreviatura de &quot;din&amp;aacute;mico&quot;.</target>
        </trans-unit>
        <trans-unit id="ff1e8b621d2f0697fd650c7bd5bdebd31c66d8f4" translate="yes" xml:space="preserve">
          <source>For the first code example, please check the function definition. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3f504eb5407df9eef6d4025ac7f91c4112cc6cf" translate="yes" xml:space="preserve">
          <source>For the full list of configuration options and defaults for each profile, see &lt;a href=&quot;https://doc.rust-lang.org/cargo/index.html&quot;&gt;Cargo&amp;rsquo;s documentation&lt;/a&gt;.</source>
          <target state="translated">Para obtener la lista completa de opciones de configuraci&amp;oacute;n y valores predeterminados para cada perfil, consulte &lt;a href=&quot;https://doc.rust-lang.org/cargo/index.html&quot;&gt;la documentaci&amp;oacute;n de Cargo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="791c57d5635fae5aa217abb12eda43c0b9996769" translate="yes" xml:space="preserve">
          <source>For the full list of configuration options and defaults for each profile, see &lt;a href=&quot;https://doc.rust-lang.org/cargo/reference/profiles.html&quot;&gt;Cargo&amp;rsquo;s documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a68c719c83bfb13b132657f78b2e4ff48741b1d" translate="yes" xml:space="preserve">
          <source>For the implementation of the &lt;code&gt;send&lt;/code&gt; method, the first parameter is still an immutable borrow of &lt;code&gt;self&lt;/code&gt;, which matches the trait definition. We call &lt;code&gt;borrow_mut&lt;/code&gt; on the &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; in &lt;code&gt;self.sent_messages&lt;/code&gt; to get a mutable reference to the value inside the &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt;, which is the vector. Then we can call &lt;code&gt;push&lt;/code&gt; on the mutable reference to the vector to keep track of the messages sent during the test.</source>
          <target state="translated">Para la implementaci&amp;oacute;n del m&amp;eacute;todo de &lt;code&gt;send&lt;/code&gt; , el primer par&amp;aacute;metro sigue siendo un pr&amp;eacute;stamo inmutable de &lt;code&gt;self&lt;/code&gt; , que coincide con la definici&amp;oacute;n del rasgo. Llamamos &lt;code&gt;borrow_mut&lt;/code&gt; en el &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; en &lt;code&gt;self.sent_messages&lt;/code&gt; para obtener una referencia al valor mutable dentro del &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; , que es el vector. Luego podemos llamar a &lt;code&gt;push&lt;/code&gt; en la referencia mutable al vector para realizar un seguimiento de los mensajes enviados durante la prueba.</target>
        </trans-unit>
        <trans-unit id="a95e91b27e6ad6f9ade905d772c0b6782aa828f3" translate="yes" xml:space="preserve">
          <source>For the mutable counterpart see &lt;a href=&quot;#method.as_mut&quot;&gt;&lt;code&gt;as_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d5a9781a149f8d35fca4d184f08a35d9f2cbdac" translate="yes" xml:space="preserve">
          <source>For the mutable counterpart see &lt;a href=&quot;#method.as_uninit_mut&quot;&gt;&lt;code&gt;as_uninit_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1f973a0bac5133bff0149357edc17c4cb290249" translate="yes" xml:space="preserve">
          <source>For the mutable counterpart see &lt;a href=&quot;#method.as_uninit_slice_mut&quot;&gt;&lt;code&gt;as_uninit_slice_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07082323caa609052dde906dbd2a21a1ab51cf54" translate="yes" xml:space="preserve">
          <source>For the mutable counterpart see &lt;a href=&quot;struct.nonnull#method.as_mut&quot;&gt;&lt;code&gt;as_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69d924fe0e8c1a5d61d0c3d9dd1c49bf7a0308ea" translate="yes" xml:space="preserve">
          <source>For the mutable counterpart see &lt;a href=&quot;struct.nonnull#method.as_uninit_mut&quot;&gt;&lt;code&gt;as_uninit_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fd7465e0cdaff95e9a716e4a710191845a70f5d" translate="yes" xml:space="preserve">
          <source>For the mutable counterpart see &lt;a href=&quot;struct.nonnull#method.as_uninit_slice_mut&quot;&gt;&lt;code&gt;as_uninit_slice_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91c42187d149ce3b9fc55c3ad6f30f4360a292d3" translate="yes" xml:space="preserve">
          <source>For the platform's canonical successful and unsuccessful codes, see the &lt;a href=&quot;#associatedconstant.SUCCESS&quot;&gt;&lt;code&gt;SUCCESS&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#associatedconstant.FAILURE&quot;&gt;&lt;code&gt;FAILURE&lt;/code&gt;&lt;/a&gt; associated items.</source>
          <target state="translated">Para conocer los c&amp;oacute;digos can&amp;oacute;nicos exitosos y no exitosos de la plataforma, consulte los elementos asociados &lt;a href=&quot;#associatedconstant.SUCCESS&quot;&gt; &lt;code&gt;SUCCESS&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#associatedconstant.FAILURE&quot;&gt; &lt;code&gt;FAILURE&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="75db543c6e1cfda586f4db237fb2c670d25637f5" translate="yes" xml:space="preserve">
          <source>For the platform's canonical successful and unsuccessful codes, see the &lt;a href=&quot;struct.exitcode#associatedconstant.SUCCESS&quot;&gt;&lt;code&gt;SUCCESS&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.exitcode#associatedconstant.FAILURE&quot;&gt;&lt;code&gt;FAILURE&lt;/code&gt;&lt;/a&gt; associated items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e0af3f991c9f15f8f69d15c2eea87200f2b169c" translate="yes" xml:space="preserve">
          <source>For the reason why this trait is marked unsafe, see them parent trait &lt;a href=&quot;trait.searcher&quot;&gt;&lt;code&gt;Searcher&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9754d4ead8c14d2fd33aefe3de619c365fcc229c" translate="yes" xml:space="preserve">
          <source>For the reason why this trait is marked unsafe, see them parent trait &lt;code&gt;Searcher&lt;/code&gt;.</source>
          <target state="translated">Por la raz&amp;oacute;n por la que este rasgo est&amp;aacute; marcado como inseguro, v&amp;eacute;alos en el &lt;code&gt;Searcher&lt;/code&gt; rasgos parentales .</target>
        </trans-unit>
        <trans-unit id="317df28410901f8510f7434f828ef3205b9a7b8a" translate="yes" xml:space="preserve">
          <source>For the shared counterpart see &lt;a href=&quot;#method.as_ref-1&quot;&gt;&lt;code&gt;as_ref&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be46a34ce569130657543d5be99d0ffccac5f531" translate="yes" xml:space="preserve">
          <source>For the shared counterpart see &lt;a href=&quot;#method.as_uninit_ref-1&quot;&gt;&lt;code&gt;as_uninit_ref&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33c7d626908c572a51181ace97075c3c7c164cf4" translate="yes" xml:space="preserve">
          <source>For the shared counterpart see &lt;a href=&quot;#method.as_uninit_slice-1&quot;&gt;&lt;code&gt;as_uninit_slice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d048329557c415195915c976f34b9b3ebb4d30b" translate="yes" xml:space="preserve">
          <source>For the shared counterpart see &lt;a href=&quot;struct.nonnull#method.as_ref&quot;&gt;&lt;code&gt;as_ref&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbea4cb29a600931bdca0544ec0671b19cb48983" translate="yes" xml:space="preserve">
          <source>For the shared counterpart see &lt;a href=&quot;struct.nonnull#method.as_uninit_ref&quot;&gt;&lt;code&gt;as_uninit_ref&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ddf9342b49f23e6ec0f7fb2b4028f00c98f3be6" translate="yes" xml:space="preserve">
          <source>For the shared counterpart see &lt;a href=&quot;struct.nonnull#method.as_uninit_slice&quot;&gt;&lt;code&gt;as_uninit_slice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e95ec06cdfac6e068dc9366f7700758986e2c5a" translate="yes" xml:space="preserve">
          <source>For the third example, when you match, all patterns must have the same type as the type you're matching on. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0fe8928fd32097dac9b918311b6eac0fcf339ce" translate="yes" xml:space="preserve">
          <source>For these reasons, Rust takes a different approach, using trait objects instead of inheritance. Let&amp;rsquo;s look at how trait objects enable polymorphism in Rust.</source>
          <target state="translated">Por estas razones, Rust adopta un enfoque diferente, utilizando objetos de rasgo en lugar de herencia. Veamos c&amp;oacute;mo los objetos de rasgo habilitan el polimorfismo en Rust.</target>
        </trans-unit>
        <trans-unit id="4710b0aeb278b541ab02b2df0abed515f474e4d8" translate="yes" xml:space="preserve">
          <source>For this reason, match arms must use refutable patterns, except for the last arm, which should match any remaining values with an irrefutable pattern. Rust allows us to use an irrefutable pattern in a &lt;code&gt;match&lt;/code&gt; with only one arm, but this syntax isn&amp;rsquo;t particularly useful and could be replaced with a simpler &lt;code&gt;let&lt;/code&gt; statement.</source>
          <target state="translated">Por esta raz&amp;oacute;n, los brazos de coincidencia deben usar patrones refutables, excepto el &amp;uacute;ltimo brazo, que debe coincidir con los valores restantes con un patr&amp;oacute;n irrefutable. Rust nos permite usar un patr&amp;oacute;n irrefutable en una &lt;code&gt;match&lt;/code&gt; con un solo brazo, pero esta sintaxis no es particularmente &amp;uacute;til y podr&amp;iacute;a reemplazarse con una declaraci&amp;oacute;n &lt;code&gt;let&lt;/code&gt; m&amp;aacute;s simple .</target>
        </trans-unit>
        <trans-unit id="adfc989e88bb9c8c7181782f55b50dfadfa83f21" translate="yes" xml:space="preserve">
          <source>For this to work, some note must be specified. An empty attribute will not do anything, please remove the attribute or add some helpful note for users of the trait.</source>
          <target state="translated">Para que esto funcione,debe especificarse alguna nota.Un atributo vacío no hará nada,por favor,elimine el atributo o añada alguna nota útil para los usuarios del rasgo.</target>
        </trans-unit>
        <trans-unit id="04f657de0e5284c90b3775d6f50f0f7a8ada21dc" translate="yes" xml:space="preserve">
          <source>For this, the impl of &lt;a href=&quot;trait.searcher&quot;&gt;&lt;code&gt;Searcher&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.reversesearcher&quot;&gt;&lt;code&gt;ReverseSearcher&lt;/code&gt;&lt;/a&gt; need to follow these conditions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd561ec2ce563662749407f0433b939f5ebe794d" translate="yes" xml:space="preserve">
          <source>For this, the impl of &lt;code&gt;Searcher&lt;/code&gt; and &lt;code&gt;ReverseSearcher&lt;/code&gt; need to follow these conditions:</source>
          <target state="translated">Para ello, el impl de &lt;code&gt;Searcher&lt;/code&gt; y &lt;code&gt;ReverseSearcher&lt;/code&gt; deben seguir estas condiciones:</target>
        </trans-unit>
        <trans-unit id="97ccae7172bda964374e1bc586c6572634aaa703" translate="yes" xml:space="preserve">
          <source>For those developing Rust, a new edition provides a rallying point for the project as a whole.</source>
          <target state="translated">Para aquellos que desarrollan Rust,una nueva edición proporciona un punto de encuentro para el proyecto en su conjunto.</target>
        </trans-unit>
        <trans-unit id="2fec446383d5f779e4c9aee400f1c7e1dddccd01" translate="yes" xml:space="preserve">
          <source>For those familiar with pointers, a reference is just a pointer that is assumed to be aligned, not null, and pointing to memory containing a valid value of &lt;code&gt;T&lt;/code&gt; - for example, &lt;code&gt;&amp;amp;bool&lt;/code&gt; can only point to an allocation containing the integer values &lt;code&gt;1&lt;/code&gt; (&lt;code&gt;true&lt;/code&gt;) or &lt;code&gt;0&lt;/code&gt; (&lt;code&gt;false&lt;/code&gt;), but creating a &lt;code&gt;&amp;amp;bool&lt;/code&gt; that points to an allocation containing the value &lt;code&gt;3&lt;/code&gt; causes undefined behaviour. In fact, &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; has the same memory representation as a nullable but aligned pointer, and can be passed across FFI boundaries as such.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6ace4ab9caa4dbb7631dba10e9c44e719dfc96f" translate="yes" xml:space="preserve">
          <source>For those familiar with pointers, a reference is just a pointer that is assumed to not be null. In fact, &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; has the same memory representation as a nullable pointer, and can be passed across FFI boundaries as such.</source>
          <target state="translated">Para aquellos familiarizados con los punteros, una referencia es solo un puntero que se supone que no es nulo. De hecho, &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; tiene la misma representaci&amp;oacute;n de memoria que un puntero que acepta valores NULL y se puede pasar a trav&amp;eacute;s de los l&amp;iacute;mites de FFI como tal.</target>
        </trans-unit>
        <trans-unit id="9aa62047cd03d84d541773dd2bfd34515672a0a9" translate="yes" xml:space="preserve">
          <source>For tuple-like enum variants, like &lt;code&gt;Message::Write&lt;/code&gt; that holds a tuple with one element and &lt;code&gt;Message::ChangeColor&lt;/code&gt; that holds a tuple with three elements, the pattern is similar to the pattern we specify to match tuples. The number of variables in the pattern must match the number of elements in the variant we&amp;rsquo;re matching.</source>
          <target state="translated">Para variantes de enumeraci&amp;oacute;n tipo tupla, como &lt;code&gt;Message::Write&lt;/code&gt; que contiene una tupla con un elemento y &lt;code&gt;Message::ChangeColor&lt;/code&gt; que contiene una tupla con tres elementos, el patr&amp;oacute;n es similar al patr&amp;oacute;n que especificamos para hacer coincidir las tuplas. El n&amp;uacute;mero de variables en el patr&amp;oacute;n debe coincidir con el n&amp;uacute;mero de elementos de la variante que estamos haciendo coincidir.</target>
        </trans-unit>
        <trans-unit id="aafd656a28f0a9eb0c651ab2742e994b8d5c6d74" translate="yes" xml:space="preserve">
          <source>For types that implement &lt;code&gt;Copy&lt;/code&gt;, the &lt;code&gt;get&lt;/code&gt; method retrieves the current interior value.</source>
          <target state="translated">Para los tipos que implementan &lt;code&gt;Copy&lt;/code&gt; , el m&amp;eacute;todo &lt;code&gt;get&lt;/code&gt; recupera el valor interior actual.</target>
        </trans-unit>
        <trans-unit id="ec453568d8f91af81c4edd923841e5de4ffcf536" translate="yes" xml:space="preserve">
          <source>For types that implement &lt;code&gt;Default&lt;/code&gt;, the &lt;code&gt;take&lt;/code&gt; method replaces the current interior value with &lt;code&gt;Default::default()&lt;/code&gt; and returns the replaced value.</source>
          <target state="translated">Para los tipos que implementan &lt;code&gt;Default&lt;/code&gt; , el m&amp;eacute;todo &lt;code&gt;take&lt;/code&gt; reemplaza el valor interior actual con &lt;code&gt;Default::default()&lt;/code&gt; y devuelve el valor reemplazado.</target>
        </trans-unit>
        <trans-unit id="4574e9c5392d2a058aa0fe0986ed5ef30945f81c" translate="yes" xml:space="preserve">
          <source>For types that implement the &lt;code&gt;Copy&lt;/code&gt; trait, like &lt;code&gt;i32&lt;/code&gt;, the values are copied into the hash map. For owned values like &lt;code&gt;String&lt;/code&gt;, the values will be moved and the hash map will be the owner of those values, as demonstrated in Listing 8-22.</source>
          <target state="translated">Para los tipos que implementan el rasgo &lt;code&gt;Copy&lt;/code&gt; , como &lt;code&gt;i32&lt;/code&gt; , los valores se copian en el mapa hash. Para valores de propiedad como &lt;code&gt;String&lt;/code&gt; , los valores se mover&amp;aacute;n y el mapa hash ser&amp;aacute; el propietario de esos valores, como se muestra en el Listado 8-22.</target>
        </trans-unit>
        <trans-unit id="bbf61af8911febf6c19fe2a100148eac8f5a6b3d" translate="yes" xml:space="preserve">
          <source>For zero-sized &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;n == 0&lt;/code&gt;, may return either of &lt;code&gt;Ok&lt;/code&gt; or &lt;code&gt;Err&lt;/code&gt;, but will &lt;em&gt;not&lt;/em&gt; yield undefined behavior.</source>
          <target state="translated">Para cero de tama&amp;ntilde;o &lt;code&gt;T&lt;/code&gt; o &lt;code&gt;n == 0&lt;/code&gt; , puede devolver cualquiera de &lt;code&gt;Ok&lt;/code&gt; o &lt;code&gt;Err&lt;/code&gt; , pero ser&amp;aacute; &lt;em&gt;no&lt;/em&gt; producir un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="af9ebebeac598bb279c7f6871c1d2e5ff692e690" translate="yes" xml:space="preserve">
          <source>For zero-sized &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;n_new == 0&lt;/code&gt;, may return either of &lt;code&gt;Ok&lt;/code&gt; or &lt;code&gt;Err&lt;/code&gt;, but will &lt;em&gt;not&lt;/em&gt; yield undefined behavior.</source>
          <target state="translated">Para &lt;code&gt;T&lt;/code&gt; de tama&amp;ntilde;o cero o &lt;code&gt;n_new == 0&lt;/code&gt; , puede devolver &lt;code&gt;Ok&lt;/code&gt; o &lt;code&gt;Err&lt;/code&gt; , pero &lt;em&gt;no&lt;/em&gt; producir&amp;aacute; un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="d17558f17d3ddd4a1525907aa24c803b6d14144e" translate="yes" xml:space="preserve">
          <source>For zero-sized &lt;code&gt;T&lt;/code&gt;, may return either of &lt;code&gt;Ok&lt;/code&gt; or &lt;code&gt;Err&lt;/code&gt;, but will &lt;em&gt;not&lt;/em&gt; yield undefined behavior.</source>
          <target state="translated">Para &lt;code&gt;T&lt;/code&gt; de tama&amp;ntilde;o cero , puede devolver &lt;code&gt;Ok&lt;/code&gt; o &lt;code&gt;Err&lt;/code&gt; , pero &lt;em&gt;no&lt;/em&gt; producir&amp;aacute; un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="0ed657cacf2452e2d4d87aa4e0d79c2d3adc9373" translate="yes" xml:space="preserve">
          <source>For zero-sized values, the &lt;code&gt;Box&lt;/code&gt; pointer still has to be &lt;a href=&quot;../ptr/index#safety&quot;&gt;valid&lt;/a&gt; for reads and writes and sufficiently aligned. In particular, casting any aligned non-zero integer literal to a raw pointer produces a valid pointer, but a pointer pointing into previously allocated memory that since got freed is not valid. The recommended way to build a Box to a ZST if &lt;code&gt;Box::new&lt;/code&gt; cannot be used is to use &lt;a href=&quot;../ptr/struct.nonnull#method.dangling&quot;&gt;&lt;code&gt;ptr::NonNull::dangling&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff122858fad706f1ffd37eb8ed4d2f766a5f5467" translate="yes" xml:space="preserve">
          <source>Forces the child process to exit. If the child has already exited, an &lt;a href=&quot;../io/enum.errorkind#variant.InvalidInput&quot;&gt;&lt;code&gt;InvalidInput&lt;/code&gt;&lt;/a&gt; error is returned.</source>
          <target state="translated">Obliga al proceso hijo a salir. Si el ni&amp;ntilde;o ya sali&amp;oacute;, se &lt;a href=&quot;../io/enum.errorkind#variant.InvalidInput&quot;&gt; &lt;code&gt;InvalidInput&lt;/code&gt; &lt;/a&gt; un error InvalidInput .</target>
        </trans-unit>
        <trans-unit id="6018bb8b2d8928af0c1e3c1dd75506aa08720534" translate="yes" xml:space="preserve">
          <source>Forces the evaluation of this lazy value and returns a reference to result. This is equivalent to the &lt;code&gt;Deref&lt;/code&gt; impl, but is explicit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="978264598af5c4bf8957f52229b3577a194aae8b" translate="yes" xml:space="preserve">
          <source>Forces the evaluation of this lazy value and returns a reference to the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c60cb66cd46faeac62256677171f90f9aab99b37" translate="yes" xml:space="preserve">
          <source>Forces the length of the vector to &lt;code&gt;new_len&lt;/code&gt;.</source>
          <target state="translated">Fuerza la longitud del vector a &lt;code&gt;new_len&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d9370d24ba125a97c3acc14af7d6d55608591f2" translate="yes" xml:space="preserve">
          <source>Forcibly captures a disabled backtrace, regardless of environment variable configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b736a57c50ca69a743556a035e80056efa69db13" translate="yes" xml:space="preserve">
          <source>Forcibly captures a full backtrace, regardless of environment variable configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a683f099c5cd32d972be2f3a92f5a845ceb5fd5" translate="yes" xml:space="preserve">
          <source>Foreword</source>
          <target state="translated">Foreword</target>
        </trans-unit>
        <trans-unit id="863ae1b2291a228e3b8c16c150fe043e32bd712d" translate="yes" xml:space="preserve">
          <source>Formally, the equality must be (for all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;):</source>
          <target state="translated">Formalmente, la igualdad debe ser (para todos &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , y &lt;code&gt;c&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="f923413c464f494d3946508ce5aa107762608185" translate="yes" xml:space="preserve">
          <source>Format the program and arguments of a Command for display. Any non-utf8 data is lossily converted using the utf8 replacement character.</source>
          <target state="translated">Formatee el programa y los argumentos de un comando para su visualización.Cualquier dato que no sea utf8 se convierte con pérdida usando el carácter de reemplazo utf8.</target>
        </trans-unit>
        <trans-unit id="140d331380e094ef881c81486bb2b41687984370" translate="yes" xml:space="preserve">
          <source>Format trait for an empty format, &lt;code&gt;{}&lt;/code&gt;.</source>
          <target state="translated">Rasgo de formato para un formato vac&amp;iacute;o, &lt;code&gt;{}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6eb3be022b65dd3036c2394343c5d04639125d42" translate="yes" xml:space="preserve">
          <source>Formats the value using the given formatter.</source>
          <target state="translated">Formatea el valor utilizando el formato dado.</target>
        </trans-unit>
        <trans-unit id="5e15b9e7259e75f0fde9e02ca48db7008320ae92" translate="yes" xml:space="preserve">
          <source>Formats the value using the given formatter. &lt;a href=&quot;../../../fmt/trait.debug#tymethod.fmt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Formatea el valor usando el formateador dado. &lt;a href=&quot;../../../fmt/trait.debug#tymethod.fmt&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3864f640d862bc0209e506aa2fd5d8114b920b88" translate="yes" xml:space="preserve">
          <source>Formats the value using the given formatter. &lt;a href=&quot;../../fmt/trait.debug#tymethod.fmt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Formatea el valor usando el formateador dado. &lt;a href=&quot;../../fmt/trait.debug#tymethod.fmt&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="891ad2cdac8c5121fa8020663e91799426bda036" translate="yes" xml:space="preserve">
          <source>Formats the value using the given formatter. &lt;a href=&quot;../../fmt/trait.display#tymethod.fmt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Formatea el valor usando el formateador dado. &lt;a href=&quot;../../fmt/trait.display#tymethod.fmt&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="22b050e95494640f18b8653fa928145e7860a473" translate="yes" xml:space="preserve">
          <source>Formats the value using the given formatter. &lt;a href=&quot;../fmt/trait.debug#tymethod.fmt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Formatea el valor usando el formateador dado. &lt;a href=&quot;../fmt/trait.debug#tymethod.fmt&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ce70014ec2bb51274cea17fec1b3f94b02c50aa6" translate="yes" xml:space="preserve">
          <source>Formats the value using the given formatter. &lt;a href=&quot;../fmt/trait.display#tymethod.fmt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Formatea el valor usando el formateador dado. &lt;a href=&quot;../fmt/trait.display#tymethod.fmt&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fdf24f4d118b813631e61dbcdfc4c5c165a520a0" translate="yes" xml:space="preserve">
          <source>Formats the value using the given formatter. &lt;a href=&quot;fmt/trait.debug#tymethod.fmt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Formatea el valor usando el formateador dado. &lt;a href=&quot;fmt/trait.debug#tymethod.fmt&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="87c49f82e8dbca91bb2bb8879fec94750d470c75" translate="yes" xml:space="preserve">
          <source>Formats the value using the given formatter. &lt;a href=&quot;fmt/trait.display#tymethod.fmt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Formatea el valor usando el formateador dado. &lt;a href=&quot;fmt/trait.display#tymethod.fmt&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f5cc6401fc7f1f08cc68b76776fcc845c5120ae5" translate="yes" xml:space="preserve">
          <source>Formats the value using the given formatter. &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Formatea el valor usando el formateador dado. &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="67729135661825a254f0d83fb3dccb9f72a3be19" translate="yes" xml:space="preserve">
          <source>Formats the value using the given formatter. &lt;a href=&quot;trait.display#tymethod.fmt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Formatea el valor usando el formateador dado. &lt;a href=&quot;trait.display#tymethod.fmt&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1ae42b52d64655839743c546b646a36f423ad845" translate="yes" xml:space="preserve">
          <source>Formatter</source>
          <target state="translated">Formatter</target>
        </trans-unit>
        <trans-unit id="5f8152f579616a1e2e7f90e547a18b826268e31e" translate="yes" xml:space="preserve">
          <source>Formatter::align</source>
          <target state="translated">Formatter::align</target>
        </trans-unit>
        <trans-unit id="9a6def787783ae143ee16edccd5c0a001ed91243" translate="yes" xml:space="preserve">
          <source>Formatter::alternate</source>
          <target state="translated">Formatter::alternate</target>
        </trans-unit>
        <trans-unit id="4ff01afb51f457cc2d85ff4291e6511c069e18e7" translate="yes" xml:space="preserve">
          <source>Formatter::borrow</source>
          <target state="translated">Formatter::borrow</target>
        </trans-unit>
        <trans-unit id="5d337fb59b434ef65405e46b43dd9298cf7d28ce" translate="yes" xml:space="preserve">
          <source>Formatter::borrow_mut</source>
          <target state="translated">Formatter::borrow_mut</target>
        </trans-unit>
        <trans-unit id="423e00ac2e2adbcb9bbef0b2b89bfd31aee767fd" translate="yes" xml:space="preserve">
          <source>Formatter::debug_list</source>
          <target state="translated">Formatter::debug_list</target>
        </trans-unit>
        <trans-unit id="2d2789bd6c0bf82cab25262ef760ac2db9d9dd87" translate="yes" xml:space="preserve">
          <source>Formatter::debug_map</source>
          <target state="translated">Formatter::debug_map</target>
        </trans-unit>
        <trans-unit id="a9ccdf007c23e02e293201f75e9a5c875ae07f89" translate="yes" xml:space="preserve">
          <source>Formatter::debug_set</source>
          <target state="translated">Formatter::debug_set</target>
        </trans-unit>
        <trans-unit id="71c2bd0a8b48dfeec742af4daf6fb65d4f40ffc9" translate="yes" xml:space="preserve">
          <source>Formatter::debug_struct</source>
          <target state="translated">Formatter::debug_struct</target>
        </trans-unit>
        <trans-unit id="00c1bd1d6a90da612560b76c5bf3d45e6291fc98" translate="yes" xml:space="preserve">
          <source>Formatter::debug_tuple</source>
          <target state="translated">Formatter::debug_tuple</target>
        </trans-unit>
        <trans-unit id="6fc7f1045521e6b9d4ff4360c00a2593331911c9" translate="yes" xml:space="preserve">
          <source>Formatter::fill</source>
          <target state="translated">Formatter::fill</target>
        </trans-unit>
        <trans-unit id="993174c205f2615b87f6bd9b99a1f83db77e9d92" translate="yes" xml:space="preserve">
          <source>Formatter::flags</source>
          <target state="translated">Formatter::flags</target>
        </trans-unit>
        <trans-unit id="1de3e4496f08f380dafc2f2099cb602dae373966" translate="yes" xml:space="preserve">
          <source>Formatter::from</source>
          <target state="translated">Formatter::from</target>
        </trans-unit>
        <trans-unit id="f20f7b5d51f57e44b5ca6cd8ab62bf45261e1970" translate="yes" xml:space="preserve">
          <source>Formatter::into</source>
          <target state="translated">Formatter::into</target>
        </trans-unit>
        <trans-unit id="8d6e0f2524599a9851fc44585f5a2d817e72ae6d" translate="yes" xml:space="preserve">
          <source>Formatter::pad</source>
          <target state="translated">Formatter::pad</target>
        </trans-unit>
        <trans-unit id="ac6ba2e959a06c5071bcc16b886f8d5d6cd7965f" translate="yes" xml:space="preserve">
          <source>Formatter::pad_integral</source>
          <target state="translated">Formatter::pad_integral</target>
        </trans-unit>
        <trans-unit id="2403b952317411744ba831a429e9297ab1c0e3b2" translate="yes" xml:space="preserve">
          <source>Formatter::precision</source>
          <target state="translated">Formatter::precision</target>
        </trans-unit>
        <trans-unit id="1f3d9e3d7faa47d0e222f72c63a039a75dc5c805" translate="yes" xml:space="preserve">
          <source>Formatter::sign_aware_zero_pad</source>
          <target state="translated">Formatter::sign_aware_zero_pad</target>
        </trans-unit>
        <trans-unit id="4177fcc3cea65ad6e0c1467fe2213bc4804199f2" translate="yes" xml:space="preserve">
          <source>Formatter::sign_minus</source>
          <target state="translated">Formatter::sign_minus</target>
        </trans-unit>
        <trans-unit id="29a954cef5d969b0ffeda4cda9b1e514ed59e128" translate="yes" xml:space="preserve">
          <source>Formatter::sign_plus</source>
          <target state="translated">Formatter::sign_plus</target>
        </trans-unit>
        <trans-unit id="4109341d852a7ae64ee2861415e3d2d47fd3985d" translate="yes" xml:space="preserve">
          <source>Formatter::try_from</source>
          <target state="translated">Formatter::try_from</target>
        </trans-unit>
        <trans-unit id="c7ea88c068c207062576e99264d8fe9db762e2ba" translate="yes" xml:space="preserve">
          <source>Formatter::try_into</source>
          <target state="translated">Formatter::try_into</target>
        </trans-unit>
        <trans-unit id="0770a06c1590caabbc6a280181ab045268a48d8b" translate="yes" xml:space="preserve">
          <source>Formatter::type_id</source>
          <target state="translated">Formatter::type_id</target>
        </trans-unit>
        <trans-unit id="0513c6c9a8b654eb3c836130d1141c065212130f" translate="yes" xml:space="preserve">
          <source>Formatter::width</source>
          <target state="translated">Formatter::width</target>
        </trans-unit>
        <trans-unit id="784e355bd41c9f5795702e1d4aa5cf5a90fcf70e" translate="yes" xml:space="preserve">
          <source>Formatter::write_char</source>
          <target state="translated">Formatter::write_char</target>
        </trans-unit>
        <trans-unit id="75462a0bc374b0c8071f850b3b54b93abf9106a0" translate="yes" xml:space="preserve">
          <source>Formatter::write_fmt</source>
          <target state="translated">Formatter::write_fmt</target>
        </trans-unit>
        <trans-unit id="b1c405b0e91eb401eaac8c2242a8de1a2f4c813d" translate="yes" xml:space="preserve">
          <source>Formatter::write_str</source>
          <target state="translated">Formatter::write_str</target>
        </trans-unit>
        <trans-unit id="177933136546eb5ae389ea27da971803b35a5e96" translate="yes" xml:space="preserve">
          <source>Formatting Parameters</source>
          <target state="translated">Parámetros de formato</target>
        </trans-unit>
        <trans-unit id="0e705959b12f9001f69d3fd6ef3e8868e1a3fcac" translate="yes" xml:space="preserve">
          <source>Formatting traits</source>
          <target state="translated">Rasgos de formato</target>
        </trans-unit>
        <trans-unit id="210abaf17ff3ec5eb2c7af6e5b16de32d6e6ae30" translate="yes" xml:space="preserve">
          <source>Forms a raw slice from a pointer and a length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea94791ea16dd8ff76446a6806bef950d2a35dda" translate="yes" xml:space="preserve">
          <source>Forms a slice from a pointer and a length.</source>
          <target state="translated">Forma una rebanada de un puntero y una longitud.</target>
        </trans-unit>
        <trans-unit id="06be2fafa00fc2fe5a6c9c357e8e8125e9d52b63" translate="yes" xml:space="preserve">
          <source>Forms of conditional compilation</source>
          <target state="translated">Formas de compilación condicional</target>
        </trans-unit>
        <trans-unit id="95db96d50ddd63cc755c744c881b8149aa6240cb" translate="yes" xml:space="preserve">
          <source>Fortunately, &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;em&gt;is&lt;/em&gt; a type like &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; that is safe to use in concurrent situations. The &lt;em&gt;a&lt;/em&gt; stands for &lt;em&gt;atomic&lt;/em&gt;, meaning it&amp;rsquo;s an &lt;em&gt;atomically reference counted&lt;/em&gt; type. Atomics are an additional kind of concurrency primitive that we won&amp;rsquo;t cover in detail here: see the standard library documentation for &lt;a href=&quot;../std/sync/atomic/index&quot;&gt;&lt;code&gt;std::sync::atomic&lt;/code&gt;&lt;/a&gt; for more details. At this point, you just need to know that atomics work like primitive types but are safe to share across threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d73377b70640496419f6407086a0d313c7e7ff8" translate="yes" xml:space="preserve">
          <source>Fortunately, &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;em&gt;is&lt;/em&gt; a type like &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; that is safe to use in concurrent situations. The &lt;em&gt;a&lt;/em&gt; stands for &lt;em&gt;atomic&lt;/em&gt;, meaning it&amp;rsquo;s an &lt;em&gt;atomically reference counted&lt;/em&gt; type. Atomics are an additional kind of concurrency primitive that we won&amp;rsquo;t cover in detail here: see the standard library documentation for &lt;code&gt;std::sync::atomic&lt;/code&gt; for more details. At this point, you just need to know that atomics work like primitive types but are safe to share across threads.</source>
          <target state="translated">Afortunadamente, &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;em&gt;es&lt;/em&gt; un tipo como &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; que es seguro de usar en situaciones concurrentes. La &lt;em&gt;a&lt;/em&gt; significa &lt;em&gt;at&amp;oacute;mico&lt;/em&gt; , lo que significa que es un tipo &lt;em&gt;contado de referencia at&amp;oacute;mica&lt;/em&gt; . Los at&amp;oacute;micos son un tipo adicional de primitiva de concurrencia que no cubriremos en detalle aqu&amp;iacute;: consulte la documentaci&amp;oacute;n de la biblioteca est&amp;aacute;ndar para &lt;code&gt;std::sync::atomic&lt;/code&gt; para obtener m&amp;aacute;s detalles. En este punto, solo necesita saber que los at&amp;oacute;micos funcionan como tipos primitivos, pero es seguro compartirlos entre subprocesos.</target>
        </trans-unit>
        <trans-unit id="666085c7aedfa1058109fb338307fe9135fa126f" translate="yes" xml:space="preserve">
          <source>Fortunately, Rust provides another, more reliable way to break out of a loop. You can place the &lt;code&gt;break&lt;/code&gt; keyword within the loop to tell the program when to stop executing the loop. Recall that we did this in the guessing game in the &lt;a href=&quot;ch02-00-guessing-game-tutorial#quitting-after-a-correct-guess&quot;&gt;&amp;ldquo;Quitting After a Correct Guess&amp;rdquo;&lt;/a&gt; section of Chapter 2 to exit the program when the user won the game by guessing the correct number.</source>
          <target state="translated">Afortunadamente, Rust proporciona otra forma m&amp;aacute;s confiable de salir de un bucle. Puede colocar la palabra clave &lt;code&gt;break&lt;/code&gt; dentro del bucle para indicarle al programa cu&amp;aacute;ndo dejar de ejecutar el bucle. Recuerde que hicimos esto en el juego de adivinanzas en la secci&amp;oacute;n &lt;a href=&quot;ch02-00-guessing-game-tutorial#quitting-after-a-correct-guess&quot;&gt;&quot;&lt;/a&gt; Salir despu&amp;eacute;s de una suposici&amp;oacute;n correcta&quot; del Cap&amp;iacute;tulo 2 para salir del programa cuando el usuario gan&amp;oacute; el juego adivinando el n&amp;uacute;mero correcto.</target>
        </trans-unit>
        <trans-unit id="2cb7a99620b68db8c37724516fdd41d698381b5f" translate="yes" xml:space="preserve">
          <source>Fortunately, another solution is available to us. We can create a struct that will hold the closure and the resulting value of calling the closure. The struct will execute the closure only if we need the resulting value, and it will cache the resulting value so the rest of our code doesn&amp;rsquo;t have to be responsible for saving and reusing the result. You may know this pattern as &lt;em&gt;memoization&lt;/em&gt; or &lt;em&gt;lazy evaluation&lt;/em&gt;.</source>
          <target state="translated">Afortunadamente, tenemos otra soluci&amp;oacute;n. Podemos crear una estructura que contendr&amp;aacute; el cierre y el valor resultante de llamar al cierre. La estructura ejecutar&amp;aacute; el cierre solo si necesitamos el valor resultante, y almacenar&amp;aacute; en cach&amp;eacute; el valor resultante para que el resto de nuestro c&amp;oacute;digo no tenga que ser responsable de guardar y reutilizar el resultado. Es posible que conozca este patr&amp;oacute;n como &lt;em&gt;memorizaci&amp;oacute;n&lt;/em&gt; o &lt;em&gt;evaluaci&amp;oacute;n perezosa&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f7a735d42f1842468e27de670a61d95c695c7d77" translate="yes" xml:space="preserve">
          <source>Fortunately, you can access elements in a string in other ways.</source>
          <target state="translated">Afortunadamente,se puede acceder a los elementos de una cadena de otras maneras.</target>
        </trans-unit>
        <trans-unit id="26c62d0f8742a3291654c368905359570c6ea25b" translate="yes" xml:space="preserve">
          <source>Forwards to the method defined on the type &lt;code&gt;Any&lt;/code&gt;.</source>
          <target state="translated">Reenv&amp;iacute;a al m&amp;eacute;todo definido en el tipo &lt;code&gt;Any&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24cfeaa5136f131a42d0f730ceb00f25ca26cc8d" translate="yes" xml:space="preserve">
          <source>Forwards to the method defined on the type &lt;code&gt;dyn Error&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0679572252c2b655ac576ff11e583e4913c131ee" translate="yes" xml:space="preserve">
          <source>Fourth, we end the line with a semicolon (&lt;code&gt;;&lt;/code&gt;), which indicates that this expression is over and the next one is ready to begin. Most lines of Rust code end with a semicolon.</source>
          <target state="translated">Cuarto, terminamos la l&amp;iacute;nea con un punto y coma ( &lt;code&gt;;&lt;/code&gt; ), lo que indica que esta expresi&amp;oacute;n ha terminado y la siguiente est&amp;aacute; lista para comenzar. La mayor&amp;iacute;a de las l&amp;iacute;neas de c&amp;oacute;digo de Rust terminan con un punto y coma.</target>
        </trans-unit>
        <trans-unit id="e91e4dcc96ac0d3266337d9de8422f466122555f" translate="yes" xml:space="preserve">
          <source>Fourth, we use &lt;code&gt;expect&lt;/code&gt; repeatedly to handle different errors, and if the user runs our program without specifying enough arguments, they&amp;rsquo;ll get an &lt;code&gt;index out of bounds&lt;/code&gt; error from Rust that doesn&amp;rsquo;t clearly explain the problem. It would be best if all the error-handling code were in one place so future maintainers had only one place to consult in the code if the error-handling logic needed to change. Having all the error-handling code in one place will also ensure that we&amp;rsquo;re printing messages that will be meaningful to our end users.</source>
          <target state="translated">Cuarto, usamos &lt;code&gt;expect&lt;/code&gt; repetidamente para manejar diferentes errores, y si el usuario ejecuta nuestro programa sin especificar suficientes argumentos, obtendr&amp;aacute; un error de &lt;code&gt;index out of bounds&lt;/code&gt; de Rust que no explica claramente el problema. Ser&amp;iacute;a mejor si todo el c&amp;oacute;digo de manejo de errores estuviera en un solo lugar para que los futuros mantenedores solo tuvieran un lugar para consultar en el c&amp;oacute;digo si la l&amp;oacute;gica de manejo de errores necesitara cambiar. Tener todo el c&amp;oacute;digo de manejo de errores en un solo lugar tambi&amp;eacute;n asegurar&amp;aacute; que estemos imprimiendo mensajes que ser&amp;aacute;n significativos para nuestros usuarios finales.</target>
        </trans-unit>
        <trans-unit id="ed80c9c6442c4ef597a2552dbc33ed2f6b8de23a" translate="yes" xml:space="preserve">
          <source>FpCategory</source>
          <target state="translated">FpCategory</target>
        </trans-unit>
        <trans-unit id="c5c59edf4deff28b67b52b7a2d8ad2d144fc15b7" translate="yes" xml:space="preserve">
          <source>FpCategory::borrow</source>
          <target state="translated">FpCategory::borrow</target>
        </trans-unit>
        <trans-unit id="d23597cd1aa75ec546253dcec332bbc22c760f94" translate="yes" xml:space="preserve">
          <source>FpCategory::borrow_mut</source>
          <target state="translated">FpCategory::borrow_mut</target>
        </trans-unit>
        <trans-unit id="751583c9571b8ec42bb13ab3d996f5382f516c44" translate="yes" xml:space="preserve">
          <source>FpCategory::clone</source>
          <target state="translated">FpCategory::clone</target>
        </trans-unit>
        <trans-unit id="e4a9c0c7fcd7d91e6ce8dc4a84468c8dff226fb5" translate="yes" xml:space="preserve">
          <source>FpCategory::clone_from</source>
          <target state="translated">FpCategory::clone_from</target>
        </trans-unit>
        <trans-unit id="b09dd4eed7eb664a0468a101965945f86157a4f7" translate="yes" xml:space="preserve">
          <source>FpCategory::clone_into</source>
          <target state="translated">FpCategory::clone_into</target>
        </trans-unit>
        <trans-unit id="e5a224baf80bccef6b2c64c70bf061c66d0be643" translate="yes" xml:space="preserve">
          <source>FpCategory::eq</source>
          <target state="translated">FpCategory::eq</target>
        </trans-unit>
        <trans-unit id="77d96d469c7820ed9e8e2550859bf5e231b036bf" translate="yes" xml:space="preserve">
          <source>FpCategory::fmt</source>
          <target state="translated">FpCategory::fmt</target>
        </trans-unit>
        <trans-unit id="d3c55faf6a766af5731aad29ee9bd29b2c453928" translate="yes" xml:space="preserve">
          <source>FpCategory::from</source>
          <target state="translated">FpCategory::from</target>
        </trans-unit>
        <trans-unit id="69b2c07f9aa6d8ad6d30706f48ef52d237b2ba0a" translate="yes" xml:space="preserve">
          <source>FpCategory::into</source>
          <target state="translated">FpCategory::into</target>
        </trans-unit>
        <trans-unit id="f38a3329d567847d1d7020b8f9012bbd294a84cd" translate="yes" xml:space="preserve">
          <source>FpCategory::ne</source>
          <target state="translated">FpCategory::ne</target>
        </trans-unit>
        <trans-unit id="e71fe5458996e5a849fc677ae5804fc42c3dccda" translate="yes" xml:space="preserve">
          <source>FpCategory::to_owned</source>
          <target state="translated">FpCategory::to_owned</target>
        </trans-unit>
        <trans-unit id="54a1083e9a89cf3ecfe165675d7e0ab953ccd2ff" translate="yes" xml:space="preserve">
          <source>FpCategory::try_from</source>
          <target state="translated">FpCategory::try_from</target>
        </trans-unit>
        <trans-unit id="bbaf3ef7ecd842bc58b2772d5b932f8c39fd8488" translate="yes" xml:space="preserve">
          <source>FpCategory::try_into</source>
          <target state="translated">FpCategory::try_into</target>
        </trans-unit>
        <trans-unit id="ccefd29d45a4e40d6e9d86bb94af58e1a57d4c4b" translate="yes" xml:space="preserve">
          <source>FpCategory::type_id</source>
          <target state="translated">FpCategory::type_id</target>
        </trans-unit>
        <trans-unit id="a9d589b62118d02ae561f6231ff20e78ff11bc84" translate="yes" xml:space="preserve">
          <source>Fran&amp;ccedil;ais</source>
          <target state="translated">Fran&amp;ccedil;ais</target>
        </trans-unit>
        <trans-unit id="b358be1e7ac10187955efc826d6d6dee79296909" translate="yes" xml:space="preserve">
          <source>Free item</source>
          <target state="translated">Artículo gratis.</target>
        </trans-unit>
        <trans-unit id="3f66052a107eaf9bae7cad0f61fb462f47ec2c47" translate="yes" xml:space="preserve">
          <source>From</source>
          <target state="translated">From</target>
        </trans-unit>
        <trans-unit id="594a1d99ee61c47df541cb8769ebf939c8303d7b" translate="yes" xml:space="preserve">
          <source>From &lt;code&gt;&amp;amp;T&lt;/code&gt; to &lt;code&gt;&amp;amp;U&lt;/code&gt; when &lt;code&gt;T: Deref&amp;lt;Target=U&amp;gt;&lt;/code&gt;</source>
          <target state="translated">De &lt;code&gt;&amp;amp;T&lt;/code&gt; a &lt;code&gt;&amp;amp;U&lt;/code&gt; cuando &lt;code&gt;T: Deref&amp;lt;Target=U&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="08bb11df769057fd0b8c167b5ec397162b1aeadb" translate="yes" xml:space="preserve">
          <source>From &lt;code&gt;&amp;amp;mut T&lt;/code&gt; to &lt;code&gt;&amp;amp;U&lt;/code&gt; when &lt;code&gt;T: Deref&amp;lt;Target=U&amp;gt;&lt;/code&gt;</source>
          <target state="translated">De &lt;code&gt;&amp;amp;mut T&lt;/code&gt; a &lt;code&gt;&amp;amp;U&lt;/code&gt; cuando &lt;code&gt;T: Deref&amp;lt;Target=U&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e62732420027526966136d3f7e0dfec52557b634" translate="yes" xml:space="preserve">
          <source>From &lt;code&gt;&amp;amp;mut T&lt;/code&gt; to &lt;code&gt;&amp;amp;mut U&lt;/code&gt; when &lt;code&gt;T: DerefMut&amp;lt;Target=U&amp;gt;&lt;/code&gt;</source>
          <target state="translated">De &lt;code&gt;&amp;amp;mut T&lt;/code&gt; a &lt;code&gt;&amp;amp;mut U&lt;/code&gt; cuando &lt;code&gt;T: DerefMut&amp;lt;Target=U&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5cc6d703e34af866105ca191df0b36dc89356e81" translate="yes" xml:space="preserve">
          <source>From there, clearly FIRST(M) can include any token from SEP_SET(M) or ALPHA_SET(M), and if the complex NT match is nonempty, then any token starting FIRST(&lt;code&gt;tt ...&lt;/code&gt;) could work too. The last piece to consider is &amp;epsilon;. SEP_SET(M) and FIRST(&lt;code&gt;tt ...&lt;/code&gt;) \ {&amp;epsilon;} cannot contain &amp;epsilon;, but ALPHA_SET(M) could. Hence, this definition allows M to accept &amp;epsilon; if and only if &amp;epsilon; &amp;isin; ALPHA_SET(M) does. This is correct because for M to accept &amp;epsilon; in the complex NT case, both the complex NT and &amp;alpha; must accept it. If OP = &lt;code&gt;+&lt;/code&gt;, meaning that the complex NT cannot be empty, then by definition &amp;epsilon; &amp;notin; ALPHA_SET(M). Otherwise, the complex NT can accept zero repetitions, and then ALPHA_SET(M) = FOLLOW(&lt;code&gt;&amp;alpha;&lt;/code&gt;). So this definition is correct with respect to \varepsilon as well.</source>
          <target state="translated">A partir de ah&amp;iacute;, claramente FIRST (M) puede incluir cualquier token de SEP_SET (M) o ALPHA_SET (M), y si la coincidencia de NT compleja no est&amp;aacute; vac&amp;iacute;a, entonces cualquier token que comience FIRST ( &lt;code&gt;tt ...&lt;/code&gt; ) tambi&amp;eacute;n podr&amp;iacute;a funcionar. La &amp;uacute;ltima pieza a considerar es &amp;epsilon;. SEP_SET (M) y FIRST ( &lt;code&gt;tt ...&lt;/code&gt; ) \ {&amp;epsilon;} no pueden contener &amp;epsilon;, pero ALPHA_SET (M) s&amp;iacute;. Por lo tanto, esta definici&amp;oacute;n permite que M acepte &amp;epsilon; si y solo si &amp;epsilon; &amp;isin; ALPHA_SET (M) lo hace. Esto es correcto porque para que M acepte &amp;epsilon; en el caso de la NT compleja, tanto la NT compleja como &amp;alpha; deben aceptarla. Si OP = &lt;code&gt;+&lt;/code&gt; , lo que significa que el complejo NT no puede estar vac&amp;iacute;o, entonces, por definici&amp;oacute;n, &amp;epsilon; &amp;notin; ALPHA_SET (M). De lo contrario, el NT complejo puede aceptar cero repeticiones y luego ALPHA_SET (M) = FOLLOW ( &lt;code&gt;&amp;alpha;&lt;/code&gt; ). As&amp;iacute; que esta definici&amp;oacute;n tambi&amp;eacute;n es correcta con respecto a \ varepsilon.</target>
        </trans-unit>
        <trans-unit id="6307b5e07877494d1ce0b104a2d8b0a5b885f84f" translate="yes" xml:space="preserve">
          <source>From these, you can see that the first argument is a format string. It is required by the compiler for this to be a string literal; it cannot be a variable passed in (in order to perform validity checking). The compiler will then parse the format string and determine if the list of arguments provided is suitable to pass to this format string.</source>
          <target state="translated">A partir de estos,se puede ver que el primer argumento es una cadena de formato.El compilador exige que sea un literal de cadena;no puede ser una variable pasada (para realizar una comprobación de validez).El compilador analizará entonces la cadena de formato y determinará si la lista de argumentos proporcionada es adecuada para pasarla a esta cadena de formato.</target>
        </trans-unit>
        <trans-unit id="636e988ae72ddba156e347bc59d0f315352542a2" translate="yes" xml:space="preserve">
          <source>From::from</source>
          <target state="translated">From::from</target>
        </trans-unit>
        <trans-unit id="08e29d1fb00c3b7e4f55ea6c2152be52cb9cffd5" translate="yes" xml:space="preserve">
          <source>FromBytesWithNulError</source>
          <target state="translated">FromBytesWithNulError</target>
        </trans-unit>
        <trans-unit id="0fa886d5bcda7ff44295308c06a19bb9f2ca1ef2" translate="yes" xml:space="preserve">
          <source>FromBytesWithNulError::borrow</source>
          <target state="translated">FromBytesWithNulError::borrow</target>
        </trans-unit>
        <trans-unit id="227e72c0ed27fb7c2db4228bdeaa7f1e2f4fbb2b" translate="yes" xml:space="preserve">
          <source>FromBytesWithNulError::borrow_mut</source>
          <target state="translated">FromBytesWithNulError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="917a76dd8d5ce07b2b32608e4fac2c07d85334ec" translate="yes" xml:space="preserve">
          <source>FromBytesWithNulError::cause</source>
          <target state="translated">FromBytesWithNulError::cause</target>
        </trans-unit>
        <trans-unit id="d333ff8aac4bcb0b21149b90dd779023c26f7273" translate="yes" xml:space="preserve">
          <source>FromBytesWithNulError::clone</source>
          <target state="translated">FromBytesWithNulError::clone</target>
        </trans-unit>
        <trans-unit id="da349bb088fcf13b909128e597aea220053fe70a" translate="yes" xml:space="preserve">
          <source>FromBytesWithNulError::clone_from</source>
          <target state="translated">FromBytesWithNulError::clone_from</target>
        </trans-unit>
        <trans-unit id="e43ad4a91a8891363b5526c6aac70021b8e8b9f4" translate="yes" xml:space="preserve">
          <source>FromBytesWithNulError::clone_into</source>
          <target state="translated">FromBytesWithNulError::clone_into</target>
        </trans-unit>
        <trans-unit id="fdc34d9df46754c7b93341a3863f600ff88ad5cd" translate="yes" xml:space="preserve">
          <source>FromBytesWithNulError::description</source>
          <target state="translated">FromBytesWithNulError::description</target>
        </trans-unit>
        <trans-unit id="5258a1a84a0930cb189c0d18cfff3f7a1eb6f915" translate="yes" xml:space="preserve">
          <source>FromBytesWithNulError::eq</source>
          <target state="translated">FromBytesWithNulError::eq</target>
        </trans-unit>
        <trans-unit id="b27518c7b2442b78dc66650a48141386af70ddd9" translate="yes" xml:space="preserve">
          <source>FromBytesWithNulError::fmt</source>
          <target state="translated">FromBytesWithNulError::fmt</target>
        </trans-unit>
        <trans-unit id="69e350f5eddef56ca7534154dcbe130775e89c37" translate="yes" xml:space="preserve">
          <source>FromBytesWithNulError::from</source>
          <target state="translated">FromBytesWithNulError::from</target>
        </trans-unit>
        <trans-unit id="830e5d4f61a30595ce8e6e3f78c6591c5a9b7752" translate="yes" xml:space="preserve">
          <source>FromBytesWithNulError::into</source>
          <target state="translated">FromBytesWithNulError::into</target>
        </trans-unit>
        <trans-unit id="6b9fdbfff68a5cffa6a5604dd67451bcca2d12ad" translate="yes" xml:space="preserve">
          <source>FromBytesWithNulError::ne</source>
          <target state="translated">FromBytesWithNulError::ne</target>
        </trans-unit>
        <trans-unit id="2e862184199a6c230f9f2243d8e321f0f31557e5" translate="yes" xml:space="preserve">
          <source>FromBytesWithNulError::source</source>
          <target state="translated">FromBytesWithNulError::source</target>
        </trans-unit>
        <trans-unit id="54f826f0c977e84bbff8ed219c9607014ac9fd7e" translate="yes" xml:space="preserve">
          <source>FromBytesWithNulError::to_owned</source>
          <target state="translated">FromBytesWithNulError::to_owned</target>
        </trans-unit>
        <trans-unit id="d83ad93be5deca6785c67b79fcb106d01b5a7e60" translate="yes" xml:space="preserve">
          <source>FromBytesWithNulError::to_string</source>
          <target state="translated">FromBytesWithNulError::to_string</target>
        </trans-unit>
        <trans-unit id="36df31fcad872818b05aba9f12c079035a34e814" translate="yes" xml:space="preserve">
          <source>FromBytesWithNulError::try_from</source>
          <target state="translated">FromBytesWithNulError::try_from</target>
        </trans-unit>
        <trans-unit id="d7d718854b40de2a9cbbf7938bd184275c5fbb3b" translate="yes" xml:space="preserve">
          <source>FromBytesWithNulError::try_into</source>
          <target state="translated">FromBytesWithNulError::try_into</target>
        </trans-unit>
        <trans-unit id="1bc03244b37f99bdcf813bff54e53e08450612a6" translate="yes" xml:space="preserve">
          <source>FromBytesWithNulError::type_id</source>
          <target state="translated">FromBytesWithNulError::type_id</target>
        </trans-unit>
        <trans-unit id="aeea3b1e1e881ee75f416d42b6a41418a5524277" translate="yes" xml:space="preserve">
          <source>FromFn</source>
          <target state="translated">FromFn</target>
        </trans-unit>
        <trans-unit id="c8518b8fb7e55cb8991e5e6afc3e72d086748ed8" translate="yes" xml:space="preserve">
          <source>FromFn::all</source>
          <target state="translated">FromFn::all</target>
        </trans-unit>
        <trans-unit id="ee215b3f9bdf8dee097ae6be066d5141a74c4422" translate="yes" xml:space="preserve">
          <source>FromFn::any</source>
          <target state="translated">FromFn::any</target>
        </trans-unit>
        <trans-unit id="ccf5f67c540d5b91e0949ed126f30addc417daf6" translate="yes" xml:space="preserve">
          <source>FromFn::borrow</source>
          <target state="translated">FromFn::borrow</target>
        </trans-unit>
        <trans-unit id="e13f389bbae0dab5ea909e4eb43686476caf7c83" translate="yes" xml:space="preserve">
          <source>FromFn::borrow_mut</source>
          <target state="translated">FromFn::borrow_mut</target>
        </trans-unit>
        <trans-unit id="ac215cf840365da8e5c15c7bdaf15be9e7bb130d" translate="yes" xml:space="preserve">
          <source>FromFn::by_ref</source>
          <target state="translated">FromFn::by_ref</target>
        </trans-unit>
        <trans-unit id="9395f4718e1c738177a77570adb7ed3222bbacab" translate="yes" xml:space="preserve">
          <source>FromFn::chain</source>
          <target state="translated">FromFn::chain</target>
        </trans-unit>
        <trans-unit id="b9afae70b69d87da33ee72ad265f7577a8b521f0" translate="yes" xml:space="preserve">
          <source>FromFn::clone</source>
          <target state="translated">FromFn::clone</target>
        </trans-unit>
        <trans-unit id="f5d858a83a4b11765ad648f861ff5231f437bd27" translate="yes" xml:space="preserve">
          <source>FromFn::clone_from</source>
          <target state="translated">FromFn::clone_from</target>
        </trans-unit>
        <trans-unit id="b1269311c4f13149e8a6a84d90f870800d694c44" translate="yes" xml:space="preserve">
          <source>FromFn::clone_into</source>
          <target state="translated">FromFn::clone_into</target>
        </trans-unit>
        <trans-unit id="bb6aa8a11de5554807803affb28dee3aaf938492" translate="yes" xml:space="preserve">
          <source>FromFn::cloned</source>
          <target state="translated">FromFn::cloned</target>
        </trans-unit>
        <trans-unit id="9e2de70acc9938a364a71db569d88dd7084bb122" translate="yes" xml:space="preserve">
          <source>FromFn::cmp</source>
          <target state="translated">FromFn::cmp</target>
        </trans-unit>
        <trans-unit id="5dc944d29ed685b0903453522c86c34ab231d0d9" translate="yes" xml:space="preserve">
          <source>FromFn::collect</source>
          <target state="translated">FromFn::collect</target>
        </trans-unit>
        <trans-unit id="d23fcdf7cbb91c0e0f62994569131c297c4ddefc" translate="yes" xml:space="preserve">
          <source>FromFn::copied</source>
          <target state="translated">FromFn::copied</target>
        </trans-unit>
        <trans-unit id="3a168b114945b66f27edc167ced99723dbcea667" translate="yes" xml:space="preserve">
          <source>FromFn::count</source>
          <target state="translated">FromFn::count</target>
        </trans-unit>
        <trans-unit id="0f1dba887057a79ecd9d75a789118b1a760f1bf9" translate="yes" xml:space="preserve">
          <source>FromFn::cycle</source>
          <target state="translated">FromFn::cycle</target>
        </trans-unit>
        <trans-unit id="364eebc33448cd890e813a37012795c1cb46e143" translate="yes" xml:space="preserve">
          <source>FromFn::enumerate</source>
          <target state="translated">FromFn::enumerate</target>
        </trans-unit>
        <trans-unit id="25ecbb4825daa1bf477051b32ed08a14a60adb4e" translate="yes" xml:space="preserve">
          <source>FromFn::eq</source>
          <target state="translated">FromFn::eq</target>
        </trans-unit>
        <trans-unit id="893cabc068144c0b9718092e7068a32de2da2fab" translate="yes" xml:space="preserve">
          <source>FromFn::filter</source>
          <target state="translated">FromFn::filter</target>
        </trans-unit>
        <trans-unit id="c428a70eed23c8748e97d7b52c53163675f55635" translate="yes" xml:space="preserve">
          <source>FromFn::filter_map</source>
          <target state="translated">FromFn::filter_map</target>
        </trans-unit>
        <trans-unit id="93846947c2b596c22bfad404c3e09fd4600173a4" translate="yes" xml:space="preserve">
          <source>FromFn::find</source>
          <target state="translated">FromFn::find</target>
        </trans-unit>
        <trans-unit id="c2fa8bbc9e75620bd3f52ec77812c683d5720689" translate="yes" xml:space="preserve">
          <source>FromFn::find_map</source>
          <target state="translated">FromFn::find_map</target>
        </trans-unit>
        <trans-unit id="c247400a7e94cb47ecf9ec277ef05328b6da39a7" translate="yes" xml:space="preserve">
          <source>FromFn::flat_map</source>
          <target state="translated">FromFn::flat_map</target>
        </trans-unit>
        <trans-unit id="b8e395dd0daa535ba3a1b2d30ce2a2297e2749c0" translate="yes" xml:space="preserve">
          <source>FromFn::flatten</source>
          <target state="translated">FromFn::flatten</target>
        </trans-unit>
        <trans-unit id="291d5ac05a71cd905fd11a3c926116e9910a0f32" translate="yes" xml:space="preserve">
          <source>FromFn::fmt</source>
          <target state="translated">FromFn::fmt</target>
        </trans-unit>
        <trans-unit id="1d6bc4438b3ee6de07c8226628c01c605cc2c12f" translate="yes" xml:space="preserve">
          <source>FromFn::fold</source>
          <target state="translated">FromFn::fold</target>
        </trans-unit>
        <trans-unit id="b0cc978eb55c645b04d4748225713d097a016c16" translate="yes" xml:space="preserve">
          <source>FromFn::for_each</source>
          <target state="translated">FromFn::for_each</target>
        </trans-unit>
        <trans-unit id="696126195e64358c186e7c8c9ba70300c1a54795" translate="yes" xml:space="preserve">
          <source>FromFn::from</source>
          <target state="translated">FromFn::from</target>
        </trans-unit>
        <trans-unit id="9422f31b3fdd3444d7d9a657e431cfc6bf368554" translate="yes" xml:space="preserve">
          <source>FromFn::fuse</source>
          <target state="translated">FromFn::fuse</target>
        </trans-unit>
        <trans-unit id="f0898886063e02add23e81048db80e14869522c9" translate="yes" xml:space="preserve">
          <source>FromFn::ge</source>
          <target state="translated">FromFn::ge</target>
        </trans-unit>
        <trans-unit id="938bc9b27931508db8e9ec4ee7e2ecfffcce85a9" translate="yes" xml:space="preserve">
          <source>FromFn::gt</source>
          <target state="translated">FromFn::gt</target>
        </trans-unit>
        <trans-unit id="5f5242ca11d2be4a93763ad44cf5a1901bba1038" translate="yes" xml:space="preserve">
          <source>FromFn::inspect</source>
          <target state="translated">FromFn::inspect</target>
        </trans-unit>
        <trans-unit id="8b24481c5fe21f0d4eefc523e12c42563a9349cf" translate="yes" xml:space="preserve">
          <source>FromFn::into</source>
          <target state="translated">FromFn::into</target>
        </trans-unit>
        <trans-unit id="ae4f0c406ba5ce7367ef7c9f2f0ff1d657965af3" translate="yes" xml:space="preserve">
          <source>FromFn::into_iter</source>
          <target state="translated">FromFn::into_iter</target>
        </trans-unit>
        <trans-unit id="afff9a10d69a5add7ba160fd8944e5721b2448b0" translate="yes" xml:space="preserve">
          <source>FromFn::is_sorted</source>
          <target state="translated">FromFn::is_sorted</target>
        </trans-unit>
        <trans-unit id="65555425c11972ea9a43c73ece4221af77b37aac" translate="yes" xml:space="preserve">
          <source>FromFn::is_sorted_by</source>
          <target state="translated">FromFn::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="e962a84a22ee3e8286deb98ec6a05dc09fb7c1da" translate="yes" xml:space="preserve">
          <source>FromFn::is_sorted_by_key</source>
          <target state="translated">FromFn::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="8ce1a710f4a70c6d10a044e276250699320aaf07" translate="yes" xml:space="preserve">
          <source>FromFn::last</source>
          <target state="translated">FromFn::last</target>
        </trans-unit>
        <trans-unit id="84d790ccc1d625773ad60ff7dbafd9719b2c1e60" translate="yes" xml:space="preserve">
          <source>FromFn::le</source>
          <target state="translated">FromFn::le</target>
        </trans-unit>
        <trans-unit id="1d494ff0f71cf64264c61f3a0d0064224ba064b9" translate="yes" xml:space="preserve">
          <source>FromFn::lt</source>
          <target state="translated">FromFn::lt</target>
        </trans-unit>
        <trans-unit id="751b0a3e001bca29a735704d123f59f147dc51fa" translate="yes" xml:space="preserve">
          <source>FromFn::map</source>
          <target state="translated">FromFn::map</target>
        </trans-unit>
        <trans-unit id="9557f4915531898d81c94e1b4775a41a6bfc887c" translate="yes" xml:space="preserve">
          <source>FromFn::max</source>
          <target state="translated">FromFn::max</target>
        </trans-unit>
        <trans-unit id="773497baa5bf74230ff0d338cc91e10ae9beefb2" translate="yes" xml:space="preserve">
          <source>FromFn::max_by</source>
          <target state="translated">FromFn::max_by</target>
        </trans-unit>
        <trans-unit id="a9eb1b7e1e1ef9f1ccc894fc973f5685bd2ee298" translate="yes" xml:space="preserve">
          <source>FromFn::max_by_key</source>
          <target state="translated">FromFn::max_by_key</target>
        </trans-unit>
        <trans-unit id="4a3bb54490abbe7310741d5e0d22f11e79c14bac" translate="yes" xml:space="preserve">
          <source>FromFn::min</source>
          <target state="translated">FromFn::min</target>
        </trans-unit>
        <trans-unit id="21f309276fd1f5ad2886f9f09f747d01a840db3c" translate="yes" xml:space="preserve">
          <source>FromFn::min_by</source>
          <target state="translated">FromFn::min_by</target>
        </trans-unit>
        <trans-unit id="2d400ed7d58d506ce1a2d1a6674024793a847641" translate="yes" xml:space="preserve">
          <source>FromFn::min_by_key</source>
          <target state="translated">FromFn::min_by_key</target>
        </trans-unit>
        <trans-unit id="de781dccfea9f050f774daaef74a4dfd4b3cebfc" translate="yes" xml:space="preserve">
          <source>FromFn::ne</source>
          <target state="translated">FromFn::ne</target>
        </trans-unit>
        <trans-unit id="3e9810f0bdab4291492baf74a6bfa30aa21a77bd" translate="yes" xml:space="preserve">
          <source>FromFn::next</source>
          <target state="translated">FromFn::next</target>
        </trans-unit>
        <trans-unit id="5ec257b2ca69cb089b12e30887e2681f5aac401e" translate="yes" xml:space="preserve">
          <source>FromFn::nth</source>
          <target state="translated">FromFn::nth</target>
        </trans-unit>
        <trans-unit id="f77021ba879adead1d2e4228d87ef2663943b655" translate="yes" xml:space="preserve">
          <source>FromFn::partial_cmp</source>
          <target state="translated">FromFn::partial_cmp</target>
        </trans-unit>
        <trans-unit id="288b8538ae0f2879d43bf94297be3c6133a5f820" translate="yes" xml:space="preserve">
          <source>FromFn::partition</source>
          <target state="translated">FromFn::partition</target>
        </trans-unit>
        <trans-unit id="6ef8b8fdd33b9e08d9b7b53fc44edd140535fa87" translate="yes" xml:space="preserve">
          <source>FromFn::peekable</source>
          <target state="translated">FromFn::peekable</target>
        </trans-unit>
        <trans-unit id="9fd5da570ca929f5692e6716a06272746f0fa1d8" translate="yes" xml:space="preserve">
          <source>FromFn::position</source>
          <target state="translated">FromFn::position</target>
        </trans-unit>
        <trans-unit id="9fd628265dd15f36a0898f2dbb30e35b39ee8fc7" translate="yes" xml:space="preserve">
          <source>FromFn::product</source>
          <target state="translated">FromFn::product</target>
        </trans-unit>
        <trans-unit id="f309b4b73dbc1c831c32217194b232a41056a729" translate="yes" xml:space="preserve">
          <source>FromFn::rev</source>
          <target state="translated">FromFn::rev</target>
        </trans-unit>
        <trans-unit id="a0c49b380c128a9bc5de2c3faa4da44b9fc8bbc6" translate="yes" xml:space="preserve">
          <source>FromFn::rposition</source>
          <target state="translated">FromFn::rposition</target>
        </trans-unit>
        <trans-unit id="19e6db953101ebb606b1b19e2f9d1a4a26b6809c" translate="yes" xml:space="preserve">
          <source>FromFn::scan</source>
          <target state="translated">FromFn::scan</target>
        </trans-unit>
        <trans-unit id="5d0d63065b04c4b09f0aa2957112e2fe0f225430" translate="yes" xml:space="preserve">
          <source>FromFn::size_hint</source>
          <target state="translated">FromFn::size_hint</target>
        </trans-unit>
        <trans-unit id="38e4d5016859cd612a773350539b8a8f8ed4f69e" translate="yes" xml:space="preserve">
          <source>FromFn::skip</source>
          <target state="translated">FromFn::skip</target>
        </trans-unit>
        <trans-unit id="12a7c70e2490eae42133b8d79eb74bbc281ed3c1" translate="yes" xml:space="preserve">
          <source>FromFn::skip_while</source>
          <target state="translated">FromFn::skip_while</target>
        </trans-unit>
        <trans-unit id="b8e40ee23c90dfe55dc2adc6eb4e1fa68a56d3f2" translate="yes" xml:space="preserve">
          <source>FromFn::step_by</source>
          <target state="translated">FromFn::step_by</target>
        </trans-unit>
        <trans-unit id="b3529c28fcc7f21d0e3ae52857e07c43bb6c8013" translate="yes" xml:space="preserve">
          <source>FromFn::sum</source>
          <target state="translated">FromFn::sum</target>
        </trans-unit>
        <trans-unit id="6daa93fa94eca065b7334c99d285abb621f9ead1" translate="yes" xml:space="preserve">
          <source>FromFn::take</source>
          <target state="translated">FromFn::take</target>
        </trans-unit>
        <trans-unit id="156bad7396ba706178e8ea89088365ae093fa7cd" translate="yes" xml:space="preserve">
          <source>FromFn::take_while</source>
          <target state="translated">FromFn::take_while</target>
        </trans-unit>
        <trans-unit id="9839051411a51874292b5e676a817c3565f4cdb7" translate="yes" xml:space="preserve">
          <source>FromFn::to_owned</source>
          <target state="translated">FromFn::to_owned</target>
        </trans-unit>
        <trans-unit id="ea08cb40922d3bbf69b931ce4241edaff08bba49" translate="yes" xml:space="preserve">
          <source>FromFn::try_fold</source>
          <target state="translated">FromFn::try_fold</target>
        </trans-unit>
        <trans-unit id="bd6c17792affbcc25b9cd6f9d78ae20bb6d8b440" translate="yes" xml:space="preserve">
          <source>FromFn::try_for_each</source>
          <target state="translated">FromFn::try_for_each</target>
        </trans-unit>
        <trans-unit id="599426d9bfd33f5d58f1c89e6fe9a710264c9a4f" translate="yes" xml:space="preserve">
          <source>FromFn::try_from</source>
          <target state="translated">FromFn::try_from</target>
        </trans-unit>
        <trans-unit id="171a8267d3eee4bfef7510e89b3fcd5c1ca50a99" translate="yes" xml:space="preserve">
          <source>FromFn::try_into</source>
          <target state="translated">FromFn::try_into</target>
        </trans-unit>
        <trans-unit id="5dbbcba7b3548c91e4ba3998b160d580ba16ca70" translate="yes" xml:space="preserve">
          <source>FromFn::type_id</source>
          <target state="translated">FromFn::type_id</target>
        </trans-unit>
        <trans-unit id="aa009f7a09e21b409ed71bd642c5fa986b90aa2e" translate="yes" xml:space="preserve">
          <source>FromFn::unzip</source>
          <target state="translated">FromFn::unzip</target>
        </trans-unit>
        <trans-unit id="efab3519b36c349c534fa71bff1cf729099859a4" translate="yes" xml:space="preserve">
          <source>FromFn::zip</source>
          <target state="translated">FromFn::zip</target>
        </trans-unit>
        <trans-unit id="32b4bf2ef95e2d2aec7397ff0647d8babccdf02c" translate="yes" xml:space="preserve">
          <source>FromIterator</source>
          <target state="translated">FromIterator</target>
        </trans-unit>
        <trans-unit id="e1870c89bb148edb105f129409fab48efce69f62" translate="yes" xml:space="preserve">
          <source>FromIterator::from_iter</source>
          <target state="translated">FromIterator::from_iter</target>
        </trans-unit>
        <trans-unit id="4bad9f9fcb9b55d2910b83906b94cb3131b43c5d" translate="yes" xml:space="preserve">
          <source>FromRawFd</source>
          <target state="translated">FromRawFd</target>
        </trans-unit>
        <trans-unit id="a56a062331e31ac1c2b5a5dac0da0b0abb9d6001" translate="yes" xml:space="preserve">
          <source>FromRawHandle</source>
          <target state="translated">FromRawHandle</target>
        </trans-unit>
        <trans-unit id="c37ec0040cdbff3d1d305c56421552ddc2489011" translate="yes" xml:space="preserve">
          <source>FromRawSocket</source>
          <target state="translated">FromRawSocket</target>
        </trans-unit>
        <trans-unit id="4dd00b66acc9fd438c18fe918918688eac4eb0c2" translate="yes" xml:space="preserve">
          <source>FromStr</source>
          <target state="translated">FromStr</target>
        </trans-unit>
        <trans-unit id="dab7a59717331bdfe8b7ab641211c67a9dfb50eb" translate="yes" xml:space="preserve">
          <source>FromStr::from_str</source>
          <target state="translated">FromStr::from_str</target>
        </trans-unit>
        <trans-unit id="95bb1cb5923a9cd972fc547c7b002fc5ba2ce7a2" translate="yes" xml:space="preserve">
          <source>FromUtf16Error</source>
          <target state="translated">FromUtf16Error</target>
        </trans-unit>
        <trans-unit id="fcb0d72a120d0c67f17203436ea5960146d62ec2" translate="yes" xml:space="preserve">
          <source>FromUtf16Error::borrow</source>
          <target state="translated">FromUtf16Error::borrow</target>
        </trans-unit>
        <trans-unit id="113c351153f138ad8e550bd5bc87e5b5707c2ec9" translate="yes" xml:space="preserve">
          <source>FromUtf16Error::borrow_mut</source>
          <target state="translated">FromUtf16Error::borrow_mut</target>
        </trans-unit>
        <trans-unit id="97836107e76f8ba4b690e740298dc374f5970b10" translate="yes" xml:space="preserve">
          <source>FromUtf16Error::cause</source>
          <target state="translated">FromUtf16Error::cause</target>
        </trans-unit>
        <trans-unit id="e94e007d11f3b1dda24c2465e9cb38303e308e73" translate="yes" xml:space="preserve">
          <source>FromUtf16Error::description</source>
          <target state="translated">FromUtf16Error::description</target>
        </trans-unit>
        <trans-unit id="2c32d02e6ae646045db166c707624569fdae72d4" translate="yes" xml:space="preserve">
          <source>FromUtf16Error::fmt</source>
          <target state="translated">FromUtf16Error::fmt</target>
        </trans-unit>
        <trans-unit id="ba0c3d406513bc34fdc41eb68be8108d0b00395d" translate="yes" xml:space="preserve">
          <source>FromUtf16Error::from</source>
          <target state="translated">FromUtf16Error::from</target>
        </trans-unit>
        <trans-unit id="d5575256ab625def6f4f6cc664052c3b6a58df9c" translate="yes" xml:space="preserve">
          <source>FromUtf16Error::into</source>
          <target state="translated">FromUtf16Error::into</target>
        </trans-unit>
        <trans-unit id="1037656b64535df6ad944739d9fe0fdcb97622a8" translate="yes" xml:space="preserve">
          <source>FromUtf16Error::source</source>
          <target state="translated">FromUtf16Error::source</target>
        </trans-unit>
        <trans-unit id="b3d3ba376b016c98e88ee83c7eef33115c996117" translate="yes" xml:space="preserve">
          <source>FromUtf16Error::to_string</source>
          <target state="translated">FromUtf16Error::to_string</target>
        </trans-unit>
        <trans-unit id="245023bdaeff4ddeb623b54723ef50f0ab4c73b2" translate="yes" xml:space="preserve">
          <source>FromUtf16Error::try_from</source>
          <target state="translated">FromUtf16Error::try_from</target>
        </trans-unit>
        <trans-unit id="01065c5d7bcef1fc490d7e58b90a6f4dca50e4fb" translate="yes" xml:space="preserve">
          <source>FromUtf16Error::try_into</source>
          <target state="translated">FromUtf16Error::try_into</target>
        </trans-unit>
        <trans-unit id="7abd332163a5c3ec4a4d4c52373ebd061517082b" translate="yes" xml:space="preserve">
          <source>FromUtf16Error::type_id</source>
          <target state="translated">FromUtf16Error::type_id</target>
        </trans-unit>
        <trans-unit id="f9cdf743b2bfb7c8f355315fba316a0105bfe790" translate="yes" xml:space="preserve">
          <source>FromUtf8Error</source>
          <target state="translated">FromUtf8Error</target>
        </trans-unit>
        <trans-unit id="748acfd665ce8fa3a2ec94e5db04d35258af238a" translate="yes" xml:space="preserve">
          <source>FromUtf8Error::as_bytes</source>
          <target state="translated">FromUtf8Error::as_bytes</target>
        </trans-unit>
        <trans-unit id="67756ec60a16d0349c2bef1bfd6a9c4327f5ce92" translate="yes" xml:space="preserve">
          <source>FromUtf8Error::borrow</source>
          <target state="translated">FromUtf8Error::borrow</target>
        </trans-unit>
        <trans-unit id="f2d6dcca426a9ff1031f09b28e7a3c7e7e95cac7" translate="yes" xml:space="preserve">
          <source>FromUtf8Error::borrow_mut</source>
          <target state="translated">FromUtf8Error::borrow_mut</target>
        </trans-unit>
        <trans-unit id="934a60e32f54920b868089cc1b73dc891da641c4" translate="yes" xml:space="preserve">
          <source>FromUtf8Error::cause</source>
          <target state="translated">FromUtf8Error::cause</target>
        </trans-unit>
        <trans-unit id="6102ea0bc31df9b0bd54ca8c6f45681afdc7f3be" translate="yes" xml:space="preserve">
          <source>FromUtf8Error::description</source>
          <target state="translated">FromUtf8Error::description</target>
        </trans-unit>
        <trans-unit id="db9d99b90918d37a2499587faaadf8cc4c5ba1e8" translate="yes" xml:space="preserve">
          <source>FromUtf8Error::fmt</source>
          <target state="translated">FromUtf8Error::fmt</target>
        </trans-unit>
        <trans-unit id="24fe7f678b98dc8e8766a2bc4809afc6de8f2446" translate="yes" xml:space="preserve">
          <source>FromUtf8Error::from</source>
          <target state="translated">FromUtf8Error::from</target>
        </trans-unit>
        <trans-unit id="a6ad7612f0b82b4e8c1334c223cd16ae09fe7950" translate="yes" xml:space="preserve">
          <source>FromUtf8Error::into</source>
          <target state="translated">FromUtf8Error::into</target>
        </trans-unit>
        <trans-unit id="b7463c02515f737098afa25500af32760dfea53f" translate="yes" xml:space="preserve">
          <source>FromUtf8Error::into_bytes</source>
          <target state="translated">FromUtf8Error::into_bytes</target>
        </trans-unit>
        <trans-unit id="436ef25551c663c53e58d3b69c8eb9dcb10d3235" translate="yes" xml:space="preserve">
          <source>FromUtf8Error::source</source>
          <target state="translated">FromUtf8Error::source</target>
        </trans-unit>
        <trans-unit id="e878d23af1cc95debb68e1cd9e006909c66b66ff" translate="yes" xml:space="preserve">
          <source>FromUtf8Error::to_string</source>
          <target state="translated">FromUtf8Error::to_string</target>
        </trans-unit>
        <trans-unit id="4fbc2f11f0a6ae5317111c17fe4fc467bfab1283" translate="yes" xml:space="preserve">
          <source>FromUtf8Error::try_from</source>
          <target state="translated">FromUtf8Error::try_from</target>
        </trans-unit>
        <trans-unit id="6ffa2b38a64b65974d8f8259323056cadca3d2ba" translate="yes" xml:space="preserve">
          <source>FromUtf8Error::try_into</source>
          <target state="translated">FromUtf8Error::try_into</target>
        </trans-unit>
        <trans-unit id="240101bf524733a6227bf7410764c0c88b68ac25" translate="yes" xml:space="preserve">
          <source>FromUtf8Error::type_id</source>
          <target state="translated">FromUtf8Error::type_id</target>
        </trans-unit>
        <trans-unit id="1520b6f9dab555ff5f00e3142608c852624a5bdc" translate="yes" xml:space="preserve">
          <source>FromUtf8Error::utf8_error</source>
          <target state="translated">FromUtf8Error::utf8_error</target>
        </trans-unit>
        <trans-unit id="66c90b064569c220f974a737cea488bb020847ab" translate="yes" xml:space="preserve">
          <source>FromVecWithNulError</source>
          <target state="translated">FromVecWithNulError</target>
        </trans-unit>
        <trans-unit id="c6a1521589825282f50a8f81cbc487bceb136c94" translate="yes" xml:space="preserve">
          <source>Fully Qualified Syntax for Disambiguation: Calling Methods with the Same Name</source>
          <target state="translated">Sintaxis totalmente cualificada para la desambiguación:Métodos de llamada con el mismo nombre</target>
        </trans-unit>
        <trans-unit id="5c898364acf0b0ec642107ce708180420a68b11c" translate="yes" xml:space="preserve">
          <source>Fully qualified paths allow for disambiguating the path for &lt;a href=&quot;items/implementations#trait-implementations&quot;&gt;trait implementations&lt;/a&gt; and for specifying &lt;a href=&quot;#canonical-paths&quot;&gt;canonical paths&lt;/a&gt;. When used in a type specification, it supports using the type syntax specified below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="627268cbc7ba4357c2bec7566f1dd46e677125cd" translate="yes" xml:space="preserve">
          <source>Fully qualified paths allow for disambiguating the path for &lt;a href=&quot;items/implementations#trait-implementations&quot;&gt;trait implementations&lt;/a&gt; and for specifying &lt;a href=&quot;paths#canonical-paths&quot;&gt;canonical paths&lt;/a&gt;. When used in a type specification, it supports using the type syntax specified below.</source>
          <target state="translated">Las rutas totalmente calificadas permiten eliminar la ambig&amp;uuml;edad de la ruta para las &lt;a href=&quot;items/implementations#trait-implementations&quot;&gt;implementaciones de rasgos&lt;/a&gt; y para especificar &lt;a href=&quot;paths#canonical-paths&quot;&gt;rutas can&amp;oacute;nicas&lt;/a&gt; . Cuando se utiliza en una especificaci&amp;oacute;n de tipo, admite el uso de la sintaxis de tipo especificada a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b6327f489e8e1ede1c999c25b8f597a08dc5e5e7" translate="yes" xml:space="preserve">
          <source>Function Bodies Contain Statements and Expressions</source>
          <target state="translated">Los órganos funcionales contienen declaraciones y expresiones</target>
        </trans-unit>
        <trans-unit id="cec90ffa8d067cfb33c2b7e5ea59f57a4ab51f07" translate="yes" xml:space="preserve">
          <source>Function Parameters</source>
          <target state="translated">Parámetros de la función</target>
        </trans-unit>
        <trans-unit id="fa21ce3153a0bf08e0da8f6a18de7da525121cc9" translate="yes" xml:space="preserve">
          <source>Function Pointers</source>
          <target state="translated">Puntos de función</target>
        </trans-unit>
        <trans-unit id="691f82dd99cc6e11c5ba71e42753b5f300e68086" translate="yes" xml:space="preserve">
          <source>Function and closure return type</source>
          <target state="translated">Función y tipo de retorno del cierre</target>
        </trans-unit>
        <trans-unit id="d289dd66334349d57b2378d89d1ba44a53f0a66f" translate="yes" xml:space="preserve">
          <source>Function bodies are made up of a series of statements optionally ending in an expression. So far, we&amp;rsquo;ve only covered functions without an ending expression, but you have seen an expression as part of a statement. Because Rust is an expression-based language, this is an important distinction to understand. Other languages don&amp;rsquo;t have the same distinctions, so let&amp;rsquo;s look at what statements and expressions are and how their differences affect the bodies of functions.</source>
          <target state="translated">Los cuerpos de las funciones se componen de una serie de declaraciones que terminan opcionalmente en una expresi&amp;oacute;n. Hasta ahora, solo hemos cubierto funciones sin una expresi&amp;oacute;n final, pero ha visto una expresi&amp;oacute;n como parte de una declaraci&amp;oacute;n. Debido a que Rust es un lenguaje basado en expresiones, esta es una distinci&amp;oacute;n importante de entender. Otros lenguajes no tienen las mismas distinciones, as&amp;iacute; que veamos qu&amp;eacute; son las declaraciones y expresiones y c&amp;oacute;mo sus diferencias afectan los cuerpos de funciones.</target>
        </trans-unit>
        <trans-unit id="36ed99d43dd98e906de43534c86aaa6329bc9711" translate="yes" xml:space="preserve">
          <source>Function call expression; also used to initialize tuple &lt;code&gt;struct&lt;/code&gt;s and tuple &lt;code&gt;enum&lt;/code&gt; variants</source>
          <target state="translated">Expresi&amp;oacute;n de llamada a funci&amp;oacute;n; tambi&amp;eacute;n se usa para inicializar &lt;code&gt;struct&lt;/code&gt; tupla y variantes de &lt;code&gt;enum&lt;/code&gt; eraci&amp;oacute;n de tuplas</target>
        </trans-unit>
        <trans-unit id="dd4883aafb3cdb86f14e39e1c7d1f7edcb15ec04" translate="yes" xml:space="preserve">
          <source>Function calls, array indexing</source>
          <target state="translated">Llamadas de función,indexación de matrices</target>
        </trans-unit>
        <trans-unit id="03a2a2fdcb8604503eda22208a226681c6707089" translate="yes" xml:space="preserve">
          <source>Function definitions are also statements; the entire preceding example is a statement in itself.</source>
          <target state="translated">Las definiciones de las funciones son también declaraciones;todo el ejemplo anterior es una declaración en sí mismo.</target>
        </trans-unit>
        <trans-unit id="19f4a1aef809a484c5ab3c0d1a7708464ac28c08" translate="yes" xml:space="preserve">
          <source>Function definitions in Rust start with &lt;code&gt;fn&lt;/code&gt; and have a set of parentheses after the function name. The curly brackets tell the compiler where the function body begins and ends.</source>
          <target state="translated">Las definiciones de funciones en Rust comienzan con &lt;code&gt;fn&lt;/code&gt; y tienen un conjunto de par&amp;eacute;ntesis despu&amp;eacute;s del nombre de la funci&amp;oacute;n. Las llaves le dicen al compilador d&amp;oacute;nde comienza y termina el cuerpo de la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f527034de868b518981c857b1101b4a224d018cd" translate="yes" xml:space="preserve">
          <source>Function item</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da36bbe9a85b3247538cc3fec803f4a226bb9238" translate="yes" xml:space="preserve">
          <source>Function item to address cast</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52aa3d6cb40fdb90563de7ef5199bdc225e74e20" translate="yes" xml:space="preserve">
          <source>Function item to function pointer cast</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac11f9c060fdae4134739658017e8fe749dedfd5" translate="yes" xml:space="preserve">
          <source>Function item to pointer cast</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb2c99db471758809fdfaf0b8a6e27088636a20c" translate="yes" xml:space="preserve">
          <source>Function item types</source>
          <target state="translated">Tipos de elementos de función</target>
        </trans-unit>
        <trans-unit id="63984dbadb9d453a95bc957d9bd90bb4979166b9" translate="yes" xml:space="preserve">
          <source>Function item types (i.e., the distinct types defined for each function)</source>
          <target state="translated">Tipos de elementos de función (es decir,los distintos tipos definidos para cada función)</target>
        </trans-unit>
        <trans-unit id="2a993beecec2e700f82f799b3535fa3479b4141d" translate="yes" xml:space="preserve">
          <source>Function item types and function pointers automatically implement the trait.</source>
          <target state="translated">Los tipos de elementos de función y los punteros de función implementan automáticamente el rasgo.</target>
        </trans-unit>
        <trans-unit id="112c129d1e3d14e754ce4eeea68853b281f78ee9" translate="yes" xml:space="preserve">
          <source>Function or method declarations without a body only allow &lt;a href=&quot;../identifiers&quot;&gt;IDENTIFIER&lt;/a&gt; or &lt;code&gt;_&lt;/code&gt;&lt;a href=&quot;../patterns#wildcard-pattern&quot;&gt;wild card&lt;/a&gt; patterns. &lt;code&gt;mut&lt;/code&gt;&lt;a href=&quot;../identifiers&quot;&gt;IDENTIFIER&lt;/a&gt; is currently allowed, but it is deprecated and will become a hard error in the future.</source>
          <target state="translated">Las declaraciones de funci&amp;oacute;n o m&amp;eacute;todo sin cuerpo solo permiten patrones &lt;a href=&quot;../identifiers&quot;&gt;IDENTIFICADOR&lt;/a&gt; o &lt;code&gt;_&lt;/code&gt; &lt;a href=&quot;../patterns#wildcard-pattern&quot;&gt;comodines&lt;/a&gt; . &lt;code&gt;mut&lt;/code&gt; &lt;a href=&quot;../identifiers&quot;&gt;IDENTIFIER&lt;/a&gt; est&amp;aacute; permitido actualmente, pero est&amp;aacute; obsoleto y se convertir&amp;aacute; en un error grave en el futuro.</target>
        </trans-unit>
        <trans-unit id="e3cf1b82dd9028df4aba63ebe0d8e6f3637f2b6a" translate="yes" xml:space="preserve">
          <source>Function parameters are immutable unless declared with &lt;code&gt;mut&lt;/code&gt;. The &lt;code&gt;mut&lt;/code&gt; keyword applies only to the following parameter. For example: &lt;code&gt;|mut x, y|&lt;/code&gt; and &lt;code&gt;fn f(mut x: Box&amp;lt;i32&amp;gt;, y: Box&amp;lt;i32&amp;gt;)&lt;/code&gt; declare one mutable variable &lt;code&gt;x&lt;/code&gt; and one immutable variable &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">Los par&amp;aacute;metros de la funci&amp;oacute;n son inmutables a menos que se declaren con &lt;code&gt;mut&lt;/code&gt; . La palabra clave &lt;code&gt;mut&lt;/code&gt; se aplica solo al siguiente par&amp;aacute;metro. Por ejemplo: &lt;code&gt;|mut x, y|&lt;/code&gt; y &lt;code&gt;fn f(mut x: Box&amp;lt;i32&amp;gt;, y: Box&amp;lt;i32&amp;gt;)&lt;/code&gt; declaran una variable mutable &lt;code&gt;x&lt;/code&gt; y una variable inmutable &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4604d097c2775f4db1df4742036b1ee376e32c38" translate="yes" xml:space="preserve">
          <source>Function parameters can also be patterns. The code in Listing 18-6, which declares a function named &lt;code&gt;foo&lt;/code&gt; that takes one parameter named &lt;code&gt;x&lt;/code&gt; of type &lt;code&gt;i32&lt;/code&gt;, should by now look familiar.</source>
          <target state="translated">Los par&amp;aacute;metros de funci&amp;oacute;n tambi&amp;eacute;n pueden ser patrones. El c&amp;oacute;digo del Listado 18-6, que declara una funci&amp;oacute;n llamada &lt;code&gt;foo&lt;/code&gt; que toma un par&amp;aacute;metro llamado &lt;code&gt;x&lt;/code&gt; de tipo &lt;code&gt;i32&lt;/code&gt; , deber&amp;iacute;a resultar familiar.</target>
        </trans-unit>
        <trans-unit id="ec08d670fef2800f4026355b26b0c2e7326f8889" translate="yes" xml:space="preserve">
          <source>Function parameters, &lt;code&gt;let&lt;/code&gt; statements, and &lt;code&gt;for&lt;/code&gt; loops can only accept irrefutable patterns, because the program cannot do anything meaningful when values don&amp;rsquo;t match. The &lt;code&gt;if let&lt;/code&gt; and &lt;code&gt;while let&lt;/code&gt; expressions accept refutable and irrefutable patterns, but the compiler warns against irrefutable patterns because by definition they&amp;rsquo;re intended to handle possible failure: the functionality of a conditional is in its ability to perform differently depending on success or failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="803b8d98596aa720a921c36dc97486686404539d" translate="yes" xml:space="preserve">
          <source>Function parameters, &lt;code&gt;let&lt;/code&gt; statements, and &lt;code&gt;for&lt;/code&gt; loops can only accept irrefutable patterns, because the program cannot do anything meaningful when values don&amp;rsquo;t match. The &lt;code&gt;if let&lt;/code&gt; and &lt;code&gt;while let&lt;/code&gt; expressions only accept refutable patterns, because by definition they&amp;rsquo;re intended to handle possible failure: the functionality of a conditional is in its ability to perform differently depending on success or failure.</source>
          <target state="translated">Los par&amp;aacute;metros de funci&amp;oacute;n, las sentencias &lt;code&gt;let&lt;/code&gt; y los bucles &lt;code&gt;for&lt;/code&gt; solo pueden aceptar patrones irrefutables, porque el programa no puede hacer nada significativo cuando los valores no coinciden. Las expresiones &lt;code&gt;if let&lt;/code&gt; y &lt;code&gt;while let&lt;/code&gt; solo aceptan patrones refutables, porque por definici&amp;oacute;n est&amp;aacute;n destinadas a manejar posibles fallas: la funcionalidad de un condicional est&amp;aacute; en su capacidad para funcionar de manera diferente dependiendo del &amp;eacute;xito o del fracaso.</target>
        </trans-unit>
        <trans-unit id="0262efe3a9e70538318d9f40b5d5c3aee785392d" translate="yes" xml:space="preserve">
          <source>Function pointer</source>
          <target state="translated">Puntero de la función</target>
        </trans-unit>
        <trans-unit id="3a6ad7fb74590fbb0ac18b89a46012671173169c" translate="yes" xml:space="preserve">
          <source>Function pointer to address cast</source>
          <target state="translated">Puntero de función para el reparto de direcciones</target>
        </trans-unit>
        <trans-unit id="2ea9417e46d243404ec3c296058e12f5458be748" translate="yes" xml:space="preserve">
          <source>Function pointer to pointer cast</source>
          <target state="translated">Función puntero a puntero lanzado</target>
        </trans-unit>
        <trans-unit id="aff25779a650561f51919916715a331dbe79e151" translate="yes" xml:space="preserve">
          <source>Function pointer types</source>
          <target state="translated">Tipos de punteros de función</target>
        </trans-unit>
        <trans-unit id="45d7a4aae060a99add3462979349c03f64926590" translate="yes" xml:space="preserve">
          <source>Function pointer types (e.g., &lt;code&gt;fn() -&amp;gt; i32&lt;/code&gt;)</source>
          <target state="translated">Tipos de puntero de funci&amp;oacute;n (por ejemplo, &lt;code&gt;fn() -&amp;gt; i32&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b24ffbdb9339fdeaf0aa7876f8b677a6e93905b1" translate="yes" xml:space="preserve">
          <source>Function pointer types, written using the &lt;code&gt;fn&lt;/code&gt; keyword, refer to a function whose identity is not necessarily known at compile-time. They can be created via a coercion from both &lt;a href=&quot;function-item&quot;&gt;function items&lt;/a&gt; and non-capturing &lt;a href=&quot;closure&quot;&gt;closures&lt;/a&gt;.</source>
          <target state="translated">Los tipos de puntero de funci&amp;oacute;n, escritos con la palabra clave &lt;code&gt;fn&lt;/code&gt; , se refieren a una funci&amp;oacute;n cuya identidad no se conoce necesariamente en tiempo de compilaci&amp;oacute;n. Se pueden crear mediante una coerci&amp;oacute;n de &lt;a href=&quot;function-item&quot;&gt;elementos de funci&amp;oacute;n&lt;/a&gt; y &lt;a href=&quot;closure&quot;&gt;cierres que&lt;/a&gt; no capturan .</target>
        </trans-unit>
        <trans-unit id="d6054df2c54398efbf27ace21713f95c0a24cb59" translate="yes" xml:space="preserve">
          <source>Function pointers</source>
          <target state="translated">Indicadores de función</target>
        </trans-unit>
        <trans-unit id="fbcf7edbb2c6d77dc22438afcec72a59e2993480" translate="yes" xml:space="preserve">
          <source>Function pointers are pointers that point to &lt;em&gt;code&lt;/em&gt;, not data. They can be called just like functions. Like references, function pointers are, among other things, assumed to not be null, so if you want to pass a function pointer over FFI and be able to accommodate null pointers, make your type &lt;code&gt;Option&amp;lt;fn()&amp;gt;&lt;/code&gt; with your required signature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15cdfd633c5d7b0c70793f7c9489a755e1d6379f" translate="yes" xml:space="preserve">
          <source>Function pointers implement all three of the closure traits (&lt;code&gt;Fn&lt;/code&gt;, &lt;code&gt;FnMut&lt;/code&gt;, and &lt;code&gt;FnOnce&lt;/code&gt;), so you can always pass a function pointer as an argument for a function that expects a closure. It&amp;rsquo;s best to write functions using a generic type and one of the closure traits so your functions can accept either functions or closures.</source>
          <target state="translated">Los punteros de funci&amp;oacute;n implementan los tres rasgos de cierre ( &lt;code&gt;Fn&lt;/code&gt; , &lt;code&gt;FnMut&lt;/code&gt; y &lt;code&gt;FnOnce&lt;/code&gt; ), por lo que siempre puede pasar un puntero de funci&amp;oacute;n como argumento para una funci&amp;oacute;n que espera un cierre. Es mejor escribir funciones usando un tipo gen&amp;eacute;rico y uno de los rasgos de cierre para que sus funciones puedan aceptar funciones o cierres.</target>
        </trans-unit>
        <trans-unit id="e715fbc2788b68f15adb3e2fe42db1f1b3eb63be" translate="yes" xml:space="preserve">
          <source>Function pointers implement the following traits:</source>
          <target state="translated">Los punteros de la función implementan los siguientes rasgos:</target>
        </trans-unit>
        <trans-unit id="99b2ae8582343bc9c462a6f08e79b5d728c91e61" translate="yes" xml:space="preserve">
          <source>Function pointers, like &lt;code&gt;fn(usize) -&amp;gt; bool&lt;/code&gt;.</source>
          <target state="translated">Punteros de funci&amp;oacute;n, como &lt;code&gt;fn(usize) -&amp;gt; bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a456906988ca1f218d8ec9026e2b7d0d28b99d1f" translate="yes" xml:space="preserve">
          <source>Function results&amp;mdash;either the final line of a block if it is not semicolon-terminated or any expression in a &lt;code&gt;return&lt;/code&gt; statement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36a229e02f3fc60bc509ebb974aa38b72eb187af" translate="yes" xml:space="preserve">
          <source>Function results, either the final line of a block if it is not semicolon-terminated or any expression in a &lt;code&gt;return&lt;/code&gt; statement</source>
          <target state="translated">Resultados de la funci&amp;oacute;n, ya sea la l&amp;iacute;nea final de un bloque si no termina en punto y coma o cualquier expresi&amp;oacute;n en una declaraci&amp;oacute;n de &lt;code&gt;return&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="29f4f46b2b3a18a824f7e4d35e9bedb57b1f2175" translate="yes" xml:space="preserve">
          <source>Function std::alloc::alloc</source>
          <target state="translated">Función std::asignada::asignada</target>
        </trans-unit>
        <trans-unit id="c194290249edf0618f600e420e211418fd7ea58d" translate="yes" xml:space="preserve">
          <source>Function std::alloc::alloc_zeroed</source>
          <target state="translated">Función std::alloc::alloc_zeroed</target>
        </trans-unit>
        <trans-unit id="c55dc24d1719cca7c04e3e54ee8524fba6daf3ee" translate="yes" xml:space="preserve">
          <source>Function std::alloc::dealloc</source>
          <target state="translated">Función std::asign::dealloc</target>
        </trans-unit>
        <trans-unit id="f0a706cc72c3f62f4ea5f25a2d577f9c7dcb0b9c" translate="yes" xml:space="preserve">
          <source>Function std::alloc::handle_alloc_error</source>
          <target state="translated">Función std::alloc::handle_alloc_error</target>
        </trans-unit>
        <trans-unit id="5107e49cfb1f88cc3e2a0a8f7ef7e8b1243aeff1" translate="yes" xml:space="preserve">
          <source>Function std::alloc::realloc</source>
          <target state="translated">Función std::asignar::reasignar</target>
        </trans-unit>
        <trans-unit id="cdfb037e537e5020acc31cc65ff942f2e9f7206e" translate="yes" xml:space="preserve">
          <source>Function std::alloc::set_alloc_error_hook</source>
          <target state="translated">Función std::alloc::set_alloc_error_hook</target>
        </trans-unit>
        <trans-unit id="d3914accafdbce71005fb9461f231fd4f5ddabd1" translate="yes" xml:space="preserve">
          <source>Function std::alloc::take_alloc_error_hook</source>
          <target state="translated">Function std::alloc::take_alloc_error_hook</target>
        </trans-unit>
        <trans-unit id="08a3d4cf4b8c828b9ff65c00bd6f11e8584bca6c" translate="yes" xml:space="preserve">
          <source>Function std::any::type_name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b9a0c79fb1d3fd234f23de7c5b34911cfa81b34" translate="yes" xml:space="preserve">
          <source>Function std::any::type_name_of_val</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca1768a755f4322f02560111cf18bb88f2cde355" translate="yes" xml:space="preserve">
          <source>Function std::array::from_mut</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="679f5406945109bebe64c531eab400a32406f941" translate="yes" xml:space="preserve">
          <source>Function std::array::from_ref</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02460030ea5749077815712a0ec7615c21f8abed" translate="yes" xml:space="preserve">
          <source>Function std::ascii::escape_default</source>
          <target state="translated">Función std::ascii::escape_default</target>
        </trans-unit>
        <trans-unit id="7c07dd33165ae734e5190fd9441a0896193554d6" translate="yes" xml:space="preserve">
          <source>Function std::char::decode_utf16</source>
          <target state="translated">Función std::char::decode_utf16</target>
        </trans-unit>
        <trans-unit id="4247dc6a69dffc51becd83114cd73f82d393cde9" translate="yes" xml:space="preserve">
          <source>Function std::char::from_digit</source>
          <target state="translated">Función std::char::from_digit</target>
        </trans-unit>
        <trans-unit id="01947a1ff576a2d0100c1951a0c5226b70685cd8" translate="yes" xml:space="preserve">
          <source>Function std::char::from_u32</source>
          <target state="translated">Función std::char::from_u32</target>
        </trans-unit>
        <trans-unit id="6dfcd96fdbe2623e4e1d282ca8990e4d07c57639" translate="yes" xml:space="preserve">
          <source>Function std::char::from_u32_unchecked</source>
          <target state="translated">Función std::char::from_u32_unchecked</target>
        </trans-unit>
        <trans-unit id="966fc7af79edea1b5d808685aa0ece42863cd0bd" translate="yes" xml:space="preserve">
          <source>Function std::cmp::max</source>
          <target state="translated">Función std::cmp::max</target>
        </trans-unit>
        <trans-unit id="654964706bd0b6371d33c88bca792ab7df2ef84f" translate="yes" xml:space="preserve">
          <source>Function std::cmp::max_by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9f49de713bede186b9e8e2bc75f0b938238fb79" translate="yes" xml:space="preserve">
          <source>Function std::cmp::max_by_key</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d81416a60431cc075bb472188b6b7e44301f4309" translate="yes" xml:space="preserve">
          <source>Function std::cmp::min</source>
          <target state="translated">Función std::cmp::min</target>
        </trans-unit>
        <trans-unit id="4afe34f5a20d5be4f51e18e6a974860d77547753" translate="yes" xml:space="preserve">
          <source>Function std::cmp::min_by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dd40a1b936bdc62e359c5776f5de1a7197f73d1" translate="yes" xml:space="preserve">
          <source>Function std::cmp::min_by_key</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e137b166d99decd00ae7a0d041b9dad569ce9b9" translate="yes" xml:space="preserve">
          <source>Function std::convert::identity</source>
          <target state="translated">Función std::convertir::identidad</target>
        </trans-unit>
        <trans-unit id="0a18c6fd4283d782572219c61b78adc0f284163d" translate="yes" xml:space="preserve">
          <source>Function std::default::default</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bef3f6086da2cb5d3c82ba307db11b82bdd500e4" translate="yes" xml:space="preserve">
          <source>Function std::env::args</source>
          <target state="translated">Función std::env::args</target>
        </trans-unit>
        <trans-unit id="a7011b47e8ac03fcbd9255878cf4c2155deab1f8" translate="yes" xml:space="preserve">
          <source>Function std::env::args_os</source>
          <target state="translated">Función std::env::args_os</target>
        </trans-unit>
        <trans-unit id="fb6d2bc291dd13ab649f3064189f28948f498c90" translate="yes" xml:space="preserve">
          <source>Function std::env::current_dir</source>
          <target state="translated">Función std::env::directorio_actual</target>
        </trans-unit>
        <trans-unit id="33c219e274f54fd4c2901cadeb8cb8a1716b07ee" translate="yes" xml:space="preserve">
          <source>Function std::env::current_exe</source>
          <target state="translated">Función std::env::current_exe</target>
        </trans-unit>
        <trans-unit id="93bdb0baaee9eb9479f683bb8e51de0bf9436845" translate="yes" xml:space="preserve">
          <source>Function std::env::home_dir</source>
          <target state="translated">Función std::env::home_dir</target>
        </trans-unit>
        <trans-unit id="dc6d846e434726288d053c67c7f123047bc5b25a" translate="yes" xml:space="preserve">
          <source>Function std::env::join_paths</source>
          <target state="translated">Función std::env::join_paths</target>
        </trans-unit>
        <trans-unit id="bbe13942873b051106118872ceff377d6414cbd0" translate="yes" xml:space="preserve">
          <source>Function std::env::remove_var</source>
          <target state="translated">Función std::env::remove_var</target>
        </trans-unit>
        <trans-unit id="a0ef2707df0c48fd4a3170eabef1fe897798e008" translate="yes" xml:space="preserve">
          <source>Function std::env::set_current_dir</source>
          <target state="translated">Función std::env::set_current_dir</target>
        </trans-unit>
        <trans-unit id="40c0dc02c3e18407f97eaa7464d7aab31d55dfea" translate="yes" xml:space="preserve">
          <source>Function std::env::set_var</source>
          <target state="translated">Función std::env::set_var</target>
        </trans-unit>
        <trans-unit id="59db75e19e909089d5b25a261bb16556aafffc1d" translate="yes" xml:space="preserve">
          <source>Function std::env::split_paths</source>
          <target state="translated">Función std::env::split_paths</target>
        </trans-unit>
        <trans-unit id="c9d56410023af3d25f02f24fd607ad8d19e28e03" translate="yes" xml:space="preserve">
          <source>Function std::env::temp_dir</source>
          <target state="translated">Función std::env::temp_dir</target>
        </trans-unit>
        <trans-unit id="b44ade5af9baa85bddb409115f11d8a3c50eb27b" translate="yes" xml:space="preserve">
          <source>Function std::env::var</source>
          <target state="translated">Función std::env::var</target>
        </trans-unit>
        <trans-unit id="515bff141b585b0fb43f2fd81c4ab54894f59b00" translate="yes" xml:space="preserve">
          <source>Function std::env::var_os</source>
          <target state="translated">Función std::env::var_os</target>
        </trans-unit>
        <trans-unit id="50d6f97705009dc1e9db00019a283d41dc6945fd" translate="yes" xml:space="preserve">
          <source>Function std::env::vars</source>
          <target state="translated">Función std::env::vars</target>
        </trans-unit>
        <trans-unit id="d0827162d968005e34a0d42ba5ac51aa36efcf56" translate="yes" xml:space="preserve">
          <source>Function std::env::vars_os</source>
          <target state="translated">Función std::env::vars_os</target>
        </trans-unit>
        <trans-unit id="797538d7608a17a03d5648866da9d6b3f078ba33" translate="yes" xml:space="preserve">
          <source>Function std::fmt::format</source>
          <target state="translated">Función std::fmt::formato</target>
        </trans-unit>
        <trans-unit id="76a06aa8251b2d9f167fedfb35746c3cf97e2ac8" translate="yes" xml:space="preserve">
          <source>Function std::fmt::write</source>
          <target state="translated">Función std::fmt::escribir</target>
        </trans-unit>
        <trans-unit id="7fdb91a20cf7c4148e5350b6228d741645e0e6c4" translate="yes" xml:space="preserve">
          <source>Function std::fs::canonicalize</source>
          <target state="translated">Función std::fs::canonizar</target>
        </trans-unit>
        <trans-unit id="44ca34ff0e7fcde3369397bebf2cb450b447625e" translate="yes" xml:space="preserve">
          <source>Function std::fs::copy</source>
          <target state="translated">Función std::fs::copy</target>
        </trans-unit>
        <trans-unit id="79b6cf93dfdb5969925a9bbf30fbc1a32165b6cc" translate="yes" xml:space="preserve">
          <source>Function std::fs::create_dir</source>
          <target state="translated">Función std::fs::crear_dir</target>
        </trans-unit>
        <trans-unit id="649c1df373944ba216c813f37e0990377d5a6ab3" translate="yes" xml:space="preserve">
          <source>Function std::fs::create_dir_all</source>
          <target state="translated">Función std::fs::crear_dir_todos</target>
        </trans-unit>
        <trans-unit id="aec64a3774022c217f50a9076ac42b9fb6d48ec2" translate="yes" xml:space="preserve">
          <source>Function std::fs::hard_link</source>
          <target state="translated">Función std::fs::hard_link</target>
        </trans-unit>
        <trans-unit id="2e6dfe4827a34c58684389da7b0164086c1599e4" translate="yes" xml:space="preserve">
          <source>Function std::fs::metadata</source>
          <target state="translated">Función std::fs::metadatos</target>
        </trans-unit>
        <trans-unit id="257ab42da62059ca592eb29ecce0ba6bb9f767ea" translate="yes" xml:space="preserve">
          <source>Function std::fs::read</source>
          <target state="translated">Función std::fs::leer</target>
        </trans-unit>
        <trans-unit id="488209597226b1646d1224bfbda57c84f45dc7d2" translate="yes" xml:space="preserve">
          <source>Function std::fs::read_dir</source>
          <target state="translated">Función std::fs::dir_lectura</target>
        </trans-unit>
        <trans-unit id="0f7c945a8871e4c87b4c07b8880a2b36fc0ce855" translate="yes" xml:space="preserve">
          <source>Function std::fs::read_link</source>
          <target state="translated">Función std::fs::read_link</target>
        </trans-unit>
        <trans-unit id="28b8da08cde6c3f8ae6f6e98d4dd66e03f939569" translate="yes" xml:space="preserve">
          <source>Function std::fs::read_to_string</source>
          <target state="translated">Función std::fs::read_to_string</target>
        </trans-unit>
        <trans-unit id="1069c1141b6eaeb5de5bd2c0a071bfa97d894617" translate="yes" xml:space="preserve">
          <source>Function std::fs::remove_dir</source>
          <target state="translated">Función std::fs::remove_dir</target>
        </trans-unit>
        <trans-unit id="c3cdc1eed161b18d3222b0df7bb2a073cb3a3c45" translate="yes" xml:space="preserve">
          <source>Function std::fs::remove_dir_all</source>
          <target state="translated">Función std::fs::remove_dir_all</target>
        </trans-unit>
        <trans-unit id="cbcb0bbc9d59dd97c42d329740ea7f8f01cc1fb7" translate="yes" xml:space="preserve">
          <source>Function std::fs::remove_file</source>
          <target state="translated">Función std::fs::eliminar_fichero</target>
        </trans-unit>
        <trans-unit id="af4b065e7ab7d2238b740f9812576377e5cd02d1" translate="yes" xml:space="preserve">
          <source>Function std::fs::rename</source>
          <target state="translated">Función std::fs::renombrar</target>
        </trans-unit>
        <trans-unit id="62954bd39f77dcd80b31f5a005cdf3185851bf80" translate="yes" xml:space="preserve">
          <source>Function std::fs::set_permissions</source>
          <target state="translated">Función std::fs::set_permissions</target>
        </trans-unit>
        <trans-unit id="b73007edcf070db673623f198d05db893c057abf" translate="yes" xml:space="preserve">
          <source>Function std::fs::soft_link</source>
          <target state="translated">Función std::fs::soft_link</target>
        </trans-unit>
        <trans-unit id="c1609b2e48046eeca39f684e9f2c1c5ab0e14c04" translate="yes" xml:space="preserve">
          <source>Function std::fs::symlink_metadata</source>
          <target state="translated">Función std::fs::symlink_metadata</target>
        </trans-unit>
        <trans-unit id="42a53d0022af817a39762880cd798efaddb33270" translate="yes" xml:space="preserve">
          <source>Function std::fs::write</source>
          <target state="translated">Función std::fs::escribir</target>
        </trans-unit>
        <trans-unit id="62fd296f6f9b7133ed05bfd466c7521be0878aa1" translate="yes" xml:space="preserve">
          <source>Function std::future::pending</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6699b0ab5f182e75bd293dd09c4b93781b378dbb" translate="yes" xml:space="preserve">
          <source>Function std::future::ready</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44b1ca263375f3e80c5d474d85e7edb549b59317" translate="yes" xml:space="preserve">
          <source>Function std::hint::black_box</source>
          <target state="translated">Función std::hint::black_box</target>
        </trans-unit>
        <trans-unit id="23fd76dd636e9b48c8e0406a01f4377257e851c2" translate="yes" xml:space="preserve">
          <source>Function std::hint::spin_loop</source>
          <target state="translated">Función std::hint::spin_loop</target>
        </trans-unit>
        <trans-unit id="c1dcca4e40039d28eec49d9f033066ddf377892d" translate="yes" xml:space="preserve">
          <source>Function std::hint::unreachable_unchecked</source>
          <target state="translated">Función std::hint::unreachable_unchecked</target>
        </trans-unit>
        <trans-unit id="c04a12aeb32eb6ee408f0172379e7189d04f7fa7" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::abort</source>
          <target state="translated">Función std::intrínseca::abortar</target>
        </trans-unit>
        <trans-unit id="083951e2b60b4a5d3ecc13ab8a8c68c9bcb5e379" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::add_with_overflow</source>
          <target state="translated">Función std::intrínseca::añadir_con_desbordamiento</target>
        </trans-unit>
        <trans-unit id="9576b2752f5e3b22d5d58bfbf2ee067369a00927" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::arith_offset</source>
          <target state="translated">Función std::intrínseca::arith_offset</target>
        </trans-unit>
        <trans-unit id="d1ebe0c7b1746455b6d7f17b0dad2bb65a6220bc" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::assert_inhabited</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f408cd1d9ec75e6daddf85e169dfa1b0b29c8cdd" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::assert_uninit_valid</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52ee7c75a0303f4182be7832e7932f58a4cf0a1c" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::assert_zero_valid</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55e9043125ea3a71432799ddbd5b5de5c59e4507" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::assume</source>
          <target state="translated">Función std::intrínseca::asumir</target>
        </trans-unit>
        <trans-unit id="97bd81f0aecc23f2c1c6e2f2556a8a5a193fa85e" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_and</source>
          <target state="translated">Función std::intrínseca::atómica_y</target>
        </trans-unit>
        <trans-unit id="83db485cd65a9c1d60ee6553eeb93464c015dcd6" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_and_acq</source>
          <target state="translated">Función std::intrínseca::atómica_y_acq</target>
        </trans-unit>
        <trans-unit id="2a136fca51e5841f60fee7bd01c6763f69802dd1" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_and_acqrel</source>
          <target state="translated">Función std::intrínseca::atómica_y_acqrel</target>
        </trans-unit>
        <trans-unit id="de28434a57082bbad9e31bcf13a493f64eeed44c" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_and_rel</source>
          <target state="translated">Función std::intrínseca::atómica_y_rel</target>
        </trans-unit>
        <trans-unit id="35b947f77ad8b80a16f2858b7963283c7447f554" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_and_relaxed</source>
          <target state="translated">Función std::intrínseca::atómica_y_relajada</target>
        </trans-unit>
        <trans-unit id="a85031e9d18ed4fd2273a2554abf20d5d0e04d42" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_cxchg</source>
          <target state="translated">Función std::intrínseca::atomic_cxchg</target>
        </trans-unit>
        <trans-unit id="21bafabb725c8d186f53d9a39873b76562515d5e" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_cxchg_acq</source>
          <target state="translated">Función std::intrínseca::atomic_cxchg_acq</target>
        </trans-unit>
        <trans-unit id="9956c269fbb5ef5958060b15ea303e7f003fbf56" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_cxchg_acq_failrelaxed</source>
          <target state="translated">Función std::intrínseca::atomic_cxchg_acq_failrelaxed</target>
        </trans-unit>
        <trans-unit id="e1a505536784b5179da9f68a2284af4a99c45b36" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_cxchg_acqrel</source>
          <target state="translated">Función std::intrínseca::atomic_cxchg_acqrel</target>
        </trans-unit>
        <trans-unit id="192a1cc6826d7c91266da1d6cb911584811f7a90" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_cxchg_acqrel_failrelaxed</source>
          <target state="translated">Función std::intrínseca::atomic_cxchg_acqrel_failrelaxed</target>
        </trans-unit>
        <trans-unit id="0156b2ddfed79dfb74958e12504cd6470faf5b91" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_cxchg_failacq</source>
          <target state="translated">Función std::intrínseca::atomic_cxchg_failacq</target>
        </trans-unit>
        <trans-unit id="55409e6ca1ad5c432b928eb8ce23a904c33f647f" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_cxchg_failrelaxed</source>
          <target state="translated">Función std::intrínseca::atomic_cxchg_failrelaxed</target>
        </trans-unit>
        <trans-unit id="39f0c4bec736294fa36eea7dac60d5fa82a8a97d" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_cxchg_rel</source>
          <target state="translated">Función std::intrínseca::atomic_cxchg_rel</target>
        </trans-unit>
        <trans-unit id="eaaab3b78d863b2e9f71342b771707d5b6ede81a" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_cxchg_relaxed</source>
          <target state="translated">Función std::intrínseca::atomic_cxchg_relaxed</target>
        </trans-unit>
        <trans-unit id="23a2de8b090010417f7343ed9f647e4c4638c9fe" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_cxchgweak</source>
          <target state="translated">Función std::intrínseca::atomic_cxchgweak</target>
        </trans-unit>
        <trans-unit id="d32ebae9ccacf8b7aaf5dcdd672e08c3462188de" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_cxchgweak_acq</source>
          <target state="translated">Función std::intrínseca::atomic_cxchgweak_acq</target>
        </trans-unit>
        <trans-unit id="a0d6493411c30c055a9bbf2189993ff6cb18a401" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_cxchgweak_acq_failrelaxed</source>
          <target state="translated">Función std::intrínseca::atomic_cxchgweak_acq_failrelaxed</target>
        </trans-unit>
        <trans-unit id="84d51cb5de7124a1441c5850c06600665e87afbf" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_cxchgweak_acqrel</source>
          <target state="translated">Función std::intrínseca::atomic_cxchgweak_acqrel</target>
        </trans-unit>
        <trans-unit id="be384c57178230ae73b1a71a2f45edbcd29561cb" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_cxchgweak_acqrel_failrelaxed</source>
          <target state="translated">Función std::intrínseca::atomic_cxchgweak_acqrel_failrelaxed</target>
        </trans-unit>
        <trans-unit id="1cae0c31481303abd7d3122fbbb4550b4b0fe2ae" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_cxchgweak_failacq</source>
          <target state="translated">Función std::intrínseca::atomic_cxchgweak_failacq</target>
        </trans-unit>
        <trans-unit id="b2a3b45d3b55aecacb1cf5ad3f42130bd04b90ee" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_cxchgweak_failrelaxed</source>
          <target state="translated">Función std::intrínseca::atomic_cxchgweak_failrelaxed</target>
        </trans-unit>
        <trans-unit id="dbdc85ce325264420dee74eb369011abf2328c62" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_cxchgweak_rel</source>
          <target state="translated">Función std::intrínseca::atomic_cxchgweak_rel</target>
        </trans-unit>
        <trans-unit id="dfea14fc309810b18b76b8d8d9eea0624c669c56" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_cxchgweak_relaxed</source>
          <target state="translated">Función std::intrínseca::atomic_cxchgweak_relaxed</target>
        </trans-unit>
        <trans-unit id="93e77549e8c09b3d6a47e1aae1153a3c86f218d6" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_fence</source>
          <target state="translated">Función std::intrínseca::valla_atómica</target>
        </trans-unit>
        <trans-unit id="9e80e29f5375e2b133e83fcec9042440ad13c3ab" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_fence_acq</source>
          <target state="translated">Función std::intrínseca::atomic_fence_acq</target>
        </trans-unit>
        <trans-unit id="e276f5f0bdfe137b7fb724ce874c30180445d419" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_fence_acqrel</source>
          <target state="translated">Función std::intrínseca::atomic_fence_acqrel</target>
        </trans-unit>
        <trans-unit id="5e0c13004af1995e4249efaadcf55bab23d8b1f0" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_fence_rel</source>
          <target state="translated">Función std::intrínseca::atomic_fence_rel</target>
        </trans-unit>
        <trans-unit id="fa5f8c9ce76fefde99e7d3efd807ca1a43f8ab6c" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_load</source>
          <target state="translated">Función std::intrínseca::carga_atómica</target>
        </trans-unit>
        <trans-unit id="12a79df9539f7af796dbd45e1c54ed05f27b0df6" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_load_acq</source>
          <target state="translated">Función std::intrínseca::atomic_load_acq</target>
        </trans-unit>
        <trans-unit id="e773d44fb21e58e51b7c05a644c45d38cd9ed277" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_load_relaxed</source>
          <target state="translated">Función std::intrínseca::atomic_load_relaxed</target>
        </trans-unit>
        <trans-unit id="44d5fbea38425f45c85b674130abc87f20105c47" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_load_unordered</source>
          <target state="translated">Función std::intrínseca::carga_atómica_desordenada</target>
        </trans-unit>
        <trans-unit id="76f39339c62e3cc8ba58c9228348d006ee9dc8cb" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_max</source>
          <target state="translated">Función std::intrínseca::atomic_max</target>
        </trans-unit>
        <trans-unit id="adfa1e651df3ca8dba7602e63cea98a1124a3cd4" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_max_acq</source>
          <target state="translated">Función std::intrínseca::atomic_max_acq</target>
        </trans-unit>
        <trans-unit id="a3b4665a7942063ce1a70d83d46c8633384f998d" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_max_acqrel</source>
          <target state="translated">Función std::intrínseca::atomic_max_acqrel</target>
        </trans-unit>
        <trans-unit id="ac0d6a9ff3e4081282044c1c5ed630f732b0b4ef" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_max_rel</source>
          <target state="translated">Función std::intrínseca::atomic_max_rel</target>
        </trans-unit>
        <trans-unit id="68181ba12e9fcb9131b0368bcff2f202617a904e" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_max_relaxed</source>
          <target state="translated">Función std::intrínseca::atomic_max_relaxed</target>
        </trans-unit>
        <trans-unit id="03d60645d9fdf40f0cdeadc9c62a66beccce73b2" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_min</source>
          <target state="translated">Función std::intrínseca::atomic_min</target>
        </trans-unit>
        <trans-unit id="f412529642bae09c91a2918ae76b0083cdd116a8" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_min_acq</source>
          <target state="translated">Función std::intrínseca::atomic_min_acq</target>
        </trans-unit>
        <trans-unit id="4f0129fd24c052c26d2cff0213021ffaa5a26141" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_min_acqrel</source>
          <target state="translated">Función std::intrínseca::atomic_min_acqrel</target>
        </trans-unit>
        <trans-unit id="accc88f6c6162721f5f1f08f16e77b97f84e8136" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_min_rel</source>
          <target state="translated">Función std::intrínseca::atomic_min_rel</target>
        </trans-unit>
        <trans-unit id="1a894d7d0ff97fe3d1bff6f23c3876e0e8d5cf01" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_min_relaxed</source>
          <target state="translated">Función std::intrínseca::atomic_min_relaxed</target>
        </trans-unit>
        <trans-unit id="2d5cfe1e0da2c8b604a13fb0c4d5def3bcc0fe05" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_nand</source>
          <target state="translated">Función std::intrínseca::atomic_nand</target>
        </trans-unit>
        <trans-unit id="20cb0e70c7eab21657d6b9196e100e7a7268e389" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_nand_acq</source>
          <target state="translated">Función std::intrínseca::atomic_nand_acq</target>
        </trans-unit>
        <trans-unit id="d829c3f5e5c25cd5f078e02412ed8b497893e505" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_nand_acqrel</source>
          <target state="translated">Función std::intrínseca::atomic_nand_acqrel</target>
        </trans-unit>
        <trans-unit id="51745bee93cb553dd515cd26d97a744e50b00f88" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_nand_rel</source>
          <target state="translated">Función std::intrínseca::atomic_nand_rel</target>
        </trans-unit>
        <trans-unit id="8f2184a53d3faf2dfbc8096bda41da42742d4b11" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_nand_relaxed</source>
          <target state="translated">Función std::intrínseca::atomic_nand_relaxed</target>
        </trans-unit>
        <trans-unit id="e15a1fa056a17ed12cc0ca7d799d64f4b13ff6b8" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_or</source>
          <target state="translated">Función std::intrínseca::atómica_o</target>
        </trans-unit>
        <trans-unit id="b9d93151e4115df6ee3345d8dd3e7a0481a98842" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_or_acq</source>
          <target state="translated">Función std::intrínseca::atómica_o_acq</target>
        </trans-unit>
        <trans-unit id="aa3340aafd6e5592ddd2e22891c16b56b7d9e0a8" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_or_acqrel</source>
          <target state="translated">Función std::intrínseca::atómica_o_acqrel</target>
        </trans-unit>
        <trans-unit id="c8119dff5e090cc7f4cf0747a6a6c6d4b63325b3" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_or_rel</source>
          <target state="translated">Función std::intrínseca::atómica_o_rel</target>
        </trans-unit>
        <trans-unit id="dc81e065a9758719576edcdd6d60fa47c707097e" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_or_relaxed</source>
          <target state="translated">Función std::intrínseca::atómica_o_relajada</target>
        </trans-unit>
        <trans-unit id="e81aaceb1658f487c55b38d935c756ae401295c3" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_singlethreadfence</source>
          <target state="translated">Función std::intrínseca::atomic_singlethreadfence</target>
        </trans-unit>
        <trans-unit id="4402db0d845f0af53cd4059d26807a4df5d6498c" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_singlethreadfence_acq</source>
          <target state="translated">Función std::intrínseca::atomic_singlethreadfence_acq</target>
        </trans-unit>
        <trans-unit id="9ebbf7f70d332b8ce126f2b6c1afe34a6b19b914" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_singlethreadfence_acqrel</source>
          <target state="translated">Función std::intrínseca::atomic_singlethreadfence_acqrel</target>
        </trans-unit>
        <trans-unit id="ffd7f5b2ce700d60a15d682ab64dd10cccc20ad4" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_singlethreadfence_rel</source>
          <target state="translated">Función std::intrínseca::atomic_singlethreadfence_rel</target>
        </trans-unit>
        <trans-unit id="0c2a81d047c561e9cb87fb39f4b1b32eebbf8ca8" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_store</source>
          <target state="translated">Función std::intrínseca::tienda_atómica</target>
        </trans-unit>
        <trans-unit id="2ee549969e877c7b27baf516286ad29d8db0c0dc" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_store_rel</source>
          <target state="translated">Función std::intrínseca::atomic_store_rel</target>
        </trans-unit>
        <trans-unit id="590261a38bfb6fc19deeb0e18f6328d56154e62c" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_store_relaxed</source>
          <target state="translated">Función std::intrínseca::atomic_store_relaxed</target>
        </trans-unit>
        <trans-unit id="709a5314326fee461b3fe825b79f13e4bbc51906" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_store_unordered</source>
          <target state="translated">Función std::intrínseca::tienda_atómica_desordenada</target>
        </trans-unit>
        <trans-unit id="2f05d15ea8839ab0a5f6a982beb914d4cd94497f" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_umax</source>
          <target state="translated">Función std::intrínseca::atomic_umax</target>
        </trans-unit>
        <trans-unit id="58caab0e44c28da818bfa8b21fb1e0a3854275db" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_umax_acq</source>
          <target state="translated">Función std::intrínseca::atomic_umax_acq</target>
        </trans-unit>
        <trans-unit id="485410d09deb7d4db9b4294336198ec95c5aac38" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_umax_acqrel</source>
          <target state="translated">Función std::intrínseca::atomic_umax_acqrel</target>
        </trans-unit>
        <trans-unit id="e7d030aa6897ab0c8e4b57031c7be08644c7d4a4" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_umax_rel</source>
          <target state="translated">Función std::intrínseca::atomic_umax_rel</target>
        </trans-unit>
        <trans-unit id="1c60325138a8d36005ec6ea575e5ea16dc74339b" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_umax_relaxed</source>
          <target state="translated">Función std::intrínseca::atomic_umax_relaxed</target>
        </trans-unit>
        <trans-unit id="b5cd699b1fc54fbec84c2a134a8833717d98009a" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_umin</source>
          <target state="translated">Función std::intrínseca::atomic_umin</target>
        </trans-unit>
        <trans-unit id="f66c3e7aa0946f69185ad6161b3e2b5d1c7c0360" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_umin_acq</source>
          <target state="translated">Función std::intrínseca::atomic_umin_acq</target>
        </trans-unit>
        <trans-unit id="6e3486c411158f0476ad8b3eb187ad36f8e05522" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_umin_acqrel</source>
          <target state="translated">Función std::intrínseca::atomic_umin_acqrel</target>
        </trans-unit>
        <trans-unit id="e8b768c6a791e83dfbc74046b1f169cc0824883d" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_umin_rel</source>
          <target state="translated">Función std::intrínseca::atomic_umin_rel</target>
        </trans-unit>
        <trans-unit id="8152554e0ce02fe3689452d05678c8a75c70e6cb" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_umin_relaxed</source>
          <target state="translated">Función std::intrínseca::atomic_umin_relaxed</target>
        </trans-unit>
        <trans-unit id="2c9460022df088a0a553484dcfacf73c4d2c6c49" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_xadd</source>
          <target state="translated">Función std::intrínseca::atomic_xadd</target>
        </trans-unit>
        <trans-unit id="bbfbb2d9fa5b20d2d0a52f974a74a8be7d1250a3" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_xadd_acq</source>
          <target state="translated">Función std::intrínseca::atomic_xadd_acq</target>
        </trans-unit>
        <trans-unit id="80a5c9fa25e8dacd29916af7a7876806c0c7b801" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_xadd_acqrel</source>
          <target state="translated">Función std::intrínseca::atomic_xadd_acqrel</target>
        </trans-unit>
        <trans-unit id="2681580a518ae1108079209ad3e87c09ac578238" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_xadd_rel</source>
          <target state="translated">Función std::intrínseca::atomic_xadd_rel</target>
        </trans-unit>
        <trans-unit id="a6632774d34b6d8bdf98921289f3bf98305b65c3" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_xadd_relaxed</source>
          <target state="translated">Función std::intrínseca::atomic_xadd_relaxed</target>
        </trans-unit>
        <trans-unit id="680cf8b973773ce9f5cb5d5e143980ef48d38f83" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_xchg</source>
          <target state="translated">Función std::intrínseca::atomic_xchg</target>
        </trans-unit>
        <trans-unit id="06fa06a9a882944323a8537e5812f44de2b15574" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_xchg_acq</source>
          <target state="translated">Función std::intrínseca::atomic_xchg_acq</target>
        </trans-unit>
        <trans-unit id="514738ba82bccec7209c92dc3e542667c9f46aa0" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_xchg_acqrel</source>
          <target state="translated">Función std::intrínseca::atomic_xchg_acqrel</target>
        </trans-unit>
        <trans-unit id="e7e8b533420ea0deb98c9b6023dbdbf8c22178a5" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_xchg_rel</source>
          <target state="translated">Función std::intrínseca::atomic_xchg_rel</target>
        </trans-unit>
        <trans-unit id="b92febd7f8f2a2256f778fadeb825e82008c19e9" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_xchg_relaxed</source>
          <target state="translated">Función std::intrínseca::atomic_xchg_relaxed</target>
        </trans-unit>
        <trans-unit id="2ea2937587ac1814222761b67af1039837c7653d" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_xor</source>
          <target state="translated">Función std::intrínseca::atomic_xor</target>
        </trans-unit>
        <trans-unit id="707de9981acd22a67a9431dbb504cf4159395ac2" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_xor_acq</source>
          <target state="translated">Función std::intrínseca::atomic_xor_acq</target>
        </trans-unit>
        <trans-unit id="833e4418ab431a17a9d91675e43ac8138046eb6d" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_xor_acqrel</source>
          <target state="translated">Función std::intrínseca::atomic_xor_acqrel</target>
        </trans-unit>
        <trans-unit id="35ec5057adba987f011914a33d5a6c2d44c7e8e4" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_xor_rel</source>
          <target state="translated">Función std::intrínseca::atomic_xor_rel</target>
        </trans-unit>
        <trans-unit id="b44cf1a28973fbd20f73163fe499efb58d6f607f" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_xor_relaxed</source>
          <target state="translated">Función std::intrínseca::atomic_xor_relaxed</target>
        </trans-unit>
        <trans-unit id="3b36393cd0aa9496b4ae784a4407d76dc0812c10" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_xsub</source>
          <target state="translated">Función std::intrínseca::atomic_xsub</target>
        </trans-unit>
        <trans-unit id="0e05edf4266ca38cec129d7cbea17e2b5615af9c" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_xsub_acq</source>
          <target state="translated">Función std::intrínseca::atomic_xsub_acq</target>
        </trans-unit>
        <trans-unit id="ec5065f3f0f50521d5a5dce38c88ff20b63d0fa5" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_xsub_acqrel</source>
          <target state="translated">Función std::intrínseca::atomic_xsub_acqrel</target>
        </trans-unit>
        <trans-unit id="8ef37695d8e866884c3d116d76da8d567f0eb2b0" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_xsub_rel</source>
          <target state="translated">Función std::intrínseca::atomic_xsub_rel</target>
        </trans-unit>
        <trans-unit id="9535a9ea988c35b98c9a100edb8dbbfcdb21cc0a" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::atomic_xsub_relaxed</source>
          <target state="translated">Función std::intrínseca::atomic_xsub_relaxed</target>
        </trans-unit>
        <trans-unit id="0260761aac2d147168334337babec7c746cf1e11" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::bitreverse</source>
          <target state="translated">Función std::intrínseca::bitreverse</target>
        </trans-unit>
        <trans-unit id="349680778834fca16f9d706876d86fef2c5f6a4d" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::breakpoint</source>
          <target state="translated">Función std::intrínseca::punto de ruptura</target>
        </trans-unit>
        <trans-unit id="44a50e7b9e7f8cceb58990743bc9f61879dd5383" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::bswap</source>
          <target state="translated">Función std::intrínseca::bswap</target>
        </trans-unit>
        <trans-unit id="ae109593fcee3317c44f07c366f8e95547100492" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::caller_location</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8a2bd170e3a75454c4f05d5bbcb8639c2aa54ff" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::ceilf32</source>
          <target state="translated">Función std::intrínseca::ceilf32</target>
        </trans-unit>
        <trans-unit id="976747cd2c5e09a74b339fc0666d68d4cfde0c5e" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::ceilf64</source>
          <target state="translated">Función std::intrínseca::ceilf64</target>
        </trans-unit>
        <trans-unit id="92178f80cf649440eb1a78675233ea868603f646" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::const_allocate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faffd8585027515ddae4f1331689122329742d1c" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::copy</source>
          <target state="translated">Función std::intrínseca::copia</target>
        </trans-unit>
        <trans-unit id="7f8aef550653229ec93aa002745a05a7de864fc8" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::copy_nonoverlapping</source>
          <target state="translated">Función std::intrínseca::copy_nonoverlapping</target>
        </trans-unit>
        <trans-unit id="b1913a2055a535ce3e7b5d8fcdb5564f85606921" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::copysignf32</source>
          <target state="translated">Función std::intrínseca::copysignf32</target>
        </trans-unit>
        <trans-unit id="137086a9e3acf79d7f58e815b9cf53cf5c487284" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::copysignf64</source>
          <target state="translated">Función std::intrínseca::copysignf64</target>
        </trans-unit>
        <trans-unit id="ba20d643ea9b3e1f178eae70ce17f616603801ed" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::cosf32</source>
          <target state="translated">Función std::intrínseca::cosf32</target>
        </trans-unit>
        <trans-unit id="7844690936abbf209a7dc3fedfccc3bbd90ec9cc" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::cosf64</source>
          <target state="translated">Función std::intrínseca::cosf64</target>
        </trans-unit>
        <trans-unit id="545d20596e2a8383e286ad517cc0ec75c2f9ab02" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::ctlz</source>
          <target state="translated">Función std::intrínseca::ctlz</target>
        </trans-unit>
        <trans-unit id="586da9633fdd054b9e8a48419276b9ebfe15778d" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::ctlz_nonzero</source>
          <target state="translated">Función std::intrínseca::ctlz_nonzero</target>
        </trans-unit>
        <trans-unit id="78aa0af231e9d9cdb012b5f501d915f806f6f319" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::ctpop</source>
          <target state="translated">Función std::intrínseca::ctpop</target>
        </trans-unit>
        <trans-unit id="8e1aff64d8386fcb240654511fcd6b1efe27e021" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::cttz</source>
          <target state="translated">Función std::intrínseca::cttz</target>
        </trans-unit>
        <trans-unit id="8203326fe691f7f3a7d6ceb9fbe41c6aa246d5ad" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::cttz_nonzero</source>
          <target state="translated">Función std::intrínseca::cttz_nonzero</target>
        </trans-unit>
        <trans-unit id="3cafd9582dca45d45f6436f5c5cc310e40a2e757" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::discriminant_value</source>
          <target state="translated">Función std::intrínseca::valor_discriminatorio</target>
        </trans-unit>
        <trans-unit id="310254651639c9db365ac028773fcd16703837c0" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::drop_in_place</source>
          <target state="translated">Función std::intrínseca::drop_in_place</target>
        </trans-unit>
        <trans-unit id="6504fb6abec53cb5ae5ba0d14dc3bbdc1460d019" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::exact_div</source>
          <target state="translated">Función std::intrínseca::exact_div</target>
        </trans-unit>
        <trans-unit id="82932dd085b91a4d031ba681d9948195cde3cd38" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::exp2f32</source>
          <target state="translated">Función std::intrínseca::exp2f32</target>
        </trans-unit>
        <trans-unit id="e028afe12378e9a7dec9c17ebc90e34a8dc9600f" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::exp2f64</source>
          <target state="translated">Función std::intrínseca::exp2f64</target>
        </trans-unit>
        <trans-unit id="18af580843073152f816810c9976eb7720febbca" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::expf32</source>
          <target state="translated">Función std::intrínseca::expf32</target>
        </trans-unit>
        <trans-unit id="a487e6b4e2e45873fc4f641e5c506c952d1524af" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::expf64</source>
          <target state="translated">Función std::intrínseca::expf64</target>
        </trans-unit>
        <trans-unit id="a8adaa7a58d666f4fbdf1e5525dfd0c198e51252" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::fabsf32</source>
          <target state="translated">Función std::intrínseca::fabsf32</target>
        </trans-unit>
        <trans-unit id="7629eebcb33c16f80571048ef86b1dfdd1a0f885" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::fabsf64</source>
          <target state="translated">Función std::intrínseca::fabsf64</target>
        </trans-unit>
        <trans-unit id="69b4f3a5e06eb557862c2a57da3d1fc73419e30a" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::fadd_fast</source>
          <target state="translated">Función std::intrínseca::fadd_fast</target>
        </trans-unit>
        <trans-unit id="c7a18d7f11ba26cb1ed1051c2e9c904a9165cd84" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::fdiv_fast</source>
          <target state="translated">Función std::intrínseca::fdiv_fast</target>
        </trans-unit>
        <trans-unit id="728738500bc610f4175ce66f13bc4fc3cdc7d6d4" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::float_to_int_unchecked</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53805e4a6d094a1ed0fc8ae314253cf3d18e4925" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::floorf32</source>
          <target state="translated">Función std::intrínseca::floorf32</target>
        </trans-unit>
        <trans-unit id="5087cca6667fde2e528e02304268dd29727f68d5" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::floorf64</source>
          <target state="translated">Función std::intrínseca::floorf64</target>
        </trans-unit>
        <trans-unit id="6d9e80778a8a8bb7b076af29d264cc6ac4d31464" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::fmaf32</source>
          <target state="translated">Función std::intrínseca::fmaf32</target>
        </trans-unit>
        <trans-unit id="69ccf507111b23d6b5f24105fccac6844e451347" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::fmaf64</source>
          <target state="translated">Función std::intrínseca::fmaf64</target>
        </trans-unit>
        <trans-unit id="2349408da65549dbec5bb73465311981246bbf97" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::fmul_fast</source>
          <target state="translated">Función std::intrínseca::fmul_fast</target>
        </trans-unit>
        <trans-unit id="cceed86fa20f56a919cf803345dd9b828df9674a" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::forget</source>
          <target state="translated">Función std::intrínseca::olvidar</target>
        </trans-unit>
        <trans-unit id="86f07f2b4a1330c776c20237c7c64e5350fe7a5e" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::frem_fast</source>
          <target state="translated">Función std::intrínseca::frem_fast</target>
        </trans-unit>
        <trans-unit id="231639afbfa8bf549bf19aa8a5784f9d60021d98" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::fsub_fast</source>
          <target state="translated">Función std::intrínseca::fsub_fast</target>
        </trans-unit>
        <trans-unit id="ed9c4a8ed619340f92e2a9df5452869c312b0de1" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::init</source>
          <target state="translated">Función std::intrínseca::init</target>
        </trans-unit>
        <trans-unit id="7c1b33d44ee817a1195ff1ae434f17a8c881520d" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::likely</source>
          <target state="translated">Función std::intrínseca::probable</target>
        </trans-unit>
        <trans-unit id="9c1a2ccf1bde488fbc644dc3f8f44d65849caac1" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::log10f32</source>
          <target state="translated">Función std::intrínseca::log10f32</target>
        </trans-unit>
        <trans-unit id="20d4bfb5aa64df87eaa6900cf1beefc654cf4a7a" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::log10f64</source>
          <target state="translated">Función std::intrínseca::log10f64</target>
        </trans-unit>
        <trans-unit id="c6b24066c8aa075221162eedd883f8b99c6e7962" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::log2f32</source>
          <target state="translated">Función std::intrínseca::log2f32</target>
        </trans-unit>
        <trans-unit id="9727143de27fc62370d2a1b5926f675d501a3b4d" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::log2f64</source>
          <target state="translated">Función std::intrínseca::log2f64</target>
        </trans-unit>
        <trans-unit id="8932c55ef33afa4acde60b583c83ca8dc7bb2b5d" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::logf32</source>
          <target state="translated">Función std::intrínseca::logf32</target>
        </trans-unit>
        <trans-unit id="7f22cdc0fa2dacd7415fc7e9d0a094184c3cb950" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::logf64</source>
          <target state="translated">Función std::intrínseca::logf64</target>
        </trans-unit>
        <trans-unit id="5d69b377a76975ef03024043cab2db73bb7cfd6e" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::maxnumf32</source>
          <target state="translated">Función std::intrínseca::maxnumf32</target>
        </trans-unit>
        <trans-unit id="a61de5d98ba89ecd434c9fa3a3ec1e6ad271b371" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::maxnumf64</source>
          <target state="translated">Función std::intrínseca::maxnumf64</target>
        </trans-unit>
        <trans-unit id="88db98a255bac3fca6c1a7aded0061f0c5ffb992" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::min_align_of</source>
          <target state="translated">Función std::intrínseca::min_align_of</target>
        </trans-unit>
        <trans-unit id="247c74b0f39ff5d9c9103b8959e5632c25d36333" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::min_align_of_val</source>
          <target state="translated">Función std::intrínseca::min_align_of_val</target>
        </trans-unit>
        <trans-unit id="4e255574eb58b5b232e8ca21b4231687388852a6" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::minnumf32</source>
          <target state="translated">Función std::intrínseca::minnumf32</target>
        </trans-unit>
        <trans-unit id="4cb1c4535cd483762169b7280f6b0d67d38dc715" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::minnumf64</source>
          <target state="translated">Función std::intrínseca::minnumf64</target>
        </trans-unit>
        <trans-unit id="64b7dd1362cd90b88d2e4cf4ba5b57fb272d0e86" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::move_val_init</source>
          <target state="translated">Función std::intrínseca::move_val_init</target>
        </trans-unit>
        <trans-unit id="ba6b9dc8d20816d73a44eae1ff702793043a6c6b" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::mul_with_overflow</source>
          <target state="translated">Función std::intrínseca::mul_con_desbordamiento</target>
        </trans-unit>
        <trans-unit id="cc363bbfcaf0ddc1c5ccc5d4bf6c45a506adf48e" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::nearbyintf32</source>
          <target state="translated">Función std::intrínseca::nearintf32</target>
        </trans-unit>
        <trans-unit id="0e1ee55cf307484318085364bbe8e054ff2d4b2c" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::nearbyintf64</source>
          <target state="translated">Función std::intrínseca::nearintf64</target>
        </trans-unit>
        <trans-unit id="d28a1a5c27c1207609e01cd087a0b7734625a4b6" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::needs_drop</source>
          <target state="translated">Función std::intrínseca::needs_drop</target>
        </trans-unit>
        <trans-unit id="cb650b3e42edf7fc293ce90a39e6cb676d382183" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::nontemporal_store</source>
          <target state="translated">Función std::intrínseca::tienda_no_temporal</target>
        </trans-unit>
        <trans-unit id="fafa1c6d37c3693abf8f4f9d868d6f55012eb92f" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::offset</source>
          <target state="translated">Función std::intrínseca::offset</target>
        </trans-unit>
        <trans-unit id="5a22426f8e762b657e9fc40aeb64ce5e6c72d064" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::overflowing_add</source>
          <target state="translated">Función std::intrínseca::overflowing_add</target>
        </trans-unit>
        <trans-unit id="4df7d5cfb3e78f525f98823f4fdfc3f1b6a232d3" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::overflowing_mul</source>
          <target state="translated">Función std::intrínseca::desbordante_mul</target>
        </trans-unit>
        <trans-unit id="cfd20a808c9a3a59059a78ac374417c18c147162" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::overflowing_sub</source>
          <target state="translated">Función std::intrínseca::desbordamiento_sub</target>
        </trans-unit>
        <trans-unit id="8aab4244d4cb857730352617a712962fe12596d7" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::panic_if_uninhabited</source>
          <target state="translated">Función std::intrínseca::panic_if_uninhabited</target>
        </trans-unit>
        <trans-unit id="c0aa024e255736ab35130f77373eafc270b53271" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::powf32</source>
          <target state="translated">Función std::intrínseca::powf32</target>
        </trans-unit>
        <trans-unit id="01ed7bdb862e4b6b2be4dd8a79730895bdce1811" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::powf64</source>
          <target state="translated">Función std::intrínseca::powf64</target>
        </trans-unit>
        <trans-unit id="687108b30d40e0e24c3c047502aa9ccd4b054f8d" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::powif32</source>
          <target state="translated">Función std::intrínseca::powif32</target>
        </trans-unit>
        <trans-unit id="1ac5843df07be2dac60ad62b042b4211533da2e6" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::powif64</source>
          <target state="translated">Función std::intrínseca::powif64</target>
        </trans-unit>
        <trans-unit id="0a6e8570156d01a735127c81e305ad49d4e17077" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::pref_align_of</source>
          <target state="translated">Función std::intrínseca::pref_align_of</target>
        </trans-unit>
        <trans-unit id="12a6591a462d811e6218d01e0da3c4ce046e4577" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::prefetch_read_data</source>
          <target state="translated">Función std::intrínseca::prefetch_read_data</target>
        </trans-unit>
        <trans-unit id="b612cc839b74b18def501a5c39142a31d05c3251" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::prefetch_read_instruction</source>
          <target state="translated">Función std::intrínseca::prefetch_read_instruction</target>
        </trans-unit>
        <trans-unit id="7cc4fef16b4e3346cf3e97a3bcfa63f4965a73fb" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::prefetch_write_data</source>
          <target state="translated">Función std::intrínseca::prefetch_write_data</target>
        </trans-unit>
        <trans-unit id="98446d47acd3b1adcc37c4e4edac6c4d5d410bc1" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::prefetch_write_instruction</source>
          <target state="translated">Función std::intrínseca::prefetch_write_instruction</target>
        </trans-unit>
        <trans-unit id="b78b0dde74d565e691e47d568598c8a5f9e96e8d" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::ptr_guaranteed_eq</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a7cfb34571d6cf78d023ca56021226516b0af6e" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::ptr_guaranteed_ne</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61ccd968a4d5bc256abbd4d44ad47fe68c6ab584" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::ptr_offset_from</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3635ca7a4ece00d22e8745333a108e09321070e" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::rintf32</source>
          <target state="translated">Función std::intrínseca::rintf32</target>
        </trans-unit>
        <trans-unit id="b52123f2feab6d81200c8b6c82009aa05af9d5e8" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::rintf64</source>
          <target state="translated">Función std::intrínseca::rintf64</target>
        </trans-unit>
        <trans-unit id="5d25a2d6ed8eb295f10db9229d10b9b801b62aac" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::rotate_left</source>
          <target state="translated">Función std::intrínseca::rotar_izquierda</target>
        </trans-unit>
        <trans-unit id="6f64a0f1e08ebc04835dfcafc082dfa995ecca65" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::rotate_right</source>
          <target state="translated">Función std::intrínseca::rotar_derecho</target>
        </trans-unit>
        <trans-unit id="01761bc7b91f5d00e064051e941086db75bc64eb" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::roundf32</source>
          <target state="translated">Función std::intrínseca::roundf32</target>
        </trans-unit>
        <trans-unit id="e3f3c017ce47d7b4613d489a7dfa5c51d99c122a" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::roundf64</source>
          <target state="translated">Función std::intrínseca::roundf64</target>
        </trans-unit>
        <trans-unit id="56592ea3364203da6002bb091c8b5ada90dd06be" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::rustc_peek</source>
          <target state="translated">Función std::intrínseca::rustc_peek</target>
        </trans-unit>
        <trans-unit id="4b62ddf100ee5e23c3b1e9f82f34aa6e7bbce1af" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::saturating_add</source>
          <target state="translated">Función std::intrínseca::saturando_add</target>
        </trans-unit>
        <trans-unit id="c47d89e89860bbcd6e10cd71fc55d76f9c148c16" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::saturating_sub</source>
          <target state="translated">Función std::intrínseca::saturando_sub</target>
        </trans-unit>
        <trans-unit id="a2f910e6e38dfbab9f3fe62488dc49c833f38693" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::sinf32</source>
          <target state="translated">Función std::intrínseca::sinf32</target>
        </trans-unit>
        <trans-unit id="5b619a447d74b5fd6738770896593b7fe76db6ca" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::sinf64</source>
          <target state="translated">Función std::intrínseca::sinf64</target>
        </trans-unit>
        <trans-unit id="602d9a20834ba884f5b93e6b43af744d53b52e84" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::size_of</source>
          <target state="translated">Función std::intrínseca::tamaño_de</target>
        </trans-unit>
        <trans-unit id="d932ae577dbc34467190ebf5837932cf7fbb0e16" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::size_of_val</source>
          <target state="translated">Función std::intrínseca::tamaño_de_valor</target>
        </trans-unit>
        <trans-unit id="d08e2158f5b8cfa3eab183618a77ec54b076b30a" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::sqrtf32</source>
          <target state="translated">Función std::intrínseca::sqrtf32</target>
        </trans-unit>
        <trans-unit id="8dbb591c1397f0ba91c7f236b0a614975c326f6a" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::sqrtf64</source>
          <target state="translated">Función std::intrínseca::sqrtf64</target>
        </trans-unit>
        <trans-unit id="740c5394484a39f579e83b184235503d95960198" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::sub_with_overflow</source>
          <target state="translated">Función std::intrínseca::sub_con_desbordamiento</target>
        </trans-unit>
        <trans-unit id="393e4373d62b400801116f27af3199376f6e2ca1" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::transmute</source>
          <target state="translated">Función std::intrínseca::transmutar</target>
        </trans-unit>
        <trans-unit id="1226c6bc2b3fcfeb6f782c3e8390b9416f380d57" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::truncf32</source>
          <target state="translated">Función std::intrínseca::truncf32</target>
        </trans-unit>
        <trans-unit id="edb587d16baed0c03c665836869638e3d11d6f56" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::truncf64</source>
          <target state="translated">Función std::intrínseca::truncf64</target>
        </trans-unit>
        <trans-unit id="a57d356a02b0ff34ec68a387e9131952f056f9aa" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::try</source>
          <target state="translated">Función std::intrínseca::intentar</target>
        </trans-unit>
        <trans-unit id="048a5087acf80c0faff9b518dcc85010ea41ae06" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::type_id</source>
          <target state="translated">Función std::intrínseca::type_id</target>
        </trans-unit>
        <trans-unit id="e75acaff03c74f3f8ac169c744a94d8a2861e33a" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::type_name</source>
          <target state="translated">Función std::intrínseca::nombre_tipo</target>
        </trans-unit>
        <trans-unit id="187c861d5662a2fda8a4bf5846d843bd0201c65a" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::unaligned_volatile_load</source>
          <target state="translated">Función std::intrínseca::carga_volátil_no alineada</target>
        </trans-unit>
        <trans-unit id="e8eb96d3a4cd10e2625c8223b4805c89ed68cf61" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::unaligned_volatile_store</source>
          <target state="translated">Función std::intrínseca::tienda_volátil_no alineada</target>
        </trans-unit>
        <trans-unit id="93c26151cb053ed2646156176f682b5a446e90f0" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::unchecked_add</source>
          <target state="translated">Función std::intrínseca::unchecked_add</target>
        </trans-unit>
        <trans-unit id="4e47211d92e063ddfd83890496af3139cde8fc16" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::unchecked_div</source>
          <target state="translated">Función std::intrínseca::unchecked_div</target>
        </trans-unit>
        <trans-unit id="ad08da36331e84c72eea9029948dfa845c72a90e" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::unchecked_mul</source>
          <target state="translated">Función std::intrínseca::unchecked_mul</target>
        </trans-unit>
        <trans-unit id="b2134ce439c68a3e1c68abdd0075fe3ce7125860" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::unchecked_rem</source>
          <target state="translated">Función std::intrínseca::unchecked_rem</target>
        </trans-unit>
        <trans-unit id="4c92ba0932c92f93ec0a719533727714b58b0697" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::unchecked_shl</source>
          <target state="translated">Función std::intrínseca::unchecked_shl</target>
        </trans-unit>
        <trans-unit id="ba6d2658ad2136cb3776c0d405847fb2996a7b26" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::unchecked_shr</source>
          <target state="translated">Función std::intrínseca::unchecked_shr</target>
        </trans-unit>
        <trans-unit id="3d1d1be087221db7a4bfc8d7ed23b90aa230d61e" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::unchecked_sub</source>
          <target state="translated">Función std::intrínseca::unchecked_sub</target>
        </trans-unit>
        <trans-unit id="5a775a1f84e4e5935e7a1fa50f24f474b2f2ece9" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::uninit</source>
          <target state="translated">Función std::intrínseca::uninit</target>
        </trans-unit>
        <trans-unit id="ac3412d8fdd72040d3536bb26f45818e160ddc4a" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::unlikely</source>
          <target state="translated">Función std::intrínseca::improbable</target>
        </trans-unit>
        <trans-unit id="bedb934a4c63e4e31201c35f9bd36ac2036acf4c" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::unreachable</source>
          <target state="translated">Función std::intrínseca::inalcanzable</target>
        </trans-unit>
        <trans-unit id="13131be8bd373e055dd1cdba09cc15d8b667e96c" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::variant_count</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="345df5921d118e19bbbe36d890c957478b05ad24" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::volatile_copy_memory</source>
          <target state="translated">Función std::intrínseca::memoria_de_copia_volátil</target>
        </trans-unit>
        <trans-unit id="d15cadb9febd1bff809e35db3daeb66b7188a917" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::volatile_copy_nonoverlapping_memory</source>
          <target state="translated">Función std::intrínseca::volátil_copia_no superpuesta_memoria</target>
        </trans-unit>
        <trans-unit id="07c6d83d44a425af2f32ab2dd74d20f7a63f96d4" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::volatile_load</source>
          <target state="translated">Función std::intrínseca::carga_volátil</target>
        </trans-unit>
        <trans-unit id="c9412efc461309c92b831fdd57c484471b4f3eea" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::volatile_set_memory</source>
          <target state="translated">Función std::intrínseca::volatile_set_memory</target>
        </trans-unit>
        <trans-unit id="1eb394e96696e1469e03dd3a669f002772e46b9a" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::volatile_store</source>
          <target state="translated">Función std::intrínseca::tienda_volátil</target>
        </trans-unit>
        <trans-unit id="bb6344dfce8c3f3f3acf3313bad2be221b6611e8" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::wrapping_add</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22514a7749b9bbbaf53c9706225dfc3714b3d78b" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::wrapping_mul</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb76adfcef09944b7694dbf0862b1566ce5b4820" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::wrapping_sub</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bb898dc02fd331bafb306f521470ae8500576f2" translate="yes" xml:space="preserve">
          <source>Function std::intrinsics::write_bytes</source>
          <target state="translated">Función std::intrínseca::escribir_bytes</target>
        </trans-unit>
        <trans-unit id="1462d4d75a2c1721ae019391a3145504468f86be" translate="yes" xml:space="preserve">
          <source>Function std::io::copy</source>
          <target state="translated">Función std::io::copy</target>
        </trans-unit>
        <trans-unit id="9d322972ffb0afbe003983c33a48b9602bb2f27f" translate="yes" xml:space="preserve">
          <source>Function std::io::empty</source>
          <target state="translated">Función std::io::vacío</target>
        </trans-unit>
        <trans-unit id="0e44261c77f2a9a37128f44301117effed40f1c3" translate="yes" xml:space="preserve">
          <source>Function std::io::repeat</source>
          <target state="translated">Función std::io::repetir</target>
        </trans-unit>
        <trans-unit id="c29e5e3e5ed19f15f59bfadf33f1b68ff0bcec24" translate="yes" xml:space="preserve">
          <source>Function std::io::sink</source>
          <target state="translated">Función std::io::fregadero</target>
        </trans-unit>
        <trans-unit id="f05871015518914000f1553345c9cdc1aacee082" translate="yes" xml:space="preserve">
          <source>Function std::io::stderr</source>
          <target state="translated">Función std::io::stderr</target>
        </trans-unit>
        <trans-unit id="9f387e200f166807748357421615ad6cd24836ef" translate="yes" xml:space="preserve">
          <source>Function std::io::stdin</source>
          <target state="translated">Función std::io::stdin</target>
        </trans-unit>
        <trans-unit id="08deee2644283017a2d65fbd802faf47f51890da" translate="yes" xml:space="preserve">
          <source>Function std::io::stdout</source>
          <target state="translated">Función std::io::stdout</target>
        </trans-unit>
        <trans-unit id="3db86c4bbed75ef0f573f856b5cce7f9cf2ceefb" translate="yes" xml:space="preserve">
          <source>Function std::iter::empty</source>
          <target state="translated">Función std::iter::empty</target>
        </trans-unit>
        <trans-unit id="66b49fad94d10ec92ebc41d1cee4b7f8d9b3b8fd" translate="yes" xml:space="preserve">
          <source>Function std::iter::from_fn</source>
          <target state="translated">Función std::iter::from_fn</target>
        </trans-unit>
        <trans-unit id="dff51980c0868fb23253f76a41dc563a29201f61" translate="yes" xml:space="preserve">
          <source>Function std::iter::once</source>
          <target state="translated">Función std::iter::una vez</target>
        </trans-unit>
        <trans-unit id="3d48207de32201be75ffe9021e62b76b7d2e78dd" translate="yes" xml:space="preserve">
          <source>Function std::iter::once_with</source>
          <target state="translated">Función std::iter::una vez_con</target>
        </trans-unit>
        <trans-unit id="a2b35eb94e24a9505503301e6633d676822bef0c" translate="yes" xml:space="preserve">
          <source>Function std::iter::repeat</source>
          <target state="translated">Función std::iter::repetir</target>
        </trans-unit>
        <trans-unit id="87a88047b36d48b765b5020959d507cb5f244ac7" translate="yes" xml:space="preserve">
          <source>Function std::iter::repeat_with</source>
          <target state="translated">Función std::iter::repetir_con</target>
        </trans-unit>
        <trans-unit id="5ef587525044407aa0b4094d8f081edd2daddc8e" translate="yes" xml:space="preserve">
          <source>Function std::iter::successors</source>
          <target state="translated">Función std::iter::sucesores</target>
        </trans-unit>
        <trans-unit id="e69ba0a2b2f3ad4e91cf8a195f315895ae885650" translate="yes" xml:space="preserve">
          <source>Function std::mem::align_of</source>
          <target state="translated">Función std::mem::align_of</target>
        </trans-unit>
        <trans-unit id="f925a0568c240c6dd15386b07765248dacabf3db" translate="yes" xml:space="preserve">
          <source>Function std::mem::align_of_val</source>
          <target state="translated">Función std::mem::align_of_val</target>
        </trans-unit>
        <trans-unit id="7b7c4699b803f66c38cc6d513902404f9aca8258" translate="yes" xml:space="preserve">
          <source>Function std::mem::align_of_val_raw</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9e95f4da151ab2a40c7e9698a17adc132df0f46" translate="yes" xml:space="preserve">
          <source>Function std::mem::discriminant</source>
          <target state="translated">Función std::mem::discriminante</target>
        </trans-unit>
        <trans-unit id="6475a81fa7667dcc4953d17a2ae5fd2196a16c35" translate="yes" xml:space="preserve">
          <source>Function std::mem::drop</source>
          <target state="translated">Función std::mem::drop</target>
        </trans-unit>
        <trans-unit id="34977281a088ed668126c16ffced4c672d9ee045" translate="yes" xml:space="preserve">
          <source>Function std::mem::forget</source>
          <target state="translated">Función std::mem::olvidar</target>
        </trans-unit>
        <trans-unit id="93c2b9571818c664355ea5a0dcd917eacf555574" translate="yes" xml:space="preserve">
          <source>Function std::mem::forget_unsized</source>
          <target state="translated">Función std::mem::forget_unsized</target>
        </trans-unit>
        <trans-unit id="6ddede8e9373838661e83d5e49c5870ddfc635d4" translate="yes" xml:space="preserve">
          <source>Function std::mem::min_align_of</source>
          <target state="translated">Función std::mem::min_align_of</target>
        </trans-unit>
        <trans-unit id="22810ad4b80752b76f6272e78e7f24408c71745f" translate="yes" xml:space="preserve">
          <source>Function std::mem::min_align_of_val</source>
          <target state="translated">Función std::mem::min_align_of_val</target>
        </trans-unit>
        <trans-unit id="e1b2757db0555bef1a5af563113bea383ea658f1" translate="yes" xml:space="preserve">
          <source>Function std::mem::needs_drop</source>
          <target state="translated">Función std::mem::needs_drop</target>
        </trans-unit>
        <trans-unit id="1d250c3f7215728aec0a7bfa6379b0d693c87c55" translate="yes" xml:space="preserve">
          <source>Function std::mem::replace</source>
          <target state="translated">Función std::mem::reemplazar</target>
        </trans-unit>
        <trans-unit id="273ddf6ee92bb4e40157a902d61bcf24a9c611ad" translate="yes" xml:space="preserve">
          <source>Function std::mem::size_of</source>
          <target state="translated">Función std::mem::tamaño_de</target>
        </trans-unit>
        <trans-unit id="f9365fb71c6db7ab8823f257068c1fa0c61895c4" translate="yes" xml:space="preserve">
          <source>Function std::mem::size_of_val</source>
          <target state="translated">Función std::mem::tamaño_de_valor</target>
        </trans-unit>
        <trans-unit id="15eebd1032b9272993d22267fe558eea496dce70" translate="yes" xml:space="preserve">
          <source>Function std::mem::size_of_val_raw</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bf15dfcadccab356db41c543e7d2dd0719bc54b" translate="yes" xml:space="preserve">
          <source>Function std::mem::swap</source>
          <target state="translated">Función std::mem::swap</target>
        </trans-unit>
        <trans-unit id="a9a358b3691976e722e4f46966a0191a117318e2" translate="yes" xml:space="preserve">
          <source>Function std::mem::take</source>
          <target state="translated">Función std::mem::take</target>
        </trans-unit>
        <trans-unit id="8000c51bce3358a180dec44b363d021f765dee13" translate="yes" xml:space="preserve">
          <source>Function std::mem::transmute</source>
          <target state="translated">Función std::mem::transmute</target>
        </trans-unit>
        <trans-unit id="a34058ce750ce0e9d7fea1e2756db0e58fabdb12" translate="yes" xml:space="preserve">
          <source>Function std::mem::transmute_copy</source>
          <target state="translated">Función std::mem::transmute_copia</target>
        </trans-unit>
        <trans-unit id="e2168cf325d9fdb4bb40acb9002e87cae0a35230" translate="yes" xml:space="preserve">
          <source>Function std::mem::uninitialized</source>
          <target state="translated">Función std::mem::no inicializada</target>
        </trans-unit>
        <trans-unit id="15b394955bbf59e3eb4f917be40b00478ba00bad" translate="yes" xml:space="preserve">
          <source>Function std::mem::variant_count</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6aee94a962f29ccad67cacb5695c37eb2e57120" translate="yes" xml:space="preserve">
          <source>Function std::mem::zeroed</source>
          <target state="translated">Función std::mem::zeroed</target>
        </trans-unit>
        <trans-unit id="9fbabcc1415c98e197c63a5df4d5f8ec75a6fd2b" translate="yes" xml:space="preserve">
          <source>Function std::os::unix::fs::symlink</source>
          <target state="translated">Función std::os::unix::fs::symlink</target>
        </trans-unit>
        <trans-unit id="0cb9d4491f67786e23110780ee139d285c647816" translate="yes" xml:space="preserve">
          <source>Function std::os::unix::process::parent_id</source>
          <target state="translated">Función std::os::unix::process::parent_id</target>
        </trans-unit>
        <trans-unit id="4beb8a255740f5d07c6a59d5ae0917e17fc96853" translate="yes" xml:space="preserve">
          <source>Function std::os::unix::ucred::impl_linux::peer_cred</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="221a56598ab4f515f7d1f48325b921251a1a8097" translate="yes" xml:space="preserve">
          <source>Function std::os::unix::ucred::peer_cred</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="955a8b38ef9ca7cc74dba342165900b733f89c71" translate="yes" xml:space="preserve">
          <source>Function std::os::windows::fs::symlink_dir</source>
          <target state="translated">Función std::os::windows::fs::symlink_dir</target>
        </trans-unit>
        <trans-unit id="7030c8af6886acb93aefd94038042b18937920ce" translate="yes" xml:space="preserve">
          <source>Function std::os::windows::fs::symlink_file</source>
          <target state="translated">Función std::os::windows::fs::symlink_file</target>
        </trans-unit>
        <trans-unit id="8561ba72a9691a11d16234536f898f0406c41e4b" translate="yes" xml:space="preserve">
          <source>Function std::panic::catch_unwind</source>
          <target state="translated">Función std::pánico::atrapar_desenrollar</target>
        </trans-unit>
        <trans-unit id="7db95b5853cd8e6470615625e376f10fb77b365a" translate="yes" xml:space="preserve">
          <source>Function std::panic::panic_any</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0b54652683b0f081f3c450fac3c724be97e0e07" translate="yes" xml:space="preserve">
          <source>Function std::panic::resume_unwind</source>
          <target state="translated">Función std::pánico::reanudar_desenrollar</target>
        </trans-unit>
        <trans-unit id="39271975d3373b9cea19608740e1ec82ed2ae6b7" translate="yes" xml:space="preserve">
          <source>Function std::panic::set_hook</source>
          <target state="translated">Función std::pánico::set_hook</target>
        </trans-unit>
        <trans-unit id="bbe33939a3aefba77a1076ac9c7e64784a3a15b1" translate="yes" xml:space="preserve">
          <source>Function std::panic::take_hook</source>
          <target state="translated">Función std::pánico::take_hook</target>
        </trans-unit>
        <trans-unit id="25a8c22b45e0de0551522051b0461b2b6ab3b0ee" translate="yes" xml:space="preserve">
          <source>Function std::path::is_separator</source>
          <target state="translated">Función std::path::is_separator</target>
        </trans-unit>
        <trans-unit id="f5cf3f4b834aa36120f315ecc6215ba2718045a8" translate="yes" xml:space="preserve">
          <source>Function std::process::abort</source>
          <target state="translated">Función std::proceso::abortar</target>
        </trans-unit>
        <trans-unit id="91cb6a8fd57a0224ea3dfbfbdf9c471db4732292" translate="yes" xml:space="preserve">
          <source>Function std::process::exit</source>
          <target state="translated">Función std::proceso::salida</target>
        </trans-unit>
        <trans-unit id="64d60f6bf21bdc40c4034158a74b2e2029d72d52" translate="yes" xml:space="preserve">
          <source>Function std::process::id</source>
          <target state="translated">Función std::proceso::id</target>
        </trans-unit>
        <trans-unit id="fde6de7146b98e72342b68e2f087fb2c0df102c7" translate="yes" xml:space="preserve">
          <source>Function std::ptr::copy</source>
          <target state="translated">Función std::ptr::copy</target>
        </trans-unit>
        <trans-unit id="a761215fdab6c66c0e836d73083b80b5919290f7" translate="yes" xml:space="preserve">
          <source>Function std::ptr::copy_nonoverlapping</source>
          <target state="translated">Función std::ptr::copy_nonoverlapping</target>
        </trans-unit>
        <trans-unit id="e5cd973501b571a40a9d66363842f4e1f61d69db" translate="yes" xml:space="preserve">
          <source>Function std::ptr::drop_in_place</source>
          <target state="translated">Función std::ptr::drop_in_place</target>
        </trans-unit>
        <trans-unit id="7d8139ca630c43a21993cd3cc28785c5944a7309" translate="yes" xml:space="preserve">
          <source>Function std::ptr::eq</source>
          <target state="translated">Función std::ptr::eq</target>
        </trans-unit>
        <trans-unit id="9f66565ab45d94ff05fc6926dcfe0bbd68272b62" translate="yes" xml:space="preserve">
          <source>Function std::ptr::hash</source>
          <target state="translated">Función std::ptr::hash</target>
        </trans-unit>
        <trans-unit id="a03cdb32dfba992c5ba308341a9ecf47921cafcd" translate="yes" xml:space="preserve">
          <source>Function std::ptr::null</source>
          <target state="translated">Función std::ptr::null</target>
        </trans-unit>
        <trans-unit id="4c7d5ac57a6bf5a7b544b85794d87b81e4bab2bb" translate="yes" xml:space="preserve">
          <source>Function std::ptr::null_mut</source>
          <target state="translated">Función std::ptr::null_mut</target>
        </trans-unit>
        <trans-unit id="c850fed4a12786c6b64cf8983a8b4ed6836f871b" translate="yes" xml:space="preserve">
          <source>Function std::ptr::read</source>
          <target state="translated">Función std::ptr::leer</target>
        </trans-unit>
        <trans-unit id="b5627f9e5c58db99606464fa93bdcc9942395ffe" translate="yes" xml:space="preserve">
          <source>Function std::ptr::read_unaligned</source>
          <target state="translated">Función std::ptr::read_unaligned</target>
        </trans-unit>
        <trans-unit id="cfe13a6b31ec05872aa7514cbd914f1bb5861485" translate="yes" xml:space="preserve">
          <source>Function std::ptr::read_volatile</source>
          <target state="translated">Función std::ptr::read_volatile</target>
        </trans-unit>
        <trans-unit id="d039612bde4c6048992efb15148a025858e32b3b" translate="yes" xml:space="preserve">
          <source>Function std::ptr::replace</source>
          <target state="translated">Función std::ptr::reemplazar</target>
        </trans-unit>
        <trans-unit id="d248267b6dd81ea6d45a36bf72ea24089aebcfc9" translate="yes" xml:space="preserve">
          <source>Function std::ptr::slice_from_raw_parts</source>
          <target state="translated">Function std::ptr::slice_from_raw_parts</target>
        </trans-unit>
        <trans-unit id="993ad2b27084f4ef376400115cc16edac21caa44" translate="yes" xml:space="preserve">
          <source>Function std::ptr::slice_from_raw_parts_mut</source>
          <target state="translated">Function std::ptr::slice_from_raw_parts_mut</target>
        </trans-unit>
        <trans-unit id="9d32d4c811c372eac376d6b3bdbf406666808400" translate="yes" xml:space="preserve">
          <source>Function std::ptr::swap</source>
          <target state="translated">Función std::ptr::swap</target>
        </trans-unit>
        <trans-unit id="ddca334754be5ad5ccbbcff1fdd2a964723a383a" translate="yes" xml:space="preserve">
          <source>Function std::ptr::swap_nonoverlapping</source>
          <target state="translated">Función std::ptr::swap_nonoverlapping</target>
        </trans-unit>
        <trans-unit id="0a29c6829aba2904ca27c5fa1c9fe49944ebe1c7" translate="yes" xml:space="preserve">
          <source>Function std::ptr::write</source>
          <target state="translated">Función std::ptr::escribir</target>
        </trans-unit>
        <trans-unit id="6f751c45c330611925cbdc91328104f0d8563329" translate="yes" xml:space="preserve">
          <source>Function std::ptr::write_bytes</source>
          <target state="translated">Función std::ptr::escribir_bytes</target>
        </trans-unit>
        <trans-unit id="1fda9527bc74f49c29a63948c2c6dbd1ab94b1f4" translate="yes" xml:space="preserve">
          <source>Function std::ptr::write_unaligned</source>
          <target state="translated">Función std::ptr::write_unaligned</target>
        </trans-unit>
        <trans-unit id="6144b17aff45708885f2b21a0ccd281ad4b03511" translate="yes" xml:space="preserve">
          <source>Function std::ptr::write_volatile</source>
          <target state="translated">Función std::ptr::write_volatile</target>
        </trans-unit>
        <trans-unit id="a2b7a6ea0f1d928fd925aaf7a8ce4d41592caaba" translate="yes" xml:space="preserve">
          <source>Function std::slice::from_mut</source>
          <target state="translated">Función std::slice::from_mut</target>
        </trans-unit>
        <trans-unit id="c9b1f099f247a42a47b176a483889ae2efb191a9" translate="yes" xml:space="preserve">
          <source>Function std::slice::from_raw_parts</source>
          <target state="translated">Función std::slice::from_raw_parts</target>
        </trans-unit>
        <trans-unit id="1572930120c6eeb9d2f52363340245d3c52eeaa2" translate="yes" xml:space="preserve">
          <source>Function std::slice::from_raw_parts_mut</source>
          <target state="translated">Función std::slice::from_raw_parts_mut</target>
        </trans-unit>
        <trans-unit id="ec11607378374baf49258a7deea8633da5e2c00f" translate="yes" xml:space="preserve">
          <source>Function std::slice::from_ref</source>
          <target state="translated">Función std::slice::from_ref</target>
        </trans-unit>
        <trans-unit id="5f10d43fc04f417378de60595b6a08287404fc58" translate="yes" xml:space="preserve">
          <source>Function std::str::from_boxed_utf8_unchecked</source>
          <target state="translated">Función std::str::from_boxed_utf8_unchecked</target>
        </trans-unit>
        <trans-unit id="b3494167f42728c01d009e107c9996379772b067" translate="yes" xml:space="preserve">
          <source>Function std::str::from_utf8</source>
          <target state="translated">Función std::str::from_utf8</target>
        </trans-unit>
        <trans-unit id="8ab808fea002d56433d1a4c8010bde81eaf0bafe" translate="yes" xml:space="preserve">
          <source>Function std::str::from_utf8_mut</source>
          <target state="translated">Función std::str::from_utf8_mut</target>
        </trans-unit>
        <trans-unit id="c9eb986ba9ada7c0b92ddab5aeb8be6542adebfb" translate="yes" xml:space="preserve">
          <source>Function std::str::from_utf8_unchecked</source>
          <target state="translated">Función std::str::from_utf8_unchecked</target>
        </trans-unit>
        <trans-unit id="ff6fb073e193843ab8761db003fa3d1397bde0ae" translate="yes" xml:space="preserve">
          <source>Function std::str::from_utf8_unchecked_mut</source>
          <target state="translated">Función std::str::from_utf8_unchecked_mut</target>
        </trans-unit>
        <trans-unit id="426edab7099b267d5c0fadbf655008d3c3071033" translate="yes" xml:space="preserve">
          <source>Function std::sync::atomic::compiler_fence</source>
          <target state="translated">Función std::sync::atómica::cerca_de_compilador</target>
        </trans-unit>
        <trans-unit id="746c3ced7e8fb5967d8a30871aeec3190755754d" translate="yes" xml:space="preserve">
          <source>Function std::sync::atomic::fence</source>
          <target state="translated">Function std::sync::atomic::fence</target>
        </trans-unit>
        <trans-unit id="417c1f03a8782ffed0046f05147205a5928d2325" translate="yes" xml:space="preserve">
          <source>Function std::sync::atomic::spin_loop_hint</source>
          <target state="translated">Function std::sync::atomic::spin_loop_hint</target>
        </trans-unit>
        <trans-unit id="ca876872e4c8a255561392341646d67ae0b513b3" translate="yes" xml:space="preserve">
          <source>Function std::sync::mpsc::channel</source>
          <target state="translated">Función std::sync::mpsc::channel</target>
        </trans-unit>
        <trans-unit id="ed61e6291293ba5e6efc025a526a4ca0aeef12a5" translate="yes" xml:space="preserve">
          <source>Function std::sync::mpsc::sync_channel</source>
          <target state="translated">Función std::sync::mpsc::sync_channel</target>
        </trans-unit>
        <trans-unit id="3113841f2a77c8762bb099b6ff3c3fa1652320a5" translate="yes" xml:space="preserve">
          <source>Function std::thread::available_concurrency</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0af550e5e373712dc2a979ef83bfd2ff92a021a5" translate="yes" xml:space="preserve">
          <source>Function std::thread::current</source>
          <target state="translated">Función std::thread::current</target>
        </trans-unit>
        <trans-unit id="fe9807edb6332c001f6afe09456d514679fa63c2" translate="yes" xml:space="preserve">
          <source>Function std::thread::panicking</source>
          <target state="translated">Función std::hilo::pánico</target>
        </trans-unit>
        <trans-unit id="9315e3ef8d5452c0247f62dbf54f7a6f10da132d" translate="yes" xml:space="preserve">
          <source>Function std::thread::park</source>
          <target state="translated">Función std::thread::park</target>
        </trans-unit>
        <trans-unit id="fcab5565f3d2f6769e2d47ead2f243674b5700e5" translate="yes" xml:space="preserve">
          <source>Function std::thread::park_timeout</source>
          <target state="translated">Función std::thread::park_timeout</target>
        </trans-unit>
        <trans-unit id="2f1f8ca90cd667cbf91c70fd5328d42118f543d6" translate="yes" xml:space="preserve">
          <source>Function std::thread::park_timeout_ms</source>
          <target state="translated">Función std::thread::park_timeout_ms</target>
        </trans-unit>
        <trans-unit id="11ae6d9580fb9910ca48b8e032535befd540831c" translate="yes" xml:space="preserve">
          <source>Function std::thread::sleep</source>
          <target state="translated">Función std::hilo::dormir</target>
        </trans-unit>
        <trans-unit id="1f22ee1120ba93e964441735b057a58abda65aa0" translate="yes" xml:space="preserve">
          <source>Function std::thread::sleep_ms</source>
          <target state="translated">Función std::hilo::sleep_ms</target>
        </trans-unit>
        <trans-unit id="659b9896115b8a757c17153932bb710d0018ce8b" translate="yes" xml:space="preserve">
          <source>Function std::thread::spawn</source>
          <target state="translated">Función std::thread::spawn</target>
        </trans-unit>
        <trans-unit id="e317cb6f0697f119f701c359a0df2074f48a4962" translate="yes" xml:space="preserve">
          <source>Function std::thread::yield_now</source>
          <target state="translated">Function std::thread::yield_now</target>
        </trans-unit>
        <trans-unit id="6cd47a4c3bb4392119be7e20d333f200330e1d43" translate="yes" xml:space="preserve">
          <source>Function types:</source>
          <target state="translated">Tipos de función:</target>
        </trans-unit>
        <trans-unit id="2e3030f5a7f048cef8382d50828336e71bb753d2" translate="yes" xml:space="preserve">
          <source>Function-like macros</source>
          <target state="translated">Macros funcionales</target>
        </trans-unit>
        <trans-unit id="2a9fd93daca58d7ebff71d8a39637cdf3ce39fd8" translate="yes" xml:space="preserve">
          <source>Function-like macros define macros that look like function calls. Similarly to &lt;code&gt;macro_rules!&lt;/code&gt; macros, they&amp;rsquo;re more flexible than functions; for example, they can take an unknown number of arguments. However, &lt;code&gt;macro_rules!&lt;/code&gt; macros can be defined only using the match-like syntax we discussed in the section &lt;a href=&quot;#declarative-macros-with-macro_rules-for-general-metaprogramming&quot;&gt;&amp;ldquo;Declarative Macros with &lt;code&gt;macro_rules!&lt;/code&gt; for General Metaprogramming&amp;rdquo;&lt;/a&gt; earlier. Function-like macros take a &lt;code&gt;TokenStream&lt;/code&gt; parameter and their definition manipulates that &lt;code&gt;TokenStream&lt;/code&gt; using Rust code as the other two types of procedural macros do. An example of a function-like macro is an &lt;code&gt;sql!&lt;/code&gt; macro that might be called like so:</source>
          <target state="translated">Las macros de funci&amp;oacute;n definen macros que parecen llamadas a funciones. &amp;iexcl;Similar a &lt;code&gt;macro_rules!&lt;/code&gt; macros, son m&amp;aacute;s flexibles que las funciones; por ejemplo, pueden aceptar un n&amp;uacute;mero desconocido de argumentos. Sin embargo, &lt;code&gt;macro_rules!&lt;/code&gt; las macros se pueden definir solo usando la sintaxis similar a la coincidencia que discutimos en la secci&amp;oacute;n &lt;a href=&quot;#declarative-macros-with-macro_rules-for-general-metaprogramming&quot;&gt;&amp;ldquo;&amp;iexcl;Macros declarativas con &lt;code&gt;macro_rules!&lt;/code&gt; para metaprogramaci&amp;oacute;n general &amp;rdquo;&lt;/a&gt; anteriormente. Las macros similares a funciones toman un par&amp;aacute;metro &lt;code&gt;TokenStream&lt;/code&gt; y su definici&amp;oacute;n manipula ese &lt;code&gt;TokenStream&lt;/code&gt; usando c&amp;oacute;digo Rust como lo hacen los otros dos tipos de macros de procedimiento. Un ejemplo de una macro similar a una funci&amp;oacute;n es un &lt;code&gt;sql!&lt;/code&gt; macro que podr&amp;iacute;a llamarse as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="13e701d0c602544129b90642819e8ce654632b4a" translate="yes" xml:space="preserve">
          <source>Function-like macros that look like function calls but operate on the tokens specified as their argument</source>
          <target state="translated">Macros de función que parecen llamadas de función pero que funcionan con las fichas especificadas como su argumento</target>
        </trans-unit>
        <trans-unit id="08300f312a4ed1b5c2034356b30682b98bac9713" translate="yes" xml:space="preserve">
          <source>Function-like procedural macros</source>
          <target state="translated">Macros de procedimiento similares a la función</target>
        </trans-unit>
        <trans-unit id="f7211ee113b9788f705f277792fadeeb3dfa5aa3" translate="yes" xml:space="preserve">
          <source>Function-like procedural macros may be invoked in any macro invocation position, which includes &lt;a href=&quot;statements&quot;&gt;statements&lt;/a&gt;, &lt;a href=&quot;expressions&quot;&gt;expressions&lt;/a&gt;, &lt;a href=&quot;patterns&quot;&gt;patterns&lt;/a&gt;, &lt;a href=&quot;types#type-expressions&quot;&gt;type expressions&lt;/a&gt;, &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; positions, including items in &lt;a href=&quot;items/external-blocks&quot;&gt;&lt;code&gt;extern&lt;/code&gt; blocks&lt;/a&gt;, inherent and trait &lt;a href=&quot;items/implementations&quot;&gt;implementations&lt;/a&gt;, and &lt;a href=&quot;items/traits&quot;&gt;trait definitions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95ee21bcc50578b01a326947473e22f8250802dc" translate="yes" xml:space="preserve">
          <source>Functional Language Features: Iterators and Closures</source>
          <target state="translated">Características funcionales del lenguaje:Iteradores y cierres</target>
        </trans-unit>
        <trans-unit id="4e21f7bee8221a74639e92992dc14d632a7c8af0" translate="yes" xml:space="preserve">
          <source>Functional update syntax</source>
          <target state="translated">Sintaxis de actualización funcional</target>
        </trans-unit>
        <trans-unit id="1a08f42a1b56e730c49367ca1e924228662ea26b" translate="yes" xml:space="preserve">
          <source>Functionality for ordering and comparison.</source>
          <target state="translated">Funcionalidad para ordenar y comparar.</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="79a1ec8a61d65a41557e7d6041585e466687237c" translate="yes" xml:space="preserve">
          <source>Functions and consts can both be defined in an implementation. A function defined in an &lt;code&gt;impl&lt;/code&gt; block can be standalone, meaning it would be called like &lt;code&gt;Foo::bar()&lt;/code&gt;. If the function takes &lt;code&gt;self&lt;/code&gt;, &lt;code&gt;&amp;amp;self&lt;/code&gt;, or &lt;code&gt;&amp;amp;mut self&lt;/code&gt; as its first argument, it can also be called using method-call syntax, a familiar feature to any object oriented programmer, like &lt;code&gt;foo.bar()&lt;/code&gt;.</source>
          <target state="translated">Las funciones y las constantes se pueden definir en una implementaci&amp;oacute;n. Una funci&amp;oacute;n definida en un bloque &lt;code&gt;impl&lt;/code&gt; puede ser independiente, lo que significa que se llamar&amp;iacute;a como &lt;code&gt;Foo::bar()&lt;/code&gt; . Si la funci&amp;oacute;n toma &lt;code&gt;self&lt;/code&gt; , &lt;code&gt;&amp;amp;self&lt;/code&gt; o &lt;code&gt;&amp;amp;mut self&lt;/code&gt; como su primer argumento, tambi&amp;eacute;n se puede llamar usando la sintaxis de llamada al m&amp;eacute;todo, una caracter&amp;iacute;stica familiar para cualquier programador orientado a objetos, como &lt;code&gt;foo.bar()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="349871b1a6efea930aaaf0ae51e6d8084ba76744" translate="yes" xml:space="preserve">
          <source>Functions are pervasive in Rust code. You&amp;rsquo;ve already seen one of the most important functions in the language: the &lt;code&gt;main&lt;/code&gt; function, which is the entry point of many programs. You&amp;rsquo;ve also seen the &lt;code&gt;fn&lt;/code&gt; keyword, which allows you to declare new functions.</source>
          <target state="translated">Las funciones son omnipresentes en el c&amp;oacute;digo de Rust. Ya has visto una de las funciones m&amp;aacute;s importantes del lenguaje: la funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; , que es el punto de entrada de muchos programas. Tambi&amp;eacute;n ha visto la palabra clave &lt;code&gt;fn&lt;/code&gt; , que le permite declarar nuevas funciones.</target>
        </trans-unit>
        <trans-unit id="ec13d42591018f6323f28c9a51bc9ae1f1e62226" translate="yes" xml:space="preserve">
          <source>Functions are the primary way code is executed within Rust. Function blocks, usually just called functions, can be defined in a variety of different places and be assigned many different attributes and modifiers.</source>
          <target state="translated">Las funciones son la forma principal en que se ejecuta el código dentro de Rust.Los bloques de funciones,normalmente llamados simplemente funciones,pueden ser definidos en una variedad de lugares diferentes y se les pueden asignar muchos atributos y modificadores diferentes.</target>
        </trans-unit>
        <trans-unit id="0c9b40f565c06060c423846265af5229e6fca5a3" translate="yes" xml:space="preserve">
          <source>Functions can also be defined to have &lt;em&gt;parameters&lt;/em&gt;, which are special variables that are part of a function&amp;rsquo;s signature. When a function has parameters, you can provide it with concrete values for those parameters. Technically, the concrete values are called &lt;em&gt;arguments&lt;/em&gt;, but in casual conversation, people tend to use the words &lt;em&gt;parameter&lt;/em&gt; and &lt;em&gt;argument&lt;/em&gt; interchangeably for either the variables in a function&amp;rsquo;s definition or the concrete values passed in when you call a function.</source>
          <target state="translated">Las funciones tambi&amp;eacute;n se pueden definir para que tengan &lt;em&gt;par&amp;aacute;metros&lt;/em&gt; , que son variables especiales que forman parte de la firma de una funci&amp;oacute;n. Cuando una funci&amp;oacute;n tiene par&amp;aacute;metros, puede proporcionarle valores concretos para esos par&amp;aacute;metros. T&amp;eacute;cnicamente, los valores concretos se denominan &lt;em&gt;argumentos&lt;/em&gt; , pero en una conversaci&amp;oacute;n casual, la gente tiende a usar las palabras &lt;em&gt;par&amp;aacute;metro&lt;/em&gt; y &lt;em&gt;argumento&lt;/em&gt; indistintamente para las variables en la definici&amp;oacute;n de una funci&amp;oacute;n o los valores concretos que se pasan cuando se llama a una funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f7772489f6a9ea8bcb945930292f262cd76d7056" translate="yes" xml:space="preserve">
          <source>Functions can declare an argument to be an anonymous type parameter where the callee must provide a type that has the bounds declared by the anonymous type parameter and the function can only use the methods available by the trait bounds of the anonymous type parameter.</source>
          <target state="translated">Las funciones pueden declarar que un argumento es un parámetro de tipo anónimo en el que el callejero debe proporcionar un tipo que tenga los límites declarados por el parámetro de tipo anónimo y la función sólo puede utilizar los métodos disponibles por los límites de los rasgos del parámetro de tipo anónimo.</target>
        </trans-unit>
        <trans-unit id="6e06e07a734b3acc49e3963f1c74ffeae667ea5a" translate="yes" xml:space="preserve">
          <source>Functions can return values to the code that calls them. We don&amp;rsquo;t name return values, but we do declare their type after an arrow (&lt;code&gt;-&amp;gt;&lt;/code&gt;). In Rust, the return value of the function is synonymous with the value of the final expression in the block of the body of a function. You can return early from a function by using the &lt;code&gt;return&lt;/code&gt; keyword and specifying a value, but most functions return the last expression implicitly. Here&amp;rsquo;s an example of a function that returns a value:</source>
          <target state="translated">Las funciones pueden devolver valores al c&amp;oacute;digo que las llama. No nombramos valores de retorno, pero declaramos su tipo despu&amp;eacute;s de una flecha ( &lt;code&gt;-&amp;gt;&lt;/code&gt; ). En Rust, el valor de retorno de la funci&amp;oacute;n es sin&amp;oacute;nimo del valor de la expresi&amp;oacute;n final en el bloque del cuerpo de una funci&amp;oacute;n. Puede regresar antes de una funci&amp;oacute;n utilizando la palabra clave &lt;code&gt;return&lt;/code&gt; y especificando un valor, pero la mayor&amp;iacute;a de las funciones devuelven la &amp;uacute;ltima expresi&amp;oacute;n impl&amp;iacute;citamente. A continuaci&amp;oacute;n, se muestra un ejemplo de una funci&amp;oacute;n que devuelve un valor:</target>
        </trans-unit>
        <trans-unit id="8578e1edc63515b51db6bed787869c23c34bb35c" translate="yes" xml:space="preserve">
          <source>Functions do not capture local variables. To fix this error, you can replace the function with a closure:</source>
          <target state="translated">Las funciones no capturan las variables locales.Para corregir este error,puede reemplazar la función con un cierre:</target>
        </trans-unit>
        <trans-unit id="2a188df8eec44f8cdac6c18fd47adbe486ec7642" translate="yes" xml:space="preserve">
          <source>Functions in Rust can be called by foreign code, and using an ABI that differs from Rust allows, for example, to provide functions that can be called from other programming languages like C:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c048b3feb011016ec1af315c1f0d26b938c26a99" translate="yes" xml:space="preserve">
          <source>Functions in this module will block the current &lt;strong&gt;thread&lt;/strong&gt; of execution and are bindings to system-provided condition variables where possible. Note that this module places one additional restriction over the system condition variables: each condvar can be used with precisely one mutex at runtime. Any attempt to use multiple mutexes on the same condition variable will result in a runtime panic. If this is not desired, then the unsafe primitives in &lt;code&gt;sys&lt;/code&gt; do not have this restriction but may result in undefined behavior.</source>
          <target state="translated">Las funciones de este m&amp;oacute;dulo bloquear&amp;aacute;n el &lt;strong&gt;hilo&lt;/strong&gt; actual de ejecuci&amp;oacute;n y son enlaces a las variables de condici&amp;oacute;n proporcionadas por el sistema cuando sea posible. Tenga en cuenta que este m&amp;oacute;dulo coloca una restricci&amp;oacute;n adicional sobre las variables de condici&amp;oacute;n del sistema: cada condvar se puede usar con precisamente un mutex en tiempo de ejecuci&amp;oacute;n. Cualquier intento de utilizar m&amp;uacute;ltiples exclusiones mutuas en la misma variable de condici&amp;oacute;n provocar&amp;aacute; un p&amp;aacute;nico en tiempo de ejecuci&amp;oacute;n. Si esto no se desea, entonces las primitivas inseguras en &lt;code&gt;sys&lt;/code&gt; no tienen esta restricci&amp;oacute;n pero pueden resultar en un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="19486dfa520b69c11a03500cb78fcde335f9a159" translate="yes" xml:space="preserve">
          <source>Functions in this module will block the current &lt;strong&gt;thread&lt;/strong&gt; of execution. Note that any attempt to use multiple mutexes on the same condition variable may result in a runtime panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a797a5b3b54d57d908332f50a0ff14a598f923ef" translate="yes" xml:space="preserve">
          <source>Functions marked with &lt;code&gt;target_feature&lt;/code&gt; are not inlined into a context that does not support the given features. The &lt;code&gt;#[inline(always)]&lt;/code&gt; attribute may not be used with a &lt;code&gt;target_feature&lt;/code&gt; attribute.</source>
          <target state="translated">Las funciones marcadas con &lt;code&gt;target_feature&lt;/code&gt; no est&amp;aacute;n integradas en un contexto que no admita las caracter&amp;iacute;sticas dadas. El atributo &lt;code&gt;#[inline(always)]&lt;/code&gt; no se puede utilizar con un atributo &lt;code&gt;target_feature&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0500c980225aaa328a97ddd71516215766d4d2c7" translate="yes" xml:space="preserve">
          <source>Functions may be qualified as async, and this can also be combined with the &lt;code&gt;unsafe&lt;/code&gt; qualifier:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19ba2d6d6d2c4bf90e78758d9ffb195fa04a9907" translate="yes" xml:space="preserve">
          <source>Functions qualified with the &lt;code&gt;const&lt;/code&gt; keyword are &lt;a href=&quot;../const_eval#const-functions&quot;&gt;const functions&lt;/a&gt;, as are &lt;a href=&quot;structs&quot;&gt;tuple struct&lt;/a&gt; and &lt;a href=&quot;enumerations&quot;&gt;tuple variant&lt;/a&gt; constructors. &lt;em&gt;Const functions&lt;/em&gt; can be called from within &lt;a href=&quot;../const_eval#const-context&quot;&gt;const context&lt;/a&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="debf8c3aa1da35922894a71fde41ce5baca3e6ad" translate="yes" xml:space="preserve">
          <source>Functions qualified with the &lt;code&gt;const&lt;/code&gt; keyword are const functions. &lt;em&gt;Const functions&lt;/em&gt; can be called from within &lt;a href=&quot;../const_eval#const-context&quot;&gt;const context&lt;/a&gt;s. When called from a const context, the function is interpreted by the compiler at compile time. The interpretation happens in the environment of the compilation target and not the host. So &lt;code&gt;usize&lt;/code&gt; is &lt;code&gt;32&lt;/code&gt; bits if you are compiling against a &lt;code&gt;32&lt;/code&gt; bit system, irrelevant of whether you are building on a &lt;code&gt;64&lt;/code&gt; bit or a &lt;code&gt;32&lt;/code&gt; bit system.</source>
          <target state="translated">Funciones calificadas con la &lt;code&gt;const&lt;/code&gt; palabra clave son funciones const. &lt;em&gt;Las funciones const&lt;/em&gt; se pueden llamar desde dentro del &lt;a href=&quot;../const_eval#const-context&quot;&gt;contexto const&lt;/a&gt; s. Cuando se llama desde un contexto constante, el compilador interpreta la funci&amp;oacute;n en tiempo de compilaci&amp;oacute;n. La interpretaci&amp;oacute;n ocurre en el entorno del destino de compilaci&amp;oacute;n y no en el host. Por &lt;code&gt;usize&lt;/code&gt; tanto, usize es de &lt;code&gt;32&lt;/code&gt; bits si est&amp;aacute; compilando en un sistema de &lt;code&gt;32&lt;/code&gt; bits, sin importar si est&amp;aacute; construyendo en un sistema de &lt;code&gt;64&lt;/code&gt; bits o de &lt;code&gt;32&lt;/code&gt; bits.</target>
        </trans-unit>
        <trans-unit id="27716c2844ef6662e00babc6885a69e2dec63380" translate="yes" xml:space="preserve">
          <source>Functions return &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; whenever errors are expected and recoverable. In the &lt;code&gt;std&lt;/code&gt; crate, &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; is most prominently used for &lt;a href=&quot;../io/index&quot;&gt;I/O&lt;/a&gt;.</source>
          <target state="translated">Las funciones devuelven el &lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; siempre que se esperan errores y se pueden recuperar. En el &lt;code&gt;std&lt;/code&gt; caja, &lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; se utiliza lo m&amp;aacute;s prominente de &lt;a href=&quot;../io/index&quot;&gt;E / S&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9ba4110fcc3e4c930df9cd4a44d4369d4a726954" translate="yes" xml:space="preserve">
          <source>Functions which take an &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; and return another &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; are often called 'iterator adapters', as they're a form of the 'adapter pattern'.</source>
          <target state="translated">Las funciones que toman un &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; y devuelven otro &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; menudo se denominan 'adaptadores de iterador', ya que son una forma del 'patr&amp;oacute;n de adaptador'.</target>
        </trans-unit>
        <trans-unit id="e3428425ba667eae06c3ff2021c3de7d88b772af" translate="yes" xml:space="preserve">
          <source>Functions with Return Values</source>
          <target state="translated">Funciones con valores de retorno</target>
        </trans-unit>
        <trans-unit id="b18578d36545499a01a7076ba62b48fa01f0c848" translate="yes" xml:space="preserve">
          <source>Functions with an ABI that differs from &lt;code&gt;&quot;Rust&quot;&lt;/code&gt; do not support unwinding in the exact same way that Rust does. Therefore, unwinding past the end of functions with such ABIs causes the process to abort.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92807c856bd111462699f9e06c09bb56c14702fe" translate="yes" xml:space="preserve">
          <source>Functions within external blocks are declared in the same way as other Rust functions, with the exception that they may not have a body and are instead terminated by a semicolon. Patterns are not allowed in parameters, only &lt;a href=&quot;../identifiers&quot;&gt;IDENTIFIER&lt;/a&gt; or &lt;code&gt;_&lt;/code&gt; may be used.</source>
          <target state="translated">Las funciones dentro de bloques externos se declaran de la misma manera que otras funciones de Rust, con la excepci&amp;oacute;n de que pueden no tener cuerpo y en su lugar terminan con un punto y coma. No se permiten patrones en los par&amp;aacute;metros, solo se pueden usar &lt;a href=&quot;../identifiers&quot;&gt;IDENTIFICADOR&lt;/a&gt; o &lt;code&gt;_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc77dcb074f08a32cc87de1996bea238f078997a" translate="yes" xml:space="preserve">
          <source>Functions within external blocks may be called by Rust code, just like functions defined in Rust. The Rust compiler automatically translates between the Rust ABI and the foreign ABI.</source>
          <target state="translated">Las funciones dentro de los bloques externos pueden ser llamadas por el código de Rust,al igual que las funciones definidas en Rust.El compilador de Rust traduce automáticamente entre la ABI de Rust y la ABI externa.</target>
        </trans-unit>
        <trans-unit id="255f924e1ffd5da6e3f850e0ae72ac4d9101aff6" translate="yes" xml:space="preserve">
          <source>Functions within external blocks may be variadic by specifying &lt;code&gt;...&lt;/code&gt; after one or more named arguments in the argument list:</source>
          <target state="translated">Las funciones dentro de bloques externos pueden ser variables especificando &lt;code&gt;...&lt;/code&gt; despu&amp;eacute;s de uno o m&amp;aacute;s argumentos con nombre en la lista de argumentos:</target>
        </trans-unit>
        <trans-unit id="559bba4281b9cbb5285ad035b18e638f9254aa96" translate="yes" xml:space="preserve">
          <source>Functions, except for associated trait functions, can return an abstract return type. These types stand in for another concrete type where the use-site may only use the trait methods declared by the trait bounds of the type.</source>
          <target state="translated">Las funciones,excepto las funciones de rasgos asociados,pueden devolver un tipo de retorno abstracto.Estos tipos sustituyen a otro tipo concreto en el que el lugar de utilización sólo puede utilizar los métodos de rasgos declarados por los límites de los rasgos del tipo.</target>
        </trans-unit>
        <trans-unit id="5234ca15ccfb340b3c32fd38f23a4ff8df3cca57" translate="yes" xml:space="preserve">
          <source>Functions, type aliases, structs, enumerations, unions, traits and implementations may be &lt;em&gt;parameterized&lt;/em&gt; by types and lifetimes. These parameters are listed in angle brackets (&lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt;), usually immediately after the name of the item and before its definition. For implementations, which don't have a name, they come directly after &lt;code&gt;impl&lt;/code&gt;. Lifetime parameters must be declared before type parameters. Some examples of items with type and lifetime parameters:</source>
          <target state="translated">Las funciones, los alias de tipos, las estructuras, las enumeraciones, las uniones, los rasgos y las implementaciones se pueden &lt;em&gt;parametrizar&lt;/em&gt; por tipos y vidas. Estos par&amp;aacute;metros se enumeran entre corchetes angulares ( &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; ), generalmente inmediatamente despu&amp;eacute;s del nombre del elemento y antes de su definici&amp;oacute;n. Para las implementaciones que no tienen nombre, vienen directamente despu&amp;eacute;s de &lt;code&gt;impl&lt;/code&gt; . Los par&amp;aacute;metros de por vida deben declararse antes que los par&amp;aacute;metros de tipo. Algunos ejemplos de elementos con par&amp;aacute;metros de tipo y duraci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="d83a6029c4947c75a3d349d25be545ca402bff11" translate="yes" xml:space="preserve">
          <source>Functions, type aliases, structs, enumerations, unions, traits, and implementations may be &lt;em&gt;parameterized&lt;/em&gt; by types and lifetimes. These parameters are listed in angle brackets (&lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt;), usually immediately after the name of the item and before its definition. For implementations, which don't have a name, they come directly after &lt;code&gt;impl&lt;/code&gt;. Lifetime parameters must be declared before type parameters. Some examples of items with type and lifetime parameters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f57878d0751d3ab5ce8210b78147f1fbca3e0b4a" translate="yes" xml:space="preserve">
          <source>Fundamental traits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e006ca099899d227345d125f7604094fb4ac496" translate="yes" xml:space="preserve">
          <source>Fundamental type constructors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc0f9166454ea8a2d6c4817bb65ab3b4f20a8394" translate="yes" xml:space="preserve">
          <source>Fundamentally, macros are a way of writing code that writes other code, which is known as &lt;em&gt;metaprogramming&lt;/em&gt;. In Appendix C, we discuss the &lt;code&gt;derive&lt;/code&gt; attribute, which generates an implementation of various traits for you. We&amp;rsquo;ve also used the &lt;code&gt;println!&lt;/code&gt; and &lt;code&gt;vec!&lt;/code&gt; macros throughout the book. All of these macros &lt;em&gt;expand&lt;/em&gt; to produce more code than the code you&amp;rsquo;ve written manually.</source>
          <target state="translated">B&amp;aacute;sicamente, las macros son una forma de escribir c&amp;oacute;digo que escribe otro c&amp;oacute;digo, lo que se conoce como &lt;em&gt;metaprogramaci&amp;oacute;n&lt;/em&gt; . En el Ap&amp;eacute;ndice C, analizamos el atributo &lt;code&gt;derive&lt;/code&gt; , que genera una implementaci&amp;oacute;n de varios rasgos para usted. &amp;iexcl;Tambi&amp;eacute;n hemos utilizado &lt;code&gt;println!&lt;/code&gt; y &lt;code&gt;vec!&lt;/code&gt; macros en todo el libro. Todas estas macros se &lt;em&gt;expanden&lt;/em&gt; para producir m&amp;aacute;s c&amp;oacute;digo que el c&amp;oacute;digo que ha escrito manualmente.</target>
        </trans-unit>
        <trans-unit id="33aa27b63995ba1fcb3ce7d14470a2ebda4e9afb" translate="yes" xml:space="preserve">
          <source>Further examples</source>
          <target state="translated">Otros ejemplos</target>
        </trans-unit>
        <trans-unit id="d09598b8462cb55fafc0925eb6b3707aebcdffff" translate="yes" xml:space="preserve">
          <source>Further methods that return iterators are &lt;a href=&quot;../primitive.slice#method.split&quot;&gt;&lt;code&gt;.split&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../primitive.slice#method.splitn&quot;&gt;&lt;code&gt;.splitn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../primitive.slice#method.chunks&quot;&gt;&lt;code&gt;.chunks&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../primitive.slice#method.windows&quot;&gt;&lt;code&gt;.windows&lt;/code&gt;&lt;/a&gt; and more.</source>
          <target state="translated">Otros m&amp;eacute;todos que devuelven iteradores son &lt;a href=&quot;../primitive.slice#method.split&quot;&gt; &lt;code&gt;.split&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../primitive.slice#method.splitn&quot;&gt; &lt;code&gt;.splitn&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../primitive.slice#method.chunks&quot;&gt; &lt;code&gt;.chunks&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../primitive.slice#method.windows&quot;&gt; &lt;code&gt;.windows&lt;/code&gt; &lt;/a&gt; y m&amp;aacute;s.</target>
        </trans-unit>
        <trans-unit id="1ca30366a5d0ab34525f2208365c1ca94a1f8b77" translate="yes" xml:space="preserve">
          <source>Further, when providing implementations for additional traits, it needs to be considered whether they should behave identical to those of the underlying type as a consequence of acting as a representation of that underlying type. Generic code typically uses &lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt; when it relies on the identical behavior of these additional trait implementations. These traits will likely appear as additional trait bounds.</source>
          <target state="translated">Adem&amp;aacute;s, al proporcionar implementaciones para rasgos adicionales, se debe considerar si deben comportarse de manera id&amp;eacute;ntica a los del tipo subyacente como consecuencia de actuar como una representaci&amp;oacute;n de ese tipo subyacente. El c&amp;oacute;digo gen&amp;eacute;rico generalmente usa &lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt; cuando se basa en el comportamiento id&amp;eacute;ntico de estas implementaciones de rasgos adicionales. Es probable que estos rasgos aparezcan como l&amp;iacute;mites de rasgos adicionales.</target>
        </trans-unit>
        <trans-unit id="cb1960550ff747636004d7c48533ff64eb2c7cb0" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;code&gt;usize&lt;/code&gt; and &lt;code&gt;isize&lt;/code&gt; have the same size.</source>
          <target state="translated">Adem&amp;aacute;s, &lt;code&gt;usize&lt;/code&gt; e &lt;code&gt;isize&lt;/code&gt; tienen el mismo tama&amp;ntilde;o.</target>
        </trans-unit>
        <trans-unit id="cdc25e51f3bd03cefd6c886e6015dd4e5ab94438" translate="yes" xml:space="preserve">
          <source>Fuse</source>
          <target state="translated">Fuse</target>
        </trans-unit>
        <trans-unit id="5b5bb3bd654173bbe0ca32ea3cdd799fc39be7e0" translate="yes" xml:space="preserve">
          <source>Fuse::all</source>
          <target state="translated">Fuse::all</target>
        </trans-unit>
        <trans-unit id="be234633fcc19983cf10e500a6cea263759de0ec" translate="yes" xml:space="preserve">
          <source>Fuse::any</source>
          <target state="translated">Fuse::any</target>
        </trans-unit>
        <trans-unit id="fb657f6faeb38bdc2196ebc9819c5d95fe340748" translate="yes" xml:space="preserve">
          <source>Fuse::borrow</source>
          <target state="translated">Fuse::borrow</target>
        </trans-unit>
        <trans-unit id="8f3044155e9d5c84cd57e23debc6442d0e4670b3" translate="yes" xml:space="preserve">
          <source>Fuse::borrow_mut</source>
          <target state="translated">Fuse::borrow_mut</target>
        </trans-unit>
        <trans-unit id="1d289dac98b2c0ee8af0ae119550bb75a8647436" translate="yes" xml:space="preserve">
          <source>Fuse::by_ref</source>
          <target state="translated">Fuse::by_ref</target>
        </trans-unit>
        <trans-unit id="831eb7c4481fb4be2c2082f7b1da24d8f9f757ec" translate="yes" xml:space="preserve">
          <source>Fuse::chain</source>
          <target state="translated">Fuse::chain</target>
        </trans-unit>
        <trans-unit id="438fd4561c9ccfadcfc75a150d349251bb6bad15" translate="yes" xml:space="preserve">
          <source>Fuse::clone</source>
          <target state="translated">Fuse::clone</target>
        </trans-unit>
        <trans-unit id="1430674975c3f47c8efafda98d99fb2a28139d1d" translate="yes" xml:space="preserve">
          <source>Fuse::clone_from</source>
          <target state="translated">Fuse::clone_from</target>
        </trans-unit>
        <trans-unit id="9be81b457f16a4af2ac97486a4694037294d9f73" translate="yes" xml:space="preserve">
          <source>Fuse::clone_into</source>
          <target state="translated">Fuse::clone_into</target>
        </trans-unit>
        <trans-unit id="98f760afb80a8eff0c0ef367859e40f090d49189" translate="yes" xml:space="preserve">
          <source>Fuse::cloned</source>
          <target state="translated">Fuse::cloned</target>
        </trans-unit>
        <trans-unit id="6da9651643728cd0c44496dee9b4303124cabbfa" translate="yes" xml:space="preserve">
          <source>Fuse::cmp</source>
          <target state="translated">Fuse::cmp</target>
        </trans-unit>
        <trans-unit id="0c4f37e97803f9d70993fa59d61809aea7d9011a" translate="yes" xml:space="preserve">
          <source>Fuse::collect</source>
          <target state="translated">Fuse::collect</target>
        </trans-unit>
        <trans-unit id="ddc6005989b65675ac3ce7404f4341aa3e45bd46" translate="yes" xml:space="preserve">
          <source>Fuse::copied</source>
          <target state="translated">Fuse::copied</target>
        </trans-unit>
        <trans-unit id="6086889f4261af2a35bbde15545aa2b38e286eb0" translate="yes" xml:space="preserve">
          <source>Fuse::count</source>
          <target state="translated">Fuse::count</target>
        </trans-unit>
        <trans-unit id="2c7439b70ce0f07bef285135b6810c8416ce3ceb" translate="yes" xml:space="preserve">
          <source>Fuse::cycle</source>
          <target state="translated">Fuse::cycle</target>
        </trans-unit>
        <trans-unit id="1d21878382d8db3eef5c3ccb0162b537561d5fe1" translate="yes" xml:space="preserve">
          <source>Fuse::enumerate</source>
          <target state="translated">Fuse::enumerate</target>
        </trans-unit>
        <trans-unit id="823d811ae87865a3afe81991f5b1ce5c5d3e05fb" translate="yes" xml:space="preserve">
          <source>Fuse::eq</source>
          <target state="translated">Fuse::eq</target>
        </trans-unit>
        <trans-unit id="bd7cbe6bf9c8e8d0dbf1a520e5d8f393c41d5e76" translate="yes" xml:space="preserve">
          <source>Fuse::filter</source>
          <target state="translated">Fuse::filter</target>
        </trans-unit>
        <trans-unit id="ff249feec5a8ff44c09ac4d58cf0c46bc03c2e27" translate="yes" xml:space="preserve">
          <source>Fuse::filter_map</source>
          <target state="translated">Fuse::filter_map</target>
        </trans-unit>
        <trans-unit id="d65f3a653005a9aca1a47f1daa9574aadcf81146" translate="yes" xml:space="preserve">
          <source>Fuse::find</source>
          <target state="translated">Fuse::find</target>
        </trans-unit>
        <trans-unit id="92189ce0a3d924bfcfe5daafee0096f97e345e8a" translate="yes" xml:space="preserve">
          <source>Fuse::find_map</source>
          <target state="translated">Fuse::find_map</target>
        </trans-unit>
        <trans-unit id="1cf8f29dde6618a7c7a45ae0ed611ea18dc6d814" translate="yes" xml:space="preserve">
          <source>Fuse::flat_map</source>
          <target state="translated">Fuse::flat_map</target>
        </trans-unit>
        <trans-unit id="9f855deea4a227b1c412204b1b500286ca9898ff" translate="yes" xml:space="preserve">
          <source>Fuse::flatten</source>
          <target state="translated">Fuse::flatten</target>
        </trans-unit>
        <trans-unit id="27bca4d23d19f854df553c1f82824f7edd33ecdd" translate="yes" xml:space="preserve">
          <source>Fuse::fmt</source>
          <target state="translated">Fuse::fmt</target>
        </trans-unit>
        <trans-unit id="8293be1030013adbfbddb7413ab47a9d5713fbb2" translate="yes" xml:space="preserve">
          <source>Fuse::fold</source>
          <target state="translated">Fuse::fold</target>
        </trans-unit>
        <trans-unit id="d70e6b78ab1bfb6ecef7e95f085adfaeb6422f4a" translate="yes" xml:space="preserve">
          <source>Fuse::for_each</source>
          <target state="translated">Fuse::for_each</target>
        </trans-unit>
        <trans-unit id="c637a607309c42c80a08d11fa1900890151225d1" translate="yes" xml:space="preserve">
          <source>Fuse::from</source>
          <target state="translated">Fuse::from</target>
        </trans-unit>
        <trans-unit id="3f4b35dca4545ef8a3669e274f565d795f26df61" translate="yes" xml:space="preserve">
          <source>Fuse::fuse</source>
          <target state="translated">Fuse::fuse</target>
        </trans-unit>
        <trans-unit id="d32ae472a05f042237f60672a294af6e0f780002" translate="yes" xml:space="preserve">
          <source>Fuse::ge</source>
          <target state="translated">Fuse::ge</target>
        </trans-unit>
        <trans-unit id="db14a349561c9657cb02ec4378f0041d394de512" translate="yes" xml:space="preserve">
          <source>Fuse::gt</source>
          <target state="translated">Fuse::gt</target>
        </trans-unit>
        <trans-unit id="8e137668bb3688ae855ccc5853810b47754a3872" translate="yes" xml:space="preserve">
          <source>Fuse::inspect</source>
          <target state="translated">Fuse::inspect</target>
        </trans-unit>
        <trans-unit id="5cfef3b06c43a18ed973402f005ed7cd09e8c04c" translate="yes" xml:space="preserve">
          <source>Fuse::into</source>
          <target state="translated">Fuse::into</target>
        </trans-unit>
        <trans-unit id="f0ca9438fb188b5b8dad26c6bf148f9659520041" translate="yes" xml:space="preserve">
          <source>Fuse::into_iter</source>
          <target state="translated">Fuse::into_iter</target>
        </trans-unit>
        <trans-unit id="391ea300511ad72ed0c52d931ec32f9ad0fd9c6f" translate="yes" xml:space="preserve">
          <source>Fuse::is_empty</source>
          <target state="translated">Fuse::is_empty</target>
        </trans-unit>
        <trans-unit id="dbc1aa11443b40a7ec81e5ce0dd280ae99df5395" translate="yes" xml:space="preserve">
          <source>Fuse::is_sorted</source>
          <target state="translated">Fuse::is_sorted</target>
        </trans-unit>
        <trans-unit id="6de34202c0045be112d2ee0f948bb537aa9be637" translate="yes" xml:space="preserve">
          <source>Fuse::is_sorted_by</source>
          <target state="translated">Fuse::is_sorted_by</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
