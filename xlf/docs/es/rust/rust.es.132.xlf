<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="8c62b63ef24786f929500cd4f0e354183f51728d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait is rarely required; types that implement &lt;code&gt;Copy&lt;/code&gt; have optimizations available, meaning you don&amp;rsquo;t have to call &lt;code&gt;clone&lt;/code&gt;, which makes the code more concise.</source>
          <target state="translated">La &lt;code&gt;Copy&lt;/code&gt; rasgo rara vez se requiere; los tipos que implementan &lt;code&gt;Copy&lt;/code&gt; tienen optimizaciones disponibles, lo que significa que no tiene que llamar a &lt;code&gt;clone&lt;/code&gt; , lo que hace que el c&amp;oacute;digo sea m&amp;aacute;s conciso.</target>
        </trans-unit>
        <trans-unit id="19e60de5e2cec4f66ffc273d83b18ba133a29961" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait was implemented on a type which contains a field that doesn't implement the &lt;code&gt;Copy&lt;/code&gt; trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bc1853088c8596ec738b63d0b306b0f2a10680d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait was implemented on a type which is neither a struct nor an enum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23cc8d6ab49e3b2451486ee83ff4fdc2f0dab312" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait was implemented on a type with a &lt;code&gt;Drop&lt;/code&gt; implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a2c2f0333db2747594fc8c5736d8f8e947ab10e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Counter&lt;/code&gt; struct has one field named &lt;code&gt;count&lt;/code&gt;. This field holds a &lt;code&gt;u32&lt;/code&gt; value that will keep track of where we are in the process of iterating from 1 to 5. The &lt;code&gt;count&lt;/code&gt; field is private because we want the implementation of &lt;code&gt;Counter&lt;/code&gt; to manage its value. The &lt;code&gt;new&lt;/code&gt; function enforces the behavior of always starting new instances with a value of 0 in the &lt;code&gt;count&lt;/code&gt; field.</source>
          <target state="translated">La estructura &lt;code&gt;Counter&lt;/code&gt; tiene un campo llamado &lt;code&gt;count&lt;/code&gt; . Este campo tiene un valor &lt;code&gt;u32&lt;/code&gt; que har&amp;aacute; un seguimiento de d&amp;oacute;nde estamos en el proceso de iterar de 1 a 5. El campo de &lt;code&gt;count&lt;/code&gt; es privado porque queremos que la implementaci&amp;oacute;n de &lt;code&gt;Counter&lt;/code&gt; administre su valor. La &lt;code&gt;new&lt;/code&gt; funci&amp;oacute;n impone el comportamiento de iniciar siempre nuevas instancias con un valor de 0 en el campo de &lt;code&gt;count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e402bbce82e84dd539cf1e138daa2856a0613786" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Debug&lt;/code&gt; trait allows you to print instances of a type for debugging purposes, so you and other programmers using your type can inspect an instance at a particular point in a program&amp;rsquo;s execution.</source>
          <target state="translated">El rasgo &lt;code&gt;Debug&lt;/code&gt; le permite imprimir instancias de un tipo con fines de depuraci&amp;oacute;n, por lo que usted y otros programadores que usan su tipo pueden inspeccionar una instancia en un punto particular de la ejecuci&amp;oacute;n de un programa.</target>
        </trans-unit>
        <trans-unit id="853b42f22ba0be46a6e5cd03ba34756814292e76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Debug&lt;/code&gt; trait enables debug formatting in format strings, which you indicate by adding &lt;code&gt;:?&lt;/code&gt; within &lt;code&gt;{}&lt;/code&gt; placeholders.</source>
          <target state="translated">El rasgo &lt;code&gt;Debug&lt;/code&gt; habilita el formato de depuraci&amp;oacute;n en cadenas de formato, que indica agregando &lt;code&gt;:?&lt;/code&gt; dentro de &lt;code&gt;{}&lt;/code&gt; marcadores de posici&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6967ae462b0a2a18036d993e8418edd4a969bd40" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Debug&lt;/code&gt; trait is required, for example, in use of the &lt;code&gt;assert_eq!&lt;/code&gt; macro. This macro prints the values of instances given as arguments if the equality assertion fails so programmers can see why the two instances weren&amp;rsquo;t equal.</source>
          <target state="translated">El rasgo &lt;code&gt;Debug&lt;/code&gt; es necesario, por ejemplo, en el uso de &lt;code&gt;assert_eq!&lt;/code&gt; macro. Esta macro imprime los valores de las instancias dadas como argumentos si falla la aserci&amp;oacute;n de igualdad para que los programadores puedan ver por qu&amp;eacute; las dos instancias no eran iguales.</target>
        </trans-unit>
        <trans-unit id="aba43f90e22e0dfd98100913cb543e02752ca675" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default::default&lt;/code&gt; function is commonly used in combination with the struct update syntax discussed in the &lt;a href=&quot;ch05-01-defining-structs#creating-instances-from-other-instances-with-struct-update-syntax&quot;&gt;&amp;ldquo;Creating Instances From Other Instances With Struct Update Syntax&amp;rdquo;&lt;/a&gt; section in Chapter 5. You can customize a few fields of a struct and then set and use a default value for the rest of the fields by using &lt;code&gt;..Default::default()&lt;/code&gt;.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;Default::default&lt;/code&gt; se usa com&amp;uacute;nmente en combinaci&amp;oacute;n con la sintaxis de actualizaci&amp;oacute;n de estructura discutida en la secci&amp;oacute;n &lt;a href=&quot;ch05-01-defining-structs#creating-instances-from-other-instances-with-struct-update-syntax&quot;&gt;&quot;Creaci&amp;oacute;n de instancias a partir de otras instancias con sintaxis de actualizaci&amp;oacute;n de estructura&quot;&lt;/a&gt; en el Cap&amp;iacute;tulo 5. Puede personalizar algunos campos de una estructura y luego establecer y usar una valor predeterminado para el resto de los campos utilizando &lt;code&gt;..Default::default()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f7be30b5dee7044de3817ca4c87b66ab54682e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; cannot be derived on an enum for the simple reason that the compiler doesn't know which value to pick by default whereas it can for a struct as long as all its fields implement the &lt;code&gt;Default&lt;/code&gt; trait as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="155c03f436324748d5a47629042098342e63a6ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; trait allows you to create a default value for a type. Deriving &lt;code&gt;Default&lt;/code&gt; implements the &lt;code&gt;default&lt;/code&gt; function. The derived implementation of the &lt;code&gt;default&lt;/code&gt; function calls the &lt;code&gt;default&lt;/code&gt; function on each part of the type, meaning all fields or values in the type must also implement &lt;code&gt;Default&lt;/code&gt; to derive &lt;code&gt;Default&lt;/code&gt;.</source>
          <target state="translated">El rasgo &lt;code&gt;Default&lt;/code&gt; permite crear un valor predeterminado para un tipo. Deriving &lt;code&gt;Default&lt;/code&gt; implementa la funci&amp;oacute;n &lt;code&gt;default&lt;/code&gt; . La implementaci&amp;oacute;n derivada de la funci&amp;oacute;n &lt;code&gt;default&lt;/code&gt; llama a la funci&amp;oacute;n &lt;code&gt;default&lt;/code&gt; en cada parte del tipo, lo que significa que todos los campos o valores del tipo tambi&amp;eacute;n deben implementar &lt;code&gt;Default&lt;/code&gt; para derivar &lt;code&gt;Default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="417d240e17ea189069372338520fb02d077b097b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; trait for types which may have meaningful default values.</source>
          <target state="translated">El rasgo &lt;code&gt;Default&lt;/code&gt; para los tipos que pueden tener valores predeterminados significativos.</target>
        </trans-unit>
        <trans-unit id="e9ffe8630d56067e177ef382279c1fa4ad4f3ea3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; trait is required when you use the method &lt;code&gt;unwrap_or_default&lt;/code&gt; on &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; instances, for example. If the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, the method &lt;code&gt;unwrap_or_default&lt;/code&gt; will return the result of &lt;code&gt;Default::default&lt;/code&gt; for the type &lt;code&gt;T&lt;/code&gt; stored in the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">El rasgo &lt;code&gt;Default&lt;/code&gt; es necesario cuando se usa el m&amp;eacute;todo &lt;code&gt;unwrap_or_default&lt;/code&gt; en instancias de &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; , por ejemplo. Si la &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; es &lt;code&gt;None&lt;/code&gt; , el m&amp;eacute;todo &lt;code&gt;unwrap_or_default&lt;/code&gt; devolver&amp;aacute; el resultado de &lt;code&gt;Default::default&lt;/code&gt; para el tipo &lt;code&gt;T&lt;/code&gt; almacenado en la &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="faec1eafc86ec050669e657d677254ae1cc5eb09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; trait was derived on an enum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bac5d0a36fa049d2b9d797796c56dde34fe6945" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DispatchFromDyn&lt;/code&gt; trait currently can only be implemented for builtin pointer types and structs that are newtype wrappers around them &amp;mdash; that is, the struct must have only one field (except for&lt;code&gt;PhantomData&lt;/code&gt;), and that field must itself implement &lt;code&gt;DispatchFromDyn&lt;/code&gt;.</source>
          <target state="translated">El &lt;code&gt;DispatchFromDyn&lt;/code&gt; Rasgo actualmente s&amp;oacute;lo se puede aplicar para este tipo de orden interna de puntero y estructuras que son envoltorios de Newtype alrededor de ellos - es decir, la estructura debe tener s&amp;oacute;lo un campo (excepto para &lt;code&gt;PhantomData&lt;/code&gt; ), y que en s&amp;iacute; campo debe aplicar &lt;code&gt;DispatchFromDyn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4511d27b8bd2f5f7b72a8b815a18a15df561075" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DispatchFromDyn&lt;/code&gt; trait was implemented on something which is not a pointer or a newtype wrapper around a pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6986e696b5a0b081bb4012a05eb9e1b65dcc35b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DraftPost&lt;/code&gt; struct has an &lt;code&gt;add_text&lt;/code&gt; method, so we can add text to &lt;code&gt;content&lt;/code&gt; as before, but note that &lt;code&gt;DraftPost&lt;/code&gt; does not have a &lt;code&gt;content&lt;/code&gt; method defined! So now the program ensures all posts start as draft posts, and draft posts don&amp;rsquo;t have their content available for display. Any attempt to get around these constraints will result in a compiler error.</source>
          <target state="translated">La estructura &lt;code&gt;DraftPost&lt;/code&gt; tiene un m&amp;eacute;todo &lt;code&gt;add_text&lt;/code&gt; , por lo que podemos agregar texto al &lt;code&gt;content&lt;/code&gt; como antes, pero tenga en cuenta que &lt;code&gt;DraftPost&lt;/code&gt; no tiene un m&amp;eacute;todo de &lt;code&gt;content&lt;/code&gt; definido. Por lo tanto, ahora el programa garantiza que todas las publicaciones comiencen como publicaciones preliminares y que las publicaciones preliminares no tengan su contenido disponible para mostrar. Cualquier intento de eludir estas limitaciones resultar&amp;aacute; en un error del compilador.</target>
        </trans-unit>
        <trans-unit id="b1de117663cb2f27f8306ea33629038001aac2df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Drop&lt;/code&gt; trait is included in the prelude, so we don&amp;rsquo;t need to bring it into scope. We implement the &lt;code&gt;Drop&lt;/code&gt; trait on &lt;code&gt;CustomSmartPointer&lt;/code&gt; and provide an implementation for the &lt;code&gt;drop&lt;/code&gt; method that calls &lt;code&gt;println!&lt;/code&gt;. The body of the &lt;code&gt;drop&lt;/code&gt; function is where you would place any logic that you wanted to run when an instance of your type goes out of scope. We&amp;rsquo;re printing some text here to demonstrate when Rust will call &lt;code&gt;drop&lt;/code&gt;.</source>
          <target state="translated">El rasgo &lt;code&gt;Drop&lt;/code&gt; est&amp;aacute; incluido en el preludio, por lo que no es necesario que lo llevemos al alcance. Implementamos el rasgo &lt;code&gt;Drop&lt;/code&gt; en &lt;code&gt;CustomSmartPointer&lt;/code&gt; y proporcionamos una implementaci&amp;oacute;n para el m&amp;eacute;todo &lt;code&gt;drop&lt;/code&gt; que llama a &lt;code&gt;println!&lt;/code&gt; . El cuerpo de la &lt;code&gt;drop&lt;/code&gt; la funci&amp;oacute;n es donde se coloque ninguna l&amp;oacute;gica que quer&amp;iacute;a correr cuando una instancia de su tipo fuera de &amp;aacute;mbito. Estamos imprimiendo un texto aqu&amp;iacute; para demostrar cuando Rust llamar&amp;aacute; a &lt;code&gt;drop&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a67a7efec93a37792cb31993e146b2f7a5f7bc09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Eq&lt;/code&gt; trait has no methods. Its purpose is to signal that for every value of the annotated type, the value is equal to itself. The &lt;code&gt;Eq&lt;/code&gt; trait can only be applied to types that also implement &lt;code&gt;PartialEq&lt;/code&gt;, although not all types that implement &lt;code&gt;PartialEq&lt;/code&gt; can implement &lt;code&gt;Eq&lt;/code&gt;. One example of this is floating point number types: the implementation of floating point numbers states that two instances of the not-a-number (&lt;code&gt;NaN&lt;/code&gt;) value are not equal to each other.</source>
          <target state="translated">El rasgo &lt;code&gt;Eq&lt;/code&gt; no tiene m&amp;eacute;todos. Su prop&amp;oacute;sito es se&amp;ntilde;alar que para cada valor del tipo anotado, el valor es igual a s&amp;iacute; mismo. El rasgo &lt;code&gt;Eq&lt;/code&gt; solo se puede aplicar a tipos que tambi&amp;eacute;n implementan &lt;code&gt;PartialEq&lt;/code&gt; , aunque no todos los tipos que implementan &lt;code&gt;PartialEq&lt;/code&gt; pueden implementar &lt;code&gt;Eq&lt;/code&gt; . Un ejemplo de esto son los tipos de n&amp;uacute;meros de punto flotante: la implementaci&amp;oacute;n de n&amp;uacute;meros de punto flotante establece que dos instancias del valor de no un n&amp;uacute;mero ( &lt;code&gt;NaN&lt;/code&gt; ) no son iguales entre s&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="339e508d8f9f4467a3c3de396b4c7c19141c661f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;F&lt;/code&gt; type parameter also has the trait bound &lt;code&gt;Send&lt;/code&gt; and the lifetime bound &lt;code&gt;'static&lt;/code&gt;, which are useful in our situation: we need &lt;code&gt;Send&lt;/code&gt; to transfer the closure from one thread to another and &lt;code&gt;'static&lt;/code&gt; because we don&amp;rsquo;t know how long the thread will take to execute. Let&amp;rsquo;s create an &lt;code&gt;execute&lt;/code&gt; method on &lt;code&gt;ThreadPool&lt;/code&gt; that will take a generic parameter of type &lt;code&gt;F&lt;/code&gt; with these bounds:</source>
          <target state="translated">El par&amp;aacute;metro de tipo &lt;code&gt;F&lt;/code&gt; tambi&amp;eacute;n tiene el atributo &lt;code&gt;Send&lt;/code&gt; y el l&amp;iacute;mite de por vida &lt;code&gt;'static&lt;/code&gt; , que son &amp;uacute;tiles en nuestra situaci&amp;oacute;n: necesitamos &lt;code&gt;Send&lt;/code&gt; para transferir el cierre de un hilo a otro y &lt;code&gt;'static&lt;/code&gt; porque no sabemos cu&amp;aacute;nto tiempo durar&amp;aacute; el hilo tomar para ejecutar. &lt;code&gt;ThreadPool&lt;/code&gt; un m&amp;eacute;todo de &lt;code&gt;execute&lt;/code&gt; en ThreadPool que tomar&amp;aacute; un par&amp;aacute;metro gen&amp;eacute;rico de tipo &lt;code&gt;F&lt;/code&gt; con estos l&amp;iacute;mites:</target>
        </trans-unit>
        <trans-unit id="44f286163600e21778b5e8ddc538f3f66c2c5215" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;F&lt;/code&gt; type parameter is the one we&amp;rsquo;re concerned with here; the &lt;code&gt;T&lt;/code&gt; type parameter is related to the return value, and we&amp;rsquo;re not concerned with that. We can see that &lt;code&gt;spawn&lt;/code&gt; uses &lt;code&gt;FnOnce&lt;/code&gt; as the trait bound on &lt;code&gt;F&lt;/code&gt;. This is probably what we want as well, because we&amp;rsquo;ll eventually pass the argument we get in &lt;code&gt;execute&lt;/code&gt; to &lt;code&gt;spawn&lt;/code&gt;. We can be further confident that &lt;code&gt;FnOnce&lt;/code&gt; is the trait we want to use because the thread for running a request will only execute that request&amp;rsquo;s closure one time, which matches the &lt;code&gt;Once&lt;/code&gt; in &lt;code&gt;FnOnce&lt;/code&gt;.</source>
          <target state="translated">El par&amp;aacute;metro de tipo &lt;code&gt;F&lt;/code&gt; es el que nos interesa aqu&amp;iacute;; el par&amp;aacute;metro de tipo &lt;code&gt;T&lt;/code&gt; est&amp;aacute; relacionado con el valor de retorno, y eso no nos preocupa. Podemos ver que &lt;code&gt;spawn&lt;/code&gt; utiliza &lt;code&gt;FnOnce&lt;/code&gt; como el rasgo cota &lt;code&gt;F&lt;/code&gt; . Esto es probablemente lo que tambi&amp;eacute;n queremos, porque eventualmente pasaremos el argumento que obtenemos en &lt;code&gt;execute&lt;/code&gt; para &lt;code&gt;spawn&lt;/code&gt; . Podemos estar m&amp;aacute;s seguros de que &lt;code&gt;FnOnce&lt;/code&gt; es el rasgo que queremos usar porque el hilo para ejecutar una solicitud solo ejecutar&amp;aacute; el cierre de esa solicitud una vez, lo que coincide con &lt;code&gt;Once&lt;/code&gt; in &lt;code&gt;FnOnce&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2cc0c55739bb91f91d10f706c9cab70e100723e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Fn&lt;/code&gt; traits are provided by the standard library. All closures implement at least one of the traits: &lt;code&gt;Fn&lt;/code&gt;, &lt;code&gt;FnMut&lt;/code&gt;, or &lt;code&gt;FnOnce&lt;/code&gt;. We&amp;rsquo;ll discuss the difference between these traits in the &lt;a href=&quot;#capturing-the-environment-with-closures&quot;&gt;&amp;ldquo;Capturing the Environment with Closures&amp;rdquo;&lt;/a&gt; section; in this example, we can use the &lt;code&gt;Fn&lt;/code&gt; trait.</source>
          <target state="translated">Los rasgos &lt;code&gt;Fn&lt;/code&gt; los proporciona la biblioteca est&amp;aacute;ndar. Todos los cierres implementan al menos uno de los rasgos: &lt;code&gt;Fn&lt;/code&gt; , &lt;code&gt;FnMut&lt;/code&gt; o &lt;code&gt;FnOnce&lt;/code&gt; . Discutiremos la diferencia entre estos rasgos en la secci&amp;oacute;n &lt;a href=&quot;#capturing-the-environment-with-closures&quot;&gt;&quot;Capturar el medio ambiente con cierres&quot;&lt;/a&gt; ; en este ejemplo, podemos usar el rasgo &lt;code&gt;Fn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="851722264534e1910cdc1ef4f424b4a4414f9688" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;From&lt;/code&gt; is also very useful when performing error handling. When constructing a function that is capable of failing, the return type will generally be of the form &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;. The &lt;code&gt;From&lt;/code&gt; trait simplifies error handling by allowing a function to return a single error type that encapsulate multiple error types. See the &quot;Examples&quot; section and &lt;a href=&quot;../../book/ch09-00-error-handling&quot;&gt;the book&lt;/a&gt; for more details.</source>
          <target state="translated">El &lt;code&gt;From&lt;/code&gt; tambi&amp;eacute;n es muy &amp;uacute;til al realizar el manejo de errores. Cuando se construye una funci&amp;oacute;n que puede fallar, el tipo de retorno generalmente ser&amp;aacute; de la forma &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; . El rasgo &lt;code&gt;From&lt;/code&gt; simplifica el manejo de errores al permitir que una funci&amp;oacute;n devuelva un solo tipo de error que encapsula m&amp;uacute;ltiples tipos de error. Consulte la secci&amp;oacute;n &quot;Ejemplos&quot; y &lt;a href=&quot;../../book/ch09-00-error-handling&quot;&gt;el libro&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="924c96483cec1214b829647e918270a4c12cbe49" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GeneratorState&lt;/code&gt; enum returned from this function indicates what state the generator is in upon returning. If the &lt;code&gt;Yielded&lt;/code&gt; variant is returned then the generator has reached a suspension point and a value has been yielded out. Generators in this state are available for resumption at a later point.</source>
          <target state="translated">La enumeraci&amp;oacute;n &lt;code&gt;GeneratorState&lt;/code&gt; devuelta por esta funci&amp;oacute;n indica en qu&amp;eacute; estado se encuentra el generador al regresar. Si se devuelve la variante &lt;code&gt;Yielded&lt;/code&gt; , el generador ha alcanzado un punto de suspensi&amp;oacute;n y se ha obtenido un valor. Los generadores en este estado est&amp;aacute;n disponibles para reanudarse en un momento posterior.</target>
        </trans-unit>
        <trans-unit id="93144a0b07feb0dfc814fce370a7ec1878fc8518" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GlobalAlloc&lt;/code&gt; trait is an &lt;code&gt;unsafe&lt;/code&gt; trait for a number of reasons, and implementors must ensure that they adhere to these contracts:</source>
          <target state="translated">El rasgo &lt;code&gt;GlobalAlloc&lt;/code&gt; es un rasgo &lt;code&gt;unsafe&lt;/code&gt; por varias razones, y los implementadores deben asegurarse de cumplir con estos contratos:</target>
        </trans-unit>
        <trans-unit id="ac746bf118e800d6204d1b9be35a781fccfa8fc0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Hash&lt;/code&gt; trait allows you to take an instance of a type of arbitrary size and map that instance to a value of fixed size using a hash function. Deriving &lt;code&gt;Hash&lt;/code&gt; implements the &lt;code&gt;hash&lt;/code&gt; method. The derived implementation of the &lt;code&gt;hash&lt;/code&gt; method combines the result of calling &lt;code&gt;hash&lt;/code&gt; on each of the parts of the type, meaning all fields or values must also implement &lt;code&gt;Hash&lt;/code&gt; to derive &lt;code&gt;Hash&lt;/code&gt;.</source>
          <target state="translated">El rasgo &lt;code&gt;Hash&lt;/code&gt; le permite tomar una instancia de un tipo de tama&amp;ntilde;o arbitrario y asignar esa instancia a un valor de tama&amp;ntilde;o fijo usando una funci&amp;oacute;n hash. Deriving &lt;code&gt;Hash&lt;/code&gt; implementa el m&amp;eacute;todo &lt;code&gt;hash&lt;/code&gt; . La implementaci&amp;oacute;n derivada del m&amp;eacute;todo &lt;code&gt;hash&lt;/code&gt; combina el resultado de llamar a &lt;code&gt;hash&lt;/code&gt; en cada una de las partes del tipo, lo que significa que todos los campos o valores tambi&amp;eacute;n deben implementar &lt;code&gt;Hash&lt;/code&gt; para derivar &lt;code&gt;Hash&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc2c322c74118357f702bcbb43acd3519194cb4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Iterator&lt;/code&gt; trait has a number of different methods with default implementations provided by the standard library; you can find out about these methods by looking in the standard library API documentation for the &lt;code&gt;Iterator&lt;/code&gt; trait. Some of these methods call the &lt;code&gt;next&lt;/code&gt; method in their definition, which is why you&amp;rsquo;re required to implement the &lt;code&gt;next&lt;/code&gt; method when implementing the &lt;code&gt;Iterator&lt;/code&gt; trait.</source>
          <target state="translated">El rasgo &lt;code&gt;Iterator&lt;/code&gt; tiene varios m&amp;eacute;todos diferentes con implementaciones predeterminadas proporcionadas por la biblioteca est&amp;aacute;ndar; puede obtener informaci&amp;oacute;n sobre estos m&amp;eacute;todos buscando en la documentaci&amp;oacute;n API de la biblioteca est&amp;aacute;ndar el rasgo &lt;code&gt;Iterator&lt;/code&gt; . Algunos de estos m&amp;eacute;todos llaman &lt;code&gt;next&lt;/code&gt; m&amp;eacute;todo siguiente en su definici&amp;oacute;n, por lo que debe implementar el m&amp;eacute;todo &lt;code&gt;next&lt;/code&gt; al implementar el rasgo &lt;code&gt;Iterator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7674b68a4f6af8a05d48508e05e8b51cf5d1646" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Iterator&lt;/code&gt; trait only requires implementors to define one method: the &lt;code&gt;next&lt;/code&gt; method, which returns one item of the iterator at a time wrapped in &lt;code&gt;Some&lt;/code&gt; and, when iteration is over, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">El rasgo &lt;code&gt;Iterator&lt;/code&gt; solo requiere que los implementadores definan un m&amp;eacute;todo: el m&amp;eacute;todo &lt;code&gt;next&lt;/code&gt; , que devuelve un elemento del iterador a la vez envuelto en &lt;code&gt;Some&lt;/code&gt; y, cuando finaliza la iteraci&amp;oacute;n, devuelve &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9025083930c31cf7871ed20937306b52f26761a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LinkedList&lt;/code&gt; allows pushing and popping elements at either end in constant time.</source>
          <target state="translated">El &lt;code&gt;LinkedList&lt;/code&gt; permite empujar y hacer estallar los elementos en cada extremo en tiempo constante.</target>
        </trans-unit>
        <trans-unit id="4baf38aed9bf1ffe36a931bbfb0cb77e6aa0a43b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LowerExp&lt;/code&gt; trait should format its output in scientific notation with a lower-case &lt;code&gt;e&lt;/code&gt;.</source>
          <target state="translated">El rasgo &lt;code&gt;LowerExp&lt;/code&gt; debe formatear su salida en notaci&amp;oacute;n cient&amp;iacute;fica con una &lt;code&gt;e&lt;/code&gt; min&amp;uacute;scula .</target>
        </trans-unit>
        <trans-unit id="dc66d9062a365376bc4e9ff4cb202550c7cc32a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LowerHex&lt;/code&gt; trait should format its output as a number in hexadecimal, with &lt;code&gt;a&lt;/code&gt; through &lt;code&gt;f&lt;/code&gt; in lower case.</source>
          <target state="translated">El rasgo &lt;code&gt;LowerHex&lt;/code&gt; debe formatear su salida como un n&amp;uacute;mero en hexadecimal, con &lt;code&gt;a&lt;/code&gt; hasta una &lt;code&gt;f&lt;/code&gt; en min&amp;uacute;sculas.</target>
        </trans-unit>
        <trans-unit id="3b321c2a56af633f328bf4b8ba254ce361d7a954" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Octal&lt;/code&gt; trait should format its output as a number in base-8.</source>
          <target state="translated">El rasgo &lt;code&gt;Octal&lt;/code&gt; debe formatear su salida como un n&amp;uacute;mero en base 8.</target>
        </trans-unit>
        <trans-unit id="eb10a578affd8a62e12f3ef265b344e167e3dcf6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; enum is so useful that it&amp;rsquo;s even included in the prelude; you don&amp;rsquo;t need to bring it into scope explicitly. In addition, so are its variants: you can use &lt;code&gt;Some&lt;/code&gt; and &lt;code&gt;None&lt;/code&gt; directly without the &lt;code&gt;Option::&lt;/code&gt; prefix. The &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; enum is still just a regular enum, and &lt;code&gt;Some(T)&lt;/code&gt; and &lt;code&gt;None&lt;/code&gt; are still variants of type &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">La enumeraci&amp;oacute;n &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; es tan &amp;uacute;til que incluso se incluye en el preludio; no es necesario incluirlo en el &amp;aacute;mbito de forma expl&amp;iacute;cita. Adem&amp;aacute;s, tambi&amp;eacute;n lo son sus variantes: puede usar &lt;code&gt;Some&lt;/code&gt; y &lt;code&gt;None&lt;/code&gt; directamente sin el prefijo &lt;code&gt;Option::&lt;/code&gt; . La enumeraci&amp;oacute;n &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; sigue siendo solo una enumeraci&amp;oacute;n regular, y &lt;code&gt;Some(T)&lt;/code&gt; y &lt;code&gt;None&lt;/code&gt; siguen siendo variantes del tipo &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="757a8b38147115f7267a95ffaa6fac00dcad6a55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Option&lt;/code&gt; type. See &lt;a href=&quot;index&quot;&gt;the module level documentation&lt;/a&gt; for more.</source>
          <target state="translated">El tipo de &lt;code&gt;Option&lt;/code&gt; . Consulte &lt;a href=&quot;index&quot;&gt;la documentaci&amp;oacute;n de nivel de m&amp;oacute;dulo&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6ec87aec96d36200bb49beb7ba67c5c626bb7aad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Ord&lt;/code&gt; trait allows you to know that for any two values of the annotated type, a valid ordering will exist. The &lt;code&gt;Ord&lt;/code&gt; trait implements the &lt;code&gt;cmp&lt;/code&gt; method, which returns an &lt;code&gt;Ordering&lt;/code&gt; rather than an &lt;code&gt;Option&amp;lt;Ordering&amp;gt;&lt;/code&gt; because a valid ordering will always be possible. You can only apply the &lt;code&gt;Ord&lt;/code&gt; trait to types that also implement &lt;code&gt;PartialOrd&lt;/code&gt; and &lt;code&gt;Eq&lt;/code&gt; (and &lt;code&gt;Eq&lt;/code&gt; requires &lt;code&gt;PartialEq&lt;/code&gt;). When derived on structs and enums, &lt;code&gt;cmp&lt;/code&gt; behaves the same way as the derived implementation for &lt;code&gt;partial_cmp&lt;/code&gt; does with &lt;code&gt;PartialOrd&lt;/code&gt;.</source>
          <target state="translated">El rasgo &lt;code&gt;Ord&lt;/code&gt; le permite saber que para dos valores cualesquiera del tipo anotado, existir&amp;aacute; un orden v&amp;aacute;lido. El rasgo &lt;code&gt;Ord&lt;/code&gt; implementa el m&amp;eacute;todo &lt;code&gt;cmp&lt;/code&gt; , que devuelve un &lt;code&gt;Ordering&lt;/code&gt; en lugar de una &lt;code&gt;Option&amp;lt;Ordering&amp;gt;&lt;/code&gt; porque siempre ser&amp;aacute; posible un pedido v&amp;aacute;lido. Solo puede aplicar el rasgo &lt;code&gt;Ord&lt;/code&gt; a tipos que tambi&amp;eacute;n implementan &lt;code&gt;PartialOrd&lt;/code&gt; y &lt;code&gt;Eq&lt;/code&gt; (y &lt;code&gt;Eq&lt;/code&gt; requiere &lt;code&gt;PartialEq&lt;/code&gt; ). Cuando se deriva de estructuras y enumeraciones, &lt;code&gt;cmp&lt;/code&gt; se comporta de la misma manera que la implementaci&amp;oacute;n derivada de &lt;code&gt;partial_cmp&lt;/code&gt; con &lt;code&gt;PartialOrd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="711a8eb9ad73721345ff8b7d5d49057eb05ba2c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Orphan Check&lt;/code&gt; states that every trait implementation must meet either of the following conditions:</source>
          <target state="translated">Los &lt;code&gt;Orphan Check&lt;/code&gt; estados que cada rasgo aplicaci&amp;oacute;n debe cumplir alguna de las siguientes condiciones:</target>
        </trans-unit>
        <trans-unit id="c00d178bf6b2317cc12ea4871792b476ee2d6ac7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PartialEq&lt;/code&gt; trait allows you to compare instances of a type to check for equality and enables use of the &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; operators.</source>
          <target state="translated">El rasgo &lt;code&gt;PartialEq&lt;/code&gt; le permite comparar instancias de un tipo para verificar la igualdad y habilita el uso de los operadores &lt;code&gt;==&lt;/code&gt; y &lt;code&gt;!=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43e89dc3eb492904f3da074b02b2cf97b105430c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PartialEq&lt;/code&gt; trait is required, for example, with the use of the &lt;code&gt;assert_eq!&lt;/code&gt; macro, which needs to be able to compare two instances of a type for equality.</source>
          <target state="translated">El rasgo &lt;code&gt;PartialEq&lt;/code&gt; es necesario, por ejemplo, con el uso de &lt;code&gt;assert_eq!&lt;/code&gt; macro, que debe poder comparar dos instancias de un tipo para determinar la igualdad.</target>
        </trans-unit>
        <trans-unit id="a3b5763e3772b503d126748c966660daf7b02e86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PartialOrd&lt;/code&gt; trait allows you to compare instances of a type for sorting purposes. A type that implements &lt;code&gt;PartialOrd&lt;/code&gt; can be used with the &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;=&lt;/code&gt; operators. You can only apply the &lt;code&gt;PartialOrd&lt;/code&gt; trait to types that also implement &lt;code&gt;PartialEq&lt;/code&gt;.</source>
          <target state="translated">El rasgo &lt;code&gt;PartialOrd&lt;/code&gt; le permite comparar instancias de un tipo con fines de clasificaci&amp;oacute;n. Un tipo que implementa &lt;code&gt;PartialOrd&lt;/code&gt; se puede usar con los operadores &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; y &lt;code&gt;&amp;gt;=&lt;/code&gt; . Solo puede aplicar el rasgo &lt;code&gt;PartialOrd&lt;/code&gt; a tipos que tambi&amp;eacute;n implementan &lt;code&gt;PartialEq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d44604638bc3e14fe0790aae9645322a35831c38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PartialOrd&lt;/code&gt; trait is required, for example, for the &lt;code&gt;gen_range&lt;/code&gt; method from the &lt;code&gt;rand&lt;/code&gt; crate that generates a random value in the range specified by a low value and a high value.</source>
          <target state="translated">El rasgo &lt;code&gt;PartialOrd&lt;/code&gt; es necesario, por ejemplo, para el m&amp;eacute;todo &lt;code&gt;gen_range&lt;/code&gt; de la caja &lt;code&gt;rand&lt;/code&gt; que genera un valor aleatorio en el rango especificado por un valor bajo y un valor alto.</target>
        </trans-unit>
        <trans-unit id="aa9b33d349ddf99a4aba8a405103bf7fb4c6e253" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Pointer&lt;/code&gt; trait should format its output as a memory location. This is commonly presented as hexadecimal.</source>
          <target state="translated">El rasgo &lt;code&gt;Pointer&lt;/code&gt; debe formatear su salida como una ubicaci&amp;oacute;n de memoria. Esto se presenta com&amp;uacute;nmente como hexadecimal.</target>
        </trans-unit>
        <trans-unit id="ab8bbad2b08fc48ec0e5ed2730d22da62501a267" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Range&lt;/code&gt;&lt;code&gt;start..end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;gt;= start&lt;/code&gt; and &lt;code&gt;x &amp;lt; end&lt;/code&gt;. It is empty unless &lt;code&gt;start &amp;lt; end&lt;/code&gt;.</source>
          <target state="translated">El &lt;code&gt;Range&lt;/code&gt; &lt;code&gt;start..end&lt;/code&gt; contiene todos los valores con &lt;code&gt;x &amp;gt;= start&lt;/code&gt; y &lt;code&gt;x &amp;lt; end&lt;/code&gt; . Est&amp;aacute; vac&amp;iacute;o a menos que &lt;code&gt;start &amp;lt; end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2aa0761be84214baf72bdc665e4aaa54d88ab96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeFrom&lt;/code&gt;&lt;code&gt;start..&lt;/code&gt; contains all values with &lt;code&gt;x &amp;gt;= start&lt;/code&gt;.</source>
          <target state="translated">El &lt;code&gt;RangeFrom&lt;/code&gt; &lt;code&gt;start..&lt;/code&gt; contiene todos los valores con &lt;code&gt;x &amp;gt;= start&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73c149dd90366bce823890f694cf867f1bb0a225" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeInclusive&lt;/code&gt;&lt;code&gt;start..=end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;gt;= start&lt;/code&gt; and &lt;code&gt;x &amp;lt;= end&lt;/code&gt;. It is empty unless &lt;code&gt;start &amp;lt;= end&lt;/code&gt;.</source>
          <target state="translated">El &lt;code&gt;start..=end&lt;/code&gt; &lt;code&gt;RangeInclusive&lt;/code&gt; .. = end contiene todos los valores con &lt;code&gt;x &amp;gt;= start&lt;/code&gt; y &lt;code&gt;x &amp;lt;= end&lt;/code&gt; . Est&amp;aacute; vac&amp;iacute;o a menos que &lt;code&gt;start &amp;lt;= end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cec61b7c44a745e689ab10fff029089cd54c5d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeTo&lt;/code&gt;&lt;code&gt;..end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;lt; end&lt;/code&gt;. It cannot serve as an &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; because it doesn't have a starting point.</source>
          <target state="translated">El &lt;code&gt;RangeTo&lt;/code&gt; &lt;code&gt;..end&lt;/code&gt; contiene todos los valores con &lt;code&gt;x &amp;lt; end&lt;/code&gt; . No puede servir como &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; porque no tiene un punto de partida.</target>
        </trans-unit>
        <trans-unit id="0de78a1c773797166ef937a052ccd5e9331c867f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeTo&lt;/code&gt;&lt;code&gt;..end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;lt; end&lt;/code&gt;. It cannot serve as an &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; because it doesn't have a starting point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e2d4326e8450b1f620c09e80702de680708776b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeToInclusive&lt;/code&gt;&lt;code&gt;..=end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;lt;= end&lt;/code&gt;. It cannot serve as an &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; because it doesn't have a starting point.</source>
          <target state="translated">El &lt;code&gt;RangeToInclusive&lt;/code&gt; &lt;code&gt;..=end&lt;/code&gt; contiene todos los valores con &lt;code&gt;x &amp;lt;= end&lt;/code&gt; . No puede servir como &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; porque no tiene un punto de partida.</target>
        </trans-unit>
        <trans-unit id="0729997e88bb0119e0af233dfbcdefc61396cf4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeToInclusive&lt;/code&gt;&lt;code&gt;..=end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;lt;= end&lt;/code&gt;. It cannot serve as an &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; because it doesn't have a starting point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebdc80637c460a3fe51040149db057ee546f653a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Rc::clone(&amp;amp;from)&lt;/code&gt; syntax is the most idiomatic because it conveys more explicitly the meaning of the code. In the example above, this syntax makes it easier to see that this code is creating a new reference rather than copying the whole content of foo.</source>
          <target state="translated">La sintaxis &lt;code&gt;Rc::clone(&amp;amp;from)&lt;/code&gt; es la m&amp;aacute;s idiom&amp;aacute;tica porque transmite m&amp;aacute;s expl&amp;iacute;citamente el significado del c&amp;oacute;digo. En el ejemplo anterior, esta sintaxis facilita ver que este c&amp;oacute;digo est&amp;aacute; creando una nueva referencia en lugar de copiar todo el contenido de foo.</target>
        </trans-unit>
        <trans-unit id="d18566a4555f118c35b2f7296c41294a80e62f05" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Read&lt;/code&gt; trait allows for reading bytes from a source.</source>
          <target state="translated">El &lt;code&gt;Read&lt;/code&gt; rasgo permite la lectura de bytes de una fuente.</target>
        </trans-unit>
        <trans-unit id="167de79249a0cb690644cc2f30f26fd674ac84c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; keeps track of how many &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; smart pointers are currently active. Every time we call &lt;code&gt;borrow&lt;/code&gt;, the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; increases its count of how many immutable borrows are active. When a &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; value goes out of scope, the count of immutable borrows goes down by one. Just like the compile-time borrowing rules, &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; lets us have many immutable borrows or one mutable borrow at any point in time.</source>
          <target state="translated">El &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; mantiene un registro de cu&amp;aacute;ntas &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; y &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; punteros inteligentes son actualmente activo. Cada vez que llamamos a &lt;code&gt;borrow&lt;/code&gt; , &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; aumenta su recuento de cu&amp;aacute;ntos pr&amp;eacute;stamos inmutables est&amp;aacute;n activos. Cuando un valor de &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; sale de su alcance, el recuento de pr&amp;eacute;stamos inmutables se reduce en uno. Al igual que las reglas de pr&amp;eacute;stamos en tiempo de compilaci&amp;oacute;n, &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; nos permite tener muchos pr&amp;eacute;stamos inmutables o un pr&amp;eacute;stamo mutable en cualquier momento.</target>
        </trans-unit>
        <trans-unit id="2e6771afd6b14e03fc38f6d16106ee1f97bd4cbd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RefCell&lt;/code&gt; is already immutably borrowed, so this cannot fail.</source>
          <target state="translated">El &lt;code&gt;RefCell&lt;/code&gt; ya ha sido tomada de manera inmutable, por lo que este no puede fallar.</target>
        </trans-unit>
        <trans-unit id="c305974ea6149ae71e2c43fcd219e993594dd96e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RefCell&lt;/code&gt; is already mutably borrowed, so this cannot fail.</source>
          <target state="translated">El &lt;code&gt;RefCell&lt;/code&gt; ya est&amp;aacute; tomada mutably, as&amp;iacute; que esto no puede fallar.</target>
        </trans-unit>
        <trans-unit id="52b1edfc20b8e3433cc429a2a34dab08626e2ce2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Result&amp;lt;..., Error&amp;gt;&lt;/code&gt; is repeated a lot. As such, &lt;code&gt;std::io&lt;/code&gt; has this type of alias declaration:</source>
          <target state="translated">El &lt;code&gt;Result&amp;lt;..., Error&amp;gt;&lt;/code&gt; se repite mucho. Como tal, &lt;code&gt;std::io&lt;/code&gt; tiene este tipo de declaraci&amp;oacute;n de alias:</target>
        </trans-unit>
        <trans-unit id="1e71572578c618ddeccc701e84d14574b4552896" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Result&lt;/code&gt; enum is generic over two types, &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;E&lt;/code&gt;, and has two variants: &lt;code&gt;Ok&lt;/code&gt;, which holds a value of type &lt;code&gt;T&lt;/code&gt;, and &lt;code&gt;Err&lt;/code&gt;, which holds a value of type &lt;code&gt;E&lt;/code&gt;. This definition makes it convenient to use the &lt;code&gt;Result&lt;/code&gt; enum anywhere we have an operation that might succeed (return a value of some type &lt;code&gt;T&lt;/code&gt;) or fail (return an error of some type &lt;code&gt;E&lt;/code&gt;). In fact, this is what we used to open a file in Listing 9-3, where &lt;code&gt;T&lt;/code&gt; was filled in with the type &lt;code&gt;std::fs::File&lt;/code&gt; when the file was opened successfully and &lt;code&gt;E&lt;/code&gt; was filled in with the type &lt;code&gt;std::io::Error&lt;/code&gt; when there were problems opening the file.</source>
          <target state="translated">El &lt;code&gt;Result&lt;/code&gt; de enumeraci&amp;oacute;n es gen&amp;eacute;rico m&amp;aacute;s de dos tipos, &lt;code&gt;T&lt;/code&gt; y &lt;code&gt;E&lt;/code&gt; , y tiene dos variantes: &lt;code&gt;Ok&lt;/code&gt; , que tiene un valor de tipo &lt;code&gt;T&lt;/code&gt; , y &lt;code&gt;Err&lt;/code&gt; , que tiene un valor de tipo &lt;code&gt;E&lt;/code&gt; . Esta definici&amp;oacute;n hace que sea conveniente usar la enumeraci&amp;oacute;n &lt;code&gt;Result&lt;/code&gt; en cualquier lugar donde tengamos una operaci&amp;oacute;n que podr&amp;iacute;a tener &amp;eacute;xito (devolver un valor de alg&amp;uacute;n tipo &lt;code&gt;T&lt;/code&gt; ) o fallar (devolver un error de alg&amp;uacute;n tipo &lt;code&gt;E&lt;/code&gt; ). De hecho, esto es lo que usamos para abrir un archivo en el Listado 9-3, donde &lt;code&gt;T&lt;/code&gt; se complet&amp;oacute; con el tipo &lt;code&gt;std::fs::File&lt;/code&gt; cuando el archivo se abri&amp;oacute; correctamente y &lt;code&gt;E&lt;/code&gt; se complet&amp;oacute; con el tipo &lt;code&gt;std::io::Error&lt;/code&gt; cuando hubo problemas para abrir el archivo.</target>
        </trans-unit>
        <trans-unit id="67d17ec2155cc71f4cbd159b4631b04d17855080" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Result&lt;/code&gt; types are &lt;a href=&quot;ch06-00-enums&quot;&gt;&lt;em&gt;enumerations&lt;/em&gt;&lt;/a&gt;, often referred to as &lt;em&gt;enums&lt;/em&gt;. An enumeration is a type that can have a fixed set of values, and those values are called the enum&amp;rsquo;s &lt;em&gt;variants&lt;/em&gt;. Chapter 6 will cover enums in more detail.</source>
          <target state="translated">Los tipos de &lt;code&gt;Result&lt;/code&gt; son &lt;a href=&quot;ch06-00-enums&quot;&gt;&lt;em&gt;enumeraciones&lt;/em&gt;&lt;/a&gt; , a menudo denominadas &lt;em&gt;enumeraciones&lt;/em&gt; . Una enumeraci&amp;oacute;n es un tipo que puede tener un conjunto fijo de valores, y esos valores se denominan &lt;em&gt;variantes de&lt;/em&gt; la enumeraci&amp;oacute;n . El cap&amp;iacute;tulo 6 cubrir&amp;aacute; las enumeraciones con m&amp;aacute;s detalle.</target>
        </trans-unit>
        <trans-unit id="64d4c779a9a53da0609d26369514238e751f0a8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Seek&lt;/code&gt; trait provides a cursor which can be moved within a stream of bytes.</source>
          <target state="translated">El rasgo de &lt;code&gt;Seek&lt;/code&gt; proporciona un cursor que se puede mover dentro de una secuencia de bytes.</target>
        </trans-unit>
        <trans-unit id="45132395a8da1a9af17f15db9b29d073d0c74c5d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; keyword is an alias for the type we&amp;rsquo;re implementing the traits or methods on. Trait objects must be object safe because once you&amp;rsquo;ve used a trait object, Rust no longer knows the concrete type that&amp;rsquo;s implementing that trait. If a trait method returns the concrete &lt;code&gt;Self&lt;/code&gt; type, but a trait object forgets the exact type that &lt;code&gt;Self&lt;/code&gt; is, there is no way the method can use the original concrete type. The same is true of generic type parameters that are filled in with concrete type parameters when the trait is used: the concrete types become part of the type that implements the trait. When the type is forgotten through the use of a trait object, there is no way to know what types to fill in the generic type parameters with.</source>
          <target state="translated">La palabra clave &lt;code&gt;Self&lt;/code&gt; es un alias para el tipo en el que estamos implementando los rasgos o m&amp;eacute;todos. Los objetos de rasgo deben ser seguros para objetos porque una vez que ha usado un objeto de rasgo, Rust ya no sabe el tipo concreto que est&amp;aacute; implementando ese rasgo. Si un m&amp;eacute;todo de rasgo devuelve el tipo &lt;code&gt;Self&lt;/code&gt; concreto , pero un objeto rasgo olvida el tipo exacto que es &lt;code&gt;Self&lt;/code&gt; , no hay forma de que el m&amp;eacute;todo pueda usar el tipo concreto original. Lo mismo ocurre con los par&amp;aacute;metros de tipo gen&amp;eacute;rico que se completan con par&amp;aacute;metros de tipo concreto cuando se utiliza el rasgo: los tipos concretos pasan a formar parte del tipo que implementa el rasgo. Cuando el tipo se olvida mediante el uso de un objeto de rasgo, no hay forma de saber con qu&amp;eacute; tipos completar los par&amp;aacute;metros de tipo gen&amp;eacute;rico.</target>
        </trans-unit>
        <trans-unit id="90a76b71efb75f391d26231783f81feb6c797a7f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; keyword represents the current type, which explains why it can only be used inside an impl, trait, or type definition. It gives access to the associated items of a type:</source>
          <target state="translated">La palabra clave &lt;code&gt;Self&lt;/code&gt; representa el tipo actual, lo que explica por qu&amp;eacute; solo se puede usar dentro de una definici&amp;oacute;n de impl, rasgo o tipo. Da acceso a los elementos asociados de un tipo:</target>
        </trans-unit>
        <trans-unit id="a02332e854d71300403fa93482ff8605d97eadb6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; keyword was used outside an impl, trait, or type definition.</source>
          <target state="translated">La palabra clave &lt;code&gt;Self&lt;/code&gt; se us&amp;oacute; fuera de una definici&amp;oacute;n impl&amp;iacute;cita, de rasgo o de tipo.</target>
        </trans-unit>
        <trans-unit id="6a3c6ecd1deb9539342b4b667c8f7da5207114d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; term can be replaced with the type being implemented.</source>
          <target state="translated">El t&amp;eacute;rmino &lt;code&gt;Self&lt;/code&gt; se puede reemplazar con el tipo que se est&amp;aacute; implementando.</target>
        </trans-unit>
        <trans-unit id="268068ec98ee8d589f1d0d25a4fa87cb52fefae1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; terminal in this grammar denotes a type resolving to the implementing type. This can also include the contextual type alias &lt;code&gt;Self&lt;/code&gt;, other type aliases, or associated type projections resolving to the implementing type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d50619fe26b234beecf764a55ec164440b77b3f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Send&lt;/code&gt; marker trait indicates that ownership of the type implementing &lt;code&gt;Send&lt;/code&gt; can be transferred between threads. Almost every Rust type is &lt;code&gt;Send&lt;/code&gt;, but there are some exceptions, including &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;: this cannot be &lt;code&gt;Send&lt;/code&gt; because if you cloned an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value and tried to transfer ownership of the clone to another thread, both threads might update the reference count at the same time. For this reason, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; is implemented for use in single-threaded situations where you don&amp;rsquo;t want to pay the thread-safe performance penalty.</source>
          <target state="translated">El rasgo de marcador de &lt;code&gt;Send&lt;/code&gt; indica que la propiedad del tipo que implementa el &lt;code&gt;Send&lt;/code&gt; se puede transferir entre subprocesos. Casi todos los tipos de Rust son &lt;code&gt;Send&lt;/code&gt; , pero hay algunas excepciones, incluido &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; : esto no puede ser &lt;code&gt;Send&lt;/code&gt; porque si clon&amp;oacute; un valor &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; e intent&amp;oacute; transferir la propiedad del clon a otro hilo, ambos hilos podr&amp;iacute;an actualizar el recuento de referencias al mismo tiempo. Por esta raz&amp;oacute;n, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; est&amp;aacute; implementado para su uso en situaciones de un solo subproceso en las que no desea pagar la penalizaci&amp;oacute;n de rendimiento seguro para subprocesos.</target>
        </trans-unit>
        <trans-unit id="da7504f8cf4ba12a9f166abe295fe49d0cc29f7f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sized&lt;/code&gt; trait is a special trait built-in to the compiler for types with a constant size known at compile-time. This trait is automatically implemented for types as needed by the compiler, and it is currently disallowed to explicitly implement it for a type.</source>
          <target state="translated">El rasgo &lt;code&gt;Sized&lt;/code&gt; es un rasgo especial incorporado al compilador para tipos con un tama&amp;ntilde;o constante conocido en tiempo de compilaci&amp;oacute;n. Este rasgo se implementa autom&amp;aacute;ticamente para los tipos seg&amp;uacute;n lo necesite el compilador, y actualmente no est&amp;aacute; permitido implementarlo expl&amp;iacute;citamente para un tipo.</target>
        </trans-unit>
        <trans-unit id="faed9283b4f09789ea3439cf47c62be8b01765b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sized&lt;/code&gt; trait was implemented explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57ed07b6ec3a8248f3dbedbfe819f564dab9a89c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Some(5)&lt;/code&gt; value doesn&amp;rsquo;t match the pattern &lt;code&gt;None&lt;/code&gt;, so we continue to the next arm.</source>
          <target state="translated">El valor &lt;code&gt;Some(5)&lt;/code&gt; no coincide con el patr&amp;oacute;n &lt;code&gt;None&lt;/code&gt; , as&amp;iacute; que continuamos con el siguiente brazo.</target>
        </trans-unit>
        <trans-unit id="5cf7d1bcd1b02d8684f384aeb150bd3c1fada36f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;State&lt;/code&gt; trait defines the behavior shared by different post states, and the &lt;code&gt;Draft&lt;/code&gt;, &lt;code&gt;PendingReview&lt;/code&gt;, and &lt;code&gt;Published&lt;/code&gt; states will all implement the &lt;code&gt;State&lt;/code&gt; trait. For now, the trait doesn&amp;rsquo;t have any methods, and we&amp;rsquo;ll start by defining just the &lt;code&gt;Draft&lt;/code&gt; state because that is the state we want a post to start in.</source>
          <target state="translated">El rasgo de &lt;code&gt;State&lt;/code&gt; define el comportamiento compartido por diferentes estados de publicaci&amp;oacute;n, y los estados &lt;code&gt;Draft&lt;/code&gt; , &lt;code&gt;PendingReview&lt;/code&gt; y &lt;code&gt;Published&lt;/code&gt; implementar&amp;aacute;n el rasgo de &lt;code&gt;State&lt;/code&gt; . Por ahora, el rasgo no tiene ning&amp;uacute;n m&amp;eacute;todo, y comenzaremos definiendo solo el estado &lt;code&gt;Draft&lt;/code&gt; porque ese es el estado en el que queremos que comience una publicaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a99c80ac2ff235e2978574f670cbd4660bb61703" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;String&lt;/code&gt; type implements the &lt;code&gt;Clone&lt;/code&gt; trait, and when we call the &lt;code&gt;clone&lt;/code&gt; method on an instance of &lt;code&gt;String&lt;/code&gt; we get back an instance of &lt;code&gt;String&lt;/code&gt;. Similarly, if we call &lt;code&gt;clone&lt;/code&gt; on an instance of &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, we get back an instance of &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. The signature of &lt;code&gt;clone&lt;/code&gt; needs to know what type will stand in for &lt;code&gt;Self&lt;/code&gt;, because that&amp;rsquo;s the return type.</source>
          <target state="translated">El tipo &lt;code&gt;String&lt;/code&gt; implementa el rasgo &lt;code&gt;Clone&lt;/code&gt; , y cuando llamamos al m&amp;eacute;todo &lt;code&gt;clone&lt;/code&gt; en una instancia de &lt;code&gt;String&lt;/code&gt; , obtenemos una instancia de &lt;code&gt;String&lt;/code&gt; . De manera similar, si llamamos a &lt;code&gt;clone&lt;/code&gt; en una instancia de &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; , obtenemos una instancia de &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; . La firma del &lt;code&gt;clone&lt;/code&gt; necesita saber qu&amp;eacute; tipo sustituir&amp;aacute; a &lt;code&gt;Self&lt;/code&gt; , porque ese es el tipo de retorno.</target>
        </trans-unit>
        <trans-unit id="ce3a0f98cdb5c97fe7ff53bab286ef96b0a0614f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;String&lt;/code&gt; type is the most common string type that has ownership over the contents of the string. It has a close relationship with its borrowed counterpart, the primitive &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El tipo de &lt;code&gt;String&lt;/code&gt; es el tipo de cadena m&amp;aacute;s com&amp;uacute;n que tiene propiedad sobre el contenido de la cadena. Tiene una estrecha relaci&amp;oacute;n con su contraparte prestada, la &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; primitiva .</target>
        </trans-unit>
        <trans-unit id="75cb7ba1e6deab5f4a0c4ef1dddcb7ea6d8d2520" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;String&lt;/code&gt; type, which is provided by Rust&amp;rsquo;s standard library rather than coded into the core language, is a growable, mutable, owned, UTF-8 encoded string type. When Rustaceans refer to &amp;ldquo;strings&amp;rdquo; in Rust, they usually mean the &lt;code&gt;String&lt;/code&gt; and the string slice &lt;code&gt;&amp;amp;str&lt;/code&gt; types, not just one of those types. Although this section is largely about &lt;code&gt;String&lt;/code&gt;, both types are used heavily in Rust&amp;rsquo;s standard library, and both &lt;code&gt;String&lt;/code&gt; and string slices are UTF-8 encoded.</source>
          <target state="translated">El tipo de &lt;code&gt;String&lt;/code&gt; , que es proporcionado por la biblioteca est&amp;aacute;ndar de Rust en lugar de codificado en el lenguaje principal, es un tipo de cadena codificada en UTF-8, de propiedad, que puede crecer, mutable. Cuando los rust&amp;aacute;ceos se refieren a &quot;cadenas&quot; en Rust, por lo general se refieren a los tipos &lt;code&gt;String&lt;/code&gt; y slice &lt;code&gt;&amp;amp;str&lt;/code&gt; , no solo a uno de esos tipos. Aunque esta secci&amp;oacute;n trata principalmente sobre &lt;code&gt;String&lt;/code&gt; , ambos tipos se utilizan mucho en la biblioteca est&amp;aacute;ndar de Rust, y tanto &lt;code&gt;String&lt;/code&gt; como los cortes de cadena est&amp;aacute;n codificados en UTF-8.</target>
        </trans-unit>
        <trans-unit id="e2f29f1c300ba36b21c6a01062d991f47ee83fd6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sync&lt;/code&gt; and &lt;code&gt;Send&lt;/code&gt; traits, which extend Rust&amp;rsquo;s concurrency guarantees to user-defined types as well as types provided by the standard library</source>
          <target state="translated">Los rasgos de &lt;code&gt;Sync&lt;/code&gt; y &lt;code&gt;Send&lt;/code&gt; , que ampl&amp;iacute;an las garant&amp;iacute;as de concurrencia de Rust a los tipos definidos por el usuario, as&amp;iacute; como a los tipos proporcionados por la biblioteca est&amp;aacute;ndar.</target>
        </trans-unit>
        <trans-unit id="546dfd59f5dde2a2d3bad5396a6d76cbe9696aee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sync&lt;/code&gt; marker trait indicates that it is safe for the type implementing &lt;code&gt;Sync&lt;/code&gt; to be referenced from multiple threads. In other words, any type &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt; if &lt;code&gt;&amp;amp;T&lt;/code&gt; (a reference to &lt;code&gt;T&lt;/code&gt;) is &lt;code&gt;Send&lt;/code&gt;, meaning the reference can be sent safely to another thread. Similar to &lt;code&gt;Send&lt;/code&gt;, primitive types are &lt;code&gt;Sync&lt;/code&gt;, and types composed entirely of types that are &lt;code&gt;Sync&lt;/code&gt; are also &lt;code&gt;Sync&lt;/code&gt;.</source>
          <target state="translated">El rasgo del marcador de &lt;code&gt;Sync&lt;/code&gt; indica que es seguro que el tipo que implementa la &lt;code&gt;Sync&lt;/code&gt; sea ​​referenciado desde varios subprocesos. En otras palabras, cualquier tipo &lt;code&gt;T&lt;/code&gt; es &lt;code&gt;Sync&lt;/code&gt; si &lt;code&gt;&amp;amp;T&lt;/code&gt; (una referencia a &lt;code&gt;T&lt;/code&gt; ) es &lt;code&gt;Send&lt;/code&gt; , lo que significa que la referencia se puede enviar de forma segura a otro hilo. Al igual que en &lt;code&gt;Send&lt;/code&gt; , los tipos primitivos son &lt;code&gt;Sync&lt;/code&gt; y los tipos compuestos en su totalidad por tipos que son &lt;code&gt;Sync&lt;/code&gt; tambi&amp;eacute;n son &lt;code&gt;Sync&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="646e9a46a3198e5aae6cea0647712ac157d7125f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;E&lt;/code&gt; are generic type parameters: we&amp;rsquo;ll discuss generics in more detail in Chapter 10. What you need to know right now is that &lt;code&gt;T&lt;/code&gt; represents the type of the value that will be returned in a success case within the &lt;code&gt;Ok&lt;/code&gt; variant, and &lt;code&gt;E&lt;/code&gt; represents the type of the error that will be returned in a failure case within the &lt;code&gt;Err&lt;/code&gt; variant. Because &lt;code&gt;Result&lt;/code&gt; has these generic type parameters, we can use the &lt;code&gt;Result&lt;/code&gt; type and the functions that the standard library has defined on it in many different situations where the successful value and error value we want to return may differ.</source>
          <target state="translated">La &lt;code&gt;T&lt;/code&gt; y &lt;code&gt;E&lt;/code&gt; son par&amp;aacute;metros de tipo gen&amp;eacute;rico: hablaremos de los gen&amp;eacute;ricos en m&amp;aacute;s detalle en el cap&amp;iacute;tulo 10. Lo que hay que saber en este momento es que &lt;code&gt;T&lt;/code&gt; representa el tipo del valor que ser&amp;aacute; devuelto en un caso de &amp;eacute;xito dentro de la &lt;code&gt;Ok&lt;/code&gt; variante, y &lt;code&gt;E&lt;/code&gt; representa el tipo de error que se devolver&amp;aacute; en caso de falla dentro de la variante &lt;code&gt;Err&lt;/code&gt; . Debido a que &lt;code&gt;Result&lt;/code&gt; tiene estos par&amp;aacute;metros de tipo gen&amp;eacute;rico, podemos usar el tipo &lt;code&gt;Result&lt;/code&gt; y las funciones que la biblioteca est&amp;aacute;ndar ha definido en &amp;eacute;l en muchas situaciones diferentes donde el valor exitoso y el valor de error que queremos devolver pueden diferir.</target>
        </trans-unit>
        <trans-unit id="cb756122c49feafba4692e36792c9ec503818ac1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Thread&lt;/code&gt; type</source>
          <target state="translated">El tipo de &lt;code&gt;Thread&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fadb7c71117e778367444a0d18f0442e8249124b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ThreadPool&lt;/code&gt; will create a channel and hold on to the sending side of the channel.</source>
          <target state="translated">El &lt;code&gt;ThreadPool&lt;/code&gt; crear&amp;aacute; un canal y mantenerse en el lado emisor del canal.</target>
        </trans-unit>
        <trans-unit id="e48c39ae08cbb88aef00b305b9017512b2fc007b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UnsafeCell&lt;/code&gt; API itself is technically very simple: &lt;a href=&quot;struct.unsafecell#method.get&quot;&gt;&lt;code&gt;.get()&lt;/code&gt;&lt;/a&gt; gives you a raw pointer &lt;code&gt;*mut T&lt;/code&gt; to its contents. It is up to &lt;em&gt;you&lt;/em&gt; as the abstraction designer to use that raw pointer correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a5cd0207b32d758dbbf9a6159c66155c77acce0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UnsafeCell&lt;/code&gt; API itself is technically very simple: it gives you a raw pointer &lt;code&gt;*mut T&lt;/code&gt; to its contents. It is up to &lt;em&gt;you&lt;/em&gt; as the abstraction designer to use that raw pointer correctly.</source>
          <target state="translated">La API de &lt;code&gt;UnsafeCell&lt;/code&gt; en s&amp;iacute; es t&amp;eacute;cnicamente muy simple: le da un puntero &lt;code&gt;*mut T&lt;/code&gt; sin formato a su contenido. Depende de &lt;em&gt;usted,&lt;/em&gt; como dise&amp;ntilde;ador de abstracci&amp;oacute;n, utilizar correctamente ese puntero sin procesar.</target>
        </trans-unit>
        <trans-unit id="0a41c6aadefabb63fa74ac6fccd4136ec47ca08f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UpperExp&lt;/code&gt; trait should format its output in scientific notation with an upper-case &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">El rasgo &lt;code&gt;UpperExp&lt;/code&gt; debe formatear su salida en notaci&amp;oacute;n cient&amp;iacute;fica con una &lt;code&gt;E&lt;/code&gt; may&amp;uacute;scula .</target>
        </trans-unit>
        <trans-unit id="c532f0150ba601cb070b0fc006c6b873d809aeda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UpperHex&lt;/code&gt; trait should format its output as a number in hexadecimal, with &lt;code&gt;A&lt;/code&gt; through &lt;code&gt;F&lt;/code&gt; in upper case.</source>
          <target state="translated">El rasgo &lt;code&gt;UpperHex&lt;/code&gt; debe formatear su salida como un n&amp;uacute;mero en hexadecimal, con &lt;code&gt;A&lt;/code&gt; a &lt;code&gt;F&lt;/code&gt; en may&amp;uacute;sculas.</target>
        </trans-unit>
        <trans-unit id="1692dc51a2dd0859a66b3a15d1e8df4859265ffa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vec&lt;/code&gt; type allows to access values by index, because it implements the &lt;a href=&quot;../ops/trait.index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt; trait. An example will be more explicit:</source>
          <target state="translated">El tipo &lt;code&gt;Vec&lt;/code&gt; permite acceder a valores por &amp;iacute;ndice, ya que implementa el rasgo &lt;a href=&quot;../ops/trait.index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; &lt;/a&gt; . Un ejemplo ser&amp;aacute; m&amp;aacute;s expl&amp;iacute;cito:</target>
        </trans-unit>
        <trans-unit id="fdf15f1d79f5be8a81ff6d7d469c446ffbe09215" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_&lt;/code&gt; pattern will match any value. By putting it after our other arms, the &lt;code&gt;_&lt;/code&gt; will match all the possible cases that aren&amp;rsquo;t specified before it. The &lt;code&gt;()&lt;/code&gt; is just the unit value, so nothing will happen in the &lt;code&gt;_&lt;/code&gt; case. As a result, we can say that we want to do nothing for all the possible values that we don&amp;rsquo;t list before the &lt;code&gt;_&lt;/code&gt; placeholder.</source>
          <target state="translated">El patr&amp;oacute;n &lt;code&gt;_&lt;/code&gt; coincidir&amp;aacute; con cualquier valor. Al ponerlo despu&amp;eacute;s de nuestros otros brazos, &lt;code&gt;_&lt;/code&gt; coincidir&amp;aacute; con todos los casos posibles que no se hayan especificado antes. El &lt;code&gt;()&lt;/code&gt; es solo el valor unitario, por lo que no suceder&amp;aacute; nada en el caso &lt;code&gt;_&lt;/code&gt; . Como resultado, podemos decir que no queremos hacer nada para todos los valores posibles que no enumeramos antes del marcador de posici&amp;oacute;n &lt;code&gt;_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4f623218e4e907b6db896a6ba8ba2e0737f6051" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;abort&lt;/code&gt; function terminates the process, so the destructor will not get run on the example below:</source>
          <target state="translated">La funci&amp;oacute;n de &lt;code&gt;abort&lt;/code&gt; o finaliza el proceso, por lo que el destructor no se ejecutar&amp;aacute; en el siguiente ejemplo:</target>
        </trans-unit>
        <trans-unit id="1da31d2d7b88dbadae1ea02224cc02bf279c6b4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;add&lt;/code&gt; method adds the &lt;code&gt;x&lt;/code&gt; values of two &lt;code&gt;Point&lt;/code&gt; instances and the &lt;code&gt;y&lt;/code&gt; values of two &lt;code&gt;Point&lt;/code&gt; instances to create a new &lt;code&gt;Point&lt;/code&gt;. The &lt;code&gt;Add&lt;/code&gt; trait has an associated type named &lt;code&gt;Output&lt;/code&gt; that determines the type returned from the &lt;code&gt;add&lt;/code&gt; method.</source>
          <target state="translated">El &lt;code&gt;add&lt;/code&gt; m&amp;eacute;todo agrega los &lt;code&gt;x&lt;/code&gt; valores de dos &lt;code&gt;Point&lt;/code&gt; instancias y las &lt;code&gt;y&lt;/code&gt; valores de dos &lt;code&gt;Point&lt;/code&gt; casos para crear un nuevo &lt;code&gt;Point&lt;/code&gt; . El rasgo &lt;code&gt;Add&lt;/code&gt; tiene un tipo asociado llamado &lt;code&gt;Output&lt;/code&gt; que determina el tipo devuelto por el m&amp;eacute;todo &lt;code&gt;add&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b4f66cfe4d8578da648c05ce2a1d295046eb19d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;add_text&lt;/code&gt; method takes a mutable reference to &lt;code&gt;self&lt;/code&gt;, because we&amp;rsquo;re changing the &lt;code&gt;Post&lt;/code&gt; instance that we&amp;rsquo;re calling &lt;code&gt;add_text&lt;/code&gt; on. We then call &lt;code&gt;push_str&lt;/code&gt; on the &lt;code&gt;String&lt;/code&gt; in &lt;code&gt;content&lt;/code&gt; and pass the &lt;code&gt;text&lt;/code&gt; argument to add to the saved &lt;code&gt;content&lt;/code&gt;. This behavior doesn&amp;rsquo;t depend on the state the post is in, so it&amp;rsquo;s not part of the state pattern. The &lt;code&gt;add_text&lt;/code&gt; method doesn&amp;rsquo;t interact with the &lt;code&gt;state&lt;/code&gt; field at all, but it is part of the behavior we want to support.</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;add_text&lt;/code&gt; toma una referencia mutable a &lt;code&gt;self&lt;/code&gt; , porque estamos cambiando la instancia de &lt;code&gt;Post&lt;/code&gt; en la que llamamos &lt;code&gt;add_text&lt;/code&gt; . Luego llamamos &lt;code&gt;push_str&lt;/code&gt; en la &lt;code&gt;String&lt;/code&gt; en el &lt;code&gt;content&lt;/code&gt; y pasamos el argumento de &lt;code&gt;text&lt;/code&gt; o para agregarlo al &lt;code&gt;content&lt;/code&gt; guardado . Este comportamiento no depende del estado en el que se encuentre la publicaci&amp;oacute;n, por lo que no forma parte del patr&amp;oacute;n de estado. El m&amp;eacute;todo &lt;code&gt;add_text&lt;/code&gt; no interact&amp;uacute;a en absoluto con el campo de &lt;code&gt;state&lt;/code&gt; , pero es parte del comportamiento que queremos apoyar.</target>
        </trans-unit>
        <trans-unit id="2c3ad15ad6826ff34548cd3374a6a4eed3efc204" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; modifiers can be used to respectively raise or lower the alignment of &lt;code&gt;struct&lt;/code&gt;s and &lt;code&gt;union&lt;/code&gt;s. &lt;code&gt;packed&lt;/code&gt; may also alter the padding between fields.</source>
          <target state="translated">Los modificadores de &lt;code&gt;align&lt;/code&gt; y &lt;code&gt;packed&lt;/code&gt; se pueden usar para aumentar o disminuir respectivamente la alineaci&amp;oacute;n de &lt;code&gt;struct&lt;/code&gt; y &lt;code&gt;union&lt;/code&gt; es . &lt;code&gt;packed&lt;/code&gt; tambi&amp;eacute;n puede alterar el relleno entre campos.</target>
        </trans-unit>
        <trans-unit id="0e0634e43790fec0970517f968c2cdaea9942a64" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; modifiers cannot be applied on the same type and a &lt;code&gt;packed&lt;/code&gt; type cannot transitively contain another &lt;code&gt;align&lt;/code&gt;ed type. &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; may only be applied to the &lt;a href=&quot;#the-default-representation&quot;&gt;default&lt;/a&gt; and &lt;a href=&quot;#the-c-representation&quot;&gt;&lt;code&gt;C&lt;/code&gt;&lt;/a&gt; representations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba365c1b081658cee386344e9e2a04962a51bb04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; modifiers cannot be applied on the same type and a &lt;code&gt;packed&lt;/code&gt; type cannot transitively contain another &lt;code&gt;align&lt;/code&gt;ed type. &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; may only be applied to the &lt;a href=&quot;type-layout#the-default-representation&quot;&gt;default&lt;/a&gt; and &lt;a href=&quot;type-layout#the-c-representation&quot;&gt;&lt;code&gt;C&lt;/code&gt;&lt;/a&gt; representations.</source>
          <target state="translated">Los modificadores de &lt;code&gt;align&lt;/code&gt; y &lt;code&gt;packed&lt;/code&gt; no se pueden aplicar al mismo tipo y un tipo &lt;code&gt;packed&lt;/code&gt; no puede contener transitivamente otro tipo de &lt;code&gt;align&lt;/code&gt; . &lt;code&gt;align&lt;/code&gt; y &lt;code&gt;packed&lt;/code&gt; solo se pueden aplicar a las representaciones &lt;a href=&quot;type-layout#the-default-representation&quot;&gt;predeterminadas&lt;/a&gt; y en &lt;a href=&quot;type-layout#the-c-representation&quot;&gt; &lt;code&gt;C&lt;/code&gt; .&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="53e65577e1cfa4684ae0b49bee71e8da03a67fa1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; modifier can also be applied on an &lt;code&gt;enum&lt;/code&gt;. When it is, the effect on the &lt;code&gt;enum&lt;/code&gt;'s alignment is the same as if the &lt;code&gt;enum&lt;/code&gt; was wrapped in a newtype &lt;code&gt;struct&lt;/code&gt; with the same &lt;code&gt;align&lt;/code&gt; modifier.</source>
          <target state="translated">El modificador de &lt;code&gt;align&lt;/code&gt; tambi&amp;eacute;n se puede aplicar en una &lt;code&gt;enum&lt;/code&gt; eraci&amp;oacute;n . Cuando es as&amp;iacute;, el efecto sobre la alineaci&amp;oacute;n de la &lt;code&gt;enum&lt;/code&gt; eraci&amp;oacute;n es el mismo que si la &lt;code&gt;enum&lt;/code&gt; eraci&amp;oacute;n estuviera envuelta en una &lt;code&gt;struct&lt;/code&gt; newtype con el mismo modificador de &lt;code&gt;align&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ad8df46a380899eaf26791f29aae33e2b0b76bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amt&lt;/code&gt; must be &lt;code&gt;&amp;lt;=&lt;/code&gt; the number of bytes in the buffer returned by &lt;a href=&quot;#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El &lt;code&gt;amt&lt;/code&gt; debe ser &lt;code&gt;&amp;lt;=&lt;/code&gt; el n&amp;uacute;mero de bytes en el b&amp;uacute;fer devuelto por &lt;a href=&quot;#tymethod.fill_buf&quot;&gt; &lt;code&gt;fill_buf&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6cdd430203e5d1bc8171135295b8e6a12c3f9ccb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amt&lt;/code&gt; must be &lt;code&gt;&amp;lt;=&lt;/code&gt; the number of bytes in the buffer returned by &lt;a href=&quot;trait.bufread#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45b714d09b6da61ea117e3601d5d1e5fd89a8774" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;approve&lt;/code&gt; method will be similar to the &lt;code&gt;request_review&lt;/code&gt; method: it will set &lt;code&gt;state&lt;/code&gt; to the value that the current state says it should have when that state is approved, as shown in Listing 17-16:</source>
          <target state="translated">El m&amp;eacute;todo de &lt;code&gt;approve&lt;/code&gt; ser&amp;aacute; similar al m&amp;eacute;todo &lt;code&gt;request_review&lt;/code&gt; : establecer&amp;aacute; el &lt;code&gt;state&lt;/code&gt; en el valor que el estado actual dice que deber&amp;iacute;a tener cuando se apruebe ese estado, como se muestra en el Listado 17-16:</target>
        </trans-unit>
        <trans-unit id="0d99e2697c98f4ee00d53c8602d75f85424ebe1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;area&lt;/code&gt; function accesses the &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; fields of the &lt;code&gt;Rectangle&lt;/code&gt; instance. Our function signature for &lt;code&gt;area&lt;/code&gt; now says exactly what we mean: calculate the area of &lt;code&gt;Rectangle&lt;/code&gt;, using its &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; fields. This conveys that the width and height are related to each other, and it gives descriptive names to the values rather than using the tuple index values of &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;. This is a win for clarity.</source>
          <target state="translated">La funci&amp;oacute;n de &lt;code&gt;area&lt;/code&gt; accede a los campos de &lt;code&gt;width&lt;/code&gt; y &lt;code&gt;height&lt;/code&gt; de la instancia de &lt;code&gt;Rectangle&lt;/code&gt; . Nuestra firma de funci&amp;oacute;n para el &lt;code&gt;area&lt;/code&gt; ahora dice exactamente lo que queremos decir: calcular el &amp;aacute;rea de &lt;code&gt;Rectangle&lt;/code&gt; , usando sus campos de &lt;code&gt;width&lt;/code&gt; y &lt;code&gt;height&lt;/code&gt; . Esto transmite que el ancho y el alto est&amp;aacute;n relacionados entre s&amp;iacute;, y da nombres descriptivos a los valores en lugar de utilizar los valores de &amp;iacute;ndice de tupla de &lt;code&gt;0&lt;/code&gt; y &lt;code&gt;1&lt;/code&gt; . Esta es una victoria por claridad.</target>
        </trans-unit>
        <trans-unit id="f0f4d5c245d843fc107cb0d995f1cc0cbaafe380" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;area&lt;/code&gt; function is supposed to calculate the area of one rectangle, but the function we wrote has two parameters. The parameters are related, but that&amp;rsquo;s not expressed anywhere in our program. It would be more readable and more manageable to group width and height together. We&amp;rsquo;ve already discussed one way we might do that in &lt;a href=&quot;ch03-02-data-types#the-tuple-type&quot;&gt;&amp;ldquo;The Tuple Type&amp;rdquo;&lt;/a&gt; section of Chapter 3: by using tuples.</source>
          <target state="translated">El &lt;code&gt;area&lt;/code&gt; funci&amp;oacute;n debe calcular el &amp;aacute;rea de un rect&amp;aacute;ngulo, pero la funci&amp;oacute;n que escribimos tiene dos par&amp;aacute;metros. Los par&amp;aacute;metros est&amp;aacute;n relacionados, pero eso no se expresa en ninguna parte de nuestro programa. Ser&amp;iacute;a m&amp;aacute;s legible y manejable agrupar el ancho y el alto. Ya hemos discutido una forma en que podr&amp;iacute;amos hacer eso en la secci&amp;oacute;n &lt;a href=&quot;ch03-02-data-types#the-tuple-type&quot;&gt;&quot;El tipo de tupla&quot;&lt;/a&gt; del Cap&amp;iacute;tulo 3: usando tuplas.</target>
        </trans-unit>
        <trans-unit id="03663b761515431ad66c10f38033078682c6e595" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;art&lt;/code&gt; crate users can still see and use the internal structure from Listing 14-3 as demonstrated in Listing 14-4, or they can use the more convenient structure in Listing 14-5, as shown in Listing 14-6:</source>
          <target state="translated">Los usuarios de cajas de &lt;code&gt;art&lt;/code&gt; e a&amp;uacute;n pueden ver y usar la estructura interna del Listado 14-3 como se muestra en el Listado 14-4, o pueden usar la estructura m&amp;aacute;s conveniente en el Listado 14-5, como se muestra en el Listado 14-6:</target>
        </trans-unit>
        <trans-unit id="e825da57c4a60047ea61533b7c1bd5bca8251591" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as&lt;/code&gt; keyword can be used to change what the crate is referred to as in your project. If a crate name includes a dash, it is implicitly imported with the dashes replaced by underscores.</source>
          <target state="translated">La palabra clave &lt;code&gt;as&lt;/code&gt; se puede utilizar para cambiar el nombre de la caja en su proyecto. Si un nombre de caja incluye un gui&amp;oacute;n, se importa impl&amp;iacute;citamente y los guiones se reemplazan por guiones bajos.</target>
        </trans-unit>
        <trans-unit id="2dd2463e89570fe4f3bb6f6203a6c56b03267f94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;assert!&lt;/code&gt; macro, provided by the standard library, is useful when you want to ensure that some condition in a test evaluates to &lt;code&gt;true&lt;/code&gt;. We give the &lt;code&gt;assert!&lt;/code&gt; macro an argument that evaluates to a Boolean. If the value is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;assert!&lt;/code&gt; does nothing and the test passes. If the value is &lt;code&gt;false&lt;/code&gt;, the &lt;code&gt;assert!&lt;/code&gt; macro calls the &lt;code&gt;panic!&lt;/code&gt; macro, which causes the test to fail. Using the &lt;code&gt;assert!&lt;/code&gt; macro helps us check that our code is functioning in the way we intend.</source>
          <target state="translated">&amp;iexcl;La &lt;code&gt;assert!&lt;/code&gt; La macro, proporcionada por la biblioteca est&amp;aacute;ndar, es &amp;uacute;til cuando desea asegurarse de que alguna condici&amp;oacute;n en una prueba se eval&amp;uacute;e como &lt;code&gt;true&lt;/code&gt; . &amp;iexcl;Damos el &lt;code&gt;assert!&lt;/code&gt; macro un argumento que se eval&amp;uacute;a como un booleano. Si el valor es &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;assert!&lt;/code&gt; no hace nada y pasa la prueba. Si el valor es &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;assert!&lt;/code&gt; macro llama al &lt;code&gt;panic!&lt;/code&gt; macro, que hace que la prueba falle. &amp;iexcl;Usando la &lt;code&gt;assert!&lt;/code&gt; macro nos ayuda a comprobar que nuestro c&amp;oacute;digo funciona de la manera que pretendemos.</target>
        </trans-unit>
        <trans-unit id="95f1355f51c209910ea66191ec2fc57f92344bfc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;assert_ne!&lt;/code&gt; macro will pass if the two values we give it are not equal and fail if they&amp;rsquo;re equal. This macro is most useful for cases when we&amp;rsquo;re not sure what a value &lt;em&gt;will&lt;/em&gt; be, but we know what the value definitely &lt;em&gt;won&amp;rsquo;t&lt;/em&gt; be if our code is functioning as we intend. For example, if we&amp;rsquo;re testing a function that is guaranteed to change its input in some way, but the way in which the input is changed depends on the day of the week that we run our tests, the best thing to assert might be that the output of the function is not equal to the input.</source>
          <target state="translated">El &lt;code&gt;assert_ne!&lt;/code&gt; La macro pasar&amp;aacute; si los dos valores que le damos no son iguales y fallar&amp;aacute;n si son iguales. Esta macro es m&amp;aacute;s &amp;uacute;til para los casos en los que no estamos seguros de cu&amp;aacute;l &lt;em&gt;ser&amp;aacute;&lt;/em&gt; un valor , pero sabemos cu&amp;aacute;l &lt;em&gt;ser&amp;aacute;&lt;/em&gt; el valor definitivamente si nuestro c&amp;oacute;digo funciona como pretendemos. Por ejemplo, si estamos probando una funci&amp;oacute;n que est&amp;aacute; garantizada para cambiar su entrada de alguna manera, pero la forma en que se cambia la entrada depende del d&amp;iacute;a de la semana en que ejecutamos nuestras pruebas, lo mejor para afirmar podr&amp;iacute;a ser que la salida de la funci&amp;oacute;n no es igual a la entrada.</target>
        </trans-unit>
        <trans-unit id="bf35e012d7004404479ddec49cb6abc4ee90bc1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bind&lt;/code&gt; function in this scenario works like the &lt;code&gt;new&lt;/code&gt; function in that it will return a new &lt;code&gt;TcpListener&lt;/code&gt; instance. The reason the function is called &lt;code&gt;bind&lt;/code&gt; is that in networking, connecting to a port to listen to is known as &amp;ldquo;binding to a port.&amp;rdquo;</source>
          <target state="translated">La funci&amp;oacute;n de &lt;code&gt;bind&lt;/code&gt; en este escenario funciona como la &lt;code&gt;new&lt;/code&gt; funci&amp;oacute;n en el sentido de que devolver&amp;aacute; una nueva instancia de &lt;code&gt;TcpListener&lt;/code&gt; . La raz&amp;oacute;n por la que la funci&amp;oacute;n se llama &lt;code&gt;bind&lt;/code&gt; es que en las redes, conectarse a un puerto para escuchar se conoce como &quot;vinculaci&amp;oacute;n a un puerto&quot;.</target>
        </trans-unit>
        <trans-unit id="3a9db4154e7cfc914c7af74a70f78787dc149e27" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bind&lt;/code&gt; function returns a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;, which indicates that binding might fail. For example, connecting to port 80 requires administrator privileges (nonadministrators can listen only on ports higher than 1024), so if we tried to connect to port 80 without being an administrator, binding wouldn&amp;rsquo;t work. As another example, binding wouldn&amp;rsquo;t work if we ran two instances of our program and so had two programs listening to the same port. Because we&amp;rsquo;re writing a basic server just for learning purposes, we won&amp;rsquo;t worry about handling these kinds of errors; instead, we use &lt;code&gt;unwrap&lt;/code&gt; to stop the program if errors happen.</source>
          <target state="translated">El &lt;code&gt;bind&lt;/code&gt; funci&amp;oacute;n devuelve un &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; , lo que indica que la uni&amp;oacute;n puede fallar. Por ejemplo, conectarse al puerto 80 requiere privilegios de administrador (los no administradores pueden escuchar solo en puertos superiores a 1024), por lo que si intent&amp;aacute;ramos conectarnos al puerto 80 sin ser un administrador, la vinculaci&amp;oacute;n no funcionar&amp;iacute;a. Como otro ejemplo, el enlace no funcionar&amp;iacute;a si ejecut&amp;aacute;ramos dos instancias de nuestro programa y, por lo tanto, tuvi&amp;eacute;ramos dos programas escuchando el mismo puerto. Debido a que estamos escribiendo un servidor b&amp;aacute;sico solo con fines de aprendizaje, no nos preocuparemos por manejar este tipo de errores; en su lugar, usamos &lt;code&gt;unwrap&lt;/code&gt; para detener el programa si ocurren errores.</target>
        </trans-unit>
        <trans-unit id="86e869ec27553a2645d530ee9b57e980ad085326" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bool&lt;/code&gt; represents a value, which could only be either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. If you cast a &lt;code&gt;bool&lt;/code&gt; into an integer, &lt;code&gt;true&lt;/code&gt; will be 1 and &lt;code&gt;false&lt;/code&gt; will be 0.</source>
          <target state="translated">El &lt;code&gt;bool&lt;/code&gt; representa un valor, que solo puede ser &lt;code&gt;true&lt;/code&gt; o &lt;code&gt;false&lt;/code&gt; . Si convierte un &lt;code&gt;bool&lt;/code&gt; en un n&amp;uacute;mero entero, &lt;code&gt;true&lt;/code&gt; ser&amp;aacute; 1 y &lt;code&gt;false&lt;/code&gt; ser&amp;aacute; 0.</target>
        </trans-unit>
        <trans-unit id="d4311662fb8a13303491e364af26bcbe8200bef8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bool&lt;/code&gt; type is a datatype which can be either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. The boolean type uses one byte of memory. It is used in comparisons and bitwise operations like &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, and &lt;code&gt;!&lt;/code&gt;.</source>
          <target state="translated">El tipo &lt;code&gt;bool&lt;/code&gt; es un tipo de datos que puede ser &lt;code&gt;true&lt;/code&gt; o &lt;code&gt;false&lt;/code&gt; . El tipo booleano usa un byte de memoria. Se utiliza en comparaciones y operaciones bit a bit como &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; y &lt;code&gt;!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="71b45beaeed4f4e8bb8cb42d1eee7255c7dfda23" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;break&lt;/code&gt; statement can take an argument (which will be the value of the loop expression if the &lt;code&gt;break&lt;/code&gt; statement is executed) in &lt;code&gt;loop&lt;/code&gt; loops, but not &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, or &lt;code&gt;while let&lt;/code&gt; loops.</source>
          <target state="translated">La instrucci&amp;oacute;n &lt;code&gt;break&lt;/code&gt; puede tomar un argumento (que ser&amp;aacute; el valor de la expresi&amp;oacute;n de bucle si se ejecuta la instrucci&amp;oacute;n &lt;code&gt;break&lt;/code&gt; ) en bucles de &lt;code&gt;loop&lt;/code&gt; , pero no &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; o &lt;code&gt;while let&lt;/code&gt; bucles.</target>
        </trans-unit>
        <trans-unit id="d4fc4821431bbe2f5d7ca950ef58b031fb001379" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bytes&lt;/code&gt; method returns each raw byte, which might be appropriate for your domain:</source>
          <target state="translated">El m&amp;eacute;todo de &lt;code&gt;bytes&lt;/code&gt; devuelve cada byte sin procesar, que podr&amp;iacute;a ser apropiado para su dominio:</target>
        </trans-unit>
        <trans-unit id="0c67d48bb9bf16df95a3dc50a92dbdfe313c2a09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;can_hold&lt;/code&gt; method returns a Boolean, which means it&amp;rsquo;s a perfect use case for the &lt;code&gt;assert!&lt;/code&gt; macro. In Listing 11-6, we write a test that exercises the &lt;code&gt;can_hold&lt;/code&gt; method by creating a &lt;code&gt;Rectangle&lt;/code&gt; instance that has a width of 8 and a height of 7 and asserting that it can hold another &lt;code&gt;Rectangle&lt;/code&gt; instance that has a width of 5 and a height of 1.</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;can_hold&lt;/code&gt; devuelve un booleano, lo que significa que es un caso de uso perfecto para la &lt;code&gt;assert!&lt;/code&gt; macro. En el Listado 11-6, escribimos una prueba que ejercita el m&amp;eacute;todo &lt;code&gt;can_hold&lt;/code&gt; creando una instancia de &lt;code&gt;Rectangle&lt;/code&gt; que tiene un ancho de 8 y una altura de 7 y afirmando que puede contener otra instancia de &lt;code&gt;Rectangle&lt;/code&gt; que tiene un ancho de 5 y una altura de 1.</target>
        </trans-unit>
        <trans-unit id="5a25b55443c783de850a8f716e7e98dd68745de2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cargo install&lt;/code&gt; command allows you to install and use binary crates locally. This isn&amp;rsquo;t intended to replace system packages; it&amp;rsquo;s meant to be a convenient way for Rust developers to install tools that others have shared on &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;. Note that you can only install packages that have binary targets. A &lt;em&gt;binary target&lt;/em&gt; is the runnable program that is created if the crate has a &lt;em&gt;src/main.rs&lt;/em&gt; file or another file specified as a binary, as opposed to a library target that isn&amp;rsquo;t runnable on its own but is suitable for including within other programs. Usually, crates have information in the &lt;em&gt;README&lt;/em&gt; file about whether a crate is a library, has a binary target, or both.</source>
          <target state="translated">El comando de &lt;code&gt;cargo install&lt;/code&gt; permite instalar y usar cajas binarias localmente. Esto no pretende reemplazar los paquetes del sistema; est&amp;aacute; destinado a ser una forma conveniente para que los desarrolladores de Rust instalen herramientas que otros han compartido en &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; . Tenga en cuenta que solo puede instalar paquetes que tengan destinos binarios. Un &lt;em&gt;destino binario&lt;/em&gt; es el programa ejecutable que se crea si la caja tiene un archivo &lt;em&gt;src / main.rs&lt;/em&gt; u otro archivo especificado como binario, a diferencia de un destino de biblioteca que no se puede ejecutar por s&amp;iacute; solo pero es adecuado para incluirlo en otros programas. Por lo general, las cajas tienen informaci&amp;oacute;n en el archivo &lt;em&gt;README&lt;/em&gt; sobre si una caja es una biblioteca, tiene un objetivo binario o ambos.</target>
        </trans-unit>
        <trans-unit id="2664dcbe5273c6722a5b153d876b9b792f2ada2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cargo test&lt;/code&gt; command runs all tests in our project, as shown in Listing 11-2.</source>
          <target state="translated">El comando de &lt;code&gt;cargo test&lt;/code&gt; ejecuta todas las pruebas en nuestro proyecto, como se muestra en el Listado 11-2.</target>
        </trans-unit>
        <trans-unit id="375baaee400dee61b2707b887bd9af56fe2bc128" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;cfg&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c6c79dbe0366f164760e8fbd149ca95e0429eec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt; attribute is allowed anywhere attributes are allowed.</source>
          <target state="translated">El atributo &lt;code&gt;cfg&lt;/code&gt; est&amp;aacute; permitido en cualquier lugar donde se permitan atributos.</target>
        </trans-unit>
        <trans-unit id="c1be4a466f7709a98c138b8664fae5693d56dd2b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt; attribute supports only three kinds of predicates:</source>
          <target state="translated">El atributo &lt;code&gt;cfg&lt;/code&gt; admite solo tres tipos de predicados:</target>
        </trans-unit>
        <trans-unit id="28422790bd7081a79bb025fb9d66e378219a525d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt; macro</source>
          <target state="translated">La macro &lt;code&gt;cfg&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fde18a15c12045ccc5f862ad4d07ffff9bb790a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; conditionally includes the thing it is attached to based on a configuration predicate.</source>
          <target state="translated">El &lt;a href=&quot;attributes&quot;&gt;atributo &lt;/a&gt; &lt;code&gt;cfg&lt;/code&gt; incluye condicionalmente el elemento al que est&amp;aacute; asociado en funci&amp;oacute;n de un predicado de configuraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="2223835f7d8034d74bbb5846af6ec97de49a67f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg_attr&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;cfg_attr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76546526e7489be649c0d74ada78ee80e5e85965" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg_attr&lt;/code&gt; attribute is allowed anywhere attributes are allowed.</source>
          <target state="translated">El atributo &lt;code&gt;cfg_attr&lt;/code&gt; est&amp;aacute; permitido en cualquier lugar donde se permitan atributos.</target>
        </trans-unit>
        <trans-unit id="548a83f876de36acae9e81967a808fe451cf7938" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg_attr&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; conditionally includes &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt; based on a configuration predicate.</source>
          <target state="translated">El &lt;a href=&quot;attributes&quot;&gt;atributo &lt;/a&gt; &lt;code&gt;cfg_attr&lt;/code&gt; incluye condicionalmente &lt;a href=&quot;attributes&quot;&gt;atributos&lt;/a&gt; basados ​​en un predicado de configuraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="85a19bbf37eb56f0525c8c2436505adedd691250" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;char&lt;/code&gt; type represents a single character. More specifically, since 'character' isn't a well-defined concept in Unicode, &lt;code&gt;char&lt;/code&gt; is a '&lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt;', which is similar to, but not the same as, a '&lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;Unicode code point&lt;/a&gt;'.</source>
          <target state="translated">El tipo &lt;code&gt;char&lt;/code&gt; representa un solo car&amp;aacute;cter. M&amp;aacute;s espec&amp;iacute;ficamente, dado que 'car&amp;aacute;cter' no es un concepto bien definido en Unicode, &lt;code&gt;char&lt;/code&gt; es un ' &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;valor escalar Unicode&lt;/a&gt; ', que es similar, pero no lo mismo, a un ' &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;punto de c&amp;oacute;digo Unicode&lt;/a&gt; '.</target>
        </trans-unit>
        <trans-unit id="b73bedd4705331ddde92b218ee42ae14fd783b1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cold&lt;/code&gt; and &lt;code&gt;inline&lt;/code&gt;&lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; give suggestions to generate code in a way that may be faster than what it would do without the hint. The attributes are only hints, and may be ignored.</source>
          <target state="translated">Los &lt;a href=&quot;../attributes&quot;&gt;atributos &lt;/a&gt; &lt;code&gt;cold&lt;/code&gt; e &lt;code&gt;inline&lt;/code&gt; brindan sugerencias para generar c&amp;oacute;digo de una manera que puede ser m&amp;aacute;s r&amp;aacute;pida de lo que har&amp;iacute;a sin la pista. Los atributos son solo sugerencias y pueden ignorarse.</target>
        </trans-unit>
        <trans-unit id="5e443e8933fc7022a9fff52a5391c70d8fc736a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cold&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;cold&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f187d03d0870d5f7cf8d911158a2ad4bf8bfb1f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;const&lt;/code&gt; keyword is also used in raw pointers in combination with &lt;code&gt;mut&lt;/code&gt;, as seen in &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt;. More about &lt;code&gt;const&lt;/code&gt; as used in raw pointers can be read at the Rust docs for the &lt;a href=&quot;primitive.pointer&quot;&gt;pointer primitive&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c647cbb39e778e9b3fee3b9f221a846f5e10198a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;const&lt;/code&gt; keyword is also used in raw pointers in combination with &lt;code&gt;mut&lt;/code&gt;, as seen in &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt;. More about that can be read at the &lt;a href=&quot;primitive.pointer&quot;&gt;pointer&lt;/a&gt; primitive part of the Rust docs.</source>
          <target state="translated">La &lt;code&gt;const&lt;/code&gt; palabra clave se utiliza tambi&amp;eacute;n en punteros primas en combinaci&amp;oacute;n con &lt;code&gt;mut&lt;/code&gt; , como se ve en &lt;code&gt;*const T&lt;/code&gt; y &lt;code&gt;*mut T&lt;/code&gt; . Se puede leer m&amp;aacute;s sobre eso en la parte primitiva del &lt;a href=&quot;primitive.pointer&quot;&gt;puntero&lt;/a&gt; de los documentos de Rust.</target>
        </trans-unit>
        <trans-unit id="90ef70a34f1bf7aa0febc79627f67bbce0e1d9d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;core&lt;/code&gt; crate is always added to the extern prelude. The &lt;code&gt;std&lt;/code&gt; crate is added as long as the &lt;a href=&quot;../crates-and-source-files#preludes-and-no_std&quot;&gt;&lt;code&gt;no_std&lt;/code&gt;&lt;/a&gt; attribute is not specified in the crate root.</source>
          <target state="translated">La caja del &lt;code&gt;core&lt;/code&gt; siempre se agrega al preludio externo. El &lt;code&gt;std&lt;/code&gt; caj&amp;oacute;n se a&amp;ntilde;ade siempre y cuando el &lt;a href=&quot;../crates-and-source-files#preludes-and-no_std&quot;&gt; &lt;code&gt;no_std&lt;/code&gt; &lt;/a&gt; atributo no se especifica en la ra&amp;iacute;z del caj&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="38acae0d6ab176e191a45e1f1b54faccd4c7f448" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crate_name&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;crate_name&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ef2c8badee302cb0baefa21db745a07eb79b3acf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; pointer can be used to store arbitrary data as required by the executor. This could be e.g. a type-erased pointer to an &lt;code&gt;Arc&lt;/code&gt; that is associated with the task. The value of this poiner will get passed to all functions that are part of the &lt;code&gt;vtable&lt;/code&gt; as the first parameter.</source>
          <target state="translated">El puntero de &lt;code&gt;data&lt;/code&gt; se puede utilizar para almacenar datos arbitrarios seg&amp;uacute;n lo requiera el ejecutor. Esto podr&amp;iacute;a ser, por ejemplo, un puntero borrado a un &lt;code&gt;Arc&lt;/code&gt; que est&amp;aacute; asociado con la tarea. El valor de este puntero se pasar&amp;aacute; a todas las funciones que forman parte de &lt;code&gt;vtable&lt;/code&gt; como primer par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="9e90fa7bb07af3f80ba061dbc0af88db5a79ba76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; pointer can be used to store arbitrary data as required by the executor. This could be e.g. a type-erased pointer to an &lt;code&gt;Arc&lt;/code&gt; that is associated with the task. The value of this pointer will get passed to all functions that are part of the &lt;code&gt;vtable&lt;/code&gt; as the first parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7af61314557c2255ce30f13387bf574343b8476" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dbg!(..)&lt;/code&gt; macro moves the input:</source>
          <target state="translated">La macro &lt;code&gt;dbg!(..)&lt;/code&gt; mueve la entrada:</target>
        </trans-unit>
        <trans-unit id="b7a4dd4c094bb75a82ed633489f0ec96c82a6296" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dbg!&lt;/code&gt; macro works exactly the same in release builds. This is useful when debugging issues that only occur in release builds or when debugging in release mode is significantly faster.</source>
          <target state="translated">El &lt;code&gt;dbg!&lt;/code&gt; La macro funciona exactamente igual en las versiones de lanzamiento. Esto es &amp;uacute;til cuando se depuran problemas que solo ocurren en compilaciones de lanzamiento o cuando la depuraci&amp;oacute;n en modo de lanzamiento es significativamente m&amp;aacute;s r&amp;aacute;pida.</target>
        </trans-unit>
        <trans-unit id="5a03c825d089a243f66f60fd9869adfb4b5c6857" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;deprecated&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8b0ffc1f78b8eb9694b4e7509ecdd919acc0c0cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute can only be present &lt;strong&gt;once&lt;/strong&gt; on an item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c348bd3f38f8d7b286030ed2d1f972d4a02706b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute has several forms:</source>
          <target state="translated">El atributo &lt;code&gt;deprecated&lt;/code&gt; tiene varias formas:</target>
        </trans-unit>
        <trans-unit id="44c311ce3d12b2d5a8a0632c6cd020f999b4ee16" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute may be applied to any &lt;a href=&quot;../items&quot;&gt;item&lt;/a&gt;, &lt;a href=&quot;../items/traits&quot;&gt;trait item&lt;/a&gt;, &lt;a href=&quot;../items/enumerations&quot;&gt;enum variant&lt;/a&gt;, &lt;a href=&quot;../items/structs&quot;&gt;struct field&lt;/a&gt;, &lt;a href=&quot;../items/external-blocks&quot;&gt;external block item&lt;/a&gt;, or &lt;a href=&quot;../macros-by-example&quot;&gt;macro definition&lt;/a&gt;. It cannot be applied to &lt;a href=&quot;../items/implementations#trait-implementations&quot;&gt;trait implementation items&lt;/a&gt;. When applied to an item containing other items, such as a &lt;a href=&quot;../items/modules&quot;&gt;module&lt;/a&gt; or &lt;a href=&quot;../items/implementations&quot;&gt;implementation&lt;/a&gt;, all child items inherit the deprecation attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1d23eb4050e4bb4bd6008dd3e0216cd81ba2cd1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute may be applied to any &lt;a href=&quot;../items&quot;&gt;item&lt;/a&gt;, &lt;a href=&quot;../items/traits&quot;&gt;trait item&lt;/a&gt;, &lt;a href=&quot;../items/enumerations&quot;&gt;enum variant&lt;/a&gt;, &lt;a href=&quot;../items/structs&quot;&gt;struct field&lt;/a&gt;, or &lt;a href=&quot;../items/external-blocks&quot;&gt;external block item&lt;/a&gt;. It cannot be applied to &lt;a href=&quot;../items/implementations#trait-implementations&quot;&gt;trait implementation items&lt;/a&gt;. When applied to an item containing other items, such as a &lt;a href=&quot;../items/modules&quot;&gt;module&lt;/a&gt; or &lt;a href=&quot;../items/implementations&quot;&gt;implementation&lt;/a&gt;, all child items inherit the deprecation attribute.</source>
          <target state="translated">El atributo &lt;code&gt;deprecated&lt;/code&gt; se puede aplicar a cualquier &lt;a href=&quot;../items&quot;&gt;elemento&lt;/a&gt; , elemento de &lt;a href=&quot;../items/traits&quot;&gt;rasgo&lt;/a&gt; , &lt;a href=&quot;../items/enumerations&quot;&gt;variante de enumeraci&amp;oacute;n&lt;/a&gt; , &lt;a href=&quot;../items/structs&quot;&gt;campo de estructura&lt;/a&gt; o &lt;a href=&quot;../items/external-blocks&quot;&gt;elemento de bloque externo&lt;/a&gt; . No se puede aplicar a &lt;a href=&quot;../items/implementations#trait-implementations&quot;&gt;elementos de implementaci&amp;oacute;n de rasgos&lt;/a&gt; . Cuando se aplica a un elemento que contiene otros elementos, como un &lt;a href=&quot;../items/modules&quot;&gt;m&amp;oacute;dulo&lt;/a&gt; o una &lt;a href=&quot;../items/implementations&quot;&gt;implementaci&amp;oacute;n&lt;/a&gt; , todos los elementos secundarios heredan el atributo de obsolescencia.</target>
        </trans-unit>
        <trans-unit id="6e7f4030e080734f98683be5c8344d101d0992db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dev&lt;/code&gt; and &lt;code&gt;release&lt;/code&gt; shown in this build output indicate that the compiler is using different profiles.</source>
          <target state="translated">El &lt;code&gt;dev&lt;/code&gt; y &lt;code&gt;release&lt;/code&gt; se muestra en esta salida acumulaci&amp;oacute;n indican que el compilador est&amp;aacute; utilizando diferentes perfiles.</target>
        </trans-unit>
        <trans-unit id="2bcbec4aff44a7472a393bc8eca9c7c00034401d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;drop&lt;/code&gt; method is called when &lt;code&gt;_x&lt;/code&gt; goes out of scope, and therefore &lt;code&gt;main&lt;/code&gt; prints &lt;code&gt;Dropping!&lt;/code&gt;.</source>
          <target state="translated">El m&amp;eacute;todo de &lt;code&gt;drop&lt;/code&gt; se llama cuando &lt;code&gt;_x&lt;/code&gt; sale del alcance y, por lo tanto, las impresiones &lt;code&gt;main&lt;/code&gt; &lt;code&gt;Dropping!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa3edbdb8ad85c4d37e55b2e809f2f18d6f4e045" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a directory symbolic link pointing to the &lt;code&gt;src&lt;/code&gt; path.</source>
          <target state="translated">La ruta &lt;code&gt;dst&lt;/code&gt; ser&amp;aacute; un enlace simb&amp;oacute;lico de directorio que apunta a la ruta &lt;code&gt;src&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8ab040b8a001ca82f66534b2d20a3b8892fd2dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a file symbolic link pointing to the &lt;code&gt;src&lt;/code&gt; path.</source>
          <target state="translated">La ruta &lt;code&gt;dst&lt;/code&gt; ser&amp;aacute; un enlace simb&amp;oacute;lico de archivo que apunta a la ruta &lt;code&gt;src&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0ecd1a2ccd0de8765e1ce7cbb8fab53800f6ce6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a link pointing to the &lt;code&gt;src&lt;/code&gt; path. Note that systems often require these two paths to both be located on the same filesystem.</source>
          <target state="translated">La ruta &lt;code&gt;dst&lt;/code&gt; ser&amp;aacute; un enlace que apunta a la ruta &lt;code&gt;src&lt;/code&gt; . Tenga en cuenta que los sistemas a menudo requieren que estas dos rutas est&amp;eacute;n ubicadas en el mismo sistema de archivos.</target>
        </trans-unit>
        <trans-unit id="b0f3651131fc6e4c0e98108eb60e32485bb1899b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a symbolic link pointing to the &lt;code&gt;src&lt;/code&gt; path.</source>
          <target state="translated">La ruta &lt;code&gt;dst&lt;/code&gt; ser&amp;aacute; un enlace simb&amp;oacute;lico que apunta a la ruta &lt;code&gt;src&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c07e52fcb5c94a3c499bbc6e95804ccd5a8bfc6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a symbolic link pointing to the &lt;code&gt;src&lt;/code&gt; path. On Windows, this will be a file symlink, not a directory symlink; for this reason, the platform-specific &lt;a href=&quot;../os/unix/fs/fn.symlink&quot;&gt;&lt;code&gt;std::os::unix::fs::symlink&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../os/windows/fs/fn.symlink_file&quot;&gt;&lt;code&gt;std::os::windows::fs::symlink_file&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../os/windows/fs/fn.symlink_dir&quot;&gt;&lt;code&gt;symlink_dir&lt;/code&gt;&lt;/a&gt; should be used instead to make the intent explicit.</source>
          <target state="translated">La ruta &lt;code&gt;dst&lt;/code&gt; ser&amp;aacute; un enlace simb&amp;oacute;lico que apunta a la ruta &lt;code&gt;src&lt;/code&gt; . En Windows, ser&amp;aacute; un enlace simb&amp;oacute;lico de archivo, no un enlace simb&amp;oacute;lico de directorio; por esta raz&amp;oacute;n, el &lt;a href=&quot;../os/unix/fs/fn.symlink&quot;&gt; &lt;code&gt;std::os::unix::fs::symlink&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../os/windows/fs/fn.symlink_file&quot;&gt; &lt;code&gt;std::os::windows::fs::symlink_file&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;../os/windows/fs/fn.symlink_dir&quot;&gt; &lt;code&gt;symlink_dir&lt;/code&gt; &lt;/a&gt;espec&amp;iacute;ficos de la plataforma deben usarse en su lugar para hacer expl&amp;iacute;cita la intenci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="fce5aa6e4c6fe0d2a117a0ec0a2f7f52bfd2748e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dyn&lt;/code&gt; keyword is used to highlight that calls to methods on the associated &lt;code&gt;Trait&lt;/code&gt; are dynamically dispatched. To use the trait this way, it must be 'object safe'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f31eeeb70d8a71f4b93bd89156c38bf0e5709ff2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;edition&lt;/code&gt; key in &lt;em&gt;Cargo.toml&lt;/em&gt; indicates which edition the compiler should use for your code. If the key doesn&amp;rsquo;t exist, Rust uses &lt;code&gt;2015&lt;/code&gt; as the edition value for backward compatibility reasons.</source>
          <target state="translated">La clave de &lt;code&gt;edition&lt;/code&gt; en &lt;em&gt;Cargo.toml&lt;/em&gt; indica qu&amp;eacute; edici&amp;oacute;n debe usar el compilador para su c&amp;oacute;digo. Si la clave no existe, Rust usa &lt;code&gt;2015&lt;/code&gt; como valor de edici&amp;oacute;n por razones de compatibilidad con versiones anteriores.</target>
        </trans-unit>
        <trans-unit id="d4302d0f2edafc20c30c1bca4c608a973532a107" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;else&lt;/code&gt; block of an &lt;code&gt;if&lt;/code&gt; expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25d57c60dcf697c3f5bb61f1ff343393baeeb72f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;entry&lt;/code&gt; API is intended to provide an efficient mechanism for manipulating the contents of a map conditionally on the presence of a key or not. The primary motivating use case for this is to provide efficient accumulator maps. For instance, if one wishes to maintain a count of the number of times each key has been seen, they will have to perform some conditional logic on whether this is the first time the key has been seen or not. Normally, this would require a &lt;code&gt;find&lt;/code&gt; followed by an &lt;code&gt;insert&lt;/code&gt;, effectively duplicating the search effort on each insertion.</source>
          <target state="translated">La API de &lt;code&gt;entry&lt;/code&gt; est&amp;aacute; destinada a proporcionar un mecanismo eficiente para manipular el contenido de un mapa condicionalmente en la presencia de una clave o no. El principal caso de uso motivador para esto es proporcionar mapas acumuladores eficientes. Por ejemplo, si uno desea mantener un recuento del n&amp;uacute;mero de veces que se ha visto cada clave, tendr&amp;aacute; que realizar alguna l&amp;oacute;gica condicional sobre si esta es la primera vez que se ha visto la clave o no. Normalmente, esto requerir&amp;iacute;a una &lt;code&gt;find&lt;/code&gt; seguida de una &lt;code&gt;insert&lt;/code&gt; , duplicando efectivamente el esfuerzo de b&amp;uacute;squeda en cada inserci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f625c5b9aa8efa15984a630e2609a8460845d869" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;enum&lt;/code&gt; type is analogous to a &lt;code&gt;data&lt;/code&gt; constructor declaration in ML, or a &lt;em&gt;pick ADT&lt;/em&gt; in Limbo.</source>
          <target state="translated">El tipo &lt;code&gt;enum&lt;/code&gt; es an&amp;aacute;logo a una declaraci&amp;oacute;n de constructor de &lt;code&gt;data&lt;/code&gt; en ML, o un &lt;em&gt;ADT pick&lt;/em&gt; en Limbo.</target>
        </trans-unit>
        <trans-unit id="a4c06e2ed2dc5ac68975592625d2fc4a6fa31065" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;env::args&lt;/code&gt; function returns an iterator! Rather than collecting the iterator values into a vector and then passing a slice to &lt;code&gt;Config::new&lt;/code&gt;, now we&amp;rsquo;re passing ownership of the iterator returned from &lt;code&gt;env::args&lt;/code&gt; to &lt;code&gt;Config::new&lt;/code&gt; directly.</source>
          <target state="translated">&amp;iexcl;La funci&amp;oacute;n &lt;code&gt;env::args&lt;/code&gt; devuelve un iterador! En lugar de recopilar los valores del iterador en un vector y luego pasar un segmento a &lt;code&gt;Config::new&lt;/code&gt; , ahora estamos pasando la propiedad del iterador devuelto desde &lt;code&gt;env::args&lt;/code&gt; a &lt;code&gt;Config::new&lt;/code&gt; directamente.</target>
        </trans-unit>
        <trans-unit id="8c4edba08b3e0cbdebf585d9d18019162245f0c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;execute&lt;/code&gt; method will send the job it wants to execute down the sending side of the channel.</source>
          <target state="translated">El m&amp;eacute;todo de &lt;code&gt;execute&lt;/code&gt; enviar&amp;aacute; el trabajo que desea ejecutar por el lado de env&amp;iacute;o del canal.</target>
        </trans-unit>
        <trans-unit id="f04efaa242b2b0657b1281616eed7892b34b84f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expensive_test&lt;/code&gt; function is listed as &lt;code&gt;ignored&lt;/code&gt;. If we want to run only the ignored tests, we can use &lt;code&gt;cargo test -- --ignored&lt;/code&gt;:</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;expensive_test&lt;/code&gt; aparece como &lt;code&gt;ignored&lt;/code&gt; . Si queremos ejecutar solo las pruebas ignoradas, podemos usar &lt;code&gt;cargo test -- --ignored&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b3f7670e25e83de589c198657dfe09fdc1e175dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;export_name&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;export_name&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="71ce9eba53db805fddc2d08a297018a65234c4f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extern&lt;/code&gt; function qualifier allows providing function &lt;em&gt;definitions&lt;/em&gt; that can be called with a particular ABI:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40efbff38e084ea29f3140f45238b8f3a1480902" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extern&lt;/code&gt; keyword is used in two places in Rust. One is in conjunction with the &lt;a href=&quot;index&quot;&gt;&lt;code&gt;crate&lt;/code&gt;&lt;/a&gt; keyword to make your Rust code aware of other Rust crates in your project, i.e., &lt;code&gt;extern crate lazy_static;&lt;/code&gt;. The other use is in foreign function interfaces (FFI).</source>
          <target state="translated">La palabra clave &lt;code&gt;extern&lt;/code&gt; se usa en dos lugares en Rust. Uno est&amp;aacute; en conjunto con la palabra clave &lt;a href=&quot;index&quot;&gt; &lt;code&gt;crate&lt;/code&gt; &lt;/a&gt; para hacer que su c&amp;oacute;digo de Rust sea consciente de otras cajas de Rust en su proyecto, es decir, &lt;code&gt;extern crate lazy_static;&lt;/code&gt; . El otro uso es en interfaces de funciones externas (FFI).</target>
        </trans-unit>
        <trans-unit id="e4b4130d453476128e8ae98130baa92b7675ca5c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extern&lt;/code&gt; keyword is used in two places in Rust. One is in conjunction with the &lt;a href=&quot;keyword.crate&quot;&gt;&lt;code&gt;crate&lt;/code&gt;&lt;/a&gt; keyword to make your Rust code aware of other Rust crates in your project, i.e., &lt;code&gt;extern crate lazy_static;&lt;/code&gt;. The other use is in foreign function interfaces (FFI).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80a6e01d93b27f65515594890e0091001ba7b217" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;feature&lt;/code&gt; attribute only accept a &quot;feature flag&quot; and can only be used on nightly. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36584ecca666e59936c11f071bcfcb0da92fd4b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;feature&lt;/code&gt; attribute was badly formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="424a7adcc55a187f305df277831d5dda5afa7154" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ffi_const&lt;/code&gt; attribute can only be used on foreign function declarations which have no side effects except for their return value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9fac3c8fa0259e175ffb5e9aab803c7bd9140ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ffi_const&lt;/code&gt; attribute was used on something other than a foreign function declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfe6d270783e8b73023767bbcd8ed3a773bacf0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ffi_pure&lt;/code&gt; attribute can only be used on foreign functions which do not have side effects or infinite loops:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="883b8dfd3c5fc179185e1d061b052f5f3e0fb52a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ffi_pure&lt;/code&gt; attribute was used on a non-foreign function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e96870e73ec5eb32cc1bdf8256711d63dccde7e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fix_incorrect_order&lt;/code&gt; function is in the &lt;code&gt;back_of_house&lt;/code&gt; module, so we can use &lt;code&gt;super&lt;/code&gt; to go to the parent module of &lt;code&gt;back_of_house&lt;/code&gt;, which in this case is &lt;code&gt;crate&lt;/code&gt;, the root. From there, we look for &lt;code&gt;serve_order&lt;/code&gt; and find it. Success! We think the &lt;code&gt;back_of_house&lt;/code&gt; module and the &lt;code&gt;serve_order&lt;/code&gt; function are likely to stay in the same relationship to each other and get moved together should we decide to reorganize the crate&amp;rsquo;s module tree. Therefore, we used &lt;code&gt;super&lt;/code&gt; so we&amp;rsquo;ll have fewer places to update code in the future if this code gets moved to a different module.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;fix_incorrect_order&lt;/code&gt; est&amp;aacute; en el m&amp;oacute;dulo &lt;code&gt;back_of_house&lt;/code&gt; , por lo que podemos usar &lt;code&gt;super&lt;/code&gt; para ir al m&amp;oacute;dulo principal de &lt;code&gt;back_of_house&lt;/code&gt; , que en este caso es &lt;code&gt;crate&lt;/code&gt; , la ra&amp;iacute;z. A partir de ah&amp;iacute;, buscamos &lt;code&gt;serve_order&lt;/code&gt; y lo encontramos. &amp;iexcl;&amp;Eacute;xito! Creemos que es probable que el m&amp;oacute;dulo &lt;code&gt;back_of_house&lt;/code&gt; y la funci&amp;oacute;n &lt;code&gt;serve_order&lt;/code&gt; mantengan la misma relaci&amp;oacute;n entre s&amp;iacute; y se muevan juntos si decidimos reorganizar el &amp;aacute;rbol de m&amp;oacute;dulos de la caja. Por lo tanto, usamos &lt;code&gt;super&lt;/code&gt; , por lo que tendremos menos lugares para actualizar el c&amp;oacute;digo en el futuro si este c&amp;oacute;digo se mueve a un m&amp;oacute;dulo diferente.</target>
        </trans-unit>
        <trans-unit id="8941a23b194692ed51f3b950de07285880e660a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fn&lt;/code&gt; syntax declares a new function, the parentheses, &lt;code&gt;()&lt;/code&gt;, indicate there are no parameters, and the curly bracket, &lt;code&gt;{&lt;/code&gt;, starts the body of the function.</source>
          <target state="translated">La sintaxis &lt;code&gt;fn&lt;/code&gt; declara una nueva funci&amp;oacute;n, los par&amp;eacute;ntesis, &lt;code&gt;()&lt;/code&gt; , indican que no hay par&amp;aacute;metros, y el corchete, &lt;code&gt;{&lt;/code&gt; , inicia el cuerpo de la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="2ec5406eba98b65177f08bb6b301125802a344f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; keyword is used in many syntactic locations:</source>
          <target state="translated">La palabra clave &lt;code&gt;for&lt;/code&gt; se utiliza en muchas ubicaciones sint&amp;aacute;cticas:</target>
        </trans-unit>
        <trans-unit id="f09d76fe1ac31bb0c6ea4013cf20271ea27e1d4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; loop variable is now named &lt;code&gt;_i&lt;/code&gt;, and the warning no longer appears.</source>
          <target state="translated">La variable de bucle &lt;code&gt;for&lt;/code&gt; ahora se llama &lt;code&gt;_i&lt;/code&gt; y la advertencia ya no aparece.</target>
        </trans-unit>
        <trans-unit id="05236db55a3c27bea79ddd94d4c11b4238339e3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;forbid&lt;/code&gt; lint setting, like &lt;code&gt;deny&lt;/code&gt;, turns the corresponding compiler warning into a hard error. Unlike &lt;code&gt;deny&lt;/code&gt;, &lt;code&gt;forbid&lt;/code&gt; prevents itself from being overridden by inner attributes.</source>
          <target state="translated">La configuraci&amp;oacute;n de &lt;code&gt;forbid&lt;/code&gt; lint, como &lt;code&gt;deny&lt;/code&gt; , convierte la advertencia del compilador correspondiente en un error grave. A diferencia de &lt;code&gt;deny&lt;/code&gt; , &lt;code&gt;forbid&lt;/code&gt; evita que los atributos internos lo anulen.</target>
        </trans-unit>
        <trans-unit id="4235fdb48267c248121e84a51ecfc4901ad84de8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;format&lt;/code&gt; function takes an &lt;a href=&quot;struct.arguments&quot;&gt;&lt;code&gt;Arguments&lt;/code&gt;&lt;/a&gt; struct and returns the resulting formatted string.</source>
          <target state="translated">La funci&amp;oacute;n de &lt;code&gt;format&lt;/code&gt; o toma una estructura &lt;a href=&quot;struct.arguments&quot;&gt; &lt;code&gt;Arguments&lt;/code&gt; &lt;/a&gt; y devuelve la cadena formateada resultante.</target>
        </trans-unit>
        <trans-unit id="d0e2c1abc11834d5ec0f9413abedb6a8d1f2b1d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt; file does not exist.</source>
          <target state="translated">El &lt;code&gt;from&lt;/code&gt; archivo no existe.</target>
        </trans-unit>
        <trans-unit id="0c95afec6a5645bced705f13162ada21e2af597c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt; path is not a file.</source>
          <target state="translated">El &lt;code&gt;from&lt;/code&gt; camino no es un archivo.</target>
        </trans-unit>
        <trans-unit id="6acb8d35118f04b02cccbeee4ae943f064bc37b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;global_allocator&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;global_allocator&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ae2c6463795dadd5e649f9eb12f49008495df3a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hash_builder&lt;/code&gt; passed should implement the &lt;a href=&quot;../../hash/trait.buildhasher&quot;&gt;&lt;code&gt;BuildHasher&lt;/code&gt;&lt;/a&gt; trait for the HashMap to be useful, see its documentation for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b0ca98b2928cdd13f0ccd74c40e39e4e68ec9cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hash_builder&lt;/code&gt; passed should implement the &lt;a href=&quot;../hash/trait.buildhasher&quot;&gt;&lt;code&gt;BuildHasher&lt;/code&gt;&lt;/a&gt; trait for the HashMap to be useful, see its documentation for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c35c9498a5a0a48423b3c0138b12569234cd1c61" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hello_macro_derive&lt;/code&gt; function first converts the &lt;code&gt;input&lt;/code&gt; from a &lt;code&gt;TokenStream&lt;/code&gt; to a data structure that we can then interpret and perform operations on. This is where &lt;code&gt;syn&lt;/code&gt; comes into play. The &lt;code&gt;parse&lt;/code&gt; function in &lt;code&gt;syn&lt;/code&gt; takes a &lt;code&gt;TokenStream&lt;/code&gt; and returns a &lt;code&gt;DeriveInput&lt;/code&gt; struct representing the parsed Rust code. Listing 19-32 shows the relevant parts of the &lt;code&gt;DeriveInput&lt;/code&gt; struct we get from parsing the &lt;code&gt;struct Pancakes;&lt;/code&gt; string:</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;hello_macro_derive&lt;/code&gt; primero convierte la &lt;code&gt;input&lt;/code&gt; de un &lt;code&gt;TokenStream&lt;/code&gt; en una estructura de datos que luego podemos interpretar y realizar operaciones. Aqu&amp;iacute; es donde entra en juego la &lt;code&gt;syn&lt;/code&gt; . El &lt;code&gt;parse&lt;/code&gt; funci&amp;oacute;n en &lt;code&gt;syn&lt;/code&gt; realiza un &lt;code&gt;TokenStream&lt;/code&gt; y devuelve un &lt;code&gt;DeriveInput&lt;/code&gt; struct que representa el c&amp;oacute;digo Rust analizada. El Listado 19-32 muestra las partes relevantes de la estructura &lt;code&gt;DeriveInput&lt;/code&gt; que obtenemos al analizar la &lt;code&gt;struct Pancakes;&lt;/code&gt; cuerda:</target>
        </trans-unit>
        <trans-unit id="004c835aa77c1c8e124a5716a58b7a6bffdd04f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hello_macro_derive&lt;/code&gt; function will be called when a user of our library specifies &lt;code&gt;#[derive(HelloMacro)]&lt;/code&gt; on a type. This is possible because we&amp;rsquo;ve annotated the &lt;code&gt;hello_macro_derive&lt;/code&gt; function here with &lt;code&gt;proc_macro_derive&lt;/code&gt; and specified the name, &lt;code&gt;HelloMacro&lt;/code&gt;, which matches our trait name; this is the convention most procedural macros follow.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;hello_macro_derive&lt;/code&gt; se llamar&amp;aacute; cuando un usuario de nuestra biblioteca especifique &lt;code&gt;#[derive(HelloMacro)]&lt;/code&gt; en un tipo. Esto es posible porque hemos anotado la funci&amp;oacute;n &lt;code&gt;hello_macro_derive&lt;/code&gt; aqu&amp;iacute; con &lt;code&gt;proc_macro_derive&lt;/code&gt; y hemos especificado el nombre, &lt;code&gt;HelloMacro&lt;/code&gt; , que coincide con nuestro nombre de rasgo; esta es la convenci&amp;oacute;n que siguen la mayor&amp;iacute;a de las macros de procedimiento.</target>
        </trans-unit>
        <trans-unit id="f6187e2c81223b9029c3a44a9c821bc39754afaa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if let&lt;/code&gt; syntax lets you combine &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; into a less verbose way to handle values that match one pattern while ignoring the rest. Consider the program in Listing 6-6 that matches on an &lt;code&gt;Option&amp;lt;u8&amp;gt;&lt;/code&gt; value but only wants to execute code if the value is 3.</source>
          <target state="translated">La sintaxis &lt;code&gt;if let&lt;/code&gt; le permite combinar &lt;code&gt;if&lt;/code&gt; y &lt;code&gt;let&lt;/code&gt; en una forma menos detallada de manejar valores que coinciden con un patr&amp;oacute;n mientras ignora el resto. Considere el programa del Listado 6-6 que coincide con un valor de &lt;code&gt;Option&amp;lt;u8&amp;gt;&lt;/code&gt; pero solo quiere ejecutar c&amp;oacute;digo si el valor es 3.</target>
        </trans-unit>
        <trans-unit id="4dd0a50c18a24fd3e6c3d1653fdf8d2add1e5c54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; condition evaluates to a value of &lt;code&gt;3&lt;/code&gt; this time, and Rust throws an error:</source>
          <target state="translated">La condici&amp;oacute;n &lt;code&gt;if&lt;/code&gt; se eval&amp;uacute;a con un valor de &lt;code&gt;3&lt;/code&gt; esta vez, y Rust arroja un error:</target>
        </trans-unit>
        <trans-unit id="3b97788abf2717f652bd87cae2841d2689fe301c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; expression checks whether our value is out of range, tells the user about the problem, and calls &lt;code&gt;continue&lt;/code&gt; to start the next iteration of the loop and ask for another guess. After the &lt;code&gt;if&lt;/code&gt; expression, we can proceed with the comparisons between &lt;code&gt;guess&lt;/code&gt; and the secret number knowing that &lt;code&gt;guess&lt;/code&gt; is between 1 and 100.</source>
          <target state="translated">La expresi&amp;oacute;n &lt;code&gt;if&lt;/code&gt; comprueba si nuestro valor est&amp;aacute; fuera de rango, le informa al usuario sobre el problema y las llamadas &lt;code&gt;continue&lt;/code&gt; para iniciar la siguiente iteraci&amp;oacute;n del ciclo y solicitar otra conjetura. Despu&amp;eacute;s de la expresi&amp;oacute;n &lt;code&gt;if&lt;/code&gt; , podemos continuar con las comparaciones entre la &lt;code&gt;guess&lt;/code&gt; y el n&amp;uacute;mero secreto sabiendo que la &lt;code&gt;guess&lt;/code&gt; est&amp;aacute; entre 1 y 100.</target>
        </trans-unit>
        <trans-unit id="21d4200f741c0e5d495167ba918e66c0fa127463" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; keyword is used in one other place in Rust, namely as a part of pattern matching itself, allowing patterns such as &lt;code&gt;Some(x) if x &amp;gt; 200&lt;/code&gt; to be used.</source>
          <target state="translated">La palabra clave &lt;code&gt;if&lt;/code&gt; se usa en otro lugar en Rust, es decir, como parte de la coincidencia de patrones en s&amp;iacute;, lo que permite que se usen patrones como &lt;code&gt;Some(x) if x &amp;gt; 200&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60fa964e136b0f0fd7616e520f7abaf2ebfa7111" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ignore&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;ignore&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f363aa597e809eee39b1326a49009f8ed22190d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ignore&lt;/code&gt; attribute may optionally be written with the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify a reason why the test is ignored.</source>
          <target state="translated">El atributo &lt;code&gt;ignore&lt;/code&gt; se puede escribir opcionalmente con la sintaxis &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; para especificar una raz&amp;oacute;n por la que se ignora la prueba.</target>
        </trans-unit>
        <trans-unit id="db8fdc6685b8fc701d318f4f3dec52f0b9a4e868" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;impl Trait&lt;/code&gt; return type captures lifetime parameters that do not appear within the &lt;code&gt;impl Trait&lt;/code&gt; itself.</source>
          <target state="translated">El tipo de retorno &lt;code&gt;impl Trait&lt;/code&gt; captura par&amp;aacute;metros de por vida que no aparecen dentro del propio &lt;code&gt;impl Trait&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9150ca2fdc92a2e0f4ccf4f986d692afa5493d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;impl Trait&lt;/code&gt; syntax is convenient and makes for more concise code in simple cases. The trait bound syntax can express more complexity in other cases. For example, we can have two parameters that implement &lt;code&gt;Summary&lt;/code&gt;. Using the &lt;code&gt;impl Trait&lt;/code&gt; syntax looks like this:</source>
          <target state="translated">La sintaxis &lt;code&gt;impl Trait&lt;/code&gt; es conveniente y permite un c&amp;oacute;digo m&amp;aacute;s conciso en casos simples. La sintaxis ligada a rasgos puede expresar m&amp;aacute;s complejidad en otros casos. Por ejemplo, podemos tener dos par&amp;aacute;metros que implementen &lt;code&gt;Summary&lt;/code&gt; . El uso de la sintaxis &lt;code&gt;impl Trait&lt;/code&gt; se ve as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="778ea7a6b81f5bfa7d87e34cfb75fde414639934" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;impl Trait&lt;/code&gt; syntax works for straightforward cases but is actually syntax sugar for a longer form, which is called a &lt;em&gt;trait bound&lt;/em&gt;; it looks like this:</source>
          <target state="translated">La sintaxis &lt;code&gt;impl Trait&lt;/code&gt; funciona para casos sencillos, pero en realidad es az&amp;uacute;car sint&amp;aacute;ctica para una forma m&amp;aacute;s larga, que se denomina &lt;em&gt;l&amp;iacute;mite de caracter&amp;iacute;stica&lt;/em&gt; ; se parece a esto:</target>
        </trans-unit>
        <trans-unit id="2ffdcc0f4b373da2777f00eb0b778b9205836471" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;impl&lt;/code&gt; keyword is primarily used to define implementations on types. Inherent implementations are standalone, while trait implementations are used to implement traits for types, or other traits.</source>
          <target state="translated">La palabra clave &lt;code&gt;impl&lt;/code&gt; se usa principalmente para definir implementaciones en tipos. Las implementaciones inherentes son independientes, mientras que las implementaciones de rasgos se utilizan para implementar rasgos para tipos u otros rasgos.</target>
        </trans-unit>
        <trans-unit id="49b529510ff41b8ce0e4f03d01af2d0795d82946" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;incoming&lt;/code&gt; method on &lt;code&gt;TcpListener&lt;/code&gt; returns an iterator that gives us a sequence of streams (more specifically, streams of type &lt;code&gt;TcpStream&lt;/code&gt;). A single &lt;em&gt;stream&lt;/em&gt; represents an open connection between the client and the server. A &lt;em&gt;connection&lt;/em&gt; is the name for the full request and response process in which a client connects to the server, the server generates a response, and the server closes the connection. As such, &lt;code&gt;TcpStream&lt;/code&gt; will read from itself to see what the client sent and then allow us to write our response to the stream. Overall, this &lt;code&gt;for&lt;/code&gt; loop will process each connection in turn and produce a series of streams for us to handle.</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;incoming&lt;/code&gt; en &lt;code&gt;TcpListener&lt;/code&gt; devuelve un iterador que nos da una secuencia de flujos (m&amp;aacute;s espec&amp;iacute;ficamente, flujos de tipo &lt;code&gt;TcpStream&lt;/code&gt; ). Un solo &lt;em&gt;flujo&lt;/em&gt; representa una conexi&amp;oacute;n abierta entre el cliente y el servidor. Una &lt;em&gt;conexi&amp;oacute;n&lt;/em&gt; es el nombre del proceso completo de solicitud y respuesta en el que un cliente se conecta al servidor, el servidor genera una respuesta y el servidor cierra la conexi&amp;oacute;n. Como tal, &lt;code&gt;TcpStream&lt;/code&gt; leer&amp;aacute; de s&amp;iacute; mismo para ver lo que envi&amp;oacute; el cliente y luego nos permitir&amp;aacute; escribir nuestra respuesta en la transmisi&amp;oacute;n. En general, este bucle &lt;code&gt;for&lt;/code&gt; procesar&amp;aacute; cada conexi&amp;oacute;n a su vez y producir&amp;aacute; una serie de flujos para que los manejemos.</target>
        </trans-unit>
        <trans-unit id="3ae3f99054fefa43fcfe679af5b3d84ea2c62ac1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inline&lt;/code&gt; attribute</source>
          <target state="translated">El atributo en &lt;code&gt;inline&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f0d784eef56974f3daef0d597995f18b5e5f8afb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inline&lt;/code&gt; attribute only supports two arguments:</source>
          <target state="translated">El atributo en &lt;code&gt;inline&lt;/code&gt; solo admite dos argumentos:</target>
        </trans-unit>
        <trans-unit id="bc1a141c850728d98b956fd0716ebc10f9ffb6e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inline&lt;/code&gt; attribute was malformed.</source>
          <target state="translated">El atributo en &lt;code&gt;inline&lt;/code&gt; estaba mal formado.</target>
        </trans-unit>
        <trans-unit id="91c34dfeac33c0fc72de6d1c1ac619e7a9084ef1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;instruction_set&lt;/code&gt; attribute only supports two arguments currently:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65492eab1824c51df92e478cb44c3823042f292f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;instruction_set&lt;/code&gt; attribute was malformed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4788ad11ac891125e5295255c9d02cd7b36750e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isize&lt;/code&gt; type is a signed integer type with the same number of bits as the platform's pointer type. The theoretical upper bound on object and array size is the maximum &lt;code&gt;isize&lt;/code&gt; value. This ensures that &lt;code&gt;isize&lt;/code&gt; can be used to calculate differences between pointers into an object or array and can address every byte within an object along with one byte past the end.</source>
          <target state="translated">El tipo &lt;code&gt;isize&lt;/code&gt; es un tipo entero con signo con el mismo n&amp;uacute;mero de bits que el tipo de puntero de la plataforma. El l&amp;iacute;mite superior te&amp;oacute;rico en objeto y tama&amp;ntilde;o de la matriz es el m&amp;aacute;ximo &lt;code&gt;isize&lt;/code&gt; valor. Esto asegura que &lt;code&gt;isize&lt;/code&gt; pueda usarse para calcular diferencias entre punteros en un objeto o matriz y pueda direccionar cada byte dentro de un objeto junto con un byte m&amp;aacute;s all&amp;aacute; del final.</target>
        </trans-unit>
        <trans-unit id="7d599bd6c4aa9e941662680b3c4cf55e952c7777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;it_works&lt;/code&gt; function now has a return type, &lt;code&gt;Result&amp;lt;(), String&amp;gt;&lt;/code&gt;. In the body of the function, rather than calling the &lt;code&gt;assert_eq!&lt;/code&gt; macro, we return &lt;code&gt;Ok(())&lt;/code&gt; when the test passes and an &lt;code&gt;Err&lt;/code&gt; with a &lt;code&gt;String&lt;/code&gt; inside when the test fails.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;it_works&lt;/code&gt; ahora tiene un tipo de retorno, &lt;code&gt;Result&amp;lt;(), String&amp;gt;&lt;/code&gt; . En el cuerpo de la funci&amp;oacute;n, en lugar de llamar a &lt;code&gt;assert_eq!&lt;/code&gt; macro, devolvemos &lt;code&gt;Ok(())&lt;/code&gt; cuando pasa la prueba y un &lt;code&gt;Err&lt;/code&gt; con una &lt;code&gt;String&lt;/code&gt; adentro cuando falla la prueba.</target>
        </trans-unit>
        <trans-unit id="d7cf351f8d0a069e43102c73f4dd09e2f7958bd2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;largest&lt;/code&gt; function has a parameter called &lt;code&gt;list&lt;/code&gt;, which represents any concrete slice of &lt;code&gt;i32&lt;/code&gt; values that we might pass into the function. As a result, when we call the function, the code runs on the specific values that we pass in.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;largest&lt;/code&gt; tiene un par&amp;aacute;metro llamado &lt;code&gt;list&lt;/code&gt; a , que representa cualquier porci&amp;oacute;n concreta de valores &lt;code&gt;i32&lt;/code&gt; que podamos pasar a la funci&amp;oacute;n. Como resultado, cuando llamamos a la funci&amp;oacute;n, el c&amp;oacute;digo se ejecuta en los valores espec&amp;iacute;ficos que pasamos.</target>
        </trans-unit>
        <trans-unit id="29c272390da5b69d23c340bb06b514ca355b63f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;largest_i32&lt;/code&gt; function is the one we extracted in Listing 10-3 that finds the largest &lt;code&gt;i32&lt;/code&gt; in a slice. The &lt;code&gt;largest_char&lt;/code&gt; function finds the largest &lt;code&gt;char&lt;/code&gt; in a slice. The function bodies have the same code, so let&amp;rsquo;s eliminate the duplication by introducing a generic type parameter in a single function.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;largest_i32&lt;/code&gt; es la que extrajimos en el Listado 10-3 que encuentra el &lt;code&gt;i32&lt;/code&gt; m&amp;aacute;s grande en un segmento. La funci&amp;oacute;n &lt;code&gt;largest_char&lt;/code&gt; encuentra el &lt;code&gt;char&lt;/code&gt; m&amp;aacute;s grande en un segmento. Los cuerpos de las funciones tienen el mismo c&amp;oacute;digo, as&amp;iacute; que eliminemos la duplicaci&amp;oacute;n introduciendo un par&amp;aacute;metro de tipo gen&amp;eacute;rico en una sola funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d1c6673a10646101d9e252f3f63c9d87dc9cd482" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;len&lt;/code&gt; argument is the number of &lt;strong&gt;elements&lt;/strong&gt;, not the number of bytes.</source>
          <target state="translated">El argumento &lt;code&gt;len&lt;/code&gt; es el n&amp;uacute;mero de &lt;strong&gt;elementos&lt;/strong&gt; , no el n&amp;uacute;mero de bytes.</target>
        </trans-unit>
        <trans-unit id="eabd24b648d02186aedafa8c6e64a26cd4789b21" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let y = 6&lt;/code&gt; statement does not return a value, so there isn&amp;rsquo;t anything for &lt;code&gt;x&lt;/code&gt; to bind to. This is different from what happens in other languages, such as C and Ruby, where the assignment returns the value of the assignment. In those languages, you can write &lt;code&gt;x = y = 6&lt;/code&gt; and have both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; have the value &lt;code&gt;6&lt;/code&gt;; that is not the case in Rust.</source>
          <target state="translated">La instrucci&amp;oacute;n &lt;code&gt;let y = 6&lt;/code&gt; no devuelve un valor, por lo que no hay nada a lo que &lt;code&gt;x&lt;/code&gt; pueda vincularse. Esto es diferente de lo que sucede en otros lenguajes, como C y Ruby, donde la asignaci&amp;oacute;n devuelve el valor de la asignaci&amp;oacute;n. En esos idiomas, puede escribir &lt;code&gt;x = y = 6&lt;/code&gt; y hacer que tanto &lt;code&gt;x&lt;/code&gt; como &lt;code&gt;y&lt;/code&gt; tengan el valor &lt;code&gt;6&lt;/code&gt; ; ese no es el caso en Rust.</target>
        </trans-unit>
        <trans-unit id="38e40fe06999fccdbadcd0aed2907afe5c6e93b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lines&lt;/code&gt; method returns an iterator. We&amp;rsquo;ll talk about iterators in depth in &lt;a href=&quot;ch13-02-iterators&quot;&gt;Chapter 13&lt;/a&gt;, but recall that you saw this way of using an iterator in &lt;a href=&quot;ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;Listing 3-5&lt;/a&gt;, where we used a &lt;code&gt;for&lt;/code&gt; loop with an iterator to run some code on each item in a collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb368f642161e00040244b9fcf42bf09c020466c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lines&lt;/code&gt; method returns an iterator. We&amp;rsquo;ll talk about iterators in depth in [Chapter 13][ch13], but recall that you saw this way of using an iterator in &lt;a href=&quot;ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;Listing 3-5&lt;/a&gt;, where we used a &lt;code&gt;for&lt;/code&gt; loop with an iterator to run some code on each item in a collection.</source>
          <target state="translated">El m&amp;eacute;todo de &lt;code&gt;lines&lt;/code&gt; devuelve un iterador. Hablaremos sobre los iteradores en profundidad en el [Cap&amp;iacute;tulo 13] [ch13], pero recuerde que vio esta forma de usar un iterador en el &lt;a href=&quot;ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;Listado 3-5&lt;/a&gt; , donde usamos un bucle &lt;code&gt;for&lt;/code&gt; con un iterador para ejecutar c&amp;oacute;digo en cada elemento. en una colecci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="eb1d841506acd030675c6922085c83e81e995a8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link&lt;/code&gt; attribute</source>
          <target state="translated">El atributo de &lt;code&gt;link&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="49ce3813b3cc29f6621eed5040dfcafe494f7af6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link_name&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;link_name&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="affa85dfaaac9c19595e178102133ab86d473f6f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link_name&lt;/code&gt; attribute may be specified on declarations inside an &lt;code&gt;extern&lt;/code&gt; block to indicate the symbol to import for the given function or static. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the name of the symbol.</source>
          <target state="translated">El atributo &lt;code&gt;link_name&lt;/code&gt; se puede especificar en declaraciones dentro de un bloque &lt;code&gt;extern&lt;/code&gt; o para indicar el s&amp;iacute;mbolo a importar para la funci&amp;oacute;n dada o est&amp;aacute;tica. Utiliza la sintaxis &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; para especificar el nombre del s&amp;iacute;mbolo.</target>
        </trans-unit>
        <trans-unit id="76e0be66315f639652150dfe37a31422ede56b88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link_section&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;link_section&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5d3ac97ce0e51b7500958397678a0747500d6a86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locality&lt;/code&gt; argument must be a constant integer and is a temporal locality specifier ranging from (0) - no locality, to (3) - extremely local keep in cache</source>
          <target state="translated">El argumento de &lt;code&gt;locality&lt;/code&gt; debe ser un entero constante y es un especificador de localidad temporal que va desde (0) - sin localidad, a (3) - extremadamente local mantener en cach&amp;eacute;</target>
        </trans-unit>
        <trans-unit id="08d3f68a2cf00952341cb92b2cabeabf4f7aad60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locality&lt;/code&gt; argument must be a constant integer and is a temporal locality specifier ranging from (0) - no locality, to (3) - extremely local keep in cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef1c91d4a25bd321565ee99def8880c9e7e661ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;loop&lt;/code&gt; keyword creates an infinite loop. We&amp;rsquo;ll add that now to give users more chances at guessing the number:</source>
          <target state="translated">La palabra clave &lt;code&gt;loop&lt;/code&gt; crea un ciclo infinito. Agregaremos eso ahora para brindar a los usuarios m&amp;aacute;s oportunidades de adivinar el n&amp;uacute;mero:</target>
        </trans-unit>
        <trans-unit id="ebe9e1bcc2f0843b5208a2b5109915be71857732" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;loop&lt;/code&gt; keyword tells Rust to execute a block of code over and over again forever or until you explicitly tell it to stop.</source>
          <target state="translated">La palabra clave &lt;code&gt;loop&lt;/code&gt; le dice a Rust que ejecute un bloque de c&amp;oacute;digo una y otra vez para siempre o hasta que le digas expl&amp;iacute;citamente que se detenga.</target>
        </trans-unit>
        <trans-unit id="9910971bdcb643aec0b768364519db2f99d5aff4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;macro_use&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;macro_use&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c25fb9655125d01a5a1e9d67f7f0780bc361281a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function here creates an instance of the &lt;code&gt;ImportantExcerpt&lt;/code&gt; struct that holds a reference to the first sentence of the &lt;code&gt;String&lt;/code&gt; owned by the variable &lt;code&gt;novel&lt;/code&gt;. The data in &lt;code&gt;novel&lt;/code&gt; exists before the &lt;code&gt;ImportantExcerpt&lt;/code&gt; instance is created. In addition, &lt;code&gt;novel&lt;/code&gt; doesn&amp;rsquo;t go out of scope until after the &lt;code&gt;ImportantExcerpt&lt;/code&gt; goes out of scope, so the reference in the &lt;code&gt;ImportantExcerpt&lt;/code&gt; instance is valid.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; aqu&amp;iacute; crea una instancia de la estructura &lt;code&gt;ImportantExcerpt&lt;/code&gt; que contiene una referencia a la primera oraci&amp;oacute;n de &lt;code&gt;String&lt;/code&gt; propiedad de la variable &lt;code&gt;novel&lt;/code&gt; . Los datos en &lt;code&gt;novel&lt;/code&gt; existen antes de que se cree la instancia de &lt;code&gt;ImportantExcerpt&lt;/code&gt; . Adem&amp;aacute;s, &lt;code&gt;novel&lt;/code&gt; no sale del alcance hasta que el &lt;code&gt;ImportantExcerpt&lt;/code&gt; sale del alcance, por lo que la referencia en la instancia de &lt;code&gt;ImportantExcerpt&lt;/code&gt; es v&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="db5fe1609c8c74f709a4f1880a24bb8f27550e1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function is special, and there are restrictions on what its return type must be. One valid return type for main is &lt;code&gt;()&lt;/code&gt;, and conveniently, another valid return type is &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;, as shown here:</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; es especial y existen restricciones sobre cu&amp;aacute;l debe ser su tipo de retorno. Un tipo de retorno v&amp;aacute;lido para main es &lt;code&gt;()&lt;/code&gt; y, convenientemente, otro tipo de retorno v&amp;aacute;lido es &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; , como se muestra aqu&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="df8be9695315286ea699a84bc57bf274e0dcbb5a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function prototype should never take arguments. Example:</source>
          <target state="translated">El prototipo de la funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; nunca deber&amp;iacute;a aceptar argumentos. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="db6afd48cca2e467a026116d5334792843766266" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function was defined with generic parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b77f7c754f9c38d3041a1e299a31ef7eeecfa144" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function was incorrectly declared.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; se declar&amp;oacute; incorrectamente.</target>
        </trans-unit>
        <trans-unit id="43e2fa6b27c55d262177050d71a4a20b71217bb8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;move&lt;/code&gt; closure is often used alongside &lt;code&gt;thread::spawn&lt;/code&gt; because it allows you to use data from one thread in another thread.</source>
          <target state="translated">El cierre de &lt;code&gt;move&lt;/code&gt; se usa a menudo junto con &lt;code&gt;thread::spawn&lt;/code&gt; porque le permite usar datos de un hilo en otro hilo.</target>
        </trans-unit>
        <trans-unit id="619f2d182d04cd2437b9280f0034a655e725227f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mpsc::channel&lt;/code&gt; function returns a tuple, the first element of which is the sending end and the second element is the receiving end. The abbreviations &lt;code&gt;tx&lt;/code&gt; and &lt;code&gt;rx&lt;/code&gt; are traditionally used in many fields for &lt;em&gt;transmitter&lt;/em&gt; and &lt;em&gt;receiver&lt;/em&gt; respectively, so we name our variables as such to indicate each end. We&amp;rsquo;re using a &lt;code&gt;let&lt;/code&gt; statement with a pattern that destructures the tuples; we&amp;rsquo;ll discuss the use of patterns in &lt;code&gt;let&lt;/code&gt; statements and destructuring in Chapter 18. Using a &lt;code&gt;let&lt;/code&gt; statement this way is a convenient approach to extract the pieces of the tuple returned by &lt;code&gt;mpsc::channel&lt;/code&gt;.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;mpsc::channel&lt;/code&gt; devuelve una tupla, cuyo primer elemento es el extremo de env&amp;iacute;o y el segundo elemento es el extremo de recepci&amp;oacute;n. Las abreviaturas &lt;code&gt;tx&lt;/code&gt; y &lt;code&gt;rx&lt;/code&gt; se utilizan tradicionalmente en muchos campos para &lt;em&gt;transmisor&lt;/em&gt; y &lt;em&gt;receptor&lt;/em&gt; respectivamente, por lo que nombramos nuestras variables como tales para indicar cada extremo. Estamos usando una declaraci&amp;oacute;n &lt;code&gt;let&lt;/code&gt; con un patr&amp;oacute;n que desestructura las tuplas; discutiremos el uso de patrones en las sentencias &lt;code&gt;let&lt;/code&gt; y la desestructuraci&amp;oacute;n en el Cap&amp;iacute;tulo 18. Usar una sentencia &lt;code&gt;let&lt;/code&gt; de esta manera es un enfoque conveniente para extraer las partes de la tupla devueltas por &lt;code&gt;mpsc::channel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a5adaf35abd6fb52abc875dfd1ff8ace4487057" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;must_use&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;must_use&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4dc21fbdabdadeb25794ca5fcb0a8eb690cc55f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;must_use&lt;/code&gt; attribute may include a message by using the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax such as &lt;code&gt;#[must_use = &quot;example message&quot;]&lt;/code&gt;. The message will be given alongside the warning.</source>
          <target state="translated">El atributo &lt;code&gt;must_use&lt;/code&gt; puede incluir un mensaje utilizando la sintaxis &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; como &lt;code&gt;#[must_use = &quot;example message&quot;]&lt;/code&gt; . El mensaje se dar&amp;aacute; junto a la advertencia.</target>
        </trans-unit>
        <trans-unit id="fa08dd7bde9ed9336c6bf68b835c76ace5a2b281" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; key must be included if &lt;code&gt;kind&lt;/code&gt; is specified.</source>
          <target state="translated">La clave del &lt;code&gt;name&lt;/code&gt; debe incluirse si se especifica &lt;code&gt;kind&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f5d61c5238b80d1372117cdc9301f7c5a015909" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_builtins&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;no_builtins&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0e25b9ca8aa17342df965438e7d8b3912387ac96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_link&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;no_link&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4c0b9a2602cdb8c2f59fe6476a9d0299ede88a3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_main&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;no_main&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="63ed748c3f1f47aec501358b0494a62e8e33119a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_mangle&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;no_mangle&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3db3cdb5f8ea826a09ba97c6a8d286d70aec5a65" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;non_exhaustive&lt;/code&gt; attribute uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaWord&lt;/em&gt;&lt;/a&gt; syntax and thus does not take any inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6746e3c0ec6ce06b907e0392a7e5f26c1647e02" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;not&lt;/code&gt; cfg-predicate was malformed.</source>
          <target state="translated">El predicado &lt;code&gt;not&lt;/code&gt; cfg estaba mal formado.</target>
        </trans-unit>
        <trans-unit id="522f2fe5c8ca134ded384cd8e598baad904cbb06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;not&lt;/code&gt; predicate expects one cfg-pattern. Example:</source>
          <target state="translated">El predicado &lt;code&gt;not&lt;/code&gt; espera un patr&amp;oacute;n cfg. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="b32d84af66b0734455999894598a8249aed66fbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;number&lt;/code&gt; variable will be bound to a value based on the outcome of the &lt;code&gt;if&lt;/code&gt; expression. Run this code to see what happens:</source>
          <target state="translated">La variable &lt;code&gt;number&lt;/code&gt; estar&amp;aacute; vinculada a un valor basado en el resultado de la expresi&amp;oacute;n &lt;code&gt;if&lt;/code&gt; . Ejecute este c&amp;oacute;digo para ver qu&amp;eacute; sucede:</target>
        </trans-unit>
        <trans-unit id="60fb1fa966c95caff6ec3f67558fb81ff746c1d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;op_string_ref&lt;/code&gt; binding has type &lt;code&gt;&amp;amp;Option&amp;lt;&amp;amp;String&amp;gt;&lt;/code&gt; in both cases.</source>
          <target state="translated">El enlace &lt;code&gt;op_string_ref&lt;/code&gt; tiene el tipo &lt;code&gt;&amp;amp;Option&amp;lt;&amp;amp;String&amp;gt;&lt;/code&gt; en ambos casos.</target>
        </trans-unit>
        <trans-unit id="2d0c9a8f467995322cb26a15b43a2ed10bd928bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;opt-level&lt;/code&gt; setting controls the number of optimizations Rust will apply to your code, with a range of 0 to 3. Applying more optimizations extends compiling time, so if you&amp;rsquo;re in development and compiling your code often, you&amp;rsquo;ll want faster compiling even if the resulting code runs slower. That is the reason the default &lt;code&gt;opt-level&lt;/code&gt; for &lt;code&gt;dev&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;. When you&amp;rsquo;re ready to release your code, it&amp;rsquo;s best to spend more time compiling. You&amp;rsquo;ll only compile in release mode once, but you&amp;rsquo;ll run the compiled program many times, so release mode trades longer compile time for code that runs faster. That is why the default &lt;code&gt;opt-level&lt;/code&gt; for the &lt;code&gt;release&lt;/code&gt; profile is &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">La configuraci&amp;oacute;n de &lt;code&gt;opt-level&lt;/code&gt; controla la cantidad de optimizaciones que Rust aplicar&amp;aacute; a su c&amp;oacute;digo, con un rango de 0 a 3. La aplicaci&amp;oacute;n de m&amp;aacute;s optimizaciones extiende el tiempo de compilaci&amp;oacute;n, por lo que si est&amp;aacute; en desarrollo y compila su c&amp;oacute;digo con frecuencia, querr&amp;aacute; m&amp;aacute;s r&amp;aacute;pido compilando incluso si el c&amp;oacute;digo resultante se ejecuta m&amp;aacute;s lento. Esa es la raz&amp;oacute;n por la que el &lt;code&gt;opt-level&lt;/code&gt; de opci&amp;oacute;n predeterminado para &lt;code&gt;dev&lt;/code&gt; es &lt;code&gt;0&lt;/code&gt; . Cuando est&amp;eacute; listo para publicar su c&amp;oacute;digo, es mejor dedicar m&amp;aacute;s tiempo a compilar. Solo compilar&amp;aacute; en modo de lanzamiento una vez, pero ejecutar&amp;aacute; el programa compilado muchas veces, por lo que el modo de lanzamiento intercambia un tiempo de compilaci&amp;oacute;n m&amp;aacute;s largo por un c&amp;oacute;digo que se ejecuta m&amp;aacute;s r&amp;aacute;pido. Es por eso que el &lt;code&gt;opt-level&lt;/code&gt; de opci&amp;oacute;n predeterminado para el perfil de &lt;code&gt;release&lt;/code&gt; es &lt;code&gt;3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a0e04095b896f42634e32e5783ee8a2f1b36521" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;or_insert&lt;/code&gt; method on &lt;code&gt;Entry&lt;/code&gt; is defined to return a mutable reference to the value for the corresponding &lt;code&gt;Entry&lt;/code&gt; key if that key exists, and if not, inserts the parameter as the new value for this key and returns a mutable reference to the new value. This technique is much cleaner than writing the logic ourselves and, in addition, plays more nicely with the borrow checker.</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;or_insert&lt;/code&gt; en &lt;code&gt;Entry&lt;/code&gt; se define para devolver una referencia mutable al valor de la clave &lt;code&gt;Entry&lt;/code&gt; correspondiente si esa clave existe, y si no, inserta el par&amp;aacute;metro como el nuevo valor para esta clave y devuelve una referencia mutable al nuevo valor. Esta t&amp;eacute;cnica es mucho m&amp;aacute;s limpia que escribir la l&amp;oacute;gica nosotros mismos y, adem&amp;aacute;s, funciona mejor con el comprobador de pr&amp;eacute;stamos.</target>
        </trans-unit>
        <trans-unit id="6774c9469b6011fbcb32c16aad7d03e8b6f6c4d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;panic_handler&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;panic_handler&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a6291890b4261d452b074ebd1ea09861364cf569" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; attribute</source>
          <target state="translated">El atributo de &lt;code&gt;path&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eca9cdb5a96c8de323e434d012e339f61d08ae9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; points at a non-directory file.</source>
          <target state="translated">La &lt;code&gt;path&lt;/code&gt; apunta a un archivo que no es de directorio.</target>
        </trans-unit>
        <trans-unit id="34ed0df01305ce0f75ec5fd43922003af97a525e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;poll&lt;/code&gt; function is not called repeatedly in a tight loop -- instead, it should only be called when the future indicates that it is ready to make progress (by calling &lt;code&gt;wake()&lt;/code&gt;). If you're familiar with the &lt;code&gt;poll(2)&lt;/code&gt; or &lt;code&gt;select(2)&lt;/code&gt; syscalls on Unix it's worth noting that futures typically do &lt;em&gt;not&lt;/em&gt; suffer the same problems of &quot;all wakeups must poll all events&quot;; they are more like &lt;code&gt;epoll(4)&lt;/code&gt;.</source>
          <target state="translated">La funci&amp;oacute;n de &lt;code&gt;poll&lt;/code&gt; no se llama repetidamente en un bucle cerrado; en cambio, solo debe llamarse cuando el futuro indique que est&amp;aacute; lista para progresar (llamando a &lt;code&gt;wake()&lt;/code&gt; ). Si est&amp;aacute; familiarizado con la &lt;code&gt;poll(2)&lt;/code&gt; o &lt;code&gt;select(2)&lt;/code&gt; llamadas al sistema en Unix, vale la pena se&amp;ntilde;alar que los futuros normalmente &lt;em&gt;no&lt;/em&gt; sufren los mismos problemas de &quot;todas las activaciones deben sondear todos los eventos&quot;; son m&amp;aacute;s como &lt;code&gt;epoll(4)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4cdf57409266ff4ceaefa41a5aa6a9d06ca0f60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;poll&lt;/code&gt; method</source>
          <target state="translated">El m&amp;eacute;todo de &lt;code&gt;poll&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f69f8390bb6f3d4deb2545de4fdfa29877369556" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prefetch&lt;/code&gt; intrinsic is a hint to the code generator to insert a prefetch instruction if supported; otherwise, it is a no-op. Prefetches have no effect on the behavior of the program but can change its performance characteristics.</source>
          <target state="translated">El intr&amp;iacute;nseco de &lt;code&gt;prefetch&lt;/code&gt; previa es una sugerencia para que el generador de c&amp;oacute;digo inserte una instrucci&amp;oacute;n de captaci&amp;oacute;n previa si es compatible; de lo contrario, no es una operaci&amp;oacute;n. Las captaciones previas no tienen ning&amp;uacute;n efecto sobre el comportamiento del programa, pero pueden cambiar sus caracter&amp;iacute;sticas de rendimiento.</target>
        </trans-unit>
        <trans-unit id="fa7fa9cd2241a28cad4fa12a2f135f7ef3c12daf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;println!&lt;/code&gt; function is only capable of printing to standard output, so we have to use something else to print to standard error.</source>
          <target state="translated">&amp;iexcl;El &lt;code&gt;println!&lt;/code&gt; La funci&amp;oacute;n solo es capaz de imprimir en salida est&amp;aacute;ndar, por lo que tenemos que usar algo m&amp;aacute;s para imprimir en error est&amp;aacute;ndar.</target>
        </trans-unit>
        <trans-unit id="f554c0d8cd003f0dac64077248339772aef74465" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;println!&lt;/code&gt; macro can do many kinds of formatting, and by default, the curly brackets tell &lt;code&gt;println!&lt;/code&gt; to use formatting known as &lt;code&gt;Display&lt;/code&gt;: output intended for direct end user consumption. The primitive types we&amp;rsquo;ve seen so far implement &lt;code&gt;Display&lt;/code&gt; by default, because there&amp;rsquo;s only one way you&amp;rsquo;d want to show a &lt;code&gt;1&lt;/code&gt; or any other primitive type to a user. But with structs, the way &lt;code&gt;println!&lt;/code&gt; should format the output is less clear because there are more display possibilities: Do you want commas or not? Do you want to print the curly brackets? Should all the fields be shown? Due to this ambiguity, Rust doesn&amp;rsquo;t try to guess what we want, and structs don&amp;rsquo;t have a provided implementation of &lt;code&gt;Display&lt;/code&gt;.</source>
          <target state="translated">&amp;iexcl;El &lt;code&gt;println!&lt;/code&gt; La macro puede hacer muchos tipos de formato y, de forma predeterminada, las llaves indican &lt;code&gt;println!&lt;/code&gt; utilizar el formato conocido como &lt;code&gt;Display&lt;/code&gt; : salida destinada al consumo directo del usuario final. Los tipos primitivos que hemos visto hasta ahora implementan &lt;code&gt;Display&lt;/code&gt; de forma predeterminada, porque solo hay una forma en la que le gustar&amp;iacute;a mostrar un &lt;code&gt;1&lt;/code&gt; o cualquier otro tipo primitivo a un usuario. Pero con estructuras, la forma en que &lt;code&gt;println!&lt;/code&gt; Deber&amp;iacute;a formatear la salida es menos clara porque hay m&amp;aacute;s posibilidades de visualizaci&amp;oacute;n: &amp;iquest;Quieres comas o no? &amp;iquest;Quieres imprimir las llaves? &amp;iquest;Deber&amp;iacute;an mostrarse todos los campos? Debido a esta ambig&amp;uuml;edad, Rust no intenta adivinar lo que queremos, y las estructuras no tienen una implementaci&amp;oacute;n proporcionada de &lt;code&gt;Display&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02931ec361bbc5f61952272ead50c2b1cc721cb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;println!&lt;/code&gt; macro is only capable of printing to standard output, so we have to use something else to print to standard error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df3a7253c874e9c54aed370b97b0410e823ccbd2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;proc_macro&lt;/code&gt; crate</source>
          <target state="translated">La caja &lt;code&gt;proc_macro&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0ebc19fdeafa41e303e045832093f26b01f1011c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pub&lt;/code&gt; keyword was used inside a function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4aeb159d9e69df04b16b32d0a540b4e48d1c2ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pub&lt;/code&gt; keyword was used inside a function. Erroneous code example:</source>
          <target state="translated">La palabra clave &lt;code&gt;pub&lt;/code&gt; se utiliz&amp;oacute; dentro de una funci&amp;oacute;n. Ejemplo de c&amp;oacute;digo err&amp;oacute;neo:</target>
        </trans-unit>
        <trans-unit id="b670fe1e664ec6db0ea27f497b8f300d96565afa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pub&lt;/code&gt; keyword was used inside a public enum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d36ebedc5c61f3368fb308364706ea53f77e634b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pub&lt;/code&gt; keyword was used inside a public enum. Erroneous code example:</source>
          <target state="translated">La palabra clave &lt;code&gt;pub&lt;/code&gt; se utiliz&amp;oacute; dentro de una enumeraci&amp;oacute;n p&amp;uacute;blica. Ejemplo de c&amp;oacute;digo err&amp;oacute;neo:</target>
        </trans-unit>
        <trans-unit id="855c30613293c5803da1be19530bcff46d089f73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;push&lt;/code&gt; method takes a single character as a parameter and adds it to the &lt;code&gt;String&lt;/code&gt;. Listing 8-17 shows code that adds the letter &lt;em&gt;l&lt;/em&gt; to a &lt;code&gt;String&lt;/code&gt; using the &lt;code&gt;push&lt;/code&gt; method.</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;push&lt;/code&gt; toma un solo car&amp;aacute;cter como par&amp;aacute;metro y lo agrega a &lt;code&gt;String&lt;/code&gt; . El listado 8-17 muestra el c&amp;oacute;digo que agrega la letra &lt;em&gt;l&lt;/em&gt; a una &lt;code&gt;String&lt;/code&gt; usando el m&amp;eacute;todo &lt;code&gt;push&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7c0b086ee3b65e9ef7299c70cf8f6fd0c56999e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;quote!&lt;/code&gt; macro also provides some very cool templating mechanics: we can enter &lt;code&gt;#name&lt;/code&gt;, and &lt;code&gt;quote!&lt;/code&gt; will replace it with the value in the variable &lt;code&gt;name&lt;/code&gt;. You can even do some repetition similar to the way regular macros work. Check out &lt;a href=&quot;https://docs.rs/quote&quot;&gt;the &lt;code&gt;quote&lt;/code&gt; crate&amp;rsquo;s docs&lt;/a&gt; for a thorough introduction.</source>
          <target state="translated">&amp;iexcl;La &lt;code&gt;quote!&lt;/code&gt; macro tambi&amp;eacute;n proporciona algunas mec&amp;aacute;nicas de plantillas muy interesantes: &amp;iexcl;podemos ingresar &lt;code&gt;#name&lt;/code&gt; y &lt;code&gt;quote!&lt;/code&gt; lo reemplazar&amp;aacute; con el valor en el &lt;code&gt;name&lt;/code&gt; la variable . Incluso puede hacer una repetici&amp;oacute;n similar a la forma en que funcionan las macros normales. Consulte &lt;a href=&quot;https://docs.rs/quote&quot;&gt;los documentos de la caja de &lt;code&gt;quote&lt;/code&gt; &lt;/a&gt; para obtener una introducci&amp;oacute;n completa.</target>
        </trans-unit>
        <trans-unit id="62ab310a7862369bfdb3998e805adaae0cd4f2e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;quote!&lt;/code&gt; macro lets us define the Rust code that we want to return. The compiler expects something different to the direct result of the &lt;code&gt;quote!&lt;/code&gt; macro&amp;rsquo;s execution, so we need to convert it to a &lt;code&gt;TokenStream&lt;/code&gt;. We do this by calling the &lt;code&gt;into&lt;/code&gt; method, which consumes this intermediate representation and returns a value of the required &lt;code&gt;TokenStream&lt;/code&gt; type.</source>
          <target state="translated">&amp;iexcl;La &lt;code&gt;quote!&lt;/code&gt; macro nos permite definir el c&amp;oacute;digo de Rust que queremos devolver. &amp;iexcl;El compilador espera algo diferente al resultado directo de la &lt;code&gt;quote!&lt;/code&gt; ejecuci&amp;oacute;n de la macro, por lo que debemos convertirla en un &lt;code&gt;TokenStream&lt;/code&gt; . Hacemos esto llamando &lt;code&gt;into&lt;/code&gt; m&amp;eacute;todo into , que consume esta representaci&amp;oacute;n intermedia y devuelve un valor del tipo &lt;code&gt;TokenStream&lt;/code&gt; requerido .</target>
        </trans-unit>
        <trans-unit id="53ae9c1c1e33423bee13e403e332e75689959214" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ready!&lt;/code&gt; call expands to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b83941e960f12671a681a1df28d6d59cb442a02e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recursion_limit&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;recursion_limit&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7fd3ec074e9dd99ae0db784fdf399ea43dd43516" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ref&lt;/code&gt; and/or &lt;code&gt;mut&lt;/code&gt;&lt;em&gt;IDENTIFIER&lt;/em&gt; syntax matches any value and binds it to a variable with the same name as the given field.</source>
          <target state="translated">La sintaxis &lt;code&gt;ref&lt;/code&gt; y / o &lt;code&gt;mut&lt;/code&gt; &lt;em&gt;IDENTIFIER&lt;/em&gt; coincide con cualquier valor y lo vincula a una variable con el mismo nombre que el campo dado.</target>
        </trans-unit>
        <trans-unit id="a07e646920bfd0169ef8462620bb6bf857e50545" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;repeat()&lt;/code&gt; function repeats a single value over and over again.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;repeat()&lt;/code&gt; repite un solo valor una y otra vez.</target>
        </trans-unit>
        <trans-unit id="ca6b7fab269378f975039696a9d029f43743fe55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;repeat_with()&lt;/code&gt; function calls the repeater over and over again.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;repeat_with()&lt;/code&gt; llama al repetidor una y otra vez.</target>
        </trans-unit>
        <trans-unit id="203b4d4e0f959a4e516770bf1c8acd411f9645d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;request_review&lt;/code&gt; and &lt;code&gt;approve&lt;/code&gt; methods take ownership of &lt;code&gt;self&lt;/code&gt;, thus consuming the &lt;code&gt;DraftPost&lt;/code&gt; and &lt;code&gt;PendingReviewPost&lt;/code&gt; instances and transforming them into a &lt;code&gt;PendingReviewPost&lt;/code&gt; and a published &lt;code&gt;Post&lt;/code&gt;, respectively. This way, we won&amp;rsquo;t have any lingering &lt;code&gt;DraftPost&lt;/code&gt; instances after we&amp;rsquo;ve called &lt;code&gt;request_review&lt;/code&gt; on them, and so forth. The &lt;code&gt;PendingReviewPost&lt;/code&gt; struct doesn&amp;rsquo;t have a &lt;code&gt;content&lt;/code&gt; method defined on it, so attempting to read its content results in a compiler error, as with &lt;code&gt;DraftPost&lt;/code&gt;. Because the only way to get a published &lt;code&gt;Post&lt;/code&gt; instance that does have a &lt;code&gt;content&lt;/code&gt; method defined is to call the &lt;code&gt;approve&lt;/code&gt; method on a &lt;code&gt;PendingReviewPost&lt;/code&gt;, and the only way to get a &lt;code&gt;PendingReviewPost&lt;/code&gt; is to call the &lt;code&gt;request_review&lt;/code&gt; method on a &lt;code&gt;DraftPost&lt;/code&gt;, we&amp;rsquo;ve now encoded the blog post workflow into the type system.</source>
          <target state="translated">El &lt;code&gt;request_review&lt;/code&gt; y &lt;code&gt;approve&lt;/code&gt; m&amp;eacute;todos toman la propiedad de &lt;code&gt;self&lt;/code&gt; , consumiendo de este modo los &lt;code&gt;DraftPost&lt;/code&gt; y &lt;code&gt;PendingReviewPost&lt;/code&gt; casos y transformarlas en una &lt;code&gt;PendingReviewPost&lt;/code&gt; y un publicado &lt;code&gt;Post&lt;/code&gt; , respectivamente. De esta manera, no &lt;code&gt;DraftPost&lt;/code&gt; instancias de DraftPost persistentes despu&amp;eacute;s de haber llamado a &lt;code&gt;request_review&lt;/code&gt; en ellas, y as&amp;iacute; sucesivamente. La estructura &lt;code&gt;PendingReviewPost&lt;/code&gt; no tiene un m&amp;eacute;todo de &lt;code&gt;content&lt;/code&gt; definido, por lo que intentar leer su contenido da como resultado un error del compilador, como con &lt;code&gt;DraftPost&lt;/code&gt; . Porque la &amp;uacute;nica forma de conseguir un &lt;code&gt;Post&lt;/code&gt; publicadoinstancia que tiene un &lt;code&gt;content&lt;/code&gt; m&amp;eacute;todo definido es llamar al &lt;code&gt;approve&lt;/code&gt; m&amp;eacute;todo en un &lt;code&gt;PendingReviewPost&lt;/code&gt; , y la &amp;uacute;nica manera de conseguir un &lt;code&gt;PendingReviewPost&lt;/code&gt; es llamar a la &lt;code&gt;request_review&lt;/code&gt; m&amp;eacute;todo en un &lt;code&gt;DraftPost&lt;/code&gt; , ahora hemos codificaba el flujo de trabajo de post blog en el sistema de tipos.</target>
        </trans-unit>
        <trans-unit id="14e654a0e6edb832d7ec2e9f01e2cec2e8fc8293" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;request_review&lt;/code&gt; method on &lt;code&gt;Draft&lt;/code&gt; needs to return a new, boxed instance of a new &lt;code&gt;PendingReview&lt;/code&gt; struct, which represents the state when a post is waiting for a review. The &lt;code&gt;PendingReview&lt;/code&gt; struct also implements the &lt;code&gt;request_review&lt;/code&gt; method but doesn&amp;rsquo;t do any transformations. Rather, it returns itself, because when we request a review on a post already in the &lt;code&gt;PendingReview&lt;/code&gt; state, it should stay in the &lt;code&gt;PendingReview&lt;/code&gt; state.</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;request_review&lt;/code&gt; en &lt;code&gt;Draft&lt;/code&gt; necesita devolver una nueva instancia en caja de una nueva estructura &lt;code&gt;PendingReview&lt;/code&gt; , que representa el estado cuando una publicaci&amp;oacute;n est&amp;aacute; esperando una revisi&amp;oacute;n. La estructura &lt;code&gt;PendingReview&lt;/code&gt; tambi&amp;eacute;n implementa el m&amp;eacute;todo &lt;code&gt;request_review&lt;/code&gt; pero no realiza ninguna transformaci&amp;oacute;n. M&amp;aacute;s bien, se devuelve solo, porque cuando solicitamos una revisi&amp;oacute;n de una publicaci&amp;oacute;n que ya se encuentra en el estado &lt;code&gt;PendingReview&lt;/code&gt; , debe permanecer en el estado &lt;code&gt;PendingReview&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e74e1506742074d3eac6be2b7d8e21235520da47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run&lt;/code&gt; command comes in handy when you need to rapidly iterate on a project, as we&amp;rsquo;ll do in this game, quickly testing each iteration before moving on to the next one.</source>
          <target state="translated">El comando de &lt;code&gt;run&lt;/code&gt; es &amp;uacute;til cuando necesita iterar r&amp;aacute;pidamente en un proyecto, como lo haremos en este juego, probando r&amp;aacute;pidamente cada iteraci&amp;oacute;n antes de pasar a la siguiente.</target>
        </trans-unit>
        <trans-unit id="46e85b1a08cc19eee77379933feec0b53082268f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run&lt;/code&gt; function definition</source>
          <target state="translated">La definici&amp;oacute;n de la funci&amp;oacute;n de &lt;code&gt;run&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5e5f409e03a8829700c6b7a5a46ab61b65379877" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run&lt;/code&gt; function now contains all the remaining logic from &lt;code&gt;main&lt;/code&gt;, starting from reading the file. The &lt;code&gt;run&lt;/code&gt; function takes the &lt;code&gt;Config&lt;/code&gt; instance as an argument.</source>
          <target state="translated">La funci&amp;oacute;n de &lt;code&gt;run&lt;/code&gt; ahora contiene toda la l&amp;oacute;gica restante de &lt;code&gt;main&lt;/code&gt; , comenzando por leer el archivo. La funci&amp;oacute;n de &lt;code&gt;run&lt;/code&gt; toma la instancia de &lt;code&gt;Config&lt;/code&gt; como argumento.</target>
        </trans-unit>
        <trans-unit id="6fc1541b8f6585c0ffe5cd745827dfb79f574e45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rustfmt&lt;/code&gt; tool reformats your code according to the community code style. Many collaborative projects use &lt;code&gt;rustfmt&lt;/code&gt; to prevent arguments about which style to use when writing Rust: everyone formats their code using the tool.</source>
          <target state="translated">La herramienta &lt;code&gt;rustfmt&lt;/code&gt; reformatea su c&amp;oacute;digo de acuerdo con el estilo del c&amp;oacute;digo de la comunidad. Muchos proyectos colaborativos usan &lt;code&gt;rustfmt&lt;/code&gt; para evitar discusiones sobre qu&amp;eacute; estilo usar al escribir Rust: todos formatean su c&amp;oacute;digo usando la herramienta.</target>
        </trans-unit>
        <trans-unit id="f41fbdae4087d677734daccb36bd68168ac22c54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;same_bucket&lt;/code&gt; function is passed references to two elements from the slice and must determine if the elements compare equal. The elements are passed in opposite order from their order in the slice, so if &lt;code&gt;same_bucket(a, b)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is moved at the end of the slice.</source>
          <target state="translated">A la funci&amp;oacute;n &lt;code&gt;same_bucket&lt;/code&gt; se le pasan referencias a dos elementos del segmento y debe determinar si los elementos se comparan igual. Los elementos se pasan en orden opuesto a su orden en el segmento, por lo que si &lt;code&gt;same_bucket(a, b)&lt;/code&gt; devuelve &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; se mueve al final del segmento.</target>
        </trans-unit>
        <trans-unit id="51106981f7e1a09193991d8a2ebd9672888c0e0a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;same_bucket&lt;/code&gt; function is passed references to two elements from the vector and must determine if the elements compare equal. The elements are passed in opposite order from their order in the slice, so if &lt;code&gt;same_bucket(a, b)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is removed.</source>
          <target state="translated">A la funci&amp;oacute;n &lt;code&gt;same_bucket&lt;/code&gt; se le pasan referencias a dos elementos del vector y debe determinar si los elementos se comparan igual. Los elementos se pasan en orden opuesto a su orden en el segmento, por lo que si &lt;code&gt;same_bucket(a, b)&lt;/code&gt; devuelve &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; se elimina.</target>
        </trans-unit>
        <trans-unit id="a14ee345d1496dff6fbc5e218ae3b33c17f09dd5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;search_case_insensitive&lt;/code&gt; function, shown in Listing 12-21, will be almost the same as the &lt;code&gt;search&lt;/code&gt; function. The only difference is that we&amp;rsquo;ll lowercase the &lt;code&gt;query&lt;/code&gt; and each &lt;code&gt;line&lt;/code&gt; so whatever the case of the input arguments, they&amp;rsquo;ll be the same case when we check whether the line contains the query.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;search_case_insensitive&lt;/code&gt; , que se muestra en el Listado 12-21, ser&amp;aacute; casi la misma que la funci&amp;oacute;n de &lt;code&gt;search&lt;/code&gt; . La &amp;uacute;nica diferencia es que pondremos en min&amp;uacute;sculas la &lt;code&gt;query&lt;/code&gt; y cada &lt;code&gt;line&lt;/code&gt; por lo que cualquiera que sea el caso de los argumentos de entrada, ser&amp;aacute;n el mismo caso cuando verifiquemos si la l&amp;iacute;nea contiene la consulta.</target>
        </trans-unit>
        <trans-unit id="bbcc387564e51cca06178b88f2766991af78a4d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; crate may be imported which creates a binding to the current crate. In this case the &lt;code&gt;as&lt;/code&gt; clause must be used to specify the name to bind it to.</source>
          <target state="translated">La caja &lt;code&gt;self&lt;/code&gt; se puede importar, lo que crea un v&amp;iacute;nculo con la caja actual. En este caso &lt;code&gt;as&lt;/code&gt; debe utilizar la cl&amp;aacute;usula as para especificar el nombre al que enlazar.</target>
        </trans-unit>
        <trans-unit id="5df3512b09c8677b58f509f70a4092543dbb8630" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; import appears more than once in the list.</source>
          <target state="translated">La &lt;code&gt;self&lt;/code&gt; aparece m&amp;aacute;s de una vez en la lista.</target>
        </trans-unit>
        <trans-unit id="776137337eaf5141c6cf75f1ef731869806d23fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; keyword can only be used inside methods, which are associated functions (functions defined inside of a &lt;code&gt;trait&lt;/code&gt; or &lt;code&gt;impl&lt;/code&gt; block) that have a &lt;code&gt;self&lt;/code&gt; receiver as its first parameter, like &lt;code&gt;self&lt;/code&gt;, &lt;code&gt;&amp;amp;self&lt;/code&gt;, &lt;code&gt;&amp;amp;mut self&lt;/code&gt; or &lt;code&gt;self: &amp;amp;mut Pin&amp;lt;Self&amp;gt;&lt;/code&gt; (this last one is an example of an &lt;a href=&quot;https://github.com/rust-lang/rust/issues/44874&quot;&gt;&quot;abitrary &lt;code&gt;self&lt;/code&gt; type&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31848a0c1be52494be53b5a9553dbe8630cef51b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; keyword can only be used inside methods, which are associated functions (functions defined inside of a &lt;code&gt;trait&lt;/code&gt; or &lt;code&gt;impl&lt;/code&gt; block) that have a &lt;code&gt;self&lt;/code&gt; receiver as its first parameter, like &lt;code&gt;self&lt;/code&gt;, &lt;code&gt;&amp;amp;self&lt;/code&gt;, &lt;code&gt;&amp;amp;mut self&lt;/code&gt; or &lt;code&gt;self: &amp;amp;mut Pin&amp;lt;Self&amp;gt;&lt;/code&gt; (this last one is an example of an &lt;a href=&quot;https://github.com/rust-lang/rust/issues/44874&quot;&gt;&quot;arbitrary &lt;code&gt;self&lt;/code&gt; type&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca20974e52a0607307348bb19d0d894eb2389060" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; keyword cannot appear alone as the last segment in a &lt;code&gt;use&lt;/code&gt; declaration.</source>
          <target state="translated">La palabra clave &lt;code&gt;self&lt;/code&gt; no puede aparecer sola como &amp;uacute;ltimo segmento en una declaraci&amp;oacute;n de &lt;code&gt;use&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3baa95a2b4735c8ad9eb06f47e895376f593ffa3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; keyword was used in a static method.</source>
          <target state="translated">La palabra clave &lt;code&gt;self&lt;/code&gt; se utiliz&amp;oacute; en un m&amp;eacute;todo est&amp;aacute;tico.</target>
        </trans-unit>
        <trans-unit id="a9568dcdfe3a23be1dee117543923d717013ab13" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; keyword was used inside of an associated function without a &quot;&lt;code&gt;self&lt;/code&gt; receiver&quot; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f67620c2fbc5330097742f848b2b9886ad0ef4ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; parameter in a method has an invalid &quot;receiver type&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71e55d8484323ba680a4d79f359c6a8e4726809e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sent_messages&lt;/code&gt; field is now of type &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; instead of &lt;code&gt;Vec&amp;lt;String&amp;gt;&lt;/code&gt;. In the &lt;code&gt;new&lt;/code&gt; function, we create a new &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; instance around the empty vector.</source>
          <target state="translated">El campo &lt;code&gt;sent_messages&lt;/code&gt; ahora es de tipo &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; lugar de &lt;code&gt;Vec&amp;lt;String&amp;gt;&lt;/code&gt; . En la &lt;code&gt;new&lt;/code&gt; funci&amp;oacute;n, creamos una nueva &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; alrededor del vector vac&amp;iacute;o.</target>
        </trans-unit>
        <trans-unit id="337c62942744e545dcf717c6319edbedc18f313b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shoes_in_my_size&lt;/code&gt; function takes ownership of a vector of shoes and a shoe size as parameters. It returns a vector containing only shoes of the specified size.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;shoes_in_my_size&lt;/code&gt; toma posesi&amp;oacute;n de un vector de zapatos y un tama&amp;ntilde;o de zapato como par&amp;aacute;metros. Devuelve un vector que contiene solo zapatos del tama&amp;ntilde;o especificado.</target>
        </trans-unit>
        <trans-unit id="16a60caa064b42a78f27eb4d74ff02e2b3b32b36" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;should_panic&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;should_panic&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="639f1b128b2e8340c54ba2df925fcc505b0aa67b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;should_panic&lt;/code&gt; attribute may optionally take an input string that must appear within the panic message. If the string is not found in the message, then the test will fail. The string may be passed using the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax or the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; syntax with an &lt;code&gt;expected&lt;/code&gt; field.</source>
          <target state="translated">El atributo &lt;code&gt;should_panic&lt;/code&gt; puede tomar opcionalmente una cadena de entrada que debe aparecer dentro del mensaje de p&amp;aacute;nico. Si la cadena no se encuentra en el mensaje, la prueba fallar&amp;aacute;. La cadena se puede pasar usando la sintaxis &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; o la sintaxis &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; con un campo &lt;code&gt;expected&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47db49dacc0e9fe0c5ab4b84de0a525fbcc167ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;simd_shuffle&lt;/code&gt; function needs the length of the array passed as last parameter in its name. Example:</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;simd_shuffle&lt;/code&gt; necesita la longitud de la matriz pasada como &amp;uacute;ltimo par&amp;aacute;metro en su nombre. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="1728894948cd279e5a554b1af44ad631d3c73ca8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;spawn&lt;/code&gt; function returns a &lt;code&gt;JoinHandle&amp;lt;T&amp;gt;&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is the type that the closure returns. Let&amp;rsquo;s try using &lt;code&gt;JoinHandle&lt;/code&gt; too and see what happens. In our case, the closures we&amp;rsquo;re passing to the thread pool will handle the connection and not return anything, so &lt;code&gt;T&lt;/code&gt; will be the unit type &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">Los &lt;code&gt;spawn&lt;/code&gt; funci&amp;oacute;n devuelve un &lt;code&gt;JoinHandle&amp;lt;T&amp;gt;&lt;/code&gt; , en donde &lt;code&gt;T&lt;/code&gt; es el tipo que los rendimientos de cierre. Intentemos usar &lt;code&gt;JoinHandle&lt;/code&gt; tambi&amp;eacute;n y veamos qu&amp;eacute; sucede. En nuestro caso, los cierres que estamos pasando al grupo de subprocesos manejar&amp;aacute;n la conexi&amp;oacute;n y no devolver&amp;aacute;n nada, por lo que &lt;code&gt;T&lt;/code&gt; ser&amp;aacute; el tipo de unidad &lt;code&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="566807adf1a1b2e0676b75e750b724f0403f4cce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;src&lt;/code&gt; path is not a file or doesn't exist.</source>
          <target state="translated">La ruta &lt;code&gt;src&lt;/code&gt; no es un archivo o no existe.</target>
        </trans-unit>
        <trans-unit id="8b80b9ca4d5b5301222f74ba4e7cb474c1a9b0c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start..&lt;/code&gt; syntax is a &lt;code&gt;RangeFrom&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d29bbe16c04fa990f15f7ad6e1fd231be48fb8e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start..=end&lt;/code&gt; syntax is a &lt;code&gt;RangeInclusive&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f551a983bf25bb9ca332d4bf79a3c5ffe5eff531" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start..end&lt;/code&gt; syntax is a &lt;code&gt;Range&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07635229348f3268d25fca1958c374b441ce892b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; function was defined with a where clause.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a73480c4afd7847e00e31fe3aafec20a20c54b25" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;static&lt;/code&gt; keyword, on the other hand, guarantees a fixed location in memory. This does not always mean that the value is constant. For example, a global mutex can be declared &lt;code&gt;static&lt;/code&gt; as well.</source>
          <target state="translated">La palabra clave &lt;code&gt;static&lt;/code&gt; , por otro lado, garantiza una ubicaci&amp;oacute;n fija en la memoria. Esto no siempre significa que el valor sea constante. Por ejemplo, un mutex global tambi&amp;eacute;n puede declararse &lt;code&gt;static&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d33afa111381148e1c91bd2523fbea89118180e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::env&lt;/code&gt; module contains many more useful features for dealing with environment variables: check out its documentation to see what is available.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;code&gt;std::env&lt;/code&gt; contiene muchas m&amp;aacute;s funciones &amp;uacute;tiles para tratar con variables de entorno: consulte su documentaci&amp;oacute;n para ver qu&amp;eacute; hay disponible.</target>
        </trans-unit>
        <trans-unit id="bcaf28a16adceb8447193d5235bef5d8bd3335ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::io&lt;/code&gt; module contains a number of common things you'll need when doing input and output. The most core part of this module is the &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt; traits, which provide the most general interface for reading and writing input and output.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;code&gt;std::io&lt;/code&gt; contiene una serie de cosas comunes que necesitar&amp;aacute; al hacer entrada y salida. La parte fundamental de este m&amp;oacute;dulo son las caracter&amp;iacute;sticas de &lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt; , que proporcionan la interfaz m&amp;aacute;s general para la lectura y escritura de entrada y salida.</target>
        </trans-unit>
        <trans-unit id="4a54af6bd4d1bf95ed93c13cd61787ff3a49ae58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::mem::drop&lt;/code&gt; function is different from the &lt;code&gt;drop&lt;/code&gt; method in the &lt;code&gt;Drop&lt;/code&gt; trait. We call it by passing the value we want to force to be dropped early as an argument. The function is in the prelude, so we can modify &lt;code&gt;main&lt;/code&gt; in Listing 15-15 to call the &lt;code&gt;drop&lt;/code&gt; function, as shown in Listing 15-16:</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;std::mem::drop&lt;/code&gt; es diferente del m&amp;eacute;todo &lt;code&gt;drop&lt;/code&gt; en el rasgo &lt;code&gt;Drop&lt;/code&gt; . Lo llamamos pasando el valor que queremos forzar para que se elimine antes como argumento. La funci&amp;oacute;n est&amp;aacute; en el preludio, por lo que podemos modificar &lt;code&gt;main&lt;/code&gt; en el Listado 15-15 para llamar a la funci&amp;oacute;n &lt;code&gt;drop&lt;/code&gt; , como se muestra en el Listado 15-16:</target>
        </trans-unit>
        <trans-unit id="964c58feb2d7a0e4b6c63c315388a37636bb2ffa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;steps_between&lt;/code&gt; function provides a way to efficiently compare two &lt;code&gt;Step&lt;/code&gt; objects.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;steps_between&lt;/code&gt; proporciona una forma de comparar eficientemente dos objetos &lt;code&gt;Step&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d6948e046aa3d769d70c7d7f5831db7b61d283e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;str&lt;/code&gt; type, also called a 'string slice', is the most primitive string type. It is usually seen in its borrowed form, &lt;code&gt;&amp;amp;str&lt;/code&gt;. It is also the type of string literals, &lt;code&gt;&amp;amp;'static str&lt;/code&gt;.</source>
          <target state="translated">El tipo &lt;code&gt;str&lt;/code&gt; , tambi&amp;eacute;n llamado 'segmento de cadena', es el tipo de cadena m&amp;aacute;s primitivo. Suele verse en su forma prestada, &lt;code&gt;&amp;amp;str&lt;/code&gt; . Tambi&amp;eacute;n es el tipo de cadenas literales, &lt;code&gt;&amp;amp;'static str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ea4c33d08beaf7c17c84c4930138d5a7a1f80fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;stringify!&lt;/code&gt; macro used here is built into Rust. It takes a Rust expression, such as &lt;code&gt;1 + 2&lt;/code&gt;, and at compile time turns the expression into a string literal, such as &lt;code&gt;&quot;1 + 2&quot;&lt;/code&gt;. This is different than &lt;code&gt;format!&lt;/code&gt; or &lt;code&gt;println!&lt;/code&gt;, macros which evaluate the expression and then turn the result into a &lt;code&gt;String&lt;/code&gt;. There is a possibility that the &lt;code&gt;#name&lt;/code&gt; input might be an expression to print literally, so we use &lt;code&gt;stringify!&lt;/code&gt;. Using &lt;code&gt;stringify!&lt;/code&gt; also saves an allocation by converting &lt;code&gt;#name&lt;/code&gt; to a string literal at compile time.</source>
          <target state="translated">&amp;iexcl;La &lt;code&gt;stringify!&lt;/code&gt; La macro utilizada aqu&amp;iacute; est&amp;aacute; integrada en Rust. Toma una expresi&amp;oacute;n de Rust, como &lt;code&gt;1 + 2&lt;/code&gt; , y en tiempo de compilaci&amp;oacute;n convierte la expresi&amp;oacute;n en una cadena literal, como &lt;code&gt;&quot;1 + 2&quot;&lt;/code&gt; . &amp;iexcl;Esto es diferente al &lt;code&gt;format!&lt;/code&gt; o &lt;code&gt;println!&lt;/code&gt; , macros que eval&amp;uacute;an la expresi&amp;oacute;n y luego convierten el resultado en una &lt;code&gt;String&lt;/code&gt; . Existe la posibilidad de que la entrada &lt;code&gt;#name&lt;/code&gt; sea ​​una expresi&amp;oacute;n para imprimir literalmente, &amp;iexcl;as&amp;iacute; que usamos &lt;code&gt;stringify!&lt;/code&gt; . Usando &lt;code&gt;stringify!&lt;/code&gt; tambi&amp;eacute;n guarda una asignaci&amp;oacute;n al convertir &lt;code&gt;#name&lt;/code&gt; en una cadena literal en tiempo de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="5e2bbf89c9d53502f02966909193300b8b8e39a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;syn&lt;/code&gt; crate parses Rust code from a string into a data structure that we can perform operations on. The &lt;code&gt;quote&lt;/code&gt; crate turns &lt;code&gt;syn&lt;/code&gt; data structures back into Rust code. These crates make it much simpler to parse any sort of Rust code we might want to handle: writing a full parser for Rust code is no simple task.</source>
          <target state="translated">La &lt;code&gt;syn&lt;/code&gt; analiza el c&amp;oacute;digo Rust de una cadena en una estructura de datos en la que podemos realizar operaciones. La caja de &lt;code&gt;quote&lt;/code&gt; convierte las estructuras de datos de &lt;code&gt;syn&lt;/code&gt; en c&amp;oacute;digo Rust. Estas cajas hacen que sea mucho m&amp;aacute;s sencillo analizar cualquier tipo de c&amp;oacute;digo Rust que queramos manejar: escribir un analizador completo para el c&amp;oacute;digo Rust no es una tarea sencilla.</target>
        </trans-unit>
        <trans-unit id="4c2f6cfbefda1dc3521b2af3bf1923ea6ba12d89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;take&lt;/code&gt; method is defined in the &lt;code&gt;Iterator&lt;/code&gt; trait and limits the iteration to the first two items at most. The &lt;code&gt;ThreadPool&lt;/code&gt; will go out of scope at the end of &lt;code&gt;main&lt;/code&gt;, and the &lt;code&gt;drop&lt;/code&gt; implementation will run.</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;take&lt;/code&gt; se define en el rasgo &lt;code&gt;Iterator&lt;/code&gt; y limita la iteraci&amp;oacute;n a los dos primeros elementos como m&amp;aacute;ximo. El &lt;code&gt;ThreadPool&lt;/code&gt; ir&amp;aacute; fuera de alcance al final del &lt;code&gt;main&lt;/code&gt; , y la &lt;code&gt;drop&lt;/code&gt; la aplicaci&amp;oacute;n se ejecutar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="f4261b148ae0a22c8791698e09a2d9939e795de1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;target_feature&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;target_feature&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0bfa2ee4e02addd4c71ab19bd1f7c85cc21dadfe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;test&lt;/code&gt; attribute</source>
          <target state="translated">El atributo de &lt;code&gt;test&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c6b28a9d1db605fca4af25fdaf7d2f63f3f4ff7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;track_caller&lt;/code&gt; attribute may be applied to any function with &lt;a href=&quot;../items/external-blocks#abi&quot;&gt;&lt;code&gt;&quot;Rust&quot;&lt;/code&gt; ABI&lt;/a&gt; with the exception of the entry point &lt;code&gt;fn main&lt;/code&gt;. When applied to functions and methods in trait declarations, the attribute applies to all implementations. If the trait provides a default implementation with the attribute, then the attribute also applies to override implementations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbbce8f10ed8de46d53a88134091400a4cad8f24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transparent&lt;/code&gt; Representation</source>
          <target state="translated">La Representaci&amp;oacute;n &lt;code&gt;transparent&lt;/code&gt; e</target>
        </trans-unit>
        <trans-unit id="16cfac7d668a26094fafdea930dd55dadb7672de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transparent&lt;/code&gt; representation can only be used on &lt;code&gt;struct&lt;/code&gt;s that have a single non-zero sized field and any number of zero-sized fields, including &lt;a href=&quot;special-types-and-traits#phantomdatat&quot;&gt;&lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La representaci&amp;oacute;n &lt;code&gt;transparent&lt;/code&gt; e solo se puede usar en &lt;code&gt;struct&lt;/code&gt; que tienen un solo campo de tama&amp;ntilde;o distinto de cero y cualquier n&amp;uacute;mero de campos de tama&amp;ntilde;o cero, incluido &lt;a href=&quot;special-types-and-traits#phantomdatat&quot;&gt; &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="811b48cd1ea2c8f7773b17e401a6ef4a6664ee6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transparent&lt;/code&gt; representation can only be used on a &lt;a href=&quot;items/structs&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt;&lt;/a&gt; with a single variant that has:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d7d7afaf943b9e9b10757db03a01818240c2c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try_recv&lt;/code&gt; method doesn&amp;rsquo;t block, but will instead return a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; immediately: an &lt;code&gt;Ok&lt;/code&gt; value holding a message if one is available and an &lt;code&gt;Err&lt;/code&gt; value if there aren&amp;rsquo;t any messages this time. Using &lt;code&gt;try_recv&lt;/code&gt; is useful if this thread has other work to do while waiting for messages: we could write a loop that calls &lt;code&gt;try_recv&lt;/code&gt; every so often, handles a message if one is available, and otherwise does other work for a little while until checking again.</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;try_recv&lt;/code&gt; no bloquea, sino que devolver&amp;aacute; un &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; inmediatamente: un valor &lt;code&gt;Ok&lt;/code&gt; que contiene un mensaje si hay uno disponible y un valor &lt;code&gt;Err&lt;/code&gt; si no hay ning&amp;uacute;n mensaje esta vez. Usar &lt;code&gt;try_recv&lt;/code&gt; es &amp;uacute;til si este hilo tiene otro trabajo que hacer mientras espera mensajes: podr&amp;iacute;amos escribir un bucle que llame a &lt;code&gt;try_recv&lt;/code&gt; de vez en cuando, maneje un mensaje si hay uno disponible y, de lo contrario, hace otro trabajo por un tiempo hasta que vuelva a verificar.</target>
        </trans-unit>
        <trans-unit id="1c06a34327e19720b6fdb343c408e7c55dd84e16" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type Target = T;&lt;/code&gt; syntax defines an associated type for the &lt;code&gt;Deref&lt;/code&gt; trait to use. Associated types are a slightly different way of declaring a generic parameter, but you don&amp;rsquo;t need to worry about them for now; we&amp;rsquo;ll cover them in more detail in Chapter 19.</source>
          <target state="translated">El &lt;code&gt;type Target = T;&lt;/code&gt; la sintaxis define un tipo asociado para el &lt;code&gt;Deref&lt;/code&gt; rasgo Deref . Los tipos asociados son una forma ligeramente diferente de declarar un par&amp;aacute;metro gen&amp;eacute;rico, pero no necesita preocuparse por ellos por ahora; los cubriremos con m&amp;aacute;s detalle en el Cap&amp;iacute;tulo 19.</target>
        </trans-unit>
        <trans-unit id="ed8f6c9e0893fd91a5e6d611722172ed9ef6f6c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type_length_limit&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;type_length_limit&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="88b76f9ce33c0af8e240ed6b37ada9e83ea43da5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typeof&lt;/code&gt; keyword is currently reserved but unimplemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7495ddf8e7dd908218ee8fe0115f879a8fb5ec94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typeof&lt;/code&gt; keyword is currently reserved but unimplemented. Erroneous code example:</source>
          <target state="translated">La &lt;code&gt;typeof&lt;/code&gt; clave typeof est&amp;aacute; actualmente reservada pero no implementada. Ejemplo de c&amp;oacute;digo err&amp;oacute;neo:</target>
        </trans-unit>
        <trans-unit id="dd3cfc211f63708e7ec9409ea2198c30928717cb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; keyword has two uses: to declare the existence of contracts the compiler can't check (&lt;code&gt;unsafe fn&lt;/code&gt; and &lt;code&gt;unsafe trait&lt;/code&gt;), and to declare that a programmer has checked that these contracts have been upheld (&lt;code&gt;unsafe {}&lt;/code&gt; and &lt;code&gt;unsafe impl&lt;/code&gt;, but also &lt;code&gt;unsafe fn&lt;/code&gt; -- see below). They are not mutually exclusive, as can be seen in &lt;code&gt;unsafe fn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3bcdab50b34b5e5716db8fd4a0ee45ad2abea8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; keyword is syntactically allowed to appear before the &lt;code&gt;extern&lt;/code&gt; keyword, but it is rejected at a semantic level. This allows macros to consume the syntax and make use of the &lt;code&gt;unsafe&lt;/code&gt; keyword, before removing it from the token stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="205e3b2923533eb22d4e09801e3f784e668f24fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; keyword is syntactically allowed to appear before the &lt;code&gt;mod&lt;/code&gt; keyword, but it is rejected at a semantic level. This allows macros to consume the syntax and make use of the &lt;code&gt;unsafe&lt;/code&gt; keyword, before removing it from the token stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a346e1081bfa2911e1aa0fde6117ab4a081928a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; qualifier indicates that the type's value is an &lt;a href=&quot;../unsafe-functions&quot;&gt;unsafe function&lt;/a&gt;, and the &lt;code&gt;extern&lt;/code&gt; qualifier indicates it is an &lt;a href=&quot;../items/functions#extern-function-qualifier&quot;&gt;extern function&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="994e471fd3da940319d1417edcfca60d6a3db828" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; qualifier indicates that the type's value is an &lt;a href=&quot;../unsafe-functions&quot;&gt;unsafe function&lt;/a&gt;, and the &lt;code&gt;extern&lt;/code&gt; qualifier indicates it is an &lt;a href=&quot;../items/functions#extern-functions&quot;&gt;extern function&lt;/a&gt;.</source>
          <target state="translated">El calificador &lt;code&gt;unsafe&lt;/code&gt; indica que el valor del tipo es una &lt;a href=&quot;../unsafe-functions&quot;&gt;funci&amp;oacute;n insegura&lt;/a&gt; y el calificador &lt;code&gt;extern&lt;/code&gt; o indica que es una &lt;a href=&quot;../items/functions#extern-functions&quot;&gt;funci&amp;oacute;n externa&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="78ba9e0cc65cc7840eaadd16f98f7cca440cd4f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unwind&lt;/code&gt; attribute was malformed.</source>
          <target state="translated">El atributo de &lt;code&gt;unwind&lt;/code&gt; estaba mal formado.</target>
        </trans-unit>
        <trans-unit id="a60fd78a94b551f1746c4a391dd52899994edd99" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;used&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;used&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="762cbbe7d454d7148fa1b85ecdd6dd222c5646ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;usize&lt;/code&gt; type is an unsigned integer type with the same number of bits as the platform's pointer type. It can represent every memory address in the process.</source>
          <target state="translated">El tipo &lt;code&gt;usize&lt;/code&gt; es un tipo entero sin signo con el mismo n&amp;uacute;mero de bits que el tipo de puntero de la plataforma. Puede representar cada direcci&amp;oacute;n de memoria en el proceso.</target>
        </trans-unit>
        <trans-unit id="ca7074c2679596c96e2d40f1a9e7060f1f83b71a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; field is of type &lt;code&gt;Option&amp;lt;u32&amp;gt;&lt;/code&gt;. Before we execute the closure, &lt;code&gt;value&lt;/code&gt; will be &lt;code&gt;None&lt;/code&gt;. When code using a &lt;code&gt;Cacher&lt;/code&gt; asks for the &lt;em&gt;result&lt;/em&gt; of the closure, the &lt;code&gt;Cacher&lt;/code&gt; will execute the closure at that time and store the result within a &lt;code&gt;Some&lt;/code&gt; variant in the &lt;code&gt;value&lt;/code&gt; field. Then if the code asks for the result of the closure again, instead of executing the closure again, the &lt;code&gt;Cacher&lt;/code&gt; will return the result held in the &lt;code&gt;Some&lt;/code&gt; variant.</source>
          <target state="translated">El campo de &lt;code&gt;value&lt;/code&gt; es de tipo &lt;code&gt;Option&amp;lt;u32&amp;gt;&lt;/code&gt; . Antes de ejecutar el cierre, el &lt;code&gt;value&lt;/code&gt; ser&amp;aacute; &lt;code&gt;None&lt;/code&gt; . Cuando el c&amp;oacute;digo que usa un &lt;code&gt;Cacher&lt;/code&gt; solicita el &lt;em&gt;resultado&lt;/em&gt; del cierre, el &lt;code&gt;Cacher&lt;/code&gt; ejecutar&amp;aacute; el cierre en ese momento y almacenar&amp;aacute; el resultado dentro de una variante &lt;code&gt;Some&lt;/code&gt; en el campo de &lt;code&gt;value&lt;/code&gt; . Luego, si el c&amp;oacute;digo solicita el resultado del cierre nuevamente, en lugar de ejecutar el cierre nuevamente, el &lt;code&gt;Cacher&lt;/code&gt; devolver&amp;aacute; el resultado contenido en la variante &lt;code&gt;Some&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5defa2a7e24b93d29be444c6bce3655062b73aee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vtable&lt;/code&gt; customizes the behavior of a &lt;code&gt;Waker&lt;/code&gt; which gets created from a &lt;code&gt;RawWaker&lt;/code&gt;. For each operation on the &lt;code&gt;Waker&lt;/code&gt;, the associated function in the &lt;code&gt;vtable&lt;/code&gt; of the underlying &lt;code&gt;RawWaker&lt;/code&gt; will be called.</source>
          <target state="translated">La &lt;code&gt;vtable&lt;/code&gt; personaliza el comportamiento de un &lt;code&gt;Waker&lt;/code&gt; que se crea a partir de un &lt;code&gt;RawWaker&lt;/code&gt; . Para cada operaci&amp;oacute;n en el &lt;code&gt;Waker&lt;/code&gt; , se llamar&amp;aacute; a la funci&amp;oacute;n asociada en la &lt;code&gt;vtable&lt;/code&gt; del &lt;code&gt;RawWaker&lt;/code&gt; subyacente .</target>
        </trans-unit>
        <trans-unit id="58deddf572f1c05716c0aff255109ee68c618f77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;wasm_import_module&lt;/code&gt; key may be used to specify the &lt;a href=&quot;https://webassembly.github.io/spec/core/syntax/modules.html&quot;&gt;WebAssembly module&lt;/a&gt; name for the items within an &lt;code&gt;extern&lt;/code&gt; block when importing symbols from the host environment. The default module name is &lt;code&gt;env&lt;/code&gt; if &lt;code&gt;wasm_import_module&lt;/code&gt; is not specified.</source>
          <target state="translated">La clave &lt;code&gt;wasm_import_module&lt;/code&gt; se puede utilizar para especificar el nombre del &lt;a href=&quot;https://webassembly.github.io/spec/core/syntax/modules.html&quot;&gt;m&amp;oacute;dulo WebAssembly&lt;/a&gt; para los elementos dentro de un bloque &lt;code&gt;extern&lt;/code&gt; o al importar s&amp;iacute;mbolos del entorno host. El nombre del m&amp;oacute;dulo predeterminado es &lt;code&gt;env&lt;/code&gt; si no se especifica &lt;code&gt;wasm_import_module&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03b2e1ae71fdcbd9ffac8eca408ab8d4e8472f94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;, and &lt;code&gt;label&lt;/code&gt; fields on &lt;code&gt;Button&lt;/code&gt; will differ from the fields on other components, such as a &lt;code&gt;TextField&lt;/code&gt; type, that might have those fields plus a &lt;code&gt;placeholder&lt;/code&gt; field instead. Each of the types we want to draw on the screen will implement the &lt;code&gt;Draw&lt;/code&gt; trait but will use different code in the &lt;code&gt;draw&lt;/code&gt; method to define how to draw that particular type, as &lt;code&gt;Button&lt;/code&gt; has here (without the actual GUI code, which is beyond the scope of this chapter). The &lt;code&gt;Button&lt;/code&gt; type, for instance, might have an additional &lt;code&gt;impl&lt;/code&gt; block containing methods related to what happens when a user clicks the button. These kinds of methods won&amp;rsquo;t apply to types like &lt;code&gt;TextField&lt;/code&gt;.</source>
          <target state="translated">Los campos de &lt;code&gt;width&lt;/code&gt; , &lt;code&gt;height&lt;/code&gt; y &lt;code&gt;label&lt;/code&gt; en &lt;code&gt;Button&lt;/code&gt; ser&amp;aacute;n diferentes de los campos en otros componentes, como un tipo &lt;code&gt;TextField&lt;/code&gt; , que podr&amp;iacute;an tener esos campos m&amp;aacute;s un campo de &lt;code&gt;placeholder&lt;/code&gt; lugar. Cada uno de los tipos que queremos dibujar en la pantalla implementar&amp;aacute; el rasgo &lt;code&gt;Draw&lt;/code&gt; , pero usar&amp;aacute; un c&amp;oacute;digo diferente en el m&amp;eacute;todo de &lt;code&gt;draw&lt;/code&gt; para definir c&amp;oacute;mo dibujar ese tipo en particular, como &lt;code&gt;Button&lt;/code&gt; tiene aqu&amp;iacute; (sin el c&amp;oacute;digo GUI real, que est&amp;aacute; m&amp;aacute;s all&amp;aacute; del alcance de este cap&amp;iacute;tulo). El tipo de &lt;code&gt;Button&lt;/code&gt; , por ejemplo, puede tener una &lt;code&gt;impl&lt;/code&gt; icaci&amp;oacute;n adicionalbloque que contiene m&amp;eacute;todos relacionados con lo que sucede cuando un usuario hace clic en el bot&amp;oacute;n. Este tipo de m&amp;eacute;todos no se aplicar&amp;aacute; a tipos como &lt;code&gt;TextField&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49fef96b0756f10c5fd5c7fedcccb9ee963b501d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;windows_subsystem&lt;/code&gt; attribute</source>
          <target state="translated">El atributo &lt;code&gt;windows_subsystem&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe674a5495eedc22d7ae598194abec96fa238a33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;write&lt;/code&gt; function takes an output stream, and an &lt;code&gt;Arguments&lt;/code&gt; struct that can be precompiled with the &lt;code&gt;format_args!&lt;/code&gt; macro.</source>
          <target state="translated">La funci&amp;oacute;n de &lt;code&gt;write&lt;/code&gt; toma un flujo de salida y una estructura &lt;code&gt;Arguments&lt;/code&gt; que se puede precompilar con &lt;code&gt;format_args!&lt;/code&gt; macro.</target>
        </trans-unit>
        <trans-unit id="5644d7245fdec36266e15ee66f56202b01bc587d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;x&lt;/code&gt; part is a pattern! As we did with &lt;code&gt;let&lt;/code&gt;, we could match a tuple in a function&amp;rsquo;s arguments to the pattern. Listing 18-7 splits the values in a tuple as we pass it to a function.</source>
          <target state="translated">&amp;iexcl;La parte &lt;code&gt;x&lt;/code&gt; es un patr&amp;oacute;n! Como hicimos con &lt;code&gt;let&lt;/code&gt; , podr&amp;iacute;amos hacer coincidir una tupla en los argumentos de una funci&amp;oacute;n con el patr&amp;oacute;n. El listado 18-7 divide los valores de una tupla a medida que la pasamos a una funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="90c7cb6860c6df5927660a73f110e2f9166750a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;x&lt;/code&gt; value is moved into the closure when the closure is defined, because we added the &lt;code&gt;move&lt;/code&gt; keyword. The closure then has ownership of &lt;code&gt;x&lt;/code&gt;, and &lt;code&gt;main&lt;/code&gt; isn&amp;rsquo;t allowed to use &lt;code&gt;x&lt;/code&gt; anymore in the &lt;code&gt;println!&lt;/code&gt; statement. Removing &lt;code&gt;println!&lt;/code&gt; will fix this example.</source>
          <target state="translated">El valor &lt;code&gt;x&lt;/code&gt; se mueve al cierre cuando se define el cierre, porque agregamos la palabra clave &lt;code&gt;move&lt;/code&gt; . El cierre entonces tiene propiedad de &lt;code&gt;x&lt;/code&gt; , &amp;iexcl;y &lt;code&gt;main&lt;/code&gt; ya no puede usar &lt;code&gt;x&lt;/code&gt; en &lt;code&gt;println!&lt;/code&gt; declaraci&amp;oacute;n. Eliminando &lt;code&gt;println!&lt;/code&gt; arreglar&amp;aacute; este ejemplo.</target>
        </trans-unit>
        <trans-unit id="693d3b957625a8e3df8f4384a832c7be5cfa15d0" translate="yes" xml:space="preserve">
          <source>The &lt;em id=&quot;the-tests-directory&quot;&gt;tests&lt;/em&gt; Directory</source>
          <target state="translated">El directorio de &lt;em id=&quot;the-tests-directory&quot;&gt;pruebas&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2382217293f35827ef839ef57a6e0636f3faa56f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;automatically_derived&lt;/code&gt; attribute&lt;/em&gt; is automatically added to &lt;a href=&quot;../items/implementations&quot;&gt;implementations&lt;/a&gt; created by the &lt;code&gt;derive&lt;/code&gt; attribute for built-in traits. It has no direct effect, but it may be used by tools and diagnostic lints to detect these automatically generated implementations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d372f8b0a676dc2ae354b920b56c31e1ed0230f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;cold&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; suggests that the attributed function is unlikely to be called.</source>
          <target state="translated">El &lt;em&gt;&lt;a href=&quot;../attributes&quot;&gt;atributo &lt;/a&gt;&lt;/em&gt;&lt;em&gt; &lt;code&gt;cold&lt;/code&gt; &lt;/em&gt; sugiere que es poco probable que se llame a la funci&amp;oacute;n atribuida.</target>
        </trans-unit>
        <trans-unit id="c8dd94fd6bb692bd54e04ee95744533de367bad8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;crate_name&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; may be applied at the crate level to specify the name of the crate with the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax.</source>
          <target state="translated">El &lt;em&gt;&lt;a href=&quot;attributes&quot;&gt;atributo &lt;/a&gt;&lt;/em&gt;&lt;em&gt; &lt;code&gt;crate_name&lt;/code&gt; &lt;/em&gt; se puede aplicar al nivel de la caja para especificar el nombre de la caja con la sintaxis &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2db8e6439808a243c5fa24e648c2e0fab8ef4d83" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;deprecated&lt;/code&gt; attribute&lt;/em&gt; marks an item as deprecated. &lt;code&gt;rustc&lt;/code&gt; will issue warnings on usage of &lt;code&gt;#[deprecated]&lt;/code&gt; items. &lt;code&gt;rustdoc&lt;/code&gt; will show item deprecation, including the &lt;code&gt;since&lt;/code&gt; version and &lt;code&gt;note&lt;/code&gt;, if available.</source>
          <target state="translated">El &lt;em&gt;atributo &lt;/em&gt;&lt;em&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/em&gt; marca un art&amp;iacute;culo como obsoleto. &lt;code&gt;rustc&lt;/code&gt; emitir&amp;aacute; advertencias sobre el uso de &lt;code&gt;#[deprecated]&lt;/code&gt; . &lt;code&gt;rustdoc&lt;/code&gt; mostrar&amp;aacute; el art&amp;iacute;culo en desuso, incluida la versi&amp;oacute;n &lt;code&gt;since&lt;/code&gt; y la &lt;code&gt;note&lt;/code&gt; , si est&amp;aacute;n disponibles.</target>
        </trans-unit>
        <trans-unit id="fa15bab6a083f19d9ae9cd7eaa338e697eaf4832" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;derive&lt;/code&gt; attribute&lt;/em&gt; allows new &lt;a href=&quot;../items&quot;&gt;items&lt;/a&gt; to be automatically generated for data structures. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListPaths&lt;/em&gt;&lt;/a&gt; syntax to specify a list of traits to implement or paths to &lt;a href=&quot;../procedural-macros#derive-macros&quot;&gt;derive macros&lt;/a&gt; to process.</source>
          <target state="translated">El &lt;em&gt;atributo &lt;/em&gt;&lt;em&gt; &lt;code&gt;derive&lt;/code&gt; &lt;/em&gt; permite generar autom&amp;aacute;ticamente nuevos &lt;a href=&quot;../items&quot;&gt;elementos&lt;/a&gt; para las estructuras de datos. Utiliza la sintaxis &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListPaths&lt;/em&gt;&lt;/a&gt; para especificar una lista de rasgos para implementar o rutas para &lt;a href=&quot;../procedural-macros#derive-macros&quot;&gt;derivar macros&lt;/a&gt; para procesar.</target>
        </trans-unit>
        <trans-unit id="a97c3213ab817ab892d8f6e5c3157736e74b3b32" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;export_name&lt;/code&gt; attribute&lt;/em&gt; specifies the name of the symbol that will be exported on a &lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; or &lt;a href=&quot;items/static-items&quot;&gt;static&lt;/a&gt;. It uses the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the symbol name.</source>
          <target state="translated">El &lt;em&gt;atributo &lt;/em&gt;&lt;em&gt; &lt;code&gt;export_name&lt;/code&gt; &lt;/em&gt; especifica el nombre del s&amp;iacute;mbolo que se exportar&amp;aacute; en una &lt;a href=&quot;items/functions&quot;&gt;funci&amp;oacute;n&lt;/a&gt; o &lt;a href=&quot;items/static-items&quot;&gt;est&amp;aacute;tica&lt;/a&gt; . Utiliza la sintaxis &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; para especificar el nombre del s&amp;iacute;mbolo.</target>
        </trans-unit>
        <trans-unit id="9d1fbcf19af41adeefc0b92335ae4b007c4dadfa" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;global_allocator&lt;/code&gt; attribute&lt;/em&gt; is used on a &lt;a href=&quot;items/static-items&quot;&gt;static item&lt;/a&gt; implementing the &lt;a href=&quot;https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html&quot;&gt;&lt;code&gt;GlobalAlloc&lt;/code&gt;&lt;/a&gt; trait to set the global allocator.</source>
          <target state="translated">El &lt;em&gt;atributo &lt;/em&gt;&lt;em&gt; &lt;code&gt;global_allocator&lt;/code&gt; &lt;/em&gt; se utiliza en un &lt;a href=&quot;items/static-items&quot;&gt;elemento est&amp;aacute;tico que&lt;/a&gt; implementa el rasgo &lt;a href=&quot;https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html&quot;&gt; &lt;code&gt;GlobalAlloc&lt;/code&gt; &lt;/a&gt; para establecer el asignador global.</target>
        </trans-unit>
        <trans-unit id="eb4af8649334dd85e9ba7979a0a444e3961c900a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;inline&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; suggests that a copy of the attributed function should be placed in the caller, rather than generating code to call the function where it is defined.</source>
          <target state="translated">El &lt;em&gt;&lt;a href=&quot;../attributes&quot;&gt;atributo en &lt;/a&gt;&lt;/em&gt;&lt;em&gt; &lt;code&gt;inline&lt;/code&gt; &lt;/em&gt; sugiere que se debe colocar una copia de la funci&amp;oacute;n atribuida en el llamador, en lugar de generar c&amp;oacute;digo para llamar a la funci&amp;oacute;n donde est&amp;aacute; definida.</target>
        </trans-unit>
        <trans-unit id="1d9a7b1456b98dca1d8fed53edde3318db90e4c5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;link&lt;/code&gt; attribute&lt;/em&gt; specifies the name of a native library that the compiler should link with for the items within an &lt;code&gt;extern&lt;/code&gt; block. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify its inputs. The &lt;code&gt;name&lt;/code&gt; key is the name of the native library to link. The &lt;code&gt;kind&lt;/code&gt; key is an optional value which specifies the kind of library with the following possible values:</source>
          <target state="translated">El &lt;em&gt;atributo de &lt;/em&gt;&lt;em&gt; &lt;code&gt;link&lt;/code&gt; &lt;/em&gt; especifica el nombre de una biblioteca nativa con la que el compilador debe enlazar para los elementos dentro de un bloque &lt;code&gt;extern&lt;/code&gt; o . Utiliza la sintaxis &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; para especificar sus entradas. La clave de &lt;code&gt;name&lt;/code&gt; es el nombre de la biblioteca nativa a vincular. La clave &lt;code&gt;kind&lt;/code&gt; es un valor opcional que especifica el tipo de biblioteca con los siguientes valores posibles:</target>
        </trans-unit>
        <trans-unit id="6603167a8a5aa9df2deb989c68e33b760144ac17" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;link_section&lt;/code&gt; attribute&lt;/em&gt; specifies the section of the object file that a &lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; or &lt;a href=&quot;items/static-items&quot;&gt;static&lt;/a&gt;'s content will be placed into. It uses the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the section name.</source>
          <target state="translated">El &lt;em&gt;atributo &lt;/em&gt;&lt;em&gt; &lt;code&gt;link_section&lt;/code&gt; &lt;/em&gt; especifica la secci&amp;oacute;n del archivo de objeto en la que se colocar&amp;aacute; una &lt;a href=&quot;items/functions&quot;&gt;funci&amp;oacute;n&lt;/a&gt; o contenido &lt;a href=&quot;items/static-items&quot;&gt;est&amp;aacute;tico&lt;/a&gt; . Utiliza la sintaxis &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; para especificar el nombre de la secci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="806935dfacd2a07be8b57f073dcdf39509c2b1f7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;macro_use&lt;/code&gt; attribute&lt;/em&gt; has two purposes. First, it can be used to make a module's macro scope not end when the module is closed, by applying it to a module:</source>
          <target state="translated">El &lt;em&gt;atributo &lt;/em&gt;&lt;em&gt; &lt;code&gt;macro_use&lt;/code&gt; &lt;/em&gt; tiene dos prop&amp;oacute;sitos. Primero, se puede usar para hacer que el alcance de la macro de un m&amp;oacute;dulo no termine cuando el m&amp;oacute;dulo est&amp;aacute; cerrado, aplic&amp;aacute;ndolo a un m&amp;oacute;dulo:</target>
        </trans-unit>
        <trans-unit id="05f0042fe91a37001bd65ea0d74fd9143e55659c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;must_use&lt;/code&gt; attribute&lt;/em&gt; is used to issue a diagnostic warning when a value is not &quot;used&quot;. It can be applied to user-defined composite types (&lt;a href=&quot;../items/structs&quot;&gt;&lt;code&gt;struct&lt;/code&gt;s&lt;/a&gt;, &lt;a href=&quot;../items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt;s&lt;/a&gt;, and &lt;a href=&quot;../items/unions&quot;&gt;&lt;code&gt;union&lt;/code&gt;s&lt;/a&gt;), &lt;a href=&quot;../items/functions&quot;&gt;functions&lt;/a&gt;, and &lt;a href=&quot;../items/traits&quot;&gt;traits&lt;/a&gt;.</source>
          <target state="translated">El &lt;em&gt;atributo &lt;/em&gt;&lt;em&gt; &lt;code&gt;must_use&lt;/code&gt; &lt;/em&gt; se utiliza para emitir una advertencia de diagn&amp;oacute;stico cuando un valor no se &quot;utiliza&quot;. Se puede aplicar a los tipos definidos por el usuario compuestos ( &lt;a href=&quot;../items/structs&quot;&gt; &lt;code&gt;struct&lt;/code&gt; s&lt;/a&gt; , &lt;a href=&quot;../items/enumerations&quot;&gt; &lt;code&gt;enum&lt;/code&gt; s&lt;/a&gt; , y &lt;a href=&quot;../items/unions&quot;&gt; &lt;code&gt;union&lt;/code&gt; s&lt;/a&gt; ), &lt;a href=&quot;../items/functions&quot;&gt;funciones&lt;/a&gt; , y &lt;a href=&quot;../items/traits&quot;&gt;rasgos&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="df0d5b935c63e0d5d09ad34649237d79db006af9" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;no_builtins&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; may be applied at the crate level to disable optimizing certain code patterns to invocations of library functions that are assumed to exist.</source>
          <target state="translated">El &lt;em&gt;&lt;a href=&quot;../attributes&quot;&gt;atributo &lt;/a&gt;&lt;/em&gt;&lt;em&gt; &lt;code&gt;no_builtins&lt;/code&gt; &lt;/em&gt; se puede aplicar a nivel de caja para deshabilitar la optimizaci&amp;oacute;n de ciertos patrones de c&amp;oacute;digo para invocaciones de funciones de biblioteca que se supone que existen.</target>
        </trans-unit>
        <trans-unit id="1c5fb5c17e1ae5e93c491f3ff3864f7cf3700a82" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;no_link&lt;/code&gt; attribute&lt;/em&gt; may be specified on an &lt;code&gt;extern crate&lt;/code&gt; item to prevent linking the crate into the output. This is commonly used to load a crate to access only its macros.</source>
          <target state="translated">El &lt;em&gt;atributo &lt;/em&gt;&lt;em&gt; &lt;code&gt;no_link&lt;/code&gt; &lt;/em&gt; puede especificarse en un elemento de &lt;code&gt;extern crate&lt;/code&gt; para evitar vincular la caja a la salida. Esto se usa com&amp;uacute;nmente para cargar una caja para acceder solo a sus macros.</target>
        </trans-unit>
        <trans-unit id="a894d89850015842793e60fc8f351c2309ee5ef4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;no_main&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; may be applied at the crate level to disable emitting the &lt;code&gt;main&lt;/code&gt; symbol for an executable binary. This is useful when some other object being linked to defines &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">El &lt;em&gt;&lt;a href=&quot;attributes&quot;&gt;atributo &lt;/a&gt;&lt;/em&gt;&lt;em&gt; &lt;code&gt;no_main&lt;/code&gt; &lt;/em&gt; se puede aplicar a nivel de caja para inhabilitar la emisi&amp;oacute;n del s&amp;iacute;mbolo &lt;code&gt;main&lt;/code&gt; para un binario ejecutable. Esto es &amp;uacute;til cuando alg&amp;uacute;n otro objeto vinculado define &lt;code&gt;main&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3bcfb88f5c979d523b3f1a38c5f5b56a611b895" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;no_mangle&lt;/code&gt; attribute&lt;/em&gt; may be used on any &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; to disable standard symbol name mangling. The symbol for the item will be the identifier of the item's name.</source>
          <target state="translated">El &lt;em&gt;atributo &lt;/em&gt;&lt;em&gt; &lt;code&gt;no_mangle&lt;/code&gt; &lt;/em&gt; se puede utilizar en cualquier &lt;a href=&quot;items&quot;&gt;elemento&lt;/a&gt; para deshabilitar el cambio de nombre de s&amp;iacute;mbolo est&amp;aacute;ndar. El s&amp;iacute;mbolo del art&amp;iacute;culo ser&amp;aacute; el identificador del nombre del art&amp;iacute;culo.</target>
        </trans-unit>
        <trans-unit id="0bb656555b55ed7c2f8a3087c34efb6ed0ed4cf4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;non_exhaustive&lt;/code&gt; attribute&lt;/em&gt; indicates that a type or variant may have more fields or variants added in the future. It can be applied to &lt;a href=&quot;../items/structs&quot;&gt;&lt;code&gt;struct&lt;/code&gt;s&lt;/a&gt;, &lt;a href=&quot;../items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt;s&lt;/a&gt;, and &lt;code&gt;enum&lt;/code&gt; variants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53a982d72d2f0894ccb0ac1653ff149a9b51224c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;panic_handler&lt;/code&gt; attribute&lt;/em&gt; can only be applied to a function with signature &lt;code&gt;fn(&amp;amp;PanicInfo) -&amp;gt; !&lt;/code&gt;. The function marked with this &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; defines the behavior of panics. The &lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.PanicInfo.html&quot;&gt;&lt;code&gt;PanicInfo&lt;/code&gt;&lt;/a&gt; struct contains information about the location of the panic. There must be a single &lt;code&gt;panic_handler&lt;/code&gt; function in the dependency graph of a binary, dylib or cdylib crate.</source>
          <target state="translated">El &lt;em&gt;atributo &lt;/em&gt;&lt;em&gt; &lt;code&gt;panic_handler&lt;/code&gt; &lt;/em&gt; solo se puede aplicar a una funci&amp;oacute;n con la firma &lt;code&gt;fn(&amp;amp;PanicInfo) -&amp;gt; !&lt;/code&gt; . La funci&amp;oacute;n marcada con este &lt;a href=&quot;attributes&quot;&gt;atributo&lt;/a&gt; define el comportamiento de p&amp;aacute;nico. La estructura &lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.PanicInfo.html&quot;&gt; &lt;code&gt;PanicInfo&lt;/code&gt; &lt;/a&gt; contiene informaci&amp;oacute;n sobre la ubicaci&amp;oacute;n del p&amp;aacute;nico. Debe haber una &amp;uacute;nica funci&amp;oacute;n &lt;code&gt;panic_handler&lt;/code&gt; en el gr&amp;aacute;fico de dependencia de una caja binaria, dylib o cdylib.</target>
        </trans-unit>
        <trans-unit id="12cdf01a779d8c77135d5a609c4b4e6849f40d6f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;recursion_limit&lt;/code&gt; attribute&lt;/em&gt; may be applied at the &lt;a href=&quot;../crates-and-source-files&quot;&gt;crate&lt;/a&gt; level to set the maximum depth for potentially infinitely-recursive compile-time operations like macro expansion or auto-dereference. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the recursion depth.</source>
          <target state="translated">El &lt;em&gt;atributo &lt;/em&gt;&lt;em&gt; &lt;code&gt;recursion_limit&lt;/code&gt; &lt;/em&gt; se puede aplicar a nivel de &lt;a href=&quot;../crates-and-source-files&quot;&gt;caja&lt;/a&gt; para establecer la profundidad m&amp;aacute;xima para operaciones en tiempo de compilaci&amp;oacute;n potencialmente infinitamente recursivas como la expansi&amp;oacute;n de macros o la desreferencia autom&amp;aacute;tica. Utiliza la sintaxis &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; para especificar la profundidad de recursividad.</target>
        </trans-unit>
        <trans-unit id="a7c71f7f4ce5a08ecec5e3cb423add9b9986d9b2" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;target_feature&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; may be applied to an &lt;a href=&quot;../unsafe-functions&quot;&gt;unsafe function&lt;/a&gt; to enable code generation of that function for specific platform architecture features. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; syntax with a single key of &lt;code&gt;enable&lt;/code&gt; whose value is a string of comma-separated feature names to enable.</source>
          <target state="translated">El &lt;em&gt;&lt;a href=&quot;../attributes&quot;&gt;atributo &lt;/a&gt;&lt;/em&gt;&lt;em&gt; &lt;code&gt;target_feature&lt;/code&gt; &lt;/em&gt; se puede aplicar a una &lt;a href=&quot;../unsafe-functions&quot;&gt;funci&amp;oacute;n insegura&lt;/a&gt; para permitir la generaci&amp;oacute;n de c&amp;oacute;digo de esa funci&amp;oacute;n para caracter&amp;iacute;sticas de arquitectura de plataforma espec&amp;iacute;ficas. Utiliza la sintaxis &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; con una &amp;uacute;nica clave de &lt;code&gt;enable&lt;/code&gt; cuyo valor es una cadena de nombres de funciones separados por comas para habilitar.</target>
        </trans-unit>
        <trans-unit id="3aa1c2ce8a0a269a928c5414e9b6749a40da4909" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;test&lt;/code&gt; attribute&lt;/em&gt; marks a function to be executed as a test. These functions are only compiled when in test mode. Test functions must be free, monomorphic functions that take no arguments, and the return type must be one of the following:</source>
          <target state="translated">El &lt;em&gt;atributo de &lt;/em&gt;&lt;em&gt; &lt;code&gt;test&lt;/code&gt; &lt;/em&gt; marca una funci&amp;oacute;n que se ejecutar&amp;aacute; como prueba. Estas funciones solo se compilan en el modo de prueba. Las funciones de prueba deben ser funciones monom&amp;oacute;rficas libres que no tengan argumentos, y el tipo de retorno debe ser uno de los siguientes:</target>
        </trans-unit>
        <trans-unit id="8e32e2a7306abe757340b9bbe77da987dbdce7fd" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;type_length_limit&lt;/code&gt; attribute&lt;/em&gt; limits the maximum number of type substitutions made when constructing a concrete type during monomorphization. It is applied at the &lt;a href=&quot;../crates-and-source-files&quot;&gt;crate&lt;/a&gt; level, and uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to set the limit based on the number of type substitutions.</source>
          <target state="translated">El &lt;em&gt;atributo &lt;/em&gt;&lt;em&gt; &lt;code&gt;type_length_limit&lt;/code&gt; &lt;/em&gt; limita el n&amp;uacute;mero m&amp;aacute;ximo de sustituciones de tipos realizadas al construir un tipo concreto durante la monomorfizaci&amp;oacute;n. Se aplica a nivel de &lt;a href=&quot;../crates-and-source-files&quot;&gt;caja&lt;/a&gt; y utiliza la sintaxis &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; para establecer el l&amp;iacute;mite en funci&amp;oacute;n del n&amp;uacute;mero de sustituciones de tipos.</target>
        </trans-unit>
        <trans-unit id="6e74f839ef9f1efad1a8f9c7c9bbeff2f9cc5cae" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;used&lt;/code&gt; attribute&lt;/em&gt; can only be applied to &lt;a href=&quot;items/static-items&quot;&gt;&lt;code&gt;static&lt;/code&gt; items&lt;/a&gt;. This &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; forces the compiler to keep the variable in the output object file (.o, .rlib, etc. excluding final binaries) even if the variable is not used, or referenced, by any other item in the crate. However, the linker is still free to remove such an item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9f3929d821839852e44df6684413a39c02b618f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;used&lt;/code&gt; attribute&lt;/em&gt; can only be applied to &lt;a href=&quot;items/static-items&quot;&gt;&lt;code&gt;static&lt;/code&gt; items&lt;/a&gt;. This &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; forces the compiler to keep the variable in the output object file (.o, .rlib, etc.) even if the variable is not used, or referenced, by any other item in the crate.</source>
          <target state="translated">El &lt;em&gt;atributo &lt;/em&gt;&lt;em&gt; &lt;code&gt;used&lt;/code&gt; &lt;/em&gt; solo se puede aplicar a &lt;a href=&quot;items/static-items&quot;&gt;elementos &lt;/a&gt; &lt;code&gt;static&lt;/code&gt; . Este &lt;a href=&quot;attributes&quot;&gt;atributo&lt;/a&gt; obliga al compilador a mantener la variable en el archivo del objeto de salida (.o, .rlib, etc.) incluso si la variable no es utilizada o referenciada por ning&amp;uacute;n otro elemento de la caja.</target>
        </trans-unit>
        <trans-unit id="cabd9dd1fe1f065b8657354c25edb014ad53f468" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;windows_subsystem&lt;/code&gt; attribute&lt;/em&gt; may be applied at the crate level to set the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/fcc1zstk.aspx&quot;&gt;subsystem&lt;/a&gt; when linking on a Windows target. It uses the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the subsystem with a value of either &lt;code&gt;console&lt;/code&gt; or &lt;code&gt;windows&lt;/code&gt;. This attribute is ignored on non-Windows targets, and for non-&lt;code&gt;bin&lt;/code&gt;&lt;a href=&quot;linkage&quot;&gt;crate types&lt;/a&gt;.</source>
          <target state="translated">El &lt;em&gt;atributo &lt;/em&gt;&lt;em&gt; &lt;code&gt;windows_subsystem&lt;/code&gt; &lt;/em&gt; se puede aplicar a nivel de caja para configurar el &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/fcc1zstk.aspx&quot;&gt;subsistema&lt;/a&gt; cuando se vincula en un destino de Windows. Utiliza la sintaxis &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; para especificar el subsistema con un valor de &lt;code&gt;console&lt;/code&gt; o &lt;code&gt;windows&lt;/code&gt; . Este atributo se ignora en los destinos que no son de Windows y para los &lt;a href=&quot;linkage&quot;&gt;tipos de cajas que&lt;/a&gt; no son &lt;code&gt;bin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="637d9dddc1ad4617a0c58ddffc3922ae87e9baab" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;alignment&lt;/em&gt; of a value specifies what addresses are valid to store the value at. A value of alignment &lt;code&gt;n&lt;/code&gt; must only be stored at an address that is a multiple of n. For example, a value with an alignment of 2 must be stored at an even address, while a value with an alignment of 1 can be stored at any address. Alignment is measured in bytes, and must be at least 1, and always a power of 2. The alignment of a value can be checked with the &lt;a href=&quot;../std/mem/fn.align_of_val&quot;&gt;&lt;code&gt;align_of_val&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">La &lt;em&gt;alineaci&amp;oacute;n&lt;/em&gt; de un valor especifica en qu&amp;eacute; direcciones son v&amp;aacute;lidas para almacenar el valor. Un valor de alineaci&amp;oacute;n &lt;code&gt;n&lt;/code&gt; solo debe almacenarse en una direcci&amp;oacute;n que sea m&amp;uacute;ltiplo de n. Por ejemplo, un valor con una alineaci&amp;oacute;n de 2 debe almacenarse en una direcci&amp;oacute;n par, mientras que un valor con una alineaci&amp;oacute;n de 1 se puede almacenar en cualquier direcci&amp;oacute;n. La alineaci&amp;oacute;n se mide en bytes, y debe ser al menos 1, y siempre una potencia de 2. La alineaci&amp;oacute;n de un valor se puede verificar con la funci&amp;oacute;n &lt;a href=&quot;../std/mem/fn.align_of_val&quot;&gt; &lt;code&gt;align_of_val&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="caa4287ee2eae29f4b7097731528e2f984499328" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;at&lt;/em&gt; operator (&lt;code&gt;@&lt;/code&gt;) lets us create a variable that holds a value at the same time we&amp;rsquo;re testing that value to see whether it matches a pattern. Listing 18-29 shows an example where we want to test that a &lt;code&gt;Message::Hello&lt;/code&gt;&lt;code&gt;id&lt;/code&gt; field is within the range &lt;code&gt;3...7&lt;/code&gt;. But we also want to bind the value to the variable &lt;code&gt;id_variable&lt;/code&gt; so we can use it in the code associated with the arm. We could name this variable &lt;code&gt;id&lt;/code&gt;, the same as the field, but for this example we&amp;rsquo;ll use a different name.</source>
          <target state="translated">El &lt;em&gt;al&lt;/em&gt; operador ( &lt;code&gt;@&lt;/code&gt; ) nos permite crear una variable que contiene un valor, al mismo tiempo que estamos probando que el valor para ver si coincide con un patr&amp;oacute;n. El Listado 18-29 muestra un ejemplo en el que queremos probar que un campo &lt;code&gt;Message::Hello&lt;/code&gt; &lt;code&gt;id&lt;/code&gt; est&amp;aacute; dentro del rango &lt;code&gt;3...7&lt;/code&gt; . Pero tambi&amp;eacute;n queremos vincular el valor a la variable &lt;code&gt;id_variable&lt;/code&gt; para poder usarlo en el c&amp;oacute;digo asociado con el brazo. Podr&amp;iacute;amos nombrar esta variable &lt;code&gt;id&lt;/code&gt; , igual que el campo, pero para este ejemplo usaremos un nombre diferente.</target>
        </trans-unit>
        <trans-unit id="6fe3095ea3510353b505863afd4ade90995e4e2e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;at&lt;/em&gt; operator (&lt;code&gt;@&lt;/code&gt;) lets us create a variable that holds a value at the same time we&amp;rsquo;re testing that value to see whether it matches a pattern. Listing 18-29 shows an example where we want to test that a &lt;code&gt;Message::Hello&lt;/code&gt;&lt;code&gt;id&lt;/code&gt; field is within the range &lt;code&gt;3..=7&lt;/code&gt;. But we also want to bind the value to the variable &lt;code&gt;id_variable&lt;/code&gt; so we can use it in the code associated with the arm. We could name this variable &lt;code&gt;id&lt;/code&gt;, the same as the field, but for this example we&amp;rsquo;ll use a different name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="491e011fde2c63e7287e5968a958f99a0e0608ea" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;backslash escape&lt;/em&gt; is the character &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) which must be escaped in order to denote its ASCII encoding &lt;code&gt;0x5C&lt;/code&gt;.</source>
          <target state="translated">El &lt;em&gt;escape de barra invertida&lt;/em&gt; es el car&amp;aacute;cter &lt;code&gt;U+005C&lt;/code&gt; ( &lt;code&gt;\&lt;/code&gt; ) que debe escaparse para denotar su codificaci&amp;oacute;n ASCII &lt;code&gt;0x5C&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e78bebf05e1ce9e264a960c4a634448ed6a163c1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;backslash escape&lt;/em&gt; is the character &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) which must be escaped in order to denote itself.</source>
          <target state="translated">El &lt;em&gt;escape de barra invertida&lt;/em&gt; es el car&amp;aacute;cter &lt;code&gt;U+005C&lt;/code&gt; ( &lt;code&gt;\&lt;/code&gt; ) que debe escaparse para denotarse a s&amp;iacute; mismo.</target>
        </trans-unit>
        <trans-unit id="863e56925d2ff8675a4dd9c4a460d825a809b69e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;heap&lt;/em&gt; is a general term that describes boxes. The lifetime of an allocation in the heap depends on the lifetime of the box values pointing to it. Since box values may themselves be passed in and out of frames, or stored in the heap, heap allocations may outlive the frame they are allocated within. An allocation in the heap is guaranteed to reside at a single location in the heap for the whole lifetime of the allocation - it will never be relocated as a result of moving a box value.</source>
          <target state="translated">El &lt;em&gt;mont&amp;oacute;n&lt;/em&gt; es un t&amp;eacute;rmino general que describe cajas. La duraci&amp;oacute;n de una asignaci&amp;oacute;n en el mont&amp;oacute;n depende de la duraci&amp;oacute;n de los valores de caja que apuntan a ella. Dado que los valores de las cajas pueden pasarse dentro y fuera de las tramas, o almacenarse en el mont&amp;oacute;n, las asignaciones de la pila pueden sobrevivir a la trama en la que est&amp;aacute;n asignadas. Se garantiza que una asignaci&amp;oacute;n en el mont&amp;oacute;n residir&amp;aacute; en una &amp;uacute;nica ubicaci&amp;oacute;n en el mont&amp;oacute;n durante toda la vida &amp;uacute;til de la asignaci&amp;oacute;n; nunca se reubicar&amp;aacute; como resultado de mover un valor de caja.</target>
        </trans-unit>
        <trans-unit id="21ffe4f08baa3ee5d8fcae0ac2b2640039bc170b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;items&lt;/em&gt; of a program are those functions, modules and types that have their value calculated at compile-time and stored uniquely in the memory image of the rust process. Items are neither dynamically allocated nor freed.</source>
          <target state="translated">Los &lt;em&gt;elementos&lt;/em&gt; de un programa son aquellas funciones, m&amp;oacute;dulos y tipos que tienen su valor calculado en tiempo de compilaci&amp;oacute;n y almacenado &amp;uacute;nicamente en la imagen de memoria del proceso de oxidaci&amp;oacute;n. Los art&amp;iacute;culos no se asignan ni se liberan din&amp;aacute;micamente.</target>
        </trans-unit>
        <trans-unit id="7f297b31862071391a99da1af535c50f23bb4ea5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;items&lt;/em&gt; of a program are those functions, modules, and types that have their value calculated at compile-time and stored uniquely in the memory image of the rust process. Items are neither dynamically allocated nor freed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="867bacda5c963969dd78331f878c031b22f73cbb" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;null escape&lt;/em&gt; is the character &lt;code&gt;U+0030&lt;/code&gt; (&lt;code&gt;0&lt;/code&gt;) and denotes the Unicode value &lt;code&gt;U+0000&lt;/code&gt; (NUL).</source>
          <target state="translated">El &lt;em&gt;escape nulo&lt;/em&gt; es el car&amp;aacute;cter &lt;code&gt;U+0030&lt;/code&gt; ( &lt;code&gt;0&lt;/code&gt; ) y denota el valor Unicode &lt;code&gt;U+0000&lt;/code&gt; (NUL).</target>
        </trans-unit>
        <trans-unit id="c0460a3f4832868522908bad2876d5f8fef36d49" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;null escape&lt;/em&gt; is the character &lt;code&gt;U+0030&lt;/code&gt; (&lt;code&gt;0&lt;/code&gt;) and denotes the byte value &lt;code&gt;0x00&lt;/code&gt; (ASCII NUL).</source>
          <target state="translated">El &lt;em&gt;escape nulo&lt;/em&gt; es el car&amp;aacute;cter &lt;code&gt;U+0030&lt;/code&gt; ( &lt;code&gt;0&lt;/code&gt; ) y denota el valor de byte &lt;code&gt;0x00&lt;/code&gt; (ASCII NUL).</target>
        </trans-unit>
        <trans-unit id="b4b356718e399f8a05dc4012731a26a28084f252" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;prelude&lt;/em&gt; is the list of things that Rust automatically imports into every Rust program. It's kept as small as possible, and is focused on things, particularly traits, which are used in almost every single Rust program.</source>
          <target state="translated">El &lt;em&gt;preludio&lt;/em&gt; es la lista de cosas que Rust importa autom&amp;aacute;ticamente en cada programa de Rust. Se mantiene lo m&amp;aacute;s peque&amp;ntilde;o posible y se centra en las cosas, en particular los rasgos, que se utilizan en casi todos los programas de Rust.</target>
        </trans-unit>
        <trans-unit id="c5fc79bf9688aa8e786959c2742e411818e5d89a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;primitive representations&lt;/em&gt; are the representations with the same names as the primitive integer types. That is: &lt;code&gt;u8&lt;/code&gt;, &lt;code&gt;u16&lt;/code&gt;, &lt;code&gt;u32&lt;/code&gt;, &lt;code&gt;u64&lt;/code&gt;, &lt;code&gt;u128&lt;/code&gt;, &lt;code&gt;usize&lt;/code&gt;, &lt;code&gt;i8&lt;/code&gt;, &lt;code&gt;i16&lt;/code&gt;, &lt;code&gt;i32&lt;/code&gt;, &lt;code&gt;i64&lt;/code&gt;, &lt;code&gt;i128&lt;/code&gt;, and &lt;code&gt;isize&lt;/code&gt;.</source>
          <target state="translated">Las &lt;em&gt;representaciones primitivas&lt;/em&gt; son las representaciones con los mismos nombres que los tipos enteros primitivos. Es decir: &lt;code&gt;u8&lt;/code&gt; , &lt;code&gt;u16&lt;/code&gt; , &lt;code&gt;u32&lt;/code&gt; , &lt;code&gt;u64&lt;/code&gt; , &lt;code&gt;u128&lt;/code&gt; , &lt;code&gt;usize&lt;/code&gt; , &lt;code&gt;i8&lt;/code&gt; , &lt;code&gt;i16&lt;/code&gt; , &lt;code&gt;i32&lt;/code&gt; , &lt;code&gt;i64&lt;/code&gt; , &lt;code&gt;i128&lt;/code&gt; , y &lt;code&gt;isize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3ce8f949608b1daede8105623fa327eab5c410b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;rest pattern&lt;/em&gt; (the &lt;code&gt;..&lt;/code&gt; token) acts as a variable-length pattern which matches zero or more elements that haven't been matched already before and after. It may only be used in &lt;a href=&quot;#tuple-patterns&quot;&gt;tuple&lt;/a&gt;, &lt;a href=&quot;#tuple-struct-patterns&quot;&gt;tuple struct&lt;/a&gt;, and &lt;a href=&quot;#slice-patterns&quot;&gt;slice&lt;/a&gt; patterns, and may only appear once as one of the elements in those patterns. It is also allowed in an &lt;a href=&quot;#identifier-patterns&quot;&gt;identifier pattern&lt;/a&gt; for &lt;a href=&quot;#slice-patterns&quot;&gt;slice patterns&lt;/a&gt; only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4971362f3b5f40470a74c81b64c44c61022c0ae5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;size&lt;/em&gt; of a value is the offset in bytes between successive elements in an array with that item type including alignment padding. The size of a value is always a multiple of its alignment. The size of a value can be checked with the &lt;a href=&quot;../std/mem/fn.size_of_val&quot;&gt;&lt;code&gt;size_of_val&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">El &lt;em&gt;tama&amp;ntilde;o&lt;/em&gt; de un valor es el desplazamiento en bytes entre elementos sucesivos en una matriz con ese tipo de elemento incluido el relleno de alineaci&amp;oacute;n. El tama&amp;ntilde;o de un valor es siempre un m&amp;uacute;ltiplo de su alineaci&amp;oacute;n. El tama&amp;ntilde;o de un valor se puede verificar con la funci&amp;oacute;n &lt;a href=&quot;../std/mem/fn.size_of_val&quot;&gt; &lt;code&gt;size_of_val&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="608607007d0795edd59e30f51aeabc80ca46b5f6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;state pattern&lt;/em&gt; is an object-oriented design pattern. The crux of the pattern is that a value has some internal state, which is represented by a set of &lt;em&gt;state objects&lt;/em&gt;, and the value&amp;rsquo;s behavior changes based on the internal state. The state objects share functionality: in Rust, of course, we use structs and traits rather than objects and inheritance. Each state object is responsible for its own behavior and for governing when it should change into another state. The value that holds a state object knows nothing about the different behavior of the states or when to transition between states.</source>
          <target state="translated">El &lt;em&gt;patr&amp;oacute;n de estado&lt;/em&gt; es un patr&amp;oacute;n de dise&amp;ntilde;o orientado a objetos. El quid del patr&amp;oacute;n es que un valor tiene alg&amp;uacute;n estado interno, que est&amp;aacute; representado por un conjunto de &lt;em&gt;objetos&lt;/em&gt; de &lt;em&gt;estado&lt;/em&gt; , y el comportamiento del valor cambia seg&amp;uacute;n el estado interno. Los objetos de estado comparten funcionalidad: en Rust, por supuesto, usamos estructuras y rasgos en lugar de objetos y herencia. Cada objeto de estado es responsable de su propio comportamiento y de gobernar cu&amp;aacute;ndo deber&amp;iacute;a cambiar a otro estado. El valor que tiene un objeto de estado no sabe nada sobre el comportamiento diferente de los estados o cu&amp;aacute;ndo hacer la transici&amp;oacute;n entre estados.</target>
        </trans-unit>
        <trans-unit id="ec835310b404eed2cb3a60731c66a0fc7069cf96" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;successor&lt;/em&gt; operation moves towards values that compare greater. The &lt;em&gt;predecessor&lt;/em&gt; operation moves towards values that compare lesser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71b31d9fd96bdd059ab3da8b882ee0c455f89891" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;temporary scope&lt;/em&gt; of an expression is the scope that is used for the temporary variable that holds the result of that expression when used in a &lt;a href=&quot;expressions#place-expressions-and-value-expressions&quot;&gt;place context&lt;/a&gt;, unless it is &lt;a href=&quot;destructors#constant-promotion&quot;&gt;promoted&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da892b01ccbdf152bb00bb5fb34ad8db3069d651" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;tuple type&lt;/em&gt; is a structural type&lt;sup&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; for heterogeneous lists of other types. Each entry in the list is an &lt;em&gt;element&lt;/em&gt;&lt;sup&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; of the tuple. The position of the element makes it the &lt;em&gt;nth element&lt;/em&gt; using zero (&lt;code&gt;0&lt;/code&gt;) as the initial index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50c8131f661492ad3eb04d5338d01ccf9f429562" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;wildcard pattern&lt;/em&gt; (an underscore symbol) matches any value. It is used to ignore values when they don't matter. Inside other patterns it matches a single data field (as opposed to the &lt;code&gt;..&lt;/code&gt; which matches the remaining fields). Unlike identifier patterns, it does not copy, move or borrow the value it matches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c707e6c38639fd82e39cc81120827bce74e177e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;wildcard pattern&lt;/em&gt; matches any value. It is used to ignore values when they don't matter. Inside other patterns it matches a single data field (as opposed to the &lt;code&gt;..&lt;/code&gt; which matches the remaining fields). Unlike identifier patterns, it does not copy, move or borrow the value it matches.</source>
          <target state="translated">El &lt;em&gt;patr&amp;oacute;n de comod&amp;iacute;n&lt;/em&gt; coincide con cualquier valor. Se utiliza para ignorar valores cuando no importan. Dentro de otros patrones, coincide con un solo campo de datos (a diferencia del &lt;code&gt;..&lt;/code&gt; que coincide con los campos restantes). A diferencia de los patrones de identificaci&amp;oacute;n, no copia, mueve ni toma prestado el valor que coincide.</target>
        </trans-unit>
        <trans-unit id="75f0595163c83b48141e476739787cd1006a8d33" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;channel&lt;/strong&gt;'s sending half has become disconnected, and there will never be any more data received on it.</source>
          <target state="translated">La mitad de env&amp;iacute;o del &lt;strong&gt;canal se&lt;/strong&gt; ha desconectado y nunca se recibir&amp;aacute;n m&amp;aacute;s datos en &amp;eacute;l.</target>
        </trans-unit>
        <trans-unit id="7d020769b0b6d90680db8e09c6dc6e9b663dc909" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;compiler&lt;/strong&gt; reordering instructions: If the compiler can issue an instruction at an earlier point, it will try to do so. For example, it might hoist memory loads at the top of a code block, so that the CPU can start &lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_prefetching&quot;&gt;prefetching&lt;/a&gt; the values from memory.</source>
          <target state="translated">Las instrucciones de reordenamiento del &lt;strong&gt;compilador&lt;/strong&gt; : si el compilador puede emitir una instrucci&amp;oacute;n en un punto anterior, intentar&amp;aacute; hacerlo. Por ejemplo, podr&amp;iacute;a izar cargas de memoria en la parte superior de un bloque de c&amp;oacute;digo, de modo que la CPU puede comenzar &lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_prefetching&quot;&gt;la obtenci&amp;oacute;n previa de&lt;/a&gt; los valores de la memoria.</target>
        </trans-unit>
        <trans-unit id="314b68cd7b660a21edb44d2117cd4a156ae245a5" translate="yes" xml:space="preserve">
          <source>The API documentation that &lt;code&gt;cargo doc&lt;/code&gt; generates for this crate will now list and link re-exports on the front page, as shown in Figure 14-4, making the &lt;code&gt;PrimaryColor&lt;/code&gt; and &lt;code&gt;SecondaryColor&lt;/code&gt; types and the &lt;code&gt;mix&lt;/code&gt; function easier to find.</source>
          <target state="translated">La documentaci&amp;oacute;n API que genera &lt;code&gt;cargo doc&lt;/code&gt; para esta caja ahora enumerar&amp;aacute; y vincular&amp;aacute; las reexportaciones en la p&amp;aacute;gina principal, como se muestra en la Figura 14-4, lo que &lt;code&gt;PrimaryColor&lt;/code&gt; &lt;code&gt;SecondaryColor&lt;/code&gt; tipos PrimaryColor y SecondaryColor y la funci&amp;oacute;n de &lt;code&gt;mix&lt;/code&gt; m&amp;aacute;s f&amp;aacute;ciles de encontrar.</target>
        </trans-unit>
        <trans-unit id="fe97d53a4341ff985473c7759453c7f0b6f51809" translate="yes" xml:space="preserve">
          <source>The API is typically used by acquiring a handle to the current thread, placing that handle in a shared data structure so that other threads can find it, and then &lt;code&gt;park&lt;/code&gt;ing in a loop. When some desired condition is met, another thread calls &lt;a href=&quot;struct.thread#method.unpark&quot;&gt;&lt;code&gt;unpark&lt;/code&gt;&lt;/a&gt; on the handle.</source>
          <target state="translated">La API se usa t&amp;iacute;picamente adquiriendo un identificador para el hilo actual, colocando ese identificador en una estructura de datos compartida para que otros hilos puedan encontrarlo y luego &lt;code&gt;park&lt;/code&gt; en un bucle. Cuando se cumple alguna condici&amp;oacute;n deseada, otro hilo llama a &lt;a href=&quot;struct.thread#method.unpark&quot;&gt; &lt;code&gt;unpark&lt;/code&gt; &lt;/a&gt; en el identificador.</target>
        </trans-unit>
        <trans-unit id="bdef16eb0aad1c8443510daaf0eaf64f22da449f" translate="yes" xml:space="preserve">
          <source>The API of &lt;code id=&quot;the-api-of-mutext&quot;&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="translated">La API de &lt;code id=&quot;the-api-of-mutext&quot;&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="da2fca5419425bb1dfeff3a19e5e6b522b71b9f7" translate="yes" xml:space="preserve">
          <source>The Anatomy of a Test Function</source>
          <target state="translated">La anatomía de una función de prueba</target>
        </trans-unit>
        <trans-unit id="6ff9dd46af7ebe72f506f56aea2ffd15b7f82cfe" translate="yes" xml:space="preserve">
          <source>The Array Type</source>
          <target state="translated">El tipo de arreglo...</target>
        </trans-unit>
        <trans-unit id="4c7fdb8a442bced7fcc6b743d86e4b178b1bc140" translate="yes" xml:space="preserve">
          <source>The Boolean Type</source>
          <target state="translated">El tipo booleano</target>
        </trans-unit>
        <trans-unit id="7a47e0b8b6b1bfa40f74993b9ed02984c335782d" translate="yes" xml:space="preserve">
          <source>The Boolean type, &lt;code&gt;bool&lt;/code&gt;, with values &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">El tipo booleano, &lt;code&gt;bool&lt;/code&gt; , con valores &lt;code&gt;true&lt;/code&gt; y &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d554fe4c508301c7dd79586706f031038650a679" translate="yes" xml:space="preserve">
          <source>The Borrow Checker</source>
          <target state="translated">El Borrow Checker</target>
        </trans-unit>
        <trans-unit id="706bc5bdd045092d3c34365727a87c607d4ff3a3" translate="yes" xml:space="preserve">
          <source>The C side must &lt;strong&gt;not&lt;/strong&gt; modify the length of the string (by writing a &lt;code&gt;NULL&lt;/code&gt; somewhere inside the string or removing the final one) before it makes it back into Rust using &lt;a href=&quot;struct.cstring#method.from_raw&quot;&gt;&lt;code&gt;CString::from_raw&lt;/code&gt;&lt;/a&gt;. See the safety section in &lt;a href=&quot;struct.cstring#method.from_raw&quot;&gt;&lt;code&gt;CString::from_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="096fc2c3eb95fb5d0ee6aa092c0689c069929e6f" translate="yes" xml:space="preserve">
          <source>The C-main function only supports to return integers as return type. So, every type implementing the &lt;code&gt;Termination&lt;/code&gt; trait has to be converted to an integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da6976366f57ccb20ad430117c89098f7fb1348a" translate="yes" xml:space="preserve">
          <source>The C-variadic type &lt;code&gt;...&lt;/code&gt; has been nested inside another type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86641abf85c69d8c4f7c9c71c79144e3a2832005" translate="yes" xml:space="preserve">
          <source>The Character Type</source>
          <target state="translated">El tipo de personaje</target>
        </trans-unit>
        <trans-unit id="35e39875eebfabcb5b0b8cd30288767fc0b6add8" translate="yes" xml:space="preserve">
          <source>The Clippy tool is a collection of lints to analyze your code so you can catch common mistakes and improve your Rust code.</source>
          <target state="translated">La herramienta Clippy es una colección de pistas para analizar tu código y así poder detectar errores comunes y mejorar tu código Rust.</target>
        </trans-unit>
        <trans-unit id="bb08bad287d0caba2752b58d322b62f2942d38e6" translate="yes" xml:space="preserve">
          <source>The Default Representation</source>
          <target state="translated">La representación por defecto</target>
        </trans-unit>
        <trans-unit id="f9e1a59444e395f067802b105261ac31a11eac66" translate="yes" xml:space="preserve">
          <source>The Difference Between Macros and Functions</source>
          <target state="translated">La diferencia entre macros y funciones</target>
        </trans-unit>
        <trans-unit id="7241096a248faf0667959dae2f7e6a0390d29dce" translate="yes" xml:space="preserve">
          <source>The GID part of the peer credential. This is the effective GID of the process at the domain socket's endpoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47f6987535ee435e225cb875fe024ba6f3b75e49" translate="yes" xml:space="preserve">
          <source>The Glob Operator</source>
          <target state="translated">El operador del globo</target>
        </trans-unit>
        <trans-unit id="a0a1aaf98c3bce57246183f1baadfe83da9b49cd" translate="yes" xml:space="preserve">
          <source>The HTML format is available online at &lt;a href=&quot;https://doc.rust-lang.org/stable/book/index.html&quot;&gt;https://doc.rust-lang.org/stable/book/&lt;/a&gt; and offline with installations of Rust made with &lt;code&gt;rustup&lt;/code&gt;; run &lt;code&gt;rustup docs --book&lt;/code&gt; to open.</source>
          <target state="translated">El formato HTML est&amp;aacute; disponible en l&amp;iacute;nea en &lt;a href=&quot;https://doc.rust-lang.org/stable/book/index.html&quot;&gt;https://doc.rust-lang.org/stable/book/&lt;/a&gt; y fuera de l&amp;iacute;nea con instalaciones de Rust hechas con &lt;code&gt;rustup&lt;/code&gt; ; ejecute &lt;code&gt;rustup docs --book&lt;/code&gt; para abrir.</target>
        </trans-unit>
        <trans-unit id="00df77514c97d921fca4a972435309219a163a06" translate="yes" xml:space="preserve">
          <source>The I/O Prelude</source>
          <target state="translated">El preludio de I/O</target>
        </trans-unit>
        <trans-unit id="6979c051972c7d2da3658847fabbf6a31d84bdb5" translate="yes" xml:space="preserve">
          <source>The I/O operation's timeout expired, causing it to be canceled.</source>
          <target state="translated">El tiempo de espera de la operación de E/S expiró,causando su cancelación.</target>
        </trans-unit>
        <trans-unit id="dc9c14a7eb4854c512e7ed69d5ba6a43f9c253aa" translate="yes" xml:space="preserve">
          <source>The IEEE 754-2008 &quot;binary32&quot; and &quot;binary64&quot; floating-point types are &lt;code&gt;f32&lt;/code&gt; and &lt;code&gt;f64&lt;/code&gt;, respectively.</source>
          <target state="translated">El IEEE 754-2008 &quot;binary32&quot; y &quot;binary64&quot; tipos de coma flotante son &lt;code&gt;f32&lt;/code&gt; y &lt;code&gt;f64&lt;/code&gt; , respectivamente.</target>
        </trans-unit>
        <trans-unit id="a46bc695392f8c742f4e678a79ed2375790074cb" translate="yes" xml:space="preserve">
          <source>The Matcher Invariants</source>
          <target state="translated">Las Invariantes de la Pareja</target>
        </trans-unit>
        <trans-unit id="5eece4981b24083c68ecabd071b66fe17ba1ce62" translate="yes" xml:space="preserve">
          <source>The Never Type that Never Returns</source>
          <target state="translated">El tipo de nunca que nunca regresa</target>
        </trans-unit>
        <trans-unit id="388566f1f9117600ae22e2ebff51f82d448e95e2" translate="yes" xml:space="preserve">
          <source>The PID part of the peer credential. This field is optional because the PID part of the peer credentials is not supported on every platform. On platforms where the mechanism to discover the PID exists, this field will be populated to the PID of the process at the domain socket's endpoint. Otherwise, it will be set to None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41b8e7692f976fe91f0cb8053dcf33a7090a4f8c" translate="yes" xml:space="preserve">
          <source>The Pattern API provides a generic mechanism for using different pattern types when searching through a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba8021c95f458659340856b34b5ce555bddda300" translate="yes" xml:space="preserve">
          <source>The RFC Process and Teams</source>
          <target state="translated">El proceso y los equipos de la RFC</target>
        </trans-unit>
        <trans-unit id="667bd8e20b1ba8153f27c9ff6c220024562a73c6" translate="yes" xml:space="preserve">
          <source>The Rules of References</source>
          <target state="translated">El Reglamento de Referencias</target>
        </trans-unit>
        <trans-unit id="161ef3f14aee5229baf3e48cdbbdab5a784349b3" translate="yes" xml:space="preserve">
          <source>The Rust Language Server powers Integrated Development Environment (IDE) integration for code completion and inline error messages.</source>
          <target state="translated">El Servidor de Lenguaje de Óxido potencia la integración del Entorno de Desarrollo Integrado (IDE)para la finalización del código y los mensajes de error en línea.</target>
        </trans-unit>
        <trans-unit id="efbadde43b4ea2876af269fef5bbeff660435dad" translate="yes" xml:space="preserve">
          <source>The Rust Prelude</source>
          <target state="translated">El preludio del óxido</target>
        </trans-unit>
        <trans-unit id="1e47c327d13b68cc315d8c0718500294854d4bd4" translate="yes" xml:space="preserve">
          <source>The Rust Prelude.</source>
          <target state="translated">El preludio del óxido.</target>
        </trans-unit>
        <trans-unit id="64d4853b323b63d9ca56f4771bf913212d9ace7a" translate="yes" xml:space="preserve">
          <source>The Rust Programming Language</source>
          <target state="translated">El lenguaje de programación del óxido</target>
        </trans-unit>
        <trans-unit id="0bb645ae646711df91105c5e5d03daf9c88ee91b" translate="yes" xml:space="preserve">
          <source>The Rust Standard Library</source>
          <target state="translated">La Biblioteca de Estándares de Óxido</target>
        </trans-unit>
        <trans-unit id="9c789ddc154274d796ddc2e963326017f63c2958" translate="yes" xml:space="preserve">
          <source>The Rust Standard Library is the foundation of portable Rust software, a set of minimal and battle-tested shared abstractions for the &lt;a href=&quot;https://crates.io&quot;&gt;broader Rust ecosystem&lt;/a&gt;. It offers core types, like &lt;a href=&quot;vec/index&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, library-defined &lt;a href=&quot;#primitives&quot;&gt;operations on language primitives&lt;/a&gt;, &lt;a href=&quot;#macros&quot;&gt;standard macros&lt;/a&gt;, &lt;a href=&quot;io/index&quot;&gt;I/O&lt;/a&gt; and &lt;a href=&quot;thread/index&quot;&gt;multithreading&lt;/a&gt;, among &lt;a href=&quot;#what-is-in-the-standard-library-documentation&quot;&gt;many other things&lt;/a&gt;.</source>
          <target state="translated">La biblioteca est&amp;aacute;ndar de Rust es la base del software Rust port&amp;aacute;til, un conjunto de abstracciones compartidas m&amp;iacute;nimas y probadas en batalla para el &lt;a href=&quot;https://crates.io&quot;&gt;ecosistema Rust m&amp;aacute;s amplio&lt;/a&gt; . Ofrece tipos de n&amp;uacute;cleo, como &lt;a href=&quot;vec/index&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#primitives&quot;&gt;operaciones&lt;/a&gt; definidas por bibliotecas en primitivas de lenguaje , &lt;a href=&quot;#macros&quot;&gt;macros est&amp;aacute;ndar&lt;/a&gt; , &lt;a href=&quot;io/index&quot;&gt;E / S&lt;/a&gt; y &lt;a href=&quot;thread/index&quot;&gt;subprocesos &lt;/a&gt;&lt;a href=&quot;#what-is-in-the-standard-library-documentation&quot;&gt;m&amp;uacute;ltiples&lt;/a&gt; , entre muchas otras cosas .</target>
        </trans-unit>
        <trans-unit id="4d3f2d23ee5d88e5e35ea9e8e79bcbc0fd6e3b11" translate="yes" xml:space="preserve">
          <source>The Rust Standard Library is the foundation of portable Rust software, a set of minimal and battle-tested shared abstractions for the &lt;a href=&quot;https://crates.io&quot;&gt;broader Rust ecosystem&lt;/a&gt;. It offers core types, like &lt;a href=&quot;vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, library-defined &lt;a href=&quot;#primitives&quot;&gt;operations on language primitives&lt;/a&gt;, &lt;a href=&quot;#macros&quot;&gt;standard macros&lt;/a&gt;, &lt;a href=&quot;io/index&quot;&gt;I/O&lt;/a&gt; and &lt;a href=&quot;thread/index&quot;&gt;multithreading&lt;/a&gt;, among &lt;a href=&quot;#what-is-in-the-standard-library-documentation&quot;&gt;many other things&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c3853d774e4956749b7c91653db336f2eec58d4" translate="yes" xml:space="preserve">
          <source>The Rust compiler does not consider the following behaviors &lt;em&gt;unsafe&lt;/em&gt;, though a programmer may (should) find them undesirable, unexpected, or erroneous.</source>
          <target state="translated">El compilador de Rust no considera &lt;em&gt;inseguros&lt;/em&gt; los siguientes comportamientos , aunque un programador puede (deber&amp;iacute;a) encontrarlos indeseables, inesperados o err&amp;oacute;neos.</target>
        </trans-unit>
        <trans-unit id="21b3dd0203ec587beb1963c1f4feb0c5c3e73b91" translate="yes" xml:space="preserve">
          <source>The Rust compiler has a &lt;em&gt;borrow checker&lt;/em&gt; that compares scopes to determine whether all borrows are valid. Listing 10-18 shows the same code as Listing 10-17 but with annotations showing the lifetimes of the variables.</source>
          <target state="translated">El compilador de Rust tiene un &lt;em&gt;verificador de pr&amp;eacute;stamos&lt;/em&gt; que compara los alcances para determinar si todos los pr&amp;eacute;stamos son v&amp;aacute;lidos. El Listado 10-18 muestra el mismo c&amp;oacute;digo que el Listado 10-17 pero con anotaciones que muestran la vida &amp;uacute;til de las variables.</target>
        </trans-unit>
        <trans-unit id="bac79421ac7e7f4a69670a43a87279fa1ea360c9" translate="yes" xml:space="preserve">
          <source>The Rust compiler is always invoked with a single source file as input, and always produces a single output crate. The processing of that source file may result in other source files being loaded as modules. Source files have the extension &lt;code&gt;.rs&lt;/code&gt;.</source>
          <target state="translated">El compilador de Rust siempre se invoca con un &amp;uacute;nico archivo fuente como entrada y siempre produce una &amp;uacute;nica caja de salida. El procesamiento de ese archivo fuente puede resultar en la carga de otros archivos fuente como m&amp;oacute;dulos. Los archivos de origen tienen la extensi&amp;oacute;n &lt;code&gt;.rs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="edecdb50208b6b73bf12c25a96c41ebd3a559a66" translate="yes" xml:space="preserve">
          <source>The Rust language and compiler have a six-week release cycle, meaning users get a constant stream of new features. Other programming languages release larger changes less often; Rust releases smaller updates more frequently. After a while, all of these tiny changes add up. But from release to release, it can be difficult to look back and say, &amp;ldquo;Wow, between Rust 1.10 and Rust 1.31, Rust has changed a lot!&amp;rdquo;</source>
          <target state="translated">El lenguaje y el compilador de Rust tienen un ciclo de lanzamiento de seis semanas, lo que significa que los usuarios obtienen un flujo constante de nuevas funciones. Otros lenguajes de programaci&amp;oacute;n lanzan cambios m&amp;aacute;s importantes con menos frecuencia; Rust lanza actualizaciones m&amp;aacute;s peque&amp;ntilde;as con mayor frecuencia. Despu&amp;eacute;s de un tiempo, todos estos peque&amp;ntilde;os cambios se suman. Pero de un lanzamiento a otro, puede ser dif&amp;iacute;cil mirar atr&amp;aacute;s y decir: &quot;&amp;iexcl;Vaya, entre Rust 1.10 y Rust 1.31, Rust ha cambiado mucho!&quot;</target>
        </trans-unit>
        <trans-unit id="bb670b9e802863986c803bc2c279a2c3ad127d26" translate="yes" xml:space="preserve">
          <source>The Rust language has a set of &lt;em&gt;keywords&lt;/em&gt; that are reserved for use by the language only, much as in other languages. Keep in mind that you cannot use these words as names of variables or functions. Most of the keywords have special meanings, and you&amp;rsquo;ll be using them to do various tasks in your Rust programs; a few have no current functionality associated with them but have been reserved for functionality that might be added to Rust in the future. You can find a list of the keywords in &lt;a href=&quot;appendix-01-keywords&quot;&gt;Appendix A&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4db8a730c896d57ac8ae13218ced391891bc4c9e" translate="yes" xml:space="preserve">
          <source>The Rust language has a set of &lt;em&gt;keywords&lt;/em&gt; that are reserved for use by the language only, much as in other languages. Keep in mind that you cannot use these words as names of variables or functions. Most of the keywords have special meanings, and you&amp;rsquo;ll be using them to do various tasks in your Rust programs; a few have no current functionality associated with them but have been reserved for functionality that might be added to Rust in the future. You can find a list of the keywords in Appendix A.</source>
          <target state="translated">El lenguaje Rust tiene un conjunto de &lt;em&gt;palabras clave&lt;/em&gt; que est&amp;aacute;n reservadas para ser utilizadas &amp;uacute;nicamente por el idioma, al igual que en otros idiomas. Tenga en cuenta que no puede usar estas palabras como nombres de variables o funciones. La mayor&amp;iacute;a de las palabras clave tienen significados especiales y las utilizar&amp;aacute; para realizar diversas tareas en sus programas de Rust; algunos no tienen una funcionalidad actual asociada con ellos, pero se han reservado para funciones que podr&amp;iacute;an agregarse a Rust en el futuro. Puede encontrar una lista de las palabras clave en el Ap&amp;eacute;ndice A.</target>
        </trans-unit>
        <trans-unit id="5c421a36adf32e1316c136776ce05dd83536c6c8" translate="yes" xml:space="preserve">
          <source>The Rust language hopes to support many other users as well; those mentioned here are merely some of the biggest stakeholders. Overall, Rust&amp;rsquo;s greatest ambition is to eliminate the trade-offs that programmers have accepted for decades by providing safety &lt;em&gt;and&lt;/em&gt; productivity, speed &lt;em&gt;and&lt;/em&gt; ergonomics. Give Rust a try and see if its choices work for you.</source>
          <target state="translated">El lenguaje Rust espera ser compatible con muchos otros usuarios tambi&amp;eacute;n; los mencionados aqu&amp;iacute; son simplemente algunos de los principales interesados. En general, la mayor ambici&amp;oacute;n de Rust es eliminar las compensaciones que los programadores han aceptado durante d&amp;eacute;cadas al brindar seguridad &lt;em&gt;y&lt;/em&gt; productividad, velocidad &lt;em&gt;y&lt;/em&gt; ergonom&amp;iacute;a. Prueba Rust y comprueba si sus opciones funcionan para ti.</target>
        </trans-unit>
        <trans-unit id="596e2b7dbc791cd3cfc77236ae00a927665967e2" translate="yes" xml:space="preserve">
          <source>The Rust runtime</source>
          <target state="translated">El tiempo de ejecución de Rust</target>
        </trans-unit>
        <trans-unit id="6be65bd73ad861e62f3888e1cc3672c017c1636b" translate="yes" xml:space="preserve">
          <source>The Rust standard library provides channels for message passing and smart pointer types, such as &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt;, that are safe to use in concurrent contexts. The type system and the borrow checker ensure that the code using these solutions won&amp;rsquo;t end up with data races or invalid references. Once you get your code to compile, you can rest assured that it will happily run on multiple threads without the kinds of hard-to-track-down bugs common in other languages. Concurrent programming is no longer a concept to be afraid of: go forth and make your programs concurrent, fearlessly!</source>
          <target state="translated">La biblioteca est&amp;aacute;ndar de Rust proporciona canales para el paso de mensajes y tipos de punteros inteligentes, como &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; y &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; , que son seguros de usar en contextos concurrentes. El sistema de tipos y el verificador de pr&amp;eacute;stamos garantizan que el c&amp;oacute;digo que utiliza estas soluciones no terminar&amp;aacute; con carreras de datos o referencias no v&amp;aacute;lidas. Una vez que obtenga su c&amp;oacute;digo para compilar, puede estar seguro de que se ejecutar&amp;aacute; felizmente en m&amp;uacute;ltiples subprocesos sin los tipos de errores dif&amp;iacute;ciles de rastrear comunes en otros idiomas. La programaci&amp;oacute;n concurrente ya no es un concepto al que temer: avance y haga que sus programas sean concurrentes, &amp;iexcl;sin miedo!</target>
        </trans-unit>
        <trans-unit id="ca0e948d58962dbdfe194b991ab15a2f509a074c" translate="yes" xml:space="preserve">
          <source>The Rust type system has some features that we&amp;rsquo;ve mentioned in this book but haven&amp;rsquo;t yet discussed. We&amp;rsquo;ll start by discussing newtypes in general as we examine why newtypes are useful as types. Then we&amp;rsquo;ll move on to type aliases, a feature similar to newtypes but with slightly different semantics. We&amp;rsquo;ll also discuss the &lt;code&gt;!&lt;/code&gt; type and dynamically sized types.</source>
          <target state="translated">El sistema de tipo Rust tiene algunas caracter&amp;iacute;sticas que hemos mencionado en este libro pero que a&amp;uacute;n no hemos comentado. Comenzaremos discutiendo los nuevos tipos en general mientras examinamos por qu&amp;eacute; los nuevos tipos son &amp;uacute;tiles como tipos. Luego pasaremos a los alias de tipo, una caracter&amp;iacute;stica similar a los nuevos tipos pero con una sem&amp;aacute;ntica ligeramente diferente. &amp;iexcl;Tambi&amp;eacute;n discutiremos el &lt;code&gt;!&lt;/code&gt; type y tipos de tama&amp;ntilde;o din&amp;aacute;mico.</target>
        </trans-unit>
        <trans-unit id="1e24d83679bf4a662ce93151d4c79beb7bc3d976" translate="yes" xml:space="preserve">
          <source>The Slice Type</source>
          <target state="translated">El tipo de rebanada</target>
        </trans-unit>
        <trans-unit id="b60a9b411326be4b7b78e74a3c2736078d2cb936" translate="yes" xml:space="preserve">
          <source>The Stack and the Heap</source>
          <target state="translated">La pila y el montón</target>
        </trans-unit>
        <trans-unit id="ea9187c27f13ce2d0fda228c7804b1eacb2a7df4" translate="yes" xml:space="preserve">
          <source>The Static Lifetime</source>
          <target state="translated">La vida estática</target>
        </trans-unit>
        <trans-unit id="dcc1bdcf64d9ba08b8c546b48a03373f9d896f1a" translate="yes" xml:space="preserve">
          <source>The Tests Module and &lt;code id=&quot;the-tests-module-and-cfgtest&quot;&gt;#[cfg(test)]&lt;/code&gt;</source>
          <target state="translated">El m&amp;oacute;dulo de pruebas y &lt;code id=&quot;the-tests-module-and-cfgtest&quot;&gt;#[cfg(test)]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="43d375d205a43568d44e006351aba054a3a6df0e" translate="yes" xml:space="preserve">
          <source>The Trade-Offs of Using &lt;code id=&quot;the-trade-offs-of-using-clone&quot;&gt;clone&lt;/code&gt;</source>
          <target state="translated">Las ventajas y desventajas de usar &lt;code id=&quot;the-trade-offs-of-using-clone&quot;&gt;clone&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="874f680f597dff734725c0edb8d1cdbdc1c687fb" translate="yes" xml:space="preserve">
          <source>The Transmission Control Protocol is specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793&lt;/a&gt;.</source>
          <target state="translated">El Protocolo de control de transmisi&amp;oacute;n se especifica en &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6d2bc0207cf3386e89a8ff90f2a45c74d008dd6b" translate="yes" xml:space="preserve">
          <source>The Tuple Type</source>
          <target state="translated">El tipo de tupla</target>
        </trans-unit>
        <trans-unit id="a1fe62622ad4944befb6b7cd3fbf5afe74512445" translate="yes" xml:space="preserve">
          <source>The UID part of the peer credential. This is the effective UID of the process at the domain socket's endpoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="720acae72ae852d88680bc6199aaf2a3185402bd" translate="yes" xml:space="preserve">
          <source>The Unsize trait should not be implemented directly. All implementations of Unsize are provided automatically by the compiler.</source>
          <target state="translated">El rasgo Unsize no debe aplicarse directamente.Todas las implementaciones de Unsize son proporcionadas automáticamente por el compilador.</target>
        </trans-unit>
        <trans-unit id="9d8c2343fd3b49fd50014f949ed7698cf46aba4f" translate="yes" xml:space="preserve">
          <source>The ability to return a type that is only specified by the trait it implements is especially useful in the context of closures and iterators, which we cover in Chapter 13. Closures and iterators create types that only the compiler knows or types that are very long to specify. The &lt;code&gt;impl Trait&lt;/code&gt; syntax lets you concisely specify that a function returns some type that implements the &lt;code&gt;Iterator&lt;/code&gt; trait without needing to write out a very long type.</source>
          <target state="translated">La capacidad de devolver un tipo que solo est&amp;aacute; especificado por el rasgo que implementa es especialmente &amp;uacute;til en el contexto de cierres e iteradores, que cubrimos en el Cap&amp;iacute;tulo 13. Los cierres e iteradores crean tipos que solo el compilador conoce o tipos que son muy largos para especificar. La sintaxis &lt;code&gt;impl Trait&lt;/code&gt; le permite especificar de manera concisa que una funci&amp;oacute;n devuelve alg&amp;uacute;n tipo que implementa el rasgo &lt;code&gt;Iterator&lt;/code&gt; sin necesidad de escribir un tipo muy largo.</target>
        </trans-unit>
        <trans-unit id="8344955111fdc074c9729e11010ee2eab0af03c1" translate="yes" xml:space="preserve">
          <source>The above example can be resolved by either reducing the number of lifetime bounds to one or by making the trait object lifetime explicit, like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde40ac9fea8ec2f55d9ca0d422fc89008496087" translate="yes" xml:space="preserve">
          <source>The above indirection is the additional runtime cost of calling a function on a &lt;code&gt;dyn Trait&lt;/code&gt;. Methods called by dynamic dispatch generally cannot be inlined by the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deb20b7d624d1708cb7603af7f7d5931910cd966" translate="yes" xml:space="preserve">
          <source>The above is &lt;em&gt;still&lt;/em&gt; an expression but it will always evaluate to &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ede9c72b891dfc1d92b0b9fffc4f21007f9ae902" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i128::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;i128&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i128::MIN&lt;/code&gt; without a panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4ff7b2880604f74445f905b71fdee96836fc628" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i128::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i128&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i128::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">El valor absoluto de &lt;code&gt;i128::min_value()&lt;/code&gt; no se puede representar como un &lt;code&gt;i128&lt;/code&gt; , e intentar calcularlo provocar&amp;aacute; un desbordamiento. Esto significa que el c&amp;oacute;digo en modo de depuraci&amp;oacute;n provocar&amp;aacute; un p&amp;aacute;nico en este caso y el c&amp;oacute;digo optimizado devolver&amp;aacute; &lt;code&gt;i128::min_value()&lt;/code&gt; sin p&amp;aacute;nico.</target>
        </trans-unit>
        <trans-unit id="68e6f1c95dcf27a099d3d4e155f55896bf8faf93" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i16::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;i16&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i16::MIN&lt;/code&gt; without a panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6634b50eb0aa3afe906f4e13b4800cc26454c92" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i16::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i16&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i16::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">El valor absoluto de &lt;code&gt;i16::min_value()&lt;/code&gt; no se puede representar como un &lt;code&gt;i16&lt;/code&gt; , e intentar calcularlo provocar&amp;aacute; un desbordamiento. Esto significa que el c&amp;oacute;digo en modo de depuraci&amp;oacute;n provocar&amp;aacute; un p&amp;aacute;nico en este caso y el c&amp;oacute;digo optimizado devolver&amp;aacute; &lt;code&gt;i16::min_value()&lt;/code&gt; sin p&amp;aacute;nico.</target>
        </trans-unit>
        <trans-unit id="37e2f0833c2e3fce2e0d86c6e578d1435f9c3b8f" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i32::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;i32&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i32::MIN&lt;/code&gt; without a panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91a991a9b7dce7a35eefa5dff81ee4a280a7e4f1" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i32::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i32&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i32::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">El valor absoluto de &lt;code&gt;i32::min_value()&lt;/code&gt; no se puede representar como un &lt;code&gt;i32&lt;/code&gt; , e intentar calcularlo provocar&amp;aacute; un desbordamiento. Esto significa que el c&amp;oacute;digo en modo de depuraci&amp;oacute;n provocar&amp;aacute; un p&amp;aacute;nico en este caso y el c&amp;oacute;digo optimizado devolver&amp;aacute; &lt;code&gt;i32::min_value()&lt;/code&gt; sin p&amp;aacute;nico.</target>
        </trans-unit>
        <trans-unit id="2ddae722d1b9330d37bd61655516374aae130695" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i64::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;i64&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i64::MIN&lt;/code&gt; without a panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c50c4d71fa72eabc1e0818c0a858ae1903c1c3c" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i64::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i64&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i64::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">El valor absoluto de &lt;code&gt;i64::min_value()&lt;/code&gt; no se puede representar como un &lt;code&gt;i64&lt;/code&gt; , e intentar calcularlo provocar&amp;aacute; un desbordamiento. Esto significa que el c&amp;oacute;digo en modo de depuraci&amp;oacute;n provocar&amp;aacute; un p&amp;aacute;nico en este caso y el c&amp;oacute;digo optimizado devolver&amp;aacute; &lt;code&gt;i64::min_value()&lt;/code&gt; sin p&amp;aacute;nico.</target>
        </trans-unit>
        <trans-unit id="94540f2ba32a8d4e2123f1b683b0ff15f6511fa8" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i8::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;i8&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i8::MIN&lt;/code&gt; without a panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5adbbbaac9cedf98e39759b8920bdb3431d04107" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i8::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i8&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i8::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">El valor absoluto de &lt;code&gt;i8::min_value()&lt;/code&gt; no se puede representar como &lt;code&gt;i8&lt;/code&gt; , e intentar calcularlo provocar&amp;aacute; un desbordamiento. Esto significa que el c&amp;oacute;digo en modo de depuraci&amp;oacute;n provocar&amp;aacute; un p&amp;aacute;nico en este caso y el c&amp;oacute;digo optimizado devolver&amp;aacute; &lt;code&gt;i8::min_value()&lt;/code&gt; sin p&amp;aacute;nico.</target>
        </trans-unit>
        <trans-unit id="f3616827787c274826d0feb8bc695ca0f90e8398" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;isize::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;isize&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;isize::MIN&lt;/code&gt; without a panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fa62dd0a50bd4c5554cb57272ae5164c2e1f601" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;isize::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;isize&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;isize::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">El valor absoluto de &lt;code&gt;isize::min_value()&lt;/code&gt; no se puede representar como un &lt;code&gt;isize&lt;/code&gt; , e intentar calcularlo provocar&amp;aacute; un desbordamiento. Esto significa que el c&amp;oacute;digo en modo de depuraci&amp;oacute;n provocar&amp;aacute; un p&amp;aacute;nico en este caso y el c&amp;oacute;digo optimizado devolver&amp;aacute; &lt;code&gt;isize::min_value()&lt;/code&gt; sin p&amp;aacute;nico.</target>
        </trans-unit>
        <trans-unit id="409fd764bcabc3595ffe004849ff8f4e30564756" translate="yes" xml:space="preserve">
          <source>The actual desugaring is more complex:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88133b615f1381b0a02c487a3edbc253bc8ee09f" translate="yes" xml:space="preserve">
          <source>The actual stack size may be greater than this value if the platform specifies a minimal stack size.</source>
          <target state="translated">El tamaño real de la pila puede ser mayor que este valor si la plataforma especifica un tamaño mínimo de pila.</target>
        </trans-unit>
        <trans-unit id="e09eb4195a6425d3d0a7b968cb406d8968af9926" translate="yes" xml:space="preserve">
          <source>The addition assignment operator &lt;code&gt;+=&lt;/code&gt;.</source>
          <target state="translated">El operador de asignaci&amp;oacute;n de suma &lt;code&gt;+=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="097ca9dd7ade97007d85b522a25e6d04cefa5c67" translate="yes" xml:space="preserve">
          <source>The addition operator &lt;code&gt;+&lt;/code&gt;.</source>
          <target state="translated">El operador de suma &lt;code&gt;+&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="161b60a028315218a44d6ebb4a0a56ea64addb73" translate="yes" xml:space="preserve">
          <source>The address of temporary value was taken.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67b3b3b11425c46c946b0ed067dfaec63ac739cb" translate="yes" xml:space="preserve">
          <source>The address type can be any implementor of &lt;a href=&quot;trait.tosocketaddrs&quot;&gt;&lt;code&gt;ToSocketAddrs&lt;/code&gt;&lt;/a&gt; trait. See its documentation for concrete examples.</source>
          <target state="translated">El tipo de direcci&amp;oacute;n puede ser cualquier implementador del rasgo &lt;a href=&quot;trait.tosocketaddrs&quot;&gt; &lt;code&gt;ToSocketAddrs&lt;/code&gt; &lt;/a&gt; . Consulte su documentaci&amp;oacute;n para ver ejemplos concretos.</target>
        </trans-unit>
        <trans-unit id="554a0871d5bd274c4e9a4646e480108243a7e12e" translate="yes" xml:space="preserve">
          <source>The advantage of checking the borrowing rules at runtime instead is that certain memory-safe scenarios are then allowed, whereas they are disallowed by the compile-time checks. Static analysis, like the Rust compiler, is inherently conservative. Some properties of code are impossible to detect by analyzing the code: the most famous example is the Halting Problem, which is beyond the scope of this book but is an interesting topic to research.</source>
          <target state="translated">La ventaja de comprobar las reglas de préstamo en tiempo de ejecución es que se permiten ciertos escenarios seguros para la memoria,mientras que las comprobaciones en tiempo de compilación no los permiten.El análisis estático,como el compilador Rust,es inherentemente conservador.Algunas propiedades del código son imposibles de detectar analizando el código:el ejemplo más famoso es el Problema de Detención,que está fuera del alcance de este libro pero es un tema interesante de investigación.</target>
        </trans-unit>
        <trans-unit id="cf97cfec24f32bdc09751ee8bbb19e7117656381" translate="yes" xml:space="preserve">
          <source>The advantage of using trait objects and Rust&amp;rsquo;s type system to write code similar to code using duck typing is that we never have to check whether a value implements a particular method at runtime or worry about getting errors if a value doesn&amp;rsquo;t implement a method but we call it anyway. Rust won&amp;rsquo;t compile our code if the values don&amp;rsquo;t implement the traits that the trait objects need.</source>
          <target state="translated">La ventaja de usar objetos de rasgo y el sistema de tipos de Rust para escribir c&amp;oacute;digo similar al c&amp;oacute;digo usando el tipo pato es que nunca tenemos que verificar si un valor implementa un m&amp;eacute;todo en particular en tiempo de ejecuci&amp;oacute;n o preocuparnos por obtener errores si un valor no implementa un m&amp;eacute;todo pero lo llamamos de todos modos. Rust no compilar&amp;aacute; nuestro c&amp;oacute;digo si los valores no implementan las caracter&amp;iacute;sticas que necesitan los objetos de caracter&amp;iacute;sticas.</target>
        </trans-unit>
        <trans-unit id="1f36aabbacdf9ecb5c08c91a08fabb8510a201b8" translate="yes" xml:space="preserve">
          <source>The advantages of checking the borrowing rules at compile time are that errors will be caught sooner in the development process, and there is no impact on runtime performance because all the analysis is completed beforehand. For those reasons, checking the borrowing rules at compile time is the best choice in the majority of cases, which is why this is Rust&amp;rsquo;s default.</source>
          <target state="translated">Las ventajas de comprobar las reglas de pr&amp;eacute;stamo en tiempo de compilaci&amp;oacute;n son que los errores se detectar&amp;aacute;n antes en el proceso de desarrollo y no hay impacto en el rendimiento en tiempo de ejecuci&amp;oacute;n porque todo el an&amp;aacute;lisis se completa de antemano. Por esas razones, verificar las reglas de pr&amp;eacute;stamos en el momento de la compilaci&amp;oacute;n es la mejor opci&amp;oacute;n en la mayor&amp;iacute;a de los casos, raz&amp;oacute;n por la cual esta es la opci&amp;oacute;n predeterminada de Rust.</target>
        </trans-unit>
        <trans-unit id="802cd88adc867c6ed95af7c7632a5b9312da114b" translate="yes" xml:space="preserve">
          <source>The alignment is specified as an integer parameter in the form of &lt;code&gt;#[repr(align(x))]&lt;/code&gt; or &lt;code&gt;#[repr(packed(x))]&lt;/code&gt;. The alignment value must be a power of two from 1 up to 2&lt;sup&gt;29&lt;/sup&gt;. For &lt;code&gt;packed&lt;/code&gt;, if no value is given, as in &lt;code&gt;#[repr(packed)]&lt;/code&gt;, then the value is 1.</source>
          <target state="translated">La alineaci&amp;oacute;n se especifica como un par&amp;aacute;metro entero en la forma de &lt;code&gt;#[repr(align(x))]&lt;/code&gt; o &lt;code&gt;#[repr(packed(x))]&lt;/code&gt; . El valor de alineaci&amp;oacute;n debe ser una potencia de dos desde 1 hasta 2 &lt;sup&gt;29&lt;/sup&gt; . Para &lt;code&gt;packed&lt;/code&gt; , si no se proporciona ning&amp;uacute;n valor, como en &lt;code&gt;#[repr(packed)]&lt;/code&gt; , entonces el valor es 1.</target>
        </trans-unit>
        <trans-unit id="4210b5f1c3a4d7626a8282b8b0091e3127367f26" translate="yes" xml:space="preserve">
          <source>The alignment may be raised or lowered with the &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; modifiers respectively. They alter the representation specified in the attribute. If no representation is specified, the default one is altered.</source>
          <target state="translated">La alineaci&amp;oacute;n se puede subir o bajar con los modificadores de &lt;code&gt;align&lt;/code&gt; y &lt;code&gt;packed&lt;/code&gt; respectivamente. Alteran la representaci&amp;oacute;n especificada en el atributo. Si no se especifica ninguna representaci&amp;oacute;n, se modifica la predeterminada.</target>
        </trans-unit>
        <trans-unit id="0bbd4814e74e1731ea096a3e29eb0e49a6112a9b" translate="yes" xml:space="preserve">
          <source>The alignment modifiers</source>
          <target state="translated">Los modificadores de alineación</target>
        </trans-unit>
        <trans-unit id="9a801ec59d9d78b1342286bf3c47cdf72d8754c9" translate="yes" xml:space="preserve">
          <source>The alignment of a value specifies what addresses values are preferred to start at. Always a power of two. References to a value must be aligned. &lt;a href=&quot;type-layout#size-and-alignment&quot;&gt;More&lt;/a&gt;.</source>
          <target state="translated">La alineaci&amp;oacute;n de un valor especifica en qu&amp;eacute; direcciones se prefiere comenzar con los valores. Siempre una potencia de dos. Las referencias a un valor deben estar alineadas. &lt;a href=&quot;type-layout#size-and-alignment&quot;&gt;M&amp;aacute;s&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d7d8131883a9466d9495401638572f0f7002cb80" translate="yes" xml:space="preserve">
          <source>The alignment of the struct is the alignment of the most-aligned field in it.</source>
          <target state="translated">La alineación de la estructura es la alineación del campo más alineado en ella.</target>
        </trans-unit>
        <trans-unit id="cb2d786ce814f96269971824a7ca8c85b85a4a91" translate="yes" xml:space="preserve">
          <source>The allocated block of memory may or may not be initialized.</source>
          <target state="translated">El bloque de memoria asignado puede o no ser inicializado.</target>
        </trans-unit>
        <trans-unit id="a853460caf9660ad50bba38269de71834329efaf" translate="yes" xml:space="preserve">
          <source>The allocation error hook is a global resource.</source>
          <target state="translated">El gancho de error de asignación es un recurso global.</target>
        </trans-unit>
        <trans-unit id="dd622480c0a0d020ad0c83e155629929c531f8bd" translate="yes" xml:space="preserve">
          <source>The allocation error hook is invoked when an infallible memory allocation fails, before the runtime aborts. The default hook prints a message to standard error, but this behavior can be customized with the &lt;a href=&quot;fn.set_alloc_error_hook&quot;&gt;&lt;code&gt;set_alloc_error_hook&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.take_alloc_error_hook&quot;&gt;&lt;code&gt;take_alloc_error_hook&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="translated">El gancho de error de asignaci&amp;oacute;n se invoca cuando falla una asignaci&amp;oacute;n de memoria infalible, antes de que se cancele el tiempo de ejecuci&amp;oacute;n. El gancho predeterminado imprime un mensaje de error est&amp;aacute;ndar, pero este comportamiento se puede personalizar con las funciones &lt;a href=&quot;fn.set_alloc_error_hook&quot;&gt; &lt;code&gt;set_alloc_error_hook&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;fn.take_alloc_error_hook&quot;&gt; &lt;code&gt;take_alloc_error_hook&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="460b0be997a504bd93f9a5f2102be17a4fe4f237" translate="yes" xml:space="preserve">
          <source>The alternate flag, &lt;code&gt;#&lt;/code&gt;, adds a &lt;code&gt;0b&lt;/code&gt; in front of the output.</source>
          <target state="translated">La bandera alternativa, &lt;code&gt;#&lt;/code&gt; , agrega un &lt;code&gt;0b&lt;/code&gt; delante de la salida.</target>
        </trans-unit>
        <trans-unit id="b053ed1e6052a16bbf0f4a89d40e16ee9bf6a88d" translate="yes" xml:space="preserve">
          <source>The alternate flag, &lt;code&gt;#&lt;/code&gt;, adds a &lt;code&gt;0o&lt;/code&gt; in front of the output.</source>
          <target state="translated">La bandera alternativa, &lt;code&gt;#&lt;/code&gt; , agrega un &lt;code&gt;0o&lt;/code&gt; al frente de la salida.</target>
        </trans-unit>
        <trans-unit id="1a67677d2b4895bdc1fb6847161bf39c61cb99f4" translate="yes" xml:space="preserve">
          <source>The alternate flag, &lt;code&gt;#&lt;/code&gt;, adds a &lt;code&gt;0x&lt;/code&gt; in front of the output.</source>
          <target state="translated">La bandera alternativa, &lt;code&gt;#&lt;/code&gt; , agrega un &lt;code&gt;0x&lt;/code&gt; delante de la salida.</target>
        </trans-unit>
        <trans-unit id="11ba8acfe40883baf3a25418d4023d5eeae6eb43" translate="yes" xml:space="preserve">
          <source>The answer to this problem is the &lt;em&gt;Cargo.lock&lt;/em&gt; file, which was created the first time you ran &lt;code&gt;cargo build&lt;/code&gt; and is now in your &lt;em&gt;guessing_game&lt;/em&gt; directory. When you build a project for the first time, Cargo figures out all the versions of the dependencies that fit the criteria and then writes them to the &lt;em&gt;Cargo.lock&lt;/em&gt; file. When you build your project in the future, Cargo will see that the &lt;em&gt;Cargo.lock&lt;/em&gt; file exists and use the versions specified there rather than doing all the work of figuring out versions again. This lets you have a reproducible build automatically. In other words, your project will remain at &lt;code&gt;0.3.14&lt;/code&gt; until you explicitly upgrade, thanks to the &lt;em&gt;Cargo.lock&lt;/em&gt; file.</source>
          <target state="translated">La respuesta a este problema es el archivo &lt;em&gt;Cargo.lock&lt;/em&gt; , que se cre&amp;oacute; la primera vez que ejecut&amp;oacute; &lt;code&gt;cargo build&lt;/code&gt; y ahora est&amp;aacute; en su directorio de &lt;em&gt;adivinanzas_juegos&lt;/em&gt; . Cuando construye un proyecto por primera vez, Cargo determina todas las versiones de las dependencias que se ajustan a los criterios y luego las escribe en el archivo &lt;em&gt;Cargo.lock&lt;/em&gt; . Cuando construya su proyecto en el futuro, Cargo ver&amp;aacute; que el archivo &lt;em&gt;Cargo.lock&lt;/em&gt; existe y usar&amp;aacute; las versiones especificadas all&amp;iacute; en lugar de hacer todo el trabajo de averiguar las versiones nuevamente. Esto le permite tener una compilaci&amp;oacute;n reproducible autom&amp;aacute;ticamente. En otras palabras, su proyecto permanecer&amp;aacute; en &lt;code&gt;0.3.14&lt;/code&gt; hasta que actualice expl&amp;iacute;citamente, gracias a &lt;em&gt;Cargo.lock&lt;/em&gt; expediente.</target>
        </trans-unit>
        <trans-unit id="8fb95ccc8cbb2b44a80d4d0a731ecb5bea70e713" translate="yes" xml:space="preserve">
          <source>The answer to this problem is the &lt;em&gt;Cargo.lock&lt;/em&gt; file, which was created the first time you ran &lt;code&gt;cargo build&lt;/code&gt; and is now in your &lt;em&gt;guessing_game&lt;/em&gt; directory. When you build a project for the first time, Cargo figures out all the versions of the dependencies that fit the criteria and then writes them to the &lt;em&gt;Cargo.lock&lt;/em&gt; file. When you build your project in the future, Cargo will see that the &lt;em&gt;Cargo.lock&lt;/em&gt; file exists and use the versions specified there rather than doing all the work of figuring out versions again. This lets you have a reproducible build automatically. In other words, your project will remain at &lt;code&gt;0.5.5&lt;/code&gt; until you explicitly upgrade, thanks to the &lt;em&gt;Cargo.lock&lt;/em&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c50839f5b75ebf2449202c65bd78e83e2a04633c" translate="yes" xml:space="preserve">
          <source>The argument order should be changed to match the parameter declaration order, as in the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff3b9111423732cd0796ed3af4340d1aeaddff87" translate="yes" xml:space="preserve">
          <source>The argument to the &lt;code&gt;llvm_asm&lt;/code&gt; macro is not well-formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d5e37bb48121061d7a9d1253e50cf299206b8ed" translate="yes" xml:space="preserve">
          <source>The argument, &lt;code&gt;mid&lt;/code&gt;, should be a byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point.</source>
          <target state="translated">El argumento, &lt;code&gt;mid&lt;/code&gt; , debe ser un desplazamiento de bytes desde el inicio de la cadena. Tambi&amp;eacute;n debe estar en el l&amp;iacute;mite de un punto de c&amp;oacute;digo UTF-8.</target>
        </trans-unit>
        <trans-unit id="843c167795952476fd4949d773d09e67f37bae5c" translate="yes" xml:space="preserve">
          <source>The arguments will be formatted according to the specified format string into the output stream provided.</source>
          <target state="translated">Los argumentos se formatearán de acuerdo con la cadena de formato especificada en el flujo de salida proporcionado.</target>
        </trans-unit>
        <trans-unit id="47d8ae2e6d2ad4b4b9256e9f4136431f5f0ee17f" translate="yes" xml:space="preserve">
          <source>The array index expression can be implemented for types other than arrays and slices by implementing the &lt;a href=&quot;../../std/ops/trait.index&quot;&gt;Index&lt;/a&gt; and &lt;a href=&quot;../../std/ops/trait.indexmut&quot;&gt;IndexMut&lt;/a&gt; traits.</source>
          <target state="translated">La expresi&amp;oacute;n de &amp;iacute;ndice de matriz se puede implementar para tipos distintos de matrices y cortes mediante la implementaci&amp;oacute;n de los rasgos &lt;a href=&quot;../../std/ops/trait.index&quot;&gt;Index&lt;/a&gt; e &lt;a href=&quot;../../std/ops/trait.indexmut&quot;&gt;IndexMut&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43b42b264d53f00eb4d50d966bdebfe503d9e502" translate="yes" xml:space="preserve">
          <source>The array named &lt;code&gt;a&lt;/code&gt; will contain &lt;code&gt;5&lt;/code&gt; elements that will all be set to the value &lt;code&gt;3&lt;/code&gt; initially. This is the same as writing &lt;code&gt;let a = [3, 3, 3, 3, 3];&lt;/code&gt; but in a more concise way.</source>
          <target state="translated">La matriz denominada &lt;code&gt;a&lt;/code&gt; contendr&amp;aacute; &lt;code&gt;5&lt;/code&gt; elementos que se establecer&amp;aacute;n inicialmente en el valor &lt;code&gt;3&lt;/code&gt; . Esto es lo mismo que escribir &lt;code&gt;let a = [3, 3, 3, 3, 3];&lt;/code&gt; pero de una manera m&amp;aacute;s concisa.</target>
        </trans-unit>
        <trans-unit id="bda6f38466d2f9f90243514e2e1d1d622e872f82" translate="yes" xml:space="preserve">
          <source>The associated error which can be returned from parsing.</source>
          <target state="translated">El error asociado que puede ser devuelto del análisis.</target>
        </trans-unit>
        <trans-unit id="264397f1a1d81bc0bfb862d1058ae5d080545332" translate="yes" xml:space="preserve">
          <source>The associated type used was not defined in the trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95b071fe52a22a379b9072dba9b8116f1e91d5e0" translate="yes" xml:space="preserve">
          <source>The assumed lifetime of references held by a &lt;a href=&quot;types/trait-object&quot;&gt;trait object&lt;/a&gt; is called its &lt;em&gt;default object lifetime bound&lt;/em&gt;. These were defined in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md&quot;&gt;RFC 599&lt;/a&gt; and amended in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md&quot;&gt;RFC 1156&lt;/a&gt;.</source>
          <target state="translated">La vida &amp;uacute;til asumida de las referencias mantenidas por un &lt;a href=&quot;types/trait-object&quot;&gt;objeto de rasgo&lt;/a&gt; se denomina &lt;em&gt;l&amp;iacute;mite de vida &amp;uacute;til del objeto predeterminado&lt;/em&gt; . Estos se definieron en &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md&quot;&gt;RFC 599&lt;/a&gt; y se modificaron en &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md&quot;&gt;RFC 1156&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4a633a670846190d4e317682018f539e771650d4" translate="yes" xml:space="preserve">
          <source>The atomic intrinsics provide common atomic operations on machine words, with multiple possible memory orderings. They obey the same semantics as C++11. See the LLVM documentation on [&lt;a href=&quot;http://llvm.org/docs/Atomics.html&quot;&gt;atomics&lt;/a&gt;].</source>
          <target state="translated">Los intr&amp;iacute;nsecos at&amp;oacute;micos proporcionan operaciones at&amp;oacute;micas comunes en palabras de m&amp;aacute;quina, con m&amp;uacute;ltiples ordenaciones de memoria posibles. Obedecen la misma sem&amp;aacute;ntica que C ++ 11. Consulte la documentaci&amp;oacute;n de LLVM sobre [ &lt;a href=&quot;http://llvm.org/docs/Atomics.html&quot;&gt;atomics&lt;/a&gt; ].</target>
        </trans-unit>
        <trans-unit id="4eacfc8c255cb1ef132a6a65b58c2019ebea9baf" translate="yes" xml:space="preserve">
          <source>The atomic types in this module may not be available on all platforms. The atomic types here are all widely available, however, and can generally be relied upon existing. Some notable exceptions are:</source>
          <target state="translated">Es posible que los tipos atómicos de este módulo no estén disponibles en todas las plataformas.Sin embargo,los tipos atómicos aquí están ampliamente disponibles y,en general,se puede confiar en que existen.Algunas excepciones notables son:</target>
        </trans-unit>
        <trans-unit id="71cc0f45759d249e1ba21744ede7b9ef7445260e" translate="yes" xml:space="preserve">
          <source>The attribute consists of a path to the attribute, followed by an optional delimited token tree whose interpretation is defined by the attribute. Attributes other than macro attributes also allow the input to be an equals sign (&lt;code&gt;=&lt;/code&gt;) followed by a literal expression. See the &lt;a href=&quot;#meta-item-attribute-syntax&quot;&gt;meta item syntax&lt;/a&gt; below for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5f89ad9ce66636388cf7509f930392e52eeb867" translate="yes" xml:space="preserve">
          <source>The attribute consists of a path to the attribute, followed by an optional delimited token tree whose interpretation is defined by the attribute. Attributes other than macro attributes also allow the input to be an equals sign (&lt;code&gt;=&lt;/code&gt;) followed by a literal expression. See the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;meta item syntax&lt;/a&gt; below for more details.</source>
          <target state="translated">El atributo consta de una ruta al atributo, seguida de un &amp;aacute;rbol de tokens delimitado opcional cuya interpretaci&amp;oacute;n est&amp;aacute; definida por el atributo. Los atributos distintos de los atributos macro tambi&amp;eacute;n permiten que la entrada sea un signo igual ( &lt;code&gt;=&lt;/code&gt; ) seguido de una expresi&amp;oacute;n literal. Consulte la &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;sintaxis&lt;/a&gt; del meta elemento a continuaci&amp;oacute;n para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="b79be106b3314bbccaaacf6171952db704c5419b" translate="yes" xml:space="preserve">
          <source>The attribute is used on a &lt;code&gt;static&lt;/code&gt; item whose type implements the &lt;a href=&quot;https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html&quot;&gt;&lt;code&gt;GlobalAlloc&lt;/code&gt;&lt;/a&gt; trait. This type can be provided by an external library:</source>
          <target state="translated">El atributo se utiliza en un elemento &lt;code&gt;static&lt;/code&gt; cuyo tipo implementa el rasgo &lt;a href=&quot;https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html&quot;&gt; &lt;code&gt;GlobalAlloc&lt;/code&gt; &lt;/a&gt; . Este tipo puede ser proporcionado por una biblioteca externa:</target>
        </trans-unit>
        <trans-unit id="638938ad1b96ca367b1ad29ad316e67748e69b45" translate="yes" xml:space="preserve">
          <source>The attribute is used on a &lt;code&gt;static&lt;/code&gt; item whose type implements the &lt;a href=&quot;trait.globalalloc&quot;&gt;&lt;code&gt;GlobalAlloc&lt;/code&gt;&lt;/a&gt; trait. This type can be provided by an external library:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07001b94d9ec08710a57474a9ab6a5a7c57ed031" translate="yes" xml:space="preserve">
          <source>The attributes that have meaning on a block expression are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;.</source>
          <target state="translated">Los atributos que tienen significado en una expresi&amp;oacute;n de bloque son &lt;a href=&quot;../conditional-compilation&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;los atributos de comprobaci&amp;oacute;n de pelusa&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="db84623389bc5fe968094b478ac6446a9f7cd32b" translate="yes" xml:space="preserve">
          <source>The attributes that have meaning on a function are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-export_name-attribute&quot;&gt;&lt;code&gt;export_name&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-link_section-attribute&quot;&gt;&lt;code&gt;link_section&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-no_mangle-attribute&quot;&gt;&lt;code&gt;no_mangle&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-must_use-attribute&quot;&gt;&lt;code&gt;must_use&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../procedural-macros&quot;&gt;the procedural macro attributes&lt;/a&gt;, &lt;a href=&quot;../attributes/testing&quot;&gt;the testing attributes&lt;/a&gt;, and &lt;a href=&quot;../attributes/codegen#optimization-hints&quot;&gt;the optimization hint attributes&lt;/a&gt;. Functions also accept attributes macros.</source>
          <target state="translated">Los atributos que tienen significado en una funci&amp;oacute;n son &lt;a href=&quot;../conditional-compilation&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt; &lt;code&gt;doc&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../abi#the-export_name-attribute&quot;&gt; &lt;code&gt;export_name&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../abi#the-link_section-attribute&quot;&gt; &lt;code&gt;link_section&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../abi#the-no_mangle-attribute&quot;&gt; &lt;code&gt;no_mangle&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;los atributos de verificaci&amp;oacute;n de pelusa&lt;/a&gt; , &lt;a href=&quot;../attributes/diagnostics#the-must_use-attribute&quot;&gt; &lt;code&gt;must_use&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../procedural-macros&quot;&gt;los atributos de macro de procedimiento&lt;/a&gt; , &lt;a href=&quot;../attributes/testing&quot;&gt;los atributos de prueba&lt;/a&gt; y &lt;a href=&quot;../attributes/codegen#optimization-hints&quot;&gt;los atributos de sugerencia de optimizaci&amp;oacute;n&lt;/a&gt; . Las funciones tambi&amp;eacute;n aceptan macros de atributos.</target>
        </trans-unit>
        <trans-unit id="622c3bad6ebce7dda9ab10b347056427bd42a746" translate="yes" xml:space="preserve">
          <source>The attributes that have meaning on a function are &lt;a href=&quot;../conditional-compilation#the-cfg-attribute&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../conditional-compilation#the-cfg_attr-attribute&quot;&gt;&lt;code&gt;cfg_attr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-export_name-attribute&quot;&gt;&lt;code&gt;export_name&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-link_section-attribute&quot;&gt;&lt;code&gt;link_section&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-no_mangle-attribute&quot;&gt;&lt;code&gt;no_mangle&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-must_use-attribute&quot;&gt;&lt;code&gt;must_use&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../procedural-macros&quot;&gt;the procedural macro attributes&lt;/a&gt;, &lt;a href=&quot;../attributes/testing&quot;&gt;the testing attributes&lt;/a&gt;, and &lt;a href=&quot;../attributes/codegen#optimization-hints&quot;&gt;the optimization hint attributes&lt;/a&gt;. Functions also accept attributes macros.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9286c2061446f78d1eb0dacb8ad2bed2198b3a3" translate="yes" xml:space="preserve">
          <source>The author of the code in Listing 14-4, which uses the &lt;code&gt;art&lt;/code&gt; crate, had to figure out that &lt;code&gt;PrimaryColor&lt;/code&gt; is in the &lt;code&gt;kinds&lt;/code&gt; module and &lt;code&gt;mix&lt;/code&gt; is in the &lt;code&gt;utils&lt;/code&gt; module. The module structure of the &lt;code&gt;art&lt;/code&gt; crate is more relevant to developers working on the &lt;code&gt;art&lt;/code&gt; crate than to developers using the &lt;code&gt;art&lt;/code&gt; crate. The internal structure that organizes parts of the crate into the &lt;code&gt;kinds&lt;/code&gt; module and the &lt;code&gt;utils&lt;/code&gt; module doesn&amp;rsquo;t contain any useful information for someone trying to understand how to use the &lt;code&gt;art&lt;/code&gt; crate. Instead, the &lt;code&gt;art&lt;/code&gt; crate&amp;rsquo;s module structure causes confusion because developers have to figure out where to look, and the structure is inconvenient because developers must specify the module names in the &lt;code&gt;use&lt;/code&gt; statements.</source>
          <target state="translated">El autor del c&amp;oacute;digo del Listado 14-4, que usa la caja de &lt;code&gt;art&lt;/code&gt; e , tuvo que darse cuenta de que &lt;code&gt;PrimaryColor&lt;/code&gt; est&amp;aacute; en el m&amp;oacute;dulo de &lt;code&gt;kinds&lt;/code&gt; y la &lt;code&gt;mix&lt;/code&gt; est&amp;aacute; en el m&amp;oacute;dulo de &lt;code&gt;utils&lt;/code&gt; . La estructura del m&amp;oacute;dulo de la caja de &lt;code&gt;art&lt;/code&gt; e es m&amp;aacute;s relevante para los desarrolladores que trabajan en la caja de &lt;code&gt;art&lt;/code&gt; e que para los desarrolladores que utilizan la caja de &lt;code&gt;art&lt;/code&gt; e . La estructura interna que organiza partes de la caja en los &lt;code&gt;kinds&lt;/code&gt; de m&amp;oacute;dulo y el &lt;code&gt;utils&lt;/code&gt; m&amp;oacute;dulo no contiene ninguna informaci&amp;oacute;n &amp;uacute;til para alguien que trata de entender c&amp;oacute;mo utilizar el &lt;code&gt;art&lt;/code&gt; e del caj&amp;oacute;n. En cambio, el &lt;code&gt;art&lt;/code&gt; eLa estructura del m&amp;oacute;dulo de crate causa confusi&amp;oacute;n porque los desarrolladores tienen que averiguar d&amp;oacute;nde buscar, y la estructura es inconveniente porque los desarrolladores deben especificar los nombres de los m&amp;oacute;dulos en las declaraciones de &lt;code&gt;use&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8ebf8e3de6c2376fc1a32c2614c0e8023f7f60e" translate="yes" xml:space="preserve">
          <source>The author of this code probably wants &lt;code&gt;collect()&lt;/code&gt; to return a &lt;code&gt;Result&amp;lt;Vec&amp;lt;bool&amp;gt;, ()&amp;gt;&lt;/code&gt;, but the compiler can't be sure that there isn't another type &lt;code&gt;T&lt;/code&gt; implementing both &lt;code&gt;Try&lt;/code&gt; and &lt;code&gt;FromIterator&amp;lt;Result&amp;lt;bool, ()&amp;gt;&amp;gt;&lt;/code&gt; in scope such that &lt;code&gt;T::Ok == Vec&amp;lt;bool&amp;gt;&lt;/code&gt;. Hence, this code is ambiguous and an error is returned.</source>
          <target state="translated">El autor de este c&amp;oacute;digo probablemente quiera que &lt;code&gt;collect()&lt;/code&gt; devuelva un &lt;code&gt;Result&amp;lt;Vec&amp;lt;bool&amp;gt;, ()&amp;gt;&lt;/code&gt; , pero el compilador no puede estar seguro de que no haya otro tipo &lt;code&gt;T&lt;/code&gt; implementando &lt;code&gt;Try&lt;/code&gt; y &lt;code&gt;FromIterator&amp;lt;Result&amp;lt;bool, ()&amp;gt;&amp;gt;&lt;/code&gt; en un alcance tal que &lt;code&gt;T::Ok == Vec&amp;lt;bool&amp;gt;&lt;/code&gt; . Por lo tanto, este c&amp;oacute;digo es ambiguo y se devuelve un error.</target>
        </trans-unit>
        <trans-unit id="938569367b830c27a570a475e7cb23644f96b802" translate="yes" xml:space="preserve">
          <source>The author of this code probably wants &lt;code&gt;into()&lt;/code&gt; to return a &lt;code&gt;u64&lt;/code&gt;, but the compiler can't be sure that there isn't another type &lt;code&gt;T&lt;/code&gt; where both &lt;code&gt;u32: Into&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;u64: Add&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="946c3c8468dffe1ee08b57091aa458b31b356f72" translate="yes" xml:space="preserve">
          <source>The automatically generated &quot;drop glue&quot; which recursively calls the destructors of the all fields of this value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="442e142fa9a496c6c2ff3a02ee78aa50e228d6e4" translate="yes" xml:space="preserve">
          <source>The bad state is not something that&amp;rsquo;s &lt;em&gt;expected&lt;/em&gt; to happen occasionally.</source>
          <target state="translated">El mal estado no es algo que se &lt;em&gt;espera&lt;/em&gt; que suceda ocasionalmente.</target>
        </trans-unit>
        <trans-unit id="1030d03bed1910f08091eb456180338b656dc0aa" translate="yes" xml:space="preserve">
          <source>The base of a &lt;a href=&quot;expressions/struct-expr#functional-update-syntax&quot;&gt;functional update&lt;/a&gt; struct expression.</source>
          <target state="translated">La base de una expresi&amp;oacute;n de estructura de &lt;a href=&quot;expressions/struct-expr#functional-update-syntax&quot;&gt;actualizaci&amp;oacute;n funcional&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1da424ed8fd790e722f71cc50f820022f89f696b" translate="yes" xml:space="preserve">
          <source>The behavior of the returned &lt;code&gt;Waker&lt;/code&gt; is undefined if the contract defined in &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt;'s and &lt;a href=&quot;struct.rawwakervtable&quot;&gt;&lt;code&gt;RawWakerVTable&lt;/code&gt;&lt;/a&gt;'s documentation is not upheld. Therefore this method is unsafe.</source>
          <target state="translated">El comportamiento del &lt;code&gt;Waker&lt;/code&gt; devuelto no est&amp;aacute; definido si el contrato definido en la &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; de RawWaker y &lt;a href=&quot;struct.rawwakervtable&quot;&gt; &lt;code&gt;RawWakerVTable&lt;/code&gt; &lt;/a&gt; no se mantiene. Por tanto, este m&amp;eacute;todo no es seguro.</target>
        </trans-unit>
        <trans-unit id="c7f5bfcda53c0f0ccac4fbf04091f03de55bc719" translate="yes" xml:space="preserve">
          <source>The behavior of this method must be independent of the state of the &lt;code&gt;Read&lt;/code&gt;er - the method only takes &lt;code&gt;&amp;amp;self&lt;/code&gt; so that it can be used through trait objects.</source>
          <target state="translated">El comportamiento de este m&amp;eacute;todo debe ser independiente del estado de la &lt;code&gt;Read&lt;/code&gt; er - el m&amp;eacute;todo s&amp;oacute;lo toma &lt;code&gt;&amp;amp;self&lt;/code&gt; para que pueda ser utilizado a trav&amp;eacute;s rasgo objetos.</target>
        </trans-unit>
        <trans-unit id="92a385c5078364ae9300fa907e25a19462c00810" translate="yes" xml:space="preserve">
          <source>The benefit of having this restriction is that Rust can prevent data races at compile time. A &lt;em&gt;data race&lt;/em&gt; is similar to a race condition and happens when these three behaviors occur:</source>
          <target state="translated">El beneficio de tener esta restricci&amp;oacute;n es que Rust puede evitar carreras de datos en tiempo de compilaci&amp;oacute;n. Una &lt;em&gt;carrera de datos&lt;/em&gt; es similar a una condici&amp;oacute;n de carrera y ocurre cuando ocurren estos tres comportamientos:</target>
        </trans-unit>
        <trans-unit id="94345eda8bccf9faca124acc23e9dfc7f68245ec" translate="yes" xml:space="preserve">
          <source>The bits that define the access mode are masked out with &lt;code&gt;O_ACCMODE&lt;/code&gt;, to ensure they do not interfere with the access mode set by Rusts options.</source>
          <target state="translated">Los bits que definen el modo de acceso est&amp;aacute;n enmascarados con &lt;code&gt;O_ACCMODE&lt;/code&gt; , para garantizar que no interfieran con el modo de acceso establecido por las opciones de Rusts.</target>
        </trans-unit>
        <trans-unit id="eaa8e0a3053148a58d441c5d948ef0afd09016e9" translate="yes" xml:space="preserve">
          <source>The bitwise AND assignment operator &lt;code&gt;&amp;amp;=&lt;/code&gt;.</source>
          <target state="translated">El operador de asignaci&amp;oacute;n AND bit a bit &lt;code&gt;&amp;amp;=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1dd8ef8a8d73fdf98095248d6c0b2047cb203cf0" translate="yes" xml:space="preserve">
          <source>The bitwise AND operator &lt;code&gt;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">El operador AND bit a bit &lt;code&gt;&amp;amp;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2bfdab4f43dd337afc8fc0552897bf0d88f4fb0e" translate="yes" xml:space="preserve">
          <source>The bitwise OR assignment operator &lt;code&gt;|=&lt;/code&gt;.</source>
          <target state="translated">El operador de asignaci&amp;oacute;n OR bit a bit &lt;code&gt;|=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a78ed80e19856e33ead5257328ef19e1b110eb08" translate="yes" xml:space="preserve">
          <source>The bitwise OR operator &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="translated">El operador OR bit a bit &lt;code&gt;|&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eafeed4a6ad02f43abd1d07f62b4dea554b3a79c" translate="yes" xml:space="preserve">
          <source>The bitwise XOR assignment operator &lt;code&gt;^=&lt;/code&gt;.</source>
          <target state="translated">El operador de asignaci&amp;oacute;n XOR bit a bit &lt;code&gt;^=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e805a1bbc089611af418b7bd9e638939dac553c5" translate="yes" xml:space="preserve">
          <source>The bitwise XOR operator &lt;code&gt;^&lt;/code&gt;.</source>
          <target state="translated">El operador XOR bit a bit &lt;code&gt;^&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9231fb12ba981aafd28f24ac7946a833b22a70e" translate="yes" xml:space="preserve">
          <source>The block must be allocated with the same alignment as &lt;a href=&quot;struct.layout#method.align&quot;&gt;&lt;code&gt;layout.align()&lt;/code&gt;&lt;/a&gt;, and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="423b8775203e06b0ca354c4f4e97825a7d00a713" translate="yes" xml:space="preserve">
          <source>The block of a function is conceptually wrapped in a block that binds the argument patterns and then &lt;code&gt;return&lt;/code&gt;s the value of the function's block. This means that the tail expression of the block, if evaluated, ends up being returned to the caller. As usual, an explicit return expression within the body of the function will short-cut that implicit return, if reached.</source>
          <target state="translated">El bloque de una funci&amp;oacute;n est&amp;aacute; conceptualmente envuelto en un bloque que une los patrones de argumento y luego &lt;code&gt;return&lt;/code&gt; el valor del bloque de la funci&amp;oacute;n. Esto significa que la expresi&amp;oacute;n de cola del bloque, si se eval&amp;uacute;a, termina devolvi&amp;eacute;ndose al llamador. Como de costumbre, una expresi&amp;oacute;n de retorno expl&amp;iacute;cita dentro del cuerpo de la funci&amp;oacute;n acortar&amp;aacute; ese retorno impl&amp;iacute;cito, si se alcanza.</target>
        </trans-unit>
        <trans-unit id="761ca0a326eb25085e5f1ebfbcef3b94f323b7c7" translate="yes" xml:space="preserve">
          <source>The block's size must fall in the range &lt;code&gt;[use_min, use_max]&lt;/code&gt;, where:</source>
          <target state="translated">El tama&amp;ntilde;o del bloque debe estar en el rango &lt;code&gt;[use_min, use_max]&lt;/code&gt; , donde:</target>
        </trans-unit>
        <trans-unit id="0d55dd5d42feb75840d81a2ee396cf125ff6a36f" translate="yes" xml:space="preserve">
          <source>The block's starting address must be aligned to &lt;code&gt;layout.align()&lt;/code&gt;.</source>
          <target state="translated">La direcci&amp;oacute;n de inicio del bloque debe estar alineada con &lt;code&gt;layout.align()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6fb5efe10f486c51a18bce4f54350dd31c9d18ad" translate="yes" xml:space="preserve">
          <source>The bodies of the &lt;code&gt;if let&lt;/code&gt; and the &lt;code&gt;unwrap_or_else&lt;/code&gt; functions are the same in both cases: we print the error and exit.</source>
          <target state="translated">Los cuerpos de las funciones &lt;code&gt;if let&lt;/code&gt; y &lt;code&gt;unwrap_or_else&lt;/code&gt; son los mismos en ambos casos: imprimimos el error y salimos.</target>
        </trans-unit>
        <trans-unit id="a084bd821dcd5af3bead7d20966da99b85c8d3d6" translate="yes" xml:space="preserve">
          <source>The body of a &lt;a href=&quot;expressions/if-expr#if-expressions&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;expressions/loop-expr#predicate-loops&quot;&gt;&lt;code&gt;while&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;expressions/loop-expr#infinite-loops&quot;&gt;&lt;code&gt;loop&lt;/code&gt;&lt;/a&gt; expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d22837f9a0a24391528e1a0b3b2365c1d2579bc" translate="yes" xml:space="preserve">
          <source>The body of the function starts by calling the &lt;code&gt;File::open&lt;/code&gt; function. Then we handle the &lt;code&gt;Result&lt;/code&gt; value returned with a &lt;code&gt;match&lt;/code&gt; similar to the &lt;code&gt;match&lt;/code&gt; in Listing 9-4, only instead of calling &lt;code&gt;panic!&lt;/code&gt; in the &lt;code&gt;Err&lt;/code&gt; case, we return early from this function and pass the error value from &lt;code&gt;File::open&lt;/code&gt; back to the calling code as this function&amp;rsquo;s error value. If &lt;code&gt;File::open&lt;/code&gt; succeeds, we store the file handle in the variable &lt;code&gt;f&lt;/code&gt; and continue.</source>
          <target state="translated">El cuerpo de la funci&amp;oacute;n comienza llamando a la funci&amp;oacute;n &lt;code&gt;File::open&lt;/code&gt; . Luego manejamos el valor de &lt;code&gt;Result&lt;/code&gt; ado devuelto con una &lt;code&gt;match&lt;/code&gt; similar a la &lt;code&gt;match&lt;/code&gt; Listado 9-4, &amp;iexcl;solo que en lugar de llamar al &lt;code&gt;panic!&lt;/code&gt; en el caso de &lt;code&gt;Err&lt;/code&gt; , regresamos antes de esta funci&amp;oacute;n y pasamos el valor de error de &lt;code&gt;File::open&lt;/code&gt; al c&amp;oacute;digo de llamada como el valor de error de esta funci&amp;oacute;n. Si &lt;code&gt;File::open&lt;/code&gt; tiene &amp;eacute;xito, almacenamos el identificador del archivo en la variable &lt;code&gt;f&lt;/code&gt; y continuamos.</target>
        </trans-unit>
        <trans-unit id="9ba4d0e4523a23a56b57272682f48b03a790c657" translate="yes" xml:space="preserve">
          <source>The body of the method would use &lt;code&gt;self&lt;/code&gt; to get the value that we called the method on. In this example, we&amp;rsquo;ve created a variable &lt;code&gt;m&lt;/code&gt; that has the value &lt;code&gt;Message::Write(String::from(&quot;hello&quot;))&lt;/code&gt;, and that is what &lt;code&gt;self&lt;/code&gt; will be in the body of the &lt;code&gt;call&lt;/code&gt; method when &lt;code&gt;m.call()&lt;/code&gt; runs.</source>
          <target state="translated">El cuerpo del m&amp;eacute;todo usar&amp;iacute;a &lt;code&gt;self&lt;/code&gt; para obtener el valor en el que llamamos al m&amp;eacute;todo. En este ejemplo, hemos creado una variable &lt;code&gt;m&lt;/code&gt; que tiene el valor &lt;code&gt;Message::Write(String::from(&quot;hello&quot;))&lt;/code&gt; , y eso es lo que &lt;code&gt;self&lt;/code&gt; estar&amp;aacute; en el cuerpo del m&amp;eacute;todo de &lt;code&gt;call&lt;/code&gt; cuando &lt;code&gt;m.call()&lt;/code&gt; corre.</target>
        </trans-unit>
        <trans-unit id="9c00fd6128e2bdd1cc90bd415df84de85499f4fb" translate="yes" xml:space="preserve">
          <source>The book &lt;em&gt;Design Patterns: Elements of Reusable Object-Oriented Software&lt;/em&gt; by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (Addison-Wesley Professional, 1994) colloquially referred to as &lt;em&gt;The Gang of Four&lt;/em&gt; book, is a catalog of object-oriented design patterns. It defines OOP this way:</source>
          <target state="translated">El libro &lt;em&gt;Design Patterns: Elements of Reusable Object-Oriented Software&lt;/em&gt; de Erich Gamma, Richard Helm, Ralph Johnson y John Vlissides (Addison-Wesley Professional, 1994), conocido coloquialmente como &lt;em&gt;The Gang of Four&lt;/em&gt; , es un cat&amp;aacute;logo de libros orientados a objetos. patrones de dise&amp;ntilde;o. Define OOP de esta manera:</target>
        </trans-unit>
        <trans-unit id="0ab81c05a8d6cbaec3e9dfb9c8caa2a16dab19bf" translate="yes" xml:space="preserve">
          <source>The boolean type.</source>
          <target state="translated">El tipo booleano.</target>
        </trans-unit>
        <trans-unit id="06283747a377154700dbba912c9e77d60011a87e" translate="yes" xml:space="preserve">
          <source>The borrow lasts until the returned &lt;code&gt;Ref&lt;/code&gt; exits scope. Multiple immutable borrows can be taken out at the same time.</source>
          <target state="translated">El pr&amp;eacute;stamo dura hasta que la &lt;code&gt;Ref&lt;/code&gt; devuelta sale del alcance. Se pueden tomar varios pr&amp;eacute;stamos inmutables al mismo tiempo.</target>
        </trans-unit>
        <trans-unit id="45376451530857b96a10ec4a5e20bb51cfc0ed12" translate="yes" xml:space="preserve">
          <source>The borrow lasts until the returned &lt;code&gt;RefMut&lt;/code&gt; or all &lt;code&gt;RefMut&lt;/code&gt;s derived from it exit scope. The value cannot be borrowed while this borrow is active.</source>
          <target state="translated">El pr&amp;eacute;stamo dura hasta que &lt;code&gt;RefMut&lt;/code&gt; devuelto o todos los &lt;code&gt;RefMut&lt;/code&gt; derivados de su alcance de salida. El valor no se puede tomar prestado mientras este pr&amp;eacute;stamo est&amp;eacute; activo.</target>
        </trans-unit>
        <trans-unit id="f968733bf846dacfb002493e18e27a27864a5d95" translate="yes" xml:space="preserve">
          <source>The buffer is written out before returning the writer.</source>
          <target state="translated">La memoria intermedia se escribe antes de devolver al escritor.</target>
        </trans-unit>
        <trans-unit id="8d2f5c9c4df44bd26200b02c526dd9675a0b62ea" translate="yes" xml:space="preserve">
          <source>The buffer specified was 0 bytes in length.</source>
          <target state="translated">La memoria intermedia especificada tenía una longitud de 0 bytes.</target>
        </trans-unit>
        <trans-unit id="aac2e47b3535d051db39f7a14fa1dba18fc6a121" translate="yes" xml:space="preserve">
          <source>The built-in &lt;code&gt;cfg&lt;/code&gt; macro takes in a single configuration predicate and evaluates to the &lt;code&gt;true&lt;/code&gt; literal when the predicate is true and the &lt;code&gt;false&lt;/code&gt; literal when it is false.</source>
          <target state="translated">La macro &lt;code&gt;cfg&lt;/code&gt; incorporada toma un &amp;uacute;nico predicado de configuraci&amp;oacute;n y eval&amp;uacute;a el literal &lt;code&gt;true&lt;/code&gt; cuando el predicado es verdadero y el literal &lt;code&gt;false&lt;/code&gt; cuando es falso.</target>
        </trans-unit>
        <trans-unit id="87ae881f172e3eab463a1dba119d942ed8deaed7" translate="yes" xml:space="preserve">
          <source>The built-in attributes that have meaning on a function are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;, &lt;code&gt;path&lt;/code&gt;, and &lt;code&gt;no_implicit_prelude&lt;/code&gt;. Modules also accept macro attributes.</source>
          <target state="translated">Los atributos integrados que tienen significado en una funci&amp;oacute;n son &lt;a href=&quot;../conditional-compilation&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt; &lt;code&gt;doc&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;los atributos de comprobaci&amp;oacute;n de pelusa&lt;/a&gt; , &lt;code&gt;path&lt;/code&gt; y &lt;code&gt;no_implicit_prelude&lt;/code&gt; . Los m&amp;oacute;dulos tambi&amp;eacute;n aceptan atributos de macro.</target>
        </trans-unit>
        <trans-unit id="0658caeac4e6cc6250807a10a1d1127da8f7b8cb" translate="yes" xml:space="preserve">
          <source>The built-in attributes that have meaning on a module are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;, &lt;code&gt;path&lt;/code&gt;, and &lt;code&gt;no_implicit_prelude&lt;/code&gt;. Modules also accept macro attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7917b1e20d5567c345241cec71cc654edebdd434" translate="yes" xml:space="preserve">
          <source>The built-in function traits are generic over a tuple of the function arguments. If one uses angle-bracket notation (&lt;code&gt;Fn&amp;lt;(T,), Output=U&amp;gt;&lt;/code&gt;) instead of parentheses (&lt;code&gt;Fn(T) -&amp;gt; U&lt;/code&gt;) to denote the function trait, the type parameter should be a tuple. Otherwise function call notation cannot be used and the trait will not be implemented by closures.</source>
          <target state="translated">Los rasgos de la funci&amp;oacute;n incorporados son gen&amp;eacute;ricos sobre una tupla de los argumentos de la funci&amp;oacute;n. Si se usa la notaci&amp;oacute;n entre corchetes angulares ( &lt;code&gt;Fn&amp;lt;(T,), Output=U&amp;gt;&lt;/code&gt; ) en lugar de par&amp;eacute;ntesis ( &lt;code&gt;Fn(T) -&amp;gt; U&lt;/code&gt; ) para denotar el rasgo de la funci&amp;oacute;n, el par&amp;aacute;metro de tipo debe ser una tupla. De lo contrario, no se puede utilizar la notaci&amp;oacute;n de llamada a funci&amp;oacute;n y los cierres no implementar&amp;aacute;n el rasgo.</target>
        </trans-unit>
        <trans-unit id="a9e1ef14ad9c5016cccb06e0dae0b41ca0441837" translate="yes" xml:space="preserve">
          <source>The c-main function only supports to return integers as return type. So, every type implementing the &lt;code&gt;Termination&lt;/code&gt; trait has to be converted to an integer.</source>
          <target state="translated">La funci&amp;oacute;n c-main solo admite la devoluci&amp;oacute;n de enteros como tipo de retorno. Por lo tanto, cada tipo que implemente el rasgo de &lt;code&gt;Termination&lt;/code&gt; debe convertirse en un n&amp;uacute;mero entero.</target>
        </trans-unit>
        <trans-unit id="98a1e057ef0866ad400391fbf23a2daa11b28012" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;lock&lt;/code&gt; would fail if another thread holding the lock panicked. In that case, no one would ever be able to get the lock, so we&amp;rsquo;ve chosen to &lt;code&gt;unwrap&lt;/code&gt; and have this thread panic if we&amp;rsquo;re in that situation.</source>
          <target state="translated">La llamada a &lt;code&gt;lock&lt;/code&gt; fallar&amp;iacute;a si otro hilo que sostiene el bloqueo entrara en p&amp;aacute;nico. En ese caso, nadie podr&amp;iacute;a obtener el candado, por lo que hemos optado por &lt;code&gt;unwrap&lt;/code&gt; y este hilo entra en p&amp;aacute;nico si estamos en esa situaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a399c55a0729e88865a33bb045bf002d26006429" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;panic!&lt;/code&gt; causes the error message contained in the last two lines. The first line shows our panic message and the place in our source code where the panic occurred: &lt;em&gt;src/main.rs:2:5&lt;/em&gt; indicates that it&amp;rsquo;s the second line, fifth character of our &lt;em&gt;src/main.rs&lt;/em&gt; file.</source>
          <target state="translated">&amp;iexcl;La llamada al &lt;code&gt;panic!&lt;/code&gt; provoca el mensaje de error contenido en las dos &amp;uacute;ltimas l&amp;iacute;neas. La primera l&amp;iacute;nea muestra nuestro mensaje de p&amp;aacute;nico y el lugar en nuestro c&amp;oacute;digo fuente donde ocurri&amp;oacute; el p&amp;aacute;nico: &lt;em&gt;src / main.rs: 2: 5&lt;/em&gt; indica que es la segunda l&amp;iacute;nea, el quinto car&amp;aacute;cter de nuestro archivo &lt;em&gt;src / main.rs.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="76991560cfa9d5bcd0a2eea05c7ac9259a741680" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;parse&lt;/code&gt; could easily cause an error. If, for example, the string contained &lt;code&gt;A👍%&lt;/code&gt;, there would be no way to convert that to a number. Because it might fail, the &lt;code&gt;parse&lt;/code&gt; method returns a &lt;code&gt;Result&lt;/code&gt; type, much as the &lt;code&gt;read_line&lt;/code&gt; method does (discussed earlier in &lt;a href=&quot;#handling-potential-failure-with-the-result-type&quot;&gt;&amp;ldquo;Handling Potential Failure with the &lt;code&gt;Result&lt;/code&gt; Type&amp;rdquo;&lt;/a&gt;). We&amp;rsquo;ll treat this &lt;code&gt;Result&lt;/code&gt; the same way by using the &lt;code&gt;expect&lt;/code&gt; method again. If &lt;code&gt;parse&lt;/code&gt; returns an &lt;code&gt;Err&lt;/code&gt;&lt;code&gt;Result&lt;/code&gt; variant because it couldn&amp;rsquo;t create a number from the string, the &lt;code&gt;expect&lt;/code&gt; call will crash the game and print the message we give it. If &lt;code&gt;parse&lt;/code&gt; can successfully convert the string to a number, it will return the &lt;code&gt;Ok&lt;/code&gt; variant of &lt;code&gt;Result&lt;/code&gt;, and &lt;code&gt;expect&lt;/code&gt; will return the number that we want from the &lt;code&gt;Ok&lt;/code&gt; value.</source>
          <target state="translated">La llamada a &lt;code&gt;parse&lt;/code&gt; f&amp;aacute;cilmente podr&amp;iacute;a provocar un error. Si, por ejemplo, la cadena contuviera &lt;code&gt;A👍%&lt;/code&gt; , no habr&amp;iacute;a forma de convertir eso en un n&amp;uacute;mero. Debido a que puede fallar, el m&amp;eacute;todo de &lt;code&gt;parse&lt;/code&gt; devuelve un tipo de &lt;code&gt;Result&lt;/code&gt; , al igual que lo &lt;code&gt;read_line&lt;/code&gt; m&amp;eacute;todo read_line (discutido anteriormente en &lt;a href=&quot;#handling-potential-failure-with-the-result-type&quot;&gt;&amp;ldquo;Manejo de fallas potenciales con el tipo de &lt;code&gt;Result&lt;/code&gt; &amp;rdquo;&lt;/a&gt; ). Trataremos este &lt;code&gt;Result&lt;/code&gt; la misma manera usando el m&amp;eacute;todo de &lt;code&gt;expect&lt;/code&gt; nuevamente. Si &lt;code&gt;parse&lt;/code&gt; devuelve una llamada &lt;code&gt;Err&lt;/code&gt; bloquear&amp;aacute; el juego e imprimir&amp;aacute; el mensaje que le damos. Si &lt;code&gt;parse&lt;/code&gt; &lt;code&gt;Result&lt;/code&gt; variante Result porque no pudo crear un n&amp;uacute;mero a partir de la cadena, se &lt;code&gt;expect&lt;/code&gt; puede convertir correctamente la cadena en un n&amp;uacute;mero, devolver&amp;aacute; la variante &lt;code&gt;Ok&lt;/code&gt; de &lt;code&gt;Result&lt;/code&gt; , y &lt;code&gt;expect&lt;/code&gt; que devuelva el n&amp;uacute;mero que queremos del valor &lt;code&gt;Ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b69e26d39a3f8839842ab3c559f82019ca9b310" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;recv&lt;/code&gt; blocks, so if there is no job yet, the current thread will wait until a job becomes available. The &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; ensures that only one &lt;code&gt;Worker&lt;/code&gt; thread at a time is trying to request a job.</source>
          <target state="translated">La llamada a &lt;code&gt;recv&lt;/code&gt; bloquea, por lo que si a&amp;uacute;n no hay ning&amp;uacute;n trabajo, el hilo actual esperar&amp;aacute; hasta que haya un trabajo disponible. El &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; asegura que s&amp;oacute;lo un &lt;code&gt;Worker&lt;/code&gt; hilo a la vez est&amp;aacute; tratando de solicitar un puesto de trabajo.</target>
        </trans-unit>
        <trans-unit id="8993444f4968db6cec0c3f76e82220cf7def7574" translate="yes" xml:space="preserve">
          <source>The caller has to ensure that no references in the supplied thread closure or its return type can outlive the spawned thread's lifetime. This can be guaranteed in two ways:</source>
          <target state="translated">La persona que llama tiene que asegurarse de que ninguna referencia en el cierre del hilo suministrado o su tipo de devolución pueda sobrevivir a la vida del hilo engendrado.Esto se puede garantizar de dos maneras:</target>
        </trans-unit>
        <trans-unit id="093036972d7bffcd0b16a57c6e2ba75deeb1dca1" translate="yes" xml:space="preserve">
          <source>The caller must also ensure that the memory the pointer (non-transitively) points to is never written to (except inside an &lt;code&gt;UnsafeCell&lt;/code&gt;) using this pointer or any pointer derived from it. If you need to mutate the contents of the slice, use &lt;a href=&quot;#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La persona que llama tambi&amp;eacute;n debe asegurarse de que la memoria a la que apunta el puntero (no transitivamente) nunca se escriba (excepto dentro de una &lt;code&gt;UnsafeCell&lt;/code&gt; ) utilizando este puntero o cualquier puntero derivado de &amp;eacute;l. Si necesita mutar el contenido del segmento, use&lt;a href=&quot;#method.as_mut_ptr&quot;&gt; &lt;code&gt;as_mut_ptr&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fbd8e378206e5ebe48537e21894c0d0196aa5c37" translate="yes" xml:space="preserve">
          <source>The caller must also ensure that the memory the pointer (non-transitively) points to is never written to (except inside an &lt;code&gt;UnsafeCell&lt;/code&gt;) using this pointer or any pointer derived from it. If you need to mutate the contents of the slice, use &lt;a href=&quot;struct.vec#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2daa4ea0adccac77e0ee2e5186b78bccb935a23d" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the content of the slice is valid UTF-8 before the borrow ends and the underlying &lt;code&gt;str&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac3ada34e0728cb1a740ac35a9a92bd4109e42c8" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the returned pointer is never written to. If you need to mutate the contents of the string slice, use &lt;a href=&quot;#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La persona que llama debe asegurarse de que nunca se escriba en el puntero devuelto. Si necesita mutar el contenido del segmento de cadena, use &lt;a href=&quot;#method.as_mut_ptr&quot;&gt; &lt;code&gt;as_mut_ptr&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0c95ecf028004da1510b460935745006e917bea1" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the returned pointer is never written to. If you need to mutate the contents of the string slice, use &lt;a href=&quot;../primitive.str#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de2dba4a5088d0450aaa1d7584230c3882b4aa0e" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the returned pointer is never written to. If you need to mutate the contents of the string slice, use &lt;a href=&quot;primitive.str#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0392a3d2bc79f7cc36923d474ab5bb48f657c119" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the slice outlives the pointer this function returns, or else it will end up pointing to garbage.</source>
          <target state="translated">La persona que llama debe asegurarse de que la rebanada sobreviva al puntero que esta función devuelve,o de lo contrario terminará apuntando a la basura.</target>
        </trans-unit>
        <trans-unit id="bf480a8080607d02f4b53d9ea9e935964787c02b" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the vector outlives the pointer this function returns, or else it will end up pointing to garbage. Modifying the vector may cause its buffer to be reallocated, which would also make any pointers to it invalid.</source>
          <target state="translated">El llamador debe asegurarse de que el vector sobreviva al puntero que esta función devuelve,o de lo contrario terminará apuntando a la basura.Modificar el vector puede causar que su búfer sea reasignado,lo que también haría que cualquier puntero hacia él sea inválido.</target>
        </trans-unit>
        <trans-unit id="09005f0066a1b73d30e33e09129bf20aee61c736" translate="yes" xml:space="preserve">
          <source>The calling thread will be blocked until there are no more writers which hold the lock. There may be other readers currently inside the lock when this method returns. This method does not provide any guarantees with respect to the ordering of whether contentious readers or writers will acquire the lock first.</source>
          <target state="translated">El hilo de llamada se bloqueará hasta que no haya más escritores que mantengan el bloqueo.Puede que haya otros lectores actualmente dentro del candado cuando este método regrese.Este método no ofrece ninguna garantía con respecto al orden de si los lectores o escritores contenciosos adquirirán primero el candado.</target>
        </trans-unit>
        <trans-unit id="4c684d1da6df1a86528a2f3d33b0bb20fea3d352" translate="yes" xml:space="preserve">
          <source>The calls to &lt;code&gt;thread::sleep&lt;/code&gt; force a thread to stop its execution for a short duration, allowing a different thread to run. The threads will probably take turns, but that isn&amp;rsquo;t guaranteed: it depends on how your operating system schedules the threads. In this run, the main thread printed first, even though the print statement from the spawned thread appears first in the code. And even though we told the spawned thread to print until &lt;code&gt;i&lt;/code&gt; is 9, it only got to 5 before the main thread shut down.</source>
          <target state="translated">Las llamadas a &lt;code&gt;thread::sleep&lt;/code&gt; obligan a un hilo a detener su ejecuci&amp;oacute;n durante un breve per&amp;iacute;odo, lo que permite que se ejecute un hilo diferente. Los hilos probablemente se turnar&amp;aacute;n, pero eso no est&amp;aacute; garantizado: depende de c&amp;oacute;mo su sistema operativo programe los hilos. En esta ejecuci&amp;oacute;n, el hilo principal se imprimi&amp;oacute; primero, aunque la declaraci&amp;oacute;n de impresi&amp;oacute;n del hilo generado aparece primero en el c&amp;oacute;digo. Y aunque le dijimos al hilo generado que imprimiera hasta &lt;code&gt;i&lt;/code&gt; sea ​​9, solo lleg&amp;oacute; a 5 antes de que el hilo principal se apagara.</target>
        </trans-unit>
        <trans-unit id="c7560eebffb8ae3cdb259698d7be211bc4620b7e" translate="yes" xml:space="preserve">
          <source>The canonical ExitCode for successful termination on this platform.</source>
          <target state="translated">El código de salida canónico para la terminación exitosa en esta plataforma.</target>
        </trans-unit>
        <trans-unit id="8f6ef1b9ea50b970966541a96ea6f822d628893b" translate="yes" xml:space="preserve">
          <source>The canonical ExitCode for unsuccessful termination on this platform.</source>
          <target state="translated">El código de salida canónico para la terminación sin éxito en esta plataforma.</target>
        </trans-unit>
        <trans-unit id="edfe5292e463236ad7502b40af63d1dc3846bebd" translate="yes" xml:space="preserve">
          <source>The canonical path is only meaningful within a given crate. There is no global namespace across crates; an item's canonical path merely identifies it within the crate.</source>
          <target state="translated">El camino canónico sólo tiene sentido dentro de una caja determinada.No hay un espacio de nombres global a través de los cajones;el camino canónico de un artículo sólo lo identifica dentro del cajón.</target>
        </trans-unit>
        <trans-unit id="42b8d1ea1b4247711765802c026fc2d790b1362d" translate="yes" xml:space="preserve">
          <source>The canonical safe use of &lt;code&gt;mem::forget&lt;/code&gt; is to circumvent a value's destructor implemented by the &lt;code&gt;Drop&lt;/code&gt; trait. For example, this will leak a &lt;code&gt;File&lt;/code&gt;, i.e. reclaim the space taken by the variable but never close the underlying system resource:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aa3ddcbed06fec001e59bb6f3f1f1da2ef18ef6" translate="yes" xml:space="preserve">
          <source>The capacity may be increased by more than &lt;code&gt;additional&lt;/code&gt; bytes if it chooses, to prevent frequent reallocations.</source>
          <target state="translated">La capacidad puede aumentarse en m&amp;aacute;s de &lt;code&gt;additional&lt;/code&gt; bytes si lo desea, para evitar que las reasignaciones frecuentes.</target>
        </trans-unit>
        <trans-unit id="4e527152d8f3ca4ddc869842d5ee9ae2a46a82fb" translate="yes" xml:space="preserve">
          <source>The capacity of a vector is the amount of space allocated for any future elements that will be added onto the vector. This is not to be confused with the &lt;em&gt;length&lt;/em&gt; of a vector, which specifies the number of actual elements within the vector. If a vector's length exceeds its capacity, its capacity will automatically be increased, but its elements will have to be reallocated.</source>
          <target state="translated">La capacidad de un vector es la cantidad de espacio asignada para cualquier elemento futuro que se agregar&amp;aacute; al vector. Esto no debe confundirse con el&lt;em&gt; longitud&lt;/em&gt; de un vector, que especifica el n&amp;uacute;mero de elementos reales dentro del vector. Si la longitud de un vector excede su capacidad, su capacidad aumentar&amp;aacute; autom&amp;aacute;ticamente, pero sus elementos deber&amp;aacute;n reasignarse.</target>
        </trans-unit>
        <trans-unit id="a70fb21498dabd7b592b7614b4af0ad2efc52b05" translate="yes" xml:space="preserve">
          <source>The capacity will remain at least as large as both the length and the supplied value.</source>
          <target state="translated">La capacidad seguirá siendo al menos tan grande como la longitud y el valor suministrado.</target>
        </trans-unit>
        <trans-unit id="f2f4d42ff0e5eed287aac391d229f38ad7615e31" translate="yes" xml:space="preserve">
          <source>The captured values of a &lt;a href=&quot;types/closure&quot;&gt;closure&lt;/a&gt; are dropped in an unspecified order.</source>
          <target state="translated">Los valores capturados de un &lt;a href=&quot;types/closure&quot;&gt;cierre&lt;/a&gt; se eliminan en un orden no especificado.</target>
        </trans-unit>
        <trans-unit id="138edd42fa740c68b92f8f2886d9a7cfd608a2f8" translate="yes" xml:space="preserve">
          <source>The changes we needed to make to &lt;code&gt;main&lt;/code&gt; to reassign &lt;code&gt;post&lt;/code&gt; mean that this implementation doesn&amp;rsquo;t quite follow the object-oriented state pattern anymore: the transformations between the states are no longer encapsulated entirely within the &lt;code&gt;Post&lt;/code&gt; implementation. However, our gain is that invalid states are now impossible because of the type system and the type checking that happens at compile time! This ensures that certain bugs, such as display of the content of an unpublished post, will be discovered before they make it to production.</source>
          <target state="translated">Los cambios que necesit&amp;aacute;bamos hacer en &lt;code&gt;main&lt;/code&gt; para reasignar la &lt;code&gt;post&lt;/code&gt; significan que esta implementaci&amp;oacute;n ya no sigue el patr&amp;oacute;n de estado orientado a objetos: las transformaciones entre los estados ya no est&amp;aacute;n encapsuladas por completo dentro de la &lt;code&gt;Post&lt;/code&gt; implementaci&amp;oacute;n de . Sin embargo, nuestro beneficio es que los estados inv&amp;aacute;lidos ahora son imposibles debido al sistema de tipos y la verificaci&amp;oacute;n de tipos que ocurre en el momento de la compilaci&amp;oacute;n. Esto asegura que ciertos errores, como la visualizaci&amp;oacute;n del contenido de una publicaci&amp;oacute;n no publicada, ser&amp;aacute;n descubiertos antes de que lleguen a producci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7c6978553f5d9c2a253b6007e164ab1e1253e787" translate="yes" xml:space="preserve">
          <source>The character represented by this escape</source>
          <target state="translated">El personaje representado por esta fuga</target>
        </trans-unit>
        <trans-unit id="444f11cad1e3ea489affb1093e4cfe00aec033b8" translate="yes" xml:space="preserve">
          <source>The character type, &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">El tipo de car&amp;aacute;cter, &lt;code&gt;char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2ab8aadbe1c6203ddb8254dc62679ad2d0d6a50" translate="yes" xml:space="preserve">
          <source>The child inherits from the corresponding parent descriptor.</source>
          <target state="translated">El hijo hereda del padre descriptor correspondiente.</target>
        </trans-unit>
        <trans-unit id="57f64da60a0aae4c7ca65b39d52634b157698777" translate="yes" xml:space="preserve">
          <source>The chunks are array references and do not overlap. If &lt;code&gt;N&lt;/code&gt; does not divide the length of the slice, then the last up to &lt;code&gt;N-1&lt;/code&gt; elements will be omitted and can be retrieved from the &lt;code&gt;remainder&lt;/code&gt; function of the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15fa38fbe64a63fe95b52b94271d4ba554613043" translate="yes" xml:space="preserve">
          <source>The chunks are mutable array references and do not overlap. If &lt;code&gt;N&lt;/code&gt; does not divide the length of the slice, then the last up to &lt;code&gt;N-1&lt;/code&gt; elements will be omitted and can be retrieved from the &lt;code&gt;into_remainder&lt;/code&gt; function of the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22f36eeee32622c7a505cef344bfce71a990d798" translate="yes" xml:space="preserve">
          <source>The chunks are mutable slices, and do not overlap. If &lt;code&gt;chunk_size&lt;/code&gt; does not divide the length of the slice, then the last chunk will not have length &lt;code&gt;chunk_size&lt;/code&gt;.</source>
          <target state="translated">Los trozos son cortes mutables y no se superponen. Si &lt;code&gt;chunk_size&lt;/code&gt; no divide la longitud del segmento, entonces el &amp;uacute;ltimo trozo no tendr&amp;aacute; la longitud &lt;code&gt;chunk_size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a56cc46096f73dcb9c3581ef24840c1b8a52d3e3" translate="yes" xml:space="preserve">
          <source>The chunks are mutable slices, and do not overlap. If &lt;code&gt;chunk_size&lt;/code&gt; does not divide the length of the slice, then the last up to &lt;code&gt;chunk_size-1&lt;/code&gt; elements will be omitted and can be retrieved from the &lt;code&gt;into_remainder&lt;/code&gt; function of the iterator.</source>
          <target state="translated">Los trozos son cortes mutables y no se superponen. Si &lt;code&gt;chunk_size&lt;/code&gt; no divide la longitud del segmento, los &amp;uacute;ltimos elementos hasta &lt;code&gt;chunk_size-1&lt;/code&gt; se omitir&amp;aacute;n y se podr&amp;aacute;n recuperar de la funci&amp;oacute;n &lt;code&gt;into_remainder&lt;/code&gt; del iterador.</target>
        </trans-unit>
        <trans-unit id="b9b82e1f955649f5c987c92e4ad59440a3cb7655" translate="yes" xml:space="preserve">
          <source>The chunks are slices and do not overlap. If &lt;code&gt;chunk_size&lt;/code&gt; does not divide the length of the slice, then the last chunk will not have length &lt;code&gt;chunk_size&lt;/code&gt;.</source>
          <target state="translated">Los trozos son rodajas y no se superponen. Si &lt;code&gt;chunk_size&lt;/code&gt; no divide la longitud del segmento, el &amp;uacute;ltimo trozo no tendr&amp;aacute; la longitud &lt;code&gt;chunk_size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93ee6025794c31565e33ecdc52225cb4e18501bf" translate="yes" xml:space="preserve">
          <source>The chunks are slices and do not overlap. If &lt;code&gt;chunk_size&lt;/code&gt; does not divide the length of the slice, then the last up to &lt;code&gt;chunk_size-1&lt;/code&gt; elements will be omitted and can be retrieved from the &lt;code&gt;remainder&lt;/code&gt; function of the iterator.</source>
          <target state="translated">Los trozos son rodajas y no se superponen. Si &lt;code&gt;chunk_size&lt;/code&gt; no divide la longitud del segmento, los &amp;uacute;ltimos elementos hasta &lt;code&gt;chunk_size-1&lt;/code&gt; se omitir&amp;aacute;n y se podr&amp;aacute;n recuperar del &lt;code&gt;remainder&lt;/code&gt; funci&amp;oacute;n del iterador.</target>
        </trans-unit>
        <trans-unit id="5ab8cfd0030cc999866ad155de372dfc9a291653" translate="yes" xml:space="preserve">
          <source>The closure &lt;code&gt;f&lt;/code&gt; is yielded a &lt;a href=&quot;struct.oncestate&quot;&gt;&lt;code&gt;OnceState&lt;/code&gt;&lt;/a&gt; structure which can be used to query the poison status of the &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8464cb339a91ac7f9edf87e86826287afbdde678" translate="yes" xml:space="preserve">
          <source>The closure &lt;code&gt;f&lt;/code&gt; is yielded a &lt;a href=&quot;struct.oncestate&quot;&gt;&lt;code&gt;OnceState&lt;/code&gt;&lt;/a&gt; structure which can be used to query the poison status of the &lt;code&gt;Once&lt;/code&gt;.</source>
          <target state="translated">El cierre &lt;code&gt;f&lt;/code&gt; produce una estructura &lt;a href=&quot;struct.oncestate&quot;&gt; &lt;code&gt;OnceState&lt;/code&gt; &lt;/a&gt; que se puede utilizar para consultar el estado de envenenamiento de &lt;code&gt;Once&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6122336d1e3dc25f0e6a48ca5c6617d72884ddeb" translate="yes" xml:space="preserve">
          <source>The closure &lt;code&gt;f&lt;/code&gt; will only be executed once if this is called concurrently amongst many threads. If that closure panics, however, then it will &lt;em&gt;poison&lt;/em&gt; this &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; instance, causing all future invocations of &lt;code&gt;call_once&lt;/code&gt; to also panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1151c6060a40c30d933870c684e8f8c1c9ce7a79" translate="yes" xml:space="preserve">
          <source>The closure &lt;code&gt;f&lt;/code&gt; will only be executed once if this is called concurrently amongst many threads. If that closure panics, however, then it will &lt;em&gt;poison&lt;/em&gt; this &lt;code&gt;Once&lt;/code&gt; instance, causing all future invocations of &lt;code&gt;call_once&lt;/code&gt; to also panic.</source>
          <target state="translated">El cierre &lt;code&gt;f&lt;/code&gt; solo se ejecutar&amp;aacute; una vez si se llama simult&amp;aacute;neamente entre muchos subprocesos. Sin embargo, si ese cierre entra en p&amp;aacute;nico, &lt;em&gt;envenenar&amp;aacute;&lt;/em&gt; esta instancia &lt;code&gt;Once&lt;/code&gt; , lo que provocar&amp;aacute; que todas las invocaciones futuras de &lt;code&gt;call_once&lt;/code&gt; tambi&amp;eacute;n entren en p&amp;aacute;nico.</target>
        </trans-unit>
        <trans-unit id="9a9ae7f6f31f6430eeec94354c414e42d745c712" translate="yes" xml:space="preserve">
          <source>The closure can use captures and its environment to track state across iterations. Depending on how the iterator is used, this may require specifying the &lt;a href=&quot;../keyword.move&quot;&gt;&lt;code&gt;move&lt;/code&gt;&lt;/a&gt; keyword on the closure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbba645c0f92459c3e584dd2aad4e56b6422ddeb" translate="yes" xml:space="preserve">
          <source>The closure can use captures and its environment to track state across iterations. Depending on how the iterator is used, this may require specifying the &lt;code&gt;move&lt;/code&gt; keyword on the closure.</source>
          <target state="translated">El cierre puede usar capturas y su entorno para rastrear el estado en las iteraciones. Dependiendo de c&amp;oacute;mo se use el iterador, esto puede requerir especificar el &lt;code&gt;move&lt;/code&gt; palabra clave en el cierre.</target>
        </trans-unit>
        <trans-unit id="8e57e2087c6fad9eaa8a18bdb745b2ddd95bd84c" translate="yes" xml:space="preserve">
          <source>The closure captures the &lt;code&gt;shoe_size&lt;/code&gt; parameter from the environment and compares the value with each shoe&amp;rsquo;s size, keeping only shoes of the size specified. Finally, calling &lt;code&gt;collect&lt;/code&gt; gathers the values returned by the adapted iterator into a vector that&amp;rsquo;s returned by the function.</source>
          <target state="translated">El cierre captura el par&amp;aacute;metro &lt;code&gt;shoe_size&lt;/code&gt; del entorno y compara el valor con el tama&amp;ntilde;o de cada zapato, manteniendo solo zapatos del tama&amp;ntilde;o especificado. Finalmente, llamar a &lt;code&gt;collect&lt;/code&gt; re&amp;uacute;ne los valores devueltos por el iterador adaptado en un vector que devuelve la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="0112db2feb7312ad3c6512257c24783293514225" translate="yes" xml:space="preserve">
          <source>The closure definition comes after the &lt;code&gt;=&lt;/code&gt; to assign it to the variable &lt;code&gt;expensive_closure&lt;/code&gt;. To define a closure, we start with a pair of vertical pipes (&lt;code&gt;|&lt;/code&gt;), inside which we specify the parameters to the closure; this syntax was chosen because of its similarity to closure definitions in Smalltalk and Ruby. This closure has one parameter named &lt;code&gt;num&lt;/code&gt;: if we had more than one parameter, we would separate them with commas, like &lt;code&gt;|param1, param2|&lt;/code&gt;.</source>
          <target state="translated">La definici&amp;oacute;n de cierre viene despu&amp;eacute;s de &lt;code&gt;=&lt;/code&gt; para asignarla a la variable &lt;code&gt;expensive_closure&lt;/code&gt; . Para definir un cierre, partimos de un par de tubos verticales ( &lt;code&gt;|&lt;/code&gt; ), dentro de los cuales especificamos los par&amp;aacute;metros del cierre; se eligi&amp;oacute; esta sintaxis debido a su similitud con las definiciones de cierre en Smalltalk y Ruby. Este cierre tiene un par&amp;aacute;metro llamado &lt;code&gt;num&lt;/code&gt; : si tuvi&amp;eacute;ramos m&amp;aacute;s de un par&amp;aacute;metro, los separar&amp;iacute;amos con comas, como &lt;code&gt;|param1, param2|&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b467eb6733245bc29dea650b68390c954774c96" translate="yes" xml:space="preserve">
          <source>The closure is allowed to return an I/O error whose OS error code will be communicated back to the parent and returned as an error from when the spawn was requested.</source>
          <target state="translated">El cierre se permite para devolver un error de E/S cuyo código de error del SO se comunicará al padre y se devolverá como un error de cuando se solicitó el desove.</target>
        </trans-unit>
        <trans-unit id="2d07950c5510607459c97a1e9bf4b42e15a155b7" translate="yes" xml:space="preserve">
          <source>The closure must return &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. &lt;code&gt;filter()&lt;/code&gt; creates an iterator which calls this closure on each element. If the closure returns &lt;code&gt;true&lt;/code&gt;, then the element is returned. If the closure returns &lt;code&gt;false&lt;/code&gt;, it will try again, and call the closure on the next element, seeing if it passes the test.</source>
          <target state="translated">El cierre debe devolver &lt;code&gt;true&lt;/code&gt; o &lt;code&gt;false&lt;/code&gt; . &lt;code&gt;filter()&lt;/code&gt; crea un iterador que llama a este cierre en cada elemento. Si el cierre devuelve &lt;code&gt;true&lt;/code&gt; , se devuelve el elemento. Si el cierre vuelve &lt;code&gt;false&lt;/code&gt; , lo intentar&amp;aacute; de nuevo y llamar&amp;aacute; al cierre en el siguiente elemento, viendo si pasa la prueba.</target>
        </trans-unit>
        <trans-unit id="0dfbb8ddc807c0ec7e308a6bcf0502df62203387" translate="yes" xml:space="preserve">
          <source>The closure must return an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;filter_map&lt;/code&gt; creates an iterator which calls this closure on each element. If the closure returns &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(element)&lt;/code&gt;&lt;/a&gt;, then that element is returned. If the closure returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, it will try again, and call the closure on the next element, seeing if it will return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El cierre debe devolver una &lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;filter_map&lt;/code&gt; crea un iterador que llama a este cierre en cada elemento. Si el cierre devuelve &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(element)&lt;/code&gt; &lt;/a&gt; , ese elemento se devuelve. Si el cierre devuelve &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , lo intentar&amp;aacute; de nuevo y llamar&amp;aacute; al cierre del siguiente elemento, viendo si devolver&amp;aacute; &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7a4c6af8980cc5834794f8ba584bb6cebd16567c" translate="yes" xml:space="preserve">
          <source>The closure provided is required to adhere to the &lt;a href=&quot;trait.unwindsafe&quot;&gt;&lt;code&gt;UnwindSafe&lt;/code&gt;&lt;/a&gt; trait to ensure that all captured variables are safe to cross this boundary. The purpose of this bound is to encode the concept of &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md&quot;&gt;exception safety&lt;/a&gt; in the type system. Most usage of this function should not need to worry about this bound as programs are naturally unwind safe without &lt;code&gt;unsafe&lt;/code&gt; code. If it becomes a problem the &lt;a href=&quot;struct.assertunwindsafe&quot;&gt;&lt;code&gt;AssertUnwindSafe&lt;/code&gt;&lt;/a&gt; wrapper struct can be used to quickly assert that the usage here is indeed unwind safe.</source>
          <target state="translated">Se requiere que el cierre provisto se adhiera al rasgo &lt;a href=&quot;trait.unwindsafe&quot;&gt; &lt;code&gt;UnwindSafe&lt;/code&gt; &lt;/a&gt; para garantizar que todas las variables capturadas sean seguras para cruzar este l&amp;iacute;mite. El prop&amp;oacute;sito de este l&amp;iacute;mite es codificar el concepto de &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md&quot;&gt;seguridad&lt;/a&gt; de excepci&amp;oacute;n en el sistema de tipos. La mayor parte del uso de esta funci&amp;oacute;n no deber&amp;iacute;a tener que preocuparse por este enlace, ya que los programas se desenrollan naturalmente de forma segura sin c&amp;oacute;digo &lt;code&gt;unsafe&lt;/code&gt; . Si se convierte en un problema, la &lt;a href=&quot;struct.assertunwindsafe&quot;&gt; &lt;code&gt;AssertUnwindSafe&lt;/code&gt; &lt;/a&gt; contenedora AssertUnwindSafe se puede usar para afirmar r&amp;aacute;pidamente que el uso aqu&amp;iacute; es realmente seguro.</target>
        </trans-unit>
        <trans-unit id="1db2515eb35827d3b48808ed11db89506d167098" translate="yes" xml:space="preserve">
          <source>The closure uses &lt;code&gt;v&lt;/code&gt;, so it will capture &lt;code&gt;v&lt;/code&gt; and make it part of the closure&amp;rsquo;s environment. Because &lt;code&gt;thread::spawn&lt;/code&gt; runs this closure in a new thread, we should be able to access &lt;code&gt;v&lt;/code&gt; inside that new thread. But when we compile this example, we get the following error:</source>
          <target state="translated">El cierre usa &lt;code&gt;v&lt;/code&gt; , por lo que capturar&amp;aacute; &lt;code&gt;v&lt;/code&gt; y lo har&amp;aacute; parte del entorno del cierre. Debido a que &lt;code&gt;thread::spawn&lt;/code&gt; ejecuta este cierre en un nuevo hilo, deber&amp;iacute;amos poder acceder a &lt;code&gt;v&lt;/code&gt; dentro de ese nuevo hilo. Pero cuando compilamos este ejemplo, obtenemos el siguiente error:</target>
        </trans-unit>
        <trans-unit id="d7aca11a6ac0f9ea5173acf1c9757981e77e687c" translate="yes" xml:space="preserve">
          <source>The code associated with each arm is an expression, and the resulting value of the expression in the matching arm is the value that gets returned for the entire &lt;code&gt;match&lt;/code&gt; expression.</source>
          <target state="translated">El c&amp;oacute;digo asociado con cada brazo es una expresi&amp;oacute;n, y el valor resultante de la expresi&amp;oacute;n en el brazo coincidente es el valor que se devuelve para toda la expresi&amp;oacute;n &lt;code&gt;match&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86ec55efa28e5ccc120a1f5241fba708e750dd58" translate="yes" xml:space="preserve">
          <source>The code in Listing 13-17 doesn&amp;rsquo;t do anything; the closure we&amp;rsquo;ve specified never gets called. The warning reminds us why: iterator adaptors are lazy, and we need to consume the iterator here.</source>
          <target state="translated">El c&amp;oacute;digo del Listado 13-17 no hace nada; el cierre que hemos especificado nunca se llama. La advertencia nos recuerda por qu&amp;eacute;: los adaptadores de iterador son perezosos y necesitamos consumir el iterador aqu&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="27595e3e42c890c6fdee5b82c7f1d2b1399713f0" translate="yes" xml:space="preserve">
          <source>The code in Listing 13-3 has multiple calls to the slow calculation function. The first &lt;code&gt;if&lt;/code&gt; block calls &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; twice, the &lt;code&gt;if&lt;/code&gt; inside the outer &lt;code&gt;else&lt;/code&gt; doesn&amp;rsquo;t call it at all, and the code inside the second &lt;code&gt;else&lt;/code&gt; case calls it once.</source>
          <target state="translated">El c&amp;oacute;digo del Listado 13-3 tiene m&amp;uacute;ltiples llamadas a la funci&amp;oacute;n de c&amp;aacute;lculo lento. El primer bloque &lt;code&gt;if&lt;/code&gt; llama a &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; dos veces, el &lt;code&gt;if&lt;/code&gt; dentro del exterior &lt;code&gt;else&lt;/code&gt; no lo llama en absoluto, y el c&amp;oacute;digo dentro del segundo &lt;code&gt;else&lt;/code&gt; caso llama una vez.</target>
        </trans-unit>
        <trans-unit id="984f7b754ab17440aa0c07b718b002aed1594b7a" translate="yes" xml:space="preserve">
          <source>The code in Listing 16-1 not only stops the spawned thread prematurely most of the time due to the main thread ending, but also can&amp;rsquo;t guarantee that the spawned thread will get to run at all. The reason is that there is no guarantee on the order in which threads run!</source>
          <target state="translated">El c&amp;oacute;digo del Listado 16-1 no solo detiene el subproceso generado prematuramente la mayor parte del tiempo debido a la finalizaci&amp;oacute;n del subproceso principal, sino que tampoco puede garantizar que el subproceso generado se ejecute en absoluto. La raz&amp;oacute;n es que no hay garant&amp;iacute;a sobre el orden en que se ejecutan los hilos.</target>
        </trans-unit>
        <trans-unit id="4d5adfd375cd377b4763e2eeee96a84687acf4e5" translate="yes" xml:space="preserve">
          <source>The code in Listing 16-8 compiled and ran, but it didn&amp;rsquo;t clearly show us that two separate threads were talking to each other over the channel. In Listing 16-10 we&amp;rsquo;ve made some modifications that will prove the code in Listing 16-8 is running concurrently: the spawned thread will now send multiple messages and pause for a second between each message.</source>
          <target state="translated">El c&amp;oacute;digo del Listado 16-8 se compil&amp;oacute; y ejecut&amp;oacute;, pero no nos mostr&amp;oacute; claramente que dos hilos separados se comunicaban entre s&amp;iacute; a trav&amp;eacute;s del canal. En el Listado 16-10 hemos realizado algunas modificaciones que probar&amp;aacute;n que el c&amp;oacute;digo del Listado 16-8 se est&amp;aacute; ejecutando simult&amp;aacute;neamente: el hilo generado ahora enviar&amp;aacute; varios mensajes y se detendr&amp;aacute; por un segundo entre cada mensaje.</target>
        </trans-unit>
        <trans-unit id="9e7e0566bf3de2c83a460b61c17bb70770c4b1c5" translate="yes" xml:space="preserve">
          <source>The code in Listing 18-1 shows a series of checks for several conditions that decide what the background color should be. For this example, we&amp;rsquo;ve created variables with hardcoded values that a real program might receive from user input.</source>
          <target state="translated">El c&amp;oacute;digo del Listado 18-1 muestra una serie de comprobaciones para varias condiciones que deciden cu&amp;aacute;l debe ser el color de fondo. Para este ejemplo, hemos creado variables con valores codificados que un programa real podr&amp;iacute;a recibir de la entrada del usuario.</target>
        </trans-unit>
        <trans-unit id="c12405c78a2c0d83f529e2201871e22f52a8474e" translate="yes" xml:space="preserve">
          <source>The code in Listing 18-3 will print the following:</source>
          <target state="translated">El código de la lista 18-3 imprimirá lo siguiente:</target>
        </trans-unit>
        <trans-unit id="efe51698d475c0b9864955b57e12d5b79c9bbf35" translate="yes" xml:space="preserve">
          <source>The code in Listing 20-14 will compile but doesn&amp;rsquo;t create any threads yet. We&amp;rsquo;ve changed the definition of &lt;code&gt;ThreadPool&lt;/code&gt; to hold a vector of &lt;code&gt;thread::JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; instances, initialized the vector with a capacity of &lt;code&gt;size&lt;/code&gt;, set up a &lt;code&gt;for&lt;/code&gt; loop that will run some code to create the threads, and returned a &lt;code&gt;ThreadPool&lt;/code&gt; instance containing them.</source>
          <target state="translated">El c&amp;oacute;digo del Listado 20-14 se compilar&amp;aacute; pero a&amp;uacute;n no crea ning&amp;uacute;n hilo. Hemos cambiado la definici&amp;oacute;n de &lt;code&gt;ThreadPool&lt;/code&gt; para contener un vector de &lt;code&gt;thread::JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; , inicializamos el vector con una capacidad de &lt;code&gt;size&lt;/code&gt; , configuramos un bucle &lt;code&gt;for&lt;/code&gt; que ejecutar&amp;aacute; alg&amp;uacute;n c&amp;oacute;digo para crear los hilos y devolvi&amp;oacute; un Instancia de &lt;code&gt;ThreadPool&lt;/code&gt; que los contiene.</target>
        </trans-unit>
        <trans-unit id="d3a6f7dff2487d4bcc7b7e0489bef3c4a5207416" translate="yes" xml:space="preserve">
          <source>The code in Listing 20-20 is responding to requests asynchronously through the use of a thread pool, as we intended. We get some warnings about the &lt;code&gt;workers&lt;/code&gt;, &lt;code&gt;id&lt;/code&gt;, and &lt;code&gt;thread&lt;/code&gt; fields that we&amp;rsquo;re not using in a direct way that reminds us we&amp;rsquo;re not cleaning up anything. When we use the less elegant ctrl-c method to halt the main thread, all other threads are stopped immediately as well, even if they&amp;rsquo;re in the middle of serving a request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9b3fdc249a44ebef0cd41734527cea5bbbbc841" translate="yes" xml:space="preserve">
          <source>The code in Listing 20-21 is responding to requests asynchronously through the use of a thread pool, as we intended. We get some warnings about the &lt;code&gt;workers&lt;/code&gt;, &lt;code&gt;id&lt;/code&gt;, and &lt;code&gt;thread&lt;/code&gt; fields that we&amp;rsquo;re not using in a direct way that reminds us we&amp;rsquo;re not cleaning up anything. When we use the less elegant ctrl-c method to halt the main thread, all other threads are stopped immediately as well, even if they&amp;rsquo;re in the middle of serving a request.</source>
          <target state="translated">El c&amp;oacute;digo del Listado 20-21 responde a las solicitudes de forma asincr&amp;oacute;nica mediante el uso de un grupo de subprocesos, como pretend&amp;iacute;amos. Recibimos algunas advertencias sobre los campos de los &lt;code&gt;workers&lt;/code&gt; , la &lt;code&gt;id&lt;/code&gt; entificaci&amp;oacute;n y el &lt;code&gt;thread&lt;/code&gt; que no estamos usando de manera directa que nos recuerdan que no estamos limpiando nada. Cuando usamos el m&amp;eacute;todo ctrl-c menos elegante para detener el subproceso principal, todos los dem&amp;aacute;s subprocesos tambi&amp;eacute;n se detienen inmediatamente, incluso si est&amp;aacute;n en el medio de atender una solicitud.</target>
        </trans-unit>
        <trans-unit id="af00e0657ebb48c72ab0e8023da460e28c0f23c3" translate="yes" xml:space="preserve">
          <source>The code in Listing 5-7 also creates an instance in &lt;code&gt;user2&lt;/code&gt; that has a different value for &lt;code&gt;email&lt;/code&gt; and &lt;code&gt;username&lt;/code&gt; but has the same values for the &lt;code&gt;active&lt;/code&gt; and &lt;code&gt;sign_in_count&lt;/code&gt; fields from &lt;code&gt;user1&lt;/code&gt;.</source>
          <target state="translated">El c&amp;oacute;digo del Listado 5-7 tambi&amp;eacute;n crea una instancia en &lt;code&gt;user2&lt;/code&gt; que tiene un valor diferente para el &lt;code&gt;email&lt;/code&gt; y el &lt;code&gt;username&lt;/code&gt; pero tiene los mismos valores para los campos &lt;code&gt;active&lt;/code&gt; y &lt;code&gt;sign_in_count&lt;/code&gt; de &lt;code&gt;user1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0531b3f098e465468fd76e222f809f69ed8edfae" translate="yes" xml:space="preserve">
          <source>The code in Listing 8-7 might look like it should work: why should a reference to the first element care about what changes at the end of the vector? This error is due to the way vectors work: adding a new element onto the end of the vector might require allocating new memory and copying the old elements to the new space, if there isn&amp;rsquo;t enough room to put all the elements next to each other where the vector currently is. In that case, the reference to the first element would be pointing to deallocated memory. The borrowing rules prevent programs from ending up in that situation.</source>
          <target state="translated">El c&amp;oacute;digo del Listado 8-7 podr&amp;iacute;a parecer que deber&amp;iacute;a funcionar: &amp;iquest;por qu&amp;eacute; una referencia al primer elemento deber&amp;iacute;a preocuparse por los cambios al final del vector? Este error se debe a la forma en que funcionan los vectores: agregar un nuevo elemento al final del vector puede requerir asignar nueva memoria y copiar los elementos antiguos al nuevo espacio, si no hay suficiente espacio para poner todos los elementos al lado de cada uno otro donde est&amp;aacute; el vector actualmente. En ese caso, la referencia al primer elemento estar&amp;iacute;a apuntando a la memoria desasignada. Las reglas de endeudamiento evitan que los programas terminen en esa situaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="94cc2f51904c3f9ddd0cfd3520b820c4eb301ad4" translate="yes" xml:space="preserve">
          <source>The code in Listing 9-4 will &lt;code&gt;panic!&lt;/code&gt; no matter why &lt;code&gt;File::open&lt;/code&gt; failed. What we want to do instead is take different actions for different failure reasons: if &lt;code&gt;File::open&lt;/code&gt; failed because the file doesn&amp;rsquo;t exist, we want to create the file and return the handle to the new file. If &lt;code&gt;File::open&lt;/code&gt; failed for any other reason&amp;mdash;for example, because we didn&amp;rsquo;t have permission to open the file&amp;mdash;we still want the code to &lt;code&gt;panic!&lt;/code&gt; in the same way as it did in Listing 9-4. Look at Listing 9-5, which adds an inner &lt;code&gt;match&lt;/code&gt; expression.</source>
          <target state="translated">&amp;iexcl;El c&amp;oacute;digo del Listado 9-4 entrar&amp;aacute; en &lt;code&gt;panic!&lt;/code&gt; no importa por qu&amp;eacute; &lt;code&gt;File::open&lt;/code&gt; fall&amp;oacute;. Lo que queremos hacer en cambio es tomar diferentes acciones por diferentes razones de falla: si &lt;code&gt;File::open&lt;/code&gt; fall&amp;oacute; porque el archivo no existe, queremos crear el archivo y devolver el identificador al nuevo archivo. Si &lt;code&gt;File::open&lt;/code&gt; fall&amp;oacute; por cualquier otro motivo, por ejemplo, porque no ten&amp;iacute;amos permiso para abrir el archivo, &amp;iexcl;a&amp;uacute;n queremos que el c&amp;oacute;digo entre en &lt;code&gt;panic!&lt;/code&gt; de la misma manera que lo hizo en el Listado 9-4. Mire el Listado 9-5, que agrega una expresi&amp;oacute;n de &lt;code&gt;match&lt;/code&gt; interna .</target>
        </trans-unit>
        <trans-unit id="e95fa13e369d6a99c35a00c2091e07ffadc180a6" translate="yes" xml:space="preserve">
          <source>The code is trying to pass &lt;code&gt;receiver&lt;/code&gt; to multiple &lt;code&gt;Worker&lt;/code&gt; instances. This won&amp;rsquo;t work, as you&amp;rsquo;ll recall from Chapter 16: the channel implementation that Rust provides is multiple &lt;em&gt;producer&lt;/em&gt;, single &lt;em&gt;consumer&lt;/em&gt;. This means we can&amp;rsquo;t just clone the consuming end of the channel to fix this code. Even if we could, that is not the technique we would want to use; instead, we want to distribute the jobs across threads by sharing the single &lt;code&gt;receiver&lt;/code&gt; among all the workers.</source>
          <target state="translated">El c&amp;oacute;digo intenta pasar el &lt;code&gt;receiver&lt;/code&gt; a varias instancias de &lt;code&gt;Worker&lt;/code&gt; . Esto no funcionar&amp;aacute;, como recordar&amp;aacute; del Cap&amp;iacute;tulo 16: la implementaci&amp;oacute;n de canal que proporciona Rust es de m&amp;uacute;ltiples &lt;em&gt;productores&lt;/em&gt; y de un solo &lt;em&gt;consumidor&lt;/em&gt; . Esto significa que no podemos simplemente clonar el extremo consumidor del canal para corregir este c&amp;oacute;digo. Incluso si pudi&amp;eacute;ramos, esa no es la t&amp;eacute;cnica que nos gustar&amp;iacute;a usar; en su lugar, queremos distribuir los trabajos a trav&amp;eacute;s de subprocesos compartiendo el &lt;code&gt;receiver&lt;/code&gt; &amp;uacute;nico entre todos los trabajadores.</target>
        </trans-unit>
        <trans-unit id="404cdeaf9f9f5734a0b6eb5da98e14aed6b8934d" translate="yes" xml:space="preserve">
          <source>The code refers to a trait that is not in scope.</source>
          <target state="translated">El código se refiere a un rasgo que no está en el ámbito de aplicación.</target>
        </trans-unit>
        <trans-unit id="f585d5dc0ef34cc30960f293fe10c97e69068fe3" translate="yes" xml:space="preserve">
          <source>The code that calls this code will then handle getting either an &lt;code&gt;Ok&lt;/code&gt; value that contains a username or an &lt;code&gt;Err&lt;/code&gt; value that contains an &lt;code&gt;io::Error&lt;/code&gt;. We don&amp;rsquo;t know what the calling code will do with those values. If the calling code gets an &lt;code&gt;Err&lt;/code&gt; value, it could call &lt;code&gt;panic!&lt;/code&gt; and crash the program, use a default username, or look up the username from somewhere other than a file, for example. We don&amp;rsquo;t have enough information on what the calling code is actually trying to do, so we propagate all the success or error information upward for it to handle appropriately.</source>
          <target state="translated">El c&amp;oacute;digo que llama a este c&amp;oacute;digo se encargar&amp;aacute; de obtener un valor &lt;code&gt;Ok&lt;/code&gt; que contiene un nombre de usuario o un valor &lt;code&gt;Err&lt;/code&gt; que contiene un &lt;code&gt;io::Error&lt;/code&gt; . No sabemos qu&amp;eacute; har&amp;aacute; el c&amp;oacute;digo de llamada con esos valores. Si el c&amp;oacute;digo de llamada obtiene un valor &lt;code&gt;Err&lt;/code&gt; , &amp;iexcl;podr&amp;iacute;a llamar al &lt;code&gt;panic!&lt;/code&gt; y bloquear el programa, usar un nombre de usuario predeterminado o buscar el nombre de usuario en alg&amp;uacute;n lugar que no sea un archivo, por ejemplo. No tenemos suficiente informaci&amp;oacute;n sobre lo que realmente intenta hacer el c&amp;oacute;digo de llamada, por lo que propagamos toda la informaci&amp;oacute;n de &amp;eacute;xito o error hacia arriba para que la maneje adecuadamente.</target>
        </trans-unit>
        <trans-unit id="cfac4f190729188f4689af6ae5b0042be7b9afad" translate="yes" xml:space="preserve">
          <source>The collection may reserve more space to avoid frequent reallocations.</source>
          <target state="translated">La colección puede reservar más espacio para evitar reasignaciones frecuentes.</target>
        </trans-unit>
        <trans-unit id="a921d34f1378e463d6297235d9b237b6a37c1373" translate="yes" xml:space="preserve">
          <source>The comma following &lt;code&gt;$()&lt;/code&gt; indicates that a literal comma separator character could optionally appear after the code that matches the code in &lt;code&gt;$()&lt;/code&gt;. The &lt;code&gt;*&lt;/code&gt; specifies that the pattern matches zero or more of whatever precedes the &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">La coma que sigue a &lt;code&gt;$()&lt;/code&gt; indica que un car&amp;aacute;cter separador de coma literal podr&amp;iacute;a aparecer opcionalmente despu&amp;eacute;s del c&amp;oacute;digo que coincide con el c&amp;oacute;digo en &lt;code&gt;$()&lt;/code&gt; . El &lt;code&gt;*&lt;/code&gt; especifica que el patr&amp;oacute;n coincide con cero o m&amp;aacute;s de lo que precede al &lt;code&gt;*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1bacb24582ff767b21e31f4cc1ad3d6012f25a0b" translate="yes" xml:space="preserve">
          <source>The command downloads a script and starts the installation of the &lt;code&gt;rustup&lt;/code&gt; tool, which installs the latest stable version of Rust. You might be prompted for your password. If the install is successful, the following line will appear:</source>
          <target state="translated">El comando descarga un script e inicia la instalaci&amp;oacute;n de la herramienta &lt;code&gt;rustup&lt;/code&gt; , que instala la &amp;uacute;ltima versi&amp;oacute;n estable de Rust. Es posible que se le solicite su contrase&amp;ntilde;a. Si la instalaci&amp;oacute;n es exitosa, aparecer&amp;aacute; la siguiente l&amp;iacute;nea:</target>
        </trans-unit>
        <trans-unit id="73b43b32097905758197f28a5b18a2fd54ae6279" translate="yes" xml:space="preserve">
          <source>The common part of these two paths is &lt;code&gt;std::io&lt;/code&gt;, and that&amp;rsquo;s the complete first path. To merge these two paths into one &lt;code&gt;use&lt;/code&gt; statement, we can use &lt;code&gt;self&lt;/code&gt; in the nested path, as shown in Listing 7-20.</source>
          <target state="translated">La parte com&amp;uacute;n de estas dos rutas es &lt;code&gt;std::io&lt;/code&gt; , y esa es la primera ruta completa. Para fusionar estas dos rutas en una declaraci&amp;oacute;n de &lt;code&gt;use&lt;/code&gt; , podemos usar &lt;code&gt;self&lt;/code&gt; en la ruta anidada, como se muestra en el Listado 7-20.</target>
        </trans-unit>
        <trans-unit id="3e8778a56f7c16d517be41bfd502f5b861a15290" translate="yes" xml:space="preserve">
          <source>The comparator function must define a total ordering for the elements in the slice. If the ordering is not total, the order of the elements is unspecified. An order is a total order if it is (for all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;):</source>
          <target state="translated">La funci&amp;oacute;n de comparador debe definir un orden total para los elementos del sector. Si el orden no es total, el orden de los elementos no se especifica. Una orden es una orden total si es (para todos &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; y &lt;code&gt;c&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="aebc23a2aec802159973c4b13320302322bbb426" translate="yes" xml:space="preserve">
          <source>The comparator function must define a total ordering for the elements in the slice. If the ordering is not total, the order of the elements is unspecified. An order is a total order if it is (for all a, b and c):</source>
          <target state="translated">La función de comparación debe definir un orden total para los elementos de la rebanada.Si el orden no es total,el orden de los elementos no está especificado.Un orden es un orden total si lo es (para todos los a,b y c):</target>
        </trans-unit>
        <trans-unit id="25646f45d8bc733d7759e265f95a900ae5f85f26" translate="yes" xml:space="preserve">
          <source>The comparator function should implement an order consistent with the sort order of the underlying &lt;code&gt;VecDeque&lt;/code&gt;, returning an order code that indicates whether its argument is &lt;code&gt;Less&lt;/code&gt;, &lt;code&gt;Equal&lt;/code&gt; or &lt;code&gt;Greater&lt;/code&gt; than the desired target.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92ccf3fc61c0a63453fa6ca42d0beca2274f875f" translate="yes" xml:space="preserve">
          <source>The comparator function should implement an order consistent with the sort order of the underlying slice, returning an order code that indicates whether its argument is &lt;code&gt;Less&lt;/code&gt;, &lt;code&gt;Equal&lt;/code&gt; or &lt;code&gt;Greater&lt;/code&gt; the desired target.</source>
          <target state="translated">La funci&amp;oacute;n de comparaci&amp;oacute;n debe implementar un orden consistente con el orden de clasificaci&amp;oacute;n del segmento subyacente, devolviendo un c&amp;oacute;digo de orden que indique si su argumento es &lt;code&gt;Less&lt;/code&gt; , &lt;code&gt;Equal&lt;/code&gt; o &lt;code&gt;Greater&lt;/code&gt; el objetivo deseado.</target>
        </trans-unit>
        <trans-unit id="45e688bbffc9733765a7b6aca03992e2d5e377a5" translate="yes" xml:space="preserve">
          <source>The comparison must satisfy, for all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;:</source>
          <target state="translated">La comparaci&amp;oacute;n debe satisfacer, por todo &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; y &lt;code&gt;c&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0c2765074489dd525efeb165a25dbc97454a652e" translate="yes" xml:space="preserve">
          <source>The compilation didn&amp;rsquo;t produce any errors, but the program resulted in a &lt;em&gt;runtime&lt;/em&gt; error and didn&amp;rsquo;t exit successfully. When you attempt to access an element using indexing, Rust will check that the index you&amp;rsquo;ve specified is less than the array length. If the index is greater than or equal to the array length, Rust will panic.</source>
          <target state="translated">La compilaci&amp;oacute;n no produjo ning&amp;uacute;n error, pero el programa dio como resultado un error de &lt;em&gt;tiempo de ejecuci&amp;oacute;n&lt;/em&gt; y no se cerr&amp;oacute; correctamente. Cuando intentas acceder a un elemento usando la indexaci&amp;oacute;n, Rust verificar&amp;aacute; que el &amp;iacute;ndice que hayas especificado sea menor que la longitud de la matriz. Si el &amp;iacute;ndice es mayor o igual que la longitud de la matriz, Rust entrar&amp;aacute; en p&amp;aacute;nico.</target>
        </trans-unit>
        <trans-unit id="0a0cf1febd61e4c4aeb0165c7c721394953162c8" translate="yes" xml:space="preserve">
          <source>The compilation model centers on artifacts called &lt;em&gt;crates&lt;/em&gt;. Each compilation processes a single crate in source form, and if successful, produces a single crate in binary form: either an executable or some sort of library.&lt;sup&gt;&lt;a href=&quot;#cratesourcefile&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25f0592827e30de97cacdd81a110584696dcea70" translate="yes" xml:space="preserve">
          <source>The compilation model centers on artifacts called &lt;em&gt;crates&lt;/em&gt;. Each compilation processes a single crate in source form, and if successful, produces a single crate in binary form: either an executable or some sort of library.&lt;sup&gt;&lt;a href=&quot;crates-and-source-files#cratesourcefile&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">El modelo de compilaci&amp;oacute;n se centra en artefactos llamados &lt;em&gt;cajas&lt;/em&gt; . Cada compilaci&amp;oacute;n procesa una sola caja en forma de c&amp;oacute;digo fuente y, si tiene &amp;eacute;xito, produce una sola caja en forma binaria: ya sea un ejecutable o alg&amp;uacute;n tipo de biblioteca. &lt;sup&gt;&lt;a href=&quot;crates-and-source-files#cratesourcefile&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="90596055b20c856dc417525ea133e8b1049b15fa" translate="yes" xml:space="preserve">
          <source>The compiler and standard library generally tries to ensure allocations never reach a size where an offset is a concern. For instance, &lt;code&gt;Vec&lt;/code&gt; and &lt;code&gt;Box&lt;/code&gt; ensure they never allocate more than &lt;code&gt;isize::MAX&lt;/code&gt; bytes, so &lt;code&gt;vec.as_ptr().add(vec.len()).sub(vec.len())&lt;/code&gt; is always safe.</source>
          <target state="translated">El compilador y la biblioteca est&amp;aacute;ndar generalmente intentan garantizar que las asignaciones nunca alcancen un tama&amp;ntilde;o en el que un desplazamiento sea una preocupaci&amp;oacute;n. Por ejemplo, &lt;code&gt;Vec&lt;/code&gt; y &lt;code&gt;Box&lt;/code&gt; aseguran que nunca asignan m&amp;aacute;s de &lt;code&gt;isize::MAX&lt;/code&gt; bytes, por lo que &lt;code&gt;vec.as_ptr().add(vec.len()).sub(vec.len())&lt;/code&gt; siempre es seguro.</target>
        </trans-unit>
        <trans-unit id="59cbb1cc8a088f98671593c9041c2587a34ab70d" translate="yes" xml:space="preserve">
          <source>The compiler and standard library generally tries to ensure allocations never reach a size where an offset is a concern. For instance, &lt;code&gt;Vec&lt;/code&gt; and &lt;code&gt;Box&lt;/code&gt; ensure they never allocate more than &lt;code&gt;isize::MAX&lt;/code&gt; bytes, so &lt;code&gt;vec.as_ptr().add(vec.len())&lt;/code&gt; is always safe.</source>
          <target state="translated">El compilador y la biblioteca est&amp;aacute;ndar generalmente intentan garantizar que las asignaciones nunca alcancen un tama&amp;ntilde;o en el que un desplazamiento sea una preocupaci&amp;oacute;n. Por ejemplo, &lt;code&gt;Vec&lt;/code&gt; y &lt;code&gt;Box&lt;/code&gt; aseguran que nunca asignan m&amp;aacute;s de &lt;code&gt;isize::MAX&lt;/code&gt; bytes, por lo que &lt;code&gt;vec.as_ptr().add(vec.len())&lt;/code&gt; siempre es seguro.</target>
        </trans-unit>
        <trans-unit id="5647f6303a746120d1bc013678162600f20688f8" translate="yes" xml:space="preserve">
          <source>The compiler and standard library generally try to ensure allocations never reach a size where an offset is a concern. For instance, &lt;code&gt;Vec&lt;/code&gt; and &lt;code&gt;Box&lt;/code&gt; ensure they never allocate more than &lt;code&gt;isize::MAX&lt;/code&gt; bytes, so &lt;code&gt;ptr_into_vec.offset_from(vec.as_ptr())&lt;/code&gt; is always safe.</source>
          <target state="translated">El compilador y la biblioteca est&amp;aacute;ndar generalmente intentan garantizar que las asignaciones nunca alcancen un tama&amp;ntilde;o en el que un desplazamiento sea una preocupaci&amp;oacute;n. Por ejemplo, &lt;code&gt;Vec&lt;/code&gt; y &lt;code&gt;Box&lt;/code&gt; aseguran que nunca asignan m&amp;aacute;s que &lt;code&gt;isize::MAX&lt;/code&gt; bytes, por lo que &lt;code&gt;ptr_into_vec.offset_from(vec.as_ptr())&lt;/code&gt; siempre es seguro.</target>
        </trans-unit>
        <trans-unit id="d1adc5111740e7a8d58bceec3601a6e3d4ef92d4" translate="yes" xml:space="preserve">
          <source>The compiler could not infer a type and asked for a type annotation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="030993899960155dfaeaf56819f76523f90d8c36" translate="yes" xml:space="preserve">
          <source>The compiler currently implements no method of hinting what format a library should be linked with. When dynamically linking, the compiler will attempt to maximize dynamic dependencies while still allowing some dependencies to be linked in via an rlib.</source>
          <target state="translated">El compilador no aplica actualmente ningún método para indicar el formato con el que debe vincularse una biblioteca.Al enlazar dinámicamente,el compilador intentará maximizar las dependencias dinámicas y al mismo tiempo permitir que algunas dependencias se enlacen mediante una rlib.</target>
        </trans-unit>
        <trans-unit id="fe8298a5d8326c70ef926aa1826e7331454f6a26" translate="yes" xml:space="preserve">
          <source>The compiler doesn't know what method to call because more than one method has the same prototype.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1821ca1d85d61b39565f6e9976cc18b3afce261c" translate="yes" xml:space="preserve">
          <source>The compiler doesn't know what method to call because more than one method has the same prototype. Erroneous code example:</source>
          <target state="translated">El compilador no sabe qué método llamar porque más de un método tiene el mismo prototipo.Ejemplo de código erróneo:</target>
        </trans-unit>
        <trans-unit id="1be1361775707ec1fbdcf50e883b1d7b1bdb5f0d" translate="yes" xml:space="preserve">
          <source>The compiler error is as follows:</source>
          <target state="translated">El error del compilador es el siguiente:</target>
        </trans-unit>
        <trans-unit id="b5655bf28c5aee029b50ebff36ecbfc08852001c" translate="yes" xml:space="preserve">
          <source>The compiler even reminds us that this only works with closures!</source>
          <target state="translated">¡El compilador incluso nos recuerda que esto sólo funciona con los cierres!</target>
        </trans-unit>
        <trans-unit id="b0cba35bf39af6cdfd6b56d4dbe10dbaf77ed516" translate="yes" xml:space="preserve">
          <source>The compiler found a function whose body contains a &lt;code&gt;return;&lt;/code&gt; statement but whose return type is not &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b08f603159dc0eecd0f21f28c07166cefeb69847" translate="yes" xml:space="preserve">
          <source>The compiler found a function whose body contains a &lt;code&gt;return;&lt;/code&gt; statement but whose return type is not &lt;code&gt;()&lt;/code&gt;. An example of this is:</source>
          <target state="translated">El compilador encontr&amp;oacute; una funci&amp;oacute;n cuyo cuerpo contiene un &lt;code&gt;return;&lt;/code&gt; declaraci&amp;oacute;n pero cuyo tipo de retorno no es &lt;code&gt;()&lt;/code&gt; . Un ejemplo de esto es:</target>
        </trans-unit>
        <trans-unit id="3e4713e81e1fe06044671ee83362a3b9a0f5ad86" translate="yes" xml:space="preserve">
          <source>The compiler gives us this error:</source>
          <target state="translated">El compilador nos da este error:</target>
        </trans-unit>
        <trans-unit id="b01feef52238a9b5f1daf51373c75b238f421fe8" translate="yes" xml:space="preserve">
          <source>The compiler is allowed to perform any combination of these optimizations, as long as the final optimized code, when executed, produces the same results as the one without optimizations.</source>
          <target state="translated">El compilador puede realizar cualquier combinación de estas optimizaciones,siempre que el código final optimizado,al ejecutarse,produzca los mismos resultados que el que no tiene optimizaciones.</target>
        </trans-unit>
        <trans-unit id="ec5c1119f8e1ac4ec1c89254831939480c03edd7" translate="yes" xml:space="preserve">
          <source>The compiler may allow attributes for external tools where each tool resides in its own namespace. The first segment of the attribute path is the name of the tool, with one or more additional segments whose interpretation is up to the tool.</source>
          <target state="translated">El compilador puede permitir atributos para herramientas externas donde cada herramienta reside en su propio espacio de nombres.El primer segmento de la ruta de atributos es el nombre de la herramienta,con uno o más segmentos adicionales cuya interpretación depende de la herramienta.</target>
        </trans-unit>
        <trans-unit id="a7720aa4345b4147bab4d25831f37466e57d1fcc" translate="yes" xml:space="preserve">
          <source>The compiler prefers to capture a closed-over variable by immutable borrow, followed by unique immutable borrow (see below), by mutable borrow, and finally by move. It will pick the first choice of these that allows the closure to compile. The choice is made only with regards to the contents of the closure expression; the compiler does not take into account surrounding code, such as the lifetimes of involved variables.</source>
          <target state="translated">El compilador prefiere capturar una variable cerrada por medio de un préstamo inmutable,seguido de un préstamo inmutable único (véase más abajo),por un préstamo mutable y,por último,por un movimiento.Elegirá la primera opción de estas que permita compilar el cierre.La elección se hace sólo con respecto al contenido de la expresión de cierre;el compilador no tiene en cuenta el código circundante,como la vida útil de las variables implicadas.</target>
        </trans-unit>
        <trans-unit id="5212bd9f30887e16d9c074bb9450838a12a0be2d" translate="yes" xml:space="preserve">
          <source>The compiler shouldn't change the relative order or number of volatile memory operations. However, volatile memory operations on zero-sized types (e.g., if a zero-sized type is passed to &lt;code&gt;read_volatile&lt;/code&gt;) are noops and may be ignored.</source>
          <target state="translated">El compilador no deber&amp;iacute;a cambiar el orden relativo o el n&amp;uacute;mero de operaciones de memoria vol&amp;aacute;til. Sin embargo, las operaciones de memoria vol&amp;aacute;til en tipos de tama&amp;ntilde;o cero (por ejemplo, si se pasa un tipo de tama&amp;ntilde;o cero a &lt;code&gt;read_volatile&lt;/code&gt; ) no son errores y se pueden ignorar.</target>
        </trans-unit>
        <trans-unit id="955e9c25a8bb7d2a1fb8b16fdbf5d5e19b107461" translate="yes" xml:space="preserve">
          <source>The compiler shouldn't change the relative order or number of volatile memory operations. However, volatile memory operations on zero-sized types (e.g., if a zero-sized type is passed to &lt;code&gt;write_volatile&lt;/code&gt;) are noops and may be ignored.</source>
          <target state="translated">El compilador no deber&amp;iacute;a cambiar el orden relativo o el n&amp;uacute;mero de operaciones de memoria vol&amp;aacute;til. Sin embargo, las operaciones de memoria vol&amp;aacute;til en tipos de tama&amp;ntilde;o cero (por ejemplo, si se pasa un tipo de tama&amp;ntilde;o cero a &lt;code&gt;write_volatile&lt;/code&gt; ) no son errores y pueden ignorarse.</target>
        </trans-unit>
        <trans-unit id="d348a40c0a7a1bd0e6bae37a48c29f90fc773ea5" translate="yes" xml:space="preserve">
          <source>The compiler supports various methods to link crates together both statically and dynamically. This section will explore the various methods to link crates together, and more information about native libraries can be found in the &lt;a href=&quot;https://doc.rust-lang.org/book/ffi.html&quot;&gt;FFI section of the book&lt;/a&gt;.</source>
          <target state="translated">El compilador admite varios m&amp;eacute;todos para vincular cajas de forma est&amp;aacute;tica y din&amp;aacute;mica. Esta secci&amp;oacute;n explorar&amp;aacute; los diversos m&amp;eacute;todos para vincular cajas, y se puede encontrar m&amp;aacute;s informaci&amp;oacute;n sobre bibliotecas nativas en la &lt;a href=&quot;https://doc.rust-lang.org/book/ffi.html&quot;&gt;secci&amp;oacute;n FFI del libro&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e6a5c185d40ba65d2c0863bc15ff86b37643834d" translate="yes" xml:space="preserve">
          <source>The compiler then knows to not make any incorrect assumptions or optimizations on this code.</source>
          <target state="translated">El compilador sabe entonces que no debe hacer ninguna suposición incorrecta u optimización en este código.</target>
        </trans-unit>
        <trans-unit id="4f49b0710fee284944c10fc8dd575c9f675cc65d" translate="yes" xml:space="preserve">
          <source>The compiler uses three rules to figure out what lifetimes references have when there aren&amp;rsquo;t explicit annotations. The first rule applies to input lifetimes, and the second and third rules apply to output lifetimes. If the compiler gets to the end of the three rules and there are still references for which it can&amp;rsquo;t figure out lifetimes, the compiler will stop with an error. These rules apply to &lt;code&gt;fn&lt;/code&gt; definitions as well as &lt;code&gt;impl&lt;/code&gt; blocks.</source>
          <target state="translated">El compilador usa tres reglas para averiguar qu&amp;eacute; tiempos de vida tienen las referencias cuando no hay anotaciones expl&amp;iacute;citas. La primera regla se aplica a la vida &amp;uacute;til de las entradas, y la segunda y la tercera reglas se aplican a la vida &amp;uacute;til de la salida. Si el compilador llega al final de las tres reglas y todav&amp;iacute;a hay referencias para las que no puede calcular la vida &amp;uacute;til, el compilador se detendr&amp;aacute; con un error. Estas reglas se aplican tanto a las definiciones de &lt;code&gt;fn&lt;/code&gt; como a los bloques &lt;code&gt;impl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="433b36c96c38bd66008e924fa1864ced83fcb794" translate="yes" xml:space="preserve">
          <source>The compiler will complain that it needs lifetime specifiers:</source>
          <target state="translated">El compilador se quejará de que necesita especificadores de por vida:</target>
        </trans-unit>
        <trans-unit id="572859abb18057fb674dd21429d06414b40c8275" translate="yes" xml:space="preserve">
          <source>The compiler will determine which of the &lt;a href=&quot;../types/closure#call-traits-and-coercions&quot;&gt;closure traits&lt;/a&gt; the closure's type will implement by how it acts on its captured variables. The closure will also implement &lt;a href=&quot;../special-types-and-traits#send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; and/or &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; if all of its captured types do. These traits allow functions to accept closures using generics, even though the exact types can't be named.</source>
          <target state="translated">El compilador determinar&amp;aacute; cu&amp;aacute;l de los &lt;a href=&quot;../types/closure#call-traits-and-coercions&quot;&gt;rasgos de&lt;/a&gt; cierre implementar&amp;aacute; el tipo de cierre por c&amp;oacute;mo act&amp;uacute;a sobre sus variables capturadas. El cierre tambi&amp;eacute;n implementar&amp;aacute; &lt;a href=&quot;../special-types-and-traits#send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt; y / o &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; si todos los tipos capturados lo hacen. Estos rasgos permiten que las funciones acepten cierres usando gen&amp;eacute;ricos, aunque no se pueden nombrar los tipos exactos.</target>
        </trans-unit>
        <trans-unit id="948f1a92a83b2e1e3378ae6b818bd73449ba504b" translate="yes" xml:space="preserve">
          <source>The compiler will indicate when you&amp;rsquo;re trying to do something that violates the rules of object safety in regard to trait objects. For example, let&amp;rsquo;s say we tried to implement the &lt;code&gt;Screen&lt;/code&gt; struct in Listing 17-4 to hold types that implement the &lt;code&gt;Clone&lt;/code&gt; trait instead of the &lt;code&gt;Draw&lt;/code&gt; trait, like this:</source>
          <target state="translated">El compilador le indicar&amp;aacute; cuando est&amp;eacute; intentando hacer algo que viole las reglas de seguridad de objetos con respecto a los objetos de rasgo. Por ejemplo, digamos que intentamos implementar la estructura &lt;code&gt;Screen&lt;/code&gt; en el Listado 17-4 para contener tipos que implementan el rasgo &lt;code&gt;Clone&lt;/code&gt; lugar del rasgo &lt;code&gt;Draw&lt;/code&gt; , as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="0946476a608603480a8c85b783bae37331306e67" translate="yes" xml:space="preserve">
          <source>The compiler, in general, assumes that a variable is properly initialized according to the requirements of the variable's type. For example, a variable of reference type must be aligned and non-NULL. This is an invariant that must &lt;em&gt;always&lt;/em&gt; be upheld, even in unsafe code. As a consequence, zero-initializing a variable of reference type causes instantaneous &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt;, no matter whether that reference ever gets used to access memory:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a84c7a7769bfd766452d6377b59bc8d2e574c64c" translate="yes" xml:space="preserve">
          <source>The compiler, in general, assumes that variables are properly initialized at their respective type. For example, a variable of reference type must be aligned and non-NULL. This is an invariant that must &lt;em&gt;always&lt;/em&gt; be upheld, even in unsafe code. As a consequence, zero-initializing a variable of reference type causes instantaneous &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt;, no matter whether that reference ever gets used to access memory:</source>
          <target state="translated">El compilador, en general, asume que las variables se inicializan correctamente en su tipo respectivo. Por ejemplo, una variable de tipo de referencia debe estar alineada y no ser NULL. Este es un invariante que &lt;em&gt;siempre&lt;/em&gt; debe mantenerse, incluso en c&amp;oacute;digo inseguro. Como consecuencia, la inicializaci&amp;oacute;n cero de una variable de tipo de referencia provoca &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;un comportamiento&lt;/a&gt; instant&amp;aacute;neo indefinido , sin importar si esa referencia se utiliza alguna vez para acceder a la memoria:</target>
        </trans-unit>
        <trans-unit id="4ed049edf6523bee71aa6c2cc8dac47d3acb83f3" translate="yes" xml:space="preserve">
          <source>The computed offset cannot exceed &lt;code&gt;isize::MAX&lt;/code&gt;&lt;strong&gt;bytes&lt;/strong&gt;.</source>
          <target state="translated">El desplazamiento calculado no puede exceder &lt;code&gt;isize::MAX&lt;/code&gt; &lt;strong&gt;bytes&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="4f78f76fdf78ce465bd63ef1c725533fd764ba85" translate="yes" xml:space="preserve">
          <source>The computed offset, &lt;strong&gt;in bytes&lt;/strong&gt;, cannot overflow an &lt;code&gt;isize&lt;/code&gt;.</source>
          <target state="translated">El desplazamiento calculado, &lt;strong&gt;en bytes&lt;/strong&gt; , no puede desbordar un &lt;code&gt;isize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63f5ab3561e8fa530abb7afbb885243679cbd27d" translate="yes" xml:space="preserve">
          <source>The concatenation &amp;alpha; &amp;beta; &amp;gamma; &amp;delta; is a parseable Rust program.</source>
          <target state="translated">La concatenaci&amp;oacute;n &amp;alpha; &amp;beta; &amp;gamma; &amp;delta; es un programa Rust analizable.</target>
        </trans-unit>
        <trans-unit id="026ad0f5294d67f94938651fe3bfaacf62c15a89" translate="yes" xml:space="preserve">
          <source>The concept of lifetimes is somewhat different from tools in other programming languages, arguably making lifetimes Rust&amp;rsquo;s most distinctive feature. Although we won&amp;rsquo;t cover lifetimes in their entirety in this chapter, we&amp;rsquo;ll discuss common ways you might encounter lifetime syntax so you can become familiar with the concepts.</source>
          <target state="translated">El concepto de vida &amp;uacute;til es algo diferente de las herramientas en otros lenguajes de programaci&amp;oacute;n, lo que posiblemente hace que la vida &amp;uacute;til sea la caracter&amp;iacute;stica m&amp;aacute;s distintiva de Rust. Aunque no cubriremos la vida &amp;uacute;til en su totalidad en este cap&amp;iacute;tulo, discutiremos las formas comunes en las que puede encontrar la sintaxis de por vida para que pueda familiarizarse con los conceptos.</target>
        </trans-unit>
        <trans-unit id="bf8b3cea5648a2c56269d845203de953f7dc58d3" translate="yes" xml:space="preserve">
          <source>The concepts of ownership, borrowing, and slices ensure memory safety in Rust programs at compile time. The Rust language gives you control over your memory usage in the same way as other systems programming languages, but having the owner of data automatically clean up that data when the owner goes out of scope means you don&amp;rsquo;t have to write and debug extra code to get this control.</source>
          <target state="translated">Los conceptos de propiedad, pr&amp;eacute;stamo y porciones garantizan la seguridad de la memoria en los programas Rust en tiempo de compilaci&amp;oacute;n. El lenguaje Rust le da control sobre el uso de su memoria de la misma manera que otros lenguajes de programaci&amp;oacute;n de sistemas, pero hacer que el propietario de los datos limpie autom&amp;aacute;ticamente esos datos cuando el propietario se sale del alcance significa que no tiene que escribir y depurar c&amp;oacute;digo adicional para obtener este control.</target>
        </trans-unit>
        <trans-unit id="5484608e7530a94c46507f1fbbbe29684e230d84" translate="yes" xml:space="preserve">
          <source>The condition can use variables created in the pattern. Listing 18-26 shows a &lt;code&gt;match&lt;/code&gt; where the first arm has the pattern &lt;code&gt;Some(x)&lt;/code&gt; and also has a match guard of &lt;code&gt;if x &amp;lt; 5&lt;/code&gt;.</source>
          <target state="translated">La condici&amp;oacute;n puede utilizar variables creadas en el patr&amp;oacute;n. El listado 18-26 muestra una &lt;code&gt;match&lt;/code&gt; en la que el primer brazo tiene el patr&amp;oacute;n &lt;code&gt;Some(x)&lt;/code&gt; y tambi&amp;eacute;n tiene un protector de coincidencia de &lt;code&gt;if x &amp;lt; 5&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c47359692fd118dbc5a64f61c4a95c135750d6d3" translate="yes" xml:space="preserve">
          <source>The condition expression of an &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;while&lt;/code&gt; expression, or a &lt;code&gt;match&lt;/code&gt; guard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="095096dc5e2804946ad94bae4f75159f2bd38855" translate="yes" xml:space="preserve">
          <source>The condition in an &lt;a href=&quot;keyword.if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; expression must be of type &lt;code&gt;bool&lt;/code&gt;. Whenever that condition evaluates to &lt;strong&gt;true&lt;/strong&gt;, the &lt;code&gt;if&lt;/code&gt; expression takes on the value of the first block. If however, the condition evaluates to &lt;code&gt;false&lt;/code&gt;, the expression takes on value of the &lt;code&gt;else&lt;/code&gt; block if there is one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75d37ae80df9e59cac39010c72ed606ee381207c" translate="yes" xml:space="preserve">
          <source>The condition we want to check in the inner match is whether the value returned by &lt;code&gt;error.kind()&lt;/code&gt; is the &lt;code&gt;NotFound&lt;/code&gt; variant of the &lt;code&gt;ErrorKind&lt;/code&gt; enum. If it is, we try to create the file with &lt;code&gt;File::create&lt;/code&gt;. However, because &lt;code&gt;File::create&lt;/code&gt; could also fail, we need a second arm in the inner &lt;code&gt;match&lt;/code&gt; expression. When the file can&amp;rsquo;t be created, a different error message is printed. The second arm of the outer &lt;code&gt;match&lt;/code&gt; stays the same, so the program panics on any error besides the missing file error.</source>
          <target state="translated">La condici&amp;oacute;n que queremos verificar en la coincidencia interna es si el valor devuelto por &lt;code&gt;error.kind()&lt;/code&gt; es la variante &lt;code&gt;NotFound&lt;/code&gt; de la enumeraci&amp;oacute;n &lt;code&gt;ErrorKind&lt;/code&gt; . Si es as&amp;iacute;, intentamos crear el archivo con &lt;code&gt;File::create&lt;/code&gt; . Sin embargo, debido a que &lt;code&gt;File::create&lt;/code&gt; tambi&amp;eacute;n podr&amp;iacute;a fallar, necesitamos un segundo brazo en la expresi&amp;oacute;n de &lt;code&gt;match&lt;/code&gt; interna . Cuando no se puede crear el archivo, se imprime un mensaje de error diferente. El segundo brazo de la &lt;code&gt;match&lt;/code&gt; externa permanece igual, por lo que el programa entra en p&amp;aacute;nico ante cualquier error adem&amp;aacute;s del error de archivo faltante.</target>
        </trans-unit>
        <trans-unit id="6c5b1587da56cf50f7a60ae4167ed8ca12fc4a83" translate="yes" xml:space="preserve">
          <source>The conditions in which you&amp;rsquo;re allowed or not allowed to implement the trait</source>
          <target state="translated">Las condiciones en las que est&amp;aacute; permitido o no implementar el rasgo</target>
        </trans-unit>
        <trans-unit id="1fd449b5671c0c531048bf228bce50b5745274bb" translate="yes" xml:space="preserve">
          <source>The connection was aborted (terminated) by the remote server.</source>
          <target state="translated">La conexión fue abortada (terminada)por el servidor remoto.</target>
        </trans-unit>
        <trans-unit id="394cd4f1c44fd561007d2b956b477de854f22ebc" translate="yes" xml:space="preserve">
          <source>The connection was refused by the remote server.</source>
          <target state="translated">La conexión fue rechazada por el servidor remoto.</target>
        </trans-unit>
        <trans-unit id="ee9eafc82d73396db6a743b750893f5328ee460c" translate="yes" xml:space="preserve">
          <source>The connection was reset by the remote server.</source>
          <target state="translated">La conexión fue restablecida por el servidor remoto.</target>
        </trans-unit>
        <trans-unit id="c5c0b8221782b43e8764b446a2f5d5156fcf8b34" translate="yes" xml:space="preserve">
          <source>The connection will be closed when the value is dropped. The reading and writing portions of the connection can also be shut down individually with the &lt;a href=&quot;#method.shutdown&quot;&gt;&lt;code&gt;shutdown&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">La conexi&amp;oacute;n se cerrar&amp;aacute; cuando se elimine el valor. Las partes de lectura y escritura de la conexi&amp;oacute;n tambi&amp;eacute;n se pueden apagar individualmente con el m&amp;eacute;todo de &lt;a href=&quot;#method.shutdown&quot;&gt; &lt;code&gt;shutdown&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ee6719cfaf61adca10461f2b171bde13e23a4a41" translate="yes" xml:space="preserve">
          <source>The connection will be closed when the value is dropped. The reading and writing portions of the connection can also be shut down individually with the &lt;a href=&quot;struct.tcpstream#method.shutdown&quot;&gt;&lt;code&gt;shutdown&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98a1585e2f9a061b72de9d4f949a75a416a4fb56" translate="yes" xml:space="preserve">
          <source>The cons function concept has made its way into more general functional programming jargon: &amp;ldquo;to cons &lt;em&gt;x&lt;/em&gt; onto &lt;em&gt;y&lt;/em&gt;&amp;rdquo; informally means to construct a new container instance by putting the element &lt;em&gt;x&lt;/em&gt; at the start of this new container, followed by the container &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">El concepto de funci&amp;oacute;n de contras se ha abierto camino hacia una jerga de programaci&amp;oacute;n funcional m&amp;aacute;s general: &amp;ldquo;cons &lt;em&gt;x&lt;/em&gt; sobre &lt;em&gt;y&lt;/em&gt; &amp;rdquo; significa informalmente construir una nueva instancia de contenedor colocando el elemento &lt;em&gt;x&lt;/em&gt; al comienzo de este nuevo contenedor, seguido del contenedor &lt;em&gt;y&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3946118b0e2f7f5ec1675cedbf82ccd7c8d576ce" translate="yes" xml:space="preserve">
          <source>The contents of &lt;em&gt;src/lib.rs&lt;/em&gt; should have the signatures shown in Listing 12-13 (we&amp;rsquo;ve omitted the bodies of the functions for brevity). Note that this won&amp;rsquo;t compile until we modify &lt;em&gt;src/main.rs&lt;/em&gt; in Listing 12-14.</source>
          <target state="translated">El contenido de &lt;em&gt;src / lib.rs&lt;/em&gt; debe tener las firmas que se muestran en el Listado 12-13 (hemos omitido los cuerpos de las funciones por brevedad). Tenga en cuenta que esto no se compilar&amp;aacute; hasta que modifiquemos &lt;em&gt;src / main.rs&lt;/em&gt; en el Listado 12-14.</target>
        </trans-unit>
        <trans-unit id="4fb4cd20ff2b04a7f8f088847ce2546308d2b8ce" translate="yes" xml:space="preserve">
          <source>The contents of the &lt;em&gt;src/lib.rs&lt;/em&gt; file in your &lt;code&gt;adder&lt;/code&gt; library should look like Listing 11-1.</source>
          <target state="translated">El contenido del archivo &lt;em&gt;src / lib.rs&lt;/em&gt; en su biblioteca de &lt;code&gt;adder&lt;/code&gt; debe verse como el Listado 11-1.</target>
        </trans-unit>
        <trans-unit id="1735f7c56c57e86fb0b029da9024a55f63cc6d92" translate="yes" xml:space="preserve">
          <source>The contents of the repetition must be able to follow whatever comes before, and whatever comes after must be able to follow the contents of the repetition.</source>
          <target state="translated">El contenido de la repetición debe ser capaz de seguir lo que viene antes,y lo que viene después debe ser capaz de seguir el contenido de la repetición.</target>
        </trans-unit>
        <trans-unit id="33e5fb5d650df50a2e77352564f0bccccceac217" translate="yes" xml:space="preserve">
          <source>The contents of the returned &lt;a href=&quot;../raw/struct.stat&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; are &lt;strong&gt;not&lt;/strong&gt; consistent across Unix platforms. The &lt;code&gt;os::unix::fs::MetadataExt&lt;/code&gt; trait contains the cross-Unix abstractions contained within the raw stat.</source>
          <target state="translated">El contenido de la regresado &lt;a href=&quot;../raw/struct.stat&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt; son &lt;strong&gt;no&lt;/strong&gt; coherente en plataformas Unix. El rasgo &lt;code&gt;os::unix::fs::MetadataExt&lt;/code&gt; contiene las abstracciones cruzadas de Unix contenidas en la estad&amp;iacute;stica en bruto.</target>
        </trans-unit>
        <trans-unit id="0770383d0616ee4e47049d055237250b7b2bfaef" translate="yes" xml:space="preserve">
          <source>The conversion allocates on the heap and moves &lt;code&gt;t&lt;/code&gt; from the stack into it.</source>
          <target state="translated">La conversi&amp;oacute;n asigna en el mont&amp;oacute;n y mueve &lt;code&gt;t&lt;/code&gt; de la pila a &amp;eacute;l.</target>
        </trans-unit>
        <trans-unit id="66e8c9afb284902c1e321d76aa570359994fd792" translate="yes" xml:space="preserve">
          <source>The conversion consumes the &lt;a href=&quot;../ffi/struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt;, and removes the terminating NUL byte.</source>
          <target state="translated">La conversi&amp;oacute;n consume &lt;a href=&quot;../ffi/struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt; y elimina el byte NUL de terminaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b49f9ee7f1f30037339c1daa1d1e1cd395843299" translate="yes" xml:space="preserve">
          <source>The conversion consumes the &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt;, and removes the terminating NUL byte.</source>
          <target state="translated">La conversi&amp;oacute;n consume &lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt; y elimina el byte NUL de terminaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9ff60369ad0f3cbf8d85443d93a8bb4f7f1f7686" translate="yes" xml:space="preserve">
          <source>The conversion copies the data, and includes an allocation on the heap.</source>
          <target state="translated">La conversión copia los datos,e incluye una asignación en el montón.</target>
        </trans-unit>
        <trans-unit id="cbdea02b60597ccd54b5d9dbad9b3681336b3420" translate="yes" xml:space="preserve">
          <source>The core method of future, &lt;code&gt;poll&lt;/code&gt;, &lt;em&gt;attempts&lt;/em&gt; to resolve the future into a final value. This method does not block if the value is not ready. Instead, the current task is scheduled to be woken up when it's possible to make further progress by &lt;code&gt;poll&lt;/code&gt;ing again. The &lt;code&gt;context&lt;/code&gt; passed to the &lt;code&gt;poll&lt;/code&gt; method can provide a &lt;a href=&quot;../task/struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt;, which is a handle for waking up the current task.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af0586e1698754134d6653d1c35d55045868b007" translate="yes" xml:space="preserve">
          <source>The core method of future, &lt;code&gt;poll&lt;/code&gt;, &lt;em&gt;attempts&lt;/em&gt; to resolve the future into a final value. This method does not block if the value is not ready. Instead, the current task is scheduled to be woken up when it's possible to make further progress by &lt;code&gt;poll&lt;/code&gt;ing again. The &lt;code&gt;context&lt;/code&gt; passed to the &lt;code&gt;poll&lt;/code&gt; method can provide a &lt;code&gt;Waker&lt;/code&gt;, which is a handle for waking up the current task.</source>
          <target state="translated">El m&amp;eacute;todo central del futuro, la &lt;code&gt;poll&lt;/code&gt; , &lt;em&gt;intenta&lt;/em&gt; resolver el futuro en un valor final. Este m&amp;eacute;todo no se bloquea si el valor no est&amp;aacute; listo. En cambio, la tarea actual est&amp;aacute; programada para que se active cuando sea posible avanzar m&amp;aacute;s al &lt;code&gt;poll&lt;/code&gt; nuevamente. El &lt;code&gt;context&lt;/code&gt; o pasado al m&amp;eacute;todo de &lt;code&gt;poll&lt;/code&gt; puede proporcionar un &lt;code&gt;Waker&lt;/code&gt; , que es un identificador para despertar la tarea actual.</target>
        </trans-unit>
        <trans-unit id="7cb53e3d2cc08f8c1b0d6306a44e9e0ab47f9511" translate="yes" xml:space="preserve">
          <source>The core of the error states that there are &lt;em&gt;mismatched types&lt;/em&gt;. Rust has a strong, static type system. However, it also has type inference. When we wrote &lt;code&gt;let mut guess = String::new()&lt;/code&gt;, Rust was able to infer that &lt;code&gt;guess&lt;/code&gt; should be a &lt;code&gt;String&lt;/code&gt; and didn&amp;rsquo;t make us write the type. The &lt;code&gt;secret_number&lt;/code&gt;, on the other hand, is a number type. A few number types can have a value between 1 and 100: &lt;code&gt;i32&lt;/code&gt;, a 32-bit number; &lt;code&gt;u32&lt;/code&gt;, an unsigned 32-bit number; &lt;code&gt;i64&lt;/code&gt;, a 64-bit number; as well as others. Rust defaults to an &lt;code&gt;i32&lt;/code&gt;, which is the type of &lt;code&gt;secret_number&lt;/code&gt; unless you add type information elsewhere that would cause Rust to infer a different numerical type. The reason for the error is that Rust cannot compare a string and a number type.</source>
          <target state="translated">El n&amp;uacute;cleo del error indica que hay &lt;em&gt;tipos&lt;/em&gt; que no &lt;em&gt;coinciden&lt;/em&gt; . El &amp;oacute;xido tiene un sistema de tipo est&amp;aacute;tico fuerte. Sin embargo, tambi&amp;eacute;n tiene inferencia de tipos. Cuando escribimos &lt;code&gt;let mut guess = String::new()&lt;/code&gt; , Rust pudo inferir que la &lt;code&gt;guess&lt;/code&gt; deber&amp;iacute;a ser una &lt;code&gt;String&lt;/code&gt; y no nos oblig&amp;oacute; a escribir el tipo. El &lt;code&gt;secret_number&lt;/code&gt; , por otro lado, es un tipo de n&amp;uacute;mero. Algunos tipos de n&amp;uacute;meros pueden tener un valor entre 1 y 100: &lt;code&gt;i32&lt;/code&gt; , un n&amp;uacute;mero de 32 bits; &lt;code&gt;u32&lt;/code&gt; , un n&amp;uacute;mero de 32 bits sin signo; &lt;code&gt;i64&lt;/code&gt; , un n&amp;uacute;mero de 64 bits; as&amp;iacute; como otros. Rust tiene por defecto un &lt;code&gt;i32&lt;/code&gt; , que es el tipo de &lt;code&gt;secret_number&lt;/code&gt; a menos que agregue informaci&amp;oacute;n de tipo en otro lugar que har&amp;iacute;a que Rust infiera un tipo num&amp;eacute;rico diferente. La raz&amp;oacute;n del error es que Rust no puede comparar una cadena y un tipo de n&amp;uacute;mero.</target>
        </trans-unit>
        <trans-unit id="ddff64ad7c369ce0737f5b8b0b3f4b7511787cca" translate="yes" xml:space="preserve">
          <source>The core primitive for interior mutability in Rust.</source>
          <target state="translated">El núcleo primitivo para la mutabilidad interior en el óxido.</target>
        </trans-unit>
        <trans-unit id="e23a80c74457fb7f3e04241567981840f6b6a5f0" translate="yes" xml:space="preserve">
          <source>The corresponding definitions are in &lt;code&gt;compiler/rustc_codegen_llvm/src/intrinsic.rs&lt;/code&gt;. The corresponding const implementations are in &lt;code&gt;compiler/rustc_mir/src/interpret/intrinsics.rs&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="159b3bf04af466ed5bc13962fe870a560dd18283" translate="yes" xml:space="preserve">
          <source>The corresponding definitions are in &lt;code&gt;librustc_codegen_llvm/intrinsic.rs&lt;/code&gt;.</source>
          <target state="translated">Las definiciones correspondientes se encuentran en &lt;code&gt;librustc_codegen_llvm/intrinsic.rs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46698ed84aa8c683839a27c0dd70bde9fa62d21c" translate="yes" xml:space="preserve">
          <source>The counts are not affected in any way and the &lt;code&gt;Arc&lt;/code&gt; is not consumed. The pointer is valid for as long as there are strong counts in the &lt;code&gt;Arc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77f706694dca621192d20fdc480b2fbc8fb70f49" translate="yes" xml:space="preserve">
          <source>The counts are not affected in any way and the &lt;code&gt;Rc&lt;/code&gt; is not consumed. The pointer is valid for as long there are strong counts in the &lt;code&gt;Rc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d69c16c8fa846f1af610002036c48591d43f28f" translate="yes" xml:space="preserve">
          <source>The crate name must not be empty, and must only contain &lt;a href=&quot;../std/primitive.char#method.is_alphanumeric&quot;&gt;Unicode alphanumeric&lt;/a&gt; or &lt;code&gt;-&lt;/code&gt; (U+002D) characters.</source>
          <target state="translated">El nombre de la caja no debe estar vac&amp;iacute;o y solo debe contener caracteres &lt;a href=&quot;../std/primitive.char#method.is_alphanumeric&quot;&gt;alfanum&amp;eacute;ricos Unicode&lt;/a&gt; o &lt;code&gt;-&lt;/code&gt; (U + 002D).</target>
        </trans-unit>
        <trans-unit id="be4dd5125e77acafd163c79956b21bce0b41caf8" translate="yes" xml:space="preserve">
          <source>The created map has the default initial capacity.</source>
          <target state="translated">El mapa creado tiene la capacidad inicial predeterminada.</target>
        </trans-unit>
        <trans-unit id="a9c04b6351b379cccf29eab61f8204218529d934" translate="yes" xml:space="preserve">
          <source>The current algorithm is an adaptive, iterative merge sort inspired by &lt;a href=&quot;https://en.wikipedia.org/wiki/Timsort&quot;&gt;timsort&lt;/a&gt;. It is designed to be very fast in cases where the slice is nearly sorted, or consists of two or more sorted sequences concatenated one after another.</source>
          <target state="translated">El algoritmo actual es un tipo de fusi&amp;oacute;n iterativo y adaptativo inspirado en &lt;a href=&quot;https://en.wikipedia.org/wiki/Timsort&quot;&gt;timsort&lt;/a&gt; . Est&amp;aacute; dise&amp;ntilde;ado para ser muy r&amp;aacute;pido en los casos en que el segmento est&amp;aacute; casi ordenado o consta de dos o m&amp;aacute;s secuencias ordenadas concatenadas una tras otra.</target>
        </trans-unit>
        <trans-unit id="bf4d84cfe0f7a72eb4a521a3a9fe9d6ec790d19e" translate="yes" xml:space="preserve">
          <source>The current algorithm is based on &lt;a href=&quot;https://github.com/orlp/pdqsort&quot;&gt;pattern-defeating quicksort&lt;/a&gt; by Orson Peters, which combines the fast average case of randomized quicksort with the fast worst case of heapsort, while achieving linear time on slices with certain patterns. It uses some randomization to avoid degenerate cases, but with a fixed seed to always provide deterministic behavior.</source>
          <target state="translated">El algoritmo actual se basa en la clasificaci&amp;oacute;n &lt;a href=&quot;https://github.com/orlp/pdqsort&quot;&gt;r&amp;aacute;pida que derrota&lt;/a&gt; a los patrones de Orson Peters, que combina el caso promedio r&amp;aacute;pido de clasificaci&amp;oacute;n r&amp;aacute;pida aleatoria con el peor caso r&amp;aacute;pido de clasificaci&amp;oacute;n en pilas, al tiempo que logra un tiempo lineal en los cortes con ciertos patrones. Utiliza cierta aleatorizaci&amp;oacute;n para evitar casos degenerados, pero con una semilla fija para proporcionar siempre un comportamiento determinista.</target>
        </trans-unit>
        <trans-unit id="17185ac0ce099c141b9827d28f04ee4d12e294f8" translate="yes" xml:space="preserve">
          <source>The current algorithm is based on the quickselect portion of the same quicksort algorithm used for &lt;a href=&quot;#method.sort_unstable&quot;&gt;&lt;code&gt;sort_unstable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El algoritmo actual se basa en la parte de selecci&amp;oacute;n r&amp;aacute;pida del mismo algoritmo de &lt;a href=&quot;#method.sort_unstable&quot;&gt; &lt;code&gt;sort_unstable&lt;/code&gt; &lt;/a&gt; r&amp;aacute;pida utilizado para sort_unstable .</target>
        </trans-unit>
        <trans-unit id="593e3fc1b65f7b6d06f9c45167b067a1a762655b" translate="yes" xml:space="preserve">
          <source>The current file cursor is not affected by this function.</source>
          <target state="translated">El cursor de archivo actual no se ve afectado por esta función.</target>
        </trans-unit>
        <trans-unit id="b3777ab23f3b1144c9a96d550ee493d6bc6e2d44" translate="yes" xml:space="preserve">
          <source>The current implementation uses the same infrastructure as compiler diagnostics and debuginfo, but this is not guaranteed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3346ba5eca8038cde57805738abeaa90cd6a63c6" translate="yes" xml:space="preserve">
          <source>The current module path can be thought of as the hierarchy of modules leading back up to the crate root. The first component of the path returned is the name of the crate currently being compiled.</source>
          <target state="translated">La ruta actual de los módulos puede ser pensada como la jerarquía de módulos que llevan de vuelta a la raíz de la caja.El primer componente de la ruta devuelta es el nombre de la caja que se está compilando actualmente.</target>
        </trans-unit>
        <trans-unit id="bdf915fa340c78bb10eee5926542917da6f9a74d" translate="yes" xml:space="preserve">
          <source>The current process does not have the permission rights to access &lt;code&gt;from&lt;/code&gt; or write &lt;code&gt;to&lt;/code&gt;.</source>
          <target state="translated">El proceso actual no tiene los derechos de permiso para acceder &lt;code&gt;from&lt;/code&gt; o escribir &lt;code&gt;to&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b9c6f166ff606296d138016ea8392f66f7ed63a" translate="yes" xml:space="preserve">
          <source>The current status of a backtrace, indicating whether it was captured or whether it is empty for some other reason.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa1cdfe5525c9cd270fc9b5826bff19009fb273e" translate="yes" xml:space="preserve">
          <source>The current version of the prelude (version 1) lives in &lt;a href=&quot;v1/index&quot;&gt;&lt;code&gt;std::prelude::v1&lt;/code&gt;&lt;/a&gt;, and re-exports the following.</source>
          <target state="translated">La versi&amp;oacute;n actual del preludio (versi&amp;oacute;n 1) vive en &lt;a href=&quot;v1/index&quot;&gt; &lt;code&gt;std::prelude::v1&lt;/code&gt; &lt;/a&gt; y reexporta lo siguiente.</target>
        </trans-unit>
        <trans-unit id="912528c0cfbd7646c08850f1e407245a6bf7145e" translate="yes" xml:space="preserve">
          <source>The cursor is pointing to the &quot;ghost&quot; non-element if the list is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9ad03e9a3edaaa56118f6fc3f2871f3d642b3c0" translate="yes" xml:space="preserve">
          <source>The data could not be sent on the &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt; because it would require that the callee block to send the data.</source>
          <target state="translated">Los datos no se pudieron enviar en &lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; &lt;/a&gt; porque requerir&amp;iacute;a que el destinatario se bloquee para enviar los datos.</target>
        </trans-unit>
        <trans-unit id="caac8e332d6bed98dbe6a446c232bbf7ded49130" translate="yes" xml:space="preserve">
          <source>The data members that this trait exposes correspond to the members of the &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/fileapi/ns-fileapi-by_handle_file_information&quot;&gt;&lt;code&gt;BY_HANDLE_FILE_INFORMATION&lt;/code&gt;&lt;/a&gt; structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="113312da9f41c00330f3f6a2627f87633cf51181" translate="yes" xml:space="preserve">
          <source>The data members that this trait exposes correspond to the members of the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa363788.aspx&quot;&gt;&lt;code&gt;BY_HANDLE_FILE_INFORMATION&lt;/code&gt;&lt;/a&gt; structure.</source>
          <target state="translated">Los miembros de datos que expone este rasgo corresponden a los miembros de la estructura &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa363788.aspx&quot;&gt; &lt;code&gt;BY_HANDLE_FILE_INFORMATION&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c9421f388aa0f6bda7993e70317be2c01ffcdb74" translate="yes" xml:space="preserve">
          <source>The data protected by the mutex can be accessed through this guard via its &lt;a href=&quot;../ops/trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../ops/trait.derefmut&quot;&gt;&lt;code&gt;DerefMut&lt;/code&gt;&lt;/a&gt; implementations.</source>
          <target state="translated">Se puede acceder a los datos protegidos por el mutex a trav&amp;eacute;s de esta protecci&amp;oacute;n a trav&amp;eacute;s de sus implementaciones &lt;a href=&quot;../ops/trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../ops/trait.derefmut&quot;&gt; &lt;code&gt;DerefMut&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a8b69bce2135d478ffa031311b309f0dc7de4fc2" translate="yes" xml:space="preserve">
          <source>The data that the process wrote to stderr.</source>
          <target state="translated">Los datos que el proceso escribió para stderr.</target>
        </trans-unit>
        <trans-unit id="5ad3bfb524d0ca744c539d652ec4054ab0b9dc35" translate="yes" xml:space="preserve">
          <source>The data that the process wrote to stdout.</source>
          <target state="translated">Los datos que el proceso escribió a stdout.</target>
        </trans-unit>
        <trans-unit id="f0f62565562b0bbca1d9e555b1c167c8869cc294" translate="yes" xml:space="preserve">
          <source>The declaration of &lt;code&gt;another_function&lt;/code&gt; has one parameter named &lt;code&gt;x&lt;/code&gt;. The type of &lt;code&gt;x&lt;/code&gt; is specified as &lt;code&gt;i32&lt;/code&gt;. When &lt;code&gt;5&lt;/code&gt; is passed to &lt;code&gt;another_function&lt;/code&gt;, the &lt;code&gt;println!&lt;/code&gt; macro puts &lt;code&gt;5&lt;/code&gt; where the pair of curly brackets were in the format string.</source>
          <target state="translated">La declaraci&amp;oacute;n de &lt;code&gt;another_function&lt;/code&gt; tiene un par&amp;aacute;metro llamado &lt;code&gt;x&lt;/code&gt; . El tipo de &lt;code&gt;x&lt;/code&gt; se especifica como &lt;code&gt;i32&lt;/code&gt; . Cuando se pasa &lt;code&gt;5&lt;/code&gt; a otra &lt;code&gt;another_function&lt;/code&gt; , el &lt;code&gt;println!&lt;/code&gt; macro pone &lt;code&gt;5&lt;/code&gt; donde el par de llaves estaban en la cadena de formato.</target>
        </trans-unit>
        <trans-unit id="f3e2b77707e4042bb7d326cf080f9fda22d6fd02" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;#fillalignment&quot;&gt;fill/alignment&lt;/a&gt; for non-numerics is a space and left-aligned. The default for numeric formatters is also a space character but with right-alignment. If the &lt;code&gt;0&lt;/code&gt; flag (see below) is specified for numerics, then the implicit fill character is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a4c3f3e9f4bf073db3de78ffdfd8f78a08679d0" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;#fillalignment&quot;&gt;fill/alignment&lt;/a&gt; for non-numerics is a space and left-aligned. The defaults for numeric formatters is also a space but with right-alignment. If the &lt;code&gt;0&lt;/code&gt; flag is specified for numerics, then the implicit fill character is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">El &lt;a href=&quot;#fillalignment&quot;&gt;relleno / alineaci&amp;oacute;n&lt;/a&gt; predeterminado para los no num&amp;eacute;ricos es un espacio y est&amp;aacute; alineado a la izquierda. Los valores predeterminados para los formateadores num&amp;eacute;ricos tambi&amp;eacute;n son un espacio pero con alineaci&amp;oacute;n a la derecha. Si se especifica la bandera &lt;code&gt;0&lt;/code&gt; para n&amp;uacute;meros, entonces el car&amp;aacute;cter de relleno impl&amp;iacute;cito es &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e71d3da519e1259cb4d0ff052a4082fe544273e4" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;../../hash/trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt; used by &lt;a href=&quot;struct.randomstate&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El &lt;a href=&quot;../../hash/trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt; predeterminado utilizado por &lt;a href=&quot;struct.randomstate&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="81a33ca44ce969a6a0433a7aff9f0392c46b2e52" translate="yes" xml:space="preserve">
          <source>The default behavior of this function is to print a message to standard error and abort the process. It can be replaced with &lt;a href=&quot;fn.set_alloc_error_hook&quot;&gt;&lt;code&gt;set_alloc_error_hook&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.take_alloc_error_hook&quot;&gt;&lt;code&gt;take_alloc_error_hook&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El comportamiento predeterminado de esta funci&amp;oacute;n es imprimir un mensaje de error est&amp;aacute;ndar y abortar el proceso. Se puede reemplazar con &lt;a href=&quot;fn.set_alloc_error_hook&quot;&gt; &lt;code&gt;set_alloc_error_hook&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;fn.take_alloc_error_hook&quot;&gt; &lt;code&gt;take_alloc_error_hook&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1fe48c8009742af8ee8a3efe0842a923bc01bf9d" translate="yes" xml:space="preserve">
          <source>The default generic type in this code is within the &lt;code&gt;Add&lt;/code&gt; trait. Here is its definition:</source>
          <target state="translated">El tipo gen&amp;eacute;rico predeterminado en este c&amp;oacute;digo est&amp;aacute; dentro del rasgo &lt;code&gt;Add&lt;/code&gt; . Aqu&amp;iacute; est&amp;aacute; su definici&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="697b922437171b9fe1e8c84494c4b161d6fd03d3" translate="yes" xml:space="preserve">
          <source>The default hashing algorithm is currently SipHash 1-3, though this is subject to change at any point in the future. While its performance is very competitive for medium sized keys, other hashing algorithms will outperform it for small keys such as integers as well as large keys such as long strings, though those algorithms will typically &lt;em&gt;not&lt;/em&gt; protect against attacks such as HashDoS.</source>
          <target state="translated">El algoritmo hash predeterminado es actualmente SipHash 1-3, aunque est&amp;aacute; sujeto a cambios en cualquier momento en el futuro. Si bien su rendimiento es muy competitivo para claves de tama&amp;ntilde;o mediano, otros algoritmos de hash lo superar&amp;aacute;n para claves peque&amp;ntilde;as como n&amp;uacute;meros enteros y claves grandes como cadenas largas, aunque esos algoritmos normalmente &lt;em&gt;no&lt;/em&gt; proteger&amp;aacute;n contra ataques como HashDoS.</target>
        </trans-unit>
        <trans-unit id="80e587164750efd5907b562bcc2c0ec8621ca1dc" translate="yes" xml:space="preserve">
          <source>The default implementation calls &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; with either the first nonempty buffer provided, or an empty one if none exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73b38e69c912c9cd2a1d35da9b4cb8282e56833f" translate="yes" xml:space="preserve">
          <source>The default implementation calls &lt;code&gt;read&lt;/code&gt; with either the first nonempty buffer provided, or an empty one if none exists.</source>
          <target state="translated">Las llamadas de implementaci&amp;oacute;n predeterminadas &lt;code&gt;read&lt;/code&gt; con el primer b&amp;uacute;fer no vac&amp;iacute;o proporcionado, o uno vac&amp;iacute;o si no existe.</target>
        </trans-unit>
        <trans-unit id="2e19ee8802e471056a9e27a45d3086893e133973" translate="yes" xml:space="preserve">
          <source>The default implementation calls &lt;code&gt;write&lt;/code&gt; with either the first nonempty buffer provided, or an empty one if none exists.</source>
          <target state="translated">Las llamadas de implementaci&amp;oacute;n predeterminadas &lt;code&gt;write&lt;/code&gt; con el primer b&amp;uacute;fer no vac&amp;iacute;o proporcionado o uno vac&amp;iacute;o si no existe ninguno.</target>
        </trans-unit>
        <trans-unit id="917b792910290b9f104f9e9bb1c1c376f6e62a1b" translate="yes" xml:space="preserve">
          <source>The default implementation does nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cda4f183b9995aecf4b0037179612271bde1f6bd" translate="yes" xml:space="preserve">
          <source>The default implementation returns &lt;code&gt;(0, &lt;/code&gt;&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt; which is correct for any iterator.</source>
          <target state="translated">La implementaci&amp;oacute;n predeterminada devuelve &lt;code&gt;(0, &lt;/code&gt; &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; &lt;code&gt;)&lt;/code&gt; que es correcta para cualquier iterador.</target>
        </trans-unit>
        <trans-unit id="e33ad58e76bb269caa1c45076544afb93bb1e40d" translate="yes" xml:space="preserve">
          <source>The default implementation returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="969fb25f2024192b2aecf3ee3a177be1b86acfb5" translate="yes" xml:space="preserve">
          <source>The default implementation returns an initializer which will zero buffers.</source>
          <target state="translated">La implementación por defecto devuelve un inicializador que pondrá a cero los buffers.</target>
        </trans-unit>
        <trans-unit id="bb3d803ebf5acd8c1abc49ce5f1cae9b36493095" translate="yes" xml:space="preserve">
          <source>The default implementations are returning &lt;code&gt;libc::EXIT_SUCCESS&lt;/code&gt; to indicate a successful execution. In case of a failure, &lt;code&gt;libc::EXIT_FAILURE&lt;/code&gt; is returned.</source>
          <target state="translated">Las implementaciones predeterminadas devuelven &lt;code&gt;libc::EXIT_SUCCESS&lt;/code&gt; para indicar una ejecuci&amp;oacute;n exitosa. En caso de falla, se devuelve &lt;code&gt;libc::EXIT_FAILURE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31cdcfae6f2b31eff3f08e0d9f029eeb9ec7bee1" translate="yes" xml:space="preserve">
          <source>The default is chosen with a bias toward producing literals that are legal in a variety of languages, including C++11 and similar C-family languages. The exact rules are:</source>
          <target state="translated">El valor por defecto se elige con un sesgo hacia la producción de literales que son legales en una variedad de idiomas,incluyendo C++11 y otros idiomas similares de la familia C.Las reglas exactas son:</target>
        </trans-unit>
        <trans-unit id="b02cae987658ffb74f03215f87762f2599f0c7eb" translate="yes" xml:space="preserve">
          <source>The default memory allocator provided by the operating system.</source>
          <target state="translated">El asignador de memoria por defecto proporcionado por el sistema operativo.</target>
        </trans-unit>
        <trans-unit id="1dd4678ade75055f3987aad761b36a01d2353c9f" translate="yes" xml:space="preserve">
          <source>The default stack size for spawned threads is 2 MiB, though this particular stack size is subject to change in the future. There are two ways to manually specify the stack size for spawned threads:</source>
          <target state="translated">El tamaño de pila por defecto para los hilos engendrados es de 2 MiB,aunque este tamaño de pila en particular está sujeto a cambios en el futuro.Hay dos maneras de especificar manualmente el tamaño de pila para los hilos engendrados:</target>
        </trans-unit>
        <trans-unit id="0f91c7ab56b392b9e17d4e1e13452f2f412a7407" translate="yes" xml:space="preserve">
          <source>The definition for complex NTs deserves some justification. SEP_SET(M) defines the possibility that the separator could be a valid first token for M, which happens when there is a separator defined and the repeated fragment could be empty. ALPHA_SET(M) defines the possibility that the complex NT could be empty, meaning that M's valid first tokens are those of the following token-tree sequences &lt;code&gt;&amp;alpha;&lt;/code&gt;. This occurs when either &lt;code&gt;\*&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt; is used, in which case there could be zero repetitions. In theory, this could also occur if &lt;code&gt;+&lt;/code&gt; was used with a potentially-empty repeating fragment, but this is forbidden by the third invariant.</source>
          <target state="translated">La definici&amp;oacute;n de NT complejos merece alguna justificaci&amp;oacute;n. SEP_SET (M) define la posibilidad de que el separador pueda ser un primer token v&amp;aacute;lido para M, lo que ocurre cuando hay un separador definido y el fragmento repetido puede estar vac&amp;iacute;o. ALPHA_SET (M) define la posibilidad de que el NT complejo pueda estar vac&amp;iacute;o, lo que significa que los primeros tokens v&amp;aacute;lidos de M son los de las siguientes secuencias &lt;code&gt;&amp;alpha;&lt;/code&gt; del &amp;aacute;rbol de tokens . Esto ocurre cuando &lt;code&gt;\*&lt;/code&gt; o &lt;code&gt;?&lt;/code&gt; se utiliza, en cuyo caso podr&amp;iacute;a haber cero repeticiones. En teor&amp;iacute;a, esto tambi&amp;eacute;n podr&amp;iacute;a ocurrir si se usara &lt;code&gt;+&lt;/code&gt; con un fragmento repetido potencialmente vac&amp;iacute;o, pero esto est&amp;aacute; prohibido por el tercer invariante.</target>
        </trans-unit>
        <trans-unit id="985a8049c57bbba61492d3048826a9b3471b56f7" translate="yes" xml:space="preserve">
          <source>The definition of &lt;code&gt;Config&lt;/code&gt;</source>
          <target state="translated">La definici&amp;oacute;n de &lt;code&gt;Config&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="830ab684e6b9340db4f9c07a73c12e27ccb95977" translate="yes" xml:space="preserve">
          <source>The dereference operator</source>
          <target state="translated">El operador de la desreferenciación</target>
        </trans-unit>
        <trans-unit id="75ad44a3ef91af0a45f2841a370dda11b833e07f" translate="yes" xml:space="preserve">
          <source>The desired behavior of the &lt;code&gt;generate_workout&lt;/code&gt; function is to first check whether the user wants a low-intensity workout (indicated by a number less than 25) or a high-intensity workout (a number of 25 or greater).</source>
          <target state="translated">El comportamiento deseado de la funci&amp;oacute;n &lt;code&gt;generate_workout&lt;/code&gt; es verificar primero si el usuario desea un entrenamiento de baja intensidad (indicado por un n&amp;uacute;mero menor que 25) o un entrenamiento de alta intensidad (un n&amp;uacute;mero de 25 o mayor).</target>
        </trans-unit>
        <trans-unit id="f11d06267e33f3ae0370e1b473dace96a1d49d65" translate="yes" xml:space="preserve">
          <source>The destructor of a type &lt;code&gt;T&lt;/code&gt; consists of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be2c8573e9de352b5e8e680cfa4b055e97512426" translate="yes" xml:space="preserve">
          <source>The destructor of a type consists of</source>
          <target state="translated">El destructor de un tipo consiste en</target>
        </trans-unit>
        <trans-unit id="c9c60944e1a21001c2063c93ac3b0f4cb46946e2" translate="yes" xml:space="preserve">
          <source>The destructor of the struct must not move structural fields out of its argument. This is the exact point that was raised in the &lt;a href=&quot;#drop-implementation&quot;&gt;previous section&lt;/a&gt;: &lt;code&gt;drop&lt;/code&gt; takes &lt;code&gt;&amp;amp;mut self&lt;/code&gt;, but the struct (and hence its fields) might have been pinned before. You have to guarantee that you do not move a field inside your &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; implementation. In particular, as explained previously, this means that your struct must &lt;em&gt;not&lt;/em&gt; be &lt;code&gt;#[repr(packed)]&lt;/code&gt;. See that section for how to write &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; in a way that the compiler can help you not accidentally break pinning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30054f3bf420ad868745eedcb4cc73a1da34e82c" translate="yes" xml:space="preserve">
          <source>The destructor of the struct must not move structural fields out of its argument. This is the exact point that was raised in the &lt;a href=&quot;#drop-implementation&quot;&gt;previous section&lt;/a&gt;: &lt;code&gt;drop&lt;/code&gt; takes &lt;code&gt;&amp;amp;mut self&lt;/code&gt;, but the struct (and hence its fields) might have been pinned before. You have to guarantee that you do not move a field inside your &lt;code&gt;Drop&lt;/code&gt; implementation. In particular, as explained previously, this means that your struct must &lt;em&gt;not&lt;/em&gt; be &lt;code&gt;#[repr(packed)]&lt;/code&gt;. See that section for how to write &lt;code&gt;drop&lt;/code&gt; in a way that the compiler can help you not accidentally break pinning.</source>
          <target state="translated">El destructor de la estructura no debe sacar los campos estructurales de su argumento. Este es el punto exacto en el que se cri&amp;oacute; en la &lt;a href=&quot;#drop-implementation&quot;&gt;secci&amp;oacute;n anterior&lt;/a&gt; : &lt;code&gt;drop&lt;/code&gt; toma &lt;code&gt;&amp;amp;mut self&lt;/code&gt; , pero la estructura (y, por tanto, sus campos) podr&amp;iacute;a haber sido fijado antes. Debe garantizar que no mueva un campo dentro de su implementaci&amp;oacute;n de &lt;code&gt;Drop&lt;/code&gt; . En particular, como se explic&amp;oacute; anteriormente, esto significa que su estructura &lt;em&gt;no&lt;/em&gt; debe ser &lt;code&gt;#[repr(packed)]&lt;/code&gt; . Consulte esa secci&amp;oacute;n para saber c&amp;oacute;mo escribir &lt;code&gt;drop&lt;/code&gt; de una manera que el compilador pueda ayudarlo a no romper accidentalmente la fijaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f85efc5c824a33e7773d4a9703af1abcf28610ef" translate="yes" xml:space="preserve">
          <source>The difference between 'the prelude' and these other preludes is that they are not automatically &lt;code&gt;use&lt;/code&gt;'d, and must be imported manually. This is still easier than importing all of their constituent components.</source>
          <target state="translated">La diferencia entre 'el preludio' y estos otros preludios es que no se &lt;code&gt;use&lt;/code&gt; autom&amp;aacute;ticamente 'd, y deben importarse manualmente. Esto sigue siendo m&amp;aacute;s f&amp;aacute;cil que importar todos sus componentes constituyentes.</target>
        </trans-unit>
        <trans-unit id="505a24f6c966bf30ebbdd0623555d0248f90c11b" translate="yes" xml:space="preserve">
          <source>The difference between &lt;a href=&quot;macro.unimplemented&quot;&gt;&lt;code&gt;unimplemented!&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;todo!&lt;/code&gt; is that while &lt;code&gt;todo!&lt;/code&gt; conveys an intent of implementing the functionality later and the message is &quot;not yet implemented&quot;, &lt;code&gt;unimplemented!&lt;/code&gt; makes no such claims. Its message is &quot;not implemented&quot;. Also some IDEs will mark &lt;code&gt;todo!&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03297ced74ba958f935a37ee67580ef54eeb9a79" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;unimplemented!&lt;/code&gt; and &lt;a href=&quot;macro.todo&quot;&gt;&lt;code&gt;todo!&lt;/code&gt;&lt;/a&gt; is that while &lt;code&gt;todo!&lt;/code&gt; conveys an intent of implementing the functionality later and the message is &quot;not yet implemented&quot;, &lt;code&gt;unimplemented!&lt;/code&gt; makes no such claims. Its message is &quot;not implemented&quot;. Also some IDEs will mark &lt;code&gt;todo!&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d53ebfe9f22c1eb14437a5afaa7bab7ac81b640" translate="yes" xml:space="preserve">
          <source>The difference is that when using generics, as in Listing 19-13, we must annotate the types in each implementation; because we can also implement &lt;code&gt;Iterator&amp;lt;String&amp;gt; for Counter&lt;/code&gt; or any other type, we could have multiple implementations of &lt;code&gt;Iterator&lt;/code&gt; for &lt;code&gt;Counter&lt;/code&gt;. In other words, when a trait has a generic parameter, it can be implemented for a type multiple times, changing the concrete types of the generic type parameters each time. When we use the &lt;code&gt;next&lt;/code&gt; method on &lt;code&gt;Counter&lt;/code&gt;, we would have to provide type annotations to indicate which implementation of &lt;code&gt;Iterator&lt;/code&gt; we want to use.</source>
          <target state="translated">La diferencia es que cuando usamos gen&amp;eacute;ricos, como en el Listado 19-13, debemos anotar los tipos en cada implementaci&amp;oacute;n; debido a que tambi&amp;eacute;n podemos implementar &lt;code&gt;Iterator&amp;lt;String&amp;gt; for Counter&lt;/code&gt; o cualquier otro tipo, podr&amp;iacute;amos tener m&amp;uacute;ltiples implementaciones de &lt;code&gt;Iterator&lt;/code&gt; para &lt;code&gt;Counter&lt;/code&gt; . En otras palabras, cuando un rasgo tiene un par&amp;aacute;metro gen&amp;eacute;rico, se puede implementar para un tipo varias veces, cambiando los tipos concretos de los par&amp;aacute;metros de tipo gen&amp;eacute;rico cada vez. Cuando usemos el &lt;code&gt;next&lt;/code&gt; m&amp;eacute;todo en &lt;code&gt;Counter&lt;/code&gt; , tendr&amp;iacute;amos que proporcionar anotaciones de tipo para indicar qu&amp;eacute; implementaci&amp;oacute;n de &lt;code&gt;Iterator&lt;/code&gt; queremos usar.</target>
        </trans-unit>
        <trans-unit id="5d4f5e1a47f10d66452650a5f161fd164ebd410d" translate="yes" xml:space="preserve">
          <source>The differences about paths and the &lt;code&gt;use&lt;/code&gt; keyword between the 2015 and 2018 editions can also be found in the &lt;a href=&quot;../reference/items/use-declarations&quot;&gt;Reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b61b2f901725762b56d16bf06bea0055df6804" translate="yes" xml:space="preserve">
          <source>The different behavior of files in the &lt;em&gt;tests&lt;/em&gt; directory is most noticeable when you have a set of helper functions that would be useful in multiple integration test files and you try to follow the steps in the &lt;a href=&quot;ch07-05-separating-modules-into-different-files&quot;&gt;&amp;ldquo;Separating Modules into Different Files&amp;rdquo;&lt;/a&gt; section of Chapter 7 to extract them into a common module. For example, if we create &lt;em&gt;tests/common.rs&lt;/em&gt; and place a function named &lt;code&gt;setup&lt;/code&gt; in it, we can add some code to &lt;code&gt;setup&lt;/code&gt; that we want to call from multiple test functions in multiple test files:</source>
          <target state="translated">El comportamiento diferente de los archivos en el directorio de &lt;em&gt;pruebas&lt;/em&gt; es m&amp;aacute;s notable cuando tiene un conjunto de funciones auxiliares que ser&amp;iacute;an &amp;uacute;tiles en varios archivos de prueba de integraci&amp;oacute;n e intenta seguir los pasos de la secci&amp;oacute;n &lt;a href=&quot;ch07-05-separating-modules-into-different-files&quot;&gt;&quot;Separaci&amp;oacute;n de m&amp;oacute;dulos en archivos diferentes&quot;&lt;/a&gt; del Cap&amp;iacute;tulo 7 para extraerlos en un m&amp;oacute;dulo com&amp;uacute;n. Por ejemplo, si creamos &lt;em&gt;tests / common.rs&lt;/em&gt; y colocamos una funci&amp;oacute;n llamada &lt;code&gt;setup&lt;/code&gt; en &amp;eacute;l, podemos agregar un c&amp;oacute;digo a la &lt;code&gt;setup&lt;/code&gt; que queremos llamar desde m&amp;uacute;ltiples funciones de prueba en m&amp;uacute;ltiples archivos de prueba:</target>
        </trans-unit>
        <trans-unit id="d5be1c02c26fe5ef598a5696a274160d696e7977" translate="yes" xml:space="preserve">
          <source>The different meanings of &lt;code&gt;unsafe&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fd895f49df6ac41f021206eb05bd5dfbc8e5ada" translate="yes" xml:space="preserve">
          <source>The directories and files used for loading external file modules can be influenced with the &lt;code&gt;path&lt;/code&gt; attribute.</source>
          <target state="translated">Los directorios y archivos utilizados para cargar m&amp;oacute;dulos de archivos externos se pueden influir con el atributo de &lt;code&gt;path&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e92ecf8e1ea3e2a6e4c02654c525e112d825547" translate="yes" xml:space="preserve">
          <source>The directory isn't empty.</source>
          <target state="translated">El directorio no está vacío.</target>
        </trans-unit>
        <trans-unit id="8e9718c5436468359091854f47e29ace6b258c73" translate="yes" xml:space="preserve">
          <source>The discriminant enum from the example &lt;a href=&quot;#reprc-enums-with-fields&quot;&gt;earlier&lt;/a&gt; then becomes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5406bf9928b412a24605eecb2ec809ade9b2bfca" translate="yes" xml:space="preserve">
          <source>The discriminant of an enum variant may change if the enum definition changes. A discriminant of some variant will not change between compilations with the same compiler.</source>
          <target state="translated">El discriminante de una variante del enum puede cambiar si cambia la definición del enum.El discriminante de una variante no cambiará entre compilaciones con el mismo compilador.</target>
        </trans-unit>
        <trans-unit id="e1e71495d678a5d4be21061931a65d8862bd4e7e" translate="yes" xml:space="preserve">
          <source>The distance being in bounds cannot rely on &quot;wrapping around&quot; the address space.</source>
          <target state="translated">La distancia que se encuentra en los límites no puede depender de &quot;envolver&quot; el espacio de direcciones.</target>
        </trans-unit>
        <trans-unit id="6c785ac664fd8d2346ca1bb482fcd8b5593d6af3" translate="yes" xml:space="preserve">
          <source>The distance between the pointers, &lt;strong&gt;in bytes&lt;/strong&gt;, cannot overflow an &lt;code&gt;isize&lt;/code&gt;.</source>
          <target state="translated">La distancia entre los punteros, &lt;strong&gt;en bytes&lt;/strong&gt; , no puede desbordar un &lt;code&gt;isize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd1487c3b6f63cdfefd3896403e040d0a14037e5" translate="yes" xml:space="preserve">
          <source>The distance between the pointers, in bytes, must be an exact multiple of the size of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">La distancia entre los punteros, en bytes, debe ser un m&amp;uacute;ltiplo exacto del tama&amp;ntilde;o de &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c85eee3f8fcb1e3d7acfa8c71113a8ed01e9b6ce" translate="yes" xml:space="preserve">
          <source>The division assignment operator &lt;code&gt;/=&lt;/code&gt;.</source>
          <target state="translated">El operador de asignaci&amp;oacute;n de divisi&amp;oacute;n &lt;code&gt;/=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fac0cbbb13a4ae4385140ac3ccea99961d57c224" translate="yes" xml:space="preserve">
          <source>The division operator &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">El operador de divisi&amp;oacute;n &lt;code&gt;/&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4bae769945be3db52fcb8fef6b0f5ad9c54eef4" translate="yes" xml:space="preserve">
          <source>The documentation for this keyword is &lt;a href=&quot;https://github.com/rust-lang/rust/issues/34601&quot;&gt;not yet complete&lt;/a&gt;. Pull requests welcome!</source>
          <target state="translated">La documentaci&amp;oacute;n de esta palabra clave &lt;a href=&quot;https://github.com/rust-lang/rust/issues/34601&quot;&gt;a&amp;uacute;n no&lt;/a&gt; est&amp;aacute; completa . &amp;iexcl;Solicitudes de extracci&amp;oacute;n bienvenidas!</target>
        </trans-unit>
        <trans-unit id="7092af2bcd91c441c2dfc4c8d572a11dfce60e91" translate="yes" xml:space="preserve">
          <source>The double colon (&lt;code&gt;::&lt;/code&gt;) is an operator that allows us to namespace this particular &lt;code&gt;from&lt;/code&gt; function under the &lt;code&gt;String&lt;/code&gt; type rather than using some sort of name like &lt;code&gt;string_from&lt;/code&gt;. We&amp;rsquo;ll discuss this syntax more in the &lt;a href=&quot;ch05-03-method-syntax#method-syntax&quot;&gt;&amp;ldquo;Method Syntax&amp;rdquo;&lt;/a&gt; section of Chapter 5 and when we talk about namespacing with modules in &lt;a href=&quot;ch07-03-paths-for-referring-to-an-item-in-the-module-tree&quot;&gt;&amp;ldquo;Paths for Referring to an Item in the Module Tree&amp;rdquo;&lt;/a&gt; in Chapter 7.</source>
          <target state="translated">El doble signo de dos puntos ( &lt;code&gt;::&lt;/code&gt; &lt;code&gt;string_from&lt;/code&gt; es un operador que nos permite asignar un espacio de nombres a esta funci&amp;oacute;n &lt;code&gt;from&lt;/code&gt; en particular bajo el tipo &lt;code&gt;String&lt;/code&gt; en lugar de usar alg&amp;uacute;n tipo de nombre como string_from . Discutiremos esta sintaxis m&amp;aacute;s en la secci&amp;oacute;n &lt;a href=&quot;ch05-03-method-syntax#method-syntax&quot;&gt;&quot;Sintaxis del m&amp;eacute;todo&quot;&lt;/a&gt; del Cap&amp;iacute;tulo 5 y cuando hablemos sobre el espacio de nombres con m&amp;oacute;dulos en &lt;a href=&quot;ch07-03-paths-for-referring-to-an-item-in-the-module-tree&quot;&gt;&quot;Rutas para hacer referencia a un elemento en el &amp;aacute;rbol de m&amp;oacute;dulos&quot;&lt;/a&gt; en el Cap&amp;iacute;tulo 7.</target>
        </trans-unit>
        <trans-unit id="27b2d1743e157ab144583c8c6b85ea9ad0092f0b" translate="yes" xml:space="preserve">
          <source>The downside of using &lt;code&gt;if let&lt;/code&gt; expressions is that the compiler doesn&amp;rsquo;t check exhaustiveness, whereas with &lt;code&gt;match&lt;/code&gt; expressions it does. If we omitted the last &lt;code&gt;else&lt;/code&gt; block and therefore missed handling some cases, the compiler would not alert us to the possible logic bug.</source>
          <target state="translated">La desventaja de usar expresiones &lt;code&gt;if let&lt;/code&gt; es que el compilador no verifica la exhaustividad, mientras que con las expresiones &lt;code&gt;match&lt;/code&gt; s&amp;iacute; lo hace. Si omitimos el &amp;uacute;ltimo bloque &lt;code&gt;else&lt;/code&gt; y por lo tanto no manejamos algunos casos, el compilador no nos alertar&amp;iacute;a del posible error l&amp;oacute;gico.</target>
        </trans-unit>
        <trans-unit id="e387e6a833f24807236bb7fd7266c18e39a1df6d" translate="yes" xml:space="preserve">
          <source>The downside of using this technique is that &lt;code&gt;Wrapper&lt;/code&gt; is a new type, so it doesn&amp;rsquo;t have the methods of the value it&amp;rsquo;s holding. We would have to implement all the methods of &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; directly on &lt;code&gt;Wrapper&lt;/code&gt; such that the methods delegate to &lt;code&gt;self.0&lt;/code&gt;, which would allow us to treat &lt;code&gt;Wrapper&lt;/code&gt; exactly like a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. If we wanted the new type to have every method the inner type has, implementing the &lt;code&gt;Deref&lt;/code&gt; trait (discussed in Chapter 15 in the &lt;a href=&quot;ch15-02-deref#treating-smart-pointers-like-regular-references-with-the-deref-trait&quot;&gt;&amp;ldquo;Treating Smart Pointers Like Regular References with the &lt;code&gt;Deref&lt;/code&gt; Trait&amp;rdquo;&lt;/a&gt; section) on the &lt;code&gt;Wrapper&lt;/code&gt; to return the inner type would be a solution. If we don&amp;rsquo;t want the &lt;code&gt;Wrapper&lt;/code&gt; type to have all the methods of the inner type&amp;mdash;for example, to restrict the &lt;code&gt;Wrapper&lt;/code&gt; type&amp;rsquo;s behavior&amp;mdash;we would have to implement just the methods we do want manually.</source>
          <target state="translated">La desventaja de usar esta t&amp;eacute;cnica es que &lt;code&gt;Wrapper&lt;/code&gt; es un tipo nuevo, por lo que no tiene los m&amp;eacute;todos del valor que tiene. Tendr&amp;iacute;amos que implementar todos los m&amp;eacute;todos de &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; directamente en &lt;code&gt;Wrapper&lt;/code&gt; de manera que los m&amp;eacute;todos se deleguen en &lt;code&gt;self.0&lt;/code&gt; , lo que nos permitir&amp;iacute;a tratar a &lt;code&gt;Wrapper&lt;/code&gt; exactamente como un &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; . Si quisi&amp;eacute;ramos que el nuevo tipo tuviera todos los m&amp;eacute;todos que tiene el tipo interno, implementar el rasgo &lt;code&gt;Deref&lt;/code&gt; (discutido en el Cap&amp;iacute;tulo 15 en la secci&amp;oacute;n &lt;a href=&quot;ch15-02-deref#treating-smart-pointers-like-regular-references-with-the-deref-trait&quot;&gt;&quot;Tratar los punteros inteligentes como referencias regulares con el rasgo &lt;code&gt;Deref&lt;/code&gt; &quot;&lt;/a&gt; ) en el &lt;code&gt;Wrapper&lt;/code&gt; devolver el tipo interno ser&amp;iacute;a una soluci&amp;oacute;n. Si no queremos que el tipo &lt;code&gt;Wrapper&lt;/code&gt; tenga todos los m&amp;eacute;todos del tipo interno, por ejemplo, para restringir el comportamiento del tipo &lt;code&gt;Wrapper&lt;/code&gt; , tendr&amp;iacute;amos que implementar solo los m&amp;eacute;todos que deseamos manualmente.</target>
        </trans-unit>
        <trans-unit id="0e7aa88c59ccdb8f5ae43f1abe07297a4d7ace58" translate="yes" xml:space="preserve">
          <source>The downside to implementing a macro instead of a function is that macro definitions are more complex than function definitions because you&amp;rsquo;re writing Rust code that writes Rust code. Due to this indirection, macro definitions are generally more difficult to read, understand, and maintain than function definitions.</source>
          <target state="translated">La desventaja de implementar una macro en lugar de una funci&amp;oacute;n es que las definiciones de macro son m&amp;aacute;s complejas que las definiciones de funciones porque est&amp;aacute; escribiendo c&amp;oacute;digo Rust que escribe c&amp;oacute;digo Rust. Debido a esta indirecta, las definiciones de macros son generalmente m&amp;aacute;s dif&amp;iacute;ciles de leer, comprender y mantener que las definiciones de funciones.</target>
        </trans-unit>
        <trans-unit id="719fc8d49d59015d6dffe7ccc55e5816d1966b0e" translate="yes" xml:space="preserve">
          <source>The duration of one microsecond.</source>
          <target state="translated">La duración de un microsegundo.</target>
        </trans-unit>
        <trans-unit id="e68beeeb11183a3ff18abb9e6896356e66b6200f" translate="yes" xml:space="preserve">
          <source>The duration of one millisecond.</source>
          <target state="translated">La duración de un milisegundo.</target>
        </trans-unit>
        <trans-unit id="e9d186359c1c80de39171fea4281a767f86db9c5" translate="yes" xml:space="preserve">
          <source>The duration of one nanosecond.</source>
          <target state="translated">La duración de un nanosegundo.</target>
        </trans-unit>
        <trans-unit id="926b58a37c99c224d9cf0ad023e9e79f2bae5af3" translate="yes" xml:space="preserve">
          <source>The duration of one second.</source>
          <target state="translated">La duración de un segundo.</target>
        </trans-unit>
        <trans-unit id="51e82336197f20c9062a20d4490259f940ada0fe" translate="yes" xml:space="preserve">
          <source>The easiest fix is to rewrite your closure into a top-level function, or into a method. In some cases, you may also be able to have your closure call itself by capturing a &lt;code&gt;&amp;amp;Fn()&lt;/code&gt; object or &lt;code&gt;fn()&lt;/code&gt; pointer that refers to itself. That is permitting, since the closure would be invoking itself via a virtual call, and hence does not directly reference its own &lt;em&gt;type&lt;/em&gt;.</source>
          <target state="translated">La soluci&amp;oacute;n m&amp;aacute;s f&amp;aacute;cil es reescribir su cierre en una funci&amp;oacute;n de nivel superior o en un m&amp;eacute;todo. En algunos casos, tambi&amp;eacute;n puede hacer que su cierre se llame a s&amp;iacute; mismo capturando un objeto &lt;code&gt;&amp;amp;Fn()&lt;/code&gt; o un puntero &lt;code&gt;fn()&lt;/code&gt; que se refiera a s&amp;iacute; mismo. Eso est&amp;aacute; permitido, ya que el cierre se invocar&amp;iacute;a a s&amp;iacute; mismo mediante una llamada virtual y, por lo tanto, no hace referencia directamente a su propio &lt;em&gt;tipo&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="8b90152377c4d2fa6a58836b95414b3c64c66683" translate="yes" xml:space="preserve">
          <source>The easiest way to use &lt;code&gt;HashMap&lt;/code&gt; with a custom key type is to derive &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt;. We must also derive &lt;a href=&quot;../../cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La forma m&amp;aacute;s f&amp;aacute;cil de usar &lt;code&gt;HashMap&lt;/code&gt; con un tipo de clave personalizado es derivar &lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; . Tambi&amp;eacute;n debemos derivar &lt;a href=&quot;../../cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8fdc4a2a7876216a8a5156bcc124c1c5c1d13c54" translate="yes" xml:space="preserve">
          <source>The easiest way to use &lt;code&gt;HashMap&lt;/code&gt; with a custom key type is to derive &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt;. We must also derive &lt;a href=&quot;../cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La forma m&amp;aacute;s f&amp;aacute;cil de usar &lt;code&gt;HashMap&lt;/code&gt; con un tipo de clave personalizado es derivar &lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; . Tambi&amp;eacute;n debemos derivar &lt;a href=&quot;../cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2b835cd73ddea2cd4aee637c4f9c2cd855ee696f" translate="yes" xml:space="preserve">
          <source>The easiest way to use &lt;code&gt;HashSet&lt;/code&gt; with a custom type is to derive &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt;. We must also derive &lt;a href=&quot;../../cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;, this will in the future be implied by &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La forma m&amp;aacute;s f&amp;aacute;cil de usar &lt;code&gt;HashSet&lt;/code&gt; con un tipo personalizado es derivar &lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; . Tambi&amp;eacute;n debemos derivar &lt;a href=&quot;../../cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt; , esto en el futuro estar&amp;aacute; impl&amp;iacute;cito en la &lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bcd32a61d8029373ce3811b4c81b01b04e2fcd8a" translate="yes" xml:space="preserve">
          <source>The easiest way to use &lt;code&gt;HashSet&lt;/code&gt; with a custom type is to derive &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt;. We must also derive &lt;a href=&quot;../cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;, this will in the future be implied by &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La forma m&amp;aacute;s f&amp;aacute;cil de usar &lt;code&gt;HashSet&lt;/code&gt; con un tipo personalizado es derivar &lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; . Tambi&amp;eacute;n debemos derivar &lt;a href=&quot;../cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt; , esto en el futuro estar&amp;aacute; impl&amp;iacute;cito en la &lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4abca09eae529f079207e693c4204e4240160458" translate="yes" xml:space="preserve">
          <source>The element range is removed even if the iterator is not consumed until the end.</source>
          <target state="translated">El rango de elementos se elimina aunque el iterador no se consuma hasta el final.</target>
        </trans-unit>
        <trans-unit id="857f1367d5858bf310bc19ad475cfec76822e623" translate="yes" xml:space="preserve">
          <source>The element that was removed is returned, and the cursor is moved to point to the next element in the &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17d488f8279ef9d0e051cac2f43dff0a68f18b2b" translate="yes" xml:space="preserve">
          <source>The elements are removed in arbitrary order.</source>
          <target state="translated">Los elementos se eliminan en un orden arbitrario.</target>
        </trans-unit>
        <trans-unit id="5fe5f813b6a2f233abc73bad03a94ec158695239" translate="yes" xml:space="preserve">
          <source>The elements at &lt;code&gt;old_len..new_len&lt;/code&gt; must be initialized.</source>
          <target state="translated">Los elementos en &lt;code&gt;old_len..new_len&lt;/code&gt; deben inicializarse.</target>
        </trans-unit>
        <trans-unit id="2bafc31dee9d33ba4d10ed67ef0f71ab38bfff69" translate="yes" xml:space="preserve">
          <source>The elements of an &lt;a href=&quot;types/array&quot;&gt;array&lt;/a&gt; or owned &lt;a href=&quot;types/array&quot;&gt;slice&lt;/a&gt; are dropped from the first element to the last. *</source>
          <target state="translated">Los elementos de una &lt;a href=&quot;types/array&quot;&gt;matriz&lt;/a&gt; o un &lt;a href=&quot;types/array&quot;&gt;segmento propio&lt;/a&gt; se eliminan del primer elemento al &amp;uacute;ltimo. *</target>
        </trans-unit>
        <trans-unit id="1e3e69cc26857f9c1293b40c529b047e54164338" translate="yes" xml:space="preserve">
          <source>The elements of an &lt;a href=&quot;types/array&quot;&gt;array&lt;/a&gt; or owned &lt;a href=&quot;types/slice&quot;&gt;slice&lt;/a&gt; are dropped from the first element to the last.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aa9bb19de05cfdf90da669db74c8f4ff87b16d5" translate="yes" xml:space="preserve">
          <source>The elements yielded by &lt;code&gt;DoubleEndedIterator&lt;/code&gt;'s methods may differ from the ones yielded by &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;'s methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88efd616f1a1b2e8d8f2dcc3a848a8c623471404" translate="yes" xml:space="preserve">
          <source>The elision rules don&amp;rsquo;t provide full inference. If Rust deterministically applies the rules but there is still ambiguity as to what lifetimes the references have, the compiler won&amp;rsquo;t guess what the lifetime of the remaining references should be. In this case, instead of guessing, the compiler will give you an error that you can resolve by adding the lifetime annotations that specify how the references relate to each other.</source>
          <target state="translated">Las reglas de elisi&amp;oacute;n no proporcionan una inferencia completa. Si Rust aplica las reglas de manera determinista, pero a&amp;uacute;n existe ambig&amp;uuml;edad en cuanto a la duraci&amp;oacute;n de las referencias, el compilador no adivinar&amp;aacute; cu&amp;aacute;l deber&amp;iacute;a ser la duraci&amp;oacute;n de las referencias restantes. En este caso, en lugar de adivinar, el compilador le dar&amp;aacute; un error que puede resolver agregando las anotaciones de por vida que especifican c&amp;oacute;mo se relacionan las referencias entre s&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="3e3b658969dac70797ae99e22406a5919df5b0c6" translate="yes" xml:space="preserve">
          <source>The entire expression uses the given values for the fields that were specified and moves or copies the remaining fields from the base expression. As with all struct expressions, all of the fields of the struct must be &lt;a href=&quot;../visibility-and-privacy&quot;&gt;visible&lt;/a&gt;, even those not explicitly named.</source>
          <target state="translated">Toda la expresi&amp;oacute;n usa los valores dados para los campos que se especificaron y mueve o copia los campos restantes de la expresi&amp;oacute;n base. Al igual que con todas las expresiones de estructura, todos los campos de la estructura deben estar &lt;a href=&quot;../visibility-and-privacy&quot;&gt;visibles&lt;/a&gt; , incluso aquellos que no se nombran expl&amp;iacute;citamente.</target>
        </trans-unit>
        <trans-unit id="a0574dfce03935016b1e7370699d140878e68385" translate="yes" xml:space="preserve">
          <source>The entire file name if the file name begins with &lt;code&gt;.&lt;/code&gt; and has no other &lt;code&gt;.&lt;/code&gt;s within;</source>
          <target state="translated">El nombre completo del archivo si el nombre del archivo comienza con &lt;code&gt;.&lt;/code&gt; y no tiene otro &lt;code&gt;.&lt;/code&gt; s dentro;</target>
        </trans-unit>
        <trans-unit id="e83cf0228defdcd6e7afea0984d3278d36eab74c" translate="yes" xml:space="preserve">
          <source>The entire file name if there is no embedded &lt;code&gt;.&lt;/code&gt;;</source>
          <target state="translated">El nombre completo del archivo si no hay ning&amp;uacute;n &lt;code&gt;.&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="3fa274546f438640798ab62aae39ac18398db5cc" translate="yes" xml:space="preserve">
          <source>The entire function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a5d709e7f69a77cb8061cae38e47a941e97332f" translate="yes" xml:space="preserve">
          <source>The entire function body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c15c39c685d0906fec325e3d5c2bea1c6eb708a" translate="yes" xml:space="preserve">
          <source>The entire function scope is the outer most scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b8eedec31f30287b3b74ad1f2675a525e2c3cf5" translate="yes" xml:space="preserve">
          <source>The entire hash map is generic over a key type &lt;code&gt;K&lt;/code&gt;. Because these keys are stored with the hash map, this type has to own the key&amp;rsquo;s data. When inserting a key-value pair, the map is given such a &lt;code&gt;K&lt;/code&gt; and needs to find the correct hash bucket and check if the key is already present based on that &lt;code&gt;K&lt;/code&gt;. It therefore requires &lt;code&gt;K: Hash + Eq&lt;/code&gt;.</source>
          <target state="translated">Todo el mapa hash es gen&amp;eacute;rico sobre un tipo de clave &lt;code&gt;K&lt;/code&gt; . Debido a que estas claves se almacenan con el mapa hash, este tipo debe poseer los datos de la clave. Al insertar un par clave-valor, el mapa se da un ejemplo &lt;code&gt;K&lt;/code&gt; y necesita encontrar el cubo de hash correcto y compruebe si la memoria ya est&amp;aacute; presente sobre la base de que &lt;code&gt;K&lt;/code&gt; . Por lo tanto, requiere &lt;code&gt;K: Hash + Eq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0297c1c788a21e67f6b7fde15406ec3888485937" translate="yes" xml:space="preserve">
          <source>The entire memory range of this slice must be contained within a single allocated object! Slices can never span across multiple allocated objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d250d768cfabd095635656557072ab76a1e3cbad" translate="yes" xml:space="preserve">
          <source>The entire memory range of this slice must be contained within a single allocated object! Slices can never span across multiple allocated objects. See &lt;a href=&quot;#incorrect-usage&quot;&gt;below&lt;/a&gt; for an example incorrectly not taking this into account.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97dea0260f138033ef7cf2f5ca57a634d6eea616" translate="yes" xml:space="preserve">
          <source>The entry point of the program was marked as &lt;code&gt;async&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82f98df6718e5a9d6fd411d1cc853597af7467ed" translate="yes" xml:space="preserve">
          <source>The error and the note tell the story: Rust strings don&amp;rsquo;t support indexing. But why not? To answer that question, we need to discuss how Rust stores strings in memory.</source>
          <target state="translated">El error y la nota cuentan la historia: las cadenas de Rust no admiten la indexaci&amp;oacute;n. &amp;iquest;Pero por qu&amp;eacute; no? Para responder a esa pregunta, debemos analizar c&amp;oacute;mo Rust almacena cadenas en la memoria.</target>
        </trans-unit>
        <trans-unit id="41a72aa86a9d9e55bed7f9841f1b9fdc25696e6c" translate="yes" xml:space="preserve">
          <source>The error happens on numeric literals and on numeric bindings without an identified concrete type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1decc58ff466451824639b9b2033b046dfa94fee" translate="yes" xml:space="preserve">
          <source>The error happens on numeric literals:</source>
          <target state="translated">El error se produce en los literales numéricos:</target>
        </trans-unit>
        <trans-unit id="39121a17de405ba30c8238c549d55b70becaf449" translate="yes" xml:space="preserve">
          <source>The error indicates that Rust expected a &lt;code&gt;bool&lt;/code&gt; but got an integer. Unlike languages such as Ruby and JavaScript, Rust will not automatically try to convert non-Boolean types to a Boolean. You must be explicit and always provide &lt;code&gt;if&lt;/code&gt; with a Boolean as its condition. If we want the &lt;code&gt;if&lt;/code&gt; code block to run only when a number is not equal to &lt;code&gt;0&lt;/code&gt;, for example, we can change the &lt;code&gt;if&lt;/code&gt; expression to the following:</source>
          <target state="translated">El error indica que Rust esperaba un &lt;code&gt;bool&lt;/code&gt; pero obtuvo un n&amp;uacute;mero entero. A diferencia de lenguajes como Ruby y JavaScript, Rust no intentar&amp;aacute; convertir autom&amp;aacute;ticamente los tipos no booleanos en booleanos. Debe ser expl&amp;iacute;cito y siempre proporcionar &lt;code&gt;if&lt;/code&gt; con un booleano como condici&amp;oacute;n. Si queremos que el bloque de c&amp;oacute;digo &lt;code&gt;if&lt;/code&gt; se ejecute solo cuando un n&amp;uacute;mero no es igual a &lt;code&gt;0&lt;/code&gt; , por ejemplo, podemos cambiar la expresi&amp;oacute;n &lt;code&gt;if&lt;/code&gt; a lo siguiente:</target>
        </trans-unit>
        <trans-unit id="82fe814b563c83c1ad42c2a44464d60e45abeb59" translate="yes" xml:space="preserve">
          <source>The error message indicates that the cause of the error is that you &lt;code&gt;cannot assign twice to immutable variable x&lt;/code&gt;, because you tried to assign a second value to the immutable &lt;code&gt;x&lt;/code&gt; variable.</source>
          <target state="translated">El mensaje de error indica que la causa del error es que no &lt;code&gt;cannot assign twice to immutable variable x&lt;/code&gt; , porque intent&amp;oacute; asignar un segundo valor a la variable &lt;code&gt;x&lt;/code&gt; inmutable .</target>
        </trans-unit>
        <trans-unit id="1acd99d552c691a91137d21fedf0cc394ac8a4d0" translate="yes" xml:space="preserve">
          <source>The error message states that the &lt;code&gt;counter&lt;/code&gt; value is moved into the closure and then captured when we call &lt;code&gt;lock&lt;/code&gt;. That description sounds like what we wanted, but it&amp;rsquo;s not allowed!</source>
          <target state="translated">El mensaje de error indica que el valor del &lt;code&gt;counter&lt;/code&gt; se mueve al cierre y luego se captura cuando llamamos al &lt;code&gt;lock&lt;/code&gt; . Esa descripci&amp;oacute;n suena como lo que quer&amp;iacute;amos, &amp;iexcl;pero no est&amp;aacute; permitido!</target>
        </trans-unit>
        <trans-unit id="5bb7a0ad71457e0f1d6ce226ce7b55ec5697ceba" translate="yes" xml:space="preserve">
          <source>The error message states that the &lt;code&gt;counter&lt;/code&gt; value was moved in the previous iteration of the loop. So Rust is telling us that we can&amp;rsquo;t move the ownership of lock &lt;code&gt;counter&lt;/code&gt; into multiple threads. Let&amp;rsquo;s fix the compiler error with a multiple-ownership method we discussed in Chapter 15.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6326b5d7f5ddab487c6090e5e84a18d25a0a3db6" translate="yes" xml:space="preserve">
          <source>The error messages say that module &lt;code&gt;hosting&lt;/code&gt; is private. In other words, we have the correct paths for the &lt;code&gt;hosting&lt;/code&gt; module and the &lt;code&gt;add_to_waitlist&lt;/code&gt; function, but Rust won&amp;rsquo;t let us use them because it doesn&amp;rsquo;t have access to the private sections.</source>
          <target state="translated">Los mensajes de error dicen que el &lt;code&gt;hosting&lt;/code&gt; m&amp;oacute;dulo es privado. En otras palabras, tenemos las rutas correctas para el m&amp;oacute;dulo de &lt;code&gt;hosting&lt;/code&gt; y la funci&amp;oacute;n &lt;code&gt;add_to_waitlist&lt;/code&gt; , pero Rust no nos deja usarlas porque no tiene acceso a las secciones privadas.</target>
        </trans-unit>
        <trans-unit id="8eb6e3e38ad85be87f507639136fdec21b108288" translate="yes" xml:space="preserve">
          <source>The error occurs because &lt;code&gt;foo&lt;/code&gt; accepts a closure that takes an &lt;code&gt;i32&lt;/code&gt; argument, but in &lt;code&gt;main&lt;/code&gt;, it is passed a closure with a &lt;code&gt;&amp;amp;str&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4df536d23e48c26eec2d844083fbc5169ab15de6" translate="yes" xml:space="preserve">
          <source>The error occurs because keyword &lt;code&gt;yield&lt;/code&gt; can only be used inside the generator literal. This can be fixed by constructing the generator correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bce45a967fbcca42003bd3fc6c351711632526a" translate="yes" xml:space="preserve">
          <source>The error references the &lt;code&gt;Sized&lt;/code&gt; trait again! Rust doesn&amp;rsquo;t know how much space it will need to store the closure. We saw a solution to this problem earlier. We can use a trait object:</source>
          <target state="translated">&amp;iexcl;El error hace referencia al rasgo &lt;code&gt;Sized&lt;/code&gt; nuevamente! Rust no sabe cu&amp;aacute;nto espacio necesitar&amp;aacute; para almacenar el cierre. Vimos una soluci&amp;oacute;n a este problema antes. Podemos usar un objeto de rasgo:</target>
        </trans-unit>
        <trans-unit id="687172b839a6f9ace430c7922b4119fecbbc273c" translate="yes" xml:space="preserve">
          <source>The error says we&amp;rsquo;re not allowed to mutate a variable&amp;rsquo;s type:</source>
          <target state="translated">El error dice que no podemos mutar el tipo de una variable:</target>
        </trans-unit>
        <trans-unit id="4c799801c95c3499262c7f795808c56dd04d3f03" translate="yes" xml:space="preserve">
          <source>The error shows that for &lt;code&gt;result&lt;/code&gt; to be valid for the &lt;code&gt;println!&lt;/code&gt; statement, &lt;code&gt;string2&lt;/code&gt; would need to be valid until the end of the outer scope. Rust knows this because we annotated the lifetimes of the function parameters and return values using the same lifetime parameter &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="translated">El error muestra que para que el &lt;code&gt;result&lt;/code&gt; ado sea ​​v&amp;aacute;lido para &lt;code&gt;println!&lt;/code&gt; declaraci&amp;oacute;n, &lt;code&gt;string2&lt;/code&gt; deber&amp;iacute;a ser v&amp;aacute;lida hasta el final del alcance externo. Rust lo sabe porque anotamos la vida &amp;uacute;til de los par&amp;aacute;metros de la funci&amp;oacute;n y los valores de retorno utilizando el mismo par&amp;aacute;metro de vida &amp;uacute;til &lt;code&gt;'a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81dd6345e63f7b9b970ec324dc927c2a78ce87e8" translate="yes" xml:space="preserve">
          <source>The error shows that you can&amp;rsquo;t use the keyword &lt;code&gt;match&lt;/code&gt; as the function identifier. To use &lt;code&gt;match&lt;/code&gt; as a function name, you need to use the raw identifier syntax, like this:</source>
          <target state="translated">El error muestra que no puede utilizar la &lt;code&gt;match&lt;/code&gt; palabras clave como identificador de funci&amp;oacute;n. Para usar la &lt;code&gt;match&lt;/code&gt; como nombre de funci&amp;oacute;n, debe usar la sintaxis de identificador sin formato, como esta:</target>
        </trans-unit>
        <trans-unit id="17031b6288809d4b66c77a71348fe05200b2e1e5" translate="yes" xml:space="preserve">
          <source>The error shows this type &amp;ldquo;has infinite size.&amp;rdquo; The reason is that we&amp;rsquo;ve defined &lt;code&gt;List&lt;/code&gt; with a variant that is recursive: it holds another value of itself directly. As a result, Rust can&amp;rsquo;t figure out how much space it needs to store a &lt;code&gt;List&lt;/code&gt; value. Let&amp;rsquo;s break down why we get this error a bit. First, let&amp;rsquo;s look at how Rust decides how much space it needs to store a value of a non-recursive type.</source>
          <target state="translated">El error muestra que este tipo &quot;tiene un tama&amp;ntilde;o infinito&quot;. La raz&amp;oacute;n es que hemos definido &lt;code&gt;List&lt;/code&gt; con una variante que es recursiva: tiene otro valor de s&amp;iacute; mismo directamente. Como resultado, Rust no puede calcular cu&amp;aacute;nto espacio necesita para almacenar un valor de &lt;code&gt;List&lt;/code&gt; . Analicemos un poco por qu&amp;eacute; obtenemos este error. Primero, veamos c&amp;oacute;mo Rust decide cu&amp;aacute;nto espacio necesita para almacenar un valor de tipo no recursivo.</target>
        </trans-unit>
        <trans-unit id="ddd69ec9cc85fcc63997c43bed364cf16ee6b3f9" translate="yes" xml:space="preserve">
          <source>The error tells us we can&amp;rsquo;t call &lt;code&gt;join&lt;/code&gt; because we only have a mutable borrow of each &lt;code&gt;worker&lt;/code&gt; and &lt;code&gt;join&lt;/code&gt; takes ownership of its argument. To solve this issue, we need to move the thread out of the &lt;code&gt;Worker&lt;/code&gt; instance that owns &lt;code&gt;thread&lt;/code&gt; so &lt;code&gt;join&lt;/code&gt; can consume the thread. We did this in Listing 17-15: if &lt;code&gt;Worker&lt;/code&gt; holds an &lt;code&gt;Option&amp;lt;thread::JoinHandle&amp;lt;()&amp;gt;&amp;gt;&lt;/code&gt; instead, we can call the &lt;code&gt;take&lt;/code&gt; method on the &lt;code&gt;Option&lt;/code&gt; to move the value out of the &lt;code&gt;Some&lt;/code&gt; variant and leave a &lt;code&gt;None&lt;/code&gt; variant in its place. In other words, a &lt;code&gt;Worker&lt;/code&gt; that is running will have a &lt;code&gt;Some&lt;/code&gt; variant in &lt;code&gt;thread&lt;/code&gt;, and when we want to clean up a &lt;code&gt;Worker&lt;/code&gt;, we&amp;rsquo;ll replace &lt;code&gt;Some&lt;/code&gt; with &lt;code&gt;None&lt;/code&gt; so the &lt;code&gt;Worker&lt;/code&gt; doesn&amp;rsquo;t have a thread to run.</source>
          <target state="translated">El error nos dice que no podemos llamar a &lt;code&gt;join&lt;/code&gt; porque solo tenemos un pr&amp;eacute;stamo mutable de cada &lt;code&gt;worker&lt;/code&gt; y &lt;code&gt;join&lt;/code&gt; toma posesi&amp;oacute;n de su argumento. Para resolver este problema, necesitamos mover el subproceso fuera de la instancia de &lt;code&gt;Worker&lt;/code&gt; que posee el &lt;code&gt;thread&lt;/code&gt; para que &lt;code&gt;join&lt;/code&gt; pueda consumir el subproceso. Hicimos esto en el Listado 17-15: si &lt;code&gt;Worker&lt;/code&gt; tiene una &lt;code&gt;Option&amp;lt;thread::JoinHandle&amp;lt;()&amp;gt;&amp;gt;&lt;/code&gt; lugar, podemos llamar al m&amp;eacute;todo &lt;code&gt;take&lt;/code&gt; en la &lt;code&gt;Option&lt;/code&gt; para mover el valor fuera de la variante &lt;code&gt;Some&lt;/code&gt; y dejar una variante &lt;code&gt;None&lt;/code&gt; en su lugar. En otras palabras, un &lt;code&gt;Worker&lt;/code&gt; que se est&amp;aacute; ejecutando tendr&amp;aacute; una variante &lt;code&gt;Some&lt;/code&gt; en &lt;code&gt;thread&lt;/code&gt; , y cuando queramos limpiar un &lt;code&gt;Worker&lt;/code&gt; , reemplazaremos &lt;code&gt;Some&lt;/code&gt; con &lt;code&gt;None&lt;/code&gt; para que el &lt;code&gt;Worker&lt;/code&gt; no tenga un subproceso para ejecutar.</target>
        </trans-unit>
        <trans-unit id="58b8d8f068cf467e7f55c896bbdf137f3a755bf5" translate="yes" xml:space="preserve">
          <source>The error type for &lt;code&gt;try_reserve&lt;/code&gt; methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="458fb320b83d2d5563146d6c64a5e9086c1cdbe5" translate="yes" xml:space="preserve">
          <source>The error type for I/O operations of the &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trait.seek&quot;&gt;&lt;code&gt;Seek&lt;/code&gt;&lt;/a&gt;, and associated traits.</source>
          <target state="translated">El tipo de error para las operaciones de E / S de &lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;trait.seek&quot;&gt; &lt;code&gt;Seek&lt;/code&gt; &lt;/a&gt; y caracter&amp;iacute;sticas asociadas.</target>
        </trans-unit>
        <trans-unit id="3e8c3a7432541c640c48492379ea610ecb40f6ae" translate="yes" xml:space="preserve">
          <source>The error type for errors that can never happen.</source>
          <target state="translated">El tipo de error para los errores que nunca pueden ocurrir.</target>
        </trans-unit>
        <trans-unit id="fdb319ec59d1f1964ec642ac851b7301cdf60e57" translate="yes" xml:space="preserve">
          <source>The error type for operations interacting with environment variables. Possibly returned from &lt;a href=&quot;fn.var&quot;&gt;&lt;code&gt;env::var()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="751842d7baf0779231030e01a15db69a4f03c6bc" translate="yes" xml:space="preserve">
          <source>The error type for operations interacting with environment variables. Possibly returned from the &lt;a href=&quot;fn.var&quot;&gt;&lt;code&gt;env::var&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">El tipo de error para operaciones que interact&amp;uacute;an con variables de entorno. Posiblemente devuelto de la funci&amp;oacute;n &lt;a href=&quot;fn.var&quot;&gt; &lt;code&gt;env::var&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="11ea1ae6c021101c095eab4ba4b755be8b16c063" translate="yes" xml:space="preserve">
          <source>The error type for operations on the &lt;code&gt;PATH&lt;/code&gt; variable. Possibly returned from &lt;a href=&quot;fn.join_paths&quot;&gt;&lt;code&gt;env::join_paths()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04e8342895bd312f045a40780238aabb9ef5de36" translate="yes" xml:space="preserve">
          <source>The error type for operations on the &lt;code&gt;PATH&lt;/code&gt; variable. Possibly returned from the &lt;a href=&quot;fn.join_paths&quot;&gt;&lt;code&gt;env::join_paths&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">El tipo de error para operaciones en la variable &lt;code&gt;PATH&lt;/code&gt; . Posiblemente devuelto por la funci&amp;oacute;n &lt;a href=&quot;fn.join_paths&quot;&gt; &lt;code&gt;env::join_paths&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="92c7e92ce900890826a3bdc04f0bdb6f93a2ae4e" translate="yes" xml:space="preserve">
          <source>The error type returned when a checked integral type conversion fails.</source>
          <target state="translated">El tipo de error regresó cuando una conversión de tipo integral comprobada falla.</target>
        </trans-unit>
        <trans-unit id="7c03030b0922657a2b23ad871594bf872bfa86e8" translate="yes" xml:space="preserve">
          <source>The error type returned when a conversion from a slice to an array fails.</source>
          <target state="translated">El tipo de error regresó cuando una conversión de una rebanada a un arreglo falla.</target>
        </trans-unit>
        <trans-unit id="5bd755e234651b9d8db0dad82d899820eb73c1c6" translate="yes" xml:space="preserve">
          <source>The error type returned when a conversion from u32 to char fails.</source>
          <target state="translated">El tipo de error regresó cuando una conversión de u32 a char falla.</target>
        </trans-unit>
        <trans-unit id="74bd671788812266d70e1e6379cd71d68b83bdd8" translate="yes" xml:space="preserve">
          <source>The error type that results from applying the try operator (&lt;code&gt;?&lt;/code&gt;) to a &lt;code&gt;None&lt;/code&gt; value. If you wish to allow &lt;code&gt;x?&lt;/code&gt; (where &lt;code&gt;x&lt;/code&gt; is an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;) to be converted into your error type, you can implement &lt;code&gt;impl From&amp;lt;NoneError&amp;gt;&lt;/code&gt; for &lt;code&gt;YourErrorType&lt;/code&gt;. In that case, &lt;code&gt;x?&lt;/code&gt; within a function that returns &lt;code&gt;Result&amp;lt;_, YourErrorType&amp;gt;&lt;/code&gt; will translate a &lt;code&gt;None&lt;/code&gt; value into an &lt;code&gt;Err&lt;/code&gt; result.</source>
          <target state="translated">El tipo de error que resulta de aplicar el operador try ( &lt;code&gt;?&lt;/code&gt; ) A un valor &lt;code&gt;None&lt;/code&gt; . Si desea permitir &lt;code&gt;x?&lt;/code&gt; (donde &lt;code&gt;x&lt;/code&gt; es una &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; ) para convertirla en su tipo de error, puede implementar &lt;code&gt;impl From&amp;lt;NoneError&amp;gt;&lt;/code&gt; para &lt;code&gt;YourErrorType&lt;/code&gt; . En ese caso, &lt;code&gt;x?&lt;/code&gt; dentro de una funci&amp;oacute;n que devuelve &lt;code&gt;Result&amp;lt;_, YourErrorType&amp;gt;&lt;/code&gt; traducir&amp;aacute; un valor &lt;code&gt;None&lt;/code&gt; en un resultado &lt;code&gt;Err&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="620e9e66f647e7af133c1492023ad78f941762d1" translate="yes" xml:space="preserve">
          <source>The error type which is returned from formatting a message into a stream.</source>
          <target state="translated">El tipo de error que se devuelve al formatear un mensaje en un flujo.</target>
        </trans-unit>
        <trans-unit id="d4672a685f085da2d7d7f62486ff4649fbce70a5" translate="yes" xml:space="preserve">
          <source>The errors in Listing 7-6 say that the &lt;code&gt;add_to_waitlist&lt;/code&gt; function is private. The privacy rules apply to structs, enums, functions, and methods as well as modules.</source>
          <target state="translated">Los errores del Listado 7-6 dicen que la funci&amp;oacute;n &lt;code&gt;add_to_waitlist&lt;/code&gt; es privada. Las reglas de privacidad se aplican a estructuras, enumeraciones, funciones y m&amp;eacute;todos, as&amp;iacute; como a m&amp;oacute;dulos.</target>
        </trans-unit>
        <trans-unit id="5c9b02894ffaf56c3eee190bd9f4d3e5a18ff962" translate="yes" xml:space="preserve">
          <source>The exact behavior on locking a mutex in the thread which already holds the lock is left unspecified. However, this function will not return on the second call (it might panic or deadlock, for example).</source>
          <target state="translated">El comportamiento exacto al bloquear un mutex en el hilo que ya sujeta el cierre se deja sin especificar.Sin embargo,esta función no regresará en la segunda llamada (podría entrar en pánico o en un punto muerto,por ejemplo).</target>
        </trans-unit>
        <trans-unit id="ec573024d9a369fea8772d4967a09d1e972fae0a" translate="yes" xml:space="preserve">
          <source>The exact character(s)</source>
          <target state="translated">El personaje o personajes exactos</target>
        </trans-unit>
        <trans-unit id="df2f57248767dbedd045941faa73ddbe53944b27" translate="yes" xml:space="preserve">
          <source>The exact order may be useful for tracking external state, like an index.</source>
          <target state="translated">El orden exacto puede ser útil para rastrear el estado externo,como un índice.</target>
        </trans-unit>
        <trans-unit id="8fe495e6414bd43e7bea5f0003cca50741a5b59b" translate="yes" xml:space="preserve">
          <source>The exact output printed by this macro should not be relied upon and is subject to future changes.</source>
          <target state="translated">La salida exacta impresa por esta macro no debe ser confiable y está sujeta a futuros cambios.</target>
        </trans-unit>
        <trans-unit id="469498f0144088c9a82cccca15de67704811a8dd" translate="yes" xml:space="preserve">
          <source>The exact text, of course, depends on what files you have in &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="translated">El texto exacto, por supuesto, depende de los archivos que tenga &lt;code&gt;.&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="395c851d3758c4daf594b9f6b458c5ca4cd7434f" translate="yes" xml:space="preserve">
          <source>The example in Listing 13-14 separates the creation of the iterator from the use of the iterator in the &lt;code&gt;for&lt;/code&gt; loop. The iterator is stored in the &lt;code&gt;v1_iter&lt;/code&gt; variable, and no iteration takes place at that time. When the &lt;code&gt;for&lt;/code&gt; loop is called using the iterator in &lt;code&gt;v1_iter&lt;/code&gt;, each element in the iterator is used in one iteration of the loop, which prints out each value.</source>
          <target state="translated">El ejemplo del Listado 13-14 separa la creaci&amp;oacute;n del iterador del uso del iterador en el bucle &lt;code&gt;for&lt;/code&gt; . El iterador se almacena en la variable &lt;code&gt;v1_iter&lt;/code&gt; y no tiene lugar ninguna iteraci&amp;oacute;n en ese momento. Cuando se llama &lt;code&gt;for&lt;/code&gt; bucle for usando el iterador en &lt;code&gt;v1_iter&lt;/code&gt; , cada elemento del iterador se usa en una iteraci&amp;oacute;n del bucle, que imprime cada valor.</target>
        </trans-unit>
        <trans-unit id="e88d69a7ee7e1056409be12e179c7703287290b1" translate="yes" xml:space="preserve">
          <source>The exception to this idiom is if we&amp;rsquo;re bringing two items with the same name into scope with &lt;code&gt;use&lt;/code&gt; statements, because Rust doesn&amp;rsquo;t allow that. Listing 7-15 shows how to bring two &lt;code&gt;Result&lt;/code&gt; types into scope that have the same name but different parent modules and how to refer to them.</source>
          <target state="translated">La excepci&amp;oacute;n a este modismo es si traemos dos elementos con el mismo nombre al alcance con declaraciones de &lt;code&gt;use&lt;/code&gt; , porque Rust no lo permite. El Listado 7-15 muestra c&amp;oacute;mo traer dos tipos de &lt;code&gt;Result&lt;/code&gt; al alcance que tienen el mismo nombre pero diferentes m&amp;oacute;dulos principales y c&amp;oacute;mo hacer referencia a ellos.</target>
        </trans-unit>
        <trans-unit id="f9ff06ceaf161b4f26d0944c142b9739231935eb" translate="yes" xml:space="preserve">
          <source>The exception to this is the unit tuple (&lt;code&gt;()&lt;/code&gt;) which is guaranteed as a zero-sized type to have a size of 0 and an alignment of 1.</source>
          <target state="translated">La excepci&amp;oacute;n a esto es la tupla unitaria ( &lt;code&gt;()&lt;/code&gt; ) que se garantiza como tipo de tama&amp;ntilde;o cero para tener un tama&amp;ntilde;o de 0 y una alineaci&amp;oacute;n de 1.</target>
        </trans-unit>
        <trans-unit id="3dc57cf649d183700b8e68c720c692cad27e1162" translate="yes" xml:space="preserve">
          <source>The expanded expression has type &lt;code&gt;&amp;amp;'static str&lt;/code&gt;, and the returned file is not the invocation of the &lt;code&gt;file!&lt;/code&gt; macro itself, but rather the first macro invocation leading up to the invocation of the &lt;code&gt;file!&lt;/code&gt; macro.</source>
          <target state="translated">La expresi&amp;oacute;n expandida tiene el tipo &lt;code&gt;&amp;amp;'static str&lt;/code&gt; , &amp;iexcl;y el archivo devuelto no es la invocaci&amp;oacute;n del &lt;code&gt;file!&lt;/code&gt; macro en s&amp;iacute;, sino la primera invocaci&amp;oacute;n de macro que lleva a la invocaci&amp;oacute;n del &lt;code&gt;file!&lt;/code&gt; macro.</target>
        </trans-unit>
        <trans-unit id="2027bedff965dc7817b0dd952d1fc211920c5f6d" translate="yes" xml:space="preserve">
          <source>The expanded expression has type &lt;code&gt;u32&lt;/code&gt; and is 1-based, so the first column in each line evaluates to 1, the second to 2, etc. This is consistent with error messages by common compilers or popular editors. The returned column is &lt;em&gt;not necessarily&lt;/em&gt; the line of the &lt;code&gt;column!&lt;/code&gt; invocation itself, but rather the first macro invocation leading up to the invocation of the &lt;code&gt;column!&lt;/code&gt; macro.</source>
          <target state="translated">La expresi&amp;oacute;n expandida tiene el tipo &lt;code&gt;u32&lt;/code&gt; y est&amp;aacute; basada en 1, por lo que la primera columna de cada l&amp;iacute;nea se eval&amp;uacute;a como 1, la segunda como 2, etc. Esto es consistente con los mensajes de error de compiladores comunes o editores populares. &amp;iexcl;La columna devuelta &lt;em&gt;no&lt;/em&gt; es &lt;em&gt;necesariamente&lt;/em&gt; la l&amp;iacute;nea de la &lt;code&gt;column!&lt;/code&gt; invocaci&amp;oacute;n en s&amp;iacute;, sino m&amp;aacute;s bien la primera macro invocaci&amp;oacute;n que conduce a la invocaci&amp;oacute;n de la &lt;code&gt;column!&lt;/code&gt; macro.</target>
        </trans-unit>
        <trans-unit id="b0b06f58ec99c372d86a17a34c7166fa5de08c27" translate="yes" xml:space="preserve">
          <source>The expanded expression has type &lt;code&gt;u32&lt;/code&gt; and is 1-based, so the first line in each file evaluates to 1, the second to 2, etc. This is consistent with error messages by common compilers or popular editors. The returned line is &lt;em&gt;not necessarily&lt;/em&gt; the line of the &lt;code&gt;line!&lt;/code&gt; invocation itself, but rather the first macro invocation leading up to the invocation of the &lt;code&gt;line!&lt;/code&gt; macro.</source>
          <target state="translated">La expresi&amp;oacute;n expandida tiene el tipo &lt;code&gt;u32&lt;/code&gt; y est&amp;aacute; basada en 1, por lo que la primera l&amp;iacute;nea de cada archivo se eval&amp;uacute;a como 1, la segunda como 2, etc. Esto es consistente con los mensajes de error de compiladores comunes o editores populares. &amp;iexcl;La l&amp;iacute;nea devuelta &lt;em&gt;no&lt;/em&gt; es &lt;em&gt;necesariamente&lt;/em&gt; la l&amp;iacute;nea de la &lt;code&gt;line!&lt;/code&gt; invocaci&amp;oacute;n en s&amp;iacute;, sino m&amp;aacute;s bien la primera macro invocaci&amp;oacute;n que conduce a la invocaci&amp;oacute;n de la &lt;code&gt;line!&lt;/code&gt; macro.</target>
        </trans-unit>
        <trans-unit id="6dec360ada9c00c421ed26b5b352f032e17122ed" translate="yes" xml:space="preserve">
          <source>The expected cost of &lt;code&gt;push&lt;/code&gt;, averaged over every possible ordering of the elements being pushed, and over a sufficiently large number of pushes, is &lt;em&gt;O&lt;/em&gt;(1). This is the most meaningful cost metric when pushing elements that are &lt;em&gt;not&lt;/em&gt; already in any sorted pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="606b0f6565bb5e33a7e793c7978e5b02d8b8d28b" translate="yes" xml:space="preserve">
          <source>The expected cost of &lt;code&gt;push&lt;/code&gt;, averaged over every possible ordering of the elements being pushed, and over a sufficiently large number of pushes, is O(1). This is the most meaningful cost metric when pushing elements that are &lt;em&gt;not&lt;/em&gt; already in any sorted pattern.</source>
          <target state="translated">El costo esperado de &lt;code&gt;push&lt;/code&gt; , promediado sobre cada posible orden de los elementos empujados, y sobre un n&amp;uacute;mero suficientemente grande de empujes, es O (1). Esta es la m&amp;eacute;trica de costos m&amp;aacute;s significativa cuando se empujan elementos que a&amp;uacute;n &lt;em&gt;no&lt;/em&gt; est&amp;aacute;n en ning&amp;uacute;n patr&amp;oacute;n ordenado.</target>
        </trans-unit>
        <trans-unit id="a72ec7eef34f0a8ffd7d99e9cfce2da0536188e2" translate="yes" xml:space="preserve">
          <source>The expression above creates a value of type &lt;code&gt;MyUnion&lt;/code&gt; and initializes the storage using field &lt;code&gt;f1&lt;/code&gt;. The union can be accessed using the same syntax as struct fields:</source>
          <target state="translated">La expresi&amp;oacute;n anterior crea un valor de tipo &lt;code&gt;MyUnion&lt;/code&gt; e inicializa el almacenamiento usando el campo &lt;code&gt;f1&lt;/code&gt; . Se puede acceder a la uni&amp;oacute;n usando la misma sintaxis que los campos de estructura:</target>
        </trans-unit>
        <trans-unit id="b5fa765f11cc060019641c8e75e38c695bdb1bda" translate="yes" xml:space="preserve">
          <source>The expression cannot be a &lt;a href=&quot;operator-expr#lazy-boolean-operators&quot;&gt;lazy boolean operator expression&lt;/a&gt;. Use of a lazy boolean operator is ambiguous with a planned feature change of the language (the implementation of if-let chains - see &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2497-if-let-chains.md#rollout-plan-and-transitioning-to-rust-2018&quot;&gt;eRFC 2947&lt;/a&gt;). When lazy boolean operator expression is desired, this can be achieved by using parenthesis as below:</source>
          <target state="translated">La expresi&amp;oacute;n no puede ser una &lt;a href=&quot;operator-expr#lazy-boolean-operators&quot;&gt;expresi&amp;oacute;n de operador booleano perezoso&lt;/a&gt; . El uso de un operador booleano perezoso es ambiguo con un cambio de caracter&amp;iacute;stica planificado del lenguaje (la implementaci&amp;oacute;n de cadenas if-let - ver &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2497-if-let-chains.md#rollout-plan-and-transitioning-to-rust-2018&quot;&gt;eRFC 2947&lt;/a&gt; ). Cuando se desea una expresi&amp;oacute;n de operador booleano perezoso, esto se puede lograr usando par&amp;eacute;ntesis como se muestra a continuaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="a608f321648c235bb5c3f09a506a153d6d9a7fa1" translate="yes" xml:space="preserve">
          <source>The expression for a match arm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edc402eeeb9a7639cb3c026b59f168e6cd732965" translate="yes" xml:space="preserve">
          <source>The expression immediately following &lt;code&gt;in&lt;/code&gt; must implement the &lt;a href=&quot;../book/ch13-04-performance&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64c3c13114c938924165b32b931fcfa0929a3dad" translate="yes" xml:space="preserve">
          <source>The expression in the &lt;code&gt;if&lt;/code&gt; block evaluates to an integer, and the expression in the &lt;code&gt;else&lt;/code&gt; block evaluates to a string. This won&amp;rsquo;t work because variables must have a single type. Rust needs to know at compile time what type the &lt;code&gt;number&lt;/code&gt; variable is, definitively, so it can verify at compile time that its type is valid everywhere we use &lt;code&gt;number&lt;/code&gt;. Rust wouldn&amp;rsquo;t be able to do that if the type of &lt;code&gt;number&lt;/code&gt; was only determined at runtime; the compiler would be more complex and would make fewer guarantees about the code if it had to keep track of multiple hypothetical types for any variable.</source>
          <target state="translated">La expresi&amp;oacute;n en el bloque &lt;code&gt;if&lt;/code&gt; se eval&amp;uacute;a como un n&amp;uacute;mero entero y la expresi&amp;oacute;n en el bloque &lt;code&gt;else&lt;/code&gt; se eval&amp;uacute;a como una cadena. Esto no funcionar&amp;aacute; porque las variables deben tener un solo tipo. Rust necesita saber en el momento de la compilaci&amp;oacute;n qu&amp;eacute; tipo es la variable &lt;code&gt;number&lt;/code&gt; , definitivamente, para poder verificar en el momento de la compilaci&amp;oacute;n que su tipo es v&amp;aacute;lido en todos los lugares donde usamos el &lt;code&gt;number&lt;/code&gt; . Rust no podr&amp;iacute;a hacer eso si el tipo de &lt;code&gt;number&lt;/code&gt; solo se determinara en tiempo de ejecuci&amp;oacute;n; el compilador ser&amp;iacute;a m&amp;aacute;s complejo y ofrecer&amp;iacute;a menos garant&amp;iacute;as sobre el c&amp;oacute;digo si tuviera que realizar un seguimiento de m&amp;uacute;ltiples tipos hipot&amp;eacute;ticos para cualquier variable.</target>
        </trans-unit>
        <trans-unit id="7947155b0fa5fdbbf2d84b0fb9bff1298adf4bf1" translate="yes" xml:space="preserve">
          <source>The extension is:</source>
          <target state="translated">La extensión es:</target>
        </trans-unit>
        <trans-unit id="ea39e7727f6084ef5165d4f9b888542528c3cc1d" translate="yes" xml:space="preserve">
          <source>The external crate is resolved to a specific &lt;code&gt;soname&lt;/code&gt; at compile time, and a runtime linkage requirement to that &lt;code&gt;soname&lt;/code&gt; is passed to the linker for loading at runtime. The &lt;code&gt;soname&lt;/code&gt; is resolved at compile time by scanning the compiler's library path and matching the optional &lt;code&gt;crateid&lt;/code&gt; provided against the &lt;code&gt;crateid&lt;/code&gt; attributes that were declared on the external crate when it was compiled. If no &lt;code&gt;crateid&lt;/code&gt; is provided, a default &lt;code&gt;name&lt;/code&gt; attribute is assumed, equal to the &lt;a href=&quot;../identifiers&quot;&gt;identifier&lt;/a&gt; given in the &lt;code&gt;extern crate&lt;/code&gt; declaration.</source>
          <target state="translated">La caja externa se resuelve en un &lt;code&gt;soname&lt;/code&gt; espec&amp;iacute;fico en tiempo de compilaci&amp;oacute;n, y un requisito de vinculaci&amp;oacute;n en tiempo de ejecuci&amp;oacute;n para ese &lt;code&gt;soname&lt;/code&gt; se pasa al enlazador para cargar en tiempo de ejecuci&amp;oacute;n. El &lt;code&gt;soname&lt;/code&gt; se resuelve en el momento de la compilaci&amp;oacute;n escaneando la ruta de la biblioteca del compilador y &lt;code&gt;crateid&lt;/code&gt; el crateid opcional proporcionado con los atributos &lt;code&gt;crateid&lt;/code&gt; que se declararon en la caja externa cuando se compil&amp;oacute;. Si no se proporciona &lt;code&gt;crateid&lt;/code&gt; , se asume un atributo de &lt;code&gt;name&lt;/code&gt; predeterminado , igual al &lt;a href=&quot;../identifiers&quot;&gt;identificador&lt;/a&gt; dado en la declaraci&amp;oacute;n de &lt;code&gt;extern crate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d4ff9b9a673e6ef5c73fd0d74de95c1584abb9d" translate="yes" xml:space="preserve">
          <source>The failure message indicates that this test did indeed panic as we expected, but the panic message did not include the expected string &lt;code&gt;'Guess value must be less than or equal to 100'&lt;/code&gt;. The panic message that we did get in this case was &lt;code&gt;Guess value must be greater than or equal to 1, got 200.&lt;/code&gt; Now we can start figuring out where our bug is!</source>
          <target state="translated">El mensaje de error indica que esta prueba realmente entr&amp;oacute; en p&amp;aacute;nico como esper&amp;aacute;bamos, pero el mensaje de p&amp;aacute;nico no inclu&amp;iacute;a la cadena esperada &lt;code&gt;'Guess value must be less than or equal to 100'&lt;/code&gt; suposici&amp;oacute;n debe ser menor o igual a 100' . El mensaje de p&amp;aacute;nico que recibimos en este caso fue &lt;code&gt;Guess value must be greater than or equal to 1, got 200.&lt;/code&gt; Ahora podemos comenzar a averiguar d&amp;oacute;nde est&amp;aacute; nuestro error!</target>
        </trans-unit>
        <trans-unit id="1264d4255ef5d1877747639a91dce97d95706422" translate="yes" xml:space="preserve">
          <source>The family of the operating system. Example value is &lt;code&gt;unix&lt;/code&gt;.</source>
          <target state="translated">La familia del sistema operativo. El valor de ejemplo es &lt;code&gt;unix&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f19a750b2fcc57343d113fae5c2d35cbbeabd61" translate="yes" xml:space="preserve">
          <source>The field names can be decimal integer values to specify indices for constructing tuple structs. This can be used with base structs to fill out the remaining indices not specified:</source>
          <target state="translated">Los nombres de los campos pueden ser valores enteros decimales para especificar índices para construir estructuras tuplicadas.Esto puede utilizarse con estructuras de base para rellenar los índices restantes no especificados:</target>
        </trans-unit>
        <trans-unit id="0bbc5c6747805ec7b206ff1d7bd4fc19a67e98d4" translate="yes" xml:space="preserve">
          <source>The fields of a &lt;a href=&quot;types/struct&quot;&gt;struct&lt;/a&gt; are dropped in declaration order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1e05fef4f32d53e63c8251d9d852a226e0b9d94" translate="yes" xml:space="preserve">
          <source>The fields of a &lt;a href=&quot;types/struct&quot;&gt;struct&lt;/a&gt;, &lt;a href=&quot;types/tuple&quot;&gt;tuple&lt;/a&gt; or &lt;a href=&quot;types/enum&quot;&gt;enum variant&lt;/a&gt; are dropped in declaration order. *</source>
          <target state="translated">Los campos de una &lt;a href=&quot;types/struct&quot;&gt;estructura&lt;/a&gt; , &lt;a href=&quot;types/tuple&quot;&gt;tupla&lt;/a&gt; o &lt;a href=&quot;types/enum&quot;&gt;variante enum&lt;/a&gt; se eliminan en el orden de declaraci&amp;oacute;n. *</target>
        </trans-unit>
        <trans-unit id="ad3f74fe8b6e787f7b7254796fcea650c623bbf0" translate="yes" xml:space="preserve">
          <source>The fields of a &lt;a href=&quot;types/tuple&quot;&gt;tuple&lt;/a&gt; are dropped in order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="985befbf65bb726fbdc7e8fa5788956f4d2e4bf1" translate="yes" xml:space="preserve">
          <source>The fields of a &lt;code&gt;struct&lt;/code&gt; may be qualified by &lt;a href=&quot;../visibility-and-privacy&quot;&gt;visibility modifiers&lt;/a&gt;, to allow access to data in a struct outside a module.</source>
          <target state="translated">Los campos de una &lt;code&gt;struct&lt;/code&gt; se pueden calificar mediante &lt;a href=&quot;../visibility-and-privacy&quot;&gt;modificadores de visibilidad&lt;/a&gt; , para permitir el acceso a los datos en una estructura fuera de un m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="d44253ff03665f86e16760d6d12a49f11125c4e2" translate="yes" xml:space="preserve">
          <source>The fields of the active &lt;a href=&quot;types/enum&quot;&gt;enum variant&lt;/a&gt; are dropped in declaration order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ccc036f7a6ce305846dd9b315fdf1f96b15a3b" translate="yes" xml:space="preserve">
          <source>The fields of this struct show that the Rust code we&amp;rsquo;ve parsed is a unit struct with the &lt;code&gt;ident&lt;/code&gt; (identifier, meaning the name) of &lt;code&gt;Pancakes&lt;/code&gt;. There are more fields on this struct for describing all sorts of Rust code; check the &lt;a href=&quot;https://docs.rs/syn/0.14.4/syn/struct.DeriveInput.html&quot;&gt;&lt;code&gt;syn&lt;/code&gt; documentation for &lt;code&gt;DeriveInput&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">Los campos de esta estructura muestran que el c&amp;oacute;digo de Rust que hemos analizado es una estructura de unidad con el &lt;code&gt;ident&lt;/code&gt; (identificador, es decir, el nombre) de &lt;code&gt;Pancakes&lt;/code&gt; . Hay m&amp;aacute;s campos en esta estructura para describir todo tipo de c&amp;oacute;digo Rust; comprobar el &lt;a href=&quot;https://docs.rs/syn/0.14.4/syn/struct.DeriveInput.html&quot;&gt; &lt;code&gt;syn&lt;/code&gt; documentaci&amp;oacute;n para &lt;code&gt;DeriveInput&lt;/code&gt; &lt;/a&gt; para m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b0794c80e766c7ef30098e79990a99a126d86062" translate="yes" xml:space="preserve">
          <source>The fields of this struct show that the Rust code we&amp;rsquo;ve parsed is a unit struct with the &lt;code&gt;ident&lt;/code&gt; (identifier, meaning the name) of &lt;code&gt;Pancakes&lt;/code&gt;. There are more fields on this struct for describing all sorts of Rust code; check the &lt;a href=&quot;https://docs.rs/syn/1.0/syn/struct.DeriveInput.html&quot;&gt;&lt;code&gt;syn&lt;/code&gt; documentation for &lt;code&gt;DeriveInput&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41f21e4814cce1d92447f83c7dd9a65499d60626" translate="yes" xml:space="preserve">
          <source>The file doesn't exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c618b2bfdd921c07e86f2a30b8c3ccd4f98ae789" translate="yes" xml:space="preserve">
          <source>The file is located relative to the current file (similarly to how modules are found).</source>
          <target state="translated">El archivo se ubica en relación con el archivo actual (de manera similar a como se encuentran los módulos).</target>
        </trans-unit>
        <trans-unit id="0630128fbb4da19cb239333b356fc43bbab7e18f" translate="yes" xml:space="preserve">
          <source>The file is located relative to the current file (similarly to how modules are found). The provided path is interpreted in a platform-specific way at compile time. So, for instance, an invocation with a Windows path containing backslashes &lt;code&gt;\&lt;/code&gt; would not compile correctly on Unix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1df7519bc8cdda06f6336bd152ecc0e5b1b6c7c" translate="yes" xml:space="preserve">
          <source>The file is located relative to the current file. (similarly to how modules are found)</source>
          <target state="translated">El archivo está ubicado en relación con el archivo actual.(de manera similar a como se encuentran los módulos)</target>
        </trans-unit>
        <trans-unit id="d6c5af6a5c60f4fa56d05a0fa81955ff57e694aa" translate="yes" xml:space="preserve">
          <source>The file must be opened with write access for truncate to work.</source>
          <target state="translated">El archivo debe abrirse con acceso de escritura para que el truncamiento funcione.</target>
        </trans-unit>
        <trans-unit id="b64dc47988604588017060c77446efa88568cbbc" translate="yes" xml:space="preserve">
          <source>The file must be opened with write or append access in order to create a new file.</source>
          <target state="translated">El archivo debe abrirse con acceso de escritura o adición para crear un nuevo archivo.</target>
        </trans-unit>
        <trans-unit id="55a4d79c2d543091872b4da347b5d4b201da5902" translate="yes" xml:space="preserve">
          <source>The file's cursor isn't changed. In particular, if the cursor was at the end and the file is shrunk using this operation, the cursor will now be past the end.</source>
          <target state="translated">El cursor del archivo no ha cambiado.En particular,si el cursor estaba al final y el archivo se encoge usando esta operación,el cursor ahora estará más allá del final.</target>
        </trans-unit>
        <trans-unit id="6c8ba754d920c70b815c96a59ae89e2ab19e9615" translate="yes" xml:space="preserve">
          <source>The fill character is provided normally in conjunction with the &lt;a href=&quot;#width&quot;&gt;&lt;code&gt;width&lt;/code&gt;&lt;/a&gt; parameter. This indicates that if the value being formatted is smaller than &lt;code&gt;width&lt;/code&gt; some extra characters will be printed around it. The extra characters are specified by &lt;code&gt;fill&lt;/code&gt;, and the alignment can be one of the following options:</source>
          <target state="translated">El car&amp;aacute;cter de relleno se proporciona normalmente junto con el par&amp;aacute;metro de &lt;a href=&quot;#width&quot;&gt; &lt;code&gt;width&lt;/code&gt; &lt;/a&gt; . Esto indica que si el valor que se est&amp;aacute; formateando es menor que el &lt;code&gt;width&lt;/code&gt; , se imprimir&amp;aacute;n algunos caracteres adicionales a su alrededor. Los caracteres adicionales se especifican por &lt;code&gt;fill&lt;/code&gt; y la alineaci&amp;oacute;n puede ser una de las siguientes opciones:</target>
        </trans-unit>
        <trans-unit id="93dbdf12316da4d04bf621e9eb356e67a9dd2780" translate="yes" xml:space="preserve">
          <source>The final action that works only with &lt;code&gt;unsafe&lt;/code&gt; is implementing an unsafe trait. A trait is unsafe when at least one of its methods has some invariant that the compiler can&amp;rsquo;t verify. We can declare that a trait is &lt;code&gt;unsafe&lt;/code&gt; by adding the &lt;code&gt;unsafe&lt;/code&gt; keyword before &lt;code&gt;trait&lt;/code&gt; and marking the implementation of the trait as &lt;code&gt;unsafe&lt;/code&gt; too, as shown in Listing 19-11.</source>
          <target state="translated">La acci&amp;oacute;n final que funciona solo con &lt;code&gt;unsafe&lt;/code&gt; es implementar un rasgo inseguro. Un rasgo no es seguro cuando al menos uno de sus m&amp;eacute;todos tiene alguna invariante que el compilador no puede verificar. Podemos declarar que un rasgo &lt;code&gt;unsafe&lt;/code&gt; es seguro agregando la palabra clave &lt;code&gt;unsafe&lt;/code&gt; antes del &lt;code&gt;trait&lt;/code&gt; y marcando la implementaci&amp;oacute;n del rasgo como &lt;code&gt;unsafe&lt;/code&gt; tambi&amp;eacute;n, como se muestra en el Listado 19-11.</target>
        </trans-unit>
        <trans-unit id="49a4f7cf0e0e66e3c555d75f0978be5130fe5dec" translate="yes" xml:space="preserve">
          <source>The final expression of any extending &lt;a href=&quot;expressions/block-expr&quot;&gt;block expression&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d305704a4fbc5372e6355348bdb324639855c0b" translate="yes" xml:space="preserve">
          <source>The final line ending is optional.</source>
          <target state="translated">El final de la línea es opcional.</target>
        </trans-unit>
        <trans-unit id="7bcad5659fa398bc4723e1a1e4ec534359f32934" translate="yes" xml:space="preserve">
          <source>The final line ending is optional. A string that ends with a final line ending will return the same lines as an otherwise identical string without a final line ending.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d405e4ac4031d3643938bc829210c93b1a171c2a" translate="yes" xml:space="preserve">
          <source>The final line ending isn't required:</source>
          <target state="translated">El final de la línea no es necesario:</target>
        </trans-unit>
        <trans-unit id="c5271e27e91796af655967c8ffbfa429a17a75cb" translate="yes" xml:space="preserve">
          <source>The final result could be determined just by looking at the code at compile time, so &lt;a href=&quot;https://en.wikipedia.org/wiki/Constant_folding&quot;&gt;constant folding&lt;/a&gt; might turn the whole block into a simple &lt;code&gt;println!(&quot;7 4 4&quot;)&lt;/code&gt;.</source>
          <target state="translated">El resultado final podr&amp;iacute;a determinarse simplemente mirando el c&amp;oacute;digo en tiempo de compilaci&amp;oacute;n, por lo que el &lt;a href=&quot;https://en.wikipedia.org/wiki/Constant_folding&quot;&gt;plegado constante&lt;/a&gt; podr&amp;iacute;a convertir todo el bloque en un simple &lt;code&gt;println!(&quot;7 4 4&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e59d9d4ed7f661f21e1daf6cf7e1143fd8d7bfa" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;Cons&lt;/code&gt; value holds &lt;code&gt;1&lt;/code&gt; and another &lt;code&gt;List&lt;/code&gt; value. This &lt;code&gt;List&lt;/code&gt; value is another &lt;code&gt;Cons&lt;/code&gt; value that holds &lt;code&gt;2&lt;/code&gt; and another &lt;code&gt;List&lt;/code&gt; value. This &lt;code&gt;List&lt;/code&gt; value is one more &lt;code&gt;Cons&lt;/code&gt; value that holds &lt;code&gt;3&lt;/code&gt; and a &lt;code&gt;List&lt;/code&gt; value, which is finally &lt;code&gt;Nil&lt;/code&gt;, the non-recursive variant that signals the end of the list.</source>
          <target state="translated">El primer valor de &lt;code&gt;Cons&lt;/code&gt; contiene &lt;code&gt;1&lt;/code&gt; y otro valor de &lt;code&gt;List&lt;/code&gt; a . Este valor de &lt;code&gt;List&lt;/code&gt; es otro valor de &lt;code&gt;Cons&lt;/code&gt; que contiene &lt;code&gt;2&lt;/code&gt; y otro valor de &lt;code&gt;List&lt;/code&gt; . Este valor de &lt;code&gt;List&lt;/code&gt; a es un valor de &lt;code&gt;Cons&lt;/code&gt; m&amp;aacute;s que contiene &lt;code&gt;3&lt;/code&gt; y un valor de &lt;code&gt;List&lt;/code&gt; a , que finalmente es &lt;code&gt;Nil&lt;/code&gt; , la variante no recursiva que se&amp;ntilde;ala el final de la lista.</target>
        </trans-unit>
        <trans-unit id="b8427aa75fccc52f421b7262b47d3cb66ca8ba99" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;length&lt;/code&gt; bytes at &lt;code&gt;buf&lt;/code&gt; need to be valid UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2f6ee38297963ecf451ec169c5ecff0bb88450f" translate="yes" xml:space="preserve">
          <source>The first argument &lt;code&gt;format!&lt;/code&gt; receives is a format string. This must be a string literal. The power of the formatting string is in the &lt;code&gt;{}&lt;/code&gt;s contained.</source>
          <target state="translated">&amp;iexcl;El primer &lt;code&gt;format!&lt;/code&gt; argumento ! recibe es una cadena de formato. Debe ser una cadena literal. El poder de la cadena de formato est&amp;aacute; en los &lt;code&gt;{}&lt;/code&gt; s contenidos.</target>
        </trans-unit>
        <trans-unit id="172d64775742c02b6a5a5317561d4368b0242e63" translate="yes" xml:space="preserve">
          <source>The first argument we gave to the &lt;code&gt;assert_eq!&lt;/code&gt; macro, &lt;code&gt;4&lt;/code&gt;, is equal to the result of calling &lt;code&gt;add_two(2)&lt;/code&gt;. The line for this test is &lt;code&gt;test tests::it_adds_two ... ok&lt;/code&gt;, and the &lt;code&gt;ok&lt;/code&gt; text indicates that our test passed!</source>
          <target state="translated">El primer argumento que le dimos a &lt;code&gt;assert_eq!&lt;/code&gt; macro, &lt;code&gt;4&lt;/code&gt; , es igual al resultado de llamar a &lt;code&gt;add_two(2)&lt;/code&gt; . La l&amp;iacute;nea para esta prueba es &lt;code&gt;test tests::it_adds_two ... ok&lt;/code&gt; , y el texto &lt;code&gt;ok&lt;/code&gt; indica que nuestra prueba pas&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="3de15e9c98b000a8208779afdf2f678b58acd245" translate="yes" xml:space="preserve">
          <source>The first arm will match any point that lies on the &lt;code&gt;x&lt;/code&gt; axis by specifying that the &lt;code&gt;y&lt;/code&gt; field matches if its value matches the literal &lt;code&gt;0&lt;/code&gt;. The pattern still creates an &lt;code&gt;x&lt;/code&gt; variable that we can use in the code for this arm.</source>
          <target state="translated">El primer brazo coincidir&amp;aacute; con cualquier punto que se encuentre en el eje &lt;code&gt;x&lt;/code&gt; especificando que el campo &lt;code&gt;y&lt;/code&gt; coincide si su valor coincide con el literal &lt;code&gt;0&lt;/code&gt; . El patr&amp;oacute;n a&amp;uacute;n crea una variable &lt;code&gt;x&lt;/code&gt; que podemos usar en el c&amp;oacute;digo para este brazo.</target>
        </trans-unit>
        <trans-unit id="0d5278ef07d533df9f2058795a528bf65f8762b5" translate="yes" xml:space="preserve">
          <source>The first character is &lt;code&gt;_&lt;/code&gt;.</source>
          <target state="translated">El primer car&amp;aacute;cter es &lt;code&gt;_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6995348ce355253fb2b3997cb5b666e8341177e1" translate="yes" xml:space="preserve">
          <source>The first character is a letter.</source>
          <target state="translated">El primer personaje es una letra.</target>
        </trans-unit>
        <trans-unit id="a8c76b012fc5c6ec5d1d2757128af41ec43b821f" translate="yes" xml:space="preserve">
          <source>The first collection type we&amp;rsquo;ll look at is &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, also known as a &lt;em&gt;vector&lt;/em&gt;. Vectors allow you to store more than one value in a single data structure that puts all the values next to each other in memory. Vectors can only store values of the same type. They are useful when you have a list of items, such as the lines of text in a file or the prices of items in a shopping cart.</source>
          <target state="translated">El primer tipo de colecci&amp;oacute;n que veremos es &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; , tambi&amp;eacute;n conocido como &lt;em&gt;vector&lt;/em&gt; . Los vectores le permiten almacenar m&amp;aacute;s de un valor en una &amp;uacute;nica estructura de datos que coloca todos los valores uno al lado del otro en la memoria. Los vectores solo pueden almacenar valores del mismo tipo. Son &amp;uacute;tiles cuando tiene una lista de art&amp;iacute;culos, como las l&amp;iacute;neas de texto en un archivo o los precios de los art&amp;iacute;culos en un carrito de compras.</target>
        </trans-unit>
        <trans-unit id="428cb6a8ac810de3963e02d4205a82867bb3d81a" translate="yes" xml:space="preserve">
          <source>The first command creates a new directory called &lt;em&gt;hello_cargo&lt;/em&gt;. We&amp;rsquo;ve named our project &lt;em&gt;hello_cargo&lt;/em&gt;, and Cargo creates its files in a directory of the same name.</source>
          <target state="translated">El primer comando crea un nuevo directorio llamado &lt;em&gt;hello_cargo&lt;/em&gt; . Hemos nombrado a nuestro proyecto &lt;em&gt;hello_cargo&lt;/em&gt; y Cargo crea sus archivos en un directorio con el mismo nombre.</target>
        </trans-unit>
        <trans-unit id="63eaa7d21eca5ee74b5e72e48aed31081f441d50" translate="yes" xml:space="preserve">
          <source>The first command, &lt;code&gt;cargo new&lt;/code&gt;, takes the name of the project (&lt;code&gt;guessing_game&lt;/code&gt;) as the first argument. The second command changes to the new project&amp;rsquo;s directory.</source>
          <target state="translated">El primer comando, &lt;code&gt;cargo new&lt;/code&gt; , toma el nombre del proyecto ( juego de &lt;code&gt;guessing_game&lt;/code&gt; ) como primer argumento. El segundo comando cambia al directorio del nuevo proyecto.</target>
        </trans-unit>
        <trans-unit id="0041dd0d29e2c266e11aba3af3bc7df1a46ad21b" translate="yes" xml:space="preserve">
          <source>The first element is traditionally the path of the executable, but it can be set to arbitrary text, and it may not even exist, so this property should not be relied upon for security purposes.</source>
          <target state="translated">El primer elemento es tradicionalmente el camino del ejecutable,pero puede establecerse en un texto arbitrario,y puede incluso no existir,por lo que no se debe confiar en esta propiedad para fines de seguridad.</target>
        </trans-unit>
        <trans-unit id="d1fd88a9bd4f9b97a6544f441d40f72dd7a6a337" translate="yes" xml:space="preserve">
          <source>The first element is traditionally the path of the executable, but it can be set to arbitrary text, and may not even exist. This means this property should not be relied upon for security purposes.</source>
          <target state="translated">El primer elemento es tradicionalmente el camino del ejecutable,pero puede establecerse en un texto arbitrario,y puede incluso no existir.Esto significa que no se debe confiar en esta propiedad por motivos de seguridad.</target>
        </trans-unit>
        <trans-unit id="57c13dc1f835e54c634e0d373f7f324807f9c426" translate="yes" xml:space="preserve">
          <source>The first element was moved out of the array, but this is not possible because &lt;code&gt;NonCopy&lt;/code&gt; does not implement the &lt;code&gt;Copy&lt;/code&gt; trait.</source>
          <target state="translated">El primer elemento se movi&amp;oacute; fuera de la matriz, pero esto no es posible porque &lt;code&gt;NonCopy&lt;/code&gt; no implementa el rasgo &lt;code&gt;Copy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e08bb0a99fdc3cd6e428394eb70ec134e104b16" translate="yes" xml:space="preserve">
          <source>The first enum shown is the usual kind of enum you'd find in a C-style language. The second shows off a hypothetical example of something storing location data, with &lt;code&gt;Coord&lt;/code&gt; being any other type that's needed, for example a struct. The third example demonstrates the kind of data a variant can store, ranging from nothing, to a tuple, to an anonymous struct.</source>
          <target state="translated">La primera enumeraci&amp;oacute;n que se muestra es el tipo habitual de enumeraci&amp;oacute;n que encontrar&amp;iacute;a en un lenguaje de estilo C. El segundo muestra un ejemplo hipot&amp;eacute;tico de algo que almacena datos de ubicaci&amp;oacute;n, siendo &lt;code&gt;Coord&lt;/code&gt; cualquier otro tipo que se necesite, por ejemplo, una estructura. El tercer ejemplo demuestra el tipo de datos que puede almacenar una variante, que van desde nada, a una tupla, a una estructura an&amp;oacute;nima.</target>
        </trans-unit>
        <trans-unit id="356931433c23df443c1df1a79c8ba26a23e35bf5" translate="yes" xml:space="preserve">
          <source>The first error is in our &lt;code&gt;Drop&lt;/code&gt; implementation. We mentioned earlier that we intended to call &lt;code&gt;take&lt;/code&gt; on the &lt;code&gt;Option&lt;/code&gt; value to move &lt;code&gt;thread&lt;/code&gt; out of &lt;code&gt;worker&lt;/code&gt;. The following changes will do so:</source>
          <target state="translated">El primer error est&amp;aacute; en nuestra implementaci&amp;oacute;n de &lt;code&gt;Drop&lt;/code&gt; . Mencionamos anteriormente que ten&amp;iacute;amos la intenci&amp;oacute;n de llamar a &lt;code&gt;take&lt;/code&gt; el valor de &lt;code&gt;Option&lt;/code&gt; para mover el &lt;code&gt;thread&lt;/code&gt; fuera del &lt;code&gt;worker&lt;/code&gt; . Los siguientes cambios lo har&amp;aacute;n:</target>
        </trans-unit>
        <trans-unit id="65b1330f4d7e9b563ff90a9ab4bea0daa6bb9857" translate="yes" xml:space="preserve">
          <source>The first invariant says that whatever actual token that comes after a matcher, if any, must be somewhere in the predetermined follow set. This ensures that a legal macro definition will continue to assign the same determination as to where &lt;code&gt;... tt&lt;/code&gt; ends and &lt;code&gt;uu ...&lt;/code&gt; begins, even as new syntactic forms are added to the language.</source>
          <target state="translated">El primer invariante dice que cualquier token real que venga despu&amp;eacute;s de un emparejador, si lo hay, debe estar en alg&amp;uacute;n lugar del conjunto de seguimiento predeterminado. Esto asegura que una macrodefinici&amp;oacute;n legal continuar&amp;aacute; asignando la misma determinaci&amp;oacute;n en cuanto a d&amp;oacute;nde &lt;code&gt;... tt&lt;/code&gt; termina y &lt;code&gt;uu ...&lt;/code&gt; comienza, incluso cuando se agregan nuevas formas sint&amp;aacute;cticas al lenguaje.</target>
        </trans-unit>
        <trans-unit id="5f19def176a50d6a90af45519ada69ee7f97eb7e" translate="yes" xml:space="preserve">
          <source>The first is that it is how much memory must be allocated to store that value.</source>
          <target state="translated">La primera es que es la cantidad de memoria que debe asignarse para almacenar ese valor.</target>
        </trans-unit>
        <trans-unit id="beaa6fcb1bf59defe3de830f4f2763f9980dd889" translate="yes" xml:space="preserve">
          <source>The first is to answer a specific question. If you know which chapter answers that question, you can jump to that chapter in the table of contents. Otherwise, you can press &lt;code&gt;s&lt;/code&gt; or the click the magnifying glass on the top bar to search for keywords related to your question. For example, say you wanted to know when a temporary value created in a let statement is dropped. If you didn't already know that the &lt;a href=&quot;expressions#temporaries&quot;&gt;lifetime of temporaries&lt;/a&gt; is defined in the &lt;a href=&quot;expressions&quot;&gt;expressions chapter&lt;/a&gt;, you could search &quot;temporary let&quot; and the first search result will take you to that section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fc0f539a4da8814ced28ee34b9432e35dbaf3f6" translate="yes" xml:space="preserve">
          <source>The first is to answer a specific question. If you know which chapter answers that question, you can jump to that chapter in the table of contents. Otherwise, you can press &lt;code&gt;s&lt;/code&gt; or the click the magnifying glass on the top bar to search for keywords related to your question. For example, say you wanted to know when a temporary value created in a let statement is dropped. If you didn't already know that the &lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;lifetime of temporaries&lt;/a&gt; is defined in the &lt;a href=&quot;expressions&quot;&gt;expressions chapter&lt;/a&gt;, you could search &quot;temporary let&quot; and the first search result will take you to that section.</source>
          <target state="translated">El primero es responder a una pregunta espec&amp;iacute;fica. Si sabe qu&amp;eacute; cap&amp;iacute;tulo responde a esa pregunta, puede saltar a ese cap&amp;iacute;tulo en la tabla de contenido. De lo contrario, puede presionar &lt;code&gt;s&lt;/code&gt; o hacer clic en la lupa en la barra superior para buscar palabras clave relacionadas con su pregunta. Por ejemplo, supongamos que desea saber cu&amp;aacute;ndo se elimina un valor temporal creado en una instrucci&amp;oacute;n let. Si a&amp;uacute;n no sab&amp;iacute;a que la &lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;vida &amp;uacute;til de los temporales&lt;/a&gt; se define en el &lt;a href=&quot;expressions&quot;&gt;cap&amp;iacute;tulo de expresiones&lt;/a&gt; , puede buscar &quot;permiso temporal&quot; y el primer resultado de la b&amp;uacute;squeda lo llevar&amp;aacute; a esa secci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9d5da3096efb5359ed9929a25c1646ef8f4d3a16" translate="yes" xml:space="preserve">
          <source>The first line is a &lt;em&gt;status line&lt;/em&gt; that contains the HTTP version used in the response, a numeric status code that summarizes the result of the request, and a reason phrase that provides a text description of the status code. After the CRLF sequence are any headers, another CRLF sequence, and the body of the response.</source>
          <target state="translated">La primera l&amp;iacute;nea es una &lt;em&gt;l&amp;iacute;nea de estado&lt;/em&gt; que contiene la versi&amp;oacute;n HTTP utilizada en la respuesta, un c&amp;oacute;digo de estado num&amp;eacute;rico que resume el resultado de la solicitud y una frase de motivo que proporciona una descripci&amp;oacute;n de texto del c&amp;oacute;digo de estado. Despu&amp;eacute;s de la secuencia CRLF est&amp;aacute;n los encabezados, otra secuencia CRLF y el cuerpo de la respuesta.</target>
        </trans-unit>
        <trans-unit id="f9ee7ff7ce4ca8fcacdd1bbbd80ae645db3e5b9c" translate="yes" xml:space="preserve">
          <source>The first line is the &lt;em&gt;request line&lt;/em&gt; that holds information about what the client is requesting. The first part of the request line indicates the &lt;em&gt;method&lt;/em&gt; being used, such as &lt;code&gt;GET&lt;/code&gt; or &lt;code&gt;POST&lt;/code&gt;, which describes how the client is making this request. Our client used a &lt;code&gt;GET&lt;/code&gt; request.</source>
          <target state="translated">La primera l&amp;iacute;nea es la &lt;em&gt;l&amp;iacute;nea de solicitud&lt;/em&gt; que contiene informaci&amp;oacute;n sobre lo que solicita el cliente. La primera parte de la l&amp;iacute;nea de solicitud indica el &lt;em&gt;m&amp;eacute;todo que se&lt;/em&gt; est&amp;aacute; utilizando, como &lt;code&gt;GET&lt;/code&gt; o &lt;code&gt;POST&lt;/code&gt; , que describe c&amp;oacute;mo el cliente realiza esta solicitud. Nuestro cliente utiliz&amp;oacute; una solicitud &lt;code&gt;GET&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81a313a5dc649f34279e079a51051be71d71d911" translate="yes" xml:space="preserve">
          <source>The first line shows a function definition, and the second line shows a fully annotated closure definition. The third line removes the type annotations from the closure definition, and the fourth line removes the brackets, which are optional because the closure body has only one expression. These are all valid definitions that will produce the same behavior when they&amp;rsquo;re called.</source>
          <target state="translated">La primera l&amp;iacute;nea muestra una definici&amp;oacute;n de funci&amp;oacute;n y la segunda l&amp;iacute;nea muestra una definici&amp;oacute;n de cierre completamente anotada. La tercera l&amp;iacute;nea elimina las anotaciones de tipo de la definici&amp;oacute;n de cierre y la cuarta l&amp;iacute;nea elimina los corchetes, que son opcionales porque el cuerpo del cierre solo tiene una expresi&amp;oacute;n. Todas estas son definiciones v&amp;aacute;lidas que producir&amp;aacute;n el mismo comportamiento cuando se las llame.</target>
        </trans-unit>
        <trans-unit id="ee8e9ca51bced15f598c9116a158790ff9d282d7" translate="yes" xml:space="preserve">
          <source>The first line shows a function definition, and the second line shows a fully annotated closure definition. The third line removes the type annotations from the closure definition, and the fourth line removes the brackets, which are optional because the closure body has only one expression. These are all valid definitions that will produce the same behavior when they&amp;rsquo;re called. Calling the closures is required for &lt;code&gt;add_one_v3&lt;/code&gt; and &lt;code&gt;add_one_v4&lt;/code&gt; to be able to compile because the types will be inferred from their usage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98148895ad25eccad7c245ba3595f3571d1d992c" translate="yes" xml:space="preserve">
          <source>The first line, &lt;code&gt;[package]&lt;/code&gt;, is a section heading that indicates that the following statements are configuring a package. As we add more information to this file, we&amp;rsquo;ll add other sections.</source>
          <target state="translated">La primera l&amp;iacute;nea, &lt;code&gt;[package]&lt;/code&gt; , es un encabezado de secci&amp;oacute;n que indica que las siguientes declaraciones est&amp;aacute;n configurando un paquete. A medida que agreguemos m&amp;aacute;s informaci&amp;oacute;n a este archivo, agregaremos otras secciones.</target>
        </trans-unit>
        <trans-unit id="b65c034b9a1653c1664e07497c1d14736ba472ab" translate="yes" xml:space="preserve">
          <source>The first mismatching element defines which sequence is lexicographically less or greater than the other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b310676b3019d119c9c467f577a365e7a655455" translate="yes" xml:space="preserve">
          <source>The first new bit here is another &lt;code&gt;use&lt;/code&gt; statement, bringing a type called &lt;code&gt;std::cmp::Ordering&lt;/code&gt; into scope from the standard library. Like &lt;code&gt;Result&lt;/code&gt;, &lt;code&gt;Ordering&lt;/code&gt; is another enum, but the variants for &lt;code&gt;Ordering&lt;/code&gt; are &lt;code&gt;Less&lt;/code&gt;, &lt;code&gt;Greater&lt;/code&gt;, and &lt;code&gt;Equal&lt;/code&gt;. These are the three outcomes that are possible when you compare two values.</source>
          <target state="translated">El primer bit nuevo aqu&amp;iacute; es otra declaraci&amp;oacute;n de &lt;code&gt;use&lt;/code&gt; , que trae un tipo llamado &lt;code&gt;std::cmp::Ordering&lt;/code&gt; al alcance de la biblioteca est&amp;aacute;ndar. Al igual que &lt;code&gt;Result&lt;/code&gt; , &lt;code&gt;Ordering&lt;/code&gt; es otra enumeraci&amp;oacute;n, pero las variantes de &lt;code&gt;Ordering&lt;/code&gt; son &lt;code&gt;Less&lt;/code&gt; , &lt;code&gt;Greater&lt;/code&gt; e &lt;code&gt;Equal&lt;/code&gt; . Estos son los tres resultados que son posibles cuando compara dos valores.</target>
        </trans-unit>
        <trans-unit id="cc86c6e2624cc3af0cff65094ba89e9de1e68ebb" translate="yes" xml:space="preserve">
          <source>The first new line defines the &lt;code&gt;response&lt;/code&gt; variable that holds the success message&amp;rsquo;s data. Then we call &lt;code&gt;as_bytes&lt;/code&gt; on our &lt;code&gt;response&lt;/code&gt; to convert the string data to bytes. The &lt;code&gt;write&lt;/code&gt; method on &lt;code&gt;stream&lt;/code&gt; takes a &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; and sends those bytes directly down the connection.</source>
          <target state="translated">La primera l&amp;iacute;nea nueva define la variable de &lt;code&gt;response&lt;/code&gt; que contiene los datos del mensaje de &amp;eacute;xito. Luego llamamos a &lt;code&gt;as_bytes&lt;/code&gt; en nuestra &lt;code&gt;response&lt;/code&gt; para convertir los datos de la cadena en bytes. El m&amp;eacute;todo de &lt;code&gt;write&lt;/code&gt; en la &lt;code&gt;stream&lt;/code&gt; toma un &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; y env&amp;iacute;a esos bytes directamente por la conexi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="155e4331405457b07f19de5018b6f05e551344c8" translate="yes" xml:space="preserve">
          <source>The first one looks much cleaner. This automatic referencing behavior works because methods have a clear receiver&amp;mdash;the type of &lt;code&gt;self&lt;/code&gt;. Given the receiver and name of a method, Rust can figure out definitively whether the method is reading (&lt;code&gt;&amp;amp;self&lt;/code&gt;), mutating (&lt;code&gt;&amp;amp;mut self&lt;/code&gt;), or consuming (&lt;code&gt;self&lt;/code&gt;). The fact that Rust makes borrowing implicit for method receivers is a big part of making ownership ergonomic in practice.</source>
          <target state="translated">El primero parece mucho m&amp;aacute;s limpio. Este comportamiento de referencia autom&amp;aacute;tica funciona porque los m&amp;eacute;todos tienen un receptor claro: el tipo de &lt;code&gt;self&lt;/code&gt; . Dado el receptor y el nombre de un m&amp;eacute;todo, Rust puede determinar definitivamente si el m&amp;eacute;todo est&amp;aacute; leyendo ( &lt;code&gt;&amp;amp;self&lt;/code&gt; ), mutando ( &lt;code&gt;&amp;amp;mut self&lt;/code&gt; ) o consumiendo ( &lt;code&gt;self&lt;/code&gt; ). El hecho de que Rust haga impl&amp;iacute;cito el uso de pr&amp;eacute;stamos para los receptores de m&amp;eacute;todos es una parte importante para que la propiedad sea ergon&amp;oacute;mica en la pr&amp;aacute;ctica.</target>
        </trans-unit>
        <trans-unit id="69774098a6b4b7c12621ff37f51e96103a8b7208" translate="yes" xml:space="preserve">
          <source>The first part of the guessing game program will ask for user input, process that input, and check that the input is in the expected form. To start, we&amp;rsquo;ll allow the player to input a guess. Enter the code in Listing 2-1 into &lt;em&gt;src/main.rs&lt;/em&gt;.</source>
          <target state="translated">La primera parte del programa del juego de adivinanzas solicitar&amp;aacute; la entrada del usuario, procesar&amp;aacute; esa entrada y verificar&amp;aacute; que la entrada est&amp;eacute; en la forma esperada. Para comenzar, permitiremos que el jugador ingrese una suposici&amp;oacute;n. Introducir el c&amp;oacute;digo en el Listado 2-1 en &lt;em&gt;src / main.rs&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2750d61c6d5f6fdb7cf8539aba812571a959c619" translate="yes" xml:space="preserve">
          <source>The first parts of the module system we&amp;rsquo;ll cover are packages and crates. A crate is a binary or library. The &lt;em&gt;crate root&lt;/em&gt; is a source file that the Rust compiler starts from and makes up the root module of your crate (we&amp;rsquo;ll explain modules in depth in the &lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;&amp;ldquo;Defining Modules to Control Scope and Privacy&amp;rdquo;&lt;/a&gt; section). A &lt;em&gt;package&lt;/em&gt; is one or more crates that provide a set of functionality. A package contains a &lt;em&gt;Cargo.toml&lt;/em&gt; file that describes how to build those crates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84c014079631c14ba610d8bbfcba357c51089179" translate="yes" xml:space="preserve">
          <source>The first parts of the module system we&amp;rsquo;ll cover are packages and crates. A crate is a binary or library. The &lt;em&gt;crate root&lt;/em&gt; is a source file that the Rust compiler starts from and makes up the root module of your crate (we&amp;rsquo;ll explain modules in depth in the &lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;&amp;ldquo;Defining Modules to Control Scope and Privacy&amp;rdquo;&lt;/a&gt;) section. A &lt;em&gt;package&lt;/em&gt; is one or more crates that provide a set of functionality. A package contains a &lt;em&gt;Cargo.toml&lt;/em&gt; file that describes how to build those crates.</source>
          <target state="translated">Las primeras partes del sistema de m&amp;oacute;dulos que cubriremos son paquetes y cajas. Una caja es un binario o una biblioteca. La &lt;em&gt;ra&amp;iacute;z de la caja&lt;/em&gt; es un archivo de origen desde el que parte el compilador de Rust y constituye el m&amp;oacute;dulo ra&amp;iacute;z de su caja (explicaremos los m&amp;oacute;dulos en profundidad en la secci&amp;oacute;n &lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;&quot;Definici&amp;oacute;n de m&amp;oacute;dulos para controlar el alcance y la privacidad&quot;&lt;/a&gt; ). Un &lt;em&gt;paquete&lt;/em&gt; es una o m&amp;aacute;s cajas que proporcionan un conjunto de funciones. Un paquete contiene un archivo &lt;em&gt;Cargo.toml&lt;/em&gt; que describe c&amp;oacute;mo construir esas cajas.</target>
        </trans-unit>
        <trans-unit id="af7ae34fc30a5ff985eeb202b31d100b9995dad4" translate="yes" xml:space="preserve">
          <source>The first problem is that a &lt;code&gt;Cacher&lt;/code&gt; instance assumes it will always get the same value for the parameter &lt;code&gt;arg&lt;/code&gt; to the &lt;code&gt;value&lt;/code&gt; method. That is, this test of &lt;code&gt;Cacher&lt;/code&gt; will fail:</source>
          <target state="translated">El primer problema es que una instancia de &lt;code&gt;Cacher&lt;/code&gt; asume que siempre obtendr&amp;aacute; el mismo valor para el par&amp;aacute;metro &lt;code&gt;arg&lt;/code&gt; que el m&amp;eacute;todo &lt;code&gt;value&lt;/code&gt; . Es decir, esta prueba de &lt;code&gt;Cacher&lt;/code&gt; fallar&amp;aacute;:</target>
        </trans-unit>
        <trans-unit id="dafa36fcdade4f5ce81d7dee337248690a10ae6d" translate="yes" xml:space="preserve">
          <source>The first purpose is similar to the second but in reverse: if you want to add a type parameter to an existing trait, you can give it a default to allow extension of the functionality of the trait without breaking the existing implementation code.</source>
          <target state="translated">El primer propósito es similar al segundo pero a la inversa:si se quiere añadir un parámetro de tipo a un rasgo existente,se le puede dar un valor por defecto para permitir la extensión de la funcionalidad del rasgo sin romper el código de implementación existente.</target>
        </trans-unit>
        <trans-unit id="5f5a900754c112ed82386f584763afdd02db421d" translate="yes" xml:space="preserve">
          <source>The first rule is that each parameter that is a reference gets its own lifetime parameter. In other words, a function with one parameter gets one lifetime parameter: &lt;code&gt;fn foo&amp;lt;'a&amp;gt;(x: &amp;amp;'a i32)&lt;/code&gt;; a function with two parameters gets two separate lifetime parameters: &lt;code&gt;fn foo&amp;lt;'a, 'b&amp;gt;(x: &amp;amp;'a i32, y: &amp;amp;'b i32)&lt;/code&gt;; and so on.</source>
          <target state="translated">La primera regla es que cada par&amp;aacute;metro que es una referencia obtiene su propio par&amp;aacute;metro de duraci&amp;oacute;n. En otras palabras, una funci&amp;oacute;n con un par&amp;aacute;metro obtiene un par&amp;aacute;metro de por vida: &lt;code&gt;fn foo&amp;lt;'a&amp;gt;(x: &amp;amp;'a i32)&lt;/code&gt; ; una funci&amp;oacute;n con dos par&amp;aacute;metros obtiene dos par&amp;aacute;metros de duraci&amp;oacute;n separados: &lt;code&gt;fn foo&amp;lt;'a, 'b&amp;gt;(x: &amp;amp;'a i32, y: &amp;amp;'b i32)&lt;/code&gt; ; y as&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="d13f338beec8e6c884aee47f7c30a9f0bc21c5c9" translate="yes" xml:space="preserve">
          <source>The first section of the output shows that the &lt;code&gt;it_works&lt;/code&gt; test in the &lt;code&gt;add-one&lt;/code&gt; crate passed. The next section shows that zero tests were found in the &lt;code&gt;adder&lt;/code&gt; crate, and then the last section shows zero documentation tests were found in the &lt;code&gt;add-one&lt;/code&gt; crate. Running &lt;code&gt;cargo test&lt;/code&gt; in a workspace structured like this one will run the tests for all the crates in the workspace.</source>
          <target state="translated">La primera secci&amp;oacute;n de la salida muestra que &lt;code&gt;it_works&lt;/code&gt; prueba it_works en la caja &lt;code&gt;add-one&lt;/code&gt; . La siguiente secci&amp;oacute;n muestra que no se encontraron pruebas en la caja del &lt;code&gt;adder&lt;/code&gt; , y luego la &amp;uacute;ltima secci&amp;oacute;n muestra que no se encontraron pruebas de documentaci&amp;oacute;n en la caja &lt;code&gt;add-one&lt;/code&gt; . Ejecutar la &lt;code&gt;cargo test&lt;/code&gt; en un espacio de trabajo estructurado como este ejecutar&amp;aacute; las pruebas para todas las cajas en el espacio de trabajo.</target>
        </trans-unit>
        <trans-unit id="1aa6d921fdf65cd84a902ac9021b32a10817790a" translate="yes" xml:space="preserve">
          <source>The first step is to build a list of candidate receiver types. Obtain these by repeatedly &lt;a href=&quot;operator-expr#the-dereference-operator&quot;&gt;dereferencing&lt;/a&gt; the receiver expression's type, adding each type encountered to the list, then finally attempting an &lt;a href=&quot;../type-coercions#unsized-coercions&quot;&gt;unsized coercion&lt;/a&gt; at the end, and adding the result type if that is successful. Then, for each candidate &lt;code&gt;T&lt;/code&gt;, add &lt;code&gt;&amp;amp;T&lt;/code&gt; and &lt;code&gt;&amp;amp;mut T&lt;/code&gt; to the list immediately after &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">El primer paso es crear una lista de tipos de receptores candidatos. Cons&amp;iacute;galos &lt;a href=&quot;operator-expr#the-dereference-operator&quot;&gt;desreferenciando&lt;/a&gt; repetidamente el tipo de expresi&amp;oacute;n del receptor, agregando cada tipo encontrado a la lista, luego intente finalmente una &lt;a href=&quot;../type-coercions#unsized-coercions&quot;&gt;coerci&amp;oacute;n sin tama&amp;ntilde;o&lt;/a&gt; al final y agregando el tipo de resultado si tiene &amp;eacute;xito. A continuaci&amp;oacute;n, para cada candidato &lt;code&gt;T&lt;/code&gt; , a&amp;ntilde;adir &lt;code&gt;&amp;amp;T&lt;/code&gt; y &lt;code&gt;&amp;amp;mut T&lt;/code&gt; a la lista inmediatamente despu&amp;eacute;s de &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7046b8e80cd49555b791ba84b08e3a496f0ebd34" translate="yes" xml:space="preserve">
          <source>The first step is to install Rust. We&amp;rsquo;ll download Rust through &lt;code&gt;rustup&lt;/code&gt;, a command line tool for managing Rust versions and associated tools. You&amp;rsquo;ll need an internet connection for the download.</source>
          <target state="translated">El primer paso es instalar Rust. Descargaremos Rust a trav&amp;eacute;s de &lt;code&gt;rustup&lt;/code&gt; , una herramienta de l&amp;iacute;nea de comandos para administrar versiones de Rust y herramientas asociadas. Necesitar&amp;aacute; una conexi&amp;oacute;n a Internet para la descarga.</target>
        </trans-unit>
        <trans-unit id="50ad5f65969d8efb886424560b9363334f047aa4" translate="yes" xml:space="preserve">
          <source>The first store to &lt;code&gt;C&lt;/code&gt; might be moved before the store to &lt;code&gt;A&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt;, &lt;em&gt;as if&lt;/em&gt; we had written &lt;code&gt;C = 4; A = 3; B = 4&lt;/code&gt;.</source>
          <target state="translated">La primera tienda a &lt;code&gt;C&lt;/code&gt; podr&amp;iacute;a moverse antes que la tienda a &lt;code&gt;A&lt;/code&gt; o &lt;code&gt;B&lt;/code&gt; , &lt;em&gt;como si&lt;/em&gt; hubi&amp;eacute;ramos escrito &lt;code&gt;C = 4; A = 3; B = 4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a6ba14d6296fbc087c2dbd538a2ed25e14b36c1" translate="yes" xml:space="preserve">
          <source>The first task is to make &lt;code&gt;minigrep&lt;/code&gt; accept its two command line arguments: the filename and a string to search for. That is, we want to be able to run our program with &lt;code&gt;cargo run&lt;/code&gt;, a string to search for, and a path to a file to search in, like so:</source>
          <target state="translated">La primera tarea es hacer que &lt;code&gt;minigrep&lt;/code&gt; acepte sus dos argumentos de l&amp;iacute;nea de comando: el nombre del archivo y una cadena para buscar. Es decir, queremos poder ejecutar nuestro programa con &lt;code&gt;cargo run&lt;/code&gt; , una cadena para buscar y una ruta a un archivo para buscar, as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="31729bd9aa0c04461ab01bb63b4c75c53baddad1" translate="yes" xml:space="preserve">
          <source>The first time we call &lt;code&gt;example_closure&lt;/code&gt; with the &lt;code&gt;String&lt;/code&gt; value, the compiler infers the type of &lt;code&gt;x&lt;/code&gt; and the return type of the closure to be &lt;code&gt;String&lt;/code&gt;. Those types are then locked in to the closure in &lt;code&gt;example_closure&lt;/code&gt;, and we get a type error if we try to use a different type with the same closure.</source>
          <target state="translated">La primera vez que llamamos &lt;code&gt;example_closure&lt;/code&gt; con el valor &lt;code&gt;String&lt;/code&gt; , el compilador infiere que el tipo de &lt;code&gt;x&lt;/code&gt; y el tipo de retorno del cierre es &lt;code&gt;String&lt;/code&gt; . Luego, esos tipos se bloquean en el cierre en &lt;code&gt;example_closure&lt;/code&gt; , y obtenemos un error de tipo si intentamos usar un tipo diferente con el mismo cierre.</target>
        </trans-unit>
        <trans-unit id="bd2776b4ba26113bcf03f01d82d4cc2a793fc112" translate="yes" xml:space="preserve">
          <source>The first time we call the &lt;code&gt;add_to_waitlist&lt;/code&gt; function in &lt;code&gt;eat_at_restaurant&lt;/code&gt;, we use an absolute path. The &lt;code&gt;add_to_waitlist&lt;/code&gt; function is defined in the same crate as &lt;code&gt;eat_at_restaurant&lt;/code&gt;, which means we can use the &lt;code&gt;crate&lt;/code&gt; keyword to start an absolute path.</source>
          <target state="translated">La primera vez que llamamos el &lt;code&gt;add_to_waitlist&lt;/code&gt; funci&amp;oacute;n en &lt;code&gt;eat_at_restaurant&lt;/code&gt; , se utiliza una ruta absoluta. El &lt;code&gt;add_to_waitlist&lt;/code&gt; funci&amp;oacute;n se define de la misma caja como &lt;code&gt;eat_at_restaurant&lt;/code&gt; , lo que significa que podemos usar el &lt;code&gt;crate&lt;/code&gt; palabra clave para iniciar una ruta absoluta.</target>
        </trans-unit>
        <trans-unit id="fcbd8f43979f6a3f91b2e8d0489ac836799ae483" translate="yes" xml:space="preserve">
          <source>The first two cases are the same except for mutability. The first case states that if you have a &lt;code&gt;&amp;amp;T&lt;/code&gt;, and &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Deref&lt;/code&gt; to some type &lt;code&gt;U&lt;/code&gt;, you can get a &lt;code&gt;&amp;amp;U&lt;/code&gt; transparently. The second case states that the same deref coercion happens for mutable references.</source>
          <target state="translated">Los dos primeros casos son iguales excepto por la mutabilidad. El primer caso establece que si tiene una &lt;code&gt;&amp;amp;T&lt;/code&gt; , y &lt;code&gt;T&lt;/code&gt; implementa &lt;code&gt;Deref&lt;/code&gt; en alg&amp;uacute;n tipo &lt;code&gt;U&lt;/code&gt; , puede obtener una &lt;code&gt;&amp;amp;U&lt;/code&gt; transparente. El segundo caso establece que la misma coerci&amp;oacute;n deref ocurre para referencias mutables.</target>
        </trans-unit>
        <trans-unit id="286885295f7366f4af40320e50ad88bb3b1732e7" translate="yes" xml:space="preserve">
          <source>The first version of the prelude of The Rust Standard Library.</source>
          <target state="translated">La primera versión del preludio de la Biblioteca del Estándar del Óxido.</target>
        </trans-unit>
        <trans-unit id="2833ddd57d8c251f327110ae65b75e17455b9bb3" translate="yes" xml:space="preserve">
          <source>The first will contain all indices from &lt;code&gt;[0, mid)&lt;/code&gt; (excluding the index &lt;code&gt;mid&lt;/code&gt; itself) and the second will contain all indices from &lt;code&gt;[mid, len)&lt;/code&gt; (excluding the index &lt;code&gt;len&lt;/code&gt; itself).</source>
          <target state="translated">El primero contendr&amp;aacute; todos los &amp;iacute;ndices de &lt;code&gt;[0, mid)&lt;/code&gt; (excluyendo el &amp;iacute;ndice &lt;code&gt;mid&lt;/code&gt; en s&amp;iacute;) y el segundo contendr&amp;aacute; todos los &amp;iacute;ndices de &lt;code&gt;[mid, len)&lt;/code&gt; (excluyendo el &amp;iacute;ndice &lt;code&gt;len&lt;/code&gt; en s&amp;iacute;).</target>
        </trans-unit>
        <trans-unit id="d13813ed09799c4deb40bb4b4bb042ae0365adde" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; affect compile-time limits.</source>
          <target state="translated">Los siguientes &lt;a href=&quot;../attributes&quot;&gt;atributos&lt;/a&gt; afectan los l&amp;iacute;mites de tiempo de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1c0907607a038e19917ef67594e99ddd26567897" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; are used for changing how a type can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53b431e371001b409fc98d06f983cdb135709c0f" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; are used for controlling code generation.</source>
          <target state="translated">Los siguientes &lt;a href=&quot;../attributes&quot;&gt;atributos&lt;/a&gt; se utilizan para controlar la generaci&amp;oacute;n de c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="26da618b938f5c0f34421c8ac509923a988969a6" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; are used for controlling or generating diagnostic messages during compilation.</source>
          <target state="translated">Los siguientes &lt;a href=&quot;../attributes&quot;&gt;atributos&lt;/a&gt; se utilizan para controlar o generar mensajes de diagn&amp;oacute;stico durante la compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a094c614790975d250927975ec0fe6928fcd7c3a" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; are used for specifying functions for performing tests. Compiling a crate in &quot;test&quot; mode enables building the test functions along with a test harness for executing the tests. Enabling the test mode also enables the &lt;a href=&quot;../conditional-compilation#test&quot;&gt;&lt;code&gt;test&lt;/code&gt; conditional compilation option&lt;/a&gt;.</source>
          <target state="translated">Los siguientes &lt;a href=&quot;../attributes&quot;&gt;atributos&lt;/a&gt; se utilizan para especificar funciones para realizar pruebas. Compilar una caja en modo &quot;prueba&quot; permite construir las funciones de prueba junto con un arn&amp;eacute;s de prueba para ejecutar las pruebas. Habilitar el modo de prueba tambi&amp;eacute;n habilita la &lt;a href=&quot;../conditional-compilation#test&quot;&gt;opci&amp;oacute;n de compilaci&amp;oacute;n condicional de &lt;/a&gt; &lt;code&gt;test&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6bd6f609f21755a5a941e395bd92f148b7a32a4" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; control the behavior of external blocks.</source>
          <target state="translated">Los siguientes &lt;a href=&quot;../attributes&quot;&gt;atributos&lt;/a&gt; controlan el comportamiento de los bloques externos.</target>
        </trans-unit>
        <trans-unit id="e4c3204613b4a8b1aeaa7e0d193d03d0b636c5e8" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;join_slices&lt;/code&gt; function is &lt;strong&gt;unsound&lt;/strong&gt; ⚠️</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34e28a9dda5b8f30dd258681b177c05e512cb9ec" translate="yes" xml:space="preserve">
          <source>The following are examples of struct expressions:</source>
          <target state="translated">Los siguientes son ejemplos de expresiones estructurales:</target>
        </trans-unit>
        <trans-unit id="0cfa813f73eeb4b3df6024040cdcdc9bf704edb3" translate="yes" xml:space="preserve">
          <source>The following code tries to return a closure directly, but it won&amp;rsquo;t compile:</source>
          <target state="translated">El siguiente c&amp;oacute;digo intenta devolver un cierre directamente, pero no se compilar&amp;aacute;:</target>
        </trans-unit>
        <trans-unit id="9fdd790090c328b0bac332ac3bf94fd48a22d310" translate="yes" xml:space="preserve">
          <source>The following coercions are called &lt;code&gt;unsized coercions&lt;/code&gt;, since they relate to converting sized types to unsized types, and are permitted in a few cases where other coercions are not, as described above. They can still happen anywhere else a coercion can occur.</source>
          <target state="translated">Las siguientes coacciones se denominan &lt;code&gt;unsized coercions&lt;/code&gt; , ya que se relacionan con la conversi&amp;oacute;n de tipos con tama&amp;ntilde;o en tipos sin tama&amp;ntilde;o, y est&amp;aacute;n permitidas en unos pocos casos donde otras coacciones no lo son, como se describi&amp;oacute; anteriormente. Todav&amp;iacute;a pueden suceder en cualquier otro lugar donde pueda ocurrir una coerci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="5faa68338d0213add2f9ec4c067dc00f82eb825f" translate="yes" xml:space="preserve">
          <source>The following contexts are &lt;em&gt;place expression&lt;/em&gt; contexts:</source>
          <target state="translated">Los siguientes contextos son contextos de &lt;em&gt;expresi&amp;oacute;n de lugar&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="a03f434198c8f12dc538595d512c2779094f1534" translate="yes" xml:space="preserve">
          <source>The following example contains a circular dependency between two traits:</source>
          <target state="translated">El siguiente ejemplo contiene una dependencia circular entre dos rasgos:</target>
        </trans-unit>
        <trans-unit id="19cc88ac0ce4f5388077204fb21e73c4ffb89f2d" translate="yes" xml:space="preserve">
          <source>The following example implements &lt;code&gt;Index&lt;/code&gt; on a read-only &lt;code&gt;NucleotideCount&lt;/code&gt; container, enabling individual counts to be retrieved with index syntax.</source>
          <target state="translated">El siguiente ejemplo implementa &lt;code&gt;Index&lt;/code&gt; en un contenedor &lt;code&gt;NucleotideCount&lt;/code&gt; de solo lectura , lo que permite recuperar recuentos individuales con sintaxis de &amp;iacute;ndice.</target>
        </trans-unit>
        <trans-unit id="1e6d78aaf2b8415e3caf24e2fa8603dbd9c8a54c" translate="yes" xml:space="preserve">
          <source>The following example showcases the fact that exclusive access to an &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; implies exclusive access to its &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b79316b13dbff6d7faf92f7fbb6c36c3b4504a1c" translate="yes" xml:space="preserve">
          <source>The following example uses &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; to create an optional box of &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt;. Notice that in order to use the inner &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; value first, the &lt;code&gt;check_optional&lt;/code&gt; function needs to use pattern matching to determine whether the box has a value (i.e., it is &lt;a href=&quot;enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(...)&lt;/code&gt;&lt;/a&gt;) or not (&lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">El siguiente ejemplo usa &lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; para crear una caja opcional de &lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; . Tenga en cuenta que con el fin de utilizar el interior &lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; valor primero, los &lt;code&gt;check_optional&lt;/code&gt; necesidades de funci&amp;oacute;n a uso coincidencia de patrones para determinar si la caja tiene un valor (es decir, es &lt;a href=&quot;enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(...)&lt;/code&gt; &lt;/a&gt; ) o no ( &lt;a href=&quot;enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0098b757352995332c14af09f0677dc80f9a0b00" translate="yes" xml:space="preserve">
          <source>The following expressions are constant expressions, so long as any operands are also constant expressions and do not cause any &lt;a href=&quot;destructors&quot;&gt;&lt;code&gt;Drop::drop&lt;/code&gt;&lt;/a&gt; calls to be run.</source>
          <target state="translated">Las siguientes expresiones son expresiones constantes, siempre que los operandos sean tambi&amp;eacute;n expresiones constantes y no hagan que se ejecute ninguna llamada &lt;a href=&quot;destructors&quot;&gt; &lt;code&gt;Drop::drop&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a4fd2c18c35c909a948ecc39653105d7e64c5323" translate="yes" xml:space="preserve">
          <source>The following expressions are equivalent.</source>
          <target state="translated">Las siguientes expresiones son equivalentes.</target>
        </trans-unit>
        <trans-unit id="f79e25578dbebf348320c4abf5b91615c4d5d3bd" translate="yes" xml:space="preserve">
          <source>The following expressions can be mutable place expression contexts:</source>
          <target state="translated">Las siguientes expresiones pueden ser contextos de expresión de lugares mutables:</target>
        </trans-unit>
        <trans-unit id="0e8e60bb585909210311dad5aced6fb1ca9a2411" translate="yes" xml:space="preserve">
          <source>The following illustrates how tokens can be directly matched after matching a &lt;code&gt;tt&lt;/code&gt; fragment:</source>
          <target state="translated">A continuaci&amp;oacute;n se ilustra c&amp;oacute;mo se pueden hacer coincidir los tokens directamente despu&amp;eacute;s de hacer coincidir un fragmento &lt;code&gt;tt&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4cba4cc8b1a51987e47e31e5a3e9298ced934caa" translate="yes" xml:space="preserve">
          <source>The following is a list of the available feature names.</source>
          <target state="translated">A continuación figura una lista de los nombres de las características disponibles.</target>
        </trans-unit>
        <trans-unit id="7bfbc404b57ece9100ac4d9b168ae9cc179de313" translate="yes" xml:space="preserve">
          <source>The following is an example of a derive macro. Instead of doing anything useful with its input, it just appends a function &lt;code&gt;answer&lt;/code&gt;.</source>
          <target state="translated">El siguiente es un ejemplo de una macro derivada. En lugar de hacer algo &amp;uacute;til con su entrada, simplemente agrega una &lt;code&gt;answer&lt;/code&gt; funci&amp;oacute;n .</target>
        </trans-unit>
        <trans-unit id="cb90a0db80f40417302eef01e3aacf14fbc10a30" translate="yes" xml:space="preserve">
          <source>The following is an example of declaring &lt;code&gt;Shape&lt;/code&gt; to be a supertrait of &lt;code&gt;Circle&lt;/code&gt;.</source>
          <target state="translated">A continuaci&amp;oacute;n, se muestra un ejemplo de &lt;code&gt;Shape&lt;/code&gt; declarar que Shape es un superretrato de &lt;code&gt;Circle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0bc86808e703044cc02c714fea381b5d6b4eb104" translate="yes" xml:space="preserve">
          <source>The following is an index of all built-in attributes.</source>
          <target state="translated">A continuación se presenta un índice de todos los atributos incorporados.</target>
        </trans-unit>
        <trans-unit id="7cc1fc6a380ba45eaa1f4f2110280733486f387c" translate="yes" xml:space="preserve">
          <source>The following is an overview of the available synchronization objects:</source>
          <target state="translated">A continuación se presenta un resumen de los objetos de sincronización disponibles:</target>
        </trans-unit>
        <trans-unit id="e77d4cd3fb5ca40ba38b2400787449b1eb8f401a" translate="yes" xml:space="preserve">
          <source>The following keywords are reserved beginning in the 2018 edition.</source>
          <target state="translated">Las siguientes palabras clave están reservadas a partir de la edición de 2018.</target>
        </trans-unit>
        <trans-unit id="88a73d4d23e456f05faa46221aa0e7b9298c7349" translate="yes" xml:space="preserve">
          <source>The following keywords currently have the functionality described.</source>
          <target state="translated">Las siguientes palabras clave tienen actualmente la funcionalidad descrita.</target>
        </trans-unit>
        <trans-unit id="b5d973323cad12bb72185383671304dcd5ab9469" translate="yes" xml:space="preserve">
          <source>The following keywords do not have any functionality but are reserved by Rust for potential future use.</source>
          <target state="translated">Las siguientes palabras clave no tienen ninguna funcionalidad pero están reservadas por Rust para un posible uso futuro.</target>
        </trans-unit>
        <trans-unit id="e441a28a0807978c7d9ce6b3cf8c4bd39296d4e8" translate="yes" xml:space="preserve">
          <source>The following keywords were added beginning in the 2018 edition.</source>
          <target state="translated">Las siguientes palabras clave fueron añadidas a partir de la edición de 2018.</target>
        </trans-unit>
        <trans-unit id="7de22ffd047d06a2d94087f0583e69c5de3c8513" translate="yes" xml:space="preserve">
          <source>The following language level features cannot be used in the safe subset of Rust:</source>
          <target state="translated">Las siguientes características del nivel de lenguaje no se pueden utilizar en el subconjunto seguro de Rust:</target>
        </trans-unit>
        <trans-unit id="fa4bbe49e1fb3a478a935beaddada675b665b643" translate="yes" xml:space="preserve">
          <source>The following list contains all non-letters that don&amp;rsquo;t function as operators; that is, they don&amp;rsquo;t behave like a function or method call.</source>
          <target state="translated">La siguiente lista contiene todas las no letras que no funcionan como operadores; es decir, no se comportan como una funci&amp;oacute;n o llamada a un m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="35b04ccb391eee75aac9df7cb7f1bfc81254ebee" translate="yes" xml:space="preserve">
          <source>The following list contains keywords that are reserved for current or future use by the Rust language. As such, they cannot be used as identifiers (except as raw identifiers as we&amp;rsquo;ll discuss in the &amp;ldquo;&lt;a href=&quot;#raw-identifiers&quot;&gt;Raw Identifiers&lt;/a&gt;&amp;rdquo; section), including names of functions, variables, parameters, struct fields, modules, crates, constants, macros, static values, attributes, types, traits, or lifetimes.</source>
          <target state="translated">La siguiente lista contiene palabras clave que est&amp;aacute;n reservadas para uso actual o futuro por el lenguaje Rust. Como tales, no se pueden utilizar como identificadores (excepto como identificadores sin procesar, como veremos en la secci&amp;oacute;n &quot; &lt;a href=&quot;#raw-identifiers&quot;&gt;Identificadores sin procesar&lt;/a&gt; &quot;), incluidos los nombres de funciones, variables, par&amp;aacute;metros, campos de estructura, m&amp;oacute;dulos, cajas, constantes, macros, valores est&amp;aacute;ticos , atributos, tipos, rasgos o vidas.</target>
        </trans-unit>
        <trans-unit id="92af89abc5b10810cac2bde7c4403090edbb5361" translate="yes" xml:space="preserve">
          <source>The following notations are used by the &lt;em&gt;Lexer&lt;/em&gt; and &lt;em&gt;Syntax&lt;/em&gt; grammar snippets:</source>
          <target state="translated">Los fragmentos gramaticales de &lt;em&gt;Lexer&lt;/em&gt; y &lt;em&gt;Syntax&lt;/em&gt; utilizan las siguientes notaciones :</target>
        </trans-unit>
        <trans-unit id="6c611de22c83326f1c10498c47d838ad78c2827b" translate="yes" xml:space="preserve">
          <source>The following return &lt;a href=&quot;../primitive.bool&quot;&gt;&lt;code&gt;false&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Lo siguiente devuelve &lt;a href=&quot;../primitive.bool&quot;&gt; &lt;code&gt;false&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="1c03f7174ac895e9b31fae2f8cfc928f6b6b192e" translate="yes" xml:space="preserve">
          <source>The following return &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt;&lt;code&gt;false&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="452576d6c51a73e57d8181671d67361d1616b8f6" translate="yes" xml:space="preserve">
          <source>The following return false:</source>
          <target state="translated">El siguiente retorno es falso:</target>
        </trans-unit>
        <trans-unit id="b857efb8bb558af5cdfcfd53ef42f4d49fe84301" translate="yes" xml:space="preserve">
          <source>The following rewritten version of &lt;code&gt;another_function&lt;/code&gt; shows what parameters look like in Rust:</source>
          <target state="translated">La siguiente versi&amp;oacute;n reescrita de &lt;code&gt;another_function&lt;/code&gt; muestra c&amp;oacute;mo se ven los par&amp;aacute;metros en Rust:</target>
        </trans-unit>
        <trans-unit id="7befecdaf697f20709a802fcb20813e2f422fba6" translate="yes" xml:space="preserve">
          <source>The following sections contain reference material you may find useful in your Rust journey.</source>
          <target state="translated">Las siguientes secciones contienen material de referencia que puede serle útil en su viaje a la Óxido.</target>
        </trans-unit>
        <trans-unit id="5d4dd709d05236da16b69a96983ce9c67ce45124" translate="yes" xml:space="preserve">
          <source>The following steps install the latest stable version of the Rust compiler. Rust&amp;rsquo;s stability guarantees ensure that all the examples in the book that compile will continue to compile with newer Rust versions. The output might differ slightly between versions, because Rust often improves error messages and warnings. In other words, any newer, stable version of Rust you install using these steps should work as expected with the content of this book.</source>
          <target state="translated">Los siguientes pasos instalan la &amp;uacute;ltima versi&amp;oacute;n estable del compilador de Rust. Las garant&amp;iacute;as de estabilidad de Rust aseguran que todos los ejemplos en el libro que compilan continuar&amp;aacute;n compil&amp;aacute;ndose con versiones m&amp;aacute;s recientes de Rust. El resultado puede diferir ligeramente entre versiones, porque Rust a menudo mejora los mensajes de error y las advertencias. En otras palabras, cualquier versi&amp;oacute;n estable m&amp;aacute;s nueva de Rust que instale siguiendo estos pasos deber&amp;iacute;a funcionar como se esperaba con el contenido de este libro.</target>
        </trans-unit>
        <trans-unit id="d23c37bf8f18aef980fb1fbefe90db0a500a0719" translate="yes" xml:space="preserve">
          <source>The following table gives the size for primitives.</source>
          <target state="translated">La siguiente tabla da el tamaño para los primitivos.</target>
        </trans-unit>
        <trans-unit id="3bc9c0126109b1bad1345c2a1d2c68127ed67d67" translate="yes" xml:space="preserve">
          <source>The following traits are implemented for all &lt;code&gt;&amp;amp;T&lt;/code&gt;, regardless of the type of its referent:</source>
          <target state="translated">Los siguientes rasgos se implementan para todos &lt;code&gt;&amp;amp;T&lt;/code&gt; , independientemente del tipo de su referente:</target>
        </trans-unit>
        <trans-unit id="3e9fcf457a5e9ecd7495ab63bfd0f41db2476290" translate="yes" xml:space="preserve">
          <source>The following traits are implemented on &lt;code&gt;&amp;amp;T&lt;/code&gt; references if the underlying &lt;code&gt;T&lt;/code&gt; also implements that trait:</source>
          <target state="translated">Los siguientes rasgos se implementan en referencias &lt;code&gt;&amp;amp;T&lt;/code&gt; si la &lt;code&gt;T&lt;/code&gt; subyacente tambi&amp;eacute;n implementa ese rasgo:</target>
        </trans-unit>
        <trans-unit id="be48c1df52265e0b68ec35bc1f2481219af6ad7a" translate="yes" xml:space="preserve">
          <source>The following will print &quot;Custom panic hook&quot;:</source>
          <target state="translated">A continuación se imprimirá &quot;Gancho de pánico personalizado&quot;:</target>
        </trans-unit>
        <trans-unit id="882019462e8fd74a5df1bf54582eb004918743ba" translate="yes" xml:space="preserve">
          <source>The following will print &quot;Normal panic&quot;:</source>
          <target state="translated">Lo siguiente imprimirá &quot;Pánico normal&quot;:</target>
        </trans-unit>
        <trans-unit id="7ed71896f2a34a4014ac80c7f9efbde1c744961e" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;(..)&lt;/code&gt; with a single &lt;a href=&quot;#rest-patterns&quot;&gt;&lt;em&gt;RestPattern&lt;/em&gt;&lt;/a&gt; is a special form that does not require a comma, and matches a tuple of any size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a310cc6ed2f47da18129871732d4b9900992d6f" translate="yes" xml:space="preserve">
          <source>The formal way of describing this behavior is that expressions of type &lt;code&gt;!&lt;/code&gt; can be coerced into any other type. We&amp;rsquo;re allowed to end this &lt;code&gt;match&lt;/code&gt; arm with &lt;code&gt;continue&lt;/code&gt; because &lt;code&gt;continue&lt;/code&gt; doesn&amp;rsquo;t return a value; instead, it moves control back to the top of the loop, so in the &lt;code&gt;Err&lt;/code&gt; case, we never assign a value to &lt;code&gt;guess&lt;/code&gt;.</source>
          <target state="translated">La forma formal de describir este comportamiento es que las expresiones de tipo &lt;code&gt;!&lt;/code&gt; puede ser coaccionado a cualquier otro tipo. Se nos permite finalizar este brazo de &lt;code&gt;match&lt;/code&gt; con &lt;code&gt;continue&lt;/code&gt; porque &lt;code&gt;continue&lt;/code&gt; no devuelve un valor; en cambio, mueve el control a la parte superior del ciclo, por lo que en el caso &lt;code&gt;Err&lt;/code&gt; , nunca asignamos un valor para &lt;code&gt;guess&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99bcb45d13b51e9ae5259463fdd2a32bb1c9a90e" translate="yes" xml:space="preserve">
          <source>The full circle constant (&amp;tau;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd8574fedd8387c0dcc9c1aeee32062dd23e8095" translate="yes" xml:space="preserve">
          <source>The full path is created by joining the original path to &lt;code&gt;read_dir&lt;/code&gt; with the filename of this entry.</source>
          <target state="translated">La ruta completa se crea uniendo la ruta original a &lt;code&gt;read_dir&lt;/code&gt; con el nombre de archivo de esta entrada.</target>
        </trans-unit>
        <trans-unit id="32f32b59c17ac39e46a137b79b14f93e65ff40c1" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;inner_drop&lt;/code&gt; has the type that &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt;&lt;em&gt;should&lt;/em&gt; have, so this makes sure that you do not accidentally use &lt;code&gt;self&lt;/code&gt;/&lt;code&gt;this&lt;/code&gt; in a way that is in conflict with pinning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41bd7d7e62e02a905d152c2bd99a0375a7ed8226" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;inner_drop&lt;/code&gt; has the type that &lt;code&gt;drop&lt;/code&gt;&lt;em&gt;should&lt;/em&gt; have, so this makes sure that you do not accidentally use &lt;code&gt;self&lt;/code&gt;/&lt;code&gt;this&lt;/code&gt; in a way that is in conflict with pinning.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;inner_drop&lt;/code&gt; tiene el tipo que &lt;em&gt;deber&amp;iacute;a&lt;/em&gt; tener &lt;code&gt;drop&lt;/code&gt; , por lo que esto asegura que no use accidentalmente &lt;code&gt;self&lt;/code&gt; / &lt;code&gt;this&lt;/code&gt; de una manera que est&amp;eacute; en conflicto con la fijaci&amp;oacute;n.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cf14d5d5cd860e1137527a26dcf1970a6fdcd6cb" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; is unsafe because it takes a raw pointer and must trust that this pointer is valid. The &lt;code&gt;add&lt;/code&gt; method on raw pointers is also unsafe, because it must trust that the offset location is also a valid pointer. Therefore, we had to put an &lt;code&gt;unsafe&lt;/code&gt; block around our calls to &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; and &lt;code&gt;add&lt;/code&gt; so we could call them. By looking at the code and by adding the assertion that &lt;code&gt;mid&lt;/code&gt; must be less than or equal to &lt;code&gt;len&lt;/code&gt;, we can tell that all the raw pointers used within the &lt;code&gt;unsafe&lt;/code&gt; block will be valid pointers to data within the slice. This is an acceptable and appropriate use of &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcc8f276c3240e55b6476f93fee8521728c232e7" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; is unsafe because it takes a raw pointer and must trust that this pointer is valid. The &lt;code&gt;offset&lt;/code&gt; method on raw pointers is also unsafe, because it must trust that the offset location is also a valid pointer. Therefore, we had to put an &lt;code&gt;unsafe&lt;/code&gt; block around our calls to &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; so we could call them. By looking at the code and by adding the assertion that &lt;code&gt;mid&lt;/code&gt; must be less than or equal to &lt;code&gt;len&lt;/code&gt;, we can tell that all the raw pointers used within the &lt;code&gt;unsafe&lt;/code&gt; block will be valid pointers to data within the slice. This is an acceptable and appropriate use of &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; no es segura porque toma un puntero sin formato y debe confiar en que este puntero es v&amp;aacute;lido. El m&amp;eacute;todo de &lt;code&gt;offset&lt;/code&gt; en punteros sin formato tampoco es seguro, porque debe confiar en que la ubicaci&amp;oacute;n de desplazamiento tambi&amp;eacute;n es un puntero v&amp;aacute;lido. Por lo tanto, tuvimos que poner un bloque &lt;code&gt;unsafe&lt;/code&gt; alrededor de nuestras llamadas para &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; y &lt;code&gt;offset&lt;/code&gt; para poder llamarlas. Al observar el c&amp;oacute;digo y agregar la afirmaci&amp;oacute;n de que &lt;code&gt;mid&lt;/code&gt; debe ser menor o igual que &lt;code&gt;len&lt;/code&gt; , podemos decir que todos los punteros sin procesar usados ​​dentro del bloque &lt;code&gt;unsafe&lt;/code&gt; ser&amp;aacute;n punteros v&amp;aacute;lidos a datos dentro del segmento. Este es un uso aceptable y apropiado de &lt;code&gt;unsafe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e2ea4196275fb1f06fa7661da10e384c365aa9f" translate="yes" xml:space="preserve">
          <source>The function body block is contained within the scope of the entire function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cd654b546be7671958f348149444656b0175877" translate="yes" xml:space="preserve">
          <source>The function body uses the &lt;code&gt;assert_eq!&lt;/code&gt; macro to assert that 2 + 2 equals 4. This assertion serves as an example of the format for a typical test. Let&amp;rsquo;s run it to see that this test passes.</source>
          <target state="translated">El cuerpo de la funci&amp;oacute;n usa el valor de &lt;code&gt;assert_eq!&lt;/code&gt; macro para afirmar que 2 + 2 es igual a 4. Esta afirmaci&amp;oacute;n sirve como ejemplo del formato de una prueba t&amp;iacute;pica. Ejec&amp;uacute;telo para ver si esta prueba pasa.</target>
        </trans-unit>
        <trans-unit id="fce36fec5fc1977be02dde267db493eca3e79d7a" translate="yes" xml:space="preserve">
          <source>The function must be called with valid byte array &lt;code&gt;buf&lt;/code&gt; of sufficient size to hold the message bytes. If a message is too long to fit in the supplied buffer, excess bytes may be discarded.</source>
          <target state="translated">La funci&amp;oacute;n debe llamarse con una matriz de bytes v&amp;aacute;lida &lt;code&gt;buf&lt;/code&gt; de tama&amp;ntilde;o suficiente para contener los bytes del mensaje. Si un mensaje es demasiado largo para caber en el b&amp;uacute;fer proporcionado, los bytes sobrantes pueden descartarse.</target>
        </trans-unit>
        <trans-unit id="e529ccf733a9b5ef8b1c476a20d42d70328c6fe4" translate="yes" xml:space="preserve">
          <source>The function panics if &lt;code&gt;align&lt;/code&gt; is not a power-of-two.</source>
          <target state="translated">La funci&amp;oacute;n entra en p&amp;aacute;nico si &lt;code&gt;align&lt;/code&gt; no es una potencia de dos.</target>
        </trans-unit>
        <trans-unit id="3c4c57538d04834ae5173c38a3f23dea7037d387" translate="yes" xml:space="preserve">
          <source>The function signature now tells Rust that for some lifetime &lt;code&gt;'a&lt;/code&gt;, the function takes two parameters, both of which are string slices that live at least as long as lifetime &lt;code&gt;'a&lt;/code&gt;. The function signature also tells Rust that the string slice returned from the function will live at least as long as lifetime &lt;code&gt;'a&lt;/code&gt;. In practice, it means that the lifetime of the reference returned by the &lt;code&gt;longest&lt;/code&gt; function is the same as the smaller of the lifetimes of the references passed in. These constraints are what we want Rust to enforce. Remember, when we specify the lifetime parameters in this function signature, we&amp;rsquo;re not changing the lifetimes of any values passed in or returned. Rather, we&amp;rsquo;re specifying that the borrow checker should reject any values that don&amp;rsquo;t adhere to these constraints. Note that the &lt;code&gt;longest&lt;/code&gt; function doesn&amp;rsquo;t need to know exactly how long &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; will live, only that some scope can be substituted for &lt;code&gt;'a&lt;/code&gt; that will satisfy this signature.</source>
          <target state="translated">La firma de la funci&amp;oacute;n ahora le dice a Rust que durante un tiempo &lt;code&gt;'a&lt;/code&gt; vida 'a , la funci&amp;oacute;n toma dos par&amp;aacute;metros, los cuales son segmentos de cadena que viven al menos tanto como la vida &lt;code&gt;'a&lt;/code&gt; . La firma de la funci&amp;oacute;n tambi&amp;eacute;n le dice a Rust que el segmento de cadena devuelto por la funci&amp;oacute;n vivir&amp;aacute; al menos mientras dure &lt;code&gt;'a&lt;/code&gt; . En la pr&amp;aacute;ctica, significa que la vida &amp;uacute;til de la referencia devuelta por el &lt;code&gt;longest&lt;/code&gt; La funci&amp;oacute;n es la misma que la menor de las duraciones de las referencias pasadas. Estas restricciones son las que queremos que Rust aplique. Recuerde, cuando especificamos los par&amp;aacute;metros de duraci&amp;oacute;n en esta firma de funci&amp;oacute;n, no cambiamos la duraci&amp;oacute;n de los valores pasados ​​o devueltos. M&amp;aacute;s bien, estamos especificando que el verificador de pr&amp;eacute;stamos debe rechazar cualquier valor que no se adhiera a estas restricciones. Tenga en cuenta que la &lt;code&gt;longest&lt;/code&gt; funci&amp;oacute;n no necesita saber exactamente cu&amp;aacute;nto tiempo &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; sobrevivir&amp;aacute;n, pero s&amp;oacute;lo eso cierto margen puede ser sustituido por &lt;code&gt;'a&lt;/code&gt; que satisfaga a esta firma.</target>
        </trans-unit>
        <trans-unit id="bdcb7a1c11baa13711e61ba40d7e28572f624f97" translate="yes" xml:space="preserve">
          <source>The function that defines a procedural macro takes a &lt;code&gt;TokenStream&lt;/code&gt; as an input and produces a &lt;code&gt;TokenStream&lt;/code&gt; as an output. The &lt;code&gt;TokenStream&lt;/code&gt; type is defined by the &lt;code&gt;proc_macro&lt;/code&gt; crate that is included with Rust and represents a sequence of tokens. This is the core of the macro: the source code that the macro is operating on makes up the input &lt;code&gt;TokenStream&lt;/code&gt;, and the code the macro produces is the output &lt;code&gt;TokenStream&lt;/code&gt;. The function also has an attribute attached to it that specifies which kind of procedural macro we&amp;rsquo;re creating. We can have multiple kinds of procedural macros in the same crate.</source>
          <target state="translated">La funci&amp;oacute;n que define una macro de procedimiento toma un &lt;code&gt;TokenStream&lt;/code&gt; como entrada y produce un &lt;code&gt;TokenStream&lt;/code&gt; como salida. El tipo &lt;code&gt;TokenStream&lt;/code&gt; est&amp;aacute; definido por la caja &lt;code&gt;proc_macro&lt;/code&gt; que se incluye con Rust y representa una secuencia de tokens. Este es el n&amp;uacute;cleo de la macro: el c&amp;oacute;digo fuente en el que opera la macro constituye el &lt;code&gt;TokenStream&lt;/code&gt; de entrada , y el c&amp;oacute;digo que produce la macro es el &lt;code&gt;TokenStream&lt;/code&gt; de salida . La funci&amp;oacute;n tambi&amp;eacute;n tiene un atributo adjunto que especifica qu&amp;eacute; tipo de macro de procedimiento estamos creando. Podemos tener varios tipos de macros de procedimiento en la misma caja.</target>
        </trans-unit>
        <trans-unit id="bf36f24b39c35b8342b2a6251cb9fb9f153537b5" translate="yes" xml:space="preserve">
          <source>The function will never return and will immediately terminate the current process in a platform specific &quot;abnormal&quot; manner.</source>
          <target state="translated">La función nunca volverá y terminará inmediatamente el proceso actual de una manera &quot;anormal&quot; específica de la plataforma.</target>
        </trans-unit>
        <trans-unit id="0c78d2fcec6d6debbe4ef0124bd9c3f517852fce" translate="yes" xml:space="preserve">
          <source>The functional record update syntax is only allowed for structs (struct-like enum variants don't qualify, for example). To fix the previous code, rewrite the expression without functional record update syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4265d286c4ebab2fa68494c58f7e5472bec6ff8e" translate="yes" xml:space="preserve">
          <source>The functional record update syntax is only allowed for structs. (Struct-like enum variants don't qualify, for example.)</source>
          <target state="translated">La sintaxis de actualización del registro funcional sólo se permite para las estructuras.(Las variantes de enumeración de las estructuras no califican,por ejemplo).</target>
        </trans-unit>
        <trans-unit id="771371fc3674c285662522a3ce8c91121a8eb8d5" translate="yes" xml:space="preserve">
          <source>The functional record update syntax was used on something other than a struct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3064e7a399dc1562d735ddcb75b4d1c141aa6d18" translate="yes" xml:space="preserve">
          <source>The functionality and syntax of Rust can be extended with custom definitions called macros. They are given names, and invoked through a consistent syntax:&lt;code&gt;some_extension!(...)&lt;/code&gt;.</source>
          <target state="translated">La funcionalidad y la sintaxis de Rust se pueden ampliar con definiciones personalizadas llamadas macros. Se les da nombres y se les invoca mediante una sintaxis coherente: &lt;code&gt;some_extension!(...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90f6e5d380880e28cc22176bc452d0a2cfb51f5f" translate="yes" xml:space="preserve">
          <source>The functions inside this struct are only intended be called on the &lt;code&gt;data&lt;/code&gt; pointer of a properly constructed &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; object from inside the &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; implementation. Calling one of the contained functions using any other &lt;code&gt;data&lt;/code&gt; pointer will cause undefined behavior.</source>
          <target state="translated">Las funciones dentro de esta estructura solo deben llamarse en el puntero de &lt;code&gt;data&lt;/code&gt; de un objeto &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; construido correctamente desde dentro de la implementaci&amp;oacute;n de &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; . Llamar a una de las funciones contenidas utilizando cualquier otro puntero de &lt;code&gt;data&lt;/code&gt; provocar&amp;aacute; un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="5d3fe931a60678fe761ffe2bfb5b03361ca50257" translate="yes" xml:space="preserve">
          <source>The functions inside this struct are only intended to be called on the &lt;code&gt;data&lt;/code&gt; pointer of a properly constructed &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; object from inside the &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; implementation. Calling one of the contained functions using any other &lt;code&gt;data&lt;/code&gt; pointer will cause undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df0966ed788f9044d3bbbf28ed214b74382d234e" translate="yes" xml:space="preserve">
          <source>The general case</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44389c2bb8540f5071dbf79b16d89782c82ab1a7" translate="yes" xml:space="preserve">
          <source>The general categories for numbers (&lt;code&gt;Nd&lt;/code&gt; for decimal digits, &lt;code&gt;Nl&lt;/code&gt; for letter-like numeric characters, and &lt;code&gt;No&lt;/code&gt; for other numeric characters) are specified in the &lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;Unicode Character Database&lt;/a&gt;&lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt&quot;&gt;&lt;code&gt;UnicodeData.txt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a1ceefd46a3c1a3651802a4204c4c589bc3c7f6" translate="yes" xml:space="preserve">
          <source>The generated &lt;code&gt;impl&lt;/code&gt; for &lt;code&gt;PartialEq&lt;/code&gt; is equivalent to</source>
          <target state="translated">El generado &lt;code&gt;impl&lt;/code&gt; para &lt;code&gt;PartialEq&lt;/code&gt; es equivalente a</target>
        </trans-unit>
        <trans-unit id="b683f5ed135731413c6d034116ca989acf594401" translate="yes" xml:space="preserve">
          <source>The generator completed with a return value.</source>
          <target state="translated">El generador se completó con un valor de retorno.</target>
        </trans-unit>
        <trans-unit id="156bc757a593c6f0753b493e20c7157ef75917ae" translate="yes" xml:space="preserve">
          <source>The generator suspended with a value.</source>
          <target state="translated">El generador se suspendió con un valor.</target>
        </trans-unit>
        <trans-unit id="cd45c192be4dc3d892b1ef2f0b632aaff12d6653" translate="yes" xml:space="preserve">
          <source>The generic type &lt;code&gt;T&lt;/code&gt; specified as the type of the &lt;code&gt;item1&lt;/code&gt; and &lt;code&gt;item2&lt;/code&gt; parameters constrains the function such that the concrete type of the value passed as an argument for &lt;code&gt;item1&lt;/code&gt; and &lt;code&gt;item2&lt;/code&gt; must be the same.</source>
          <target state="translated">El tipo gen&amp;eacute;rico &lt;code&gt;T&lt;/code&gt; especifica como el tipo de la &lt;code&gt;item1&lt;/code&gt; y &lt;code&gt;item2&lt;/code&gt; Par&amp;aacute;metros limita la funci&amp;oacute;n tal que el tipo de hormig&amp;oacute;n del valor pasa como argumento para &lt;code&gt;item1&lt;/code&gt; y &lt;code&gt;item2&lt;/code&gt; debe ser el mismo.</target>
        </trans-unit>
        <trans-unit id="1bc01fb3a417f3ff749e03a42ff1490b6833bd43" translate="yes" xml:space="preserve">
          <source>The generic type has to be a SIMD type. Example:</source>
          <target state="translated">El tipo genérico tiene que ser un tipo SIMD.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="e58faf99c3204433210564e65725762b8514494f" translate="yes" xml:space="preserve">
          <source>The given &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;strong&gt;must&lt;/strong&gt; have one nul byte as its last element. This means it cannot be empty nor have any other nul byte anywhere else.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b25fdf4b8d15b07b7d25cece8768d803831d5b3d" translate="yes" xml:space="preserve">
          <source>The given block must have been produced by this allocator, and must be suitable for storing a &lt;code&gt;T&lt;/code&gt; (in terms of alignment as well as minimum and maximum size); otherwise yields undefined behavior.</source>
          <target state="translated">El bloque dado debe haber sido producido por este asignador, y debe ser adecuado para almacenar una &lt;code&gt;T&lt;/code&gt; (en t&amp;eacute;rminos de alineaci&amp;oacute;n y tama&amp;ntilde;o m&amp;iacute;nimo y m&amp;aacute;ximo); de lo contrario, produce un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="3ef7afeafd2e9737676d96a4cbd3c7dc2e9ffdbc" translate="yes" xml:space="preserve">
          <source>The glob operator is often used when testing to bring everything under test into the &lt;code&gt;tests&lt;/code&gt; module; we&amp;rsquo;ll talk about that in the &lt;a href=&quot;ch11-01-writing-tests#how-to-write-tests&quot;&gt;&amp;ldquo;How to Write Tests&amp;rdquo;&lt;/a&gt; section in Chapter 11. The glob operator is also sometimes used as part of the prelude pattern: see &lt;a href=&quot;../std/prelude/index#other-preludes&quot;&gt;the standard library documentation&lt;/a&gt; for more information on that pattern.</source>
          <target state="translated">El operador glob se usa a menudo cuando se prueba para poner todo bajo prueba en el m&amp;oacute;dulo de &lt;code&gt;tests&lt;/code&gt; ; hablaremos de eso en la secci&amp;oacute;n &lt;a href=&quot;ch11-01-writing-tests#how-to-write-tests&quot;&gt;&amp;ldquo;C&amp;oacute;mo escribir pruebas&amp;rdquo;&lt;/a&gt; en el Cap&amp;iacute;tulo 11. El operador glob tambi&amp;eacute;n se usa a veces como parte del patr&amp;oacute;n de preludio: consulte &lt;a href=&quot;../std/prelude/index#other-preludes&quot;&gt;la documentaci&amp;oacute;n de la biblioteca est&amp;aacute;ndar&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n sobre ese patr&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="edae830710bf3e8598def4042b918afe98bc10c2" translate="yes" xml:space="preserve">
          <source>The global memory allocator.</source>
          <target state="translated">El asignador de memoria global.</target>
        </trans-unit>
        <trans-unit id="ec4646ba1a1fdd24f47203209a1bde5837e4ed73" translate="yes" xml:space="preserve">
          <source>The good news is that if the structure &lt;em&gt;isn&amp;rsquo;t&lt;/em&gt; convenient for others to use from another library, you don&amp;rsquo;t have to rearrange your internal organization: instead, you can re-export items to make a public structure that&amp;rsquo;s different from your private structure by using &lt;code&gt;pub use&lt;/code&gt;. Re-exporting takes a public item in one location and makes it public in another location, as if it were defined in the other location instead.</source>
          <target state="translated">La buena noticia es que si la estructura &lt;em&gt;no es&lt;/em&gt; conveniente para que otros la usen desde otra biblioteca, no tiene que reorganizar su organizaci&amp;oacute;n interna: en cambio, puede reexportar elementos para hacer una estructura p&amp;uacute;blica que sea diferente de su estructura privada. mediante el uso de &lt;code&gt;pub use&lt;/code&gt; . La reexportaci&amp;oacute;n toma un elemento p&amp;uacute;blico en una ubicaci&amp;oacute;n y lo hace p&amp;uacute;blico en otra ubicaci&amp;oacute;n, como si estuviera definido en la otra ubicaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9e529cd967841dc9eed1fc815f3a4e6b886e5b38" translate="yes" xml:space="preserve">
          <source>The grammar and lexical structure is in blockquotes with either &quot;Lexer&quot; or &quot;Syntax&quot; in &lt;sup&gt;&lt;strong&gt;bold superscript&lt;/strong&gt;&lt;/sup&gt; as the first line.</source>
          <target state="translated">La estructura gramatical y l&amp;eacute;xica est&amp;aacute; entre comillas en bloque con &quot;Lexer&quot; o &quot;Sintaxis&quot; en &lt;sup&gt;&lt;strong&gt;super&amp;iacute;ndice&lt;/strong&gt;&lt;/sup&gt; en &lt;sup&gt;&lt;strong&gt;negrita&lt;/strong&gt;&lt;/sup&gt; como primera l&amp;iacute;nea.</target>
        </trans-unit>
        <trans-unit id="1f36df1235888018fbfcd5153ebfed60de89aef3" translate="yes" xml:space="preserve">
          <source>The grammar production for reference patterns has to match the token &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; to match a reference to a reference because it is a token by itself, not two &lt;code&gt;&amp;amp;&lt;/code&gt; tokens.</source>
          <target state="translated">La producci&amp;oacute;n gramatical para patrones de referencia tiene que coincidir con el token &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; para hacer coincidir una referencia con una referencia porque es un token en s&amp;iacute; mismo, no dos &lt;code&gt;&amp;amp;&lt;/code&gt; tokens.</target>
        </trans-unit>
        <trans-unit id="ecdb2fc042ccb9955819301d5b939d1fbe330ddf" translate="yes" xml:space="preserve">
          <source>The green-threading M:N model requires a larger language runtime to manage threads. As such, the Rust standard library only provides an implementation of 1:1 threading. Because Rust is such a low-level language, there are crates that implement M:N threading if you would rather trade overhead for aspects such as more control over which threads run when and lower costs of context switching, for example.</source>
          <target state="translated">El modelo M:N de hilos verdes requiere un mayor tiempo de ejecución del lenguaje para manejar los hilos.Por lo tanto,la biblioteca estándar de Rust sólo proporciona una implementación de hilos 1:1.Dado que Rust es un lenguaje de tan bajo nivel,hay cajas que implementan el roscado M:N si se prefiere cambiar los gastos generales por aspectos como un mayor control sobre qué hilos se ejecutan cuándo y menores costes de cambio de contexto,por ejemplo.</target>
        </trans-unit>
        <trans-unit id="ebee4d45f3971e13391e35d52c5a14b0340c1efd" translate="yes" xml:space="preserve">
          <source>The handle for reading from the child's standard error (stderr), if it has been captured.</source>
          <target state="translated">La manija para leer del error estándar del niño (stderr),si ha sido capturado.</target>
        </trans-unit>
        <trans-unit id="71a4cc891c9774ed993ea2778e2ec4e78d46aa4f" translate="yes" xml:space="preserve">
          <source>The handle for reading from the child's standard error (stderr), if it has been captured. You might find it helpful to do</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbdaac9b24bb1d15aadc721c15a3031cb1337d9a" translate="yes" xml:space="preserve">
          <source>The handle for reading from the child's standard output (stdout), if it has been captured.</source>
          <target state="translated">La manija para leer de la salida estándar del niño (stdout),si ha sido capturada.</target>
        </trans-unit>
        <trans-unit id="5b65d5fd43c0bfac48d483d2399323a0f40fd595" translate="yes" xml:space="preserve">
          <source>The handle for reading from the child's standard output (stdout), if it has been captured. You might find it helpful to do</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d208573c971bb153ba34475100ea53bd4242537e" translate="yes" xml:space="preserve">
          <source>The handle for writing to the child's standard input (stdin), if it has been captured.</source>
          <target state="translated">La manija para escribir en la entrada estándar del niño (stdin),si ha sido capturada.</target>
        </trans-unit>
        <trans-unit id="1008f723c1fd717a94e8a77d7bc5c5ff92ef4700" translate="yes" xml:space="preserve">
          <source>The handle for writing to the child's standard input (stdin), if it has been captured. To avoid partially moving the &lt;code&gt;child&lt;/code&gt; and thus blocking yourself from calling functions on &lt;code&gt;child&lt;/code&gt; while using &lt;code&gt;stdin&lt;/code&gt;, you might find it helpful:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9febcaaba526b722c76a7ab2b805ffd862b6652" translate="yes" xml:space="preserve">
          <source>The hash map is initially created with a capacity of 0, so it will not allocate until it is first inserted into.</source>
          <target state="translated">El mapa hash se crea inicialmente con una capacidad de 0,por lo que no se asignará hasta que se inserte por primera vez en él.</target>
        </trans-unit>
        <trans-unit id="ee8ffcf3c4827d14350f3675ea8e7360ee55ee19" translate="yes" xml:space="preserve">
          <source>The hash map will be able to hold at least &lt;code&gt;capacity&lt;/code&gt; elements without reallocating. If &lt;code&gt;capacity&lt;/code&gt; is 0, the hash map will not allocate.</source>
          <target state="translated">El mapa hash podr&amp;aacute; contener al menos elementos de &lt;code&gt;capacity&lt;/code&gt; sin reasignar. Si la &lt;code&gt;capacity&lt;/code&gt; es 0, el mapa hash no se asignar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="0b56c1bdca2b1b95316afe0ecdd6afdabfe66713" translate="yes" xml:space="preserve">
          <source>The hash set is also created with the default initial capacity.</source>
          <target state="translated">El conjunto de hash también se crea con la capacidad inicial predeterminada.</target>
        </trans-unit>
        <trans-unit id="b637bd7a31fb790788f10cfb96ebb867cfd6151d" translate="yes" xml:space="preserve">
          <source>The hash set is initially created with a capacity of 0, so it will not allocate until it is first inserted into.</source>
          <target state="translated">El conjunto de hash se crea inicialmente con una capacidad de 0,por lo que no se asignará hasta que se inserte por primera vez.</target>
        </trans-unit>
        <trans-unit id="7b099ba43b1ded8417cfcd0145835bc5cf64881f" translate="yes" xml:space="preserve">
          <source>The hash set will be able to hold at least &lt;code&gt;capacity&lt;/code&gt; elements without reallocating. If &lt;code&gt;capacity&lt;/code&gt; is 0, the hash set will not allocate.</source>
          <target state="translated">El conjunto de hash podr&amp;aacute; contener al menos elementos de &lt;code&gt;capacity&lt;/code&gt; sin reasignar. Si la &lt;code&gt;capacity&lt;/code&gt; es 0, el conjunto hash no se asignar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="d8a4e0ea14c5f027cfeb61abdb7d26fe519f8ab6" translate="yes" xml:space="preserve">
          <source>The hash table implementation is a Rust port of Google's &lt;a href=&quot;https://abseil.io/blog/20180927-swisstables&quot;&gt;SwissTable&lt;/a&gt;. The original C++ version of SwissTable can be found &lt;a href=&quot;https://github.com/abseil/abseil-cpp/blob/master/absl/container/internal/raw_hash_set.h&quot;&gt;here&lt;/a&gt;, and this &lt;a href=&quot;https://www.youtube.com/watch?v=ncHmEUmJZf4&quot;&gt;CppCon talk&lt;/a&gt; gives an overview of how the algorithm works.</source>
          <target state="translated">La implementaci&amp;oacute;n de la tabla hash es un puerto Rust de &lt;a href=&quot;https://abseil.io/blog/20180927-swisstables&quot;&gt;SwissTable&lt;/a&gt; de Google . La versi&amp;oacute;n original en C ++ de SwissTable se puede encontrar &lt;a href=&quot;https://github.com/abseil/abseil-cpp/blob/master/absl/container/internal/raw_hash_set.h&quot;&gt;aqu&amp;iacute;&lt;/a&gt; , y esta &lt;a href=&quot;https://www.youtube.com/watch?v=ncHmEUmJZf4&quot;&gt;charla CppCon&lt;/a&gt; ofrece una descripci&amp;oacute;n general de c&amp;oacute;mo funciona el algoritmo.</target>
        </trans-unit>
        <trans-unit id="415bb7e03ead8b051422fe277c860425b7ebbf61" translate="yes" xml:space="preserve">
          <source>The hashing algorithm can be replaced on a per-&lt;code&gt;HashMap&lt;/code&gt; basis using the &lt;a href=&quot;#method.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#method.with_hasher&quot;&gt;&lt;code&gt;with_hasher&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#method.with_capacity_and_hasher&quot;&gt;&lt;code&gt;with_capacity_and_hasher&lt;/code&gt;&lt;/a&gt; methods. Many alternative algorithms are available on crates.io, such as the &lt;a href=&quot;https://crates.io/crates/fnv&quot;&gt;&lt;code&gt;fnv&lt;/code&gt;&lt;/a&gt; crate.</source>
          <target state="translated">El algoritmo de hash se puede reemplazar por &lt;code&gt;HashMap&lt;/code&gt; utilizando los m&amp;eacute;todos &lt;a href=&quot;#method.default&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#method.with_hasher&quot;&gt; &lt;code&gt;with_hasher&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#method.with_capacity_and_hasher&quot;&gt; &lt;code&gt;with_capacity_and_hasher&lt;/code&gt; &lt;/a&gt; . Muchos algoritmos alternativos est&amp;aacute;n disponibles en crates.io, como &lt;a href=&quot;https://crates.io/crates/fnv&quot;&gt; &lt;code&gt;fnv&lt;/code&gt; crate&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="142488b9261462c1e559bf3f2ad49337e31e2ac1" translate="yes" xml:space="preserve">
          <source>The hashing algorithm can be replaced on a per-&lt;code&gt;HashMap&lt;/code&gt; basis using the &lt;a href=&quot;../../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../struct.hashmap#method.with_hasher&quot;&gt;&lt;code&gt;with_hasher&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../struct.hashmap#method.with_capacity_and_hasher&quot;&gt;&lt;code&gt;with_capacity_and_hasher&lt;/code&gt;&lt;/a&gt; methods. Many alternative algorithms are available on crates.io, such as the &lt;a href=&quot;https://crates.io/crates/fnv&quot;&gt;&lt;code&gt;fnv&lt;/code&gt;&lt;/a&gt; crate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="417d67f06aec820d5f0416a0fabba770f0ab5392" translate="yes" xml:space="preserve">
          <source>The hashing algorithm can be replaced on a per-&lt;code&gt;HashMap&lt;/code&gt; basis using the &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.hashmap#method.with_hasher&quot;&gt;&lt;code&gt;with_hasher&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;struct.hashmap#method.with_capacity_and_hasher&quot;&gt;&lt;code&gt;with_capacity_and_hasher&lt;/code&gt;&lt;/a&gt; methods. Many alternative algorithms are available on crates.io, such as the &lt;a href=&quot;https://crates.io/crates/fnv&quot;&gt;&lt;code&gt;fnv&lt;/code&gt;&lt;/a&gt; crate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36e2055f1b7671fa46f87316bf9cf49547025536" translate="yes" xml:space="preserve">
          <source>The heart and soul of this module is the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; trait. The core of &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; looks like this:</source>
          <target state="translated">El coraz&amp;oacute;n y el alma de este m&amp;oacute;dulo es el rasgo &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; . El n&amp;uacute;cleo de &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; se&lt;/a&gt; ve as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="f7cf9da11ff393d577012f24f0fd7f9d800c440a" translate="yes" xml:space="preserve">
          <source>The heart of the change is that where &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; used to default to &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait+'a&amp;gt;&lt;/code&gt;, it now defaults to &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait+'static&amp;gt;&lt;/code&gt; (here, &lt;code&gt;SomeTrait&lt;/code&gt; is the name of some trait type). Note that the only types which are affected are references to boxes, like &lt;code&gt;&amp;amp;Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;amp;[Box&amp;lt;SomeTrait&amp;gt;]&lt;/code&gt;. More common types like &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt; or &lt;code&gt;Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; are unaffected.</source>
          <target state="translated">El meollo del cambio es que donde &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; sol&amp;iacute;a ser &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait+'a&amp;gt;&lt;/code&gt; , ahora tiene como valor predeterminado &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait+'static&amp;gt;&lt;/code&gt; (aqu&amp;iacute;, &lt;code&gt;SomeTrait&lt;/code&gt; es el nombre de alg&amp;uacute;n tipo de rasgo). Tenga en cuenta que los &amp;uacute;nicos tipos que se ven afectados son las referencias a cuadros, como &lt;code&gt;&amp;amp;Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; o &lt;code&gt;&amp;amp;[Box&amp;lt;SomeTrait&amp;gt;]&lt;/code&gt; . Los tipos m&amp;aacute;s comunes como &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt; o &lt;code&gt;Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; no se ven afectados.</target>
        </trans-unit>
        <trans-unit id="8b80292943879aaefba4fcd89176f25fb4fe681b" translate="yes" xml:space="preserve">
          <source>The help text reveals that the return type needs a generic lifetime parameter on it because Rust can&amp;rsquo;t tell whether the reference being returned refers to &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt;. Actually, we don&amp;rsquo;t know either, because the &lt;code&gt;if&lt;/code&gt; block in the body of this function returns a reference to &lt;code&gt;x&lt;/code&gt; and the &lt;code&gt;else&lt;/code&gt; block returns a reference to &lt;code&gt;y&lt;/code&gt;!</source>
          <target state="translated">El texto de ayuda revela que el tipo de retorno necesita un par&amp;aacute;metro de tiempo de vida gen&amp;eacute;rica en &amp;eacute;l porque Rust no puede decir si la referencia de ser devuelto se refiere a &lt;code&gt;x&lt;/code&gt; o &lt;code&gt;y&lt;/code&gt; . En realidad, tampoco lo sabemos, porque el bloque &lt;code&gt;if&lt;/code&gt; en el cuerpo de esta funci&amp;oacute;n devuelve una referencia a &lt;code&gt;x&lt;/code&gt; y el bloque &lt;code&gt;else&lt;/code&gt; devuelve una referencia a &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d58a9f4bf1938432cc316db1e69ad2bfca3de5d4" translate="yes" xml:space="preserve">
          <source>The highest valid code point a &lt;code&gt;char&lt;/code&gt; can have.</source>
          <target state="translated">El punto de c&amp;oacute;digo v&amp;aacute;lido m&amp;aacute;s alto que puede tener un &lt;code&gt;char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c0d414ff9adc0b33c0f3d50d800e4ef1b9ec6d2" translate="yes" xml:space="preserve">
          <source>The hook is provided with a &lt;code&gt;Layout&lt;/code&gt; struct which contains information about the allocation that failed.</source>
          <target state="translated">El gancho se proporciona con una estructura &lt;code&gt;Layout&lt;/code&gt; que contiene informaci&amp;oacute;n sobre la asignaci&amp;oacute;n que fall&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="c05a8db594383eaa649c0ea9f1230d31e2d9d207" translate="yes" xml:space="preserve">
          <source>The hook is provided with a &lt;code&gt;PanicInfo&lt;/code&gt; struct which contains information about the origin of the panic, including the payload passed to &lt;code&gt;panic!&lt;/code&gt; and the source code location from which the panic originated.</source>
          <target state="translated">El gancho se proporciona con una estructura &lt;code&gt;PanicInfo&lt;/code&gt; que contiene informaci&amp;oacute;n sobre el origen del p&amp;aacute;nico, incluida la carga &amp;uacute;til que se pasa al &lt;code&gt;panic!&lt;/code&gt; y la ubicaci&amp;oacute;n del c&amp;oacute;digo fuente desde donde se origin&amp;oacute; el p&amp;aacute;nico.</target>
        </trans-unit>
        <trans-unit id="c5e73d7bf13606a783c42b98ca4eecc2c703d2de" translate="yes" xml:space="preserve">
          <source>The identifier is more than one character. &lt;code&gt;_&lt;/code&gt; alone is not an identifier.</source>
          <target state="translated">El identificador tiene m&amp;aacute;s de un car&amp;aacute;cter. &lt;code&gt;_&lt;/code&gt; solo no es un identificador.</target>
        </trans-unit>
        <trans-unit id="714243f838efe98c2e10bdbb7f1411daa3ecd7a0" translate="yes" xml:space="preserve">
          <source>The identifier is the name of the constant used in the path. The type is the type that the definition has to implement.</source>
          <target state="translated">El identificador es el nombre de la constante utilizada en el camino.El tipo es el tipo que la definición tiene que implementar.</target>
        </trans-unit>
        <trans-unit id="3a2c9033b8c31ad61606f019cbc00c4420b891b9" translate="yes" xml:space="preserve">
          <source>The identifier is the name of the declared type alias. The optional trait bounds must be fulfilled by the implementations of the type alias.</source>
          <target state="translated">El identificador es el nombre del alias de tipo declarado.Los límites de los rasgos opcionales deben ser cumplidos por las implementaciones del alias de tipo.</target>
        </trans-unit>
        <trans-unit id="1c83f053af5e622145b3145a7189cafa0c9167a0" translate="yes" xml:space="preserve">
          <source>The identifier is the name of the function. The generics, parameter list, return type, and where clause of the associated function must be the same as the associated function declarations's.</source>
          <target state="translated">El identificador es el nombre de la función.Los genéricos,la lista de parámetros,el tipo de retorno y la cláusula de dónde de la función asociada deben ser los mismos que los de las declaraciones de la función asociada.</target>
        </trans-unit>
        <trans-unit id="c54b94a826db4a7c6ce8d411476041b69555f1aa" translate="yes" xml:space="preserve">
          <source>The identity function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0f93995f216b848984f480fd53d07ae2b2c30e6" translate="yes" xml:space="preserve">
          <source>The idiomatic way to write a &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; for its side effects is to use a &lt;code&gt;for&lt;/code&gt; loop instead:</source>
          <target state="translated">La forma idiom&amp;aacute;tica de escribir un &lt;a href=&quot;trait.iterator#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; a&lt;/a&gt; para sus efectos secundarios es usar un bucle &lt;code&gt;for&lt;/code&gt; en su lugar:</target>
        </trans-unit>
        <trans-unit id="20b4ace5ebaf142e4e8addc0656248d8010dca32" translate="yes" xml:space="preserve">
          <source>The idiomatic way to write a &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; for its side effects is to use a &lt;code&gt;for&lt;/code&gt; loop or call the &lt;a href=&quot;trait.iterator#method.for_each&quot;&gt;&lt;code&gt;for_each&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dc3122c538d92098d293869587f4b3a0100941a" translate="yes" xml:space="preserve">
          <source>The implementation ensures that the iterator will return exactly &lt;code&gt;len()&lt;/code&gt; more times a &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(T)&lt;/code&gt;&lt;/a&gt; value, before returning &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. This method has a default implementation, so you usually should not implement it directly. However, if you can provide a more efficient implementation, you can do so. See the &lt;a href=&quot;trait.exactsizeiterator&quot;&gt;trait-level&lt;/a&gt; docs for an example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a17be86477c61cc7613b2ed105a5af337a27c206" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;Display&lt;/code&gt; uses &lt;code&gt;self.0&lt;/code&gt; to access the inner &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, because &lt;code&gt;Wrapper&lt;/code&gt; is a tuple struct and &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; is the item at index 0 in the tuple. Then we can use the functionality of the &lt;code&gt;Display&lt;/code&gt; type on &lt;code&gt;Wrapper&lt;/code&gt;.</source>
          <target state="translated">La implementaci&amp;oacute;n de &lt;code&gt;Display&lt;/code&gt; usa &lt;code&gt;self.0&lt;/code&gt; para acceder al &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; interno , porque &lt;code&gt;Wrapper&lt;/code&gt; es una estructura de tupla y &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; es el elemento en el &amp;iacute;ndice 0 en la tupla. Entonces podemos usar la funcionalidad del tipo de &lt;code&gt;Display&lt;/code&gt; en &lt;code&gt;Wrapper&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64d2ca9bc84ea7c438a453f8d81beffdb2cea48b" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;get&lt;/code&gt; relies in particular on identical implementations of &lt;code&gt;Hash&lt;/code&gt; by determining the key&amp;rsquo;s hash bucket by calling &lt;code&gt;Hash::hash&lt;/code&gt; on the &lt;code&gt;Q&lt;/code&gt; value even though it inserted the key based on the hash value calculated from the &lt;code&gt;K&lt;/code&gt; value.</source>
          <target state="translated">La implementaci&amp;oacute;n de &lt;code&gt;get&lt;/code&gt; se basa, en particular, en implementaciones id&amp;eacute;nticas de &lt;code&gt;Hash&lt;/code&gt; determinando el dep&amp;oacute;sito de hash de la clave llamando a &lt;code&gt;Hash::hash&lt;/code&gt; en el valor &lt;code&gt;Q&lt;/code&gt; , aunque insert&amp;oacute; la clave en funci&amp;oacute;n del valor hash calculado a partir del valor &lt;code&gt;K&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ddcc339944cbb72b0b66f63ad73cbbefd5f13bf" translate="yes" xml:space="preserve">
          <source>The implementation of this function must make sure to release any resources that are associated with this instance of a &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; and associated task.</source>
          <target state="translated">La implementaci&amp;oacute;n de esta funci&amp;oacute;n debe asegurarse de liberar todos los recursos asociados con esta instancia de &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; y la tarea asociada.</target>
        </trans-unit>
        <trans-unit id="b2b66f02783344ac4bc18a2fce3954484c2ba8e0" translate="yes" xml:space="preserve">
          <source>The implementation of this function must retain all resources that are required for this additional instance of a &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; and associated task. Calling &lt;code&gt;wake&lt;/code&gt; on the resulting &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; should result in a wakeup of the same task that would have been awoken by the original &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La implementaci&amp;oacute;n de esta funci&amp;oacute;n debe conservar todos los recursos necesarios para esta instancia adicional de &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; y la tarea asociada. Llamar a &lt;code&gt;wake&lt;/code&gt; en el &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; resultante deber&amp;iacute;a resultar en un despertar de la misma tarea que el &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; original habr&amp;iacute;a despertado .</target>
        </trans-unit>
        <trans-unit id="497d98f3948b6fc88a56b8970a7685389e682fb3" translate="yes" xml:space="preserve">
          <source>The implementation of waking a task on an executor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d439e7f4f40d7bfe18d46ea25d8affbdc7117648" translate="yes" xml:space="preserve">
          <source>The implementation using the state pattern is easy to extend to add more functionality. To see the simplicity of maintaining code that uses the state pattern, try a few of these suggestions:</source>
          <target state="translated">La implementación usando el patrón de estado es fácil de extender para añadir más funcionalidad.Para ver la simplicidad de mantener el código que utiliza el patrón de estado,pruebe algunas de estas sugerencias:</target>
        </trans-unit>
        <trans-unit id="57e5372af92c8ddd71806b33dbda4afe86f48e3e" translate="yes" xml:space="preserve">
          <source>The implementing type within a &lt;a href=&quot;keyword.trait&quot;&gt;&lt;code&gt;trait&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;keyword.impl&quot;&gt;&lt;code&gt;impl&lt;/code&gt;&lt;/a&gt; block, or the current type within a type definition.</source>
          <target state="translated">El tipo de implementaci&amp;oacute;n dentro de un &lt;a href=&quot;keyword.trait&quot;&gt; &lt;code&gt;trait&lt;/code&gt; &lt;/a&gt; o bloque &lt;a href=&quot;keyword.impl&quot;&gt; &lt;code&gt;impl&lt;/code&gt; &amp;iacute;cito&lt;/a&gt; , o el tipo actual dentro de una definici&amp;oacute;n de tipo.</target>
        </trans-unit>
        <trans-unit id="9972687dbff5abd8f4ecb962303ef66ce3678542" translate="yes" xml:space="preserve">
          <source>The index ranges returned by this trait are not required to exactly match those of the forward search in reverse.</source>
          <target state="translated">Los rangos de índice devueltos por este rasgo no se requieren para que coincidan exactamente con los de la búsqueda hacia adelante en reversa.</target>
        </trans-unit>
        <trans-unit id="fb8e7f22599fed31a57edfd5bc4f1d4fe1de7766" translate="yes" xml:space="preserve">
          <source>The indexed operand of an array indexing expression.</source>
          <target state="translated">El operando indexado de una expresión de indexación de matrices.</target>
        </trans-unit>
        <trans-unit id="8a276159145a3d291ba8902040d397309a6a3910" translate="yes" xml:space="preserve">
          <source>The inferred type asks the compiler to infer the type if possible based on the surrounding information available. It cannot be used in item signatures. It is often used in generic arguments:</source>
          <target state="translated">El tipo inferido pide al compilador que infiera el tipo si es posible basándose en la información disponible del entorno.No puede ser usado en firmas de artículos.Se utiliza a menudo en argumentos genéricos:</target>
        </trans-unit>
        <trans-unit id="1b63924c7210ee52ef50642e7b6012f573489c1d" translate="yes" xml:space="preserve">
          <source>The inherent methods of &lt;code&gt;Rc&lt;/code&gt; are all associated functions, which means that you have to call them as e.g., &lt;a href=&quot;#method.get_mut&quot;&gt;&lt;code&gt;Rc::get_mut(&amp;amp;mut value)&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;value.get_mut()&lt;/code&gt;. This avoids conflicts with methods of the inner type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Los m&amp;eacute;todos inherentes de &lt;code&gt;Rc&lt;/code&gt; son todas funciones asociadas, lo que significa que debe llamarlas como, por ejemplo, &lt;a href=&quot;#method.get_mut&quot;&gt; &lt;code&gt;Rc::get_mut(&amp;amp;mut value)&lt;/code&gt; &lt;/a&gt; lugar de &lt;code&gt;value.get_mut()&lt;/code&gt; . Esto evita conflictos con m&amp;eacute;todos del tipo interior &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cdd48be31dd031602338fabd7f9987080846befd" translate="yes" xml:space="preserve">
          <source>The inherent methods of &lt;code&gt;Rc&lt;/code&gt; are all associated functions, which means that you have to call them as e.g., &lt;a href=&quot;struct.rc#method.get_mut&quot;&gt;&lt;code&gt;Rc::get_mut(&amp;amp;mut value)&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;value.get_mut()&lt;/code&gt;. This avoids conflicts with methods of the inner type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9a135c5b11a6bdd25cebdf7bee36ffe6f4a888e" translate="yes" xml:space="preserve">
          <source>The initial value is the value the accumulator will have on the first call.</source>
          <target state="translated">El valor inicial es el valor que el acumulador tendrá en la primera llamada.</target>
        </trans-unit>
        <trans-unit id="05cd051eb5f45770d700d15bc2c291712fe7349d" translate="yes" xml:space="preserve">
          <source>The initial value is the value the accumulator will have on the first call. If applying the closure succeeded against every element of the iterator, &lt;code&gt;try_fold()&lt;/code&gt; returns the final accumulator as success.</source>
          <target state="translated">El valor inicial es el valor que tendr&amp;aacute; el acumulador en la primera llamada. Si la aplicaci&amp;oacute;n del cierre tuvo &amp;eacute;xito contra cada elemento del iterador, &lt;code&gt;try_fold()&lt;/code&gt; devuelve el acumulador final como exitoso.</target>
        </trans-unit>
        <trans-unit id="3215ce085488e89e5b23ed55a5028caf27292850" translate="yes" xml:space="preserve">
          <source>The initializer expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="005959a16886789f6cb716c2b5dc5bbb0daa12f9" translate="yes" xml:space="preserve">
          <source>The initializer of</source>
          <target state="translated">El inicializador de</target>
        </trans-unit>
        <trans-unit id="37009e2d28047124f91d44e005708dbff225d4db" translate="yes" xml:space="preserve">
          <source>The initializer of a &lt;a href=&quot;statements#let-statements&quot;&gt;let statement&lt;/a&gt;.</source>
          <target state="translated">El inicializador de una &lt;a href=&quot;statements#let-statements&quot;&gt;sentencia let&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b9db1fa1a8ca22dc3f22f48be8f2cc5fef02b51c" translate="yes" xml:space="preserve">
          <source>The input &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is the token stream of the item that has the &lt;code&gt;derive&lt;/code&gt; attribute on it. The output &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; must be a set of items that are then appended to the &lt;a href=&quot;items/modules&quot;&gt;module&lt;/a&gt; or &lt;a href=&quot;expressions/block-expr&quot;&gt;block&lt;/a&gt; that the item from the input &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is in.</source>
          <target state="translated">El &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; de&lt;/a&gt; entrada es el flujo de tokens del elemento que tiene el atributo &lt;code&gt;derive&lt;/code&gt; . El &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; de&lt;/a&gt; salida debe ser un conjunto de elementos que luego se adjuntan al &lt;a href=&quot;items/modules&quot;&gt;m&amp;oacute;dulo&lt;/a&gt; o &lt;a href=&quot;expressions/block-expr&quot;&gt;bloque en el&lt;/a&gt; que se encuentra el elemento del &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; de&lt;/a&gt; entrada .</target>
        </trans-unit>
        <trans-unit id="3584f2f431d39b47066e06bb0ba2d085c77c3d1e" translate="yes" xml:space="preserve">
          <source>The input iterator &lt;code&gt;replace_with&lt;/code&gt; is only consumed when the &lt;code&gt;Splice&lt;/code&gt; value is dropped.</source>
          <target state="translated">El iterador de entrada &lt;code&gt;replace_with&lt;/code&gt; solo se consume cuando se elimina el valor de &lt;code&gt;Splice&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b45dbdf7cc3adb9c8ff29ad732df76183eebf5c" translate="yes" xml:space="preserve">
          <source>The installation of Rust also includes a copy of the documentation locally, so you can read it offline. Run &lt;code&gt;rustup doc&lt;/code&gt; to open the local documentation in your browser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c198c64d60547785c3da652e9852896f77fa00d7" translate="yes" xml:space="preserve">
          <source>The installation script automatically adds Rust to your system PATH after your next login. If you want to start using Rust right away instead of restarting your terminal, run the following command in your shell to add Rust to your system PATH manually:</source>
          <target state="translated">El script de instalación añade automáticamente Rust a tu sistema PATH después de tu próximo ingreso.Si desea comenzar a usar Rust de inmediato en lugar de reiniciar su terminal,ejecute el siguiente comando en su shell para agregar Rust al PATH del sistema manualmente:</target>
        </trans-unit>
        <trans-unit id="a382c15195dddde8bba4823548e75c4adc802c3c" translate="yes" xml:space="preserve">
          <source>The installer also includes a copy of the documentation locally, so you can read it offline. Run &lt;code&gt;rustup doc&lt;/code&gt; to open the local documentation in your browser.</source>
          <target state="translated">El instalador tambi&amp;eacute;n incluye una copia de la documentaci&amp;oacute;n localmente, para que pueda leerla sin conexi&amp;oacute;n. Ejecute &lt;code&gt;rustup doc&lt;/code&gt; para abrir la documentaci&amp;oacute;n local en su navegador.</target>
        </trans-unit>
        <trans-unit id="eb4481a6d93414e0e2ed7586ff1e0910b51585be" translate="yes" xml:space="preserve">
          <source>The integral types provide inherent methods to allow programmers explicitly to perform wrapping arithmetic. For example, &lt;code&gt;i32::wrapping_add&lt;/code&gt; provides two's complement, wrapping addition.</source>
          <target state="translated">Los tipos integrales proporcionan m&amp;eacute;todos inherentes para permitir a los programadores realizar expl&amp;iacute;citamente aritm&amp;eacute;tica de envoltura. Por ejemplo, &lt;code&gt;i32::wrapping_add&lt;/code&gt; proporciona complemento de dos, suma de envoltura.</target>
        </trans-unit>
        <trans-unit id="a2f153ef163d784268a26bcb041875def3bd700b" translate="yes" xml:space="preserve">
          <source>The integration tests section starts with the line &lt;code&gt;Running target/debug/deps/integration_test-ce99bcc2479f4607&lt;/code&gt; (the hash at the end of your output will be different). Next, there is a line for each test function in that integration test and a summary line for the results of the integration test just before the &lt;code&gt;Doc-tests adder&lt;/code&gt; section starts.</source>
          <target state="translated">La secci&amp;oacute;n de pruebas de integraci&amp;oacute;n comienza con la l&amp;iacute;nea &lt;code&gt;Running target/debug/deps/integration_test-ce99bcc2479f4607&lt;/code&gt; (el hash al final de tu salida ser&amp;aacute; diferente). A continuaci&amp;oacute;n, hay una l&amp;iacute;nea para cada funci&amp;oacute;n de prueba en esa prueba de integraci&amp;oacute;n y una l&amp;iacute;nea de resumen para los resultados de la prueba de integraci&amp;oacute;n justo antes de que comience la secci&amp;oacute;n &lt;code&gt;Doc-tests adder&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c8b39dac0f0603ab0205cf2bfd1df712c7506c4" translate="yes" xml:space="preserve">
          <source>The intention is that the underlying data is only valid for the lifetime &lt;code&gt;'a&lt;/code&gt;, so &lt;code&gt;Slice&lt;/code&gt; should not outlive &lt;code&gt;'a&lt;/code&gt;. However, this intent is not expressed in the code, since there are no uses of the lifetime &lt;code&gt;'a&lt;/code&gt; and hence it is not clear what data it applies to. We can correct this by telling the compiler to act &lt;em&gt;as if&lt;/em&gt; the &lt;code&gt;Slice&lt;/code&gt; struct contained a reference &lt;code&gt;&amp;amp;'a T&lt;/code&gt;:</source>
          <target state="translated">La intenci&amp;oacute;n es que los datos subyacentes solo sean v&amp;aacute;lidos durante la vida &amp;uacute;til &lt;code&gt;'a&lt;/code&gt; , por lo que &lt;code&gt;Slice&lt;/code&gt; no deber&amp;iacute;a sobrevivir a &lt;code&gt;'a&lt;/code&gt; . Sin embargo, esta intenci&amp;oacute;n no se expresa en el c&amp;oacute;digo, ya que no hay usos de la vida &amp;uacute;til &lt;code&gt;'a&lt;/code&gt; ay, por lo tanto, no est&amp;aacute; claro a qu&amp;eacute; datos se aplica. Podemos corregir esto dici&amp;eacute;ndole al compilador que act&amp;uacute;e &lt;em&gt;como si&lt;/em&gt; la estructura &lt;code&gt;Slice&lt;/code&gt; contuviera una referencia &lt;code&gt;&amp;amp;'a T&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c6ec3ee71b429b0c861d2949630c53c1d4103ef2" translate="yes" xml:space="preserve">
          <source>The internal algorithm is not specified, and so it and its hashes should not be relied upon over releases.</source>
          <target state="translated">El algoritmo interno no está especificado,por lo que no se debe confiar en él ni en sus hashes por encima de las liberaciones.</target>
        </trans-unit>
        <trans-unit id="c411eb080c209397146b14ba5a4bb34e75cec138" translate="yes" xml:space="preserve">
          <source>The internal buffer is written out before returning the writer.</source>
          <target state="translated">El buffer interno se escribe antes de devolver al escritor.</target>
        </trans-unit>
        <trans-unit id="06716cd4a735b362271ebfeb2853eaa89b39ee1b" translate="yes" xml:space="preserve">
          <source>The internal iterator over the argument has not been advanced by the time the first &lt;code&gt;{}&lt;/code&gt; is seen, so it prints the first argument. Then upon reaching the second &lt;code&gt;{}&lt;/code&gt;, the iterator has advanced forward to the second argument. Essentially, parameters that explicitly name their argument do not affect parameters that do not name an argument in terms of positional specifiers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce78ff22afeda7a6f00a6ca8444175752d52c4ff" translate="yes" xml:space="preserve">
          <source>The internal iterator over the argument has not been advanced by the time the first &lt;code&gt;{}&lt;/code&gt; is seen, so it prints the first argument. Then upon reaching the second &lt;code&gt;{}&lt;/code&gt;, the iterator has advanced forward to the second argument. Essentially, parameters which explicitly name their argument do not affect parameters which do not name an argument in terms of positional specifiers.</source>
          <target state="translated">El iterador interno sobre el argumento no ha avanzado en el momento en que se ve el primer &lt;code&gt;{}&lt;/code&gt; , por lo que imprime el primer argumento. Luego, al llegar al segundo &lt;code&gt;{}&lt;/code&gt; , el iterador avanz&amp;oacute; hasta el segundo argumento. Esencialmente, los par&amp;aacute;metros que nombran expl&amp;iacute;citamente su argumento no afectan los par&amp;aacute;metros que no nombran un argumento en t&amp;eacute;rminos de especificadores posicionales.</target>
        </trans-unit>
        <trans-unit id="2c46dda1624f616f75baf2894d6d6e54ab12f317" translate="yes" xml:space="preserve">
          <source>The inverse of this method is &lt;a href=&quot;#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El inverso de este m&amp;eacute;todo es &lt;a href=&quot;#method.from_utf8&quot;&gt; &lt;code&gt;from_utf8&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dbc762f2fb2ae9279c20887c42fbcb66ef8ed68d" translate="yes" xml:space="preserve">
          <source>The inverse of this method is &lt;a href=&quot;struct.string#method.as_bytes&quot;&gt;&lt;code&gt;as_bytes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El inverso de este m&amp;eacute;todo es &lt;a href=&quot;struct.string#method.as_bytes&quot;&gt; &lt;code&gt;as_bytes&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2ef5a2c8bf418a538796f28bdc7b3ed8b4214bec" translate="yes" xml:space="preserve">
          <source>The inverse of this method is &lt;a href=&quot;struct.string#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00033d91f205bb0450cf7878d82bad2da288007b" translate="yes" xml:space="preserve">
          <source>The inverse of this method is &lt;a href=&quot;struct.string#method.into_bytes&quot;&gt;&lt;code&gt;into_bytes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d5754a49ec3bccb9874e0108120d01b2fee9ec9" translate="yes" xml:space="preserve">
          <source>The issue can be resolved by changing the associated type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2057c4ad17ebd71c1902c8394bd83a7474bbd6d5" translate="yes" xml:space="preserve">
          <source>The issue in this case is that &lt;code&gt;foo&lt;/code&gt; is defined as accepting a &lt;code&gt;Fn&lt;/code&gt; with one argument of type &lt;code&gt;String&lt;/code&gt;, but the closure we attempted to pass to it requires one arguments of type &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">El problema en este caso es que &lt;code&gt;foo&lt;/code&gt; se define como la aceptaci&amp;oacute;n de una &lt;code&gt;Fn&lt;/code&gt; con un argumento de tipo &lt;code&gt;String&lt;/code&gt; , pero el cierre que intentamos pasar requiere un argumento de tipo &lt;code&gt;usize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c02789dc84a563007f1b001c6388d43c1756fd64" translate="yes" xml:space="preserve">
          <source>The issue with the tuple code in Listing 4-5 is that we have to return the &lt;code&gt;String&lt;/code&gt; to the calling function so we can still use the &lt;code&gt;String&lt;/code&gt; after the call to &lt;code&gt;calculate_length&lt;/code&gt;, because the &lt;code&gt;String&lt;/code&gt; was moved into &lt;code&gt;calculate_length&lt;/code&gt;.</source>
          <target state="translated">El problema con el c&amp;oacute;digo de tupla en el Listado 4-5 es que tenemos que devolver la &lt;code&gt;String&lt;/code&gt; a la funci&amp;oacute;n de llamada para que podamos seguir usando la &lt;code&gt;String&lt;/code&gt; despu&amp;eacute;s de la llamada a &lt;code&gt;calculate_length&lt;/code&gt; , porque la &lt;code&gt;String&lt;/code&gt; se movi&amp;oacute; a &lt;code&gt;calculate_length&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1013a496d8eb9ca295e23a82f7ffaec17e1ba13a" translate="yes" xml:space="preserve">
          <source>The issue with this code is evident in the signature of &lt;code&gt;area&lt;/code&gt;:</source>
          <target state="translated">El problema con este c&amp;oacute;digo es evidente en la firma del &lt;code&gt;area&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e382444929f7f8a00ff868439efd08f11891e2df" translate="yes" xml:space="preserve">
          <source>The items of marker traits cannot be overridden, so there's no need to have them when they cannot be changed per-type anyway. If you wanted them for ergonomic reasons, consider making an extension trait instead.</source>
          <target state="translated">Los elementos de los rasgos marcadores no pueden ser anulados,por lo que no hay necesidad de tenerlos cuando no pueden ser cambiados por tipo de todos modos.Si los quieres por razones ergonómicas,considera hacer un rasgo de extensión en su lugar.</target>
        </trans-unit>
        <trans-unit id="5e506ce8ee681f90bb70782d8bb4d2dad5bd0685" translate="yes" xml:space="preserve">
          <source>The iterator element type is &lt;a href=&quot;../path/struct.pathbuf&quot;&gt;&lt;code&gt;PathBuf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El tipo de elemento iterador es &lt;a href=&quot;../path/struct.pathbuf&quot;&gt; &lt;code&gt;PathBuf&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6824e2e2ab7393d35f45cbd58638289d41c35be1" translate="yes" xml:space="preserve">
          <source>The iterator must produce exactly the number of elements it reported or diverge before reaching the end.</source>
          <target state="translated">El iterador debe producir exactamente el número de elementos que ha reportado o divergir antes de llegar al final.</target>
        </trans-unit>
        <trans-unit id="857086b346b7dd5e8adf55ad86cbe1dbbf8cbe54" translate="yes" xml:space="preserve">
          <source>The iterator pattern allows you to perform some task on a sequence of items in turn. An iterator is responsible for the logic of iterating over each item and determining when the sequence has finished. When you use iterators, you don&amp;rsquo;t have to reimplement that logic yourself.</source>
          <target state="translated">El patr&amp;oacute;n de iterador le permite realizar alguna tarea en una secuencia de elementos a su vez. Un iterador es responsable de la l&amp;oacute;gica de iterar sobre cada elemento y determinar cu&amp;aacute;ndo ha terminado la secuencia. Cuando usa iteradores, no tiene que volver a implementar esa l&amp;oacute;gica usted mismo.</target>
        </trans-unit>
        <trans-unit id="6db07328b493618fb3fe592624d4f327dc32ce7b" translate="yes" xml:space="preserve">
          <source>The iterator reports a size hint where it is either exact (lower bound is equal to upper bound), or the upper bound is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. The upper bound must only be &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the actual iterator length is larger than &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt;. In that case, the lower bound must be &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt;, resulting in a &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;.size_hint&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;(usize::MAX, None)&lt;/code&gt;.</source>
          <target state="translated">El iterador informa una sugerencia de tama&amp;ntilde;o donde es exacto (el l&amp;iacute;mite inferior es igual al l&amp;iacute;mite superior) o el l&amp;iacute;mite superior es &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; . El l&amp;iacute;mite superior solo debe ser &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; si la longitud real del iterador es mayor que &lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt; . En ese caso, el l&amp;iacute;mite inferior debe ser &lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt; , lo que da como resultado un &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;.size_hint&lt;/code&gt; &lt;/a&gt; de &lt;code&gt;(usize::MAX, None)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="761f99bb11c75b1d69af8441ba4ad3812f9ffc53" translate="yes" xml:space="preserve">
          <source>The iterator reports a size hint where it is either exact (lower bound is equal to upper bound), or the upper bound is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. The upper bound must only be &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the actual iterator length is larger than &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt;. In that case, the lower bound must be &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt;, resulting in a &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;Iterator::size_hint()&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;(usize::MAX, None)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5b68d7a8101dc216e0d59f65c1ebaa471e720b2" translate="yes" xml:space="preserve">
          <source>The iterator returned from this function will return instances of &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. Each vector returned will &lt;em&gt;not&lt;/em&gt; have the delimiter byte at the end.</source>
          <target state="translated">El iterador devuelto por esta funci&amp;oacute;n devolver&amp;aacute; instancias de &lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; . Cada vector devuelto &lt;em&gt;no&lt;/em&gt; tendr&amp;aacute; el byte delimitador al final.</target>
        </trans-unit>
        <trans-unit id="43d518530c9a6385f97f5ea0cf3b95e6447ddfae" translate="yes" xml:space="preserve">
          <source>The iterator returned from this function will yield instances of &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. Each string returned will &lt;em&gt;not&lt;/em&gt; have a newline byte (the 0xA byte) or CRLF (0xD, 0xA bytes) at the end.</source>
          <target state="translated">El iterador devuelto por esta funci&amp;oacute;n producir&amp;aacute; instancias de &lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; . Cada cadena devuelta &lt;em&gt;no&lt;/em&gt; tendr&amp;aacute; un byte de nueva l&amp;iacute;nea (el byte 0xA) o CRLF (0xD, 0xA bytes) al final.</target>
        </trans-unit>
        <trans-unit id="11be39dc954e81f8e71f68fa0b756ad22ee17df7" translate="yes" xml:space="preserve">
          <source>The iterator returned from this function will yield instances of &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. Each string returned will &lt;em&gt;not&lt;/em&gt; have a newline byte (the &lt;code&gt;0xA&lt;/code&gt; byte) or &lt;code&gt;CRLF&lt;/code&gt; (&lt;code&gt;0xD&lt;/code&gt;, &lt;code&gt;0xA&lt;/code&gt; bytes) at the end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d98222c90db1c99a084846a0ad925665e5230738" translate="yes" xml:space="preserve">
          <source>The iterator returned will return string slices that are sub-slices of the original string slice, separated by any amount of ASCII whitespace.</source>
          <target state="translated">El iterador devuelto devolverá rebanadas de cadena que son sub-rebanadas de la rebanada de cadena original,separadas por cualquier cantidad de espacio blanco ASCII.</target>
        </trans-unit>
        <trans-unit id="406100c150ec04008e29a14c30e99aed0f63af21" translate="yes" xml:space="preserve">
          <source>The iterator returned will return string slices that are sub-slices of the original string slice, separated by any amount of whitespace.</source>
          <target state="translated">El iterador devuelto devolverá rebanadas de cadena que son sub-rebanadas de la rebanada de cadena original,separadas por cualquier cantidad de espacio en blanco.</target>
        </trans-unit>
        <trans-unit id="4221546e7793ded4aa41dc1718c0ee56c99339b5" translate="yes" xml:space="preserve">
          <source>The iterator returned yields pairs &lt;code&gt;(i, val)&lt;/code&gt;, where &lt;code&gt;i&lt;/code&gt; is the current index of iteration and &lt;code&gt;val&lt;/code&gt; is the value returned by the iterator.</source>
          <target state="translated">El iterador devuelto produce pares &lt;code&gt;(i, val)&lt;/code&gt; , donde &lt;code&gt;i&lt;/code&gt; es el &amp;iacute;ndice actual de iteraci&amp;oacute;n y &lt;code&gt;val&lt;/code&gt; es el valor devuelto por el iterador.</target>
        </trans-unit>
        <trans-unit id="0d65a2fef7d4c6664fcfb9659495ac349d06a758" translate="yes" xml:space="preserve">
          <source>The iterator starts with the given first item (if any) and calls the given &lt;code&gt;FnMut(&amp;amp;T) -&amp;gt; Option&amp;lt;T&amp;gt;&lt;/code&gt; closure to compute each item&amp;rsquo;s successor.</source>
          <target state="translated">El iterador comienza con el primer elemento dado (si lo hay) y llama al &lt;code&gt;FnMut(&amp;amp;T) -&amp;gt; Option&amp;lt;T&amp;gt;&lt;/code&gt; dado para calcular el sucesor de cada elemento.</target>
        </trans-unit>
        <trans-unit id="fe7ef8d083d96a8372351bad5e0da1e04819839b" translate="yes" xml:space="preserve">
          <source>The iterator version was slightly faster! We won&amp;rsquo;t explain the benchmark code here, because the point is not to prove that the two versions are equivalent but to get a general sense of how these two implementations compare performance-wise.</source>
          <target state="translated">&amp;iexcl;La versi&amp;oacute;n iteradora fue un poco m&amp;aacute;s r&amp;aacute;pida! No explicaremos el c&amp;oacute;digo de referencia aqu&amp;iacute;, porque el punto no es demostrar que las dos versiones son equivalentes, sino tener una idea general de c&amp;oacute;mo estas dos implementaciones se comparan en t&amp;eacute;rminos de rendimiento.</target>
        </trans-unit>
        <trans-unit id="40a9eac2c27490989d9bce69b525d51e8393ef6d" translate="yes" xml:space="preserve">
          <source>The iterator will never return &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; and will also not yield the peer's &lt;a href=&quot;struct.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; structure.</source>
          <target state="translated">El iterador nunca devolver&amp;aacute; &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; y tampoco &lt;a href=&quot;struct.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt; estructura SocketAddr del par .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
