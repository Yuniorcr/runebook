<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="13381a81af44ee23cac490ae25db16aaac796d46" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search, the &lt;a href=&quot;../primitive.str#method.rsplitn&quot;&gt;&lt;code&gt;rsplitn&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0dc4aae442a85b53102b885d478be980f7d8acb" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search, the &lt;a href=&quot;primitive.str#method.rsplitn&quot;&gt;&lt;code&gt;rsplitn&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41f3c654ebe17619521d5571a243149ab252e55c" translate="yes" xml:space="preserve">
          <source>If the pattern in a &lt;code&gt;let&lt;/code&gt; statement is an extending pattern then the temporary scope of the initializer expression is extended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="973c0cc5d4929bc5f421c4d51b3af832d7dcc650" translate="yes" xml:space="preserve">
          <source>If the pattern is a slice of chars, split on each occurrence of any of the characters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9d4003e7c8cd37da9426d5d4d889d3aaff32c4e" translate="yes" xml:space="preserve">
          <source>If the predicate is true, the thing is rewritten to not have the &lt;code&gt;cfg&lt;/code&gt; attribute on it. If the predicate is false, the thing is removed from the source code.</source>
          <target state="translated">Si el predicado es verdadero, la cosa se reescribe para que no tenga el atributo &lt;code&gt;cfg&lt;/code&gt; . Si el predicado es falso, la cosa se elimina del c&amp;oacute;digo fuente.</target>
        </trans-unit>
        <trans-unit id="9ddbcce981c839ba50c36650f18e74f28c3996cc" translate="yes" xml:space="preserve">
          <source>If the process was terminated by a signal, returns that signal.</source>
          <target state="translated">Si el proceso fue terminado por una señal,devuelve esa señal.</target>
        </trans-unit>
        <trans-unit id="12b3054a5c2c9f1f42244cb5633baa4905430f09" translate="yes" xml:space="preserve">
          <source>If the program context over-constrains the type, it is considered a static type error.</source>
          <target state="translated">Si el contexto del programa restringe demasiado el tipo,se considera un error de tipo estático.</target>
        </trans-unit>
        <trans-unit id="0342ae828ad12df97309a477cf872adf919b1902" translate="yes" xml:space="preserve">
          <source>If the program context under-constrains the type, it defaults to &lt;code&gt;f64&lt;/code&gt;.</source>
          <target state="translated">Si el contexto del programa restringe el tipo, el valor predeterminado es &lt;code&gt;f64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c5273dc0a13c7cc0e077b4b3fa98da50edca969" translate="yes" xml:space="preserve">
          <source>If the program context under-constrains the type, it defaults to the signed 32-bit integer &lt;code&gt;i32&lt;/code&gt;.</source>
          <target state="translated">Si el contexto del programa restringe el tipo, el valor predeterminado es el entero &lt;code&gt;i32&lt;/code&gt; de 32 bits con signo .</target>
        </trans-unit>
        <trans-unit id="46f99ab4b433b6230008eadc71e11c58b7b1e70b" translate="yes" xml:space="preserve">
          <source>If the program path is relative (e.g., &lt;code&gt;&quot;./script.sh&quot;&lt;/code&gt;), it's ambiguous whether it should be interpreted relative to the parent's working directory or relative to &lt;code&gt;current_dir&lt;/code&gt;. The behavior in this case is platform specific and unstable, and it's recommended to use &lt;a href=&quot;../fs/fn.canonicalize&quot;&gt;&lt;code&gt;canonicalize&lt;/code&gt;&lt;/a&gt; to get an absolute program path instead.</source>
          <target state="translated">Si la ruta del programa es relativa (por ejemplo, &lt;code&gt;&quot;./script.sh&quot;&lt;/code&gt; ), es ambiguo si debe interpretarse en relaci&amp;oacute;n con el directorio de trabajo principal o en relaci&amp;oacute;n con &lt;code&gt;current_dir&lt;/code&gt; . El comportamiento en este caso es espec&amp;iacute;fico de la plataforma e inestable, y se recomienda usar &lt;a href=&quot;../fs/fn.canonicalize&quot;&gt; &lt;code&gt;canonicalize&lt;/code&gt; &lt;/a&gt; para obtener una ruta absoluta del programa.</target>
        </trans-unit>
        <trans-unit id="5f463c42ca012031b77b1b6ba6bda1bbf7d242ce" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.recv_from&quot;&gt;&lt;code&gt;recv_from&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">Si el valor proporcionado es &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , las llamadas &lt;a href=&quot;#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#method.recv_from&quot;&gt; &lt;code&gt;recv_from&lt;/code&gt; &lt;/a&gt; se bloquear&amp;aacute;n indefinidamente. Se devuelve un &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; si se pasa la &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; cero a este m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="27457ae3a7ce774b0ba53e72b68851ec71f67265" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.send_to&quot;&gt;&lt;code&gt;send_to&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#Err.v&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">Si el valor proporcionado es &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , las llamadas &lt;a href=&quot;#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#method.send_to&quot;&gt; &lt;code&gt;send_to&lt;/code&gt; &lt;/a&gt; se bloquear&amp;aacute;n indefinidamente. Se devuelve un &lt;a href=&quot;../../../result/enum.result#Err.v&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; si se pasa la &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; cero a este m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="a1795e7946ced7825121511cc106a9015fd798ec" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../../../io/trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">Si el valor proporcionado es &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , las llamadas de &lt;a href=&quot;../../../io/trait.read#tymethod.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; se bloquear&amp;aacute;n indefinidamente. Se devuelve un &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; si se pasa la &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; cero a este m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="e1ea6f1309304cb111df61243a566c96b67b3b82" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../../../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">Si el valor proporcionado es &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , las llamadas de &lt;a href=&quot;../../../io/trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; se bloquear&amp;aacute;n indefinidamente. Se devuelve un &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; si se pasa la &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; cero a este m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="3030eaafa081102fe45631b54a8872f8838c162b" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../../../macro.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e6460df1e81820998680e8eea34159effdca0c0" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;struct.unixdatagram#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.unixdatagram#method.recv_from&quot;&gt;&lt;code&gt;recv_from&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ee71bcd622cfb4833d8d1ba25909dd1554f21bc" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;struct.unixdatagram#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.unixdatagram#method.send_to&quot;&gt;&lt;code&gt;send_to&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02ca5c816748f7e2bf4c21dd7d1f2eac8980aece" translate="yes" xml:space="preserve">
          <source>If the receiver has type &lt;code&gt;&amp;amp;Self&lt;/code&gt; or &lt;code&gt;&amp;amp;mut Self&lt;/code&gt;, then the lifetime of that reference to &lt;code&gt;Self&lt;/code&gt; is assigned to all elided output lifetime parameters.</source>
          <target state="translated">Si el receptor tiene el tipo &lt;code&gt;&amp;amp;Self&lt;/code&gt; o &lt;code&gt;&amp;amp;mut Self&lt;/code&gt; , entonces la vida &amp;uacute;til de esa referencia a &lt;code&gt;Self&lt;/code&gt; se asigna a todos los par&amp;aacute;metros de vida &amp;uacute;til de salida elidos.</target>
        </trans-unit>
        <trans-unit id="87acaebec96dcd891a49b70723f561ac4a00a2ef" translate="yes" xml:space="preserve">
          <source>If the repetition can match zero times (&lt;code&gt;*&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt;), then whatever comes after must be able to follow whatever comes before.</source>
          <target state="translated">Si la repetici&amp;oacute;n puede coincidir con cero veces ( &lt;code&gt;*&lt;/code&gt; o &lt;code&gt;?&lt;/code&gt; ), Lo que venga despu&amp;eacute;s debe poder seguir lo que venga antes.</target>
        </trans-unit>
        <trans-unit id="0c4e89c7ed58ca57a531d68235db3f5dd485fb44" translate="yes" xml:space="preserve">
          <source>If the repetition can repeat multiple times (&lt;code&gt;*&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt;), then the contents must be able to follow themselves.</source>
          <target state="translated">Si la repetici&amp;oacute;n se puede repetir varias veces ( &lt;code&gt;*&lt;/code&gt; o &lt;code&gt;+&lt;/code&gt; ), entonces el contenido debe poder seguirse a s&amp;iacute; mismo.</target>
        </trans-unit>
        <trans-unit id="f0a7f9f74244abd35ce8e1d2208c1f4bd4a178de" translate="yes" xml:space="preserve">
          <source>If the repetition includes a separator, that separator must be able to follow the contents of the repetition.</source>
          <target state="translated">Si la repetición incluye un separador,éste debe ser capaz de seguir el contenido de la repetición.</target>
        </trans-unit>
        <trans-unit id="93fda8c7280ac97a010f00a3edbfb2871f7e4163" translate="yes" xml:space="preserve">
          <source>If the results of this method are only manipulated by the same architecture that produced them, then there is no portability concern.</source>
          <target state="translated">Si los resultados de este método sólo son manipulados por la misma arquitectura que los produjo,entonces no hay preocupación por la portabilidad.</target>
        </trans-unit>
        <trans-unit id="2714df80ed99e7f5046c9baa63d90d1d03b47084" translate="yes" xml:space="preserve">
          <source>If the return value is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(n)&lt;/code&gt;&lt;/a&gt; then it must be guaranteed that &lt;code&gt;0 &amp;lt;= n &amp;lt;= buf.len()&lt;/code&gt;. A return value of &lt;code&gt;0&lt;/code&gt; typically means that the underlying object is no longer able to accept bytes and will likely not be able to in the future as well, or that the buffer provided is empty.</source>
          <target state="translated">Si el valor de retorno es &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(n)&lt;/code&gt; &lt;/a&gt; entonces debe garantizarse que &lt;code&gt;0 &amp;lt;= n &amp;lt;= buf.len()&lt;/code&gt; . Un valor de retorno de &lt;code&gt;0&lt;/code&gt; normalmente significa que el objeto subyacente ya no puede aceptar bytes y probablemente tampoco podr&amp;aacute; hacerlo en el futuro, o que el b&amp;uacute;fer proporcionado est&amp;aacute; vac&amp;iacute;o.</target>
        </trans-unit>
        <trans-unit id="d3bffaa154919c3b8c559f95a11e7d99a1c962cc" translate="yes" xml:space="preserve">
          <source>If the return value is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(n)&lt;/code&gt;&lt;/a&gt; then it must be guaranteed that &lt;code&gt;n &amp;lt;= buf.len()&lt;/code&gt;. A return value of &lt;code&gt;0&lt;/code&gt; typically means that the underlying object is no longer able to accept bytes and will likely not be able to in the future as well, or that the buffer provided is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d8a15b3b50cba05982491cd9452366b174a6982" translate="yes" xml:space="preserve">
          <source>If the return value of this method is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(n)&lt;/code&gt;&lt;/a&gt;, then it must be guaranteed that &lt;code&gt;0 &amp;lt;= n &amp;lt;= buf.len()&lt;/code&gt;. A nonzero &lt;code&gt;n&lt;/code&gt; value indicates that the buffer &lt;code&gt;buf&lt;/code&gt; has been filled in with &lt;code&gt;n&lt;/code&gt; bytes of data from this source. If &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, then it can indicate one of two scenarios:</source>
          <target state="translated">Si el valor de retorno de este m&amp;eacute;todo es &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(n)&lt;/code&gt; &lt;/a&gt; , entonces debe garantizarse que &lt;code&gt;0 &amp;lt;= n &amp;lt;= buf.len()&lt;/code&gt; . Un valor &lt;code&gt;n&lt;/code&gt; distinto de cero indica que el b&amp;uacute;fer &lt;code&gt;buf&lt;/code&gt; se ha llenado con &lt;code&gt;n&lt;/code&gt; bytes de datos de esta fuente. Si &lt;code&gt;n&lt;/code&gt; es &lt;code&gt;0&lt;/code&gt; , entonces puede indicar uno de dos escenarios:</target>
        </trans-unit>
        <trans-unit id="ded67fe7a6c072a895832d05a296084ac3d461ad" translate="yes" xml:space="preserve">
          <source>If the seek operation completed successfully, this method returns the new position from the start of the stream. That position can be used later with &lt;a href=&quot;enum.seekfrom#variant.Start&quot;&gt;&lt;code&gt;SeekFrom::Start&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si la operaci&amp;oacute;n de b&amp;uacute;squeda se complet&amp;oacute; correctamente, este m&amp;eacute;todo devuelve la nueva posici&amp;oacute;n desde el inicio de la transmisi&amp;oacute;n. Esa posici&amp;oacute;n se puede usar m&amp;aacute;s tarde con &lt;a href=&quot;enum.seekfrom#variant.Start&quot;&gt; &lt;code&gt;SeekFrom::Start&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="40a290f3a15c2cd192fbe0ef4a0681d5f1afa2a2" translate="yes" xml:space="preserve">
          <source>If the set did have this value present, &lt;code&gt;false&lt;/code&gt; is returned, and the entry is not updated. See the &lt;a href=&quot;index#insert-and-complex-keys&quot;&gt;module-level documentation&lt;/a&gt; for more.</source>
          <target state="translated">Si el conjunto ten&amp;iacute;a este valor presente, se devuelve &lt;code&gt;false&lt;/code&gt; y la entrada no se actualiza. Consulte la &lt;a href=&quot;index#insert-and-complex-keys&quot;&gt;documentaci&amp;oacute;n a nivel de m&amp;oacute;dulo&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="94e9a109c03e48a1d66a80ba76a8cd1667e1c88c" translate="yes" xml:space="preserve">
          <source>If the set did have this value present, &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">Si el conjunto ten&amp;iacute;a este valor presente, se devuelve &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bf8ca60d7471ccc5d2a042445134f6d59f07692" translate="yes" xml:space="preserve">
          <source>If the set did not have this value present, &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">Si el conjunto no ten&amp;iacute;a este valor presente, se devuelve &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f392e4742f25190cbf5e3351752daf379a0be61" translate="yes" xml:space="preserve">
          <source>If the slice does not end with &lt;code&gt;suffix&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d43a87008e53f4a6466f036fda4975d20f3ad011" translate="yes" xml:space="preserve">
          <source>If the slice does not start with &lt;code&gt;prefix&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ad3d774a6e0ccaa727d17e721cc10badd0ba8e6" translate="yes" xml:space="preserve">
          <source>If the slice ends with &lt;code&gt;suffix&lt;/code&gt;, returns the subslice before the suffix, wrapped in &lt;code&gt;Some&lt;/code&gt;. If &lt;code&gt;suffix&lt;/code&gt; is empty, simply returns the original slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f83ff10b230425401b084d2888a7c546a452e490" translate="yes" xml:space="preserve">
          <source>If the slice is shorter than &lt;code&gt;size&lt;/code&gt;:</source>
          <target state="translated">Si la rebanada es m&amp;aacute;s corta que el &lt;code&gt;size&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1412fa3c4897cefe27e1dd8f5c2bdb81e3843fe2" translate="yes" xml:space="preserve">
          <source>If the slice is sorted, the first returned slice contains no duplicates.</source>
          <target state="translated">Si la rebanada se clasifica,la primera rebanada devuelta no contiene duplicados.</target>
        </trans-unit>
        <trans-unit id="c27d8278e5200cca20b3d013d5698cf10c18fe2f" translate="yes" xml:space="preserve">
          <source>If the slice starts with &lt;code&gt;prefix&lt;/code&gt;, returns the subslice after the prefix, wrapped in &lt;code&gt;Some&lt;/code&gt;. If &lt;code&gt;prefix&lt;/code&gt; is empty, simply returns the original slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7500b2ee92288b054ccbb9cf159239611040c00" translate="yes" xml:space="preserve">
          <source>If the socket isn't connected, it will return a &lt;a href=&quot;../io/enum.errorkind#variant.NotConnected&quot;&gt;&lt;code&gt;NotConnected&lt;/code&gt;&lt;/a&gt; error.</source>
          <target state="translated">Si el enchufe no est&amp;aacute; conectado, devolver&amp;aacute; un error &lt;a href=&quot;../io/enum.errorkind#variant.NotConnected&quot;&gt; &lt;code&gt;NotConnected&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="49c9a191f32deb0b74107f0ae0391ae8d0b43b7a" translate="yes" xml:space="preserve">
          <source>If the source and destination will &lt;em&gt;never&lt;/em&gt; overlap, &lt;a href=&quot;../ptr/fn.copy_nonoverlapping&quot;&gt;&lt;code&gt;copy_nonoverlapping&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78527ed1205c7d745b52b60ade93722ffae3f052" translate="yes" xml:space="preserve">
          <source>If the source and destination will &lt;em&gt;never&lt;/em&gt; overlap, &lt;a href=&quot;fn.copy_nonoverlapping&quot;&gt;&lt;code&gt;copy_nonoverlapping&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="translated">Si el origen y el destino &lt;em&gt;nunca se&lt;/em&gt; superponen, se puede utilizar &lt;a href=&quot;fn.copy_nonoverlapping&quot;&gt; &lt;code&gt;copy_nonoverlapping&lt;/code&gt; en&lt;/a&gt; su lugar.</target>
        </trans-unit>
        <trans-unit id="4361232c2009840823276ea8357ba262f43a3b14" translate="yes" xml:space="preserve">
          <source>If the string does not end with &lt;code&gt;suffix&lt;/code&gt;, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00699a6c688425007189014e64bb10c087e7cc42" translate="yes" xml:space="preserve">
          <source>If the string does not end with &lt;code&gt;suffix&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fd5dbdb681a59cb1a332e76b0649dd3b10de31e" translate="yes" xml:space="preserve">
          <source>If the string does not start with &lt;code&gt;prefix&lt;/code&gt;, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4c5d3aa960799aefa6afdc31361ee8f07d50151" translate="yes" xml:space="preserve">
          <source>If the string does not start with &lt;code&gt;prefix&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39245347359d8114b8b3a102418b227e0b5a250d" translate="yes" xml:space="preserve">
          <source>If the string ends with the pattern &lt;code&gt;suffix&lt;/code&gt;, &lt;code&gt;Some&lt;/code&gt; is returned with the substring where the suffix is removed. Unlike &lt;code&gt;trim_end_matches&lt;/code&gt;, this method removes the suffix exactly once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73e6ef23293e24078530c7881fe300a2cd50dbd2" translate="yes" xml:space="preserve">
          <source>If the string ends with the pattern &lt;code&gt;suffix&lt;/code&gt;, returns the substring before the suffix, wrapped in &lt;code&gt;Some&lt;/code&gt;. Unlike &lt;code&gt;trim_end_matches&lt;/code&gt;, this method removes the suffix exactly once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daa8bca77eb9444573d0ec6c5903975dcf9aaa55" translate="yes" xml:space="preserve">
          <source>If the string starts with the pattern &lt;code&gt;prefix&lt;/code&gt;, &lt;code&gt;Some&lt;/code&gt; is returned with the substring where the prefix is removed. Unlike &lt;code&gt;trim_start_matches&lt;/code&gt;, this method removes the prefix exactly once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2971983ae4e5fda25d513b0c8f02476f9d89865" translate="yes" xml:space="preserve">
          <source>If the string starts with the pattern &lt;code&gt;prefix&lt;/code&gt;, returns substring after the prefix, wrapped in &lt;code&gt;Some&lt;/code&gt;. Unlike &lt;code&gt;trim_start_matches&lt;/code&gt;, this method removes the prefix exactly once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddcbef4bcc4007d5bd1893bc755dafa184d9df1c" translate="yes" xml:space="preserve">
          <source>If the timeout is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; calls will block indefinitely.</source>
          <target state="translated">Si el tiempo de espera es &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , las llamadas de &lt;a href=&quot;../io/trait.read#tymethod.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; se bloquear&amp;aacute;n indefinidamente.</target>
        </trans-unit>
        <trans-unit id="071f9fdeaf91e92bcf2267f9e0f60277f6bcc97e" translate="yes" xml:space="preserve">
          <source>If the timeout is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; calls will block indefinitely.</source>
          <target state="translated">Si el tiempo de espera es &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , las llamadas de &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; se bloquear&amp;aacute;n indefinidamente.</target>
        </trans-unit>
        <trans-unit id="86ffa0ca9fede5aea50d7e731aa1e556c2cfcb06" translate="yes" xml:space="preserve">
          <source>If the trait &lt;code&gt;Foo&lt;/code&gt; was deriving from something like &lt;code&gt;Super&amp;lt;String&amp;gt;&lt;/code&gt; or &lt;code&gt;Super&amp;lt;T&amp;gt;&lt;/code&gt; (where &lt;code&gt;Foo&lt;/code&gt; itself is &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt;), this is okay, because given a type &lt;code&gt;get_a()&lt;/code&gt; will definitely return an object of that type.</source>
          <target state="translated">Si el rasgo &lt;code&gt;Foo&lt;/code&gt; se deriva de algo como &lt;code&gt;Super&amp;lt;String&amp;gt;&lt;/code&gt; o &lt;code&gt;Super&amp;lt;T&amp;gt;&lt;/code&gt; (donde &lt;code&gt;Foo&lt;/code&gt; mismo es &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; ), esto est&amp;aacute; bien, porque dado un tipo &lt;code&gt;get_a()&lt;/code&gt; definitivamente devolver&amp;aacute; un objeto de ese tipo.</target>
        </trans-unit>
        <trans-unit id="59d15c0755f3a894e4c73cfbee908b72296e216e" translate="yes" xml:space="preserve">
          <source>If the trait &lt;code&gt;Trait&lt;/code&gt; was deriving from something like &lt;code&gt;Super&amp;lt;String&amp;gt;&lt;/code&gt; or &lt;code&gt;Super&amp;lt;T&amp;gt;&lt;/code&gt; (where &lt;code&gt;Foo&lt;/code&gt; itself is &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt;), this is okay, because given a type &lt;code&gt;get_a()&lt;/code&gt; will definitely return an object of that type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3977c8ff69bc736e667f7951c5a2e7ce42dc78b" translate="yes" xml:space="preserve">
          <source>If the trait has no lifetime bounds, then the lifetime is inferred in expressions and is &lt;code&gt;'static&lt;/code&gt; outside of expressions.</source>
          <target state="translated">Si el rasgo no tiene l&amp;iacute;mites de duraci&amp;oacute;n, entonces la duraci&amp;oacute;n se infiere en expresiones y es &lt;code&gt;'static&lt;/code&gt; fuera de las expresiones'.</target>
        </trans-unit>
        <trans-unit id="91f2e745c85e0029a493a85d365496779bca0a85" translate="yes" xml:space="preserve">
          <source>If the trait is defined with a single lifetime &lt;em&gt;bound&lt;/em&gt; then that bound is used.</source>
          <target state="translated">Si el rasgo se define con un &amp;uacute;nico &lt;em&gt;l&amp;iacute;mite de por&lt;/em&gt; vida, se utiliza ese l&amp;iacute;mite.</target>
        </trans-unit>
        <trans-unit id="357e0325de10f1713bb7e2ce24ee991bac9ba465" translate="yes" xml:space="preserve">
          <source>If the trait object is used as a type argument of a generic type then the containing type is first used to try to infer a bound.</source>
          <target state="translated">Si el objeto de rasgo se utiliza como argumento de tipo de un tipo genérico,entonces el tipo que lo contiene se utiliza primero para tratar de inferir un límite.</target>
        </trans-unit>
        <trans-unit id="560d3597e83d956d002972f4abc002a7d2adb557" translate="yes" xml:space="preserve">
          <source>If the type of the &lt;code&gt;self&lt;/code&gt; parameter is specified, it is limited to one of the following types:</source>
          <target state="translated">Si se especifica el tipo de par&amp;aacute;metro &lt;code&gt;self&lt;/code&gt; , se limita a uno de los siguientes tipos:</target>
        </trans-unit>
        <trans-unit id="9d09dbe4faca02efaba3f848374123e962d67442" translate="yes" xml:space="preserve">
          <source>If the type of the &lt;code&gt;self&lt;/code&gt; parameter is specified, it is limited to types resolving to one generated by the following grammar (where &lt;code&gt;'lt&lt;/code&gt; denotes some arbitrary lifetime):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce48e604713fdd5d1a45036f133935186dfa1172" translate="yes" xml:space="preserve">
          <source>If the type parameter was included by mistake, this error can be fixed by simply removing the type parameter, as shown below:</source>
          <target state="translated">Si el parámetro del tipo fue incluido por error,este error puede ser corregido simplemente quitando el parámetro del tipo,como se muestra a continuación:</target>
        </trans-unit>
        <trans-unit id="518ddacd66d25987845bcd6f93021680b5c6a782" translate="yes" xml:space="preserve">
          <source>If the underlying data is &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#method.into_inner&quot;&gt;&lt;code&gt;Pin::into_inner&lt;/code&gt;&lt;/a&gt; should be used instead.</source>
          <target state="translated">Si los datos subyacentes son &lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#method.into_inner&quot;&gt; &lt;code&gt;Pin::into_inner&lt;/code&gt; &lt;/a&gt; debe usarse en su lugar.</target>
        </trans-unit>
        <trans-unit id="d7db2f45fba2c01ea8e6f00a55427c1ac62329ce" translate="yes" xml:space="preserve">
          <source>If the underlying data is &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.pin#method.into_inner&quot;&gt;&lt;code&gt;Pin::into_inner&lt;/code&gt;&lt;/a&gt; should be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6a64661df18427c960804044729f48ac301ae02" translate="yes" xml:space="preserve">
          <source>If the underlying data is &lt;code&gt;Unpin&lt;/code&gt;, &lt;code&gt;Pin::get_mut&lt;/code&gt; should be used instead.</source>
          <target state="translated">Si los datos subyacentes son &lt;code&gt;Unpin&lt;/code&gt; , se debe usar &lt;code&gt;Pin::get_mut&lt;/code&gt; su lugar.</target>
        </trans-unit>
        <trans-unit id="8405b8ad332b999aa219670b74caa5f46b181830" translate="yes" xml:space="preserve">
          <source>If the underlying filesystem does not support creation time, the returned value is 0.</source>
          <target state="translated">Si el sistema de archivos subyacente no soporta el tiempo de creación,el valor devuelto es 0.</target>
        </trans-unit>
        <trans-unit id="413f9b68289dcc8297528df41e0f0feb6ddb8349" translate="yes" xml:space="preserve">
          <source>If the underlying filesystem does not support last access time, the returned value is 0.</source>
          <target state="translated">Si el sistema de archivos subyacente no soporta el último tiempo de acceso,el valor devuelto es 0.</target>
        </trans-unit>
        <trans-unit id="fb7130f0e0ffc326e8ffb3bb43790b19856655f3" translate="yes" xml:space="preserve">
          <source>If the underlying filesystem does not support the last write time, the returned value is 0.</source>
          <target state="translated">Si el sistema de archivos subyacente no soporta el último tiempo de escritura,el valor devuelto es 0.</target>
        </trans-unit>
        <trans-unit id="4282d187fb807509a1857f1a4d0e25b41883c729" translate="yes" xml:space="preserve">
          <source>If the unsized tail of &lt;code&gt;T&lt;/code&gt; is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2800f0b4e13fb2d5eedd5490b06177fdb31e9a98" translate="yes" xml:space="preserve">
          <source>If the user specifies a favorite color, that color is the background color. If today is Tuesday, the background color is green. If the user specifies their age as a string and we can parse it as a number successfully, the color is either purple or orange depending on the value of the number. If none of these conditions apply, the background color is blue.</source>
          <target state="translated">Si el usuario especifica un color favorito,ese color es el color de fondo.Si hoy es martes,el color de fondo es verde.Si el usuario especifica su edad como una cadena y podemos analizarla como un número con éxito,el color es púrpura o naranja dependiendo del valor del número.Si no se aplica ninguna de estas condiciones,el color de fondo es azul.</target>
        </trans-unit>
        <trans-unit id="e4dd9bc072921d826fb4feb5e2064cc014699b96" translate="yes" xml:space="preserve">
          <source>If the user wants a high-intensity workout, there&amp;rsquo;s some additional logic: if the value of the random number generated by the app happens to be 3, the app will recommend a break and hydration. If not, the user will get a number of minutes of running based on the complex algorithm.</source>
          <target state="translated">Si el usuario quiere un entrenamiento de alta intensidad, hay una l&amp;oacute;gica adicional: si el valor del n&amp;uacute;mero aleatorio generado por la aplicaci&amp;oacute;n es 3, la aplicaci&amp;oacute;n recomendar&amp;aacute; un descanso e hidrataci&amp;oacute;n. De lo contrario, el usuario obtendr&amp;aacute; varios minutos de ejecuci&amp;oacute;n en funci&amp;oacute;n del complejo algoritmo.</target>
        </trans-unit>
        <trans-unit id="de326f90242f044e38821476a3f1590bb4fba9d2" translate="yes" xml:space="preserve">
          <source>If the value has to be borrowed and then moved, try limiting the lifetime of the borrow using a scoped block:</source>
          <target state="translated">Si hay que pedir prestado el valor y luego trasladarlo,intente limitar la vida útil del préstamo utilizando un bloque de alcance:</target>
        </trans-unit>
        <trans-unit id="439bfb205198efd0a4754651bf5aae96ad735451" translate="yes" xml:space="preserve">
          <source>If the value has to be borrowed, try limiting the lifetime of the borrow using a scoped block:</source>
          <target state="translated">Si hay que pedir prestado el valor,trate de limitar la vida útil del préstamo utilizando un bloque de alcance:</target>
        </trans-unit>
        <trans-unit id="f9c557d25b585efde62c6ddbcee6fee7ec33bf65" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d1fe880a09ab231c6fd293521ee6addfe1a6459" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;../result/enum.result#Err.v&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="translated">Si se encuentra el valor, se devuelve &lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt; , que contiene el &amp;iacute;ndice del elemento coincidente. Si hay varias coincidencias, se puede devolver cualquiera de las coincidencias. Si no se encuentra el valor, se devuelve &lt;a href=&quot;../result/enum.result#Err.v&quot;&gt; &lt;code&gt;Result::Err&lt;/code&gt; &lt;/a&gt; , que contiene el &amp;iacute;ndice donde se podr&amp;iacute;a insertar un elemento coincidente manteniendo el orden ordenado.</target>
        </trans-unit>
        <trans-unit id="cf626e78bb4fbb4f09006ad988abe5836977b7bd" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50a46bb743147d3eacb03edd963a4e09c15c1d2d" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;result/enum.result#Ok.v&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;result/enum.result#Err.v&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="translated">Si se encuentra el valor, se devuelve &lt;a href=&quot;result/enum.result#Ok.v&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt; , que contiene el &amp;iacute;ndice del elemento coincidente. Si hay varias coincidencias, se puede devolver cualquiera de las coincidencias. Si no se encuentra el valor, se devuelve &lt;a href=&quot;result/enum.result#Err.v&quot;&gt; &lt;code&gt;Result::Err&lt;/code&gt; &lt;/a&gt; , que contiene el &amp;iacute;ndice donde se podr&amp;iacute;a insertar un elemento coincidente manteniendo el orden ordenado.</target>
        </trans-unit>
        <trans-unit id="d91c83f96183a0d83c776c950c730bfea58d4c7b" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d22ef5ff5dbc4cc40b70616ba2e0f0190b53527" translate="yes" xml:space="preserve">
          <source>If the value specified is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">Si el valor especificado es &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , las llamadas de &lt;a href=&quot;../io/trait.read#tymethod.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; se bloquear&amp;aacute;n indefinidamente. Se devuelve un &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; si se pasa la &lt;a href=&quot;../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; cero a este m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="29067101ad21459828f0c00fe18eef137fbe68c7" translate="yes" xml:space="preserve">
          <source>If the value specified is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">Si el valor especificado es &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , las llamadas de &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; se bloquear&amp;aacute;n indefinidamente. Se devuelve un &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; si se pasa la &lt;a href=&quot;../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; cero a este m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="181ed969af7558ba19cf6745f45eb52729d76a52" translate="yes" xml:space="preserve">
          <source>If the value will be consumed in the pattern guard, using its clone will not move its ownership, so the code works.</source>
          <target state="translated">Si el valor se consumirá en el patrón de guardia,el uso de su clon no moverá su propiedad,por lo que el código funciona.</target>
        </trans-unit>
        <trans-unit id="fcea84573a8b7607a7187659bdbb55dd1d39b19b" translate="yes" xml:space="preserve">
          <source>If the vector is sorted, this removes all duplicates.</source>
          <target state="translated">Si se ordena el vector,esto elimina todos los duplicados.</target>
        </trans-unit>
        <trans-unit id="cef9f1c43befa45dbf980aee6fe9d718a1e963db" translate="yes" xml:space="preserve">
          <source>If there are multiple types involved, the only way you care to interact with them is through the trait's interface, and having to rely on dynamic dispatch is acceptable, then you can use &lt;a href=&quot;book/ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;trait objects&lt;/a&gt; with &lt;code&gt;Box&lt;/code&gt;, or other container types like &lt;code&gt;Rc&lt;/code&gt; or &lt;code&gt;Arc&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abef88012cadeaf10ba437a95f5fb3e15155b1f7" translate="yes" xml:space="preserve">
          <source>If there are no other &lt;code&gt;Rc&lt;/code&gt; pointers to this allocation, then &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to this allocation will be disassociated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff03d8563fa4e1bf22eab63535da2e3b71548d3f" translate="yes" xml:space="preserve">
          <source>If there are no other &lt;code&gt;Rc&lt;/code&gt; pointers to this value, then &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to this value will be dissassociated.</source>
          <target state="translated">Si no hay otros punteros &lt;code&gt;Rc&lt;/code&gt; para este valor, los punteros &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; para este valor se disociar&amp;aacute;n.</target>
        </trans-unit>
        <trans-unit id="95b57c72705e9580ae96b3d9b9bde30bb6b6ab81" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;Arc&lt;/code&gt; or &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to the same allocation, then &lt;code&gt;make_mut&lt;/code&gt; will create a new allocation and invoke &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on the inner value to ensure unique ownership. This is also referred to as clone-on-write.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f600b6c8aaa0b5d77a10aa7a739f040bbc9e0c6" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;Arc&lt;/code&gt; or &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to the same value, then &lt;code&gt;make_mut&lt;/code&gt; will invoke &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on the inner value to ensure unique ownership. This is also referred to as clone-on-write.</source>
          <target state="translated">Si hay otros punteros &lt;code&gt;Arc&lt;/code&gt; o &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; al mismo valor, &lt;code&gt;make_mut&lt;/code&gt; invocar&amp;aacute; el &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; en el valor interno para garantizar la propiedad &amp;uacute;nica. Esto tambi&amp;eacute;n se conoce como clonar al escribir.</target>
        </trans-unit>
        <trans-unit id="0fe3cddf6aeb04744aa2425c22a909112782196d" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;Rc&lt;/code&gt; pointers to the same allocation, then &lt;code&gt;make_mut&lt;/code&gt; will &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; the inner value to a new allocation to ensure unique ownership. This is also referred to as clone-on-write.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f863941a685dbb092b44959406a2b7b73529caaa" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;Rc&lt;/code&gt; pointers to the same value, then &lt;code&gt;make_mut&lt;/code&gt; will &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; the inner value to ensure unique ownership. This is also referred to as clone-on-write.</source>
          <target state="translated">Si hay otros &lt;code&gt;Rc&lt;/code&gt; punteros al mismo valor, entonces &lt;code&gt;make_mut&lt;/code&gt; se &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; el valor interno para garantizar la propiedad &amp;uacute;nica. Esto tambi&amp;eacute;n se conoce como clonar al escribir.</target>
        </trans-unit>
        <trans-unit id="dea40bb57bee20622d3883c554a725db6e6aee3b" translate="yes" xml:space="preserve">
          <source>If there is a blocked thread on this condition variable, then it will be woken up from its call to &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#method.wait_timeout&quot;&gt;&lt;code&gt;wait_timeout&lt;/code&gt;&lt;/a&gt;. Calls to &lt;code&gt;notify_one&lt;/code&gt; are not buffered in any way.</source>
          <target state="translated">Si hay un hilo bloqueado en esta variable de condici&amp;oacute;n, entonces se despertar&amp;aacute; de su llamada a &lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;#method.wait_timeout&quot;&gt; &lt;code&gt;wait_timeout&lt;/code&gt; &lt;/a&gt; . Las llamadas a &lt;code&gt;notify_one&lt;/code&gt; no se almacenan en b&amp;uacute;fer de ninguna manera.</target>
        </trans-unit>
        <trans-unit id="e0a267348680246d2e17aaf9a40bcf577009d4e9" translate="yes" xml:space="preserve">
          <source>If there is a blocked thread on this condition variable, then it will be woken up from its call to &lt;a href=&quot;struct.condvar#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.condvar#method.wait_timeout&quot;&gt;&lt;code&gt;wait_timeout&lt;/code&gt;&lt;/a&gt;. Calls to &lt;code&gt;notify_one&lt;/code&gt; are not buffered in any way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b165be9cc0b432064e92ddc4e5e166f180e45c19" translate="yes" xml:space="preserve">
          <source>If there is a panic, the already cloned elements will be dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="985d82ded8f795b4c5a05301fea06f8c8f8410be" translate="yes" xml:space="preserve">
          <source>If there is a single type involved, you can use &lt;a href=&quot;book/ch10-02-traits#returning-types-that-implement-traits&quot;&gt;&lt;code&gt;impl Trait&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bee2363bd2a2c8c97c0aa8c6f834b6380ae23a5d" translate="yes" xml:space="preserve">
          <source>If there is a unique bound from the containing type then that is the default</source>
          <target state="translated">Si hay un límite único del tipo que contiene,entonces ese es el valor predeterminado</target>
        </trans-unit>
        <trans-unit id="352f58ee146eece567c530e6f6054aff283c53ea" translate="yes" xml:space="preserve">
          <source>If there is exactly one lifetime used in the parameters (elided or not), that lifetime is assigned to &lt;em&gt;all&lt;/em&gt; elided output lifetimes.</source>
          <target state="translated">Si hay exactamente una vida &amp;uacute;til utilizada en los par&amp;aacute;metros (elidida o no), esa vida &amp;uacute;til se asigna a &lt;em&gt;todas&lt;/em&gt; las vidas de salida elididas.</target>
        </trans-unit>
        <trans-unit id="05c8d9cff8b4cacded32e768ce8c1fe1b9bf7b05" translate="yes" xml:space="preserve">
          <source>If there is more than one bound from the containing type then an explicit bound must be specified</source>
          <target state="translated">Si hay más de un límite del tipo que contiene,se debe especificar un límite explícito</target>
        </trans-unit>
        <trans-unit id="3635b90aa1ac5e9d56b967f455ea5a68c64aa12a" translate="yes" xml:space="preserve">
          <source>If there is no data attached to &lt;em&gt;any&lt;/em&gt; of the variants of an enumeration, then the discriminant can be directly chosen and accessed.</source>
          <target state="translated">Si no hay datos adjuntos a &lt;em&gt;ninguna&lt;/em&gt; de las variantes de una enumeraci&amp;oacute;n, se puede elegir y acceder directamente al discriminante.</target>
        </trans-unit>
        <trans-unit id="5a74422fbdc8c963cd6dd0e8d60bffef84d0d7d1" translate="yes" xml:space="preserve">
          <source>If there's still a partial line in the buffer when the &lt;code&gt;LineWriter&lt;/code&gt; is dropped, it will flush those contents.</source>
          <target state="translated">Si todav&amp;iacute;a hay una l&amp;iacute;nea parcial en el b&amp;uacute;fer cuando se &lt;code&gt;LineWriter&lt;/code&gt; , vaciar&amp;aacute; esos contenidos.</target>
        </trans-unit>
        <trans-unit id="e49a0ab914289e14797d67f14458c53775df1443" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; was constructed via &lt;a href=&quot;struct.error#method.last_os_error&quot;&gt;&lt;code&gt;last_os_error&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.error#method.from_raw_os_error&quot;&gt;&lt;code&gt;from_raw_os_error&lt;/code&gt;&lt;/a&gt;, then this function will return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;, otherwise it will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eaa98dea050ef5ef34b38731584cb22e203de6c" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; was constructed via &lt;a href=&quot;struct.error#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; then this function will return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;, otherwise it will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abb98d91de395055f4edd70094a7b8dcc7dd5d8b" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Error&lt;/code&gt; was constructed via &lt;code&gt;last_os_error&lt;/code&gt; or &lt;code&gt;from_raw_os_error&lt;/code&gt;, then this function will return &lt;code&gt;Some&lt;/code&gt;, otherwise it will return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">Si este &lt;code&gt;Error&lt;/code&gt; se construy&amp;oacute; a trav&amp;eacute;s de &lt;code&gt;last_os_error&lt;/code&gt; o &lt;code&gt;from_raw_os_error&lt;/code&gt; , esta funci&amp;oacute;n devolver&amp;aacute; &lt;code&gt;Some&lt;/code&gt; , de lo contrario, devolver&amp;aacute; &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6ffccf610cd6b37d68c88255675f6191805f967" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Error&lt;/code&gt; was constructed via &lt;code&gt;new&lt;/code&gt; then this function will return &lt;code&gt;Some&lt;/code&gt;, otherwise it will return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">Si este &lt;code&gt;Error&lt;/code&gt; se construy&amp;oacute; a trav&amp;eacute;s de &lt;code&gt;new&lt;/code&gt; , esta funci&amp;oacute;n devolver&amp;aacute; &lt;code&gt;Some&lt;/code&gt; , de lo contrario, devolver&amp;aacute; &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="972ece54d9b74d11c408e1f298396f497ba6449a" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; does not have a lowercase mapping, the iterator yields the same &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58c79af0f9cc118b1977a59ee7eda23560b0caa9" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; does not have a uppercase mapping, the iterator yields the same &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="829eac6176dbda0779cc96fbc600b1df90d4e4bc" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; has a one-to-one lowercase mapping given by the &lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;Unicode Character Database&lt;/a&gt;&lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt&quot;&gt;&lt;code&gt;UnicodeData.txt&lt;/code&gt;&lt;/a&gt;, the iterator yields that &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8172678f4c99b3f0dc7b848aa7a176d18218ceb4" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; has a one-to-one uppercase mapping given by the &lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;Unicode Character Database&lt;/a&gt;&lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt&quot;&gt;&lt;code&gt;UnicodeData.txt&lt;/code&gt;&lt;/a&gt;, the iterator yields that &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89a8c0c082c5779306df0c22e5cf142b946f6c4e" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; requires special considerations (e.g. multiple &lt;code&gt;char&lt;/code&gt;s) the iterator yields the &lt;code&gt;char&lt;/code&gt;(s) given by &lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt&quot;&gt;&lt;code&gt;SpecialCasing.txt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="548965be0bbc95fe2de47e9f63883d2758d88ca6" translate="yes" xml:space="preserve">
          <source>If this chapter has piqued your interest and you want to implement your own smart pointers, check out &lt;a href=&quot;https://doc.rust-lang.org/nomicon/index.html&quot;&gt;&amp;ldquo;The Rustonomicon&amp;rdquo;&lt;/a&gt; for more useful information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b584e3b971153b633a07eca679cded17a1c1b693" translate="yes" xml:space="preserve">
          <source>If this chapter has piqued your interest and you want to implement your own smart pointers, check out &lt;a href=&quot;https://doc.rust-lang.org/stable/nomicon/index.html&quot;&gt;&amp;ldquo;The Rustonomicon&amp;rdquo;&lt;/a&gt; for more useful information.</source>
          <target state="translated">Si este cap&amp;iacute;tulo ha despertado su inter&amp;eacute;s y desea implementar sus propios indicadores inteligentes, consulte &lt;a href=&quot;https://doc.rust-lang.org/stable/nomicon/index.html&quot;&gt;&amp;ldquo;El icono de Rustonomic&amp;rdquo;&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n &amp;uacute;til.</target>
        </trans-unit>
        <trans-unit id="0ddae77e0fadbaabd5b7dbc95fb35e2d525819bd" translate="yes" xml:space="preserve">
          <source>If this function encounters an &quot;end of file&quot; before completely filling the buffer, it returns an error of the kind &lt;a href=&quot;../../../io/enum.errorkind#variant.UnexpectedEof&quot;&gt;&lt;code&gt;ErrorKind::UnexpectedEof&lt;/code&gt;&lt;/a&gt;. The contents of &lt;code&gt;buf&lt;/code&gt; are unspecified in this case.</source>
          <target state="translated">Si esta funci&amp;oacute;n encuentra un &quot;final de archivo&quot; antes de llenar completamente el b&amp;uacute;fer, devuelve un error del tipo &lt;a href=&quot;../../../io/enum.errorkind#variant.UnexpectedEof&quot;&gt; &lt;code&gt;ErrorKind::UnexpectedEof&lt;/code&gt; &lt;/a&gt; . En este caso, el contenido de &lt;code&gt;buf&lt;/code&gt; no est&amp;aacute; especificado.</target>
        </trans-unit>
        <trans-unit id="dd91d7afe70f171b1effa9750344f0fa576225f4" translate="yes" xml:space="preserve">
          <source>If this function encounters an &quot;end of file&quot; before completely filling the buffer, it returns an error of the kind &lt;a href=&quot;../../../io/enum.errorkind#variant.UnexpectedEof&quot;&gt;&lt;code&gt;io::ErrorKind::UnexpectedEof&lt;/code&gt;&lt;/a&gt;. The contents of &lt;code&gt;buf&lt;/code&gt; are unspecified in this case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38d7508026f8cac220a71afe0772cc2be9708eb8" translate="yes" xml:space="preserve">
          <source>If this function encounters an &quot;end of file&quot; before completely filling the buffer, it returns an error of the kind &lt;a href=&quot;enum.errorkind#variant.UnexpectedEof&quot;&gt;&lt;code&gt;ErrorKind::UnexpectedEof&lt;/code&gt;&lt;/a&gt;. The contents of &lt;code&gt;buf&lt;/code&gt; are unspecified in this case.</source>
          <target state="translated">Si esta funci&amp;oacute;n encuentra un &quot;final de archivo&quot; antes de llenar completamente el b&amp;uacute;fer, devuelve un error del tipo &lt;a href=&quot;enum.errorkind#variant.UnexpectedEof&quot;&gt; &lt;code&gt;ErrorKind::UnexpectedEof&lt;/code&gt; &lt;/a&gt; . En este caso, el contenido de &lt;code&gt;buf&lt;/code&gt; no est&amp;aacute; especificado.</target>
        </trans-unit>
        <trans-unit id="bb4e1045443cca4084567ed8afb7d4a2bc6c922a" translate="yes" xml:space="preserve">
          <source>If this function encounters an error of the kind &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; then the error is ignored and the operation will continue.</source>
          <target state="translated">Si esta funci&amp;oacute;n encuentra un error del tipo &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; , el error se ignora y la operaci&amp;oacute;n continuar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="a8875047b32226ad3b08a483cfff719e7d61c887" translate="yes" xml:space="preserve">
          <source>If this function encounters an error of the kind &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; then the error is ignored and the operation will continue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b6df35b215478f7f7741d3182fb05937f86e727" translate="yes" xml:space="preserve">
          <source>If this function encounters an error of the kind &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; then the error is ignored and the operation will continue.</source>
          <target state="translated">Si esta funci&amp;oacute;n encuentra un error del tipo &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; , el error se ignora y la operaci&amp;oacute;n continuar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="14f9d7ca930e810af603a93101162a569a3ddf35" translate="yes" xml:space="preserve">
          <source>If this function encounters any form of I/O or other error, an error variant will be returned. If an error is returned then it must be guaranteed that no bytes were read.</source>
          <target state="translated">Si esta función encuentra cualquier forma de E/S u otro error,se devolverá una variante de error.Si se devuelve un error,entonces debe garantizarse que no se han leído bytes.</target>
        </trans-unit>
        <trans-unit id="a8d408c5e61a9b54abca8856c432fb48776f9a75" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(0)&lt;/code&gt;&lt;/a&gt;, the stream has reached EOF.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8a07da1b0668efaf930a01d9ed7e8496400a4f8" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;code&gt;Ok(0)&lt;/code&gt;, the stream has reached EOF.</source>
          <target state="translated">Si esta funci&amp;oacute;n devuelve &lt;code&gt;Ok(0)&lt;/code&gt; , la secuencia ha alcanzado EOF.</target>
        </trans-unit>
        <trans-unit id="32100a1ba4be6bddcd14becf4ad19ac4def99416" translate="yes" xml:space="preserve">
          <source>If this function returns an error, it is unspecified how many bytes it has read, but it will never read more than would be necessary to completely fill the buffer.</source>
          <target state="translated">Si esta función devuelve un error,no se especifica cuántos bytes ha leído,pero nunca leerá más de los que serían necesarios para llenar completamente la memoria intermedia.</target>
        </trans-unit>
        <trans-unit id="87d71722719a13aad250b3e972be1f6616e469cd" translate="yes" xml:space="preserve">
          <source>If this is a buffered channel, then the buffer is full at this time. If this is not a buffered channel, then there is no &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt; available to acquire the data.</source>
          <target state="translated">Si se trata de un canal con b&amp;uacute;fer, entonces el b&amp;uacute;fer est&amp;aacute; lleno en este momento. Si este no es un canal almacenado en b&amp;uacute;fer, entonces no hay ning&amp;uacute;n &lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt; disponible para adquirir los datos.</target>
        </trans-unit>
        <trans-unit id="91184bf48d3bff1e231691842c160f41d0aa37b7" translate="yes" xml:space="preserve">
          <source>If this is not an option, consider replacing the type parameter with another trait object (e.g., if &lt;code&gt;T: OtherTrait&lt;/code&gt;, use &lt;code&gt;on: Box&amp;lt;OtherTrait&amp;gt;&lt;/code&gt;). If the number of types you intend to feed to this method is limited, consider manually listing out the methods of different types.</source>
          <target state="translated">Si esta no es una opci&amp;oacute;n, considere reemplazar el par&amp;aacute;metro de tipo con otro objeto de rasgo (por ejemplo, si &lt;code&gt;T: OtherTrait&lt;/code&gt; , use &lt;code&gt;on: Box&amp;lt;OtherTrait&amp;gt;&lt;/code&gt; ). Si la cantidad de tipos que desea alimentar con este m&amp;eacute;todo es limitada, considere enumerar manualmente los m&amp;eacute;todos de diferentes tipos.</target>
        </trans-unit>
        <trans-unit id="5c02bd6638372b67d88f3ddd5d1f383f3787bce7" translate="yes" xml:space="preserve">
          <source>If this is your first time, the documentation for the standard library is written to be casually perused. Clicking on interesting things should generally lead you to interesting places. Still, there are important bits you don't want to miss, so read on for a tour of the standard library and its documentation!</source>
          <target state="translated">Si es la primera vez,la documentación de la biblioteca estándar está escrita para ser examinada casualmente.Haciendo clic en cosas interesantes generalmente te llevará a lugares interesantes.Aún así,hay partes importantes que no te quieres perder,¡así que sigue leyendo para hacer un recorrido por la biblioteca estándar y su documentación!</target>
        </trans-unit>
        <trans-unit id="9676dae75a055d60a25e6ce7412236743ae6ea02" translate="yes" xml:space="preserve">
          <source>If this method returns &lt;code&gt;Err&lt;/code&gt;, then ownership of the memory block has not been transferred to this allocator, and the contents of the memory block are unaltered.</source>
          <target state="translated">Si este m&amp;eacute;todo devuelve &lt;code&gt;Err&lt;/code&gt; , entonces la propiedad del bloque de memoria no se ha transferido a este asignador y el contenido del bloque de memoria no se modifica.</target>
        </trans-unit>
        <trans-unit id="01b48a2a055f0e9e221863ae53b5df15b8890a45" translate="yes" xml:space="preserve">
          <source>If this method returns an &lt;code&gt;Ok(addr)&lt;/code&gt;, then the &lt;code&gt;addr&lt;/code&gt; returned will be non-null address pointing to a block of storage suitable for holding an instance of &lt;code&gt;layout&lt;/code&gt;.</source>
          <target state="translated">Si este m&amp;eacute;todo devuelve un &lt;code&gt;Ok(addr)&lt;/code&gt; , entonces el &lt;code&gt;addr&lt;/code&gt; devuelto ser&amp;aacute; una direcci&amp;oacute;n no nula que apunta a un bloque de almacenamiento adecuado para albergar una instancia de &lt;code&gt;layout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57431fcdddc5fa976aeed322cde258661b0155ef" translate="yes" xml:space="preserve">
          <source>If this method returns null, then ownership of the memory block has not been transferred to this allocator, and the contents of the memory block are unaltered.</source>
          <target state="translated">Si este método devuelve nulo,entonces la propiedad del bloque de memoria no se ha transferido a este asignador,y el contenido del bloque de memoria no se ha alterado.</target>
        </trans-unit>
        <trans-unit id="0ffa302b9d10d74aa11c3e8a0d25a30c1712822c" translate="yes" xml:space="preserve">
          <source>If this results in multiple possible candidates, then it is an error, and the receiver must be &lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;converted&lt;/a&gt; to an appropriate receiver type to make the method call.</source>
          <target state="translated">Si esto da como resultado m&amp;uacute;ltiples candidatos posibles, entonces es un error y el receptor debe &lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;convertirse&lt;/a&gt; a un tipo de receptor apropiado para realizar la llamada al m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="09145f758f25c9eb35661be01cc46455e17d7df0" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Err&lt;/code&gt;, then the memory block is considered to still represent the original (larger) &lt;code&gt;layout&lt;/code&gt;. None of the block has been carved off for reuse elsewhere, ownership of the memory block has not been transferred, and the contents of the memory block are unaltered.</source>
          <target state="translated">Si devuelve &lt;code&gt;Err&lt;/code&gt; , entonces se considera que el bloque de memoria sigue representando el &lt;code&gt;layout&lt;/code&gt; original (m&amp;aacute;s grande) . Ninguno de los bloques se ha tallado para su reutilizaci&amp;oacute;n en otro lugar, la propiedad del bloque de memoria no se ha transferido y el contenido del bloque de memoria no se ha modificado.</target>
        </trans-unit>
        <trans-unit id="7b6bef076ebe49dc4a2edbad684a0b757b358554" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Ok&lt;/code&gt;, then ownership of the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; has been transferred to this allocator. The memory may or may not have been freed, and should be considered unusable (unless of course it was transferred back to the caller again via the return value of this method).</source>
          <target state="translated">Si esto devuelve &lt;code&gt;Ok&lt;/code&gt; , entonces la propiedad del bloque de memoria referenciado por &lt;code&gt;ptr&lt;/code&gt; se ha transferido a este asignador. La memoria puede haber sido liberada o no, y debe considerarse inutilizable (a menos que, por supuesto, se haya transferido nuevamente a la persona que llama a trav&amp;eacute;s del valor de retorno de este m&amp;eacute;todo).</target>
        </trans-unit>
        <trans-unit id="d418fdb16ac3dec6f2998c32246199d93bd8ccd1" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Ok&lt;/code&gt;, then ownership of the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; has been transferred to this allocator. The memory may or may not have been freed, and should be considered unusable unless it was transferred back to the caller again via the return value of this method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b07b65f6bada4aa52d604e0c09ea706a071d0221" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Ok&lt;/code&gt;, then the allocator has asserted that the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; now fits &lt;code&gt;new_size&lt;/code&gt;, and thus can be used to carry data of a layout of that size and same alignment as &lt;code&gt;layout&lt;/code&gt;. (The allocator is allowed to expend effort to accomplish this, such as extending the memory block to include successor blocks, or virtual memory tricks.)</source>
          <target state="translated">Si esto devuelve &lt;code&gt;Ok&lt;/code&gt; , entonces el asignador ha afirmado que el bloque de memoria al que hace referencia &lt;code&gt;ptr&lt;/code&gt; ahora se ajusta a &lt;code&gt;new_size&lt;/code&gt; y, por lo tanto, puede usarse para transportar datos de un dise&amp;ntilde;o de ese tama&amp;ntilde;o y la misma alineaci&amp;oacute;n que el &lt;code&gt;layout&lt;/code&gt; . (El asignador puede hacer un esfuerzo para lograr esto, como extender el bloque de memoria para incluir bloques sucesores o trucos de memoria virtual).</target>
        </trans-unit>
        <trans-unit id="265c1e3719888af4af19b397644a5084b5b82f03" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Ok&lt;/code&gt;, then the allocator has asserted that the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; now fits &lt;code&gt;new_size&lt;/code&gt;, and thus can only be used to carry data of that smaller layout. (The allocator is allowed to take advantage of this, carving off portions of the block for reuse elsewhere.) The truncated contents of the block within the smaller layout are unaltered, and ownership of block has not been transferred.</source>
          <target state="translated">Si esto devuelve &lt;code&gt;Ok&lt;/code&gt; , entonces el asignador ha afirmado que el bloque de memoria al que hace referencia &lt;code&gt;ptr&lt;/code&gt; ahora se ajusta a &lt;code&gt;new_size&lt;/code&gt; y, por lo tanto, solo se puede usar para transportar datos de ese dise&amp;ntilde;o m&amp;aacute;s peque&amp;ntilde;o. (El asignador puede aprovechar esto, cortando porciones del bloque para su reutilizaci&amp;oacute;n en otro lugar). El contenido truncado del bloque dentro del dise&amp;ntilde;o m&amp;aacute;s peque&amp;ntilde;o no se modifica y la propiedad del bloque no se ha transferido.</target>
        </trans-unit>
        <trans-unit id="1e21899c81274a7e69e0d33ce177abd176697388" translate="yes" xml:space="preserve">
          <source>If this returns a non-null pointer, then ownership of the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; has been transferred to this allocator. The memory may or may not have been deallocated, and should be considered unusable (unless of course it was transferred back to the caller again via the return value of this method).</source>
          <target state="translated">Si devuelve un puntero no nulo, entonces la propiedad del bloque de memoria al que hace referencia &lt;code&gt;ptr&lt;/code&gt; se ha transferido a este asignador. La memoria puede haber sido desasignada o no, y deber&amp;iacute;a considerarse inutilizable (a menos que, por supuesto, se haya transferido de nuevo a la persona que llama a trav&amp;eacute;s del valor de retorno de este m&amp;eacute;todo).</target>
        </trans-unit>
        <trans-unit id="8d4043cdbda910f0ad6a1a1cd5c98aae741eec3c" translate="yes" xml:space="preserve">
          <source>If this returns a non-null pointer, then ownership of the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; has been transferred to this allocator. The memory may or may not have been deallocated, and should be considered unusable (unless of course it was transferred back to the caller again via the return value of this method). The new memory block is allocated with &lt;code&gt;layout&lt;/code&gt;, but with the &lt;code&gt;size&lt;/code&gt; updated to &lt;code&gt;new_size&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d52bbe20c5aac68705e76e7c5e6b2bad9de5e10" translate="yes" xml:space="preserve">
          <source>If this slice is not partitioned, the returned result is unspecified and meaningless, as this method performs a kind of binary search.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2533e7aaf9faf4802db49c2aac243e2b2261233a" translate="yes" xml:space="preserve">
          <source>If this syntax is used, then the number of characters to print precedes the actual object being formatted, and the number of characters must have the type &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si se usa esta sintaxis, entonces el n&amp;uacute;mero de caracteres a imprimir precede al objeto real que se est&amp;aacute; formateando, y el n&amp;uacute;mero de caracteres debe tener el tipo &lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="64b179337be99298379500e406a343560aae2c69" translate="yes" xml:space="preserve">
          <source>If this would overflow the range of values supported by &lt;code&gt;Self&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b27728b02e3e78c5d0c38db43dde768cdde4959" translate="yes" xml:space="preserve">
          <source>If this would overflow the range of values supported by &lt;code&gt;Self&lt;/code&gt;, this function is allowed to panic, wrap, or saturate. The suggested behavior is to panic when debug assertions are enabled, and to wrap or saturate otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0df7d71ccb9fef6722d0478c8d5e8fc86939d3f" translate="yes" xml:space="preserve">
          <source>If two matched elements are directly adjacent, an empty slice will be present between them:</source>
          <target state="translated">Si dos elementos emparejados son directamente adyacentes,una parte vacía estará presente entre ellos:</target>
        </trans-unit>
        <trans-unit id="aba72b6261d8cf54f8817ecf4602e9f657125528" translate="yes" xml:space="preserve">
          <source>If two sequence have equivalent elements and are of the same length, then the sequences are lexicographically equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3d45eebf9b7ed122af4ed423facfc2fe8966ab8" translate="yes" xml:space="preserve">
          <source>If we &lt;em&gt;do&lt;/em&gt; want to deeply copy the heap data of the &lt;code&gt;String&lt;/code&gt;, not just the stack data, we can use a common method called &lt;code&gt;clone&lt;/code&gt;. We&amp;rsquo;ll discuss method syntax in Chapter 5, but because methods are a common feature in many programming languages, you&amp;rsquo;ve probably seen them before.</source>
          <target state="translated">Si nosotros &lt;em&gt;hacemos&lt;/em&gt; desea copiar profundamente los datos del mont&amp;oacute;n de la &lt;code&gt;String&lt;/code&gt; , no s&amp;oacute;lo los datos de la pila, podemos utilizar un m&amp;eacute;todo com&amp;uacute;n llamado &lt;code&gt;clone&lt;/code&gt; . Discutiremos la sintaxis de los m&amp;eacute;todos en el Cap&amp;iacute;tulo 5, pero debido a que los m&amp;eacute;todos son una caracter&amp;iacute;stica com&amp;uacute;n en muchos lenguajes de programaci&amp;oacute;n, probablemente los haya visto antes.</target>
        </trans-unit>
        <trans-unit id="401dbe72f6e067cf29a630716f3d3b23f7eb7742" translate="yes" xml:space="preserve">
          <source>If we compile this code right now, we&amp;rsquo;ll get this error:</source>
          <target state="translated">Si compilamos este c&amp;oacute;digo ahora mismo, obtendremos este error:</target>
        </trans-unit>
        <trans-unit id="47e134e66136b075454568cd0131337b49150e26" translate="yes" xml:space="preserve">
          <source>If we continue reading the errors, we&amp;rsquo;ll find this helpful note:</source>
          <target state="translated">Si continuamos leyendo los errores, encontraremos esta &amp;uacute;til nota:</target>
        </trans-unit>
        <trans-unit id="d42c7d1da5d982e675dccc0a9e2a41b79cecc88f" translate="yes" xml:space="preserve">
          <source>If we control the definition of a type, we can implement &lt;code&gt;Clone&lt;/code&gt; on it ourselves with &lt;code&gt;#[derive(Clone)]&lt;/code&gt;.</source>
          <target state="translated">Si controlamos la definici&amp;oacute;n de un tipo, podemos implementar &lt;code&gt;Clone&lt;/code&gt; en &amp;eacute;l nosotros mismos con &lt;code&gt;#[derive(Clone)]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87e3953b2e8c7c5293b9804529d84ebcbc0b39fd" translate="yes" xml:space="preserve">
          <source>If we don&amp;rsquo;t add the type annotation here, Rust will display the following error, which means the compiler needs more information from us to know which type we want to use:</source>
          <target state="translated">Si no agregamos la anotaci&amp;oacute;n de tipo aqu&amp;iacute;, Rust mostrar&amp;aacute; el siguiente error, lo que significa que el compilador necesita m&amp;aacute;s informaci&amp;oacute;n de nosotros para saber qu&amp;eacute; tipo queremos usar:</target>
        </trans-unit>
        <trans-unit id="64f181d4acc8150a490f15e9bd18aaaa910dbc02" translate="yes" xml:space="preserve">
          <source>If we don&amp;rsquo;t want to restrict the &lt;code&gt;largest&lt;/code&gt; function to the types that implement the &lt;code&gt;Copy&lt;/code&gt; trait, we could specify that &lt;code&gt;T&lt;/code&gt; has the trait bound &lt;code&gt;Clone&lt;/code&gt; instead of &lt;code&gt;Copy&lt;/code&gt;. Then we could clone each value in the slice when we want the &lt;code&gt;largest&lt;/code&gt; function to have ownership. Using the &lt;code&gt;clone&lt;/code&gt; function means we&amp;rsquo;re potentially making more heap allocations in the case of types that own heap data like &lt;code&gt;String&lt;/code&gt;, and heap allocations can be slow if we&amp;rsquo;re working with large amounts of data.</source>
          <target state="translated">Si no queremos restringir la funci&amp;oacute;n &lt;code&gt;largest&lt;/code&gt; a los tipos que implementan el rasgo &lt;code&gt;Copy&lt;/code&gt; , podr&amp;iacute;amos especificar que &lt;code&gt;T&lt;/code&gt; tiene el rasgo vinculado &lt;code&gt;Clone&lt;/code&gt; lugar de &lt;code&gt;Copy&lt;/code&gt; . Entonces podr&amp;iacute;amos clonar cada valor en el segmento cuando queramos que la funci&amp;oacute;n &lt;code&gt;largest&lt;/code&gt; tenga propiedad. El uso de la funci&amp;oacute;n de &lt;code&gt;clone&lt;/code&gt; significa que potencialmente estamos haciendo m&amp;aacute;s asignaciones de mont&amp;oacute;n en el caso de tipos que poseen datos de mont&amp;oacute;n como &lt;code&gt;String&lt;/code&gt; , y las asignaciones de mont&amp;oacute;n pueden ser lentas si trabajamos con grandes cantidades de datos.</target>
        </trans-unit>
        <trans-unit id="9f4e2a91ce5b3d093909a51433f578b35d100485" translate="yes" xml:space="preserve">
          <source>If we forget the lifetime annotations and try to compile this function, we&amp;rsquo;ll get this error:</source>
          <target state="translated">Si olvidamos las anotaciones de por vida e intentamos compilar esta funci&amp;oacute;n, obtendremos este error:</target>
        </trans-unit>
        <trans-unit id="d50142aed73fdab3ce99830192ece11c222bce36" translate="yes" xml:space="preserve">
          <source>If we get the lock on the mutex, we call &lt;code&gt;recv&lt;/code&gt; to receive a &lt;code&gt;Job&lt;/code&gt; from the channel. A final &lt;code&gt;unwrap&lt;/code&gt; moves past any errors here as well, which might occur if the thread holding the sending side of the channel has shut down, similar to how the &lt;code&gt;send&lt;/code&gt; method returns &lt;code&gt;Err&lt;/code&gt; if the receiving side shuts down.</source>
          <target state="translated">Si obtenemos el bloqueo en el mutex, llamamos a &lt;code&gt;recv&lt;/code&gt; para recibir un &lt;code&gt;Job&lt;/code&gt; del canal. Un &lt;code&gt;unwrap&lt;/code&gt; final tambi&amp;eacute;n pasa por alto cualquier error aqu&amp;iacute;, lo que podr&amp;iacute;a ocurrir si el hilo que contiene el lado de env&amp;iacute;o del canal se ha apagado, similar a c&amp;oacute;mo el m&amp;eacute;todo de &lt;code&gt;send&lt;/code&gt; devuelve &lt;code&gt;Err&lt;/code&gt; si el lado de recepci&amp;oacute;n se apaga.</target>
        </trans-unit>
        <trans-unit id="0fca700376fa2044b0a30ebcc11fb4a985b05812" translate="yes" xml:space="preserve">
          <source>If we hadn&amp;rsquo;t listed the &lt;code&gt;use std::io&lt;/code&gt; line at the beginning of the program, we could have written this function call as &lt;code&gt;std::io::stdin&lt;/code&gt;. The &lt;code&gt;stdin&lt;/code&gt; function returns an instance of &lt;a href=&quot;../std/io/struct.stdin&quot;&gt;&lt;code&gt;std::io::Stdin&lt;/code&gt;&lt;/a&gt;, which is a type that represents a handle to the standard input for your terminal.</source>
          <target state="translated">Si no hubi&amp;eacute;ramos enumerado la l&amp;iacute;nea &lt;code&gt;use std::io&lt;/code&gt; al principio del programa, podr&amp;iacute;amos haber escrito esta llamada de funci&amp;oacute;n como &lt;code&gt;std::io::stdin&lt;/code&gt; . La funci&amp;oacute;n &lt;code&gt;stdin&lt;/code&gt; devuelve una instancia de &lt;a href=&quot;../std/io/struct.stdin&quot;&gt; &lt;code&gt;std::io::Stdin&lt;/code&gt; &lt;/a&gt; , que es un tipo que representa un identificador para la entrada est&amp;aacute;ndar de su terminal.</target>
        </trans-unit>
        <trans-unit id="04a189966ad80f06981ca07607a5760233b03d38" translate="yes" xml:space="preserve">
          <source>If we hadn&amp;rsquo;t put the &lt;code&gt;use std::io&lt;/code&gt; line at the beginning of the program, we could have written this function call as &lt;code&gt;std::io::stdin&lt;/code&gt;. The &lt;code&gt;stdin&lt;/code&gt; function returns an instance of &lt;a href=&quot;../std/io/struct.stdin&quot;&gt;&lt;code&gt;std::io::Stdin&lt;/code&gt;&lt;/a&gt;, which is a type that represents a handle to the standard input for your terminal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86bab42cdbe16f85be0625509956004f41556e40" translate="yes" xml:space="preserve">
          <source>If we have a more complex key, calls to &lt;code&gt;insert&lt;/code&gt; will not update the value of the key. For example:</source>
          <target state="translated">Si tenemos una clave m&amp;aacute;s compleja, las llamadas a &lt;code&gt;insert&lt;/code&gt; ar no actualizar&amp;aacute;n el valor de la clave. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="3e6f59e85b3f49aeec8c0c885c1d87959b650a9b" translate="yes" xml:space="preserve">
          <source>If we have a string slice, we can pass that directly. If we have a &lt;code&gt;String&lt;/code&gt;, we can pass a slice of the entire &lt;code&gt;String&lt;/code&gt;. Defining a function to take a string slice instead of a reference to a &lt;code&gt;String&lt;/code&gt; makes our API more general and useful without losing any functionality:</source>
          <target state="translated">Si tenemos un segmento de cadena, podemos pasarlo directamente. Si tenemos una &lt;code&gt;String&lt;/code&gt; , podemos pasar una porci&amp;oacute;n de toda la &lt;code&gt;String&lt;/code&gt; . Definir una funci&amp;oacute;n para tomar un segmento de cadena en lugar de una referencia a una &lt;code&gt;String&lt;/code&gt; hace que nuestra API sea m&amp;aacute;s general y &amp;uacute;til sin perder ninguna funcionalidad:</target>
        </trans-unit>
        <trans-unit id="ac138ffa3b0aa3b072eefcab1045b74eb7d1fd32" translate="yes" xml:space="preserve">
          <source>If we insert a key and a value into a hash map and then insert that same key with a different value, the value associated with that key will be replaced. Even though the code in Listing 8-24 calls &lt;code&gt;insert&lt;/code&gt; twice, the hash map will only contain one key/value pair because we&amp;rsquo;re inserting the value for the Blue team&amp;rsquo;s key both times.</source>
          <target state="translated">Si insertamos una clave y un valor en un mapa hash y luego insertamos esa misma clave con un valor diferente, el valor asociado con esa clave ser&amp;aacute; reemplazado. Aunque el c&amp;oacute;digo en las llamadas del Listado 8-24 se &lt;code&gt;insert&lt;/code&gt; a dos veces, el mapa hash solo contendr&amp;aacute; un par clave / valor porque estamos insertando el valor de la clave del equipo azul en ambas ocasiones.</target>
        </trans-unit>
        <trans-unit id="543a3a170d1010f43b117fa4c1442ab0b46b4495" translate="yes" xml:space="preserve">
          <source>If we insert references to values into the hash map, the values won&amp;rsquo;t be moved into the hash map. The values that the references point to must be valid for at least as long as the hash map is valid. We&amp;rsquo;ll talk more about these issues in the &lt;a href=&quot;ch10-03-lifetime-syntax#validating-references-with-lifetimes&quot;&gt;&amp;ldquo;Validating References with Lifetimes&amp;rdquo;&lt;/a&gt; section in Chapter 10.</source>
          <target state="translated">Si insertamos referencias a valores en el mapa hash, los valores no se mover&amp;aacute;n al mapa hash. Los valores a los que apuntan las referencias deben ser v&amp;aacute;lidos al menos mientras el mapa hash sea v&amp;aacute;lido. Hablaremos m&amp;aacute;s sobre estos problemas en la secci&amp;oacute;n &lt;a href=&quot;ch10-03-lifetime-syntax#validating-references-with-lifetimes&quot;&gt;&quot;Validaci&amp;oacute;n de referencias con tiempos de vida&quot;&lt;/a&gt; en el Cap&amp;iacute;tulo 10.</target>
        </trans-unit>
        <trans-unit id="48b30993a53ec7ab3753fc22f9cfc6b10c4026a3" translate="yes" xml:space="preserve">
          <source>If we look at the Hindi word &amp;ldquo;नमस्ते&amp;rdquo; written in the Devanagari script, it is stored as a vector of &lt;code&gt;u8&lt;/code&gt; values that looks like this:</source>
          <target state="translated">Si miramos la palabra hindi &quot;नमस्ते&quot; escrita en el script devanagari, se almacena como un vector de valores &lt;code&gt;u8&lt;/code&gt; que se ve as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="ceefcf2e8fb61a92a19892547650cfb486bbbfbc" translate="yes" xml:space="preserve">
          <source>If we need to concatenate multiple strings, the behavior of the &lt;code&gt;+&lt;/code&gt; operator gets unwieldy:</source>
          <target state="translated">Si necesitamos concatenar varias cadenas, el comportamiento del operador &lt;code&gt;+&lt;/code&gt; se vuelve dif&amp;iacute;cil de manejar:</target>
        </trans-unit>
        <trans-unit id="bef4e363e9355203a78ff831eeab87691d89132c" translate="yes" xml:space="preserve">
          <source>If we run the tests without passing any arguments, as we saw earlier, all the tests will run in parallel:</source>
          <target state="translated">Si hacemos las pruebas sin pasar ningún argumento,como vimos antes,todas las pruebas se harán en paralelo:</target>
        </trans-unit>
        <trans-unit id="ef6509c394cc9b5a25c62c835728d6447e229bde" translate="yes" xml:space="preserve">
          <source>If we run this code without a &lt;em&gt;hello.txt&lt;/em&gt; file, we&amp;rsquo;ll see an error message from the &lt;code&gt;panic!&lt;/code&gt; call that the &lt;code&gt;unwrap&lt;/code&gt; method makes:</source>
          <target state="translated">Si ejecutamos este c&amp;oacute;digo sin un archivo &lt;em&gt;hello.txt&lt;/em&gt; , &amp;iexcl;veremos un mensaje de error del &lt;code&gt;panic!&lt;/code&gt; llamada que hace el m&amp;eacute;todo de &lt;code&gt;unwrap&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="411b71603dc821df269f0168d402fe39b58175ea" translate="yes" xml:space="preserve">
          <source>If we run this code, we get an error message like this:</source>
          <target state="translated">Si ejecutamos este código,obtenemos un mensaje de error como este:</target>
        </trans-unit>
        <trans-unit id="9a30a99adbc91389f388f95d8ce88be5cc567df1" translate="yes" xml:space="preserve">
          <source>If we tried to use &lt;code&gt;s&lt;/code&gt; after the call to &lt;code&gt;takes_ownership&lt;/code&gt;, Rust would throw a compile-time error. These static checks protect us from mistakes. Try adding code to &lt;code&gt;main&lt;/code&gt; that uses &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; to see where you can use them and where the ownership rules prevent you from doing so.</source>
          <target state="translated">Si intent&amp;aacute;ramos usar &lt;code&gt;s&lt;/code&gt; despu&amp;eacute;s de la llamada a &lt;code&gt;takes_ownership&lt;/code&gt; , Rust arrojar&amp;iacute;a un error en tiempo de compilaci&amp;oacute;n. Estos controles est&amp;aacute;ticos nos protegen de errores. Trate de a&amp;ntilde;adir c&amp;oacute;digo al &lt;code&gt;main&lt;/code&gt; que los usos &lt;code&gt;s&lt;/code&gt; y &lt;code&gt;x&lt;/code&gt; para ver donde se puede usarlos y donde las reglas de propiedad le impide hacerlo.</target>
        </trans-unit>
        <trans-unit id="5b3d2369c0d31316ed024d7ec48406786e9f748a" translate="yes" xml:space="preserve">
          <source>If we tried to write &lt;code&gt;assert_eq!(5, y);&lt;/code&gt; instead, we would get this compilation error:</source>
          <target state="translated">Si intentamos escribir &lt;code&gt;assert_eq!(5, y);&lt;/code&gt; en su lugar, obtendr&amp;iacute;amos este error de compilaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="d0808380a836c64109f92b188e2221162883a939" translate="yes" xml:space="preserve">
          <source>If we try to access the parent of &lt;code&gt;leaf&lt;/code&gt; after the end of the scope, we&amp;rsquo;ll get &lt;code&gt;None&lt;/code&gt; again. At the end of the program, the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; in &lt;code&gt;leaf&lt;/code&gt; has a strong count of 1 and a weak count of 0, because the variable &lt;code&gt;leaf&lt;/code&gt; is now the only reference to the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; again.</source>
          <target state="translated">Si intentamos acceder al padre de la &lt;code&gt;leaf&lt;/code&gt; despu&amp;eacute;s del final del alcance, obtendremos &lt;code&gt;None&lt;/code&gt; nuevamente. Al final del programa, el &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; en la &lt;code&gt;leaf&lt;/code&gt; tiene un conteo fuerte de 1 y un conteo d&amp;eacute;bil de 0, porque la variable &lt;code&gt;leaf&lt;/code&gt; es ahora la &amp;uacute;nica referencia al &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; nuevamente.</target>
        </trans-unit>
        <trans-unit id="dbfc404f11392f04791b1e2ab5a9b874585793ff" translate="yes" xml:space="preserve">
          <source>If we try to call the &lt;code&gt;Drop&lt;/code&gt; trait&amp;rsquo;s &lt;code&gt;drop&lt;/code&gt; method manually by modifying the &lt;code&gt;main&lt;/code&gt; function from Listing 15-14, as shown in Listing 15-15, we&amp;rsquo;ll get a compiler error:</source>
          <target state="translated">Si intentamos llamar al m&amp;eacute;todo de &lt;code&gt;drop&lt;/code&gt; del rasgo &lt;code&gt;Drop&lt;/code&gt; manualmente modificando la funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; del Listado 15-14, como se muestra en el Listado 15-15, obtendremos un error de compilador:</target>
        </trans-unit>
        <trans-unit id="508b7cd6a86a635fd3e7f2924e5c92cb610d409e" translate="yes" xml:space="preserve">
          <source>If we try to compile the code in Listing 15-3, we get the error shown in Listing 15-4:</source>
          <target state="translated">Si intentamos compilar el código en la Lista 15-3,obtenemos el error mostrado en la Lista 15-4:</target>
        </trans-unit>
        <trans-unit id="356aa3ddcc40c463be6fae51bd6d2da9e98de1a0" translate="yes" xml:space="preserve">
          <source>If we try to implement the &lt;code&gt;longest&lt;/code&gt; function as shown in Listing 10-21, it won&amp;rsquo;t compile.</source>
          <target state="translated">Si intentamos implementar la funci&amp;oacute;n &lt;code&gt;longest&lt;/code&gt; como se muestra en el Listado 10-21, no se compilar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="4115f2934de822135b29f8084e1ef304be3b3698" translate="yes" xml:space="preserve">
          <source>If we try to violate these rules, rather than getting a compiler error as we would with references, the implementation of &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; will panic at runtime. Listing 15-23 shows a modification of the implementation of &lt;code&gt;send&lt;/code&gt; in Listing 15-22. We&amp;rsquo;re deliberately trying to create two mutable borrows active for the same scope to illustrate that &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; prevents us from doing this at runtime.</source>
          <target state="translated">Si intentamos violar estas reglas, en lugar de obtener un error del compilador como lo har&amp;iacute;amos con las referencias, la implementaci&amp;oacute;n de &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; entrar&amp;aacute; en p&amp;aacute;nico en tiempo de ejecuci&amp;oacute;n. El Listado 15-23 muestra una modificaci&amp;oacute;n de la implementaci&amp;oacute;n de &lt;code&gt;send&lt;/code&gt; en el Listado 15-22. Intentamos deliberadamente crear dos pr&amp;eacute;stamos mutables activos para el mismo alcance para ilustrar que &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; nos impide hacer esto en tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="33490125b250fc49578a0df8c40853722c24e45b" translate="yes" xml:space="preserve">
          <source>If we use &lt;code&gt;None&lt;/code&gt; rather than &lt;code&gt;Some&lt;/code&gt;, we need to tell Rust what type of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; we have, because the compiler can&amp;rsquo;t infer the type that the &lt;code&gt;Some&lt;/code&gt; variant will hold by looking only at a &lt;code&gt;None&lt;/code&gt; value.</source>
          <target state="translated">Si usamos &lt;code&gt;None&lt;/code&gt; en lugar de &lt;code&gt;Some&lt;/code&gt; , necesitamos decirle a Rust qu&amp;eacute; tipo de &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; tenemos, porque el compilador no puede inferir el tipo que la variante &lt;code&gt;Some&lt;/code&gt; contendr&amp;aacute; mirando solo un valor &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db89280f9463246331f861bb20b0b44756cbd59b" translate="yes" xml:space="preserve">
          <source>If we want to access each element in a vector in turn, we can iterate through all of the elements rather than use indices to access one at a time. Listing 8-8 shows how to use a &lt;code&gt;for&lt;/code&gt; loop to get immutable references to each element in a vector of &lt;code&gt;i32&lt;/code&gt; values and print them.</source>
          <target state="translated">Si queremos acceder a cada elemento en un vector a su vez, podemos iterar a trav&amp;eacute;s de todos los elementos en lugar de utilizar &amp;iacute;ndices para acceder a uno a la vez. El Listado 8-8 muestra c&amp;oacute;mo usar un bucle &lt;code&gt;for&lt;/code&gt; para obtener referencias inmutables a cada elemento en un vector de valores &lt;code&gt;i32&lt;/code&gt; e imprimirlos.</target>
        </trans-unit>
        <trans-unit id="59b1ce32c14325e5555ecb1473306e5c2ee4df8e" translate="yes" xml:space="preserve">
          <source>If we want to bring &lt;em&gt;all&lt;/em&gt; public items defined in a path into scope, we can specify that path followed by &lt;code&gt;*&lt;/code&gt;, the glob operator:</source>
          <target state="translated">Si queremos traer &lt;em&gt;todos&lt;/em&gt; los elementos p&amp;uacute;blicos definidos en una ruta al alcance, podemos especificar esa ruta seguida por &lt;code&gt;*&lt;/code&gt; , el operador glob:</target>
        </trans-unit>
        <trans-unit id="ecacd2ec61672bd426d468428f535112c37b0728" translate="yes" xml:space="preserve">
          <source>If we want to see printed values for passing tests as well, we can disable the output capture behavior by using the &lt;code&gt;--nocapture&lt;/code&gt; flag:</source>
          <target state="translated">Si tambi&amp;eacute;n queremos ver los valores impresos para pasar las pruebas, podemos deshabilitar el comportamiento de captura de salida usando el indicador &lt;code&gt;--nocapture&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="05c7ba5ef2e7723af5524e8b4d89c5b4dc32b80d" translate="yes" xml:space="preserve">
          <source>If we want to see printed values for passing tests as well, we can tell Rust to also show the output of successful tests at the end with &lt;code&gt;--show-output&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a582928a24dff1951656692ced5e56692b89dd3" translate="yes" xml:space="preserve">
          <source>If we wanted this function to allow &lt;code&gt;item1&lt;/code&gt; and &lt;code&gt;item2&lt;/code&gt; to have different types, using &lt;code&gt;impl Trait&lt;/code&gt; would be appropriate (as long as both types implement &lt;code&gt;Summary&lt;/code&gt;). If we wanted to force both parameters to have the same type, that&amp;rsquo;s only possible to express using a trait bound, like this:</source>
          <target state="translated">Si quisi&amp;eacute;ramos esta funci&amp;oacute;n para permitir &lt;code&gt;item1&lt;/code&gt; y &lt;code&gt;item2&lt;/code&gt; que tienen diferentes tipos, utilizando &lt;code&gt;impl Trait&lt;/code&gt; ser&amp;iacute;a apropiado (siempre que ambos tipos implementan &lt;code&gt;Summary&lt;/code&gt; ). Si quisi&amp;eacute;ramos forzar que ambos par&amp;aacute;metros tengan el mismo tipo, solo es posible expresarlo usando un l&amp;iacute;mite de rasgo, como este:</target>
        </trans-unit>
        <trans-unit id="081b049808c06cb466640ee9a7514dc2c103759d" translate="yes" xml:space="preserve">
          <source>If we wanted to ignore one or more of the values in the tuple, we could use &lt;code&gt;_&lt;/code&gt; or &lt;code&gt;..&lt;/code&gt;, as you&amp;rsquo;ll see in the &lt;a href=&quot;ch18-03-pattern-syntax#ignoring-values-in-a-pattern&quot;&gt;&amp;ldquo;Ignoring Values in a Pattern&amp;rdquo;&lt;/a&gt; section. If the problem is that we have too many variables in the pattern, the solution is to make the types match by removing variables so the number of variables equals the number of elements in the tuple.</source>
          <target state="translated">Si quisi&amp;eacute;ramos ignorar uno o m&amp;aacute;s de los valores en la tupla, podr&amp;iacute;amos usar &lt;code&gt;_&lt;/code&gt; o &lt;code&gt;..&lt;/code&gt; , como ver&amp;aacute; en la secci&amp;oacute;n &lt;a href=&quot;ch18-03-pattern-syntax#ignoring-values-in-a-pattern&quot;&gt;&quot;Ignorar valores en un patr&amp;oacute;n&quot;&lt;/a&gt; . Si el problema es que tenemos demasiadas variables en el patr&amp;oacute;n, la soluci&amp;oacute;n es hacer que los tipos coincidan eliminando variables para que el n&amp;uacute;mero de variables sea igual al n&amp;uacute;mero de elementos en la tupla.</target>
        </trans-unit>
        <trans-unit id="43509b2eb6e52b66cb9ff0f7f464bfc498c6c385" translate="yes" xml:space="preserve">
          <source>If we were allowed to run this code, there&amp;rsquo;s a possibility the spawned thread would be immediately put in the background without running at all. The spawned thread has a reference to &lt;code&gt;v&lt;/code&gt; inside, but the main thread immediately drops &lt;code&gt;v&lt;/code&gt;, using the &lt;code&gt;drop&lt;/code&gt; function we discussed in Chapter 15. Then, when the spawned thread starts to execute, &lt;code&gt;v&lt;/code&gt; is no longer valid, so a reference to it is also invalid. Oh no!</source>
          <target state="translated">Si pudi&amp;eacute;ramos ejecutar este c&amp;oacute;digo, existe la posibilidad de que el hilo generado se coloque inmediatamente en segundo plano sin ejecutarse en absoluto. El subproceso generado tiene una referencia a &lt;code&gt;v&lt;/code&gt; dentro, pero el subproceso principal elimina inmediatamente &lt;code&gt;v&lt;/code&gt; , utilizando la funci&amp;oacute;n de &lt;code&gt;drop&lt;/code&gt; que discutimos en el Cap&amp;iacute;tulo 15. Luego, cuando el subproceso generado comienza a ejecutarse, &lt;code&gt;v&lt;/code&gt; ya no es v&amp;aacute;lido, por lo que una referencia a &amp;eacute;l es tambi&amp;eacute;n inv&amp;aacute;lido. &amp;iexcl;Oh no!</target>
        </trans-unit>
        <trans-unit id="800a58868e2237c8fac619c4b8e2c0a22bb50724" translate="yes" xml:space="preserve">
          <source>If we were to call &lt;code&gt;value_in_cents(Coin::Quarter(UsState::Alaska))&lt;/code&gt;, &lt;code&gt;coin&lt;/code&gt; would be &lt;code&gt;Coin::Quarter(UsState::Alaska)&lt;/code&gt;. When we compare that value with each of the match arms, none of them match until we reach &lt;code&gt;Coin::Quarter(state)&lt;/code&gt;. At that point, the binding for &lt;code&gt;state&lt;/code&gt; will be the value &lt;code&gt;UsState::Alaska&lt;/code&gt;. We can then use that binding in the &lt;code&gt;println!&lt;/code&gt; expression, thus getting the inner state value out of the &lt;code&gt;Coin&lt;/code&gt; enum variant for &lt;code&gt;Quarter&lt;/code&gt;.</source>
          <target state="translated">Si tuvi&amp;eacute;ramos que llamar &lt;code&gt;value_in_cents(Coin::Quarter(UsState::Alaska))&lt;/code&gt; , la &lt;code&gt;coin&lt;/code&gt; ser&amp;iacute;a &lt;code&gt;Coin::Quarter(UsState::Alaska)&lt;/code&gt; . Cuando comparamos ese valor con cada uno de los brazos de coincidencia, ninguno de ellos coincide hasta que llegamos a &lt;code&gt;Coin::Quarter(state)&lt;/code&gt; . En ese momento, el enlace para el &lt;code&gt;state&lt;/code&gt; ser&amp;aacute; el valor &lt;code&gt;UsState::Alaska&lt;/code&gt; . &amp;iexcl;Entonces podemos usar ese enlace en &lt;code&gt;println!&lt;/code&gt; expresi&amp;oacute;n, obteniendo as&amp;iacute; el valor del estado interno de la variante de enumeraci&amp;oacute;n &lt;code&gt;Coin&lt;/code&gt; para &lt;code&gt;Quarter&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24bb7707d39d3c3128c279561fde2df4d9c496d5" translate="yes" xml:space="preserve">
          <source>If we were to create an alternative implementation that didn&amp;rsquo;t use the state pattern, we might instead use &lt;code&gt;match&lt;/code&gt; expressions in the methods on &lt;code&gt;Post&lt;/code&gt; or even in the &lt;code&gt;main&lt;/code&gt; code that checks the state of the post and changes behavior in those places. That would mean we would have to look in several places to understand all the implications of a post being in the published state! This would only increase the more states we added: each of those &lt;code&gt;match&lt;/code&gt; expressions would need another arm.</source>
          <target state="translated">Si tuvi&amp;eacute;ramos que crear una implementaci&amp;oacute;n alternativa que no usara el patr&amp;oacute;n de estado, podr&amp;iacute;amos usar expresiones &lt;code&gt;match&lt;/code&gt; en los m&amp;eacute;todos en &lt;code&gt;Post&lt;/code&gt; o incluso en el c&amp;oacute;digo &lt;code&gt;main&lt;/code&gt; que verifica el estado de la publicaci&amp;oacute;n y cambia el comportamiento en esos lugares. &amp;iexcl;Eso significar&amp;iacute;a que tendr&amp;iacute;amos que buscar en varios lugares para comprender todas las implicaciones de que una publicaci&amp;oacute;n est&amp;eacute; en el estado publicado! Esto solo aumentar&amp;iacute;a cuantos m&amp;aacute;s estados agreguemos: cada una de esas expresiones de &lt;code&gt;match&lt;/code&gt; necesitar&amp;iacute;a otro brazo.</target>
        </trans-unit>
        <trans-unit id="75317df9fc9654e5dff79b3ede765cb275596098" translate="yes" xml:space="preserve">
          <source>If we&amp;rsquo;re using multiple items defined in the same crate or same module, listing each item on its own line can take up a lot of vertical space in our files. For example, these two &lt;code&gt;use&lt;/code&gt; statements we had in the Guessing Game in Listing 2-4 bring items from &lt;code&gt;std&lt;/code&gt; into scope:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c510fe09c79d935a20cfb821edcb59eeece4e5e" translate="yes" xml:space="preserve">
          <source>If we&amp;rsquo;re using multiple items defined in the same package or same module, listing each item on its own line can take up a lot of vertical space in our files. For example, these two &lt;code&gt;use&lt;/code&gt; statements we had in Listing 2-4 in the Guessing Game bring items from &lt;code&gt;std&lt;/code&gt; into scope:</source>
          <target state="translated">Si utilizamos varios elementos definidos en el mismo paquete o m&amp;oacute;dulo, enumerar cada elemento en su propia l&amp;iacute;nea puede ocupar mucho espacio vertical en nuestros archivos. Por ejemplo, estas dos declaraciones de &lt;code&gt;use&lt;/code&gt; que ten&amp;iacute;amos en el Listado 2-4 en el Juego de Adivinanzas traen elementos de &lt;code&gt;std&lt;/code&gt; al alcance:</target>
        </trans-unit>
        <trans-unit id="1e5c7c085207b2b3646e21a3cf1669e6a93ba6f6" translate="yes" xml:space="preserve">
          <source>If you &lt;em&gt;do&lt;/em&gt; write that in Rust, the compiler will give you a warning (by default, controlled by the &lt;code&gt;unused_must_use&lt;/code&gt; lint).</source>
          <target state="translated">Si &lt;em&gt;haces&lt;/em&gt; de escritura que en Rust, el compilador le dar&amp;aacute; una advertencia (por defecto, controlado por el &lt;code&gt;unused_must_use&lt;/code&gt; pelusa).</target>
        </trans-unit>
        <trans-unit id="0b6f4208cc3cd5d0efb30ee565f817f70bd28255" translate="yes" xml:space="preserve">
          <source>If you already know the name of what you are looking for, the fastest way to find it is to use the search bar at the top of the page.</source>
          <target state="translated">Si ya sabes el nombre de lo que estás buscando,la forma más rápida de encontrarlo es usar la barra de búsqueda en la parte superior de la página.</target>
        </trans-unit>
        <trans-unit id="6ecce765aae2c5dfe3bf74974f6a9aa5e5412c0c" translate="yes" xml:space="preserve">
          <source>If you are defining your own smart pointer type and would like to enable conversion from a sized to an unsized type with the &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md&quot;&gt;DST coercion system&lt;/a&gt;, use &lt;a href=&quot;std/ops/trait.coerceunsized&quot;&gt;&lt;code&gt;CoerceUnsized&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Si est&amp;aacute; definiendo su propio tipo de puntero inteligente y le gustar&amp;iacute;a habilitar la conversi&amp;oacute;n de un tipo de tama&amp;ntilde;o a uno sin tama&amp;ntilde;o con el &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md&quot;&gt;sistema de coerci&amp;oacute;n DST&lt;/a&gt; , use &lt;a href=&quot;std/ops/trait.coerceunsized&quot;&gt; &lt;code&gt;CoerceUnsized&lt;/code&gt; &lt;/a&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="66477a0847de02b7542626d1278a3f568234bcb5" translate="yes" xml:space="preserve">
          <source>If you are good at thinking in types, you can think of &lt;code&gt;map()&lt;/code&gt; like this: If you have an iterator that gives you elements of some type &lt;code&gt;A&lt;/code&gt;, and you want an iterator of some other type &lt;code&gt;B&lt;/code&gt;, you can use &lt;code&gt;map()&lt;/code&gt;, passing a closure that takes an &lt;code&gt;A&lt;/code&gt; and returns a &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">Si eres bueno pensando en tipos, puedes pensar en &lt;code&gt;map()&lt;/code&gt; as&amp;iacute;: si tienes un iterador que te da elementos de alg&amp;uacute;n tipo &lt;code&gt;A&lt;/code&gt; , y quieres un iterador de alg&amp;uacute;n otro tipo &lt;code&gt;B&lt;/code&gt; , puedes usar &lt;code&gt;map()&lt;/code&gt; , pasando un cierre que tiene una &lt;code&gt;A&lt;/code&gt; y devuelve un &lt;code&gt;B&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3dcd4a0e63a2a163e2870bf93d8878778590c39f" translate="yes" xml:space="preserve">
          <source>If you are sure that the byte slice is valid UTF-8, and you don't want to incur the overhead of the conversion, there is an unsafe version of this function, &lt;a href=&quot;struct.string#method.from_utf8_unchecked&quot;&gt;&lt;code&gt;from_utf8_unchecked&lt;/code&gt;&lt;/a&gt;, which has the same behavior but skips the checks.</source>
          <target state="translated">Si est&amp;aacute; seguro de que el segmento de bytes es UTF-8 v&amp;aacute;lido y no desea incurrir en la sobrecarga de la conversi&amp;oacute;n, existe una versi&amp;oacute;n insegura de esta funci&amp;oacute;n, &lt;a href=&quot;struct.string#method.from_utf8_unchecked&quot;&gt; &lt;code&gt;from_utf8_unchecked&lt;/code&gt; &lt;/a&gt; , que tiene el mismo comportamiento pero omite las comprobaciones.</target>
        </trans-unit>
        <trans-unit id="70a26cf07cad3d4651db91a560fa471c2d93cbb7" translate="yes" xml:space="preserve">
          <source>If you are sure that the byte slice is valid UTF-8, and you don't want to incur the overhead of the validity check, there is an unsafe version of this function, &lt;a href=&quot;fn.from_utf8_unchecked&quot;&gt;&lt;code&gt;from_utf8_unchecked&lt;/code&gt;&lt;/a&gt;, which has the same behavior but skips the check.</source>
          <target state="translated">Si est&amp;aacute; seguro de que el segmento de bytes es UTF-8 v&amp;aacute;lido y no desea incurrir en la sobrecarga de la verificaci&amp;oacute;n de validez, hay una versi&amp;oacute;n insegura de esta funci&amp;oacute;n, &lt;a href=&quot;fn.from_utf8_unchecked&quot;&gt; &lt;code&gt;from_utf8_unchecked&lt;/code&gt; &lt;/a&gt; , que tiene el mismo comportamiento pero omite la verificaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="72764b3fde213adc88d425dd4be37c972ecfcc18" translate="yes" xml:space="preserve">
          <source>If you are sure that the byte slice is valid UTF-8, and you don't want to incur the overhead of the validity check, there is an unsafe version of this function, &lt;a href=&quot;struct.string#method.from_utf8_unchecked&quot;&gt;&lt;code&gt;from_utf8_unchecked&lt;/code&gt;&lt;/a&gt;, which has the same behavior but skips the check.</source>
          <target state="translated">Si est&amp;aacute; seguro de que el segmento de bytes es UTF-8 v&amp;aacute;lido y no desea incurrir en la sobrecarga de la verificaci&amp;oacute;n de validez, hay una versi&amp;oacute;n insegura de esta funci&amp;oacute;n, &lt;a href=&quot;struct.string#method.from_utf8_unchecked&quot;&gt; &lt;code&gt;from_utf8_unchecked&lt;/code&gt; &lt;/a&gt; , que tiene el mismo comportamiento pero omite la verificaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ec9b3e217ed7bc91bb00c80e7f9d1bd56da37e45" translate="yes" xml:space="preserve">
          <source>If you are sure the pointer can never be null and are looking for some kind of &lt;code&gt;as_mut_unchecked&lt;/code&gt; that returns the &lt;code&gt;&amp;amp;mut T&lt;/code&gt; instead of &lt;code&gt;Option&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt;, know that you can dereference the pointer directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e4c7437a6a564088a56f1865abca59f4d577976" translate="yes" xml:space="preserve">
          <source>If you are sure the pointer can never be null and are looking for some kind of &lt;code&gt;as_ref_unchecked&lt;/code&gt; that returns the &lt;code&gt;&amp;amp;T&lt;/code&gt; instead of &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt;, know that you can dereference the pointer directly.</source>
          <target state="translated">Si est&amp;aacute; seguro de que el puntero nunca puede ser nulo y est&amp;aacute; buscando alg&amp;uacute;n tipo de &lt;code&gt;as_ref_unchecked&lt;/code&gt; que devuelva &lt;code&gt;&amp;amp;T&lt;/code&gt; lugar de &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; , sepa que puede eliminar la referencia del puntero directamente.</target>
        </trans-unit>
        <trans-unit id="a8aa6751d5dba0ca9b5b9835bc110d6acd1e850e" translate="yes" xml:space="preserve">
          <source>If you are trying to cast a numeric type to a bool, you can compare it with zero instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1b515d34e658e3eaec145f92af8986a5d9085c3" translate="yes" xml:space="preserve">
          <source>If you are using shorthand field patterns but want to refer to the struct field by a different name, you should rename it explicitly.</source>
          <target state="translated">Si está usando patrones de campos abreviados pero quiere referirse al campo de estructura con un nombre diferente,debe renombrarlo explícitamente.</target>
        </trans-unit>
        <trans-unit id="667b81601454358fbbba0b10884eb54779935f54" translate="yes" xml:space="preserve">
          <source>If you are using shorthand field patterns but want to refer to the struct field by a different name, you should rename it explicitly. Struct fields are identified by the name used before the colon &lt;code&gt;:&lt;/code&gt; so struct patterns should resemble the declaration of the struct type being matched.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52d98e4ed274b2f1754b60874045cd81c4a04b5d" translate="yes" xml:space="preserve">
          <source>If you are writing a program that will process an existing file format, check what that format's definition of whitespace is before using this function.</source>
          <target state="translated">Si está escribiendo un programa que procesará un formato de archivo existente,compruebe cuál es la definición de espacio en blanco de ese formato antes de usar esta función.</target>
        </trans-unit>
        <trans-unit id="3049570361a92b7df46a925de03339dbac72cca9" translate="yes" xml:space="preserve">
          <source>If you cannot access the directory containing the file, e.g., because of a permission error, this will return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si no puede acceder al directorio que contiene el archivo, por ejemplo, debido a un error de permiso, esto devolver&amp;aacute; &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="458a7fb4ac06186fc13af81b6a29de1ace17f81e" translate="yes" xml:space="preserve">
          <source>If you cannot use the &lt;code&gt;derive&lt;/code&gt; strategy, specify that your type implements &lt;code&gt;Eq&lt;/code&gt;, which has no methods:</source>
          <target state="translated">Si no puede usar la estrategia de &lt;code&gt;derive&lt;/code&gt; , especifique que su tipo implementa &lt;code&gt;Eq&lt;/code&gt; , que no tiene m&amp;eacute;todos:</target>
        </trans-unit>
        <trans-unit id="d0466a77e31d18684a221949891d87548a998d3f" translate="yes" xml:space="preserve">
          <source>If you create a safe reference with lifetime &lt;code&gt;'a&lt;/code&gt; (either a &lt;code&gt;&amp;amp;T&lt;/code&gt; or &lt;code&gt;&amp;amp;mut T&lt;/code&gt; reference) that is accessible by safe code (for example, because you returned it), then you must not access the data in any way that contradicts that reference for the remainder of &lt;code&gt;'a&lt;/code&gt;. For example, this means that if you take the &lt;code&gt;*mut T&lt;/code&gt; from an &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; and cast it to an &lt;code&gt;&amp;amp;T&lt;/code&gt;, then the data in &lt;code&gt;T&lt;/code&gt; must remain immutable (modulo any &lt;code&gt;UnsafeCell&lt;/code&gt; data found within &lt;code&gt;T&lt;/code&gt;, of course) until that reference's lifetime expires. Similarly, if you create a &lt;code&gt;&amp;amp;mut T&lt;/code&gt; reference that is released to safe code, then you must not access the data within the &lt;code&gt;UnsafeCell&lt;/code&gt; until that reference expires.</source>
          <target state="translated">Si crea una referencia segura con una duraci&amp;oacute;n &lt;code&gt;'a&lt;/code&gt; (ya sea una referencia a &lt;code&gt;&amp;amp;T&lt;/code&gt; o &lt;code&gt;&amp;amp;mut T&lt;/code&gt; ) a la que se puede acceder mediante un c&amp;oacute;digo seguro (por ejemplo, porque lo devolvi&amp;oacute;), entonces no debe acceder a los datos de ninguna manera que contradiga esa referencia para el resto de &lt;code&gt;'a&lt;/code&gt; . Por ejemplo, esto significa que si toma el &lt;code&gt;*mut T&lt;/code&gt; de un &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; y lo convierte en un &lt;code&gt;&amp;amp;T&lt;/code&gt; , entonces los datos en &lt;code&gt;T&lt;/code&gt; deben permanecer inmutables (m&amp;oacute;dulo cualquier dato de &lt;code&gt;UnsafeCell&lt;/code&gt; encontrado dentro de &lt;code&gt;T&lt;/code&gt; , por supuesto) hasta la vida &amp;uacute;til de esa referencia expira. Del mismo modo, si crea un &lt;code&gt;&amp;amp;mut T&lt;/code&gt; referencia que se publica a un c&amp;oacute;digo seguro, entonces no debe acceder a los datos dentro de &lt;code&gt;UnsafeCell&lt;/code&gt; hasta que esa referencia caduque.</target>
        </trans-unit>
        <trans-unit id="0185ed1fba59b251fe1857608aaa4660006fe514" translate="yes" xml:space="preserve">
          <source>If you create a variable but don&amp;rsquo;t use it anywhere, Rust will usually issue a warning because that could be a bug. But sometimes it&amp;rsquo;s useful to create a variable you won&amp;rsquo;t use yet, such as when you&amp;rsquo;re prototyping or just starting a project. In this situation, you can tell Rust not to warn you about the unused variable by starting the name of the variable with an underscore. In Listing 18-20, we create two unused variables, but when we run this code, we should only get a warning about one of them.</source>
          <target state="translated">Si crea una variable pero no la usa en ning&amp;uacute;n lugar, Rust generalmente emitir&amp;aacute; una advertencia porque podr&amp;iacute;a ser un error. Pero a veces es &amp;uacute;til crear una variable que a&amp;uacute;n no usar&amp;aacute;, como cuando est&amp;aacute; creando un prototipo o reci&amp;eacute;n iniciando un proyecto. En esta situaci&amp;oacute;n, puede decirle a Rust que no le advierta sobre la variable no utilizada comenzando el nombre de la variable con un gui&amp;oacute;n bajo. En el Listado 18-20, creamos dos variables no utilizadas, pero cuando ejecutamos este c&amp;oacute;digo, solo deber&amp;iacute;amos recibir una advertencia sobre una de ellas.</target>
        </trans-unit>
        <trans-unit id="53d962e32cf41eea1b88858329905f991b93fcaa" translate="yes" xml:space="preserve">
          <source>If you decide to use trait objects, be aware that these rely on &lt;a href=&quot;book/ch17-02-trait-objects#trait-objects-perform-dynamic-dispatch&quot;&gt;dynamic dispatch&lt;/a&gt;, which has performance implications, as the compiler needs to emit code that will figure out which method to call &lt;em&gt;at runtime&lt;/em&gt; instead of during compilation. Using trait objects we are trading flexibility for performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="495358664585a670e9065e75b0da97e6c9808c60" translate="yes" xml:space="preserve">
          <source>If you do not have an &lt;code&gt;&amp;amp;T&lt;/code&gt;, but just an &lt;code&gt;&amp;amp;U&lt;/code&gt; such that &lt;code&gt;T: Borrow&amp;lt;U&amp;gt;&lt;/code&gt; (e.g. &lt;code&gt;String: Borrow&amp;lt;str&amp;gt;&lt;/code&gt;), you can use &lt;code&gt;iter().any&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05624f4cd79d0d50c7459fc7a7809ab013e516d2" translate="yes" xml:space="preserve">
          <source>If you do not want this &quot;at least&quot; behavior, see the &lt;a href=&quot;struct.string#method.reserve_exact&quot;&gt;&lt;code&gt;reserve_exact&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Si no desea este comportamiento &quot;al menos&quot;, consulte el m&amp;eacute;todo &lt;a href=&quot;struct.string#method.reserve_exact&quot;&gt; &lt;code&gt;reserve_exact&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3fa75551a6e58e68f711ab2f03a9cc21a66d738a" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t call &lt;code&gt;expect&lt;/code&gt;, the program will compile, but you&amp;rsquo;ll get a warning:</source>
          <target state="translated">Si no llama a &lt;code&gt;expect&lt;/code&gt; , el programa se compilar&amp;aacute;, pero recibir&amp;aacute; una advertencia:</target>
        </trans-unit>
        <trans-unit id="aa9b352f2a9ad676e75ebea1e09ea589739aa744" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to run the tests in parallel or if you want more fine-grained control over the number of threads used, you can send the &lt;code&gt;--test-threads&lt;/code&gt; flag and the number of threads you want to use to the test binary. Take a look at the following example:</source>
          <target state="translated">Si no desea ejecutar las pruebas en paralelo o si desea un control m&amp;aacute;s detallado sobre la cantidad de subprocesos utilizados, puede enviar la &lt;code&gt;--test-threads&lt;/code&gt; y la cantidad de subprocesos que desea utilizar para la prueba binario. Eche un vistazo al siguiente ejemplo:</target>
        </trans-unit>
        <trans-unit id="8dc704dcbb9c3ebe8a328db6c83f459b5ea12df0" translate="yes" xml:space="preserve">
          <source>If you don't care about signaling-ness (very likely), then there is no portability concern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03f408e5bb66764d7ffd1cc87bf60d44d2f11a95" translate="yes" xml:space="preserve">
          <source>If you don't care about signalingness (very likely), then there is no portability concern.</source>
          <target state="translated">Si no te preocupas por la señalización (muy probablemente),entonces no hay preocupación por la portabilidad.</target>
        </trans-unit>
        <trans-unit id="eccfed5b1fccd97fad68aa10ed7d3af7af7893a9" translate="yes" xml:space="preserve">
          <source>If you don't know the basics of Rust, you can go look to the Rust Book to get started: https://doc.rust-lang.org/book/</source>
          <target state="translated">Si no conoces los fundamentos del óxido,puedes ir a mirar el Libro del Óxido para empezar:https://doc.rust-lang.org/book/</target>
        </trans-unit>
        <trans-unit id="e26edf9b7f412dd5926032771fa72456da3e35ef" translate="yes" xml:space="preserve">
          <source>If you don't know the basics of Rust, you can look at the &lt;a href=&quot;index&quot;&gt;Rust Book&lt;/a&gt; to get started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf6d5abeee91a58bb08b86aab21ccdd70a1f28d4" translate="yes" xml:space="preserve">
          <source>If you don't qualify the names, the code will bind new variables named &quot;GET&quot; and &quot;POST&quot; instead. This behavior is likely not what you want, so &lt;code&gt;rustc&lt;/code&gt; warns when that happens.</source>
          <target state="translated">Si no califica los nombres, el c&amp;oacute;digo enlazar&amp;aacute; nuevas variables llamadas &quot;GET&quot; y &quot;POST&quot; en su lugar. Es probable que este comportamiento no sea el que desea, por lo que &lt;code&gt;rustc&lt;/code&gt; advierte cuando eso sucede.</target>
        </trans-unit>
        <trans-unit id="30e1c43099f6397f247562dd2f5b6571eda814ad" translate="yes" xml:space="preserve">
          <source>If you encounter this error you must alter your patterns so that every possible value of the input type is matched. For types with a small number of variants (like enums) you should probably cover all cases explicitly. Alternatively, the underscore &lt;code&gt;_&lt;/code&gt; wildcard pattern can be added after all other patterns to match &quot;anything else&quot;. Example:</source>
          <target state="translated">Si encuentra este error, debe modificar sus patrones para que coincidan todos los valores posibles del tipo de entrada. Para tipos con una peque&amp;ntilde;a cantidad de variantes (como enumeraciones) probablemente deber&amp;iacute;a cubrir todos los casos expl&amp;iacute;citamente. Alternativamente, el patr&amp;oacute;n de gui&amp;oacute;n bajo &lt;code&gt;_&lt;/code&gt; comod&amp;iacute;n se puede agregar despu&amp;eacute;s de todos los dem&amp;aacute;s patrones para que coincida con &quot;cualquier otra cosa&quot;. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="c99fe79ebb0d8c77c7785b8167d26f6b602a1b29" translate="yes" xml:space="preserve">
          <source>If you encounter this error you probably need to use a &lt;code&gt;match&lt;/code&gt; or &lt;code&gt;if let&lt;/code&gt; to deal with the possibility of failure. Example:</source>
          <target state="translated">Si encuentra este error, probablemente necesite usar una &lt;code&gt;match&lt;/code&gt; o, &lt;code&gt;if let&lt;/code&gt; lidiar con la posibilidad de falla. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="289fc8ad6bfff7525b7f4a843265b14e717b2af6" translate="yes" xml:space="preserve">
          <source>If you have a C or C++ background, you&amp;rsquo;ll notice that this is similar to &lt;code&gt;gcc&lt;/code&gt; or &lt;code&gt;clang&lt;/code&gt;. After compiling successfully, Rust outputs a binary executable.</source>
          <target state="translated">Si tiene experiencia en C o C ++, notar&amp;aacute; que esto es similar a &lt;code&gt;gcc&lt;/code&gt; o &lt;code&gt;clang&lt;/code&gt; . Despu&amp;eacute;s de compilar con &amp;eacute;xito, Rust genera un ejecutable binario.</target>
        </trans-unit>
        <trans-unit id="49d7cea9bb89d7aa1e9d9d998c1c8d8fd8ff2825" translate="yes" xml:space="preserve">
          <source>If you have a list of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;s, you can use &lt;code&gt;collect()&lt;/code&gt; to see if any of them failed:</source>
          <target state="translated">Si tiene una lista de &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; &lt;/a&gt; s, puede usar &lt;code&gt;collect()&lt;/code&gt; para ver si alguno de ellos fall&amp;oacute;:</target>
        </trans-unit>
        <trans-unit id="dbb6609dcc94bde15a6614f094acb0b0abfc28f2" translate="yes" xml:space="preserve">
          <source>If you have a reference &lt;code&gt;&amp;amp;SomeStruct&lt;/code&gt;, then normally in Rust all fields of &lt;code&gt;SomeStruct&lt;/code&gt; are immutable. The compiler makes optimizations based on the knowledge that &lt;code&gt;&amp;amp;T&lt;/code&gt; is not mutably aliased or mutated, and that &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is unique. &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; is the only core language feature to work around the restriction that &lt;code&gt;&amp;amp;T&lt;/code&gt; may not be mutated. All other types that allow internal mutability, such as &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, use &lt;code&gt;UnsafeCell&lt;/code&gt; to wrap their internal data. There is &lt;em&gt;no&lt;/em&gt; legal way to obtain aliasing &lt;code&gt;&amp;amp;mut&lt;/code&gt;, not even with &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="603c68300fca461a298a423a92a14317f38dd713" translate="yes" xml:space="preserve">
          <source>If you have a reference &lt;code&gt;&amp;amp;SomeStruct&lt;/code&gt;, then normally in Rust all fields of &lt;code&gt;SomeStruct&lt;/code&gt; are immutable. The compiler makes optimizations based on the knowledge that &lt;code&gt;&amp;amp;T&lt;/code&gt; is not mutably aliased or mutated, and that &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is unique. &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; is the only core language feature to work around this restriction. All other types that allow internal mutability, such as &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, use &lt;code&gt;UnsafeCell&lt;/code&gt; to wrap their internal data.</source>
          <target state="translated">Si tiene una referencia &lt;code&gt;&amp;amp;SomeStruct&lt;/code&gt; , normalmente en Rust todos los campos de &lt;code&gt;SomeStruct&lt;/code&gt; son inmutables. El compilador realiza optimizaciones bas&amp;aacute;ndose en el conocimiento de que &lt;code&gt;&amp;amp;T&lt;/code&gt; no tiene un alias o mutaciones mutantes, y que &lt;code&gt;&amp;amp;mut T&lt;/code&gt; es &amp;uacute;nico. &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; es la &amp;uacute;nica caracter&amp;iacute;stica del lenguaje principal que evita esta restricci&amp;oacute;n. Todos los dem&amp;aacute;s tipos que permiten la mutabilidad interna, como &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; y &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; , usan &lt;code&gt;UnsafeCell&lt;/code&gt; para ajustar sus datos internos.</target>
        </trans-unit>
        <trans-unit id="edf1169c29b5f18e94ef5bfa0ce80d44e6e0e706" translate="yes" xml:space="preserve">
          <source>If you have a situation in which your program has logic that is too verbose to express using a &lt;code&gt;match&lt;/code&gt;, remember that &lt;code&gt;if let&lt;/code&gt; is in your Rust toolbox as well.</source>
          <target state="translated">Si tiene una situaci&amp;oacute;n en la que su programa tiene una l&amp;oacute;gica que es demasiado detallada para expresarla usando una &lt;code&gt;match&lt;/code&gt; , recuerde que &lt;code&gt;if let&lt;/code&gt; est&amp;aacute; en su caja de herramientas de Rust.</target>
        </trans-unit>
        <trans-unit id="4d514f69487626541e99f2f08d0b5ef4bda3e112" translate="yes" xml:space="preserve">
          <source>If you have a vector of UTF-8 bytes, you can create a &lt;code&gt;String&lt;/code&gt; from it with the &lt;a href=&quot;#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">Si tiene un vector de bytes UTF-8, puede crear una &lt;code&gt;String&lt;/code&gt; partir de &amp;eacute;l con el m&amp;eacute;todo &lt;a href=&quot;#method.from_utf8&quot;&gt; &lt;code&gt;from_utf8&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="628f5229655ec7d34ffefb0c482b9ec478191d5b" translate="yes" xml:space="preserve">
          <source>If you have a vector of UTF-8 bytes, you can create a &lt;code&gt;String&lt;/code&gt; from it with the &lt;a href=&quot;struct.string#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="594422b6f37e612f2fe4809f8c9021e17bddb83c" translate="yes" xml:space="preserve">
          <source>If you have a vector of valid UTF-8 bytes, you can make a &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; out of it. You can do the reverse too.</source>
          <target state="translated">Si tiene un vector de bytes UTF-8 v&amp;aacute;lidos, puede convertirlo en una &lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; . Tambi&amp;eacute;n puedes hacer lo contrario.</target>
        </trans-unit>
        <trans-unit id="09514694f23f12c4005f6c9a94a1355114b933e9" translate="yes" xml:space="preserve">
          <source>If you have ownership of the &lt;code&gt;MaybeUninit&lt;/code&gt;, you can use &lt;a href=&quot;union.maybeuninit#method.assume_init&quot;&gt;&lt;code&gt;assume_init&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6ce7a19cbb44d746f329213322cf181c479880e" translate="yes" xml:space="preserve">
          <source>If you have ownership of the container, you can use &lt;a href=&quot;#method.into_inner&quot;&gt;&lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Si tiene la propiedad del contenedor, puede usar &lt;a href=&quot;#method.into_inner&quot;&gt; &lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt; &lt;/a&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="25db03dcaf36d059be68f895db3dece722d76812" translate="yes" xml:space="preserve">
          <source>If you have ownership of the value, you can use &lt;a href=&quot;#method.into_inner&quot;&gt;&lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Si tiene la propiedad del valor, puede usar &lt;a href=&quot;#method.into_inner&quot;&gt; &lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt; &lt;/a&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="b2ef31901106431a912012e61b6ed669627013f2" translate="yes" xml:space="preserve">
          <source>If you have ownership of the value, you can use &lt;a href=&quot;struct.manuallydrop#method.into_inner&quot;&gt;&lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbcd3198f789fbc8cbdd096a8ff06c5c6dfc54d9" translate="yes" xml:space="preserve">
          <source>If you have something that implements &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt;, you can use the &lt;a href=&quot;struct.bufreader&quot;&gt;&lt;code&gt;BufReader&lt;/code&gt; type&lt;/a&gt; to turn it into a &lt;code&gt;BufRead&lt;/code&gt;.</source>
          <target state="translated">Si tiene algo que implemente &lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; , puede usar el &lt;a href=&quot;struct.bufreader&quot;&gt;tipo &lt;/a&gt; &lt;code&gt;BufReader&lt;/code&gt; para convertirlo en un &lt;code&gt;BufRead&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26025a7b33e21d0ed3af5941205257def877195b" translate="yes" xml:space="preserve">
          <source>If you immediately run &lt;code&gt;cargo build&lt;/code&gt; again without making any changes, you won&amp;rsquo;t get any output aside from the &lt;code&gt;Finished&lt;/code&gt; line. Cargo knows it has already downloaded and compiled the dependencies, and you haven&amp;rsquo;t changed anything about them in your &lt;em&gt;Cargo.toml&lt;/em&gt; file. Cargo also knows that you haven&amp;rsquo;t changed anything about your code, so it doesn&amp;rsquo;t recompile that either. With nothing to do, it simply exits.</source>
          <target state="translated">Si vuelve a ejecutar inmediatamente la &lt;code&gt;cargo build&lt;/code&gt; sin realizar ning&amp;uacute;n cambio, no obtendr&amp;aacute; ning&amp;uacute;n resultado aparte de la l&amp;iacute;nea de &lt;code&gt;Finished&lt;/code&gt; . Cargo sabe que ya ha descargado y compilado las dependencias, y no ha cambiado nada sobre ellas en su archivo &lt;em&gt;Cargo.toml&lt;/em&gt; . Cargo tambi&amp;eacute;n sabe que no ha cambiado nada sobre su c&amp;oacute;digo, por lo que tampoco lo vuelve a compilar. Sin nada que hacer, simplemente sale.</target>
        </trans-unit>
        <trans-unit id="aead6d9073f2963585c85964dbd5fd9f72b085e1" translate="yes" xml:space="preserve">
          <source>If you need a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; instead of a &lt;code&gt;String&lt;/code&gt;, consider &lt;a href=&quot;../str/fn.from_utf8&quot;&gt;&lt;code&gt;str::from_utf8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si necesita un &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; lugar de un &lt;code&gt;String&lt;/code&gt; , considere &lt;a href=&quot;../str/fn.from_utf8&quot;&gt; &lt;code&gt;str::from_utf8&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fadf8ed3eb8dc56d2e21bd202aa9d97fad2da2e5" translate="yes" xml:space="preserve">
          <source>If you need a &lt;code&gt;&amp;amp;[&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;]&lt;/code&gt; slice &lt;em&gt;with&lt;/em&gt; the nul terminator, you can use &lt;a href=&quot;#method.as_bytes_with_nul&quot;&gt;&lt;code&gt;as_bytes_with_nul&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Si necesita una &lt;code&gt;&amp;amp;[&lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;]&lt;/code&gt; rebanada &lt;em&gt;con&lt;/em&gt; el terminador nulo, puede utilizar &lt;a href=&quot;#method.as_bytes_with_nul&quot;&gt; &lt;code&gt;as_bytes_with_nul&lt;/code&gt; &lt;/a&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="8859e0e13ac4a2988b7250ce45ef124efe28cd7a" translate="yes" xml:space="preserve">
          <source>If you need a &lt;code&gt;&amp;amp;[&lt;/code&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;]&lt;/code&gt; slice &lt;em&gt;with&lt;/em&gt; the nul terminator, you can use &lt;a href=&quot;struct.cstring#method.as_bytes_with_nul&quot;&gt;&lt;code&gt;CString::as_bytes_with_nul&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7efefa0d5ccda958764237a619135366f98b28d8" translate="yes" xml:space="preserve">
          <source>If you need a &lt;code&gt;String&lt;/code&gt; instead of a &lt;code&gt;&amp;amp;str&lt;/code&gt;, consider &lt;a href=&quot;../string/struct.string#method.from_utf8&quot;&gt;&lt;code&gt;String::from_utf8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si necesita un &lt;code&gt;String&lt;/code&gt; en lugar de un &lt;code&gt;&amp;amp;str&lt;/code&gt; , considere &lt;a href=&quot;../string/struct.string#method.from_utf8&quot;&gt; &lt;code&gt;String::from_utf8&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="45013794627f8d7d5a958593854bff018239ef49" translate="yes" xml:space="preserve">
          <source>If you need a reference to the &lt;code&gt;OccupiedEntry&lt;/code&gt; that may outlive the destruction of the &lt;code&gt;Entry&lt;/code&gt; value, see &lt;a href=&quot;#method.into_mut&quot;&gt;&lt;code&gt;into_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si necesita una referencia a &lt;code&gt;OccupiedEntry&lt;/code&gt; que puede sobrevivir a la destrucci&amp;oacute;n del valor de &lt;code&gt;Entry&lt;/code&gt; , consulte &lt;a href=&quot;#method.into_mut&quot;&gt; &lt;code&gt;into_mut&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="219941c8b5f5991f98f925058a19ec303a64916f" translate="yes" xml:space="preserve">
          <source>If you need a reference to the &lt;code&gt;OccupiedEntry&lt;/code&gt; that may outlive the destruction of the &lt;code&gt;Entry&lt;/code&gt; value, see &lt;a href=&quot;struct.occupiedentry#method.into_mut&quot;&gt;&lt;code&gt;into_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76f640be80a9e8c1bdad2ee8c022f44a0a1aaaf8" translate="yes" xml:space="preserve">
          <source>If you need a reference to the &lt;code&gt;OccupiedEntry&lt;/code&gt; which may outlive the destruction of the &lt;code&gt;Entry&lt;/code&gt; value, see &lt;a href=&quot;#method.into_mut&quot;&gt;&lt;code&gt;into_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si necesita una referencia a &lt;code&gt;OccupiedEntry&lt;/code&gt; que puede sobrevivir a la destrucci&amp;oacute;n del valor de &lt;code&gt;Entry&lt;/code&gt; , consulte &lt;a href=&quot;#method.into_mut&quot;&gt; &lt;code&gt;into_mut&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0102aa221685138b4538e7bcf99473f525d3ae0b" translate="yes" xml:space="preserve">
          <source>If you need a reference to the &lt;code&gt;OccupiedEntry&lt;/code&gt; which may outlive the destruction of the &lt;code&gt;Entry&lt;/code&gt; value, see &lt;a href=&quot;struct.occupiedentry#method.into_mut&quot;&gt;&lt;code&gt;into_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a60e3312521d167a8398684f23a8bda2cd769f2d" translate="yes" xml:space="preserve">
          <source>If you need more control over how a value is hashed, you can of course implement the &lt;code&gt;Hash&lt;/code&gt; trait yourself:</source>
          <target state="translated">Si necesita m&amp;aacute;s control sobre c&amp;oacute;mo se codifica un valor, por supuesto, puede implementar el rasgo &lt;code&gt;Hash&lt;/code&gt; usted mismo:</target>
        </trans-unit>
        <trans-unit id="efc0a9fb0d5d442c54eae5e0575801419c0ddc5b" translate="yes" xml:space="preserve">
          <source>If you need more control over how a value is hashed, you need to implement the &lt;a href=&quot;trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; trait:</source>
          <target state="translated">Si necesita m&amp;aacute;s control sobre c&amp;oacute;mo se aplica el &lt;a href=&quot;trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; un valor, debe implementar el rasgo Hash :</target>
        </trans-unit>
        <trans-unit id="0241681a3d3ab7483e993964ada28ea51777d3f5" translate="yes" xml:space="preserve">
          <source>If you need multiple references to the &lt;code&gt;OccupiedEntry&lt;/code&gt;, see &lt;a href=&quot;#method.get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si necesita varias referencias a &lt;code&gt;OccupiedEntry&lt;/code&gt; , consulte &lt;a href=&quot;#method.get_mut&quot;&gt; &lt;code&gt;get_mut&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c038d740f3ac229d9b9c028c5b74e72acefec36c" translate="yes" xml:space="preserve">
          <source>If you need multiple references to the &lt;code&gt;OccupiedEntry&lt;/code&gt;, see &lt;a href=&quot;struct.occupiedentry#method.get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ade792259bb48c52c18a2f2d1b3c073ea1c7a1" translate="yes" xml:space="preserve">
          <source>If you need the feature, make sure to use a nightly release of the compiler (but be warned that the feature may be removed or altered in the future).</source>
          <target state="translated">Si necesita la función,asegúrese de utilizar una versión nocturna del compilador (pero tenga en cuenta que la función puede ser eliminada o alterada en el futuro).</target>
        </trans-unit>
        <trans-unit id="8d959103a15d2de9826ef517fc6c5926c4dc9c0f" translate="yes" xml:space="preserve">
          <source>If you need this, there's a good chance you're doing something wrong. Keep in mind that Rust doesn't guarantee much about the layout of different structs (even two structs with identical declarations may have different layouts). If there is a solution that avoids the transmute entirely, try it instead.</source>
          <target state="translated">Si necesitas esto,hay una buena posibilidad de que estés haciendo algo mal.Ten en cuenta que Rust no garantiza mucho sobre la disposición de las diferentes estructuras (incluso dos estructuras con declaraciones idénticas pueden tener diferentes disposiciones).Si hay una solución que evita completamente la transmutación,inténtalo en su lugar.</target>
        </trans-unit>
        <trans-unit id="18db342a00e23c3779573ca28794a36c6f8d6e91" translate="yes" xml:space="preserve">
          <source>If you need to cross object boundaries, cast the pointer to an integer and do the arithmetic there.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d12ddc464aa8618d85b99bead398fd46eff9e38" translate="yes" xml:space="preserve">
          <source>If you need to obtain the length of &lt;em&gt;many&lt;/em&gt; streams and you don't care about the seek position afterwards, you can reduce the number of seek operations by simply calling &lt;code&gt;seek(SeekFrom::End(0))&lt;/code&gt; and using its return value (it is also the stream length).</source>
          <target state="translated">Si necesita obtener la longitud de &lt;em&gt;muchas&lt;/em&gt; transmisiones y no le importa la posici&amp;oacute;n de b&amp;uacute;squeda despu&amp;eacute;s, puede reducir la cantidad de operaciones de b&amp;uacute;squeda simplemente llamando a &lt;code&gt;seek(SeekFrom::End(0))&lt;/code&gt; y usando su valor de retorno (it es tambi&amp;eacute;n la longitud de la corriente).</target>
        </trans-unit>
        <trans-unit id="35592f144aa64ae5ca74cce00e23680445e57820" translate="yes" xml:space="preserve">
          <source>If you need to perform operations on individual Unicode scalar values, the best way to do so is to use the &lt;code&gt;chars&lt;/code&gt; method. Calling &lt;code&gt;chars&lt;/code&gt; on &amp;ldquo;नमस्ते&amp;rdquo; separates out and returns six values of type &lt;code&gt;char&lt;/code&gt;, and you can iterate over the result to access each element:</source>
          <target state="translated">Si necesita realizar operaciones en valores escalares Unicode individuales, la mejor manera de hacerlo es utilizar el m&amp;eacute;todo &lt;code&gt;chars&lt;/code&gt; . Llamar a los &lt;code&gt;chars&lt;/code&gt; en &quot;नमस्ते&quot; separa y devuelve seis valores de tipo &lt;code&gt;char&lt;/code&gt; , y puede iterar sobre el resultado para acceder a cada elemento:</target>
        </trans-unit>
        <trans-unit id="601e2909b73af510ea23340b158c3431ac0b2075" translate="yes" xml:space="preserve">
          <source>If you only want to import the namespace, do so directly:</source>
          <target state="translated">Si sólo quiere importar el espacio de nombres,hágalo directamente:</target>
        </trans-unit>
        <trans-unit id="f0344a16618dba921a326e3422d6b25ac64c22ba" translate="yes" xml:space="preserve">
          <source>If you open up the &lt;em&gt;src/main.rs&lt;/em&gt; file, make a trivial change, and then save it and build again, you&amp;rsquo;ll only see two lines of output:</source>
          <target state="translated">Si abre el archivo &lt;em&gt;src / main.rs&lt;/em&gt; , realiza un cambio trivial y luego lo guarda y vuelve a compilar, solo ver&amp;aacute; dos l&amp;iacute;neas de salida:</target>
        </trans-unit>
        <trans-unit id="acc3c2bbba4fb91bf96f0af82ae7667a7148e8e6" translate="yes" xml:space="preserve">
          <source>If you prefer, feel free to download the script and inspect it before running it.</source>
          <target state="translated">Si lo prefieres,siéntete libre de descargar el guión e inspeccionarlo antes de ejecutarlo.</target>
        </trans-unit>
        <trans-unit id="b0bfb1242185bbb2e23ce66c3dc2f4aa29788236" translate="yes" xml:space="preserve">
          <source>If you publish the crates in the workspace to &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;, each crate in the workspace will need to be published separately. The &lt;code&gt;cargo publish&lt;/code&gt; command does not have an &lt;code&gt;--all&lt;/code&gt; flag or a &lt;code&gt;-p&lt;/code&gt; flag, so you must change to each crate&amp;rsquo;s directory and run &lt;code&gt;cargo publish&lt;/code&gt; on each crate in the workspace to publish the crates.</source>
          <target state="translated">Si publica las cajas en el espacio de trabajo en &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; , cada caja en el espacio de trabajo deber&amp;aacute; publicarse por separado. El comando de &lt;code&gt;cargo publish&lt;/code&gt; no tiene una bandera &lt;code&gt;--all&lt;/code&gt; ni una bandera &lt;code&gt;-p&lt;/code&gt; , por lo que debe cambiar al directorio de cada caja y ejecutar &lt;code&gt;cargo publish&lt;/code&gt; en cada caja en el espacio de trabajo para publicar las cajas.</target>
        </trans-unit>
        <trans-unit id="f1a5e7e0b8234558c676e94b23a0846e7e9f1bdc" translate="yes" xml:space="preserve">
          <source>If you really want global mutable state, try using &lt;code&gt;static mut&lt;/code&gt; or a global &lt;code&gt;UnsafeCell&lt;/code&gt;.</source>
          <target state="translated">Si realmente desea un estado mutable global, intente usar &lt;code&gt;static mut&lt;/code&gt; o un &lt;code&gt;UnsafeCell&lt;/code&gt; global .</target>
        </trans-unit>
        <trans-unit id="62a69dfd70472a3083a61e19bd21f1bf21495b51" translate="yes" xml:space="preserve">
          <source>If you run this code and only see output from the main thread, or don&amp;rsquo;t see any overlap, try increasing the numbers in the ranges to create more opportunities for the operating system to switch between the threads.</source>
          <target state="translated">Si ejecuta este c&amp;oacute;digo y solo ve la salida del subproceso principal, o no ve ninguna superposici&amp;oacute;n, intente aumentar los n&amp;uacute;meros en los rangos para crear m&amp;aacute;s oportunidades para que el sistema operativo cambie entre los subprocesos.</target>
        </trans-unit>
        <trans-unit id="9b13bcfddcd9ed188e7606569deda5313f2555de" translate="yes" xml:space="preserve">
          <source>If you see a version number, you have it! If you see an error, such as &lt;code&gt;command not found&lt;/code&gt;, look at the documentation for your method of installation to determine how to install Cargo separately.</source>
          <target state="translated">Si ve un n&amp;uacute;mero de versi&amp;oacute;n, &amp;iexcl;lo tiene! Si ve un error, como &lt;code&gt;command not found&lt;/code&gt; , consulte la documentaci&amp;oacute;n de su m&amp;eacute;todo de instalaci&amp;oacute;n para determinar c&amp;oacute;mo instalar Cargo por separado.</target>
        </trans-unit>
        <trans-unit id="ca1a3838ab344cfca748fd158d2f145d4ad1816e" translate="yes" xml:space="preserve">
          <source>If you see this information, you have installed Rust successfully! If you don&amp;rsquo;t see this information and you&amp;rsquo;re on Windows, check that Rust is in your &lt;code&gt;%PATH%&lt;/code&gt; system variable. If that&amp;rsquo;s all correct and Rust still isn&amp;rsquo;t working, there are a number of places you can get help. The easiest is the #beginners channel on &lt;a href=&quot;https://discord.gg/rust-lang&quot;&gt;the official Rust Discord&lt;/a&gt;. There, you can chat with other Rustaceans (a silly nickname we call ourselves) who can help you out. Other great resources include &lt;a href=&quot;https://users.rust-lang.org/&quot;&gt;the Users forum&lt;/a&gt; and &lt;a href=&quot;http://stackoverflow.com/questions/tagged/rust&quot;&gt;Stack Overflow&lt;/a&gt;.</source>
          <target state="translated">Si ve esta informaci&amp;oacute;n, &amp;iexcl;ha instalado Rust correctamente! Si no ve esta informaci&amp;oacute;n y est&amp;aacute; en Windows, verifique que Rust est&amp;eacute; en su &lt;code&gt;%PATH%&lt;/code&gt; sistema % PATH% . Si todo es correcto y Rust a&amp;uacute;n no funciona, hay varios lugares donde puede obtener ayuda. El m&amp;aacute;s f&amp;aacute;cil es el canal #beginners en &lt;a href=&quot;https://discord.gg/rust-lang&quot;&gt;el Rust Discord oficial&lt;/a&gt; . All&amp;iacute;, puedes charlar con otros rust&amp;aacute;ceos (un apodo tonto que nos llamamos a nosotros mismos) que pueden ayudarte. Otros excelentes recursos incluyen &lt;a href=&quot;https://users.rust-lang.org/&quot;&gt;el foro de usuarios&lt;/a&gt; y &lt;a href=&quot;http://stackoverflow.com/questions/tagged/rust&quot;&gt;Stack Overflow&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="af95d793530f81bcda528d6176e0d39ead994b28" translate="yes" xml:space="preserve">
          <source>If you see this information, you have installed Rust successfully! If you don&amp;rsquo;t see this information and you&amp;rsquo;re on Windows, check that Rust is in your &lt;code&gt;%PATH%&lt;/code&gt; system variable. If that&amp;rsquo;s all correct and Rust still isn&amp;rsquo;t working, there are a number of places you can get help. The easiest is the #beginners channel on &lt;a href=&quot;https://discord.gg/rust-lang&quot;&gt;the official Rust Discord&lt;/a&gt;. There, you can chat with other Rustaceans (a silly nickname we call ourselves) who can help you out. Other great resources include &lt;a href=&quot;https://users.rust-lang.org/&quot;&gt;the Users forum&lt;/a&gt; and &lt;a href=&quot;https://stackoverflow.com/questions/tagged/rust&quot;&gt;Stack Overflow&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0b39f9cc59d35c45bd9b2beb8d8d98394272d63" translate="yes" xml:space="preserve">
          <source>If you started a project that doesn&amp;rsquo;t use Cargo, as we did with the &amp;ldquo;Hello, world!&amp;rdquo; project, you can convert it to a project that does use Cargo. Move the project code into the &lt;em&gt;src&lt;/em&gt; directory and create an appropriate &lt;em&gt;Cargo.toml&lt;/em&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d31b977744193df180d9786073117d4f248efa6" translate="yes" xml:space="preserve">
          <source>If you started a project that doesn&amp;rsquo;t use Cargo, as we did with the Hello, world! project, you can convert it to a project that does use Cargo. Move the project code into the &lt;em&gt;src&lt;/em&gt; directory and create an appropriate &lt;em&gt;Cargo.toml&lt;/em&gt; file.</source>
          <target state="translated">Si inici&amp;oacute; un proyecto que no usa Cargo, como hicimos con Hello, world! proyecto, puede convertirlo en un proyecto que utilice Cargo. Mueva el c&amp;oacute;digo del proyecto al directorio &lt;em&gt;src&lt;/em&gt; y cree un archivo &lt;em&gt;Cargo.toml&lt;/em&gt; apropiado .</target>
        </trans-unit>
        <trans-unit id="eb46c5a7ea5d3810ebecfc87299120cce00be773" translate="yes" xml:space="preserve">
          <source>If you still want to implement &lt;code&gt;Default&lt;/code&gt; on your enum, you'll have to do it &quot;by hand&quot;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5c951c0594854e5d5c8e44057a2f94e7bdb34b3" translate="yes" xml:space="preserve">
          <source>If you tried to compile this code, you&amp;rsquo;d get the following error:</source>
          <target state="translated">Si intenta compilar este c&amp;oacute;digo, obtendr&amp;aacute; el siguiente error:</target>
        </trans-unit>
        <trans-unit id="5cf70a0009bb0e1db5e453e3370fec24dd9aef5e" translate="yes" xml:space="preserve">
          <source>If you tried to use a module from an external crate and are using Rust 2015, you may have missed the &lt;code&gt;extern crate&lt;/code&gt; declaration (which is usually placed in the crate root):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f1e8e43bae6ab3a4aca1d32515bf332a0c95245" translate="yes" xml:space="preserve">
          <source>If you try to implement &lt;code&gt;Copy&lt;/code&gt; on a struct or enum containing non-&lt;code&gt;Copy&lt;/code&gt; data, you will get the error &lt;a href=&quot;../../error-index#E0204&quot;&gt;E0204&lt;/a&gt;.</source>
          <target state="translated">Si intenta implementar &lt;code&gt;Copy&lt;/code&gt; en una estructura o enumeraci&amp;oacute;n que contiene datos que no son de &lt;code&gt;Copy&lt;/code&gt; , obtendr&amp;aacute; el error &lt;a href=&quot;../../error-index#E0204&quot;&gt;E0204&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a662d7b675ef788169c5956b5c9a92931774165" translate="yes" xml:space="preserve">
          <source>If you uncomment the last &lt;code&gt;println!&lt;/code&gt; and run the program, Rust will try to print this cycle with &lt;code&gt;a&lt;/code&gt; pointing to &lt;code&gt;b&lt;/code&gt; pointing to &lt;code&gt;a&lt;/code&gt; and so forth until it overflows the stack.</source>
          <target state="translated">Si descomenta la &amp;uacute;ltima &lt;code&gt;println!&lt;/code&gt; y ejecutar el programa, Rust tratar&amp;aacute; de imprimir este ciclo con &lt;code&gt;a&lt;/code&gt; se&amp;ntilde;alador para &lt;code&gt;b&lt;/code&gt; apuntando a &lt;code&gt;a&lt;/code&gt; y as&amp;iacute; sucesivamente hasta que se desborde la pila.</target>
        </trans-unit>
        <trans-unit id="a14a926ed132d09c491a177cd2b2d9e55f1e2bdf" translate="yes" xml:space="preserve">
          <source>If you want different behavior from that provided by the &lt;code&gt;derive&lt;/code&gt; attribute, consult the &lt;a href=&quot;../std/index&quot;&gt;standard library documentation&lt;/a&gt; for each trait for details of how to manually implement them.</source>
          <target state="translated">Si desea un comportamiento diferente al proporcionado por el atributo &lt;code&gt;derive&lt;/code&gt; , consulte la &lt;a href=&quot;../std/index&quot;&gt;documentaci&amp;oacute;n de la biblioteca est&amp;aacute;ndar&lt;/a&gt; para cada rasgo para obtener detalles sobre c&amp;oacute;mo implementarlos manualmente.</target>
        </trans-unit>
        <trans-unit id="da45b590331746dc88457283dc0cfa0a00ed8210" translate="yes" xml:space="preserve">
          <source>If you want others to be able to import variants from your module directly, use &lt;code&gt;pub use&lt;/code&gt;:</source>
          <target state="translated">Si desea que otros puedan importar variantes de su m&amp;oacute;dulo directamente, use &lt;code&gt;pub use&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="25e1ad087ce44bfb4ab6681d137bc6701595a370" translate="yes" xml:space="preserve">
          <source>If you want to access this field, you have two options:</source>
          <target state="translated">Si quieres acceder a este campo,tienes dos opciones:</target>
        </trans-unit>
        <trans-unit id="e54440276aac79fc98a847cf2428e9933e1917a0" translate="yes" xml:space="preserve">
          <source>If you want to dispose of a value properly, running its destructor, see &lt;a href=&quot;fn.drop&quot;&gt;&lt;code&gt;mem::drop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si desea deshacerse de un valor correctamente, ejecutando su destructor, consulte &lt;a href=&quot;fn.drop&quot;&gt; &lt;code&gt;mem::drop&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9768a2ab3e4f7c290cb7e9ced37ea2ca5de6e479" translate="yes" xml:space="preserve">
          <source>If you want to force the closure to take ownership of the values it uses in the environment, you can use the &lt;code&gt;move&lt;/code&gt; keyword before the parameter list. This technique is mostly useful when passing a closure to a new thread to move the data so it&amp;rsquo;s owned by the new thread.</source>
          <target state="translated">Si desea forzar el cierre para que se apropie de los valores que usa en el entorno, puede usar la palabra clave &lt;code&gt;move&lt;/code&gt; antes de la lista de par&amp;aacute;metros. Esta t&amp;eacute;cnica es principalmente &amp;uacute;til cuando se pasa un cierre a un nuevo hilo para mover los datos para que sean propiedad del nuevo hilo.</target>
        </trans-unit>
        <trans-unit id="80acd43e0370273ccef8254a4e57d1f60b0bc413" translate="yes" xml:space="preserve">
          <source>If you want to get command-line arguments, use &lt;code&gt;std::env::args&lt;/code&gt;. To exit with a specified exit code, use &lt;code&gt;std::process::exit&lt;/code&gt;.</source>
          <target state="translated">Si desea obtener argumentos de la l&amp;iacute;nea de comandos, use &lt;code&gt;std::env::args&lt;/code&gt; . Para salir con un c&amp;oacute;digo de salida especificado, use &lt;code&gt;std::process::exit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c9a2ec635fa6b00d5880ff9292416d8dca9a7fc" translate="yes" xml:space="preserve">
          <source>If you want to insert an item to a sorted &lt;code&gt;VecDeque&lt;/code&gt;, while maintaining sort order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0acc8dd0f308905dd135a12c1b3dd9fcb9493376" translate="yes" xml:space="preserve">
          <source>If you want to insert an item to a sorted vector, while maintaining sort order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b0f51a38399c4a2f70e6ceafe1a91c955b3ae7a" translate="yes" xml:space="preserve">
          <source>If you want to keep using the first &lt;code&gt;String&lt;/code&gt;, you can clone it and append to the clone instead:</source>
          <target state="translated">Si desea seguir usando la primera &lt;code&gt;String&lt;/code&gt; , puede clonarla y agregarla al clon en su lugar:</target>
        </trans-unit>
        <trans-unit id="61d387167097c227de2b74d46c810a6f48988800" translate="yes" xml:space="preserve">
          <source>If you want to leak memory, see &lt;a href=&quot;../boxed/struct.box#method.leak&quot;&gt;&lt;code&gt;Box::leak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si desea perder memoria, consulte &lt;a href=&quot;../boxed/struct.box#method.leak&quot;&gt; &lt;code&gt;Box::leak&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="96909eb09d644dffe9876e98f5676019fe4cca01" translate="yes" xml:space="preserve">
          <source>If you want to match against a &lt;code&gt;static&lt;/code&gt;, consider using a guard instead:</source>
          <target state="translated">Si desea hacer coincidir con una &lt;code&gt;static&lt;/code&gt; , considere usar un protector en su lugar:</target>
        </trans-unit>
        <trans-unit id="5dd2ed8224f86c5b9637dc361ab843ced67e5d10" translate="yes" xml:space="preserve">
          <source>If you want to match against a value returned by a method, you need to bind the value first:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d1a047e7f9af156ca480104309f128f398877a3" translate="yes" xml:space="preserve">
          <source>If you want to obtain a raw pointer to the memory, see &lt;a href=&quot;../boxed/struct.box#method.into_raw&quot;&gt;&lt;code&gt;Box::into_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si desea obtener un puntero sin formato a la memoria, consulte &lt;a href=&quot;../boxed/struct.box#method.into_raw&quot;&gt; &lt;code&gt;Box::into_raw&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="af2b12bea50ff4e3f56fd90fac941705dc1d40f8" translate="yes" xml:space="preserve">
          <source>If you want to obtain the maximum value in one step, you can use the following:</source>
          <target state="translated">Si quiere obtener el valor máximo en un paso,puede usar lo siguiente:</target>
        </trans-unit>
        <trans-unit id="aa75a1d98c5a72deacc062c764e53ed6e0e651fd" translate="yes" xml:space="preserve">
          <source>If you want to obtain the minimum value in one step, you can use the following:</source>
          <target state="translated">Si quiere obtener el valor mínimo en un paso,puede usar lo siguiente:</target>
        </trans-unit>
        <trans-unit id="cfd0b8d443659aca7120d5cc8d6a3c8166b35c1d" translate="yes" xml:space="preserve">
          <source>If you want to omit the current error and only use its sources, use &lt;code&gt;skip(1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="926fba741a818eca51e737d7fa3523921dbd4a71" translate="yes" xml:space="preserve">
          <source>If you want to omit the initial error and only process its sources, use &lt;code&gt;skip(1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e4b997d351ad9a525cf19f543e85c5da006d9c7" translate="yes" xml:space="preserve">
          <source>If you want to override a particular option, but still retain the other defaults:</source>
          <target state="translated">Si quiere anular una opción en particular,pero aún así conservar los otros valores por defecto:</target>
        </trans-unit>
        <trans-unit id="651cc5caec5314245c67d0f62c5870f23101d920" translate="yes" xml:space="preserve">
          <source>If you want to replace the values of two variables, see &lt;a href=&quot;fn.swap&quot;&gt;&lt;code&gt;swap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6af86f0661e2c9a64c8c625b38f0956d4f284ae" translate="yes" xml:space="preserve">
          <source>If you want to replace with a default value, see &lt;a href=&quot;fn.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bfdbf254f5b63f82b216ed7084a2deb7f3dca85" translate="yes" xml:space="preserve">
          <source>If you want to replace with a passed value instead of the default value, see &lt;a href=&quot;fn.replace&quot;&gt;&lt;code&gt;replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55dde3b0a389df6438eee8ef5e4606e7a78527fd" translate="yes" xml:space="preserve">
          <source>If you want to stick to a standard style across Rust projects, you can use an automatic formatter tool called &lt;code&gt;rustfmt&lt;/code&gt; to format your code in a particular style. The Rust team has included this tool with the standard Rust distribution, like &lt;code&gt;rustc&lt;/code&gt;, so it should already be installed on your computer! Check the online documentation for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1373af912652b0c7e66f623e887c5b41f2472fcc" translate="yes" xml:space="preserve">
          <source>If you want to swap with a default or dummy value, see &lt;a href=&quot;fn.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efa2ff7053e1b87144c40e113ce37c56691cc7f2" translate="yes" xml:space="preserve">
          <source>If you want to swap with a passed value, returning the old value, see &lt;a href=&quot;fn.replace&quot;&gt;&lt;code&gt;replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18f006db9a3676ab2ada8ccb85ca3e9d0996d340" translate="yes" xml:space="preserve">
          <source>If you want to use a license that doesn&amp;rsquo;t appear in the SPDX, you need to place the text of that license in a file, include the file in your project, and then use &lt;code&gt;license-file&lt;/code&gt; to specify the name of that file instead of using the &lt;code&gt;license&lt;/code&gt; key.</source>
          <target state="translated">Si desea utilizar una licencia que no aparece en la SPDX, debe colocar el texto de esa licencia en un archivo, incluir el archivo en su proyecto y luego usar &lt;code&gt;license-file&lt;/code&gt; para especificar el nombre de ese archivo. de utilizar la clave de &lt;code&gt;license&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9090aa9e8ad232d87792cb945b3e00a6429cd6aa" translate="yes" xml:space="preserve">
          <source>If you want to use a method, add &lt;code&gt;()&lt;/code&gt; after it:</source>
          <target state="translated">Si desea utilizar un m&amp;eacute;todo, agregue &lt;code&gt;()&lt;/code&gt; despu&amp;eacute;s de &amp;eacute;l:</target>
        </trans-unit>
        <trans-unit id="51277c9215e04719281555a263f500118558534d" translate="yes" xml:space="preserve">
          <source>If you wanted to use &lt;code&gt;rand&lt;/code&gt; version &lt;code&gt;0.4.0&lt;/code&gt; or any version in the &lt;code&gt;0.4.x&lt;/code&gt; series, you&amp;rsquo;d have to update the &lt;em&gt;Cargo.toml&lt;/em&gt; file to look like this instead:</source>
          <target state="translated">Si quisiera usar la versi&amp;oacute;n &lt;code&gt;0.4.0&lt;/code&gt; de &lt;code&gt;rand&lt;/code&gt; o cualquier versi&amp;oacute;n de la serie &lt;code&gt;0.4.x&lt;/code&gt; , tendr&amp;iacute;a que actualizar el archivo &lt;em&gt;Cargo.toml&lt;/em&gt; para que se vea as&amp;iacute;:&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8c50d781b9647450248f78ab145ade0f4a366fe2" translate="yes" xml:space="preserve">
          <source>If you wanted to use &lt;code&gt;rand&lt;/code&gt; version &lt;code&gt;0.6.0&lt;/code&gt; or any version in the &lt;code&gt;0.6.x&lt;/code&gt; series, you&amp;rsquo;d have to update the &lt;em&gt;Cargo.toml&lt;/em&gt; file to look like this instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1701a67103b86d7651d634397fe65d313d58f55d" translate="yes" xml:space="preserve">
          <source>If you wish to apply this attribute to all methods in an impl, manually annotate each method; it is not possible to annotate the entire impl with an &lt;code&gt;#[inline]&lt;/code&gt; attribute.</source>
          <target state="translated">Si desea aplicar este atributo a todos los m&amp;eacute;todos en un impl, anote manualmente cada m&amp;eacute;todo; no es posible anotar el impl completo con un atributo &lt;code&gt;#[inline]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d397e83dcd0f1559792d3e0a89cf887adf0bfaa" translate="yes" xml:space="preserve">
          <source>If you wish to learn more about ownership in Rust, start with the &lt;a href=&quot;book/ch04-00-understanding-ownership&quot;&gt;Understanding Ownership&lt;/a&gt; chapter in the Book.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87899c4a4d606a4f4020452b11cba149b8345c16" translate="yes" xml:space="preserve">
          <source>If you wish to learn more about ownership in Rust, start with the chapter in the Book:</source>
          <target state="translated">Si desea aprender más sobre la propiedad en Rust,empiece con el capítulo del Libro:</target>
        </trans-unit>
        <trans-unit id="3e41aae8d663fd217f0f3e9bae5f0ce51dac4bca" translate="yes" xml:space="preserve">
          <source>If you work with Windows API, you may wish to convert &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;Vec&amp;lt;u16&amp;gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78eac0234db79506b991eda9c4b9c36157e1c9b6" translate="yes" xml:space="preserve">
          <source>If you would like to import all exported macros, write &lt;code&gt;macro_use&lt;/code&gt; with no arguments.</source>
          <target state="translated">Si desea importar todas las macros exportadas, escriba &lt;code&gt;macro_use&lt;/code&gt; sin argumentos.</target>
        </trans-unit>
        <trans-unit id="ed1dda05d27b4d27cb9305c801cdb5137665995d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re more familiar with a dynamic language, such as Ruby, Python, or JavaScript, you might not be used to compiling and running a program as separate steps. Rust is an &lt;em&gt;ahead-of-time compiled&lt;/em&gt; language, meaning you can compile a program and give the executable to someone else, and they can run it even without having Rust installed. If you give someone a &lt;em&gt;.rb&lt;/em&gt;, &lt;em&gt;.py&lt;/em&gt;, or &lt;em&gt;.js&lt;/em&gt; file, they need to have a Ruby, Python, or JavaScript implementation installed (respectively). But in those languages, you only need one command to compile and run your program. Everything is a trade-off in language design.</source>
          <target state="translated">Si est&amp;aacute; m&amp;aacute;s familiarizado con un lenguaje din&amp;aacute;mico, como Ruby, Python o JavaScript, es posible que no est&amp;eacute; acostumbrado a compilar y ejecutar un programa como pasos separados. Rust es un lenguaje &lt;em&gt;compilado con anticipaci&amp;oacute;n&lt;/em&gt; , lo que significa que puede compilar un programa y darle el ejecutable a otra persona, y ellos pueden ejecutarlo incluso sin tener Rust instalado. Si le da a alguien un &lt;em&gt;archivo .rb&lt;/em&gt; , &lt;em&gt;.py&lt;/em&gt; o &lt;em&gt;.js&lt;/em&gt; , debe tener instalada una implementaci&amp;oacute;n de Ruby, Python o JavaScript (respectivamente). Pero en esos lenguajes, solo necesita un comando para compilar y ejecutar su programa. Todo es una compensaci&amp;oacute;n en el dise&amp;ntilde;o del lenguaje.</target>
        </trans-unit>
        <trans-unit id="7e490007e6b65d7d7858801f6aacf713c1c91404" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re up for a challenge, try implementing these changes on your own before looking at the code in Listing 20-15.</source>
          <target state="translated">Si est&amp;aacute; preparado para un desaf&amp;iacute;o, intente implementar estos cambios por su cuenta antes de mirar el c&amp;oacute;digo en el Listado 20-15.</target>
        </trans-unit>
        <trans-unit id="503925e7f62154ea6178c580b761e23a80e387e3" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Linux or macOS, open a terminal and enter the following command:</source>
          <target state="translated">Si est&amp;aacute; usando Linux o macOS, abra una terminal e ingrese el siguiente comando:</target>
        </trans-unit>
        <trans-unit id="98942c95131204f993cffde6931d1582fa280610" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using PowerShell, you will need to set the environment variable and run the program in two commands rather than one:</source>
          <target state="translated">Si est&amp;aacute; utilizando PowerShell, deber&amp;aacute; configurar la variable de entorno y ejecutar el programa en dos comandos en lugar de uno:</target>
        </trans-unit>
        <trans-unit id="10222b367fb9120d22d60ff135277a5cc297aae4" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using a beta or stable release of Rust, you can&amp;rsquo;t use any feature flags. This is the key that allows us to get practical use with new features before we declare them stable forever. Those who wish to opt into the bleeding edge can do so, and those who want a rock-solid experience can stick with stable and know that their code won&amp;rsquo;t break. Stability without stagnation.</source>
          <target state="translated">Si est&amp;aacute; usando una versi&amp;oacute;n beta o estable de Rust, no puede usar ning&amp;uacute;n indicador de funciones. Esta es la clave que nos permite hacer un uso pr&amp;aacute;ctico de las nuevas funciones antes de declararlas estables para siempre. Aquellos que deseen optar por la vanguardia pueden hacerlo, y aquellos que quieran una experiencia s&amp;oacute;lida como una roca pueden quedarse con estable y saber que su c&amp;oacute;digo no se romper&amp;aacute;. Estabilidad sin estancamiento.</target>
        </trans-unit>
        <trans-unit id="c4d2404277922b45ce332d5f67f5f097fe76da77" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re wanting to copy the contents of one file to another and you&amp;rsquo;re working with &lt;a href=&quot;struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;s, see the &lt;a href=&quot;../io/fn.copy&quot;&gt;&lt;code&gt;io::copy()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da77f918478283fad1f198de108fa4f8ef398fc0" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re wanting to copy the contents of one file to another and you&amp;rsquo;re working with &lt;a href=&quot;struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;s, see the &lt;a href=&quot;../io/fn.copy&quot;&gt;&lt;code&gt;io::copy&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Si desea copiar el contenido de un archivo a otro y est&amp;aacute; trabajando con &lt;a href=&quot;struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; , consulte la funci&amp;oacute;n &lt;a href=&quot;../io/fn.copy&quot;&gt; &lt;code&gt;io::copy&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2a58c6f07d04f7dc7feddd58a27cebcc6f22ddd7" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re wanting to copy the contents of one file to another and you&amp;rsquo;re working with filesystem paths, see the &lt;a href=&quot;../fs/fn.copy&quot;&gt;&lt;code&gt;fs::copy&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Si desea copiar el contenido de un archivo a otro y est&amp;aacute; trabajando con rutas del sistema de archivos, consulte la funci&amp;oacute;n &lt;a href=&quot;../fs/fn.copy&quot;&gt; &lt;code&gt;fs::copy&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6ecddb0b505fd4dff9fe47fcf13cd242249940e4" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve heard the terms &lt;em&gt;shallow copy&lt;/em&gt; and &lt;em&gt;deep copy&lt;/em&gt; while working with other languages, the concept of copying the pointer, length, and capacity without copying the data probably sounds like making a shallow copy. But because Rust also invalidates the first variable, instead of being called a shallow copy, it&amp;rsquo;s known as a &lt;em&gt;move&lt;/em&gt;. In this example, we would say that &lt;code&gt;s1&lt;/code&gt; was &lt;em&gt;moved&lt;/em&gt; into &lt;code&gt;s2&lt;/code&gt;. So what actually happens is shown in Figure 4-4.</source>
          <target state="translated">Si ha escuchado los t&amp;eacute;rminos &lt;em&gt;copia superficial&lt;/em&gt; y &lt;em&gt;copia &lt;/em&gt;&lt;em&gt;profunda&lt;/em&gt; mientras trabaja con otros idiomas, el concepto de copiar el puntero, la longitud y la capacidad sin copiar los datos probablemente suene como hacer una copia superficial. Pero debido a que Rust tambi&amp;eacute;n invalida la primera variable, en lugar de llamarse copia superficial, se conoce como &lt;em&gt;movimiento&lt;/em&gt; . En este ejemplo, dir&amp;iacute;amos que &lt;code&gt;s1&lt;/code&gt; se &lt;em&gt;movi&amp;oacute;&lt;/em&gt; a &lt;code&gt;s2&lt;/code&gt; . Entonces, lo que realmente sucede se muestra en la Figura 4-4.</target>
        </trans-unit>
        <trans-unit id="7a247142750d6b996e14a5e30ade8f9e7fae56a4" translate="yes" xml:space="preserve">
          <source>If you'd like explicitly call the destructor of a value, &lt;a href=&quot;../mem/fn.drop&quot;&gt;&lt;code&gt;mem::drop&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d19c3fd1002bae38df7f3d3cb85b6b1334bcacb4" translate="yes" xml:space="preserve">
          <source>If you're creating a collection, implementing &lt;a href=&quot;trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; for it will allow your collection to be used with the &lt;code&gt;for&lt;/code&gt; loop.</source>
          <target state="translated">Si est&amp;aacute; creando una colecci&amp;oacute;n, implementar &lt;a href=&quot;trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt; para ella permitir&amp;aacute; que su colecci&amp;oacute;n se use con el bucle &lt;code&gt;for&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a422eed6103cbb87db1af03fc39e19d93bd47305" translate="yes" xml:space="preserve">
          <source>If you're doing some sort of side effect, prefer &lt;a href=&quot;../../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;map()&lt;/code&gt;:</source>
          <target state="translated">Si est&amp;aacute;s haciendo alg&amp;uacute;n tipo de efecto secundario, prefieren &lt;a href=&quot;../../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt; que &lt;code&gt;map()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="50fae5c17f1680200b10a72b86983fc6d83252f1" translate="yes" xml:space="preserve">
          <source>If you're fine with just getting a prefix of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, you can call &lt;a href=&quot;../vec/struct.vec#method.truncate&quot;&gt;&lt;code&gt;.truncate(N)&lt;/code&gt;&lt;/a&gt; first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="657123c4239a0672bb847d20cff32727a933d93f" translate="yes" xml:space="preserve">
          <source>If you're fine with just getting a prefix of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, you can call &lt;a href=&quot;struct.vec#method.truncate&quot;&gt;&lt;code&gt;.truncate(N)&lt;/code&gt;&lt;/a&gt; first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2c18403b0527c315799b70edeca9e66be8c0011" translate="yes" xml:space="preserve">
          <source>If you're fine with just getting a prefix of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, you can call &lt;a href=&quot;vec/struct.vec#method.truncate&quot;&gt;&lt;code&gt;.truncate(N)&lt;/code&gt;&lt;/a&gt; first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9afd2d591bc8d95f3d42da1a03f80ebc1b1aa2ee" translate="yes" xml:space="preserve">
          <source>If you're only returning this and &lt;code&gt;SUCCESS&lt;/code&gt; from &lt;code&gt;main&lt;/code&gt;, consider instead returning &lt;code&gt;Err(_)&lt;/code&gt; and &lt;code&gt;Ok(())&lt;/code&gt; respectively, which will return the same codes (but will also &lt;code&gt;eprintln!&lt;/code&gt; the error).</source>
          <target state="translated">Si solo est&amp;aacute; devolviendo esto y &lt;code&gt;SUCCESS&lt;/code&gt; de &lt;code&gt;main&lt;/code&gt; , considere en su lugar devolver &lt;code&gt;Err(_)&lt;/code&gt; y &lt;code&gt;Ok(())&lt;/code&gt; respectivamente, que devolver&amp;aacute;n los mismos c&amp;oacute;digos (pero tambi&amp;eacute;n &lt;code&gt;eprintln!&lt;/code&gt; El error).</target>
        </trans-unit>
        <trans-unit id="f631fe468a2c97e4c088457880f99d9a4e107ff3" translate="yes" xml:space="preserve">
          <source>If you're sure you want to override the lint check, you can change &lt;code&gt;forbid&lt;/code&gt; to &lt;code&gt;deny&lt;/code&gt; (or use &lt;code&gt;-D&lt;/code&gt; instead of &lt;code&gt;-F&lt;/code&gt; if the &lt;code&gt;forbid&lt;/code&gt; setting was given as a command-line option) to allow the inner lint check attribute:</source>
          <target state="translated">Si est&amp;aacute; seguro de que desea anular la verificaci&amp;oacute;n de pelusa, puede cambiar &lt;code&gt;forbid&lt;/code&gt; a &lt;code&gt;deny&lt;/code&gt; (o usar &lt;code&gt;-D&lt;/code&gt; en lugar de &lt;code&gt;-F&lt;/code&gt; si la configuraci&amp;oacute;n de &lt;code&gt;forbid&lt;/code&gt; se proporcion&amp;oacute; como una opci&amp;oacute;n de l&amp;iacute;nea de comandos) para permitir el atributo de verificaci&amp;oacute;n de pelusa interna:</target>
        </trans-unit>
        <trans-unit id="9708dfd947b0f617c80eaf862c93f6be07e715ad" translate="yes" xml:space="preserve">
          <source>If you're using PowerShell, you will need to set the environment variable and run the program as separate commands:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7026945961ed8f6ca8800fb0c4e20b697752c2a9" translate="yes" xml:space="preserve">
          <source>If you're using a nightly version of rustc, just add the corresponding feature to be able to use it:</source>
          <target state="translated">Si estás usando una versión nocturna de rustc,sólo tienes que añadir la característica correspondiente para poder usarla:</target>
        </trans-unit>
        <trans-unit id="576937c9d8ed13353425e007feb4c070a940e8cb" translate="yes" xml:space="preserve">
          <source>If you're using a stable or a beta version of rustc, you won't be able to use any unstable features. In order to do so, please switch to a nightly version of rustc (by using rustup).</source>
          <target state="translated">Si usas una versión estable o una versión beta de rustc,no podrás usar ninguna característica inestable.Para ello,por favor cambia a una versión nocturna de rustc (usando rustup).</target>
        </trans-unit>
        <trans-unit id="395533f4484790ce7a8392319e82621aa7e5325d" translate="yes" xml:space="preserve">
          <source>If you're writing an &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, you can use it with a &lt;code&gt;for&lt;/code&gt; loop.</source>
          <target state="translated">Si est&amp;aacute; escribiendo un &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; , puede usarlo con un bucle &lt;code&gt;for&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39b96bd78ad2447973090132f0c782a06fee701a" translate="yes" xml:space="preserve">
          <source>If you've expected to use a crate name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fb2ecfb4c92e4052c3107bd77c1eec1689462b3" translate="yes" xml:space="preserve">
          <source>If you've found yourself with a collection of some kind, and needed to perform an operation on the elements of said collection, you'll quickly run into 'iterators'. Iterators are heavily used in idiomatic Rust code, so it's worth becoming familiar with them.</source>
          <target state="translated">Si te encuentras con una colección de algún tipo,y necesitas realizar una operación sobre los elementos de dicha colección,rápidamente te encontrarás con &quot;iteradores&quot;.Los iteradores son muy utilizados en el código idiomático de Rust,así que vale la pena familiarizarse con ellos.</target>
        </trans-unit>
        <trans-unit id="bba321adc53e908723f50dd512716ff5bec65b5c" translate="yes" xml:space="preserve">
          <source>If your struct does not in fact &lt;em&gt;own&lt;/em&gt; the data of type &lt;code&gt;T&lt;/code&gt;, it is better to use a reference type, like &lt;code&gt;PhantomData&amp;lt;&amp;amp;'a T&amp;gt;&lt;/code&gt; (ideally) or &lt;code&gt;PhantomData&amp;lt;*const T&amp;gt;&lt;/code&gt; (if no lifetime applies), so as not to indicate ownership.</source>
          <target state="translated">Si su estructura de hecho no &lt;em&gt;posee&lt;/em&gt; los datos de tipo &lt;code&gt;T&lt;/code&gt; , es mejor usar un tipo de referencia, como &lt;code&gt;PhantomData&amp;lt;&amp;amp;'a T&amp;gt;&lt;/code&gt; (idealmente) o &lt;code&gt;PhantomData&amp;lt;*const T&amp;gt;&lt;/code&gt; (si no se aplica una vida &amp;uacute;til), de modo que para no indicar propiedad.</target>
        </trans-unit>
        <trans-unit id="1f6b5f80968da1047a776f5803bbfc765104a318" translate="yes" xml:space="preserve">
          <source>If your type is &lt;a href=&quot;trait.ord&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt;, you can implement &lt;a href=&quot;trait.partialord#tymethod.partial_cmp&quot;&gt;&lt;code&gt;partial_cmp&lt;/code&gt;&lt;/a&gt; by using &lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt;&lt;code&gt;cmp&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35168f4f4ac93dd52237413aa76a27a7ee5549a6" translate="yes" xml:space="preserve">
          <source>If your type is &lt;code&gt;Ord&lt;/code&gt;, you can implement &lt;code&gt;partial_cmp()&lt;/code&gt; by using &lt;code&gt;cmp()&lt;/code&gt;:</source>
          <target state="translated">Si su tipo es &lt;code&gt;Ord&lt;/code&gt; , puede implementar &lt;code&gt;partial_cmp()&lt;/code&gt; usando &lt;code&gt;cmp()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7bfd0ea25f9360aa8168faba44b4ab62b5c11325" translate="yes" xml:space="preserve">
          <source>If your type uses pinning (such as the two examples above), you have to be careful when implementing &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; function takes &lt;code&gt;&amp;amp;mut self&lt;/code&gt;, but this is called &lt;em&gt;even if your type was previously pinned&lt;/em&gt;! It is as if the compiler automatically called &lt;a href=&quot;struct.pin#method.get_unchecked_mut&quot;&gt;&lt;code&gt;Pin::get_unchecked_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d37aa76a1e9c0f7fae52e7041a8731a25ef02a02" translate="yes" xml:space="preserve">
          <source>If your type uses pinning (such as the two examples above), you have to be careful when implementing &lt;code&gt;Drop&lt;/code&gt;. The &lt;code&gt;drop&lt;/code&gt; function takes &lt;code&gt;&amp;amp;mut self&lt;/code&gt;, but this is called &lt;em&gt;even if your type was previously pinned&lt;/em&gt;! It is as if the compiler automatically called &lt;code&gt;get_unchecked_mut&lt;/code&gt;.</source>
          <target state="translated">Si su tipo usa anclado (como los dos ejemplos anteriores), debe tener cuidado al implementar &lt;code&gt;Drop&lt;/code&gt; . La funci&amp;oacute;n de &lt;code&gt;drop&lt;/code&gt; toma &lt;code&gt;&amp;amp;mut self&lt;/code&gt; , pero esto se llama &lt;em&gt;incluso si su tipo fue anclado previamente&lt;/em&gt; . Es como si el compilador llamara autom&amp;aacute;ticamente &lt;code&gt;get_unchecked_mut&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="598868642b3bffa6f49c642a95c3be204b7800a8" translate="yes" xml:space="preserve">
          <source>If, instead, the closure were to use &lt;code&gt;self.vec&lt;/code&gt; directly, then it would attempt to capture &lt;code&gt;self&lt;/code&gt; by mutable reference. But since &lt;code&gt;self.set&lt;/code&gt; is already borrowed to iterate over, the code would not compile.</source>
          <target state="translated">Si, en cambio, el cierre fuera a usar &lt;code&gt;self.vec&lt;/code&gt; directamente, entonces intentar&amp;iacute;a capturar a &lt;code&gt;self&lt;/code&gt; mediante una referencia mutable. Pero dado que &lt;code&gt;self.set&lt;/code&gt; ya est&amp;aacute; prestado para iterar, el c&amp;oacute;digo no se compilar&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="48ed828a4ed281ea3d0c9ba3174c378a545d73df" translate="yes" xml:space="preserve">
          <source>Ignores the rest of the fields of &lt;code&gt;person&lt;/code&gt;. The remaining fields can have any value and are not bound to any variables.</source>
          <target state="translated">Ignora el resto de los campos de la &lt;code&gt;person&lt;/code&gt; a . Los campos restantes pueden tener cualquier valor y no est&amp;aacute;n vinculados a ninguna variable.</target>
        </trans-unit>
        <trans-unit id="c31c1e950d31bcf9e1a5b1976cfae488d68d470b" translate="yes" xml:space="preserve">
          <source>Ignoring Parts of a Value with a Nested &lt;code id=&quot;ignoring-parts-of-a-value-with-a-nested-_&quot;&gt;_&lt;/code&gt;</source>
          <target state="translated">Ignorar partes de un valor con un &lt;code id=&quot;ignoring-parts-of-a-value-with-a-nested-_&quot;&gt;_&lt;/code&gt; anidado</target>
        </trans-unit>
        <trans-unit id="cb76cccb46d6bf3b21aff42c2840779a648e9316" translate="yes" xml:space="preserve">
          <source>Ignoring Remaining Parts of a Value with &lt;code id=&quot;ignoring-remaining-parts-of-a-value-with-&quot;&gt;..&lt;/code&gt;</source>
          <target state="translated">Ignorar las partes restantes de un valor con &lt;code id=&quot;ignoring-remaining-parts-of-a-value-with-&quot;&gt;..&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72be1acfce70ef6fdf12c4ca3bdb755a5f3c62e1" translate="yes" xml:space="preserve">
          <source>Ignoring Some Tests Unless Specifically Requested</source>
          <target state="translated">Ignorar algunas pruebas a menos que se solicite específicamente</target>
        </trans-unit>
        <trans-unit id="7b50129a075aa818d7462a8d02141718c690d22a" translate="yes" xml:space="preserve">
          <source>Ignoring Values in a Pattern</source>
          <target state="translated">Ignorar los valores en un patrón</target>
        </trans-unit>
        <trans-unit id="b8aa95dab57398b05fdba8a4d4f5449c83a52c55" translate="yes" xml:space="preserve">
          <source>Ignoring an Entire Value with &lt;code id=&quot;ignoring-an-entire-value-with-_&quot;&gt;_&lt;/code&gt;</source>
          <target state="translated">Ignorar un valor completo con &lt;code id=&quot;ignoring-an-entire-value-with-_&quot;&gt;_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="824175d05fddba8fd3dcc503b0a53c542e4c9636" translate="yes" xml:space="preserve">
          <source>Ignoring an Unused Variable by Starting Its Name with &lt;code id=&quot;ignoring-an-unused-variable-by-starting-its-name-with-_&quot;&gt;_&lt;/code&gt;</source>
          <target state="translated">Ignorar una variable no utilizada comenzando su nombre con &lt;code id=&quot;ignoring-an-unused-variable-by-starting-its-name-with-_&quot;&gt;_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1de0ff71d627d79a5461c11415378b869fce1c05" translate="yes" xml:space="preserve">
          <source>Imagine &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; as a TV in a family room. When one person enters to watch TV, they turn it on. Others can come into the room and watch the TV. When the last person leaves the room, they turn off the TV because it&amp;rsquo;s no longer being used. If someone turns off the TV while others are still watching it, there would be uproar from the remaining TV watchers!</source>
          <target state="translated">Imag&amp;iacute;nese &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; como un televisor en una sala familiar. Cuando una persona entra a ver la televisi&amp;oacute;n, la enciende. Otros pueden entrar a la habitaci&amp;oacute;n y ver la televisi&amp;oacute;n. Cuando la &amp;uacute;ltima persona sale de la habitaci&amp;oacute;n, apagan el televisor porque ya no se usa. Si alguien apaga la televisi&amp;oacute;n mientras otros todav&amp;iacute;a la miran, &amp;iexcl;habr&amp;aacute; un alboroto de los espectadores restantes!</target>
        </trans-unit>
        <trans-unit id="aef09d55e979d01186c3ad5b4d52e9895c1e4d0b" translate="yes" xml:space="preserve">
          <source>Immutable raw entries have very limited use; you might instead want &lt;code&gt;raw_entry_mut&lt;/code&gt;.</source>
          <target state="translated">Las entradas crudas inmutables tienen un uso muy limitado; en su lugar, podr&amp;iacute;a querer &lt;code&gt;raw_entry_mut&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9cb7da282b676f1a9147f47cf20eae1312e8018" translate="yes" xml:space="preserve">
          <source>Immutable slice iterator</source>
          <target state="translated">Inmutable iterador de rebanadas</target>
        </trans-unit>
        <trans-unit id="f279b41bdff0c313061e7e8d87d0d00890c662fd" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value.</source>
          <target state="translated">Toma prestado inmediatamente de un valor propio.</target>
        </trans-unit>
        <trans-unit id="47c37e5ca590da5f0c3ce78d39f05441cd662917" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;../../../borrow/trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Inmutablemente toma prestado de un valor propio. &lt;a href=&quot;../../../borrow/trait.borrow#tymethod.borrow&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="861dc028ab0a94d2afc2d7df8d5b5cf1a45ca3fc" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;../../borrow/trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Inmutablemente toma prestado de un valor propio. &lt;a href=&quot;../../borrow/trait.borrow#tymethod.borrow&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e8a010bb86c5762cd52b4abd0dab0aa2a3ef476" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;../borrow/trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Inmutablemente toma prestado de un valor propio. &lt;a href=&quot;../borrow/trait.borrow#tymethod.borrow&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8833e74ed05076c118bef1874883c610436d6d5b" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;borrow/trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Inmutablemente toma prestado de un valor propio. &lt;a href=&quot;borrow/trait.borrow#tymethod.borrow&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="73be65582534de0a648096eb5ca5552095f43fdb" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Inmutablemente toma prestado de un valor propio. &lt;a href=&quot;trait.borrow#tymethod.borrow&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="809dd297db758cb75c4bd86bf3c73c53b0063ba0" translate="yes" xml:space="preserve">
          <source>Immutably borrows the wrapped value, returning an error if the value is currently mutably borrowed.</source>
          <target state="translated">Toma prestado inmediatamente el valor envuelto,devolviendo un error si el valor está actualmente mutablemente prestado.</target>
        </trans-unit>
        <trans-unit id="24dd024f910c8d7d6dfa29d6bf4e9500dd4642a7" translate="yes" xml:space="preserve">
          <source>Immutably borrows the wrapped value.</source>
          <target state="translated">Inmediatamente toma prestado el valor envuelto.</target>
        </trans-unit>
        <trans-unit id="0e1a9c7b22b101d3c2b0d138208b984996a848ee" translate="yes" xml:space="preserve">
          <source>Impl blocks declare lifetime parameters separately. You need to add lifetime parameters to an impl block if you're implementing a type that has a lifetime parameter of its own. For example:</source>
          <target state="translated">Los bloques de implantes declaran los parámetros de vida útil por separado.Es necesario añadir parámetros de vida útil a un bloque impl si se implementa un tipo que tiene un parámetro de vida útil propio.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="f0ab384ef00ad7380000aad709dff9a6e1b2d5e6" translate="yes" xml:space="preserve">
          <source>Impl trait</source>
          <target state="translated">Implantar el rasgo</target>
        </trans-unit>
        <trans-unit id="21127244da70324da76b7c0c9aa099a69f9c571a" translate="yes" xml:space="preserve">
          <source>Implement &lt;code&gt;unsafe&lt;/code&gt;&lt;a href=&quot;keyword.trait&quot;&gt;&lt;code&gt;trait&lt;/code&gt;&lt;/a&gt;s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d519e5f322d6b68d828741615581f614c79da78c" translate="yes" xml:space="preserve">
          <source>Implement an unsafe trait</source>
          <target state="translated">Implementar un rasgo inseguro</target>
        </trans-unit>
        <trans-unit id="442776eaaeebdf7e0bded5bbb09142472fe053b1" translate="yes" xml:space="preserve">
          <source>Implement some functionality for a type.</source>
          <target state="translated">Implementar alguna funcionalidad para un tipo.</target>
        </trans-unit>
        <trans-unit id="a512d32b6a8299d839d23927a30d0946b2b3937e" translate="yes" xml:space="preserve">
          <source>Implement the &lt;a href=&quot;trait.asmut&quot;&gt;&lt;code&gt;AsMut&lt;/code&gt;&lt;/a&gt; trait for cheap mutable-to-mutable conversions</source>
          <target state="translated">Implemente el rasgo &lt;a href=&quot;trait.asmut&quot;&gt; &lt;code&gt;AsMut&lt;/code&gt; &lt;/a&gt; para conversiones mutables a mutables baratas</target>
        </trans-unit>
        <trans-unit id="db05cb4c5fcad93a1bd13ef8e272ade5dcf5a9ed" translate="yes" xml:space="preserve">
          <source>Implement the &lt;a href=&quot;trait.asref&quot;&gt;&lt;code&gt;AsRef&lt;/code&gt;&lt;/a&gt; trait for cheap reference-to-reference conversions</source>
          <target state="translated">Implementar el rasgo &lt;a href=&quot;trait.asref&quot;&gt; &lt;code&gt;AsRef&lt;/code&gt; &lt;/a&gt; para conversiones de referencia a referencia econ&amp;oacute;micas</target>
        </trans-unit>
        <trans-unit id="24c2adeb5e2bfc607a7c5a50fd8f988a4093654a" translate="yes" xml:space="preserve">
          <source>Implement the &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; trait for consuming value-to-value conversions</source>
          <target state="translated">Implementar el rasgo &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; para consumir conversiones de valor a valor</target>
        </trans-unit>
        <trans-unit id="d27046965d37bd5d8cbb845498a9420dd8d95023" translate="yes" xml:space="preserve">
          <source>Implement the &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; trait for consuming value-to-value conversions to types outside the current crate</source>
          <target state="translated">Implementar el rasgo &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; para consumir conversiones de valor a valor a tipos fuera de la caja actual</target>
        </trans-unit>
        <trans-unit id="06e095af43d83707d7766a25b59d1943f1d5e7c9" translate="yes" xml:space="preserve">
          <source>Implement the &lt;code&gt;Copy&lt;/code&gt; trait on the type.</source>
          <target state="translated">Implemente el rasgo &lt;code&gt;Copy&lt;/code&gt; en el tipo.</target>
        </trans-unit>
        <trans-unit id="08a1e21e463e48ea6ec85aff968b0108176c62c8" translate="yes" xml:space="preserve">
          <source>Implementation details of logically-immutable methods</source>
          <target state="translated">Detalles de la aplicación de los métodos lógicamente inmutables</target>
        </trans-unit>
        <trans-unit id="1ddfd1ff2f1e0a2e2b1429c49bcda0a3059a1caa" translate="yes" xml:space="preserve">
          <source>Implementation details of logically-immutable methods.</source>
          <target state="translated">Detalles de la aplicación de los métodos lógicamente inmutables.</target>
        </trans-unit>
        <trans-unit id="e0bf2dc952ab6d2617aa9b9ee013534f9eeb5b62" translate="yes" xml:space="preserve">
          <source>Implementation notes</source>
          <target state="translated">Notas de aplicación</target>
        </trans-unit>
        <trans-unit id="cbd0574adde4a73750817df1b9bf6659b05baae3" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;../primitive.slice#method.concat&quot;&gt;&lt;code&gt;[T]::concat&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f209c5111fdc43ea4ba2b99ff5e91a185c5ba5f" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;../primitive.slice#method.join&quot;&gt;&lt;code&gt;[T]::join&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d07ae3ae0632c811bda0590dcd36a31748f12009" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;primitive.slice#method.concat&quot;&gt;&lt;code&gt;[T]::concat&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6523b8f0fa5de5a2e923accee11e86f6d33eb03c" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;primitive.slice#method.join&quot;&gt;&lt;code&gt;[T]::join&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59900d07c9905339bce32756f7c459df8b522597" translate="yes" xml:space="preserve">
          <source>Implementations</source>
          <target state="translated">Implementations</target>
        </trans-unit>
        <trans-unit id="a1e59e75f259fa9d9ba19603eb2d3e33d9fd3444" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to return &lt;code&gt;Err&lt;/code&gt; on memory exhaustion rather than panicking or aborting, but this is not a strict requirement. (Specifically: it is &lt;em&gt;legal&lt;/em&gt; to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)</source>
          <target state="translated">Se recomienda que las implementaciones devuelvan &lt;code&gt;Err&lt;/code&gt; al agotarse la memoria en lugar de entrar en p&amp;aacute;nico o abortar, pero este no es un requisito estricto. (Espec&amp;iacute;ficamente: es &lt;em&gt;legal&lt;/em&gt; implementar este rasgo encima de una biblioteca de asignaci&amp;oacute;n nativa subyacente que aborta cuando se agota la memoria).</target>
        </trans-unit>
        <trans-unit id="e30a5263932dd8adb2b92f110648d956dfcf128e" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to return null on memory exhaustion rather than aborting, but this is not a strict requirement. (Specifically: it is &lt;em&gt;legal&lt;/em&gt; to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)</source>
          <target state="translated">Se recomienda que las implementaciones devuelvan un valor nulo cuando se agote la memoria en lugar de abortar, pero esto no es un requisito estricto. (Espec&amp;iacute;ficamente: es &lt;em&gt;legal&lt;/em&gt; implementar este rasgo encima de una biblioteca de asignaci&amp;oacute;n nativa subyacente que aborta cuando se agota la memoria).</target>
        </trans-unit>
        <trans-unit id="7241603f3511aeef16c3bb5af01750a5d8ec0991" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to return null on memory exhaustion rather than panicking or aborting, but this is not a strict requirement. (Specifically: it is &lt;em&gt;legal&lt;/em&gt; to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)</source>
          <target state="translated">Se recomienda que las implementaciones devuelvan un valor nulo por agotamiento de la memoria en lugar de entrar en p&amp;aacute;nico o abortar, pero esto no es un requisito estricto. (Espec&amp;iacute;ficamente: es &lt;em&gt;legal&lt;/em&gt; implementar este rasgo encima de una biblioteca de asignaci&amp;oacute;n nativa subyacente que aborta cuando se agota la memoria).</target>
        </trans-unit>
        <trans-unit id="d9c40308bcf0812b701640d510d3be57409b94be" translate="yes" xml:space="preserve">
          <source>Implementations may contain outer &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; before the &lt;code&gt;impl&lt;/code&gt; keyword and inner &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; inside the brackets that contain the associated items. Inner attributes must come before any associated items. That attributes that have meaning here are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;.</source>
          <target state="translated">Las implementaciones pueden contener &lt;a href=&quot;../attributes&quot;&gt;atributos&lt;/a&gt; externos antes de la palabra clave &lt;code&gt;impl&lt;/code&gt; y &lt;a href=&quot;../attributes&quot;&gt;atributos&lt;/a&gt; internos dentro de los corchetes que contienen los elementos asociados. Los atributos internos deben ir antes que los elementos asociados. Los atributos que tienen significado aqu&amp;iacute; son &lt;a href=&quot;../conditional-compilation&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt; &lt;code&gt;doc&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;los atributos lint check&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d5c6183888e78c3e46f39fb71a3e11db5b02b618" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;a href=&quot;trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trait.partialord&quot;&gt;&lt;code&gt;PartialOrd&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;Ord&lt;/code&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. That is, &lt;code&gt;a.cmp(b) == Ordering::Equal&lt;/code&gt; if and only if &lt;code&gt;a == b&lt;/code&gt; and &lt;code&gt;Some(a.cmp(b)) == a.partial_cmp(b)&lt;/code&gt; for all &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="906e45c0ce13a452d5ad583acf7c948d36606488" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;a href=&quot;trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;PartialOrd&lt;/code&gt;, and &lt;a href=&quot;trait.ord&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c77f28f9797beb5e60c442300cafb1661e149f7" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;PartialEq&lt;/code&gt;, &lt;a href=&quot;trait.partialord&quot;&gt;&lt;code&gt;PartialOrd&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;trait.ord&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a14c265aa9aabd883301abe69f139e487531c5f2" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;PartialEq&lt;/code&gt;, &lt;code&gt;PartialOrd&lt;/code&gt;, and &lt;code&gt;Ord&lt;/code&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="translated">Las implementaciones de &lt;code&gt;PartialEq&lt;/code&gt; , &lt;code&gt;PartialOrd&lt;/code&gt; y &lt;code&gt;Ord&lt;/code&gt; &lt;em&gt;deben&lt;/em&gt; coincidir entre s&amp;iacute;. Es f&amp;aacute;cil hacer que no est&amp;eacute;n de acuerdo accidentalmente derivando algunos de los rasgos e implementando manualmente otros.</target>
        </trans-unit>
        <trans-unit id="0c5f5c9c85290b9df99598b15b458f58a9e2a332" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;PartialEq&lt;/code&gt;, &lt;code&gt;PartialOrd&lt;/code&gt;, and &lt;code&gt;Ord&lt;/code&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. That is, &lt;code&gt;a.cmp(b) == Ordering::Equal&lt;/code&gt; if and only if &lt;code&gt;a == b&lt;/code&gt; and &lt;code&gt;Some(a.cmp(b)) == a.partial_cmp(b)&lt;/code&gt; for all &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="translated">Las implementaciones de &lt;code&gt;PartialEq&lt;/code&gt; , &lt;code&gt;PartialOrd&lt;/code&gt; y &lt;code&gt;Ord&lt;/code&gt; &lt;em&gt;deben&lt;/em&gt; coincidir entre s&amp;iacute;. Es decir, &lt;code&gt;a.cmp(b) == Ordering::Equal&lt;/code&gt; si y s&amp;oacute;lo si &lt;code&gt;a == b&lt;/code&gt; y &lt;code&gt;Some(a.cmp(b)) == a.partial_cmp(b)&lt;/code&gt; para todos &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; . Es f&amp;aacute;cil hacer que no est&amp;eacute;n de acuerdo accidentalmente derivando algunos de los rasgos e implementando manualmente otros.</target>
        </trans-unit>
        <trans-unit id="f03739953743b6047f7ae8d466b9ff10b313f420" translate="yes" xml:space="preserve">
          <source>Implementations of must return the same mutable reference for their lifetime, unless replaced by a caller. Callers may only replace the reference when they stopped iteration and drop the iterator pipeline after extracting the source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="244386dfeb06556af9dc80db20c0c2ce222c9de8" translate="yes" xml:space="preserve">
          <source>Implementations of operator traits should be unsurprising in their respective contexts, keeping in mind their usual meanings and &lt;a href=&quot;../../reference/expressions#expression-precedence&quot;&gt;operator precedence&lt;/a&gt;. For example, when implementing &lt;a href=&quot;trait.mul&quot;&gt;&lt;code&gt;Mul&lt;/code&gt;&lt;/a&gt;, the operation should have some resemblance to multiplication (and share expected properties like associativity).</source>
          <target state="translated">Las implementaciones de los rasgos del operador no deber&amp;iacute;an sorprender en sus respectivos contextos, teniendo en cuenta sus significados habituales y la &lt;a href=&quot;../../reference/expressions#expression-precedence&quot;&gt;precedencia del operador&lt;/a&gt; . Por ejemplo, al implementar &lt;a href=&quot;trait.mul&quot;&gt; &lt;code&gt;Mul&lt;/code&gt; &lt;/a&gt; , la operaci&amp;oacute;n debe tener alg&amp;uacute;n parecido con la multiplicaci&amp;oacute;n (y compartir propiedades esperadas como la asociatividad).</target>
        </trans-unit>
        <trans-unit id="28805d0834dc067733940cf0a40b27bcfa746deb" translate="yes" xml:space="preserve">
          <source>Implementations of things like &lt;code&gt;Eq&lt;/code&gt; for fixed-length arrays up to a certain length. Eventually we should able to generalize to all lengths.</source>
          <target state="translated">Implementaciones de cosas como &lt;code&gt;Eq&lt;/code&gt; para arreglos de longitud fija hasta una cierta longitud. Con el tiempo, deber&amp;iacute;amos poder generalizar a todos los niveles.</target>
        </trans-unit>
        <trans-unit id="2f5aa5cbed1b025d1b2126e25480e69829ce743f" translate="yes" xml:space="preserve">
          <source>Implementations of things like &lt;code&gt;Eq&lt;/code&gt; for fixed-length arrays up to a certain length. Eventually, we should be able to generalize to all lengths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="118b3aed38f3812ad05266c0985ae4538e945007" translate="yes" xml:space="preserve">
          <source>Implementations of this trait have to promise that if the argument to &lt;code&gt;get_(mut_)unchecked&lt;/code&gt; is a safe reference, then so is the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb48644c15fbf48baad224f4f022b99ee1d0994" translate="yes" xml:space="preserve">
          <source>Implementations on Foreign Types</source>
          <target state="translated">Implementación de los tipos extranjeros</target>
        </trans-unit>
        <trans-unit id="1fc22c1620f81044690a14be1c43ca68e7e41355" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code id=&quot;implementing-send-and-sync-manually-is-unsafe&quot;&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt; Manually Is Unsafe</source>
          <target state="translated">Implementar &lt;code id=&quot;implementing-send-and-sync-manually-is-unsafe&quot;&gt;Send&lt;/code&gt; y &lt;code&gt;Sync&lt;/code&gt; manualmente no es seguro</target>
        </trans-unit>
        <trans-unit id="c7837b27bbf3d0dab1929c207399a6b0791244d8" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Add&lt;/code&gt; with generics</source>
          <target state="translated">Implementar &lt;code&gt;Add&lt;/code&gt; con gen&amp;eacute;ricos</target>
        </trans-unit>
        <trans-unit id="7dd172ca4f8bed0af8ee189dac34d629ede7f550" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Binary&lt;/code&gt; on a type:</source>
          <target state="translated">Implementando &lt;code&gt;Binary&lt;/code&gt; en un tipo:</target>
        </trans-unit>
        <trans-unit id="1493517ce3938521fcf7eadbd7d37ee08422c800" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Deref&lt;/code&gt; for smart pointers makes accessing the data behind them convenient, which is why they implement &lt;code&gt;Deref&lt;/code&gt;. On the other hand, the rules regarding &lt;code&gt;Deref&lt;/code&gt; and &lt;a href=&quot;trait.derefmut&quot;&gt;&lt;code&gt;DerefMut&lt;/code&gt;&lt;/a&gt; were designed specifically to accommodate smart pointers. Because of this, &lt;strong&gt;&lt;code&gt;Deref&lt;/code&gt; should only be implemented for smart pointers&lt;/strong&gt; to avoid confusion.</source>
          <target state="translated">La implementaci&amp;oacute;n de &lt;code&gt;Deref&lt;/code&gt; para punteros inteligentes hace que acceder a los datos detr&amp;aacute;s de ellos sea conveniente, por lo que implementan &lt;code&gt;Deref&lt;/code&gt; . Por otro lado, las reglas relativas a &lt;code&gt;Deref&lt;/code&gt; y &lt;a href=&quot;trait.derefmut&quot;&gt; &lt;code&gt;DerefMut&lt;/code&gt; &lt;/a&gt; se dise&amp;ntilde;aron espec&amp;iacute;ficamente para adaptarse a los punteros inteligentes. Debido a esto, &lt;strong&gt; &lt;code&gt;Deref&lt;/code&gt; solo debe implementarse para punteros inteligentes&lt;/strong&gt; para evitar confusiones.</target>
        </trans-unit>
        <trans-unit id="50891607fd39352027fce2fd66191f4d13f39144" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;DerefMut&lt;/code&gt; for smart pointers makes mutating the data behind them convenient, which is why they implement &lt;code&gt;DerefMut&lt;/code&gt;. On the other hand, the rules regarding &lt;a href=&quot;trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;DerefMut&lt;/code&gt; were designed specifically to accommodate smart pointers. Because of this, &lt;strong&gt;&lt;code&gt;DerefMut&lt;/code&gt; should only be implemented for smart pointers&lt;/strong&gt; to avoid confusion.</source>
          <target state="translated">La implementaci&amp;oacute;n de &lt;code&gt;DerefMut&lt;/code&gt; para punteros inteligentes hace que mutar los datos detr&amp;aacute;s de ellos sea conveniente, por eso implementan &lt;code&gt;DerefMut&lt;/code&gt; . Por otro lado, las reglas relativas a &lt;a href=&quot;trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt; y &lt;code&gt;DerefMut&lt;/code&gt; se dise&amp;ntilde;aron espec&amp;iacute;ficamente para adaptarse a los punteros inteligentes. Debido a esto, &lt;strong&gt; &lt;code&gt;DerefMut&lt;/code&gt; solo debe implementarse para punteros inteligentes&lt;/strong&gt; para evitar confusiones.</target>
        </trans-unit>
        <trans-unit id="8fb3ada706bbd2ce93453f2096c2280f1c5218cd" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Display&lt;/code&gt; on a type:</source>
          <target state="translated">Implementaci&amp;oacute;n de &lt;code&gt;Display&lt;/code&gt; en un tipo:</target>
        </trans-unit>
        <trans-unit id="19c2782a069f688b67217fbb710cab6e8fa425b0" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Drop&lt;/code&gt;</source>
          <target state="translated">Implementando &lt;code&gt;Drop&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fbf86abd91a91734cbbf99bafbece882a53975c0" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Extend&lt;/code&gt;:</source>
          <target state="translated">Implementando &lt;code&gt;Extend&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="55075e933ba7659b07b95de59bbad9f493028a57" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;FromIterator&lt;/code&gt; for your type:</source>
          <target state="translated">Implementando &lt;code&gt;FromIterator&lt;/code&gt; para su tipo:</target>
        </trans-unit>
        <trans-unit id="714405414f007a14389378ee0e0e1ef6296723bb" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Hash&lt;/code&gt;</source>
          <target state="translated">Implementando &lt;code&gt;Hash&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bd2490e0169b082204c99b8a05144dcf3715c4d7" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Into&lt;/code&gt; for conversions to external types</source>
          <target state="translated">Implementaci&amp;oacute;n &lt;code&gt;Into&lt;/code&gt; para conversiones a tipos externos</target>
        </trans-unit>
        <trans-unit id="47b64f6f87d5b0f43159c63203037214de4fae2c" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Into&lt;/code&gt; for conversions to external types in old versions of Rust</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6231ea57468a3a20172e55bfccdb5ea4af3eeb4" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;IntoIterator&lt;/code&gt; for your type:</source>
          <target state="translated">Implementando &lt;code&gt;IntoIterator&lt;/code&gt; para su tipo:</target>
        </trans-unit>
        <trans-unit id="147cae7152009bed2fea43b659a8a180c932938a" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;LowerExp&lt;/code&gt; on a type:</source>
          <target state="translated">Implementando &lt;code&gt;LowerExp&lt;/code&gt; en un tipo:</target>
        </trans-unit>
        <trans-unit id="69b1d57e51514796d74ae7e951b469bb891b71b2" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;LowerHex&lt;/code&gt; on a type:</source>
          <target state="translated">Implementaci&amp;oacute;n de &lt;code&gt;LowerHex&lt;/code&gt; en un tipo:</target>
        </trans-unit>
        <trans-unit id="77c550c1021e38d5e793ac99f6aef22c9d7b959a" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Octal&lt;/code&gt; on a type:</source>
          <target state="translated">Implementando &lt;code&gt;Octal&lt;/code&gt; en un tipo:</target>
        </trans-unit>
        <trans-unit id="4470ff81326a926c53b3562296af892e9472f832" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Pointer&lt;/code&gt; on a type:</source>
          <target state="translated">Implementando &lt;code&gt;Pointer&lt;/code&gt; en un tipo:</target>
        </trans-unit>
        <trans-unit id="ef0bab8534f2ce76a65ec1c5fd2792b4367f2e5b" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Sub&lt;/code&gt; with generics</source>
          <target state="translated">Implementando &lt;code&gt;Sub&lt;/code&gt; con gen&amp;eacute;ricos</target>
        </trans-unit>
        <trans-unit id="c36bf4b44d4c5b354ab37fe91e9d4c947758aacb" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;TryInto&lt;/code&gt;</source>
          <target state="translated">Implementando &lt;code&gt;TryInto&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ad299d14ee500d50f7ee89bb1d193e8f0dd8e2ea" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;UpperExp&lt;/code&gt; on a type:</source>
          <target state="translated">Implementando &lt;code&gt;UpperExp&lt;/code&gt; en un tipo:</target>
        </trans-unit>
        <trans-unit id="e594e74c4265d12e94c709d795a23f7132ef459e" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;UpperHex&lt;/code&gt; on a type:</source>
          <target state="translated">Implementando &lt;code&gt;UpperHex&lt;/code&gt; en un tipo:</target>
        </trans-unit>
        <trans-unit id="b2b4da88a0c30dc16a40a8acf8dff33108062af0" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;split_at_mut&lt;/code&gt;:</source>
          <target state="translated">Implementando &lt;code&gt;split_at_mut&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="77e25b21a8bf8e36c99842f5744d7e5c80adaf35" translate="yes" xml:space="preserve">
          <source>Implementing Iterator</source>
          <target state="translated">Implementar el Iterator</target>
        </trans-unit>
        <trans-unit id="0e4c93262368adc6172d82967b0b3a7ef8563873" translate="yes" xml:space="preserve">
          <source>Implementing Transitions as Transformations into Different Types</source>
          <target state="translated">Implementación de las transiciones como transformaciones en diferentes tipos</target>
        </trans-unit>
        <trans-unit id="3fc3cd424d3e34fdc8a1a744d196849e48c653de" translate="yes" xml:space="preserve">
          <source>Implementing a Trait on a Type</source>
          <target state="translated">Aplicación de un rasgo en un tipo</target>
        </trans-unit>
        <trans-unit id="15241dc16be9c86fd5c43587d3e88552aecb53a6" translate="yes" xml:space="preserve">
          <source>Implementing a trait on a type is similar to implementing regular methods. The difference is that after &lt;code&gt;impl&lt;/code&gt;, we put the trait name that we want to implement, then use the &lt;code&gt;for&lt;/code&gt; keyword, and then specify the name of the type we want to implement the trait for. Within the &lt;code&gt;impl&lt;/code&gt; block, we put the method signatures that the trait definition has defined. Instead of adding a semicolon after each signature, we use curly brackets and fill in the method body with the specific behavior that we want the methods of the trait to have for the particular type.</source>
          <target state="translated">Implementar un rasgo en un tipo es similar a implementar m&amp;eacute;todos regulares. La diferencia es que despu&amp;eacute;s de &lt;code&gt;impl&lt;/code&gt; , colocamos el nombre del rasgo que queremos implementar, luego usamos la palabra clave &lt;code&gt;for&lt;/code&gt; y luego especificamos el nombre del tipo para el que queremos implementar el rasgo. Dentro del bloque &lt;code&gt;impl&lt;/code&gt; , colocamos las firmas del m&amp;eacute;todo que la definici&amp;oacute;n del rasgo ha definido. En lugar de agregar un punto y coma despu&amp;eacute;s de cada firma, usamos llaves y completamos el cuerpo del m&amp;eacute;todo con el comportamiento espec&amp;iacute;fico que queremos que tengan los m&amp;eacute;todos del rasgo para el tipo en particular.</target>
        </trans-unit>
        <trans-unit id="52069ac07360b321a9102676a5d535746dd3971d" translate="yes" xml:space="preserve">
          <source>Implementing an &lt;a href=&quot;items/traits#unsafe-traits&quot;&gt;unsafe trait&lt;/a&gt;.</source>
          <target state="translated">Implementar un &lt;a href=&quot;items/traits#unsafe-traits&quot;&gt;rasgo inseguro&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a9e954962053f990d74213e5dbc3064a18dca7ad" translate="yes" xml:space="preserve">
          <source>Implementing an Object-Oriented Design Pattern</source>
          <target state="translated">Implementación de un patrón de diseño orientado a objetos</target>
        </trans-unit>
        <trans-unit id="9d35a11b4c4266f39d4667e1f1d83da884c8f6f2" translate="yes" xml:space="preserve">
          <source>Implementing an Unsafe Trait</source>
          <target state="translated">Implementación de un rasgo inseguro</target>
        </trans-unit>
        <trans-unit id="d729cb73986bbb9227ce3a73ce58a9f0f6e86093" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code id=&quot;implementing-the-drop-trait-on-threadpool&quot;&gt;Drop&lt;/code&gt; Trait on &lt;code&gt;ThreadPool&lt;/code&gt;</source>
          <target state="translated">Implementaci&amp;oacute;n del rasgo de &lt;code id=&quot;implementing-the-drop-trait-on-threadpool&quot;&gt;Drop&lt;/code&gt; en &lt;code&gt;ThreadPool&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="101c900375f64c03b1a8afd7a6a0fe94b0211873" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code id=&quot;implementing-the-execute-method&quot;&gt;execute&lt;/code&gt; Method</source>
          <target state="translated">Implementando el &lt;code id=&quot;implementing-the-execute-method&quot;&gt;execute&lt;/code&gt; m&amp;eacute;todo de ejecuci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="91e9cf1a72455d39636a847c09900ca81ea1ede1" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code id=&quot;implementing-the-search_case_insensitive-function&quot;&gt;search_case_insensitive&lt;/code&gt; Function</source>
          <target state="translated">Implementaci&amp;oacute;n de &lt;code id=&quot;implementing-the-search_case_insensitive-function&quot;&gt;search_case_insensitive&lt;/code&gt; funci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="3f2c422307f69f3d1ab1dc7b97ac7fa95dab102e" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code&gt;Deref&lt;/code&gt; trait allows you to customize the behavior of the &lt;em&gt;dereference operator&lt;/em&gt;, &lt;code&gt;*&lt;/code&gt; (as opposed to the multiplication or glob operator). By implementing &lt;code&gt;Deref&lt;/code&gt; in such a way that a smart pointer can be treated like a regular reference, you can write code that operates on references and use that code with smart pointers too.</source>
          <target state="translated">La implementaci&amp;oacute;n del rasgo &lt;code&gt;Deref&lt;/code&gt; le permite personalizar el comportamiento del &lt;em&gt;operador de desreferencia&lt;/em&gt; , &lt;code&gt;*&lt;/code&gt; (en contraposici&amp;oacute;n al operador de multiplicaci&amp;oacute;n o glob). Implementando &lt;code&gt;Deref&lt;/code&gt; de tal manera que un puntero inteligente pueda tratarse como una referencia regular, puede escribir c&amp;oacute;digo que opere sobre referencias y usar ese c&amp;oacute;digo tambi&amp;eacute;n con punteros inteligentes.</target>
        </trans-unit>
        <trans-unit id="0f9c556a4371185e579cbc710c1fc95eeb3c1d8f" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code&gt;Unpin&lt;/code&gt; trait for &lt;code&gt;T&lt;/code&gt; lifts the restrictions of pinning off the type, which then allows moving &lt;code&gt;T&lt;/code&gt; out of &lt;a href=&quot;../pin/struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt; with functions such as &lt;a href=&quot;../mem/fn.replace&quot;&gt;&lt;code&gt;mem::replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d230053d77d384522d54d81ff99e98d1f875f924" translate="yes" xml:space="preserve">
          <source>Implementing the Trait</source>
          <target state="translated">Implementación del rasgo</target>
        </trans-unit>
        <trans-unit id="b82c6b339ac0349fc9ead7cdf10b339a39a68691" translate="yes" xml:space="preserve">
          <source>Implementing these traits allows you to overload certain operators.</source>
          <target state="translated">La implementación de estos rasgos permite sobrecargar a ciertos operadores.</target>
        </trans-unit>
        <trans-unit id="eda774fd99643b19395b54fc514042bb2ec818cd" translate="yes" xml:space="preserve">
          <source>Implementing this method means adapters relinquish private-only access to their source and can only rely on guarantees made based on method receiver types. The lack of restricted access also requires that adapters must uphold the source's public API even when they have access to its internals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca73abeab36da273c6bc9f449021752cd0c1e57b" translate="yes" xml:space="preserve">
          <source>Implementing this trait lifts the restrictions of pinning off a type, which then allows it to move out with functions such as &lt;a href=&quot;../mem/fn.replace&quot;&gt;&lt;code&gt;mem::replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La implementaci&amp;oacute;n de este rasgo elimina las restricciones de anclar un tipo, lo que luego le permite moverse con funciones como &lt;a href=&quot;../mem/fn.replace&quot;&gt; &lt;code&gt;mem::replace&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0a118bbde46189d417f967d1c407afa2b062e337" translate="yes" xml:space="preserve">
          <source>Implementors</source>
          <target state="translated">Implementors</target>
        </trans-unit>
        <trans-unit id="d41c99e77922bf02d10d8206c4ebca64efb50ed3" translate="yes" xml:space="preserve">
          <source>Implementors of the &lt;code&gt;Read&lt;/code&gt; trait are called 'readers'.</source>
          <target state="translated">Los implementadores del rasgo &lt;code&gt;Read&lt;/code&gt; se denominan &quot;lectores&quot;.</target>
        </trans-unit>
        <trans-unit id="514197376900c36ae488796364d18374db39a755" translate="yes" xml:space="preserve">
          <source>Implementors of the &lt;code&gt;Write&lt;/code&gt; trait are sometimes called 'writers'.</source>
          <target state="translated">Los implementadores del rasgo &lt;code&gt;Write&lt;/code&gt; a veces se denominan &quot;escritores&quot;.</target>
        </trans-unit>
        <trans-unit id="7b51391f063265e762b93ff05cea534b40f36cab" translate="yes" xml:space="preserve">
          <source>Implements &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implementa &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../marker/trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a29b7cdf7ecad32a88da5f080db151e6782b6cbd" translate="yes" xml:space="preserve">
          <source>Implements comparison of arrays &lt;a href=&quot;cmp/trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b3e920e06f6ab852e47c92d5907d33f79db03f9" translate="yes" xml:space="preserve">
          <source>Implements comparison of arrays &lt;a href=&quot;trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b100c6b8306d80c3deac3c66eb144722bfbf34" translate="yes" xml:space="preserve">
          <source>Implements comparison of arrays lexicographically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a9bfc1f72bab87b52d6e0bc8ae9d29b981a8471" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors &lt;a href=&quot;cmp/trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1d4e2f4157c9478fac1167b8d36a099c3612234" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors &lt;a href=&quot;trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10b74ce308f3638c8dc26a321e4788cd3549d889" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors lexicographically.</source>
          <target state="translated">Implementa la comparación de vectores lexicográficamente.</target>
        </trans-unit>
        <trans-unit id="8c72616b99bde1fdb32f3ac1428fa28fcbc9bbe4" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors, &lt;a href=&quot;../cmp/trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="121392f51a7cb90c886bedc6219cb1e615ac17eb" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors, &lt;a href=&quot;trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb0984094b6e313cb053dba105c8a5fe1518709" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors, lexicographically.</source>
          <target state="translated">Implementa la comparación de vectores,lexicográficamente.</target>
        </trans-unit>
        <trans-unit id="c623dbf45db1a1dd3155e5aa00891729d9911a75" translate="yes" xml:space="preserve">
          <source>Implements comparison operations on strings.</source>
          <target state="translated">Implementa operaciones de comparación en las cuerdas.</target>
        </trans-unit>
        <trans-unit id="fa422ad638e34def3ed61f76d643f937ad273390" translate="yes" xml:space="preserve">
          <source>Implements ordering of strings.</source>
          <target state="translated">Implementa el orden de las cuerdas.</target>
        </trans-unit>
        <trans-unit id="35489c538a41efaebde69fb1cc4bd86b19d3be17" translate="yes" xml:space="preserve">
          <source>Implements ordering of vectors, &lt;a href=&quot;../cmp/trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0d293e0c8158270fc97cffd60669c60a1be015e" translate="yes" xml:space="preserve">
          <source>Implements ordering of vectors, &lt;a href=&quot;trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="971e74fed270cce031930eefae039d50cd565e60" translate="yes" xml:space="preserve">
          <source>Implements ordering of vectors, lexicographically.</source>
          <target state="translated">Implementa el ordenamiento de los vectores,lexicográficamente.</target>
        </trans-unit>
        <trans-unit id="58680944d0462c99ce50feabef36368106c01977" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[.. end]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[.. end]&lt;/code&gt;.</source>
          <target state="translated">Implementa la divisi&amp;oacute;n de subcadenas con la sintaxis &lt;code&gt;&amp;amp;self[.. end]&lt;/code&gt; o &lt;code&gt;&amp;amp;mut self[.. end]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bf1f89bacc4ebdf2c2a2d9a87f72a0cbee11668" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[..= end]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[..= end]&lt;/code&gt;.</source>
          <target state="translated">Implementa la divisi&amp;oacute;n de subcadenas con la sintaxis &lt;code&gt;&amp;amp;self[..= end]&lt;/code&gt; o &lt;code&gt;&amp;amp;mut self[..= end]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da645ed385fdda76f9f961ac5448a881f907e224" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[..]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[..]&lt;/code&gt;.</source>
          <target state="translated">Implementa la divisi&amp;oacute;n de subcadenas con la sintaxis &lt;code&gt;&amp;amp;self[..]&lt;/code&gt; o &lt;code&gt;&amp;amp;mut self[..]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c82188764e977bacdfe21b9530d35069e941412" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[begin .. end]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[begin .. end]&lt;/code&gt;.</source>
          <target state="translated">Implementa la divisi&amp;oacute;n de subcadenas con la sintaxis &lt;code&gt;&amp;amp;self[begin .. end]&lt;/code&gt; o &lt;code&gt;&amp;amp;mut self[begin .. end]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a07fed60a46af26079807bf7a0b3e1b8a8d87bb3" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[begin ..= end]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[begin ..= end]&lt;/code&gt;.</source>
          <target state="translated">Implementa la divisi&amp;oacute;n de subcadenas con la sintaxis &lt;code&gt;&amp;amp;self[begin ..= end]&lt;/code&gt; o &lt;code&gt;&amp;amp;mut self[begin ..= end]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1537ec46c2d0a4e7e9dc461c66dd7e3cbe98aa22" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[begin ..]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[begin ..]&lt;/code&gt;.</source>
          <target state="translated">Implementa la divisi&amp;oacute;n de subcadenas con la sintaxis &lt;code&gt;&amp;amp;self[begin ..]&lt;/code&gt; o &lt;code&gt;&amp;amp;mut self[begin ..]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d223234199abe8bb4c0bfb887abef9197c31b0b9" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;+&lt;/code&gt; operator for concatenating two strings.</source>
          <target state="translated">Implementa el operador &lt;code&gt;+&lt;/code&gt; para concatenar dos cadenas.</target>
        </trans-unit>
        <trans-unit id="a62b7d81ea62737514c99985edc740e2f4893f26" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;+=&lt;/code&gt; operator for appending to a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">Implementa el operador &lt;code&gt;+=&lt;/code&gt; para agregar a una &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08b4a374d5ecdf82a3bd7fcf0a3e5cd5e3d002b0" translate="yes" xml:space="preserve">
          <source>Implicit Borrows</source>
          <target state="translated">Préstamos implícitos</target>
        </trans-unit>
        <trans-unit id="52d69fbd753e37f89d007646ca34b62401a67b65" translate="yes" xml:space="preserve">
          <source>Implicit Deref Coercions with Functions and Methods</source>
          <target state="translated">Coacciones derivadas implícitas con funciones y métodos</target>
        </trans-unit>
        <trans-unit id="9cd3fd2c19032ec0693dd3e0bb3e6864c82344f9" translate="yes" xml:space="preserve">
          <source>Implicit borrows may be taken in the following expressions:</source>
          <target state="translated">Los préstamos implícitos pueden tomarse en las siguientes expresiones:</target>
        </trans-unit>
        <trans-unit id="0961d46086f62e40321101d8fe037c3242c1dca6" translate="yes" xml:space="preserve">
          <source>Implicitly Enables</source>
          <target state="translated">Implícitamente permite</target>
        </trans-unit>
        <trans-unit id="8d3c039379d281862e761701f9524d54eb568424" translate="yes" xml:space="preserve">
          <source>Import or rename items from other crates or modules.</source>
          <target state="translated">Importar o renombrar artículos de otras cajas o módulos.</target>
        </trans-unit>
        <trans-unit id="a3bc444ee7d2e0f0563ef80376cca1e4bb0a9a91" translate="yes" xml:space="preserve">
          <source>Importing with &lt;code&gt;_&lt;/code&gt; to only import the methods of a trait without binding it to a name (to avoid conflict for example): &lt;code&gt;use ::std::io::Read as _;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29b127da2c62a0f25a7fa91c02ddc3226003ecc1" translate="yes" xml:space="preserve">
          <source>Imports (&lt;code&gt;use&lt;/code&gt; statements) are not allowed after non-item statements, such as variable declarations and expression statements.</source>
          <target state="translated">Las importaciones ( declaraciones de &lt;code&gt;use&lt;/code&gt; ) no est&amp;aacute;n permitidas despu&amp;eacute;s de declaraciones que no son elementos, como declaraciones de variables y declaraciones de expresi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d2aaf30df627c6b455b6a60c943334e191311021" translate="yes" xml:space="preserve">
          <source>Improve the throughput of our server with a thread pool.</source>
          <target state="translated">Mejorar el rendimiento de nuestro servidor con un pool de hilos.</target>
        </trans-unit>
        <trans-unit id="8267a696e1fca0bf8e1c78b12f8b41535d37f29b" translate="yes" xml:space="preserve">
          <source>Improving Our I/O Project</source>
          <target state="translated">Mejorando nuestro proyecto de E/S</target>
        </trans-unit>
        <trans-unit id="36118f9610eaa573d453c935f24819cf14a02463" translate="yes" xml:space="preserve">
          <source>Improving Throughput with a Thread Pool</source>
          <target state="translated">Mejorando el rendimiento con una piscina de hilos</target>
        </trans-unit>
        <trans-unit id="6bb602ffe1a1796a0ed0994f72e464f54eb4f21f" translate="yes" xml:space="preserve">
          <source>Improving the Error Message</source>
          <target state="translated">Mejorando el mensaje de error</target>
        </trans-unit>
        <trans-unit id="e4f837d4943a95698d5ec4f9d39820ea86b85e18" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ThreadPool::new&lt;/code&gt;, use the &lt;code&gt;for&lt;/code&gt; loop counter to generate an &lt;code&gt;id&lt;/code&gt;, create a new &lt;code&gt;Worker&lt;/code&gt; with that &lt;code&gt;id&lt;/code&gt;, and store the worker in the vector.</source>
          <target state="translated">En &lt;code&gt;ThreadPool::new&lt;/code&gt; , use el contador de bucle &lt;code&gt;for&lt;/code&gt; para generar una &lt;code&gt;id&lt;/code&gt; entificaci&amp;oacute;n , cree un nuevo &lt;code&gt;Worker&lt;/code&gt; con esa &lt;code&gt;id&lt;/code&gt; entificaci&amp;oacute;n y almacene el trabajador en el vector.</target>
        </trans-unit>
        <trans-unit id="100c202393da689d751f40d7d7c72d2eb2131665" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ThreadPool::new&lt;/code&gt;, we create our new channel and have the pool hold the sending end. This will successfully compile, still with warnings.</source>
          <target state="translated">En &lt;code&gt;ThreadPool::new&lt;/code&gt; , creamos nuestro nuevo canal y hacemos que el grupo mantenga el extremo de env&amp;iacute;o. Esto se compilar&amp;aacute; correctamente, a&amp;uacute;n con advertencias.</target>
        </trans-unit>
        <trans-unit id="cd9ea4b1362ab818a61083cc410122b19426aee3" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ThreadPool::new&lt;/code&gt;, we put the receiving end of the channel in an &lt;code&gt;Arc&lt;/code&gt; and a &lt;code&gt;Mutex&lt;/code&gt;. For each new worker, we clone the &lt;code&gt;Arc&lt;/code&gt; to bump the reference count so the workers can share ownership of the receiving end.</source>
          <target state="translated">En &lt;code&gt;ThreadPool::new&lt;/code&gt; , colocamos el extremo receptor del canal en un &lt;code&gt;Arc&lt;/code&gt; y un &lt;code&gt;Mutex&lt;/code&gt; . Para cada nuevo trabajador, clonamos &lt;code&gt;Arc&lt;/code&gt; para aumentar el recuento de referencias para que los trabajadores puedan compartir la propiedad del extremo receptor.</target>
        </trans-unit>
        <trans-unit id="f2d294f487d8a5d6835e163c33ed5e5a47eb006a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we call the &lt;code&gt;Dog::baby_name&lt;/code&gt; function, which calls the associated function defined on &lt;code&gt;Dog&lt;/code&gt; directly. This code prints the following:</source>
          <target state="translated">En &lt;code&gt;main&lt;/code&gt; , llamamos a la funci&amp;oacute;n &lt;code&gt;Dog::baby_name&lt;/code&gt; , que llama a la funci&amp;oacute;n asociada definida en &lt;code&gt;Dog&lt;/code&gt; directamente a . Este c&amp;oacute;digo imprime lo siguiente:</target>
        </trans-unit>
        <trans-unit id="b126874c95de4c61a2b8e325eb70f8ef2e22596f" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we create two instances of &lt;code&gt;CustomSmartPointer&lt;/code&gt; and then print &lt;code&gt;CustomSmartPointers created.&lt;/code&gt;. At the end of &lt;code&gt;main&lt;/code&gt;, our instances of &lt;code&gt;CustomSmartPointer&lt;/code&gt; will go out of scope, and Rust will call the code we put in the &lt;code&gt;drop&lt;/code&gt; method, printing our final message. Note that we didn&amp;rsquo;t need to call the &lt;code&gt;drop&lt;/code&gt; method explicitly.</source>
          <target state="translated">En &lt;code&gt;main&lt;/code&gt; , creamos dos instancias de &lt;code&gt;CustomSmartPointer&lt;/code&gt; y luego imprimimos &lt;code&gt;CustomSmartPointers created.&lt;/code&gt; . Al final de &lt;code&gt;main&lt;/code&gt; , nuestras instancias de &lt;code&gt;CustomSmartPointer&lt;/code&gt; saldr&amp;aacute;n del alcance y Rust llamar&amp;aacute; al c&amp;oacute;digo que pusimos en el m&amp;eacute;todo &lt;code&gt;drop&lt;/code&gt; , imprimiendo nuestro mensaje final. Tenga en cuenta que no necesitamos llamar al m&amp;eacute;todo &lt;code&gt;drop&lt;/code&gt; expl&amp;iacute;citamente.</target>
        </trans-unit>
        <trans-unit id="80fb329de5f9b05c42fffbe0f4f0674e4bf17666" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we create two instances of &lt;code&gt;CustomSmartPointer&lt;/code&gt; and then print &lt;code&gt;CustomSmartPointers created&lt;/code&gt;. At the end of &lt;code&gt;main&lt;/code&gt;, our instances of &lt;code&gt;CustomSmartPointer&lt;/code&gt; will go out of scope, and Rust will call the code we put in the &lt;code&gt;drop&lt;/code&gt; method, printing our final message. Note that we didn&amp;rsquo;t need to call the &lt;code&gt;drop&lt;/code&gt; method explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46b07b2a2c9642ffdec1ea49c3a0a4bddfa6c2fc" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we&amp;rsquo;ve added a new statement: &lt;code&gt;fs::read_to_string&lt;/code&gt; takes the &lt;code&gt;filename&lt;/code&gt;, opens that file, and returns a &lt;code&gt;Result&amp;lt;String&amp;gt;&lt;/code&gt; of the file&amp;rsquo;s contents.</source>
          <target state="translated">En &lt;code&gt;main&lt;/code&gt; , hemos agregado una nueva declaraci&amp;oacute;n: &lt;code&gt;fs::read_to_string&lt;/code&gt; toma el &lt;code&gt;filename&lt;/code&gt; del archivo , abre ese archivo y devuelve un &lt;code&gt;Result&amp;lt;String&amp;gt;&lt;/code&gt; del contenido del archivo.</target>
        </trans-unit>
        <trans-unit id="e1e44a817bac208c6df64d33b0859e2cb13dbc28" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we&amp;rsquo;ve defined a &lt;code&gt;Point&lt;/code&gt; that has an &lt;code&gt;i32&lt;/code&gt; for &lt;code&gt;x&lt;/code&gt; (with value &lt;code&gt;5&lt;/code&gt;) and an &lt;code&gt;f64&lt;/code&gt; for &lt;code&gt;y&lt;/code&gt; (with value &lt;code&gt;10.4&lt;/code&gt;). The &lt;code&gt;p2&lt;/code&gt; variable is a &lt;code&gt;Point&lt;/code&gt; struct that has a string slice for &lt;code&gt;x&lt;/code&gt; (with value &lt;code&gt;&quot;Hello&quot;&lt;/code&gt;) and a &lt;code&gt;char&lt;/code&gt; for &lt;code&gt;y&lt;/code&gt; (with value &lt;code&gt;c&lt;/code&gt;). Calling &lt;code&gt;mixup&lt;/code&gt; on &lt;code&gt;p1&lt;/code&gt; with the argument &lt;code&gt;p2&lt;/code&gt; gives us &lt;code&gt;p3&lt;/code&gt;, which will have an &lt;code&gt;i32&lt;/code&gt; for &lt;code&gt;x&lt;/code&gt;, because &lt;code&gt;x&lt;/code&gt; came from &lt;code&gt;p1&lt;/code&gt;. The &lt;code&gt;p3&lt;/code&gt; variable will have a &lt;code&gt;char&lt;/code&gt; for &lt;code&gt;y&lt;/code&gt;, because &lt;code&gt;y&lt;/code&gt; came from &lt;code&gt;p2&lt;/code&gt;. The &lt;code&gt;println!&lt;/code&gt; macro call will print &lt;code&gt;p3.x = 5, p3.y = c&lt;/code&gt;.</source>
          <target state="translated">En &lt;code&gt;main&lt;/code&gt; , hemos definido un &lt;code&gt;Point&lt;/code&gt; que tiene un &lt;code&gt;i32&lt;/code&gt; para &lt;code&gt;x&lt;/code&gt; (con valor &lt;code&gt;5&lt;/code&gt; ) y un &lt;code&gt;f64&lt;/code&gt; para &lt;code&gt;y&lt;/code&gt; (con valor &lt;code&gt;10.4&lt;/code&gt; ). La variable &lt;code&gt;p2&lt;/code&gt; es una estructura &lt;code&gt;Point&lt;/code&gt; que tiene un segmento de cadena para &lt;code&gt;x&lt;/code&gt; (con valor &lt;code&gt;&quot;Hello&quot;&lt;/code&gt; ) y un &lt;code&gt;char&lt;/code&gt; para &lt;code&gt;y&lt;/code&gt; (con valor &lt;code&gt;c&lt;/code&gt; ). Llamar a la &lt;code&gt;mixup&lt;/code&gt; en &lt;code&gt;p1&lt;/code&gt; con el argumento &lt;code&gt;p2&lt;/code&gt; nos da &lt;code&gt;p3&lt;/code&gt; , que tendr&amp;aacute; un &lt;code&gt;i32&lt;/code&gt; para &lt;code&gt;x&lt;/code&gt; , porque &lt;code&gt;x&lt;/code&gt; vino de &lt;code&gt;p1&lt;/code&gt; . La variable &lt;code&gt;p3&lt;/code&gt; tendr&amp;aacute; un &lt;code&gt;char&lt;/code&gt; para &lt;code&gt;y&lt;/code&gt; , porque &lt;code&gt;y&lt;/code&gt; vino de &lt;code&gt;p2&lt;/code&gt; . &amp;iexcl;El &lt;code&gt;println!&lt;/code&gt; la llamada de macro imprimir&amp;aacute; &lt;code&gt;p3.x = 5, p3.y = c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bba4ad5fa0c6788a8a98dbb77c65406e530ab490" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;match&lt;/code&gt; expressions, you can match multiple patterns using the &lt;code&gt;|&lt;/code&gt; syntax, which means &lt;em&gt;or&lt;/em&gt;. For example, the following code matches the value of &lt;code&gt;x&lt;/code&gt; against the match arms, the first of which has an &lt;em&gt;or&lt;/em&gt; option, meaning if the value of &lt;code&gt;x&lt;/code&gt; matches either of the values in that arm, that arm&amp;rsquo;s code will run:</source>
          <target state="translated">En las expresiones de &lt;code&gt;match&lt;/code&gt; , puede hacer coincidir varios patrones utilizando el &lt;code&gt;|&lt;/code&gt; sintaxis, que significa &lt;em&gt;o&lt;/em&gt; . Por ejemplo, el siguiente c&amp;oacute;digo hace coincidir el valor de &lt;code&gt;x&lt;/code&gt; con los brazos de coincidencia, el primero de los cuales tiene una opci&amp;oacute;n &lt;em&gt;o&lt;/em&gt; , lo que significa que si el valor de &lt;code&gt;x&lt;/code&gt; coincide con cualquiera de los valores en ese brazo, el c&amp;oacute;digo de ese brazo se ejecutar&amp;aacute;:</target>
        </trans-unit>
        <trans-unit id="471f0502f020cdf6e90a94b9a608c70253a470d4" translate="yes" xml:space="preserve">
          <source>In C and C++, two different operators are used for calling methods: you use &lt;code&gt;.&lt;/code&gt; if you&amp;rsquo;re calling a method on the object directly and &lt;code&gt;-&amp;gt;&lt;/code&gt; if you&amp;rsquo;re calling the method on a pointer to the object and need to dereference the pointer first. In other words, if &lt;code&gt;object&lt;/code&gt; is a pointer, &lt;code&gt;object-&amp;gt;something()&lt;/code&gt; is similar to &lt;code&gt;(*object).something()&lt;/code&gt;.</source>
          <target state="translated">En C y C ++, se utilizan dos operadores diferentes para llamar a los m&amp;eacute;todos: you use &lt;code&gt;.&lt;/code&gt; si est&amp;aacute; llamando a un m&amp;eacute;todo en el objeto directamente y &lt;code&gt;-&amp;gt;&lt;/code&gt; si est&amp;aacute; llamando al m&amp;eacute;todo en un puntero al objeto y necesita desreferenciar el puntero primero. En otras palabras, si el &lt;code&gt;object&lt;/code&gt; es un puntero, &lt;code&gt;object-&amp;gt;something()&lt;/code&gt; es similar a &lt;code&gt;(*object).something()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13a07dbff3d7bb71ba41c886c11573397f976542" translate="yes" xml:space="preserve">
          <source>In C, attempting to read beyond the end of a data structure is undefined behavior. You might get whatever is at the location in memory that would correspond to that element in the data structure, even though the memory doesn&amp;rsquo;t belong to that structure. This is called a &lt;em&gt;buffer overread&lt;/em&gt; and can lead to security vulnerabilities if an attacker is able to manipulate the index in such a way as to read data they shouldn&amp;rsquo;t be allowed to that is stored after the data structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64fdbbe6b968fb04c1bbec44c80cb2463dbf6c14" translate="yes" xml:space="preserve">
          <source>In Chapter 1, you saw that &lt;code&gt;cargo new&lt;/code&gt; adds a bit of metadata to your &lt;em&gt;Cargo.toml&lt;/em&gt; file about an edition. This appendix talks about what that means!</source>
          <target state="translated">En el Cap&amp;iacute;tulo 1, vio que &lt;code&gt;cargo new&lt;/code&gt; agrega un poco de metadatos a su archivo &lt;em&gt;Cargo.toml&lt;/em&gt; sobre una edici&amp;oacute;n. &amp;iexcl;Este ap&amp;eacute;ndice habla de lo que eso significa!</target>
        </trans-unit>
        <trans-unit id="419cbad0fac9867b4734602903e0b31a93310f44" translate="yes" xml:space="preserve">
          <source>In Chapter 10 in the &lt;a href=&quot;ch10-02-traits#implementing-a-trait-on-a-type&quot;&gt;&amp;ldquo;Implementing a Trait on a Type&amp;rdquo;&lt;/a&gt; section, we mentioned the orphan rule that states we&amp;rsquo;re allowed to implement a trait on a type as long as either the trait or the type are local to our crate. It&amp;rsquo;s possible to get around this restriction using the &lt;em&gt;newtype pattern&lt;/em&gt;, which involves creating a new type in a tuple struct. (We covered tuple structs in the &lt;a href=&quot;ch05-01-defining-structs#using-tuple-structs-without-named-fields-to-create-different-types&quot;&gt;&amp;ldquo;Using Tuple Structs without Named Fields to Create Different Types&amp;rdquo;&lt;/a&gt; section of Chapter 5.) The tuple struct will have one field and be a thin wrapper around the type we want to implement a trait for. Then the wrapper type is local to our crate, and we can implement the trait on the wrapper. &lt;em&gt;Newtype&lt;/em&gt; is a term that originates from the Haskell programming language. There is no runtime performance penalty for using this pattern, and the wrapper type is elided at compile time.</source>
          <target state="translated">En el Cap&amp;iacute;tulo 10, en la secci&amp;oacute;n &lt;a href=&quot;ch10-02-traits#implementing-a-trait-on-a-type&quot;&gt;&amp;ldquo;Implementaci&amp;oacute;n de un rasgo en un tipo&amp;rdquo;&lt;/a&gt; , mencionamos la regla hu&amp;eacute;rfana que establece que se nos permite implementar un rasgo en un tipo siempre que el rasgo o el tipo sean locales de nuestra caja. Es posible sortear esta restricci&amp;oacute;n usando el &lt;em&gt;patr&amp;oacute;n newtype&lt;/em&gt; , que implica la creaci&amp;oacute;n de un nuevo tipo en una estructura de tupla. (Cubrimos las estructuras de tupla en la &lt;a href=&quot;ch05-01-defining-structs#using-tuple-structs-without-named-fields-to-create-different-types&quot;&gt;secci&amp;oacute;n &amp;ldquo;Uso de&lt;/a&gt; estructuras de tupla sin campos con nombre para crear tipos diferentes&amp;rdquo; del Cap&amp;iacute;tulo 5.) La estructura de tupla tendr&amp;aacute; un campo y ser&amp;aacute; una envoltura delgada alrededor del tipo para el que queremos implementar un rasgo. Entonces, el tipo de contenedor es local para nuestra caja y podemos implementar el rasgo en el contenedor.&lt;em&gt; Nuevo tipo&lt;/em&gt;es un t&amp;eacute;rmino que se origina en el lenguaje de programaci&amp;oacute;n Haskell. No hay ninguna penalizaci&amp;oacute;n de rendimiento en tiempo de ejecuci&amp;oacute;n por usar este patr&amp;oacute;n y el tipo de contenedor se elide en tiempo de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6e8eda75a8ab9306f12acf53c046575d81b5e2dd" translate="yes" xml:space="preserve">
          <source>In Chapter 10, we&amp;rsquo;ll discuss how to fix these errors so you can store references in structs, but for now, we&amp;rsquo;ll fix errors like these using owned types like &lt;code&gt;String&lt;/code&gt; instead of references like &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">En el Cap&amp;iacute;tulo 10, discutiremos c&amp;oacute;mo corregir estos errores para que pueda almacenar referencias en estructuras, pero por ahora, corregiremos errores como estos usando tipos &lt;code&gt;String&lt;/code&gt; como String en lugar de referencias como &lt;code&gt;&amp;amp;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6dd5d2912e04922d837d86cebbd6cbd63896a277" translate="yes" xml:space="preserve">
          <source>In Chapter 12, we built a package that included a binary crate and a library crate. As your project develops, you might find that the library crate continues to get bigger and you want to split up your package further into multiple library crates. In this situation, Cargo offers a feature called &lt;em&gt;workspaces&lt;/em&gt; that can help manage multiple related packages that are developed in tandem.</source>
          <target state="translated">En el Cap&amp;iacute;tulo 12, creamos un paquete que inclu&amp;iacute;a una caja binaria y una caja de biblioteca. A medida que se desarrolla su proyecto, es posible que descubra que la caja de la biblioteca sigue creciendo y desea dividir su paquete en varias cajas de la biblioteca. En esta situaci&amp;oacute;n, Cargo ofrece una funci&amp;oacute;n denominada &lt;em&gt;espacios de trabajo&lt;/em&gt; que puede ayudar a administrar m&amp;uacute;ltiples paquetes relacionados que se desarrollan en conjunto.</target>
        </trans-unit>
        <trans-unit id="49c36b868291ef37c009d9056785bf6564cfe5b0" translate="yes" xml:space="preserve">
          <source>In Chapter 13, we mentioned we can use the &lt;code&gt;move&lt;/code&gt; keyword before the parameter list of a closure to force the closure to take ownership of the values it uses in the environment. This technique is especially useful when creating new threads in order to transfer ownership of values from one thread to another.</source>
          <target state="translated">En el Cap&amp;iacute;tulo 13, mencionamos que podemos usar la palabra clave &lt;code&gt;move&lt;/code&gt; antes de la lista de par&amp;aacute;metros de un cierre para forzar al cierre a tomar posesi&amp;oacute;n de los valores que usa en el entorno. Esta t&amp;eacute;cnica es especialmente &amp;uacute;til al crear nuevos hilos para transferir la propiedad de los valores de un hilo a otro.</target>
        </trans-unit>
        <trans-unit id="9616d4847d514e47da8c019bd296575902cae104" translate="yes" xml:space="preserve">
          <source>In Chapter 15, we gave a value multiple owners by using the smart pointer &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; to create a reference counted value. Let&amp;rsquo;s do the same here and see what happens. We&amp;rsquo;ll wrap the &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; in &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; in Listing 16-14 and clone the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; before moving ownership to the thread. Now that we&amp;rsquo;ve seen the errors, we&amp;rsquo;ll also switch back to using the &lt;code&gt;for&lt;/code&gt; loop, and we&amp;rsquo;ll keep the &lt;code&gt;move&lt;/code&gt; keyword with the closure.</source>
          <target state="translated">En el Cap&amp;iacute;tulo 15, dimos un valor a varios propietarios mediante el uso del puntero inteligente &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; para crear un valor contado de referencia. Hagamos lo mismo aqu&amp;iacute; y veamos qu&amp;eacute; pasa. Envolveremos el &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; en &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; en el Listado 16-14 y clonaremos el &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; antes de mover la propiedad al hilo. Ahora que hemos visto los errores, tambi&amp;eacute;n volveremos a usar el ciclo &lt;code&gt;for&lt;/code&gt; y mantendremos la palabra clave &lt;code&gt;move&lt;/code&gt; con el cierre.</target>
        </trans-unit>
        <trans-unit id="524e710ff3be8a916b101bc286117de87c9609ca" translate="yes" xml:space="preserve">
          <source>In Chapter 16, we&amp;rsquo;ll walk through different models of concurrent programming and talk about how Rust helps you to program in multiple threads fearlessly. Chapter 17 looks at how Rust idioms compare to object-oriented programming principles you might be familiar with.</source>
          <target state="translated">En el Cap&amp;iacute;tulo 16, analizaremos diferentes modelos de programaci&amp;oacute;n concurrente y hablaremos sobre c&amp;oacute;mo Rust lo ayuda a programar en m&amp;uacute;ltiples subprocesos sin temor. El cap&amp;iacute;tulo 17 analiza c&amp;oacute;mo se comparan los modismos de Rust con los principios de programaci&amp;oacute;n orientada a objetos con los que puede estar familiarizado.</target>
        </trans-unit>
        <trans-unit id="b254c18823eda209cde7cf6f8cea34605d9c5def" translate="yes" xml:space="preserve">
          <source>In Chapter 16, you learned about &lt;em&gt;channels&lt;/em&gt;&amp;mdash;a simple way to communicate between two threads&amp;mdash;that would be perfect for this use case. We&amp;rsquo;ll use a channel to function as the queue of jobs, and &lt;code&gt;execute&lt;/code&gt; will send a job from the &lt;code&gt;ThreadPool&lt;/code&gt; to the &lt;code&gt;Worker&lt;/code&gt; instances, which will send the job to its thread. Here is the plan:</source>
          <target state="translated">En el Cap&amp;iacute;tulo 16, aprendi&amp;oacute; sobre los &lt;em&gt;canales&lt;/em&gt; , una forma sencilla de comunicarse entre dos subprocesos, que ser&amp;iacute;a perfecta para este caso de uso. Usaremos un canal para funcionar como la cola de trabajos, y la &lt;code&gt;execute&lt;/code&gt; enviar&amp;aacute; un trabajo desde &lt;code&gt;ThreadPool&lt;/code&gt; a las instancias de &lt;code&gt;Worker&lt;/code&gt; , que enviar&amp;aacute;n el trabajo a su hilo. Aqu&amp;iacute; est&amp;aacute; el plan:</target>
        </trans-unit>
        <trans-unit id="3e1e00d25fb2f54374f9cdbbf2a3175b4803a287" translate="yes" xml:space="preserve">
          <source>In Chapter 2, we programmed a guessing game project that used an external package called &lt;code&gt;rand&lt;/code&gt; to get random numbers. To use &lt;code&gt;rand&lt;/code&gt; in our project, we added this line to &lt;em&gt;Cargo.toml&lt;/em&gt;:</source>
          <target state="translated">En el Cap&amp;iacute;tulo 2, programamos un proyecto de juego de adivinanzas que usaba un paquete externo llamado &lt;code&gt;rand&lt;/code&gt; para obtener n&amp;uacute;meros aleatorios. Para usar &lt;code&gt;rand&lt;/code&gt; en nuestro proyecto, agregamos esta l&amp;iacute;nea a &lt;em&gt;Cargo.toml&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="bee04de80d9266da1b5a5bfd7fdbec672bcfa89d" translate="yes" xml:space="preserve">
          <source>In Chapter 20, we&amp;rsquo;ll complete a project in which we&amp;rsquo;ll implement a low-level multithreaded web server!</source>
          <target state="translated">En el Cap&amp;iacute;tulo 20, completaremos un proyecto en el que implementaremos un servidor web multiproceso de bajo nivel.</target>
        </trans-unit>
        <trans-unit id="da4870a8b39d1e60ec313b35fcf304bfbc8e23e3" translate="yes" xml:space="preserve">
          <source>In Chapter 3, we mentioned that the &lt;code&gt;for&lt;/code&gt; loop is the most common loop construction in Rust code, but we haven&amp;rsquo;t yet discussed the pattern that &lt;code&gt;for&lt;/code&gt; takes. In a &lt;code&gt;for&lt;/code&gt; loop, the pattern is the value that directly follows the keyword &lt;code&gt;for&lt;/code&gt;, so in &lt;code&gt;for x in y&lt;/code&gt; the &lt;code&gt;x&lt;/code&gt; is the pattern.</source>
          <target state="translated">En el cap&amp;iacute;tulo 3, mencionamos que el &lt;code&gt;for&lt;/code&gt; bucle es la construcci&amp;oacute;n de lazos com&amp;uacute;n en la mayor&amp;iacute;a de c&amp;oacute;digo Rust, pero a&amp;uacute;n no han discutido el patr&amp;oacute;n que &lt;code&gt;for&lt;/code&gt; toma. En un bucle &lt;code&gt;for&lt;/code&gt; , el patr&amp;oacute;n es el valor que sigue directamente a la palabra clave &lt;code&gt;for&lt;/code&gt; , por lo que en &lt;code&gt;for x in y&lt;/code&gt; la &lt;code&gt;x&lt;/code&gt; es el patr&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="2a6b931e0d8436c1034f6b7e378a03d10cebb868" translate="yes" xml:space="preserve">
          <source>In Chapter 4, in the &lt;a href=&quot;ch04-02-references-and-borrowing#dangling-references&quot;&gt;&amp;ldquo;Dangling References&amp;rdquo;&lt;/a&gt; section, we mentioned that the compiler ensures references are always valid. Unsafe Rust has two new types called &lt;em&gt;raw pointers&lt;/em&gt; that are similar to references. As with references, raw pointers can be immutable or mutable and are written as &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt;, respectively. The asterisk isn&amp;rsquo;t the dereference operator; it&amp;rsquo;s part of the type name. In the context of raw pointers, &lt;em&gt;immutable&lt;/em&gt; means that the pointer can&amp;rsquo;t be directly assigned to after being dereferenced.</source>
          <target state="translated">En el Cap&amp;iacute;tulo 4, en la secci&amp;oacute;n &lt;a href=&quot;ch04-02-references-and-borrowing#dangling-references&quot;&gt;&quot;Referencias colgantes&quot;&lt;/a&gt; , mencionamos que el compilador garantiza que las referencias sean siempre v&amp;aacute;lidas. Unsafe Rust tiene dos nuevos tipos llamados &lt;em&gt;punteros sin procesar&lt;/em&gt; que son similares a las referencias. Al igual que con las referencias, los punteros en bruto pueden ser inmutables o mutables y se escriben como &lt;code&gt;*const T&lt;/code&gt; y &lt;code&gt;*mut T&lt;/code&gt; , respectivamente. El asterisco no es el operador de desreferencia; es parte del nombre del tipo. En el contexto de los punteros sin formato, &lt;em&gt;inmutable&lt;/em&gt; significa que el puntero no se puede asignar directamente despu&amp;eacute;s de ser desreferenciado.</target>
        </trans-unit>
        <trans-unit id="9616acd550b92d5d17bfb0c9bd8cbc2238060146" translate="yes" xml:space="preserve">
          <source>In Chapter 5, Listing 5-15, we used a &lt;code&gt;Rectangle&lt;/code&gt; struct and a &lt;code&gt;can_hold&lt;/code&gt; method, which are repeated here in Listing 11-5. Let&amp;rsquo;s put this code in the &lt;em&gt;src/lib.rs&lt;/em&gt; file and write some tests for it using the &lt;code&gt;assert!&lt;/code&gt; macro.</source>
          <target state="translated">En el Cap&amp;iacute;tulo 5, Listado 5-15, usamos una estructura &lt;code&gt;Rectangle&lt;/code&gt; y un m&amp;eacute;todo &lt;code&gt;can_hold&lt;/code&gt; , que se repiten aqu&amp;iacute; en el Listado 11-5. &amp;iexcl;Pongamos este c&amp;oacute;digo en el archivo &lt;em&gt;src / lib.rs&lt;/em&gt; y escribamos algunas pruebas para &amp;eacute;l usando el &lt;em&gt;comando &lt;/em&gt; &lt;code&gt;assert!&lt;/code&gt; macro.</target>
        </trans-unit>
        <trans-unit id="d64a393b249bd7e0a04108160fbc20ff47d94fee" translate="yes" xml:space="preserve">
          <source>In Chapter 6 we discussed how to use &lt;code&gt;if let&lt;/code&gt; expressions mainly as a shorter way to write the equivalent of a &lt;code&gt;match&lt;/code&gt; that only matches one case. Optionally, &lt;code&gt;if let&lt;/code&gt; can have a corresponding &lt;code&gt;else&lt;/code&gt; containing code to run if the pattern in the &lt;code&gt;if let&lt;/code&gt; doesn&amp;rsquo;t match.</source>
          <target state="translated">En el Cap&amp;iacute;tulo 6 discutimos c&amp;oacute;mo usar las expresiones &lt;code&gt;if let&lt;/code&gt; principalmente como una forma m&amp;aacute;s corta de escribir el equivalente de una &lt;code&gt;match&lt;/code&gt; que solo coincide con un caso. Opcionalmente, &lt;code&gt;if let&lt;/code&gt; puede tener un &lt;code&gt;else&lt;/code&gt; correspondiente que contenga el c&amp;oacute;digo para ejecutar si el patr&amp;oacute;n en &lt;code&gt;if let&lt;/code&gt; no coincide.</target>
        </trans-unit>
        <trans-unit id="ff49c1ea64c951562a8bcde89d13031f272fed75" translate="yes" xml:space="preserve">
          <source>In Chapter 7, we covered how to organize our code into modules using the &lt;code&gt;mod&lt;/code&gt; keyword, how to make items public using the &lt;code&gt;pub&lt;/code&gt; keyword, and how to bring items into a scope with the &lt;code&gt;use&lt;/code&gt; keyword. However, the structure that makes sense to you while you&amp;rsquo;re developing a crate might not be very convenient for your users. You might want to organize your structs in a hierarchy containing multiple levels, but then people who want to use a type you&amp;rsquo;ve defined deep in the hierarchy might have trouble finding out that type exists. They might also be annoyed at having to enter &lt;code&gt;use&lt;/code&gt;&lt;code&gt;my_crate::some_module::another_module::UsefulType;&lt;/code&gt; rather than &lt;code&gt;use&lt;/code&gt;&lt;code&gt;my_crate::UsefulType;&lt;/code&gt;.</source>
          <target state="translated">En el Cap&amp;iacute;tulo 7, cubrimos c&amp;oacute;mo organizar nuestro c&amp;oacute;digo en m&amp;oacute;dulos usando la palabra clave &lt;code&gt;mod&lt;/code&gt; , c&amp;oacute;mo hacer p&amp;uacute;blicos los elementos usando la palabra clave &lt;code&gt;pub&lt;/code&gt; y c&amp;oacute;mo traer elementos a un &amp;aacute;mbito con la palabra clave &lt;code&gt;use&lt;/code&gt; . Sin embargo, la estructura que tiene sentido para usted mientras est&amp;aacute; desarrollando una caja puede no ser muy conveniente para sus usuarios. Es posible que desee organizar sus estructuras en una jerarqu&amp;iacute;a que contenga varios niveles, pero las personas que quieran usar un tipo que haya definido en lo profundo de la jerarqu&amp;iacute;a podr&amp;iacute;an tener problemas para descubrir que ese tipo existe. Tambi&amp;eacute;n pueden estar molestos por tener que ingresar &lt;code&gt;use&lt;/code&gt; &lt;code&gt;my_crate::some_module::another_module::UsefulType;&lt;/code&gt; en lugar de &lt;code&gt;use&lt;/code&gt; &lt;code&gt;my_crate::UsefulType;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02801cfc606033e06bb49c81943aa261a440dd2d" translate="yes" xml:space="preserve">
          <source>In Chapter 7, you&amp;rsquo;ll learn about Rust&amp;rsquo;s module system and about privacy rules for organizing your code and its public Application Programming Interface (API). Chapter 8 discusses some common collection data structures that the standard library provides, such as vectors, strings, and hash maps. Chapter 9 explores Rust&amp;rsquo;s error-handling philosophy and techniques.</source>
          <target state="translated">En el Cap&amp;iacute;tulo 7, aprender&amp;aacute; sobre el sistema de m&amp;oacute;dulos de Rust y las reglas de privacidad para organizar su c&amp;oacute;digo y su Interfaz de programaci&amp;oacute;n de aplicaciones (API) p&amp;uacute;blica. El Cap&amp;iacute;tulo 8 analiza algunas estructuras de datos de colecci&amp;oacute;n comunes que proporciona la biblioteca est&amp;aacute;ndar, como vectores, cadenas y mapas hash. El Cap&amp;iacute;tulo 9 explora la filosof&amp;iacute;a y las t&amp;eacute;cnicas de manejo de errores de Rust.</target>
        </trans-unit>
        <trans-unit id="e7f4fbe5cc4d72a766ad29608655fb9ff4930d83" translate="yes" xml:space="preserve">
          <source>In Chapter 8, we mentioned that one limitation of vectors is that they can store elements of only one type. We created a workaround in Listing 8-10 where we defined a &lt;code&gt;SpreadsheetCell&lt;/code&gt; enum that had variants to hold integers, floats, and text. This meant we could store different types of data in each cell and still have a vector that represented a row of cells. This is a perfectly good solution when our interchangeable items are a fixed set of types that we know when our code is compiled.</source>
          <target state="translated">En el cap&amp;iacute;tulo 8, mencionamos que una limitaci&amp;oacute;n de los vectores es que pueden almacenar elementos de un solo tipo. Creamos una soluci&amp;oacute;n en el Listado 8-10 donde definimos una enumeraci&amp;oacute;n &lt;code&gt;SpreadsheetCell&lt;/code&gt; que ten&amp;iacute;a variantes para contener enteros, flotantes y texto. Esto significaba que pod&amp;iacute;amos almacenar diferentes tipos de datos en cada celda y a&amp;uacute;n tener un vector que representaba una fila de celdas. Esta es una soluci&amp;oacute;n perfectamente buena cuando nuestros elementos intercambiables son un conjunto fijo de tipos que conocemos cuando se compila nuestro c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="e267a053c2b31342cb5ac845e840508abfe7bbb3" translate="yes" xml:space="preserve">
          <source>In Enum Definitions</source>
          <target state="translated">Definiciones In Enum</target>
        </trans-unit>
        <trans-unit id="d08f333361cce04633f52b106d6b6ade62115445" translate="yes" xml:space="preserve">
          <source>In Function Definitions</source>
          <target state="translated">En las definiciones de la función</target>
        </trans-unit>
        <trans-unit id="952ef560c212771bbd3d16f99bce32435686fed6" translate="yes" xml:space="preserve">
          <source>In Listing 10-3, we extracted the code that finds the largest number into a function named &lt;code&gt;largest&lt;/code&gt;. Unlike the code in Listing 10-1, which can find the largest number in only one particular list, this program can find the largest number in two different lists.</source>
          <target state="translated">En el Listado 10-3, extrajimos el c&amp;oacute;digo que encuentra el n&amp;uacute;mero m&amp;aacute;s grande en una funci&amp;oacute;n llamada &lt;code&gt;largest&lt;/code&gt; . A diferencia del c&amp;oacute;digo del Listado 10-1, que puede encontrar el n&amp;uacute;mero m&amp;aacute;s grande en una sola lista en particular, este programa puede encontrar el n&amp;uacute;mero m&amp;aacute;s grande en dos listas diferentes.</target>
        </trans-unit>
        <trans-unit id="251e784aeacbd80cde739b539768704abe3ddc6d" translate="yes" xml:space="preserve">
          <source>In Listing 11-7, we write a function named &lt;code&gt;add_two&lt;/code&gt; that adds &lt;code&gt;2&lt;/code&gt; to its parameter and returns the result. Then we test this function using the &lt;code&gt;assert_eq!&lt;/code&gt; macro.</source>
          <target state="translated">En el Listado 11-7, escribimos una funci&amp;oacute;n llamada &lt;code&gt;add_two&lt;/code&gt; que agrega &lt;code&gt;2&lt;/code&gt; a su par&amp;aacute;metro y devuelve el resultado. &amp;iexcl;Entonces probamos esta funci&amp;oacute;n usando el &lt;code&gt;assert_eq!&lt;/code&gt; macro.</target>
        </trans-unit>
        <trans-unit id="d82e9fd957ce66c3c7a26e3dace06a42f3599199" translate="yes" xml:space="preserve">
          <source>In Listing 12-6, we added code that took a slice of &lt;code&gt;String&lt;/code&gt; values and created an instance of the &lt;code&gt;Config&lt;/code&gt; struct by indexing into the slice and cloning the values, allowing the &lt;code&gt;Config&lt;/code&gt; struct to own those values. In Listing 13-24, we&amp;rsquo;ve reproduced the implementation of the &lt;code&gt;Config::new&lt;/code&gt; function as it was in Listing 12-23:</source>
          <target state="translated">En el Listado 12-6, agregamos c&amp;oacute;digo que tom&amp;oacute; una porci&amp;oacute;n de valores &lt;code&gt;String&lt;/code&gt; y cre&amp;oacute; una instancia de la estructura &lt;code&gt;Config&lt;/code&gt; indexando en la porci&amp;oacute;n y clonando los valores, permitiendo que la estructura &lt;code&gt;Config&lt;/code&gt; posea esos valores. En el Listado 13-24, hemos reproducido la implementaci&amp;oacute;n de la funci&amp;oacute;n &lt;code&gt;Config::new&lt;/code&gt; como estaba en el Listado 12-23:</target>
        </trans-unit>
        <trans-unit id="5c6ece155f6f659be90dea5131241132de1cb17f" translate="yes" xml:space="preserve">
          <source>In Listing 12-8, we add a check in the &lt;code&gt;new&lt;/code&gt; function that will verify that the slice is long enough before accessing index 1 and 2. If the slice isn&amp;rsquo;t long enough, the program panics and displays a better error message than the &lt;code&gt;index out of bounds&lt;/code&gt; message.</source>
          <target state="translated">En el Listado 12-8, agregamos una marca en la &lt;code&gt;new&lt;/code&gt; funci&amp;oacute;n que verificar&amp;aacute; que el segmento sea lo suficientemente largo antes de acceder al &amp;iacute;ndice 1 y 2. Si el segmento no es lo suficientemente largo, el programa entra en p&amp;aacute;nico y muestra un mensaje de error mejor que el mensaje de &lt;code&gt;index out of bounds&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a621c68344fc07697a4c57219c3ad610f989fc9" translate="yes" xml:space="preserve">
          <source>In Listing 13-18, we collect the results of iterating over the iterator that&amp;rsquo;s returned from the call to &lt;code&gt;map&lt;/code&gt; into a vector. This vector will end up containing each item from the original vector incremented by 1.</source>
          <target state="translated">En el Listado 13-18, recopilamos los resultados de la iteraci&amp;oacute;n sobre el iterador que devuelve la llamada para &lt;code&gt;map&lt;/code&gt; ear en un vector. Este vector terminar&amp;aacute; conteniendo cada elemento del vector original incrementado en 1.</target>
        </trans-unit>
        <trans-unit id="e328aca1efe77dcb66a14beff2cb9b70d383d6ea" translate="yes" xml:space="preserve">
          <source>In Listing 13-19, we use &lt;code&gt;filter&lt;/code&gt; with a closure that captures the &lt;code&gt;shoe_size&lt;/code&gt; variable from its environment to iterate over a collection of &lt;code&gt;Shoe&lt;/code&gt; struct instances. It will return only shoes that are the specified size.</source>
          <target state="translated">En el Listado 13-19, usamos un &lt;code&gt;filter&lt;/code&gt; con un cierre que captura la variable &lt;code&gt;shoe_size&lt;/code&gt; de su entorno para iterar sobre una colecci&amp;oacute;n de instancias de estructura &lt;code&gt;Shoe&lt;/code&gt; . Solo devolver&amp;aacute; zapatos del tama&amp;ntilde;o especificado.</target>
        </trans-unit>
        <trans-unit id="6a1682e0b3a9e5c47b274321d74d735f83965745" translate="yes" xml:space="preserve">
          <source>In Listing 15-19, we&amp;rsquo;ll change &lt;code&gt;main&lt;/code&gt; so it has an inner scope around list &lt;code&gt;c&lt;/code&gt;; then we can see how the reference count changes when &lt;code&gt;c&lt;/code&gt; goes out of scope.</source>
          <target state="translated">En el Listado 15-19, cambiaremos &lt;code&gt;main&lt;/code&gt; para que tenga un alcance interno alrededor de la lista &lt;code&gt;c&lt;/code&gt; ; entonces podemos ver c&amp;oacute;mo cambia el recuento de referencias cuando &lt;code&gt;c&lt;/code&gt; sale del alcance.</target>
        </trans-unit>
        <trans-unit id="9f9626bbec497c54ebb40a79e403600ad23d1aab" translate="yes" xml:space="preserve">
          <source>In Listing 15-26, we&amp;rsquo;re adding a &lt;code&gt;main&lt;/code&gt; function that uses the definitions in Listing 15-25. This code creates a list in &lt;code&gt;a&lt;/code&gt; and a list in &lt;code&gt;b&lt;/code&gt; that points to the list in &lt;code&gt;a&lt;/code&gt;. Then it modifies the list in &lt;code&gt;a&lt;/code&gt; to point to &lt;code&gt;b&lt;/code&gt;, creating a reference cycle. There are &lt;code&gt;println!&lt;/code&gt; statements along the way to show what the reference counts are at various points in this process.</source>
          <target state="translated">En el Listado 15-26, agregamos una funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; que usa las definiciones del Listado 15-25. Este c&amp;oacute;digo crea una lista en &lt;code&gt;a&lt;/code&gt; y una lista de &lt;code&gt;b&lt;/code&gt; que apunta a la lista en &lt;code&gt;a&lt;/code&gt; . Luego modifica la lista en &lt;code&gt;a&lt;/code&gt; para que apunte &lt;code&gt;b&lt;/code&gt; , creando un ciclo de referencia. &amp;iexcl;Hay &lt;code&gt;println!&lt;/code&gt; declaraciones en el camino para mostrar cu&amp;aacute;les son los recuentos de referencia en varios puntos de este proceso.</target>
        </trans-unit>
        <trans-unit id="f237ef95544abe33f20082c2caecb5f5e32b6fb4" translate="yes" xml:space="preserve">
          <source>In Listing 16-8, we&amp;rsquo;ll get the value from the receiving end of the channel in the main thread. This is like retrieving the rubber duck from the water at the end of the river or like getting a chat message.</source>
          <target state="translated">En el Listado 16-8, obtendremos el valor del extremo receptor del canal en el hilo principal. Esto es como recuperar el patito de goma del agua al final del r&amp;iacute;o o como recibir un mensaje de chat.</target>
        </trans-unit>
        <trans-unit id="d280dcdadbaa3eeba45c56f7de104a2c1d73e794" translate="yes" xml:space="preserve">
          <source>In Listing 18-11, we mentioned that we could use match guards to solve our pattern-shadowing problem. Recall that a new variable was created inside the pattern in the &lt;code&gt;match&lt;/code&gt; expression instead of using the variable outside the &lt;code&gt;match&lt;/code&gt;. That new variable meant we couldn&amp;rsquo;t test against the value of the outer variable. Listing 18-27 shows how we can use a match guard to fix this problem.</source>
          <target state="translated">En el listado 18-11, mencionamos que podr&amp;iacute;amos usar protectores de coincidencias para resolver nuestro problema de sombreado de patrones. Recuerde que se cre&amp;oacute; una nueva variable dentro del patr&amp;oacute;n en la expresi&amp;oacute;n de &lt;code&gt;match&lt;/code&gt; lugar de utilizar la variable fuera de la &lt;code&gt;match&lt;/code&gt; . Esa nueva variable significaba que no pod&amp;iacute;amos probar el valor de la variable externa. El Listado 18-27 muestra c&amp;oacute;mo podemos usar un protector de partidos para solucionar este problema.</target>
        </trans-unit>
        <trans-unit id="abca10c8f21596ea1dcac6548e565013c9ca5e54" translate="yes" xml:space="preserve">
          <source>In Listing 7-11, we bring the &lt;code&gt;crate::front_of_house::hosting&lt;/code&gt; module into the scope of the &lt;code&gt;eat_at_restaurant&lt;/code&gt; function so we only have to specify &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; to call the &lt;code&gt;add_to_waitlist&lt;/code&gt; function in &lt;code&gt;eat_at_restaurant&lt;/code&gt;.</source>
          <target state="translated">En el listado 7-11, traemos el &lt;code&gt;crate::front_of_house::hosting&lt;/code&gt; m&amp;oacute;dulo en el &amp;aacute;mbito de la &lt;code&gt;eat_at_restaurant&lt;/code&gt; funci&amp;oacute;n tan s&amp;oacute;lo tenemos que especificar &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; a llamar a la &lt;code&gt;add_to_waitlist&lt;/code&gt; funci&amp;oacute;n en &lt;code&gt;eat_at_restaurant&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4980a71413b7bee6107bccf8cc848ba4479eb5f7" translate="yes" xml:space="preserve">
          <source>In Listing 7-11, you might have wondered why we specified &lt;code&gt;use crate::front_of_house::hosting&lt;/code&gt; and then called &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; in &lt;code&gt;eat_at_restaurant&lt;/code&gt; rather than specifying the &lt;code&gt;use&lt;/code&gt; path all the way out to the &lt;code&gt;add_to_waitlist&lt;/code&gt; function to achieve the same result, as in Listing 7-13.</source>
          <target state="translated">En el Listado 7-11, es posible que se haya preguntado por qu&amp;eacute; especificamos &lt;code&gt;use crate::front_of_house::hosting&lt;/code&gt; y luego llamamos &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; en &lt;code&gt;eat_at_restaurant&lt;/code&gt; en lugar de especificar la ruta de &lt;code&gt;use&lt;/code&gt; hasta la funci&amp;oacute;n &lt;code&gt;add_to_waitlist&lt;/code&gt; para lograr el mismo resultado, como en el Listado 7-13.</target>
        </trans-unit>
        <trans-unit id="e4a8944a57a6797c5d37540cb53feeffc923077a" translate="yes" xml:space="preserve">
          <source>In Method Definitions</source>
          <target state="translated">En las definiciones de los métodos</target>
        </trans-unit>
        <trans-unit id="6bcea9677a17f227f763c241c0436f8dec05cc75" translate="yes" xml:space="preserve">
          <source>In Rust 1.3, the default object lifetime bounds are expected to change, as described in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md&quot;&gt;RFC 1156&lt;/a&gt;. You are getting a warning because the compiler thinks it is possible that this change will cause a compilation error in your code. It is possible, though unlikely, that this is a false alarm.</source>
          <target state="translated">En Rust 1.3, se espera que cambien los l&amp;iacute;mites de duraci&amp;oacute;n del objeto predeterminados, como se describe en &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md&quot;&gt;RFC 1156&lt;/a&gt; . Recibir&amp;aacute; una advertencia porque el compilador cree que es posible que este cambio provoque un error de compilaci&amp;oacute;n en su c&amp;oacute;digo. Es posible, aunque poco probable, que se trate de una falsa alarma.</target>
        </trans-unit>
        <trans-unit id="024c5bd925d0560baf0e3312c1764bcb998284df" translate="yes" xml:space="preserve">
          <source>In Rust 2015, paths in &lt;code&gt;use&lt;/code&gt; statements are relative to the crate root. To import items relative to the current and parent modules, use the &lt;code&gt;self::&lt;/code&gt; and &lt;code&gt;super::&lt;/code&gt; prefixes, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1dd28b00244d1766f66dc28a5630ffdd59cfac9" translate="yes" xml:space="preserve">
          <source>In Rust 2018 the &lt;code&gt;extern crate&lt;/code&gt; declaration is not required and you can instead just &lt;code&gt;use&lt;/code&gt; it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b256b3c7dd03072851511683d3f9db1e7f94539a" translate="yes" xml:space="preserve">
          <source>In Rust 2018, paths in &lt;code&gt;use&lt;/code&gt; statements are relative to the current module unless they begin with the name of a crate or a literal &lt;code&gt;crate::&lt;/code&gt;, in which case they start from the crate root. As in Rust 2015 code, the &lt;code&gt;self::&lt;/code&gt; and &lt;code&gt;super::&lt;/code&gt; prefixes refer to the current and parent modules respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="712e6f56bd66b2c2324289d3a7246a32df88ce1c" translate="yes" xml:space="preserve">
          <source>In Rust a function can &quot;return&quot; early if it either panics or calls a function which transitively panics. This sort of control flow is not always anticipated, and has the possibility of causing subtle bugs through a combination of two critical components:</source>
          <target state="translated">En el óxido,una función puede &quot;volver&quot; antes si entra en pánico o llama a una función que entra en pánico de manera transitoria.Este tipo de flujo de control no siempre se anticipa,y tiene la posibilidad de causar sutiles errores a través de una combinación de dos componentes críticos:</target>
        </trans-unit>
        <trans-unit id="9bc4180eb9646df4526201ce99ed1c8e848a3716" translate="yes" xml:space="preserve">
          <source>In Rust, &lt;em&gt;release profiles&lt;/em&gt; are predefined and customizable profiles with different configurations that allow a programmer to have more control over various options for compiling code. Each profile is configured independently of the others.</source>
          <target state="translated">En Rust, los &lt;em&gt;perfiles de lanzamiento&lt;/em&gt; son &lt;em&gt;perfiles&lt;/em&gt; predefinidos y personalizables con diferentes configuraciones que permiten al programador tener m&amp;aacute;s control sobre varias opciones para compilar c&amp;oacute;digo. Cada perfil se configura independientemente de los dem&amp;aacute;s.</target>
        </trans-unit>
        <trans-unit id="7767a9661c12c424875cfc28277bdd9f242eed45" translate="yes" xml:space="preserve">
          <source>In Rust, comments must start with two slashes and continue until the end of the line. For comments that extend beyond a single line, you&amp;rsquo;ll need to include &lt;code&gt;//&lt;/code&gt; on each line, like this:</source>
          <target state="translated">En Rust, los comentarios deben comenzar con dos barras y continuar hasta el final de la l&amp;iacute;nea. Para los comentarios que se extienden m&amp;aacute;s all&amp;aacute; de una sola l&amp;iacute;nea, deber&amp;aacute; incluir &lt;code&gt;//&lt;/code&gt; en cada l&amp;iacute;nea, as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="2b870cbcd5d9e116b1796136a551009e4fc668b1" translate="yes" xml:space="preserve">
          <source>In Rust, global variables are called &lt;em&gt;static&lt;/em&gt; variables. Listing 19-9 shows an example declaration and use of a static variable with a string slice as a value.</source>
          <target state="translated">En Rust, las variables globales se denominan variables &lt;em&gt;est&amp;aacute;ticas&lt;/em&gt; . El Listado 19-9 muestra una declaraci&amp;oacute;n de ejemplo y el uso de una variable est&amp;aacute;tica con un segmento de cadena como valor.</target>
        </trans-unit>
        <trans-unit id="9017f450d5ec005f20ca12643e0bd4fe5612a944" translate="yes" xml:space="preserve">
          <source>In Rust, integration tests are entirely external to your library. They use your library in the same way any other code would, which means they can only call functions that are part of your library&amp;rsquo;s public API. Their purpose is to test whether many parts of your library work together correctly. Units of code that work correctly on their own could have problems when integrated, so test coverage of the integrated code is important as well. To create integration tests, you first need a &lt;em&gt;tests&lt;/em&gt; directory.</source>
          <target state="translated">En Rust, las pruebas de integraci&amp;oacute;n son completamente externas a su biblioteca. Usan su biblioteca de la misma manera que lo har&amp;iacute;a cualquier otro c&amp;oacute;digo, lo que significa que solo pueden llamar a funciones que forman parte de la API p&amp;uacute;blica de su biblioteca. Su prop&amp;oacute;sito es probar si muchas partes de su biblioteca funcionan juntas correctamente. Las unidades de c&amp;oacute;digo que funcionan correctamente por s&amp;iacute; solas pueden tener problemas cuando se integran, por lo que la cobertura de prueba del c&amp;oacute;digo integrado tambi&amp;eacute;n es importante. Para crear pruebas de integraci&amp;oacute;n, primero necesita un directorio de &lt;em&gt;pruebas&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="dec0f2165acd76f17d012b2a448b31c87c4a44df" translate="yes" xml:space="preserve">
          <source>In Rust, it is common to provide different representations of a type for different use cases. For instance, storage location and management for a value can be specifically chosen as appropriate for a particular use via pointer types such as &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. Beyond these generic wrappers that can be used with any type, some types provide optional facets providing potentially costly functionality. An example for such a type is &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; which adds the ability to extend a string to the basic &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. This requires keeping additional information unnecessary for a simple, immutable string.</source>
          <target state="translated">En Rust, es com&amp;uacute;n proporcionar diferentes representaciones de un tipo para diferentes casos de uso. Por ejemplo, la ubicaci&amp;oacute;n de almacenamiento y la gesti&amp;oacute;n de un valor se pueden elegir espec&amp;iacute;ficamente seg&amp;uacute;n sea apropiado para un uso particular mediante tipos de puntero como &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; . M&amp;aacute;s all&amp;aacute; de estos envoltorios gen&amp;eacute;ricos que se pueden usar con cualquier tipo, algunos tipos proporcionan facetas opcionales que proporcionan una funcionalidad potencialmente costosa. Un ejemplo de tal tipo es &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; ,&lt;/a&gt; que agrega la capacidad de extender una cadena a la &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; b&amp;aacute;sica . Esto requiere mantener informaci&amp;oacute;n adicional innecesaria para una cadena simple e inmutable.</target>
        </trans-unit>
        <trans-unit id="82ce18dba324f3792ac22c2d57152d85262e47df" translate="yes" xml:space="preserve">
          <source>In Rust, it's more common to pass slices as arguments rather than vectors when you just want to provide a read access. The same goes for &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">En Rust, es m&amp;aacute;s com&amp;uacute;n pasar segmentos como argumentos en lugar de vectores cuando solo desea proporcionar acceso de lectura. Lo mismo ocurre con &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fa445d9bc6ce3579a8b9343d188f81a07982bc87" translate="yes" xml:space="preserve">
          <source>In Rust, it's more common to pass slices as arguments rather than vectors when you just want to provide read access. The same goes for &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26c54c2fe2f6156c5b713520cfa95f63f7a98f30" translate="yes" xml:space="preserve">
          <source>In Rust, iterators are &lt;em&gt;lazy&lt;/em&gt;, meaning they have no effect until you call methods that consume the iterator to use it up. For example, the code in Listing 13-13 creates an iterator over the items in the vector &lt;code&gt;v1&lt;/code&gt; by calling the &lt;code&gt;iter&lt;/code&gt; method defined on &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. This code by itself doesn&amp;rsquo;t do anything useful.</source>
          <target state="translated">En Rust, los iteradores son &lt;em&gt;perezosos&lt;/em&gt; , lo que significa que no tienen ning&amp;uacute;n efecto hasta que llama a m&amp;eacute;todos que consumen el iterador para usarlo. Por ejemplo, el c&amp;oacute;digo del Listado 13-13 crea un iterador sobre los elementos del vector &lt;code&gt;v1&lt;/code&gt; llamando al m&amp;eacute;todo &lt;code&gt;iter&lt;/code&gt; definido en &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; . Este c&amp;oacute;digo por s&amp;iacute; solo no hace nada &amp;uacute;til.</target>
        </trans-unit>
        <trans-unit id="94113c6270ca76a6260b8782567c46273149927b" translate="yes" xml:space="preserve">
          <source>In Rust, some simple types are &quot;implicitly copyable&quot; and when you assign them or pass them as arguments, the receiver will get a copy, leaving the original value in place. These types do not require allocation to copy and do not have finalizers (i.e., they do not contain owned boxes or implement &lt;a href=&quot;../ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt;), so the compiler considers them cheap and safe to copy. For other types copies must be made explicitly, by convention implementing the &lt;a href=&quot;trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; trait and calling the &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">En Rust, algunos tipos simples son &quot;copiables impl&amp;iacute;citamente&quot; y cuando los asigna o los pasa como argumentos, el receptor obtendr&amp;aacute; una copia, dejando el valor original en su lugar. Estos tipos no requieren asignaci&amp;oacute;n para copiar y no tienen finalizadores (es decir, no contienen cajas propias ni implementan &lt;a href=&quot;../ops/trait.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; &lt;/a&gt; ), por lo que el compilador los considera baratos y seguros de copiar. Para otros tipos, las copias deben hacerse expl&amp;iacute;citamente, por convenci&amp;oacute;n, implementando el rasgo &lt;a href=&quot;trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; y llamando al m&amp;eacute;todo &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2fcd990460e8b6d0fc26ae7880ea98a98c91ad7c" translate="yes" xml:space="preserve">
          <source>In Rust, some simple types are &quot;implicitly copyable&quot; and when you assign them or pass them as arguments, the receiver will get a copy, leaving the original value in place. These types do not require allocation to copy and do not have finalizers (i.e., they do not contain owned boxes or implement &lt;a href=&quot;../ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt;), so the compiler considers them cheap and safe to copy. For other types copies must be made explicitly, by convention implementing the &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; trait and calling the &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d027227e4e1f4e8516c4cd730528f3ec982d46a" translate="yes" xml:space="preserve">
          <source>In Rust, some types don't have a known size at compile-time. For example, in a slice type like &lt;code&gt;[u32]&lt;/code&gt;, the number of elements is not known at compile-time and hence the overall size cannot be computed. As a result, such types can only be manipulated through a reference (e.g., &lt;code&gt;&amp;amp;T&lt;/code&gt; or &lt;code&gt;&amp;amp;mut T&lt;/code&gt;) or other pointer-type (e.g., &lt;code&gt;Box&lt;/code&gt; or &lt;code&gt;Rc&lt;/code&gt;). Try casting to a reference instead:</source>
          <target state="translated">En Rust, algunos tipos no tienen un tama&amp;ntilde;o conocido en tiempo de compilaci&amp;oacute;n. Por ejemplo, en un tipo de segmento como &lt;code&gt;[u32]&lt;/code&gt; , el n&amp;uacute;mero de elementos no se conoce en tiempo de compilaci&amp;oacute;n y, por lo tanto, no se puede calcular el tama&amp;ntilde;o total. Como resultado, estos tipos solo se pueden manipular a trav&amp;eacute;s de una referencia (por ejemplo, &lt;code&gt;&amp;amp;T&lt;/code&gt; o &lt;code&gt;&amp;amp;mut T&lt;/code&gt; ) u otro tipo de puntero (por ejemplo, &lt;code&gt;Box&lt;/code&gt; o &lt;code&gt;Rc&lt;/code&gt; ). En su lugar, intente transmitir a una referencia:</target>
        </trans-unit>
        <trans-unit id="9fe024fcbc9eb5fd9138b820c96a155b436c6f2b" translate="yes" xml:space="preserve">
          <source>In Rust, strings are always valid UTF-8, which may contain zeros.</source>
          <target state="translated">En Rust,las cuerdas son siempre válidas UTF-8,que pueden contener ceros.</target>
        </trans-unit>
        <trans-unit id="47b3f71c4c3ef3117002e8cd6753431d26cd2f16" translate="yes" xml:space="preserve">
          <source>In Rust, the compiler guarantees that when you state that a value won&amp;rsquo;t change, it really won&amp;rsquo;t change. That means that when you&amp;rsquo;re reading and writing code, you don&amp;rsquo;t have to keep track of how and where a value might change. Your code is thus easier to reason through.</source>
          <target state="translated">En Rust, el compilador garantiza que cuando declaras que un valor no cambiar&amp;aacute;, realmente no cambiar&amp;aacute;. Eso significa que cuando lee y escribe c&amp;oacute;digo, no tiene que hacer un seguimiento de c&amp;oacute;mo y d&amp;oacute;nde puede cambiar un valor. Por lo tanto, su c&amp;oacute;digo es m&amp;aacute;s f&amp;aacute;cil de razonar.</target>
        </trans-unit>
        <trans-unit id="187bd10d150e89528422d52ad5b94f3768fbf136" translate="yes" xml:space="preserve">
          <source>In Rust, the idiomatic comment style starts a comment with two slashes, and the comment continues until the end of the line. For comments that extend beyond a single line, you&amp;rsquo;ll need to include &lt;code&gt;//&lt;/code&gt; on each line, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6617fc32e8b52f8e6973b5aca9e078db6c9e5e4e" translate="yes" xml:space="preserve">
          <source>In Rust, the values going into an array are written as a comma-separated list inside square brackets:</source>
          <target state="translated">En Rust,los valores que van en una matriz se escriben como una lista separada por comas dentro de corchetes:</target>
        </trans-unit>
        <trans-unit id="a0eeda0b6efe2675308b78561e1528ea9b8ef8e6" translate="yes" xml:space="preserve">
          <source>In Rust, which uses the concept of ownership and borrowing, an additional difference between references and smart pointers is that references are pointers that only borrow data; in contrast, in many cases, smart pointers &lt;em&gt;own&lt;/em&gt; the data they point to.</source>
          <target state="translated">En Rust, que utiliza el concepto de propiedad y pr&amp;eacute;stamo, una diferencia adicional entre referencias y punteros inteligentes es que las referencias son punteros que solo toman prestados datos; por el contrario, en muchos casos, los punteros inteligentes &lt;em&gt;poseen&lt;/em&gt; los datos a los que apuntan.</target>
        </trans-unit>
        <trans-unit id="691eb1f4f0d39b9fa142187d5288e88e969f7b55" translate="yes" xml:space="preserve">
          <source>In Rust, you can only move a value when its size is known at compile time.</source>
          <target state="translated">En Rust,sólo se puede mover un valor cuando se conoce su tamaño en el momento de la compilación.</target>
        </trans-unit>
        <trans-unit id="a157248f3dcdf6e31faebd518fa0921b01977a17" translate="yes" xml:space="preserve">
          <source>In Struct Definitions</source>
          <target state="translated">En Definiciones de Estructuras</target>
        </trans-unit>
        <trans-unit id="d100734dbe9aad18e3d33332b24c477c5b5bbfb9" translate="yes" xml:space="preserve">
          <source>In Turkish, the equivalent of 'i' in Latin has five forms instead of two:</source>
          <target state="translated">En turco,el equivalente de la &quot;i&quot; en latín tiene cinco formas en lugar de dos:</target>
        </trans-unit>
        <trans-unit id="95435691c2a2f4eefe5ecbf90205f41c0b8b41fb" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;keyword.trait&quot;&gt;&lt;code&gt;trait&lt;/code&gt;&lt;/a&gt; definition and related &lt;a href=&quot;keyword.impl&quot;&gt;&lt;code&gt;impl&lt;/code&gt;&lt;/a&gt; block:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b57043cd55b10d931a7fc7d67ec1a60b6e68743" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;fn&lt;/code&gt; type, a lifetime appears only in the return type and not in the arguments types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ed6a36e0bfb7f0da5796e97aada1c92ba3960ed" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;fn&lt;/code&gt; type, a lifetime appears only in the return type, and not in the arguments types.</source>
          <target state="translated">En un &lt;code&gt;fn&lt;/code&gt; tipo , una duraci&amp;oacute;n aparece solo en el tipo de retorno y no en los tipos de argumentos.</target>
        </trans-unit>
        <trans-unit id="f577fe622a880c803e2735f577b8d078ed3ef1c7" translate="yes" xml:space="preserve">
          <source>In a given program, the standard library has one &amp;ldquo;global&amp;rdquo; memory allocator that is used for example by &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">En un programa dado, la biblioteca est&amp;aacute;ndar tiene un asignador de memoria &quot;global&quot; que se utiliza, por ejemplo, por &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; y &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46b9760c06657f51a003601c090db16f5dbd5990" translate="yes" xml:space="preserve">
          <source>In a match expression, only numbers and characters can be matched against a range. This is because the compiler checks that the range is non-empty at compile-time, and is unable to evaluate arbitrary comparison functions. If you want to capture values of an orderable type between two end-points, you can use a guard.</source>
          <target state="translated">En una expresión de coincidencia,sólo los números y los caracteres pueden coincidir con un rango.Esto se debe a que el compilador comprueba que el rango no está vacío en tiempo de compilación,y no puede evaluar funciones de comparación arbitrarias.Si desea capturar valores de un tipo ordenable entre dos puntos finales,puede utilizar un protector.</target>
        </trans-unit>
        <trans-unit id="33cf96775891f63612a2b18790b9f75c00ddb97e" translate="yes" xml:space="preserve">
          <source>In a more ideal world, we could check that requirement by just checking that the given type implements both (1.) the &lt;code&gt;StructuralPartialEq&lt;/code&gt; trait &lt;em&gt;and&lt;/em&gt; (2.) the &lt;code&gt;Eq&lt;/code&gt; trait. However, you can have ADTs that &lt;em&gt;do&lt;/em&gt;&lt;code&gt;derive(PartialEq, Eq)&lt;/code&gt;, and be a case that we want the compiler to accept, and yet the constant's type fails to implement &lt;code&gt;Eq&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebeafd71108fc97e3607fbd0638300cd9c65eab5" translate="yes" xml:space="preserve">
          <source>In a more ideal world, we could check that requirement by just checking that the given type implements both the &lt;code&gt;StructuralPartialEq&lt;/code&gt; trait &lt;em&gt;and&lt;/em&gt; the &lt;code&gt;Eq&lt;/code&gt; trait. However, you can have ADTs that &lt;em&gt;do&lt;/em&gt;&lt;code&gt;derive(PartialEq, Eq)&lt;/code&gt;, and be a case that we want the compiler to accept, and yet the constant's type fails to implement &lt;code&gt;Eq&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41334b21dc400411b3cbc2d397bfe91718ef4ea6" translate="yes" xml:space="preserve">
          <source>In a pattern, all values that don't implement the &lt;code&gt;Copy&lt;/code&gt; trait have to be bound the same way. The goal here is to avoid binding simultaneously by-move and by-ref.</source>
          <target state="translated">En un patr&amp;oacute;n, todos los valores que no implementan la &lt;code&gt;Copy&lt;/code&gt; rasgo deben estar vinculados de la misma manera. El objetivo aqu&amp;iacute; es evitar atar simult&amp;aacute;neamente por movimiento y por ref.</target>
        </trans-unit>
        <trans-unit id="af5a9dd7adf13b2c4101e8e1cf8cfb6e4f72a459" translate="yes" xml:space="preserve">
          <source>In a pattern: inclusive range pattern</source>
          <target state="translated">En un patrón:patrón de rango inclusivo</target>
        </trans-unit>
        <trans-unit id="83c0ddf34fdbd1317fa94180ff2437b5be9c9767" translate="yes" xml:space="preserve">
          <source>In a similar fashion to the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; protocol, once a &lt;code&gt;DoubleEndedIterator&lt;/code&gt; returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; from a &lt;a href=&quot;trait.doubleendediterator#tymethod.next_back&quot;&gt;&lt;code&gt;next_back()&lt;/code&gt;&lt;/a&gt;, calling it again may or may not ever return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt; again. &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.doubleendediterator#tymethod.next_back&quot;&gt;&lt;code&gt;next_back()&lt;/code&gt;&lt;/a&gt; are interchangeable for this purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="697b27e185f89dd645c18a1dc354fc3f1802ced3" translate="yes" xml:space="preserve">
          <source>In a similar fashion to the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; protocol, once a &lt;code&gt;DoubleEndedIterator&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt; from a &lt;code&gt;next_back()&lt;/code&gt;, calling it again may or may not ever return &lt;code&gt;Some&lt;/code&gt; again. &lt;code&gt;next()&lt;/code&gt; and &lt;code&gt;next_back()&lt;/code&gt; are interchangeable for this purpose.</source>
          <target state="translated">De una manera similar a la &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; protocolo, una vez al &lt;code&gt;DoubleEndedIterator&lt;/code&gt; vuelve &lt;code&gt;None&lt;/code&gt; de un &lt;code&gt;next_back()&lt;/code&gt; , llamando de nuevo puede o no volver jam&amp;aacute;s &lt;code&gt;Some&lt;/code&gt; de nuevo. &lt;code&gt;next()&lt;/code&gt; y &lt;code&gt;next_back()&lt;/code&gt; son intercambiables para este prop&amp;oacute;sito.</target>
        </trans-unit>
        <trans-unit id="88eab3fc134ebcc83a18f11603e4f9bb4c35397e" translate="yes" xml:space="preserve">
          <source>In a way, channels in any programming language are similar to single ownership, because once you transfer a value down a channel, you should no longer use that value. Shared memory concurrency is like multiple ownership: multiple threads can access the same memory location at the same time. As you saw in Chapter 15, where smart pointers made multiple ownership possible, multiple ownership can add complexity because these different owners need managing. Rust&amp;rsquo;s type system and ownership rules greatly assist in getting this management correct. For an example, let&amp;rsquo;s look at mutexes, one of the more common concurrency primitives for shared memory.</source>
          <target state="translated">En cierto modo, los canales en cualquier lenguaje de programaci&amp;oacute;n son similares a la propiedad individual, porque una vez que transfieres un valor a un canal, ya no debes usar ese valor. La simultaneidad de la memoria compartida es como propiedad m&amp;uacute;ltiple: varios subprocesos pueden acceder a la misma ubicaci&amp;oacute;n de memoria al mismo tiempo. Como vio en el Cap&amp;iacute;tulo 15, donde los punteros inteligentes hicieron posible la propiedad m&amp;uacute;ltiple, la propiedad m&amp;uacute;ltiple puede agregar complejidad porque estos diferentes propietarios necesitan administraci&amp;oacute;n. El sistema de tipos y las reglas de propiedad de Rust ayudan enormemente a que esta gesti&amp;oacute;n sea correcta. Por ejemplo, veamos las exclusiones mutuas, una de las primitivas de concurrencia m&amp;aacute;s comunes para la memoria compartida.</target>
        </trans-unit>
        <trans-unit id="48cbc9de09384450c3743b99a8ac852e0f936580" translate="yes" xml:space="preserve">
          <source>In addition to being used for explicit dereferencing operations with the (unary) &lt;code&gt;*&lt;/code&gt; operator in immutable contexts, &lt;code&gt;Deref&lt;/code&gt; is also used implicitly by the compiler in many circumstances. This mechanism is called &lt;a href=&quot;#more-on-deref-coercion&quot;&gt;'&lt;code&gt;Deref&lt;/code&gt; coercion'&lt;/a&gt;. In mutable contexts, &lt;a href=&quot;trait.derefmut&quot;&gt;&lt;code&gt;DerefMut&lt;/code&gt;&lt;/a&gt; is used.</source>
          <target state="translated">Adem&amp;aacute;s de usarse para operaciones expl&amp;iacute;citas de desreferenciaci&amp;oacute;n con el operador (unario) &lt;code&gt;*&lt;/code&gt; en contextos inmutables, el &lt;code&gt;Deref&lt;/code&gt; tambi&amp;eacute;n usa impl&amp;iacute;citamente Deref en muchas circunstancias. Este mecanismo se llama &lt;a href=&quot;#more-on-deref-coercion&quot;&gt;&quot; coerci&amp;oacute;n de &lt;code&gt;Deref&lt;/code&gt; &quot;&lt;/a&gt; . En contextos mutables, se usa &lt;a href=&quot;trait.derefmut&quot;&gt; &lt;code&gt;DerefMut&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="af3b06fb6100259de10ad5265fd070edc0ff47dc" translate="yes" xml:space="preserve">
          <source>In addition to being used for explicit dereferencing operations with the (unary) &lt;code&gt;*&lt;/code&gt; operator in mutable contexts, &lt;code&gt;DerefMut&lt;/code&gt; is also used implicitly by the compiler in many circumstances. This mechanism is called &lt;a href=&quot;#more-on-deref-coercion&quot;&gt;'&lt;code&gt;Deref&lt;/code&gt; coercion'&lt;/a&gt;. In immutable contexts, &lt;a href=&quot;trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; is used.</source>
          <target state="translated">Adem&amp;aacute;s de usarse para operaciones de desreferenciaci&amp;oacute;n expl&amp;iacute;citas con el operador (unario) &lt;code&gt;*&lt;/code&gt; en contextos mutables, el &lt;code&gt;DerefMut&lt;/code&gt; tambi&amp;eacute;n usa impl&amp;iacute;citamente DerefMut en muchas circunstancias. Este mecanismo se llama &lt;a href=&quot;#more-on-deref-coercion&quot;&gt;&quot; coerci&amp;oacute;n de &lt;code&gt;Deref&lt;/code&gt; &quot;&lt;/a&gt; . En contextos inmutables, se usa &lt;a href=&quot;trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="abb02b5058d0ef49ec9e5d67ae93248f0d00150f" translate="yes" xml:space="preserve">
          <source>In addition to checking that our code returns the correct values we expect, it&amp;rsquo;s also important to check that our code handles error conditions as we expect. For example, consider the &lt;code&gt;Guess&lt;/code&gt; type that we created in Chapter 9, Listing 9-10. Other code that uses &lt;code&gt;Guess&lt;/code&gt; depends on the guarantee that &lt;code&gt;Guess&lt;/code&gt; instances will contain only values between 1 and 100. We can write a test that ensures that attempting to create a &lt;code&gt;Guess&lt;/code&gt; instance with a value outside that range panics.</source>
          <target state="translated">Adem&amp;aacute;s de verificar que nuestro c&amp;oacute;digo devuelva los valores correctos que esperamos, tambi&amp;eacute;n es importante verificar que nuestro c&amp;oacute;digo maneje las condiciones de error como esperamos. Por ejemplo, considere el tipo &lt;code&gt;Guess&lt;/code&gt; que creamos en el Cap&amp;iacute;tulo 9, Listado 9-10. Otro c&amp;oacute;digo que usa &lt;code&gt;Guess&lt;/code&gt; depende de la garant&amp;iacute;a de que las instancias de &lt;code&gt;Guess&lt;/code&gt; contendr&amp;aacute;n solo valores entre 1 y 100. Podemos escribir una prueba que asegure que intentar crear una instancia de &lt;code&gt;Guess&lt;/code&gt; con un valor fuera de ese rango entra en p&amp;aacute;nico.</target>
        </trans-unit>
        <trans-unit id="365e97bba6e57bb996028209ce11038273821045" translate="yes" xml:space="preserve">
          <source>In addition to destructuring through pattern matching, we can access a tuple element directly by using a period (&lt;code&gt;.&lt;/code&gt;) followed by the index of the value we want to access. For example:</source>
          <target state="translated">Adem&amp;aacute;s de la desestructuraci&amp;oacute;n mediante la coincidencia de patrones, podemos acceder a un elemento de tupla directamente usando un punto ( &lt;code&gt;.&lt;/code&gt; ) Seguido del &amp;iacute;ndice del valor al que queremos acceder. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="47ed7b4173b1b21a3fd1fe7ba6e3f3784fea24f1" translate="yes" xml:space="preserve">
          <source>In addition to fitting the block of memory &lt;code&gt;layout&lt;/code&gt;, the alignment of the &lt;code&gt;layout&lt;/code&gt; must match the alignment used to allocate that block of memory.</source>
          <target state="translated">Adem&amp;aacute;s de ajustar el &lt;code&gt;layout&lt;/code&gt; del bloque de memoria , la alineaci&amp;oacute;n del &lt;code&gt;layout&lt;/code&gt; debe coincidir con la alineaci&amp;oacute;n utilizada para asignar ese bloque de memoria.</target>
        </trans-unit>
        <trans-unit id="858e151181f26f5ae0ab57f08e577f173bb29c01" translate="yes" xml:space="preserve">
          <source>In addition to grouping functionality, encapsulating implementation details lets you reuse code at a higher level: once you&amp;rsquo;ve implemented an operation, other code can call that code via the code&amp;rsquo;s public interface without knowing how the implementation works. The way you write code defines which parts are public for other code to use and which parts are private implementation details that you reserve the right to change. This is another way to limit the amount of detail you have to keep in your head.</source>
          <target state="translated">Adem&amp;aacute;s de la funcionalidad de agrupaci&amp;oacute;n, encapsular los detalles de la implementaci&amp;oacute;n le permite reutilizar el c&amp;oacute;digo en un nivel superior: una vez que haya implementado una operaci&amp;oacute;n, otro c&amp;oacute;digo puede llamar a ese c&amp;oacute;digo a trav&amp;eacute;s de la interfaz p&amp;uacute;blica del c&amp;oacute;digo sin saber c&amp;oacute;mo funciona la implementaci&amp;oacute;n. La forma en que escribe el c&amp;oacute;digo define qu&amp;eacute; partes son p&amp;uacute;blicas para que las use otro c&amp;oacute;digo y qu&amp;eacute; partes son detalles de implementaci&amp;oacute;n privados que se reserva el derecho de cambiar. Esta es otra forma de limitar la cantidad de detalles que debe tener en la cabeza.</target>
        </trans-unit>
        <trans-unit id="d459ee4d2bcede7c5e1530b0662bf25061170f15" translate="yes" xml:space="preserve">
          <source>In addition to presenting fixed types in the form of &lt;code&gt;fn name(arg: type, ..) -&amp;gt; return_type&lt;/code&gt;, functions can also declare a list of type parameters along with trait bounds that they fall into.</source>
          <target state="translated">Adem&amp;aacute;s de presentar tipos fijos en forma de &lt;code&gt;fn name(arg: type, ..) -&amp;gt; return_type&lt;/code&gt; , las funciones tambi&amp;eacute;n pueden declarar una lista de par&amp;aacute;metros de tipo junto con los l&amp;iacute;mites de rasgos en los que caen.</target>
        </trans-unit>
        <trans-unit id="d6b811c43ad4130bc5a6536fe58f23b2b67258a1" translate="yes" xml:space="preserve">
          <source>In addition to public and private, Rust allows users to declare an item as visible only within a given scope. The rules for &lt;code&gt;pub&lt;/code&gt; restrictions are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef3214c58b982aa2702311df460d3b874a884211" translate="yes" xml:space="preserve">
          <source>In addition to public and private, Rust allows users to declare an item as visible within a given scope. The rules for &lt;code&gt;pub&lt;/code&gt; restrictions are as follows:</source>
          <target state="translated">Adem&amp;aacute;s de p&amp;uacute;blico y privado, Rust permite a los usuarios declarar un elemento como visible dentro de un alcance determinado. Las reglas para las restricciones de &lt;code&gt;pub&lt;/code&gt; son las siguientes:</target>
        </trans-unit>
        <trans-unit id="3a4fd8d0332edcf68d5aa98b13a167d67e20f89e" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;#implementors&quot;&gt;implementors listed below&lt;/a&gt;, the following types also implement &lt;code&gt;Clone&lt;/code&gt;:</source>
          <target state="translated">Adem&amp;aacute;s de los &lt;a href=&quot;#implementors&quot;&gt;implementadores que se enumeran a continuaci&amp;oacute;n&lt;/a&gt; , los siguientes tipos tambi&amp;eacute;n implementan &lt;code&gt;Clone&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ace5e2ba5f74b469af0997ea9c80ff822efcee75" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;#implementors&quot;&gt;implementors listed below&lt;/a&gt;, the following types also implement &lt;code&gt;Copy&lt;/code&gt;:</source>
          <target state="translated">Adem&amp;aacute;s de los &lt;a href=&quot;#implementors&quot;&gt;implementadores que se enumeran a continuaci&amp;oacute;n&lt;/a&gt; , los siguientes tipos tambi&amp;eacute;n implementan &lt;code&gt;Copy&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2b65cf249390a35c8db24cb36bc73dc17e310a62" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;#[cfg]&lt;/code&gt; attribute, this macro is provided to allow boolean expression evaluation of configuration flags. This frequently leads to less duplicated code.</source>
          <target state="translated">Adem&amp;aacute;s del atributo &lt;code&gt;#[cfg]&lt;/code&gt; , esta macro se proporciona para permitir la evaluaci&amp;oacute;n de expresiones booleanas de los indicadores de configuraci&amp;oacute;n. Con frecuencia, esto conduce a un c&amp;oacute;digo menos duplicado.</target>
        </trans-unit>
        <trans-unit id="9928bdeaf0664bcb4ac6ed66b9b662d8e9fba451" translate="yes" xml:space="preserve">
          <source>In addition to the parsed &lt;a href=&quot;enum.prefix&quot;&gt;&lt;code&gt;Prefix&lt;/code&gt;&lt;/a&gt; information returned by &lt;a href=&quot;#method.kind&quot;&gt;&lt;code&gt;kind&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;PrefixComponent&lt;/code&gt; also holds the raw and unparsed &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; slice, returned by &lt;a href=&quot;#method.as_os_str&quot;&gt;&lt;code&gt;as_os_str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Adem&amp;aacute;s de la informaci&amp;oacute;n de &lt;a href=&quot;enum.prefix&quot;&gt; &lt;code&gt;Prefix&lt;/code&gt; &lt;/a&gt; analizada devuelta por &lt;a href=&quot;#method.kind&quot;&gt; &lt;code&gt;kind&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;PrefixComponent&lt;/code&gt; tambi&amp;eacute;n contiene el segmento &lt;a href=&quot;../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; sin&lt;/a&gt; analizar y sin analizar , devuelto por &lt;a href=&quot;#method.as_os_str&quot;&gt; &lt;code&gt;as_os_str&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5eb0888677903038da8d3a6a5332c2add97dc4d4" translate="yes" xml:space="preserve">
          <source>In addition to the parsed &lt;a href=&quot;enum.prefix&quot;&gt;&lt;code&gt;Prefix&lt;/code&gt;&lt;/a&gt; information returned by &lt;a href=&quot;struct.prefixcomponent#method.kind&quot;&gt;&lt;code&gt;kind&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;PrefixComponent&lt;/code&gt; also holds the raw and unparsed &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; slice, returned by &lt;a href=&quot;struct.prefixcomponent#method.as_os_str&quot;&gt;&lt;code&gt;as_os_str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0480691b89aace6e481aff35265293b818ddc02e" translate="yes" xml:space="preserve">
          <source>In addition to varying based on their signature, function pointers come in two flavors: safe and unsafe. Plain &lt;code&gt;fn()&lt;/code&gt; function pointers can only point to safe functions, while &lt;code&gt;unsafe fn()&lt;/code&gt; function pointers can point to safe or unsafe functions.</source>
          <target state="translated">Adem&amp;aacute;s de variar en funci&amp;oacute;n de su firma, los indicadores de funci&amp;oacute;n vienen en dos sabores: seguros e inseguros. Los punteros de funci&amp;oacute;n &lt;code&gt;fn()&lt;/code&gt; simples solo pueden apuntar a funciones seguras, mientras que los punteros de funci&amp;oacute;n &lt;code&gt;unsafe fn()&lt;/code&gt; pueden apuntar a funciones seguras o no seguras.</target>
        </trans-unit>
        <trans-unit id="63d3d13a6b16bc95491afdee798f040bc422692b" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;unsafe&lt;/code&gt; does not mean the code inside the block is necessarily dangerous or that it will definitely have memory safety problems: the intent is that as the programmer, you&amp;rsquo;ll ensure the code inside an &lt;code&gt;unsafe&lt;/code&gt; block will access memory in a valid way.</source>
          <target state="translated">Adem&amp;aacute;s, &lt;code&gt;unsafe&lt;/code&gt; no significa que el c&amp;oacute;digo dentro del bloque sea necesariamente peligroso o que definitivamente tendr&amp;aacute; problemas de seguridad de la memoria: la intenci&amp;oacute;n es que, como programador, se asegure de que el c&amp;oacute;digo dentro de un bloque &lt;code&gt;unsafe&lt;/code&gt; acceda a la memoria de manera v&amp;aacute;lida. .</target>
        </trans-unit>
        <trans-unit id="2b037e46e14761e122095139862caa141b1230d1" translate="yes" xml:space="preserve">
          <source>In addition, function pointers of &lt;em&gt;any&lt;/em&gt; signature, ABI, or safety are &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, and all &lt;em&gt;safe&lt;/em&gt; function pointers implement &lt;a href=&quot;ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;ops/trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt;. This works because these traits are specially known to the compiler.</source>
          <target state="translated">Adem&amp;aacute;s, los punteros de funci&amp;oacute;n de &lt;em&gt;cualquier&lt;/em&gt; firma, ABI o seguridad son &lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; , y todos &lt;em&gt;los&lt;/em&gt; punteros de funci&amp;oacute;n &lt;em&gt;segura&lt;/em&gt; implementan &lt;a href=&quot;ops/trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;ops/trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;ops/trait.fnonce&quot;&gt; &lt;code&gt;FnOnce&lt;/code&gt; &lt;/a&gt; . Esto funciona porque el compilador conoce especialmente estos rasgos.</target>
        </trans-unit>
        <trans-unit id="136cc8b49dd7ef1ec81fe965f37fef063a4440bd" translate="yes" xml:space="preserve">
          <source>In addition, there&amp;rsquo;s a design choice that&amp;rsquo;s implied by this: Rust will never automatically create &amp;ldquo;deep&amp;rdquo; copies of your data. Therefore, any &lt;em&gt;automatic&lt;/em&gt; copying can be assumed to be inexpensive in terms of runtime performance.</source>
          <target state="translated">Adem&amp;aacute;s, hay una opci&amp;oacute;n de dise&amp;ntilde;o impl&amp;iacute;cita en esto: Rust nunca crear&amp;aacute; autom&amp;aacute;ticamente copias &quot;profundas&quot; de sus datos. Por lo tanto, se puede suponer que cualquier copia &lt;em&gt;autom&amp;aacute;tica&lt;/em&gt; es econ&amp;oacute;mica en t&amp;eacute;rminos de rendimiento en tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="3ea562ca4457a0f2edce71b5e5d5d3d508efc799" translate="yes" xml:space="preserve">
          <source>In addition, we&amp;rsquo;ll cover the &lt;em&gt;interior mutability&lt;/em&gt; pattern where an immutable type exposes an API for mutating an interior value. We&amp;rsquo;ll also discuss &lt;em&gt;reference cycles&lt;/em&gt;: how they can leak memory and how to prevent them.</source>
          <target state="translated">Adem&amp;aacute;s, cubriremos el patr&amp;oacute;n de &lt;em&gt;mutabilidad interior&lt;/em&gt; donde un tipo inmutable expone una API para mutar un valor interior. Tambi&amp;eacute;n discutiremos los &lt;em&gt;ciclos de referencia&lt;/em&gt; : c&amp;oacute;mo pueden perder memoria y c&amp;oacute;mo prevenirlos.</target>
        </trans-unit>
        <trans-unit id="665a1277188bff1c69c683d1be5f9fbcfa42875d" translate="yes" xml:space="preserve">
          <source>In all other cases (if either &lt;code&gt;setting_value&lt;/code&gt; or &lt;code&gt;new_setting_value&lt;/code&gt; are &lt;code&gt;None&lt;/code&gt;) expressed by the &lt;code&gt;_&lt;/code&gt; pattern in the second arm, we want to allow &lt;code&gt;new_setting_value&lt;/code&gt; to become &lt;code&gt;setting_value&lt;/code&gt;.</source>
          <target state="translated">En todos los dem&amp;aacute;s casos (si &lt;code&gt;setting_value&lt;/code&gt; o &lt;code&gt;new_setting_value&lt;/code&gt; son &lt;code&gt;None&lt;/code&gt; ) expresados ​​por el patr&amp;oacute;n &lt;code&gt;_&lt;/code&gt; en el segundo brazo, queremos permitir que &lt;code&gt;new_setting_value&lt;/code&gt; se convierta en &lt;code&gt;setting_value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50f872ce73ab8e1e8a7650611ee67d38d3b2ccb6" translate="yes" xml:space="preserve">
          <source>In all other cases the attributes get ignored.</source>
          <target state="translated">En todos los demás casos los atributos son ignorados.</target>
        </trans-unit>
        <trans-unit id="7d8a9a3640946afedd6187bd88567e66ef40d8ba" translate="yes" xml:space="preserve">
          <source>In all these errors, a type was expected. For example, in the first error, if we want to return the &lt;code&gt;Born&lt;/code&gt; variant from the &lt;code&gt;Dragon&lt;/code&gt; enum, we must set the function to return the enum and not its variant:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a19757cafa1e47c029cbe2ba1f57c4bdca558327" translate="yes" xml:space="preserve">
          <source>In all these errors, a type was expected. For example, in the first error, we tried to instantiate the &lt;code&gt;Mordor&lt;/code&gt; module, which is impossible. If you want to instantiate a type inside a module, you can do it as follow:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c47f29567923fe326970ee49948a1a1d55a18345" translate="yes" xml:space="preserve">
          <source>In an &lt;a href=&quot;keyword.extern&quot;&gt;&lt;code&gt;extern&lt;/code&gt;&lt;/a&gt; block:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f98ac0f1fa0dec56de41fe3ea37987b03944662" translate="yes" xml:space="preserve">
          <source>In an &lt;a href=&quot;keyword.impl&quot;&gt;&lt;code&gt;impl&lt;/code&gt;&lt;/a&gt; block:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35e764e206cbb7f7f22d345fb8c210bd54217a9f" translate="yes" xml:space="preserve">
          <source>In an intrusive doubly-linked list, the collection does not actually allocate the memory for the elements itself. Allocation is controlled by the clients, and elements can live on a stack frame that lives shorter than the collection does.</source>
          <target state="translated">En una lista intrusiva de doble enlace,la colección no asigna realmente la memoria para los elementos en sí.La asignación es controlada por los clientes,y los elementos pueden vivir en un marco de pila que vive menos tiempo que la colección.</target>
        </trans-unit>
        <trans-unit id="d614cd101c88d0fcc72d7ca1ff622264cb285eeb" translate="yes" xml:space="preserve">
          <source>In bigger programs, bringing many items into scope from the same crate or module using nested paths can reduce the number of separate &lt;code&gt;use&lt;/code&gt; statements needed by a lot!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e822bbbd5e19b7e72569624aa953246414cef9f" translate="yes" xml:space="preserve">
          <source>In bigger programs, bringing many items into scope from the same package or module using nested paths can reduce the number of separate &lt;code&gt;use&lt;/code&gt; statements needed by a lot!</source>
          <target state="translated">En programas m&amp;aacute;s grandes, traer muchos elementos al alcance del mismo paquete o m&amp;oacute;dulo usando rutas anidadas puede reducir mucho la cantidad de instrucciones de &lt;code&gt;use&lt;/code&gt; separadas necesarias.</target>
        </trans-unit>
        <trans-unit id="411e743273ff9b097675015034e11f98bb60f0a1" translate="yes" xml:space="preserve">
          <source>In both cases, we're declaring a variable (called &lt;code&gt;_&lt;/code&gt;) and we're giving it a type. However, &lt;code&gt;&amp;lt;u8 as Rick&amp;gt;::Morty&lt;/code&gt; and &lt;code&gt;&amp;lt;u8 as Age&amp;gt;::Mythology&lt;/code&gt; aren't types, therefore the compiler throws an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9090e4aabed5325b4009a735999c912f0f910934" translate="yes" xml:space="preserve">
          <source>In both of these examples, '&amp;szlig;' takes two bytes to encode.</source>
          <target state="translated">En ambos ejemplos, '&amp;szlig;' requiere dos bytes para codificarse.</target>
        </trans-unit>
        <trans-unit id="cecc69a558cba8a6dc73cb622945faf2e5653ab1" translate="yes" xml:space="preserve">
          <source>In both of these examples, '𝕊' takes two &lt;code&gt;u16&lt;/code&gt;s to encode.</source>
          <target state="translated">En ambos ejemplos, '𝕊' necesita dos &lt;code&gt;u16&lt;/code&gt; s para codificar.</target>
        </trans-unit>
        <trans-unit id="3bd0c40bcc38a21de271423b14aaff21406fde9d" translate="yes" xml:space="preserve">
          <source>In both the matcher and the transcriber, the &lt;code&gt;$&lt;/code&gt; token is used to invoke special behaviours from the macro engine (described below in &lt;a href=&quot;#metavariables&quot;&gt;Metavariables&lt;/a&gt; and &lt;a href=&quot;#repetitions&quot;&gt;Repetitions&lt;/a&gt;). Tokens that aren't part of such an invocation are matched and transcribed literally, with one exception. The exception is that the outer delimiters for the matcher will match any pair of delimiters. Thus, for instance, the matcher &lt;code&gt;(())&lt;/code&gt; will match &lt;code&gt;{()}&lt;/code&gt; but not &lt;code&gt;{{}}&lt;/code&gt;. The character &lt;code&gt;$&lt;/code&gt; cannot be matched or transcribed literally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b2b1898136ef5633d7de6bd1a25b5873a3b910c" translate="yes" xml:space="preserve">
          <source>In both the matcher and the transcriber, the &lt;code&gt;$&lt;/code&gt; token is used to invoke special behaviours from the macro engine (described below in &lt;a href=&quot;macros-by-example#metavariables&quot;&gt;Metavariables&lt;/a&gt; and &lt;a href=&quot;macros-by-example#repetitions&quot;&gt;Repetitions&lt;/a&gt;). Tokens that aren't part of such an invocation are matched and transcribed literally, with one exception. The exception is that the outer delimiters for the matcher will match any pair of delimiters. Thus, for instance, the matcher &lt;code&gt;(())&lt;/code&gt; will match &lt;code&gt;{()}&lt;/code&gt; but not &lt;code&gt;{{}}&lt;/code&gt;. The character &lt;code&gt;$&lt;/code&gt; cannot be matched or transcribed literally.</source>
          <target state="translated">Tanto en el comparador como en el transcriptor, el token &lt;code&gt;$&lt;/code&gt; se usa para invocar comportamientos especiales del motor de macros (que se describe a continuaci&amp;oacute;n en &lt;a href=&quot;macros-by-example#metavariables&quot;&gt;Metavariables&lt;/a&gt; y &lt;a href=&quot;macros-by-example#repetitions&quot;&gt;repeticiones&lt;/a&gt; ). Los tokens que no forman parte de dicha invocaci&amp;oacute;n se combinan y transcriben literalmente, con una excepci&amp;oacute;n. La excepci&amp;oacute;n es que los delimitadores externos del comparador coincidir&amp;aacute;n con cualquier par de delimitadores. As&amp;iacute;, por ejemplo, el comparador &lt;code&gt;(())&lt;/code&gt; coincidir&amp;aacute; con &lt;code&gt;{()}&lt;/code&gt; pero no con &lt;code&gt;{{}}&lt;/code&gt; . El car&amp;aacute;cter &lt;code&gt;$&lt;/code&gt; no se puede emparejar ni transcribir literalmente.</target>
        </trans-unit>
        <trans-unit id="6fa90f15a6602bac9e50b98bba1b4d2d430ba8af" translate="yes" xml:space="preserve">
          <source>In both the matcher and transcriber, repetitions are indicated by placing the tokens to be repeated inside &lt;code&gt;$(&lt;/code&gt;&amp;hellip;&lt;code&gt;)&lt;/code&gt;, followed by a repetition operator, optionally with a separator token between. The separator token can be any token other than a delimiter or one of the repetition operators, but &lt;code&gt;;&lt;/code&gt; and &lt;code&gt;,&lt;/code&gt; are the most common. For instance, &lt;code&gt;$( $i:ident ),*&lt;/code&gt; represents any number of identifiers separated by commas. Nested repetitions are permitted.</source>
          <target state="translated">Tanto en el comparador como en el transcriptor, las repeticiones se indican colocando las fichas que se repetir&amp;aacute;n dentro de &lt;code&gt;$(&lt;/code&gt; &amp;hellip; &lt;code&gt;)&lt;/code&gt; , seguido de un operador de repetici&amp;oacute;n, opcionalmente con un token de separaci&amp;oacute;n entre ellos. El s&amp;iacute;mbolo del separador puede ser cualquier s&amp;iacute;mbolo que no sea un delimitador o uno de los operadores de repetici&amp;oacute;n, pero &lt;code&gt;;&lt;/code&gt; y &lt;code&gt;,&lt;/code&gt; son los m&amp;aacute;s comunes. Por ejemplo, &lt;code&gt;$( $i:ident ),*&lt;/code&gt; representa cualquier n&amp;uacute;mero de identificadores separados por comas. Se permiten repeticiones anidadas.</target>
        </trans-unit>
        <trans-unit id="bda412bf4ac443ace6b933eedb9b5ef6ed17c2eb" translate="yes" xml:space="preserve">
          <source>In case &lt;code&gt;self&lt;/code&gt; is a (fat) pointer to an unsized type, this operation will only affect the pointer part, whereas for (thin) pointers to sized types, this has the same effect as a simple assignment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13a4f6c5542d522a1d64efb05e7cb21f75cdc110" translate="yes" xml:space="preserve">
          <source>In case of the &lt;code&gt;Err&lt;/code&gt; variant, it retrieves the inner error. &lt;code&gt;try!&lt;/code&gt; then performs conversion using &lt;code&gt;From&lt;/code&gt;. This provides automatic conversion between specialized errors and more general ones. The resulting error is then immediately returned.</source>
          <target state="translated">En el caso de la variante &lt;code&gt;Err&lt;/code&gt; , recupera el error interno. &lt;code&gt;try!&lt;/code&gt; luego realiza la conversi&amp;oacute;n usando &lt;code&gt;From&lt;/code&gt; . Esto proporciona conversi&amp;oacute;n autom&amp;aacute;tica entre errores especializados y errores m&amp;aacute;s generales. El error resultante se devuelve inmediatamente.</target>
        </trans-unit>
        <trans-unit id="941cab2e6d7a9cf7c0181840706fdb117ee2d348" translate="yes" xml:space="preserve">
          <source>In case the item is a function inside an &lt;code&gt;impl&lt;/code&gt;, defining a private helper function might be easier:</source>
          <target state="translated">En caso de que el elemento sea una funci&amp;oacute;n dentro de un &lt;code&gt;impl&lt;/code&gt; , definir una funci&amp;oacute;n auxiliar privada podr&amp;iacute;a ser m&amp;aacute;s f&amp;aacute;cil:</target>
        </trans-unit>
        <trans-unit id="e819f47e8194440086ecc95f22e7c6f58bfe9e72" translate="yes" xml:space="preserve">
          <source>In case you want to document the item following the doc comment, you might want to use outer doc comment:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b1af6acd0d5d83e834a292ebeca257005964bbd" translate="yes" xml:space="preserve">
          <source>In cases where there are many nested modules, re-exporting the types at the top level with &lt;code&gt;pub use&lt;/code&gt; can make a significant difference in the experience of people who use the crate.</source>
          <target state="translated">En los casos en los que hay muchos m&amp;oacute;dulos anidados, la reexportaci&amp;oacute;n de los tipos en el nivel superior con &lt;code&gt;pub use&lt;/code&gt; puede marcar una diferencia significativa en la experiencia de las personas que usan la caja.</target>
        </trans-unit>
        <trans-unit id="bf128a40829b30190a1501e6919bf7db04f1c0f1" translate="yes" xml:space="preserve">
          <source>In certain cases Rust doesn't have enough information to make this conversion, known as &lt;a href=&quot;../ops/trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; coercion. In the following example a string slice &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;'a str&lt;/code&gt;&lt;/a&gt; implements the trait &lt;code&gt;TraitExample&lt;/code&gt;, and the function &lt;code&gt;example_func&lt;/code&gt; takes anything that implements the trait. In this case Rust would need to make two implicit conversions, which Rust doesn't have the means to do. For that reason, the following example will not compile.</source>
          <target state="translated">En ciertos casos, Rust no tiene suficiente informaci&amp;oacute;n para realizar esta conversi&amp;oacute;n, conocida como coerci&amp;oacute;n de &lt;a href=&quot;../ops/trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt; . En el siguiente ejemplo, un segmento de cadena &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;'a str&lt;/code&gt; &lt;/a&gt; implementa el rasgo &lt;code&gt;TraitExample&lt;/code&gt; , y la funci&amp;oacute;n &lt;code&gt;example_func&lt;/code&gt; toma cualquier cosa que implemente el rasgo. En este caso, Rust necesitar&amp;iacute;a realizar dos conversiones impl&amp;iacute;citas, lo que Rust no tiene los medios para hacer. Por esa raz&amp;oacute;n, el siguiente ejemplo no se compilar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="05789113cec31f9ba27c211f5de8eaee1029d96b" translate="yes" xml:space="preserve">
          <source>In certain cases it is possible for sub-bindings to violate memory safety. Updates to the borrow checker in a future version of Rust may remove this restriction, but for now patterns must be rewritten without sub-bindings.</source>
          <target state="translated">En ciertos casos es posible que los subenclaves violen la seguridad de la memoria.Las actualizaciones del verificador de préstamos en una futura versión de Rust pueden eliminar esta restricción,pero por ahora los patrones deben ser reescritos sin subencuadernaciones.</target>
        </trans-unit>
        <trans-unit id="d394f1aae10ef8b092ba2c671f6d9b214faf89ad" translate="yes" xml:space="preserve">
          <source>In comparison, a &lt;a href=&quot;struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt; does not distinguish between readers or writers that acquire the lock, therefore blocking any threads waiting for the lock to become available. An &lt;code&gt;RwLock&lt;/code&gt; will allow any number of readers to acquire the lock as long as a writer is not holding the lock.</source>
          <target state="translated">En comparaci&amp;oacute;n, un &lt;a href=&quot;struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; &lt;/a&gt; no distingue entre lectores o escritores que adquieren el bloqueo, por lo que bloquea los hilos que esperan que el bloqueo est&amp;eacute; disponible. Un &lt;code&gt;RwLock&lt;/code&gt; permitir&amp;aacute; que cualquier n&amp;uacute;mero de lectores adquiera el bloqueo siempre y cuando un escritor no lo mantenga presionado.</target>
        </trans-unit>
        <trans-unit id="c115328cd5dddf39c58dad4ab7eb1715dbdfb6a2" translate="yes" xml:space="preserve">
          <source>In conclusion: always check if the index you want to get really exists before doing it.</source>
          <target state="translated">En conclusión:siempre comprueba si el índice que quieres obtener existe realmente antes de hacerlo.</target>
        </trans-unit>
        <trans-unit id="bc5067b36d2a80d931bdadd8da0d1762cb0d699b" translate="yes" xml:space="preserve">
          <source>In contrast, if we make an enum public, all of its variants are then public. We only need the &lt;code&gt;pub&lt;/code&gt; before the &lt;code&gt;enum&lt;/code&gt; keyword, as shown in Listing 7-10.</source>
          <target state="translated">Por el contrario, si hacemos p&amp;uacute;blica una enumeraci&amp;oacute;n, todas sus variantes son p&amp;uacute;blicas. Solo necesitamos el &lt;code&gt;pub&lt;/code&gt; antes del &lt;code&gt;enum&lt;/code&gt; palabra clave enum , como se muestra en el Listado 7-10.</target>
        </trans-unit>
        <trans-unit id="eef3a39c643559e323c1398fc6cc1dee8d7cdd7b" translate="yes" xml:space="preserve">
          <source>In contrast, statements in Rust serve &lt;em&gt;mostly&lt;/em&gt; to contain and explicitly sequence expression evaluation.</source>
          <target state="translated">Por el contrario, las declaraciones en Rust sirven &lt;em&gt; principalmente&lt;/em&gt; para contener y secuenciar expl&amp;iacute;citamente la evaluaci&amp;oacute;n de expresiones.</target>
        </trans-unit>
        <trans-unit id="ff04b6c4317002c1756854a2d669fb7993a6fc92" translate="yes" xml:space="preserve">
          <source>In contrast, the use of &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; in Listing 19-7 would likely crash when the slice is used. This code takes an arbitrary memory location and creates a slice 10,000 items long.</source>
          <target state="translated">Por el contrario, el uso de &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; en el Listado 19-7 probablemente fallar&amp;iacute;a cuando se usara la porci&amp;oacute;n. Este c&amp;oacute;digo toma una ubicaci&amp;oacute;n de memoria arbitraria y crea un segmento de 10,000 elementos de largo.</target>
        </trans-unit>
        <trans-unit id="b352fcdc1230066708e3119b26e7a9dddf361692" translate="yes" xml:space="preserve">
          <source>In each such case, there are a set of types &lt;code&gt;T0..Tn&lt;/code&gt; to be mutually coerced to some target type &lt;code&gt;T_t&lt;/code&gt;, which is unknown to start. Computing the LUB coercion is done iteratively. The target type &lt;code&gt;T_t&lt;/code&gt; begins as the type &lt;code&gt;T0&lt;/code&gt;. For each new type &lt;code&gt;Ti&lt;/code&gt;, we consider whether</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="759bae86a2327a6965c49083e94e3f6d305cc988" translate="yes" xml:space="preserve">
          <source>In either of the two scenarios above, we reject usage of such a constant in a pattern match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06e667f68e56d5242973de51944bcdddd7e82fb4" translate="yes" xml:space="preserve">
          <source>In essence, &lt;code&gt;*const c_void&lt;/code&gt; is equivalent to C's &lt;code&gt;const void*&lt;/code&gt; and &lt;code&gt;*mut c_void&lt;/code&gt; is equivalent to C's &lt;code&gt;void*&lt;/code&gt;. That said, this is &lt;em&gt;not&lt;/em&gt; the same as C's &lt;code&gt;void&lt;/code&gt; return type, which is Rust's &lt;code&gt;()&lt;/code&gt; type.</source>
          <target state="translated">En esencia, &lt;code&gt;*const c_void&lt;/code&gt; es equivalente al &lt;code&gt;const void*&lt;/code&gt; de C y &lt;code&gt;*mut c_void&lt;/code&gt; es equivalente al &lt;code&gt;void*&lt;/code&gt; de C * . Dicho esto, &lt;em&gt;no&lt;/em&gt; es &lt;em&gt;lo&lt;/em&gt; mismo que el tipo de retorno &lt;code&gt;void&lt;/code&gt; de C , que es el tipo de Rust &lt;code&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0739de72e1deacfa1d546c048ef9f93475a4ab03" translate="yes" xml:space="preserve">
          <source>In function signatures, you &lt;em&gt;must&lt;/em&gt; declare the type of each parameter. This is a deliberate decision in Rust&amp;rsquo;s design: requiring type annotations in function definitions means the compiler almost never needs you to use them elsewhere in the code to figure out what you mean.</source>
          <target state="translated">En firmas de funciones, &lt;em&gt; debe&lt;/em&gt; declarar el tipo de cada par&amp;aacute;metro. Esta es una decisi&amp;oacute;n deliberada en el dise&amp;ntilde;o de Rust: requerir anotaciones de tipo en las definiciones de funciones significa que el compilador casi nunca necesita que las use en otra parte del c&amp;oacute;digo para averiguar lo que quiere decir.</target>
        </trans-unit>
        <trans-unit id="a163a5fc2f2f3cf5125dad843b5d152fd8d96ed5" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;--crate-type=bin&lt;/code&gt; or &lt;code&gt;--crate-type=lib&lt;/code&gt; should be sufficient for all compilation needs, and the other options are just available if more fine-grained control is desired over the output format of a crate.</source>
          <target state="translated">En general, &lt;code&gt;--crate-type=bin&lt;/code&gt; o &lt;code&gt;--crate-type=lib&lt;/code&gt; deber&amp;iacute;a ser suficiente para todas las necesidades de compilaci&amp;oacute;n, y las otras opciones solo est&amp;aacute;n disponibles si se desea un control m&amp;aacute;s detallado sobre el formato de salida de una caja.</target>
        </trans-unit>
        <trans-unit id="7777bf666faebd9aefa18991fe8e03e45c4f9bd4" translate="yes" xml:space="preserve">
          <source>In general, C++ implementations obey the zero-overhead principle: What you don&amp;rsquo;t use, you don&amp;rsquo;t pay for. And further: What you do use, you couldn&amp;rsquo;t hand code any better.</source>
          <target state="translated">En general, las implementaciones de C ++ obedecen al principio de cero gastos generales: lo que no usa, no paga. Y m&amp;aacute;s: lo que usas, no podr&amp;iacute;as codificar mejor.</target>
        </trans-unit>
        <trans-unit id="3a3df1206a7a0ce3ee2a987af627c57e92761a96" translate="yes" xml:space="preserve">
          <source>In general, any cast that can be performed via ascribing the type can also be done using &lt;code&gt;as&lt;/code&gt;, so instead of writing &lt;code&gt;let x: u32 = 123&lt;/code&gt;, you can write &lt;code&gt;let x = 123 as u32&lt;/code&gt; (Note: &lt;code&gt;let x: u32 = 123&lt;/code&gt; would be best in that situation). The same is not true in the other direction, however, explicitly using &lt;code&gt;as&lt;/code&gt; allows a few more coercions that aren't allowed implicitly, such as changing the type of a raw pointer or turning closures into raw pointers.</source>
          <target state="translated">En general, cualquier lanzamiento que se pueda realizar mediante la atribuci&amp;oacute;n del tipo tambi&amp;eacute;n se puede hacer usando &lt;code&gt;as&lt;/code&gt; , por lo que en lugar de escribir &lt;code&gt;let x: u32 = 123&lt;/code&gt; , puede escribir &lt;code&gt;let x = 123 as u32&lt;/code&gt; (Nota: &lt;code&gt;let x: u32 = 123&lt;/code&gt; ser&amp;iacute;a ser el mejor en esa situaci&amp;oacute;n). Lo mismo no es cierto en la otra direcci&amp;oacute;n, sin embargo, usando expl&amp;iacute;citamente &lt;code&gt;as&lt;/code&gt; permite algunas coacciones m&amp;aacute;s que no se permiten impl&amp;iacute;citamente, como cambiar el tipo de un puntero sin formato o convertir cierres en punteros sin formato.</target>
        </trans-unit>
        <trans-unit id="3ee5af53911e508508beef41bbd5529b831af173" translate="yes" xml:space="preserve">
          <source>In general, any cast that can be performed via ascribing the type can also be done using &lt;code&gt;as&lt;/code&gt;, so instead of writing &lt;code&gt;let x: u32 = 123&lt;/code&gt;, you can write &lt;code&gt;let x = 123 as u32&lt;/code&gt; (note: &lt;code&gt;let x: u32 = 123&lt;/code&gt; would be best in that situation). The same is not true in the other direction, however; explicitly using &lt;code&gt;as&lt;/code&gt; allows a few more coercions that aren't allowed implicitly, such as changing the type of a raw pointer or turning closures into raw pointers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5001dd632e7b54d8c780b39311ea5efcf079833" translate="yes" xml:space="preserve">
          <source>In general, because this function may panic, its use is discouraged. Instead, prefer to use pattern matching and handle the &lt;a href=&quot;#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; case explicitly.</source>
          <target state="translated">En general, debido a que esta funci&amp;oacute;n puede entrar en p&amp;aacute;nico, se desaconseja su uso. En su lugar, prefiera utilizar la coincidencia de patrones y manejar &lt;a href=&quot;#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; caso expl&amp;iacute;citamente.</target>
        </trans-unit>
        <trans-unit id="0358df2536c58bf0115d699da84271da00e22fdc" translate="yes" xml:space="preserve">
          <source>In general, fully qualified syntax is defined as follows:</source>
          <target state="translated">En general,la sintaxis plenamente cualificada se define de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="7487c2808663723e7c1f944b2e8eea78a2788483" translate="yes" xml:space="preserve">
          <source>In general, in order to use an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; value, you want to have code that will handle each variant. You want some code that will run only when you have a &lt;code&gt;Some(T)&lt;/code&gt; value, and this code is allowed to use the inner &lt;code&gt;T&lt;/code&gt;. You want some other code to run if you have a &lt;code&gt;None&lt;/code&gt; value, and that code doesn&amp;rsquo;t have a &lt;code&gt;T&lt;/code&gt; value available. The &lt;code&gt;match&lt;/code&gt; expression is a control flow construct that does just this when used with enums: it will run different code depending on which variant of the enum it has, and that code can use the data inside the matching value.</source>
          <target state="translated">En general, para usar un valor &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; , desea tener un c&amp;oacute;digo que maneje cada variante. Desea alg&amp;uacute;n c&amp;oacute;digo que se ejecute solo cuando tenga un valor &lt;code&gt;Some(T)&lt;/code&gt; , y este c&amp;oacute;digo puede usar la &lt;code&gt;T&lt;/code&gt; interna . Desea que se ejecute alg&amp;uacute;n otro c&amp;oacute;digo si tiene un valor &lt;code&gt;None&lt;/code&gt; y ese c&amp;oacute;digo no tiene un valor &lt;code&gt;T&lt;/code&gt; disponible. El &lt;code&gt;match&lt;/code&gt; expresi&amp;oacute;n de es una construcci&amp;oacute;n de flujo de control que hace exactamente esto cuando se usa con enumeraciones: ejecutar&amp;aacute; c&amp;oacute;digo diferente seg&amp;uacute;n la variante de la enumeraci&amp;oacute;n que tenga, y ese c&amp;oacute;digo puede usar los datos dentro del valor coincidente.</target>
        </trans-unit>
        <trans-unit id="fe5910a656bafc28cb04b104db1abacc502046d7" translate="yes" xml:space="preserve">
          <source>In general, the size of a type is not stable across compilations, but specific types such as primitives are.</source>
          <target state="translated">En general,el tamaño de un tipo no es estable en todas las compilaciones,pero los tipos específicos como los primitivos sí lo son.</target>
        </trans-unit>
        <trans-unit id="9278a820cf286fae1a78be16430b1781c0f65837" translate="yes" xml:space="preserve">
          <source>In general, this book assumes that you&amp;rsquo;re reading it in sequence from front to back. Later chapters build on concepts in earlier chapters, and earlier chapters might not delve into details on a topic; we typically revisit the topic in a later chapter.</source>
          <target state="translated">En general, este libro asume que lo est&amp;aacute; leyendo en secuencia de adelante hacia atr&amp;aacute;s. Los cap&amp;iacute;tulos posteriores se basan en conceptos de cap&amp;iacute;tulos anteriores, y es posible que los cap&amp;iacute;tulos anteriores no profundicen en los detalles de un tema; normalmente revisamos el tema en un cap&amp;iacute;tulo posterior.</target>
        </trans-unit>
        <trans-unit id="977ea6d6c942b4c170b22ed11bf03379c02b9dfe" translate="yes" xml:space="preserve">
          <source>In general, you shouldn&amp;rsquo;t have to worry about the distinction between refutable and irrefutable patterns; however, you do need to be familiar with the concept of refutability so you can respond when you see it in an error message. In those cases, you&amp;rsquo;ll need to change either the pattern or the construct you&amp;rsquo;re using the pattern with, depending on the intended behavior of the code.</source>
          <target state="translated">En general, no deber&amp;iacute;a tener que preocuparse por la distinci&amp;oacute;n entre patrones refutables e irrefutables; sin embargo, debe estar familiarizado con el concepto de refutabilidad para poder responder cuando lo vea en un mensaje de error. En esos casos, deber&amp;aacute; cambiar el patr&amp;oacute;n o la construcci&amp;oacute;n con la que est&amp;aacute; utilizando el patr&amp;oacute;n, seg&amp;uacute;n el comportamiento previsto del c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="060df941ecb41c6d059208976354e6aeaa04999f" translate="yes" xml:space="preserve">
          <source>In here, &lt;code&gt;jon_snow&lt;/code&gt; is already borrowed by the &lt;code&gt;nights_watch&lt;/code&gt; reference, so it cannot be borrowed by the &lt;code&gt;starks&lt;/code&gt; closure at the same time. To fix this issue, you can create the closure after the borrow has ended:</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;jon_snow&lt;/code&gt; ya est&amp;aacute; prestado por la referencia &lt;code&gt;nights_watch&lt;/code&gt; , por lo que no puede ser prestado por el cierre de &lt;code&gt;starks&lt;/code&gt; al mismo tiempo. Para solucionar este problema, puede crear el cierre una vez finalizado el pr&amp;eacute;stamo:</target>
        </trans-unit>
        <trans-unit id="2eeaad023e9112af1e8f815d9f7d440dc203c89a" translate="yes" xml:space="preserve">
          <source>In here, &lt;code&gt;x&lt;/code&gt; isn't mutable, so when we try to mutably borrow it in &lt;code&gt;y&lt;/code&gt;, it fails. To fix this error, you need to make &lt;code&gt;x&lt;/code&gt; mutable:</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;x&lt;/code&gt; no es mutable, por lo que cuando intentamos tomarlo prestado de manera mutante en &lt;code&gt;y&lt;/code&gt; , falla. Para corregir este error, necesita hacer &lt;code&gt;x&lt;/code&gt; mutable:</target>
        </trans-unit>
        <trans-unit id="81d6b3668007d5f159cb30ea0bd675623ee7c869" translate="yes" xml:space="preserve">
          <source>In here, &lt;code&gt;y&lt;/code&gt; is dropped at the end of the inner scope, but it is borrowed by &lt;code&gt;x&lt;/code&gt; until the &lt;code&gt;println&lt;/code&gt;. To fix the previous example, just remove the scope so that &lt;code&gt;y&lt;/code&gt; isn't dropped until after the println</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;y&lt;/code&gt; se coloca al final del &amp;aacute;mbito interno, pero &lt;code&gt;x&lt;/code&gt; lo toma prestado hasta que &lt;code&gt;println&lt;/code&gt; . Para corregir el ejemplo anterior, simplemente elimine el alcance para que &lt;code&gt;y&lt;/code&gt; no se elimine hasta despu&amp;eacute;s de println</target>
        </trans-unit>
        <trans-unit id="08dfb3c33a779adcd494f821429d48fd85e32c31" translate="yes" xml:space="preserve">
          <source>In his 1972 essay &amp;ldquo;The Humble Programmer,&amp;rdquo; Edsger W. Dijkstra said that &amp;ldquo;Program testing can be a very effective way to show the presence of bugs, but it is hopelessly inadequate for showing their absence.&amp;rdquo; That doesn&amp;rsquo;t mean we shouldn&amp;rsquo;t try to test as much as we can!</source>
          <target state="translated">En su ensayo de 1972 &quot;The Humble Programmer&quot;, Edsger W. Dijkstra dijo que &quot;las pruebas de programas pueden ser una forma muy eficaz de mostrar la presencia de errores, pero es desesperadamente inadecuada para mostrar su ausencia&quot;. &amp;iexcl;Eso no significa que no debamos intentar probar tanto como podamos!</target>
        </trans-unit>
        <trans-unit id="ae6d2c496cd6d4afe298d6ce8f4a6cee4e357ed4" translate="yes" xml:space="preserve">
          <source>In his 2009 presentation &amp;ldquo;Null References: The Billion Dollar Mistake,&amp;rdquo; Tony Hoare, the inventor of null, has this to say:</source>
          <target state="translated">En su presentaci&amp;oacute;n de 2009 &quot;Null References: The Billion Dollar Mistake&quot;, Tony Hoare, el inventor de null, dice lo siguiente:</target>
        </trans-unit>
        <trans-unit id="c66d30f8ac627ea5119575fc56779340f4bd49e0" translate="yes" xml:space="preserve">
          <source>In immutable contexts, &lt;code&gt;*x&lt;/code&gt; (where &lt;code&gt;T&lt;/code&gt; is neither a reference nor a raw pointer) is equivalent to &lt;code&gt;*Deref::deref(&amp;amp;x)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45d9087614e2245b4983911ff32ea54b22230bdc" translate="yes" xml:space="preserve">
          <source>In immutable contexts, &lt;code&gt;*x&lt;/code&gt; on non-pointer types is equivalent to &lt;code&gt;*Deref::deref(&amp;amp;x)&lt;/code&gt;.</source>
          <target state="translated">En contextos inmutables, &lt;code&gt;*x&lt;/code&gt; en tipos que no son punteros es equivalente a &lt;code&gt;*Deref::deref(&amp;amp;x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34a59a9afbc47f966db9cd49be041253f3860e79" translate="yes" xml:space="preserve">
          <source>In its thread, the &lt;code&gt;Worker&lt;/code&gt; will loop over its receiving side of the channel and execute the closures of any jobs it receives.</source>
          <target state="translated">En su hilo, el &lt;code&gt;Worker&lt;/code&gt; recorrer&amp;aacute; su lado receptor del canal y ejecutar&amp;aacute; los cierres de cualquier trabajo que reciba.</target>
        </trans-unit>
        <trans-unit id="942b73624a3734e7f84234cddf5d7ae090876792" translate="yes" xml:space="preserve">
          <source>In languages that don&amp;rsquo;t have iterators provided by their standard libraries, you would likely write this same functionality by starting a variable at index 0, using that variable to index into the vector to get a value, and incrementing the variable value in a loop until it reached the total number of items in the vector.</source>
          <target state="translated">En los lenguajes que no tienen iteradores proporcionados por sus bibliotecas est&amp;aacute;ndar, probablemente escribir&amp;iacute;a esta misma funcionalidad comenzando una variable en el &amp;iacute;ndice 0, usando esa variable para indexar en el vector para obtener un valor e incrementando el valor de la variable en un ciclo hasta alcanzar el n&amp;uacute;mero total de elementos del vector.</target>
        </trans-unit>
        <trans-unit id="148bb2115d5f741226fa757de3c9723acba277f4" translate="yes" xml:space="preserve">
          <source>In languages with pointers, it&amp;rsquo;s easy to erroneously create a &lt;em&gt;dangling pointer&lt;/em&gt;, a pointer that references a location in memory that may have been given to someone else, by freeing some memory while preserving a pointer to that memory. In Rust, by contrast, the compiler guarantees that references will never be dangling references: if you have a reference to some data, the compiler will ensure that the data will not go out of scope before the reference to the data does.</source>
          <target state="translated">En lenguajes con punteros, es f&amp;aacute;cil crear err&amp;oacute;neamente un &lt;em&gt;puntero colgante&lt;/em&gt; , un puntero que hace referencia a una ubicaci&amp;oacute;n en la memoria que se le puede haber dado a otra persona, liberando algo de memoria mientras se conserva un puntero a esa memoria. En Rust, por el contrario, el compilador garantiza que las referencias nunca ser&amp;aacute;n referencias colgantes: si tiene una referencia a algunos datos, el compilador se asegurar&amp;aacute; de que los datos no se salgan del alcance antes de que lo haga la referencia a los datos.</target>
        </trans-unit>
        <trans-unit id="c69f662a72816b0c83c46e48583efed26b50f091" translate="yes" xml:space="preserve">
          <source>In many other programming languages, accessing individual characters in a string by referencing them by index is a valid and common operation. However, if you try to access parts of a &lt;code&gt;String&lt;/code&gt; using indexing syntax in Rust, you&amp;rsquo;ll get an error. Consider the invalid code in Listing 8-19.</source>
          <target state="translated">En muchos otros lenguajes de programaci&amp;oacute;n, acceder a caracteres individuales en una cadena haciendo referencia a ellos por &amp;iacute;ndice es una operaci&amp;oacute;n v&amp;aacute;lida y com&amp;uacute;n. Sin embargo, si intenta acceder a partes de una &lt;code&gt;String&lt;/code&gt; utilizando la sintaxis de indexaci&amp;oacute;n en Rust, obtendr&amp;aacute; un error. Considere el c&amp;oacute;digo no v&amp;aacute;lido del Listado 8-19.</target>
        </trans-unit>
        <trans-unit id="53fc7ae898feca654262cacac0837b1725d55798" translate="yes" xml:space="preserve">
          <source>In many programming languages, you don&amp;rsquo;t have to think about the stack and the heap very often. But in a systems programming language like Rust, whether a value is on the stack or the heap has more of an effect on how the language behaves and why you have to make certain decisions. Parts of ownership will be described in relation to the stack and the heap later in this chapter, so here is a brief explanation in preparation.</source>
          <target state="translated">En muchos lenguajes de programaci&amp;oacute;n, no es necesario pensar en la pila y el mont&amp;oacute;n con mucha frecuencia. Pero en un lenguaje de programaci&amp;oacute;n de sistemas como Rust, el hecho de que un valor est&amp;eacute; en la pila o en el mont&amp;oacute;n tiene m&amp;aacute;s efecto sobre c&amp;oacute;mo se comporta el lenguaje y por qu&amp;eacute; tiene que tomar ciertas decisiones. Las partes de la propiedad se describir&amp;aacute;n en relaci&amp;oacute;n con la pila y el mont&amp;oacute;n m&amp;aacute;s adelante en este cap&amp;iacute;tulo, por lo que aqu&amp;iacute; hay una breve explicaci&amp;oacute;n en preparaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a71b0804f74afde789f1f323a88f714aecff2fd9" translate="yes" xml:space="preserve">
          <source>In method signatures inside the &lt;code&gt;impl&lt;/code&gt; block, references might be tied to the lifetime of references in the struct&amp;rsquo;s fields, or they might be independent. In addition, the lifetime elision rules often make it so that lifetime annotations aren&amp;rsquo;t necessary in method signatures. Let&amp;rsquo;s look at some examples using the struct named &lt;code&gt;ImportantExcerpt&lt;/code&gt; that we defined in Listing 10-25.</source>
          <target state="translated">En las firmas de m&amp;eacute;todos dentro del bloque &lt;code&gt;impl&lt;/code&gt; , las referencias pueden estar vinculadas a la vida &amp;uacute;til de las referencias en los campos de la estructura, o pueden ser independientes. Adem&amp;aacute;s, las reglas de elisi&amp;oacute;n de por vida a menudo hacen que las anotaciones de por vida no sean necesarias en las firmas de m&amp;eacute;todos. Veamos algunos ejemplos usando la estructura llamada &lt;code&gt;ImportantExcerpt&lt;/code&gt; que definimos en el Listado 10-25.</target>
        </trans-unit>
        <trans-unit id="56b091fc8b5e112138b2d81b03cef11eb14a4977" translate="yes" xml:space="preserve">
          <source>In method signatures there is another rule</source>
          <target state="translated">En las firmas de métodos hay otra regla</target>
        </trans-unit>
        <trans-unit id="4f7f26526673f7e0758f04fd37bb64448ac73dee" translate="yes" xml:space="preserve">
          <source>In more realistic code, Rust can often infer the type of value you want to store once you insert values, so you rarely need to do this type annotation. It&amp;rsquo;s more common to create a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; that has initial values, and Rust provides the &lt;code&gt;vec!&lt;/code&gt; macro for convenience. The macro will create a new vector that holds the values you give it. Listing 8-2 creates a new &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; that holds the values &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, and &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">En un c&amp;oacute;digo m&amp;aacute;s realista, Rust a menudo puede inferir el tipo de valor que desea almacenar una vez que inserta los valores, por lo que rara vez necesita hacer este tipo de anotaci&amp;oacute;n. Es m&amp;aacute;s com&amp;uacute;n crear un &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; que tenga valores iniciales, &amp;iexcl;y Rust proporciona el &lt;code&gt;vec!&lt;/code&gt; macro por conveniencia. La macro crear&amp;aacute; un nuevo vector que contiene los valores que le des. El Listado 8-2 crea un nuevo &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; que contiene los valores &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; y &lt;code&gt;3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa2c751f0fffe581147bea700ab4a27b2b536a1b" translate="yes" xml:space="preserve">
          <source>In more realistic code, Rust can often infer the type of value you want to store once you insert values, so you rarely need to do this type annotation. It&amp;rsquo;s more common to create a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; that has initial values, and Rust provides the &lt;code&gt;vec!&lt;/code&gt; macro for convenience. The macro will create a new vector that holds the values you give it. Listing 8-2 creates a new &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; that holds the values &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, and &lt;code&gt;3&lt;/code&gt;. The integer type is &lt;code&gt;i32&lt;/code&gt; because that&amp;rsquo;s the default integer type, as we discussed in the &lt;a href=&quot;ch03-02-data-types#data-types&quot;&gt;&amp;ldquo;Data Types&amp;rdquo;&lt;/a&gt; section of Chapter 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f61ae2da01f7f174aa9072fda333fb0da9180ccf" translate="yes" xml:space="preserve">
          <source>In most cases (if not all), using just one representation hint is more than enough. If you want to have a representation hint depending on the current architecture, use &lt;code&gt;cfg_attr&lt;/code&gt;. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf5efe0547b39e89a71b61a6014e248867460fb1" translate="yes" xml:space="preserve">
          <source>In most cases when you no longer need a particular function parameter, you would change the signature so it doesn&amp;rsquo;t include the unused parameter. Ignoring a function parameter can be especially useful in some cases, for example, when implementing a trait when you need a certain type signature but the function body in your implementation doesn&amp;rsquo;t need one of the parameters. The compiler will then not warn about unused function parameters, as it would if you used a name instead.</source>
          <target state="translated">En la mayor&amp;iacute;a de los casos, cuando ya no necesita un par&amp;aacute;metro de funci&amp;oacute;n en particular, debe cambiar la firma para que no incluya el par&amp;aacute;metro no utilizado. Ignorar un par&amp;aacute;metro de funci&amp;oacute;n puede ser especialmente &amp;uacute;til en algunos casos, por ejemplo, cuando se implementa un rasgo cuando se necesita una determinada firma de tipo, pero el cuerpo de la funci&amp;oacute;n en su implementaci&amp;oacute;n no necesita uno de los par&amp;aacute;metros. El compilador no advertir&amp;aacute; sobre los par&amp;aacute;metros de funci&amp;oacute;n no utilizados, como lo har&amp;iacute;a si utilizara un nombre en su lugar.</target>
        </trans-unit>
        <trans-unit id="85959f6561074f86f5f458df7e8bde59a19923db" translate="yes" xml:space="preserve">
          <source>In most cases, it's either a forgotten import or a typo. However, let's look at how you can have such a type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26e080b759ded4bafe71b2a50d6f7fff275a8902" translate="yes" xml:space="preserve">
          <source>In most cases, references can be used much like the original value. Field access, method calling, and indexing work the same (save for mutability rules, of course). In addition, the comparison operators transparently defer to the referent's implementation, allowing references to be compared the same as owned values.</source>
          <target state="translated">En la mayoría de los casos,las referencias pueden utilizarse de manera muy similar al valor original.El acceso a los campos,la llamada a métodos y la indexación funcionan de la misma manera (salvo por las reglas de mutabilidad,por supuesto).Además,los operadores de comparación se someten con transparencia a la aplicación del referente,lo que permite que las referencias se comparen de la misma manera que los valores de propiedad.</target>
        </trans-unit>
        <trans-unit id="cb1a853128acc3d6c0a0581a5f8b082bf00d635a" translate="yes" xml:space="preserve">
          <source>In most current operating systems, an executed program&amp;rsquo;s code is run in a &lt;em&gt;process&lt;/em&gt;, and the operating system manages multiple processes at once. Within your program, you can also have independent parts that run simultaneously. The features that run these independent parts are called &lt;em&gt;threads&lt;/em&gt;.</source>
          <target state="translated">En la mayor&amp;iacute;a de los sistemas operativos actuales, el c&amp;oacute;digo de un programa ejecutado se ejecuta en un &lt;em&gt;proceso&lt;/em&gt; y el sistema operativo administra varios procesos a la vez. Dentro de su programa, tambi&amp;eacute;n puede tener partes independientes que se ejecutan simult&amp;aacute;neamente. Las funciones que ejecutan estas partes independientes se denominan &lt;em&gt;subprocesos&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="78e7514eee61487e2e785a94b5ca9176768d676e" translate="yes" xml:space="preserve">
          <source>In most situations, we&amp;rsquo;ll lead you to the correct version of any code that doesn&amp;rsquo;t compile.</source>
          <target state="translated">En la mayor&amp;iacute;a de las situaciones, lo llevaremos a la versi&amp;oacute;n correcta de cualquier c&amp;oacute;digo que no se compile.</target>
        </trans-unit>
        <trans-unit id="c68d3ee8b930a30d24c024ab8aa0750ac37303d5" translate="yes" xml:space="preserve">
          <source>In mutable contexts, &lt;code&gt;*x&lt;/code&gt; (where &lt;code&gt;T&lt;/code&gt; is neither a reference nor a raw pointer) is equivalent to &lt;code&gt;*DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b734ae92655f6d1fea340617e159a961db4d096" translate="yes" xml:space="preserve">
          <source>In mutable contexts, &lt;code&gt;*x&lt;/code&gt; on non-pointer types is equivalent to &lt;code&gt;*DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt;.</source>
          <target state="translated">En contextos mutables, &lt;code&gt;*x&lt;/code&gt; en tipos que no son punteros es equivalente a &lt;code&gt;*DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69b6246a1999e07c08f9e609157264f54e6ef863" translate="yes" xml:space="preserve">
          <source>In one session of compilation, the compiler can generate multiple artifacts through the usage of either command line flags or the &lt;code&gt;crate_type&lt;/code&gt; attribute. If one or more command line flags are specified, all &lt;code&gt;crate_type&lt;/code&gt; attributes will be ignored in favor of only building the artifacts specified by command line.</source>
          <target state="translated">En una sesi&amp;oacute;n de compilaci&amp;oacute;n, el compilador puede generar m&amp;uacute;ltiples artefactos mediante el uso de indicadores de l&amp;iacute;nea de comando o el atributo &lt;code&gt;crate_type&lt;/code&gt; . Si se especifican uno o m&amp;aacute;s indicadores de l&amp;iacute;nea de comando, todos los atributos &lt;code&gt;crate_type&lt;/code&gt; se ignorar&amp;aacute;n a favor de construir solo los artefactos especificados por la l&amp;iacute;nea de comando.</target>
        </trans-unit>
        <trans-unit id="39ef695f2f217a58a60f492df45908959e1ce256" translate="yes" xml:space="preserve">
          <source>In one way, this program is better. Tuples let us add a bit of structure, and we&amp;rsquo;re now passing just one argument. But in another way, this version is less clear: tuples don&amp;rsquo;t name their elements, so our calculation has become more confusing because we have to index into the parts of the tuple.</source>
          <target state="translated">De alguna manera, este programa es mejor. Las tuplas nos permiten agregar un poco de estructura, y ahora solo estamos pasando un argumento. Pero de otra manera, esta versi&amp;oacute;n es menos clara: las tuplas no nombran sus elementos, por lo que nuestro c&amp;aacute;lculo se ha vuelto m&amp;aacute;s confuso porque tenemos que indexar en las partes de la tupla.</target>
        </trans-unit>
        <trans-unit id="622cc33b53324bf6d0c97dce1d56dd6b2940830c" translate="yes" xml:space="preserve">
          <source>In order for a type to implement this trait, it must not only provide implementations for every method, but it must specify the type &lt;code&gt;E&lt;/code&gt;. Here's an implementation of &lt;code&gt;Container&lt;/code&gt; for the standard library type &lt;code&gt;Vec&lt;/code&gt;:</source>
          <target state="translated">Para que un tipo de implementar esta caracter&amp;iacute;stica, no s&amp;oacute;lo debe proporcionar implementaciones para cada m&amp;eacute;todo, pero debe especificar el tipo &lt;code&gt;E&lt;/code&gt; . Aqu&amp;iacute; hay una implementaci&amp;oacute;n de &lt;code&gt;Container&lt;/code&gt; para el tipo de biblioteca est&amp;aacute;ndar &lt;code&gt;Vec&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="19c7f913e08cfe33ae3164f0e143039e6e29b1bd" translate="yes" xml:space="preserve">
          <source>In order for the file to be created, &lt;a href=&quot;#method.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#method.append&quot;&gt;&lt;code&gt;append&lt;/code&gt;&lt;/a&gt; access must be used.</source>
          <target state="translated">Para que se cree el archivo, se debe utilizar el acceso de &lt;a href=&quot;#method.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;#method.append&quot;&gt; &lt;code&gt;append&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b17e4fe4c4cad25a01268fcf2e26864d2a26e310" translate="yes" xml:space="preserve">
          <source>In order for the file to be created, &lt;a href=&quot;struct.openoptions#method.write&quot;&gt;&lt;code&gt;OpenOptions::write&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.openoptions#method.append&quot;&gt;&lt;code&gt;OpenOptions::append&lt;/code&gt;&lt;/a&gt; access must be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="961d3f038f800fcb79e8e066158ebbffb2dcbb67" translate="yes" xml:space="preserve">
          <source>In order to be consistent with Rust's lack of global type inference, type and const placeholders are disallowed by design in item signatures.</source>
          <target state="translated">Para ser coherente con la falta de inferencia de tipo global de Rust,los marcadores de posición de tipo y const están desautorizados por diseño en las firmas de los artículos.</target>
        </trans-unit>
        <trans-unit id="8a65853b278eb7154e9a97a3b9168563f7fe07ac" translate="yes" xml:space="preserve">
          <source>In order to change the requirement from &lt;code&gt;'static&lt;/code&gt; to be a lifetime derived from its arguments, you can add an explicit bound, either to an anonymous lifetime &lt;code&gt;'_&lt;/code&gt; or some appropriate named lifetime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12fa624eb80e06baae2665fd37db20bf0778d0e3" translate="yes" xml:space="preserve">
          <source>In order to encode this kind of constraint, a &lt;code&gt;where&lt;/code&gt; clause and a new type parameter are needed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9667d5a282ae24dfeac4aaa28cc09c9d5311dfe4" translate="yes" xml:space="preserve">
          <source>In order to express that we want a generic function to take all arguments that can be converted to a specified type &lt;code&gt;T&lt;/code&gt;, we can use a trait bound of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt;. For example: The function &lt;code&gt;is_hello&lt;/code&gt; takes all arguments that can be converted into a &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f043234d0ac3953b89a91d738afd1e8d1c0c3577" translate="yes" xml:space="preserve">
          <source>In order to express that we want a generic function to take all arguments that can be converted to a specified type &lt;code&gt;T&lt;/code&gt;, we can use a trait bound of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt;. For example: The function &lt;code&gt;is_hello&lt;/code&gt; takes all arguments that can be converted into a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Para expresar que queremos que una funci&amp;oacute;n gen&amp;eacute;rica tome todos los argumentos que se pueden convertir a un tipo &lt;code&gt;T&lt;/code&gt; especificado , podemos usar un l&amp;iacute;mite de rasgo de &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; . Por ejemplo: la funci&amp;oacute;n &lt;code&gt;is_hello&lt;/code&gt; toma todos los argumentos que se pueden convertir en un &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0303aa2ff8dce24c97377d14d0409dbdf1ce9cff" translate="yes" xml:space="preserve">
          <source>In order to fix this error, verify that the type you're using does implement the trait. Example:</source>
          <target state="translated">Para corregir este error,verifique que el tipo que está usando implemente el rasgo.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="16814ae1bb835500e448e8f35cc53da6f0ca0628" translate="yes" xml:space="preserve">
          <source>In order to fix this error, you need to make the item public by using the &lt;code&gt;pub&lt;/code&gt; keyword. Example:</source>
          <target state="translated">Para corregir este error, debe hacer p&amp;uacute;blico el elemento mediante la palabra clave &lt;code&gt;pub&lt;/code&gt; . Ejemplo:</target>
        </trans-unit>
        <trans-unit id="0f266e5d780b399f0089fa40c8b0e4ea12c652ab" translate="yes" xml:space="preserve">
          <source>In order to make an intrinsic usable at compile-time, one needs to copy the implementation from &lt;a href=&quot;https://github.com/rust-lang/miri/blob/master/src/shims/intrinsics.rs&quot;&gt;https://github.com/rust-lang/miri/blob/master/src/shims/intrinsics.rs&lt;/a&gt; to &lt;code&gt;compiler/rustc_mir/src/interpret/intrinsics.rs&lt;/code&gt; and add a &lt;code&gt;#[rustc_const_unstable(feature = &quot;foo&quot;, issue = &quot;01234&quot;)]&lt;/code&gt; to the intrinsic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7221777f5fa03d42ac87ea82e0b30794fd67a12c" translate="yes" xml:space="preserve">
          <source>In order to make an intrinsic usable at compile-time, one needs to copy the implementation from https://github.com/rust-lang/miri/blob/master/src/shims/intrinsics.rs to &lt;code&gt;compiler/rustc_mir/src/interpret/intrinsics.rs&lt;/code&gt; and add a &lt;code&gt;#[rustc_const_unstable(feature = &quot;foo&quot;, issue = &quot;01234&quot;)]&lt;/code&gt; to the intrinsic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b32572b0c44c50ef0b6442f048eb1d80506db1f" translate="yes" xml:space="preserve">
          <source>In order to make common patterns more ergonomic, lifetime arguments can be &lt;em&gt;elided&lt;/em&gt; in &lt;a href=&quot;types/function-item&quot;&gt;function item&lt;/a&gt;, &lt;a href=&quot;types/function-pointer&quot;&gt;function pointer&lt;/a&gt; and &lt;a href=&quot;types/closure&quot;&gt;closure trait&lt;/a&gt; signatures. The following rules are used to infer lifetime parameters for elided lifetimes. It is an error to elide lifetime parameters that cannot be inferred. The placeholder lifetime, &lt;code&gt;'_&lt;/code&gt;, can also be used to have a lifetime inferred in the same way. For lifetimes in paths, using &lt;code&gt;'_&lt;/code&gt; is preferred. Trait object lifetimes follow different rules discussed &lt;a href=&quot;lifetime-elision#default-trait-object-lifetimes&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">Con el fin de hacer que los patrones comunes sean m&amp;aacute;s ergon&amp;oacute;micos, los argumentos de duraci&amp;oacute;n se pueden &lt;em&gt;elidir&lt;/em&gt; en el &lt;a href=&quot;types/function-item&quot;&gt;elemento de &lt;/a&gt;&lt;a href=&quot;types/function-pointer&quot;&gt;funci&amp;oacute;n&lt;/a&gt; , el puntero de funci&amp;oacute;n y las firmas de &lt;a href=&quot;types/closure&quot;&gt;rasgos de cierre&lt;/a&gt; . Las siguientes reglas se utilizan para inferir par&amp;aacute;metros de vida &amp;uacute;til para vidas elididas. Es un error eludir par&amp;aacute;metros de vida &amp;uacute;til que no se pueden inferir. La duraci&amp;oacute;n del marcador de posici&amp;oacute;n, &lt;code&gt;'_&lt;/code&gt; , tambi&amp;eacute;n se puede utilizar para inferir una duraci&amp;oacute;n de la misma forma. Para vidas en caminos, se prefiere usar &lt;code&gt;'_&lt;/code&gt; . La vida de los objetos rasgo sigue diferentes reglas que se describen a &lt;a href=&quot;lifetime-elision#default-trait-object-lifetimes&quot;&gt;continuaci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8c05c9e0569d955006204f9ccd8d44e873f7454e" translate="yes" xml:space="preserve">
          <source>In order to make common patterns more ergonomic, lifetime arguments can be &lt;em&gt;elided&lt;/em&gt; in &lt;a href=&quot;types/function-item&quot;&gt;function item&lt;/a&gt;, &lt;a href=&quot;types/function-pointer&quot;&gt;function pointer&lt;/a&gt;, and &lt;a href=&quot;types/closure&quot;&gt;closure trait&lt;/a&gt; signatures. The following rules are used to infer lifetime parameters for elided lifetimes. It is an error to elide lifetime parameters that cannot be inferred. The placeholder lifetime, &lt;code&gt;'_&lt;/code&gt;, can also be used to have a lifetime inferred in the same way. For lifetimes in paths, using &lt;code&gt;'_&lt;/code&gt; is preferred. Trait object lifetimes follow different rules discussed &lt;a href=&quot;#default-trait-object-lifetimes&quot;&gt;below&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d27121a6ebe29fbef52ed61a820dd624d21ff0c" translate="yes" xml:space="preserve">
          <source>In order to match C representation layout &lt;code&gt;repr(C)&lt;/code&gt;, you should call &lt;code&gt;pad_to_align&lt;/code&gt; after extending the layout with all fields. (There is no way to match the default Rust representation layout &lt;code&gt;repr(Rust)&lt;/code&gt;, as it is unspecified.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2072ffa181cdd9bbeca38913d9e7ffc8a4c68a24" translate="yes" xml:space="preserve">
          <source>In order to provide a well-organized API to your users that is straightforward to use and only exposes exactly what your users will need, let&amp;rsquo;s now turn to Rust&amp;rsquo;s modules.</source>
          <target state="translated">Para proporcionar una API bien organizada a sus usuarios que sea f&amp;aacute;cil de usar y solo exponga exactamente lo que sus usuarios necesitar&amp;aacute;n, pasemos ahora a los m&amp;oacute;dulos de Rust.</target>
        </trans-unit>
        <trans-unit id="62f97a59b8d70df8d4c8aedef19af999118a740d" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;x.wrapping_offset((y as usize).wrapping_sub(x as usize) / size_of::&amp;lt;T&amp;gt;())&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; the same as &lt;code&gt;y&lt;/code&gt;, and dereferencing it is undefined behavior unless &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; point into the same allocated object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f05491651266ee56252066973243e4d59fd4986f" translate="yes" xml:space="preserve">
          <source>In other words, all &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;s implement &lt;a href=&quot;trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt;, by just returning themselves. This means two things:</source>
          <target state="translated">En otras palabras, todo &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; es aplicar &lt;a href=&quot;trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt; , que acaban de volver a s&amp;iacute; mismos. Esto significa dos cosas:</target>
        </trans-unit>
        <trans-unit id="5e34b91de407d76f531f3eb575c5f8c03b7057c6" translate="yes" xml:space="preserve">
          <source>In other words, each &lt;a href=&quot;struct.thread&quot;&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;/a&gt; acts a bit like a spinlock that can be locked and unlocked using &lt;code&gt;park&lt;/code&gt; and &lt;code&gt;unpark&lt;/code&gt;.</source>
          <target state="translated">En otras palabras, cada &lt;a href=&quot;struct.thread&quot;&gt; &lt;code&gt;Thread&lt;/code&gt; &lt;/a&gt; act&amp;uacute;a un poco como un bloqueo &lt;code&gt;unpark&lt;/code&gt; que se puede bloquear y desbloquear utilizando &lt;code&gt;park&lt;/code&gt; y desbloquear .</target>
        </trans-unit>
        <trans-unit id="017a22416220a22bb237e68a2935592375fcdbd8" translate="yes" xml:space="preserve">
          <source>In other words, if a zero-sized pointer can flow out of an allocator, then that allocator must likewise accept that pointer flowing back into its deallocation and reallocation methods.</source>
          <target state="translated">En otras palabras,si un puntero de tamaño cero puede fluir fuera de un asignador,entonces ese asignador debe igualmente aceptar que ese puntero fluya de vuelta a sus métodos de asignación y reasignación.</target>
        </trans-unit>
        <trans-unit id="e3d6e585c04e6960f4a4daf614d13944251e6245" translate="yes" xml:space="preserve">
          <source>In other words, if two keys are equal, their hashes must also be equal. &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../collections/struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt; both rely on this behavior.</source>
          <target state="translated">En otras palabras, si dos claves son iguales, sus valores hash tambi&amp;eacute;n deben ser iguales. &lt;a href=&quot;../collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../collections/struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; se&lt;/a&gt; basan en este comportamiento.</target>
        </trans-unit>
        <trans-unit id="0806744b814432ac5eeb9bbe9aaec55997c24ce4" translate="yes" xml:space="preserve">
          <source>In other words, if two keys are equal, their hashes must be equal.</source>
          <target state="translated">En otras palabras,si dos llaves son iguales,sus hashes deben ser iguales.</target>
        </trans-unit>
        <trans-unit id="651e99e3b0937bfaed54c38e268ae7294b8d7b90" translate="yes" xml:space="preserve">
          <source>In other words, if you tried to explicitly call &lt;code&gt;Drop::drop&lt;/code&gt; in the above example, you'd get a compiler error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f6bdd62db2c3d1c564fe1508c5d510fa5ae36fe" translate="yes" xml:space="preserve">
          <source>In other words, it links two iterators together, in a chain. 🔗</source>
          <target state="translated">En otras palabras,une dos iteradores en una cadena.🔗</target>
        </trans-unit>
        <trans-unit id="54f872e9b6db688afe70a73782dd0f6ed1033af8" translate="yes" xml:space="preserve">
          <source>In other words, it removes the &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; layer automatically. If your mapping is already returning an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and you want to skip over &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;s, then &lt;code&gt;filter_map&lt;/code&gt; is much, much nicer to use.</source>
          <target state="translated">En otras palabras, elimina la capa &lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; autom&amp;aacute;ticamente. Si su mapeo ya est&amp;aacute; devolviendo una &lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; y desea omitir &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , entonces &lt;code&gt;filter_map&lt;/code&gt; es mucho, mucho m&amp;aacute;s agradable de usar.</target>
        </trans-unit>
        <trans-unit id="89979b2fec011c660ad3e7734fd58ee8f629327f" translate="yes" xml:space="preserve">
          <source>In other words, it zips two iterators together, into a single one.</source>
          <target state="translated">En otras palabras,junta dos iteradores en uno solo.</target>
        </trans-unit>
        <trans-unit id="b3e56b5cdfc19448d528331ce8acb937d8705430" translate="yes" xml:space="preserve">
          <source>In other words, remove all characters &lt;code&gt;c&lt;/code&gt; such that &lt;code&gt;f(c)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. This method operates in place, visiting each character exactly once in the original order, and preserves the order of the retained characters.</source>
          <target state="translated">En otras palabras, elimine todos los caracteres &lt;code&gt;c&lt;/code&gt; de modo que &lt;code&gt;f(c)&lt;/code&gt; devuelva &lt;code&gt;false&lt;/code&gt; . Este m&amp;eacute;todo funciona en el lugar, visitando cada car&amp;aacute;cter exactamente una vez en el orden original y conserva el orden de los caracteres retenidos.</target>
        </trans-unit>
        <trans-unit id="da3db680c88a9b20c1061ab552177a6db2b7f021" translate="yes" xml:space="preserve">
          <source>In other words, remove all elements &lt;code&gt;e&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">En otras palabras, elimine todos los elementos &lt;code&gt;e&lt;/code&gt; d manera que &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; devuelva &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="326bae5baf07932f414f02dbcc5ff71283bf4bd0" translate="yes" xml:space="preserve">
          <source>In other words, remove all elements &lt;code&gt;e&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. The elements are visited in unsorted (and unspecified) order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e07775077ea9082d7402b02d807e4e57d5847374" translate="yes" xml:space="preserve">
          <source>In other words, remove all elements &lt;code&gt;e&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. This method operates in place, visiting each element exactly once in the original order, and preserves the order of the retained elements.</source>
          <target state="translated">En otras palabras, elimine todos los elementos &lt;code&gt;e&lt;/code&gt; d manera que &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; devuelva &lt;code&gt;false&lt;/code&gt; . Este m&amp;eacute;todo opera en el lugar, visitando cada elemento exactamente una vez en el orden original y preserva el orden de los elementos retenidos.</target>
        </trans-unit>
        <trans-unit id="6acdfc87ca3bbf1858881abbc8aa3fe29f18bd27" translate="yes" xml:space="preserve">
          <source>In other words, remove all elements &lt;code&gt;e&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; returns false. This method operates in place, visiting each element exactly once in the original order, and preserves the order of the retained elements.</source>
          <target state="translated">En otras palabras, elimine todos los elementos &lt;code&gt;e&lt;/code&gt; d manera que &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; devuelva falso. Este m&amp;eacute;todo opera en el lugar, visitando cada elemento exactamente una vez en el orden original y preserva el orden de los elementos retenidos.</target>
        </trans-unit>
        <trans-unit id="f592c733f4a495d9c0b5f64b20924cb17921a1b4" translate="yes" xml:space="preserve">
          <source>In other words, remove all pairs &lt;code&gt;(k, v)&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;k, &amp;amp;mut v)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="409ac6d61a4514fa20ba9e42bf2bc871e22e3383" translate="yes" xml:space="preserve">
          <source>In other words, remove all pairs &lt;code&gt;(k, v)&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;k,&amp;amp;mut v)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">En otras palabras, elimine todos los pares &lt;code&gt;(k, v)&lt;/code&gt; modo que &lt;code&gt;f(&amp;amp;k,&amp;amp;mut v)&lt;/code&gt; devuelva &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db6a61aac7244549da2135cbc7c5d55db0ae8143" translate="yes" xml:space="preserve">
          <source>In other words, the result is &lt;code&gt;self / rhs&lt;/code&gt; rounded to the integer &lt;code&gt;n&lt;/code&gt; such that &lt;code&gt;self &amp;gt;= n * rhs&lt;/code&gt;. If &lt;code&gt;self &amp;gt; 0&lt;/code&gt;, this is equal to round towards zero (the default in Rust); if &lt;code&gt;self &amp;lt; 0&lt;/code&gt;, this is equal to round towards +/- infinity.</source>
          <target state="translated">En otras palabras, el resultado es &lt;code&gt;self / rhs&lt;/code&gt; redondeado al entero &lt;code&gt;n&lt;/code&gt; tal que &lt;code&gt;self &amp;gt;= n * rhs&lt;/code&gt; . Si &lt;code&gt;self &amp;gt; 0&lt;/code&gt; , esto es igual a redondear hacia cero (el valor predeterminado en Rust); si &lt;code&gt;self &amp;lt; 0&lt;/code&gt; , esto es igual a redondear hacia +/- infinito.</target>
        </trans-unit>
        <trans-unit id="f3eceeaf0b00ea5c9de839f6b4c98970d8bf7ccc" translate="yes" xml:space="preserve">
          <source>In other words, there are two important points in time here:</source>
          <target state="translated">En otras palabras,hay dos puntos importantes en el tiempo aquí:</target>
        </trans-unit>
        <trans-unit id="514a6e60d538677dfc818a6af055ba7f84a3873f" translate="yes" xml:space="preserve">
          <source>In other words, we tell Rust that the data returned by the &lt;code&gt;search&lt;/code&gt; function will live as long as the data passed into the &lt;code&gt;search&lt;/code&gt; function in the &lt;code&gt;contents&lt;/code&gt; argument. This is important! The data referenced &lt;em&gt;by&lt;/em&gt; a slice needs to be valid for the reference to be valid; if the compiler assumes we&amp;rsquo;re making string slices of &lt;code&gt;query&lt;/code&gt; rather than &lt;code&gt;contents&lt;/code&gt;, it will do its safety checking incorrectly.</source>
          <target state="translated">En otras palabras, le decimos a Rust que los datos devueltos por la funci&amp;oacute;n de &lt;code&gt;search&lt;/code&gt; vivir&amp;aacute;n mientras los datos pasados ​​a la funci&amp;oacute;n de &lt;code&gt;search&lt;/code&gt; en el argumento de &lt;code&gt;contents&lt;/code&gt; . &amp;iexcl;Esto es importante! Los datos referenciados &lt;em&gt;por&lt;/em&gt; unas necesidades rebanada sea v&amp;aacute;lida para que la referencia sea v&amp;aacute;lida; si el compilador asume que estamos haciendo secciones de cadena de &lt;code&gt;query&lt;/code&gt; lugar de &lt;code&gt;contents&lt;/code&gt; , har&amp;aacute; su verificaci&amp;oacute;n de seguridad de manera incorrecta.</target>
        </trans-unit>
        <trans-unit id="804ea33dad59d1c5c89d408ead7e387f0a985972" translate="yes" xml:space="preserve">
          <source>In other words, you can think of &lt;code&gt;if let&lt;/code&gt; as syntax sugar for a &lt;code&gt;match&lt;/code&gt; that runs code when the value matches one pattern and then ignores all other values.</source>
          <target state="translated">En otras palabras, puede pensar en &lt;code&gt;if let&lt;/code&gt; como az&amp;uacute;car de sintaxis para una &lt;code&gt;match&lt;/code&gt; que ejecuta c&amp;oacute;digo cuando el valor coincide con un patr&amp;oacute;n y luego ignora todos los dem&amp;aacute;s valores.</target>
        </trans-unit>
        <trans-unit id="6334c9849815dfecdd814af745b203f67c22a399" translate="yes" xml:space="preserve">
          <source>In other words, you have to convert an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; to a &lt;code&gt;T&lt;/code&gt; before you can perform &lt;code&gt;T&lt;/code&gt; operations with it. Generally, this helps catch one of the most common issues with null: assuming that something isn&amp;rsquo;t null when it actually is.</source>
          <target state="translated">En otras palabras, debe convertir una &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; en una &lt;code&gt;T&lt;/code&gt; antes de poder realizar operaciones &lt;code&gt;T&lt;/code&gt; con ella. Generalmente, esto ayuda a detectar uno de los problemas m&amp;aacute;s comunes con nulo: asumir que algo no es nulo cuando en realidad lo es.</target>
        </trans-unit>
        <trans-unit id="0196eaac5628739fbf6cb05a071b0a88467b2539" translate="yes" xml:space="preserve">
          <source>In other words: t &amp;isin; FOLLOW(M) if and only if there exists (potentially empty) token sequences &amp;alpha;, &amp;beta;, &amp;gamma;, &amp;delta; where:</source>
          <target state="translated">En otras palabras: t &amp;isin; SIGUE (M) si y solo si existen secuencias de tokens (potencialmente vac&amp;iacute;as) &amp;alpha;, &amp;beta;, &amp;gamma;, &amp;delta; donde:</target>
        </trans-unit>
        <trans-unit id="3cd75e15c4f05dc1708639a16368fd49e4de241e" translate="yes" xml:space="preserve">
          <source>In our erroneous example, however, we're referencing a single concrete type. Since we know for certain that &lt;code&gt;Wrapper&amp;lt;u32&amp;gt;&lt;/code&gt; implements &lt;code&gt;Clone&lt;/code&gt;, there's no reason to also specify it in a &lt;code&gt;where&lt;/code&gt; clause.</source>
          <target state="translated">Sin embargo, en nuestro ejemplo err&amp;oacute;neo, estamos haciendo referencia a un solo tipo de hormig&amp;oacute;n. Dado que sabemos con certeza que &lt;code&gt;Wrapper&amp;lt;u32&amp;gt;&lt;/code&gt; implementa &lt;code&gt;Clone&lt;/code&gt; , no hay raz&amp;oacute;n para especificarlo tambi&amp;eacute;n en una cl&amp;aacute;usula &lt;code&gt;where&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="293c59c6ff48105f3a4a79bd57b559d1a88006c4" translate="yes" xml:space="preserve">
          <source>In particular &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt; and &lt;code&gt;Hash&lt;/code&gt; must be equivalent for borrowed and owned values: &lt;code&gt;x.borrow() == y.borrow()&lt;/code&gt; should give the same result as &lt;code&gt;x == y&lt;/code&gt;.</source>
          <target state="translated">En particular , &lt;code&gt;Eq&lt;/code&gt; , &lt;code&gt;Ord&lt;/code&gt; y &lt;code&gt;Hash&lt;/code&gt; deben ser equivalentes para valores prestados y &lt;code&gt;x.borrow() == y.borrow()&lt;/code&gt; : x.borrow () == y.borrow () debe dar el mismo resultado que &lt;code&gt;x == y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75333f3519a07df1c42a5d8eddbdb687099bae84" translate="yes" xml:space="preserve">
          <source>In particular, coercing a function with &lt;code&gt;#[track_caller]&lt;/code&gt; to a function pointer creates a shim which appears to observers to have been called at the attributed function's definition site, losing actual caller information across virtual calls. A common example of this coercion is the creation of a trait object whose methods are attributed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fc02ea574ea8868955711f77244bfddf7cf3916" translate="yes" xml:space="preserve">
          <source>In particular, if one has a memory block allocated via a given allocator &lt;code&gt;a&lt;/code&gt; and layout &lt;code&gt;k&lt;/code&gt; where &lt;code&gt;a.usable_size(k)&lt;/code&gt; returns &lt;code&gt;(l, u)&lt;/code&gt;, then one can pass that block to &lt;code&gt;a.dealloc()&lt;/code&gt; with a layout in the size range [l, u].</source>
          <target state="translated">En particular, si uno tiene un bloque de memoria asignado a trav&amp;eacute;s de un asignador dado &lt;code&gt;a&lt;/code&gt; y un dise&amp;ntilde;o &lt;code&gt;k&lt;/code&gt; donde &lt;code&gt;a.usable_size(k)&lt;/code&gt; devuelve &lt;code&gt;(l, u)&lt;/code&gt; , entonces uno puede pasar ese bloque a &lt;code&gt;a.dealloc()&lt;/code&gt; con un dise&amp;ntilde;o en el tama&amp;ntilde;o rango [l, u].</target>
        </trans-unit>
        <trans-unit id="d30439b36bf2c88bac9a70141d7e2e3a34d9cecb" translate="yes" xml:space="preserve">
          <source>In particular, it can happen if you forgot the closing bracket of a register constraint (see issue #51430), like in the previous code example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1d6c2afe57e4288fb19b871bba2fa73f6a44e31" translate="yes" xml:space="preserve">
          <source>In particular, it can happen if you forgot the closing bracket of a register constraint (see issue #51430):</source>
          <target state="translated">En particular,puede suceder si se olvida el paréntesis de cierre de una restricción de registro (véase el número 51430):</target>
        </trans-unit>
        <trans-unit id="f7716ba7e6003b68172172b437c60f14481d71f9" translate="yes" xml:space="preserve">
          <source>In particular, the hash used to initialized the raw entry must still be consistent with the hash of the key that is ultimately stored in the entry. This is because implementations of HashMap may need to recompute hashes when resizing, at which point only the keys are available.</source>
          <target state="translated">En particular,el hash utilizado para inicializar la entrada en bruto debe seguir siendo coherente con el hash de la clave que se almacena en última instancia en la entrada.Esto se debe a que las implementaciones de HashMap pueden necesitar volver a calcular los hash al redimensionar,momento en el que sólo están disponibles las claves.</target>
        </trans-unit>
        <trans-unit id="1f0c47f31f9dc083f9c5c01ccece4c74f77d799d" translate="yes" xml:space="preserve">
          <source>In particular, the resulting pointer remains attached to the same allocated object that &lt;code&gt;self&lt;/code&gt; points to. It may &lt;em&gt;not&lt;/em&gt; be used to access a different allocated object. Note that in Rust, every (stack-allocated) variable is considered a separate allocated object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b3f61d7a53e26f34f171feb26ed7836eaeaa8a1" translate="yes" xml:space="preserve">
          <source>In particular, the return value &lt;code&gt;r&lt;/code&gt; satisfies &lt;code&gt;0.0 &amp;lt;= r &amp;lt; rhs.abs()&lt;/code&gt; in most cases. However, due to a floating point round-off error it can result in &lt;code&gt;r == rhs.abs()&lt;/code&gt;, violating the mathematical definition, if &lt;code&gt;self&lt;/code&gt; is much smaller than &lt;code&gt;rhs.abs()&lt;/code&gt; in magnitude and &lt;code&gt;self &amp;lt; 0.0&lt;/code&gt;. This result is not an element of the function's codomain, but it is the closest floating point number in the real numbers and thus fulfills the property &lt;code&gt;self == self.div_euclid(rhs) * rhs + self.rem_euclid(rhs)&lt;/code&gt; approximatively.</source>
          <target state="translated">En particular, el valor de retorno &lt;code&gt;r&lt;/code&gt; satisface &lt;code&gt;0.0 &amp;lt;= r &amp;lt; rhs.abs()&lt;/code&gt; en la mayor&amp;iacute;a de los casos. Sin embargo, debido a un error de redondeo de coma flotante, puede resultar en &lt;code&gt;r == rhs.abs()&lt;/code&gt; , violando la definici&amp;oacute;n matem&amp;aacute;tica, si &lt;code&gt;self&lt;/code&gt; es mucho m&amp;aacute;s peque&amp;ntilde;o que &lt;code&gt;rhs.abs()&lt;/code&gt; en magnitud y &lt;code&gt;self &amp;lt; 0.0&lt;/code&gt; . Este resultado no es un elemento del codominio de la funci&amp;oacute;n, pero es el n&amp;uacute;mero de punto flotante m&amp;aacute;s cercano en los n&amp;uacute;meros reales y, por lo tanto, cumple la propiedad &lt;code&gt;self == self.div_euclid(rhs) * rhs + self.rem_euclid(rhs)&lt;/code&gt; aproximadamente.</target>
        </trans-unit>
        <trans-unit id="5ace8c101adbcb8f417784f9525d6b6b04d2023a" translate="yes" xml:space="preserve">
          <source>In particular, try to have this call &lt;code&gt;fold()&lt;/code&gt; on the internal parts from which this iterator is composed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebe8059d8d4f315af9e0c1a14935b000c2ce3c36" translate="yes" xml:space="preserve">
          <source>In particular, try to have this call &lt;code&gt;try_fold()&lt;/code&gt; on the internal parts from which this iterator is composed. If multiple calls are needed, the &lt;code&gt;?&lt;/code&gt; operator may be convenient for chaining the accumulator value along, but beware any invariants that need to be upheld before those early returns. This is a &lt;code&gt;&amp;amp;mut self&lt;/code&gt; method, so iteration needs to be resumable after hitting an error here.</source>
          <target state="translated">En particular, intente tener esta llamada &lt;code&gt;try_fold()&lt;/code&gt; en las partes internas de las que est&amp;aacute; compuesto este iterador. Si se necesitan varias llamadas, el &lt;code&gt;?&lt;/code&gt; El operador puede ser conveniente para encadenar el valor del acumulador, pero tenga cuidado con cualquier invariante que deba mantenerse antes de esos retornos anticipados. Este es un m&amp;eacute;todo de &lt;code&gt;&amp;amp;mut self&lt;/code&gt; , por lo que la iteraci&amp;oacute;n debe poder reanudarse despu&amp;eacute;s de encontrar un error aqu&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="b28ffdb986ba0682e9d2b9fe7fe1c75ddd8df192" translate="yes" xml:space="preserve">
          <source>In rare situations, it&amp;rsquo;s more appropriate to write code that panics instead of returning a &lt;code&gt;Result&lt;/code&gt;. Let&amp;rsquo;s explore why it&amp;rsquo;s appropriate to panic in examples, prototype code, and tests. Then we&amp;rsquo;ll discuss situations in which the compiler can&amp;rsquo;t tell that failure is impossible, but you as a human can. The chapter will conclude with some general guidelines on how to decide whether to panic in library code.</source>
          <target state="translated">En situaciones raras, es m&amp;aacute;s apropiado escribir c&amp;oacute;digo que entre en p&amp;aacute;nico en lugar de devolver un &lt;code&gt;Result&lt;/code&gt; . Exploremos por qu&amp;eacute; es apropiado entrar en p&amp;aacute;nico en ejemplos, c&amp;oacute;digo prototipo y pruebas. Luego discutiremos situaciones en las que el compilador no puede decir que el fracaso es imposible, pero usted, como humano, puede hacerlo. El cap&amp;iacute;tulo concluir&amp;aacute; con algunas pautas generales sobre c&amp;oacute;mo decidir si entrar en p&amp;aacute;nico en el c&amp;oacute;digo de la biblioteca.</target>
        </trans-unit>
        <trans-unit id="080a5588048a460fe7952d8098cb9c6856c84518" translate="yes" xml:space="preserve">
          <source>In short, because &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; (where &lt;code&gt;T&lt;/code&gt; can be any type) are different types, the compiler won&amp;rsquo;t let us use an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; value as if it were definitely a valid value. For example, this code won&amp;rsquo;t compile because it&amp;rsquo;s trying to add an &lt;code&gt;i8&lt;/code&gt; to an &lt;code&gt;Option&amp;lt;i8&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">En resumen, debido a que &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; y &lt;code&gt;T&lt;/code&gt; (donde &lt;code&gt;T&lt;/code&gt; puede ser de cualquier tipo) son tipos diferentes, el compilador no nos permitir&amp;aacute; usar un valor &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; como si fuera definitivamente un valor v&amp;aacute;lido. Por ejemplo, este c&amp;oacute;digo no se compilar&amp;aacute; porque est&amp;aacute; intentando agregar un &lt;code&gt;i8&lt;/code&gt; a una &lt;code&gt;Option&amp;lt;i8&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="21e76fec2b332ec53cb1d4a54f13b33bbe0752a4" translate="yes" xml:space="preserve">
          <source>In single-threaded scenarios, this can cause issues when writing signal handlers or certain kinds of low-level code. Use &lt;a href=&quot;atomic/fn.compiler_fence&quot;&gt;compiler fences&lt;/a&gt; to prevent this reordering.</source>
          <target state="translated">En escenarios de un solo subproceso, esto puede causar problemas al escribir controladores de se&amp;ntilde;ales o ciertos tipos de c&amp;oacute;digo de bajo nivel. Utilice &lt;a href=&quot;atomic/fn.compiler_fence&quot;&gt;vallas del compilador&lt;/a&gt; para evitar este reordenamiento.</target>
        </trans-unit>
        <trans-unit id="6eccde4f87031328924ef4f1acaf135f499b7802" translate="yes" xml:space="preserve">
          <source>In some contexts, the compiler must coerce together multiple types to try and find the most general type. This is called a &quot;Least Upper Bound&quot; coercion. LUB coercion is used and only used in the following situations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0772e28e9cf06b8832079dff483fbb65fa8253ca" translate="yes" xml:space="preserve">
          <source>In some languages, the programmer must call code to free memory or resources every time they finish using an instance of a smart pointer. If they forget, the system might become overloaded and crash. In Rust, you can specify that a particular bit of code be run whenever a value goes out of scope, and the compiler will insert this code automatically. As a result, you don&amp;rsquo;t need to be careful about placing cleanup code everywhere in a program that an instance of a particular type is finished with&amp;mdash;you still won&amp;rsquo;t leak resources!</source>
          <target state="translated">En algunos lenguajes, el programador debe llamar al c&amp;oacute;digo para liberar memoria o recursos cada vez que terminan de usar una instancia de un puntero inteligente. Si se olvidan, el sistema podr&amp;iacute;a sobrecargarse y bloquearse. En Rust, puede especificar que se ejecute un fragmento de c&amp;oacute;digo en particular cada vez que un valor salga del alcance, y el compilador insertar&amp;aacute; este c&amp;oacute;digo autom&amp;aacute;ticamente. Como resultado, no necesita tener cuidado al colocar c&amp;oacute;digo de limpieza en cualquier lugar de un programa con el que termine una instancia de un tipo en particular; &amp;iexcl;a&amp;uacute;n no perder&amp;aacute; recursos!</target>
        </trans-unit>
        <trans-unit id="37072e6e82bbf9d96cc9281defd328d5ab53bf93" translate="yes" xml:space="preserve">
          <source>In some programming languages, the behavior of string formatting functions depends on the operating system's locale setting. The format functions provided by Rust's standard library do not have any concept of locale and will produce the same results on all systems regardless of user configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1e113cf6d44a0a189f70b8c727f406e2c0c6aed" translate="yes" xml:space="preserve">
          <source>In some situations the combination of types may be ambiguous. Use parentheses around a type to avoid ambiguity. For example, the &lt;code&gt;+&lt;/code&gt; operator for &lt;a href=&quot;trait-bounds&quot;&gt;type boundaries&lt;/a&gt; within a &lt;a href=&quot;types/pointer#shared-references-&quot;&gt;reference type&lt;/a&gt; is unclear where the boundary applies, so the use of parentheses is required. Grammar rules that require this disambiguation use the &lt;a href=&quot;types#type-expressions&quot;&gt;&lt;em&gt;TypeNoBounds&lt;/em&gt;&lt;/a&gt; rule instead of &lt;a href=&quot;types#type-expressions&quot;&gt;&lt;em&gt;Type&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">En algunas situaciones, la combinaci&amp;oacute;n de tipos puede ser ambigua. Use par&amp;eacute;ntesis alrededor de un tipo para evitar ambig&amp;uuml;edades. Por ejemplo, el operador &lt;code&gt;+&lt;/code&gt; para los &lt;a href=&quot;trait-bounds&quot;&gt;l&amp;iacute;mites de tipo&lt;/a&gt; dentro de un &lt;a href=&quot;types/pointer#shared-references-&quot;&gt;tipo de referencia&lt;/a&gt; no est&amp;aacute; claro d&amp;oacute;nde se aplica el l&amp;iacute;mite, por lo que se requiere el uso de par&amp;eacute;ntesis. Las reglas gramaticales que requieren esta desambiguaci&amp;oacute;n utilizan la regla &lt;a href=&quot;types#type-expressions&quot;&gt;&lt;em&gt;TypeNoBounds en&lt;/em&gt;&lt;/a&gt; lugar de &lt;a href=&quot;types#type-expressions&quot;&gt;&lt;em&gt;Type&lt;/em&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="78a25e5b990fcd1740e4efa791bdb025c393c864" translate="yes" xml:space="preserve">
          <source>In some situations, some strings that should create a valid float instead return an error. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/31407&quot;&gt;issue #31407&lt;/a&gt; for details.</source>
          <target state="translated">En algunas situaciones, algunas cadenas que deber&amp;iacute;an crear un flotante v&amp;aacute;lido devuelven un error. Consulte el &lt;a href=&quot;https://github.com/rust-lang/rust/issues/31407&quot;&gt;n&amp;uacute;mero 31407&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="e28b9cfae095cd08e8afd62032026a0b23bc39f7" translate="yes" xml:space="preserve">
          <source>In statements like &lt;code&gt;let x = 5;&lt;/code&gt; with a variable name in the &lt;code&gt;PATTERN&lt;/code&gt; slot, the variable name is just a particularly simple form of a pattern. Rust compares the expression against the pattern and assigns any names it finds. So in the &lt;code&gt;let x = 5;&lt;/code&gt; example, &lt;code&gt;x&lt;/code&gt; is a pattern that means &amp;ldquo;bind what matches here to the variable &lt;code&gt;x&lt;/code&gt;.&amp;rdquo; Because the name &lt;code&gt;x&lt;/code&gt; is the whole pattern, this pattern effectively means &amp;ldquo;bind everything to the variable &lt;code&gt;x&lt;/code&gt;, whatever the value is.&amp;rdquo;</source>
          <target state="translated">En declaraciones como &lt;code&gt;let x = 5;&lt;/code&gt; con un nombre de variable en el espacio &lt;code&gt;PATTERN&lt;/code&gt; , el nombre de la variable es solo una forma particularmente simple de un patr&amp;oacute;n. Rust compara la expresi&amp;oacute;n con el patr&amp;oacute;n y asigna los nombres que encuentra. Entonces, en el caso &lt;code&gt;let x = 5;&lt;/code&gt; Por ejemplo, &lt;code&gt;x&lt;/code&gt; es un patr&amp;oacute;n que significa &quot;vincular lo que coincida aqu&amp;iacute; con la variable &lt;code&gt;x&lt;/code&gt; &quot;. Debido a que el nombre &lt;code&gt;x&lt;/code&gt; es el patr&amp;oacute;n completo, este patr&amp;oacute;n significa efectivamente &quot;vincular todo a la variable &lt;code&gt;x&lt;/code&gt; , sea cual sea el valor&quot;.</target>
        </trans-unit>
        <trans-unit id="ab76c75fb8be2531be195781f70554fa526d2349" translate="yes" xml:space="preserve">
          <source>In such a case, the compiler cannot predict the return type of &lt;code&gt;foo()&lt;/code&gt; in a situation like the following:</source>
          <target state="translated">En tal caso, el compilador no puede predecir el tipo de retorno de &lt;code&gt;foo()&lt;/code&gt; en una situaci&amp;oacute;n como la siguiente:</target>
        </trans-unit>
        <trans-unit id="a84c028b3015af78e467c76bddbf22405a6992e9" translate="yes" xml:space="preserve">
          <source>In sum, here are the steps we took to change the code from Listing 10-2 to Listing 10-3:</source>
          <target state="translated">En resumen,estos son los pasos que dimos para cambiar el código de la Lista 10-2 a la Lista 10-3:</target>
        </trans-unit>
        <trans-unit id="b66a6766ec59e5aa720a0c750a221736c0a524da" translate="yes" xml:space="preserve">
          <source>In terms of &lt;a href=&quot;../sync/atomic/index&quot;&gt;atomic memory orderings&lt;/a&gt;, the completion of the associated thread synchronizes with this function returning. In other words, all operations performed by that thread are ordered before all operations that happen after &lt;code&gt;join&lt;/code&gt; returns.</source>
          <target state="translated">En t&amp;eacute;rminos de &lt;a href=&quot;../sync/atomic/index&quot;&gt;ordenaciones de memoria at&amp;oacute;mica&lt;/a&gt; , la finalizaci&amp;oacute;n del hilo asociado se sincroniza con el retorno de esta funci&amp;oacute;n. En otras palabras, todas las operaciones realizadas por ese hilo se ordenan antes de todas las operaciones que suceden despu&amp;eacute;s de que &lt;code&gt;join&lt;/code&gt; devuelva la combinaci&amp;oacute;n .</target>
        </trans-unit>
        <trans-unit id="49ebdf4d886162df5d53e77b9ab0d51282c8c87c" translate="yes" xml:space="preserve">
          <source>In the 2015 edition parameters pattern where not needed for traits:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95c17fb8e8e9e84f4aa64abfe2139c371569ca73" translate="yes" xml:space="preserve">
          <source>In the 2015 edition the parameters pattern was not needed for traits:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fb4dfd79140995a00d7f2f4a091910c0bb3584f" translate="yes" xml:space="preserve">
          <source>In the 2015 edition, &lt;a href=&quot;types/trait-object&quot;&gt;&lt;code&gt;dyn&lt;/code&gt;&lt;/a&gt; is a keyword when used in a type position followed by a path that does not start with &lt;code&gt;::&lt;/code&gt;.</source>
          <target state="translated">En la edici&amp;oacute;n de 2015, &lt;a href=&quot;types/trait-object&quot;&gt; &lt;code&gt;dyn&lt;/code&gt; &lt;/a&gt; es una palabra clave cuando se usa en una posici&amp;oacute;n de tipo seguida de una ruta que no comienza con &lt;code&gt;::&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5c533200fa356e0f6f01942ecd077fd12144d48" translate="yes" xml:space="preserve">
          <source>In the 2015 edition, the pattern for a trait function or method parameter is optional:</source>
          <target state="translated">En la edición de 2015,el patrón para una función de rasgo o un parámetro de método es opcional:</target>
        </trans-unit>
        <trans-unit id="ead217a846b182b1c7c3895bb636fcdc53cf3da8" translate="yes" xml:space="preserve">
          <source>In the 2018 edition, if an in-scope item has the same name as an external crate, then &lt;code&gt;use&lt;/code&gt; of that crate name requires a leading &lt;code&gt;::&lt;/code&gt; to unambiguously select the crate name. This is to retain compatibility with potential future changes.</source>
          <target state="translated">En la edici&amp;oacute;n 2018, si un elemento dentro del alcance tiene el mismo nombre que una caja externa, entonces el &lt;code&gt;use&lt;/code&gt; de ese nombre de caja requiere un &lt;code&gt;::&lt;/code&gt; para seleccionar sin ambig&amp;uuml;edades el nombre de la caja. Esto es para mantener la compatibilidad con posibles cambios futuros.</target>
        </trans-unit>
        <trans-unit id="a3999cf3a0362f5c3017eea167e996c61b1004cc" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://www.unicode.org/versions/latest/&quot;&gt;Unicode Standard&lt;/a&gt;, Chapter 4 (Character Properties) discusses case mapping in general and Chapter 3 (Conformance) discusses the default algorithm for case conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac8c3e671a7bc9e2a3ca26713c444ad82025ac40" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;index&quot;&gt;module level docs&lt;/a&gt;, we implemented an &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;Counter&lt;/code&gt;. Let's implement &lt;code&gt;ExactSizeIterator&lt;/code&gt; for it as well:</source>
          <target state="translated">En los &lt;a href=&quot;index&quot;&gt;documentos de nivel de m&amp;oacute;dulo&lt;/a&gt; , implementamos un &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;Counter&lt;/code&gt; . Implementemos &lt;code&gt;ExactSizeIterator&lt;/code&gt; tambi&amp;eacute;n para &amp;eacute;l:</target>
        </trans-unit>
        <trans-unit id="29a70e5936b8ef90f87c3d79c860b1701d924dbc" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;index&quot;&gt;module-level docs&lt;/a&gt;, we implemented an &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;Counter&lt;/code&gt;. Let's implement &lt;code&gt;ExactSizeIterator&lt;/code&gt; for it as well:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="542be6c89aa5ea78dd9931c09f1fa338c6d41b0e" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;User&lt;/code&gt; struct definition in Listing 5-1, we used the owned &lt;code&gt;String&lt;/code&gt; type rather than the &lt;code&gt;&amp;amp;str&lt;/code&gt; string slice type. This is a deliberate choice because we want instances of this struct to own all of its data and for that data to be valid for as long as the entire struct is valid.</source>
          <target state="translated">En la definici&amp;oacute;n de estructura de &lt;code&gt;User&lt;/code&gt; en el Listado 5-1, usamos el tipo de &lt;code&gt;String&lt;/code&gt; propiedad en lugar del tipo de segmento de cadena &lt;code&gt;&amp;amp;str&lt;/code&gt; . Esta es una elecci&amp;oacute;n deliberada porque queremos que las instancias de esta estructura posean todos sus datos y que esos datos sean v&amp;aacute;lidos mientras la estructura completa sea v&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="86f5e9e4af3e5d42db41973d9449d9469f700ef8" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;handle_connection&lt;/code&gt; function, we&amp;rsquo;ve made the &lt;code&gt;stream&lt;/code&gt; parameter mutable. The reason is that the &lt;code&gt;TcpStream&lt;/code&gt; instance keeps track of what data it returns to us internally. It might read more data than we asked for and save that data for the next time we ask for data. It therefore needs to be &lt;code&gt;mut&lt;/code&gt; because its internal state might change; usually, we think of &amp;ldquo;reading&amp;rdquo; as not needing mutation, but in this case we need the &lt;code&gt;mut&lt;/code&gt; keyword.</source>
          <target state="translated">En la funci&amp;oacute;n &lt;code&gt;handle_connection&lt;/code&gt; , hemos hecho que el par&amp;aacute;metro de &lt;code&gt;stream&lt;/code&gt; mutable. La raz&amp;oacute;n es que la instancia de &lt;code&gt;TcpStream&lt;/code&gt; realiza un seguimiento de los datos que nos devuelve internamente. Puede leer m&amp;aacute;s datos de los que solicitamos y guardarlos para la pr&amp;oacute;xima vez que solicitemos datos. Por lo tanto, debe ser &lt;code&gt;mut&lt;/code&gt; porque su estado interno podr&amp;iacute;a cambiar; por lo general, pensamos que &quot;lectura&quot; no necesita mutaci&amp;oacute;n, pero en este caso necesitamos la palabra clave &lt;code&gt;mut&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41e5d381e8adcfa53c11fefa07fcde5916d77703" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;Cargo.toml&lt;/em&gt; file, everything that follows a header is part of a section that continues until another section starts. The &lt;code&gt;[dependencies]&lt;/code&gt; section is where you tell Cargo which external crates your project depends on and which versions of those crates you require. In this case, we&amp;rsquo;ll specify the &lt;code&gt;rand&lt;/code&gt; crate with the semantic version specifier &lt;code&gt;0.3.14&lt;/code&gt;. Cargo understands &lt;a href=&quot;http://semver.org&quot;&gt;Semantic Versioning&lt;/a&gt; (sometimes called &lt;em&gt;SemVer&lt;/em&gt;), which is a standard for writing version numbers. The number &lt;code&gt;0.3.14&lt;/code&gt; is actually shorthand for &lt;code&gt;^0.3.14&lt;/code&gt;, which means &amp;ldquo;any version that has a public API compatible with version 0.3.14.&amp;rdquo;</source>
          <target state="translated">En el archivo &lt;em&gt;Cargo.toml&lt;/em&gt; , todo lo que sigue a un encabezado es parte de una secci&amp;oacute;n que contin&amp;uacute;a hasta que comienza otra secci&amp;oacute;n. La secci&amp;oacute;n &lt;code&gt;[dependencies]&lt;/code&gt; es donde le dice a Cargo de qu&amp;eacute; cajas externas depende su proyecto y qu&amp;eacute; versiones de esas cajas necesita. En este caso, especificaremos la caja &lt;code&gt;rand&lt;/code&gt; con el especificador de versi&amp;oacute;n sem&amp;aacute;ntica &lt;code&gt;0.3.14&lt;/code&gt; . Cargo comprende el &lt;a href=&quot;http://semver.org&quot;&gt;control de versiones sem&amp;aacute;ntico&lt;/a&gt; (a veces llamado &lt;em&gt;SemVer&lt;/em&gt; ), que es un est&amp;aacute;ndar para escribir n&amp;uacute;meros de versi&amp;oacute;n. El n&amp;uacute;mero &lt;code&gt;0.3.14&lt;/code&gt; es en realidad una abreviatura de &lt;code&gt;^0.3.14&lt;/code&gt; , que significa &quot;cualquier versi&amp;oacute;n que tenga una API p&amp;uacute;blica compatible con la versi&amp;oacute;n 0.3.14&quot;.</target>
        </trans-unit>
        <trans-unit id="ba414d8766c29269cba8897672efd77d70e901b9" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;Cargo.toml&lt;/em&gt; file, everything that follows a header is part of a section that continues until another section starts. The &lt;code&gt;[dependencies]&lt;/code&gt; section is where you tell Cargo which external crates your project depends on and which versions of those crates you require. In this case, we&amp;rsquo;ll specify the &lt;code&gt;rand&lt;/code&gt; crate with the semantic version specifier &lt;code&gt;0.5.5&lt;/code&gt;. Cargo understands &lt;a href=&quot;http://semver.org&quot;&gt;Semantic Versioning&lt;/a&gt; (sometimes called &lt;em&gt;SemVer&lt;/em&gt;), which is a standard for writing version numbers. The number &lt;code&gt;0.5.5&lt;/code&gt; is actually shorthand for &lt;code&gt;^0.5.5&lt;/code&gt;, which means &amp;ldquo;any version that has a public API compatible with version 0.5.5.&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eddcd6a499d2c2be1d503ec8a0e525837574e9f" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;Cargo.toml&lt;/em&gt; file, everything that follows a header is part of a section that continues until another section starts. The &lt;code&gt;[dependencies]&lt;/code&gt; section is where you tell Cargo which external crates your project depends on and which versions of those crates you require. In this case, we&amp;rsquo;ll specify the &lt;code&gt;rand&lt;/code&gt; crate with the semantic version specifier &lt;code&gt;0.5.5&lt;/code&gt;. Cargo understands &lt;a href=&quot;http://semver.org&quot;&gt;Semantic Versioning&lt;/a&gt; (sometimes called &lt;em&gt;SemVer&lt;/em&gt;), which is a standard for writing version numbers. The number &lt;code&gt;0.5.5&lt;/code&gt; is actually shorthand for &lt;code&gt;^0.5.5&lt;/code&gt;, which means any version that is at least &lt;code&gt;0.5.5&lt;/code&gt; but below &lt;code&gt;0.6.0&lt;/code&gt;. Cargo considers these versions to have public APIs compatible with version &lt;code&gt;0.5.5&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7177f5dba94e8e93990faf2d2454fb646d49847" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;add-one/src/lib.rs&lt;/em&gt; file, let&amp;rsquo;s add an &lt;code&gt;add_one&lt;/code&gt; function:</source>
          <target state="translated">En el archivo &lt;em&gt;add-one / src / lib.rs&lt;/em&gt; , agreguemos una funci&amp;oacute;n &lt;code&gt;add_one&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3da0b39e8b4dc5e8ab87b83cc0f936c2b1215ca7" translate="yes" xml:space="preserve">
          <source>In the above example &lt;code&gt;T&lt;/code&gt; is unknowable by the compiler. To fix this you must bind &lt;code&gt;T&lt;/code&gt; to a concrete type such as &lt;code&gt;String&lt;/code&gt; so that a generator can then be constructed:</source>
          <target state="translated">En el ejemplo anterior, el compilador no puede conocer &lt;code&gt;T&lt;/code&gt; .Para solucionar esto, debe vincular &lt;code&gt;T&lt;/code&gt; a un tipo concreto como &lt;code&gt;String&lt;/code&gt; para que luego se pueda construir un generador:</target>
        </trans-unit>
        <trans-unit id="dac108bef6e0aa0c5a3c87c1e1dd002eec20cb12" translate="yes" xml:space="preserve">
          <source>In the absolute path, we start with &lt;code&gt;crate&lt;/code&gt;, the root of our crate&amp;rsquo;s module tree. Then the &lt;code&gt;front_of_house&lt;/code&gt; module is defined in the crate root. The &lt;code&gt;front_of_house&lt;/code&gt; module isn&amp;rsquo;t public, but because the &lt;code&gt;eat_at_restaurant&lt;/code&gt; function is defined in the same module as &lt;code&gt;front_of_house&lt;/code&gt; (that is, &lt;code&gt;eat_at_restaurant&lt;/code&gt; and &lt;code&gt;front_of_house&lt;/code&gt; are siblings), we can refer to &lt;code&gt;front_of_house&lt;/code&gt; from &lt;code&gt;eat_at_restaurant&lt;/code&gt;. Next is the &lt;code&gt;hosting&lt;/code&gt; module marked with &lt;code&gt;pub&lt;/code&gt;. We can access the parent module of &lt;code&gt;hosting&lt;/code&gt;, so we can access &lt;code&gt;hosting&lt;/code&gt;. Finally, the &lt;code&gt;add_to_waitlist&lt;/code&gt; function is marked with &lt;code&gt;pub&lt;/code&gt; and we can access its parent module, so this function call works!</source>
          <target state="translated">En la ruta absoluta, comenzamos con &lt;code&gt;crate&lt;/code&gt; , la ra&amp;iacute;z del &amp;aacute;rbol de m&amp;oacute;dulos de nuestro crate. Luego, el m&amp;oacute;dulo &lt;code&gt;front_of_house&lt;/code&gt; se define en la ra&amp;iacute;z de la caja. El m&amp;oacute;dulo &lt;code&gt;front_of_house&lt;/code&gt; no es p&amp;uacute;blico, pero debido a que la funci&amp;oacute;n &lt;code&gt;eat_at_restaurant&lt;/code&gt; se define en el mismo m&amp;oacute;dulo que &lt;code&gt;front_of_house&lt;/code&gt; (es decir, &lt;code&gt;eat_at_restaurant&lt;/code&gt; y &lt;code&gt;front_of_house&lt;/code&gt; son hermanos), podemos referirnos a &lt;code&gt;front_of_house&lt;/code&gt; desde &lt;code&gt;eat_at_restaurant&lt;/code&gt; . El siguiente es el m&amp;oacute;dulo de &lt;code&gt;hosting&lt;/code&gt; marcado con &lt;code&gt;pub&lt;/code&gt; . Podemos acceder al m&amp;oacute;dulo principal de &lt;code&gt;hosting&lt;/code&gt; , por lo que podemos acceder &lt;code&gt;hosting&lt;/code&gt; .. Finalmente, la funci&amp;oacute;n &lt;code&gt;add_to_waitlist&lt;/code&gt; est&amp;aacute; marcada con &lt;code&gt;pub&lt;/code&gt; y podemos acceder a su m&amp;oacute;dulo principal, &amp;iexcl;as&amp;iacute; que esta llamada a funci&amp;oacute;n funciona!</target>
        </trans-unit>
        <trans-unit id="e8a74d26ff6bb6812e6769b94696470ac83d32c8" translate="yes" xml:space="preserve">
          <source>In the body of &lt;code&gt;largest&lt;/code&gt; we wanted to compare two values of type &lt;code&gt;T&lt;/code&gt; using the greater than (&lt;code&gt;&amp;gt;&lt;/code&gt;) operator. Because that operator is defined as a default method on the standard library trait &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt;, we need to specify &lt;code&gt;PartialOrd&lt;/code&gt; in the trait bounds for &lt;code&gt;T&lt;/code&gt; so the &lt;code&gt;largest&lt;/code&gt; function can work on slices of any type that we can compare. We don&amp;rsquo;t need to bring &lt;code&gt;PartialOrd&lt;/code&gt; into scope because it&amp;rsquo;s in the prelude. Change the signature of &lt;code&gt;largest&lt;/code&gt; to look like this:</source>
          <target state="translated">En el cuerpo de &lt;code&gt;largest&lt;/code&gt; quer&amp;iacute;amos comparar dos valores de tipo &lt;code&gt;T&lt;/code&gt; usando el operador mayor que ( &lt;code&gt;&amp;gt;&lt;/code&gt; ). Debido a que ese operador est&amp;aacute; definido como un m&amp;eacute;todo predeterminado en el rasgo est&amp;aacute;ndar de la biblioteca &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt; , necesitamos especificar &lt;code&gt;PartialOrd&lt;/code&gt; en los l&amp;iacute;mites del rasgo para &lt;code&gt;T&lt;/code&gt; para que la funci&amp;oacute;n &lt;code&gt;largest&lt;/code&gt; pueda trabajar en cortes de cualquier tipo que podamos comparar. No necesitamos traer &lt;code&gt;PartialOrd&lt;/code&gt; al alcance porque est&amp;aacute; en el preludio. Cambie la firma del &lt;code&gt;largest&lt;/code&gt; para que se vea as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="9eeb876353faccbcba2ce19feeb7d0dafe4faead" translate="yes" xml:space="preserve">
          <source>In the body of &lt;code&gt;shoes_in_my_size&lt;/code&gt;, we call &lt;code&gt;into_iter&lt;/code&gt; to create an iterator that takes ownership of the vector. Then we call &lt;code&gt;filter&lt;/code&gt; to adapt that iterator into a new iterator that only contains elements for which the closure returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">En el cuerpo de &lt;code&gt;shoes_in_my_size&lt;/code&gt; , llamamos &lt;code&gt;into_iter&lt;/code&gt; para crear un iterador que se apropie del vector. Luego, llamamos a &lt;code&gt;filter&lt;/code&gt; para adaptar ese iterador a un nuevo iterador que solo contiene elementos para los que el cierre devuelve &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ccc28c109f469220d7a0f86ba3d92af7a489d690" translate="yes" xml:space="preserve">
          <source>In the body of a generic function, methods from &lt;code&gt;Trait&lt;/code&gt; can be called on &lt;code&gt;Ty&lt;/code&gt; values. Likewise associated constants on the &lt;code&gt;Trait&lt;/code&gt; can be used.</source>
          <target state="translated">En el cuerpo de una funci&amp;oacute;n gen&amp;eacute;rica, los m&amp;eacute;todos de &lt;code&gt;Trait&lt;/code&gt; se pueden llamar en valores &lt;code&gt;Ty&lt;/code&gt; . Asimismo, se pueden usar constantes asociadas en el &lt;code&gt;Trait&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed9b56a6d3a5e9ebb3e76d9359071c31eee0aecc" translate="yes" xml:space="preserve">
          <source>In the case a &lt;code&gt;loop&lt;/code&gt; has an associated &lt;code&gt;break&lt;/code&gt;, it is not considered diverging, and the &lt;code&gt;loop&lt;/code&gt; must have a type compatible with each &lt;code&gt;break&lt;/code&gt; expression. &lt;code&gt;break&lt;/code&gt; without an expression is considered identical to &lt;code&gt;break&lt;/code&gt; with expression &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">En el caso de que un &lt;code&gt;loop&lt;/code&gt; tenga una &lt;code&gt;break&lt;/code&gt; asociada , no se considera divergente y el &lt;code&gt;loop&lt;/code&gt; debe tener un tipo compatible con cada expresi&amp;oacute;n de &lt;code&gt;break&lt;/code&gt; . &lt;code&gt;break&lt;/code&gt; sin una expresi&amp;oacute;n se considera id&amp;eacute;ntico a &lt;code&gt;break&lt;/code&gt; con expresi&amp;oacute;n &lt;code&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e9ac885fce76186450b96a37f179bf757255fd6" translate="yes" xml:space="preserve">
          <source>In the case of a &lt;a href=&quot;expressions/block-expr&quot;&gt;block expression&lt;/a&gt;, the scope for the block and the expression are the same scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57fe262eb9d9754ab04dac149861a78ef7f9cbdf" translate="yes" xml:space="preserve">
          <source>In the case of a string literal, we know the contents at compile time, so the text is hardcoded directly into the final executable. This is why string literals are fast and efficient. But these properties only come from the string literal&amp;rsquo;s immutability. Unfortunately, we can&amp;rsquo;t put a blob of memory into the binary for each piece of text whose size is unknown at compile time and whose size might change while running the program.</source>
          <target state="translated">En el caso de un literal de cadena, conocemos el contenido en el momento de la compilaci&amp;oacute;n, por lo que el texto se codifica directamente en el ejecutable final. Es por eso que los literales de cadena son r&amp;aacute;pidos y eficientes. Pero estas propiedades solo provienen de la inmutabilidad del literal de cadena. Desafortunadamente, no podemos poner una gota de memoria en el binario para cada fragmento de texto cuyo tama&amp;ntilde;o se desconoce en el momento de la compilaci&amp;oacute;n y cuyo tama&amp;ntilde;o puede cambiar mientras se ejecuta el programa.</target>
        </trans-unit>
        <trans-unit id="174ee51902d80b0fa89335cd9be3f224ff39dd4c" translate="yes" xml:space="preserve">
          <source>In the case of implicitly-wrapped overflow, implementations must provide well-defined (even if still considered erroneous) results by using two's complement overflow conventions.</source>
          <target state="translated">En el caso de un desbordamiento implícito,las implementaciones deben proporcionar resultados bien definidos (aunque todavía se consideren erróneos)mediante el uso de las convenciones de desbordamiento del complemento de dos.</target>
        </trans-unit>
        <trans-unit id="ad072c8ebb70bdab55dbb950bf9d58e7b04bb9e3" translate="yes" xml:space="preserve">
          <source>In the case where &lt;code&gt;File::open&lt;/code&gt; succeeds, the value in the variable &lt;code&gt;f&lt;/code&gt; will be an instance of &lt;code&gt;Ok&lt;/code&gt; that contains a file handle. In the case where it fails, the value in &lt;code&gt;f&lt;/code&gt; will be an instance of &lt;code&gt;Err&lt;/code&gt; that contains more information about the kind of error that happened.</source>
          <target state="translated">En el caso de que &lt;code&gt;File::open&lt;/code&gt; tenga &amp;eacute;xito, el valor de la variable &lt;code&gt;f&lt;/code&gt; ser&amp;aacute; una instancia de &lt;code&gt;Ok&lt;/code&gt; que contiene un identificador de archivo. En el caso de que falle, el valor de &lt;code&gt;f&lt;/code&gt; ser&amp;aacute; una instancia de &lt;code&gt;Err&lt;/code&gt; que contiene m&amp;aacute;s informaci&amp;oacute;n sobre el tipo de error que ocurri&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="98ff22c3c9a8db90c4e7212603caadebf4d948d5" translate="yes" xml:space="preserve">
          <source>In the code above, the function is returning data borrowed from either &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt;, but the &lt;code&gt;'a&lt;/code&gt; annotation indicates that it is returning data only from &lt;code&gt;x&lt;/code&gt;. To fix the error, the signature and the body must be made to match. Typically, this is done by updating the function signature. So, in this case, we change the type of &lt;code&gt;y&lt;/code&gt; to &lt;code&gt;&amp;amp;'a i32&lt;/code&gt;, like so:</source>
          <target state="translated">En el c&amp;oacute;digo anterior, la funci&amp;oacute;n devuelve datos tomados de &lt;code&gt;x&lt;/code&gt; o &lt;code&gt;y&lt;/code&gt; , pero la anotaci&amp;oacute;n &lt;code&gt;'a&lt;/code&gt; indica que solo devuelve datos de &lt;code&gt;x&lt;/code&gt; . Para corregir el error, la firma y el cuerpo deben coincidir. Normalmente, esto se hace actualizando la firma de la funci&amp;oacute;n. Entonces, en este caso, cambiamos el tipo de &lt;code&gt;y&lt;/code&gt; a &lt;code&gt;&amp;amp;'a i32&lt;/code&gt; , as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="47d276ce9763d36114b6391e5e3702972a6d1fd2" translate="yes" xml:space="preserve">
          <source>In the context of Listing 9-7, the &lt;code&gt;?&lt;/code&gt; at the end of the &lt;code&gt;File::open&lt;/code&gt; call will return the value inside an &lt;code&gt;Ok&lt;/code&gt; to the variable &lt;code&gt;f&lt;/code&gt;. If an error occurs, the &lt;code&gt;?&lt;/code&gt; operator will return early out of the whole function and give any &lt;code&gt;Err&lt;/code&gt; value to the calling code. The same thing applies to the &lt;code&gt;?&lt;/code&gt; at the end of the &lt;code&gt;read_to_string&lt;/code&gt; call.</source>
          <target state="translated">En el contexto del Listado 9-7, el &lt;code&gt;?&lt;/code&gt; al final de la llamada &lt;code&gt;File::open&lt;/code&gt; devolver&amp;aacute; el valor dentro de un &lt;code&gt;Ok&lt;/code&gt; a la variable &lt;code&gt;f&lt;/code&gt; . Si ocurre un error, el &lt;code&gt;?&lt;/code&gt; El operador regresar&amp;aacute; temprano de toda la funci&amp;oacute;n y dar&amp;aacute; cualquier valor &lt;code&gt;Err&lt;/code&gt; al c&amp;oacute;digo de llamada. Lo mismo se aplica a la &lt;code&gt;?&lt;/code&gt; al final de la llamada &lt;code&gt;read_to_string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c49979de4803e07d7682a6dac88ad65cf9bdcef3" translate="yes" xml:space="preserve">
          <source>In the end, this means that you may need to pair &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; with some sort of &lt;a href=&quot;index&quot;&gt;&lt;code&gt;std::sync&lt;/code&gt;&lt;/a&gt; type, usually &lt;a href=&quot;struct.mutex&quot;&gt;&lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Al final, esto significa que es posible que deba emparejar &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; con alg&amp;uacute;n tipo de &lt;a href=&quot;index&quot;&gt; &lt;code&gt;std::sync&lt;/code&gt; &lt;/a&gt; , generalmente &lt;a href=&quot;struct.mutex&quot;&gt; &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5a1b716ed41677dd2be556cd6b10193bd9fd8fb5" translate="yes" xml:space="preserve">
          <source>In the erroneous code example above, the wrong name was provided, so changing to a correct one it will fix the error. Example:</source>
          <target state="translated">En el ejemplo de código erróneo de arriba,se proporcionó el nombre equivocado,así que al cambiar a uno correcto se corregirá el error.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="a13ba9220a713242d839758de54b6d6a213f5d7c" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;closure&lt;/code&gt; is an &lt;code&gt;FnOnce&lt;/code&gt; closure whereas the &lt;code&gt;bar&lt;/code&gt; function expected an &lt;code&gt;Fn&lt;/code&gt; closure. In this case, it's simple to fix the issue, you just have to implement &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Clone&lt;/code&gt; traits on &lt;code&gt;struct X&lt;/code&gt; and it'll be ok:</source>
          <target state="translated">En el ejemplo anterior, el &lt;code&gt;closure&lt;/code&gt; es un cierre &lt;code&gt;FnOnce&lt;/code&gt; mientras que la funci&amp;oacute;n de &lt;code&gt;bar&lt;/code&gt; ra esperaba un cierre &lt;code&gt;Fn&lt;/code&gt; . En este caso, es simple solucionar el problema, solo tiene que implementar los rasgos &lt;code&gt;Copy&lt;/code&gt; y &lt;code&gt;Clone&lt;/code&gt; en la &lt;code&gt;struct X&lt;/code&gt; y estar&amp;aacute; bien:</target>
        </trans-unit>
        <trans-unit id="0a2556b76fed59d4f25e18f6058b48758d96fe76" translate="yes" xml:space="preserve">
          <source>In the example below, &lt;code&gt;name&lt;/code&gt; is moved out of &lt;code&gt;person&lt;/code&gt;, trying to use &lt;code&gt;person&lt;/code&gt; as a whole or &lt;code&gt;person.name&lt;/code&gt; would result in an error because of &lt;em&gt;partial move&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4e63cece27f012d6cb0c3b410a4800e38cdde84" translate="yes" xml:space="preserve">
          <source>In the example below, we implement a &lt;code&gt;Point&lt;/code&gt; type. Because it only stores two integers, we opt-out of ownership semantics with &lt;code&gt;Copy&lt;/code&gt;. Then we can &lt;code&gt;let p2 = p1&lt;/code&gt; without &lt;code&gt;p1&lt;/code&gt; being moved.</source>
          <target state="translated">En el siguiente ejemplo, implementamos un tipo de &lt;code&gt;Point&lt;/code&gt; . Debido a que solo almacena dos enteros, optamos por no participar en la sem&amp;aacute;ntica de propiedad con &lt;code&gt;Copy&lt;/code&gt; . Entonces podemos &lt;code&gt;let p2 = p1&lt;/code&gt; sin que &lt;code&gt;p1&lt;/code&gt; se mueva.</target>
        </trans-unit>
        <trans-unit id="c1f21adbe43e342921b2cfef575b2b17bbbed822" translate="yes" xml:space="preserve">
          <source>In the example, the type cannot have a well-defined size, because it needs to be arbitrarily large (since we would be able to nest &lt;code&gt;ListNode&lt;/code&gt;s to any depth). Specifically,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dce7e71b1b63c6637f941a4911789744e653ecbd" translate="yes" xml:space="preserve">
          <source>In the first case, the output lifetime is inferred to be the same as the unique input lifetime. In the second case, the lifetime is instead inferred to be the same as the lifetime on &lt;code&gt;&amp;amp;self&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self&lt;/code&gt;.</source>
          <target state="translated">En el primer caso, se infiere que la vida &amp;uacute;til de la salida es la misma que la vida &amp;uacute;til de la entrada &amp;uacute;nica. En el segundo caso, en cambio, se infiere que la vida es la misma que la vida en &lt;code&gt;&amp;amp;self&lt;/code&gt; o &lt;code&gt;&amp;amp;mut self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fd5720ef4de3e0fbc4e279820c08cbec7f12fa8" translate="yes" xml:space="preserve">
          <source>In the first code example, the compiler cannot infer what the type of &lt;code&gt;x&lt;/code&gt; should be: &lt;code&gt;Vec&amp;lt;char&amp;gt;&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; are both suitable candidates. To specify which type to use, you can use a type annotation on &lt;code&gt;x&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="874b3aefadd7a8d78fd78ecf2f3f7b20564e4f86" translate="yes" xml:space="preserve">
          <source>In the first example, the lowercased string is represented &lt;code&gt;&quot;cafe\u{301}&quot;&lt;/code&gt; (the last character is an acute accent &lt;a href=&quot;https://en.wikipedia.org/wiki/Combining_character&quot;&gt;combining character&lt;/a&gt;). Unlike the other characters in the string, the combining character will not get mapped to an uppercase variant, resulting in &lt;code&gt;&quot;CAFE\u{301}&quot;&lt;/code&gt;. In the second example, the lowercased string is represented &lt;code&gt;&quot;caf\u{e9}&quot;&lt;/code&gt; (the last character is a single Unicode character representing an 'e' with an acute accent). Since the last character is defined outside the scope of ASCII, it will not get mapped to an uppercase variant, resulting in &lt;code&gt;&quot;CAF\u{e9}&quot;&lt;/code&gt;.</source>
          <target state="translated">En el primer ejemplo, la cadena en min&amp;uacute;sculas se representa &lt;code&gt;&quot;cafe\u{301}&quot;&lt;/code&gt; (el &amp;uacute;ltimo car&amp;aacute;cter es un &lt;a href=&quot;https://en.wikipedia.org/wiki/Combining_character&quot;&gt;car&amp;aacute;cter de combinaci&amp;oacute;n de&lt;/a&gt; acento agudo ). A diferencia de los dem&amp;aacute;s caracteres de la cadena, el car&amp;aacute;cter de combinaci&amp;oacute;n no se asignar&amp;aacute; a una variante en may&amp;uacute;sculas, lo que dar&amp;aacute; como resultado &lt;code&gt;&quot;CAFE\u{301}&quot;&lt;/code&gt; . En el segundo ejemplo, la cadena en min&amp;uacute;sculas se representa &lt;code&gt;&quot;caf\u{e9}&quot;&lt;/code&gt; (el &amp;uacute;ltimo car&amp;aacute;cter es un &amp;uacute;nico car&amp;aacute;cter Unicode que representa una 'e' con acento agudo). Dado que el &amp;uacute;ltimo car&amp;aacute;cter est&amp;aacute; definido fuera del alcance de ASCII, no se asignar&amp;aacute; a una variante en may&amp;uacute;sculas, lo que dar&amp;aacute; como resultado &lt;code&gt;&quot;CAF\u{e9}&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e492b1a4744d12effe76c9a0dc29e53bf345ccf" translate="yes" xml:space="preserve">
          <source>In the first match expression, the value is copied (or moved). In the second match, a reference to the same memory location is bound to the variable value. This syntax is needed because in destructuring subpatterns the &lt;code&gt;&amp;amp;&lt;/code&gt; operator can't be applied to the value's fields. For example, the following is not valid:</source>
          <target state="translated">En la primera expresi&amp;oacute;n de coincidencia, el valor se copia (o mueve). En la segunda coincidencia, una referencia a la misma ubicaci&amp;oacute;n de la memoria est&amp;aacute; vinculada al valor de la variable. Esta sintaxis es necesaria porque al desestructurar subpatrones, el operador &lt;code&gt;&amp;amp;&lt;/code&gt; no se puede aplicar a los campos del valor. Por ejemplo, lo siguiente no es v&amp;aacute;lido:</target>
        </trans-unit>
        <trans-unit id="963b4be1c96ed23abf1f14a5ca37f0831c8c64ef" translate="yes" xml:space="preserve">
          <source>In the following example, we make the &lt;code&gt;call_from_c&lt;/code&gt; function accessible from C code, after it&amp;rsquo;s compiled to a shared library and linked from C:</source>
          <target state="translated">En el siguiente ejemplo, hacemos que la funci&amp;oacute;n &lt;code&gt;call_from_c&lt;/code&gt; sea accesible desde el c&amp;oacute;digo C, despu&amp;eacute;s de que se compila en una biblioteca compartida y se vincula desde C:</target>
        </trans-unit>
        <trans-unit id="ab9b978885ac92b130a921c64c6e0cb297ec938c" translate="yes" xml:space="preserve">
          <source>In the general case, collecting into &lt;code&gt;Arc&amp;lt;[T]&amp;gt;&lt;/code&gt; is done by first collecting into a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. That is, when writing the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="068c8963b2ca078d181d2b0a51e8af10dd52ecbb" translate="yes" xml:space="preserve">
          <source>In the general case, collecting into &lt;code&gt;Rc&amp;lt;[T]&amp;gt;&lt;/code&gt; is done by first collecting into a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. That is, when writing the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acbd16055f21eb6fdaf455bf26541bd9198ef8ac" translate="yes" xml:space="preserve">
          <source>In the implementation of &lt;code&gt;outline_print&lt;/code&gt;, we want to use the &lt;code&gt;Display&lt;/code&gt; trait&amp;rsquo;s functionality. Therefore, we need to specify that the &lt;code&gt;OutlinePrint&lt;/code&gt; trait will work only for types that also implement &lt;code&gt;Display&lt;/code&gt; and provide the functionality that &lt;code&gt;OutlinePrint&lt;/code&gt; needs. We can do that in the trait definition by specifying &lt;code&gt;OutlinePrint: Display&lt;/code&gt;. This technique is similar to adding a trait bound to the trait. Listing 19-22 shows an implementation of the &lt;code&gt;OutlinePrint&lt;/code&gt; trait.</source>
          <target state="translated">En la implementaci&amp;oacute;n de &lt;code&gt;outline_print&lt;/code&gt; , queremos usar la funcionalidad de &lt;code&gt;Display&lt;/code&gt; trait. Por lo tanto, debemos especificar que el rasgo &lt;code&gt;OutlinePrint&lt;/code&gt; funcionar&amp;aacute; solo para tipos que tambi&amp;eacute;n implementan &lt;code&gt;Display&lt;/code&gt; y brindan la funcionalidad que &lt;code&gt;OutlinePrint&lt;/code&gt; necesita. Podemos hacer eso en la definici&amp;oacute;n del rasgo especificando &lt;code&gt;OutlinePrint: Display&lt;/code&gt; . Esta t&amp;eacute;cnica es similar a agregar un rasgo vinculado al rasgo. El listado 19-22 muestra una implementaci&amp;oacute;n del rasgo &lt;code&gt;OutlinePrint&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81a422714f2fa87b38ce332890d1f64c8678f1a7" translate="yes" xml:space="preserve">
          <source>In the last arm, where we&amp;rsquo;ve specified a variable without a range, we do have the value available to use in the arm&amp;rsquo;s code in a variable named &lt;code&gt;id&lt;/code&gt;. The reason is that we&amp;rsquo;ve used the struct field shorthand syntax. But we haven&amp;rsquo;t applied any test to the value in the &lt;code&gt;id&lt;/code&gt; field in this arm, as we did with the first two arms: any value would match this pattern.</source>
          <target state="translated">En el &amp;uacute;ltimo brazo, donde especificamos una variable sin rango, tenemos el valor disponible para usar en el c&amp;oacute;digo del brazo en una variable llamada &lt;code&gt;id&lt;/code&gt; . La raz&amp;oacute;n es que hemos utilizado la sintaxis abreviada del campo de estructura. Pero no hemos aplicado ninguna prueba al valor en el campo &lt;code&gt;id&lt;/code&gt; en este brazo, como hicimos con los dos primeros brazos: cualquier valor coincidir&amp;iacute;a con este patr&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8a42fbeac9d5cd28add8db6a4c34d47e67684d80" translate="yes" xml:space="preserve">
          <source>In the main thread, we collect all the join handles. Then, as we did in Listing 16-2, we call &lt;code&gt;join&lt;/code&gt; on each handle to make sure all the threads finish. At that point, the main thread will acquire the lock and print the result of this program.</source>
          <target state="translated">En el hilo principal, recopilamos todos los identificadores de uni&amp;oacute;n. Luego, como hicimos en el Listado 16-2, llamamos a &lt;code&gt;join&lt;/code&gt; en cada identificador para asegurarnos de que todos los hilos terminen. En ese punto, el hilo principal adquirir&amp;aacute; el bloqueo e imprimir&amp;aacute; el resultado de este programa.</target>
        </trans-unit>
        <trans-unit id="04da7f268aa71a2c6ae0063d0f79d0cc060f8123" translate="yes" xml:space="preserve">
          <source>In the main thread, we&amp;rsquo;re not calling the &lt;code&gt;recv&lt;/code&gt; function explicitly anymore: instead, we&amp;rsquo;re treating &lt;code&gt;rx&lt;/code&gt; as an iterator. For each value received, we&amp;rsquo;re printing it. When the channel is closed, iteration will end.</source>
          <target state="translated">En el hilo principal, ya no llamamos expl&amp;iacute;citamente a la funci&amp;oacute;n &lt;code&gt;recv&lt;/code&gt; : en su lugar, tratamos a &lt;code&gt;rx&lt;/code&gt; como un iterador. Por cada valor recibido, lo imprimimos. Cuando el canal est&amp;aacute; cerrado, la iteraci&amp;oacute;n terminar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="6a6bd022f18026c156e26cea87623c8cec496bfa" translate="yes" xml:space="preserve">
          <source>In the majority of cases, ownership is clear: you know exactly which variable owns a given value. However, there are cases when a single value might have multiple owners. For example, in graph data structures, multiple edges might point to the same node, and that node is conceptually owned by all of the edges that point to it. A node shouldn&amp;rsquo;t be cleaned up unless it doesn&amp;rsquo;t have any edges pointing to it.</source>
          <target state="translated">En la mayor&amp;iacute;a de los casos, la propiedad es clara: sabes exactamente qu&amp;eacute; variable posee un valor dado. Sin embargo, hay casos en los que un &amp;uacute;nico valor puede tener varios propietarios. Por ejemplo, en las estructuras de datos de gr&amp;aacute;ficos, varios bordes pueden apuntar al mismo nodo, y ese nodo es conceptualmente propiedad de todos los bordes que apuntan a &amp;eacute;l. Un nodo no debe limpiarse a menos que no tenga ning&amp;uacute;n borde apuntando hacia &amp;eacute;l.</target>
        </trans-unit>
        <trans-unit id="b4fe9ca25f444c9952c260922e7715e70a50aab9" translate="yes" xml:space="preserve">
          <source>In the match expression for this code, we add a variable called &lt;code&gt;state&lt;/code&gt; to the pattern that matches values of the variant &lt;code&gt;Coin::Quarter&lt;/code&gt;. When a &lt;code&gt;Coin::Quarter&lt;/code&gt; matches, the &lt;code&gt;state&lt;/code&gt; variable will bind to the value of that quarter&amp;rsquo;s state. Then we can use &lt;code&gt;state&lt;/code&gt; in the code for that arm, like so:</source>
          <target state="translated">En la expresi&amp;oacute;n de coincidencia para este c&amp;oacute;digo, agregamos una variable llamada &lt;code&gt;state&lt;/code&gt; al patr&amp;oacute;n que coincide con los valores de la variante &lt;code&gt;Coin::Quarter&lt;/code&gt; . Cuando &lt;code&gt;Coin::Quarter&lt;/code&gt; coincide, la variable de &lt;code&gt;state&lt;/code&gt; se vincular&amp;aacute; al valor del estado de ese trimestre. Entonces podemos usar &lt;code&gt;state&lt;/code&gt; en el c&amp;oacute;digo para ese brazo, as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="37676c5799bfd02feed7afe648d55c20c391e411" translate="yes" xml:space="preserve">
          <source>In the matcher, &lt;code&gt;$&lt;/code&gt;&lt;em&gt;name&lt;/em&gt;&lt;code&gt;:&lt;/code&gt;&lt;em&gt;fragment-specifier&lt;/em&gt; matches a Rust syntax fragment of the kind specified and binds it to the metavariable &lt;code&gt;$&lt;/code&gt;&lt;em&gt;name&lt;/em&gt;. Valid fragment specifiers are:</source>
          <target state="translated">En el comparador, &lt;code&gt;$&lt;/code&gt; &lt;em&gt;name &lt;/em&gt; &lt;code&gt;:&lt;/code&gt; &lt;em&gt;fragment-specifier&lt;/em&gt; coincide con un fragmento de sintaxis de Rust del tipo especificado y lo vincula a la metavariable &lt;code&gt;$&lt;/code&gt; &lt;em&gt;name&lt;/em&gt; . Los especificadores de fragmentos v&amp;aacute;lidos son:</target>
        </trans-unit>
        <trans-unit id="963b3e8473b4ab06c6410ca4e20e74e946590848" translate="yes" xml:space="preserve">
          <source>In the next chapter, we&amp;rsquo;ll look at some collection data structures in the standard library that you can use in your neatly organized code.</source>
          <target state="translated">En el pr&amp;oacute;ximo cap&amp;iacute;tulo, veremos algunas estructuras de datos de colecci&amp;oacute;n en la biblioteca est&amp;aacute;ndar que puede usar en su c&amp;oacute;digo perfectamente organizado.</target>
        </trans-unit>
        <trans-unit id="62f755e3daa908e0af290719bd4bb3bcad378eef" translate="yes" xml:space="preserve">
          <source>In the output in Listing 9-2, line 12 of the backtrace points to the line in our project that&amp;rsquo;s causing the problem: line 4 of &lt;em&gt;src/main.rs&lt;/em&gt;. If we don&amp;rsquo;t want our program to panic, the location pointed to by the first line mentioning a file we wrote is where we should start investigating. In Listing 9-1, where we deliberately wrote code that would panic in order to demonstrate how to use backtraces, the way to fix the panic is to not request an element at index 99 from a vector that only contains 3 items. When your code panics in the future, you&amp;rsquo;ll need to figure out what action the code is taking with what values to cause the panic and what the code should do instead.</source>
          <target state="translated">En la salida del listado 9-2, la l&amp;iacute;nea 12 de los puntos backtrace a la l&amp;iacute;nea en nuestro proyecto que est&amp;aacute; causando el problema: la l&amp;iacute;nea 4 de &lt;em&gt;src / main.rs&lt;/em&gt; . Si no queremos que nuestro programa entre en p&amp;aacute;nico, la ubicaci&amp;oacute;n apuntada por la primera l&amp;iacute;nea que menciona un archivo que escribimos es donde debemos comenzar a investigar. En el Listado 9-1, donde deliberadamente escribimos c&amp;oacute;digo que entrar&amp;iacute;a en p&amp;aacute;nico para demostrar c&amp;oacute;mo usar backtraces, la forma de solucionar el p&amp;aacute;nico es no solicitar un elemento en el &amp;iacute;ndice 99 de un vector que solo contiene 3 elementos. Cuando su c&amp;oacute;digo entre en p&amp;aacute;nico en el futuro, deber&amp;aacute; averiguar qu&amp;eacute; acci&amp;oacute;n est&amp;aacute; tomando el c&amp;oacute;digo con qu&amp;eacute; valores causar el p&amp;aacute;nico y qu&amp;eacute; deber&amp;iacute;a hacer el c&amp;oacute;digo en su lugar.</target>
        </trans-unit>
        <trans-unit id="c97b14b94a5006f9b4ef147bf12f463db5d6141e" translate="yes" xml:space="preserve">
          <source>In the output in Listing 9-2, line 17 of the backtrace points to the line in our project that&amp;rsquo;s causing the problem: line 4 of &lt;em&gt;src/main.rs&lt;/em&gt;. If we don&amp;rsquo;t want our program to panic, the location pointed to by the first line mentioning a file we wrote is where we should start investigating. In Listing 9-1, where we deliberately wrote code that would panic in order to demonstrate how to use backtraces, the way to fix the panic is to not request an element at index 99 from a vector that only contains 3 items. When your code panics in the future, you&amp;rsquo;ll need to figure out what action the code is taking with what values to cause the panic and what the code should do instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a7555618db6cec5efbdcd91e0e2567f5d19799c" translate="yes" xml:space="preserve">
          <source>In the output in Listing 9-2, line 6 of the backtrace points to the line in our project that&amp;rsquo;s causing the problem: line 4 of &lt;em&gt;src/main.rs&lt;/em&gt;. If we don&amp;rsquo;t want our program to panic, the location pointed to by the first line mentioning a file we wrote is where we should start investigating. In Listing 9-1, where we deliberately wrote code that would panic in order to demonstrate how to use backtraces, the way to fix the panic is to not request an element at index 99 from a vector that only contains 3 items. When your code panics in the future, you&amp;rsquo;ll need to figure out what action the code is taking with what values to cause the panic and what the code should do instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff1955a5e30929ce37102fab2f4935897b292825" translate="yes" xml:space="preserve">
          <source>In the previous section, we looked at how the &lt;code&gt;IpAddr&lt;/code&gt; enum let us use Rust&amp;rsquo;s type system to encode more information than just the data into our program. This section explores a case study of &lt;code&gt;Option&lt;/code&gt;, which is another enum defined by the standard library. The &lt;code&gt;Option&lt;/code&gt; type is used in many places because it encodes the very common scenario in which a value could be something or it could be nothing. Expressing this concept in terms of the type system means the compiler can check whether you&amp;rsquo;ve handled all the cases you should be handling; this functionality can prevent bugs that are extremely common in other programming languages.</source>
          <target state="translated">En la secci&amp;oacute;n anterior, vimos c&amp;oacute;mo la enumeraci&amp;oacute;n &lt;code&gt;IpAddr&lt;/code&gt; nos permiti&amp;oacute; usar el sistema de tipos de Rust para codificar m&amp;aacute;s informaci&amp;oacute;n que solo los datos en nuestro programa. Esta secci&amp;oacute;n explora un estudio de caso de &lt;code&gt;Option&lt;/code&gt; , que es otra enumeraci&amp;oacute;n definida por la biblioteca est&amp;aacute;ndar. El tipo &lt;code&gt;Option&lt;/code&gt; se usa en muchos lugares porque codifica el escenario muy com&amp;uacute;n en el que un valor podr&amp;iacute;a ser algo o podr&amp;iacute;a ser nada. Expresar este concepto en t&amp;eacute;rminos del sistema de tipos significa que el compilador puede verificar si ha manejado todos los casos que deber&amp;iacute;a estar manejando; esta funcionalidad puede prevenir errores que son extremadamente comunes en otros lenguajes de programaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7166e371e82ca092dfca006916f5e7d27ed3dcc0" translate="yes" xml:space="preserve">
          <source>In the previous section, we wanted to get the inner &lt;code&gt;T&lt;/code&gt; value out of the &lt;code&gt;Some&lt;/code&gt; case when using &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;; we can also handle &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; using &lt;code&gt;match&lt;/code&gt; as we did with the &lt;code&gt;Coin&lt;/code&gt; enum! Instead of comparing coins, we&amp;rsquo;ll compare the variants of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;, but the way that the &lt;code&gt;match&lt;/code&gt; expression works remains the same.</source>
          <target state="translated">En la secci&amp;oacute;n anterior, quer&amp;iacute;amos obtener el valor &lt;code&gt;T&lt;/code&gt; interno del caso &lt;code&gt;Some&lt;/code&gt; cuando usamos &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; ; &amp;iexcl;tambi&amp;eacute;n podemos manejar &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; usando &lt;code&gt;match&lt;/code&gt; como hicimos con la enumeraci&amp;oacute;n &lt;code&gt;Coin&lt;/code&gt; ! En lugar de comparar monedas, compararemos las variantes de &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; , pero la forma en que funciona la expresi&amp;oacute;n de &lt;code&gt;match&lt;/code&gt; sigue siendo la misma.</target>
        </trans-unit>
        <trans-unit id="021531d5da5d15cfe5b7187998d391941c64c620" translate="yes" xml:space="preserve">
          <source>In the relative path, the logic is the same as the absolute path except for the first step: rather than starting from the crate root, the path starts from &lt;code&gt;front_of_house&lt;/code&gt;. The &lt;code&gt;front_of_house&lt;/code&gt; module is defined within the same module as &lt;code&gt;eat_at_restaurant&lt;/code&gt;, so the relative path starting from the module in which &lt;code&gt;eat_at_restaurant&lt;/code&gt; is defined works. Then, because &lt;code&gt;hosting&lt;/code&gt; and &lt;code&gt;add_to_waitlist&lt;/code&gt; are marked with &lt;code&gt;pub&lt;/code&gt;, the rest of the path works, and this function call is valid!</source>
          <target state="translated">En la ruta relativa, la l&amp;oacute;gica es la misma que la ruta absoluta excepto por el primer paso: en lugar de comenzar desde la ra&amp;iacute;z de la caja, la ruta comienza desde &lt;code&gt;front_of_house&lt;/code&gt; . El m&amp;oacute;dulo &lt;code&gt;front_of_house&lt;/code&gt; se define dentro del mismo m&amp;oacute;dulo que &lt;code&gt;eat_at_restaurant&lt;/code&gt; , por lo que funciona la ruta relativa a partir del m&amp;oacute;dulo en el que se define &lt;code&gt;eat_at_restaurant&lt;/code&gt; . Entonces, debido a que &lt;code&gt;hosting&lt;/code&gt; y &lt;code&gt;add_to_waitlist&lt;/code&gt; est&amp;aacute;n marcados con &lt;code&gt;pub&lt;/code&gt; , el resto de la ruta funciona, &amp;iexcl;y esta llamada de funci&amp;oacute;n es v&amp;aacute;lida!</target>
        </trans-unit>
        <trans-unit id="34eddaeb0b0b8fe0265b13cd54b792a68e5d0a8d" translate="yes" xml:space="preserve">
          <source>In the restaurant industry, some parts of a restaurant are referred to as &lt;em&gt;front of house&lt;/em&gt; and others as &lt;em&gt;back of house&lt;/em&gt;. Front of house is where customers are; this is where hosts seat customers, servers take orders and payment, and bartenders make drinks. Back of house is where the chefs and cooks work in the kitchen, dishwashers clean up, and managers do administrative work.</source>
          <target state="translated">En la industria de los restaurantes, algunas partes de un restaurante se conocen como parte &lt;em&gt;delantera de la casa&lt;/em&gt; y otras como parte &lt;em&gt;trasera de la casa&lt;/em&gt; . El frente de la casa es donde est&amp;aacute;n los clientes; aqu&amp;iacute; es donde los anfitriones sientan a los clientes, los meseros toman los pedidos y el pago y los camareros preparan las bebidas. La parte trasera de la casa es donde los chefs y cocineros trabajan en la cocina, los lavavajillas limpian y los gerentes hacen el trabajo administrativo.</target>
        </trans-unit>
        <trans-unit id="d2fbd57442ab7172a121e226a86228020af2eb14" translate="yes" xml:space="preserve">
          <source>In the second &lt;code&gt;use&lt;/code&gt; statement, we chose the new name &lt;code&gt;IoResult&lt;/code&gt; for the &lt;code&gt;std::io::Result&lt;/code&gt; type, which won&amp;rsquo;t conflict with the &lt;code&gt;Result&lt;/code&gt; from &lt;code&gt;std::fmt&lt;/code&gt; that we&amp;rsquo;ve also brought into scope. Listing 7-15 and Listing 7-16 are considered idiomatic, so the choice is up to you!</source>
          <target state="translated">En la segunda declaraci&amp;oacute;n de &lt;code&gt;use&lt;/code&gt; , elegimos el nuevo nombre &lt;code&gt;IoResult&lt;/code&gt; para el tipo &lt;code&gt;std::io::Result&lt;/code&gt; , que no entrar&amp;aacute; en conflicto con el &lt;code&gt;Result&lt;/code&gt; de &lt;code&gt;std::fmt&lt;/code&gt; que tambi&amp;eacute;n hemos incluido en el alcance. El Listado 7-15 y el Listado 7-16 se consideran idiom&amp;aacute;ticos, &amp;iexcl;as&amp;iacute; que la elecci&amp;oacute;n depende de usted!</target>
        </trans-unit>
        <trans-unit id="adc1d9d12c1d2bddf332118061c6c7cd3ce7bb85" translate="yes" xml:space="preserve">
          <source>In the second arm, where we only have a range specified in the pattern, the code associated with the arm doesn&amp;rsquo;t have a variable that contains the actual value of the &lt;code&gt;id&lt;/code&gt; field. The &lt;code&gt;id&lt;/code&gt; field&amp;rsquo;s value could have been 10, 11, or 12, but the code that goes with that pattern doesn&amp;rsquo;t know which it is. The pattern code isn&amp;rsquo;t able to use the value from the &lt;code&gt;id&lt;/code&gt; field, because we haven&amp;rsquo;t saved the &lt;code&gt;id&lt;/code&gt; value in a variable.</source>
          <target state="translated">En el segundo brazo, donde solo tenemos un rango especificado en el patr&amp;oacute;n, el c&amp;oacute;digo asociado con el brazo no tiene una variable que contenga el valor real del campo &lt;code&gt;id&lt;/code&gt; . El valor del campo &lt;code&gt;id&lt;/code&gt; podr&amp;iacute;a haber sido 10, 11 o 12, pero el c&amp;oacute;digo que acompa&amp;ntilde;a a ese patr&amp;oacute;n no sabe cu&amp;aacute;l es. El c&amp;oacute;digo de patr&amp;oacute;n no puede usar el valor del campo &lt;code&gt;id&lt;/code&gt; , porque no hemos guardado el valor &lt;code&gt;id&lt;/code&gt; en una variable.</target>
        </trans-unit>
        <trans-unit id="555ee2d5bf80e581edd3155ac1632a3804b80f34" translate="yes" xml:space="preserve">
          <source>In the second case, it mentions that a private item &quot;can be accessed&quot; by the current module and its descendants, but the exact meaning of accessing an item depends on what the item is. Accessing a module, for example, would mean looking inside of it (to import more items). On the other hand, accessing a function would mean that it is invoked. Additionally, path expressions and import statements are considered to access an item in the sense that the import/expression is only valid if the destination is in the current visibility scope.</source>
          <target state="translated">En el segundo caso,menciona que un elemento privado &quot;puede ser accedido&quot; por el módulo actual y sus descendientes,pero el significado exacto de acceder a un elemento depende de lo que sea el elemento.Acceder a un módulo,por ejemplo,significaría mirar dentro de él (para importar más artículos).Por otra parte,acceder a una función significaría que se la invoca.Además,se considera que las expresiones de ruta y las declaraciones de importación acceden a un artículo en el sentido de que la importación/expresión sólo es válida si el destino se encuentra en el ámbito de visibilidad actual.</target>
        </trans-unit>
        <trans-unit id="16e34afb2acb9f1c8b1247e4ecd62d975388d5ff" translate="yes" xml:space="preserve">
          <source>In the second error, we tried to bind the &lt;code&gt;Jak&lt;/code&gt; enum directly, which is not possible: you can only bind one of its variants. To do so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75974ca9e444bb30cc1d72502f982a23696566b5" translate="yes" xml:space="preserve">
          <source>In the second error, you can't implement something on an item, only on types. We would need to create a new type if we wanted to do something similar:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3e1b0f0f7f1d23b0a9789a638c11ce7f83e6698" translate="yes" xml:space="preserve">
          <source>In the second you can do it by simply removing &lt;code&gt;'b&lt;/code&gt; so they both use &lt;code&gt;'a&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde08af4b5bbaaf0718281f4cc2fdcf3ef098583" translate="yes" xml:space="preserve">
          <source>In the signature for &lt;code&gt;area&lt;/code&gt;, we use &lt;code&gt;&amp;amp;self&lt;/code&gt; instead of &lt;code&gt;rectangle: &amp;amp;Rectangle&lt;/code&gt; because Rust knows the type of &lt;code&gt;self&lt;/code&gt; is &lt;code&gt;Rectangle&lt;/code&gt; due to this method&amp;rsquo;s being inside the &lt;code&gt;impl Rectangle&lt;/code&gt; context. Note that we still need to use the &lt;code&gt;&amp;amp;&lt;/code&gt; before &lt;code&gt;self&lt;/code&gt;, just as we did in &lt;code&gt;&amp;amp;Rectangle&lt;/code&gt;. Methods can take ownership of &lt;code&gt;self&lt;/code&gt;, borrow &lt;code&gt;self&lt;/code&gt; immutably as we&amp;rsquo;ve done here, or borrow &lt;code&gt;self&lt;/code&gt; mutably, just as they can any other parameter.</source>
          <target state="translated">En la firma para el &lt;code&gt;area&lt;/code&gt; , usamos &lt;code&gt;&amp;amp;self&lt;/code&gt; lugar de &lt;code&gt;rectangle: &amp;amp;Rectangle&lt;/code&gt; porque Rust sabe que el tipo de &lt;code&gt;self&lt;/code&gt; es &lt;code&gt;Rectangle&lt;/code&gt; debido a que este m&amp;eacute;todo est&amp;aacute; dentro del contexto &lt;code&gt;impl Rectangle&lt;/code&gt; . Tenga en cuenta que todav&amp;iacute;a necesitamos usar &lt;code&gt;&amp;amp;&lt;/code&gt; antes de &lt;code&gt;self&lt;/code&gt; , tal como lo hicimos en &lt;code&gt;&amp;amp;Rectangle&lt;/code&gt; . Los m&amp;eacute;todos pueden tomar posesi&amp;oacute;n de &lt;code&gt;self&lt;/code&gt; , tomar prestado &lt;code&gt;self&lt;/code&gt; inmutable como lo hemos hecho aqu&amp;iacute;, o tomar prestado &lt;code&gt;self&lt;/code&gt; mutante, al igual que cualquier otro par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="15bf74e663ebaabe244e5b40c6c296178b0d40e8" translate="yes" xml:space="preserve">
          <source>In the standard library, pointer types generally do not have structural pinning, and thus they do not offer pinning projections. This is why &lt;code&gt;Box&amp;lt;T&amp;gt;: Unpin&lt;/code&gt; holds for all &lt;code&gt;T&lt;/code&gt;. It makes sense to do this for pointer types, because moving the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; does not actually move the &lt;code&gt;T&lt;/code&gt;: the &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; can be freely movable (aka &lt;code&gt;Unpin&lt;/code&gt;) even if the &lt;code&gt;T&lt;/code&gt; is not. In fact, even &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; and &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; are always &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; themselves, for the same reason: their contents (the &lt;code&gt;T&lt;/code&gt;) are pinned, but the pointers themselves can be moved without moving the pinned data. For both &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;, whether the content is pinned is entirely independent of whether the pointer is pinned, meaning pinning is &lt;em&gt;not&lt;/em&gt; structural.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b01eb539066ab2d6a68111a77de7d3391be1abdf" translate="yes" xml:space="preserve">
          <source>In the standard library, pointer types generally do not have structural pinning, and thus they do not offer pinning projections. This is why &lt;code&gt;Box&amp;lt;T&amp;gt;: Unpin&lt;/code&gt; holds for all &lt;code&gt;T&lt;/code&gt;. It makes sense to do this for pointer types, because moving the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; does not actually move the &lt;code&gt;T&lt;/code&gt;: the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; can be freely movable (aka &lt;code&gt;Unpin&lt;/code&gt;) even if the &lt;code&gt;T&lt;/code&gt; is not. In fact, even &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;Pin&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; are always &lt;code&gt;Unpin&lt;/code&gt; themselves, for the same reason: their contents (the &lt;code&gt;T&lt;/code&gt;) are pinned, but the pointers themselves can be moved without moving the pinned data. For both &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;, whether the content is pinned is entirely independent of whether the pointer is pinned, meaning pinning is &lt;em&gt;not&lt;/em&gt; structural.</source>
          <target state="translated">En la biblioteca est&amp;aacute;ndar, los tipos de puntero generalmente no tienen fijaci&amp;oacute;n estructural y, por lo tanto, no ofrecen proyecciones de fijaci&amp;oacute;n. Esta es la raz&amp;oacute;n por &lt;code&gt;Box&amp;lt;T&amp;gt;: Unpin&lt;/code&gt; se mantiene para todos los &lt;code&gt;T&lt;/code&gt; . Tiene sentido hacer esto para los tipos de puntero, porque mover la &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; no mueve realmente la &lt;code&gt;T&lt;/code&gt; : la &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; puede moverse libremente (tambi&amp;eacute;n &lt;code&gt;Unpin&lt;/code&gt; como Desanclar ) incluso si la &lt;code&gt;T&lt;/code&gt; no lo es. De hecho, incluso el &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; y el &lt;code&gt;Pin&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; siempre se &lt;code&gt;Unpin&lt;/code&gt; , por la misma raz&amp;oacute;n: su contenido (la &lt;code&gt;T&lt;/code&gt; ) est&amp;aacute; anclado, pero los punteros en s&amp;iacute; se pueden mover sin mover los datos anclados. Para ambos &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; y &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; , si el contenido est&amp;aacute; anclado es totalmente independiente de si el puntero est&amp;aacute; anclado, lo que significa que la fijaci&amp;oacute;n &lt;em&gt;no&lt;/em&gt; es estructural.</target>
        </trans-unit>
        <trans-unit id="69a1bd27469eb2f59075cae2a36951b2f4c30b0e" translate="yes" xml:space="preserve">
          <source>In the test, we&amp;rsquo;re testing what happens when the &lt;code&gt;LimitTracker&lt;/code&gt; is told to set &lt;code&gt;value&lt;/code&gt; to something that is more than 75 percent of the &lt;code&gt;max&lt;/code&gt; value. First, we create a new &lt;code&gt;MockMessenger&lt;/code&gt;, which will start with an empty list of messages. Then we create a new &lt;code&gt;LimitTracker&lt;/code&gt; and give it a reference to the new &lt;code&gt;MockMessenger&lt;/code&gt; and a &lt;code&gt;max&lt;/code&gt; value of 100. We call the &lt;code&gt;set_value&lt;/code&gt; method on the &lt;code&gt;LimitTracker&lt;/code&gt; with a value of 80, which is more than 75 percent of 100. Then we assert that the list of messages that the &lt;code&gt;MockMessenger&lt;/code&gt; is keeping track of should now have one message in it.</source>
          <target state="translated">En la prueba, estamos probando lo que sucede cuando se le dice al &lt;code&gt;LimitTracker&lt;/code&gt; que establezca un &lt;code&gt;value&lt;/code&gt; en algo que sea m&amp;aacute;s del 75 por ciento del valor &lt;code&gt;max&lt;/code&gt; . Primero, creamos un nuevo &lt;code&gt;MockMessenger&lt;/code&gt; , que comenzar&amp;aacute; con una lista vac&amp;iacute;a de mensajes. Luego creamos un nuevo &lt;code&gt;LimitTracker&lt;/code&gt; y le damos una referencia al nuevo &lt;code&gt;MockMessenger&lt;/code&gt; y un valor &lt;code&gt;max&lt;/code&gt; de 100. Llamamos al m&amp;eacute;todo &lt;code&gt;set_value&lt;/code&gt; en el &lt;code&gt;LimitTracker&lt;/code&gt; con un valor de 80, que es m&amp;aacute;s del 75 por ciento de 100. Luego afirmamos que el La lista de mensajes de los que &lt;code&gt;MockMessenger&lt;/code&gt; est&amp;aacute; realizando un seguimiento ahora deber&amp;iacute;a tener un mensaje.</target>
        </trans-unit>
        <trans-unit id="adba8ce512afb3223e0e44bbc4efd34311d66e90" translate="yes" xml:space="preserve">
          <source>In the third case, we tried to only expect one variant of the &lt;code&gt;Wizard&lt;/code&gt; enum, which is not possible. To make this work, we need to using pattern matching over the &lt;code&gt;Wizard&lt;/code&gt; enum:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fe4d3d8b095874ffa846390a6fba933c59176e6" translate="yes" xml:space="preserve">
          <source>In the transcriber, metavariables are referred to simply by &lt;code&gt;$&lt;/code&gt;&lt;em&gt;name&lt;/em&gt;, since the fragment kind is specified in the matcher. Metavariables are replaced with the syntax element that matched them. The keyword metavariable &lt;code&gt;$crate&lt;/code&gt; can be used to refer to the current crate; see &lt;a href=&quot;#hygiene&quot;&gt;Hygiene&lt;/a&gt; below. Metavariables can be transcribed more than once or not at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="474cfc53c29ed4a7f5438f6a16ce96a820777966" translate="yes" xml:space="preserve">
          <source>In the transcriber, metavariables are referred to simply by &lt;code&gt;$&lt;/code&gt;&lt;em&gt;name&lt;/em&gt;, since the fragment kind is specified in the matcher. Metavariables are replaced with the syntax element that matched them. The keyword metavariable &lt;code&gt;$crate&lt;/code&gt; can be used to refer to the current crate; see &lt;a href=&quot;macros-by-example#hygiene&quot;&gt;Hygiene&lt;/a&gt; below. Metavariables can be transcribed more than once or not at all.</source>
          <target state="translated">En el transcriptor, las metavariables se denominan simplemente por &lt;code&gt;$&lt;/code&gt; &lt;em&gt;name&lt;/em&gt; , ya que el tipo de fragmento se especifica en el comparador. Las metavariables se reemplazan con el elemento de sintaxis que las empareja. La palabra clave metavariable &lt;code&gt;$crate&lt;/code&gt; puede usarse para referirse a la caja actual; consulte &lt;a href=&quot;macros-by-example#hygiene&quot;&gt;Higiene a&lt;/a&gt; continuaci&amp;oacute;n. Las metavariables se pueden transcribir m&amp;aacute;s de una vez o no se pueden transcribir en absoluto.</target>
        </trans-unit>
        <trans-unit id="fc28b1beae2c194779de6e426a53754bfb37f82e" translate="yes" xml:space="preserve">
          <source>In the workout generator example, we only used closures as inline anonymous functions. However, closures have an additional capability that functions don&amp;rsquo;t have: they can capture their environment and access variables from the scope in which they&amp;rsquo;re defined.</source>
          <target state="translated">En el ejemplo del generador de ejercicios, solo usamos cierres como funciones an&amp;oacute;nimas en l&amp;iacute;nea. Sin embargo, los cierres tienen una capacidad adicional que las funciones no tienen: pueden capturar su entorno y acceder a las variables desde el &amp;aacute;mbito en el que est&amp;aacute;n definidos.</target>
        </trans-unit>
        <trans-unit id="402986500120f551bc8e41d90bdabaccacec9185" translate="yes" xml:space="preserve">
          <source>In the worst case, the algorithm allocates temporary storage in a &lt;code&gt;Vec&amp;lt;(K, usize)&amp;gt;&lt;/code&gt; the length of the slice.</source>
          <target state="translated">En el peor de los casos, el algoritmo asigna almacenamiento temporal en un &lt;code&gt;Vec&amp;lt;(K, usize)&amp;gt;&lt;/code&gt; la longitud del segmento.</target>
        </trans-unit>
        <trans-unit id="2792c27ad83efd64abffe24df3a1fb1485fd08bf" translate="yes" xml:space="preserve">
          <source>In these examples, types of the &lt;code&gt;ba*&lt;/code&gt; are found by LUB coercion. And the compiler checks whether LUB coercion result of &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt; is &lt;code&gt;i32&lt;/code&gt; in the processing of the function &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bc14d5532165c49508408bd484b7e97e6ac2646" translate="yes" xml:space="preserve">
          <source>In this appendix, we provide a reference of all the traits in the standard library that you can use with &lt;code&gt;derive&lt;/code&gt;. Each section covers:</source>
          <target state="translated">En este ap&amp;eacute;ndice, proporcionamos una referencia de todos los rasgos en la biblioteca est&amp;aacute;ndar que puede usar con &lt;code&gt;derive&lt;/code&gt; . Cada secci&amp;oacute;n cubre:</target>
        </trans-unit>
        <trans-unit id="0046a6cf07943993e17ce12f3c78298391a2264f" translate="yes" xml:space="preserve">
          <source>In this appendix, we talk about some useful development tools that the Rust project provides. We&amp;rsquo;ll look at automatic formatting, quick ways to apply warning fixes, a linter, and integrating with IDEs.</source>
          <target state="translated">En este ap&amp;eacute;ndice, hablamos sobre algunas herramientas de desarrollo &amp;uacute;tiles que proporciona el proyecto Rust. Veremos el formato autom&amp;aacute;tico, las formas r&amp;aacute;pidas de aplicar correcciones de advertencia, un linter y la integraci&amp;oacute;n con IDE.</target>
        </trans-unit>
        <trans-unit id="ac9b1080783742689a97db16c3344339516e90c0" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;Foo&lt;/code&gt; is undefined, so it inherently isn't anything, and definitely not a struct.</source>
          <target state="translated">En este caso, &lt;code&gt;Foo&lt;/code&gt; no est&amp;aacute; definido, por lo que inherentemente no es nada y definitivamente no es una estructura.</target>
        </trans-unit>
        <trans-unit id="afe608724d7fcb6b165ca3da57f4af8c6e2f8834" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;Question&lt;/code&gt; would need to implement the &lt;code&gt;std::ops::Not&lt;/code&gt; trait in order to be able to use &lt;code&gt;!&lt;/code&gt; on it. Let's implement it:</source>
          <target state="translated">En este caso, &lt;code&gt;Question&lt;/code&gt; necesitar&amp;iacute;a implementar el rasgo &lt;code&gt;std::ops::Not&lt;/code&gt; para poder usar &lt;code&gt;!&lt;/code&gt; en eso. Implement&amp;eacute;moslo:</target>
        </trans-unit>
        <trans-unit id="4b7473dc279144e44448cca5746abb04e0fa8694" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;c_double&lt;/code&gt; has the same size as &lt;code&gt;f64&lt;/code&gt; so we can use it directly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3b4ba6190447ccb2a7d84efd7c0391f36cf1b3c" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;foo&lt;/code&gt; is defined, but is not a struct, so Rust can't use it as one.</source>
          <target state="translated">En este caso, &lt;code&gt;foo&lt;/code&gt; est&amp;aacute; definido, pero no es una estructura, por lo que Rust no puede usarlo como uno.</target>
        </trans-unit>
        <trans-unit id="e3897adfb1b49645b05c0b83e391e1fc19ac894e" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;len&lt;/code&gt; will be 4, which means the vector storing the string &amp;ldquo;Hola&amp;rdquo; is 4 bytes long. Each of these letters takes 1 byte when encoded in UTF-8. But what about the following line? (Note that this string begins with the capital Cyrillic letter Ze, not the Arabic number 3.)</source>
          <target state="translated">En este caso, &lt;code&gt;len&lt;/code&gt; ser&amp;aacute; 4, lo que significa que el vector que almacena la cadena &quot;Hola&quot; tiene 4 bytes de longitud. Cada una de estas letras ocupa 1 byte cuando se codifica en UTF-8. Pero, &amp;iquest;qu&amp;eacute; pasa con la siguiente l&amp;iacute;nea? (Tenga en cuenta que esta cadena comienza con la letra cir&amp;iacute;lica may&amp;uacute;scula Ze, no el n&amp;uacute;mero ar&amp;aacute;bigo 3).</target>
        </trans-unit>
        <trans-unit id="8561b972a9830d06a3e257ff13fef28acb8d1808" translate="yes" xml:space="preserve">
          <source>In this case, borrowing &lt;code&gt;x&lt;/code&gt; mutably is not possible, because &lt;code&gt;x&lt;/code&gt; is not &lt;code&gt;mut&lt;/code&gt;. But at the same time, borrowing &lt;code&gt;x&lt;/code&gt; immutably would make the assignment illegal, because a &lt;code&gt;&amp;amp; &amp;amp;mut&lt;/code&gt; reference may not be unique, so it cannot safely be used to modify a value. So a unique immutable borrow is used: it borrows &lt;code&gt;x&lt;/code&gt; immutably, but like a mutable borrow, it must be unique. In the above example, uncommenting the declaration of &lt;code&gt;y&lt;/code&gt; will produce an error because it would violate the uniqueness of the closure's borrow of &lt;code&gt;x&lt;/code&gt;; the declaration of z is valid because the closure's lifetime has expired at the end of the block, releasing the borrow.</source>
          <target state="translated">En este caso, no es posible tomar prestado &lt;code&gt;x&lt;/code&gt; de manera mutante, porque &lt;code&gt;x&lt;/code&gt; no es &lt;code&gt;mut&lt;/code&gt; . Pero al mismo tiempo, tomar prestado &lt;code&gt;x&lt;/code&gt; de manera inmutable har&amp;iacute;a ilegal la asignaci&amp;oacute;n, porque una referencia &lt;code&gt;&amp;amp; &amp;amp;mut&lt;/code&gt; puede no ser &amp;uacute;nica, por lo que no se puede usar de manera segura para modificar un valor. Por tanto, se utiliza un pr&amp;eacute;stamo &amp;uacute;nico e inmutable: se pide prestado &lt;code&gt;x&lt;/code&gt; inmutablemente, pero como un pr&amp;eacute;stamo mutable, debe ser &amp;uacute;nico. En el ejemplo anterior, descomentar la declaraci&amp;oacute;n de &lt;code&gt;y&lt;/code&gt; producir&amp;aacute; un error porque violar&amp;iacute;a la unicidad del pr&amp;eacute;stamo de &lt;code&gt;x&lt;/code&gt; del cierre ; la declaraci&amp;oacute;n de z es v&amp;aacute;lida porque la vida &amp;uacute;til del cierre ha expirado al final del bloque, liberando el pr&amp;eacute;stamo.</target>
        </trans-unit>
        <trans-unit id="bf5da830ba52c31b3f48f71542b74085fca253da" translate="yes" xml:space="preserve">
          <source>In this case, right after we create the reference cycle, the program ends. The consequences of this cycle aren&amp;rsquo;t very dire. However, if a more complex program allocated lots of memory in a cycle and held onto it for a long time, the program would use more memory than it needed and might overwhelm the system, causing it to run out of available memory.</source>
          <target state="translated">En este caso, justo despu&amp;eacute;s de crear el ciclo de referencia, el programa finaliza. Las consecuencias de este ciclo no son muy graves. Sin embargo, si un programa m&amp;aacute;s complejo asign&amp;oacute; mucha memoria en un ciclo y la retuvo durante mucho tiempo, el programa usar&amp;iacute;a m&amp;aacute;s memoria de la que necesitaba y podr&amp;iacute;a sobrecargar el sistema, provocando que se quedara sin memoria disponible.</target>
        </trans-unit>
        <trans-unit id="94ade146c6864efc0d837c6a05c5b82eb67849f1" translate="yes" xml:space="preserve">
          <source>In this case, the compiler cannot infer what the type of &lt;code&gt;x&lt;/code&gt; should be: &lt;code&gt;Vec&amp;lt;char&amp;gt;&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; are both suitable candidates. To specify which type to use, you can use a type annotation on &lt;code&gt;x&lt;/code&gt;:</source>
          <target state="translated">En este caso, el compilador no puede inferir cu&amp;aacute;l deber&amp;iacute;a ser el tipo de &lt;code&gt;x&lt;/code&gt; : &lt;code&gt;Vec&amp;lt;char&amp;gt;&lt;/code&gt; y &lt;code&gt;String&lt;/code&gt; son candidatos adecuados. Para especificar qu&amp;eacute; tipo usar, puede usar una anotaci&amp;oacute;n de tipo en &lt;code&gt;x&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f275640cc613a55c1aac0d980097965aad345a42" translate="yes" xml:space="preserve">
          <source>In this case, the line indicated is part of our code, and if we go to that line, we see the &lt;code&gt;panic!&lt;/code&gt; macro call. In other cases, the &lt;code&gt;panic!&lt;/code&gt; call might be in code that our code calls, and the filename and line number reported by the error message will be someone else&amp;rsquo;s code where the &lt;code&gt;panic!&lt;/code&gt; macro is called, not the line of our code that eventually led to the &lt;code&gt;panic!&lt;/code&gt; call. We can use the backtrace of the functions the &lt;code&gt;panic!&lt;/code&gt; call came from to figure out the part of our code that is causing the problem. We&amp;rsquo;ll discuss what a backtrace is in more detail next.</source>
          <target state="translated">En este caso, la l&amp;iacute;nea indicada es parte de nuestro c&amp;oacute;digo, y si vamos a esa l&amp;iacute;nea, &amp;iexcl;vemos el &lt;code&gt;panic!&lt;/code&gt; llamada macro. En otros casos, &amp;iexcl;el &lt;code&gt;panic!&lt;/code&gt; La llamada puede estar en el c&amp;oacute;digo que llama nuestro c&amp;oacute;digo, y el nombre de archivo y el n&amp;uacute;mero de l&amp;iacute;nea informado por el mensaje de error ser&amp;aacute; el c&amp;oacute;digo de otra persona donde el &lt;code&gt;panic!&lt;/code&gt; se llama macro, no la l&amp;iacute;nea de nuestro c&amp;oacute;digo que eventualmente llev&amp;oacute; al &lt;code&gt;panic!&lt;/code&gt; llamada. &amp;iexcl;Podemos usar el seguimiento de las funciones del &lt;code&gt;panic!&lt;/code&gt; provino de la llamada para averiguar la parte de nuestro c&amp;oacute;digo que est&amp;aacute; causando el problema. A continuaci&amp;oacute;n, analizaremos con m&amp;aacute;s detalle qu&amp;eacute; es un backtrace.</target>
        </trans-unit>
        <trans-unit id="a03c0650d25cf706ca4c711a0b4fa0c7cdd46367" translate="yes" xml:space="preserve">
          <source>In this case, you need to implement the &lt;code&gt;chocolate&lt;/code&gt; method to fix the error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dfdeb564b13d0de24ae4a70c8a6c9f64176934b" translate="yes" xml:space="preserve">
          <source>In this chapter and throughout the book, we&amp;rsquo;ll show some commands used in the terminal. Lines that you should enter in a terminal all start with &lt;code&gt;$&lt;/code&gt;. You don&amp;rsquo;t need to type in the &lt;code&gt;$&lt;/code&gt; character; it indicates the start of each command. Lines that don&amp;rsquo;t start with &lt;code&gt;$&lt;/code&gt; typically show the output of the previous command. Additionally, PowerShell-specific examples will use &lt;code&gt;&amp;gt;&lt;/code&gt; rather than &lt;code&gt;$&lt;/code&gt;.</source>
          <target state="translated">En este cap&amp;iacute;tulo y a lo largo del libro, mostraremos algunos comandos utilizados en la terminal. Todas las l&amp;iacute;neas que debe ingresar en una terminal comienzan con &lt;code&gt;$&lt;/code&gt; . No es necesario escribir el car&amp;aacute;cter &lt;code&gt;$&lt;/code&gt; ; indica el inicio de cada comando. Las l&amp;iacute;neas que no comienzan con &lt;code&gt;$&lt;/code&gt; suelen mostrar el resultado del comando anterior. Adem&amp;aacute;s, los ejemplos espec&amp;iacute;ficos de PowerShell usar&amp;aacute;n &lt;code&gt;&amp;gt;&lt;/code&gt; en lugar de &lt;code&gt;$&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f1d6f9bd53aa4df418aa201b887fdd6df55aeab" translate="yes" xml:space="preserve">
          <source>In this chapter we&amp;rsquo;ll look at &lt;em&gt;enumerations&lt;/em&gt;, also referred to as &lt;em&gt;enums&lt;/em&gt;. Enums allow you to define a type by enumerating its possible &lt;em&gt;variants&lt;/em&gt;. First, we&amp;rsquo;ll define and use an enum to show how an enum can encode meaning along with data. Next, we&amp;rsquo;ll explore a particularly useful enum, called &lt;code&gt;Option&lt;/code&gt;, which expresses that a value can be either something or nothing. Then we&amp;rsquo;ll look at how pattern matching in the &lt;code&gt;match&lt;/code&gt; expression makes it easy to run different code for different values of an enum. Finally, we&amp;rsquo;ll cover how the &lt;code&gt;if let&lt;/code&gt; construct is another convenient and concise idiom available to you to handle enums in your code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="511940d9b79e52eebc6c566f728bbaeb0dd1dd34" translate="yes" xml:space="preserve">
          <source>In this chapter we&amp;rsquo;ll look at &lt;em&gt;enumerations&lt;/em&gt;, also referred to as &lt;em&gt;enums&lt;/em&gt;. Enums allow you to define a type by enumerating its possible values. First, we&amp;rsquo;ll define and use an enum to show how an enum can encode meaning along with data. Next, we&amp;rsquo;ll explore a particularly useful enum, called &lt;code&gt;Option&lt;/code&gt;, which expresses that a value can be either something or nothing. Then we&amp;rsquo;ll look at how pattern matching in the &lt;code&gt;match&lt;/code&gt; expression makes it easy to run different code for different values of an enum. Finally, we&amp;rsquo;ll cover how the &lt;code&gt;if let&lt;/code&gt; construct is another convenient and concise idiom available to you to handle enums in your code.</source>
          <target state="translated">En este cap&amp;iacute;tulo veremos las &lt;em&gt;enumeraciones&lt;/em&gt; , tambi&amp;eacute;n denominadas &lt;em&gt;enums&lt;/em&gt; . Las enumeraciones le permiten definir un tipo enumerando sus posibles valores. Primero, definiremos y usaremos una enumeraci&amp;oacute;n para mostrar c&amp;oacute;mo una enumeraci&amp;oacute;n puede codificar el significado junto con los datos. A continuaci&amp;oacute;n, exploraremos una enumeraci&amp;oacute;n particularmente &amp;uacute;til, llamada &lt;code&gt;Option&lt;/code&gt; , que expresa que un valor puede ser algo o nada. Luego, veremos c&amp;oacute;mo la coincidencia de patrones en la expresi&amp;oacute;n de &lt;code&gt;match&lt;/code&gt; facilita la ejecuci&amp;oacute;n de c&amp;oacute;digo diferente para diferentes valores de una enumeraci&amp;oacute;n. Finalmente, cubriremos c&amp;oacute;mo la construcci&amp;oacute;n &lt;code&gt;if let&lt;/code&gt; es otro modismo conveniente y conciso disponible para manejar enumeraciones en su c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="54bfe40f65e4baf089b3fdf58b27393a8784f4c8" translate="yes" xml:space="preserve">
          <source>In this chapter, we won&amp;rsquo;t debate the issue of what functional programming is or isn&amp;rsquo;t but will instead discuss some features of Rust that are similar to features in many languages often referred to as functional.</source>
          <target state="translated">En este cap&amp;iacute;tulo, no debatiremos el tema de qu&amp;eacute; es o no es la programaci&amp;oacute;n funcional, sino que analizaremos algunas caracter&amp;iacute;sticas de Rust que son similares a las caracter&amp;iacute;sticas en muchos lenguajes que a menudo se denominan funcionales.</target>
        </trans-unit>
        <trans-unit id="1a7486659e0b2248f370c5b62acbfa92d0246aa8" translate="yes" xml:space="preserve">
          <source>In this chapter, we&amp;rsquo;ll cover all these features, discuss how they interact, and explain how to use them to manage scope. By the end, you should have a solid understanding of the module system and be able to work with scopes like a pro!</source>
          <target state="translated">En este cap&amp;iacute;tulo, cubriremos todas estas caracter&amp;iacute;sticas, discutiremos c&amp;oacute;mo interact&amp;uacute;an y explicaremos c&amp;oacute;mo usarlas para administrar el alcance. Al final, deber&amp;aacute;s tener un conocimiento s&amp;oacute;lido del sistema de m&amp;oacute;dulos y ser capaz de trabajar con osciloscopios como un profesional.</target>
        </trans-unit>
        <trans-unit id="323ae7b14fd96e68551f003142bf4b84170544d5" translate="yes" xml:space="preserve">
          <source>In this chapter, we&amp;rsquo;ll cover:</source>
          <target state="translated">En este cap&amp;iacute;tulo, cubriremos:</target>
        </trans-unit>
        <trans-unit id="a4639a7fb71c7cc2724cbe31da70376d99c56baa" translate="yes" xml:space="preserve">
          <source>In this code, the first and last value are matched with &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt;. The &lt;code&gt;..&lt;/code&gt; will match and ignore everything in the middle.</source>
          <target state="translated">En este c&amp;oacute;digo, el primer y &amp;uacute;ltimo valor se comparan con el &lt;code&gt;first&lt;/code&gt; y el &lt;code&gt;last&lt;/code&gt; . El &lt;code&gt;..&lt;/code&gt; coincidir&amp;aacute; e ignorar&amp;aacute; todo lo que est&amp;eacute; en el medio.</target>
        </trans-unit>
        <trans-unit id="145a83e849a55e3baebf66ad497473ddcd7f5f55" translate="yes" xml:space="preserve">
          <source>In this code, the same thing happens as in the &lt;code&gt;match&lt;/code&gt; in Listing 19-26: Rust sees that &lt;code&gt;val&lt;/code&gt; has the type &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;panic!&lt;/code&gt; has the type &lt;code&gt;!&lt;/code&gt;, so the result of the overall &lt;code&gt;match&lt;/code&gt; expression is &lt;code&gt;T&lt;/code&gt;. This code works because &lt;code&gt;panic!&lt;/code&gt; doesn&amp;rsquo;t produce a value; it ends the program. In the &lt;code&gt;None&lt;/code&gt; case, we won&amp;rsquo;t be returning a value from &lt;code&gt;unwrap&lt;/code&gt;, so this code is valid.</source>
          <target state="translated">En este c&amp;oacute;digo, sucede lo mismo que en la &lt;code&gt;match&lt;/code&gt; Listado 19-26: Rust ve que &lt;code&gt;val&lt;/code&gt; tiene el tipo &lt;code&gt;T&lt;/code&gt; y &lt;code&gt;panic!&lt;/code&gt; tiene el tipo &lt;code&gt;!&lt;/code&gt; , Por lo que el resultado global del &lt;code&gt;match&lt;/code&gt; expresi&amp;oacute;n es &lt;code&gt;T&lt;/code&gt; . &amp;iexcl;Este c&amp;oacute;digo funciona porque &lt;code&gt;panic!&lt;/code&gt; no produce un valor; finaliza el programa. En el caso &lt;code&gt;None&lt;/code&gt; , no devolveremos un valor de &lt;code&gt;unwrap&lt;/code&gt; , por lo que este c&amp;oacute;digo es v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="844247dc89592da735fc5622f72eb35876e2a2a2" translate="yes" xml:space="preserve">
          <source>In this code, you have two ways to solve this issue:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f5f63902ac52a2fdb77ae9b0aaf168362307239" translate="yes" xml:space="preserve">
          <source>In this context, by &lt;em&gt;runtime&lt;/em&gt; we mean code that is included by the language in every binary. This code can be large or small depending on the language, but every non-assembly language will have some amount of runtime code. For that reason, colloquially when people say a language has &amp;ldquo;no runtime,&amp;rdquo; they often mean &amp;ldquo;small runtime.&amp;rdquo; Smaller runtimes have fewer features but have the advantage of resulting in smaller binaries, which make it easier to combine the language with other languages in more contexts. Although many languages are okay with increasing the runtime size in exchange for more features, Rust needs to have nearly no runtime and cannot compromise on being able to call into C to maintain performance.</source>
          <target state="translated">En este contexto, por &lt;em&gt;tiempo&lt;/em&gt; de &lt;em&gt;ejecuci&amp;oacute;n&lt;/em&gt; nos referimos al c&amp;oacute;digo que est&amp;aacute; incluido por el lenguaje en cada binario. Este c&amp;oacute;digo puede ser grande o peque&amp;ntilde;o seg&amp;uacute;n el lenguaje, pero cada lenguaje que no sea ensamblador tendr&amp;aacute; cierta cantidad de c&amp;oacute;digo de tiempo de ejecuci&amp;oacute;n. Por esa raz&amp;oacute;n, coloquialmente cuando las personas dicen que un idioma &quot;no tiene tiempo de ejecuci&amp;oacute;n&quot;, a menudo se refieren a &quot;peque&amp;ntilde;o tiempo de ejecuci&amp;oacute;n&quot;. Los tiempos de ejecuci&amp;oacute;n m&amp;aacute;s peque&amp;ntilde;os tienen menos funciones, pero tienen la ventaja de generar binarios m&amp;aacute;s peque&amp;ntilde;os, lo que facilita la combinaci&amp;oacute;n del idioma con otros idiomas en m&amp;aacute;s contextos. Aunque muchos lenguajes est&amp;aacute;n de acuerdo con aumentar el tama&amp;ntilde;o del tiempo de ejecuci&amp;oacute;n a cambio de m&amp;aacute;s funciones, Rust no necesita casi ning&amp;uacute;n tiempo de ejecuci&amp;oacute;n y no puede comprometer la posibilidad de llamar a C para mantener el rendimiento.</target>
        </trans-unit>
        <trans-unit id="3f10f5106c28699182d72488c5b199580b51f515" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;2&lt;/code&gt; is destroyed right after the assignment, which means that &lt;code&gt;ptr&lt;/code&gt; now points to an unavailable location.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16ee00cd14e3198e4bb4ed77351c13a68c4d2964" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;BoxCar&lt;/code&gt; has two super-traits: &lt;code&gt;Vehicle&lt;/code&gt; and &lt;code&gt;Box&lt;/code&gt;. Both of these traits define an associated type &lt;code&gt;Color&lt;/code&gt;. &lt;code&gt;BoxCar&lt;/code&gt; inherits two types with that name from both super-traits. Because of this, we need to use the fully qualified path syntax to refer to the appropriate &lt;code&gt;Color&lt;/code&gt; associated type, either &lt;code&gt;&amp;lt;BoxCar as Vehicle&amp;gt;::Color&lt;/code&gt; or &lt;code&gt;&amp;lt;BoxCar as Box&amp;gt;::Color&lt;/code&gt;, but this syntax is not allowed to be used in a function signature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e0ee0316ee57e8497270b5ce77464ecb56adca2" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;Cat&lt;/code&gt; is a &lt;em&gt;struct-like enum variant&lt;/em&gt;, whereas &lt;code&gt;Dog&lt;/code&gt; is simply called an enum variant. Each enum instance has a &lt;em&gt;discriminant&lt;/em&gt; which is an integer associated to it that is used to determine which variant it holds. An opaque reference to this discriminant can be obtained with the &lt;a href=&quot;../../std/mem/fn.discriminant&quot;&gt;&lt;code&gt;mem::discriminant&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">En este ejemplo, &lt;code&gt;Cat&lt;/code&gt; es una &lt;em&gt;variante de enumeraci&amp;oacute;n similar a&lt;/em&gt; una &lt;em&gt;estructura&lt;/em&gt; , mientras que &lt;code&gt;Dog&lt;/code&gt; simplemente se denomina variante de enumeraci&amp;oacute;n. Cada instancia de enumeraci&amp;oacute;n tiene un &lt;em&gt;discriminante&lt;/em&gt; que es un n&amp;uacute;mero entero asociado que se usa para determinar qu&amp;eacute; variante contiene. Se puede obtener una referencia opaca a este discriminante con la funci&amp;oacute;n &lt;a href=&quot;../../std/mem/fn.discriminant&quot;&gt; &lt;code&gt;mem::discriminant&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7bb9799e70052b9e454a954f47a55d73983d300f" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;Foo&lt;/code&gt; defines an associated type &lt;code&gt;A&lt;/code&gt;. &lt;code&gt;Bar&lt;/code&gt; inherits that type from &lt;code&gt;Foo&lt;/code&gt;, and defines another associated type of the same name. As a result, when we attempt to use &lt;code&gt;Self::A&lt;/code&gt;, it's ambiguous whether we mean the &lt;code&gt;A&lt;/code&gt; defined by &lt;code&gt;Foo&lt;/code&gt; or the one defined by &lt;code&gt;Bar&lt;/code&gt;.</source>
          <target state="translated">En este ejemplo, &lt;code&gt;Foo&lt;/code&gt; define un tipo &lt;code&gt;A&lt;/code&gt; asociado . &lt;code&gt;Bar&lt;/code&gt; hereda ese tipo de &lt;code&gt;Foo&lt;/code&gt; y define otro tipo asociado del mismo nombre. Como resultado, cuando intentamos usar &lt;code&gt;Self::A&lt;/code&gt; , es ambiguo si nos referimos a la &lt;code&gt;A&lt;/code&gt; definida por &lt;code&gt;Foo&lt;/code&gt; o la definida por &lt;code&gt;Bar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8cedc14f701bbdf96ac8102b9f064b1dca2f26cb" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;Y&lt;/code&gt; cannot refer to &lt;code&gt;X&lt;/code&gt; here. To fix this, the value can be extracted as a const and then used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea4ed47b5eac4878ae970fa360382b182707dcb9" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;string1&lt;/code&gt; is valid until the end of the outer scope, &lt;code&gt;string2&lt;/code&gt; is valid until the end of the inner scope, and &lt;code&gt;result&lt;/code&gt; references something that is valid until the end of the inner scope. Run this code, and you&amp;rsquo;ll see that the borrow checker approves of this code; it will compile and print &lt;code&gt;The longest string is long string is long&lt;/code&gt;.</source>
          <target state="translated">En este ejemplo, &lt;code&gt;string1&lt;/code&gt; es v&amp;aacute;lido hasta el final del alcance externo, &lt;code&gt;string2&lt;/code&gt; es v&amp;aacute;lido hasta el final del alcance interno y el &lt;code&gt;result&lt;/code&gt; ado hace referencia a algo que es v&amp;aacute;lido hasta el final del alcance interno. Ejecute este c&amp;oacute;digo y ver&amp;aacute; que el verificador de pr&amp;eacute;stamos aprueba este c&amp;oacute;digo; compilar&amp;aacute; e imprimir&amp;aacute; &lt;code&gt;The longest string is long string is long&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a21a4f7cf44738665bcf722c117e87d97dd2b44" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;value&lt;/code&gt; is mutably borrowed by &lt;code&gt;borrow&lt;/code&gt; and cannot be used to calculate &lt;code&gt;sum&lt;/code&gt;. This is not possible because this would violate Rust's mutability rules.</source>
          <target state="translated">En este ejemplo, &lt;code&gt;value&lt;/code&gt; se mutably prestado por el &lt;code&gt;borrow&lt;/code&gt; y no puede ser usada para calcular &lt;code&gt;sum&lt;/code&gt; . Esto no es posible porque violar&amp;iacute;a las reglas de mutabilidad de Rust.</target>
        </trans-unit>
        <trans-unit id="ee5fd415a36736dbb42604438d3e115f3ef63293" translate="yes" xml:space="preserve">
          <source>In this example, if &lt;code&gt;x&lt;/code&gt; matches the pattern &lt;code&gt;(0, _)&lt;/code&gt;, the second field is set to &lt;code&gt;y&lt;/code&gt;. If it matches &lt;code&gt;(_, 0)&lt;/code&gt;, the first field is set to &lt;code&gt;y&lt;/code&gt;; so in all cases &lt;code&gt;y&lt;/code&gt; is set to some value.</source>
          <target state="translated">En este ejemplo, si &lt;code&gt;x&lt;/code&gt; coincide con el patr&amp;oacute;n &lt;code&gt;(0, _)&lt;/code&gt; , el segundo campo se establece en &lt;code&gt;y&lt;/code&gt; . Si coincide con &lt;code&gt;(_, 0)&lt;/code&gt; , el primer campo se establece en &lt;code&gt;y&lt;/code&gt; ; por lo que en todos los casos &lt;code&gt;y&lt;/code&gt; se establece en alg&amp;uacute;n valor.</target>
        </trans-unit>
        <trans-unit id="7fe9cc71a505a06c66b5d9f57153a2d3327a9165" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;'SnowWhite&lt;/code&gt; lifetime is supposed to outlive the &lt;code&gt;'kiss&lt;/code&gt; lifetime but the declaration of the &lt;code&gt;Prince&lt;/code&gt; struct doesn't enforce it. To fix this issue, you need to specify it:</source>
          <target state="translated">En este ejemplo, el &lt;code&gt;'SnowWhite&lt;/code&gt; se supone que la duraci&amp;oacute;n de 'SnowWhite sobrevive a la &lt;code&gt;'kiss&lt;/code&gt; duraci&amp;oacute;n del beso, pero la declaraci&amp;oacute;n de la estructura &lt;code&gt;Prince&lt;/code&gt; no la impone. Para solucionar este problema, debe especificarlo:</target>
        </trans-unit>
        <trans-unit id="5793bd2e6d3c5293d83c901c5867d17a61fb1b7b" translate="yes" xml:space="preserve">
          <source>In this example, the closure does not satisfy the &lt;code&gt;'static&lt;/code&gt; lifetime constraint. To fix this error, you need to double check the lifetime of the type. Here, we can fix this problem by giving &lt;code&gt;s&lt;/code&gt; a static lifetime:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c61f98e2cee2baaabf8be1956ffb960bd279fb24" translate="yes" xml:space="preserve">
          <source>In this example, the module &lt;code&gt;quux&lt;/code&gt; re-exports two public names defined in &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">En este ejemplo, el m&amp;oacute;dulo &lt;code&gt;quux&lt;/code&gt; reexporta dos nombres p&amp;uacute;blicos definidos en &lt;code&gt;foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4350bf464e116b6d57c761b20a820cb5925c37d3" translate="yes" xml:space="preserve">
          <source>In this example, the spawned thread is &quot;detached&quot; from the current thread. This means that it can outlive its parent (the thread that spawned it), unless this parent is the main thread.</source>
          <target state="translated">En este ejemplo,el hilo engendrado se &quot;desprende&quot; del hilo actual.Esto significa que puede sobrevivir a su padre (el hilo que lo engendró),a menos que este padre sea el hilo principal.</target>
        </trans-unit>
        <trans-unit id="adb1f627c4f5f533a368664ad1bfd6b52635fef6" translate="yes" xml:space="preserve">
          <source>In this example, the trait &lt;code&gt;Foo&lt;/code&gt; and the trait method &lt;code&gt;do_something_else&lt;/code&gt; both define a type parameter &lt;code&gt;T&lt;/code&gt;. This is not allowed: if the method wishes to define a type parameter, it must use a different name for it.</source>
          <target state="translated">En este ejemplo, el rasgo &lt;code&gt;Foo&lt;/code&gt; y el m&amp;eacute;todo rasgo &lt;code&gt;do_something_else&lt;/code&gt; tanto definen un tipo de par&amp;aacute;metro &lt;code&gt;T&lt;/code&gt; . Esto no est&amp;aacute; permitido: si el m&amp;eacute;todo desea definir un par&amp;aacute;metro de tipo, debe usar un nombre diferente para &amp;eacute;l.</target>
        </trans-unit>
        <trans-unit id="5106de7dace445aa59aa82effd4989b6c9358ae0" translate="yes" xml:space="preserve">
          <source>In this example, the trait &lt;code&gt;Printable&lt;/code&gt; occurs as a trait object in both the type signature of &lt;code&gt;print&lt;/code&gt;, and the cast expression in &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">En este ejemplo, el rasgo &lt;code&gt;Printable&lt;/code&gt; aparece como un objeto de rasgo tanto en la firma de tipo de &lt;code&gt;print&lt;/code&gt; como en la expresi&amp;oacute;n de conversi&amp;oacute;n en &lt;code&gt;main&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c7b2451157bfe66dfc5ae3bcc7df818cb052f87" translate="yes" xml:space="preserve">
          <source>In this example, the value &lt;code&gt;p&lt;/code&gt; matches the second arm by virtue of &lt;code&gt;x&lt;/code&gt; containing a 0, so this code will print &lt;code&gt;On the y axis at 7&lt;/code&gt;.</source>
          <target state="translated">En este ejemplo, el valor &lt;code&gt;p&lt;/code&gt; coincide con el segundo brazo en virtud de que &lt;code&gt;x&lt;/code&gt; contiene un 0, por lo que este c&amp;oacute;digo se imprimir&amp;aacute; &lt;code&gt;On the y axis at 7&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76e376bb135f5c25de32c031f91a381023081f30" translate="yes" xml:space="preserve">
          <source>In this example, the variable named &lt;code&gt;first&lt;/code&gt; will get the value &lt;code&gt;1&lt;/code&gt;, because that is the value at index &lt;code&gt;[0]&lt;/code&gt; in the array. The variable named &lt;code&gt;second&lt;/code&gt; will get the value &lt;code&gt;2&lt;/code&gt; from index &lt;code&gt;[1]&lt;/code&gt; in the array.</source>
          <target state="translated">En este ejemplo, la variable nombrada &lt;code&gt;first&lt;/code&gt; obtendr&amp;aacute; el valor &lt;code&gt;1&lt;/code&gt; , porque ese es el valor en el &amp;iacute;ndice &lt;code&gt;[0]&lt;/code&gt; en la matriz. La variable denominada &lt;code&gt;second&lt;/code&gt; obtendr&amp;aacute; el valor &lt;code&gt;2&lt;/code&gt; del &amp;iacute;ndice &lt;code&gt;[1]&lt;/code&gt; en la matriz.</target>
        </trans-unit>
        <trans-unit id="db1c89f552fe6cd5046ff6bd0d230e80deb004f6" translate="yes" xml:space="preserve">
          <source>In this example, we are asserting that the destructor for &lt;code&gt;Foo&lt;/code&gt; will not access any data of type &lt;code&gt;X&lt;/code&gt;, and require this assertion to be true for overall safety in our program. The compiler does not currently attempt to verify this assertion; therefore we must tag this &lt;code&gt;impl&lt;/code&gt; as unsafe.</source>
          <target state="translated">En este ejemplo, afirmamos que el destructor de &lt;code&gt;Foo&lt;/code&gt; no acceder&amp;aacute; a ning&amp;uacute;n dato de tipo &lt;code&gt;X&lt;/code&gt; , y requerimos que esta afirmaci&amp;oacute;n sea cierta para la seguridad general de nuestro programa. Actualmente, el compilador no intenta verificar esta afirmaci&amp;oacute;n; por lo tanto, debemos etiquetar este &lt;code&gt;impl&lt;/code&gt; &amp;iacute;cito como inseguro.</target>
        </trans-unit>
        <trans-unit id="5b639017ef60ffaf0981282e4da6c27fcdd578e1" translate="yes" xml:space="preserve">
          <source>In this example, we define a function &lt;code&gt;ten_times&lt;/code&gt; that takes a higher-order function argument, and we then call it with a closure expression as an argument, followed by a closure expression that moves values from its environment.</source>
          <target state="translated">En este ejemplo, definimos una funci&amp;oacute;n &lt;code&gt;ten_times&lt;/code&gt; que toma un argumento de funci&amp;oacute;n de orden superior, y luego la llamamos con una expresi&amp;oacute;n de cierre como argumento, seguida de una expresi&amp;oacute;n de cierre que mueve valores de su entorno.</target>
        </trans-unit>
        <trans-unit id="65cd159213dbe5caf10e5067fe9f06a95f76f236" translate="yes" xml:space="preserve">
          <source>In this example, we have to instantiate &lt;code&gt;'x&lt;/code&gt;, and we don't know what lifetime to instantiate it with. To fix this, spell out the precise lifetimes involved. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9be8015724a60f5a7de7fc8be3cf3fbc9130aa82" translate="yes" xml:space="preserve">
          <source>In this example, we tried to set a value with an incompatible lifetime to another one (&lt;code&gt;'long&lt;/code&gt; is unrelated to &lt;code&gt;'short&lt;/code&gt;). We can solve this issue in two different ways:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8385385b7c5acae88f390fa2486165f8a8931f92" translate="yes" xml:space="preserve">
          <source>In this example, we tried to use the non-existent associated type &lt;code&gt;You&lt;/code&gt; of the &lt;code&gt;Hello&lt;/code&gt; trait. To fix this error, use an existing associated type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bbce52117883bf5718cfbbb01cfe64f9309a2ae" translate="yes" xml:space="preserve">
          <source>In this example, we&amp;rsquo;ve specified a lifetime parameter &lt;code&gt;'a&lt;/code&gt; for the parameter &lt;code&gt;x&lt;/code&gt; and the return type, but not for the parameter &lt;code&gt;y&lt;/code&gt;, because the lifetime of &lt;code&gt;y&lt;/code&gt; does not have any relationship with the lifetime of &lt;code&gt;x&lt;/code&gt; or the return value.</source>
          <target state="translated">En este ejemplo, hemos especificado un par&amp;aacute;metro de duraci&amp;oacute;n &lt;code&gt;'a&lt;/code&gt; para el par&amp;aacute;metro &lt;code&gt;x&lt;/code&gt; y el tipo de retorno, pero no para el par&amp;aacute;metro &lt;code&gt;y&lt;/code&gt; , porque la duraci&amp;oacute;n de &lt;code&gt;y&lt;/code&gt; no tiene ninguna relaci&amp;oacute;n con la duraci&amp;oacute;n de &lt;code&gt;x&lt;/code&gt; o el valor de retorno.</target>
        </trans-unit>
        <trans-unit id="2185efdb59ae63a632adf24d45f191ffee2411df" translate="yes" xml:space="preserve">
          <source>In this example, when we assign the integer value 5 to &lt;code&gt;x&lt;/code&gt;, we let the compiler know that the generic type &lt;code&gt;T&lt;/code&gt; will be an integer for this instance of &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt;. Then when we specify 4.0 for &lt;code&gt;y&lt;/code&gt;, which we&amp;rsquo;ve defined to have the same type as &lt;code&gt;x&lt;/code&gt;, we&amp;rsquo;ll get a type mismatch error like this:</source>
          <target state="translated">En este ejemplo, cuando asignamos el valor entero 5 &lt;code&gt;x&lt;/code&gt; , le dejamos saber al compilador que el tipo gen&amp;eacute;rico &lt;code&gt;T&lt;/code&gt; ser&amp;aacute; un n&amp;uacute;mero entero para esta instancia de &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; . Luego, cuando especificamos 4.0 para &lt;code&gt;y&lt;/code&gt; , que hemos definido para tener el mismo tipo que &lt;code&gt;x&lt;/code&gt; , obtendremos un error de falta de coincidencia de tipos como este:</target>
        </trans-unit>
        <trans-unit id="af5f4c7efbea71694085e036fb3fca287f7c1342" translate="yes" xml:space="preserve">
          <source>In this example, you can see that &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; enables mutation inside an immutable struct. In other words, it enables &quot;interior mutability&quot;.</source>
          <target state="translated">En este ejemplo, puede ver que &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; habilita la mutaci&amp;oacute;n dentro de una estructura inmutable. En otras palabras, permite la &quot;mutabilidad interior&quot;.</target>
        </trans-unit>
        <trans-unit id="28ad91d98b4c69b8725ca2927cbfaca53b3c5e8d" translate="yes" xml:space="preserve">
          <source>In this implementation, the &lt;code&gt;to_string&lt;/code&gt; method panics if the &lt;code&gt;Display&lt;/code&gt; implementation returns an error. This indicates an incorrect &lt;code&gt;Display&lt;/code&gt; implementation since &lt;code&gt;fmt::Write for String&lt;/code&gt; never returns an error itself.</source>
          <target state="translated">En esta implementaci&amp;oacute;n, el m&amp;eacute;todo &lt;code&gt;to_string&lt;/code&gt; entra en p&amp;aacute;nico si la implementaci&amp;oacute;n de &lt;code&gt;Display&lt;/code&gt; devuelve un error. Esto indica una implementaci&amp;oacute;n de &lt;code&gt;Display&lt;/code&gt; incorrecta ya que &lt;code&gt;fmt::Write for String&lt;/code&gt; nunca devuelve un error en s&amp;iacute; mismo.</target>
        </trans-unit>
        <trans-unit id="f07445d5d52a84f1a2b08af97ac8fb5214288938" translate="yes" xml:space="preserve">
          <source>In this listing, we&amp;rsquo;ve used a method we haven&amp;rsquo;t covered before: &lt;code&gt;unwrap_or_else&lt;/code&gt;, which is defined on &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; by the standard library. Using &lt;code&gt;unwrap_or_else&lt;/code&gt; allows us to define some custom, non-&lt;code&gt;panic!&lt;/code&gt; error handling. If the &lt;code&gt;Result&lt;/code&gt; is an &lt;code&gt;Ok&lt;/code&gt; value, this method&amp;rsquo;s behavior is similar to &lt;code&gt;unwrap&lt;/code&gt;: it returns the inner value &lt;code&gt;Ok&lt;/code&gt; is wrapping. However, if the value is an &lt;code&gt;Err&lt;/code&gt; value, this method calls the code in the &lt;em&gt;closure&lt;/em&gt;, which is an anonymous function we define and pass as an argument to &lt;code&gt;unwrap_or_else&lt;/code&gt;. We&amp;rsquo;ll cover closures in more detail in &lt;a href=&quot;ch13-00-functional-features&quot;&gt;Chapter 13&lt;/a&gt;. For now, you just need to know that &lt;code&gt;unwrap_or_else&lt;/code&gt; will pass the inner value of the &lt;code&gt;Err&lt;/code&gt;, which in this case is the static string &lt;code&gt;&quot;not enough arguments&quot;&lt;/code&gt; that we added in Listing 12-9, to our closure in the argument &lt;code&gt;err&lt;/code&gt; that appears between the vertical pipes. The code in the closure can then use the &lt;code&gt;err&lt;/code&gt; value when it runs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cf45f5e676953372bb64ede268b0f879c84bec0" translate="yes" xml:space="preserve">
          <source>In this listing, we&amp;rsquo;ve used a method we haven&amp;rsquo;t covered before: &lt;code&gt;unwrap_or_else&lt;/code&gt;, which is defined on &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; by the standard library. Using &lt;code&gt;unwrap_or_else&lt;/code&gt; allows us to define some custom, non-&lt;code&gt;panic!&lt;/code&gt; error handling. If the &lt;code&gt;Result&lt;/code&gt; is an &lt;code&gt;Ok&lt;/code&gt; value, this method&amp;rsquo;s behavior is similar to &lt;code&gt;unwrap&lt;/code&gt;: it returns the inner value &lt;code&gt;Ok&lt;/code&gt; is wrapping. However, if the value is an &lt;code&gt;Err&lt;/code&gt; value, this method calls the code in the &lt;em&gt;closure&lt;/em&gt;, which is an anonymous function we define and pass as an argument to &lt;code&gt;unwrap_or_else&lt;/code&gt;. We&amp;rsquo;ll cover closures in more detail in &lt;a href=&quot;ch13-00-functional-features&quot;&gt;Chapter 13&lt;/a&gt;. For now, you just need to know that &lt;code&gt;unwrap_or_else&lt;/code&gt; will pass the inner value of the &lt;code&gt;Err&lt;/code&gt;, which in this case is the static string &lt;code&gt;not enough arguments&lt;/code&gt; that we added in Listing 12-9, to our closure in the argument &lt;code&gt;err&lt;/code&gt; that appears between the vertical pipes. The code in the closure can then use the &lt;code&gt;err&lt;/code&gt; value when it runs.</source>
          <target state="translated">En esta lista, hemos utilizado un m&amp;eacute;todo que no hemos cubierto antes: &lt;code&gt;unwrap_or_else&lt;/code&gt; , que est&amp;aacute; definido en &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; por la biblioteca est&amp;aacute;ndar. El uso de &lt;code&gt;unwrap_or_else&lt;/code&gt; nos permite definir algunos personalizados, &amp;iexcl;sin &lt;code&gt;panic!&lt;/code&gt; manejo de errores. Si el &lt;code&gt;Result&lt;/code&gt; es un valor &lt;code&gt;Ok&lt;/code&gt; , el comportamiento de este m&amp;eacute;todo es similar a &lt;code&gt;unwrap&lt;/code&gt; : devuelve el valor interno que &lt;code&gt;Ok&lt;/code&gt; est&amp;aacute; envolviendo. Sin embargo, si el valor es un valor &lt;code&gt;Err&lt;/code&gt; , este m&amp;eacute;todo llama al c&amp;oacute;digo en el &lt;em&gt;cierre&lt;/em&gt; , que es una funci&amp;oacute;n an&amp;oacute;nima que definimos y pasamos como argumento a &lt;code&gt;unwrap_or_else&lt;/code&gt; . Cubriremos los cierres con m&amp;aacute;s detalle en&lt;a href=&quot;ch13-00-functional-features&quot;&gt;Cap&amp;iacute;tulo 13&lt;/a&gt; . Por ahora, solo necesita saber que &lt;code&gt;unwrap_or_else&lt;/code&gt; pasar&amp;aacute; el valor interno de &lt;code&gt;Err&lt;/code&gt; , que en este caso es la cadena est&amp;aacute;tica, &lt;code&gt;not enough arguments&lt;/code&gt; que agregamos en el Listado 12-9, a nuestro cierre en el argumento &lt;code&gt;err&lt;/code&gt; que aparece entre los Tuber&amp;iacute;as verticales. El c&amp;oacute;digo en el cierre puede usar el valor de &lt;code&gt;err&lt;/code&gt; or cuando se ejecuta.</target>
        </trans-unit>
        <trans-unit id="bd1efd0f88f5695bb09cde72e8a0904d7ad1c207" translate="yes" xml:space="preserve">
          <source>In this more complex example, we use &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;.debug_set()&lt;/code&gt; to build a list of match arms:</source>
          <target state="translated">En este ejemplo m&amp;aacute;s complejo, usamos &lt;a href=&quot;../macro.format_args&quot;&gt; &lt;code&gt;format_args!&lt;/code&gt; &lt;/a&gt;y &lt;code&gt;.debug_set()&lt;/code&gt; para construir una lista de brazos coincidentes:</target>
        </trans-unit>
        <trans-unit id="b03c6712fd2fec1eec14a91751691024a72c4d16" translate="yes" xml:space="preserve">
          <source>In this next example, &lt;code&gt;init_after_if&lt;/code&gt; is initialized after the &lt;a href=&quot;expressions/if-expr#if-expressions&quot;&gt;&lt;code&gt;if&lt;/code&gt; expression&lt;/a&gt; while &lt;code&gt;uninit_after_if&lt;/code&gt; is not because it is not initialized in the &lt;code&gt;else&lt;/code&gt; case.</source>
          <target state="translated">En el siguiente ejemplo, &lt;code&gt;init_after_if&lt;/code&gt; se inicializa despu&amp;eacute;s de la &lt;a href=&quot;expressions/if-expr#if-expressions&quot;&gt;expresi&amp;oacute;n &lt;/a&gt; &lt;code&gt;if&lt;/code&gt; , mientras que &lt;code&gt;uninit_after_if&lt;/code&gt; no lo es porque no se inicializa en el caso &lt;code&gt;else&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c69b4c18cf4fe1c7e28ef21ab7b9243778f0c95" translate="yes" xml:space="preserve">
          <source>In this process, the compiler does the opposite of the steps we used to create the generic function in Listing 10-5: the compiler looks at all the places where generic code is called and generates code for the concrete types the generic code is called with.</source>
          <target state="translated">En este proceso,el compilador hace lo contrario de los pasos que usamos para crear la función genérica en la Lista 10-5:el compilador mira todos los lugares en los que se llama el código genérico y genera código para los tipos concretos con los que se llama el código genérico.</target>
        </trans-unit>
        <trans-unit id="9b2eecf1196adab0e0b7bc0dd52bfa9ea4118939" translate="yes" xml:space="preserve">
          <source>In this section, we&amp;rsquo;ll add the searching logic to the &lt;code&gt;minigrep&lt;/code&gt; program by using the Test-driven development (TDD) process. This software development technique follows these steps:</source>
          <target state="translated">En esta secci&amp;oacute;n, agregaremos la l&amp;oacute;gica de b&amp;uacute;squeda al programa &lt;code&gt;minigrep&lt;/code&gt; mediante el proceso de desarrollo impulsado por pruebas (TDD). Esta t&amp;eacute;cnica de desarrollo de software sigue estos pasos:</target>
        </trans-unit>
        <trans-unit id="35594ca80fb0c4ca7018f39776903a474d1cfb0f" translate="yes" xml:space="preserve">
          <source>In this section, we&amp;rsquo;ll talk about modules and other parts of the module system, namely &lt;em&gt;paths&lt;/em&gt; that allow you to name items; the &lt;code&gt;use&lt;/code&gt; keyword that brings a path into scope; and the &lt;code&gt;pub&lt;/code&gt; keyword to make items public. We&amp;rsquo;ll also discuss the &lt;code&gt;as&lt;/code&gt; keyword, external packages, and the glob operator. For now, let&amp;rsquo;s focus on modules!</source>
          <target state="translated">En esta secci&amp;oacute;n, hablaremos sobre m&amp;oacute;dulos y otras partes del sistema de m&amp;oacute;dulos, a saber, &lt;em&gt;rutas&lt;/em&gt; que le permiten nombrar elementos; la palabra clave &lt;code&gt;use&lt;/code&gt; que trae una ruta al alcance; y la palabra clave &lt;code&gt;pub&lt;/code&gt; para hacer p&amp;uacute;blicos los elementos. Tambi&amp;eacute;n discutiremos la palabra clave &lt;code&gt;as&lt;/code&gt; , los paquetes externos y el operador glob. &amp;iexcl;Por ahora, centr&amp;eacute;monos en los m&amp;oacute;dulos!</target>
        </trans-unit>
        <trans-unit id="b9ddbf2b08f89e10bfeee4884b118c18fb0ff1c3" translate="yes" xml:space="preserve">
          <source>In this situation, even the &lt;code&gt;ref&lt;/code&gt; keyword cannot solve it, since borrowed content cannot be moved. This problem cannot be solved generally. If the value can be cloned, here is a not-so-specific solution:</source>
          <target state="translated">En esta situaci&amp;oacute;n, incluso la palabra clave &lt;code&gt;ref&lt;/code&gt; no puede resolverlo, ya que el contenido prestado no se puede mover. Este problema no se puede resolver en general. Si el valor se puede clonar, aqu&amp;iacute; hay una soluci&amp;oacute;n no tan espec&amp;iacute;fica:</target>
        </trans-unit>
        <trans-unit id="66f6d7f6d5b6dce217f5225ca67e0e2ff88fca0a" translate="yes" xml:space="preserve">
          <source>In this specific case there's a good chance that the transmute is harmless (but this is not guaranteed by Rust). However, when alignment and enum optimizations come into the picture, it's quite likely that the sizes may or may not match with different type parameter substitutions. It's not possible to check this for &lt;em&gt;all&lt;/em&gt; possible types, so &lt;code&gt;transmute()&lt;/code&gt; simply only accepts types without any unsubstituted type parameters.</source>
          <target state="translated">En este caso espec&amp;iacute;fico, existe una buena posibilidad de que la transmutaci&amp;oacute;n sea inofensiva (pero Rust no lo garantiza). Sin embargo, cuando las optimizaciones de alineaci&amp;oacute;n y enumeraci&amp;oacute;n entran en juego, es bastante probable que los tama&amp;ntilde;os coincidan o no con las sustituciones de par&amp;aacute;metros de tipo diferente. No es posible verificar esto para &lt;em&gt;todos&lt;/em&gt; los tipos posibles, por lo que &lt;code&gt;transmute()&lt;/code&gt; simplemente solo acepta tipos sin ning&amp;uacute;n par&amp;aacute;metro de tipo no sustituido.</target>
        </trans-unit>
        <trans-unit id="fe9b2052803d3d7b3dd78aa5085c8137d21478b8" translate="yes" xml:space="preserve">
          <source>In this suggestion, &amp;ldquo;indirection&amp;rdquo; means that instead of storing a value directly, we&amp;rsquo;ll change the data structure to store the value indirectly by storing a pointer to the value instead.</source>
          <target state="translated">En esta sugerencia, &quot;indirecci&amp;oacute;n&quot; significa que en lugar de almacenar un valor directamente, cambiaremos la estructura de datos para almacenar el valor indirectamente almacenando un puntero al valor.</target>
        </trans-unit>
        <trans-unit id="ace1483441c50f77553551974f43198070533a0e" translate="yes" xml:space="preserve">
          <source>In this way, the structure of expressions dictates the structure of execution. Blocks are just another kind of expression, so blocks, statements, expressions, and blocks again can recursively nest inside each other to an arbitrary depth.</source>
          <target state="translated">De esta manera,la estructura de las expresiones dicta la estructura de la ejecución.Los bloques son sólo otro tipo de expresión,por lo que los bloques,declaraciones,expresiones y bloques de nuevo pueden anidar recursivamente dentro de cada uno a una profundidad arbitraria.</target>
        </trans-unit>
        <trans-unit id="3c64ce605c02c94d28e3d47caa98671818a3b2ae" translate="yes" xml:space="preserve">
          <source>In those cases, you need to provide the type explicitly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f60575dd030bfd74d0c69219e41591057c41df3" translate="yes" xml:space="preserve">
          <source>In trait declarations as &lt;a href=&quot;items/traits#supertraits&quot;&gt;supertraits&lt;/a&gt;: &lt;code&gt;trait Circle : Shape {}&lt;/code&gt; is equivalent to &lt;code&gt;trait Circle where Self : Shape {}&lt;/code&gt;.</source>
          <target state="translated">En declaraciones de rasgos como &lt;a href=&quot;items/traits#supertraits&quot;&gt;supertraits&lt;/a&gt; : &lt;code&gt;trait Circle : Shape {}&lt;/code&gt; es equivalente al &lt;code&gt;trait Circle where Self : Shape {}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4f93075a116db72d1570a79e9e24585b192c4ef" translate="yes" xml:space="preserve">
          <source>In trait declarations as bounds on &lt;a href=&quot;items/associated-items#associated-types&quot;&gt;associated types&lt;/a&gt;: &lt;code&gt;trait A { type B: Copy; }&lt;/code&gt; is equivalent to &lt;code&gt;trait A where Self::B: Copy { type B; }&lt;/code&gt;.</source>
          <target state="translated">En declaraciones de rasgos como l&amp;iacute;mites en &lt;a href=&quot;items/associated-items#associated-types&quot;&gt;tipos asociados&lt;/a&gt; : &lt;code&gt;trait A { type B: Copy; }&lt;/code&gt; es equivalente al &lt;code&gt;trait A where Self::B: Copy { type B; }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d593169be70ffe063ab15f461603b04fb19d3943" translate="yes" xml:space="preserve">
          <source>In traits, &lt;code&gt;type&lt;/code&gt; is used to declare an &lt;a href=&quot;../reference/items/associated-items#associated-types&quot;&gt;associated type&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31d52c1f8837d60baebd5fe1bd8acd4770d12408" translate="yes" xml:space="preserve">
          <source>In types, the &lt;code&gt;+&lt;/code&gt; type operator has low precedence, so it is often necessary to use parentheses.</source>
          <target state="translated">En tipos, el operador de tipo &lt;code&gt;+&lt;/code&gt; tiene baja precedencia, por lo que a menudo es necesario utilizar par&amp;eacute;ntesis.</target>
        </trans-unit>
        <trans-unit id="f9490ac1bbc7d37c9f2c0e3e394c8775ef19ff65" translate="yes" xml:space="preserve">
          <source>In types, the &lt;code&gt;+&lt;/code&gt; type operator has low precedence, so it is often necessary to use parentheses:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd1daf40491a926084464e0388144e6ba829d637" translate="yes" xml:space="preserve">
          <source>In various places in the book, we&amp;rsquo;ve discussed the &lt;code&gt;derive&lt;/code&gt; attribute, which you can apply to a struct or enum definition. The &lt;code&gt;derive&lt;/code&gt; attribute generates code that will implement a trait with its own default implementation on the type you&amp;rsquo;ve annotated with the &lt;code&gt;derive&lt;/code&gt; syntax.</source>
          <target state="translated">En varios lugares del libro, hemos discutido el atributo &lt;code&gt;derive&lt;/code&gt; , que puede aplicar a una definici&amp;oacute;n de estructura o enumeraci&amp;oacute;n. El atributo &lt;code&gt;derive&lt;/code&gt; genera c&amp;oacute;digo que implementar&amp;aacute; un rasgo con su propia implementaci&amp;oacute;n predeterminada en el tipo que ha anotado con la sintaxis &lt;code&gt;derive&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cebe38e502b4e0d3a49a067f9739636c8c7567e" translate="yes" xml:space="preserve">
          <source>In very rare edge cases, this may happen when loading &lt;code&gt;core&lt;/code&gt; or &lt;code&gt;std&lt;/code&gt; twice, once with &lt;code&gt;check&lt;/code&gt; metadata and once with &lt;code&gt;build&lt;/code&gt; metadata. For more information, see &lt;a href=&quot;https://github.com/rust-lang/rust/pull/75176#issuecomment-683234468&quot;&gt;#75176&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fcacf884bdd57e38c179c26c2a445daf0a3b88d" translate="yes" xml:space="preserve">
          <source>In-band lifetimes cannot be mixed with explicit lifetime binders. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c1253e722ca01693911433634c27b9199fbe1b5" translate="yes" xml:space="preserve">
          <source>In-band lifetimes cannot be used in &lt;code&gt;fn&lt;/code&gt;/&lt;code&gt;Fn&lt;/code&gt; syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0307fb1316fe032b75c2eab1c02683137e89f74" translate="yes" xml:space="preserve">
          <source>In-band lifetimes were mixed with explicit lifetime binders.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71195f6d729d094826e987475aa2b83d4c3354c6" translate="yes" xml:space="preserve">
          <source>InPlaceIterable</source>
          <target state="translated">InPlaceIterable</target>
        </trans-unit>
        <trans-unit id="0d84c9de7449d934ab38cca665ee24ab8d418e04" translate="yes" xml:space="preserve">
          <source>Includes a UTF-8 encoded file as a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42e257e75b3e4fa6d9e9989f973afa801a9a03f0" translate="yes" xml:space="preserve">
          <source>Includes a file as a reference to a byte array.</source>
          <target state="translated">Incluye un archivo como referencia a una matriz de bytes.</target>
        </trans-unit>
        <trans-unit id="9c140715e3185328a980b4bc60a18b0febc51520" translate="yes" xml:space="preserve">
          <source>Includes a utf8-encoded file as a string.</source>
          <target state="translated">Incluye un archivo codificado en utf8 como cadena.</target>
        </trans-unit>
        <trans-unit id="0c11e0c644b5890be96bab7620a548663254f1f7" translate="yes" xml:space="preserve">
          <source>Includes all extension traits, and some important type definitions.</source>
          <target state="translated">Incluye todos los rasgos de extensión y algunas definiciones de tipos importantes.</target>
        </trans-unit>
        <trans-unit id="a9c615b9e833ee226ac08cb33f93df17a615ca30" translate="yes" xml:space="preserve">
          <source>Incoming</source>
          <target state="translated">Incoming</target>
        </trans-unit>
        <trans-unit id="805a014cffe854e2c811b260ab089d2eda0bbeb7" translate="yes" xml:space="preserve">
          <source>Incoming::all</source>
          <target state="translated">Incoming::all</target>
        </trans-unit>
        <trans-unit id="83bd443d175b9e89de0c8b8872961ea2816dcfb6" translate="yes" xml:space="preserve">
          <source>Incoming::any</source>
          <target state="translated">Incoming::any</target>
        </trans-unit>
        <trans-unit id="f9822b9a823019e577bdfe3ac98493f3aa60473c" translate="yes" xml:space="preserve">
          <source>Incoming::borrow</source>
          <target state="translated">Incoming::borrow</target>
        </trans-unit>
        <trans-unit id="db57c16634c0af16618401e02b9b1b14cfb90675" translate="yes" xml:space="preserve">
          <source>Incoming::borrow_mut</source>
          <target state="translated">Incoming::borrow_mut</target>
        </trans-unit>
        <trans-unit id="909a090d9b0ea3ec427658ae73388b50d4bfbc1f" translate="yes" xml:space="preserve">
          <source>Incoming::by_ref</source>
          <target state="translated">Incoming::by_ref</target>
        </trans-unit>
        <trans-unit id="6d7e9108e413d8a837bb790d96b999eaae29b3f2" translate="yes" xml:space="preserve">
          <source>Incoming::chain</source>
          <target state="translated">Incoming::chain</target>
        </trans-unit>
        <trans-unit id="30254dbd6651bc8d2ce9a6489cb59513c462d366" translate="yes" xml:space="preserve">
          <source>Incoming::cloned</source>
          <target state="translated">Incoming::cloned</target>
        </trans-unit>
        <trans-unit id="8a2bf20be5038460f2e5f09718d4cb6a21fb4c03" translate="yes" xml:space="preserve">
          <source>Incoming::cmp</source>
          <target state="translated">Incoming::cmp</target>
        </trans-unit>
        <trans-unit id="5ed0bcc65453a7978586b3e2016dacfbc14352fe" translate="yes" xml:space="preserve">
          <source>Incoming::collect</source>
          <target state="translated">Incoming::collect</target>
        </trans-unit>
        <trans-unit id="e70d0d30256802ac0658826bed8a56d75ffa6c45" translate="yes" xml:space="preserve">
          <source>Incoming::copied</source>
          <target state="translated">Incoming::copied</target>
        </trans-unit>
        <trans-unit id="a1ce4c03ba198d6862609c9bca7b4fdfd0e790c1" translate="yes" xml:space="preserve">
          <source>Incoming::count</source>
          <target state="translated">Incoming::count</target>
        </trans-unit>
        <trans-unit id="445c24f8aeffb804abbe66eac8d728adfa6384c3" translate="yes" xml:space="preserve">
          <source>Incoming::cycle</source>
          <target state="translated">Incoming::cycle</target>
        </trans-unit>
        <trans-unit id="c7373d860bdcd6bd00f58afd7287948921f2cf3d" translate="yes" xml:space="preserve">
          <source>Incoming::enumerate</source>
          <target state="translated">Incoming::enumerate</target>
        </trans-unit>
        <trans-unit id="422e90f2e0427cea81726aa22dde243c959e3442" translate="yes" xml:space="preserve">
          <source>Incoming::eq</source>
          <target state="translated">Incoming::eq</target>
        </trans-unit>
        <trans-unit id="d82ad0962be1b645dba4415057b56c8c71d2db6c" translate="yes" xml:space="preserve">
          <source>Incoming::filter</source>
          <target state="translated">Incoming::filter</target>
        </trans-unit>
        <trans-unit id="f2d060b73d6c431a592011fdcaf80f72c4327ea7" translate="yes" xml:space="preserve">
          <source>Incoming::filter_map</source>
          <target state="translated">Incoming::filter_map</target>
        </trans-unit>
        <trans-unit id="ec24aef48051e0d66dfbf513fbece0b535e8173a" translate="yes" xml:space="preserve">
          <source>Incoming::find</source>
          <target state="translated">Incoming::find</target>
        </trans-unit>
        <trans-unit id="9f1745b317ce967f0969bdd91f79615c9788ba14" translate="yes" xml:space="preserve">
          <source>Incoming::find_map</source>
          <target state="translated">Incoming::find_map</target>
        </trans-unit>
        <trans-unit id="57ed09c2ac8fbae367da14cf88b9a1cf3a0b0f16" translate="yes" xml:space="preserve">
          <source>Incoming::flat_map</source>
          <target state="translated">Incoming::flat_map</target>
        </trans-unit>
        <trans-unit id="aa8cfa9877df81bdf6f3e26ae8c327e4f18e7ca7" translate="yes" xml:space="preserve">
          <source>Incoming::flatten</source>
          <target state="translated">Incoming::flatten</target>
        </trans-unit>
        <trans-unit id="f534c99639d2a7b60622d67e3da268c1b2dbd8a2" translate="yes" xml:space="preserve">
          <source>Incoming::fmt</source>
          <target state="translated">Incoming::fmt</target>
        </trans-unit>
        <trans-unit id="7bf954d9f452b8f0bff229d58d17ebe667b8bdaa" translate="yes" xml:space="preserve">
          <source>Incoming::fold</source>
          <target state="translated">Incoming::fold</target>
        </trans-unit>
        <trans-unit id="f45d04534657562b3b8e1ac8b93f0995c4f52ffc" translate="yes" xml:space="preserve">
          <source>Incoming::for_each</source>
          <target state="translated">Incoming::for_each</target>
        </trans-unit>
        <trans-unit id="146d704978de3d221c4a8b538e653f767ff7d0cc" translate="yes" xml:space="preserve">
          <source>Incoming::from</source>
          <target state="translated">Incoming::from</target>
        </trans-unit>
        <trans-unit id="8d00e730beb7664120c689b2165fe55c7e43696b" translate="yes" xml:space="preserve">
          <source>Incoming::fuse</source>
          <target state="translated">Incoming::fuse</target>
        </trans-unit>
        <trans-unit id="d6f3fa46377ae997728223371f8e2928bbcd46ee" translate="yes" xml:space="preserve">
          <source>Incoming::ge</source>
          <target state="translated">Incoming::ge</target>
        </trans-unit>
        <trans-unit id="ed38c0b5ef84ea5163b2da693e4b72183ddee0ec" translate="yes" xml:space="preserve">
          <source>Incoming::gt</source>
          <target state="translated">Incoming::gt</target>
        </trans-unit>
        <trans-unit id="b1345261a277f185321d6adb9b350bcb58cd599e" translate="yes" xml:space="preserve">
          <source>Incoming::inspect</source>
          <target state="translated">Incoming::inspect</target>
        </trans-unit>
        <trans-unit id="59abb681c116c064869e4b015c6b1cd16fb45598" translate="yes" xml:space="preserve">
          <source>Incoming::into</source>
          <target state="translated">Incoming::into</target>
        </trans-unit>
        <trans-unit id="95a20422d3926772d9c359f121355edbd8f745f9" translate="yes" xml:space="preserve">
          <source>Incoming::into_iter</source>
          <target state="translated">Incoming::into_iter</target>
        </trans-unit>
        <trans-unit id="77b7ce153ce8067d29a7d019ff3fcc043c2fdd8e" translate="yes" xml:space="preserve">
          <source>Incoming::is_sorted</source>
          <target state="translated">Incoming::is_sorted</target>
        </trans-unit>
        <trans-unit id="4dfdf545d2798411e8ee50244269b54395d86c9a" translate="yes" xml:space="preserve">
          <source>Incoming::is_sorted_by</source>
          <target state="translated">Incoming::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="d90a5dfb897aff5c068a0a4a12a54de5b9bdf1da" translate="yes" xml:space="preserve">
          <source>Incoming::is_sorted_by_key</source>
          <target state="translated">Incoming::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="f1c770fca353b885ee610fe1f519139cdebcc0ee" translate="yes" xml:space="preserve">
          <source>Incoming::last</source>
          <target state="translated">Incoming::last</target>
        </trans-unit>
        <trans-unit id="f5c79843bca5e97321f55d85100e1ac93d537dd7" translate="yes" xml:space="preserve">
          <source>Incoming::le</source>
          <target state="translated">Incoming::le</target>
        </trans-unit>
        <trans-unit id="41753aa4086d7645034ac6f543870deca487abbb" translate="yes" xml:space="preserve">
          <source>Incoming::lt</source>
          <target state="translated">Incoming::lt</target>
        </trans-unit>
        <trans-unit id="42262cd6a3c45e0c4ccd2f403ab3dde4f31c999d" translate="yes" xml:space="preserve">
          <source>Incoming::map</source>
          <target state="translated">Incoming::map</target>
        </trans-unit>
        <trans-unit id="b14fbc258acb1391be68964dacf06c868d0223ee" translate="yes" xml:space="preserve">
          <source>Incoming::max</source>
          <target state="translated">Incoming::max</target>
        </trans-unit>
        <trans-unit id="e598cfd5a561805bab3a055536a7ce8d4cbc0d87" translate="yes" xml:space="preserve">
          <source>Incoming::max_by</source>
          <target state="translated">Incoming::max_by</target>
        </trans-unit>
        <trans-unit id="02e8830cd577c40509d7ca817740c861b52c07c0" translate="yes" xml:space="preserve">
          <source>Incoming::max_by_key</source>
          <target state="translated">Incoming::max_by_key</target>
        </trans-unit>
        <trans-unit id="e522553048356a9c7e3aafb53205e73c814823fd" translate="yes" xml:space="preserve">
          <source>Incoming::min</source>
          <target state="translated">Incoming::min</target>
        </trans-unit>
        <trans-unit id="8b1b84ed0cee495bc315c75dc85c4916ce7f680f" translate="yes" xml:space="preserve">
          <source>Incoming::min_by</source>
          <target state="translated">Incoming::min_by</target>
        </trans-unit>
        <trans-unit id="94a6455843a6def08f4247ddbcf5a373aff6a12c" translate="yes" xml:space="preserve">
          <source>Incoming::min_by_key</source>
          <target state="translated">Incoming::min_by_key</target>
        </trans-unit>
        <trans-unit id="af6f0e0d448b8971f8088a94ecfe2c2c28074b20" translate="yes" xml:space="preserve">
          <source>Incoming::ne</source>
          <target state="translated">Incoming::ne</target>
        </trans-unit>
        <trans-unit id="ad9f2df7e05588db669a49fe0bfa35787281e257" translate="yes" xml:space="preserve">
          <source>Incoming::next</source>
          <target state="translated">Incoming::next</target>
        </trans-unit>
        <trans-unit id="15fdadbdf731ff5f14bd01d14581b0031b5aa856" translate="yes" xml:space="preserve">
          <source>Incoming::nth</source>
          <target state="translated">Incoming::nth</target>
        </trans-unit>
        <trans-unit id="f584fdb6a022a6b9c2041ae0049adb844c00af0a" translate="yes" xml:space="preserve">
          <source>Incoming::partial_cmp</source>
          <target state="translated">Incoming::partial_cmp</target>
        </trans-unit>
        <trans-unit id="d6e7347d2f13179a0246ad8c2f8f8c42d5ea1e8b" translate="yes" xml:space="preserve">
          <source>Incoming::partition</source>
          <target state="translated">Incoming::partition</target>
        </trans-unit>
        <trans-unit id="d15dc3a739c395fba4cdef1bb3db41863ef399f5" translate="yes" xml:space="preserve">
          <source>Incoming::peekable</source>
          <target state="translated">Incoming::peekable</target>
        </trans-unit>
        <trans-unit id="cab06ddc3af8abd52b92e45544310b0faa110219" translate="yes" xml:space="preserve">
          <source>Incoming::position</source>
          <target state="translated">Incoming::position</target>
        </trans-unit>
        <trans-unit id="bb23c8eb76a6d68dfc63c6d32849abe960c1b856" translate="yes" xml:space="preserve">
          <source>Incoming::product</source>
          <target state="translated">Incoming::product</target>
        </trans-unit>
        <trans-unit id="b3d90889f7b30454426b3ed4e11228f5d9d8ee9f" translate="yes" xml:space="preserve">
          <source>Incoming::rev</source>
          <target state="translated">Incoming::rev</target>
        </trans-unit>
        <trans-unit id="d662587d11104ca4324befe21e5aaa1cf3ed3fa3" translate="yes" xml:space="preserve">
          <source>Incoming::rposition</source>
          <target state="translated">Incoming::rposition</target>
        </trans-unit>
        <trans-unit id="6b42372525b119239ec4bd20dc7bf69a1a105a08" translate="yes" xml:space="preserve">
          <source>Incoming::scan</source>
          <target state="translated">Incoming::scan</target>
        </trans-unit>
        <trans-unit id="c1399e28a107bc4249663ed0d2b97e798127c9c6" translate="yes" xml:space="preserve">
          <source>Incoming::size_hint</source>
          <target state="translated">Incoming::size_hint</target>
        </trans-unit>
        <trans-unit id="85ee70ca43a998ef206f4a945f59006b6f40ddfa" translate="yes" xml:space="preserve">
          <source>Incoming::skip</source>
          <target state="translated">Incoming::skip</target>
        </trans-unit>
        <trans-unit id="fdd32c3e0206952202e83705e9d627eb48f607e6" translate="yes" xml:space="preserve">
          <source>Incoming::skip_while</source>
          <target state="translated">Incoming::skip_while</target>
        </trans-unit>
        <trans-unit id="5a589e1b9602c4ff48aa22e65968275507ea9485" translate="yes" xml:space="preserve">
          <source>Incoming::step_by</source>
          <target state="translated">Incoming::step_by</target>
        </trans-unit>
        <trans-unit id="d9ed48df44b20a36de8b0990f9b0c9b964475772" translate="yes" xml:space="preserve">
          <source>Incoming::sum</source>
          <target state="translated">Incoming::sum</target>
        </trans-unit>
        <trans-unit id="bcf6381c826c50e1aaea7423243d1529dca214b8" translate="yes" xml:space="preserve">
          <source>Incoming::take</source>
          <target state="translated">Incoming::take</target>
        </trans-unit>
        <trans-unit id="981c1e08f556e3870dd2af3a144f3176473200b7" translate="yes" xml:space="preserve">
          <source>Incoming::take_while</source>
          <target state="translated">Incoming::take_while</target>
        </trans-unit>
        <trans-unit id="2f0356552ebde5f1c3f3f3ad37fa03b3d1bf90bd" translate="yes" xml:space="preserve">
          <source>Incoming::try_fold</source>
          <target state="translated">Incoming::try_fold</target>
        </trans-unit>
        <trans-unit id="5c1f1df01cacdbf861258e63eb2cb8581f88d043" translate="yes" xml:space="preserve">
          <source>Incoming::try_for_each</source>
          <target state="translated">Incoming::try_for_each</target>
        </trans-unit>
        <trans-unit id="9a58299e31b9803379553db37123ab15774b671d" translate="yes" xml:space="preserve">
          <source>Incoming::try_from</source>
          <target state="translated">Incoming::try_from</target>
        </trans-unit>
        <trans-unit id="fff541a38a97a609e5012c516e4164326cfb79eb" translate="yes" xml:space="preserve">
          <source>Incoming::try_into</source>
          <target state="translated">Incoming::try_into</target>
        </trans-unit>
        <trans-unit id="946f55dc3e1af640cd291f2aaa8528234e768102" translate="yes" xml:space="preserve">
          <source>Incoming::type_id</source>
          <target state="translated">Incoming::type_id</target>
        </trans-unit>
        <trans-unit id="bf46b8f3bb432660f79899dee66baf3e9f087f95" translate="yes" xml:space="preserve">
          <source>Incoming::unzip</source>
          <target state="translated">Incoming::unzip</target>
        </trans-unit>
        <trans-unit id="96a8cde7e0e4c52965055072fd39e0d341071072" translate="yes" xml:space="preserve">
          <source>Incoming::zip</source>
          <target state="translated">Incoming::zip</target>
        </trans-unit>
        <trans-unit id="bcbf83cd2f0ed89c4d2689129dde9ed148866efc" translate="yes" xml:space="preserve">
          <source>Incorrect bytes:</source>
          <target state="translated">Bytes incorrectos:</target>
        </trans-unit>
        <trans-unit id="2a70492a6aefdfa404f3b9ac0c6d0448b88be337" translate="yes" xml:space="preserve">
          <source>Incorrect usage</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d7c0e61e47d8d76b1fdbcd2b9644ebc448b482b" translate="yes" xml:space="preserve">
          <source>Increments the strong reference count on the &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; associated with the provided pointer by one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="52cb15ca8d9c1e4b950b26ef1f32246271f50339" translate="yes" xml:space="preserve">
          <source>Index expressions on arrays and slices</source>
          <target state="translated">Expresiones de índice en matrices y cortes</target>
        </trans-unit>
        <trans-unit id="361d6f89c121ce39bb2ed14f7085cd248645d21b" translate="yes" xml:space="preserve">
          <source>Index expressions, &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;array indexing&lt;/a&gt; or &lt;a href=&quot;types/slice&quot;&gt;slice&lt;/a&gt; with a &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">Expresiones de &amp;iacute;ndice, &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;indexaci&amp;oacute;n de matrices&lt;/a&gt; o &lt;a href=&quot;types/slice&quot;&gt;corte&lt;/a&gt; con un &lt;code&gt;usize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="528b0ff12e28b750b5aeda40648664d5f6804c7c" translate="yes" xml:space="preserve">
          <source>Index::index</source>
          <target state="translated">Index::index</target>
        </trans-unit>
        <trans-unit id="21d657443793a7fc6c319cfc186e761fac77191e" translate="yes" xml:space="preserve">
          <source>IndexMut</source>
          <target state="translated">IndexMut</target>
        </trans-unit>
        <trans-unit id="24f9ef47b9bb8985e28653af23b1accbf6cd2d9b" translate="yes" xml:space="preserve">
          <source>IndexMut::index_mut</source>
          <target state="translated">IndexMut::index_mut</target>
        </trans-unit>
        <trans-unit id="bda8e2dcef8324d4ce1ba450c4e2e0cae96a9a4a" translate="yes" xml:space="preserve">
          <source>Indexes must be within bounds of the original slice;</source>
          <target state="translated">Los índices deben estar dentro de los límites de la rebanada original;</target>
        </trans-unit>
        <trans-unit id="fa74cb6623de227628f45b4ae93159daddea90b3" translate="yes" xml:space="preserve">
          <source>Indexes must lie on UTF-8 sequence boundaries.</source>
          <target state="translated">Los índices deben estar en los límites de la secuencia UTF-8.</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="8e33bba2a2fe8c945dee904cfed37743c8dd2807" translate="yes" xml:space="preserve">
          <source>Indexing into Strings</source>
          <target state="translated">La indexación en las cadenas</target>
        </trans-unit>
        <trans-unit id="bc1a7f445eecf9a21ddaa6928da85497c3f808d7" translate="yes" xml:space="preserve">
          <source>Indexing into a string is often a bad idea because it&amp;rsquo;s not clear what the return type of the string-indexing operation should be: a byte value, a character, a grapheme cluster, or a string slice. Therefore, Rust asks you to be more specific if you really need to use indices to create string slices. To be more specific in your indexing and indicate that you want a string slice, rather than indexing using &lt;code&gt;[]&lt;/code&gt; with a single number, you can use &lt;code&gt;[]&lt;/code&gt; with a range to create a string slice containing particular bytes:</source>
          <target state="translated">La indexaci&amp;oacute;n en una cadena suele ser una mala idea porque no est&amp;aacute; claro cu&amp;aacute;l deber&amp;iacute;a ser el tipo de retorno de la operaci&amp;oacute;n de indexaci&amp;oacute;n de cadenas: un valor de byte, un car&amp;aacute;cter, un grupo de grafemas o un segmento de cadena. Por lo tanto, Rust le pide que sea m&amp;aacute;s espec&amp;iacute;fico si realmente necesita usar &amp;iacute;ndices para crear cortes de cadenas. Para ser m&amp;aacute;s espec&amp;iacute;fico en su indexaci&amp;oacute;n e indicar que desea un segmento de cadena, en lugar de indexar usando &lt;code&gt;[]&lt;/code&gt; con un solo n&amp;uacute;mero, puede usar &lt;code&gt;[]&lt;/code&gt; con un rango para crear un segmento de cadena que contenga bytes particulares:</target>
        </trans-unit>
        <trans-unit id="6b92d7c5b5fd6e80ddd2c2e71ae6f53dabf14469" translate="yes" xml:space="preserve">
          <source>Indexing is intended to be a constant-time operation, but UTF-8 encoding does not allow us to do this. Furthermore, it's not clear what sort of thing the index should return: a byte, a codepoint, or a grapheme cluster. The &lt;a href=&quot;#method.bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.chars&quot;&gt;&lt;code&gt;chars&lt;/code&gt;&lt;/a&gt; methods return iterators over the first two, respectively.</source>
          <target state="translated">La indexaci&amp;oacute;n est&amp;aacute; destinada a ser una operaci&amp;oacute;n de tiempo constante, pero la codificaci&amp;oacute;n UTF-8 no nos permite hacer esto. Adem&amp;aacute;s, no est&amp;aacute; claro qu&amp;eacute; tipo de cosa deber&amp;iacute;a devolver el &amp;iacute;ndice: un byte, un punto de c&amp;oacute;digo o un grupo de grafemas. Los m&amp;eacute;todos &lt;a href=&quot;#method.bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#method.chars&quot;&gt; &lt;code&gt;chars&lt;/code&gt; &lt;/a&gt; devuelven iteradores sobre los dos primeros, respectivamente.</target>
        </trans-unit>
        <trans-unit id="ceeb8ddb5f53fcb5614444876f148bbebee79484" translate="yes" xml:space="preserve">
          <source>Indexing is intended to be a constant-time operation, but UTF-8 encoding does not allow us to do this. Furthermore, it's not clear what sort of thing the index should return: a byte, a codepoint, or a grapheme cluster. The &lt;a href=&quot;../primitive.str#method.bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.str#method.chars&quot;&gt;&lt;code&gt;chars&lt;/code&gt;&lt;/a&gt; methods return iterators over the first two, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aba4d1ffc3e50a35d8e6bb2627a9921d36e96c9" translate="yes" xml:space="preserve">
          <source>Indexing outside of the bounds of an object with &lt;a href=&quot;../std/primitive.pointer#method.offset&quot;&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/a&gt; with the exception of one byte past the end of the object.</source>
          <target state="translated">Indexaci&amp;oacute;n fuera de los l&amp;iacute;mites de un objeto con &lt;a href=&quot;../std/primitive.pointer#method.offset&quot;&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/a&gt; con la excepci&amp;oacute;n de un byte m&amp;aacute;s all&amp;aacute; del final del objeto.</target>
        </trans-unit>
        <trans-unit id="27caa1fa7c65a4437e649a4888fe129281a79568" translate="yes" xml:space="preserve">
          <source>Indicates if a buffer should be initialized.</source>
          <target state="translated">Indica si se debe inicializar una memoria intermedia.</target>
        </trans-unit>
        <trans-unit id="c4c4786e638c55c48e8eb353954207ab6043189e" translate="yes" xml:space="preserve">
          <source>Indicates that directories should be created recursively, creating all parent directories. Parents that do not exist are created with the same security and permissions settings.</source>
          <target state="translated">Indica que los directorios deben ser creados recursivamente,creando todos los directorios padres.Los padres que no existen se crean con la misma configuración de seguridad y permisos.</target>
        </trans-unit>
        <trans-unit id="4856479107baf14ea55cfdf8d4985b8807716a64" translate="yes" xml:space="preserve">
          <source>Indicates the manner in which a thread exited.</source>
          <target state="translated">Indica la forma en que salió un hilo.</target>
        </trans-unit>
        <trans-unit id="075cfaf01d924967ba4b76beb1cc86c1b8ffbe22" translate="yes" xml:space="preserve">
          <source>Indicates the time-to-live value of outgoing multicast packets for this socket. The default value is 1 which means that multicast packets don't leave the local network unless explicitly requested.</source>
          <target state="translated">Indica el valor de tiempo de vida de los paquetes multicast salientes para este enchufe.El valor por defecto es 1,lo que significa que los paquetes multicast no salen de la red local a menos que se solicite explícitamente.</target>
        </trans-unit>
        <trans-unit id="888a497d6d0feb54c4bc51c8bbfa14e4db0f048b" translate="yes" xml:space="preserve">
          <source>Indicates unfinished code.</source>
          <target state="translated">Indica que el código no está terminado.</target>
        </trans-unit>
        <trans-unit id="35472c24a202b583e18e139d3d561c6674911e84" translate="yes" xml:space="preserve">
          <source>Indicates unimplemented code by panicking with a message of &quot;not implemented&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4862445239fb7cd37f48e6ace7775dcd354d2d14" translate="yes" xml:space="preserve">
          <source>Indicates unreachable code.</source>
          <target state="translated">Indica un código inalcanzable.</target>
        </trans-unit>
        <trans-unit id="cd5cea6e94489fba68a0399bcc4d11feffb0cbe4" translate="yes" xml:space="preserve">
          <source>Indicates whether a value is available or if the current task has been scheduled to receive a wakeup instead.</source>
          <target state="translated">Indica si un valor está disponible o si la tarea actual ha sido programada para recibir un despertar en su lugar.</target>
        </trans-unit>
        <trans-unit id="a5d9b716629f981c5e75c2880c16718258347eb9" translate="yes" xml:space="preserve">
          <source>Indication that contents should be center-aligned.</source>
          <target state="translated">Indicación de que el contenido debe estar alineado en el centro.</target>
        </trans-unit>
        <trans-unit id="582259f836deeb40225aa78333ee7027acddbdbe" translate="yes" xml:space="preserve">
          <source>Indication that contents should be left-aligned.</source>
          <target state="translated">Indicación de que el contenido debe estar alineado a la izquierda.</target>
        </trans-unit>
        <trans-unit id="30524864694504eb9866802047ab21c114fa2091" translate="yes" xml:space="preserve">
          <source>Indication that contents should be right-aligned.</source>
          <target state="translated">Indicación de que el contenido debe estar alineado a la derecha.</target>
        </trans-unit>
        <trans-unit id="f2cd68a3153c21de89ed40993772ed6007b02a6f" translate="yes" xml:space="preserve">
          <source>Indices are zero-based for arrays and slices. Array access is a &lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant expression&lt;/a&gt;, so bounds can be checked at compile-time with a constant index value. Otherwise a check will be performed at run-time that will put the thread in a &lt;em&gt;panicked state&lt;/em&gt; if it fails.</source>
          <target state="translated">Los &amp;iacute;ndices se basan en cero para matrices y sectores. El acceso a la matriz es una &lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;expresi&amp;oacute;n constante&lt;/a&gt; , por lo que los l&amp;iacute;mites se pueden verificar en tiempo de compilaci&amp;oacute;n con un valor de &amp;iacute;ndice constante. De lo contrario, se realizar&amp;aacute; una verificaci&amp;oacute;n en tiempo de ejecuci&amp;oacute;n que pondr&amp;aacute; al hilo en un &lt;em&gt;estado de p&amp;aacute;nico&lt;/em&gt; si falla.</target>
        </trans-unit>
        <trans-unit id="e7d8ee4a5140f0e6e32c94f9ff32453c7e40a4a3" translate="yes" xml:space="preserve">
          <source>Inequality for two &lt;code&gt;Arc&lt;/code&gt;s.</source>
          <target state="translated">Desigualdad por dos &lt;code&gt;Arc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8aa90054db987f32eec9e62690e9b9862d6f642a" translate="yes" xml:space="preserve">
          <source>Inequality for two &lt;code&gt;Rc&lt;/code&gt;s.</source>
          <target state="translated">Desigualdad por dos &lt;code&gt;Rc&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="5d55264281a8b8357477a0b1f6f6a4a72582a08d" translate="yes" xml:space="preserve">
          <source>Inert helper attributes used by procedural macro attributes applied to items are also allowed but be careful to not include these inert attributes in your final &lt;code&gt;TokenStream&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32565cc43897d204c904c25aeddc29a5a2fe5f4d" translate="yes" xml:space="preserve">
          <source>Infallible</source>
          <target state="translated">Infallible</target>
        </trans-unit>
        <trans-unit id="327440953e8036a6b78b97c190dedc5d1ddc1d6f" translate="yes" xml:space="preserve">
          <source>Infallible errors</source>
          <target state="translated">Errores infalibles</target>
        </trans-unit>
        <trans-unit id="379d563f62e4c026be425a08a60de86e8b28b34e" translate="yes" xml:space="preserve">
          <source>Infallible::borrow</source>
          <target state="translated">Infallible::borrow</target>
        </trans-unit>
        <trans-unit id="ffd9adf91cadc5963cf564501d6440dfcb9953d6" translate="yes" xml:space="preserve">
          <source>Infallible::borrow_mut</source>
          <target state="translated">Infallible::borrow_mut</target>
        </trans-unit>
        <trans-unit id="d5161b5d2a0dd973c7749267f912225db6f86b3c" translate="yes" xml:space="preserve">
          <source>Infallible::clamp</source>
          <target state="translated">Infallible::clamp</target>
        </trans-unit>
        <trans-unit id="f9dfe17efa7693fd64ca4bce650f4693dec46e6a" translate="yes" xml:space="preserve">
          <source>Infallible::clone</source>
          <target state="translated">Infallible::clone</target>
        </trans-unit>
        <trans-unit id="7c7c7505a3bdd3e6bbbfabe3c0aa36eea42c2f97" translate="yes" xml:space="preserve">
          <source>Infallible::clone_from</source>
          <target state="translated">Infallible::clone_from</target>
        </trans-unit>
        <trans-unit id="6af6b86ef345c274a60c49262dbedb50a8323471" translate="yes" xml:space="preserve">
          <source>Infallible::clone_into</source>
          <target state="translated">Infallible::clone_into</target>
        </trans-unit>
        <trans-unit id="3f4e892d27a40b0bfaf9fee7ba4a2719e5f0e03b" translate="yes" xml:space="preserve">
          <source>Infallible::cmp</source>
          <target state="translated">Infallible::cmp</target>
        </trans-unit>
        <trans-unit id="465ca79819acd2f64e9c25bd2a18d141db20f7e4" translate="yes" xml:space="preserve">
          <source>Infallible::eq</source>
          <target state="translated">Infallible::eq</target>
        </trans-unit>
        <trans-unit id="7b0120f9faa0f0e51d2f41f2228ccb58415bb901" translate="yes" xml:space="preserve">
          <source>Infallible::fmt</source>
          <target state="translated">Infallible::fmt</target>
        </trans-unit>
        <trans-unit id="7699715e87167505521e297f0cc5acf9571073ba" translate="yes" xml:space="preserve">
          <source>Infallible::from</source>
          <target state="translated">Infallible::from</target>
        </trans-unit>
        <trans-unit id="9ed64ca1536a61aeb71e791f8b0cd35996768800" translate="yes" xml:space="preserve">
          <source>Infallible::ge</source>
          <target state="translated">Infallible::ge</target>
        </trans-unit>
        <trans-unit id="6bc6944b5c980e7843d508d02dcd2bfaf58a503d" translate="yes" xml:space="preserve">
          <source>Infallible::gt</source>
          <target state="translated">Infallible::gt</target>
        </trans-unit>
        <trans-unit id="be25a1605cddc636f6f076ea8d21d97812f2aa85" translate="yes" xml:space="preserve">
          <source>Infallible::into</source>
          <target state="translated">Infallible::into</target>
        </trans-unit>
        <trans-unit id="acae0cd14002a94fe132d6ca88f1fdd5ca563403" translate="yes" xml:space="preserve">
          <source>Infallible::le</source>
          <target state="translated">Infallible::le</target>
        </trans-unit>
        <trans-unit id="2b7d09de5fbcd932797ca9cc160818ef628164b0" translate="yes" xml:space="preserve">
          <source>Infallible::lt</source>
          <target state="translated">Infallible::lt</target>
        </trans-unit>
        <trans-unit id="d981e531de4db6af3fa624928233a62cc48506b0" translate="yes" xml:space="preserve">
          <source>Infallible::max</source>
          <target state="translated">Infallible::max</target>
        </trans-unit>
        <trans-unit id="4e77b6f968c067dfd00c877ce693a33816232a84" translate="yes" xml:space="preserve">
          <source>Infallible::min</source>
          <target state="translated">Infallible::min</target>
        </trans-unit>
        <trans-unit id="1b9bdf4c04b01562bf66a579b3902b4d24df2814" translate="yes" xml:space="preserve">
          <source>Infallible::ne</source>
          <target state="translated">Infallible::ne</target>
        </trans-unit>
        <trans-unit id="593cf3934010f07d135bbd81984d0e7b07060f05" translate="yes" xml:space="preserve">
          <source>Infallible::partial_cmp</source>
          <target state="translated">Infallible::partial_cmp</target>
        </trans-unit>
        <trans-unit id="171d7fff4d94e2b47d18a78e5a1c94a683078c15" translate="yes" xml:space="preserve">
          <source>Infallible::to_owned</source>
          <target state="translated">Infallible::to_owned</target>
        </trans-unit>
        <trans-unit id="256be91884f5591734d76be10903ead44c9f209f" translate="yes" xml:space="preserve">
          <source>Infallible::to_string</source>
          <target state="translated">Infallible::to_string</target>
        </trans-unit>
        <trans-unit id="c3635403870a783a099eedcae587acfb8a52bc1f" translate="yes" xml:space="preserve">
          <source>Infallible::try_from</source>
          <target state="translated">Infallible::try_from</target>
        </trans-unit>
        <trans-unit id="3c8ee4706115d8499f3abf4d51e35db72e1ffd2e" translate="yes" xml:space="preserve">
          <source>Infallible::try_into</source>
          <target state="translated">Infallible::try_into</target>
        </trans-unit>
        <trans-unit id="9701bd213ca2d8e7962b353284539a737fba44f7" translate="yes" xml:space="preserve">
          <source>Infallible::type_id</source>
          <target state="translated">Infallible::type_id</target>
        </trans-unit>
        <trans-unit id="c548ca9534f0b8a6c18d5933d5460cae1f620bec" translate="yes" xml:space="preserve">
          <source>Inferred type</source>
          <target state="translated">Tipo inferido</target>
        </trans-unit>
        <trans-unit id="85dc47997d86458573535c2b6419f71eaedb8bec" translate="yes" xml:space="preserve">
          <source>Infinite iterators like &lt;code&gt;repeat()&lt;/code&gt; are often used with adapters like &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;Iterator::take()&lt;/code&gt;&lt;/a&gt;, in order to make them finite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b827f3090a9999d7251035ec3accdcd8d4fbe7d" translate="yes" xml:space="preserve">
          <source>Infinite iterators like &lt;code&gt;repeat()&lt;/code&gt; are often used with adapters like &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;, in order to make them finite.</source>
          <target state="translated">Los iteradores infinitos como &lt;code&gt;repeat()&lt;/code&gt; se usan a menudo con adaptadores como &lt;a href=&quot;trait.iterator#method.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; , para hacerlos finitos.</target>
        </trans-unit>
        <trans-unit id="2872d343e29a3d0faf1e93a846c0ad3b8146eceb" translate="yes" xml:space="preserve">
          <source>Infinite iterators like &lt;code&gt;repeat_with()&lt;/code&gt; are often used with adapters like &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;Iterator::take()&lt;/code&gt;&lt;/a&gt;, in order to make them finite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e414b3978173634ff311532d9eb1dc73109f5119" translate="yes" xml:space="preserve">
          <source>Infinite iterators like &lt;code&gt;repeat_with()&lt;/code&gt; are often used with adapters like &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;, in order to make them finite.</source>
          <target state="translated">Los iteradores infinitos como &lt;code&gt;repeat_with()&lt;/code&gt; se utilizan a menudo con adaptadores como &lt;a href=&quot;trait.iterator#method.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; , para hacerlos finitos.</target>
        </trans-unit>
        <trans-unit id="a2550f47e7bda60f30b73b2126315e72f6a1181f" translate="yes" xml:space="preserve">
          <source>Infinite loops</source>
          <target state="translated">Bucles infinitos</target>
        </trans-unit>
        <trans-unit id="0219fd54bd5841008b18c414a5b2dea331bad1c5" translate="yes" xml:space="preserve">
          <source>Infinity</source>
          <target state="translated">Infinity</target>
        </trans-unit>
        <trans-unit id="2caa9882f0053ecda17ba6be06a5251c1ec2645f" translate="yes" xml:space="preserve">
          <source>Infinity (&amp;infin;).</source>
          <target state="translated">Infinito (&amp;infin;).</target>
        </trans-unit>
        <trans-unit id="87a3bea62fc4aac2370741613d6bad23fc5e7898" translate="yes" xml:space="preserve">
          <source>Infinity (&amp;infin;). Use &lt;a href=&quot;../primitive.f32#associatedconstant.INFINITY&quot;&gt;&lt;code&gt;f32::INFINITY&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5889ff563c59beba5ff715c644770f8c520445a" translate="yes" xml:space="preserve">
          <source>Infinity (&amp;infin;). Use &lt;a href=&quot;../primitive.f64#associatedconstant.INFINITY&quot;&gt;&lt;code&gt;f64::INFINITY&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="584304393b0ea6955cb4308163835ca022286a68" translate="yes" xml:space="preserve">
          <source>Influences</source>
          <target state="translated">Influences</target>
        </trans-unit>
        <trans-unit id="d42473cc429103c815ee41c99ce227e6800bc064" translate="yes" xml:space="preserve">
          <source>Informally:</source>
          <target state="translated">Informally:</target>
        </trans-unit>
        <trans-unit id="50473fcaee3f0826f522b7d9bde1dee298665a6b" translate="yes" xml:space="preserve">
          <source>Informs the compiler that this point in the code is not reachable, enabling further optimizations.</source>
          <target state="translated">Informa al compilador de que este punto del código no es alcanzable,lo que permite mayores optimizaciones.</target>
        </trans-unit>
        <trans-unit id="da26edc8a2a6b051f930b8dc35ea3b2d2eb04a3f" translate="yes" xml:space="preserve">
          <source>Informs the optimizer that a condition is always true. If the condition is false, the behavior is undefined.</source>
          <target state="translated">Informa al optimizador de que una condición es siempre verdadera.Si la condición es falsa,el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="7ae97ac101c4619f2cdd3e3df7584b679394eca7" translate="yes" xml:space="preserve">
          <source>Inhabited</source>
          <target state="translated">Inhabited</target>
        </trans-unit>
        <trans-unit id="b07b5b517980bf88c19321ee29f23f8a21e0b4de" translate="yes" xml:space="preserve">
          <source>Inherent Implementations</source>
          <target state="translated">Implementaciones inherentes</target>
        </trans-unit>
        <trans-unit id="bf73ea65fd18a78a9021507f0c11c78ed2ec5124" translate="yes" xml:space="preserve">
          <source>Inherent associated types were part of &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md&quot;&gt;RFC 195&lt;/a&gt; but are not yet implemented. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/8995&quot;&gt;the tracking issue&lt;/a&gt; for the status of this implementation.</source>
          <target state="translated">Los tipos asociados inherentes eran parte de &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md&quot;&gt;RFC 195&lt;/a&gt; pero a&amp;uacute;n no se han implementado. Consulte &lt;a href=&quot;https://github.com/rust-lang/rust/issues/8995&quot;&gt;el problema de seguimiento&lt;/a&gt; para conocer el estado de esta implementaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f47cc0e78be269b94ff1fbb506eefabb2d14cd1d" translate="yes" xml:space="preserve">
          <source>Inherent implementation</source>
          <target state="translated">Aplicación inherente</target>
        </trans-unit>
        <trans-unit id="89d8c2e2efc6fafd98f5603953f0cb702613d6d3" translate="yes" xml:space="preserve">
          <source>Inherent implementations (one that do not implement a trait but provide methods associated with a type) are always safe because they are not implementing an unsafe trait. Removing the &lt;code&gt;unsafe&lt;/code&gt; keyword from the inherent implementation will resolve this error.</source>
          <target state="translated">Las implementaciones inherentes (una que no implementa un rasgo pero proporciona m&amp;eacute;todos asociados con un tipo) siempre son seguras porque no implementan un rasgo inseguro. Eliminar la palabra clave &lt;code&gt;unsafe&lt;/code&gt; de la implementaci&amp;oacute;n inherente resolver&amp;aacute; este error.</target>
        </trans-unit>
        <trans-unit id="02407dbce9ca24cc02710598fc24ae8f49c07a7e" translate="yes" xml:space="preserve">
          <source>Inherent implementations associate the contained items to the implementing type. Inherent implementations can contain &lt;a href=&quot;associated-items#associated-functions-and-methods&quot;&gt;associated functions&lt;/a&gt; (including methods) and &lt;a href=&quot;associated-items#associated-constants&quot;&gt;associated constants&lt;/a&gt;. They cannot contain associated type aliases.</source>
          <target state="translated">Las implementaciones inherentes asocian los elementos contenidos al tipo de implementaci&amp;oacute;n. Las implementaciones inherentes pueden contener &lt;a href=&quot;associated-items#associated-functions-and-methods&quot;&gt;funciones asociadas&lt;/a&gt; (incluidos m&amp;eacute;todos) y &lt;a href=&quot;associated-items#associated-constants&quot;&gt;constantes asociadas&lt;/a&gt; . No pueden contener alias de tipo asociados.</target>
        </trans-unit>
        <trans-unit id="4ccb704ced0ac70357d35287cb1c67388f967d06" translate="yes" xml:space="preserve">
          <source>Inherent method</source>
          <target state="translated">Método inherente</target>
        </trans-unit>
        <trans-unit id="c7a774bf3dce2aac99ad48347458653bbd55d325" translate="yes" xml:space="preserve">
          <source>Inherit stdin/stdout/stderr for &lt;code&gt;spawn&lt;/code&gt; or &lt;code&gt;status&lt;/code&gt;, but create pipes for &lt;code&gt;output&lt;/code&gt;</source>
          <target state="translated">Herede stdin / stdout / stderr para &lt;code&gt;spawn&lt;/code&gt; o &lt;code&gt;status&lt;/code&gt; , pero cree tuber&amp;iacute;as para la &lt;code&gt;output&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9f4e94fb7b802199fb91e731b50847b79d9607c1" translate="yes" xml:space="preserve">
          <source>Inherit the current process's environment</source>
          <target state="translated">Heredar el entorno del proceso actual</target>
        </trans-unit>
        <trans-unit id="44c348c84d3785ac5adb30ee3d2d10f68e971317" translate="yes" xml:space="preserve">
          <source>Inherit the current process's working directory</source>
          <target state="translated">Heredar el directorio de trabajo del proceso actual</target>
        </trans-unit>
        <trans-unit id="6325b69277e854d2ebda5c6558b946870708063a" translate="yes" xml:space="preserve">
          <source>Inheritance as a Type System and as Code Sharing</source>
          <target state="translated">La herencia como sistema de tipos y como código compartido</target>
        </trans-unit>
        <trans-unit id="c561edc4e8c488ada0373bbdca70237bf7b2c36a" translate="yes" xml:space="preserve">
          <source>Inheritance has recently fallen out of favor as a programming design solution in many programming languages because it&amp;rsquo;s often at risk of sharing more code than necessary. Subclasses shouldn&amp;rsquo;t always share all characteristics of their parent class but will do so with inheritance. This can make a program&amp;rsquo;s design less flexible. It also introduces the possibility of calling methods on subclasses that don&amp;rsquo;t make sense or that cause errors because the methods don&amp;rsquo;t apply to the subclass. In addition, some languages will only allow a subclass to inherit from one class, further restricting the flexibility of a program&amp;rsquo;s design.</source>
          <target state="translated">La herencia ha ca&amp;iacute;do recientemente en desgracia como soluci&amp;oacute;n de dise&amp;ntilde;o de programaci&amp;oacute;n en muchos lenguajes de programaci&amp;oacute;n porque a menudo se corre el riesgo de compartir m&amp;aacute;s c&amp;oacute;digo del necesario. Las subclases no siempre deben compartir todas las caracter&amp;iacute;sticas de su clase principal, pero lo har&amp;aacute;n con herencia. Esto puede hacer que el dise&amp;ntilde;o de un programa sea menos flexible. Tambi&amp;eacute;n introduce la posibilidad de llamar a m&amp;eacute;todos en subclases que no tienen sentido o que causan errores porque los m&amp;eacute;todos no se aplican a la subclase. Adem&amp;aacute;s, algunos lenguajes solo permitir&amp;aacute;n que una subclase herede de una clase, restringiendo a&amp;uacute;n m&amp;aacute;s la flexibilidad del dise&amp;ntilde;o de un programa.</target>
        </trans-unit>
        <trans-unit id="2e8b04bb573d36dddf2182bf5af08f053f087e52" translate="yes" xml:space="preserve">
          <source>Initial values</source>
          <target state="translated">Valores iniciales</target>
        </trans-unit>
        <trans-unit id="c904b3e1f2d0c5d733b728b7a681f23a1ee75fda" translate="yes" xml:space="preserve">
          <source>Initialization and Destruction</source>
          <target state="translated">Inicialización y destrucción</target>
        </trans-unit>
        <trans-unit id="13d802cdbafe0031cbe0ff944c50f80b718c2135" translate="yes" xml:space="preserve">
          <source>Initialization invariant</source>
          <target state="translated">Invariante de inicialización</target>
        </trans-unit>
        <trans-unit id="e4de29eb027f99abd844645c1796c2a7a7d72482" translate="yes" xml:space="preserve">
          <source>Initialization is dynamically performed on the first call to &lt;a href=&quot;struct.localkey#method.with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; within a thread, and values that implement &lt;a href=&quot;../ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; get destructed when a thread exits. Some caveats apply, which are explained below.</source>
          <target state="translated">La inicializaci&amp;oacute;n se realiza din&amp;aacute;micamente en la primera llamada a &lt;a href=&quot;struct.localkey#method.with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; dentro de un hilo, y los valores que implementan &lt;a href=&quot;../ops/trait.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; &lt;/a&gt; se destruyen cuando sale un hilo. Se aplican algunas advertencias, que se explican a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b12d9d28ca06ab166730d1a0be67505b54f2b263" translate="yes" xml:space="preserve">
          <source>Initialization of a union</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db21316277d9b77e6330bd9b3d2303f36118171f" translate="yes" xml:space="preserve">
          <source>Initialization value for static &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; values.</source>
          <target state="translated">Valor de inicializaci&amp;oacute;n para valores &lt;a href=&quot;struct.once&quot;&gt; &lt;code&gt;Once&lt;/code&gt; &lt;/a&gt; est&amp;aacute;ticos .</target>
        </trans-unit>
        <trans-unit id="777041461872120636aa50d7bf36c832a7f4df98" translate="yes" xml:space="preserve">
          <source>Initialize a result to &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; before a loop:</source>
          <target state="translated">Inicialice un resultado en &lt;a href=&quot;enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; antes de un bucle:</target>
        </trans-unit>
        <trans-unit id="26ac5e37d496de00bf60e19d042275381e3527b3" translate="yes" xml:space="preserve">
          <source>Initialized</source>
          <target state="translated">Initialized</target>
        </trans-unit>
        <trans-unit id="0c55ba13e2bd9dbfd35641ebe93792c6061e39cd" translate="yes" xml:space="preserve">
          <source>Initializer</source>
          <target state="translated">Initializer</target>
        </trans-unit>
        <trans-unit id="cb5407ce66e9cc74c7b9cdad45d317b358a42346" translate="yes" xml:space="preserve">
          <source>Initializer::borrow</source>
          <target state="translated">Initializer::borrow</target>
        </trans-unit>
        <trans-unit id="9329992da7e67d3d87b950443458d66c568d4935" translate="yes" xml:space="preserve">
          <source>Initializer::borrow_mut</source>
          <target state="translated">Initializer::borrow_mut</target>
        </trans-unit>
        <trans-unit id="8b338b461eda8eab3ac52c21c7ba950b55ddab77" translate="yes" xml:space="preserve">
          <source>Initializer::fmt</source>
          <target state="translated">Initializer::fmt</target>
        </trans-unit>
        <trans-unit id="370ad1ce33d717e00bfed251c3d4bf09120c4049" translate="yes" xml:space="preserve">
          <source>Initializer::from</source>
          <target state="translated">Initializer::from</target>
        </trans-unit>
        <trans-unit id="26ef6fd69d6de0da79344847b51c3c8c83e2b8cc" translate="yes" xml:space="preserve">
          <source>Initializer::initialize</source>
          <target state="translated">Initializer::initialize</target>
        </trans-unit>
        <trans-unit id="bdae64fb5268754bb9cc8ae6c8db2ab2a08fdbc3" translate="yes" xml:space="preserve">
          <source>Initializer::into</source>
          <target state="translated">Initializer::into</target>
        </trans-unit>
        <trans-unit id="a79949e93a459b7f8ca5406e877e55f5660e5c75" translate="yes" xml:space="preserve">
          <source>Initializer::nop</source>
          <target state="translated">Initializer::nop</target>
        </trans-unit>
        <trans-unit id="dcb257db32b009bda392da62101575610abd1f91" translate="yes" xml:space="preserve">
          <source>Initializer::should_initialize</source>
          <target state="translated">Initializer::should_initialize</target>
        </trans-unit>
        <trans-unit id="bcab8cf375f63f790f0ce8e05777079bda310ea7" translate="yes" xml:space="preserve">
          <source>Initializer::try_from</source>
          <target state="translated">Initializer::try_from</target>
        </trans-unit>
        <trans-unit id="1ce33c3dc308ea20a9c3e23385d3fd4e6cdbc2f0" translate="yes" xml:space="preserve">
          <source>Initializer::try_into</source>
          <target state="translated">Initializer::try_into</target>
        </trans-unit>
        <trans-unit id="7015bd93154feb364c2957b0fc2cdb3fe5bb0863" translate="yes" xml:space="preserve">
          <source>Initializer::type_id</source>
          <target state="translated">Initializer::type_id</target>
        </trans-unit>
        <trans-unit id="38d15bea38cc632ed42db7368869a2581cd9ac0d" translate="yes" xml:space="preserve">
          <source>Initializer::zeroing</source>
          <target state="translated">Initializer::zeroing</target>
        </trans-unit>
        <trans-unit id="b02eff8ddabee28d5ce99312e8bd3930e76e09a5" translate="yes" xml:space="preserve">
          <source>Initializes a buffer if necessary.</source>
          <target state="translated">Inicializa un buffer si es necesario.</target>
        </trans-unit>
        <trans-unit id="c1014a628ca9687c4db754c43f3628d84e3050c5" translate="yes" xml:space="preserve">
          <source>Initializing a struct field-by-field</source>
          <target state="translated">Iniciando una estructura campo por campo</target>
        </trans-unit>
        <trans-unit id="6d9d88d804a2b918f6a240e649b5e1a2aa5a1b6e" translate="yes" xml:space="preserve">
          <source>Initializing an array element-by-element</source>
          <target state="translated">Iniciando una matriz elemento por elemento</target>
        </trans-unit>
        <trans-unit id="e30e79f506a4a7b48aa6bd2ea1d1c98586736d96" translate="yes" xml:space="preserve">
          <source>Initially, the Rust team thought that ensuring memory safety and preventing concurrency problems were two separate challenges to be solved with different methods. Over time, the team discovered that the ownership and type systems are a powerful set of tools to help manage memory safety &lt;em&gt;and&lt;/em&gt; concurrency problems! By leveraging ownership and type checking, many concurrency errors are compile-time errors in Rust rather than runtime errors. Therefore, rather than making you spend lots of time trying to reproduce the exact circumstances under which a runtime concurrency bug occurs, incorrect code will refuse to compile and present an error explaining the problem. As a result, you can fix your code while you&amp;rsquo;re working on it rather than potentially after it has been shipped to production. We&amp;rsquo;ve nicknamed this aspect of Rust &lt;em&gt;fearless&lt;/em&gt;&lt;em&gt;concurrency&lt;/em&gt;. Fearless concurrency allows you to write code that is free of subtle bugs and is easy to refactor without introducing new bugs.</source>
          <target state="translated">Inicialmente, el equipo de Rust pens&amp;oacute; que garantizar la seguridad de la memoria y prevenir problemas de concurrencia eran dos desaf&amp;iacute;os separados que deb&amp;iacute;an resolverse con diferentes m&amp;eacute;todos. Con el tiempo, el equipo descubri&amp;oacute; que los sistemas de propiedad y tipo son un poderoso conjunto de herramientas para ayudar a administrar la seguridad de la memoria &lt;em&gt;y&lt;/em&gt;problemas de concurrencia! Al aprovechar la propiedad y la verificaci&amp;oacute;n de tipos, muchos errores de concurrencia son errores en tiempo de compilaci&amp;oacute;n en Rust en lugar de errores en tiempo de ejecuci&amp;oacute;n. Por lo tanto, en lugar de hacerle pasar mucho tiempo tratando de reproducir las circunstancias exactas en las que ocurre un error de concurrencia en tiempo de ejecuci&amp;oacute;n, el c&amp;oacute;digo incorrecto se negar&amp;aacute; a compilar y presentar&amp;aacute; un error que explica el problema. Como resultado, puede corregir su c&amp;oacute;digo mientras trabaja en &amp;eacute;l en lugar de potencialmente despu&amp;eacute;s de que se haya enviado a producci&amp;oacute;n. Hemos apodado este aspecto de la &lt;em&gt;intr&amp;eacute;pida &lt;/em&gt;&lt;em&gt;concurrencia&lt;/em&gt; de Rust . La simultaneidad intr&amp;eacute;pida le permite escribir c&amp;oacute;digo que est&amp;aacute; libre de errores sutiles y es f&amp;aacute;cil de refactorizar sin introducir errores nuevos.</target>
        </trans-unit>
        <trans-unit id="377c3360b199ab4bedae33ce6d834fe07f041fe6" translate="yes" xml:space="preserve">
          <source>Inline assembly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7a13c17feda3ff04e933d53202cd41c94dace05" translate="yes" xml:space="preserve">
          <source>Inner attribute</source>
          <target state="translated">Atributo interno</target>
        </trans-unit>
        <trans-unit id="565c802152b12c7dd9aea0fe59ebaacf3d1a82a3" translate="yes" xml:space="preserve">
          <source>Inner block doc comment</source>
          <target state="translated">Comentario del médico del bloque interno</target>
        </trans-unit>
        <trans-unit id="af507067e5f2cec421f889124df4ee46c1a92bbf" translate="yes" xml:space="preserve">
          <source>Inner document can only be used before items. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ca5fb7f033a9d40e84c1a1a0c29b149dc2c2561" translate="yes" xml:space="preserve">
          <source>Inner functions do not have access to their containing environment. To fix this error, you can replace the function with a closure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10264f133a74f365cfab7999c77a7091803d2786" translate="yes" xml:space="preserve">
          <source>Inner items do not inherit type or const parameters from the functions they are embedded in.</source>
          <target state="translated">Los elementos internos no heredan parámetros de tipo o constancia de las funciones en las que están incrustados.</target>
        </trans-unit>
        <trans-unit id="6909dc9a044dcde9a4fe7603daf0a9a52557aba3" translate="yes" xml:space="preserve">
          <source>Inner line doc comment</source>
          <target state="translated">Comentario del doctor de la línea interna</target>
        </trans-unit>
        <trans-unit id="1b77a7f4983f9ce773f466c761a7f6e9771bf925" translate="yes" xml:space="preserve">
          <source>Input format</source>
          <target state="translated">Formato de entrada</target>
        </trans-unit>
        <trans-unit id="daf107c7f6d6d3a06676862d762621e314a3de24" translate="yes" xml:space="preserve">
          <source>Insert and complex keys</source>
          <target state="translated">Insertar y teclas complejas</target>
        </trans-unit>
        <trans-unit id="3d9eeb934e6164d2c24b6394e6758d068509ccb2" translate="yes" xml:space="preserve">
          <source>Insertion and popping the largest element have &lt;code&gt;O(log n)&lt;/code&gt; time complexity. Checking the largest element is &lt;code&gt;O(1)&lt;/code&gt;. Converting a vector to a binary heap can be done in-place, and has &lt;code&gt;O(n)&lt;/code&gt; complexity. A binary heap can also be converted to a sorted vector in-place, allowing it to be used for an &lt;code&gt;O(n log n)&lt;/code&gt; in-place heapsort.</source>
          <target state="translated">La inserci&amp;oacute;n y la extracci&amp;oacute;n del elemento m&amp;aacute;s grande tienen una complejidad de tiempo &lt;code&gt;O(log n)&lt;/code&gt; . La verificaci&amp;oacute;n del elemento m&amp;aacute;s grande es &lt;code&gt;O(1)&lt;/code&gt; . La conversi&amp;oacute;n de un vector en un mont&amp;oacute;n binario se puede realizar en el lugar y tiene una complejidad &lt;code&gt;O(n)&lt;/code&gt; . Un mont&amp;oacute;n binario tambi&amp;eacute;n se puede convertir en un vector ordenado en el lugar, lo que permite que se utilice para un heapsort local &lt;code&gt;O(n log n)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3054fc5d210400311e9f74c38361908c7518246" translate="yes" xml:space="preserve">
          <source>Insertion and popping the largest element have &lt;em&gt;O&lt;/em&gt;(log(&lt;em&gt;n&lt;/em&gt;)) time complexity. Checking the largest element is &lt;em&gt;O&lt;/em&gt;(1). Converting a vector to a binary heap can be done in-place, and has &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) complexity. A binary heap can also be converted to a sorted vector in-place, allowing it to be used for an &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt; * log(&lt;em&gt;n&lt;/em&gt;)) in-place heapsort.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0b51cb1a3f7392b32f519dbb88d97e332d11c69" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;v&lt;/code&gt; into the option if it is &lt;a href=&quot;#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then returns a mutable reference to the contained value.</source>
          <target state="translated">Inserta &lt;code&gt;v&lt;/code&gt; en la opci&amp;oacute;n si es &lt;a href=&quot;#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , luego devuelve una referencia mutable al valor contenido.</target>
        </trans-unit>
        <trans-unit id="ea064b5e532406cd5efbee55897b1c3c1824866f" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;v&lt;/code&gt; into the option if it is &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then returns a mutable reference to the contained value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94836515b3818e2e9860b9063cc6b9696a633f85" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; into the option if it is &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then returns a mutable reference to the contained value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec673856ac415b2c56f7363563f20a74b9ab6742" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; into the option then returns a mutable reference to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="633ef776ac14fc1a5ba3722ac27ba6e3e9e74927" translate="yes" xml:space="preserve">
          <source>Inserts a character into this &lt;code&gt;String&lt;/code&gt; at a byte position.</source>
          <target state="translated">Inserta un car&amp;aacute;cter en esta &lt;code&gt;String&lt;/code&gt; en una posici&amp;oacute;n de byte.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
