<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="fe9cf4a133a88b8bc470c4394f4eb8cf3b306e68" translate="yes" xml:space="preserve">
          <source>This is an alias to &lt;a href=&quot;../fs/fn.read_dir&quot;&gt;&lt;code&gt;fs::read_dir&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Este es un alias para &lt;a href=&quot;../fs/fn.read_dir&quot;&gt; &lt;code&gt;fs::read_dir&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f461dafd60906d9babd38850b381951321bafa0a" translate="yes" xml:space="preserve">
          <source>This is an alias to &lt;a href=&quot;../fs/fn.read_link&quot;&gt;&lt;code&gt;fs::read_link&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Este es un alias para &lt;a href=&quot;../fs/fn.read_link&quot;&gt; &lt;code&gt;fs::read_link&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8a772f821d093dc45f53501fe5deb3218dd74356" translate="yes" xml:space="preserve">
          <source>This is an alias to &lt;a href=&quot;../fs/fn.symlink_metadata&quot;&gt;&lt;code&gt;fs::symlink_metadata&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Este es un alias para &lt;a href=&quot;../fs/fn.symlink_metadata&quot;&gt; &lt;code&gt;fs::symlink_metadata&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d34ac7564172d2ff8117857aff9df3320c42fae5" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;Ref::clone(...)&lt;/code&gt;. A &lt;code&gt;Clone&lt;/code&gt; implementation or a method would interfere with the widespread use of &lt;code&gt;r.borrow().clone()&lt;/code&gt; to clone the contents of a &lt;code&gt;RefCell&lt;/code&gt;.</source>
          <target state="translated">Esta es una funci&amp;oacute;n asociada que debe usarse como &lt;code&gt;Ref::clone(...)&lt;/code&gt; . Una implementaci&amp;oacute;n &lt;code&gt;Clone&lt;/code&gt; o un m&amp;eacute;todo interferir&amp;iacute;a con el uso generalizado de &lt;code&gt;r.borrow().clone()&lt;/code&gt; para clonar el contenido de una &lt;code&gt;RefCell&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0de597cdfc25d4b695eb376a8a0838157803d015" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;Ref::leak(...)&lt;/code&gt;. A method would interfere with methods of the same name on the contents of a &lt;code&gt;RefCell&lt;/code&gt; used through &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f83e3e547dadb3f845f93bfeaf6231ee030e91c8" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;Ref::map(...)&lt;/code&gt;. A method would interfere with methods of the same name on the contents of a &lt;code&gt;RefCell&lt;/code&gt; used through &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">Esta es una funci&amp;oacute;n asociada que debe usarse como &lt;code&gt;Ref::map(...)&lt;/code&gt; . Un m&amp;eacute;todo interferir&amp;iacute;a con m&amp;eacute;todos del mismo nombre en el contenido de una &lt;code&gt;RefCell&lt;/code&gt; utilizada a trav&amp;eacute;s de &lt;code&gt;Deref&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f18aedd0b02030c35b1012078adf973833d874e" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;Ref::map_split(...)&lt;/code&gt;. A method would interfere with methods of the same name on the contents of a &lt;code&gt;RefCell&lt;/code&gt; used through &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">Esta es una funci&amp;oacute;n asociada que debe usarse como &lt;code&gt;Ref::map_split(...)&lt;/code&gt; . Un m&amp;eacute;todo interferir&amp;iacute;a con m&amp;eacute;todos del mismo nombre en el contenido de una &lt;code&gt;RefCell&lt;/code&gt; utilizada a trav&amp;eacute;s de &lt;code&gt;Deref&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9124c09eb61044a9051beed91e77bd6ffcbf176" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;RefMut::leak(...)&lt;/code&gt;. A method would interfere with methods of the same name on the contents of a &lt;code&gt;RefCell&lt;/code&gt; used through &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14ab5139ea01a60d2224bebc358fd7f5a09aee7b" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;RefMut::map(...)&lt;/code&gt;. A method would interfere with methods of the same name on the contents of a &lt;code&gt;RefCell&lt;/code&gt; used through &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">Esta es una funci&amp;oacute;n asociada que debe usarse como &lt;code&gt;RefMut::map(...)&lt;/code&gt; . Un m&amp;eacute;todo interferir&amp;iacute;a con m&amp;eacute;todos del mismo nombre en el contenido de una &lt;code&gt;RefCell&lt;/code&gt; utilizada a trav&amp;eacute;s de &lt;code&gt;Deref&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="202f23e551bc61ba34f51a486b60ddfce30150ab" translate="yes" xml:space="preserve">
          <source>This is an associated function that needs to be used as &lt;code&gt;RefMut::map_split(...)&lt;/code&gt;. A method would interfere with methods of the same name on the contents of a &lt;code&gt;RefCell&lt;/code&gt; used through &lt;code&gt;Deref&lt;/code&gt;.</source>
          <target state="translated">Esta es una funci&amp;oacute;n asociada que debe usarse como &lt;code&gt;RefMut::map_split(...)&lt;/code&gt; . Un m&amp;eacute;todo interferir&amp;iacute;a con m&amp;eacute;todos del mismo nombre en el contenido de una &lt;code&gt;RefCell&lt;/code&gt; utilizada a trav&amp;eacute;s de &lt;code&gt;Deref&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb3bd037be08bb82591900e7ddf468637a2b8c80" translate="yes" xml:space="preserve">
          <source>This is appropriate for initializing uninitialized memory, or overwriting memory that has previously been &lt;a href=&quot;fn.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; from.</source>
          <target state="translated">Esto es apropiado para inicializar la memoria no inicializada o sobrescribir la memoria que se ha &lt;a href=&quot;fn.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; previamente .</target>
        </trans-unit>
        <trans-unit id="856709efbf0ee049257184bc9760c0b3d18a43eb" translate="yes" xml:space="preserve">
          <source>This is appropriate for initializing uninitialized memory, or overwriting memory that has previously been read with &lt;a href=&quot;fn.read_unaligned&quot;&gt;&lt;code&gt;read_unaligned&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esto es apropiado para inicializar la memoria no inicializada o sobrescribir la memoria que se ha le&amp;iacute;do previamente con &lt;a href=&quot;fn.read_unaligned&quot;&gt; &lt;code&gt;read_unaligned&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9049d14f9f0cb6f47694e4f8dd6256baa32e595c" translate="yes" xml:space="preserve">
          <source>This is based on &lt;code&gt;malloc&lt;/code&gt; on Unix platforms and &lt;code&gt;HeapAlloc&lt;/code&gt; on Windows, plus related functions.</source>
          <target state="translated">Esto se basa en &lt;code&gt;malloc&lt;/code&gt; en plataformas Unix y &lt;code&gt;HeapAlloc&lt;/code&gt; en Windows, adem&amp;aacute;s de funciones relacionadas.</target>
        </trans-unit>
        <trans-unit id="d9e17b1971fcc8ebac923ca9bdcdbe86fd7ccc27" translate="yes" xml:space="preserve">
          <source>This is because &lt;code&gt;AddAssign&lt;/code&gt; is not automatically implemented, so you need to manually implement it for your type.</source>
          <target state="translated">Esto se debe a que &lt;code&gt;AddAssign&lt;/code&gt; no se implementa autom&amp;aacute;ticamente, por lo que debe implementarlo manualmente para su tipo.</target>
        </trans-unit>
        <trans-unit id="5c0cfc8e697e9e04f2ac8988522860bd36ed371a" translate="yes" xml:space="preserve">
          <source>This is because cell types do operations that are not thread-safe. Due to this, they don't implement Sync and thus can't be placed in statics.</source>
          <target state="translated">Esto se debe a que los tipos de células realizan operaciones que no son seguras para los hilos.Debido a esto,no implementan la sincronización y por lo tanto no pueden ser colocados en estática.</target>
        </trans-unit>
        <trans-unit id="43247ccf0e7189f6826d62c195b63176c827f652" translate="yes" xml:space="preserve">
          <source>This is because of a type mismatch between the associated type of some trait (e.g., &lt;code&gt;T::Bar&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;trait Quux { type Bar; }&lt;/code&gt;) and another type &lt;code&gt;U&lt;/code&gt; that is required to be equal to &lt;code&gt;T::Bar&lt;/code&gt;, but is not. Examples follow.</source>
          <target state="translated">Esto se debe a una discrepancia de tipos entre el tipo asociado de alg&amp;uacute;n rasgo (por ejemplo, &lt;code&gt;T::Bar&lt;/code&gt; , donde &lt;code&gt;T&lt;/code&gt; implementa el &lt;code&gt;trait Quux { type Bar; }&lt;/code&gt; ) y otro tipo &lt;code&gt;U&lt;/code&gt; que debe ser igual a &lt;code&gt;T::Bar&lt;/code&gt; , pero no es. A continuaci&amp;oacute;n se muestran algunos ejemplos.</target>
        </trans-unit>
        <trans-unit id="0e543293d9c4cb900df2afb34a1c801950192149" translate="yes" xml:space="preserve">
          <source>This is because there could exist &lt;code&gt;V&lt;/code&gt; types with multiple &lt;code&gt;Borrow&amp;lt;[_]&amp;gt;&lt;/code&gt; impls, such that multiple &lt;code&gt;T&lt;/code&gt; types would apply:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a641717e833808f9f0bc4f5f362a54b6a1faff5b" translate="yes" xml:space="preserve">
          <source>This is borrow-generalized version of &lt;code&gt;Clone::clone_from&lt;/code&gt;.</source>
          <target state="translated">Esta es la versi&amp;oacute;n generalizada prestada de &lt;code&gt;Clone::clone_from&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="834216017331c86ca1e125eb990783c9079a99f6" translate="yes" xml:space="preserve">
          <source>This is called the &amp;ldquo;train model&amp;rdquo; because every six weeks, a release &amp;ldquo;leaves the station&amp;rdquo;, but still has to take a journey through the beta channel before it arrives as a stable release.</source>
          <target state="translated">A esto se le llama el &quot;modelo de tren&quot; porque cada seis semanas, una versi&amp;oacute;n &quot;sale de la estaci&amp;oacute;n&quot;, pero a&amp;uacute;n tiene que hacer un viaje a trav&amp;eacute;s del canal beta antes de llegar como una versi&amp;oacute;n estable.</target>
        </trans-unit>
        <trans-unit id="d83e7e82097d376958eb95d5e51d98e6719f2542" translate="yes" xml:space="preserve">
          <source>This is catastrophic, it means we can first pin the content of the &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; (using &lt;code&gt;RefCell::get_pin_mut&lt;/code&gt;) and then move that content using the mutable reference we got later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9e339d64ba30c9973394f6282049233c7be4f71" translate="yes" xml:space="preserve">
          <source>This is catastrophic, it means we can first pin the content of the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; (using &lt;code&gt;RefCell::get_pin_mut&lt;/code&gt;) and then move that content using the mutable reference we got later.</source>
          <target state="translated">Esto es catastr&amp;oacute;fico, significa que primero podemos anclar el contenido de &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; (usando &lt;code&gt;RefCell::get_pin_mut&lt;/code&gt; ) y luego mover ese contenido usando la referencia mutable que obtuvimos m&amp;aacute;s tarde.</target>
        </trans-unit>
        <trans-unit id="9ed19556018375489742916bfb6ea73b08918fbf" translate="yes" xml:space="preserve">
          <source>This is commonly used to adapt a single value generator into a &lt;a href=&quot;trait.iterator#method.chain&quot;&gt;&lt;code&gt;chain()&lt;/code&gt;&lt;/a&gt; of other kinds of iteration. Maybe you have an iterator that covers almost everything, but you need an extra special case. Maybe you have a function which works on iterators, but you only need to process one value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67913f9219472099fcca84773f5f227006ffbcce" translate="yes" xml:space="preserve">
          <source>This is commonly used to adapt a single value generator into a &lt;a href=&quot;trait.iterator#method.chain&quot;&gt;&lt;code&gt;chain&lt;/code&gt;&lt;/a&gt; of other kinds of iteration. Maybe you have an iterator that covers almost everything, but you need an extra special case. Maybe you have a function which works on iterators, but you only need to process one value.</source>
          <target state="translated">Esto se usa com&amp;uacute;nmente para adaptar un generador de valor &amp;uacute;nico en una &lt;a href=&quot;trait.iterator#method.chain&quot;&gt; &lt;code&gt;chain&lt;/code&gt; &lt;/a&gt; de otros tipos de iteraci&amp;oacute;n. Tal vez tenga un iterador que cubra casi todo, pero necesita un caso especial adicional. Tal vez tenga una funci&amp;oacute;n que funcione en iteradores, pero solo necesita procesar un valor.</target>
        </trans-unit>
        <trans-unit id="507d399d0caa748ec0f687d63827f62d38ea93b1" translate="yes" xml:space="preserve">
          <source>This is commonly used to adapt a single value into a &lt;a href=&quot;trait.iterator#method.chain&quot;&gt;&lt;code&gt;chain()&lt;/code&gt;&lt;/a&gt; of other kinds of iteration. Maybe you have an iterator that covers almost everything, but you need an extra special case. Maybe you have a function which works on iterators, but you only need to process one value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="764e0240ad7ec9a9585ed8305ceb8e8099f2723d" translate="yes" xml:space="preserve">
          <source>This is commonly used to adapt a single value into a &lt;a href=&quot;trait.iterator#method.chain&quot;&gt;&lt;code&gt;chain&lt;/code&gt;&lt;/a&gt; of other kinds of iteration. Maybe you have an iterator that covers almost everything, but you need an extra special case. Maybe you have a function which works on iterators, but you only need to process one value.</source>
          <target state="translated">Esto se usa com&amp;uacute;nmente para adaptar un valor &amp;uacute;nico en una &lt;a href=&quot;trait.iterator#method.chain&quot;&gt; &lt;code&gt;chain&lt;/code&gt; &lt;/a&gt; de otros tipos de iteraciones. Tal vez tenga un iterador que cubra casi todo, pero necesita un caso especial adicional. Tal vez tenga una funci&amp;oacute;n que funcione en iteradores, pero solo necesita procesar un valor.</target>
        </trans-unit>
        <trans-unit id="f239b530d28c30ec1070f1658b16620a287e3251" translate="yes" xml:space="preserve">
          <source>This is correct (explicit):</source>
          <target state="translated">Esto es correcto (explícito):</target>
        </trans-unit>
        <trans-unit id="7d6342cfa6f9200a801992dcf925b5cee5be4a5b" translate="yes" xml:space="preserve">
          <source>This is currently identical to &lt;code&gt;transmute::&amp;lt;f32, u32&amp;gt;(self)&lt;/code&gt; on all platforms.</source>
          <target state="translated">Esto es actualmente id&amp;eacute;ntico a &lt;code&gt;transmute::&amp;lt;f32, u32&amp;gt;(self)&lt;/code&gt; en todas las plataformas.</target>
        </trans-unit>
        <trans-unit id="a48f92d085d1c5423be432a065e6504acd5a4a36" translate="yes" xml:space="preserve">
          <source>This is currently identical to &lt;code&gt;transmute::&amp;lt;f64, u64&amp;gt;(self)&lt;/code&gt; on all platforms.</source>
          <target state="translated">Actualmente es id&amp;eacute;ntico a &lt;code&gt;transmute::&amp;lt;f64, u64&amp;gt;(self)&lt;/code&gt; en todas las plataformas.</target>
        </trans-unit>
        <trans-unit id="918c5990ef12f35794f26c0b83e42a5d2ef0c694" translate="yes" xml:space="preserve">
          <source>This is currently identical to &lt;code&gt;transmute::&amp;lt;u32, f32&amp;gt;(v)&lt;/code&gt; on all platforms. It turns out this is incredibly portable, for two reasons:</source>
          <target state="translated">Actualmente es id&amp;eacute;ntico a &lt;code&gt;transmute::&amp;lt;u32, f32&amp;gt;(v)&lt;/code&gt; en todas las plataformas. Resulta que esto es incre&amp;iacute;blemente port&amp;aacute;til, por dos razones:</target>
        </trans-unit>
        <trans-unit id="00309d71e504692e129d008c7a1eff96961c44fc" translate="yes" xml:space="preserve">
          <source>This is currently identical to &lt;code&gt;transmute::&amp;lt;u64, f64&amp;gt;(v)&lt;/code&gt; on all platforms. It turns out this is incredibly portable, for two reasons:</source>
          <target state="translated">Actualmente es id&amp;eacute;ntico a &lt;code&gt;transmute::&amp;lt;u64, f64&amp;gt;(v)&lt;/code&gt; en todas las plataformas. Resulta que esto es incre&amp;iacute;blemente port&amp;aacute;til, por dos razones:</target>
        </trans-unit>
        <trans-unit id="de7179edea4813efbd79fdfefd23f0fcc07d0700" translate="yes" xml:space="preserve">
          <source>This is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc5737&quot;&gt;IETF RFC 5737&lt;/a&gt;:</source>
          <target state="translated">Esto se define en &lt;a href=&quot;https://tools.ietf.org/html/rfc5737&quot;&gt;IETF RFC 5737&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="59a6ad6e6ae513088e0c1bb8ed9888b474a9dbba" translate="yes" xml:space="preserve">
          <source>This is designed to be used in conjunction with &lt;a href=&quot;fn.catch_unwind&quot;&gt;&lt;code&gt;catch_unwind&lt;/code&gt;&lt;/a&gt; to, for example, carry a panic across a layer of C code.</source>
          <target state="translated">Esto est&amp;aacute; dise&amp;ntilde;ado para usarse junto con &lt;a href=&quot;fn.catch_unwind&quot;&gt; &lt;code&gt;catch_unwind&lt;/code&gt; &lt;/a&gt; para, por ejemplo, llevar un p&amp;aacute;nico a trav&amp;eacute;s de una capa de c&amp;oacute;digo C.</target>
        </trans-unit>
        <trans-unit id="5fdeff8202418046160b5ede029f4ae17e4cb706" translate="yes" xml:space="preserve">
          <source>This is different than the &lt;code&gt;C&lt;/code&gt; representation because a struct with the &lt;code&gt;C&lt;/code&gt; representation will always have the ABI of a &lt;code&gt;C&lt;/code&gt;&lt;code&gt;struct&lt;/code&gt; while, for example, a struct with the &lt;code&gt;transparent&lt;/code&gt; representation with a primitive field will have the ABI of the primitive field.</source>
          <target state="translated">Esto es diferente a la representaci&amp;oacute;n en &lt;code&gt;C&lt;/code&gt; porque una estructura con la representaci&amp;oacute;n en &lt;code&gt;C&lt;/code&gt; siempre tendr&amp;aacute; el ABI de una &lt;code&gt;struct&lt;/code&gt; &lt;code&gt;C&lt;/code&gt; mientras que, por ejemplo, una estructura con la representaci&amp;oacute;n &lt;code&gt;transparent&lt;/code&gt; e con un campo primitivo tendr&amp;aacute; el ABI del campo primitivo.</target>
        </trans-unit>
        <trans-unit id="f40a48629593c80076df828df6524a31bbb5832c" translate="yes" xml:space="preserve">
          <source>This is done as if by the Euclidean division algorithm -- given &lt;code&gt;r = self.rem_euclid(rhs)&lt;/code&gt;, &lt;code&gt;self = rhs * self.div_euclid(rhs) + r&lt;/code&gt;, and &lt;code&gt;0 &amp;lt;= r &amp;lt; abs(rhs)&lt;/code&gt;.</source>
          <target state="translated">Esto se hace como si lo hiciera el algoritmo de divisi&amp;oacute;n euclidiana, dado &lt;code&gt;r = self.rem_euclid(rhs)&lt;/code&gt; , &lt;code&gt;self = rhs * self.div_euclid(rhs) + r&lt;/code&gt; , y &lt;code&gt;0 &amp;lt;= r &amp;lt; abs(rhs)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="261341fb7dbde0853cc1e229f30dada63a712ac0" translate="yes" xml:space="preserve">
          <source>This is enforced by the Rust compiler. However, there are situations where this rule is not flexible enough. Sometimes it is required to have multiple references to an object and yet mutate it.</source>
          <target state="translated">Esto lo hace el compilador de óxido.Sin embargo,hay situaciones en las que esta regla no es lo suficientemente flexible.A veces se requiere tener múltiples referencias a un objeto y aún así mutarlo.</target>
        </trans-unit>
        <trans-unit id="1a48a3285621637ef35ee331d4de4979ad866379" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;self.seek(SeekFrom::Current(0))&lt;/code&gt;.</source>
          <target state="translated">Esto es equivalente a &lt;code&gt;self.seek(SeekFrom::Current(0))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea3c08c47d3f2c239e1b0612d35fd093489ce76f" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;to_ascii_lowercase(a) == to_ascii_lowercase(b)&lt;/code&gt;.</source>
          <target state="translated">Esto es equivalente a &lt;code&gt;to_ascii_lowercase(a) == to_ascii_lowercase(b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a97a7d1bcb8cd7cc77582edff43cedf5b5f9e7ec" translate="yes" xml:space="preserve">
          <source>This is equivalent to adding the result of &lt;code&gt;padding_needed_for&lt;/code&gt; to the layout's current size.</source>
          <target state="translated">Esto es equivalente a agregar el resultado de &lt;code&gt;padding_needed_for&lt;/code&gt; al tama&amp;ntilde;o actual del dise&amp;ntilde;o.</target>
        </trans-unit>
        <trans-unit id="cd40c4706f12ddab3deeab19ddffb1056c56c24a" translate="yes" xml:space="preserve">
          <source>This is equivalent to casting &lt;code&gt;self&lt;/code&gt; to &lt;code&gt;*const T&lt;/code&gt;, but more type-safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1cc6c65ebdd0a382483c4dc8c7f13d29cc10dc3" translate="yes" xml:space="preserve">
          <source>This is equivalent to casting &lt;code&gt;self&lt;/code&gt; to &lt;code&gt;*mut T&lt;/code&gt;, but more type-safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6cc1d085b275d07a515f10b6c1293ccce68e246" translate="yes" xml:space="preserve">
          <source>This is equivalent to sending a SIGKILL on Unix platforms.</source>
          <target state="translated">Esto equivale a enviar un SIGKILL en plataformas Unix.</target>
        </trans-unit>
        <trans-unit id="f985a290d8b35439e1509532b1f307ab14186afb" translate="yes" xml:space="preserve">
          <source>This is equivalent to the &lt;code&gt;Deref&lt;/code&gt; impl, but is explicit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbb80b753a6a285f62ca3be46d0ca7ebb71f7211" translate="yes" xml:space="preserve">
          <source>This is equivalent to using a &lt;a href=&quot;../../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; loop on the iterator, although &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; are not possible from a closure. It's generally more idiomatic to use a &lt;code&gt;for&lt;/code&gt; loop, but &lt;code&gt;for_each&lt;/code&gt; may be more legible when processing items at the end of longer iterator chains. In some cases &lt;code&gt;for_each&lt;/code&gt; may also be faster than a loop, because it will use internal iteration on adaptors like &lt;code&gt;Chain&lt;/code&gt;.</source>
          <target state="translated">Esto es equivalente a usar un bucle &lt;a href=&quot;../../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt; en el iterador, aunque no es posible &lt;code&gt;break&lt;/code&gt; y &lt;code&gt;continue&lt;/code&gt; desde un cierre. Por lo general, es m&amp;aacute;s idiom&amp;aacute;tico usar un bucle &lt;code&gt;for&lt;/code&gt; , pero &lt;code&gt;for_each&lt;/code&gt; puede ser m&amp;aacute;s legible cuando se procesan elementos al final de cadenas de iteradores m&amp;aacute;s largas. En algunos casos, &lt;code&gt;for_each&lt;/code&gt; tambi&amp;eacute;n puede ser m&amp;aacute;s r&amp;aacute;pido que un bucle, porque usar&amp;aacute; iteraci&amp;oacute;n interna en adaptadores como &lt;code&gt;Chain&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="85aa708c3c4c286a53847d7118e6789eccd018b1" translate="yes" xml:space="preserve">
          <source>This is essentially the reversed version of &lt;a href=&quot;trait.iterator#method.nth&quot;&gt;&lt;code&gt;Iterator::nth()&lt;/code&gt;&lt;/a&gt;. Although like most indexing operations, the count starts from zero, so &lt;code&gt;nth_back(0)&lt;/code&gt; returns the first value from the end, &lt;code&gt;nth_back(1)&lt;/code&gt; the second, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d5fc7a87669eb5a575d2a14569feb14339d998c" translate="yes" xml:space="preserve">
          <source>This is essentially the reversed version of &lt;a href=&quot;trait.iterator#method.nth&quot;&gt;&lt;code&gt;nth&lt;/code&gt;&lt;/a&gt;. Although like most indexing operations, the count starts from zero, so &lt;code&gt;nth_back(0)&lt;/code&gt; returns the first value fro the end, &lt;code&gt;nth_back(1)&lt;/code&gt; the second, and so on.</source>
          <target state="translated">Esta es esencialmente la versi&amp;oacute;n inversa de &lt;a href=&quot;trait.iterator#method.nth&quot;&gt; &lt;code&gt;nth&lt;/code&gt; &lt;/a&gt; . Aunque como la mayor&amp;iacute;a de las operaciones de indexaci&amp;oacute;n, el recuento comienza desde cero, entonces &lt;code&gt;nth_back(0)&lt;/code&gt; devuelve el primer valor del final, &lt;code&gt;nth_back(1)&lt;/code&gt; el segundo, y as&amp;iacute; sucesivamente.</target>
        </trans-unit>
        <trans-unit id="da357ed847b3be924604524d54de90650dc840c5" translate="yes" xml:space="preserve">
          <source>This is exactly the kind of guarantee that the intrusive linked list from the previous section needs to function correctly.</source>
          <target state="translated">Este es exactamente el tipo de garantía que la lista de enlaces intrusivos de la sección anterior necesita para funcionar correctamente.</target>
        </trans-unit>
        <trans-unit id="bb45c58beba541079b29f983c2bd8c56db26b71e" translate="yes" xml:space="preserve">
          <source>This is exploited by the compiler for various optimizations, such as eliding run-time checks and optimizing &lt;code&gt;enum&lt;/code&gt; layout.</source>
          <target state="translated">El compilador explota esto para varias optimizaciones, como eludir las comprobaciones en tiempo de ejecuci&amp;oacute;n y optimizar el dise&amp;ntilde;o de &lt;code&gt;enum&lt;/code&gt; eraci&amp;oacute;n .</target>
        </trans-unit>
        <trans-unit id="2800cba431c3f0317ff7290328c22feda7e8a245" translate="yes" xml:space="preserve">
          <source>This is fixed by declaring the impl block like this:</source>
          <target state="translated">Esto se arregla declarando el bloque implícito de esta manera:</target>
        </trans-unit>
        <trans-unit id="7800b5b60ece10a2bb3977b34790a457f9ba1d9b" translate="yes" xml:space="preserve">
          <source>This is generally created by methods like &lt;a href=&quot;struct.mutex#method.lock&quot;&gt;&lt;code&gt;Mutex::lock&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.rwlock#method.read&quot;&gt;&lt;code&gt;RwLock::read&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esto generalmente se crea mediante m&amp;eacute;todos como &lt;a href=&quot;struct.mutex#method.lock&quot;&gt; &lt;code&gt;Mutex::lock&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;struct.rwlock#method.read&quot;&gt; &lt;code&gt;RwLock::read&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d04e3acde7f8ef92dfb6b7b52b3e3c3811cad1e0" translate="yes" xml:space="preserve">
          <source>This is generally not recommended, use with caution! For a safe alternative see &lt;a href=&quot;#method.get&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esto generalmente no se recomienda, &amp;iexcl;util&amp;iacute;celo con precauci&amp;oacute;n! Para obtener una alternativa segura, consulte &lt;a href=&quot;#method.get&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4bd5c92d6bc3bc69b3d544b464184377050cce05" translate="yes" xml:space="preserve">
          <source>This is generally not recommended, use with caution! For a safe alternative see &lt;a href=&quot;#method.get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esto generalmente no se recomienda, &amp;iexcl;util&amp;iacute;celo con precauci&amp;oacute;n! Para obtener una alternativa segura, consulte &lt;a href=&quot;#method.get_mut&quot;&gt; &lt;code&gt;get_mut&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1be3a48c43f2cbe9f66bb8b317aa83c1345f1b36" translate="yes" xml:space="preserve">
          <source>This is generally not recommended, use with caution! For a safe alternative see &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../ops/trait.index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60f2e569769a80d9853e1327c13dd3289346f0be" translate="yes" xml:space="preserve">
          <source>This is generally not recommended, use with caution! For a safe alternative see &lt;a href=&quot;primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ops/trait.index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esto generalmente no se recomienda, &amp;iexcl;util&amp;iacute;celo con precauci&amp;oacute;n! Para obtener una alternativa segura, consulte &lt;a href=&quot;primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; e &lt;a href=&quot;ops/trait.index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5835397a3648f1790072b1697b1686de073dd8a5" translate="yes" xml:space="preserve">
          <source>This is highly unsafe, due to the number of invariants that aren't checked:</source>
          <target state="translated">Esto es muy inseguro,debido al número de invariantes que no se comprueban:</target>
        </trans-unit>
        <trans-unit id="75907ab0f8297b43f4704528d57293015e32b770" translate="yes" xml:space="preserve">
          <source>This is implemented as an intrinsic to avoid converting to and from an integer, since the conversion inhibits certain optimizations.</source>
          <target state="translated">Esto se implementa como algo intrínseco para evitar la conversión a y desde un entero,ya que la conversión inhibe ciertas optimizaciones.</target>
        </trans-unit>
        <trans-unit id="11f5a22e0c8092b2e830a298d3f000dd528e1ac9" translate="yes" xml:space="preserve">
          <source>This is implemented as an intrinsic to avoid converting to and from an integer, since the conversion would throw away aliasing information.</source>
          <target state="translated">Esto se implementa como algo intrínseco para evitar la conversión hacia y desde un número entero,ya que la conversión tiraría la información de alias.</target>
        </trans-unit>
        <trans-unit id="0d148f9608c961194f7d8d82b9462e528bb48245" translate="yes" xml:space="preserve">
          <source>This is in contrast to the default behaviour of &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; which unwinds the current thread's stack and calls all destructors. When &lt;code&gt;panic=&quot;abort&quot;&lt;/code&gt; is set, either as an argument to &lt;code&gt;rustc&lt;/code&gt; or in a crate's Cargo.toml, &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;abort&lt;/code&gt; are similar. However, &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; will still call the &lt;a href=&quot;../panic/fn.set_hook&quot;&gt;panic hook&lt;/a&gt; while &lt;code&gt;abort&lt;/code&gt; will not.</source>
          <target state="translated">Esto contrasta con el comportamiento predeterminado del &lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;que desenrolla la pila del hilo actual y llama a todos los destructores. Cuando se establece &lt;code&gt;panic=&quot;abort&quot;&lt;/code&gt; , ya sea como un argumento para &lt;code&gt;rustc&lt;/code&gt; o en el Cargo.toml de una caja, &lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;y &lt;code&gt;abort&lt;/code&gt; ar son similares. Sin embargo, &lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;seguir&amp;aacute; llamando al &lt;a href=&quot;../panic/fn.set_hook&quot;&gt;gancho de p&amp;aacute;nico&lt;/a&gt; mientras que &lt;code&gt;abort&lt;/code&gt; ar no lo har&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="4ae8371c0715e2fc1f945296e51fa6a1f4eac55c" translate="yes" xml:space="preserve">
          <source>This is intended for diagnostic use. The exact contents and format of the string are not specified, other than being a best-effort description of the type. For example, &lt;code&gt;type_name_of_val::&amp;lt;Option&amp;lt;String&amp;gt;&amp;gt;(None)&lt;/code&gt; could return &lt;code&gt;&quot;Option&amp;lt;String&amp;gt;&quot;&lt;/code&gt; or &lt;code&gt;&quot;std::option::Option&amp;lt;std::string::String&amp;gt;&quot;&lt;/code&gt;, but not &lt;code&gt;&quot;foobar&quot;&lt;/code&gt;. In addition, the output may change between versions of the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8ec787ed30362b911645f3b84c9e12d95cf9472" translate="yes" xml:space="preserve">
          <source>This is intended for diagnostic use. The exact contents and format of the string returned are not specified, other than being a best-effort description of the type. For example, amongst the strings that &lt;code&gt;type_name::&amp;lt;Option&amp;lt;String&amp;gt;&amp;gt;()&lt;/code&gt; might return are &lt;code&gt;&quot;Option&amp;lt;String&amp;gt;&quot;&lt;/code&gt; and &lt;code&gt;&quot;std::option::Option&amp;lt;std::string::String&amp;gt;&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abc319fa8d54bb7f30ec3fbd3c75a33f269dda0d" translate="yes" xml:space="preserve">
          <source>This is intended for use cases that must synchronize content, but don't need the metadata on disk. The goal of this method is to reduce disk operations.</source>
          <target state="translated">Esto está pensado para los casos de uso que deben sincronizar el contenido,pero que no necesitan los metadatos en el disco.El objetivo de este método es reducir las operaciones de disco.</target>
        </trans-unit>
        <trans-unit id="b4baa659f5df3a480bf1bbe9b4f50e4e5030b61c" translate="yes" xml:space="preserve">
          <source>This is lossless: calling &lt;a href=&quot;trait.osstrext#tymethod.encode_wide&quot;&gt;&lt;code&gt;OsStrExt::encode_wide&lt;/code&gt;&lt;/a&gt; on the resulting string will always return the original code units.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a817bf3dc422e9202ff238105af54d744a0e12d" translate="yes" xml:space="preserve">
          <source>This is lossless: calling &lt;a href=&quot;trait.osstrext#tymethod.encode_wide&quot;&gt;&lt;code&gt;encode_wide&lt;/code&gt;&lt;/a&gt; on the resulting string will always return the original code units.</source>
          <target state="translated">Esto no tiene p&amp;eacute;rdidas: llamar a &lt;a href=&quot;trait.osstrext#tymethod.encode_wide&quot;&gt; &lt;code&gt;encode_wide&lt;/code&gt; &lt;/a&gt; en la cadena resultante siempre devolver&amp;aacute; las unidades de c&amp;oacute;digo originales.</target>
        </trans-unit>
        <trans-unit id="628dc171fde34c2da2657493d9e0d1f50a03e413" translate="yes" xml:space="preserve">
          <source>This is lossless: calling &lt;a href=&quot;trait.osstringext#tymethod.from_wide&quot;&gt;&lt;code&gt;OsString::from_wide&lt;/code&gt;&lt;/a&gt; and then &lt;code&gt;encode_wide&lt;/code&gt; on the result will yield the original code units. Note that the encoding does not add a final null terminator.</source>
          <target state="translated">Esto no tiene p&amp;eacute;rdidas: llamar a &lt;a href=&quot;trait.osstringext#tymethod.from_wide&quot;&gt; &lt;code&gt;OsString::from_wide&lt;/code&gt; &lt;/a&gt; y luego &lt;code&gt;encode_wide&lt;/code&gt; en el resultado producir&amp;aacute; las unidades de c&amp;oacute;digo originales. Tenga en cuenta que la codificaci&amp;oacute;n no agrega un terminador nulo final.</target>
        </trans-unit>
        <trans-unit id="77e982184c9ea4360d1954dd63bc884090bdd324" translate="yes" xml:space="preserve">
          <source>This is lossless: calling &lt;a href=&quot;trait.osstringext#tymethod.from_wide&quot;&gt;&lt;code&gt;OsStringExt::from_wide&lt;/code&gt;&lt;/a&gt; and then &lt;code&gt;encode_wide&lt;/code&gt; on the result will yield the original code units. Note that the encoding does not add a final null terminator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0151e5762979bf36757d9fa68f187e7676c048da" translate="yes" xml:space="preserve">
          <source>This is more useful when combined with higher-level abstractions, like collecting to a &lt;code&gt;Result&amp;lt;(), E&amp;gt;&lt;/code&gt; where you only care about errors:</source>
          <target state="translated">Esto es m&amp;aacute;s &amp;uacute;til cuando se combina con abstracciones de nivel superior, como recopilar en un &lt;code&gt;Result&amp;lt;(), E&amp;gt;&lt;/code&gt; donde solo le importan los errores:</target>
        </trans-unit>
        <trans-unit id="10329d9d786a635bdda96b8986fb374a569f8990" translate="yes" xml:space="preserve">
          <source>This is normally only useful in macro generated code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2fe1510c25bad6c81eb0b6402e2bd1a4066b7f9" translate="yes" xml:space="preserve">
          <source>This is not currently supported: &lt;code&gt;v&lt;/code&gt; should be defined as &lt;code&gt;Vec&amp;lt;&amp;amp;str&amp;gt;&lt;/code&gt;. Parentheses are currently only used with generic types when defining parameters for &lt;code&gt;Fn&lt;/code&gt;-family traits.</source>
          <target state="translated">Actualmente no se admite: &lt;code&gt;v&lt;/code&gt; debe definirse como &lt;code&gt;Vec&amp;lt;&amp;amp;str&amp;gt;&lt;/code&gt; . Actualmente, los par&amp;eacute;ntesis solo se usan con tipos gen&amp;eacute;ricos al definir par&amp;aacute;metros para rasgos de familia &lt;code&gt;Fn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="711ce4ce5401a3c09d45281217695490f1c55a87" translate="yes" xml:space="preserve">
          <source>This is often the correct thing to use when building data structures using raw pointers, but is ultimately more dangerous to use because of its additional properties. If you're not sure if you should use &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt;, just use &lt;code&gt;*mut T&lt;/code&gt;!</source>
          <target state="translated">A menudo, esto es lo correcto cuando se construyen estructuras de datos usando punteros sin procesar, pero en &amp;uacute;ltima instancia, es m&amp;aacute;s peligroso de usar debido a sus propiedades adicionales. Si no est&amp;aacute; seguro de si debe usar &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; , simplemente use &lt;code&gt;*mut T&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="fa820eea81b725c2fa4febe2a3901035a1fc9e49" translate="yes" xml:space="preserve">
          <source>This is one of the reasons Rust projects that provide a binary have a straightforward &lt;em&gt;src/main.rs&lt;/em&gt; file that calls logic that lives in the &lt;em&gt;src/lib.rs&lt;/em&gt; file. Using that structure, integration tests &lt;em&gt;can&lt;/em&gt; test the library crate with &lt;code&gt;use&lt;/code&gt; to make the important functionality available. If the important functionality works, the small amount of code in the &lt;em&gt;src/main.rs&lt;/em&gt; file will work as well, and that small amount of code doesn&amp;rsquo;t need to be tested.</source>
          <target state="translated">Esta es una de las razones por las que los proyectos de Rust que proporcionan un binario tienen un archivo &lt;em&gt;src / main.rs sencillo&lt;/em&gt; que llama a la l&amp;oacute;gica que vive en el archivo &lt;em&gt;src / lib.rs. &lt;/em&gt;Usando esa estructura, las pruebas de integraci&amp;oacute;n &lt;em&gt;pueden&lt;/em&gt; probar la caja de la biblioteca con el &lt;code&gt;use&lt;/code&gt; para hacer disponible la funcionalidad importante. Si la funcionalidad importante funciona, la peque&amp;ntilde;a cantidad de c&amp;oacute;digo en el archivo &lt;em&gt;src / main.rs&lt;/em&gt; tambi&amp;eacute;n funcionar&amp;aacute;, y esa peque&amp;ntilde;a cantidad de c&amp;oacute;digo no necesita ser probada.</target>
        </trans-unit>
        <trans-unit id="73e2aa9ae5cc887b643d8522a473733b99e09722" translate="yes" xml:space="preserve">
          <source>This is only available on unix platforms and must be imported in order to call the method. Windows platforms have a corresponding &lt;code&gt;AsRawHandle&lt;/code&gt; and &lt;code&gt;AsRawSocket&lt;/code&gt; set of traits.</source>
          <target state="translated">Esto solo est&amp;aacute; disponible en plataformas Unix y debe importarse para poder llamar al m&amp;eacute;todo. Plataformas de Windows tienen un correspondiente &lt;code&gt;AsRawHandle&lt;/code&gt; y &lt;code&gt;AsRawSocket&lt;/code&gt; conjunto de caracter&amp;iacute;sticas .</target>
        </trans-unit>
        <trans-unit id="b95758d57810f70a3e0dda910c113e0c41898398" translate="yes" xml:space="preserve">
          <source>This is only possible if the iterator has an end, so &lt;code&gt;rev()&lt;/code&gt; only works on &lt;a href=&quot;trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">Esto solo es posible si el iterador tiene un final, por lo que &lt;code&gt;rev()&lt;/code&gt; solo funciona en &lt;a href=&quot;trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; &lt;/a&gt; s.</target>
        </trans-unit>
        <trans-unit id="3a074412ade07f77d614925409e4080a4208783e" translate="yes" xml:space="preserve">
          <source>This is optimal if:</source>
          <target state="translated">Esto es óptimo si:</target>
        </trans-unit>
        <trans-unit id="37e51cab1c9ec8f6780dbae6b990b1f230875324" translate="yes" xml:space="preserve">
          <source>This is primarily due to ABI incompatibilities between the two attributes. See &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2091-inline-semantic.md&quot;&gt;RFC 2091&lt;/a&gt; for details on this and other limitations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d34b82a0a85b619783fe065420d506ce185b6196" translate="yes" xml:space="preserve">
          <source>This is purely an optimization hint, and may be implemented conservatively: it may return &lt;code&gt;true&lt;/code&gt; for types that don't actually need to be dropped. As such always returning &lt;code&gt;true&lt;/code&gt; would be a valid implementation of this function. However if this function actually returns &lt;code&gt;false&lt;/code&gt;, then you can be certain dropping &lt;code&gt;T&lt;/code&gt; has no side effect.</source>
          <target state="translated">Esto es puramente una sugerencia de optimizaci&amp;oacute;n y puede implementarse de manera conservadora: puede devolver &lt;code&gt;true&lt;/code&gt; para los tipos que en realidad no necesitan descartarse. Como tal, devolver siempre &lt;code&gt;true&lt;/code&gt; ser&amp;iacute;a una implementaci&amp;oacute;n v&amp;aacute;lida de esta funci&amp;oacute;n. Sin embargo, si esta funci&amp;oacute;n realmente devuelve &lt;code&gt;false&lt;/code&gt; , entonces puede estar seguro de que eliminar &lt;code&gt;T&lt;/code&gt; no tiene ning&amp;uacute;n efecto secundario.</target>
        </trans-unit>
        <trans-unit id="5e7810a8956ac37cd206f449b307f75cea11f52b" translate="yes" xml:space="preserve">
          <source>This is returned in a Result by either the &lt;a href=&quot;struct.command#method.output&quot;&gt;&lt;code&gt;output&lt;/code&gt;&lt;/a&gt; method of a &lt;a href=&quot;struct.command&quot;&gt;&lt;code&gt;Command&lt;/code&gt;&lt;/a&gt;, or the &lt;a href=&quot;struct.child#method.wait_with_output&quot;&gt;&lt;code&gt;wait_with_output&lt;/code&gt;&lt;/a&gt; method of a &lt;a href=&quot;struct.child&quot;&gt;&lt;code&gt;Child&lt;/code&gt;&lt;/a&gt; process.</source>
          <target state="translated">Esto se devuelve en un resultado mediante el m&amp;eacute;todo de &lt;a href=&quot;struct.command#method.output&quot;&gt; &lt;code&gt;output&lt;/code&gt; &lt;/a&gt; de un &lt;a href=&quot;struct.command&quot;&gt; &lt;code&gt;Command&lt;/code&gt; &lt;/a&gt; o el m&amp;eacute;todo &lt;a href=&quot;struct.child#method.wait_with_output&quot;&gt; &lt;code&gt;wait_with_output&lt;/code&gt; &lt;/a&gt; de un &lt;a href=&quot;struct.child&quot;&gt; &lt;code&gt;Child&lt;/code&gt; &lt;/a&gt; proceso .</target>
        </trans-unit>
        <trans-unit id="b6ad57d3243660eeae5c83dc6d6e37580997866e" translate="yes" xml:space="preserve">
          <source>This is safe because it is not possible to move out of a shared reference. It may seem like there is an issue here with interior mutability: in fact, it &lt;em&gt;is&lt;/em&gt; possible to move a &lt;code&gt;T&lt;/code&gt; out of a &lt;code&gt;&amp;amp;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;. However, this is not a problem as long as there does not also exist a &lt;code&gt;Pin&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; pointing to the same data, and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; does not let you create a pinned reference to its contents. See the discussion on &lt;a href=&quot;index#projections-and-structural-pinning&quot;&gt;&quot;pinning projections&quot;&lt;/a&gt; for further details.</source>
          <target state="translated">Esto es seguro porque no es posible salir de una referencia compartida. Puede parecer que aqu&amp;iacute; hay un problema con la mutabilidad interior: de hecho, &lt;em&gt;es&lt;/em&gt; posible sacar una &lt;code&gt;T&lt;/code&gt; de un &lt;code&gt;&amp;amp;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; . Sin embargo, esto no es un problema siempre que no exista un &lt;code&gt;Pin&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; apunte a los mismos datos, y &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; no le permite crear una referencia fija a su contenido. Consulte la discusi&amp;oacute;n sobre &lt;a href=&quot;index#projections-and-structural-pinning&quot;&gt;&quot;Fijar proyecciones&quot;&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="559d85299736482aa3edc92867921c11931dac34" translate="yes" xml:space="preserve">
          <source>This is safe because passing &lt;code&gt;self&lt;/code&gt; by value guarantees that no other threads are concurrently accessing the atomic data.</source>
          <target state="translated">Esto es seguro porque se pasa a &lt;code&gt;self&lt;/code&gt; por valor garantiza que ning&amp;uacute;n otro subproceso acceda al mismo tiempo a los datos at&amp;oacute;micos.</target>
        </trans-unit>
        <trans-unit id="fdcd86e75de03ac238cab2145da08762d1c1fa0e" translate="yes" xml:space="preserve">
          <source>This is safe because the mutable reference guarantees that no other threads are concurrently accessing the atomic data.</source>
          <target state="translated">Esto es seguro porque la referencia mutable garantiza que ningún otro hilo accede simultáneamente a los datos atómicos.</target>
        </trans-unit>
        <trans-unit id="a603b8208d8f49fcc985893385a8e118d832cdea" translate="yes" xml:space="preserve">
          <source>This is safe, because &lt;code&gt;T&lt;/code&gt; is borrowed for the &lt;code&gt;'static&lt;/code&gt; lifetime, which never ends.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62f1c9ceb59d3f4f94d3d3fedf2ebcb7110ae8d6" translate="yes" xml:space="preserve">
          <source>This is semantically equivalent to calling &lt;a href=&quot;../ptr/fn.read&quot;&gt;&lt;code&gt;ptr::read&lt;/code&gt;&lt;/a&gt; and discarding the result, but has the following advantages:</source>
          <target state="translated">Esto es sem&amp;aacute;nticamente equivalente a llamar a &lt;a href=&quot;../ptr/fn.read&quot;&gt; &lt;code&gt;ptr::read&lt;/code&gt; &lt;/a&gt; y descartar el resultado, pero tiene las siguientes ventajas:</target>
        </trans-unit>
        <trans-unit id="f8249e0d4f2746bf5b8aa8a678e0e1e5a321179d" translate="yes" xml:space="preserve">
          <source>This is semantically equivalent to calling &lt;a href=&quot;fn.read&quot;&gt;&lt;code&gt;ptr::read&lt;/code&gt;&lt;/a&gt; and discarding the result, but has the following advantages:</source>
          <target state="translated">Esto es sem&amp;aacute;nticamente equivalente a llamar a &lt;a href=&quot;fn.read&quot;&gt; &lt;code&gt;ptr::read&lt;/code&gt; &lt;/a&gt; y descartar el resultado, pero tiene las siguientes ventajas:</target>
        </trans-unit>
        <trans-unit id="fb69e9b77c8f67d2dd23964f55732bc6174eb1f3" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;struct.mutex#poisoning&quot;&gt;poisoning with mutexes&lt;/a&gt;.</source>
          <target state="translated">Esto es similar al &lt;a href=&quot;struct.mutex#poisoning&quot;&gt;envenenamiento con mutex&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="323433898b799fb03eed09fdd2d727e9828c9a3d" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;wake&lt;/code&gt;, but may be slightly less efficient in the case where an owned &lt;code&gt;Waker&lt;/code&gt; is available. This method should be preferred to calling &lt;code&gt;waker.clone().wake()&lt;/code&gt;.</source>
          <target state="translated">Esto es similar a la &lt;code&gt;wake&lt;/code&gt; , pero puede ser un poco menos eficiente en el caso de que est&amp;eacute; disponible una &lt;code&gt;Waker&lt;/code&gt; propia . Este m&amp;eacute;todo debe preferirse a llamar a &lt;code&gt;waker.clone().wake()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67ff9ed313be1a208e09d5213c1e87906d1b8ae8" translate="yes" xml:space="preserve">
          <source>This is similar to taking a reference to the whole &lt;code&gt;String&lt;/code&gt; but with the extra &lt;code&gt;[0..5]&lt;/code&gt; bit. Rather than a reference to the entire &lt;code&gt;String&lt;/code&gt;, it&amp;rsquo;s a reference to a portion of the &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">Esto es similar a tomar una referencia a la &lt;code&gt;String&lt;/code&gt; completa pero con el bit adicional &lt;code&gt;[0..5]&lt;/code&gt; . En lugar de una referencia a la &lt;code&gt;String&lt;/code&gt; completa , es una referencia a una parte de la &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e7a7ddaef0be30145306f6816d2b3ff35a14d32" translate="yes" xml:space="preserve">
          <source>This is similar to the second sub-error, but subtler. It happens in situations like the following:</source>
          <target state="translated">Esto es similar al segundo sub-error,pero más sutil.Ocurre en situaciones como las siguientes:</target>
        </trans-unit>
        <trans-unit id="7512abd4f4f8baf21d2fa3f6cea905e84ac77b34" translate="yes" xml:space="preserve">
          <source>This is simply a special - but common - case of the previous: hiding mutability for operations that appear to be immutable. The &lt;code&gt;clone&lt;/code&gt; method is expected to not change the source value, and is declared to take &lt;code&gt;&amp;amp;self&lt;/code&gt;, not &lt;code&gt;&amp;amp;mut self&lt;/code&gt;. Therefore, any mutation that happens in the &lt;code&gt;clone&lt;/code&gt; method must use cell types. For example, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; maintains its reference counts within a &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Este es simplemente un caso especial, pero com&amp;uacute;n, del anterior: ocultar la mutabilidad para operaciones que parecen inmutables. Se espera que el m&amp;eacute;todo de &lt;code&gt;clone&lt;/code&gt; no cambie el valor de la fuente y se declara que toma &lt;code&gt;&amp;amp;self&lt;/code&gt; , no &lt;code&gt;&amp;amp;mut self&lt;/code&gt; . Por lo tanto, cualquier mutaci&amp;oacute;n que ocurra en el m&amp;eacute;todo de &lt;code&gt;clone&lt;/code&gt; debe usar tipos de c&amp;eacute;lulas. Por ejemplo, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; mantiene sus recuentos de referencia dentro de una &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="022f67943cd560f4bdb5afc8c97b7f6c6d3167eb" translate="yes" xml:space="preserve">
          <source>This is sometimes done as part of an FFI:</source>
          <target state="translated">Esto se hace a veces como parte de un FFI:</target>
        </trans-unit>
        <trans-unit id="ce79f7fec51f65c567a6d4b960b891ab223ea0af" translate="yes" xml:space="preserve">
          <source>This is supported on Linux only.</source>
          <target state="translated">Esto sólo está soportado en Linux.</target>
        </trans-unit>
        <trans-unit id="5d02662201a60807bdb13970d8ae5dbd58d92a03" translate="yes" xml:space="preserve">
          <source>This is supported on Unix only.</source>
          <target state="translated">Esto está soportado sólo en Unix.</target>
        </trans-unit>
        <trans-unit id="fe81960399abac0748704c3a05349d9cd7f1ac2c" translate="yes" xml:space="preserve">
          <source>This is supported on Windows only.</source>
          <target state="translated">Esto sólo es compatible con Windows.</target>
        </trans-unit>
        <trans-unit id="7dbd409e3c209511b0279195cd6826fb5e1a2b3b" translate="yes" xml:space="preserve">
          <source>This is the &lt;code&gt;longest&lt;/code&gt; function from Listing 10-22 that returns the longer of two string slices. But now it has an extra parameter named &lt;code&gt;ann&lt;/code&gt; of the generic type &lt;code&gt;T&lt;/code&gt;, which can be filled in by any type that implements the &lt;code&gt;Display&lt;/code&gt; trait as specified by the &lt;code&gt;where&lt;/code&gt; clause. This extra parameter will be printed before the function compares the lengths of the string slices, which is why the &lt;code&gt;Display&lt;/code&gt; trait bound is necessary. Because lifetimes are a type of generic, the declarations of the lifetime parameter &lt;code&gt;'a&lt;/code&gt; and the generic type parameter &lt;code&gt;T&lt;/code&gt; go in the same list inside the angle brackets after the function name.</source>
          <target state="translated">Esta es la funci&amp;oacute;n &lt;code&gt;longest&lt;/code&gt; del Listado 10-22 que devuelve el m&amp;aacute;s largo de dos cortes de cadena. Pero ahora tiene un par&amp;aacute;metro adicional llamado &lt;code&gt;ann&lt;/code&gt; del tipo gen&amp;eacute;rico &lt;code&gt;T&lt;/code&gt; , que puede ser completado por cualquier tipo que implemente el rasgo &lt;code&gt;Display&lt;/code&gt; como lo especifica la cl&amp;aacute;usula &lt;code&gt;where&lt;/code&gt; . Este par&amp;aacute;metro adicional se imprimir&amp;aacute; antes de que la funci&amp;oacute;n compare las longitudes de los cortes de cadena, por lo que es necesario el l&amp;iacute;mite del rasgo de &lt;code&gt;Display&lt;/code&gt; . Debido a que los tiempos de vida son un tipo de gen&amp;eacute;rico, las declaraciones del par&amp;aacute;metro de tiempo de vida &lt;code&gt;'a&lt;/code&gt; ay el par&amp;aacute;metro de tipo gen&amp;eacute;rico &lt;code&gt;T&lt;/code&gt; van en la misma lista dentro de los corchetes angulares despu&amp;eacute;s del nombre de la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="771b5400b1697f2e03b3ff52d8994e98c72fb56e" translate="yes" xml:space="preserve">
          <source>This is the alignment used for struct fields. It may be smaller than the preferred alignment.</source>
          <target state="translated">Esta es la alineación usada para los campos de estructura.Puede ser más pequeño que la alineación preferida.</target>
        </trans-unit>
        <trans-unit id="d7e12ec340db516b6de450f2a63092abb536959d" translate="yes" xml:space="preserve">
          <source>This is the const generic equivalent of &lt;a href=&quot;#method.windows&quot;&gt;&lt;code&gt;windows&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ea5fa4cdf245151000dcd8208cd57fa7396ef40" translate="yes" xml:space="preserve">
          <source>This is the correct syntax:</source>
          <target state="translated">Esta es la sintaxis correcta:</target>
        </trans-unit>
        <trans-unit id="8a3edb9de97e0819d33135bbb50051a98c123c3a" translate="yes" xml:space="preserve">
          <source>This is the difference between &lt;code&gt;1.0&lt;/code&gt; and the next larger representable number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="540ad0b8406b1727e0f455b9b013663295117df7" translate="yes" xml:space="preserve">
          <source>This is the difference between &lt;code&gt;1.0&lt;/code&gt; and the next largest representable number.</source>
          <target state="translated">Esta es la diferencia entre &lt;code&gt;1.0&lt;/code&gt; y el siguiente n&amp;uacute;mero representable m&amp;aacute;s grande.</target>
        </trans-unit>
        <trans-unit id="c620ac5f199d804600d9e6fa867d20d7e4f16f11" translate="yes" xml:space="preserve">
          <source>This is the first example of Rust&amp;rsquo;s safety principles in action. In many low-level languages, this kind of check is not done, and when you provide an incorrect index, invalid memory can be accessed. Rust protects you against this kind of error by immediately exiting instead of allowing the memory access and continuing. Chapter 9 discusses more of Rust&amp;rsquo;s error handling.</source>
          <target state="translated">Este es el primer ejemplo de los principios de seguridad de Rust en acci&amp;oacute;n. En muchos lenguajes de bajo nivel, este tipo de verificaci&amp;oacute;n no se realiza y, cuando proporciona un &amp;iacute;ndice incorrecto, se puede acceder a una memoria no v&amp;aacute;lida. Rust lo protege contra este tipo de error saliendo inmediatamente en lugar de permitir el acceso a la memoria y continuar. El cap&amp;iacute;tulo 9 trata m&amp;aacute;s sobre el manejo de errores de Rust.</target>
        </trans-unit>
        <trans-unit id="96d082bf8459464d47b35442a1fa45813a325a53" translate="yes" xml:space="preserve">
          <source>This is the main iterator trait. For more about the concept of iterators generally, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;. In particular, you may want to know how to &lt;a href=&quot;index#implementing-iterator&quot;&gt;implement &lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Este es el rasgo principal del iterador. Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre el concepto de iteradores en general, consulte la &lt;a href=&quot;index&quot;&gt;documentaci&amp;oacute;n a nivel de m&amp;oacute;dulo&lt;/a&gt; . En particular, es posible que desee saber c&amp;oacute;mo &lt;a href=&quot;index#implementing-iterator&quot;&gt;implementar &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b386764c4159d37f683e85f4c4afa8c88d4fe909" translate="yes" xml:space="preserve">
          <source>This is the non-panicking alternative to indexing the &lt;code&gt;str&lt;/code&gt;. Returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; whenever equivalent indexing operation would panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="289f1434eafb60316aca77ad31a00e3c0eb9323a" translate="yes" xml:space="preserve">
          <source>This is the non-panicking alternative to indexing the &lt;code&gt;str&lt;/code&gt;. Returns &lt;a href=&quot;option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; whenever equivalent indexing operation would panic.</source>
          <target state="translated">Esta es la alternativa sin p&amp;aacute;nico a la indexaci&amp;oacute;n de &lt;code&gt;str&lt;/code&gt; . Devuelve &lt;a href=&quot;option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; cuando la operaci&amp;oacute;n de indexaci&amp;oacute;n equivalente entra en p&amp;aacute;nico.</target>
        </trans-unit>
        <trans-unit id="759018d521d201d38bc076c0727a5d9a6e429fac" translate="yes" xml:space="preserve">
          <source>This is the non-panicking variant of &lt;a href=&quot;#method.borrow&quot;&gt;&lt;code&gt;borrow&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esta es la variante de &lt;a href=&quot;#method.borrow&quot;&gt; &lt;code&gt;borrow&lt;/code&gt; &lt;/a&gt; sin p&amp;aacute;nico .</target>
        </trans-unit>
        <trans-unit id="70fed40b0a485aa104ed49c92498ff0b436cf03b" translate="yes" xml:space="preserve">
          <source>This is the non-panicking variant of &lt;a href=&quot;#method.borrow_mut&quot;&gt;&lt;code&gt;borrow_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&amp;Eacute;sta es la variante que no &lt;a href=&quot;#method.borrow_mut&quot;&gt; &lt;code&gt;borrow_mut&lt;/code&gt; &lt;/a&gt; entrar el p&amp;aacute;nico de proud_mut .</target>
        </trans-unit>
        <trans-unit id="ccd5e95eaa2f4ad9676aca34c8e9ba1ff21b3015" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;../../iter/trait.iterator#method.try_fold&quot;&gt;&lt;code&gt;Iterator::try_fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator. &lt;a href=&quot;../../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd0528fc88151b305168bd5debfa38b6c659b612" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;../iter/trait.iterator#method.try_fold&quot;&gt;&lt;code&gt;Iterator::try_fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator. &lt;a href=&quot;../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0fe748271e612bae240bf98e735a830b559c459" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;iter/trait.iterator#method.try_fold&quot;&gt;&lt;code&gt;Iterator::try_fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator. &lt;a href=&quot;iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d3a0dba802b6e4f6285d94d4683f5056846f9fd" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;trait.iterator#method.fold&quot;&gt;&lt;code&gt;Iterator::fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cce445e189c1252f0055062d54b89751ff0fb729" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator.</source>
          <target state="translated">Esta es la versi&amp;oacute;n inversa de &lt;a href=&quot;trait.iterator#method.fold&quot;&gt; &lt;code&gt;fold()&lt;/code&gt; &lt;/a&gt; : toma elementos comenzando desde la parte posterior del iterador.</target>
        </trans-unit>
        <trans-unit id="bc1780a770503660513f01fa15c1efc71fef0175" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt;&lt;code&gt;Iterator::try_fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe6ff5d62e332d4883802b0cf8675d53b663b171" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt;&lt;code&gt;Iterator::try_fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator. &lt;a href=&quot;trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53f33f9266690c3f1f82aab587ca29e140daa7ab" translate="yes" xml:space="preserve">
          <source>This is the reverse version of &lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt;&lt;code&gt;try_fold()&lt;/code&gt;&lt;/a&gt;: it takes elements starting from the back of the iterator.</source>
          <target state="translated">Esta es la versi&amp;oacute;n inversa de &lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt; &lt;code&gt;try_fold()&lt;/code&gt; &lt;/a&gt; : toma elementos comenzando desde la parte posterior del iterador.</target>
        </trans-unit>
        <trans-unit id="d46122a89a465fda704ceb8118ba4c1126be2832" translate="yes" xml:space="preserve">
          <source>This is the reverse version of [&lt;code&gt;try_fold()&lt;/code&gt;]: it takes elements starting from the back of the iterator. &lt;a href=&quot;../../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Esta es la versi&amp;oacute;n inversa de [ &lt;code&gt;try_fold()&lt;/code&gt; ]: toma elementos comenzando desde la parte posterior del iterador. &lt;a href=&quot;../../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f495531f8eacf0a1680dc0219ed83707197faddd" translate="yes" xml:space="preserve">
          <source>This is the reverse version of [&lt;code&gt;try_fold()&lt;/code&gt;]: it takes elements starting from the back of the iterator. &lt;a href=&quot;../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Esta es la versi&amp;oacute;n inversa de [ &lt;code&gt;try_fold()&lt;/code&gt; ]: toma elementos comenzando desde la parte posterior del iterador. &lt;a href=&quot;../iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0ec81940d41390cbbcb80997a4e3d957d2b9a317" translate="yes" xml:space="preserve">
          <source>This is the reverse version of [&lt;code&gt;try_fold()&lt;/code&gt;]: it takes elements starting from the back of the iterator. &lt;a href=&quot;iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Esta es la versi&amp;oacute;n inversa de [ &lt;code&gt;try_fold()&lt;/code&gt; ]: toma elementos comenzando desde la parte posterior del iterador. &lt;a href=&quot;iter/trait.doubleendediterator#method.try_rfold&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ff3fa51ad38f312277040719826a7c977bbcd8a" translate="yes" xml:space="preserve">
          <source>This is the reverse version of [&lt;code&gt;try_fold()&lt;/code&gt;]: it takes elements starting from the back of the iterator. &lt;a href=&quot;trait.doubleendediterator#method.try_rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Esta es la versi&amp;oacute;n inversa de [ &lt;code&gt;try_fold()&lt;/code&gt; ]: toma elementos comenzando desde la parte posterior del iterador. &lt;a href=&quot;trait.doubleendediterator#method.try_rfold&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="383e94e01b1343c9d6bcfb23e7f045e384d94336" translate="yes" xml:space="preserve">
          <source>This is the same as using the &lt;code&gt;==&lt;/code&gt; operator, but less generic: the arguments have to be &lt;code&gt;*const T&lt;/code&gt; raw pointers, not anything that implements &lt;code&gt;PartialEq&lt;/code&gt;.</source>
          <target state="translated">Esto es lo mismo que usar el operador &lt;code&gt;==&lt;/code&gt; , pero menos gen&amp;eacute;rico: los argumentos deben ser punteros en bruto &lt;code&gt;*const T&lt;/code&gt; , no cualquier cosa que implemente &lt;code&gt;PartialEq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22b2f39cdef64a09df83167c24366e9e24591fdf" translate="yes" xml:space="preserve">
          <source>This is the unchecked alternative to indexing the &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Esta es la alternativa no verificada para indexar &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="589a4243aa6d42e7fc5ac36f0baed5a47e1de444" translate="yes" xml:space="preserve">
          <source>This is used for object safety, to check that a method's receiver type can be dispatched on.</source>
          <target state="translated">Esto se utiliza para la seguridad de los objetos,para comprobar que el tipo de receptor de un método puede ser despachado.</target>
        </trans-unit>
        <trans-unit id="9aea807f1415223ad9d946b1ace7fbf6d55fe5aa" translate="yes" xml:space="preserve">
          <source>This is used when the programmer knows that the thread will have nothing to do for some time, and thus avoid wasting computing time.</source>
          <target state="translated">Se utiliza cuando el programador sabe que el hilo no tendrá nada que hacer durante algún tiempo,y así evitar la pérdida de tiempo de computación.</target>
        </trans-unit>
        <trans-unit id="5ce1e416198eb464ee0a2977f8013c35c0e89565" translate="yes" xml:space="preserve">
          <source>This is useful any time that the compiler can't determine that some code is unreachable. For example:</source>
          <target state="translated">Esto es útil en cualquier momento en que el compilador no pueda determinar que algún código es inalcanzable.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="85e4c5ffc08236fd25e25201dcbaaa8757900c78" translate="yes" xml:space="preserve">
          <source>This is useful for</source>
          <target state="translated">Esto es útil para</target>
        </trans-unit>
        <trans-unit id="a885d8fe460e46c9230b0d468a457bef6acf54a6" translate="yes" xml:space="preserve">
          <source>This is useful for a flavor of &quot;optimistic check&quot; before deciding to block on a receiver.</source>
          <target state="translated">Esto es útil para un sabor de &quot;chequeo optimista&quot; antes de decidir el bloqueo de un receptor.</target>
        </trans-unit>
        <trans-unit id="79e1d9086d9f417d98c9a3f1df01e78fe0db96d9" translate="yes" xml:space="preserve">
          <source>This is useful for initializing types which lazily allocate, like &lt;code&gt;Vec::new&lt;/code&gt; does.</source>
          <target state="translated">Esto es &amp;uacute;til para inicializar tipos que se asignan de manera perezosa, como lo hace &lt;code&gt;Vec::new&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08ec962229a27774cdabf85bddcaa5d6f625b9ff" translate="yes" xml:space="preserve">
          <source>This is useful to allow applying iterator adaptors while still retaining ownership of the original iterator.</source>
          <target state="translated">Esto es útil para permitir la aplicación de los adaptadores del iterador,conservando al mismo tiempo la propiedad del iterador original.</target>
        </trans-unit>
        <trans-unit id="920763b96fccf7eb85a93a16a5bdd675d6fd634c" translate="yes" xml:space="preserve">
          <source>This is useful when the ownership of the underlying resource was previously transferred to code outside of Rust, for example by transmitting the raw file descriptor to C code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c983c1aa2c476c3f346d2a87a469f6be7bac78d1" translate="yes" xml:space="preserve">
          <source>This is useful when you are doing a type conversion that may trivially succeed but may also need special handling. For example, there is no way to convert an &lt;a href=&quot;../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt; into an &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; using the &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; trait, because an &lt;a href=&quot;../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt; may contain a value that an &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; cannot represent and so the conversion would lose data. This might be handled by truncating the &lt;a href=&quot;../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt; to an &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; (essentially giving the &lt;a href=&quot;../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;'s value modulo &lt;a href=&quot;../i32/constant.max&quot;&gt;&lt;code&gt;i32::MAX&lt;/code&gt;&lt;/a&gt;) or by simply returning &lt;a href=&quot;../i32/constant.max&quot;&gt;&lt;code&gt;i32::MAX&lt;/code&gt;&lt;/a&gt;, or by some other method. The &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; trait is intended for perfect conversions, so the &lt;code&gt;TryFrom&lt;/code&gt; trait informs the programmer when a type conversion could go bad and lets them decide how to handle it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63ccb84e9a4faa353cb290ddc5e855748a76c17b" translate="yes" xml:space="preserve">
          <source>This is useful when you are doing a type conversion that may trivially succeed but may also need special handling. For example, there is no way to convert an &lt;code&gt;i64&lt;/code&gt; into an &lt;code&gt;i32&lt;/code&gt; using the &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; trait, because an &lt;code&gt;i64&lt;/code&gt; may contain a value that an &lt;code&gt;i32&lt;/code&gt; cannot represent and so the conversion would lose data. This might be handled by truncating the &lt;code&gt;i64&lt;/code&gt; to an &lt;code&gt;i32&lt;/code&gt; (essentially giving the &lt;code&gt;i64&lt;/code&gt;'s value modulo &lt;code&gt;i32::MAX&lt;/code&gt;) or by simply returning &lt;code&gt;i32::MAX&lt;/code&gt;, or by some other method. The &lt;code&gt;From&lt;/code&gt; trait is intended for perfect conversions, so the &lt;code&gt;TryFrom&lt;/code&gt; trait informs the programmer when a type conversion could go bad and lets them decide how to handle it.</source>
          <target state="translated">Esto es &amp;uacute;til cuando est&amp;aacute; haciendo una conversi&amp;oacute;n de tipos que puede tener &amp;eacute;xito trivialmente pero que tambi&amp;eacute;n puede necesitar un manejo especial. Por ejemplo, no hay forma de convertir un &lt;code&gt;i64&lt;/code&gt; en un &lt;code&gt;i32&lt;/code&gt; usando el rasgo &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; , porque un &lt;code&gt;i64&lt;/code&gt; puede contener un valor que un &lt;code&gt;i32&lt;/code&gt; no puede representar y, por lo tanto, la conversi&amp;oacute;n perder&amp;iacute;a datos. Esto podr&amp;iacute;a manejarse truncando el &lt;code&gt;i64&lt;/code&gt; a un &lt;code&gt;i32&lt;/code&gt; (esencialmente dando el &lt;code&gt;i64&lt;/code&gt; del i64 m&amp;oacute;dulo &lt;code&gt;i32::MAX&lt;/code&gt; ) o simplemente devolviendo &lt;code&gt;i32::MAX&lt;/code&gt; , o por alg&amp;uacute;n otro m&amp;eacute;todo. El rasgo &lt;code&gt;From&lt;/code&gt; est&amp;aacute; destinado a conversiones perfectas, por lo que &lt;code&gt;TryFrom&lt;/code&gt; trait informa al programador cuando una conversi&amp;oacute;n de tipo podr&amp;iacute;a salir mal y le permite decidir c&amp;oacute;mo manejarla.</target>
        </trans-unit>
        <trans-unit id="878335df341d736b2b477f7d269d41d041479a70" translate="yes" xml:space="preserve">
          <source>This is useful when you have an iterator of iterators or an iterator of things that can be turned into iterators and you want to remove one level of indirection.</source>
          <target state="translated">Esto es útil cuando se tiene un iterador de iteradores o un iterador de cosas que pueden convertirse en iteradores y se quiere eliminar un nivel de indirección.</target>
        </trans-unit>
        <trans-unit id="bc06069272831e3fab63600d60da8286a4aa9faf" translate="yes" xml:space="preserve">
          <source>This is useful when you have an iterator over &lt;code&gt;&amp;amp;T&lt;/code&gt;, but you need an iterator over &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Esto es &amp;uacute;til cuando se tiene un iterador sobre &lt;code&gt;&amp;amp;T&lt;/code&gt; , pero se necesita un iterador sobre &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28c350dd4bfc1f4f50a6db4a558fce8f481fa714" translate="yes" xml:space="preserve">
          <source>This is useful when you wish to output a formatted list of items as a part of your &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt;&lt;code&gt;Debug::fmt&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">Esto es &amp;uacute;til cuando desea generar una lista formateada de elementos como parte de su implementaci&amp;oacute;n &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt; &lt;code&gt;Debug::fmt&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="023c37d743c95a28f62cb66dc28c6981840e275e" translate="yes" xml:space="preserve">
          <source>This is useful when you wish to output a formatted map as a part of your &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt;&lt;code&gt;Debug::fmt&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">Esto es &amp;uacute;til cuando desea generar un mapa formateado como parte de su implementaci&amp;oacute;n &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt; &lt;code&gt;Debug::fmt&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5a019c845f0ac55c26e73d5fc98b9e29c14a5266" translate="yes" xml:space="preserve">
          <source>This is useful when you wish to output a formatted set of items as a part of your &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt;&lt;code&gt;Debug::fmt&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">Esto es &amp;uacute;til cuando desea generar un conjunto formateado de elementos como parte de su implementaci&amp;oacute;n &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt; &lt;code&gt;Debug::fmt&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="742e4efaa0964cab1a9b13d64aa3f1ee505fbe93" translate="yes" xml:space="preserve">
          <source>This is useful when you wish to output a formatted struct as a part of your &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt;&lt;code&gt;Debug::fmt&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">Esto es &amp;uacute;til cuando desea generar una estructura formateada como parte de su implementaci&amp;oacute;n &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt; &lt;code&gt;Debug::fmt&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7450774ae735743f9affac51ccc2935a02180916" translate="yes" xml:space="preserve">
          <source>This is useful when you wish to output a formatted tuple as a part of your &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt;&lt;code&gt;Debug::fmt&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">Esto es &amp;uacute;til cuando desea generar una tupla formateada como parte de su implementaci&amp;oacute;n &lt;a href=&quot;trait.debug#tymethod.fmt&quot;&gt; &lt;code&gt;Debug::fmt&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="678189b9778744d56a77a9ddbd180a89dff66dd0" translate="yes" xml:space="preserve">
          <source>This is usually not needed when writing safe code, as &lt;a href=&quot;../sync/struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;es&lt;/a&gt; already poison themselves when a thread panics while holding the lock.</source>
          <target state="translated">Esto por lo general no es necesario cuando la escritura de c&amp;oacute;digo seguro, como &lt;a href=&quot;../sync/struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; es&lt;/a&gt; que ya se envenenan cuando un hilo entra en p&amp;aacute;nico mientras mantiene el bloqueo.</target>
        </trans-unit>
        <trans-unit id="73513599023f5ddb254ee6ed0d00bccac264c338" translate="yes" xml:space="preserve">
          <source>This is usually the same as &lt;code&gt;size_of::&amp;lt;T&amp;gt;()&lt;/code&gt;. However, when &lt;code&gt;T&lt;/code&gt;&lt;em&gt;has&lt;/em&gt; no statically-known size, e.g., a slice &lt;a href=&quot;../primitive.slice&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../../book/ch17-02-trait-objects&quot;&gt;trait object&lt;/a&gt;, then &lt;code&gt;size_of_val&lt;/code&gt; can be used to get the dynamically-known size.</source>
          <target state="translated">Suele ser lo mismo que &lt;code&gt;size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; . Sin embargo, cuando &lt;code&gt;T&lt;/code&gt; no &lt;em&gt;tiene&lt;/em&gt; un tama&amp;ntilde;o conocido est&amp;aacute;ticamente, por ejemplo, un corte &lt;a href=&quot;../primitive.slice&quot;&gt; &lt;code&gt;[T]&lt;/code&gt; &lt;/a&gt; o un &lt;a href=&quot;../../book/ch17-02-trait-objects&quot;&gt;objeto de rasgo&lt;/a&gt; , entonces &lt;code&gt;size_of_val&lt;/code&gt; se puede usar para obtener el tama&amp;ntilde;o conocido din&amp;aacute;micamente.</target>
        </trans-unit>
        <trans-unit id="8b96a4f28b82d88010bb7132ad9ee35ef317464c" translate="yes" xml:space="preserve">
          <source>This is usually the same as &lt;code&gt;size_of::&amp;lt;T&amp;gt;()&lt;/code&gt;. However, when &lt;code&gt;T&lt;/code&gt;&lt;em&gt;has&lt;/em&gt; no statically-known size, e.g., a slice &lt;a href=&quot;../primitive.slice&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../../book/ch17-02-trait-objects&quot;&gt;trait object&lt;/a&gt;, then &lt;code&gt;size_of_val_raw&lt;/code&gt; can be used to get the dynamically-known size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8abe6d863c59136664f0a7528f19c0cd3ff2fed7" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t the exact signature that&amp;rsquo;s in the standard library: in the standard library, &lt;code&gt;add&lt;/code&gt; is defined using generics. Here, we&amp;rsquo;re looking at the signature of &lt;code&gt;add&lt;/code&gt; with concrete types substituted for the generic ones, which is what happens when we call this method with &lt;code&gt;String&lt;/code&gt; values. We&amp;rsquo;ll discuss generics in Chapter 10. This signature gives us the clues we need to understand the tricky bits of the &lt;code&gt;+&lt;/code&gt; operator.</source>
          <target state="translated">Esta no es la firma exacta que est&amp;aacute; en la biblioteca est&amp;aacute;ndar: en la biblioteca est&amp;aacute;ndar, &lt;code&gt;add&lt;/code&gt; se define usando gen&amp;eacute;ricos. Aqu&amp;iacute;, estamos viendo la firma de &lt;code&gt;add&lt;/code&gt; con tipos concretos sustituidos por los gen&amp;eacute;ricos, que es lo que sucede cuando llamamos a este m&amp;eacute;todo con valores &lt;code&gt;String&lt;/code&gt; . Discutiremos los gen&amp;eacute;ricos en el Cap&amp;iacute;tulo 10. Esta firma nos da las pistas que necesitamos para comprender los aspectos complicados del operador &lt;code&gt;+&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="677e3e0ad58a3857efcf5b71bd28f251f1ad71c2" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t the last you&amp;rsquo;ll see of concurrency in this book: the project in Chapter 20 will use the concepts in this chapter in a more realistic situation than the smaller examples discussed here.</source>
          <target state="translated">Esta no es la &amp;uacute;ltima vez que ver&amp;aacute; simultaneidad en este libro: el proyecto del Cap&amp;iacute;tulo 20 utilizar&amp;aacute; los conceptos de este cap&amp;iacute;tulo en una situaci&amp;oacute;n m&amp;aacute;s realista que los ejemplos m&amp;aacute;s peque&amp;ntilde;os que se analizan aqu&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="c724cabc6d2e28a46495b5e9f7308161c3ff4773" translate="yes" xml:space="preserve">
          <source>This isn't allowed, but using a trait to implement a method is a good solution. Example:</source>
          <target state="translated">Esto no está permitido,pero usar un rasgo para implementar un método es una buena solución.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="c15fbb2556c65982174521dc6e82a15681dc164d" translate="yes" xml:space="preserve">
          <source>This isn't typically the method you want; these addresses don't typically function on modern systems. Use &lt;code&gt;to_ipv6_mapped&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca75bc59c45502aa721dfcf6b2008b560ce93b8c" translate="yes" xml:space="preserve">
          <source>This issue also ties into the second problem: although &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; are configuration variables to our program, variables like &lt;code&gt;contents&lt;/code&gt; are used to perform the program&amp;rsquo;s logic. The longer &lt;code&gt;main&lt;/code&gt; becomes, the more variables we&amp;rsquo;ll need to bring into scope; the more variables we have in scope, the harder it will be to keep track of the purpose of each. It&amp;rsquo;s best to group the configuration variables into one structure to make their purpose clear.</source>
          <target state="translated">Este problema tambi&amp;eacute;n se relaciona con el segundo problema: aunque la &lt;code&gt;query&lt;/code&gt; y el &lt;code&gt;filename&lt;/code&gt; son variables de configuraci&amp;oacute;n de nuestro programa, variables como el &lt;code&gt;contents&lt;/code&gt; se utilizan para realizar la l&amp;oacute;gica del programa. Cuanto m&amp;aacute;s largo sea el &lt;code&gt;main&lt;/code&gt; , m&amp;aacute;s variables tendremos que incorporar al alcance; cuantas m&amp;aacute;s variables tengamos en el alcance, m&amp;aacute;s dif&amp;iacute;cil ser&amp;aacute; hacer un seguimiento del prop&amp;oacute;sito de cada una. Es mejor agrupar las variables de configuraci&amp;oacute;n en una estructura para aclarar su prop&amp;oacute;sito.</target>
        </trans-unit>
        <trans-unit id="f6ff2f3673f7e2d10b1136073892f6a7e26909fe" translate="yes" xml:space="preserve">
          <source>This iterator is &lt;a href=&quot;../iter/trait.fusediterator&quot;&gt;fused&lt;/a&gt;, but the specific values of &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; after iteration has finished are &lt;strong&gt;unspecified&lt;/strong&gt; other than that &lt;a href=&quot;#method.is_empty&quot;&gt;&lt;code&gt;.is_empty()&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;true&lt;/code&gt; once no more values will be produced.</source>
          <target state="translated">Este iterador est&amp;aacute; &lt;a href=&quot;../iter/trait.fusediterator&quot;&gt;fusionado&lt;/a&gt; , pero los valores espec&amp;iacute;ficos de &lt;code&gt;start&lt;/code&gt; y &lt;code&gt;end&lt;/code&gt; vez finalizada la iteraci&amp;oacute;n &lt;strong&gt;no&lt;/strong&gt; est&amp;aacute;n &lt;strong&gt;especificados,&lt;/strong&gt; aparte de eso &lt;a href=&quot;#method.is_empty&quot;&gt; &lt;code&gt;.is_empty()&lt;/code&gt; &lt;/a&gt; devolver&amp;aacute; &lt;code&gt;true&lt;/code&gt; una vez que no se produzcan m&amp;aacute;s valores.</target>
        </trans-unit>
        <trans-unit id="b1db674404809b8384b33fb85e1f59e9aa55c87a" translate="yes" xml:space="preserve">
          <source>This iterator is &lt;a href=&quot;../iter/trait.fusediterator&quot;&gt;fused&lt;/a&gt;, but the specific values of &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; after iteration has finished are &lt;strong&gt;unspecified&lt;/strong&gt; other than that &lt;a href=&quot;struct.rangeinclusive#method.is_empty&quot;&gt;&lt;code&gt;.is_empty()&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;true&lt;/code&gt; once no more values will be produced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22ff5b740b07569a5d9914bbdea6a0fe28474b82" translate="yes" xml:space="preserve">
          <source>This iterator is returned from the &lt;a href=&quot;fn.read_dir&quot;&gt;&lt;code&gt;read_dir&lt;/code&gt;&lt;/a&gt; function of this module and will yield instances of &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;struct.direntry&quot;&gt;&lt;code&gt;DirEntry&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. Through a &lt;a href=&quot;struct.direntry&quot;&gt;&lt;code&gt;DirEntry&lt;/code&gt;&lt;/a&gt; information like the entry's path and possibly other metadata can be learned.</source>
          <target state="translated">Este iterador se devuelve del &lt;a href=&quot;fn.read_dir&quot;&gt; &lt;code&gt;read_dir&lt;/code&gt; &lt;/a&gt;funci&amp;oacute;n read_dir de este m&amp;oacute;dulo y producir&amp;aacute; instancias de&lt;a href=&quot;../io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;struct.direntry&quot;&gt; &lt;code&gt;DirEntry&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; . A trav&amp;eacute;s de un&lt;a href=&quot;struct.direntry&quot;&gt; &lt;code&gt;DirEntry&lt;/code&gt; se puede aprender&lt;/a&gt; informaci&amp;oacute;n como la ruta de la entrada y posiblemente otros metadatos.</target>
        </trans-unit>
        <trans-unit id="039cfdd22f7232d788dc3924aaf58e6af89b9b42" translate="yes" xml:space="preserve">
          <source>This iterator will block whenever &lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; is called, waiting for a new message, and &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; will be returned if the corresponding channel has hung up.</source>
          <target state="translated">Este iterador se bloquear&amp;aacute; cada vez que se llame a &lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; , esperando un nuevo mensaje, y se devolver&amp;aacute; &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; si el canal correspondiente ha colgado.</target>
        </trans-unit>
        <trans-unit id="47622e0905704752b067e8fb130b53a4d875da6d" translate="yes" xml:space="preserve">
          <source>This iterator will block whenever &lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; is called, waiting for a new message, and &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; will be returned when the corresponding channel has hung up.</source>
          <target state="translated">Este iterador se bloquear&amp;aacute; cada vez que se llame a &lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; , esperando un nuevo mensaje, y se devolver&amp;aacute; &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; cuando el canal correspondiente haya colgado.</target>
        </trans-unit>
        <trans-unit id="3d5f1a4f383a40c5608e98cdb7f233b0d0bd50b4" translate="yes" xml:space="preserve">
          <source>This iterator will never block the caller in order to wait for data to become available. Instead, it will return &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Este iterador nunca bloquear&amp;aacute; a la persona que llama para esperar a que los datos est&amp;eacute;n disponibles. En su lugar, devolver&amp;aacute; &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2ded90014878b45a9d1013952a0eeccef1815fa3" translate="yes" xml:space="preserve">
          <source>This iterator yields mutable references to the slice's elements, so while the element type of the slice is &lt;code&gt;i32&lt;/code&gt;, the element type of the iterator is &lt;code&gt;&amp;amp;mut i32&lt;/code&gt;.</source>
          <target state="translated">Este iterador produce referencias mutables a los elementos del segmento, por lo que mientras el tipo de elemento del segmento es &lt;code&gt;i32&lt;/code&gt; , el tipo de elemento del iterador es &lt;code&gt;&amp;amp;mut i32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f11293328eb4e550149e3eb11d18b4b99dadeb4a" translate="yes" xml:space="preserve">
          <source>This key uses the fastest possible implementation available to it for the target platform. It is instantiated with the &lt;a href=&quot;../macro.thread_local&quot;&gt;&lt;code&gt;thread_local!&lt;/code&gt;&lt;/a&gt; macro and the primary method is the &lt;a href=&quot;struct.localkey#method.with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Esta clave utiliza la implementaci&amp;oacute;n m&amp;aacute;s r&amp;aacute;pida posible disponible para la plataforma de destino. &amp;iexcl;Se &lt;a href=&quot;../macro.thread_local&quot;&gt; &lt;code&gt;thread_local!&lt;/code&gt; &lt;/a&gt; instancia con thread_local! macro y el m&amp;eacute;todo principal es el m&amp;eacute;todo &lt;a href=&quot;struct.localkey#method.with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8ba72c9f8d060c616c313ff46104db0834e023c2" translate="yes" xml:space="preserve">
          <source>This kind of reordering is handled transparently by the CPU.</source>
          <target state="translated">Este tipo de reordenación se maneja de forma transparente por la CPU.</target>
        </trans-unit>
        <trans-unit id="01e9e67a62e244fe3547a3a6a38b452018a02bd0" translate="yes" xml:space="preserve">
          <source>This kind of string &lt;em&gt;can&lt;/em&gt; be mutated:</source>
          <target state="translated">Este tipo de cadena &lt;em&gt;se&lt;/em&gt; puede modificar:</target>
        </trans-unit>
        <trans-unit id="a40000b09a25d1541d4b670c6d1a695e653d4397" translate="yes" xml:space="preserve">
          <source>This last example is different because it is not possible to use the suffix syntax with a floating point literal ending in a period. &lt;code&gt;2.f64&lt;/code&gt; would attempt to call a method named &lt;code&gt;f64&lt;/code&gt; on &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">Este &amp;uacute;ltimo ejemplo es diferente porque no es posible usar la sintaxis de sufijo con un literal de coma flotante que termina en un punto. &lt;code&gt;2.f64&lt;/code&gt; intentar&amp;iacute;a llamar a un m&amp;eacute;todo llamado &lt;code&gt;f64&lt;/code&gt; en &lt;code&gt;2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d48b41e91473a0fe92d3d1ed63ecf51de63aefff" translate="yes" xml:space="preserve">
          <source>This length is in bytes, not &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s or graphemes. In other words, it may not be what a human considers the length of the string.</source>
          <target state="translated">Esta longitud es en bytes, no &lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; s o grafemas. En otras palabras, puede que no sea lo que un humano considera la longitud de la cuerda.</target>
        </trans-unit>
        <trans-unit id="73dde2c319f588f84c6b8fc0596849d35bbf8b64" translate="yes" xml:space="preserve">
          <source>This length is in bytes, not &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s or graphemes. In other words, it may not be what a human considers the length of the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="903d848487fc64b3813a8038fcea8db3d845066a" translate="yes" xml:space="preserve">
          <source>This length is in bytes, not &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s or graphemes. In other words, it may not be what a human considers the length of the string.</source>
          <target state="translated">Esta longitud es en bytes, no &lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; s o grafemas. En otras palabras, puede que no sea lo que un humano considera la longitud de la cuerda.</target>
        </trans-unit>
        <trans-unit id="7b4fe84d99fc580ad8ef75775e9a6a1acf338c01" translate="yes" xml:space="preserve">
          <source>This length is in bytes, not &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s or graphemes. In other words, it may not be what a human considers the length of the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f8980a7dcbb36debff75ad398d722c2e476b435" translate="yes" xml:space="preserve">
          <source>This limitation may be removed in a future version of Rust.</source>
          <target state="translated">Esta limitación puede ser eliminada en una futura versión de Rust.</target>
        </trans-unit>
        <trans-unit id="65d7d6e48995b9a8b70ff571d23a4947777c0d68" translate="yes" xml:space="preserve">
          <source>This limitation on the size &lt;code&gt;N&lt;/code&gt; exists because Rust does not yet support code that is generic over the size of an array type. &lt;code&gt;[Foo; 3]&lt;/code&gt; and &lt;code&gt;[Bar; 3]&lt;/code&gt; are instances of same generic type &lt;code&gt;[T; 3]&lt;/code&gt;, but &lt;code&gt;[Foo; 3]&lt;/code&gt; and &lt;code&gt;[Foo; 5]&lt;/code&gt; are entirely different types. As a stopgap, trait implementations are statically generated up to size 32.</source>
          <target state="translated">Esta limitaci&amp;oacute;n en el tama&amp;ntilde;o &lt;code&gt;N&lt;/code&gt; existe porque Rust a&amp;uacute;n no admite c&amp;oacute;digo gen&amp;eacute;rico sobre el tama&amp;ntilde;o de un tipo de matriz. &lt;code&gt;[Foo; 3]&lt;/code&gt; y &lt;code&gt;[Bar; 3]&lt;/code&gt; son instancias del mismo tipo gen&amp;eacute;rico &lt;code&gt;[T; 3]&lt;/code&gt; , pero &lt;code&gt;[Foo; 3]&lt;/code&gt; y &lt;code&gt;[Foo; 5]&lt;/code&gt; son tipos completamente diferentes. Como medida provisional, las implementaciones de rasgos se generan est&amp;aacute;ticamente hasta el tama&amp;ntilde;o 32.</target>
        </trans-unit>
        <trans-unit id="08204384af7f77c5b07543f234ee809fc102751e" translate="yes" xml:space="preserve">
          <source>This line brings &lt;code&gt;std::io&lt;/code&gt; and &lt;code&gt;std::io::Write&lt;/code&gt; into scope.</source>
          <target state="translated">Esta l&amp;iacute;nea trae &lt;code&gt;std::io&lt;/code&gt; y &lt;code&gt;std::io::Write&lt;/code&gt; al alcance.</target>
        </trans-unit>
        <trans-unit id="c84219e32c60c562866367e57dce5465f094cc72" translate="yes" xml:space="preserve">
          <source>This line creates a new empty string called &lt;code&gt;s&lt;/code&gt;, which we can then load data into. Often, we&amp;rsquo;ll have some initial data that we want to start the string with. For that, we use the &lt;code&gt;to_string&lt;/code&gt; method, which is available on any type that implements the &lt;code&gt;Display&lt;/code&gt; trait, as string literals do. Listing 8-12 shows two examples.</source>
          <target state="translated">Esta l&amp;iacute;nea crea una nueva cadena vac&amp;iacute;a llamada &lt;code&gt;s&lt;/code&gt; , en la que luego podemos cargar datos. A menudo, tendremos algunos datos iniciales con los que queremos comenzar la cadena. Para eso, usamos la &lt;code&gt;to_string&lt;/code&gt; m&amp;eacute;todo , que est&amp;aacute; disponible en cualquier tipo que implemente el rasgo &lt;code&gt;Display&lt;/code&gt; , como lo hacen los literales de cadena. El listado 8-12 muestra dos ejemplos.</target>
        </trans-unit>
        <trans-unit id="c6d1af215b1b045e01e47bacfa1ae42f66655d33" translate="yes" xml:space="preserve">
          <source>This line creates a new variable named &lt;code&gt;foo&lt;/code&gt; and binds it to the value of the &lt;code&gt;bar&lt;/code&gt; variable. In Rust, variables are immutable by default. We&amp;rsquo;ll be discussing this concept in detail in the &lt;a href=&quot;ch03-01-variables-and-mutability#variables-and-mutability&quot;&gt;&amp;ldquo;Variables and Mutability&amp;rdquo;&lt;/a&gt; section in Chapter 3. The following example shows how to use &lt;code&gt;mut&lt;/code&gt; before the variable name to make a variable mutable:</source>
          <target state="translated">Esta l&amp;iacute;nea crea una nueva variable llamada &lt;code&gt;foo&lt;/code&gt; y la une al valor de la variable &lt;code&gt;bar&lt;/code&gt; . En Rust, las variables son inmutables por defecto. Discutiremos este concepto en detalle en la secci&amp;oacute;n &lt;a href=&quot;ch03-01-variables-and-mutability#variables-and-mutability&quot;&gt;&amp;ldquo;Variables y mutabilidad&amp;rdquo;&lt;/a&gt; en el Cap&amp;iacute;tulo 3. El siguiente ejemplo muestra c&amp;oacute;mo usar &lt;code&gt;mut&lt;/code&gt; antes del nombre de la variable para hacer una variable mutable:</target>
        </trans-unit>
        <trans-unit id="f414052fdd19a240f8f368c285f45f2ce792b467" translate="yes" xml:space="preserve">
          <source>This line does all the work in this little program: it prints text to the screen. There are four important details to notice here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d9eacc9407c12ec62c5abf0aec26e9081e77d6a" translate="yes" xml:space="preserve">
          <source>This line does all the work in this little program: it prints text to the screen. There are four important details to notice here. First, Rust style is to indent with four spaces, not a tab.</source>
          <target state="translated">Esta línea hace todo el trabajo en este pequeño programa:imprime el texto en la pantalla.Hay cuatro detalles importantes que hay que tener en cuenta aquí.Primero,el estilo Rust es sangrar con cuatro espacios,no un tabulador.</target>
        </trans-unit>
        <trans-unit id="6bb12529672d4d91a104d1b5e1346fffbd28c07c" translate="yes" xml:space="preserve">
          <source>This line prints the string we saved the user&amp;rsquo;s input in. The set of curly brackets, &lt;code&gt;{}&lt;/code&gt;, is a placeholder: think of &lt;code&gt;{}&lt;/code&gt; as little crab pincers that hold a value in place. You can print more than one value using curly brackets: the first set of curly brackets holds the first value listed after the format string, the second set holds the second value, and so on. Printing multiple values in one call to &lt;code&gt;println!&lt;/code&gt; would look like this:</source>
          <target state="translated">Esta l&amp;iacute;nea imprime la cadena en la que guardamos la entrada del usuario. El conjunto de llaves, &lt;code&gt;{}&lt;/code&gt; , es un marcador de posici&amp;oacute;n: piense en &lt;code&gt;{}&lt;/code&gt; como peque&amp;ntilde;as pinzas de cangrejo que mantienen un valor en su lugar. Puede imprimir m&amp;aacute;s de un valor utilizando corchetes: el primer conjunto de corchetes contiene el primer valor enumerado despu&amp;eacute;s de la cadena de formato, el segundo conjunto contiene el segundo valor, y as&amp;iacute; sucesivamente. Imprimir varios valores en una llamada a &lt;code&gt;println!&lt;/code&gt; se ver&amp;iacute;a as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="250f132a4cd3e14f1923c5e6c25a460649fabde4" translate="yes" xml:space="preserve">
          <source>This list is intended to grow over time and it is not recommended to exhaustively match against it.</source>
          <target state="translated">Esta lista está pensada para crecer con el tiempo y no se recomienda hacer una comparación exhaustiva con ella.</target>
        </trans-unit>
        <trans-unit id="308882c8bb15621452c72c71d1e862ba6ca42816" translate="yes" xml:space="preserve">
          <source>This longer form is equivalent to the example in the previous section but is more verbose. We place trait bounds with the declaration of the generic type parameter after a colon and inside angle brackets.</source>
          <target state="translated">Esta forma más larga equivale al ejemplo de la sección anterior pero es más verbosa.Ponemos límites de rasgos con la declaración del parámetro de tipo genérico después de los dos puntos y dentro de los corchetes de los ángulos.</target>
        </trans-unit>
        <trans-unit id="cc7e694b75fd14e7d2942129d96e2363378281a2" translate="yes" xml:space="preserve">
          <source>This looks very similar to the previous code, so we might assume that the way it works would be the same: that is, the second line would make a copy of the value in &lt;code&gt;s1&lt;/code&gt; and bind it to &lt;code&gt;s2&lt;/code&gt;. But this isn&amp;rsquo;t quite what happens.</source>
          <target state="translated">Esto se parece mucho al c&amp;oacute;digo anterior, por lo que podr&amp;iacute;amos suponer que la forma en que funciona ser&amp;iacute;a la misma: es decir, la segunda l&amp;iacute;nea har&amp;iacute;a una copia del valor en &lt;code&gt;s1&lt;/code&gt; y lo vincular&amp;iacute;a a &lt;code&gt;s2&lt;/code&gt; . Pero esto no es exactamente lo que sucede.</target>
        </trans-unit>
        <trans-unit id="1be98a7c6692df395b8bd9dd115eb38bb55be823" translate="yes" xml:space="preserve">
          <source>This macro accepts a 'writer', a format string, and a list of arguments. Arguments will be formatted according to the specified format string and the result will be passed to the writer. The writer may be any value with a &lt;code&gt;write_fmt&lt;/code&gt; method; generally this comes from an implementation of either the &lt;a href=&quot;fmt/trait.write&quot;&gt;&lt;code&gt;fmt::Write&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;io/trait.write&quot;&gt;&lt;code&gt;io::Write&lt;/code&gt;&lt;/a&gt; trait. The macro returns whatever the &lt;code&gt;write_fmt&lt;/code&gt; method returns; commonly a &lt;a href=&quot;fmt/type.result&quot;&gt;&lt;code&gt;fmt::Result&lt;/code&gt;&lt;/a&gt;, or an &lt;a href=&quot;io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3025eb870ba9e5f6ef770103ab20b04b0f42de4f" translate="yes" xml:space="preserve">
          <source>This macro accepts a format string, a list of arguments, and a 'writer'. Arguments will be formatted according to the specified format string and the result will be passed to the writer. The writer may be any value with a &lt;code&gt;write_fmt&lt;/code&gt; method; generally this comes from an implementation of either the &lt;a href=&quot;fmt/trait.write&quot;&gt;&lt;code&gt;fmt::Write&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;io/trait.write&quot;&gt;&lt;code&gt;io::Write&lt;/code&gt;&lt;/a&gt; trait. The macro returns whatever the &lt;code&gt;write_fmt&lt;/code&gt; method returns; commonly a &lt;a href=&quot;fmt/type.result&quot;&gt;&lt;code&gt;fmt::Result&lt;/code&gt;&lt;/a&gt;, or an &lt;a href=&quot;io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9c26f6e16b6bec90033e045df684b9983904c03" translate="yes" xml:space="preserve">
          <source>This macro accepts a format string, a list of arguments, and a 'writer'. Arguments will be formatted according to the specified format string and the result will be passed to the writer. The writer may be any value with a &lt;code&gt;write_fmt&lt;/code&gt; method; generally this comes from an implementation of either the &lt;a href=&quot;fmt/trait.write&quot;&gt;&lt;code&gt;std::fmt::Write&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;io/trait.write&quot;&gt;&lt;code&gt;std::io::Write&lt;/code&gt;&lt;/a&gt; trait. The macro returns whatever the &lt;code&gt;write_fmt&lt;/code&gt; method returns; commonly a &lt;a href=&quot;fmt/type.result&quot;&gt;&lt;code&gt;std::fmt::Result&lt;/code&gt;&lt;/a&gt;, or an &lt;a href=&quot;io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esta macro acepta una cadena de formato, una lista de argumentos y un 'escritor'. Los argumentos se formatear&amp;aacute;n de acuerdo con la cadena de formato especificada y el resultado se pasar&amp;aacute; al escritor. El escritor puede tener cualquier valor con un m&amp;eacute;todo &lt;code&gt;write_fmt&lt;/code&gt; ; generalmente, esto proviene de una implementaci&amp;oacute;n del &lt;a href=&quot;fmt/trait.write&quot;&gt; &lt;code&gt;std::fmt::Write&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;io/trait.write&quot;&gt; &lt;code&gt;std::io::Write&lt;/code&gt; &lt;/a&gt; . La macro devuelve lo que devuelve el m&amp;eacute;todo &lt;code&gt;write_fmt&lt;/code&gt; ; com&amp;uacute;nmente un &lt;a href=&quot;fmt/type.result&quot;&gt; &lt;code&gt;std::fmt::Result&lt;/code&gt; &lt;/a&gt; , o un &lt;a href=&quot;io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="80d761ee9febd1152f2043eb4792d1bde7232938" translate="yes" xml:space="preserve">
          <source>This macro bakes in propagation of &lt;code&gt;Pending&lt;/code&gt; signals by returning early.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9104464c61f2440f3d22798d14bf9b51373598ab" translate="yes" xml:space="preserve">
          <source>This macro functions by taking a formatting string literal containing &lt;code&gt;{}&lt;/code&gt; for each additional argument passed. &lt;code&gt;format_args!&lt;/code&gt; prepares the additional parameters to ensure the output can be interpreted as a string and canonicalizes the arguments into a single type. Any value that implements the &lt;a href=&quot;fmt/trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; trait can be passed to &lt;code&gt;format_args!&lt;/code&gt;, as can any &lt;a href=&quot;fmt/trait.debug&quot;&gt;&lt;code&gt;Debug&lt;/code&gt;&lt;/a&gt; implementation be passed to a &lt;code&gt;{:?}&lt;/code&gt; within the formatting string.</source>
          <target state="translated">Esta macro funciona tomando una cadena de formato literal que contiene &lt;code&gt;{}&lt;/code&gt; para cada argumento adicional pasado. &lt;code&gt;format_args!&lt;/code&gt; prepara los par&amp;aacute;metros adicionales para garantizar que la salida se pueda interpretar como una cadena y canonicaliza los argumentos en un solo tipo. &amp;iexcl;Cualquier valor que implemente el rasgo &lt;a href=&quot;fmt/trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt; se puede pasar a &lt;code&gt;format_args!&lt;/code&gt; , al igual que cualquier implementaci&amp;oacute;n de &lt;a href=&quot;fmt/trait.debug&quot;&gt; &lt;code&gt;Debug&lt;/code&gt; &lt;/a&gt; puede pasar a &lt;code&gt;{:?}&lt;/code&gt; dentro de la cadena de formato.</target>
        </trans-unit>
        <trans-unit id="c0f46ebdcffb6d5939dcac636e4ba0ac8074178d" translate="yes" xml:space="preserve">
          <source>This macro has a second form, where a custom panic message can be provided with or without arguments for formatting. See &lt;a href=&quot;fmt/index&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for syntax for this form.</source>
          <target state="translated">Esta macro tiene una segunda forma, donde se puede proporcionar un mensaje de p&amp;aacute;nico personalizado con o sin argumentos para formatear. Consulte &lt;a href=&quot;fmt/index&quot;&gt; &lt;code&gt;std::fmt&lt;/code&gt; &lt;/a&gt; para conocer la sintaxis de este formulario.</target>
        </trans-unit>
        <trans-unit id="1cb7c87fdbeb8a27a8d17493d87d56c13827aded" translate="yes" xml:space="preserve">
          <source>This macro has a second form, where a custom panic message can be provided with or without arguments for formatting. See &lt;a href=&quot;https://doc.rust-lang.org/core/fmt/index.html&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for syntax for this form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b5986245d717af402afebe47105d05cdf22c051" translate="yes" xml:space="preserve">
          <source>This macro is provided in the standard library and will detect at runtime whether the specified CPU feature is detected. This does &lt;strong&gt;not&lt;/strong&gt; resolve at compile time unless the specified feature is already enabled for the entire crate. Runtime detection currently relies mostly on the &lt;code&gt;cpuid&lt;/code&gt; instruction.</source>
          <target state="translated">Esta macro se proporciona en la biblioteca est&amp;aacute;ndar y detectar&amp;aacute; en tiempo de ejecuci&amp;oacute;n si se detecta la funci&amp;oacute;n de CPU especificada. Esto no &lt;strong&gt;se&lt;/strong&gt; resuelve en el momento de la compilaci&amp;oacute;n a menos que la funci&amp;oacute;n especificada ya est&amp;eacute; habilitada para toda la caja. La detecci&amp;oacute;n en tiempo de ejecuci&amp;oacute;n actualmente se basa principalmente en la instrucci&amp;oacute;n &lt;code&gt;cpuid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c76b02a9e85e30ad24e030882216f3064330d6d" translate="yes" xml:space="preserve">
          <source>This macro is the perfect way to assert conditions in example code and in tests. &lt;code&gt;panic!&lt;/code&gt; is closely tied with the &lt;code&gt;unwrap&lt;/code&gt; method of both &lt;a href=&quot;option/enum.option#method.unwrap&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;result/enum.result#method.unwrap&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; enums. Both implementations call &lt;code&gt;panic!&lt;/code&gt; when they are set to &lt;a href=&quot;option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; variants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80d199c9b2bbee396aca26a7f3417fd4e87ff814" translate="yes" xml:space="preserve">
          <source>This macro is the perfect way to assert conditions in example code and in tests. &lt;code&gt;panic!&lt;/code&gt; is closely tied with the &lt;code&gt;unwrap&lt;/code&gt; method of both &lt;a href=&quot;option/enum.option#method.unwrap&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;result/enum.result#method.unwrap&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; enums. Both implementations call &lt;code&gt;panic!&lt;/code&gt; when they are set to None or Err variants.</source>
          <target state="translated">Esta macro es la manera perfecta de afirmar condiciones en c&amp;oacute;digo de ejemplo y en pruebas. &lt;code&gt;panic!&lt;/code&gt; est&amp;aacute; estrechamente relacionado con el m&amp;eacute;todo de &lt;code&gt;unwrap&lt;/code&gt; de las enumeraciones &lt;a href=&quot;option/enum.option#method.unwrap&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;result/enum.result#method.unwrap&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; . Ambas implementaciones llaman &lt;code&gt;panic!&lt;/code&gt; cuando se establecen en las variantes None o Err.</target>
        </trans-unit>
        <trans-unit id="d0ebce932633e1b0cd797b4ddeb6ac5a11d9e6f7" translate="yes" xml:space="preserve">
          <source>This macro is used to inject panic into a Rust thread, causing the thread to panic entirely. Each thread's panic can be reaped as the &lt;a href=&quot;boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;any/trait.any&quot;&gt;&lt;code&gt;Any&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; type, and the single-argument form of the &lt;code&gt;panic!&lt;/code&gt; macro will be the value which is transmitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf0774da3df0d29e08106daf482fff334bcea403" translate="yes" xml:space="preserve">
          <source>This macro is used to inject panic into a Rust thread, causing the thread to panic entirely. Each thread's panic can be reaped as the &lt;code&gt;Box&amp;lt;Any&amp;gt;&lt;/code&gt; type, and the single-argument form of the &lt;code&gt;panic!&lt;/code&gt; macro will be the value which is transmitted.</source>
          <target state="translated">Esta macro se usa para inyectar p&amp;aacute;nico en un hilo de Rust, haciendo que el hilo entre en p&amp;aacute;nico por completo. &amp;iexcl;El p&amp;aacute;nico de cada hilo se puede cosechar como el tipo &lt;code&gt;Box&amp;lt;Any&amp;gt;&lt;/code&gt; y la forma de un solo argumento del &lt;code&gt;panic!&lt;/code&gt; macro ser&amp;aacute; el valor que se transmite.</target>
        </trans-unit>
        <trans-unit id="e7802aaf0db102edbab92f402c03063ff3b73be4" translate="yes" xml:space="preserve">
          <source>This macro only takes one argument which is a string literal of the feature being tested for. The feature names supported are the lowercase versions of the ones defined by Intel in &lt;a href=&quot;https://software.intel.com/sites/landingpage/IntrinsicsGuide&quot;&gt;their documentation&lt;/a&gt;.</source>
          <target state="translated">Esta macro solo toma un argumento que es una cadena literal de la caracter&amp;iacute;stica que se est&amp;aacute; probando. Los nombres de las funciones admitidas son las versiones en min&amp;uacute;sculas de las definidas por Intel en &lt;a href=&quot;https://software.intel.com/sites/landingpage/IntrinsicsGuide&quot;&gt;su documentaci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4bd8a54709ee381edf667e1b754c2dd4776028dd" translate="yes" xml:space="preserve">
          <source>This macro produces a value of type &lt;a href=&quot;fmt/struct.arguments&quot;&gt;&lt;code&gt;fmt::Arguments&lt;/code&gt;&lt;/a&gt;. This value can be passed to the macros within &lt;a href=&quot;fmt/index&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for performing useful redirection. All other formatting macros (&lt;a href=&quot;macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;macro.println&quot;&gt;&lt;code&gt;println!&lt;/code&gt;&lt;/a&gt;, etc) are proxied through this one. &lt;code&gt;format_args!&lt;/code&gt;, unlike its derived macros, avoids heap allocations.</source>
          <target state="translated">Esta macro produce un valor de tipo &lt;a href=&quot;fmt/struct.arguments&quot;&gt; &lt;code&gt;fmt::Arguments&lt;/code&gt; &lt;/a&gt; . Este valor se puede pasar a las macros dentro de &lt;a href=&quot;fmt/index&quot;&gt; &lt;code&gt;std::fmt&lt;/code&gt; &lt;/a&gt; para realizar una redirecci&amp;oacute;n &amp;uacute;til. Todas las otras macros de formato ( &lt;a href=&quot;macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;macro.println&quot;&gt; &lt;code&gt;println!&lt;/code&gt; &lt;/a&gt; , Etc) est&amp;aacute;n proxy a trav&amp;eacute;s de &amp;eacute;ste. &lt;code&gt;format_args!&lt;/code&gt; , a diferencia de sus macros derivadas, evita las asignaciones de mont&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="209265c4eb72c5eca06cd095d36df90048938379" translate="yes" xml:space="preserve">
          <source>This macro produces a value of type &lt;a href=&quot;fmt/struct.arguments&quot;&gt;&lt;code&gt;fmt::Arguments&lt;/code&gt;&lt;/a&gt;. This value can be passed to the macros within &lt;a href=&quot;https://doc.rust-lang.org/core/fmt/index.html&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for performing useful redirection. All other formatting macros (&lt;a href=&quot;macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;macro.println&quot;&gt;&lt;code&gt;println!&lt;/code&gt;&lt;/a&gt;, etc) are proxied through this one. &lt;code&gt;format_args!&lt;/code&gt;, unlike its derived macros, avoids heap allocations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d449e18cd48bf8c444aeabc9c847abf69b5ab8d" translate="yes" xml:space="preserve">
          <source>This macro should be used when a crate uses a conditional compilation strategy to provide better error messages for erroneous conditions. It's the compiler-level form of &lt;a href=&quot;macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;, but emits an error during &lt;em&gt;compilation&lt;/em&gt; rather than at &lt;em&gt;runtime&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d49c196cc9f23d7594245f1cc87a1f518746592e" translate="yes" xml:space="preserve">
          <source>This macro should be used when a crate uses a conditional compilation strategy to provide better error messages for erroneous conditions. It's the compiler-level form of &lt;a href=&quot;macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;, which emits an error at &lt;em&gt;runtime&lt;/em&gt;, rather than during compilation.</source>
          <target state="translated">Esta macro debe usarse cuando una caja usa una estrategia de compilaci&amp;oacute;n condicional para proporcionar mejores mensajes de error para condiciones err&amp;oacute;neas. &amp;iexcl;Es la forma de &lt;a href=&quot;macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt; nivel de compilador ! , que emite un error en &lt;em&gt;tiempo&lt;/em&gt; de &lt;em&gt;ejecuci&amp;oacute;n&lt;/em&gt; , en lugar de durante la compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="68d15cf83524f34dd8d8be7a2a8e7bed6740e783" translate="yes" xml:space="preserve">
          <source>This macro supports the same names that &lt;code&gt;#[target_feature]&lt;/code&gt; supports. Unlike &lt;code&gt;#[target_feature]&lt;/code&gt;, however, this macro does not support names separated with a comma. Instead testing for multiple features must be done through separate macro invocations for now.</source>
          <target state="translated">Esta macro admite los mismos nombres que admite &lt;code&gt;#[target_feature]&lt;/code&gt; . Sin embargo, a diferencia de &lt;code&gt;#[target_feature]&lt;/code&gt; , esta macro no admite nombres separados por comas. En su lugar, las pruebas para m&amp;uacute;ltiples funciones se deben realizar a trav&amp;eacute;s de invocaciones de macro independientes por ahora.</target>
        </trans-unit>
        <trans-unit id="fefc6add454f34259443790785050840eebbeb57" translate="yes" xml:space="preserve">
          <source>This macro takes any number of comma-separated identifiers, and concatenates them all into one, yielding an expression which is a new identifier. Note that hygiene makes it such that this macro cannot capture local variables. Also, as a general rule, macros are only allowed in item, statement or expression position. That means while you may use this macro for referring to existing variables, functions or modules etc, you cannot define a new one with it.</source>
          <target state="translated">Esta macro toma cualquier número de identificadores separados por comas,y los concatena todos en uno,produciendo una expresión que es un nuevo identificador.Nótese que la higiene es tal que este macro no puede capturar variables locales.Además,como regla general,las macros sólo se permiten en la posición de elemento,declaración o expresión.Esto significa que aunque se puede utilizar esta macro para referirse a variables,funciones o módulos existentes,etc.,no se puede definir una nueva con ella.</target>
        </trans-unit>
        <trans-unit id="a79ce9bb3fa69012483f80e7a1a2541065700d68" translate="yes" xml:space="preserve">
          <source>This macro takes any number of comma-separated literals, yielding an expression of type &lt;code&gt;&amp;amp;'static str&lt;/code&gt; which represents all of the literals concatenated left-to-right.</source>
          <target state="translated">Esta macro toma cualquier n&amp;uacute;mero de literales separados por comas, produciendo una expresi&amp;oacute;n de tipo &lt;code&gt;&amp;amp;'static str&lt;/code&gt; que representa todos los literales concatenados de izquierda a derecha.</target>
        </trans-unit>
        <trans-unit id="79fc3c2904becf8aa3c820c279472de0fe3a1f68" translate="yes" xml:space="preserve">
          <source>This macro will expand to the value of the named environment variable at compile time, yielding an expression of type &lt;code&gt;&amp;amp;'static str&lt;/code&gt;.</source>
          <target state="translated">Esta macro se expandir&amp;aacute; al valor de la variable de entorno nombrada en tiempo de compilaci&amp;oacute;n, produciendo una expresi&amp;oacute;n de tipo &lt;code&gt;&amp;amp;'static str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95e973b1ebc33842358cee19e0dba22c8a81f994" translate="yes" xml:space="preserve">
          <source>This macro will yield an expression of type &lt;code&gt;&amp;amp;'static [u8; N]&lt;/code&gt; which is the contents of the file.</source>
          <target state="translated">Esta macro producir&amp;aacute; una expresi&amp;oacute;n de tipo &lt;code&gt;&amp;amp;'static [u8; N]&lt;/code&gt; que es el contenido del archivo.</target>
        </trans-unit>
        <trans-unit id="9cdb0bb59a3aefac2ea084695df47352b8cc7f18" translate="yes" xml:space="preserve">
          <source>This macro will yield an expression of type &lt;code&gt;&amp;amp;'static str&lt;/code&gt; which is the contents of the file.</source>
          <target state="translated">Esta macro producir&amp;aacute; una expresi&amp;oacute;n de tipo &lt;code&gt;&amp;amp;'static str&lt;/code&gt; que es el contenido del archivo.</target>
        </trans-unit>
        <trans-unit id="8d3907f6b0e9a61a4bdb55de9a362a92915237c3" translate="yes" xml:space="preserve">
          <source>This macro will yield an expression of type &lt;code&gt;&amp;amp;'static str&lt;/code&gt; which is the stringification of all the tokens passed to the macro. No restrictions are placed on the syntax of the macro invocation itself.</source>
          <target state="translated">Esta macro producir&amp;aacute; una expresi&amp;oacute;n de tipo &lt;code&gt;&amp;amp;'static str&lt;/code&gt; que es la cadena de todos los tokens pasados ​​a la macro. No se imponen restricciones a la sintaxis de la propia invocaci&amp;oacute;n de macro.</target>
        </trans-unit>
        <trans-unit id="96f8e740156b1fe8242bb1857eb516b34c772e7e" translate="yes" xml:space="preserve">
          <source>This macro would parse the SQL statement inside it and check that it&amp;rsquo;s syntactically correct, which is much more complex processing than a &lt;code&gt;macro_rules!&lt;/code&gt; macro can do. The &lt;code&gt;sql!&lt;/code&gt; macro would be defined like this:</source>
          <target state="translated">Esta macro analizar&amp;iacute;a la instrucci&amp;oacute;n SQL dentro de ella y verificar&amp;iacute;a que sea sint&amp;aacute;cticamente correcta, lo cual es un procesamiento mucho m&amp;aacute;s complejo que una &lt;code&gt;macro_rules!&lt;/code&gt; macro puede hacer. El &lt;code&gt;sql!&lt;/code&gt; macro se definir&amp;iacute;a as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="f58f7dcc462ef7387fceff17b5cae04e3cbcbf04" translate="yes" xml:space="preserve">
          <source>This makes the trait implemented on all types in the scope. So if you try to implement it on another one after that, the implementations will conflict. Example:</source>
          <target state="translated">Esto hace que el rasgo implementado en todos los tipos en el ámbito de aplicación.Así que si intentas implementarlo en otro después de eso,las implementaciones entrarán en conflicto.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="dafc2f14b4f56d8dc5d075ff34c826a36e387880" translate="yes" xml:space="preserve">
          <source>This may not actually increase the capacity:</source>
          <target state="translated">Es posible que esto no aumente la capacidad:</target>
        </trans-unit>
        <trans-unit id="af903b6fc00acf0d280f6c29b1e0e8d3aeb94082" translate="yes" xml:space="preserve">
          <source>This may only be called by &lt;code&gt;Read&lt;/code&gt;ers which guarantee that they will not read from buffers passed to &lt;code&gt;Read&lt;/code&gt; methods, and that the return value of the method accurately reflects the number of bytes that have been written to the head of the buffer.</source>
          <target state="translated">Esto s&amp;oacute;lo puede ser llamado por &lt;code&gt;Read&lt;/code&gt; ERS, que garant&amp;iacute;a de que no ser&amp;aacute;n le&amp;iacute;dos de los tampones pasados a &lt;code&gt;Read&lt;/code&gt; m&amp;eacute;todos, y que el valor de retorno del m&amp;eacute;todo refleja con precisi&amp;oacute;n el n&amp;uacute;mero de bytes que se han escrito en la cabecera de la memoria intermedia.</target>
        </trans-unit>
        <trans-unit id="14a8a7c42cf833272747226b7446d6fe81b3ec47" translate="yes" xml:space="preserve">
          <source>This may require additional type hints in the function body.</source>
          <target state="translated">Esto puede requerir indicaciones de tipo adicionales en el cuerpo de la función.</target>
        </trans-unit>
        <trans-unit id="ac8b21b0f73b2747acf512efef8390bcec866c71" translate="yes" xml:space="preserve">
          <source>This means iterator adapters can rely on the source not changing during iteration but they cannot rely on it in their Drop implementations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b07ba109060bf875c034ba50fdb9ffdabfec4929" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;&amp;lt;T: 'a + ?Sized&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;T: 'b + Sized&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; are all permitted.</source>
          <target state="translated">Esto significa que &lt;code&gt;&amp;lt;T: 'a + ?Sized&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;T: 'b + Sized&amp;gt;&lt;/code&gt; y &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; est&amp;aacute;n permitidos.</target>
        </trans-unit>
        <trans-unit id="7a8c1c98c2b07fe7a77662bf8cf1e31aa75a3d05" translate="yes" xml:space="preserve">
          <source>This means that any external crate referencing &lt;code&gt;implementation::api::f&lt;/code&gt; would receive a privacy violation, while the path &lt;code&gt;api::f&lt;/code&gt; would be allowed.</source>
          <target state="translated">Esto significa que cualquier caja externa que haga referencia a la &lt;code&gt;implementation::api::f&lt;/code&gt; recibir&amp;iacute;a una violaci&amp;oacute;n de privacidad, mientras que la ruta &lt;code&gt;api::f&lt;/code&gt; estar&amp;iacute;a permitida.</target>
        </trans-unit>
        <trans-unit id="be2e4dfa333e1a56bbed2f9ca40e5f02293eda70" translate="yes" xml:space="preserve">
          <source>This means that perhaps some of the preceding patterns are too general, this one is too specific or the ordering is incorrect.</source>
          <target state="translated">Esto significa que tal vez algunos de los patrones precedentes son demasiado generales,este es demasiado específico o el ordenamiento es incorrecto.</target>
        </trans-unit>
        <trans-unit id="3a6a30f5c049c4edc23b7fd66710a9051982b10a" translate="yes" xml:space="preserve">
          <source>This means that someone can specify such a function:</source>
          <target state="translated">Esto significa que alguien puede especificar tal función:</target>
        </trans-unit>
        <trans-unit id="cb26a69e23fbbf1b07ba0d9979e852887a91fd3d" translate="yes" xml:space="preserve">
          <source>This means that the contents of the first string above &lt;em&gt;will&lt;/em&gt; fit into a &lt;code&gt;char&lt;/code&gt; while the contents of the second string &lt;em&gt;will not&lt;/em&gt;. Trying to create a &lt;code&gt;char&lt;/code&gt; literal with the contents of the second string gives an error:</source>
          <target state="translated">Esto significa que el contenido de la primera cadena anterior &lt;em&gt;se&lt;/em&gt; encajan en un &lt;code&gt;char&lt;/code&gt; , mientras que el contenido de la segunda cadena &lt;em&gt;no lo har&amp;aacute;&lt;/em&gt; . Intentar crear un literal &lt;code&gt;char&lt;/code&gt; con el contenido de la segunda cadena da un error:</target>
        </trans-unit>
        <trans-unit id="f9131c9dc6b963db63fbff2769fe5ceda6bacdcc" translate="yes" xml:space="preserve">
          <source>This means that the operands don't have to be moved out of.</source>
          <target state="translated">Esto significa que los operandos no tienen que ser movidos.</target>
        </trans-unit>
        <trans-unit id="b2ca51239acb100a6dd5efb03e14c814a0a94286" translate="yes" xml:space="preserve">
          <source>This means that when &lt;code&gt;s&lt;/code&gt; reaches the end of &lt;code&gt;demo&lt;/code&gt;, its destructor gets exclusive access to its &lt;code&gt;&amp;amp;mut&lt;/code&gt;-borrowed string data. allowing another borrow of that string data (&lt;code&gt;p&lt;/code&gt;), to exist across the drop of &lt;code&gt;s&lt;/code&gt; would be a violation of the principle that &lt;code&gt;&amp;amp;mut&lt;/code&gt;-borrows have exclusive, unaliased access to their referenced data.</source>
          <target state="translated">Esto significa que cuando &lt;code&gt;s&lt;/code&gt; llega al final de la &lt;code&gt;demo&lt;/code&gt; straci&amp;oacute;n , su destructor obtiene acceso exclusivo a sus datos de cadena prestados por &lt;code&gt;&amp;amp;mut&lt;/code&gt; . permitir que exista otro pr&amp;eacute;stamo de esa cadena de datos ( &lt;code&gt;p&lt;/code&gt; ) a trav&amp;eacute;s de la ca&amp;iacute;da de &lt;code&gt;s&lt;/code&gt; ser&amp;iacute;a una violaci&amp;oacute;n del principio de que &lt;code&gt;&amp;amp;mut&lt;/code&gt; -borrows tiene acceso exclusivo y sin alias a sus datos de referencia.</target>
        </trans-unit>
        <trans-unit id="9b50029fc42e472fbad4bc857af78f98f36c748f" translate="yes" xml:space="preserve">
          <source>This means that, for example, the padding byte in &lt;code&gt;(u8, u16)&lt;/code&gt; is not necessarily zeroed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="382ebf724244bccd694c658a6e7769ce6b7c071d" translate="yes" xml:space="preserve">
          <source>This means, that in addition to &lt;code&gt;a == b&lt;/code&gt; and &lt;code&gt;a != b&lt;/code&gt; being strict inverses, the equality must be (for all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;):</source>
          <target state="translated">Este medio, que, adem&amp;aacute;s de &lt;code&gt;a == b&lt;/code&gt; y &lt;code&gt;a != b&lt;/code&gt; Ser inversas estrictas, la igualdad debe ser (para todos &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; y &lt;code&gt;c&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="30330510a00e9290fc18b35d20dbe32f6afe0cd7" translate="yes" xml:space="preserve">
          <source>This method always returns &lt;code&gt;false&lt;/code&gt; after iteration has finished:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2cb7c4ca14739fd7d110ae41517acd9e412a5c2" translate="yes" xml:space="preserve">
          <source>This method by itself is safe, but using it correctly requires extra care. Another thread can change the strong count at any time, including potentially between calling this method and acting on the result.</source>
          <target state="translated">Este método por sí mismo es seguro,pero usarlo correctamente requiere un cuidado extra.Otro hilo puede cambiar la cuenta fuerte en cualquier momento,incluso potencialmente entre llamar a este método y actuar sobre el resultado.</target>
        </trans-unit>
        <trans-unit id="949f62fcaa7fc2070951a1bf81357a1eb29cd126" translate="yes" xml:space="preserve">
          <source>This method by itself is safe, but using it correctly requires extra care. Another thread can change the weak count at any time, including potentially between calling this method and acting on the result.</source>
          <target state="translated">Este método por sí mismo es seguro,pero usarlo correctamente requiere un cuidado extra.Otro hilo puede cambiar la cuenta débil en cualquier momento,incluso potencialmente entre llamar a este método y actuar sobre el resultado.</target>
        </trans-unit>
        <trans-unit id="3282baf6619178b04f6e093d59df95e6b50b4f0b" translate="yes" xml:space="preserve">
          <source>This method can be used for string data that is &lt;em&gt;terminated&lt;/em&gt;, rather than &lt;em&gt;separated&lt;/em&gt; by a pattern.</source>
          <target state="translated">Este m&amp;eacute;todo se puede utilizar para datos de cadena &lt;em&gt;terminados&lt;/em&gt; , en lugar de estar &lt;em&gt;separados&lt;/em&gt; por un patr&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="3369ccac8ace2a653ec652b1d0a5f9f1bd24f346" translate="yes" xml:space="preserve">
          <source>This method can be used to reverse a comparison:</source>
          <target state="translated">Este método puede utilizarse para invertir una comparación:</target>
        </trans-unit>
        <trans-unit id="9f13cbe122409bed70a7bfa8652dd2b252fa340b" translate="yes" xml:space="preserve">
          <source>This method can be useful for situations in which the vector is serving as a buffer for other code, particularly over FFI:</source>
          <target state="translated">Este método puede ser útil para situaciones en las que el vector sirve de amortiguador para otros códigos,en particular sobre el FFI:</target>
        </trans-unit>
        <trans-unit id="ce975c1398d44efbe8c10a5c85f55c0075a45068" translate="yes" xml:space="preserve">
          <source>This method can only succeed if the entire byte slice was successfully written, and this method will not return until all data has been written or an error occurs.</source>
          <target state="translated">Este método sólo puede tener éxito si todo el trozo de byte se ha escrito con éxito,y este método no volverá hasta que se hayan escrito todos los datos o se produzca un error.</target>
        </trans-unit>
        <trans-unit id="e42e806090a8aa6caab77166483a1eda09b5296d" translate="yes" xml:space="preserve">
          <source>This method can only succeed if the entire string slice was successfully written, and this method will not return until all data has been written or an error occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1f7d3cdb0bfa41dd91aa3d1bf03416a16ee48f3" translate="yes" xml:space="preserve">
          <source>This method differs from &lt;a href=&quot;struct.syncsender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; by returning immediately if the channel's buffer is full or no receiver is waiting to acquire some data. Compared with &lt;a href=&quot;struct.syncsender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt;, this function has two failure cases instead of one (one for disconnection, one for a full buffer).</source>
          <target state="translated">Este m&amp;eacute;todo se diferencia del &lt;a href=&quot;struct.syncsender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; al regresar inmediatamente si el b&amp;uacute;fer del canal est&amp;aacute; lleno o si ning&amp;uacute;n receptor est&amp;aacute; esperando para adquirir algunos datos. En comparaci&amp;oacute;n con el &lt;a href=&quot;struct.syncsender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; , esta funci&amp;oacute;n tiene dos casos de falla en lugar de uno (uno para la desconexi&amp;oacute;n y otro para un b&amp;uacute;fer lleno).</target>
        </trans-unit>
        <trans-unit id="028002d34f3fafd7bc54cd77bcaa912497a3b074" translate="yes" xml:space="preserve">
          <source>This method does &lt;strong&gt;not&lt;/strong&gt; pass ownership of the raw file descriptor to the caller. The descriptor is only guaranteed to be valid while the original object has not yet been destroyed.</source>
          <target state="translated">Este m&amp;eacute;todo &lt;strong&gt;no&lt;/strong&gt; transfiere la propiedad del descriptor de archivo sin formato a la persona que llama. Solo se garantiza que el descriptor es v&amp;aacute;lido mientras el objeto original a&amp;uacute;n no se haya destruido.</target>
        </trans-unit>
        <trans-unit id="5fd9fa51612a49edd496cd80117e23b29a509eb6" translate="yes" xml:space="preserve">
          <source>This method does &lt;strong&gt;not&lt;/strong&gt; return the length of the duration when represented by microseconds. The returned number always represents a fractional portion of a second (i.e., it is less than one million).</source>
          <target state="translated">Este m&amp;eacute;todo &lt;strong&gt;no&lt;/strong&gt; devuelve la longitud de la duraci&amp;oacute;n cuando se representa en microsegundos. El n&amp;uacute;mero devuelto siempre representa una fracci&amp;oacute;n de segundo (es decir, es menos de un mill&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="d3a3c1cf0cc150bd1c72971205d2190e708b8d2b" translate="yes" xml:space="preserve">
          <source>This method does &lt;strong&gt;not&lt;/strong&gt; return the length of the duration when represented by milliseconds. The returned number always represents a fractional portion of a second (i.e., it is less than one thousand).</source>
          <target state="translated">Este m&amp;eacute;todo &lt;strong&gt;no&lt;/strong&gt; devuelve la longitud de la duraci&amp;oacute;n cuando se representa en milisegundos. El n&amp;uacute;mero devuelto siempre representa una fracci&amp;oacute;n de segundo (es decir, es menos de mil).</target>
        </trans-unit>
        <trans-unit id="e8135547d5a3a3a5006fe1cbd5d76d770ff2a7a9" translate="yes" xml:space="preserve">
          <source>This method does &lt;strong&gt;not&lt;/strong&gt; return the length of the duration when represented by nanoseconds. The returned number always represents a fractional portion of a second (i.e., it is less than one billion).</source>
          <target state="translated">Este m&amp;eacute;todo &lt;strong&gt;no&lt;/strong&gt; devuelve la longitud de la duraci&amp;oacute;n cuando se representa en nanosegundos. El n&amp;uacute;mero devuelto siempre representa una fracci&amp;oacute;n de segundo (es decir, es menos de mil millones).</target>
        </trans-unit>
        <trans-unit id="ac2e63056cc906cac74875b70f6f9009af31f73d" translate="yes" xml:space="preserve">
          <source>This method does not allocate and does not change the order of the inserted elements. As it returns a mutable slice, this can be used to sort a deque.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdc4e2ef2ed35366fa011a172b72477b2d16bbd4" translate="yes" xml:space="preserve">
          <source>This method does not allocate and does not change the order of the inserted elements. As it returns a mutable slice, this can be used to sort or binary search a deque.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16f6f5d172fff1f1f8e9b8bb728e19c58e51b4b5" translate="yes" xml:space="preserve">
          <source>This method doesn't produce a value, but the write may fail. It's crucial to handle the error case, and &lt;em&gt;not&lt;/em&gt; write something like this:</source>
          <target state="translated">Este m&amp;eacute;todo no produce un valor, pero la escritura puede fallar. Es crucial manejar el caso de error y &lt;em&gt;no&lt;/em&gt; escribir algo como esto:</target>
        </trans-unit>
        <trans-unit id="0b024448d5d7228119631ad22266fba4066f9577" translate="yes" xml:space="preserve">
          <source>This method has a default implementation using &lt;a href=&quot;trait.exactsizeiterator#method.len&quot;&gt;&lt;code&gt;ExactSizeIterator::len()&lt;/code&gt;&lt;/a&gt;, so you don't need to implement it yourself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="803e98a2b6e5f0d6a98c75881fdb55c1597f80f0" translate="yes" xml:space="preserve">
          <source>This method has a default implementation using &lt;code&gt;self.len()&lt;/code&gt;, so you don't need to implement it yourself.</source>
          <target state="translated">Este m&amp;eacute;todo tiene una implementaci&amp;oacute;n predeterminada que usa &lt;code&gt;self.len()&lt;/code&gt; , por lo que no es necesario que lo implemente usted mismo.</target>
        </trans-unit>
        <trans-unit id="02fc3c4c098f9a864e6c45270c0a8ae6ffc408ef" translate="yes" xml:space="preserve">
          <source>This method has a default implementation, so you usually should not implement it directly. However, if you can provide a more efficient implementation, you can do so. See the &lt;a href=&quot;trait.exactsizeiterator&quot;&gt;trait-level&lt;/a&gt; docs for an example.</source>
          <target state="translated">Este m&amp;eacute;todo tiene una implementaci&amp;oacute;n predeterminada, por lo que normalmente no deber&amp;iacute;a implementarlo directamente. Sin embargo, si puede proporcionar una implementaci&amp;oacute;n m&amp;aacute;s eficiente, puede hacerlo. Consulte los documentos de &lt;a href=&quot;trait.exactsizeiterator&quot;&gt;nivel de rasgo&lt;/a&gt; para ver un ejemplo.</target>
        </trans-unit>
        <trans-unit id="89f3649aa28c1d3c90be74ebfb70d517cce77458" translate="yes" xml:space="preserve">
          <source>This method has no purpose when either input element &lt;code&gt;T&lt;/code&gt; or output element &lt;code&gt;U&lt;/code&gt; are zero-sized and will return the original slice without splitting anything.</source>
          <target state="translated">Este m&amp;eacute;todo no tiene ning&amp;uacute;n prop&amp;oacute;sito cuando el elemento de entrada &lt;code&gt;T&lt;/code&gt; o el elemento de salida &lt;code&gt;U&lt;/code&gt; son de tama&amp;ntilde;o cero y devolver&amp;aacute;n el segmento original sin dividir nada.</target>
        </trans-unit>
        <trans-unit id="08ef0643ebf0dc48a599dc8d5b289675edb9e0a3" translate="yes" xml:space="preserve">
          <source>This method is called implicitly when the value goes out of scope, and cannot be called explicitly (this is compiler error &lt;a href=&quot;../../error-index#E0040&quot;&gt;E0040&lt;/a&gt;). However, the &lt;a href=&quot;../mem/fn.drop&quot;&gt;&lt;code&gt;mem::drop&lt;/code&gt;&lt;/a&gt; function in the prelude can be used to call the argument's &lt;code&gt;Drop&lt;/code&gt; implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37d2a8db1a00abc88d21d10b6113bf279aaebd51" translate="yes" xml:space="preserve">
          <source>This method is called implicitly when the value goes out of scope, and cannot be called explicitly (this is compiler error &lt;a href=&quot;../../error-index#E0040&quot;&gt;E0040&lt;/a&gt;). However, the &lt;a href=&quot;../mem/fn.drop&quot;&gt;&lt;code&gt;std::mem::drop&lt;/code&gt;&lt;/a&gt; function in the prelude can be used to call the argument's &lt;code&gt;Drop&lt;/code&gt; implementation.</source>
          <target state="translated">Este m&amp;eacute;todo se llama impl&amp;iacute;citamente cuando el valor sale del alcance y no se puede llamar expl&amp;iacute;citamente (este es el error del compilador &lt;a href=&quot;../../error-index#E0040&quot;&gt;E0040&lt;/a&gt; ). Sin embargo, la funci&amp;oacute;n &lt;a href=&quot;../mem/fn.drop&quot;&gt; &lt;code&gt;std::mem::drop&lt;/code&gt; &lt;/a&gt; en el preludio se puede usar para llamar a la implementaci&amp;oacute;n &lt;code&gt;Drop&lt;/code&gt; del argumento .</target>
        </trans-unit>
        <trans-unit id="0b2c9d3aaaa76ea8e330a8973b644085bc25e3bb" translate="yes" xml:space="preserve">
          <source>This method is carefully constructed to avoid allocation. It will consume the error, moving out the bytes, so that a copy of the bytes does not need to be made.</source>
          <target state="translated">Este método se construye cuidadosamente para evitar la asignación.Consumirá el error,desplazando los bytes,de modo que no sea necesario hacer una copia de los mismos.</target>
        </trans-unit>
        <trans-unit id="ef9d0891851c4c2229a94b62e2e2cf59a2fd15db" translate="yes" xml:space="preserve">
          <source>This method is deprecated in favor of the identically-named inherent methods on &lt;code&gt;u8&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;[u8]&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84886aa1dad1934a5c9bdd981667f36e45fab018" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; except that no runtime assertion is made that &lt;code&gt;v&lt;/code&gt; contains no 0 bytes, and it requires an actual byte vector, not anything that can be converted to one with Into.</source>
          <target state="translated">Este m&amp;eacute;todo es equivalente a &lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; ,&lt;/a&gt; excepto que no se hace ninguna afirmaci&amp;oacute;n en tiempo de ejecuci&amp;oacute;n de que &lt;code&gt;v&lt;/code&gt; no contiene 0 bytes, y requiere un vector de bytes real, no nada que pueda convertirse en uno con Into.</target>
        </trans-unit>
        <trans-unit id="38f2c8e8e67faa398a8a8adc0a46e90cd363606b" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;a href=&quot;struct.cstring#method.new&quot;&gt;&lt;code&gt;CString::new&lt;/code&gt;&lt;/a&gt; except that no runtime assertion is made that &lt;code&gt;v&lt;/code&gt; contains no 0 bytes, and it requires an actual byte vector, not anything that can be converted to one with Into.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0358b021b2254c197a04c16c02e67b7c9901af56" translate="yes" xml:space="preserve">
          <source>This method is essentially a &lt;code&gt;transmute&lt;/code&gt; with respect to the elements in the returned middle slice, so all the usual caveats pertaining to &lt;code&gt;transmute::&amp;lt;T, U&amp;gt;&lt;/code&gt; also apply here.</source>
          <target state="translated">Este m&amp;eacute;todo es esencialmente una &lt;code&gt;transmute&lt;/code&gt; con respecto a los elementos en el segmento intermedio devuelto, por lo que todas las advertencias habituales relativas a &lt;code&gt;transmute::&amp;lt;T, U&amp;gt;&lt;/code&gt; tambi&amp;eacute;n se aplican aqu&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="dd229ccab2f3fea46c41c098065dd891d877a2e6" translate="yes" xml:space="preserve">
          <source>This method is identical to &lt;a href=&quot;struct.builder#method.spawn&quot;&gt;&lt;code&gt;thread::Builder::spawn&lt;/code&gt;&lt;/a&gt;, except for the relaxed lifetime bounds, which render it unsafe. For a more complete documentation see &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;thread::spawn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Este m&amp;eacute;todo es id&amp;eacute;ntico a &lt;a href=&quot;struct.builder#method.spawn&quot;&gt; &lt;code&gt;thread::Builder::spawn&lt;/code&gt; &lt;/a&gt; , excepto por los l&amp;iacute;mites de vida relajados, que lo vuelven inseguro. Para obtener una documentaci&amp;oacute;n m&amp;aacute;s completa, consulte &lt;a href=&quot;fn.spawn&quot;&gt; &lt;code&gt;thread::spawn&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0bc2506b00444cfc62462ac1af4908c0bbe44456" translate="yes" xml:space="preserve">
          <source>This method is implemented using up to three seek operations. If this method returns successfully, the seek position is unchanged (i.e. the position before calling this method is the same as afterwards). However, if this method returns an error, the seek position is unspecified.</source>
          <target state="translated">Este método se aplica utilizando hasta tres operaciones de búsqueda.Si este método vuelve con éxito,la posición de búsqueda no se modifica (es decir,la posición antes de llamar a este método es la misma que después).Sin embargo,si este método devuelve un error,la posición de búsqueda no se especifica.</target>
        </trans-unit>
        <trans-unit id="f531cfc3a2c409d73bd0f5c2e2364c282b1a69bd" translate="yes" xml:space="preserve">
          <source>This method is primarily intended for moving out values in drop. Instead of using &lt;a href=&quot;#method.drop&quot;&gt;&lt;code&gt;ManuallyDrop::drop&lt;/code&gt;&lt;/a&gt; to manually drop the value, you can use this method to take the value and use it however desired. &lt;code&gt;Drop&lt;/code&gt; will be invoked on the returned value following normal end-of-scope rules.</source>
          <target state="translated">Este m&amp;eacute;todo est&amp;aacute; dise&amp;ntilde;ado principalmente para mover valores en la gota. En lugar de usar &lt;a href=&quot;#method.drop&quot;&gt; &lt;code&gt;ManuallyDrop::drop&lt;/code&gt; &lt;/a&gt; para eliminar manualmente el valor, puede usar este m&amp;eacute;todo para tomar el valor y usarlo como desee. &lt;code&gt;Drop&lt;/code&gt; se invocar&amp;aacute; en el valor devuelto siguiendo las reglas normales de fin de alcance.</target>
        </trans-unit>
        <trans-unit id="ff2d30c02e4e3426a2eb2e0e84eb302b53b0327c" translate="yes" xml:space="preserve">
          <source>This method is primarily intended for moving out values in drop. Instead of using &lt;a href=&quot;struct.manuallydrop#method.drop&quot;&gt;&lt;code&gt;ManuallyDrop::drop&lt;/code&gt;&lt;/a&gt; to manually drop the value, you can use this method to take the value and use it however desired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="923fe0c4f9dba0ad8dc8e37a00ed66b6a9da0759" translate="yes" xml:space="preserve">
          <source>This method is primarily used to interface with the &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; macro, but it is rare that this should explicitly be called. The &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt; macro should be favored to invoke this method instead.</source>
          <target state="translated">&amp;iexcl;Este m&amp;eacute;todo se utiliza principalmente para interactuar con &lt;a href=&quot;../macro.format_args&quot;&gt; &lt;code&gt;format_args!&lt;/code&gt; &lt;/a&gt;macro, pero es raro que se deba llamar expl&amp;iacute;citamente. &amp;iexcl;La &lt;a href=&quot;../macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt;macro deber&amp;iacute;a ser favorecido para invocar este m&amp;eacute;todo en su lugar.</target>
        </trans-unit>
        <trans-unit id="80fc60d5306ac7d19519f64033eaf35397e48023" translate="yes" xml:space="preserve">
          <source>This method is soft-deprecated. &lt;a href=&quot;../../error/trait.error#method.description&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Este m&amp;eacute;todo est&amp;aacute; obsoleto. &lt;a href=&quot;../../error/trait.error#method.description&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7e4625fa8bf128959917fb79c2180bb0bb7de232" translate="yes" xml:space="preserve">
          <source>This method is soft-deprecated. &lt;a href=&quot;../error/trait.error#method.description&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Este m&amp;eacute;todo est&amp;aacute; obsoleto. &lt;a href=&quot;../error/trait.error#method.description&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6a9beb6c54e6c8b198cf2df220314195725bd7bb" translate="yes" xml:space="preserve">
          <source>This method is soft-deprecated. &lt;a href=&quot;error/trait.error#method.description&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Este m&amp;eacute;todo est&amp;aacute; obsoleto. &lt;a href=&quot;error/trait.error#method.description&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5490d12dcf25f9008acb9584a8ddf0c95e1664f2" translate="yes" xml:space="preserve">
          <source>This method is stable and usable, but it should be unsafe. To fix that, it got deprecated in favor of the unsafe &lt;a href=&quot;#tymethod.pre_exec&quot;&gt;&lt;code&gt;pre_exec&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Este m&amp;eacute;todo es estable y utilizable, pero no deber&amp;iacute;a ser seguro. Para solucionarlo, qued&amp;oacute; obsoleto en favor del inseguro &lt;a href=&quot;#tymethod.pre_exec&quot;&gt; &lt;code&gt;pre_exec&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a040da9f6f49ab3965186c9b54eab70d6aecfa7" translate="yes" xml:space="preserve">
          <source>This method is stable and usable, but it should be unsafe. To fix that, it got deprecated in favor of the unsafe &lt;a href=&quot;trait.commandext#tymethod.pre_exec&quot;&gt;&lt;code&gt;pre_exec&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="428465480a8425bf96628f818ad9aad9c7155318" translate="yes" xml:space="preserve">
          <source>This method is the const generic equivalent of &lt;a href=&quot;#method.chunks_exact&quot;&gt;&lt;code&gt;chunks_exact&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5d24cf3a26d22530ab9cc10e498dc43f87c776a" translate="yes" xml:space="preserve">
          <source>This method is the const generic equivalent of &lt;a href=&quot;#method.chunks_exact_mut&quot;&gt;&lt;code&gt;chunks_exact_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="881a668b22b8af1fbfcb4abff65037dd8a73fd44" translate="yes" xml:space="preserve">
          <source>This method is unsafe because a &lt;code&gt;Read&lt;/code&gt;er could otherwise return a non-zeroing &lt;code&gt;Initializer&lt;/code&gt; from another &lt;code&gt;Read&lt;/code&gt; type without an &lt;code&gt;unsafe&lt;/code&gt; block.</source>
          <target state="translated">Este m&amp;eacute;todo no es seguro porque un &lt;code&gt;Read&lt;/code&gt; er contrario podr&amp;iacute;an devolver un no-cero &lt;code&gt;Initializer&lt;/code&gt; de otro &lt;code&gt;Read&lt;/code&gt; tipo sin una &lt;code&gt;unsafe&lt;/code&gt; bloque.</target>
        </trans-unit>
        <trans-unit id="272d98e018b9a74f9a82d093db1b7d2de5f94a24" translate="yes" xml:space="preserve">
          <source>This method is useful when doing multiple calls to functions that consume the pinned type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b649b72cfd66bc53cdd1236dc499f467fbbbfc65" translate="yes" xml:space="preserve">
          <source>This method requires &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; to be able clone the passed value. If you need more flexibility (or want to rely on &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;), use &lt;a href=&quot;#method.resize_with&quot;&gt;&lt;code&gt;resize_with&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Este m&amp;eacute;todo requiere &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; para poder clonar el valor pasado. Si necesita m&amp;aacute;s flexibilidad (o desea confiar en &lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; en&lt;/a&gt; lugar de &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; ), use &lt;a href=&quot;#method.resize_with&quot;&gt; &lt;code&gt;resize_with&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fe86d6b287ee66b5bfe82d8d97c6de5a30a28fea" translate="yes" xml:space="preserve">
          <source>This method requires &lt;code&gt;T&lt;/code&gt; to implement &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, in order to be able to clone the passed value. If you need more flexibility (or want to rely on &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;), use &lt;a href=&quot;struct.vec#method.resize_with&quot;&gt;&lt;code&gt;Vec::resize_with&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9a3bfc3f1c3963b065d50d6828d4da511aead6e" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if slice does not end with &lt;code&gt;suffix&lt;/code&gt;. Also it returns the original slice if &lt;code&gt;suffix&lt;/code&gt; is an empty slice</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b59bebec2345a5a01479f3be93783390bba5fe3b" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if slice does not start with &lt;code&gt;prefix&lt;/code&gt;. Also it returns the original slice if &lt;code&gt;prefix&lt;/code&gt; is an empty slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b95f081db21ce8cf4e6f46e10880425784f2765c" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;../primitive.bool&quot;&gt;&lt;code&gt;true&lt;/code&gt;&lt;/a&gt; for addresses in the range reserved by [RFC 4291 section 2.4], i.e. addresses with the following format:</source>
          <target state="translated">Este m&amp;eacute;todo devuelve &lt;a href=&quot;../primitive.bool&quot;&gt; &lt;code&gt;true&lt;/code&gt; &lt;/a&gt; para direcciones en el rango reservado por [RFC 4291 secci&amp;oacute;n 2.4], es decir, direcciones con el siguiente formato:</target>
        </trans-unit>
        <trans-unit id="14217d50c79e4eb45c163835b69cd4e673a45e20" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;../primitive.bool&quot;&gt;&lt;code&gt;true&lt;/code&gt;&lt;/a&gt; for site-local addresses as per &lt;a href=&quot;https://tools.ietf.org/html/rfc4291#section-2.5.7&quot;&gt;RFC 4291 section 2.5.7&lt;/a&gt;</source>
          <target state="translated">Este m&amp;eacute;todo devuelve &lt;a href=&quot;../primitive.bool&quot;&gt; &lt;code&gt;true&lt;/code&gt; &lt;/a&gt; para las direcciones locales del sitio seg&amp;uacute;n la &lt;a href=&quot;https://tools.ietf.org/html/rfc4291#section-2.5.7&quot;&gt;secci&amp;oacute;n 2.5.7 de RFC 4291&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c067946f55e22970a3dc70591f782f7bfd3be70c" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt;&lt;code&gt;true&lt;/code&gt;&lt;/a&gt; for addresses in the range reserved by [RFC 4291 section 2.4], i.e. addresses with the following format:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ac7dcf5283432feb1c671ca5dfa7bc7104e0a1d" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt;&lt;code&gt;true&lt;/code&gt;&lt;/a&gt; for site-local addresses as per &lt;a href=&quot;https://tools.ietf.org/html/rfc4291#section-2.5.7&quot;&gt;RFC 4291 section 2.5.7&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48c542fa498c19ba50cecb51c023284b67bf89ad" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if slice does not end with &lt;code&gt;suffix&lt;/code&gt;. Also it returns the original slice if &lt;code&gt;suffix&lt;/code&gt; is an empty slice</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da5bb928bae82aca5b2fc0bf565da6017cb0d4d8" translate="yes" xml:space="preserve">
          <source>This method returns &lt;a href=&quot;option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if slice does not start with &lt;code&gt;prefix&lt;/code&gt;. Also it returns the original slice if &lt;code&gt;prefix&lt;/code&gt; is an empty slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8678f0273a7a7e566a6f4ee8c92fbd30439ee626" translate="yes" xml:space="preserve">
          <source>This method returns &lt;code&gt;Ok(())&lt;/code&gt; if the cell was empty and &lt;code&gt;Err(value)&lt;/code&gt; if it was full.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fe438568aa64ab40ad3ae63a4e80c06e5f2d121" translate="yes" xml:space="preserve">
          <source>This method returns &lt;code&gt;true&lt;/code&gt; after iteration has finished:</source>
          <target state="translated">Este m&amp;eacute;todo devuelve &lt;code&gt;true&lt;/code&gt; finalizada la iteraci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="a10727aefe2c0619a67b5c808cec5f4b8a1e7af5" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;a href=&quot;../../cmp/enum.ordering&quot;&gt;&lt;code&gt;Ordering&lt;/code&gt;&lt;/a&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;../../cmp/trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="553b97aa02f0558b1b0de2b63742a555e1d788b0" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;a href=&quot;../cmp/enum.ordering&quot;&gt;&lt;code&gt;Ordering&lt;/code&gt;&lt;/a&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;../cmp/trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fe70a42b371f1df3da8be36396abdc2eaf19453" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;a href=&quot;cmp/enum.ordering&quot;&gt;&lt;code&gt;Ordering&lt;/code&gt;&lt;/a&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;cmp/trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36badfc81f37e8dd9893bdb06702e1f5b7aef202" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;a href=&quot;enum.ordering&quot;&gt;&lt;code&gt;Ordering&lt;/code&gt;&lt;/a&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c319c899ab4990e562735b3d21d0f6cd464c7156" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;a href=&quot;enum.ordering&quot;&gt;&lt;code&gt;Ordering&lt;/code&gt;&lt;/a&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da8759d1633206733343524980d7a489afd16956" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;code&gt;Ordering&lt;/code&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">Este m&amp;eacute;todo devuelve un &lt;code&gt;Ordering&lt;/code&gt; entre &lt;code&gt;self&lt;/code&gt; y el &lt;code&gt;other&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f3bbc3554d60688630609ad13846c405e876fac" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;code&gt;Ordering&lt;/code&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;../../cmp/trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Este m&amp;eacute;todo devuelve un &lt;code&gt;Ordering&lt;/code&gt; entre &lt;code&gt;self&lt;/code&gt; y el &lt;code&gt;other&lt;/code&gt; . &lt;a href=&quot;../../cmp/trait.ord#tymethod.cmp&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e875552f6e4025920ca5a71d7c281b1fbfaaa2a8" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;code&gt;Ordering&lt;/code&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;../cmp/trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Este m&amp;eacute;todo devuelve un &lt;code&gt;Ordering&lt;/code&gt; entre &lt;code&gt;self&lt;/code&gt; y el &lt;code&gt;other&lt;/code&gt; . &lt;a href=&quot;../cmp/trait.ord#tymethod.cmp&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="400399c6db28cb18bc3db2944eff105cd4fca3da" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;code&gt;Ordering&lt;/code&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;cmp/trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Este m&amp;eacute;todo devuelve un &lt;code&gt;Ordering&lt;/code&gt; entre &lt;code&gt;self&lt;/code&gt; y el &lt;code&gt;other&lt;/code&gt; . &lt;a href=&quot;cmp/trait.ord#tymethod.cmp&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1a47b24f63b5fe410c6da12441f9c98d2fe17c15" translate="yes" xml:space="preserve">
          <source>This method returns an &lt;code&gt;Ordering&lt;/code&gt; between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. &lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Este m&amp;eacute;todo devuelve un &lt;code&gt;Ordering&lt;/code&gt; entre &lt;code&gt;self&lt;/code&gt; y el &lt;code&gt;other&lt;/code&gt; . &lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c3cf087c16e29fe754de64f334036b96fe0b3931" translate="yes" xml:space="preserve">
          <source>This method returns an ordering between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values if one exists.</source>
          <target state="translated">Este m&amp;eacute;todo devuelve un orden entre &lt;code&gt;self&lt;/code&gt; y &lt;code&gt;other&lt;/code&gt; valores, si existe.</target>
        </trans-unit>
        <trans-unit id="eb17b52a796e0693ad06487790fde93b26d1d781" translate="yes" xml:space="preserve">
          <source>This method returns an ordering between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values if one exists. &lt;a href=&quot;../../cmp/trait.partialord#tymethod.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Este m&amp;eacute;todo devuelve un orden entre &lt;code&gt;self&lt;/code&gt; y &lt;code&gt;other&lt;/code&gt; valores, si existe. &lt;a href=&quot;../../cmp/trait.partialord#tymethod.partial_cmp&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="39953b189e90eb45e12641b5213bac17fb6a067f" translate="yes" xml:space="preserve">
          <source>This method returns an ordering between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values if one exists. &lt;a href=&quot;../cmp/trait.partialord#tymethod.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Este m&amp;eacute;todo devuelve un orden entre &lt;code&gt;self&lt;/code&gt; y &lt;code&gt;other&lt;/code&gt; valores, si existe. &lt;a href=&quot;../cmp/trait.partialord#tymethod.partial_cmp&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a426df736d2450e1483768eb842876560c3cb8d7" translate="yes" xml:space="preserve">
          <source>This method returns an ordering between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values if one exists. &lt;a href=&quot;cmp/trait.partialord#tymethod.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Este m&amp;eacute;todo devuelve un orden entre &lt;code&gt;self&lt;/code&gt; y &lt;code&gt;other&lt;/code&gt; valores, si existe. &lt;a href=&quot;cmp/trait.partialord#tymethod.partial_cmp&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d64233d3af8194ec0eefc11c727f80c62d14630a" translate="yes" xml:space="preserve">
          <source>This method returns an ordering between &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values if one exists. &lt;a href=&quot;trait.partialord#tymethod.partial_cmp&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Este m&amp;eacute;todo devuelve un orden entre &lt;code&gt;self&lt;/code&gt; y &lt;code&gt;other&lt;/code&gt; valores, si existe. &lt;a href=&quot;trait.partialord#tymethod.partial_cmp&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="edb583eeb291a512bd3d2447d1fbe080bc3b9dce" translate="yes" xml:space="preserve">
          <source>This method should generally not be invoked manually, but rather through the &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt; macro itself.</source>
          <target state="translated">Este m&amp;eacute;todo generalmente no debe invocarse manualmente, sino a trav&amp;eacute;s de la &lt;a href=&quot;../macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt;macro en s&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="d7174476c42e976c470e5d3d833837447fe7b624" translate="yes" xml:space="preserve">
          <source>This method splits the slice into three distinct slices: prefix, correctly aligned middle slice of a new type, and the suffix slice. The method does a best effort to make the middle slice the greatest length possible for a given type and input slice, but only your algorithm's performance should depend on that, not its correctness.</source>
          <target state="translated">Este método divide la rebanada en tres rebanadas distintas:el prefijo,la rebanada central correctamente alineada de un nuevo tipo,y la rebanada del sufijo.El método se esfuerza por hacer que la rebanada media tenga la mayor longitud posible para un tipo y una rebanada de entrada dados,pero sólo el rendimiento de su algoritmo debe depender de eso,no de su corrección.</target>
        </trans-unit>
        <trans-unit id="a7dca763f7ea1b34a0cad9b954868418d78e506c" translate="yes" xml:space="preserve">
          <source>This method splits the slice into three distinct slices: prefix, correctly aligned middle slice of a new type, and the suffix slice. The method may make the middle slice the greatest length possible for a given type and input slice, but only your algorithm's performance should depend on that, not its correctness. It is permissible for all of the input data to be returned as the prefix or suffix slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8000abb209a936f78ade63de708f2749dd5748c7" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;!=&lt;/code&gt;.</source>
          <target state="translated">Este m&amp;eacute;todo prueba &lt;code&gt;!=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3639f2a22177e5f40d5314d575e638c54018960a" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;.</source>
          <target state="translated">Este m&amp;eacute;todo prueba que los valores &lt;code&gt;self&lt;/code&gt; y de los &lt;code&gt;other&lt;/code&gt; sean iguales, y es utilizado por &lt;code&gt;==&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3ea7ba813a098b9b6ae43b0aee731d0092913bf" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;. &lt;a href=&quot;../../../cmp/trait.partialeq#tymethod.eq&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f00abfa17fbf62bab913260c77c4736307dd6b08" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;. &lt;a href=&quot;../../cmp/trait.partialeq#tymethod.eq&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Este m&amp;eacute;todo prueba que los valores &lt;code&gt;self&lt;/code&gt; y de los &lt;code&gt;other&lt;/code&gt; sean iguales, y es utilizado por &lt;code&gt;==&lt;/code&gt; . &lt;a href=&quot;../../cmp/trait.partialeq#tymethod.eq&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c257c51217cc2c43c24273fbc2f10164037dd5b1" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;. &lt;a href=&quot;../cmp/trait.partialeq#tymethod.eq&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Este m&amp;eacute;todo prueba que los valores &lt;code&gt;self&lt;/code&gt; y de los &lt;code&gt;other&lt;/code&gt; sean iguales, y es utilizado por &lt;code&gt;==&lt;/code&gt; . &lt;a href=&quot;../cmp/trait.partialeq#tymethod.eq&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="34550195d18fa1542599bef9324d74efad99aeb1" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;. &lt;a href=&quot;cmp/trait.partialeq#tymethod.eq&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Este m&amp;eacute;todo prueba que los valores &lt;code&gt;self&lt;/code&gt; y de los &lt;code&gt;other&lt;/code&gt; sean iguales, y es utilizado por &lt;code&gt;==&lt;/code&gt; . &lt;a href=&quot;cmp/trait.partialeq#tymethod.eq&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d32084f8ce776d9a529be0f1da6ec9ca22e44396" translate="yes" xml:space="preserve">
          <source>This method tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;. &lt;a href=&quot;trait.partialeq#tymethod.eq&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Este m&amp;eacute;todo prueba que los valores &lt;code&gt;self&lt;/code&gt; y de los &lt;code&gt;other&lt;/code&gt; sean iguales, y es utilizado por &lt;code&gt;==&lt;/code&gt; . &lt;a href=&quot;trait.partialeq#tymethod.eq&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9893b74b381c1707e88afd0a7ed6401e06b38424" translate="yes" xml:space="preserve">
          <source>This method tests greater than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;&lt;/code&gt; operator.</source>
          <target state="translated">Este m&amp;eacute;todo prueba mayor que (para &lt;code&gt;self&lt;/code&gt; y &lt;code&gt;other&lt;/code&gt; ) y es utilizado por el operador &lt;code&gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9be75e39e05fc52a961a6f8a30bebafa3abc619e" translate="yes" xml:space="preserve">
          <source>This method tests greater than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;&lt;/code&gt; operator. &lt;a href=&quot;../../cmp/trait.partialord#method.gt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Este m&amp;eacute;todo prueba mayor que (para &lt;code&gt;self&lt;/code&gt; y &lt;code&gt;other&lt;/code&gt; ) y es utilizado por el operador &lt;code&gt;&amp;gt;&lt;/code&gt; . &lt;a href=&quot;../../cmp/trait.partialord#method.gt&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8b084733b90b43f4725bbd31294cb1f36404ce0a" translate="yes" xml:space="preserve">
          <source>This method tests greater than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;&lt;/code&gt; operator. &lt;a href=&quot;../cmp/trait.partialord#method.gt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Este m&amp;eacute;todo prueba mayor que (para &lt;code&gt;self&lt;/code&gt; y &lt;code&gt;other&lt;/code&gt; ) y es utilizado por el operador &lt;code&gt;&amp;gt;&lt;/code&gt; . &lt;a href=&quot;../cmp/trait.partialord#method.gt&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="44184bc5bd845c73d3a6bdc521b7927b64cd5369" translate="yes" xml:space="preserve">
          <source>This method tests greater than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;&lt;/code&gt; operator. &lt;a href=&quot;cmp/trait.partialord#method.gt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Este m&amp;eacute;todo prueba mayor que (para &lt;code&gt;self&lt;/code&gt; y &lt;code&gt;other&lt;/code&gt; ) y es utilizado por el operador &lt;code&gt;&amp;gt;&lt;/code&gt; . &lt;a href=&quot;cmp/trait.partialord#method.gt&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8eec657a4246dd487288b986e3d57dfd9657b208" translate="yes" xml:space="preserve">
          <source>This method tests greater than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;&lt;/code&gt; operator. &lt;a href=&quot;trait.partialord#method.gt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Este m&amp;eacute;todo prueba mayor que (para &lt;code&gt;self&lt;/code&gt; y &lt;code&gt;other&lt;/code&gt; ) y es utilizado por el operador &lt;code&gt;&amp;gt;&lt;/code&gt; . &lt;a href=&quot;trait.partialord#method.gt&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0eabc442f100ec2b7e353c049aaaf4ca623d1f2c" translate="yes" xml:space="preserve">
          <source>This method tests greater than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;=&lt;/code&gt; operator.</source>
          <target state="translated">Este m&amp;eacute;todo prueba mayor o igual a (para &lt;code&gt;self&lt;/code&gt; y &lt;code&gt;other&lt;/code&gt; ) y es utilizado por el operador &lt;code&gt;&amp;gt;=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4194eb24934481036250e733ab18937ab48da677" translate="yes" xml:space="preserve">
          <source>This method tests greater than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;=&lt;/code&gt; operator. &lt;a href=&quot;../../cmp/trait.partialord#method.ge&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Este m&amp;eacute;todo prueba mayor o igual a (para &lt;code&gt;self&lt;/code&gt; y &lt;code&gt;other&lt;/code&gt; ) y es utilizado por el operador &lt;code&gt;&amp;gt;=&lt;/code&gt; . &lt;a href=&quot;../../cmp/trait.partialord#method.ge&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="219eec29ea3645fe37ee0a3de43c26a2abe5b61f" translate="yes" xml:space="preserve">
          <source>This method tests greater than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;=&lt;/code&gt; operator. &lt;a href=&quot;../cmp/trait.partialord#method.ge&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Este m&amp;eacute;todo prueba mayor o igual a (para &lt;code&gt;self&lt;/code&gt; y &lt;code&gt;other&lt;/code&gt; ) y es utilizado por el operador &lt;code&gt;&amp;gt;=&lt;/code&gt; . &lt;a href=&quot;../cmp/trait.partialord#method.ge&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a7907168214aeaea1aa4db413b937e0f747bd41c" translate="yes" xml:space="preserve">
          <source>This method tests greater than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;=&lt;/code&gt; operator. &lt;a href=&quot;cmp/trait.partialord#method.ge&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Este m&amp;eacute;todo prueba mayor o igual a (para &lt;code&gt;self&lt;/code&gt; y &lt;code&gt;other&lt;/code&gt; ) y es utilizado por el operador &lt;code&gt;&amp;gt;=&lt;/code&gt; . &lt;a href=&quot;cmp/trait.partialord#method.ge&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e579d59fed2657492555041f61545aa7206f59b6" translate="yes" xml:space="preserve">
          <source>This method tests greater than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;gt;=&lt;/code&gt; operator. &lt;a href=&quot;trait.partialord#method.ge&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Este m&amp;eacute;todo prueba mayor o igual a (para &lt;code&gt;self&lt;/code&gt; y &lt;code&gt;other&lt;/code&gt; ) y es utilizado por el operador &lt;code&gt;&amp;gt;=&lt;/code&gt; . &lt;a href=&quot;trait.partialord#method.ge&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c0e789163efc5086c683b5a1f62c9a3bb50e4538" translate="yes" xml:space="preserve">
          <source>This method tests less than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;&lt;/code&gt; operator.</source>
          <target state="translated">Este m&amp;eacute;todo prueba menos de (para &lt;code&gt;self&lt;/code&gt; y &lt;code&gt;other&lt;/code&gt; ) y lo usa el operador &lt;code&gt;&amp;lt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9a38093c98e8f8478fc7a4cb9a47c1ad908df47" translate="yes" xml:space="preserve">
          <source>This method tests less than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;&lt;/code&gt; operator. &lt;a href=&quot;../../cmp/trait.partialord#method.lt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Este m&amp;eacute;todo prueba menos de (para &lt;code&gt;self&lt;/code&gt; y &lt;code&gt;other&lt;/code&gt; ) y lo usa el operador &lt;code&gt;&amp;lt;&lt;/code&gt; . &lt;a href=&quot;../../cmp/trait.partialord#method.lt&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d167afca39913e71e4062a05ae7a9d99838896ab" translate="yes" xml:space="preserve">
          <source>This method tests less than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;&lt;/code&gt; operator. &lt;a href=&quot;../cmp/trait.partialord#method.lt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Este m&amp;eacute;todo prueba menos de (para &lt;code&gt;self&lt;/code&gt; y &lt;code&gt;other&lt;/code&gt; ) y lo usa el operador &lt;code&gt;&amp;lt;&lt;/code&gt; . &lt;a href=&quot;../cmp/trait.partialord#method.lt&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8ebc7cc22118ac04d1f984d545d5be0d85818a1e" translate="yes" xml:space="preserve">
          <source>This method tests less than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;&lt;/code&gt; operator. &lt;a href=&quot;cmp/trait.partialord#method.lt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Este m&amp;eacute;todo prueba menos de (para &lt;code&gt;self&lt;/code&gt; y &lt;code&gt;other&lt;/code&gt; ) y lo usa el operador &lt;code&gt;&amp;lt;&lt;/code&gt; . &lt;a href=&quot;cmp/trait.partialord#method.lt&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="54945ad3f8cac4a154fb7b9e35518b30ae999d4d" translate="yes" xml:space="preserve">
          <source>This method tests less than (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;&lt;/code&gt; operator. &lt;a href=&quot;trait.partialord#method.lt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Este m&amp;eacute;todo prueba menos de (para &lt;code&gt;self&lt;/code&gt; y &lt;code&gt;other&lt;/code&gt; ) y lo usa el operador &lt;code&gt;&amp;lt;&lt;/code&gt; . &lt;a href=&quot;trait.partialord#method.lt&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d161a6ff3e691349ec054ac0d4002d49a30e7893" translate="yes" xml:space="preserve">
          <source>This method tests less than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;=&lt;/code&gt; operator.</source>
          <target state="translated">Este m&amp;eacute;todo prueba menos de o igual a (para &lt;code&gt;self&lt;/code&gt; y &lt;code&gt;other&lt;/code&gt; ) y es utilizado por el operador &lt;code&gt;&amp;lt;=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aadf89f483a504081f46ca5ef3749d0af43a4387" translate="yes" xml:space="preserve">
          <source>This method tests less than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;=&lt;/code&gt; operator. &lt;a href=&quot;../../cmp/trait.partialord#method.le&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Este m&amp;eacute;todo prueba menos de o igual a (para &lt;code&gt;self&lt;/code&gt; y &lt;code&gt;other&lt;/code&gt; ) y lo usa el operador &lt;code&gt;&amp;lt;=&lt;/code&gt; . &lt;a href=&quot;../../cmp/trait.partialord#method.le&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ddb1ab74197bbadea31b206cbb3f4c8f2c4d9f37" translate="yes" xml:space="preserve">
          <source>This method tests less than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;=&lt;/code&gt; operator. &lt;a href=&quot;../cmp/trait.partialord#method.le&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Este m&amp;eacute;todo prueba menos de o igual a (para &lt;code&gt;self&lt;/code&gt; y &lt;code&gt;other&lt;/code&gt; ) y lo usa el operador &lt;code&gt;&amp;lt;=&lt;/code&gt; . &lt;a href=&quot;../cmp/trait.partialord#method.le&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="db00fc514ef8b2e5769c8d739b13605dcfb91f42" translate="yes" xml:space="preserve">
          <source>This method tests less than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;=&lt;/code&gt; operator. &lt;a href=&quot;cmp/trait.partialord#method.le&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Este m&amp;eacute;todo prueba menos de o igual a (para &lt;code&gt;self&lt;/code&gt; y &lt;code&gt;other&lt;/code&gt; ) y lo usa el operador &lt;code&gt;&amp;lt;=&lt;/code&gt; . &lt;a href=&quot;cmp/trait.partialord#method.le&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bca462ad1eb0c753d442b14b7fe002228f03d1ee" translate="yes" xml:space="preserve">
          <source>This method tests less than or equal to (for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;) and is used by the &lt;code&gt;&amp;lt;=&lt;/code&gt; operator. &lt;a href=&quot;trait.partialord#method.le&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Este m&amp;eacute;todo prueba menos de o igual a (para &lt;code&gt;self&lt;/code&gt; y &lt;code&gt;other&lt;/code&gt; ) y es utilizado por el operador &lt;code&gt;&amp;lt;=&lt;/code&gt; . &lt;a href=&quot;trait.partialord#method.le&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5f2ae443e73d5f88ef06a1d6b529c7d18527f78a" translate="yes" xml:space="preserve">
          <source>This method uses &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; to create new values on every push. If you'd rather &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; a given value, use &lt;a href=&quot;#method.resize&quot;&gt;&lt;code&gt;resize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Este m&amp;eacute;todo usa &lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt; para crear nuevos valores en cada push. Si prefiere &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; un valor dado, use &lt;a href=&quot;#method.resize&quot;&gt; &lt;code&gt;resize&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1dc00be165ac3a4a63601e65e376c360363d264c" translate="yes" xml:space="preserve">
          <source>This method uses &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; to create new values on every push. If you'd rather &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; a given value, use &lt;a href=&quot;struct.vec#method.resize&quot;&gt;&lt;code&gt;resize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5ffc4fb20de54f6e75ded6f37d7e6542ba4dcb3" translate="yes" xml:space="preserve">
          <source>This method uses a closure to create new values on every push. If you'd rather &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; a given value, use &lt;a href=&quot;#method.resize&quot;&gt;&lt;code&gt;resize&lt;/code&gt;&lt;/a&gt;. If you want to use the &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; trait to generate values, you can pass &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;Default::default()&lt;/code&gt;&lt;/a&gt; as the second argument.</source>
          <target state="translated">Este m&amp;eacute;todo usa un cierre para crear nuevos valores en cada empuje. Si prefiere &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; un valor dado, use &lt;a href=&quot;#method.resize&quot;&gt; &lt;code&gt;resize&lt;/code&gt; &lt;/a&gt; . Si desea utilizar el rasgo &lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt; para generar valores, puede pasar &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt; &lt;code&gt;Default::default()&lt;/code&gt; &lt;/a&gt; como segundo argumento.</target>
        </trans-unit>
        <trans-unit id="94cb38be3cc225054f996a63889a25410328f00e" translate="yes" xml:space="preserve">
          <source>This method uses a closure to create new values on every push. If you'd rather &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; a given value, use &lt;a href=&quot;struct.vec#method.resize&quot;&gt;&lt;code&gt;Vec::resize&lt;/code&gt;&lt;/a&gt;. If you want to use the &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; trait to generate values, you can pass &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;Default::default&lt;/code&gt;&lt;/a&gt; as the second argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e8aba760b1e58965c26c5247df8d78a97a2b7d9" translate="yes" xml:space="preserve">
          <source>This method validates the format defined in the RFC and won't recognize the following addresses such as &lt;code&gt;fe80:0:0:1::&lt;/code&gt; or &lt;code&gt;fe81::&lt;/code&gt; as unicast link-local addresses for example. If you need a less strict validation use &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local&quot;&gt;&lt;code&gt;Ipv6Addr::is_unicast_link_local()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57f44223f055f4bc85ef6eebc9a26838b98e07df" translate="yes" xml:space="preserve">
          <source>This method validates the format defined in the RFC and won't recognize the following addresses such as &lt;code&gt;fe80:0:0:1::&lt;/code&gt; or &lt;code&gt;fe81::&lt;/code&gt; as unicast link-local addresses for example. If you need a less strict validation use &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local&quot;&gt;&lt;code&gt;is_unicast_link_local()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Este m&amp;eacute;todo valida el formato definido en el RFC y no reconocer&amp;aacute; las siguientes direcciones como &lt;code&gt;fe80:0:0:1::&lt;/code&gt; o &lt;code&gt;fe81::&lt;/code&gt; como direcciones de enlace local de unidifusi&amp;oacute;n, por ejemplo. Si necesita una validaci&amp;oacute;n menos estricta, utilice &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local&quot;&gt; &lt;code&gt;is_unicast_link_local()&lt;/code&gt; &lt;/a&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="34a9aeb12096c73821e3d3f2146e3bcd68d312a7" translate="yes" xml:space="preserve">
          <source>This method will be deprecated in favor of the identically-named inherent methods on &lt;code&gt;u8&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;[u8]&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Este m&amp;eacute;todo quedar&amp;aacute; obsoleto a favor de los m&amp;eacute;todos inherentes con nombres id&amp;eacute;nticos en &lt;code&gt;u8&lt;/code&gt; , &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;[u8]&lt;/code&gt; y &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="71c3fa499cb951e39a31bf79d7f47ca94405dd75" translate="yes" xml:space="preserve">
          <source>This method will be removed soon.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dab63bf4ac92d7a8265610c22503839aea1e5938" translate="yes" xml:space="preserve">
          <source>This method will block the calling thread if another initialization routine is currently running.</source>
          <target state="translated">Este método bloqueará el hilo de llamada si se está ejecutando otra rutina de inicialización.</target>
        </trans-unit>
        <trans-unit id="fd65ab04cca83f42050b2936debdcfa64855e2e3" translate="yes" xml:space="preserve">
          <source>This method will call &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; repeatedly until &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is encountered, returning the number of times it saw &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;. Note that &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; has to be called at least once even if the iterator does not have any elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dcd7df93995d5669f9a19d9090b19b5d2473592" translate="yes" xml:space="preserve">
          <source>This method will continuously call &lt;a href=&quot;#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; until there is no more data to be written or an error of non-&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind is returned. This method will not return until the entire buffer has been successfully written or such an error occurs. The first error that is not of &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind generated from this method will be returned.</source>
          <target state="translated">Este m&amp;eacute;todo llamar&amp;aacute; continuamente a &lt;a href=&quot;#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; hasta que no haya m&amp;aacute;s datos para escribir o se &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; un error que no sea ErrorKind :: Interrupted . Este m&amp;eacute;todo no regresar&amp;aacute; hasta que todo el b&amp;uacute;fer se haya escrito correctamente o se produzca un error de este tipo. Se &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; primer error que no sea del tipo ErrorKind :: Interrupted generado a partir de este m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="0bf4855a0328106cbe0baa3671aad93298aa630b" translate="yes" xml:space="preserve">
          <source>This method will continuously call &lt;a href=&quot;#tymethod.write_at&quot;&gt;&lt;code&gt;write_at&lt;/code&gt;&lt;/a&gt; until there is no more data to be written or an error of non-&lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind is returned. This method will not return until the entire buffer has been successfully written or such an error occurs. The first error that is not of &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind generated from this method will be returned.</source>
          <target state="translated">Este m&amp;eacute;todo llamar&amp;aacute; continuamente a &lt;a href=&quot;#tymethod.write_at&quot;&gt; &lt;code&gt;write_at&lt;/code&gt; &lt;/a&gt; hasta que no haya m&amp;aacute;s datos para escribir o se &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; un error que no sea ErrorKind :: Interrupted . Este m&amp;eacute;todo no regresar&amp;aacute; hasta que todo el b&amp;uacute;fer se haya escrito correctamente o se produzca un error de este tipo. Se &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; primer error que no sea del tipo ErrorKind :: Interrupted generado a partir de este m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="34bd7dd9f2f6fd228fe4ece502dea492de39f939" translate="yes" xml:space="preserve">
          <source>This method will continuously call &lt;a href=&quot;trait.fileext#tymethod.write_at&quot;&gt;&lt;code&gt;write_at&lt;/code&gt;&lt;/a&gt; until there is no more data to be written or an error of non-&lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind is returned. This method will not return until the entire buffer has been successfully written or such an error occurs. The first error that is not of &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind generated from this method will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59d4273ac7a3ba1d7a87ecc5115120efa61d6d44" translate="yes" xml:space="preserve">
          <source>This method will continuously call &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;&lt;code&gt;write_vectored&lt;/code&gt;&lt;/a&gt; until there is no more data to be written or an error of non-&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind is returned. This method will not return until all buffers have been successfully written or such an error occurs. The first error that is not of &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind generated from this method will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3edbd42d79d3d4c4b13caf2b0a59c3d785c0e55" translate="yes" xml:space="preserve">
          <source>This method will continuously call &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; until there is no more data to be written or an error of non-&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind is returned. This method will not return until the entire buffer has been successfully written or such an error occurs. The first error that is not of &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind generated from this method will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b531b20d0eb83c8a34e8a69001999cab52351ebf" translate="yes" xml:space="preserve">
          <source>This method will currently always return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;, but this may change in future versions.</source>
          <target state="translated">Actualmente, este m&amp;eacute;todo siempre devolver&amp;aacute; &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt; , pero esto puede cambiar en versiones futuras.</target>
        </trans-unit>
        <trans-unit id="f5ce2db6ab8281674bdcae7d5e2f97235788a1d6" translate="yes" xml:space="preserve">
          <source>This method will eagerly skip &lt;code&gt;n&lt;/code&gt; elements by calling &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; up to &lt;code&gt;n&lt;/code&gt; times until &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is encountered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2170c54e7e7e211e3d0e2c65e377ae8bcaea7ac1" translate="yes" xml:space="preserve">
          <source>This method will ensure that any current waiters on the condition variable are awoken. Calls to &lt;code&gt;notify_all()&lt;/code&gt; are not buffered in any way.</source>
          <target state="translated">Este m&amp;eacute;todo asegurar&amp;aacute; que se despierte a todos los camareros actuales en la variable de condici&amp;oacute;n. Las llamadas a &lt;code&gt;notify_all()&lt;/code&gt; no se almacenan en b&amp;uacute;fer de ninguna manera.</target>
        </trans-unit>
        <trans-unit id="149968b75a735130b9e849f252f39d4aeeb3370e" translate="yes" xml:space="preserve">
          <source>This method will evaluate the iterator until it returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. While doing so, it keeps track of the current element. After &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned, &lt;code&gt;last()&lt;/code&gt; will then return the last element it saw.</source>
          <target state="translated">Este m&amp;eacute;todo evaluar&amp;aacute; el iterador hasta que devuelva &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; . Mientras lo hace, realiza un seguimiento del elemento actual. Despu&amp;eacute;s de que se devuelva &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;last()&lt;/code&gt; devolver&amp;aacute; el &amp;uacute;ltimo elemento que vio.</target>
        </trans-unit>
        <trans-unit id="60132e29639954faf0b02a7c1a61ca490fca81f1" translate="yes" xml:space="preserve">
          <source>This method will evaluate the iterator until its &lt;a href=&quot;#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. Once &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is encountered, &lt;code&gt;count()&lt;/code&gt; returns the number of times it called &lt;a href=&quot;#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Este m&amp;eacute;todo evaluar&amp;aacute; el iterador hasta su &lt;a href=&quot;#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; retorno &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; . Una vez que se encuentra &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;count()&lt;/code&gt; devuelve el n&amp;uacute;mero de veces que llam&amp;oacute; a &lt;a href=&quot;#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="430231e1c82b4b198abc958a7fd105f7b17a6eb0" translate="yes" xml:space="preserve">
          <source>This method will fail if the socket is not connected. The &lt;code&gt;connect&lt;/code&gt; method will connect this socket to a remote address.</source>
          <target state="translated">Este m&amp;eacute;todo fallar&amp;aacute; si el enchufe no est&amp;aacute; conectado. La &lt;code&gt;connect&lt;/code&gt; m&amp;eacute;todo conectar este conector a una direcci&amp;oacute;n remota.</target>
        </trans-unit>
        <trans-unit id="99d3a71bbe68b832fc3370a5188434c797f36ae5" translate="yes" xml:space="preserve">
          <source>This method will never block the caller in order to wait for data to become available. Instead, this will always return immediately with a possible option of pending data on the channel.</source>
          <target state="translated">Este método nunca bloqueará a la persona que llama para esperar a que los datos estén disponibles.En cambio,siempre regresará inmediatamente con una posible opción de datos pendientes en el canal.</target>
        </trans-unit>
        <trans-unit id="cbdaac7e9262e1ca34c4fe476a690d8dd791b78c" translate="yes" xml:space="preserve">
          <source>This method will never block the current thread.</source>
          <target state="translated">Este método nunca bloqueará el hilo actual.</target>
        </trans-unit>
        <trans-unit id="46d2c9fdd8f22af9ddb09186941e568038365eb2" translate="yes" xml:space="preserve">
          <source>This method will panic if result is not finite, negative or overflows &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">Este m&amp;eacute;todo entrar&amp;aacute; en p&amp;aacute;nico si el resultado no es finito, negativo o desborda la &lt;code&gt;Duration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="361fc3f209ee1e7f236b4d7adeffb54823eee70f" translate="yes" xml:space="preserve">
          <source>This method will take care to not copy the vector, for efficiency's sake.</source>
          <target state="translated">Este método se encargará de no copiar el vector,por razones de eficiencia.</target>
        </trans-unit>
        <trans-unit id="086f7043b4f8a7fd4a6336d78995f0e85e9d5744" translate="yes" xml:space="preserve">
          <source>This method, together with &lt;code&gt;key&lt;/code&gt;, is an alternative to &lt;code&gt;entry&lt;/code&gt; that can be used when the complete entry isn't known upfront. Prefer the &lt;code&gt;entry&lt;/code&gt; method when it's possible to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e6fca229e267292b225ded4f3ea56dd1917d4dd" translate="yes" xml:space="preserve">
          <source>This method, together with &lt;code&gt;value&lt;/code&gt;, is an alternative to &lt;code&gt;entry&lt;/code&gt; that can be used when the complete entry isn't known upfront. Prefer the &lt;code&gt;entry&lt;/code&gt; method when it's possible to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15bda4a4da4275b96ba5bd1843478dd37908d7e9" translate="yes" xml:space="preserve">
          <source>This module also provides an implementation of thread-local storage for Rust programs. Thread-local storage is a method of storing data into a global variable that each thread in the program will have its own copy of. Threads do not share this data, so accesses do not need to be synchronized.</source>
          <target state="translated">Este módulo también proporciona una implementación de almacenamiento local de hilos para los programas de Rust.El almacenamiento local de hilos es un método para almacenar datos en una variable global de la que cada hilo del programa tendrá su propia copia.Los hilos no comparten estos datos,por lo que los accesos no necesitan ser sincronizados.</target>
        </trans-unit>
        <trans-unit id="a618e47bcd778e6fbdbebc05ca474e36092d34bf" translate="yes" xml:space="preserve">
          <source>This module contains basic methods to manipulate the contents of the local filesystem. All methods in this module represent cross-platform filesystem operations. Extra platform-specific functionality can be found in the extension traits of &lt;code&gt;std::os::$platform&lt;/code&gt;.</source>
          <target state="translated">Este m&amp;oacute;dulo contiene m&amp;eacute;todos b&amp;aacute;sicos para manipular el contenido del sistema de archivos local. Todos los m&amp;eacute;todos de este m&amp;oacute;dulo representan operaciones de sistemas de archivos multiplataforma. Se puede encontrar una funcionalidad adicional espec&amp;iacute;fica de la plataforma en las caracter&amp;iacute;sticas de extensi&amp;oacute;n de &lt;code&gt;std::os::$platform&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="facf45454888eb2d77ede3ccdd2076d5cf487a0e" translate="yes" xml:space="preserve">
          <source>This module contains functions for querying the size and alignment of types, initializing and manipulating memory.</source>
          <target state="translated">Este módulo contiene funciones para consultar el tamaño y la alineación de los tipos,inicializar y manipular la memoria.</target>
        </trans-unit>
        <trans-unit id="2408b577206af618721c013114d9c06e429f800a" translate="yes" xml:space="preserve">
          <source>This module contains functions to inspect various aspects such as environment variables, process arguments, the current directory, and various other important directories.</source>
          <target state="translated">Este módulo contiene funciones para inspeccionar varios aspectos como las variables de entorno,los argumentos de los procesos,el directorio actual y otros directorios importantes.</target>
        </trans-unit>
        <trans-unit id="493f5d09dd437f62e48924cee92d925e5c7d2ef1" translate="yes" xml:space="preserve">
          <source>This module contains the &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; type, a trait for converting &lt;a href=&quot;trait.tostring&quot;&gt;&lt;code&gt;ToString&lt;/code&gt;&lt;/a&gt;s, and several error types that may result from working with &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">Este m&amp;oacute;dulo contiene el tipo &lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; , un rasgo para convertir &lt;a href=&quot;trait.tostring&quot;&gt; &lt;code&gt;ToString&lt;/code&gt; &lt;/a&gt; s, y varios tipos de errores que pueden resultar de trabajar con &lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; s.</target>
        </trans-unit>
        <trans-unit id="0a09e5de88124067a8f4a272146af1f58ce6f16e" translate="yes" xml:space="preserve">
          <source>This module contains the &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; type, the &lt;a href=&quot;trait.tostring&quot;&gt;&lt;code&gt;ToString&lt;/code&gt;&lt;/a&gt; trait for converting to strings, and several error types that may result from working with &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a15bad5d969fcb97693f6f0bc38018fba7343164" translate="yes" xml:space="preserve">
          <source>This module contains the runtime support for the &lt;a href=&quot;../macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt; syntax extension. This macro is implemented in the compiler to emit calls to this module in order to format arguments at runtime into strings.</source>
          <target state="translated">&amp;iexcl;Este m&amp;oacute;dulo contiene el soporte de tiempo de ejecuci&amp;oacute;n para el &lt;a href=&quot;../macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt;extensi&amp;oacute;n de sintaxis. Esta macro se implementa en el compilador para emitir llamadas a este m&amp;oacute;dulo con el fin de formatear argumentos en tiempo de ejecuci&amp;oacute;n en cadenas.</target>
        </trans-unit>
        <trans-unit id="12f15aefb562d878bda21e27716658fa02862f93" translate="yes" xml:space="preserve">
          <source>This module contains the support necessary to capture a stack backtrace of a running OS thread from the OS thread itself. The &lt;code&gt;Backtrace&lt;/code&gt; type supports capturing a stack trace via the &lt;code&gt;Backtrace::capture&lt;/code&gt; and &lt;code&gt;Backtrace::force_capture&lt;/code&gt; functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe75678b9da36500f1155d5a63660783d7b96c49" translate="yes" xml:space="preserve">
          <source>This module contains various tools for ordering and comparing values. In summary:</source>
          <target state="translated">Este módulo contiene varias herramientas para ordenar y comparar valores.En resumen:</target>
        </trans-unit>
        <trans-unit id="5526cfdf674b75dda2276399dbf95bab9061f815" translate="yes" xml:space="preserve">
          <source>This module defines atomic versions of a select number of primitive types, including &lt;a href=&quot;struct.atomicbool&quot;&gt;&lt;code&gt;AtomicBool&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.atomicisize&quot;&gt;&lt;code&gt;AtomicIsize&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.atomicusize&quot;&gt;&lt;code&gt;AtomicUsize&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.atomici8&quot;&gt;&lt;code&gt;AtomicI8&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.atomicu16&quot;&gt;&lt;code&gt;AtomicU16&lt;/code&gt;&lt;/a&gt;, etc. Atomic types present operations that, when used correctly, synchronize updates between threads.</source>
          <target state="translated">Este m&amp;oacute;dulo define versiones at&amp;oacute;micas de un n&amp;uacute;mero selecto de tipos primitivos, incluyendo &lt;a href=&quot;struct.atomicbool&quot;&gt; &lt;code&gt;AtomicBool&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.atomicisize&quot;&gt; &lt;code&gt;AtomicIsize&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.atomicusize&quot;&gt; &lt;code&gt;AtomicUsize&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.atomici8&quot;&gt; &lt;code&gt;AtomicI8&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.atomicu16&quot;&gt; &lt;code&gt;AtomicU16&lt;/code&gt; &lt;/a&gt; , etc. Los tipos at&amp;oacute;micos presentan operaciones que, cuando se usan correctamente, sincronizan actualizaciones entre subprocesos.</target>
        </trans-unit>
        <trans-unit id="69b6d67047755d0189ccf8e0dd69886ba1af9f48" translate="yes" xml:space="preserve">
          <source>This module exists for technical reasons, the primary documentation for &lt;code&gt;char&lt;/code&gt; is directly on &lt;a href=&quot;../primitive.char&quot;&gt;the &lt;code&gt;char&lt;/code&gt; primitive type&lt;/a&gt; itself.</source>
          <target state="translated">Este m&amp;oacute;dulo existe por razones t&amp;eacute;cnicas, la documentaci&amp;oacute;n principal para &lt;code&gt;char&lt;/code&gt; est&amp;aacute; directamente en &lt;a href=&quot;../primitive.char&quot;&gt;el tipo primitivo &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0c05c40f88eef085aa06e135cdea7a637a633c60" translate="yes" xml:space="preserve">
          <source>This module implements the &lt;code&gt;Any&lt;/code&gt; trait, which enables dynamic typing of any &lt;code&gt;'static&lt;/code&gt; type through runtime reflection.</source>
          <target state="translated">Este m&amp;oacute;dulo implementa el rasgo &lt;code&gt;Any&lt;/code&gt; , que permite la escritura din&amp;aacute;mica de cualquier tipo &lt;code&gt;'static&lt;/code&gt; trav&amp;eacute;s de la reflexi&amp;oacute;n en tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a2779c978566f8d66cd98dfb5457c45d53a57fb6" translate="yes" xml:space="preserve">
          <source>This module is largely organized by type:</source>
          <target state="translated">Este módulo está organizado en gran medida por tipo:</target>
        </trans-unit>
        <trans-unit id="5be07f93f33ed08d424575dcac18854b8631d380" translate="yes" xml:space="preserve">
          <source>This module is mostly concerned with spawning and interacting with child processes, but it also provides &lt;a href=&quot;fn.abort&quot;&gt;&lt;code&gt;abort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.exit&quot;&gt;&lt;code&gt;exit&lt;/code&gt;&lt;/a&gt; for terminating the current process.</source>
          <target state="translated">Este m&amp;oacute;dulo se ocupa principalmente de la generaci&amp;oacute;n e interacci&amp;oacute;n con procesos secundarios, pero tambi&amp;eacute;n proporciona &lt;a href=&quot;fn.abort&quot;&gt; &lt;code&gt;abort&lt;/code&gt; o&lt;/a&gt; y &lt;a href=&quot;fn.exit&quot;&gt; &lt;code&gt;exit&lt;/code&gt; &lt;/a&gt; para finalizar el proceso actual.</target>
        </trans-unit>
        <trans-unit id="288daae4ba933c2cf1c52332e7aec01da8baaf15" translate="yes" xml:space="preserve">
          <source>This module is the home of the iterator implementations for the iterators implemented on &lt;code&gt;char&lt;/code&gt;, as well as some useful constants and conversion functions that convert various types to &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">Este m&amp;oacute;dulo es el hogar de las implementaciones de iteradores para los iteradores implementados en &lt;code&gt;char&lt;/code&gt; , as&amp;iacute; como algunas constantes &amp;uacute;tiles y funciones de conversi&amp;oacute;n que convierten varios tipos a &lt;code&gt;char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55568ed1c38eacf7d09bc4bc93efa4b457d73318" translate="yes" xml:space="preserve">
          <source>This module only currently provides one bit of information, &lt;a href=&quot;struct.permissions#method.readonly&quot;&gt;&lt;code&gt;Permissions::readonly&lt;/code&gt;&lt;/a&gt;, which is exposed on all currently supported platforms. Unix-specific functionality, such as mode bits, is available through the &lt;a href=&quot;../os/unix/fs/trait.permissionsext&quot;&gt;&lt;code&gt;PermissionsExt&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16223be8f664aa8af7792fdf4f8c15d5b579360d" translate="yes" xml:space="preserve">
          <source>This module only currently provides one bit of information, &lt;a href=&quot;struct.permissions#method.readonly&quot;&gt;&lt;code&gt;readonly&lt;/code&gt;&lt;/a&gt;, which is exposed on all currently supported platforms. Unix-specific functionality, such as mode bits, is available through the &lt;a href=&quot;../os/unix/fs/trait.permissionsext&quot;&gt;&lt;code&gt;PermissionsExt&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">Este m&amp;oacute;dulo solo proporciona actualmente un bit de informaci&amp;oacute;n, de &lt;a href=&quot;struct.permissions#method.readonly&quot;&gt; &lt;code&gt;readonly&lt;/code&gt; &lt;/a&gt; , que se expone en todas las plataformas compatibles actualmente. La funcionalidad espec&amp;iacute;fica de Unix, como los bits de modo, est&amp;aacute; disponible a trav&amp;eacute;s del rasgo &lt;a href=&quot;../os/unix/fs/trait.permissionsext&quot;&gt; &lt;code&gt;PermissionsExt&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="72abc30b878e9efe98c4c560589176b50cfcfb02" translate="yes" xml:space="preserve">
          <source>This module provides a generic way to compute the hash of a value. The simplest way to make a type hashable is to use &lt;code&gt;#[derive(Hash)]&lt;/code&gt;:</source>
          <target state="translated">Este m&amp;oacute;dulo proporciona una forma gen&amp;eacute;rica de calcular el hash de un valor. La forma m&amp;aacute;s sencilla de convertir un tipo en hash es usar &lt;code&gt;#[derive(Hash)]&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8f6357e74fc7527ed8e55102f82ccb8843f20d51" translate="yes" xml:space="preserve">
          <source>This module provides constants which are specific to the implementation of the &lt;code&gt;f32&lt;/code&gt; floating point data type.</source>
          <target state="translated">Este m&amp;oacute;dulo proporciona constantes que son espec&amp;iacute;ficas para la implementaci&amp;oacute;n del tipo de datos de coma flotante &lt;code&gt;f32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87f0d2ad3a049e2ea757e82944e2e6b1d2f310c4" translate="yes" xml:space="preserve">
          <source>This module provides constants which are specific to the implementation of the &lt;code&gt;f64&lt;/code&gt; floating point data type.</source>
          <target state="translated">Este m&amp;oacute;dulo proporciona constantes que son espec&amp;iacute;ficas para la implementaci&amp;oacute;n del tipo de datos de punto flotante &lt;code&gt;f64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4dd1d432064e6f3e28ac8c1d81caf06446f388ba" translate="yes" xml:space="preserve">
          <source>This module provides message-based communication over channels, concretely defined among three types:</source>
          <target state="translated">Este módulo proporciona una comunicación basada en mensajes a través de canales,definidos concretamente entre tres tipos:</target>
        </trans-unit>
        <trans-unit id="bfedf6f4f14d905a894526b273dfe17f7e7c03dc" translate="yes" xml:space="preserve">
          <source>This module provides networking functionality for the Transmission Control and User Datagram Protocols, as well as types for IP and socket addresses.</source>
          <target state="translated">Este módulo proporciona una funcionalidad de red para los protocolos de control de transmisión y de datagramas de usuario,así como tipos para direcciones IP y de socket.</target>
        </trans-unit>
        <trans-unit id="fcfa8dfe7aed9682173752b15b6103829ea655a1" translate="yes" xml:space="preserve">
          <source>This module provides some extra types that are useful when doing numerical work. See the individual documentation for each piece for more information.</source>
          <target state="translated">Este módulo proporciona algunos tipos adicionales que son útiles cuando se hace trabajo numérico.Consulte la documentación individual de cada pieza para obtener más información.</target>
        </trans-unit>
        <trans-unit id="b42dc453d74574a22f838766ed6a6210b7719f9b" translate="yes" xml:space="preserve">
          <source>This module provides two types, &lt;a href=&quot;struct.pathbuf&quot;&gt;&lt;code&gt;PathBuf&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; (akin to &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;), for working with paths abstractly. These types are thin wrappers around &lt;a href=&quot;../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; respectively, meaning that they work directly on strings according to the local platform's path syntax.</source>
          <target state="translated">Este m&amp;oacute;dulo proporciona dos tipos, &lt;a href=&quot;struct.pathbuf&quot;&gt; &lt;code&gt;PathBuf&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; (similar a &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; ), para trabajar con rutas de forma abstracta. Estos tipos son envoltorios delgados alrededor de &lt;a href=&quot;../ffi/struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt; respectivamente, lo que significa que funcionan directamente en cadenas de acuerdo con la sintaxis de ruta de la plataforma local.</target>
        </trans-unit>
        <trans-unit id="a9add5ffa74ddef61504588ae8fe02f3fc02034e" translate="yes" xml:space="preserve">
          <source>This module provides two types, &lt;a href=&quot;struct.pathbuf&quot;&gt;&lt;code&gt;PathBuf&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; (akin to &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;), for working with paths abstractly. These types are thin wrappers around &lt;a href=&quot;../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; respectively, meaning that they work directly on strings according to the local platform's path syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2fe72f6bcf1faf654e10546253a992773369d18" translate="yes" xml:space="preserve">
          <source>This module provides utilities to handle data across non-Rust interfaces, like other programming languages and the underlying operating system. It is mainly of use for FFI (Foreign Function Interface) bindings and code that needs to exchange C-like strings with other languages.</source>
          <target state="translated">Este módulo proporciona utilidades para manejar datos a través de interfaces no oxidadas,como otros lenguajes de programación y el sistema operativo subyacente.Se utiliza principalmente para los enlaces FFI (Foreign Function Interface)y el código que necesita intercambiar cadenas de tipo C con otros lenguajes.</target>
        </trans-unit>
        <trans-unit id="523a58a1796e44e7bd8c46d95ef23447cedfbc5f" translate="yes" xml:space="preserve">
          <source>This module reexports the primitive types to allow usage that is not possibly shadowed by other declared types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bfbd1c67f1485adce8aa9ca96b08fda6c8d21af" translate="yes" xml:space="preserve">
          <source>This mutex will block threads waiting for the lock to become available. The mutex can also be statically initialized or created via a &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; constructor. Each mutex has a type parameter which represents the data that it is protecting. The data can only be accessed through the RAII guards returned from &lt;a href=&quot;#method.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt;, which guarantees that the data is only ever accessed when the mutex is locked.</source>
          <target state="translated">Este mutex bloquear&amp;aacute; los subprocesos en espera de que el bloqueo est&amp;eacute; disponible. El mutex tambi&amp;eacute;n puede inicializarse est&amp;aacute;ticamente o crearse mediante un &lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; constructor. Cada mutex tiene un par&amp;aacute;metro de tipo que representa los datos que est&amp;aacute; protegiendo. Solo se puede acceder a los datos a trav&amp;eacute;s de los guardias RAII devueltos por &lt;a href=&quot;#method.lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#method.try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; &lt;/a&gt; , lo que garantiza que solo se accede a los datos cuando el mutex est&amp;aacute; bloqueado.</target>
        </trans-unit>
        <trans-unit id="37c35fdf98665e8061d3ede706452fcafbf6bf45" translate="yes" xml:space="preserve">
          <source>This mutex will block threads waiting for the lock to become available. The mutex can also be statically initialized or created via a &lt;a href=&quot;struct.mutex#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; constructor. Each mutex has a type parameter which represents the data that it is protecting. The data can only be accessed through the RAII guards returned from &lt;a href=&quot;struct.mutex#method.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.mutex#method.try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt;, which guarantees that the data is only ever accessed when the mutex is locked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6bb4ef8774a69f40318879a20a2f5485ae10af2" translate="yes" xml:space="preserve">
          <source>This never needs to re-allocate, but does need to do &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) data movement if the circular buffer doesn't happen to be at the beginning of the allocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56f3b065f3863bd74d78c00a2522270062418669" translate="yes" xml:space="preserve">
          <source>This never needs to re-allocate, but does need to do O(n) data movement if the circular buffer doesn't happen to be at the beginning of the allocation.</source>
          <target state="translated">Esto nunca necesita reasignarse,pero sí necesita hacer un movimiento de datos de O(n)si el búfer circular no se encuentra al principio de la asignación.</target>
        </trans-unit>
        <trans-unit id="d28b87d734ed0d5315fcb74f17b2994ec84a38d2" translate="yes" xml:space="preserve">
          <source>This new slice goes from &lt;code&gt;begin&lt;/code&gt; to &lt;code&gt;end&lt;/code&gt;, including &lt;code&gt;begin&lt;/code&gt; but excluding &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="translated">Este nuevo segmento va de &lt;code&gt;begin&lt;/code&gt; a &lt;code&gt;end&lt;/code&gt; , incluido el &lt;code&gt;begin&lt;/code&gt; pero excluyendo el &lt;code&gt;end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5e5d3eaf75778ffc4640687e8cefa2e10e75497" translate="yes" xml:space="preserve">
          <source>This next example calls a supertrait method on a generic parameter.</source>
          <target state="translated">El siguiente ejemplo llama a un método de supertratos sobre un parámetro genérico.</target>
        </trans-unit>
        <trans-unit id="9f7ad17f03d80b97ecff41fe1815f8dca0918d1f" translate="yes" xml:space="preserve">
          <source>This next example gives &lt;code&gt;radius&lt;/code&gt; a default implementation using the &lt;code&gt;area&lt;/code&gt; function from &lt;code&gt;Shape&lt;/code&gt;.</source>
          <target state="translated">El siguiente ejemplo le da a &lt;code&gt;radius&lt;/code&gt; una implementaci&amp;oacute;n predeterminada usando la funci&amp;oacute;n de &lt;code&gt;area&lt;/code&gt; de &lt;code&gt;Shape&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50d4d7072a1ea5b824d1df9626f273fc9c52a75a" translate="yes" xml:space="preserve">
          <source>This number is a lower bound; the &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; might be able to hold more, but is guaranteed to be able to hold at least this many.</source>
          <target state="translated">Este n&amp;uacute;mero es un l&amp;iacute;mite inferior; el &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; podr&amp;iacute;a contener m&amp;aacute;s, pero se garantiza que podr&amp;aacute; contener al menos esta cantidad.</target>
        </trans-unit>
        <trans-unit id="75625b78a6cc53054a38dc48c604ece0622bfe30" translate="yes" xml:space="preserve">
          <source>This number is simply useful for passing to other methods, like &lt;a href=&quot;struct.osstring#method.with_capacity&quot;&gt;&lt;code&gt;OsString::with_capacity&lt;/code&gt;&lt;/a&gt; to avoid reallocations.</source>
          <target state="translated">Este n&amp;uacute;mero es simplemente &amp;uacute;til para pasar a otros m&amp;eacute;todos, como &lt;a href=&quot;struct.osstring#method.with_capacity&quot;&gt; &lt;code&gt;OsString::with_capacity&lt;/code&gt; &lt;/a&gt; para evitar reasignaciones.</target>
        </trans-unit>
        <trans-unit id="1f022d625542e31d83b61a7cfb496898fc698f8a" translate="yes" xml:space="preserve">
          <source>This only differs from the previous &lt;code&gt;impl&lt;/code&gt; in that the parameters &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;MyType&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;code&gt;ForeignTrait2&lt;/code&gt; have been swapped. This example does &lt;em&gt;not&lt;/em&gt; violate the orphan rule; it is permitted.</source>
          <target state="translated">Esto solo difiere de la &lt;code&gt;impl&lt;/code&gt; icaci&amp;oacute;n anterior en que los par&amp;aacute;metros &lt;code&gt;T&lt;/code&gt; y &lt;code&gt;MyType&amp;lt;T&amp;gt;&lt;/code&gt; para &lt;code&gt;ForeignTrait2&lt;/code&gt; han sido intercambiados. Este ejemplo &lt;em&gt;no&lt;/em&gt; viola la regla de los hu&amp;eacute;rfanos; est&amp;aacute; permitido.</target>
        </trans-unit>
        <trans-unit id="1833c0a27c1d09954fa6a057a5eb72b9706f31ec" translate="yes" xml:space="preserve">
          <source>This only includes environment variables explicitly set with &lt;a href=&quot;struct.command#method.env&quot;&gt;&lt;code&gt;Command::env&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.command#method.envs&quot;&gt;&lt;code&gt;Command::envs&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;struct.command#method.env_remove&quot;&gt;&lt;code&gt;Command::env_remove&lt;/code&gt;&lt;/a&gt;. It does not include environment variables that will be inherited by the child process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="123296246acbbeb137b9c0c76f971008749a56bb" translate="yes" xml:space="preserve">
          <source>This operation does &lt;strong&gt;not&lt;/strong&gt; modify the filesystem. To modify the filesystem use the &lt;a href=&quot;fn.set_permissions&quot;&gt;&lt;code&gt;fs::set_permissions&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Esta operaci&amp;oacute;n &lt;strong&gt;no&lt;/strong&gt; modifica el sistema de archivos. Para modificar el sistema de archivos utilice la funci&amp;oacute;n &lt;a href=&quot;fn.set_permissions&quot;&gt; &lt;code&gt;fs::set_permissions&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7036bf2f2a1e56b239ac49dd49a90706f4ff18c2" translate="yes" xml:space="preserve">
          <source>This operation does &lt;strong&gt;not&lt;/strong&gt; modify the filesystem. To modify the filesystem use the &lt;a href=&quot;fn.set_permissions&quot;&gt;&lt;code&gt;set_permissions&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c0bbc4d892938033fbacd4684ea2a287c924f8c" translate="yes" xml:space="preserve">
          <source>This operation is &lt;code&gt;O(1)&lt;/code&gt;.</source>
          <target state="translated">Esta operaci&amp;oacute;n es &lt;code&gt;O(1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd1a487434fc87832e2f1a787954854ff60dfa9b" translate="yes" xml:space="preserve">
          <source>This operation is &lt;em&gt;O&lt;/em&gt;(1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fdec81639aa08f036b813714ac253cba45f17ed" translate="yes" xml:space="preserve">
          <source>This operation is sometimes called 'reduce' or 'inject'.</source>
          <target state="translated">Esta operación se llama a veces &quot;reducir&quot; o &quot;inyectar&quot;.</target>
        </trans-unit>
        <trans-unit id="c8451edf8bf7bc5bb1bf0555fcc9a5705a25da14" translate="yes" xml:space="preserve">
          <source>This operation performs an unconditional mapping without tailoring. That is, the conversion is independent of context and language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2fd1d86e77ef341cc160d32009392653fd89ec1" translate="yes" xml:space="preserve">
          <source>This operation rounds towards zero, truncating any fractional part of the exact result.</source>
          <target state="translated">Esta operación se redondea hacia el cero,truncando cualquier parte fraccionaria del resultado exacto.</target>
        </trans-unit>
        <trans-unit id="77029037758bda804fd792f27ba1f29cea457a7e" translate="yes" xml:space="preserve">
          <source>This operation satisfies &lt;code&gt;n % d == n - (n / d) * d&lt;/code&gt;. The result has the same sign as the left operand.</source>
          <target state="translated">Esta operaci&amp;oacute;n satisface &lt;code&gt;n % d == n - (n / d) * d&lt;/code&gt; . El resultado tiene el mismo signo que el operando izquierdo.</target>
        </trans-unit>
        <trans-unit id="bdbe7ca28eb7e43951e771605b8bd474b48c29e7" translate="yes" xml:space="preserve">
          <source>This operation should compute in &lt;em&gt;O&lt;/em&gt;(1) time and &lt;em&gt;O&lt;/em&gt;(1) memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43df87c6439b0a85582f9e67d3c1fce146118f3d" translate="yes" xml:space="preserve">
          <source>This operation should compute in &lt;em&gt;O&lt;/em&gt;(1) time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d494ef70142bea4ddf2b4f6d9f09545f47dd54e" translate="yes" xml:space="preserve">
          <source>This operation should compute in &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48c9bdd59dbbaca42da37bc9d33eec68b2af8961" translate="yes" xml:space="preserve">
          <source>This operation should compute in O(1) time and O(1) memory.</source>
          <target state="translated">Esta operación debe calcularse en tiempo O(1)y en memoria O(1).</target>
        </trans-unit>
        <trans-unit id="fc7c0f50f52c35ea7e364b7e26d103277ce95b38" translate="yes" xml:space="preserve">
          <source>This operation should compute in O(1) time.</source>
          <target state="translated">Esta operación debe calcularse en tiempo O(1).</target>
        </trans-unit>
        <trans-unit id="a13a41f53da524732e21aa1da4b3958def62f00f" translate="yes" xml:space="preserve">
          <source>This operation should compute in O(n) time.</source>
          <target state="translated">Esta operación debe calcularse en tiempo O(n).</target>
        </trans-unit>
        <trans-unit id="4da5d428cc5f4bb1f1eadb7b45f2669f2c6be87e" translate="yes" xml:space="preserve">
          <source>This operation was interrupted.</source>
          <target state="translated">Esta operación fue interrumpida.</target>
        </trans-unit>
        <trans-unit id="e5b25bf34db3082fbebf881dd2f3b63132ce24a9" translate="yes" xml:space="preserve">
          <source>This operation wraps around on overflow.</source>
          <target state="translated">Esta operación se envuelve en el desbordamiento.</target>
        </trans-unit>
        <trans-unit id="513292ffc7d15c4c6459299bf349f4e8ef41bcc6" translate="yes" xml:space="preserve">
          <source>This option defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Esta opci&amp;oacute;n tiene el valor predeterminado de &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07732c105324f285891b421be7b1897cf45eb1a8" translate="yes" xml:space="preserve">
          <source>This option indicates whether a new file will be created if the file does not yet already exist.</source>
          <target state="translated">Esta opción indica si se creará un nuevo archivo si el archivo no existe todavía.</target>
        </trans-unit>
        <trans-unit id="2ab719a36168121ae6911773d2659e3887ae7b87" translate="yes" xml:space="preserve">
          <source>This option indicates whether a new file will be created. No file is allowed to exist at the target location, also no (dangling) symlink.</source>
          <target state="translated">Esta opción indica si se creará un nuevo archivo.No se permite la existencia de ningún archivo en la ubicación de destino,ni tampoco ningún enlace simbólico (colgante).</target>
        </trans-unit>
        <trans-unit id="1997355865e9c95bba24957f07adb48aa7900b34" translate="yes" xml:space="preserve">
          <source>This option is useful because it is atomic. Otherwise between checking whether a file exists and creating a new one, the file may have been created by another process (a TOCTOU race condition / attack).</source>
          <target state="translated">Esta opción es útil porque es atómica.De lo contrario,entre la comprobación de la existencia de un archivo y la creación de uno nuevo,el archivo puede haber sido creado por otro proceso (una condición de carrera TOCTOU/ataque).</target>
        </trans-unit>
        <trans-unit id="4d1d1f446736eda75bb94ad6c4911fc032b1110f" translate="yes" xml:space="preserve">
          <source>This option, when true, means that writes will append to a file instead of overwriting previous contents. Note that setting &lt;code&gt;.write(true).append(true)&lt;/code&gt; has the same effect as setting only &lt;code&gt;.append(true)&lt;/code&gt;.</source>
          <target state="translated">Esta opci&amp;oacute;n, cuando es verdadera, significa que las escrituras se agregar&amp;aacute;n a un archivo en lugar de sobrescribir el contenido anterior. Tenga en cuenta que configurar &lt;code&gt;.write(true).append(true)&lt;/code&gt; tiene el mismo efecto que configurar solo &lt;code&gt;.append(true)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="279fd5d225ffc9cf4a6694f03d2272dc1973056a" translate="yes" xml:space="preserve">
          <source>This option, when true, will indicate that the file should be &lt;code&gt;read&lt;/code&gt;-able if opened.</source>
          <target state="translated">Esta opci&amp;oacute;n, cuando es verdadero, indica que el archivo se debe &lt;code&gt;read&lt;/code&gt; -able si se abre.</target>
        </trans-unit>
        <trans-unit id="2aa691cde7b75893eb561d3865c9d79612f73f71" translate="yes" xml:space="preserve">
          <source>This option, when true, will indicate that the file should be &lt;code&gt;write&lt;/code&gt;-able if opened.</source>
          <target state="translated">Esta opci&amp;oacute;n, cuando sea verdadera, indicar&amp;aacute; que el archivo debe poder &lt;code&gt;write&lt;/code&gt; si se abre.</target>
        </trans-unit>
        <trans-unit id="42af0ae9cc5372b7ccd519ad313f0abe9e0cfe15" translate="yes" xml:space="preserve">
          <source>This ordering is only applicable for operations that can perform a load.</source>
          <target state="translated">Esta orden sólo se aplica a las operaciones que pueden realizar una carga.</target>
        </trans-unit>
        <trans-unit id="20a3da5b9e12d0ccdf3e64c2e589466b4721fced" translate="yes" xml:space="preserve">
          <source>This ordering is only applicable for operations that can perform a store.</source>
          <target state="translated">Este ordenamiento sólo es aplicable para las operaciones que puede realizar una tienda.</target>
        </trans-unit>
        <trans-unit id="ea76b31c997f4d8a61f17e8560093311b945344f" translate="yes" xml:space="preserve">
          <source>This ordering is only applicable for operations that combine both loads and stores.</source>
          <target state="translated">Esta orden sólo es aplicable a las operaciones que combinen tanto cargas como provisiones.</target>
        </trans-unit>
        <trans-unit id="a87804f30fcdf78425015d26ec12efca3e1a08c7" translate="yes" xml:space="preserve">
          <source>This output is better: we now have a reasonable error message. However, we also have extraneous information we don&amp;rsquo;t want to give to our users. Perhaps using the technique we used in Listing 9-10 isn&amp;rsquo;t the best to use here: a call to &lt;code&gt;panic!&lt;/code&gt; is more appropriate for a programming problem than a usage problem, &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#guidelines-for-error-handling&quot;&gt;as discussed in Chapter 9&lt;/a&gt;. Instead, we can use the other technique you learned about in Chapter 9&amp;mdash;&lt;a href=&quot;ch09-02-recoverable-errors-with-result&quot;&gt;returning a &lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; that indicates either success or an error.</source>
          <target state="translated">Esta salida es mejor: ahora tenemos un mensaje de error razonable. Sin embargo, tambi&amp;eacute;n tenemos informaci&amp;oacute;n extra&amp;ntilde;a que no queremos dar a nuestros usuarios. Quiz&amp;aacute;s usar la t&amp;eacute;cnica que usamos en el Listado 9-10 no es la mejor para usar aqu&amp;iacute;: &amp;iexcl;una llamada al &lt;code&gt;panic!&lt;/code&gt; es m&amp;aacute;s apropiado para un problema de programaci&amp;oacute;n que un problema de uso, &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#guidelines-for-error-handling&quot;&gt;como se discuti&amp;oacute; en el Cap&amp;iacute;tulo 9&lt;/a&gt; . En su lugar, podemos utilizar la otra t&amp;eacute;cnica que aprendi&amp;oacute; en el Cap&amp;iacute;tulo 9: &lt;a href=&quot;ch09-02-recoverable-errors-with-result&quot;&gt;devolver un &lt;code&gt;Result&lt;/code&gt; ado&lt;/a&gt; que indica &amp;eacute;xito o error.</target>
        </trans-unit>
        <trans-unit id="04051f730c7eeba40e7dd9250f9fd3ae55f310b9" translate="yes" xml:space="preserve">
          <source>This output isn&amp;rsquo;t what we wanted. We want to call the &lt;code&gt;baby_name&lt;/code&gt; function that is part of the &lt;code&gt;Animal&lt;/code&gt; trait that we implemented on &lt;code&gt;Dog&lt;/code&gt; so the code prints &lt;code&gt;A baby dog is called a puppy&lt;/code&gt;. The technique of specifying the trait name that we used in Listing 19-18 doesn&amp;rsquo;t help here; if we change &lt;code&gt;main&lt;/code&gt; to the code in Listing 19-20, we&amp;rsquo;ll get a compilation error.</source>
          <target state="translated">Esta salida no es la que quer&amp;iacute;amos. Queremos llamar a la funci&amp;oacute;n &lt;code&gt;baby_name&lt;/code&gt; que es parte del rasgo &lt;code&gt;Animal&lt;/code&gt; que implementamos en &lt;code&gt;Dog&lt;/code&gt; para que se imprima el c&amp;oacute;digo. &lt;code&gt;A baby dog is called a puppy&lt;/code&gt; . La t&amp;eacute;cnica de especificar el nombre del rasgo que usamos en el Listado 19-18 no ayuda aqu&amp;iacute;; si cambiamos &lt;code&gt;main&lt;/code&gt; al c&amp;oacute;digo del Listado 19-20, obtendremos un error de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="66b4788ea5425d4692dd1ffafd058fec8508d60c" translate="yes" xml:space="preserve">
          <source>This output shows &lt;code&gt;cargo test&lt;/code&gt; only ran the tests for the &lt;code&gt;add-one&lt;/code&gt; crate and didn&amp;rsquo;t run the &lt;code&gt;adder&lt;/code&gt; crate tests.</source>
          <target state="translated">Esta salida muestra &lt;code&gt;cargo test&lt;/code&gt; solo ejecut&amp;oacute; las pruebas para la caja &lt;code&gt;add-one&lt;/code&gt; y no ejecut&amp;oacute; las pruebas de la caja &lt;code&gt;adder&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f91d4073e1806ac4e46d9be9407b7439ade530c5" translate="yes" xml:space="preserve">
          <source>This outputs:</source>
          <target state="translated">Esto produce:</target>
        </trans-unit>
        <trans-unit id="220a338b4d08066eba2a22fb127e73c40665ebcb" translate="yes" xml:space="preserve">
          <source>This overwrites pinned data, but that is okay: its destructor gets run before being overwritten, so no pinning guarantee is violated.</source>
          <target state="translated">Esto sobreescribe los datos fijados,pero está bien:su destructor se ejecuta antes de ser sobrescrito,por lo que no se viola la garantía de fijación.</target>
        </trans-unit>
        <trans-unit id="05caefb888af241727a56b286e8ae483a7d9633f" translate="yes" xml:space="preserve">
          <source>This page documents the formal specification of the follow rules for &lt;a href=&quot;macros-by-example&quot;&gt;Macros By Example&lt;/a&gt;. They were originally specified in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.html&quot;&gt;RFC 550&lt;/a&gt;, from which the bulk of this text is copied, and expanded upon in subsequent RFCs.</source>
          <target state="translated">Esta p&amp;aacute;gina documenta la especificaci&amp;oacute;n formal de las siguientes reglas para &lt;a href=&quot;macros-by-example&quot;&gt;Macros por ejemplo&lt;/a&gt; . Originalmente se especificaron en &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.html&quot;&gt;RFC 550&lt;/a&gt; , de la cual se copia la mayor parte de este texto y se ampl&amp;iacute;a en RFC posteriores.</target>
        </trans-unit>
        <trans-unit id="3b9633b5692298146f03a49947c6dcff6df1f7b9" translate="yes" xml:space="preserve">
          <source>This page documents the formal specification of the follow rules for &lt;a href=&quot;macros-by-example&quot;&gt;Macros By Example&lt;/a&gt;. They were originally specified in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.md&quot;&gt;RFC 550&lt;/a&gt;, from which the bulk of this text is copied, and expanded upon in subsequent RFCs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f87b1d9607de86149c082e3d8de19453e0048df2" translate="yes" xml:space="preserve">
          <source>This pattern has a profound impact on the way Rust code is written. It may seem simple right now, but the behavior of code can be unexpected in more complicated situations when we want to have multiple variables use the data we&amp;rsquo;ve allocated on the heap. Let&amp;rsquo;s explore some of those situations now.</source>
          <target state="translated">Este patr&amp;oacute;n tiene un impacto profundo en la forma en que se escribe el c&amp;oacute;digo de Rust. Puede parecer simple en este momento, pero el comportamiento del c&amp;oacute;digo puede ser inesperado en situaciones m&amp;aacute;s complicadas cuando queremos que m&amp;uacute;ltiples variables usen los datos que hemos asignado en el mont&amp;oacute;n. Exploremos algunas de esas situaciones ahora.</target>
        </trans-unit>
        <trans-unit id="ebae1cd81adce77daea1f3e37e663633c554fab5" translate="yes" xml:space="preserve">
          <source>This pattern is about separating concerns: &lt;em&gt;main.rs&lt;/em&gt; handles running the program, and &lt;em&gt;lib.rs&lt;/em&gt; handles all the logic of the task at hand. Because you can&amp;rsquo;t test the &lt;code&gt;main&lt;/code&gt; function directly, this structure lets you test all of your program&amp;rsquo;s logic by moving it into functions in &lt;em&gt;lib.rs&lt;/em&gt;. The only code that remains in &lt;em&gt;main.rs&lt;/em&gt; will be small enough to verify its correctness by reading it. Let&amp;rsquo;s rework our program by following this process.</source>
          <target state="translated">Este patr&amp;oacute;n se trata de separar preocupaciones: &lt;em&gt;main.rs&lt;/em&gt; maneja la ejecuci&amp;oacute;n del programa y &lt;em&gt;lib.rs&lt;/em&gt; maneja toda la l&amp;oacute;gica de la tarea en cuesti&amp;oacute;n. Porque no se puede probar la &lt;code&gt;main&lt;/code&gt; directamente la funci&amp;oacute;n, esta estructura le permite probar todas la l&amp;oacute;gica de su programa de movi&amp;eacute;ndolo en funciones en &lt;em&gt;lib.rs&lt;/em&gt; . El &amp;uacute;nico c&amp;oacute;digo que permanece en &lt;em&gt;main.rs&lt;/em&gt; ser&amp;aacute; lo suficientemente peque&amp;ntilde;o como para verificar su exactitud ley&amp;eacute;ndolo. Repasemos nuestro programa siguiendo este proceso.</target>
        </trans-unit>
        <trans-unit id="4f7fef1aec609824d9a98cbd4986f806fb8112f5" translate="yes" xml:space="preserve">
          <source>This pattern is refutable when one of its subpatterns is refutable.</source>
          <target state="translated">Este patrón es refutable cuando uno de sus subpatrones es refutable.</target>
        </trans-unit>
        <trans-unit id="8e7824ffc5e192a74a0014b97fd199a69a9bbad1" translate="yes" xml:space="preserve">
          <source>This pattern of propagating errors is so common in Rust that Rust provides the question mark operator &lt;code&gt;?&lt;/code&gt; to make this easier.</source>
          <target state="translated">Este patr&amp;oacute;n de propagaci&amp;oacute;n de errores es tan com&amp;uacute;n en Rust que Rust proporciona el operador de signo de interrogaci&amp;oacute;n &lt;code&gt;?&lt;/code&gt; para hacer esto m&amp;aacute;s f&amp;aacute;cil.</target>
        </trans-unit>
        <trans-unit id="be8e420bedd2fafb3e2ace598d4c2a4fc61a219a" translate="yes" xml:space="preserve">
          <source>This performs complex unconditional mappings with no tailoring: it maps one Unicode character to its lowercase equivalent according to the &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt&quot;&gt;Unicode database&lt;/a&gt; and the additional complex mappings &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt&quot;&gt;&lt;code&gt;SpecialCasing.txt&lt;/code&gt;&lt;/a&gt;. Conditional mappings (based on context or language) are not considered here.</source>
          <target state="translated">Esto realiza asignaciones incondicionales complejas sin adaptaci&amp;oacute;n: asigna un car&amp;aacute;cter Unicode a su equivalente en min&amp;uacute;sculas de acuerdo con la &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt&quot;&gt;base de datos Unicode&lt;/a&gt; y las asignaciones complejas adicionales &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt&quot;&gt; &lt;code&gt;SpecialCasing.txt&lt;/code&gt; &lt;/a&gt; . Las asignaciones condicionales (basadas en el contexto o el idioma) no se consideran aqu&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="2bedef26ecd391020afcece167562372d74e3b11" translate="yes" xml:space="preserve">
          <source>This performs complex unconditional mappings with no tailoring: it maps one Unicode character to its uppercase equivalent according to the &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt&quot;&gt;Unicode database&lt;/a&gt; and the additional complex mappings &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt&quot;&gt;&lt;code&gt;SpecialCasing.txt&lt;/code&gt;&lt;/a&gt;. Conditional mappings (based on context or language) are not considered here.</source>
          <target state="translated">Esto realiza asignaciones incondicionales complejas sin adaptaci&amp;oacute;n: asigna un car&amp;aacute;cter Unicode a su equivalente en may&amp;uacute;sculas de acuerdo con la &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt&quot;&gt;base de datos Unicode&lt;/a&gt; y las asignaciones complejas adicionales &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt&quot;&gt; &lt;code&gt;SpecialCasing.txt&lt;/code&gt; &lt;/a&gt; . Las asignaciones condicionales (basadas en el contexto o el idioma) no se consideran aqu&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="367fd59cc7a5ce52d6910a709b90bfcbe81a7ab5" translate="yes" xml:space="preserve">
          <source>This piece of Rust history is relevant because it&amp;rsquo;s possible that more deterministic patterns will emerge and be added to the compiler. In the future, even fewer lifetime annotations might be required.</source>
          <target state="translated">Esta parte de la historia de Rust es relevante porque es posible que surjan patrones m&amp;aacute;s deterministas y se agreguen al compilador. En el futuro, es posible que se requieran incluso menos anotaciones de por vida.</target>
        </trans-unit>
        <trans-unit id="4d1e98917aa47fb301eb32dc85055855554e0b37" translate="yes" xml:space="preserve">
          <source>This pinned future is then polled by calling the &lt;a href=&quot;../../std/future/trait.future#tymethod.poll&quot;&gt;&lt;code&gt;Future::poll&lt;/code&gt;&lt;/a&gt; method and passing it the current &lt;a href=&quot;#task-context&quot;&gt;task context&lt;/a&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce7cedc5fc51216f120f0eb8fae3379dc963620e" translate="yes" xml:space="preserve">
          <source>This prints output like:</source>
          <target state="translated">Esto imprime una salida como:</target>
        </trans-unit>
        <trans-unit id="ff9f7a5e1d4525cd7d8438461ac9c53da48b455e" translate="yes" xml:space="preserve">
          <source>This prints to &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)&quot;&gt;stderr&lt;/a&gt;:</source>
          <target state="translated">Esto se imprime en &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)&quot;&gt;stderr&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="3c9f3b33a54ec1f8657331a04066cc462bed4e33" translate="yes" xml:space="preserve">
          <source>This problem can be solved by specifying from which trait we want to use the &lt;code&gt;Bar&lt;/code&gt; type:</source>
          <target state="translated">Este problema se puede resolver especificando desde qu&amp;eacute; rasgo queremos usar el tipo de &lt;code&gt;Bar&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fc4e53a566f64cd7b3bd5c8e48b6dab0075560d7" translate="yes" xml:space="preserve">
          <source>This process does not take into account the mutability or lifetime of the receiver, or whether a method is &lt;code&gt;unsafe&lt;/code&gt;. Once a method is looked up, if it can't be called for one (or more) of those reasons, the result is a compiler error.</source>
          <target state="translated">Este proceso no tiene en cuenta la mutabilidad o la vida &amp;uacute;til del receptor, o si un m&amp;eacute;todo &lt;code&gt;unsafe&lt;/code&gt; es seguro . Una vez que se busca un m&amp;eacute;todo, si no se puede llamar por una (o m&amp;aacute;s) de esas razones, el resultado es un error del compilador.</target>
        </trans-unit>
        <trans-unit id="1ff3edc7107794fccb9370413ce9f2edb3d33555" translate="yes" xml:space="preserve">
          <source>This process is just one of many ways to write software, but TDD can help drive code design as well. Writing the test before you write the code that makes the test pass helps to maintain high test coverage throughout the process.</source>
          <target state="translated">Este proceso es sólo una de las muchas maneras de escribir software,pero TDD también puede ayudar en el diseño de código.Escribir la prueba antes de escribir el código que hace que la prueba pase ayuda a mantener una alta cobertura de la prueba a lo largo del proceso.</target>
        </trans-unit>
        <trans-unit id="2a5870cc6149419aa4b701948d1d720f8c2eb21c" translate="yes" xml:space="preserve">
          <source>This program compiles without any errors and would also do so if we used &lt;code&gt;word&lt;/code&gt; after calling &lt;code&gt;s.clear()&lt;/code&gt;. Because &lt;code&gt;word&lt;/code&gt; isn&amp;rsquo;t connected to the state of &lt;code&gt;s&lt;/code&gt; at all, &lt;code&gt;word&lt;/code&gt; still contains the value &lt;code&gt;5&lt;/code&gt;. We could use that value &lt;code&gt;5&lt;/code&gt; with the variable &lt;code&gt;s&lt;/code&gt; to try to extract the first word out, but this would be a bug because the contents of &lt;code&gt;s&lt;/code&gt; have changed since we saved &lt;code&gt;5&lt;/code&gt; in &lt;code&gt;word&lt;/code&gt;.</source>
          <target state="translated">Este programa se compila sin errores y tambi&amp;eacute;n lo har&amp;iacute;a si &lt;code&gt;s.clear()&lt;/code&gt; &lt;code&gt;word&lt;/code&gt; despu&amp;eacute;s de llamar a s.clear () . Debido a que &lt;code&gt;word&lt;/code&gt; no est&amp;aacute; conectada al estado de &lt;code&gt;s&lt;/code&gt; en absoluto, &lt;code&gt;word&lt;/code&gt; todav&amp;iacute;a contiene el valor &lt;code&gt;5&lt;/code&gt; . Podr&amp;iacute;amos usar ese valor &lt;code&gt;5&lt;/code&gt; con la variable &lt;code&gt;s&lt;/code&gt; para intentar extraer la primera palabra, pero esto ser&amp;iacute;a un error porque el contenido de &lt;code&gt;s&lt;/code&gt; ha cambiado desde que guardamos &lt;code&gt;5&lt;/code&gt; en &lt;code&gt;word&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1a216c5bb2240db271ccf5242339067640e2983" translate="yes" xml:space="preserve">
          <source>This program creates a tuple, &lt;code&gt;x&lt;/code&gt;, and then makes new variables for each element by using their index. As with most programming languages, the first index in a tuple is 0.</source>
          <target state="translated">Este programa crea una tupla, &lt;code&gt;x&lt;/code&gt; , y luego crea nuevas variables para cada elemento usando su &amp;iacute;ndice. Como ocurre con la mayor&amp;iacute;a de los lenguajes de programaci&amp;oacute;n, el primer &amp;iacute;ndice de una tupla es 0.</target>
        </trans-unit>
        <trans-unit id="a953795409deaf59d9e6550cf24f5329cf86ee13" translate="yes" xml:space="preserve">
          <source>This program creates a tuple, &lt;code&gt;x&lt;/code&gt;, and then makes new variables for each element by using their respective indices. As with most programming languages, the first index in a tuple is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="052f0899e565e8d2644e743be0e56bf26e6e1767" translate="yes" xml:space="preserve">
          <source>This program first binds &lt;code&gt;x&lt;/code&gt; to a value of &lt;code&gt;5&lt;/code&gt;. Then it shadows &lt;code&gt;x&lt;/code&gt; by repeating &lt;code&gt;let x =&lt;/code&gt;, taking the original value and adding &lt;code&gt;1&lt;/code&gt; so the value of &lt;code&gt;x&lt;/code&gt; is then &lt;code&gt;6&lt;/code&gt;. The third &lt;code&gt;let&lt;/code&gt; statement also shadows &lt;code&gt;x&lt;/code&gt;, multiplying the previous value by &lt;code&gt;2&lt;/code&gt; to give &lt;code&gt;x&lt;/code&gt; a final value of &lt;code&gt;12&lt;/code&gt;. When we run this program, it will output the following:</source>
          <target state="translated">Este programa primero une &lt;code&gt;x&lt;/code&gt; a un valor de &lt;code&gt;5&lt;/code&gt; . Luego sombrea &lt;code&gt;x&lt;/code&gt; repitiendo &lt;code&gt;let x =&lt;/code&gt; , tomando el valor original y agregando &lt;code&gt;1&lt;/code&gt; para que el valor de &lt;code&gt;x&lt;/code&gt; sea &lt;code&gt;6&lt;/code&gt; . La tercera declaraci&amp;oacute;n &lt;code&gt;let&lt;/code&gt; tambi&amp;eacute;n sombrea &lt;code&gt;x&lt;/code&gt; , multiplicando el valor anterior por &lt;code&gt;2&lt;/code&gt; para dar a &lt;code&gt;x&lt;/code&gt; un valor final de &lt;code&gt;12&lt;/code&gt; . Cuando ejecutamos este programa, generar&amp;aacute; lo siguiente:</target>
        </trans-unit>
        <trans-unit id="e37eff19d0df592c13224ef2e32fd74387b55f9e" translate="yes" xml:space="preserve">
          <source>This program first creates a tuple and binds it to the variable &lt;code&gt;tup&lt;/code&gt;. It then uses a pattern with &lt;code&gt;let&lt;/code&gt; to take &lt;code&gt;tup&lt;/code&gt; and turn it into three separate variables, &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;. This is called &lt;em&gt;destructuring&lt;/em&gt;, because it breaks the single tuple into three parts. Finally, the program prints the value of &lt;code&gt;y&lt;/code&gt;, which is &lt;code&gt;6.4&lt;/code&gt;.</source>
          <target state="translated">Este programa primero crea una tupla y la vincula a la variable &lt;code&gt;tup&lt;/code&gt; . Luego usa un patr&amp;oacute;n con &lt;code&gt;let&lt;/code&gt; para tomar &lt;code&gt;tup&lt;/code&gt; y convertirlo en tres variables separadas, &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; y &lt;code&gt;z&lt;/code&gt; . Esto se llama &lt;em&gt;desestructuraci&amp;oacute;n&lt;/em&gt; porque divide la tupla en tres partes. Finalmente, el programa imprime el valor de &lt;code&gt;y&lt;/code&gt; , que es &lt;code&gt;6.4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e68e59981686f4d6d9628e4a0f06c39a18431f20" translate="yes" xml:space="preserve">
          <source>This program has four possible paths it can take. After running it, you should see the following output:</source>
          <target state="translated">Este programa tiene cuatro caminos posibles que puede tomar.Después de ejecutarlo,deberías ver la siguiente salida:</target>
        </trans-unit>
        <trans-unit id="c268368ea9194ea4e99d8e793596c3443d5a9397" translate="yes" xml:space="preserve">
          <source>This project was a hands-on way to introduce you to many new Rust concepts: &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;match&lt;/code&gt;, methods, associated functions, the use of external crates, and more. In the next few chapters, you&amp;rsquo;ll learn about these concepts in more detail. Chapter 3 covers concepts that most programming languages have, such as variables, data types, and functions, and shows how to use them in Rust. Chapter 4 explores ownership, a feature that makes Rust different from other languages. Chapter 5 discusses structs and method syntax, and Chapter 6 explains how enums work.</source>
          <target state="translated">Este proyecto fue una forma pr&amp;aacute;ctica de presentarle muchos conceptos nuevos de Rust: &lt;code&gt;let&lt;/code&gt; , &lt;code&gt;match&lt;/code&gt; , m&amp;eacute;todos, funciones asociadas, el uso de cajas externas y m&amp;aacute;s. En los pr&amp;oacute;ximos cap&amp;iacute;tulos, aprender&amp;aacute; sobre estos conceptos con m&amp;aacute;s detalle. El Cap&amp;iacute;tulo 3 cubre conceptos que tienen la mayor&amp;iacute;a de los lenguajes de programaci&amp;oacute;n, como variables, tipos de datos y funciones, y muestra c&amp;oacute;mo usarlos en Rust. El Cap&amp;iacute;tulo 4 explora la propiedad, una caracter&amp;iacute;stica que hace que Rust sea diferente de otros idiomas. El Cap&amp;iacute;tulo 5 analiza las estructuras y la sintaxis de los m&amp;eacute;todos, y el Cap&amp;iacute;tulo 6 explica c&amp;oacute;mo funcionan las enumeraciones.</target>
        </trans-unit>
        <trans-unit id="9ce38c4decb31cc4f3034ac7fae7c79d93e80f53" translate="yes" xml:space="preserve">
          <source>This property cannot be checked by the compiler, and therefore &lt;code&gt;Eq&lt;/code&gt; implies &lt;a href=&quot;trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;, and has no extra methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab41f4f49ac9b596f3ff341e670c3c513d2c2a1e" translate="yes" xml:space="preserve">
          <source>This property cannot be checked by the compiler, and therefore &lt;code&gt;Eq&lt;/code&gt; implies &lt;code&gt;PartialEq&lt;/code&gt;, and has no extra methods.</source>
          <target state="translated">El compilador no puede verificar esta propiedad y, por lo tanto, &lt;code&gt;Eq&lt;/code&gt; implica &lt;code&gt;PartialEq&lt;/code&gt; y no tiene m&amp;eacute;todos adicionales.</target>
        </trans-unit>
        <trans-unit id="1608442363fd58986072b46f4e6a650827d3385c" translate="yes" xml:space="preserve">
          <source>This property is defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc1122&quot;&gt;IETF RFC 1122&lt;/a&gt;.</source>
          <target state="translated">Esta propiedad est&amp;aacute; definida por &lt;a href=&quot;https://tools.ietf.org/html/rfc1122&quot;&gt;IETF RFC 1122&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="25a4736ccf9a4ba3c3e3dac30177800bc1f743c9" translate="yes" xml:space="preserve">
          <source>This property is defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc3927&quot;&gt;IETF RFC 3927&lt;/a&gt;.</source>
          <target state="translated">Esta propiedad est&amp;aacute; definida por &lt;a href=&quot;https://tools.ietf.org/html/rfc3927&quot;&gt;IETF RFC 3927&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2cdf66b6082611e25a822825249d22e6f28f1917" translate="yes" xml:space="preserve">
          <source>This property is defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt;.</source>
          <target state="translated">Esta propiedad est&amp;aacute; definida por &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="93af0d07e68cafd035375823424d1e725ddb07d1" translate="yes" xml:space="preserve">
          <source>This property is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3849&quot;&gt;IETF RFC 3849&lt;/a&gt;.</source>
          <target state="translated">Esta propiedad se define en &lt;a href=&quot;https://tools.ietf.org/html/rfc3849&quot;&gt;IETF RFC 3849&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="85df454e96ffa6c63ed8ab37d8086b690c9dba86" translate="yes" xml:space="preserve">
          <source>This property is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4193&quot;&gt;IETF RFC 4193&lt;/a&gt;.</source>
          <target state="translated">Esta propiedad se define en &lt;a href=&quot;https://tools.ietf.org/html/rfc4193&quot;&gt;IETF RFC 4193&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d5a4dec1164aed352e96ad9af690b1a3591dc76" translate="yes" xml:space="preserve">
          <source>This property is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt;.</source>
          <target state="translated">Esta propiedad se define en &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c731a3c6e670f4842c76f756fa1e0f4c4f1cfae6" translate="yes" xml:space="preserve">
          <source>This property is defined in &lt;em&gt;UNIX Network Programming, Second Edition&lt;/em&gt;, W. Richard Stevens, p. 891; see also &lt;a href=&quot;http://man7.org/linux/man-pages/man7/ip.7.html&quot;&gt;ip7&lt;/a&gt;.</source>
          <target state="translated">Esta propiedad se define en &lt;em&gt;Programaci&amp;oacute;n de red UNIX, segunda edici&amp;oacute;n&lt;/em&gt; , W. Richard Stevens, p. 891; ver tambi&amp;eacute;n &lt;a href=&quot;http://man7.org/linux/man-pages/man7/ip.7.html&quot;&gt;ip7&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="19926d7df32802514fef095810b287a92fa4b874" translate="yes" xml:space="preserve">
          <source>This queue has &lt;code&gt;O(1)&lt;/code&gt; amortized inserts and removals from both ends of the container. It also has &lt;code&gt;O(1)&lt;/code&gt; indexing like a vector. The contained elements are not required to be copyable, and the queue will be sendable if the contained type is sendable.</source>
          <target state="translated">Esta cola tiene &lt;code&gt;O(1)&lt;/code&gt; inserciones y extracciones amortizadas de ambos extremos del contenedor. Tambi&amp;eacute;n tiene indexaci&amp;oacute;n &lt;code&gt;O(1)&lt;/code&gt; como un vector. No es necesario que los elementos contenidos se puedan copiar, y la cola se podr&amp;aacute; enviar si el tipo contenido se puede enviar.</target>
        </trans-unit>
        <trans-unit id="f222b6950bf888a7c8ce05739a640f15b3f1b84f" translate="yes" xml:space="preserve">
          <source>This queue has &lt;em&gt;O&lt;/em&gt;(1) amortized inserts and removals from both ends of the container. It also has &lt;em&gt;O&lt;/em&gt;(1) indexing like a vector. The contained elements are not required to be copyable, and the queue will be sendable if the contained type is sendable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae16a9ff1b9b0bb4dc2773f7faab160bd7347257" translate="yes" xml:space="preserve">
          <source>This reader has reached its &quot;end of file&quot; and will likely no longer be able to produce bytes. Note that this does not mean that the reader will &lt;em&gt;always&lt;/em&gt; no longer be able to produce bytes.</source>
          <target state="translated">Este lector ha llegado a su &quot;final de archivo&quot; y probablemente ya no podr&amp;aacute; producir bytes. Tenga en cuenta que esto no significa que el lector &lt;em&gt;siempre&lt;/em&gt; ya no ser&amp;aacute; capaz de producir bytes.</target>
        </trans-unit>
        <trans-unit id="eabbe1cac74b5970cf00777c8a04a9b08b503051" translate="yes" xml:space="preserve">
          <source>This reordering has the additional property that any value at position &lt;code&gt;i &amp;lt; index&lt;/code&gt; will be less than or equal to any value at a position &lt;code&gt;j &amp;gt; index&lt;/code&gt; using the comparator function. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position &lt;code&gt;index&lt;/code&gt;), in-place (i.e. does not allocate), and &lt;code&gt;O(n)&lt;/code&gt; worst-case. This function is also known as &quot;kth element&quot; in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index, using the provided comparator function.</source>
          <target state="translated">Esta reordenaci&amp;oacute;n tiene la propiedad adicional de que cualquier valor en la posici&amp;oacute;n &lt;code&gt;i &amp;lt; index&lt;/code&gt; ser&amp;aacute; menor o igual a cualquier valor en una posici&amp;oacute;n &lt;code&gt;j &amp;gt; index&lt;/code&gt; usando la funci&amp;oacute;n de comparaci&amp;oacute;n. Adem&amp;aacute;s, este reordenamiento es inestable (es decir, cualquier n&amp;uacute;mero de elementos iguales puede terminar en el &lt;code&gt;index&lt;/code&gt; posici&amp;oacute;n ), en el lugar (es decir, no asigna) y &lt;code&gt;O(n)&lt;/code&gt; peor de los casos. Esta funci&amp;oacute;n tambi&amp;eacute;n se conoce como &quot;elemento kth&quot; en otras bibliotecas. Devuelve un triplete de los siguientes valores: todos los elementos menores que uno en el &amp;iacute;ndice dado, el valor en el &amp;iacute;ndice dado y todos los elementos mayores que uno en el &amp;iacute;ndice dado, usando la funci&amp;oacute;n de comparaci&amp;oacute;n proporcionada.</target>
        </trans-unit>
        <trans-unit id="5a5e3f81a187820f825f4369ca83b2c286d9273d" translate="yes" xml:space="preserve">
          <source>This reordering has the additional property that any value at position &lt;code&gt;i &amp;lt; index&lt;/code&gt; will be less than or equal to any value at a position &lt;code&gt;j &amp;gt; index&lt;/code&gt; using the comparator function. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position &lt;code&gt;index&lt;/code&gt;), in-place (i.e. does not allocate), and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) worst-case. This function is also known as &quot;kth element&quot; in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index, using the provided comparator function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58333e6fd2204efb6d059b5e0ebaa3ad2ae11cea" translate="yes" xml:space="preserve">
          <source>This reordering has the additional property that any value at position &lt;code&gt;i &amp;lt; index&lt;/code&gt; will be less than or equal to any value at a position &lt;code&gt;j &amp;gt; index&lt;/code&gt; using the key extraction function. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position &lt;code&gt;index&lt;/code&gt;), in-place (i.e. does not allocate), and &lt;code&gt;O(n)&lt;/code&gt; worst-case. This function is also known as &quot;kth element&quot; in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index, using the provided key extraction function.</source>
          <target state="translated">Esta reordenaci&amp;oacute;n tiene la propiedad adicional de que cualquier valor en la posici&amp;oacute;n &lt;code&gt;i &amp;lt; index&lt;/code&gt; ser&amp;aacute; menor o igual a cualquier valor en una posici&amp;oacute;n &lt;code&gt;j &amp;gt; index&lt;/code&gt; usando la funci&amp;oacute;n de extracci&amp;oacute;n de claves. Adem&amp;aacute;s, este reordenamiento es inestable (es decir, cualquier n&amp;uacute;mero de elementos iguales puede terminar en el &lt;code&gt;index&lt;/code&gt; posici&amp;oacute;n ), en el lugar (es decir, no asigna) y &lt;code&gt;O(n)&lt;/code&gt; peor de los casos. Esta funci&amp;oacute;n tambi&amp;eacute;n se conoce como &quot;elemento kth&quot; en otras bibliotecas. Devuelve un triplete de los siguientes valores: todos los elementos menores que el del &amp;iacute;ndice dado, el valor del &amp;iacute;ndice dado, y todos los elementos mayores que el del &amp;iacute;ndice dado, utilizando la funci&amp;oacute;n de extracci&amp;oacute;n de claves proporcionada.</target>
        </trans-unit>
        <trans-unit id="c83a0af8a141703ce8a894f271d81b6b5d0d2d99" translate="yes" xml:space="preserve">
          <source>This reordering has the additional property that any value at position &lt;code&gt;i &amp;lt; index&lt;/code&gt; will be less than or equal to any value at a position &lt;code&gt;j &amp;gt; index&lt;/code&gt; using the key extraction function. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position &lt;code&gt;index&lt;/code&gt;), in-place (i.e. does not allocate), and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) worst-case. This function is also known as &quot;kth element&quot; in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index, using the provided key extraction function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18b0ecb2451beab6446b7792a5f32ac5b93e64f7" translate="yes" xml:space="preserve">
          <source>This reordering has the additional property that any value at position &lt;code&gt;i &amp;lt; index&lt;/code&gt; will be less than or equal to any value at a position &lt;code&gt;j &amp;gt; index&lt;/code&gt;. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position &lt;code&gt;index&lt;/code&gt;), in-place (i.e. does not allocate), and &lt;code&gt;O(n)&lt;/code&gt; worst-case. This function is also/ known as &quot;kth element&quot; in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index.</source>
          <target state="translated">Esta reordenaci&amp;oacute;n tiene la propiedad adicional de que cualquier valor en la posici&amp;oacute;n &lt;code&gt;i &amp;lt; index&lt;/code&gt; ser&amp;aacute; menor o igual que cualquier valor en una posici&amp;oacute;n &lt;code&gt;j &amp;gt; index&lt;/code&gt; . Adem&amp;aacute;s, este reordenamiento es inestable (es decir, cualquier n&amp;uacute;mero de elementos iguales puede terminar en el &lt;code&gt;index&lt;/code&gt; posici&amp;oacute;n ), en el lugar (es decir, no asigna) y &lt;code&gt;O(n)&lt;/code&gt; peor de los casos. Esta funci&amp;oacute;n tambi&amp;eacute;n se conoce como &quot;elemento kth&quot; en otras bibliotecas. Devuelve un triplete de los siguientes valores: todos los elementos menores que el del &amp;iacute;ndice dado, el valor del &amp;iacute;ndice dado y todos los elementos mayores que el del &amp;iacute;ndice dado.</target>
        </trans-unit>
        <trans-unit id="3d259af27d2572df43e2afe02e6f4d51f6ff06a9" translate="yes" xml:space="preserve">
          <source>This reordering has the additional property that any value at position &lt;code&gt;i &amp;lt; index&lt;/code&gt; will be less than or equal to any value at a position &lt;code&gt;j &amp;gt; index&lt;/code&gt;. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position &lt;code&gt;index&lt;/code&gt;), in-place (i.e. does not allocate), and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) worst-case. This function is also/ known as &quot;kth element&quot; in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a44d46360998129b78ed15d687f727979c543e5" translate="yes" xml:space="preserve">
          <source>This representation can be applied to structs, unions, and enums.</source>
          <target state="translated">Esta representación puede aplicarse a las estructuras,uniones y enums.</target>
        </trans-unit>
        <trans-unit id="c79281349d10df09672689425c0c484e6ef587c0" translate="yes" xml:space="preserve">
          <source>This representation can be applied to structs, unions, and enums. The exception is &lt;a href=&quot;items/enumerations#zero-variant-enums&quot;&gt;zero-variant enums&lt;/a&gt; for which the &lt;code&gt;C&lt;/code&gt; representation is an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54d003da75e5c18c6d78ec752d4c5ea2c1005e03" translate="yes" xml:space="preserve">
          <source>This requires that the data inside this &lt;code&gt;Pin&lt;/code&gt; is &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; so that we can ignore the pinning invariants when unwrapping it.</source>
          <target state="translated">Esto requiere que los datos dentro de este &lt;code&gt;Pin&lt;/code&gt; sean &lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt; para que podamos ignorar los invariantes de fijaci&amp;oacute;n al desenvolverlo.</target>
        </trans-unit>
        <trans-unit id="84a024e08861a138f89bc49f72665722f5345893" translate="yes" xml:space="preserve">
          <source>This requires that the data inside this &lt;code&gt;Pin&lt;/code&gt; is &lt;code&gt;Unpin&lt;/code&gt;.</source>
          <target state="translated">Esto requiere que los datos dentro de este &lt;code&gt;Pin&lt;/code&gt; sean &lt;code&gt;Unpin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb8049ba5b3a969809828fb6b20b4c6f803c243a" translate="yes" xml:space="preserve">
          <source>This restriction allows for mutation but in a very controlled fashion. It&amp;rsquo;s something that new Rustaceans struggle with, because most languages let you mutate whenever you&amp;rsquo;d like.</source>
          <target state="translated">Esta restricci&amp;oacute;n permite la mutaci&amp;oacute;n pero de una manera muy controlada. Es algo con lo que los nuevos rust&amp;aacute;ceos luchan, porque la mayor&amp;iacute;a de los idiomas te permiten mutar cuando quieras.</target>
        </trans-unit>
        <trans-unit id="b9005ee922bd85c1b8cdd5bf9e647bc71bc7e1d1" translate="yes" xml:space="preserve">
          <source>This restricts us to a &lt;code&gt;Screen&lt;/code&gt; instance that has a list of components all of type &lt;code&gt;Button&lt;/code&gt; or all of type &lt;code&gt;TextField&lt;/code&gt;. If you&amp;rsquo;ll only ever have homogeneous collections, using generics and trait bounds is preferable because the definitions will be monomorphized at compile time to use the concrete types.</source>
          <target state="translated">Esto nos restringe a una instancia de &lt;code&gt;Screen&lt;/code&gt; que tiene una lista de componentes, todos de tipo &lt;code&gt;Button&lt;/code&gt; o todos de tipo &lt;code&gt;TextField&lt;/code&gt; . Si solo tendr&amp;aacute; colecciones homog&amp;eacute;neas, es preferible usar gen&amp;eacute;ricos y l&amp;iacute;mites de rasgos porque las definiciones se monomorfizar&amp;aacute;n en el momento de la compilaci&amp;oacute;n para usar los tipos concretos.</target>
        </trans-unit>
        <trans-unit id="fef61557094c53c94d8f4b9c87d239c1c4ddf6a3" translate="yes" xml:space="preserve">
          <source>This result just indicates that the assertion failed and which line the assertion is on. A more useful failure message in this case would print the value we got from the &lt;code&gt;greeting&lt;/code&gt; function. Let&amp;rsquo;s change the test function, giving it a custom failure message made from a format string with a placeholder filled in with the actual value we got from the &lt;code&gt;greeting&lt;/code&gt; function:</source>
          <target state="translated">Este resultado solo indica que la aserci&amp;oacute;n fall&amp;oacute; y en qu&amp;eacute; l&amp;iacute;nea se encuentra la aserci&amp;oacute;n. Un mensaje de falla m&amp;aacute;s &amp;uacute;til en este caso imprimir&amp;iacute;a el valor que obtuvimos de la funci&amp;oacute;n de &lt;code&gt;greeting&lt;/code&gt; . Cambiemos la funci&amp;oacute;n de prueba, d&amp;aacute;ndole un mensaje de falla personalizado hecho a partir de una cadena de formato con un marcador de posici&amp;oacute;n completado con el valor real que obtuvimos de la funci&amp;oacute;n de &lt;code&gt;greeting&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0886cd5bf439fbbc8be3535b3d5401de7c87877b" translate="yes" xml:space="preserve">
          <source>This return type means the call to &lt;code&gt;File::open&lt;/code&gt; might succeed and return a file handle that we can read from or write to. The function call also might fail: for example, the file might not exist, or we might not have permission to access the file. The &lt;code&gt;File::open&lt;/code&gt; function needs to have a way to tell us whether it succeeded or failed and at the same time give us either the file handle or error information. This information is exactly what the &lt;code&gt;Result&lt;/code&gt; enum conveys.</source>
          <target state="translated">Este tipo de retorno significa que la llamada a &lt;code&gt;File::open&lt;/code&gt; podr&amp;iacute;a tener &amp;eacute;xito y devolver un identificador de archivo desde el que podemos leer o escribir. La llamada a la funci&amp;oacute;n tambi&amp;eacute;n puede fallar: por ejemplo, es posible que el archivo no exista o que no tengamos permiso para acceder al archivo. La funci&amp;oacute;n &lt;code&gt;File::open&lt;/code&gt; necesita tener una forma de decirnos si tuvo &amp;eacute;xito o fall&amp;oacute; y al mismo tiempo darnos el identificador del archivo o la informaci&amp;oacute;n de error. Esta informaci&amp;oacute;n es exactamente lo que transmite la enumeraci&amp;oacute;n &lt;code&gt;Result&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e6467b9314c67467a583133eaf79a55bec1323c" translate="yes" xml:space="preserve">
          <source>This returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the working directory will not be changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7256f6dfb124c4206009cc4970395f092ae3141" translate="yes" xml:space="preserve">
          <source>This returns &lt;code&gt;None&lt;/code&gt; if the cursor is currently pointing to the &quot;ghost&quot; non-element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b3770e7d2efd1b08fe66eb571f2a780fb54e25f" translate="yes" xml:space="preserve">
          <source>This returns a numeric identifier for the thread identified by this &lt;code&gt;ThreadId&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="368beec57f1181b8799a91ee73ada8b4184da78e" translate="yes" xml:space="preserve">
          <source>This reuses all the nodes from &lt;code&gt;other&lt;/code&gt; and moves them into &lt;code&gt;self&lt;/code&gt;. After this operation, &lt;code&gt;other&lt;/code&gt; becomes empty.</source>
          <target state="translated">Esto reutiliza todos los nodos de &lt;code&gt;other&lt;/code&gt; y los mueve hacia &lt;code&gt;self&lt;/code&gt; . Despu&amp;eacute;s de esta operaci&amp;oacute;n, &lt;code&gt;other&lt;/code&gt; quedan vac&amp;iacute;os.</target>
        </trans-unit>
        <trans-unit id="7730271090bac7f074841851b1b821f9fc7fca43" translate="yes" xml:space="preserve">
          <source>This rework may seem like overkill for our small program, but we&amp;rsquo;re refactoring in small, incremental steps. After making this change, run the program again to verify that the argument parsing still works. It&amp;rsquo;s good to check your progress often, to help identify the cause of problems when they occur.</source>
          <target state="translated">Esta reelaboraci&amp;oacute;n puede parecer excesiva para nuestro peque&amp;ntilde;o programa, pero estamos refactorizando en pasos peque&amp;ntilde;os e incrementales. Despu&amp;eacute;s de realizar este cambio, ejecute el programa nuevamente para verificar que el an&amp;aacute;lisis de argumentos a&amp;uacute;n funciona. Es bueno verificar su progreso con frecuencia para ayudar a identificar la causa de los problemas cuando ocurran.</target>
        </trans-unit>
        <trans-unit id="c68a9d1019f31cc86d07a97f90c903ea86167b11" translate="yes" xml:space="preserve">
          <source>This rule also applies to type parameters of impl blocks that contain const methods</source>
          <target state="translated">Esta regla también se aplica a los parámetros de tipo de los bloques implícitos que contienen métodos const</target>
        </trans-unit>
        <trans-unit id="c9e400474c407c09b7fb37164368bcd30fbe8830" translate="yes" xml:space="preserve">
          <source>This runs the code in &lt;em&gt;adder/src/main.rs&lt;/em&gt;, which depends on the &lt;code&gt;add-one&lt;/code&gt; crate.</source>
          <target state="translated">Esto ejecuta el c&amp;oacute;digo en &lt;em&gt;adder / src / main.rs&lt;/em&gt; , que depende de la caja de &lt;code&gt;add-one&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6b2224800e73c42ee25267c2896a776ab41e710" translate="yes" xml:space="preserve">
          <source>This section documents features that affect the ABI of the compiled output of a crate.</source>
          <target state="translated">En esta sección se documentan las características que afectan a la ABI de la salida compilada de una caja.</target>
        </trans-unit>
        <trans-unit id="7dc2765b02ef149354a7a9ee16a696edf0827240" translate="yes" xml:space="preserve">
          <source>This section documents features that define some aspects of the Rust runtime.</source>
          <target state="translated">Esta sección documenta las características que definen algunos aspectos del tiempo de ejecución del óxido.</target>
        </trans-unit>
        <trans-unit id="f7c12226b9e0c0ca24fa6bdd6239b023bf8ef3a4" translate="yes" xml:space="preserve">
          <source>This should only ever be called with a pointer that was earlier obtained by calling &lt;a href=&quot;#method.into_raw&quot;&gt;&lt;code&gt;into_raw&lt;/code&gt;&lt;/a&gt; on a &lt;code&gt;CString&lt;/code&gt;. Other usage (e.g., trying to take ownership of a string that was allocated by foreign code) is likely to lead to undefined behavior or allocator corruption.</source>
          <target state="translated">Esto solo deber&amp;iacute;a llamarse con un puntero que se obtuvo anteriormente llamando a &lt;a href=&quot;#method.into_raw&quot;&gt; &lt;code&gt;into_raw&lt;/code&gt; &lt;/a&gt; en un &lt;code&gt;CString&lt;/code&gt; . Otro uso (por ejemplo, intentar tomar posesi&amp;oacute;n de una cadena que fue asignada por c&amp;oacute;digo externo) probablemente lleve a un comportamiento indefinido o corrupci&amp;oacute;n del asignador.</target>
        </trans-unit>
        <trans-unit id="bb13fd72f340b7885313dcc12025456f86beff96" translate="yes" xml:space="preserve">
          <source>This should only ever be called with a pointer that was earlier obtained by calling &lt;a href=&quot;struct.cstring#method.into_raw&quot;&gt;&lt;code&gt;CString::into_raw&lt;/code&gt;&lt;/a&gt;. Other usage (e.g., trying to take ownership of a string that was allocated by foreign code) is likely to lead to undefined behavior or allocator corruption.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6de4781e84fd1ffb8326c915806ff4604cbf7406" translate="yes" xml:space="preserve">
          <source>This shows the source code file with the &lt;em&gt;.rs&lt;/em&gt; extension, the executable file (&lt;em&gt;main.exe&lt;/em&gt; on Windows, but &lt;em&gt;main&lt;/em&gt; on all other platforms), and, when using Windows, a file containing debugging information with the &lt;em&gt;.pdb&lt;/em&gt; extension. From here, you run the &lt;em&gt;main&lt;/em&gt; or &lt;em&gt;main.exe&lt;/em&gt; file, like this:</source>
          <target state="translated">Esto muestra el archivo de c&amp;oacute;digo fuente con la extensi&amp;oacute;n &lt;em&gt;.rs&lt;/em&gt; , el archivo ejecutable ( &lt;em&gt;main.exe&lt;/em&gt; en Windows, pero &lt;em&gt;main&lt;/em&gt; en todas las dem&amp;aacute;s plataformas) y, cuando se usa Windows, un archivo que contiene informaci&amp;oacute;n de depuraci&amp;oacute;n con la extensi&amp;oacute;n &lt;em&gt;.pdb&lt;/em&gt; . Desde aqu&amp;iacute;, ejecuta el archivo &lt;em&gt;main&lt;/em&gt; o &lt;em&gt;main.exe&lt;/em&gt; , as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="9575f8046ce99c60fbe347fdb162c3debc44c697" translate="yes" xml:space="preserve">
          <source>This slice has the type &lt;code&gt;&amp;amp;[i32]&lt;/code&gt;. It works the same way as string slices do, by storing a reference to the first element and a length. You&amp;rsquo;ll use this kind of slice for all sorts of other collections. We&amp;rsquo;ll discuss these collections in detail when we talk about vectors in Chapter 8.</source>
          <target state="translated">Este segmento tiene el tipo &lt;code&gt;&amp;amp;[i32]&lt;/code&gt; . Funciona de la misma manera que los cortes de cadena, almacenando una referencia al primer elemento y una longitud. Utilizar&amp;aacute; este tipo de porci&amp;oacute;n para todo tipo de otras colecciones. Discutiremos estas colecciones en detalle cuando hablemos de vectores en el Cap&amp;iacute;tulo 8.</target>
        </trans-unit>
        <trans-unit id="d65fb4bd24471a81f14e38e503058f70c64833b3" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;code&gt;O(m * n * log(n))&lt;/code&gt; worst-case, where the key function is &lt;code&gt;O(m)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5c9c4b26823864ca42f73d970b5f61574652362" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;code&gt;O(m * n + n * log(n))&lt;/code&gt; worst-case, where the key function is &lt;code&gt;O(m)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3fe498c20a11bda205dc93f4390f850884c310c" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;code&gt;O(m n + n log n)&lt;/code&gt; worst-case, where the key function is &lt;code&gt;O(m)&lt;/code&gt;.</source>
          <target state="translated">Este tipo es estable (es decir, no reordena elementos iguales) y &lt;code&gt;O(m n + n log n)&lt;/code&gt; peor de los casos, donde la funci&amp;oacute;n clave es &lt;code&gt;O(m)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04ff5f9e434224075f07c47221408f586ed69430" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;code&gt;O(m n log(m n))&lt;/code&gt; worst-case, where the key function is &lt;code&gt;O(m)&lt;/code&gt;.</source>
          <target state="translated">Este tipo es estable (es decir, no reordena elementos iguales) y &lt;code&gt;O(m n log(m n))&lt;/code&gt; peor de los casos, donde la funci&amp;oacute;n clave es &lt;code&gt;O(m)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13defa388ad16a8832cba0851748fe2d9c59598b" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;code&gt;O(n * log(n))&lt;/code&gt; worst-case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29bb618262e9818d4542507320a836e4faf4b56f" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;code&gt;O(n log n)&lt;/code&gt; worst-case.</source>
          <target state="translated">Este tipo es estable (es decir, no reordena elementos iguales) y &lt;code&gt;O(n log n)&lt;/code&gt; peor de los casos.</target>
        </trans-unit>
        <trans-unit id="342fc35a79498863eed086153ecf4de54d803470" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;m&lt;/em&gt; * &lt;em&gt;n&lt;/em&gt; * log(&lt;em&gt;n&lt;/em&gt;)) worst-case, where the key function is &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;m&lt;/em&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9e6ed2e7770cad1c08fcd52e4c75266e91bca66" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;m&lt;/em&gt; * &lt;em&gt;n&lt;/em&gt; + &lt;em&gt;n&lt;/em&gt; * log(&lt;em&gt;n&lt;/em&gt;)) worst-case, where the key function is &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;m&lt;/em&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0fa553880d5f214b25277a39b204d8402684264" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt; * log(&lt;em&gt;n&lt;/em&gt;)) worst-case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8094b9acbcdfe817a2beca8fbbfd03d36adf019" translate="yes" xml:space="preserve">
          <source>This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not allocate), and &lt;code&gt;O(m n log(m n))&lt;/code&gt; worst-case, where the key function is &lt;code&gt;O(m)&lt;/code&gt;.</source>
          <target state="translated">Esta clasificaci&amp;oacute;n es inestable (es decir, puede reordenar elementos iguales), en el lugar (es decir, no asigna) y &lt;code&gt;O(m n log(m n))&lt;/code&gt; peor de los casos, donde la funci&amp;oacute;n clave es &lt;code&gt;O(m)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e852a79da20e649bf213cb6826ee95c589ae984" translate="yes" xml:space="preserve">
          <source>This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not allocate), and &lt;code&gt;O(n log n)&lt;/code&gt; worst-case.</source>
          <target state="translated">Este tipo es inestable (es decir, puede reordenar elementos iguales), en el lugar (es decir, no asigna) y &lt;code&gt;O(n log n)&lt;/code&gt; peor de los casos.</target>
        </trans-unit>
        <trans-unit id="3d7156d28541cb0cabeaa7410dd06cdaa9199652" translate="yes" xml:space="preserve">
          <source>This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not allocate), and &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt; * log(&lt;em&gt;n&lt;/em&gt;)) worst-case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3e0c73c0881bd5d99646c6bd52683bfabd1a90e" translate="yes" xml:space="preserve">
          <source>This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not allocate), and &lt;em&gt;O&lt;/em&gt;(m * &lt;em&gt;n&lt;/em&gt; * log(&lt;em&gt;n&lt;/em&gt;)) worst-case, where the key function is &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;m&lt;/em&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b9136d07194a4e8e43750309da02e688255bd47" translate="yes" xml:space="preserve">
          <source>This sort of behavior has been known to &lt;a href=&quot;https://securityvulns.com/Wdocument183.html&quot;&gt;lead to privilege escalation&lt;/a&gt; when used incorrectly.</source>
          <target state="translated">Se sabe que este tipo de comportamiento &lt;a href=&quot;https://securityvulns.com/Wdocument183.html&quot;&gt;conduce a una escalada de privilegios&lt;/a&gt; cuando se usa incorrectamente.</target>
        </trans-unit>
        <trans-unit id="4609a563600ff8952232a98685a394486b72fb56" translate="yes" xml:space="preserve">
          <source>This state indicates that a generator has been suspended, and typically corresponds to a &lt;code&gt;yield&lt;/code&gt; statement. The value provided in this variant corresponds to the expression passed to &lt;code&gt;yield&lt;/code&gt; and allows generators to provide a value each time they yield.</source>
          <target state="translated">Este estado indica que se ha suspendido un generador y normalmente corresponde a una declaraci&amp;oacute;n de &lt;code&gt;yield&lt;/code&gt; . El valor proporcionado en esta variante corresponde a la expresi&amp;oacute;n que se pasa a &lt;code&gt;yield&lt;/code&gt; y permite a los generadores proporcionar un valor cada vez que ceden.</target>
        </trans-unit>
        <trans-unit id="90c88a5ca708244c3219f050c7309e58bf365755" translate="yes" xml:space="preserve">
          <source>This state indicates that a generator has finished execution with the provided value. Once a generator has returned &lt;code&gt;Complete&lt;/code&gt; it is considered a programmer error to call &lt;code&gt;resume&lt;/code&gt; again.</source>
          <target state="translated">Este estado indica que un generador ha finalizado la ejecuci&amp;oacute;n con el valor proporcionado. Una vez que un generador ha devuelto &lt;code&gt;Complete&lt;/code&gt; , se considera un error del programador &lt;code&gt;resume&lt;/code&gt; a llamar a resume .</target>
        </trans-unit>
        <trans-unit id="7be578f8354e75e786ae7f8a72194e570efdeae6" translate="yes" xml:space="preserve">
          <source>This stream will be ignored. This is the equivalent of attaching the stream to &lt;code&gt;/dev/null&lt;/code&gt;</source>
          <target state="translated">Esta secuencia se ignorar&amp;aacute;. Este es el equivalente a adjuntar la transmisi&amp;oacute;n a &lt;code&gt;/dev/null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="86aaaf1ade8618d076dfddfcf43a493fbd9d9208" translate="yes" xml:space="preserve">
          <source>This stream will be ignored. This is the equivalent of attaching the stream to &lt;code&gt;/dev/null&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="047e86b07f343619951ab342d709e9864cc54c3d" translate="yes" xml:space="preserve">
          <source>This struct has one field, &lt;code&gt;part&lt;/code&gt;, that holds a string slice, which is a reference. As with generic data types, we declare the name of the generic lifetime parameter inside angle brackets after the name of the struct so we can use the lifetime parameter in the body of the struct definition. This annotation means an instance of &lt;code&gt;ImportantExcerpt&lt;/code&gt; can&amp;rsquo;t outlive the reference it holds in its &lt;code&gt;part&lt;/code&gt; field.</source>
          <target state="translated">Esta estructura tiene un campo, &lt;code&gt;part&lt;/code&gt; e , que contiene un segmento de cadena, que es una referencia. Al igual que con los tipos de datos gen&amp;eacute;ricos, declaramos el nombre del par&amp;aacute;metro de vida &amp;uacute;til gen&amp;eacute;rico entre par&amp;eacute;ntesis angulares despu&amp;eacute;s del nombre de la estructura para que podamos usar el par&amp;aacute;metro de vida &amp;uacute;til en el cuerpo de la definici&amp;oacute;n de la estructura. Esta anotaci&amp;oacute;n significa que una instancia de &lt;code&gt;ImportantExcerpt&lt;/code&gt; no puede sobrevivir a la referencia que contiene en su campo de &lt;code&gt;part&lt;/code&gt; e .</target>
        </trans-unit>
        <trans-unit id="035a190c93ffcb98a162f4a1c124850fba76f70b" translate="yes" xml:space="preserve">
          <source>This struct has the same layout as types like &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt; and &lt;code&gt;Box&amp;lt;dyn AnotherTrait&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Esta estructura tiene el mismo dise&amp;ntilde;o que tipos como &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt; y &lt;code&gt;Box&amp;lt;dyn AnotherTrait&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8bcde4812fcc7ef55a0760fedbc39c027f9accb6" translate="yes" xml:space="preserve">
          <source>This struct has the same layout as types like &lt;code&gt;&amp;amp;dyn SomeTrait&lt;/code&gt; and &lt;code&gt;Box&amp;lt;dyn AnotherTrait&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78fc6455134464feceba11cc2db121b5a8d643b0" translate="yes" xml:space="preserve">
          <source>This struct is a helper to be used with functions like &lt;a href=&quot;../vec/struct.vec#method.sort_by_key&quot;&gt;&lt;code&gt;Vec::sort_by_key&lt;/code&gt;&lt;/a&gt; and can be used to reverse order a part of a key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="698bb1f1506a6aa8b90b6f64dc7e32c0c5091a12" translate="yes" xml:space="preserve">
          <source>This struct is a helper to be used with functions like &lt;code&gt;Vec::sort_by_key&lt;/code&gt; and can be used to reverse order a part of a key.</source>
          <target state="translated">Esta estructura es un ayudante que se utiliza con funciones como &lt;code&gt;Vec::sort_by_key&lt;/code&gt; y se puede utilizar para invertir el orden de una parte de una clave.</target>
        </trans-unit>
        <trans-unit id="84ced59217a045f0ae6136d2f9bd0162d392046f" translate="yes" xml:space="preserve">
          <source>This struct is created by &lt;a href=&quot;fn.args&quot;&gt;&lt;code&gt;env::args()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="421112f55866033bf937c2c2104c004765f83d6c" translate="yes" xml:space="preserve">
          <source>This struct is created by &lt;a href=&quot;fn.args_os&quot;&gt;&lt;code&gt;env::args_os()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d98990c007f08843ac1df1a07fad048ba02e034" translate="yes" xml:space="preserve">
          <source>This struct is created by &lt;a href=&quot;struct.command#method.get_args&quot;&gt;&lt;code&gt;Command::get_args&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c34405b53d7303b0dec8e54e6aa5a0abefbaa23c" translate="yes" xml:space="preserve">
          <source>This struct is created by &lt;a href=&quot;struct.command#method.get_envs&quot;&gt;&lt;code&gt;Command::get_envs&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2147718c894a448fcb5bace3573d8c66021b6ecf" translate="yes" xml:space="preserve">
          <source>This struct is created by &lt;a href=&quot;struct.vec#method.drain_filter&quot;&gt;&lt;code&gt;Vec::drain_filter&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b56bd91b0140c9f3d261bb2e7de1a84ee87136c" translate="yes" xml:space="preserve">
          <source>This struct is created by &lt;a href=&quot;struct.vec#method.splice&quot;&gt;&lt;code&gt;Vec::splice()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b94fdb25d3a1999fbb00df483466c3f3ad93974" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../iter/trait.intoiterator#tymethod.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; (provided by the &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; trait).</source>
          <target state="translated">Esta estructura es creada por el m&amp;eacute;todo &lt;a href=&quot;../iter/trait.intoiterator#tymethod.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; &lt;/a&gt; en &lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; (proporcionado por el rasgo &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0f993739b1a6e12d97f61853ab3a7aeead8ab4b9" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.array_chunks&quot;&gt;&lt;code&gt;array_chunks&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="306d58f57f3d10dc00f2031814b48c48929d8df3" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.array_chunks_mut&quot;&gt;&lt;code&gt;array_chunks_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f3c9f948ac0eb252b070770390b8ad86aa3b895" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.array_windows&quot;&gt;&lt;code&gt;array_windows&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dd8330957d499a2a2bc9ec6116864588108859d" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.chunks&quot;&gt;&lt;code&gt;chunks&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">Esta estructura se crea mediante el m&amp;eacute;todo &lt;a href=&quot;../primitive.slice#method.chunks&quot;&gt; &lt;code&gt;chunks&lt;/code&gt; &lt;/a&gt; en &lt;a href=&quot;../primitive.slice&quot;&gt;cortes&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f546acf131aa1e22a602b9ef3fb82d4387eee8e" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.chunks_exact&quot;&gt;&lt;code&gt;chunks_exact&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">Esta estructura es creada por el m&amp;eacute;todo &lt;a href=&quot;../primitive.slice#method.chunks_exact&quot;&gt; &lt;code&gt;chunks_exact&lt;/code&gt; &lt;/a&gt; en &lt;a href=&quot;../primitive.slice&quot;&gt;cortes&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e45db796c91b4ce48eb20085844caa57f6053703" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.chunks_exact_mut&quot;&gt;&lt;code&gt;chunks_exact_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">Esta estructura es creada por el m&amp;eacute;todo &lt;a href=&quot;../primitive.slice#method.chunks_exact_mut&quot;&gt; &lt;code&gt;chunks_exact_mut&lt;/code&gt; &lt;/a&gt; en &lt;a href=&quot;../primitive.slice&quot;&gt;cortes&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4164f449a467d7ed1b48f5a88a1f8a74fb26a190" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.chunks_mut&quot;&gt;&lt;code&gt;chunks_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">Esta estructura es creada por el m&amp;eacute;todo &lt;a href=&quot;../primitive.slice#method.chunks_mut&quot;&gt; &lt;code&gt;chunks_mut&lt;/code&gt; &lt;/a&gt; en &lt;a href=&quot;../primitive.slice&quot;&gt;cortes&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="76b48770dc5ec192ca6962e1d7faa3bd68e942ab" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">Esta estructura se crea mediante el m&amp;eacute;todo &lt;a href=&quot;../primitive.slice#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt; en &lt;a href=&quot;../primitive.slice&quot;&gt;cortes&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7681a887be4ac8a42d7f0ef28706aee3c6323619" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.iter_mut&quot;&gt;&lt;code&gt;iter_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">Esta estructura es creada por el m&amp;eacute;todo &lt;a href=&quot;../primitive.slice#method.iter_mut&quot;&gt; &lt;code&gt;iter_mut&lt;/code&gt; &lt;/a&gt; en &lt;a href=&quot;../primitive.slice&quot;&gt;cortes&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="523facc9e10029a951175d54b1f37f2671749ed6" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rchunks&quot;&gt;&lt;code&gt;rchunks&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">Esta estructura se crea mediante el m&amp;eacute;todo &lt;a href=&quot;../primitive.slice#method.rchunks&quot;&gt; &lt;code&gt;rchunks&lt;/code&gt; &lt;/a&gt; en &lt;a href=&quot;../primitive.slice&quot;&gt;cortes&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7743c6e4ca6fc913a9f4d37b6de12a320056fa8b" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rchunks_exact&quot;&gt;&lt;code&gt;rchunks_exact&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">Esta estructura es creada por el m&amp;eacute;todo &lt;a href=&quot;../primitive.slice#method.rchunks_exact&quot;&gt; &lt;code&gt;rchunks_exact&lt;/code&gt; &lt;/a&gt; en &lt;a href=&quot;../primitive.slice&quot;&gt;cortes&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="82404af50a38a848751818c48976a9a56b795818" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rchunks_exact_mut&quot;&gt;&lt;code&gt;rchunks_exact_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">Esta estructura es creada por el m&amp;eacute;todo &lt;a href=&quot;../primitive.slice#method.rchunks_exact_mut&quot;&gt; &lt;code&gt;rchunks_exact_mut&lt;/code&gt; &lt;/a&gt; en &lt;a href=&quot;../primitive.slice&quot;&gt;cortes&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="711c0f689f1d3a75f7b5a1b1833bc925f8986127" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rchunks_mut&quot;&gt;&lt;code&gt;rchunks_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">Esta estructura es creada por el m&amp;eacute;todo &lt;a href=&quot;../primitive.slice#method.rchunks_mut&quot;&gt; &lt;code&gt;rchunks_mut&lt;/code&gt; &lt;/a&gt; en &lt;a href=&quot;../primitive.slice&quot;&gt;cortes&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5ffea197c31595a869becf274e9c9ef3509b405a" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rsplit&quot;&gt;&lt;code&gt;rsplit&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">Esta estructura se crea mediante el m&amp;eacute;todo &lt;a href=&quot;../primitive.slice#method.rsplit&quot;&gt; &lt;code&gt;rsplit&lt;/code&gt; &lt;/a&gt; en &lt;a href=&quot;../primitive.slice&quot;&gt;cortes&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a28e12c215b6246a69d2f856da858d720de99619" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rsplit_mut&quot;&gt;&lt;code&gt;rsplit_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">Esta estructura es creada por el m&amp;eacute;todo &lt;a href=&quot;../primitive.slice#method.rsplit_mut&quot;&gt; &lt;code&gt;rsplit_mut&lt;/code&gt; &lt;/a&gt; en &lt;a href=&quot;../primitive.slice&quot;&gt;cortes&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e1ddb16a3352ab0f837d4fac934c98e22db158e5" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rsplitn&quot;&gt;&lt;code&gt;rsplitn&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">Esta estructura se crea mediante el m&amp;eacute;todo &lt;a href=&quot;../primitive.slice#method.rsplitn&quot;&gt; &lt;code&gt;rsplitn&lt;/code&gt; &lt;/a&gt; en &lt;a href=&quot;../primitive.slice&quot;&gt;cortes&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2305be064f2e36144fd442bf726fd4dd5a160216" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rsplitn_mut&quot;&gt;&lt;code&gt;rsplitn_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">Esta estructura es creada por el m&amp;eacute;todo &lt;a href=&quot;../primitive.slice#method.rsplitn_mut&quot;&gt; &lt;code&gt;rsplitn_mut&lt;/code&gt; &lt;/a&gt; en &lt;a href=&quot;../primitive.slice&quot;&gt;cortes&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d2c4405dee882e98a94c3681ae8ce615cfcc3f7" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.split&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">Esta estructura se crea mediante el m&amp;eacute;todo &lt;a href=&quot;../primitive.slice#method.split&quot;&gt; &lt;code&gt;split&lt;/code&gt; &lt;/a&gt; en &lt;a href=&quot;../primitive.slice&quot;&gt;cortes&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="abdc8d3421db5241b7ca4544a7b51d6159d67e49" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.split_mut&quot;&gt;&lt;code&gt;split_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">Esta estructura es creada por el m&amp;eacute;todo &lt;a href=&quot;../primitive.slice#method.split_mut&quot;&gt; &lt;code&gt;split_mut&lt;/code&gt; &lt;/a&gt; en &lt;a href=&quot;../primitive.slice&quot;&gt;cortes&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b850789ebec6b616db674ca7582ef014921e3e50" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.splitn&quot;&gt;&lt;code&gt;splitn&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">Esta estructura se crea mediante el m&amp;eacute;todo &lt;a href=&quot;../primitive.slice#method.splitn&quot;&gt; &lt;code&gt;splitn&lt;/code&gt; &lt;/a&gt; en &lt;a href=&quot;../primitive.slice&quot;&gt;cortes&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fcbac1aabe82a2c466b31106e57bd4691b6a4588" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.splitn_mut&quot;&gt;&lt;code&gt;splitn_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">Esta estructura es creada por el m&amp;eacute;todo &lt;a href=&quot;../primitive.slice#method.splitn_mut&quot;&gt; &lt;code&gt;splitn_mut&lt;/code&gt; &lt;/a&gt; en &lt;a href=&quot;../primitive.slice&quot;&gt;cortes&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4faa0b9911c89c4588e753ca1891a11cb9aac5c2" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.windows&quot;&gt;&lt;code&gt;windows&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">Esta estructura se crea mediante el m&amp;eacute;todo de &lt;a href=&quot;../primitive.slice#method.windows&quot;&gt; &lt;code&gt;windows&lt;/code&gt; &lt;/a&gt; en &lt;a href=&quot;../primitive.slice&quot;&gt;cortes&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="972c0f2531dd3e046ad902a7f6f569ef9de9571e" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">Esta estructura es creada por el m&amp;eacute;todo &lt;a href=&quot;../primitive.str#method.bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; en &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; . Consulte su documentaci&amp;oacute;n para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9dc716c653425077e3bf50725d3ddc775e25fe94" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.char_indices&quot;&gt;&lt;code&gt;char_indices&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">Esta estructura es creada por el m&amp;eacute;todo &lt;a href=&quot;../primitive.str#method.char_indices&quot;&gt; &lt;code&gt;char_indices&lt;/code&gt; &lt;/a&gt; en &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; . Consulte su documentaci&amp;oacute;n para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="607ded9325aedcb5c140c227e32c8ad28d5439d9" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.chars&quot;&gt;&lt;code&gt;chars&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">Esta estructura se crea mediante el m&amp;eacute;todo &lt;a href=&quot;../primitive.str#method.chars&quot;&gt; &lt;code&gt;chars&lt;/code&gt; &lt;/a&gt; en &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; . Consulte su documentaci&amp;oacute;n para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="eb31472d0cae7541e173fe527a7087a142820c04" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.encode_utf16&quot;&gt;&lt;code&gt;encode_utf16&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">Esta estructura es creada por el m&amp;eacute;todo &lt;a href=&quot;../primitive.str#method.encode_utf16&quot;&gt; &lt;code&gt;encode_utf16&lt;/code&gt; &lt;/a&gt; en &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; . Consulte su documentaci&amp;oacute;n para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e7c273a10bb61ef5da70d27b34dc57f12929254d" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.split_ascii_whitespace&quot;&gt;&lt;code&gt;split_ascii_whitespace&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">Esta estructura es creada por el m&amp;eacute;todo &lt;a href=&quot;../primitive.str#method.split_ascii_whitespace&quot;&gt; &lt;code&gt;split_ascii_whitespace&lt;/code&gt; &lt;/a&gt; en &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; . Consulte su documentaci&amp;oacute;n para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e335f4d066241eacb01d34cbc9797fdfc696dc6b" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.split_whitespace&quot;&gt;&lt;code&gt;split_whitespace&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">Esta estructura es creada por el m&amp;eacute;todo &lt;a href=&quot;../primitive.str#method.split_whitespace&quot;&gt; &lt;code&gt;split_whitespace&lt;/code&gt; &lt;/a&gt; en &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; . Consulte su documentaci&amp;oacute;n para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f9cd50ffb5bf76be59d59fc2f81ddf738ff0464b" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;fn.args&quot;&gt;&lt;code&gt;std::env::args&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">Esta estructura es creada por la funci&amp;oacute;n &lt;a href=&quot;fn.args&quot;&gt; &lt;code&gt;std::env::args&lt;/code&gt; &lt;/a&gt; . Consulte su documentaci&amp;oacute;n para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="0ec39f7b0daa2776e166f7fac0653e5c7c5e4333" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;fn.args_os&quot;&gt;&lt;code&gt;std::env::args_os&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">Esta estructura es creada por la funci&amp;oacute;n &lt;a href=&quot;fn.args_os&quot;&gt; &lt;code&gt;std::env::args_os&lt;/code&gt; &lt;/a&gt; . Consulte su documentaci&amp;oacute;n para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d49df01529faa1803ee9ac5934efa956bfb59ca5" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;struct.string#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">Esta estructura se crea mediante el m&amp;eacute;todo de &lt;a href=&quot;struct.string#method.drain&quot;&gt; &lt;code&gt;drain&lt;/code&gt; &lt;/a&gt; en &lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; . Consulte su documentaci&amp;oacute;n para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7821d89ece3dc45805333802521c4ece28a6ec77" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;struct.vec#method.splice&quot;&gt;&lt;code&gt;splice()&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">Esta estructura es creada por el m&amp;eacute;todo &lt;a href=&quot;struct.vec#method.splice&quot;&gt; &lt;code&gt;splice()&lt;/code&gt; &lt;/a&gt; en &lt;a href=&quot;struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; . Consulte su documentaci&amp;oacute;n para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="df074a53b5359b4dd926d5ab8c21cb3fdb8391e4" translate="yes" xml:space="preserve">
          <source>This struct is created with the &lt;a href=&quot;../primitive.str#method.lines&quot;&gt;&lt;code&gt;lines&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">Esta estructura se crea con el m&amp;eacute;todo &lt;a href=&quot;../primitive.str#method.lines&quot;&gt; &lt;code&gt;lines&lt;/code&gt; &lt;/a&gt; en &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; . Consulte su documentaci&amp;oacute;n para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="5a1492f5f04561e29bfe6f623f2dc30782a50bbf" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;fn.empty&quot;&gt;&lt;code&gt;empty()&lt;/code&gt;&lt;/a&gt;. Please see the documentation of &lt;a href=&quot;fn.empty&quot;&gt;&lt;code&gt;empty()&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8df7525ac9b1331bb51b51ca2c5df8a11c0a1c0e" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;fn.empty&quot;&gt;&lt;code&gt;empty&lt;/code&gt;&lt;/a&gt;. Please see the documentation of &lt;a href=&quot;fn.empty&quot;&gt;&lt;code&gt;empty()&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">Esta estructura generalmente se crea llamando a &lt;a href=&quot;fn.empty&quot;&gt; &lt;code&gt;empty&lt;/code&gt; &lt;/a&gt; . Consulte la documentaci&amp;oacute;n de &lt;a href=&quot;fn.empty&quot;&gt; &lt;code&gt;empty()&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="8dc7e6b8159c36d037a08968dd41820bb2c65481" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;fn.repeat&quot;&gt;&lt;code&gt;repeat()&lt;/code&gt;&lt;/a&gt;. Please see the documentation of &lt;a href=&quot;fn.repeat&quot;&gt;&lt;code&gt;repeat()&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d0cc773f4b725ed1f190beeb33e3f1817949265" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;fn.repeat&quot;&gt;&lt;code&gt;repeat&lt;/code&gt;&lt;/a&gt;. Please see the documentation of &lt;code&gt;repeat()&lt;/code&gt; for more details.</source>
          <target state="translated">Esta estructura generalmente se crea llamando a &lt;a href=&quot;fn.repeat&quot;&gt; &lt;code&gt;repeat&lt;/code&gt; &lt;/a&gt; . Consulte la documentaci&amp;oacute;n de &lt;code&gt;repeat()&lt;/code&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="24b0eaa40ab28907590f0749ecb8c76a4046ae2e" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;fn.sink&quot;&gt;&lt;code&gt;sink&lt;/code&gt;&lt;/a&gt;. Please see the documentation of &lt;a href=&quot;fn.sink&quot;&gt;&lt;code&gt;sink()&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc05dce26bdc09f8fc488132c92d5215b0e0bb48" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;fn.sink&quot;&gt;&lt;code&gt;sink&lt;/code&gt;&lt;/a&gt;. Please see the documentation of &lt;code&gt;sink()&lt;/code&gt; for more details.</source>
          <target state="translated">Esta estructura generalmente se crea llamando al &lt;a href=&quot;fn.sink&quot;&gt; &lt;code&gt;sink&lt;/code&gt; &lt;/a&gt; . Consulte la documentaci&amp;oacute;n de &lt;code&gt;sink()&lt;/code&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="6405be6b1dfbc1fabe9afe38ed753782ffca52fa" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;trait.bufread#method.lines&quot;&gt;&lt;code&gt;lines&lt;/code&gt;&lt;/a&gt; on a &lt;code&gt;BufRead&lt;/code&gt;. Please see the documentation of &lt;a href=&quot;trait.bufread#method.lines&quot;&gt;&lt;code&gt;lines&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a732d552fb11922cbdd232738709d5ceaab3ab0" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;trait.bufread#method.lines&quot;&gt;&lt;code&gt;lines&lt;/code&gt;&lt;/a&gt; on a &lt;code&gt;BufRead&lt;/code&gt;. Please see the documentation of &lt;code&gt;lines()&lt;/code&gt; for more details.</source>
          <target state="translated">Esta estructura generalmente se crea llamando a &lt;a href=&quot;trait.bufread#method.lines&quot;&gt; &lt;code&gt;lines&lt;/code&gt; &lt;/a&gt; en un &lt;code&gt;BufRead&lt;/code&gt; . Consulte la documentaci&amp;oacute;n de las &lt;code&gt;lines()&lt;/code&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="f6120cd0b709f995e698179414e725d511642b6c" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;trait.bufread#method.split&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt; on a &lt;code&gt;BufRead&lt;/code&gt;. Please see the documentation of &lt;a href=&quot;trait.bufread#method.split&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57521da9d072a5a75b7ef81a11e1941632c07769" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;trait.bufread#method.split&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt; on a &lt;code&gt;BufRead&lt;/code&gt;. Please see the documentation of &lt;code&gt;split()&lt;/code&gt; for more details.</source>
          <target state="translated">Esta estructura generalmente se crea llamando a &lt;a href=&quot;trait.bufread#method.split&quot;&gt; &lt;code&gt;split&lt;/code&gt; &lt;/a&gt; en un &lt;code&gt;BufRead&lt;/code&gt; . Consulte la documentaci&amp;oacute;n de &lt;code&gt;split()&lt;/code&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="e1deb8df82a06cf7e25723eca2d9b3c3500c212f" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;trait.read#method.bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; on a reader. Please see the documentation of &lt;a href=&quot;trait.read#method.bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">Esta estructura generalmente se crea llamando a &lt;a href=&quot;trait.read#method.bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; en un lector. Consulte la documentaci&amp;oacute;n de &lt;a href=&quot;trait.read#method.bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="137e3be8282a7112c63c8d5b6052cbdcefad663e" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;trait.read#method.chain&quot;&gt;&lt;code&gt;chain&lt;/code&gt;&lt;/a&gt; on a reader. Please see the documentation of &lt;a href=&quot;trait.read#method.chain&quot;&gt;&lt;code&gt;chain&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">Esta estructura generalmente se crea llamando a la &lt;a href=&quot;trait.read#method.chain&quot;&gt; &lt;code&gt;chain&lt;/code&gt; &lt;/a&gt; en un lector. Consulte la documentaci&amp;oacute;n de la &lt;a href=&quot;trait.read#method.chain&quot;&gt; &lt;code&gt;chain&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="047a4ebdecfd5e2897b79c73996497448f62e8a9" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;trait.read#method.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt; on a reader. Please see the documentation of &lt;a href=&quot;trait.read#method.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">Esta estructura generalmente se crea llamando a &lt;a href=&quot;trait.read#method.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; en un lector. Consulte la documentaci&amp;oacute;n de la &lt;a href=&quot;trait.read#method.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="a7395af01bd4a50c6dfb48da98c0430b70139ec6" translate="yes" xml:space="preserve">
          <source>This struct is used in the &lt;a href=&quot;struct.child#structfield.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt; field on &lt;a href=&quot;struct.child&quot;&gt;&lt;code&gt;Child&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esta estructura se usa en el campo &lt;a href=&quot;struct.child#structfield.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt; en &lt;a href=&quot;struct.child&quot;&gt; &lt;code&gt;Child&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="45d9e2d1a8753395175acd043fb98b742fa0c7b1" translate="yes" xml:space="preserve">
          <source>This struct is used in the &lt;a href=&quot;struct.child#structfield.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt; field on &lt;a href=&quot;struct.child&quot;&gt;&lt;code&gt;Child&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esta estructura se usa en el campo &lt;a href=&quot;struct.child#structfield.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt; en &lt;a href=&quot;struct.child&quot;&gt; &lt;code&gt;Child&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a0e77c1cd6c1d6c1011116ad5fd2720b269732ff" translate="yes" xml:space="preserve">
          <source>This struct is used in the &lt;a href=&quot;struct.child#structfield.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; field on &lt;a href=&quot;struct.child&quot;&gt;&lt;code&gt;Child&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esta estructura se usa en el campo &lt;a href=&quot;struct.child#structfield.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; en &lt;a href=&quot;struct.child&quot;&gt; &lt;code&gt;Child&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c78ae69a32ba5f8bbcb17b7abd5cf067694229aa" translate="yes" xml:space="preserve">
          <source>This structure is created by &lt;a href=&quot;fn.split_paths&quot;&gt;&lt;code&gt;env::split_paths()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c446cff104f615e56344282bb3df53e735cf1fdb" translate="yes" xml:space="preserve">
          <source>This structure is created by &lt;a href=&quot;fn.vars&quot;&gt;&lt;code&gt;env::vars()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64b2bbf5e29e3f661a1f1f7db6c4d0d2f77172fd" translate="yes" xml:space="preserve">
          <source>This structure is created by &lt;a href=&quot;fn.vars_os&quot;&gt;&lt;code&gt;env::vars_os()&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31822658b6e7064c66c1754cfb13fa7a6a0cb6b1" translate="yes" xml:space="preserve">
          <source>This structure is created by &lt;a href=&quot;struct.panicinfo#method.location&quot;&gt;&lt;code&gt;PanicInfo::location()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c3b3caed2d7f9ef42e3b6090d38c4f7a8f595c9" translate="yes" xml:space="preserve">
          <source>This structure is created by the &lt;a href=&quot;fn.split_paths&quot;&gt;&lt;code&gt;std::env::split_paths&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">Esta estructura es creada por la funci&amp;oacute;n &lt;a href=&quot;fn.split_paths&quot;&gt; &lt;code&gt;std::env::split_paths&lt;/code&gt; &lt;/a&gt; . Consulte su documentaci&amp;oacute;n para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="763fd05613c0342afc387ef243d7b2fcab0e70ec" translate="yes" xml:space="preserve">
          <source>This structure is created by the &lt;a href=&quot;fn.vars&quot;&gt;&lt;code&gt;std::env::vars&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">Esta estructura es creada por la funci&amp;oacute;n &lt;a href=&quot;fn.vars&quot;&gt; &lt;code&gt;std::env::vars&lt;/code&gt; &lt;/a&gt; . Consulte su documentaci&amp;oacute;n para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="aeb9c6eb7e34424ffff3b1a0d353cc1e7da71bbe" translate="yes" xml:space="preserve">
          <source>This structure is created by the &lt;a href=&quot;fn.vars_os&quot;&gt;&lt;code&gt;std::env::vars_os&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">Esta estructura es creada por la funci&amp;oacute;n &lt;a href=&quot;fn.vars_os&quot;&gt; &lt;code&gt;std::env::vars_os&lt;/code&gt; &lt;/a&gt; . Consulte su documentaci&amp;oacute;n para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="49ca05175d2c16657b8d4f1e47558a6913b20cd1" translate="yes" xml:space="preserve">
          <source>This structure is created by the &lt;a href=&quot;struct.mutex#method.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.mutex#method.try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt; methods on &lt;a href=&quot;struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esta estructura es creada por los m&amp;eacute;todos &lt;a href=&quot;struct.mutex#method.lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;struct.mutex#method.try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; &lt;/a&gt; en &lt;a href=&quot;struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4a6f95cf45a5bcc128684cebfbd05d3880902f8d" translate="yes" xml:space="preserve">
          <source>This structure is created by the &lt;a href=&quot;struct.panicinfo#method.location&quot;&gt;&lt;code&gt;location&lt;/code&gt;&lt;/a&gt; method of &lt;a href=&quot;struct.panicinfo&quot;&gt;&lt;code&gt;PanicInfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esta estructura se crea mediante el m&amp;eacute;todo de &lt;a href=&quot;struct.panicinfo#method.location&quot;&gt; &lt;code&gt;location&lt;/code&gt; &lt;/a&gt; de &lt;a href=&quot;struct.panicinfo&quot;&gt; &lt;code&gt;PanicInfo&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0ba43b358d72c0f70633e8ff8edbb3820ba26ae8" translate="yes" xml:space="preserve">
          <source>This structure is created by the &lt;a href=&quot;struct.rwlock#method.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.rwlock#method.try_read&quot;&gt;&lt;code&gt;try_read&lt;/code&gt;&lt;/a&gt; methods on &lt;a href=&quot;struct.rwlock&quot;&gt;&lt;code&gt;RwLock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esta estructura es creada por los m&amp;eacute;todos &lt;a href=&quot;struct.rwlock#method.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;struct.rwlock#method.try_read&quot;&gt; &lt;code&gt;try_read&lt;/code&gt; &lt;/a&gt; en &lt;a href=&quot;struct.rwlock&quot;&gt; &lt;code&gt;RwLock&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="37c48c912f9cb67a5286393a48bcb5981e2a346b" translate="yes" xml:space="preserve">
          <source>This structure is created by the &lt;a href=&quot;struct.rwlock#method.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.rwlock#method.try_write&quot;&gt;&lt;code&gt;try_write&lt;/code&gt;&lt;/a&gt; methods on &lt;a href=&quot;struct.rwlock&quot;&gt;&lt;code&gt;RwLock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esta estructura es creada por los m&amp;eacute;todos &lt;a href=&quot;struct.rwlock#method.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;struct.rwlock#method.try_write&quot;&gt; &lt;code&gt;try_write&lt;/code&gt; &lt;/a&gt; en &lt;a href=&quot;struct.rwlock&quot;&gt; &lt;code&gt;RwLock&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e1b64e1281a00cf103b0dc5f24e83df69f16eb4c" translate="yes" xml:space="preserve">
          <source>This structure is returned from the &lt;a href=&quot;fn.metadata&quot;&gt;&lt;code&gt;metadata&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;fn.symlink_metadata&quot;&gt;&lt;code&gt;symlink_metadata&lt;/code&gt;&lt;/a&gt; function or method and represents known metadata about a file such as its permissions, size, modification times, etc.</source>
          <target state="translated">Esta estructura se devuelve de la funci&amp;oacute;n o m&amp;eacute;todo de &lt;a href=&quot;fn.metadata&quot;&gt; &lt;code&gt;metadata&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;fn.symlink_metadata&quot;&gt; &lt;code&gt;symlink_metadata&lt;/code&gt; &lt;/a&gt; y representa metadatos conocidos sobre un archivo, como sus permisos, tama&amp;ntilde;o, tiempos de modificaci&amp;oacute;n, etc.</target>
        </trans-unit>
        <trans-unit id="a90c6bba494b412af840afa94f3d4327e4e6ac5c" translate="yes" xml:space="preserve">
          <source>This structure is used to represent and manage child processes. A child process is created via the &lt;a href=&quot;struct.command&quot;&gt;&lt;code&gt;Command&lt;/code&gt;&lt;/a&gt; struct, which configures the spawning process and can itself be constructed using a builder-style interface.</source>
          <target state="translated">Esta estructura se utiliza para representar y gestionar procesos secundarios. Se crea un proceso hijo a trav&amp;eacute;s de la estructura &lt;a href=&quot;struct.command&quot;&gt; &lt;code&gt;Command&lt;/code&gt; &lt;/a&gt; , que configura el proceso de generaci&amp;oacute;n y se puede construir mediante una interfaz de estilo constructor.</target>
        </trans-unit>
        <trans-unit id="21f163fe5401a35062783545bd12a7fe23e7c94b" translate="yes" xml:space="preserve">
          <source>This structure represents a safely precompiled version of a format string and its arguments. This cannot be generated at runtime because it cannot safely be done, so no constructors are given and the fields are private to prevent modification.</source>
          <target state="translated">Esta estructura representa una versión precompilada segura de una cadena de formato y sus argumentos.No se puede generar en tiempo de ejecución porque no se puede hacer con seguridad,por lo que no se dan constructores y los campos son privados para evitar su modificación.</target>
        </trans-unit>
        <trans-unit id="0adc11971ab38c810ebf2248ed011aa51008e125" translate="yes" xml:space="preserve">
          <source>This suffers the same restrictions and reasoning as implementing &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;, see there for details.</source>
          <target state="translated">Esto sufre las mismas restricciones y razonamiento que la implementaci&amp;oacute;n de &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; , consulte all&amp;iacute; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="6f2d7a21c40fec745cf07aea5a678e00b27d1d6d" translate="yes" xml:space="preserve">
          <source>This sums up every integer in a vector, rejecting the sum if a negative element is encountered:</source>
          <target state="translated">Esto resume cada entero en un vector,rechazando la suma si se encuentra un elemento negativo:</target>
        </trans-unit>
        <trans-unit id="3b38ed7b25f08579fef293fd7b9ae8fd73fe03b3" translate="yes" xml:space="preserve">
          <source>This sums up the position of the character 'a' in a vector of strings, if a word did not have the character 'a' the operation returns &lt;code&gt;None&lt;/code&gt;:</source>
          <target state="translated">Esto resume la posici&amp;oacute;n del car&amp;aacute;cter 'a' en un vector de cadenas, si una palabra no ten&amp;iacute;a el car&amp;aacute;cter 'a' la operaci&amp;oacute;n devuelve &lt;code&gt;None&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b7b5e0845ef8959eb8d683ea0316747264243c8d" translate="yes" xml:space="preserve">
          <source>This syntax seems comparable to that of generics. So why not just define the &lt;code&gt;Iterator&lt;/code&gt; trait with generics, as shown in Listing 19-13?</source>
          <target state="translated">Esta sintaxis parece comparable a la de los gen&amp;eacute;ricos. Entonces, &amp;iquest;por qu&amp;eacute; no definir el rasgo &lt;code&gt;Iterator&lt;/code&gt; con gen&amp;eacute;ricos, como se muestra en el Listado 19-13?</target>
        </trans-unit>
        <trans-unit id="2e389d45d6848629d7d0a8141a0d2eefc943d3d3" translate="yes" xml:space="preserve">
          <source>This syntax should look familiar from our discussions on how to define traits in Chapter 10. Next comes some new syntax: Listing 17-4 defines a struct named &lt;code&gt;Screen&lt;/code&gt; that holds a vector named &lt;code&gt;components&lt;/code&gt;. This vector is of type &lt;code&gt;Box&amp;lt;dyn Draw&amp;gt;&lt;/code&gt;, which is a trait object; it&amp;rsquo;s a stand-in for any type inside a &lt;code&gt;Box&lt;/code&gt; that implements the &lt;code&gt;Draw&lt;/code&gt; trait.</source>
          <target state="translated">Esta sintaxis deber&amp;iacute;a resultar familiar en nuestras discusiones sobre c&amp;oacute;mo definir rasgos en el Cap&amp;iacute;tulo 10. Luego viene una nueva sintaxis: El Listado 17-4 define una estructura llamada &lt;code&gt;Screen&lt;/code&gt; que contiene un vector llamado &lt;code&gt;components&lt;/code&gt; . Este vector es de tipo &lt;code&gt;Box&amp;lt;dyn Draw&amp;gt;&lt;/code&gt; , que es un objeto de rasgo; es un sustituto de cualquier tipo dentro de una &lt;code&gt;Box&lt;/code&gt; que implementa el rasgo &lt;code&gt;Draw&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="157ddb41dd66b7335f1aa23c99d8dc3500848966" translate="yes" xml:space="preserve">
          <source>This syntax specifies that we want the X type from MyTrait, as made concrete in MyStruct. The reason that we cannot simply use &lt;code&gt;MyStruct::X&lt;/code&gt; is that MyStruct might implement two different traits with identically-named associated types. This syntax allows disambiguation between the two.</source>
          <target state="translated">Esta sintaxis especifica que queremos el tipo X de MyTrait, como se concret&amp;oacute; en MyStruct. La raz&amp;oacute;n por la que no podemos simplemente usar &lt;code&gt;MyStruct::X&lt;/code&gt; es que MyStruct podr&amp;iacute;a implementar dos rasgos diferentes con tipos asociados con nombres id&amp;eacute;nticos. Esta sintaxis permite la desambiguaci&amp;oacute;n entre los dos.</target>
        </trans-unit>
        <trans-unit id="6be1eead3ada3953477a6dbe51c912612a272761" translate="yes" xml:space="preserve">
          <source>This technique is just one of many ways to improve the throughput of a web server. Other options you might explore are the fork/join model and the single-threaded async I/O model. If you&amp;rsquo;re interested in this topic, you can read more about other solutions and try to implement them in Rust; with a low-level language like Rust, all of these options are possible.</source>
          <target state="translated">Esta t&amp;eacute;cnica es solo una de las muchas formas de mejorar el rendimiento de un servidor web. Otras opciones que puede explorar son el modelo de bifurcaci&amp;oacute;n / uni&amp;oacute;n y el modelo de E / S as&amp;iacute;ncrona de un solo subproceso. Si est&amp;aacute; interesado en este tema, puede leer m&amp;aacute;s sobre otras soluciones e intentar implementarlas en Rust; con un lenguaje de bajo nivel como Rust, todas estas opciones son posibles.</target>
        </trans-unit>
        <trans-unit id="731e8ea356524b34210881afc68de295a0e37bff" translate="yes" xml:space="preserve">
          <source>This technique is pretty neat! By using &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, we have an outwardly immutable &lt;code&gt;List&lt;/code&gt; value. But we can use the methods on &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; that provide access to its interior mutability so we can modify our data when we need to. The runtime checks of the borrowing rules protect us from data races, and it&amp;rsquo;s sometimes worth trading a bit of speed for this flexibility in our data structures.</source>
          <target state="translated">&amp;iexcl;Esta t&amp;eacute;cnica es bastante ingeniosa! Al usar &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; , tenemos un valor &lt;code&gt;List&lt;/code&gt; aparentemente inmutable . Pero podemos usar los m&amp;eacute;todos en &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; que brindan acceso a su mutabilidad interior para que podamos modificar nuestros datos cuando sea necesario. Las comprobaciones en tiempo de ejecuci&amp;oacute;n de las reglas de pr&amp;eacute;stamo nos protegen de las carreras de datos y, a veces, vale la pena cambiar un poco de velocidad por esta flexibilidad en nuestras estructuras de datos.</target>
        </trans-unit>
        <trans-unit id="9283a8a2efae9e1f40a1d640e7fbf1f6c7025c52" translate="yes" xml:space="preserve">
          <source>This tells us the return type of the &lt;code&gt;File::open&lt;/code&gt; function is a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;. The generic parameter &lt;code&gt;T&lt;/code&gt; has been filled in here with the type of the success value, &lt;code&gt;std::fs::File&lt;/code&gt;, which is a file handle. The type of &lt;code&gt;E&lt;/code&gt; used in the error value is &lt;code&gt;std::io::Error&lt;/code&gt;.</source>
          <target state="translated">Esto nos dice que el tipo de retorno de la funci&amp;oacute;n &lt;code&gt;File::open&lt;/code&gt; es un &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; . El par&amp;aacute;metro gen&amp;eacute;rico &lt;code&gt;T&lt;/code&gt; se ha completado aqu&amp;iacute; con el tipo de valor de &amp;eacute;xito, &lt;code&gt;std::fs::File&lt;/code&gt; , que es un identificador de archivo. El tipo de &lt;code&gt;E&lt;/code&gt; utilizado en el valor de error es &lt;code&gt;std::io::Error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1369ebc6a80c7328fbe0b2bd897392d17a8945de" translate="yes" xml:space="preserve">
          <source>This test code defines a &lt;code&gt;MockMessenger&lt;/code&gt; struct that has a &lt;code&gt;sent_messages&lt;/code&gt; field with a &lt;code&gt;Vec&lt;/code&gt; of &lt;code&gt;String&lt;/code&gt; values to keep track of the messages it&amp;rsquo;s told to send. We also define an associated function &lt;code&gt;new&lt;/code&gt; to make it convenient to create new &lt;code&gt;MockMessenger&lt;/code&gt; values that start with an empty list of messages. We then implement the &lt;code&gt;Messenger&lt;/code&gt; trait for &lt;code&gt;MockMessenger&lt;/code&gt; so we can give a &lt;code&gt;MockMessenger&lt;/code&gt; to a &lt;code&gt;LimitTracker&lt;/code&gt;. In the definition of the &lt;code&gt;send&lt;/code&gt; method, we take the message passed in as a parameter and store it in the &lt;code&gt;MockMessenger&lt;/code&gt; list of &lt;code&gt;sent_messages&lt;/code&gt;.</source>
          <target state="translated">Este c&amp;oacute;digo de prueba define una estructura &lt;code&gt;MockMessenger&lt;/code&gt; que tiene un campo &lt;code&gt;sent_messages&lt;/code&gt; con un &lt;code&gt;Vec&lt;/code&gt; de valores &lt;code&gt;String&lt;/code&gt; para realizar un seguimiento de los mensajes que se le indica que env&amp;iacute;e. Tambi&amp;eacute;n definimos una &lt;code&gt;new&lt;/code&gt; funci&amp;oacute;n asociada para que sea conveniente crear nuevos valores de &lt;code&gt;MockMessenger&lt;/code&gt; que comiencen con una lista vac&amp;iacute;a de mensajes. Luego implementamos el rasgo &lt;code&gt;Messenger&lt;/code&gt; para &lt;code&gt;MockMessenger&lt;/code&gt; para que podamos darle un &lt;code&gt;MockMessenger&lt;/code&gt; a un &lt;code&gt;LimitTracker&lt;/code&gt; . En la definici&amp;oacute;n del m&amp;eacute;todo de &lt;code&gt;send&lt;/code&gt; , tomamos el mensaje pasado como par&amp;aacute;metro y lo almacenamos en la lista &lt;code&gt;MockMessenger&lt;/code&gt; de &lt;code&gt;sent_messages&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf7bdfe2c080bcfbd294561ba32984ed7b6655c2" translate="yes" xml:space="preserve">
          <source>This test creates a new &lt;code&gt;Cacher&lt;/code&gt; instance with a closure that returns the value passed into it. We call the &lt;code&gt;value&lt;/code&gt; method on this &lt;code&gt;Cacher&lt;/code&gt; instance with an &lt;code&gt;arg&lt;/code&gt; value of 1 and then an &lt;code&gt;arg&lt;/code&gt; value of 2, and we expect the call to &lt;code&gt;value&lt;/code&gt; with the &lt;code&gt;arg&lt;/code&gt; value of 2 to return 2.</source>
          <target state="translated">Esta prueba crea una nueva instancia de &lt;code&gt;Cacher&lt;/code&gt; con un cierre que devuelve el valor que se le pas&amp;oacute;. Llamamos al m&amp;eacute;todo &lt;code&gt;value&lt;/code&gt; en esta instancia de &lt;code&gt;Cacher&lt;/code&gt; con un valor &lt;code&gt;arg&lt;/code&gt; de 1 y luego un valor &lt;code&gt;arg&lt;/code&gt; de 2, y esperamos que la llamada a &lt;code&gt;value&lt;/code&gt; con el valor &lt;code&gt;arg&lt;/code&gt; de 2 devuelva 2.</target>
        </trans-unit>
        <trans-unit id="72299afca54f19e85015cb228f6cdc67fc73f999" translate="yes" xml:space="preserve">
          <source>This test creates a new &lt;code&gt;Counter&lt;/code&gt; instance in the &lt;code&gt;counter&lt;/code&gt; variable and then calls &lt;code&gt;next&lt;/code&gt; repeatedly, verifying that we have implemented the behavior we want this iterator to have: returning the values from 1 to 5.</source>
          <target state="translated">Esta prueba crea una nueva instancia de &lt;code&gt;Counter&lt;/code&gt; en la variable de &lt;code&gt;counter&lt;/code&gt; y luego llama a &lt;code&gt;next&lt;/code&gt; repetidamente, verificando que hemos implementado el comportamiento que queremos que tenga este iterador: devolver los valores de 1 a 5.</target>
        </trans-unit>
        <trans-unit id="05dea38628c56d1ac2dee0da9506b8c1998c15fa" translate="yes" xml:space="preserve">
          <source>This test searches for the string &lt;code&gt;&quot;duct&quot;&lt;/code&gt;. The text we&amp;rsquo;re searching is three lines, only one of which contains &lt;code&gt;&quot;duct&quot;&lt;/code&gt;. We assert that the value returned from the &lt;code&gt;search&lt;/code&gt; function contains only the line we expect.</source>
          <target state="translated">Esta prueba busca la cadena &lt;code&gt;&quot;duct&quot;&lt;/code&gt; . El texto que estamos buscando es de tres l&amp;iacute;neas, de las cuales solo una contiene &lt;code&gt;&quot;duct&quot;&lt;/code&gt; . Afirmamos que el valor devuelto por la funci&amp;oacute;n de &lt;code&gt;search&lt;/code&gt; contiene solo la l&amp;iacute;nea que esperamos.</target>
        </trans-unit>
        <trans-unit id="ddca2fdf5e68d60216a77aaaba507a1415303561" translate="yes" xml:space="preserve">
          <source>This test will pass because the value we put in the &lt;code&gt;should_panic&lt;/code&gt; attribute&amp;rsquo;s &lt;code&gt;expected&lt;/code&gt; parameter is a substring of the message that the &lt;code&gt;Guess::new&lt;/code&gt; function panics with. We could have specified the entire panic message that we expect, which in this case would be &lt;code&gt;Guess value must be less than or equal to 100, got 200.&lt;/code&gt; What you choose to specify in the expected parameter for &lt;code&gt;should_panic&lt;/code&gt; depends on how much of the panic message is unique or dynamic and how precise you want your test to be. In this case, a substring of the panic message is enough to ensure that the code in the test function executes the &lt;code&gt;else if value &amp;gt; 100&lt;/code&gt; case.</source>
          <target state="translated">Esta prueba pasar&amp;aacute; porque el valor que pusimos en el par&amp;aacute;metro &lt;code&gt;expected&lt;/code&gt; del atributo &lt;code&gt;should_panic&lt;/code&gt; es una subcadena del mensaje con el que la funci&amp;oacute;n &lt;code&gt;Guess::new&lt;/code&gt; entra en p&amp;aacute;nico. Podr&amp;iacute;amos haber especificado todo el mensaje de p&amp;aacute;nico que esperamos, que en este caso ser&amp;iacute;a &lt;code&gt;Guess value must be less than or equal to 100, got 200.&lt;/code&gt; Lo que elija especificar en el par&amp;aacute;metro esperado para &lt;code&gt;should_panic&lt;/code&gt; depende de la cantidad de p&amp;aacute;nico el mensaje es &amp;uacute;nico o din&amp;aacute;mico y qu&amp;eacute; tan precisa desea que sea su prueba. En este caso, una subcadena del mensaje de p&amp;aacute;nico es suficiente para garantizar que el c&amp;oacute;digo en la funci&amp;oacute;n de prueba ejecute el &lt;code&gt;else if value &amp;gt; 100&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bbe227be9e7db744874fde49a6fb7f9f9cde2ed8" translate="yes" xml:space="preserve">
          <source>This text is available in &lt;a href=&quot;https://nostarch.com/rust&quot;&gt;paperback and ebook format from No Starch Press&lt;/a&gt;.</source>
          <target state="translated">Este texto est&amp;aacute; disponible en &lt;a href=&quot;https://nostarch.com/rust&quot;&gt;formato de libro de bolsillo y libro electr&amp;oacute;nico de No Starch Press&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="abaa655d972948c0991360be1b3331d77edb5df2" translate="yes" xml:space="preserve">
          <source>This time when we compile the code, we get a different set of errors:</source>
          <target state="translated">Esta vez,cuando compilamos el código,obtenemos un conjunto diferente de errores:</target>
        </trans-unit>
        <trans-unit id="ef45f877ddb3c6c79878e62a645c0f1bb5d754ab" translate="yes" xml:space="preserve">
          <source>This time when we run the &lt;code&gt;should_panic&lt;/code&gt; test, it will fail:</source>
          <target state="translated">Esta vez, cuando ejecutamos la prueba &lt;code&gt;should_panic&lt;/code&gt; , fallar&amp;aacute;:</target>
        </trans-unit>
        <trans-unit id="927ffba8c6b861ab1b3ffedb0e60fa4989110409" translate="yes" xml:space="preserve">
          <source>This time, before we create the first spawned thread, we call &lt;code&gt;clone&lt;/code&gt; on the sending end of the channel. This will give us a new sending handle we can pass to the first spawned thread. We pass the original sending end of the channel to a second spawned thread. This gives us two threads, each sending different messages to the receiving end of the channel.</source>
          <target state="translated">Esta vez, antes de crear el primer hilo generado, llamamos a &lt;code&gt;clone&lt;/code&gt; en el extremo de env&amp;iacute;o del canal. Esto nos dar&amp;aacute; un nuevo identificador de env&amp;iacute;o que podemos pasar al primer hilo generado. Pasamos el extremo de env&amp;iacute;o original del canal a un segundo hilo generado. Esto nos da dos hilos, cada uno enviando mensajes diferentes al extremo receptor del canal.</target>
        </trans-unit>
        <trans-unit id="03b02e99d0c7b36f56fe77cf1bc6781836989a07" translate="yes" xml:space="preserve">
          <source>This time, the spawned thread has a vector of strings that we want to send to the main thread. We iterate over them, sending each individually, and pause between each by calling the &lt;code&gt;thread::sleep&lt;/code&gt; function with a &lt;code&gt;Duration&lt;/code&gt; value of 1 second.</source>
          <target state="translated">Esta vez, el hilo generado tiene un vector de cadenas que queremos enviar al hilo principal. Los iteramos, enviamos cada uno individualmente y hacemos una pausa entre cada uno llamando a la funci&amp;oacute;n &lt;code&gt;thread::sleep&lt;/code&gt; con un valor de &lt;code&gt;Duration&lt;/code&gt; de 1 segundo.</target>
        </trans-unit>
        <trans-unit id="704e60202fcb30892563c7bc7f66fbb6decda49f" translate="yes" xml:space="preserve">
          <source>This trait allows constructing network objects like &lt;a href=&quot;struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.udpsocket&quot;&gt;&lt;code&gt;UdpSocket&lt;/code&gt;&lt;/a&gt; easily with values of various types for the bind/connection address. It is needed because sometimes one type is more appropriate than the other: for simple uses a string like &lt;code&gt;&quot;localhost:12345&quot;&lt;/code&gt; is much nicer than manual construction of the corresponding &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt;, but sometimes &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; value is &lt;em&gt;the&lt;/em&gt; main source of the address, and converting it to some other type (e.g., a string) just for it to be converted back to &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; in constructor methods is pointless.</source>
          <target state="translated">Este rasgo permite construir f&amp;aacute;cilmente objetos de red como &lt;a href=&quot;struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;struct.udpsocket&quot;&gt; &lt;code&gt;UdpSocket&lt;/code&gt; &lt;/a&gt; con valores de varios tipos para la direcci&amp;oacute;n de enlace / conexi&amp;oacute;n. Es necesario porque a veces un tipo es m&amp;aacute;s apropiado que el otro: para usos simples, una cadena como &lt;code&gt;&quot;localhost:12345&quot;&lt;/code&gt; es mucho m&amp;aacute;s agradable que la construcci&amp;oacute;n manual del correspondiente &lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt; , pero a veces el valor de &lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt; es &lt;em&gt;la&lt;/em&gt; fuente principal de la direcci&amp;oacute;n y la conversi&amp;oacute;n a alg&amp;uacute;n otro tipo (por ejemplo, una cadena) s&amp;oacute;lo para que se convierta de nuevo a &lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt; en los m&amp;eacute;todos de constructor no tiene sentido.</target>
        </trans-unit>
        <trans-unit id="f4c03571c99fa2a4a0d6d2bd73efa6856a353a75" translate="yes" xml:space="preserve">
          <source>This trait allows for partial equality, for types that do not have a full equivalence relation. For example, in floating point numbers &lt;code&gt;NaN != NaN&lt;/code&gt;, so floating point types implement &lt;code&gt;PartialEq&lt;/code&gt; but not &lt;a href=&quot;trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6796333a1773b86bb39aa9af35062f79738f2038" translate="yes" xml:space="preserve">
          <source>This trait allows for partial equality, for types that do not have a full equivalence relation. For example, in floating point numbers &lt;code&gt;NaN != NaN&lt;/code&gt;, so floating point types implement &lt;code&gt;PartialEq&lt;/code&gt; but not &lt;a href=&quot;trait.partialeq#tymethod.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1802ac1cfe1536c265ef2f2bdbe3a05ea51c03f9" translate="yes" xml:space="preserve">
          <source>This trait allows for partial equality, for types that do not have a full equivalence relation. For example, in floating point numbers &lt;code&gt;NaN != NaN&lt;/code&gt;, so floating point types implement &lt;code&gt;PartialEq&lt;/code&gt; but not &lt;code&gt;Eq&lt;/code&gt;.</source>
          <target state="translated">Este rasgo permite la igualdad parcial, para tipos que no tienen una relaci&amp;oacute;n de equivalencia completa. Por ejemplo, en n&amp;uacute;meros de coma flotante &lt;code&gt;NaN != NaN&lt;/code&gt; , los tipos de coma flotante implementan &lt;code&gt;PartialEq&lt;/code&gt; pero no &lt;code&gt;Eq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff1d61ee8b274d07d29615e751a57961b3d97e97" translate="yes" xml:space="preserve">
          <source>This trait can be used to create a &lt;a href=&quot;struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt;. An executor can define an implementation of this trait, and use that to construct a Waker to pass to the tasks that are executed on that executor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bebce9a7c84fca1499f5aca86035aeb53d64365" translate="yes" xml:space="preserve">
          <source>This trait can be used to implement other traits on fixed-size arrays without causing much metadata bloat.</source>
          <target state="translated">Este rasgo puede utilizarse para implementar otros rasgos en matrices de tamaño fijo sin causar mucha hinchazón de metadatos.</target>
        </trans-unit>
        <trans-unit id="45737752ce770a5a32320c65da9b598f29acafd8" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt; if all fields are &lt;code&gt;Clone&lt;/code&gt;. The &lt;code&gt;derive&lt;/code&gt;d implementation of &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; calls &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on each field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5800007da2c584795de3c7fc5ff71b96b272866c" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt; if all fields are &lt;code&gt;Clone&lt;/code&gt;. The &lt;code&gt;derive&lt;/code&gt;d implementation of &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; calls &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on each field.</source>
          <target state="translated">Este rasgo se puede usar con &lt;code&gt;#[derive]&lt;/code&gt; si todos los campos son &lt;code&gt;Clone&lt;/code&gt; . La &lt;code&gt;derive&lt;/code&gt; aplicaci&amp;oacute;n d del &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; llama &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; en cada campo.</target>
        </trans-unit>
        <trans-unit id="e6a77474d17602cdca329051113afe871aed6794" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt; if all fields implement &lt;code&gt;Debug&lt;/code&gt;. When &lt;code&gt;derive&lt;/code&gt;d for structs, it will use the name of the &lt;code&gt;struct&lt;/code&gt;, then &lt;code&gt;{&lt;/code&gt;, then a comma-separated list of each field's name and &lt;code&gt;Debug&lt;/code&gt; value, then &lt;code&gt;}&lt;/code&gt;. For &lt;code&gt;enum&lt;/code&gt;s, it will use the name of the variant and, if applicable, &lt;code&gt;(&lt;/code&gt;, then the &lt;code&gt;Debug&lt;/code&gt; values of the fields, then &lt;code&gt;)&lt;/code&gt;.</source>
          <target state="translated">Este rasgo se puede usar con &lt;code&gt;#[derive]&lt;/code&gt; si todos los campos implementan &lt;code&gt;Debug&lt;/code&gt; . Cuando &lt;code&gt;derive&lt;/code&gt; d para estructuras, usar&amp;aacute; el nombre de la &lt;code&gt;struct&lt;/code&gt; , luego &lt;code&gt;{&lt;/code&gt; , luego una lista separada por comas del nombre de cada campo y el valor de &lt;code&gt;Debug&lt;/code&gt; , luego &lt;code&gt;}&lt;/code&gt; . Para &lt;code&gt;enum&lt;/code&gt; s, usar&amp;aacute; el nombre de la variante y, si corresponde, &lt;code&gt;(&lt;/code&gt; , luego los valores de &lt;code&gt;Debug&lt;/code&gt; de los campos, luego &lt;code&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1a45e25757830b253d95a2bc878b147cc25a79e" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt; if all of the type's fields implement &lt;code&gt;Default&lt;/code&gt;. When &lt;code&gt;derive&lt;/code&gt;d, it will use the default value for each field's type.</source>
          <target state="translated">Este rasgo se puede usar con &lt;code&gt;#[derive]&lt;/code&gt; si todos los campos del tipo implementan &lt;code&gt;Default&lt;/code&gt; . Cuando &lt;code&gt;derive&lt;/code&gt; d, usar&amp;aacute; el valor predeterminado para el tipo de cada campo.</target>
        </trans-unit>
        <trans-unit id="2676a9e67ccce40e213776c8079ad50bcc6e9ebc" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt;. When &lt;code&gt;derive&lt;/code&gt;d on structs, it will produce a &lt;a href=&quot;https://en.wikipedia.org/wiki/Lexicographic_order&quot;&gt;lexicographic&lt;/a&gt; ordering based on the top-to-bottom declaration order of the struct's members. When &lt;code&gt;derive&lt;/code&gt;d on enums, variants are ordered by their top-to-bottom discriminant order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f09d6ff7ae1d14cf4065033999ff08ecaa8a87ff" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt;. When &lt;code&gt;derive&lt;/code&gt;d on structs, it will produce a lexicographic ordering based on the top-to-bottom declaration order of the struct's members. When &lt;code&gt;derive&lt;/code&gt;d on enums, variants are ordered by their top-to-bottom declaration order.</source>
          <target state="translated">Este rasgo se puede usar con &lt;code&gt;#[derive]&lt;/code&gt; . Cuando se &lt;code&gt;derive&lt;/code&gt; d en estructuras, producir&amp;aacute; un orden lexicogr&amp;aacute;fico basado en el orden de declaraci&amp;oacute;n de arriba a abajo de los miembros de la estructura. Cuando se &lt;code&gt;derive&lt;/code&gt; enumeraciones, las variantes se ordenan por su orden de declaraci&amp;oacute;n de arriba hacia abajo.</target>
        </trans-unit>
        <trans-unit id="9c8b40d33d991fc237bdd0ad2e6af05e65ea6f04" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt;. When &lt;code&gt;derive&lt;/code&gt;d on structs, it will produce a lexicographic ordering based on the top-to-bottom declaration order of the struct's members. When &lt;code&gt;derive&lt;/code&gt;d on enums, variants are ordered by their top-to-bottom discriminant order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86c69254ea90ce1d6926208560c4e9d29d5a8ded" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt;. When &lt;code&gt;derive&lt;/code&gt;d on structs, two instances are equal if all fields are equal, and not equal if any fields are not equal. When &lt;code&gt;derive&lt;/code&gt;d on enums, each variant is equal to itself and not equal to the other variants.</source>
          <target state="translated">Este rasgo se puede usar con &lt;code&gt;#[derive]&lt;/code&gt; . Cuando se &lt;code&gt;derive&lt;/code&gt; d en estructuras, dos instancias son iguales si todos los campos son iguales y no iguales si alg&amp;uacute;n campo no es igual. Cuando se &lt;code&gt;derive&lt;/code&gt; d en enumeraciones, cada variante es igual a s&amp;iacute; misma y no igual a las otras variantes.</target>
        </trans-unit>
        <trans-unit id="d52b5ae617172e107648185da3f817960014bc61" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt;. When &lt;code&gt;derive&lt;/code&gt;d, because &lt;code&gt;Eq&lt;/code&gt; has no extra methods, it is only informing the compiler that this is an equivalence relation rather than a partial equivalence relation. Note that the &lt;code&gt;derive&lt;/code&gt; strategy requires all fields are &lt;code&gt;Eq&lt;/code&gt;, which isn't always desired.</source>
          <target state="translated">Este rasgo se puede usar con &lt;code&gt;#[derive]&lt;/code&gt; . Cuando se &lt;code&gt;derive&lt;/code&gt; d, dado que &lt;code&gt;Eq&lt;/code&gt; no tiene m&amp;eacute;todos adicionales, solo se informa al compilador que se trata de una relaci&amp;oacute;n de equivalencia en lugar de una relaci&amp;oacute;n de equivalencia parcial. Tenga en cuenta que la estrategia de &lt;code&gt;derive&lt;/code&gt; requiere que todos los campos sean &lt;code&gt;Eq&lt;/code&gt; , lo que no siempre se desea.</target>
        </trans-unit>
        <trans-unit id="7f803568cc6e1099a89a4940b9eb35200f2785e5" translate="yes" xml:space="preserve">
          <source>This trait is &lt;code&gt;unsafe&lt;/code&gt; because its implementation must be correct for the safety of &lt;code&gt;unsafe trait TrustedLen&lt;/code&gt; implementations, and the results of using this trait can otherwise be trusted by &lt;code&gt;unsafe&lt;/code&gt; code to be correct and fulfill the listed obligations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ec116d7c92b2e4ed9689a8552deb9b1c3c9f209" translate="yes" xml:space="preserve">
          <source>This trait is a memory-safe and ergonomic alternative to constructing a &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt;. It supports the common executor design in which the data used to wake up a task is stored in an &lt;a href=&quot;../sync/struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt;. Some executors (especially those for embedded systems) cannot use this API, which is why &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; exists as an alternative for those systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b8679bc430feac142d06128a89f1af63473e460" translate="yes" xml:space="preserve">
          <source>This trait is automatically implemented for almost every type.</source>
          <target state="translated">Este rasgo se implementa automáticamente para casi todos los tipos.</target>
        </trans-unit>
        <trans-unit id="ce8cc586f2666a5f5f3d6650a18ec09e61d24a39" translate="yes" xml:space="preserve">
          <source>This trait is automatically implemented for any type which implements the &lt;a href=&quot;../fmt/trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; trait. As such, &lt;code&gt;ToString&lt;/code&gt; shouldn't be implemented directly: &lt;a href=&quot;../fmt/trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; should be implemented instead, and you get the &lt;code&gt;ToString&lt;/code&gt; implementation for free.</source>
          <target state="translated">Este rasgo se implementa autom&amp;aacute;ticamente para cualquier tipo que implemente el rasgo &lt;a href=&quot;../fmt/trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt; . Como tal, &lt;code&gt;ToString&lt;/code&gt; no debe implementarse directamente: la &lt;a href=&quot;../fmt/trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt; debe implementarse en su lugar y usted obtiene la implementaci&amp;oacute;n de &lt;code&gt;ToString&lt;/code&gt; de forma gratuita.</target>
        </trans-unit>
        <trans-unit id="82a06decfe065900879f7436e10b252705283acf" translate="yes" xml:space="preserve">
          <source>This trait is automatically implemented for every type and does not add any guarantees to &lt;a href=&quot;../mem/struct.discriminant&quot;&gt;&lt;code&gt;mem::Discriminant&lt;/code&gt;&lt;/a&gt;. It is &lt;strong&gt;undefined behavior&lt;/strong&gt; to transmute between &lt;code&gt;DiscriminantKind::Discriminant&lt;/code&gt; and &lt;code&gt;mem::Discriminant&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e3b32607a26276b7eeb2dc3f257150496699a30" translate="yes" xml:space="preserve">
          <source>This trait is automatically implemented when the compiler determines it's appropriate.</source>
          <target state="translated">Este rasgo se implementa automáticamente cuando el compilador determina que es apropiado.</target>
        </trans-unit>
        <trans-unit id="494ae62c6025e3f79bcb3a8e54a1efc9a121264f" translate="yes" xml:space="preserve">
          <source>This trait is implemented by default for many types and behaves similarly in terms of inference of implementation to the &lt;a href=&quot;../marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; traits. The purpose of this trait is to encode what types are safe to cross a &lt;a href=&quot;fn.catch_unwind&quot;&gt;&lt;code&gt;catch_unwind&lt;/code&gt;&lt;/a&gt; boundary with no fear of unwind safety.</source>
          <target state="translated">Este rasgo se implementa de forma predeterminada para muchos tipos y se comporta de manera similar en t&amp;eacute;rminos de inferencia de implementaci&amp;oacute;n para los rasgos &lt;a href=&quot;../marker/trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; . El prop&amp;oacute;sito de este rasgo es codificar qu&amp;eacute; tipos son seguros para cruzar un &lt;a href=&quot;fn.catch_unwind&quot;&gt; &lt;code&gt;catch_unwind&lt;/code&gt; &lt;/a&gt; l&amp;iacute;mite sin temor a la seguridad de .</target>
        </trans-unit>
        <trans-unit id="6fb1b7be6434ef1f997fff7cbfd045083e8560fe" translate="yes" xml:space="preserve">
          <source>This trait is namely not implemented by &lt;a href=&quot;../cell/struct.unsafecell&quot;&gt;&lt;code&gt;UnsafeCell&lt;/code&gt;&lt;/a&gt;, the root of all interior mutability.</source>
          <target state="translated">Este rasgo no es implementado por &lt;a href=&quot;../cell/struct.unsafecell&quot;&gt; &lt;code&gt;UnsafeCell&lt;/code&gt; &lt;/a&gt; , la ra&amp;iacute;z de toda mutabilidad interior.</target>
        </trans-unit>
        <trans-unit id="1d0c0de184f4ceb6563275bbcba7c14bd0a8edcc" translate="yes" xml:space="preserve">
          <source>This trait is similar to &lt;a href=&quot;trait.asmut&quot;&gt;&lt;code&gt;AsMut&lt;/code&gt;&lt;/a&gt; which is used for converting between mutable references. If you need to do a costly conversion it is better to implement &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; with type &lt;code&gt;&amp;amp;T&lt;/code&gt; or write a custom function.</source>
          <target state="translated">Este rasgo es similar a &lt;a href=&quot;trait.asmut&quot;&gt; &lt;code&gt;AsMut&lt;/code&gt; &lt;/a&gt; que se usa para convertir entre referencias mutables. Si necesita hacer una conversi&amp;oacute;n costosa, es mejor implementar &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; con type &lt;code&gt;&amp;amp;T&lt;/code&gt; o escribir una funci&amp;oacute;n personalizada.</target>
        </trans-unit>
        <trans-unit id="72c951714ee4a3342d70f41b91f0921e7e49ebf0" translate="yes" xml:space="preserve">
          <source>This trait is similar to &lt;a href=&quot;trait.asref&quot;&gt;&lt;code&gt;AsRef&lt;/code&gt;&lt;/a&gt; but used for converting between mutable references. If you need to do a costly conversion it is better to implement &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; with type &lt;code&gt;&amp;amp;mut T&lt;/code&gt; or write a custom function.</source>
          <target state="translated">Este rasgo es similar a &lt;a href=&quot;trait.asref&quot;&gt; &lt;code&gt;AsRef&lt;/code&gt; &lt;/a&gt; pero se usa para convertir entre referencias mutables. Si necesita hacer una conversi&amp;oacute;n costosa, es mejor implementar &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; con type &lt;code&gt;&amp;amp;mut T&lt;/code&gt; o escribir una funci&amp;oacute;n personalizada.</target>
        </trans-unit>
        <trans-unit id="1a731da3b36000bb0e86dfbd3105e49bf55c952e" translate="yes" xml:space="preserve">
          <source>This trait is the type which this modules requires when formatting information. This is similar to the standard library's &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;io::Write&lt;/code&gt;&lt;/a&gt; trait, but it is only intended for use in libcore.</source>
          <target state="translated">Este rasgo es el tipo que requiere este m&amp;oacute;dulo al formatear la informaci&amp;oacute;n. Esto es similar al rasgo &lt;a href=&quot;../io/trait.write&quot;&gt; &lt;code&gt;io::Write&lt;/code&gt; &lt;/a&gt; la biblioteca est&amp;aacute;ndar , pero solo est&amp;aacute; dise&amp;ntilde;ado para usarse en libcore.</target>
        </trans-unit>
        <trans-unit id="0b733d2267c635d65e2675dc57b25279df45e854" translate="yes" xml:space="preserve">
          <source>This trait is used for generic address resolution when constructing network objects. By default it is implemented for the following types:</source>
          <target state="translated">Este rasgo se utiliza para la resolución de direcciones genéricas cuando se construyen objetos de red.Por defecto se implementa para los siguientes tipos:</target>
        </trans-unit>
        <trans-unit id="1e3fe626c5ddea26b813fe813b589bf866e90fcc" translate="yes" xml:space="preserve">
          <source>This trait is used to implement the &lt;a href=&quot;trait.product#tymethod.product&quot;&gt;&lt;code&gt;product()&lt;/code&gt;&lt;/a&gt; method on iterators. Types which implement the trait can be generated by the &lt;a href=&quot;trait.product#tymethod.product&quot;&gt;&lt;code&gt;product()&lt;/code&gt;&lt;/a&gt; method. Like &lt;a href=&quot;trait.fromiterator&quot;&gt;&lt;code&gt;FromIterator&lt;/code&gt;&lt;/a&gt; this trait should rarely be called directly and instead interacted with through &lt;a href=&quot;trait.iterator#method.product&quot;&gt;&lt;code&gt;Iterator::product()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d670e5f44288c65ae601422a01219d930136f211" translate="yes" xml:space="preserve">
          <source>This trait is used to implement the &lt;a href=&quot;trait.product#tymethod.product&quot;&gt;&lt;code&gt;product&lt;/code&gt;&lt;/a&gt; method on iterators. Types which implement the trait can be generated by the &lt;a href=&quot;trait.product#tymethod.product&quot;&gt;&lt;code&gt;product&lt;/code&gt;&lt;/a&gt; method. Like &lt;a href=&quot;trait.fromiterator&quot;&gt;&lt;code&gt;FromIterator&lt;/code&gt;&lt;/a&gt; this trait should rarely be called directly and instead interacted with through &lt;a href=&quot;trait.iterator#method.product&quot;&gt;&lt;code&gt;Iterator::product&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Este rasgo se utiliza para implementar el m&amp;eacute;todo del &lt;a href=&quot;trait.product#tymethod.product&quot;&gt; &lt;code&gt;product&lt;/code&gt; o&lt;/a&gt; en iteradores. Los tipos que implementan el rasgo pueden generarse mediante el m&amp;eacute;todo del &lt;a href=&quot;trait.product#tymethod.product&quot;&gt; &lt;code&gt;product&lt;/code&gt; o&lt;/a&gt; . Al igual que &lt;a href=&quot;trait.fromiterator&quot;&gt; &lt;code&gt;FromIterator&lt;/code&gt; ,&lt;/a&gt; este rasgo rara vez deber&amp;iacute;a llamarse directamente y, en cambio, interactuar con &amp;eacute;l a trav&amp;eacute;s de &lt;a href=&quot;trait.iterator#method.product&quot;&gt; &lt;code&gt;Iterator::product&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="45f3e129667be9feede25a178448a0d3c4ddec5b" translate="yes" xml:space="preserve">
          <source>This trait is used to implement the &lt;a href=&quot;trait.sum#tymethod.sum&quot;&gt;&lt;code&gt;sum()&lt;/code&gt;&lt;/a&gt; method on iterators. Types which implement the trait can be generated by the &lt;a href=&quot;trait.sum#tymethod.sum&quot;&gt;&lt;code&gt;sum()&lt;/code&gt;&lt;/a&gt; method. Like &lt;a href=&quot;trait.fromiterator&quot;&gt;&lt;code&gt;FromIterator&lt;/code&gt;&lt;/a&gt; this trait should rarely be called directly and instead interacted with through &lt;a href=&quot;trait.iterator#method.sum&quot;&gt;&lt;code&gt;Iterator::sum()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f91608e2b2b005f5d3b20c487cd2efcf273838ce" translate="yes" xml:space="preserve">
          <source>This trait is used to implement the &lt;a href=&quot;trait.sum#tymethod.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; method on iterators. Types which implement the trait can be generated by the &lt;a href=&quot;trait.sum#tymethod.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; method. Like &lt;a href=&quot;trait.fromiterator&quot;&gt;&lt;code&gt;FromIterator&lt;/code&gt;&lt;/a&gt; this trait should rarely be called directly and instead interacted with through &lt;a href=&quot;trait.iterator#method.sum&quot;&gt;&lt;code&gt;Iterator::sum&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Este rasgo se usa para implementar el m&amp;eacute;todo de &lt;a href=&quot;trait.sum#tymethod.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; a&lt;/a&gt; en iteradores. Los tipos que implementan el rasgo se pueden generar mediante el m&amp;eacute;todo de &lt;a href=&quot;trait.sum#tymethod.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; a&lt;/a&gt; . Al igual que &lt;a href=&quot;trait.fromiterator&quot;&gt; &lt;code&gt;FromIterator&lt;/code&gt; ,&lt;/a&gt; este rasgo rara vez deber&amp;iacute;a llamarse directamente y, en cambio, interactuar con &amp;eacute;l a trav&amp;eacute;s de &lt;a href=&quot;trait.iterator#method.sum&quot;&gt; &lt;code&gt;Iterator::sum&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b392534a7b8b5e656825847e787994b0e838f382" translate="yes" xml:space="preserve">
          <source>This trait must only be implemented when the contract is upheld. Consumers of this trait must inspect &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;.size_hint&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s upper bound.</source>
          <target state="translated">Este rasgo solo debe implementarse cuando se cumple el contrato. Los consumidores de este rasgo deben inspeccionar el &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;.size_hint&lt;/code&gt; &lt;/a&gt; superior de .size_hint .</target>
        </trans-unit>
        <trans-unit id="6d78a10342907305049d898a7fef5c559c08564a" translate="yes" xml:space="preserve">
          <source>This trait must only be implemented when the contract is upheld. Consumers of this trait must inspect &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;Iterator::size_hint()&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s upper bound.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f26cbb7d217e71e5e8a2a5d99b20ac95a15952a0" translate="yes" xml:space="preserve">
          <source>This trait only accepts UTF-8&amp;ndash;encoded data and is not &lt;a href=&quot;../io/trait.write#tymethod.flush&quot;&gt;flushable&lt;/a&gt;. If you only want to accept Unicode and you don't need flushing, you should implement this trait; otherwise you should implement &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;std::io::Write&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92b09db877c076776794822e006bb3f0094cf13d" translate="yes" xml:space="preserve">
          <source>This trait provides methods for searching for non-overlapping matches of a pattern starting from the back (right) of a string.</source>
          <target state="translated">Este rasgo proporciona métodos para buscar coincidencias no superpuestas de un patrón a partir de la parte posterior (derecha)de una cuerda.</target>
        </trans-unit>
        <trans-unit id="581e031865e09ba379141c2883157c1d8acecf2b" translate="yes" xml:space="preserve">
          <source>This trait provides methods for searching for non-overlapping matches of a pattern starting from the front (left) of a string.</source>
          <target state="translated">Este rasgo proporciona métodos para buscar coincidencias no superpuestas de un patrón a partir de la parte delantera (izquierda)de una cuerda.</target>
        </trans-unit>
        <trans-unit id="577d84c8d58ef48b8ffaf1a01ef5ed3b028f5279" translate="yes" xml:space="preserve">
          <source>This trait provides transitive access to source-stage in an interator-adapter pipeline under the conditions that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d02b91849e023371b70419d209ec71d8ae7432d" translate="yes" xml:space="preserve">
          <source>This trait should generally not be implemented by consumers of the standard library. The &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt; macro accepts an instance of &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;io::Write&lt;/code&gt;&lt;/a&gt;, and the &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;io::Write&lt;/code&gt;&lt;/a&gt; trait is favored over implementing this trait.</source>
          <target state="translated">Por lo general, los consumidores de la biblioteca est&amp;aacute;ndar no deben implementar este rasgo. &amp;iexcl;La &lt;a href=&quot;../macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt;macro acepta una instancia de &lt;a href=&quot;../io/trait.write&quot;&gt; &lt;code&gt;io::Write&lt;/code&gt; &lt;/a&gt; , y el rasgo &lt;a href=&quot;../io/trait.write&quot;&gt; &lt;code&gt;io::Write&lt;/code&gt; &lt;/a&gt; se favorece sobre la implementaci&amp;oacute;n de este rasgo.</target>
        </trans-unit>
        <trans-unit id="6159bc779b64f1381d56daf00e89fd123440f35d" translate="yes" xml:space="preserve">
          <source>This tree shows how some of the modules nest inside one another (for example, &lt;code&gt;hosting&lt;/code&gt; nests inside &lt;code&gt;front_of_house&lt;/code&gt;). The tree also shows that some modules are &lt;em&gt;siblings&lt;/em&gt; to each other, meaning they&amp;rsquo;re defined in the same module (&lt;code&gt;hosting&lt;/code&gt; and &lt;code&gt;serving&lt;/code&gt; are defined within &lt;code&gt;front_of_house&lt;/code&gt;). To continue the family metaphor, if module A is contained inside module B, we say that module A is the &lt;em&gt;child&lt;/em&gt; of module B and that module B is the &lt;em&gt;parent&lt;/em&gt; of module A. Notice that the entire module tree is rooted under the implicit module named &lt;code&gt;crate&lt;/code&gt;.</source>
          <target state="translated">Este &amp;aacute;rbol muestra c&amp;oacute;mo algunos de los m&amp;oacute;dulos se anidan unos dentro de otros (por ejemplo, &lt;code&gt;hosting&lt;/code&gt; nidos dentro de &lt;code&gt;front_of_house&lt;/code&gt; ). El &amp;aacute;rbol tambi&amp;eacute;n muestra que algunos m&amp;oacute;dulos son &lt;em&gt;hermanos&lt;/em&gt; entre s&amp;iacute;, lo que significa que est&amp;aacute;n definidos en el mismo m&amp;oacute;dulo (el &lt;code&gt;hosting&lt;/code&gt; y el &lt;code&gt;serving&lt;/code&gt; se definen dentro de &lt;code&gt;front_of_house&lt;/code&gt; ). Para continuar con la met&amp;aacute;fora de la familia, si el m&amp;oacute;dulo A est&amp;aacute; contenido dentro del m&amp;oacute;dulo B, decimos que el m&amp;oacute;dulo A es el &lt;em&gt;hijo&lt;/em&gt; del m&amp;oacute;dulo B y que el m&amp;oacute;dulo B es el &lt;em&gt;padre&lt;/em&gt; del m&amp;oacute;dulo A. Observe que todo el &amp;aacute;rbol del m&amp;oacute;dulo tiene sus ra&amp;iacute;ces en el m&amp;oacute;dulo impl&amp;iacute;cito denominado &lt;code&gt;crate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a2a59de8ad5e3abf90b08ea27feb4c5c9564363" translate="yes" xml:space="preserve">
          <source>This trick is very sneaky and complicated. Don&amp;rsquo;t worry if it doesn&amp;rsquo;t make perfect sense; someday, it will be completely unnecessary.</source>
          <target state="translated">Este truco es muy enga&amp;ntilde;oso y complicado. No se preocupe si no tiene perfecto sentido; alg&amp;uacute;n d&amp;iacute;a, ser&amp;aacute; completamente innecesario.</target>
        </trans-unit>
        <trans-unit id="e51c9b4abf7ac4d9724545d7cabc828636bce6da" translate="yes" xml:space="preserve">
          <source>This type can represent a wide range of decimal numbers, like &lt;code&gt;3.5&lt;/code&gt;, &lt;code&gt;27&lt;/code&gt;, &lt;code&gt;-113.75&lt;/code&gt;, &lt;code&gt;0.0078125&lt;/code&gt;, &lt;code&gt;34359738368&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;-1&lt;/code&gt;. So unlike integer types (such as &lt;code&gt;i32&lt;/code&gt;), floating point types can represent non-integer numbers, too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b151d516c842037f13cd18d29f046aea06e0121e" translate="yes" xml:space="preserve">
          <source>This type cannot have a well-defined size, because it needs to be arbitrarily large (since we would be able to nest &lt;code&gt;ListNode&lt;/code&gt;s to any depth). Specifically,</source>
          <target state="translated">Este tipo no puede tener un tama&amp;ntilde;o bien definido, porque necesita ser arbitrariamente grande (ya que podr&amp;iacute;amos anidar &lt;code&gt;ListNode&lt;/code&gt; s a cualquier profundidad). Espec&amp;iacute;ficamente,</target>
        </trans-unit>
        <trans-unit id="84f5f45f7092418ba53ffa588ed49cf6c55b3005" translate="yes" xml:space="preserve">
          <source>This type does not support transmission of an error other than that an error occurred. Any extra information must be arranged to be transmitted through some other means.</source>
          <target state="translated">Este tipo no admite la transmisión de un error que no sea el de haber ocurrido un error.Cualquier información extra debe ser arreglada para ser transmitida por algún otro medio.</target>
        </trans-unit>
        <trans-unit id="ca06708cb31886f20e9999f83e4a96bd88513b09" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as a &lt;a href=&quot;../../primitive.bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Este tipo tiene la misma representaci&amp;oacute;n en memoria que un &lt;a href=&quot;../../primitive.bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7ed5168f106b9ae49d6a5ac8c4fbf062da809a4c" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as a &lt;code&gt;*mut T&lt;/code&gt;.</source>
          <target state="translated">Este tipo tiene la misma representaci&amp;oacute;n en memoria como un &lt;code&gt;*mut T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bde0ba16d9d2a17d2da79db3c616fd2db5d4b738" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.i16&quot;&gt;&lt;code&gt;i16&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">Este tipo tiene la misma representaci&amp;oacute;n en memoria que el tipo entero subyacente, &lt;a href=&quot;../../primitive.i16&quot;&gt; &lt;code&gt;i16&lt;/code&gt; &lt;/a&gt; . Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre las diferencias entre los tipos at&amp;oacute;micos y no at&amp;oacute;micos, as&amp;iacute; como informaci&amp;oacute;n sobre la portabilidad de este tipo, consulte la &lt;a href=&quot;index&quot;&gt;documentaci&amp;oacute;n a nivel de m&amp;oacute;dulo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="11fe8d9ef82cc58363e607b1900488902f96b062" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">Este tipo tiene la misma representaci&amp;oacute;n en memoria que el tipo entero subyacente, &lt;a href=&quot;../../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; . Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre las diferencias entre tipos at&amp;oacute;micos y no at&amp;oacute;micos, as&amp;iacute; como informaci&amp;oacute;n sobre la portabilidad de este tipo, consulte la &lt;a href=&quot;index&quot;&gt;documentaci&amp;oacute;n a nivel de m&amp;oacute;dulo.&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ae2c41e53be3c451cd7fe9d715ded32f7f324930" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">Este tipo tiene la misma representaci&amp;oacute;n en memoria que el tipo entero subyacente, &lt;a href=&quot;../../primitive.i64&quot;&gt; &lt;code&gt;i64&lt;/code&gt; &lt;/a&gt; . Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre las diferencias entre tipos at&amp;oacute;micos y no at&amp;oacute;micos, as&amp;iacute; como informaci&amp;oacute;n sobre la portabilidad de este tipo, consulte la &lt;a href=&quot;index&quot;&gt;documentaci&amp;oacute;n a nivel de m&amp;oacute;dulo.&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8709735902527f53136366bbc4da81e059b1cf29" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.i8&quot;&gt;&lt;code&gt;i8&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">Este tipo tiene la misma representaci&amp;oacute;n en memoria que el tipo entero subyacente, &lt;a href=&quot;../../primitive.i8&quot;&gt; &lt;code&gt;i8&lt;/code&gt; &lt;/a&gt; . Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre las diferencias entre los tipos at&amp;oacute;micos y no at&amp;oacute;micos, as&amp;iacute; como informaci&amp;oacute;n sobre la portabilidad de este tipo, consulte la &lt;a href=&quot;index&quot;&gt;documentaci&amp;oacute;n a nivel de m&amp;oacute;dulo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="22a2662795b52aff8d9d5db4f32fbfd5a6eae45b" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.isize&quot;&gt;&lt;code&gt;isize&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">Este tipo tiene la misma representaci&amp;oacute;n en memoria que el tipo entero subyacente, &lt;a href=&quot;../../primitive.isize&quot;&gt; &lt;code&gt;isize&lt;/code&gt; &lt;/a&gt; . Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre las diferencias entre los tipos at&amp;oacute;micos y no at&amp;oacute;micos, as&amp;iacute; como informaci&amp;oacute;n sobre la portabilidad de este tipo, consulte la &lt;a href=&quot;index&quot;&gt;documentaci&amp;oacute;n a nivel de m&amp;oacute;dulo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b0e9d5aecbbcb90f5394cd93afd041c8660e20d3" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.u16&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">Este tipo tiene la misma representaci&amp;oacute;n en memoria que el tipo entero subyacente, &lt;a href=&quot;../../primitive.u16&quot;&gt; &lt;code&gt;u16&lt;/code&gt; &lt;/a&gt; . Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre las diferencias entre tipos at&amp;oacute;micos y no at&amp;oacute;micos, as&amp;iacute; como informaci&amp;oacute;n sobre la portabilidad de este tipo, consulte la &lt;a href=&quot;index&quot;&gt;documentaci&amp;oacute;n a nivel de m&amp;oacute;dulo.&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c2b9ce184354cce38ff31805f5b9e99cf85271c3" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">Este tipo tiene la misma representaci&amp;oacute;n en memoria que el tipo entero subyacente, &lt;a href=&quot;../../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; . Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre las diferencias entre tipos at&amp;oacute;micos y no at&amp;oacute;micos, as&amp;iacute; como informaci&amp;oacute;n sobre la portabilidad de este tipo, consulte la &lt;a href=&quot;index&quot;&gt;documentaci&amp;oacute;n a nivel de m&amp;oacute;dulo.&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f3b430d11ed80e34dede1d2fe612c5e93a3e75e" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.u64&quot;&gt;&lt;code&gt;u64&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">Este tipo tiene la misma representaci&amp;oacute;n en memoria que el tipo entero subyacente, &lt;a href=&quot;../../primitive.u64&quot;&gt; &lt;code&gt;u64&lt;/code&gt; &lt;/a&gt; . Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre las diferencias entre tipos at&amp;oacute;micos y no at&amp;oacute;micos, as&amp;iacute; como informaci&amp;oacute;n sobre la portabilidad de este tipo, consulte la &lt;a href=&quot;index&quot;&gt;documentaci&amp;oacute;n a nivel de m&amp;oacute;dulo.&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="da5885bb51df1018c63942e6cd581107a9d67b99" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">Este tipo tiene la misma representaci&amp;oacute;n en memoria que el tipo entero subyacente, &lt;a href=&quot;../../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; . Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre las diferencias entre tipos at&amp;oacute;micos y no at&amp;oacute;micos, as&amp;iacute; como informaci&amp;oacute;n sobre la portabilidad de este tipo, consulte la &lt;a href=&quot;index&quot;&gt;documentaci&amp;oacute;n a nivel de m&amp;oacute;dulo.&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1494d8fbdc9903b4f7f4ce3473fbf110556d56ce" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">Este tipo tiene la misma representaci&amp;oacute;n en memoria que el tipo entero subyacente, &lt;a href=&quot;../../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt; . Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre las diferencias entre tipos at&amp;oacute;micos y no at&amp;oacute;micos, as&amp;iacute; como informaci&amp;oacute;n sobre la portabilidad de este tipo, consulte la&lt;a href=&quot;index&quot;&gt; documentaci&amp;oacute;n a nivel de m&amp;oacute;dulo.&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fd773ba06290a2ef0eb43046e43b15b9753a1b01" translate="yes" xml:space="preserve">
          <source>This type implements the &lt;a href=&quot;trait.alloc&quot;&gt;&lt;code&gt;Alloc&lt;/code&gt;&lt;/a&gt; trait by forwarding calls to the allocator registered with the &lt;code&gt;#[global_allocator]&lt;/code&gt; attribute if there is one, or the &lt;code&gt;std&lt;/code&gt; crate&amp;rsquo;s default.</source>
          <target state="translated">Este tipo implementa el rasgo &lt;a href=&quot;trait.alloc&quot;&gt; &lt;code&gt;Alloc&lt;/code&gt; &lt;/a&gt; reenviando llamadas al asignador registrado con el &lt;code&gt;#[global_allocator]&lt;/code&gt; atributo # [global_allocator] si lo hay, o al &lt;code&gt;std&lt;/code&gt; por defecto del caj&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="0d10c935129b21e89e6454b38394b060ce3b284b" translate="yes" xml:space="preserve">
          <source>This type implements the &lt;a href=&quot;trait.allocref&quot;&gt;&lt;code&gt;AllocRef&lt;/code&gt;&lt;/a&gt; trait by forwarding calls to the allocator registered with the &lt;code&gt;#[global_allocator]&lt;/code&gt; attribute if there is one, or the &lt;code&gt;std&lt;/code&gt; crate&amp;rsquo;s default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1acd93eca07f0189a95b444e7590b0d811f50e31" translate="yes" xml:space="preserve">
          <source>This type implements the &lt;code&gt;GlobalAlloc&lt;/code&gt; trait and Rust programs by default work as if they had this definition:</source>
          <target state="translated">Este tipo implementa &lt;code&gt;GlobalAlloc&lt;/code&gt; rasgo y los programas Rust por defecto funcionan como si tuvieran esta definici&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="58e8fa6622de2c31c9adb96ad4ef78c440c610d0" translate="yes" xml:space="preserve">
          <source>This type is a thread-safe &lt;code&gt;Lazy&lt;/code&gt;, and can be used in statics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c766a6dd40937d2b1bee433cf315fc82a362370f" translate="yes" xml:space="preserve">
          <source>This type is a thread-safe &lt;code&gt;OnceCell&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="466a15ddbbbf930acad97c2c30afa51f3b95564c" translate="yes" xml:space="preserve">
          <source>This type is broadly used across &lt;a href=&quot;index&quot;&gt;&lt;code&gt;std::io&lt;/code&gt;&lt;/a&gt; for any operation which may produce an error.</source>
          <target state="translated">Este tipo se utiliza ampliamente en &lt;a href=&quot;index&quot;&gt; &lt;code&gt;std::io&lt;/code&gt; &lt;/a&gt; para cualquier operaci&amp;oacute;n que pueda producir un error.</target>
        </trans-unit>
        <trans-unit id="37345f83ba0c67385672d5daf1593634da8686e6" translate="yes" xml:space="preserve">
          <source>This type is the error type for the &lt;a href=&quot;struct.string#method.from_utf16&quot;&gt;&lt;code&gt;from_utf16&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Este tipo es el tipo de error para el m&amp;eacute;todo &lt;a href=&quot;struct.string#method.from_utf16&quot;&gt; &lt;code&gt;from_utf16&lt;/code&gt; &lt;/a&gt; en&lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8498c071c2463be5580b4f49150396661778b8bc" translate="yes" xml:space="preserve">
          <source>This type is the error type for the &lt;a href=&quot;struct.string#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;. It is designed in such a way to carefully avoid reallocations: the &lt;a href=&quot;struct.fromutf8error#method.into_bytes&quot;&gt;&lt;code&gt;into_bytes&lt;/code&gt;&lt;/a&gt; method will give back the byte vector that was used in the conversion attempt.</source>
          <target state="translated">Este tipo es el tipo de error para el m&amp;eacute;todo &lt;a href=&quot;struct.string#method.from_utf8&quot;&gt; &lt;code&gt;from_utf8&lt;/code&gt; &lt;/a&gt; en &lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; . Est&amp;aacute; dise&amp;ntilde;ado de tal manera que evita cuidadosamente las reasignaciones:&lt;a href=&quot;struct.fromutf8error#method.into_bytes&quot;&gt; &lt;code&gt;into_bytes&lt;/code&gt; &lt;/a&gt; m&amp;eacute;todo devolver&amp;aacute; el vector de bytes que se utiliz&amp;oacute; en el intento de conversi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d92453a7345aece96356ae2979efa1f42765d4ea" translate="yes" xml:space="preserve">
          <source>This type is very similar to &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.f32.html&quot;&gt;&lt;code&gt;f32&lt;/code&gt;&lt;/a&gt;, but has increased precision by using twice as many bits. Please see &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.f32.html&quot;&gt;the documentation for &lt;code&gt;f32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Double-precision_floating-point_format&quot;&gt;Wikipedia on double precision values&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63b84d2000b910b8457b4220e8938add88b701b5" translate="yes" xml:space="preserve">
          <source>This type of lock allows a number of readers or at most one writer at any point in time. The write portion of this lock typically allows modification of the underlying data (exclusive access) and the read portion of this lock typically allows for read-only access (shared access).</source>
          <target state="translated">Este tipo de bloqueo permite a un número de lectores o como máximo a un escritor en cualquier momento.La parte de escritura de este candado normalmente permite la modificación de los datos subyacentes (acceso exclusivo)y la parte de lectura de este candado normalmente permite el acceso de sólo lectura (acceso compartido).</target>
        </trans-unit>
        <trans-unit id="c6101d6dc5e2fd547d5ca4f8075c490b739700a9" translate="yes" xml:space="preserve">
          <source>This type provides methods like &lt;a href=&quot;struct.pathbuf#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.pathbuf#method.set_extension&quot;&gt;&lt;code&gt;set_extension&lt;/code&gt;&lt;/a&gt; that mutate the path in place. It also implements &lt;a href=&quot;../ops/trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;, meaning that all methods on &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; slices are available on &lt;code&gt;PathBuf&lt;/code&gt; values as well.</source>
          <target state="translated">Este tipo proporciona m&amp;eacute;todos como &lt;a href=&quot;struct.pathbuf#method.push&quot;&gt; &lt;code&gt;push&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;struct.pathbuf#method.set_extension&quot;&gt; &lt;code&gt;set_extension&lt;/code&gt; &lt;/a&gt; que mutan la ruta en su lugar. Tambi&amp;eacute;n implementa &lt;a href=&quot;../ops/trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt; to &lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; , lo que significa que todos los m&amp;eacute;todos en los segmentos de &lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; est&amp;aacute;n disponibles en &lt;code&gt;PathBuf&lt;/code&gt; valores de .</target>
        </trans-unit>
        <trans-unit id="e5c0f0dd2b187cb6784df147ee7001123c8936c0" translate="yes" xml:space="preserve">
          <source>This type represents a borrowed reference to a nul-terminated array of bytes. It can be constructed safely from a &lt;code&gt;&amp;amp;[&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;]&lt;/code&gt; slice, or unsafely from a raw &lt;code&gt;*const c_char&lt;/code&gt;. It can then be converted to a Rust &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; by performing UTF-8 validation, or into an owned &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Este tipo representa una referencia prestada a una matriz de bytes terminada en nulo. Puede construirse de forma segura a partir de un &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;amp;[&lt;/code&gt; u8 &lt;code&gt;]&lt;/code&gt; , o de forma insegura a partir de un &lt;code&gt;*const c_char&lt;/code&gt; sin formato . Luego se puede convertir en un Rust &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; realizando una validaci&amp;oacute;n UTF-8, o en un &lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; propio&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="020b3bfb2ee1251c34f42849931a1e6222269e82" translate="yes" xml:space="preserve">
          <source>This type represents a borrowed reference to a nul-terminated array of bytes. It can be constructed safely from a &lt;code&gt;&amp;amp;[&lt;/code&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;]&lt;/code&gt; slice, or unsafely from a raw &lt;code&gt;*const c_char&lt;/code&gt;. It can then be converted to a Rust &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; by performing UTF-8 validation, or into an owned &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e18df5bb8ad819c600cd4afb1d82afc59b7f998" translate="yes" xml:space="preserve">
          <source>This type represents a borrowed reference to a string in the operating system's preferred representation.</source>
          <target state="translated">Este tipo representa una referencia prestada a una cadena en la representación preferida del sistema operativo.</target>
        </trans-unit>
        <trans-unit id="6142b61fe2d2c68dea4ad8a85d9dc10ccc2f98b3" translate="yes" xml:space="preserve">
          <source>This type represents a stack backtrace for an OS thread captured at a previous point in time. In some instances the &lt;code&gt;Backtrace&lt;/code&gt; type may internally be empty due to configuration. For more information see &lt;code&gt;Backtrace::capture&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b774085d693678b6b309fbc90af8e885fb4742c" translate="yes" xml:space="preserve">
          <source>This type represents the status code a process can return to its parent under normal termination.</source>
          <target state="translated">Este tipo representa el código de estado que un proceso puede devolver a su padre en una terminación normal.</target>
        </trans-unit>
        <trans-unit id="8b966cfbeebcefe7f0330e7e9f54f7098bf1152f" translate="yes" xml:space="preserve">
          <source>This type serves the purpose of being able to safely generate a C-compatible string from a Rust byte slice or vector. An instance of this type is a static guarantee that the underlying bytes contain no interior 0 bytes (&quot;nul characters&quot;) and that the final byte is 0 (&quot;nul terminator&quot;).</source>
          <target state="translated">Este tipo sirve para poder generar de forma segura una cadena compatible con C a partir de un trozo o vector de byte de óxido.Un ejemplo de este tipo es una garantía estática de que los bytes subyacentes no contienen ningún byte interior 0 (&quot;caracteres nulos&quot;)y que el byte final es 0 (&quot;terminador nulo&quot;).</target>
        </trans-unit>
        <trans-unit id="7d87337ad285058ac7367e471ff8622a41dfdd71" translate="yes" xml:space="preserve">
          <source>This type supports a number of operations for inspecting a path, including breaking the path into its components (separated by &lt;code&gt;/&lt;/code&gt; on Unix and by either &lt;code&gt;/&lt;/code&gt; or  on Windows), extracting the file name, determining whether the path is absolute, and so on.</source>
          <target state="translated">Este tipo admite una serie de operaciones para inspeccionar una ruta, incluida la divisi&amp;oacute;n de la ruta en sus componentes (separados por &lt;code&gt;/&lt;/code&gt; en Unix y por &lt;code&gt;/&lt;/code&gt; o en Windows), extraer el nombre del archivo, determinar si la ruta es absoluta, etc.</target>
        </trans-unit>
        <trans-unit id="5d992ca66aeeffa4346515aab9e07f94a5a7aea4" translate="yes" xml:space="preserve">
          <source>This type supports a number of operations for inspecting a path, including breaking the path into its components (separated by &lt;code&gt;/&lt;/code&gt; on Unix and by either &lt;code&gt;/&lt;/code&gt; or &lt;code&gt;\&lt;/code&gt; on Windows), extracting the file name, determining whether the path is absolute, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f22ec26e83b1f093f0fa10a8ffd75ef588107911" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;../../primitive.f32&quot;&gt;&lt;code&gt;f32&lt;/code&gt;&lt;/a&gt;, which is guaranteed to be an &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE-754 single-precision float&lt;/a&gt; in Rust. That said, the standard technically only guarantees that it be a floating-point number, and it may have less precision than &lt;code&gt;f32&lt;/code&gt; or not follow the IEEE-754 standard at all.</source>
          <target state="translated">Este tipo casi siempre ser&amp;aacute; &lt;a href=&quot;../../primitive.f32&quot;&gt; &lt;code&gt;f32&lt;/code&gt; &lt;/a&gt; , que se garantiza que es un &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;flotador de precisi&amp;oacute;n simple IEEE-754&lt;/a&gt; en Rust. Dicho esto, el est&amp;aacute;ndar t&amp;eacute;cnicamente solo garantiza que sea un n&amp;uacute;mero de punto flotante, y puede tener menos precisi&amp;oacute;n que &lt;code&gt;f32&lt;/code&gt; o no seguir el est&amp;aacute;ndar IEEE-754 en absoluto.</target>
        </trans-unit>
        <trans-unit id="b34eb94d33cfcd2b81be054dc12a48e0b5f8dc2f" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;../../primitive.f64&quot;&gt;&lt;code&gt;f64&lt;/code&gt;&lt;/a&gt;, which is guaranteed to be an &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE-754 double-precision float&lt;/a&gt; in Rust. That said, the standard technically only guarantees that it be a floating-point number with at least the precision of a &lt;a href=&quot;type.c_float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;, and it may be &lt;code&gt;f32&lt;/code&gt; or something entirely different from the IEEE-754 standard.</source>
          <target state="translated">Este tipo casi siempre ser&amp;aacute; &lt;a href=&quot;../../primitive.f64&quot;&gt; &lt;code&gt;f64&lt;/code&gt; &lt;/a&gt; , que se garantiza que es un &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;flotador de doble precisi&amp;oacute;n IEEE-754&lt;/a&gt; en Rust. Dicho esto, el est&amp;aacute;ndar t&amp;eacute;cnicamente solo garantiza que sea un n&amp;uacute;mero de punto flotante con al menos la precisi&amp;oacute;n de un &lt;a href=&quot;type.c_float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; , y puede ser &lt;code&gt;f32&lt;/code&gt; o algo completamente diferente del est&amp;aacute;ndar IEEE-754.</target>
        </trans-unit>
        <trans-unit id="2713919b8810fb3f44c86782b09415ed3b59cda3" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;../../primitive.i16&quot;&gt;&lt;code&gt;i16&lt;/code&gt;&lt;/a&gt;, but may differ on some esoteric systems. The C standard technically only requires that this type be a signed integer with at least 16 bits; some systems may define it as &lt;code&gt;i32&lt;/code&gt;, for example.</source>
          <target state="translated">Este tipo casi siempre ser&amp;aacute; &lt;a href=&quot;../../primitive.i16&quot;&gt; &lt;code&gt;i16&lt;/code&gt; &lt;/a&gt; , pero puede diferir en algunos sistemas esot&amp;eacute;ricos. El est&amp;aacute;ndar C t&amp;eacute;cnicamente solo requiere que este tipo sea un entero con signo con al menos 16 bits; algunos sistemas pueden definirlo como &lt;code&gt;i32&lt;/code&gt; , por ejemplo.</target>
        </trans-unit>
        <trans-unit id="c0d84326d8675408ac530de354cda2d1a8ac7eb3" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;../../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt;, but may differ on some esoteric systems. The C standard technically only requires that this type be a signed integer that is at least the size of a &lt;a href=&quot;type.c_short&quot;&gt;&lt;code&gt;short&lt;/code&gt;&lt;/a&gt;; some systems define it as an &lt;a href=&quot;../../primitive.i16&quot;&gt;&lt;code&gt;i16&lt;/code&gt;&lt;/a&gt;, for example.</source>
          <target state="translated">Este tipo casi siempre ser&amp;aacute; &lt;a href=&quot;../../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; , pero puede diferir en algunos sistemas esot&amp;eacute;ricos. El est&amp;aacute;ndar C t&amp;eacute;cnicamente solo requiere que este tipo sea un entero con signo que sea al menos del tama&amp;ntilde;o de un &lt;a href=&quot;type.c_short&quot;&gt; &lt;code&gt;short&lt;/code&gt; &lt;/a&gt; ; algunos sistemas lo definen como un &lt;a href=&quot;../../primitive.i16&quot;&gt; &lt;code&gt;i16&lt;/code&gt; &lt;/a&gt; , por ejemplo.</target>
        </trans-unit>
        <trans-unit id="ab581f0ea98e052030c778602ef0ca98c399648d" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;../../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;, but may differ on some systems. The C standard technically only requires that this type be a signed integer that is at least 64 bits and at least the size of a &lt;a href=&quot;type.c_int&quot;&gt;&lt;code&gt;long&lt;/code&gt;&lt;/a&gt;, although in practice, no system would have a &lt;code&gt;long long&lt;/code&gt; that is not an &lt;code&gt;i64&lt;/code&gt;, as most systems do not have a standardised &lt;a href=&quot;../../primitive.i128&quot;&gt;&lt;code&gt;i128&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="translated">Este tipo casi siempre ser&amp;aacute; &lt;a href=&quot;../../primitive.i64&quot;&gt; &lt;code&gt;i64&lt;/code&gt; &lt;/a&gt; , pero puede diferir en algunos sistemas. El est&amp;aacute;ndar C t&amp;eacute;cnicamente solo requiere que este tipo sea un entero con signo que tenga al menos 64 bits y al menos el tama&amp;ntilde;o de un &lt;a href=&quot;type.c_int&quot;&gt; &lt;code&gt;long&lt;/code&gt; &lt;/a&gt; , aunque en la pr&amp;aacute;ctica ning&amp;uacute;n sistema tendr&amp;iacute;a un &lt;code&gt;long long&lt;/code&gt; que no sea un &lt;code&gt;i64&lt;/code&gt; , ya que la mayor&amp;iacute;a de los sistemas no lo hacen. tener un estandarizado&lt;a href=&quot;../../primitive.i128&quot;&gt; &lt;code&gt;i128&lt;/code&gt; &lt;/a&gt; tipo .</target>
        </trans-unit>
        <trans-unit id="15b5edcf451c79ce2991144552b8f569664ab769" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;../../primitive.u16&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;, but may differ on some esoteric systems. The C standard technically only requires that this type be an unsigned integer with the same size as a &lt;a href=&quot;type.c_short&quot;&gt;&lt;code&gt;short&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Este tipo casi siempre ser&amp;aacute; &lt;a href=&quot;../../primitive.u16&quot;&gt; &lt;code&gt;u16&lt;/code&gt; &lt;/a&gt; , pero puede diferir en algunos sistemas esot&amp;eacute;ricos. El est&amp;aacute;ndar C t&amp;eacute;cnicamente solo requiere que este tipo sea un entero sin signo con el mismo tama&amp;ntilde;o que un &lt;a href=&quot;type.c_short&quot;&gt; &lt;code&gt;short&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8ba1b7005ffb5ad84714cb0adcd9cce8dfd29a44" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;../../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;, but may differ on some esoteric systems. The C standard technically only requires that this type be an unsigned integer with the same size as an &lt;a href=&quot;type.c_int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;; some systems define it as a &lt;a href=&quot;../../primitive.u16&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;, for example.</source>
          <target state="translated">Este tipo casi siempre ser&amp;aacute; &lt;a href=&quot;../../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; , pero puede diferir en algunos sistemas esot&amp;eacute;ricos. El est&amp;aacute;ndar C t&amp;eacute;cnicamente solo requiere que este tipo sea un entero sin signo con el mismo tama&amp;ntilde;o que un &lt;a href=&quot;type.c_int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; ; algunos sistemas lo definen como un&lt;a href=&quot;../../primitive.u16&quot;&gt; &lt;code&gt;u16&lt;/code&gt; &lt;/a&gt; , por ejemplo.</target>
        </trans-unit>
        <trans-unit id="10f7763a2c07ba8b71ea9cbe73fe235f098f6f03" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;../../primitive.u64&quot;&gt;&lt;code&gt;u64&lt;/code&gt;&lt;/a&gt;, but may differ on some systems. The C standard technically only requires that this type be an unsigned integer with the size of a &lt;a href=&quot;type.c_longlong&quot;&gt;&lt;code&gt;long long&lt;/code&gt;&lt;/a&gt;, although in practice, no system would have a &lt;code&gt;long long&lt;/code&gt; that is not a &lt;code&gt;u64&lt;/code&gt;, as most systems do not have a standardised &lt;a href=&quot;../../primitive.u128&quot;&gt;&lt;code&gt;u128&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="translated">Este tipo casi siempre ser&amp;aacute; &lt;a href=&quot;../../primitive.u64&quot;&gt; &lt;code&gt;u64&lt;/code&gt; &lt;/a&gt; , pero puede diferir en algunos sistemas. El est&amp;aacute;ndar C t&amp;eacute;cnicamente solo requiere que este tipo sea un entero sin signo con el tama&amp;ntilde;o de un &lt;a href=&quot;type.c_longlong&quot;&gt; &lt;code&gt;long long&lt;/code&gt; &lt;/a&gt; , aunque en la pr&amp;aacute;ctica, ning&amp;uacute;n sistema tendr&amp;iacute;a un &lt;code&gt;long long&lt;/code&gt; que no sea un &lt;code&gt;u64&lt;/code&gt; , ya que la mayor&amp;iacute;a de los sistemas no tienen un &lt;a href=&quot;../../primitive.u128&quot;&gt; &lt;code&gt;u128&lt;/code&gt; &lt;/a&gt; estandarizado . tipo .</target>
        </trans-unit>
        <trans-unit id="62b8bfd925dec29031c9f9af8d15530118a5f2ce" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.f32.html&quot;&gt;&lt;code&gt;f32&lt;/code&gt;&lt;/a&gt;, which is guaranteed to be an &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE-754 single-precision float&lt;/a&gt; in Rust. That said, the standard technically only guarantees that it be a floating-point number, and it may have less precision than &lt;code&gt;f32&lt;/code&gt; or not follow the IEEE-754 standard at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c674b282d61f34daea9ef2ee13aae39fb8505b63" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.f64.html&quot;&gt;&lt;code&gt;f64&lt;/code&gt;&lt;/a&gt;, which is guaranteed to be an &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE-754 double-precision float&lt;/a&gt; in Rust. That said, the standard technically only guarantees that it be a floating-point number with at least the precision of a &lt;a href=&quot;type.c_float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;, and it may be &lt;code&gt;f32&lt;/code&gt; or something entirely different from the IEEE-754 standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea8042a19bb3c7392d0a03d8aac515052ed54c02" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.i16.html&quot;&gt;&lt;code&gt;i16&lt;/code&gt;&lt;/a&gt;, but may differ on some esoteric systems. The C standard technically only requires that this type be a signed integer with at least 16 bits; some systems may define it as &lt;code&gt;i32&lt;/code&gt;, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f5a6e28ddb1307caa7a25d8ee94ecc741d04f02" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.i32.html&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt;, but may differ on some esoteric systems. The C standard technically only requires that this type be a signed integer that is at least the size of a &lt;a href=&quot;type.c_short&quot;&gt;&lt;code&gt;short&lt;/code&gt;&lt;/a&gt;; some systems define it as an &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.i16.html&quot;&gt;&lt;code&gt;i16&lt;/code&gt;&lt;/a&gt;, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ab7786704bfcc1276eecf70ffb134c89a7de414" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.i64.html&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;, but may differ on some systems. The C standard technically only requires that this type be a signed integer that is at least 64 bits and at least the size of a &lt;a href=&quot;type.c_int&quot;&gt;&lt;code&gt;long&lt;/code&gt;&lt;/a&gt;, although in practice, no system would have a &lt;code&gt;long long&lt;/code&gt; that is not an &lt;code&gt;i64&lt;/code&gt;, as most systems do not have a standardised &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.i128.html&quot;&gt;&lt;code&gt;i128&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89d3f0d1d67d74135ffdd410a290383d90e8fe31" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u16.html&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;, but may differ on some esoteric systems. The C standard technically only requires that this type be an unsigned integer with the same size as a &lt;a href=&quot;type.c_short&quot;&gt;&lt;code&gt;short&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="202dca95d3eb592c40ce655fef3c1ec8be90922f" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u32.html&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;, but may differ on some esoteric systems. The C standard technically only requires that this type be an unsigned integer with the same size as an &lt;a href=&quot;type.c_int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;; some systems define it as a &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u16.html&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="469cb3e6510770c6f62e6ffb0ed8eda80a71067d" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u64.html&quot;&gt;&lt;code&gt;u64&lt;/code&gt;&lt;/a&gt;, but may differ on some systems. The C standard technically only requires that this type be an unsigned integer with the size of a &lt;a href=&quot;type.c_longlong&quot;&gt;&lt;code&gt;long long&lt;/code&gt;&lt;/a&gt;, although in practice, no system would have a &lt;code&gt;long long&lt;/code&gt; that is not a &lt;code&gt;u64&lt;/code&gt;, as most systems do not have a standardised &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u128.html&quot;&gt;&lt;code&gt;u128&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf97ad06e74edf68697dac1b4dcee83cfa2a22b5" translate="yes" xml:space="preserve">
          <source>This type will always be &lt;a href=&quot;../../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;. Most notably, many Linux-based systems assume an &lt;code&gt;i64&lt;/code&gt;, but Windows assumes &lt;code&gt;i32&lt;/code&gt;. The C standard technically only requires that this type be a signed integer that is at least 32 bits and at least the size of an &lt;a href=&quot;type.c_int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;, although in practice, no system would have a &lt;code&gt;long&lt;/code&gt; that is neither an &lt;code&gt;i32&lt;/code&gt; nor &lt;code&gt;i64&lt;/code&gt;.</source>
          <target state="translated">Este tipo siempre ser&amp;aacute; &lt;a href=&quot;../../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;../../primitive.i64&quot;&gt; &lt;code&gt;i64&lt;/code&gt; &lt;/a&gt; . En particular, muchos sistemas basados ​​en Linux asumen un &lt;code&gt;i64&lt;/code&gt; , pero Windows asume &lt;code&gt;i32&lt;/code&gt; . El est&amp;aacute;ndar C t&amp;eacute;cnicamente solo requiere que este tipo sea un entero con signo que tenga al menos 32 bits y al menos el tama&amp;ntilde;o de un &lt;a href=&quot;type.c_int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; , aunque en la pr&amp;aacute;ctica, ning&amp;uacute;n sistema tendr&amp;iacute;a un &lt;code&gt;long&lt;/code&gt; que no sea ni &lt;code&gt;i32&lt;/code&gt; ni &lt;code&gt;i64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7164487891e0a7833d4edf15c16beda44c3572d5" translate="yes" xml:space="preserve">
          <source>This type will always be &lt;a href=&quot;../../primitive.i8&quot;&gt;&lt;code&gt;i8&lt;/code&gt;&lt;/a&gt;, but is included for completeness. It is defined as being a signed integer the same size as a C &lt;a href=&quot;type.c_char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Este tipo siempre ser&amp;aacute; &lt;a href=&quot;../../primitive.i8&quot;&gt; &lt;code&gt;i8&lt;/code&gt; &lt;/a&gt; , pero se incluye para completar. Se define como un entero con signo del mismo tama&amp;ntilde;o que un &lt;a href=&quot;type.c_char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; C .</target>
        </trans-unit>
        <trans-unit id="9ffb84596c9e59eea63cf919456fbd81bc2d5347" translate="yes" xml:space="preserve">
          <source>This type will always be &lt;a href=&quot;../../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../primitive.u64&quot;&gt;&lt;code&gt;u64&lt;/code&gt;&lt;/a&gt;. Most notably, many Linux-based systems assume an &lt;code&gt;u64&lt;/code&gt;, but Windows assumes &lt;code&gt;u32&lt;/code&gt;. The C standard technically only requires that this type be an unsigned integer with the size of a &lt;a href=&quot;type.c_long&quot;&gt;&lt;code&gt;long&lt;/code&gt;&lt;/a&gt;, although in practice, no system would have a &lt;code&gt;ulong&lt;/code&gt; that is neither a &lt;code&gt;u32&lt;/code&gt; nor &lt;code&gt;u64&lt;/code&gt;.</source>
          <target state="translated">Este tipo siempre ser&amp;aacute; &lt;a href=&quot;../../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;../../primitive.u64&quot;&gt; &lt;code&gt;u64&lt;/code&gt; &lt;/a&gt; . M&amp;aacute;s notablemente, muchos sistemas basados ​​en Linux asumen un &lt;code&gt;u64&lt;/code&gt; , pero Windows asume &lt;code&gt;u32&lt;/code&gt; . El est&amp;aacute;ndar C t&amp;eacute;cnicamente solo requiere que este tipo sea un entero sin signo con el tama&amp;ntilde;o de un &lt;a href=&quot;type.c_long&quot;&gt; &lt;code&gt;long&lt;/code&gt; &lt;/a&gt; , aunque en la pr&amp;aacute;ctica ning&amp;uacute;n sistema tendr&amp;iacute;a un &lt;code&gt;ulong&lt;/code&gt; que no sea ni &lt;code&gt;u32&lt;/code&gt; ni &lt;code&gt;u64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="702c3c35c3eb36099eb087128d0090cf4cdc5cb9" translate="yes" xml:space="preserve">
          <source>This type will always be &lt;a href=&quot;../../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;, but is included for completeness. It is defined as being an unsigned integer the same size as a C &lt;a href=&quot;type.c_char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Este tipo siempre ser&amp;aacute; &lt;a href=&quot;../../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; , pero se incluye para completar. Se define como un entero sin signo del mismo tama&amp;ntilde;o que un &lt;a href=&quot;type.c_char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; C .</target>
        </trans-unit>
        <trans-unit id="3bd4e6f17c1fadac181d74e7c6fccf81e88a4338" translate="yes" xml:space="preserve">
          <source>This type will always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.i32.html&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.i64.html&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;. Most notably, many Linux-based systems assume an &lt;code&gt;i64&lt;/code&gt;, but Windows assumes &lt;code&gt;i32&lt;/code&gt;. The C standard technically only requires that this type be a signed integer that is at least 32 bits and at least the size of an &lt;a href=&quot;type.c_int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;, although in practice, no system would have a &lt;code&gt;long&lt;/code&gt; that is neither an &lt;code&gt;i32&lt;/code&gt; nor &lt;code&gt;i64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d40fc3671ec7ae824bd7929d61ce78e74ef07a2" translate="yes" xml:space="preserve">
          <source>This type will always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.i8.html&quot;&gt;&lt;code&gt;i8&lt;/code&gt;&lt;/a&gt;, but is included for completeness. It is defined as being a signed integer the same size as a C &lt;a href=&quot;type.c_char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a9f45d2d1c5aca56d0bed11f4011cece6101639" translate="yes" xml:space="preserve">
          <source>This type will always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u32.html&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u64.html&quot;&gt;&lt;code&gt;u64&lt;/code&gt;&lt;/a&gt;. Most notably, many Linux-based systems assume an &lt;code&gt;u64&lt;/code&gt;, but Windows assumes &lt;code&gt;u32&lt;/code&gt;. The C standard technically only requires that this type be an unsigned integer with the size of a &lt;a href=&quot;type.c_long&quot;&gt;&lt;code&gt;long&lt;/code&gt;&lt;/a&gt;, although in practice, no system would have a &lt;code&gt;ulong&lt;/code&gt; that is neither a &lt;code&gt;u32&lt;/code&gt; nor &lt;code&gt;u64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb106d3debd5b58c7a1ae3e283c55499cf8e5484" translate="yes" xml:space="preserve">
          <source>This type will always be &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;, but is included for completeness. It is defined as being an unsigned integer the same size as a C &lt;a href=&quot;type.c_char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4424cbb3fbb90751454ec3bf9577dceb9d9a320d" translate="yes" xml:space="preserve">
          <source>This typedef is generally used to avoid writing out &lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;io::Error&lt;/code&gt;&lt;/a&gt; directly and is otherwise a direct mapping to &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Este typedef se usa generalmente para evitar escribir &lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;io::Error&lt;/code&gt; &lt;/a&gt; directamente y, de lo contrario, es una asignaci&amp;oacute;n directa a &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9571d5615d4085a615ed7c5ad4cadc1ded956713" translate="yes" xml:space="preserve">
          <source>This typically means that an operation could only succeed if it read a particular number of bytes but only a smaller number of bytes could be read.</source>
          <target state="translated">Esto significa típicamente que una operación sólo podría tener éxito si leyera un número determinado de bytes,pero sólo se podría leer un número menor de bytes.</target>
        </trans-unit>
        <trans-unit id="692f047748f56fd7b6dd085f2d1ee90a117e619a" translate="yes" xml:space="preserve">
          <source>This typically means that an operation could only succeed if it wrote a particular number of bytes but only a smaller number of bytes could be written.</source>
          <target state="translated">Esto significa típicamente que una operación sólo podría tener éxito si escribiera un número determinado de bytes,pero sólo se podría escribir un número menor de bytes.</target>
        </trans-unit>
        <trans-unit id="066666922981580e3c6ec7b57246e05ce6d242d4" translate="yes" xml:space="preserve">
          <source>This usage of &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; to create safe nullable pointers is so common that Rust does special optimizations to make the representation of &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; a single pointer. Optional pointers in Rust are stored as efficiently as any other pointer type.</source>
          <target state="translated">Este uso de &lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; para crear punteros seguros que aceptan valores NULL es tan com&amp;uacute;n que Rust realiza optimizaciones especiales para hacer que la representaci&amp;oacute;n de &lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; sea un solo puntero. Los punteros opcionales en Rust se almacenan de manera tan eficiente como cualquier otro tipo de puntero.</target>
        </trans-unit>
        <trans-unit id="3473dac5d293883be110e74db63b95a407d1ea5c" translate="yes" xml:space="preserve">
          <source>This usage of &lt;code&gt;extern&lt;/code&gt; does not require &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">Este uso de &lt;code&gt;extern&lt;/code&gt; no requiere &lt;code&gt;unsafe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d52ccca3efa09c9ce1760baf0a04fa97e3aed552" translate="yes" xml:space="preserve">
          <source>This use of a &lt;code&gt;where&lt;/code&gt; clause is strange - a more common usage would look something like the following:</source>
          <target state="translated">Este uso de una cl&amp;aacute;usula &lt;code&gt;where&lt;/code&gt; es extra&amp;ntilde;o; un uso m&amp;aacute;s com&amp;uacute;n se ver&amp;iacute;a as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="3ee77b0606c712a9409edf4f68e92618c8d2ee4a" translate="yes" xml:space="preserve">
          <source>This value is not suitable for passing to &lt;code&gt;Path::new&lt;/code&gt; or similar constructors when the host platform and target platform differ.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ededb49250daf0db79bbb927c06d879d238521da" translate="yes" xml:space="preserve">
          <source>This value sets the time-to-live field that is used in every packet sent from this socket.</source>
          <target state="translated">Este valor establece el campo de tiempo de vida que se utiliza en cada paquete enviado desde este enchufe.</target>
        </trans-unit>
        <trans-unit id="75beec589ecae6a039a7d01c52fb4b4aea8d427f" translate="yes" xml:space="preserve">
          <source>This value should be considered only a hint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d769cb0769d945ca70d65f4d25befb01295f124d" translate="yes" xml:space="preserve">
          <source>This variant is also constructed when a &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; is misplaced within a string either on its own or in the middle of a number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="413d9b4dc5521012c4ffcf2dbef4c140f61e2a52" translate="yes" xml:space="preserve">
          <source>This variant is the most common one, it represents references to files or directories.</source>
          <target state="translated">Esta variante es la más común,representa referencias a archivos o directorios.</target>
        </trans-unit>
        <trans-unit id="8ad9c1ff17fcdcd8bc09eee76d183971a27c0cfe" translate="yes" xml:space="preserve">
          <source>This variant will be emitted when the parsing string has a value of zero, which would be illegal for non-zero types.</source>
          <target state="translated">Esta variante se emitirá cuando la cadena de análisis tenga un valor de cero,lo que sería ilegal para los tipos que no sean cero.</target>
        </trans-unit>
        <trans-unit id="f262b16f3428e356cf4b0dde5dbe8613ec4091d5" translate="yes" xml:space="preserve">
          <source>This version of the text assumes you&amp;rsquo;re using Rust 1.41.0 or later with &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in &lt;em&gt;Cargo.toml&lt;/em&gt; of all projects to use Rust 2018 Edition idioms. See the &lt;a href=&quot;book/ch01-01-installation&quot;&gt;&amp;ldquo;Installation&amp;rdquo; section of Chapter 1&lt;/a&gt; to install or update Rust, and see the new &lt;a href=&quot;book/appendix-05-editions&quot;&gt;Appendix E&lt;/a&gt; for information on editions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e89485f5fe729fa0419251d6d1b6a0bc0fb1791" translate="yes" xml:space="preserve">
          <source>This version of the text assumes you&amp;rsquo;re using Rust 1.41.0 or later with &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in &lt;em&gt;Cargo.toml&lt;/em&gt; of all projects to use Rust 2018 Edition idioms. See the &lt;a href=&quot;ch01-01-installation&quot;&gt;&amp;ldquo;Installation&amp;rdquo; section of Chapter 1&lt;/a&gt; to install or update Rust, and see the new &lt;a href=&quot;appendix-05-editions&quot;&gt;Appendix E&lt;/a&gt; for information on editions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="676fb636ec3ef59315a4dc9ef64f5fbe3403351d" translate="yes" xml:space="preserve">
          <source>This way, the lifetime of the &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt; in &lt;code&gt;hello&lt;/code&gt; encompasses the lifetime of &lt;code&gt;ptr&lt;/code&gt; and the &lt;code&gt;unsafe&lt;/code&gt; block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0051a5a0c2153685b22e3e481253428438ae9b0d" translate="yes" xml:space="preserve">
          <source>This way, the lifetime of the &lt;code&gt;CString&lt;/code&gt; in &lt;code&gt;hello&lt;/code&gt; encompasses the lifetime of &lt;code&gt;ptr&lt;/code&gt; and the &lt;code&gt;unsafe&lt;/code&gt; block.</source>
          <target state="translated">De esta manera, la vida &amp;uacute;til de &lt;code&gt;CString&lt;/code&gt; en &lt;code&gt;hello&lt;/code&gt; abarca la vida &amp;uacute;til de &lt;code&gt;ptr&lt;/code&gt; y el bloque &lt;code&gt;unsafe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a66e53cbccdcf1dd0b129068e28220aa1da407b" translate="yes" xml:space="preserve">
          <source>This will allocate as many times as needed for constructing the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; and then it will allocate once for turning the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; into the &lt;code&gt;Arc&amp;lt;[T]&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be23e02db6f58e9303929f35bcf996dc6954c461" translate="yes" xml:space="preserve">
          <source>This will allocate as many times as needed for constructing the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; and then it will allocate once for turning the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; into the &lt;code&gt;Rc&amp;lt;[T]&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c87576c37932e7e920719c7c3053295204953101" translate="yes" xml:space="preserve">
          <source>This will always &lt;a href=&quot;macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&amp;iexcl;Esto siempre entrar&amp;aacute; en &lt;a href=&quot;macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1c37af121800fff05f23ea7195ec86eae7b112d6" translate="yes" xml:space="preserve">
          <source>This will always &lt;a href=&quot;macro.panic&quot;&gt;panic!&lt;/a&gt;</source>
          <target state="translated">&amp;iexcl;Esto siempre entrar&amp;aacute; en &lt;a href=&quot;macro.panic&quot;&gt;p&amp;aacute;nico!&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f7ba30b4423020d7c6174593849644ce672a970c" translate="yes" xml:space="preserve">
          <source>This will always &lt;a href=&quot;macro.panic&quot;&gt;panic!&lt;/a&gt; because &lt;code&gt;unimplemented!&lt;/code&gt; is just a shorthand for &lt;code&gt;panic!&lt;/code&gt; with a fixed, specific message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca9dc67930c6219a678b4690efb3c9a2b4b3cc3e" translate="yes" xml:space="preserve">
          <source>This will be a max-heap.</source>
          <target state="translated">Esto será un montón.</target>
        </trans-unit>
        <trans-unit id="835f899ffcb476aee6b318f9e24a76f9e21b8043" translate="yes" xml:space="preserve">
          <source>This will be allowed at some point in the future, but the implementation is not yet complete. See the &lt;a href=&quot;https://github.com/rust-lang/rust/issues/61949&quot;&gt;issue-61949&lt;/a&gt; for this limitation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="850691bcf932c0c55cd89eb4535ca90e22acf61f" translate="yes" xml:space="preserve">
          <source>This will be allowed at some point in the future, but the implementation is not yet complete. See the tracking issue for &lt;a href=&quot;https://github.com/rust-lang/rust/issues/49146&quot;&gt;conditionals&lt;/a&gt; or &lt;a href=&quot;https://github.com/rust-lang/rust/issues/52000&quot;&gt;loops&lt;/a&gt; in a const context for the current status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fffbe8e22b797d8b6890d54d873414453d3490a" translate="yes" xml:space="preserve">
          <source>This will cause an error:</source>
          <target state="translated">Esto causará un error:</target>
        </trans-unit>
        <trans-unit id="5b06471f77c7403c58187c73c7a664a50663e032" translate="yes" xml:space="preserve">
          <source>This will commonly, but not always, be a &lt;code&gt;&amp;amp;'static str&lt;/code&gt; or &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esto com&amp;uacute;nmente, pero no siempre, ser&amp;aacute; un &lt;code&gt;&amp;amp;'static str&lt;/code&gt; o &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; est&amp;aacute;tico .</target>
        </trans-unit>
        <trans-unit id="1a8b17614cf7c240a7a1eb116da8eea5f59c7b71" translate="yes" xml:space="preserve">
          <source>This will compile, because it has the constraint on the type parameter:</source>
          <target state="translated">Esto compilará,porque tiene la restricción del parámetro de tipo:</target>
        </trans-unit>
        <trans-unit id="3520fed49c822ab60288ef2f8f669d15b4a41e6f" translate="yes" xml:space="preserve">
          <source>This will compile:</source>
          <target state="translated">Esto se compilará:</target>
        </trans-unit>
        <trans-unit id="49cc821a81b4f339dbb259efc2d82e6ee470759f" translate="yes" xml:space="preserve">
          <source>This will create a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; from the &lt;code&gt;String&lt;/code&gt; and pass it in. This conversion is very inexpensive, and so generally, functions will accept &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;s as arguments unless they need a &lt;code&gt;String&lt;/code&gt; for some specific reason.</source>
          <target state="translated">Esto crear&amp;aacute; un &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; partir de &lt;code&gt;String&lt;/code&gt; y lo pasar&amp;aacute;. Esta conversi&amp;oacute;n es muy econ&amp;oacute;mica y, por lo general, las funciones aceptar&amp;aacute;n &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; s como argumentos a menos que necesiten un &lt;code&gt;String&lt;/code&gt; por alguna raz&amp;oacute;n espec&amp;iacute;fica.</target>
        </trans-unit>
        <trans-unit id="1b5cc9b9f228f1bae8ee73a71afeed4d549dd793" translate="yes" xml:space="preserve">
          <source>This will create a thread using default parameters of &lt;a href=&quot;struct.builder&quot;&gt;&lt;code&gt;Builder&lt;/code&gt;&lt;/a&gt;, if you want to specify the stack size or the name of the thread, use this API instead.</source>
          <target state="translated">Esto crear&amp;aacute; un hilo usando los par&amp;aacute;metros predeterminados de &lt;a href=&quot;struct.builder&quot;&gt; &lt;code&gt;Builder&lt;/code&gt; .&lt;/a&gt; , si desea especificar el tama&amp;ntilde;o de la pila o el nombre del hilo, use esta API en su lugar.</target>
        </trans-unit>
        <trans-unit id="e391cc107c46641450ffa0654fcfb8cbca70a73b" translate="yes" xml:space="preserve">
          <source>This will decrement the strong reference count. If the strong reference count reaches zero then the only other references (if any) are &lt;a href=&quot;../rc/struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt;, so we &lt;code&gt;drop&lt;/code&gt; the inner value.</source>
          <target state="translated">Esto disminuir&amp;aacute; el recuento de referencias fuertes. Si el recuento de referencias fuertes llega a cero, las &amp;uacute;nicas otras referencias (si las hay) son &lt;a href=&quot;../rc/struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; , por lo que &lt;code&gt;drop&lt;/code&gt; el valor interno.</target>
        </trans-unit>
        <trans-unit id="97b7f84f70f9d3f5d6303968924e2733780bc78b" translate="yes" xml:space="preserve">
          <source>This will decrement the strong reference count. If the strong reference count reaches zero then the only other references (if any) are &lt;a href=&quot;../sync/struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt;, so we &lt;code&gt;drop&lt;/code&gt; the inner value.</source>
          <target state="translated">Esto disminuir&amp;aacute; el recuento de referencias fuertes. Si el recuento de referencias fuertes llega a cero, las &amp;uacute;nicas otras referencias (si las hay) son &lt;a href=&quot;../sync/struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; , por lo que &lt;code&gt;drop&lt;/code&gt; el valor interno.</target>
        </trans-unit>
        <trans-unit id="b917396cbcb63b72ec008aadc499d642c7abbf61" translate="yes" xml:space="preserve">
          <source>This will decrement the strong reference count. If the strong reference count reaches zero then the only other references (if any) are &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt;, so we &lt;code&gt;drop&lt;/code&gt; the inner value.</source>
          <target state="translated">Esto disminuir&amp;aacute; el recuento de referencias fuertes. Si el recuento de referencias fuertes llega a cero, las &amp;uacute;nicas otras referencias (si las hay) son &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; , por lo que &lt;code&gt;drop&lt;/code&gt; el valor interno.</target>
        </trans-unit>
        <trans-unit id="0e9819c7b2177172935ef1092ecc4f74eaf1578f" translate="yes" xml:space="preserve">
          <source>This will drop any excess capacity.</source>
          <target state="translated">Esto reducirá cualquier exceso de capacidad.</target>
        </trans-unit>
        <trans-unit id="354a015dbdb2ab35ae4e0b061d1f50f5025f7cbe" translate="yes" xml:space="preserve">
          <source>This will escape characters with the Rust syntax of the form &lt;code&gt;\u{NNNNNN}&lt;/code&gt; where &lt;code&gt;NNNNNN&lt;/code&gt; is a hexadecimal representation.</source>
          <target state="translated">Esto escapar&amp;aacute; a los caracteres con la sintaxis de Rust de la forma &lt;code&gt;\u{NNNNNN}&lt;/code&gt; donde &lt;code&gt;NNNNNN&lt;/code&gt; es una representaci&amp;oacute;n hexadecimal.</target>
        </trans-unit>
        <trans-unit id="c51882eef9b6927fb20dc2b079d5f33d822ffcef" translate="yes" xml:space="preserve">
          <source>This will escape the characters similar to the &lt;code&gt;Debug&lt;/code&gt; implementations of &lt;code&gt;str&lt;/code&gt; or &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">Esto evitar&amp;aacute; los caracteres similares a las implementaciones de &lt;code&gt;Debug&lt;/code&gt; de &lt;code&gt;str&lt;/code&gt; o &lt;code&gt;char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7463a3fbad059d7822b7a64865f64ec71f56ca6c" translate="yes" xml:space="preserve">
          <source>This will fail because the compiler does not know which instance of &lt;code&gt;Foo&lt;/code&gt; to call &lt;code&gt;bar&lt;/code&gt; on. Change &lt;code&gt;Foo::bar()&lt;/code&gt; to &lt;code&gt;Foo::&amp;lt;T&amp;gt;::bar()&lt;/code&gt; to resolve the error.</source>
          <target state="translated">Esto fallar&amp;aacute; porque el compilador no sabe en qu&amp;eacute; instancia de &lt;code&gt;Foo&lt;/code&gt; llamar a &lt;code&gt;bar&lt;/code&gt; . Cambie &lt;code&gt;Foo::bar()&lt;/code&gt; a &lt;code&gt;Foo::&amp;lt;T&amp;gt;::bar()&lt;/code&gt; para resolver el error.</target>
        </trans-unit>
        <trans-unit id="b95565727f175f666e1822f4733ae91ef6a1780e" translate="yes" xml:space="preserve">
          <source>This will fail to compile because we cannot implement a trait for a type if both the trait and the type are not defined by the current crate. This is due to Rust's orphaning rules. To bypass this, you can implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; directly:</source>
          <target state="translated">Esto no se compilar&amp;aacute; porque no podemos implementar un rasgo para un tipo si tanto el rasgo como el tipo no est&amp;aacute;n definidos por la caja actual. Esto se debe a las reglas de hu&amp;eacute;rfano de Rust. Para evitar esto, puede implementar &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; directamente:</target>
        </trans-unit>
        <trans-unit id="8648eb6ea2730446e0cfb046319d740aba54d8bb" translate="yes" xml:space="preserve">
          <source>This will fail to compile in older versions of the language because Rust's orphaning rules used to be a little bit more strict. To bypass this, you could implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; directly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c41f14d1e2c5310aaa0b927129f701a7031c03a" translate="yes" xml:space="preserve">
          <source>This will invoke the &lt;a href=&quot;macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; macro if the provided expression cannot be evaluated to &lt;code&gt;true&lt;/code&gt; at runtime.</source>
          <target state="translated">&amp;iexcl;Esto invocar&amp;aacute; el &lt;a href=&quot;macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;macro si la expresi&amp;oacute;n proporcionada no se puede evaluar como &lt;code&gt;true&lt;/code&gt; en tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="2deb5f847f234caa59a2e70f4ab65edaeb2fdead" translate="yes" xml:space="preserve">
          <source>This will lazily initialize the value if this thread has not referenced this key yet.</source>
          <target state="translated">Esto inicializará perezosamente el valor si este hilo no ha hecho referencia a esta clave todavía.</target>
        </trans-unit>
        <trans-unit id="2be746d77ee47101c5a961aeebfbec50b6101d49" translate="yes" xml:space="preserve">
          <source>This will lazily initialize the value if this thread has not referenced this key yet. If the key has been destroyed (which may happen if this is called in a destructor), this function will return an &lt;a href=&quot;struct.accesserror&quot;&gt;&lt;code&gt;AccessError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esto inicializar&amp;aacute; perezosamente el valor si este hilo a&amp;uacute;n no ha hecho referencia a esta clave. Si la clave ha sido destruida (lo que puede suceder si se llama a esto en un destructor), esta funci&amp;oacute;n devolver&amp;aacute; un &lt;a href=&quot;struct.accesserror&quot;&gt; &lt;code&gt;AccessError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3800eafd69cf59aa81eb6bb72cb9493004b5c43e" translate="yes" xml:space="preserve">
          <source>This will make &lt;code&gt;CASE_INSENSITIVE&lt;/code&gt; persist for the remainder of your shell session. It can be unset with the &lt;code&gt;Remove-Item&lt;/code&gt; cmdlet:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b457d7ac05dde73ffae7dfa5283d452dba90a68" translate="yes" xml:space="preserve">
          <source>This will not print any values, as we only created an iterator, rather than using it. The compiler will warn us about this kind of behavior:</source>
          <target state="translated">Esto no imprimirá ningún valor,ya que sólo creamos un iterador,en lugar de utilizarlo.El compilador nos advertirá sobre este tipo de comportamiento:</target>
        </trans-unit>
        <trans-unit id="7884f03c74d608aa53fe96a0fe19b6f01fc64a4e" translate="yes" xml:space="preserve">
          <source>This will not work if the new name is on a different mount point.</source>
          <target state="translated">Esto no funcionará si el nuevo nombre está en un punto de montaje diferente.</target>
        </trans-unit>
        <trans-unit id="29502fa64160996ff78f02e55cbb4b83b39e3b0d" translate="yes" xml:space="preserve">
          <source>This will not:</source>
          <target state="translated">Esto no lo hará:</target>
        </trans-unit>
        <trans-unit id="b5b85ab1e962bdcb10ff35cb96c42d807c436122" translate="yes" xml:space="preserve">
          <source>This will output the following:</source>
          <target state="translated">Esto producirá lo siguiente:</target>
        </trans-unit>
        <trans-unit id="01e646d50274ee113a75cb82fc9f837874518988" translate="yes" xml:space="preserve">
          <source>This will override the &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, and &lt;code&gt;append&lt;/code&gt; flags on the &lt;code&gt;OpenOptions&lt;/code&gt; structure. This method provides fine-grained control over the permissions to read, write and append data, attributes (like hidden and system), and extended attributes.</source>
          <target state="translated">Esto anular&amp;aacute; los indicadores de &lt;code&gt;read&lt;/code&gt; , &lt;code&gt;write&lt;/code&gt; y &lt;code&gt;append&lt;/code&gt; en el &lt;code&gt;OpenOptions&lt;/code&gt; estructura. Este m&amp;eacute;todo proporciona un control detallado sobre los permisos para leer, escribir y agregar datos, atributos (como ocultos y del sistema) y atributos extendidos.</target>
        </trans-unit>
        <trans-unit id="2ed7ee1155828d2b2b40b29d755792b670ff1874" translate="yes" xml:space="preserve">
          <source>This will print</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="475997c398cd5b2921c0cb8cd3f062a1e5e787e7" translate="yes" xml:space="preserve">
          <source>This will print &quot;('a', 1), ('b', 2), ('c', 3)&quot;.</source>
          <target state="translated">Esto imprimirá &quot;('a',1),('b',2),('c',3)&quot;.</target>
        </trans-unit>
        <trans-unit id="3a5f8c78def77453ab00074a3cd30ff4dd27218b" translate="yes" xml:space="preserve">
          <source>This will print &lt;code&gt;1&lt;/code&gt; through &lt;code&gt;5&lt;/code&gt;, each on their own line.</source>
          <target state="translated">Esto imprimir&amp;aacute; del &lt;code&gt;1&lt;/code&gt; al &lt;code&gt;5&lt;/code&gt; , cada uno en su propia l&amp;iacute;nea.</target>
        </trans-unit>
        <trans-unit id="45cc5d4168a6948db8686b2c0a8d37fbb64175cc" translate="yes" xml:space="preserve">
          <source>This will print &lt;code&gt;Cons(1, Cons(2, Nil))&lt;/code&gt;.</source>
          <target state="translated">Esto imprimir&amp;aacute; &lt;code&gt;Cons(1, Cons(2, Nil))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa3cd6bbcdf4b75c4bbd0f80ed7b9518ac88ecb8" translate="yes" xml:space="preserve">
          <source>This will print the numbers &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;4&lt;/code&gt;, each on their own line.</source>
          <target state="translated">Esto imprimir&amp;aacute; los n&amp;uacute;meros del &lt;code&gt;0&lt;/code&gt; al &lt;code&gt;4&lt;/code&gt; , cada uno en su propia l&amp;iacute;nea.</target>
        </trans-unit>
        <trans-unit id="a40fac0ea22a56e98579c9cc97554e4f4a65b5bb" translate="yes" xml:space="preserve">
          <source>This will print the numbers one through five, each on their own line. But you'll notice something here: we never called anything on our vector to produce an iterator. What gives?</source>
          <target state="translated">Esto imprimirá los números del uno al cinco,cada uno en su propia línea.Pero notarán algo aquí:nunca llamamos a nada en nuestro vector para producir un iterador.¿Qué pasa?</target>
        </trans-unit>
        <trans-unit id="6e363eb5c9d1e189e7877f05521713cb961f9afe" translate="yes" xml:space="preserve">
          <source>This will print:</source>
          <target state="translated">Esto se imprimirá:</target>
        </trans-unit>
        <trans-unit id="e3f9d6eebc7d0a9c3006485e1bf2fe9250c18991" translate="yes" xml:space="preserve">
          <source>This will result in &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;recv&lt;/code&gt; and &lt;code&gt;send&lt;/code&gt; operations becoming nonblocking, i.e., immediately returning from their calls. If the IO operation is successful, &lt;code&gt;Ok&lt;/code&gt; is returned and no further action is required. If the IO operation could not be completed and needs to be retried, an error with kind &lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt;&lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">Esto dar&amp;aacute; como resultado que las operaciones de &lt;code&gt;read&lt;/code&gt; , &lt;code&gt;write&lt;/code&gt; , &lt;code&gt;recv&lt;/code&gt; y &lt;code&gt;send&lt;/code&gt; se bloqueen, es decir, que regresen inmediatamente de sus llamadas. Si la operaci&amp;oacute;n de E / S tiene &amp;eacute;xito, se devuelve &lt;code&gt;Ok&lt;/code&gt; y no se requiere ninguna otra acci&amp;oacute;n. Si la operaci&amp;oacute;n de E / S no se pudo completar y es necesario volver a intentarlo, se devuelve un error con el tipo &lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt; &lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4b3da21af1f8f50bfb5fb08b425cfbfeb0c3196a" translate="yes" xml:space="preserve">
          <source>This will result in &lt;code&gt;recv&lt;/code&gt;, &lt;code&gt;recv_from&lt;/code&gt;, &lt;code&gt;send&lt;/code&gt;, and &lt;code&gt;send_to&lt;/code&gt; operations becoming nonblocking, i.e., immediately returning from their calls. If the IO operation is successful, &lt;code&gt;Ok&lt;/code&gt; is returned and no further action is required. If the IO operation could not be completed and needs to be retried, an error with kind &lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt;&lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">Esto dar&amp;aacute; como resultado que las &lt;code&gt;recv_from&lt;/code&gt; &lt;code&gt;recv&lt;/code&gt; , recv_from , &lt;code&gt;send&lt;/code&gt; y &lt;code&gt;send_to&lt;/code&gt; se conviertan en no bloqueantes, es decir, que regresen inmediatamente de sus llamadas. Si la operaci&amp;oacute;n de E / S tiene &amp;eacute;xito, se devuelve &lt;code&gt;Ok&lt;/code&gt; y no se requiere ninguna otra acci&amp;oacute;n. Si la operaci&amp;oacute;n de E / S no se pudo completar y es necesario volver a intentarlo, se devuelve un error con el tipo &lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt; &lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5f9e536d8780a7dfeadd69ff71cc712be79eb591" translate="yes" xml:space="preserve">
          <source>This will result in the &lt;code&gt;accept&lt;/code&gt; operation becoming nonblocking, i.e., immediately returning from their calls. If the IO operation is successful, &lt;code&gt;Ok&lt;/code&gt; is returned and no further action is required. If the IO operation could not be completed and needs to be retried, an error with kind &lt;a href=&quot;../../../io/enum.errorkind#variant.WouldBlock&quot;&gt;&lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62e7ab507f523fe704d7f615781e7105b958a139" translate="yes" xml:space="preserve">
          <source>This will result in the &lt;code&gt;accept&lt;/code&gt; operation becoming nonblocking, i.e., immediately returning from their calls. If the IO operation is successful, &lt;code&gt;Ok&lt;/code&gt; is returned and no further action is required. If the IO operation could not be completed and needs to be retried, an error with kind &lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt;&lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">Esto dar&amp;aacute; como resultado que la operaci&amp;oacute;n de &lt;code&gt;accept&lt;/code&gt; vuelva no bloqueante, es decir, que regresen inmediatamente de sus llamadas. Si la operaci&amp;oacute;n de E / S tiene &amp;eacute;xito, se devuelve &lt;code&gt;Ok&lt;/code&gt; y no se requiere ninguna otra acci&amp;oacute;n. Si la operaci&amp;oacute;n de E / S no se pudo completar y es necesario volver a intentarlo, se devuelve un error con el tipo &lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt; &lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b55e73be7a2382bca6297d35304f77d90844f6fa" translate="yes" xml:space="preserve">
          <source>This will retrieve the stored error in the underlying socket, clearing the field in the process. This can be useful for checking errors between calls.</source>
          <target state="translated">Esto recuperará el error almacenado en el zócalo subyacente,despejando el campo en el proceso.Esto puede ser útil para comprobar los errores entre las llamadas.</target>
        </trans-unit>
        <trans-unit id="88ce8a4d0f2f6725fab10313d205fd945723d024" translate="yes" xml:space="preserve">
          <source>This will return &lt;code&gt;None&lt;/code&gt; if the &lt;code&gt;Metadata&lt;/code&gt; instance was created from a call to &lt;code&gt;DirEntry::metadata&lt;/code&gt;. If this &lt;code&gt;Metadata&lt;/code&gt; was created by using &lt;code&gt;fs::metadata&lt;/code&gt; or &lt;code&gt;File::metadata&lt;/code&gt;, then this will return &lt;code&gt;Some&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f194e7c7453fbebb97c4d612baa72decde0dd60" translate="yes" xml:space="preserve">
          <source>This will return an error when the IP version of the local socket does not match that returned from &lt;a href=&quot;trait.tosocketaddrs&quot;&gt;&lt;code&gt;ToSocketAddrs&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esto devolver&amp;aacute; un error cuando la versi&amp;oacute;n IP del socket local no coincida con la devuelta por &lt;a href=&quot;trait.tosocketaddrs&quot;&gt; &lt;code&gt;ToSocketAddrs&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fc0cdcc30572aec7d1df1cbb47d079cf5a14ac66" translate="yes" xml:space="preserve">
          <source>This will succeed even if there are outstanding weak references.</source>
          <target state="translated">Esto tendrá éxito incluso si hay referencias débiles sobresalientes.</target>
        </trans-unit>
        <trans-unit id="2bd1f4c0ae47dc79d8ec8c7bba4ba6b5d8664eba" translate="yes" xml:space="preserve">
          <source>This will use &lt;code&gt;clone&lt;/code&gt; to duplicate an expression, so one should be careful using this with types having a nonstandard &lt;code&gt;Clone&lt;/code&gt; implementation. For example, &lt;code&gt;vec![Rc::new(1); 5]&lt;/code&gt; will create a vector of five references to the same boxed integer value, not five references pointing to independently boxed integers.</source>
          <target state="translated">Esto usar&amp;aacute; &lt;code&gt;clone&lt;/code&gt; para duplicar una expresi&amp;oacute;n, por lo que se debe tener cuidado al usar esto con tipos que tienen una implementaci&amp;oacute;n de &lt;code&gt;Clone&lt;/code&gt; no est&amp;aacute;ndar . Por ejemplo, &lt;code&gt;vec![Rc::new(1); 5]&lt;/code&gt; crear&amp;aacute; un vector de cinco referencias al mismo valor entero en caja, no cinco referencias que apunten a n&amp;uacute;meros enteros en caja independientemente.</target>
        </trans-unit>
        <trans-unit id="1af0f8715542d97c1e40ad188906242d9ebb10f7" translate="yes" xml:space="preserve">
          <source>This works because &lt;code&gt;Box&lt;/code&gt; is a pointer, so its size is well-known.</source>
          <target state="translated">Esto funciona porque &lt;code&gt;Box&lt;/code&gt; es un puntero, por lo que su tama&amp;ntilde;o es bien conocido.</target>
        </trans-unit>
        <trans-unit id="e6ae7145b95212826784b081e816d005693796fd" translate="yes" xml:space="preserve">
          <source>This works differently from defining a struct that uses a generic type parameter with trait bounds. A generic type parameter can only be substituted with one concrete type at a time, whereas trait objects allow for multiple concrete types to fill in for the trait object at runtime. For example, we could have defined the &lt;code&gt;Screen&lt;/code&gt; struct using a generic type and a trait bound as in Listing 17-6:</source>
          <target state="translated">Esto funciona de manera diferente a la definici&amp;oacute;n de una estructura que usa un par&amp;aacute;metro de tipo gen&amp;eacute;rico con l&amp;iacute;mites de rasgos. Un par&amp;aacute;metro de tipo gen&amp;eacute;rico solo se puede sustituir por un tipo concreto a la vez, mientras que los objetos de rasgo permiten que varios tipos concretos completen el objeto de rasgo en tiempo de ejecuci&amp;oacute;n. Por ejemplo, podr&amp;iacute;amos haber definido la estructura &lt;code&gt;Screen&lt;/code&gt; usando un tipo gen&amp;eacute;rico y un l&amp;iacute;mite de rasgo como en el Listado 17-6:</target>
        </trans-unit>
        <trans-unit id="a99f3af5ecd17821d147ce27f764af7ca400396e" translate="yes" xml:space="preserve">
          <source>This works fine, but when the method gains generic parameters, we can have a problem.</source>
          <target state="translated">Esto funciona bien,pero cuando el método gana parámetros genéricos,podemos tener un problema.</target>
        </trans-unit>
        <trans-unit id="d71531129bdd4b29a09ed683d862d9540e2e5d1c" translate="yes" xml:space="preserve">
          <source>This works just fine and explicitly produces the behavior shown in Figure 4-3, where the heap data &lt;em&gt;does&lt;/em&gt; get copied.</source>
          <target state="translated">Esto funciona muy bien y produce expl&amp;iacute;citamente el comportamiento se muestra en la Figura 4-3, donde el mont&amp;oacute;n de datos &lt;em&gt;no&lt;/em&gt; se copian.</target>
        </trans-unit>
        <trans-unit id="bfbfb994099b13008a48f4d00df577d26e30661c" translate="yes" xml:space="preserve">
          <source>This works without any problems. Ownership is moved out, and nothing is deallocated.</source>
          <target state="translated">Esto funciona sin problemas.La propiedad se traslada,y nada se reparte.</target>
        </trans-unit>
        <trans-unit id="6c438e4eca96ad10f658e6fd464bdd00bbab9e0b" translate="yes" xml:space="preserve">
          <source>This wrapper helps with explicitly documenting the drop order dependencies between fields of the type:</source>
          <target state="translated">Este envoltorio ayuda a documentar explícitamente las dependencias de la orden de entrega entre los campos del tipo:</target>
        </trans-unit>
        <trans-unit id="77c94458816b78e926120564c533b185a38f9981" translate="yes" xml:space="preserve">
          <source>This wrapper is 0-cost.</source>
          <target state="translated">Este envoltorio tiene un costo cero.</target>
        </trans-unit>
        <trans-unit id="bb9a9b150cc6f7bfa7d25085c5da29bd09b9aebf" translate="yes" xml:space="preserve">
          <source>This zero-sized type &lt;em&gt;coerces&lt;/em&gt; to a regular function pointer. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8adf6fbbeb84fc23d69997d38f588cc8535a0a6a" translate="yes" xml:space="preserve">
          <source>Though they both have scary names, &lt;code&gt;PhantomData&lt;/code&gt; and 'phantom types' are related, but not identical. A phantom type parameter is simply a type parameter which is never used. In Rust, this often causes the compiler to complain, and the solution is to add a &quot;dummy&quot; use by way of &lt;code&gt;PhantomData&lt;/code&gt;.</source>
          <target state="translated">Aunque ambos tienen nombres aterradores, &lt;code&gt;PhantomData&lt;/code&gt; y los 'tipos fantasmas' est&amp;aacute;n relacionados, pero no son id&amp;eacute;nticos. Un par&amp;aacute;metro de tipo fantasma es simplemente un par&amp;aacute;metro de tipo que nunca se utiliza. En Rust, esto a menudo hace que el compilador se queje, y la soluci&amp;oacute;n es agregar un uso &quot;ficticio&quot; a trav&amp;eacute;s de &lt;code&gt;PhantomData&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="394004c26aaecc036ffcf91c8fc18935b18646a0" translate="yes" xml:space="preserve">
          <source>Though this example seems innocuous and easy to solve, the problem becomes clear when it encounters functions which consume the value:</source>
          <target state="translated">Aunque este ejemplo parece inofensivo y fácil de resolver,el problema se hace evidente cuando se encuentra con funciones que consumen el valor:</target>
        </trans-unit>
        <trans-unit id="68fc8c5fcce31dacdf37236f648493191d2504be" translate="yes" xml:space="preserve">
          <source>Though this method is safe for any two pointers, note that its result will be mostly useless if the two pointers aren't into the same allocated object, for example if they point to two different local variables.</source>
          <target state="translated">Aunque este método es seguro para dos punteros cualesquiera,nótese que su resultado será mayormente inútil si los dos punteros no están en el mismo objeto asignado,por ejemplo si apuntan a dos variables locales diferentes.</target>
        </trans-unit>
        <trans-unit id="7863f7503e5377891a3b7452c7d6cc377d443fe7" translate="yes" xml:space="preserve">
          <source>Thread</source>
          <target state="translated">Thread</target>
        </trans-unit>
        <trans-unit id="b66b6cbe04365929e922b75680e179e46127f3a3" translate="yes" xml:space="preserve">
          <source>Thread Safety</source>
          <target state="translated">Seguridad de los hilos</target>
        </trans-unit>
        <trans-unit id="8acbe8abc881f5530528aa5ba52eb0a3d5f4e21c" translate="yes" xml:space="preserve">
          <source>Thread factory, which can be used in order to configure the properties of a new thread.</source>
          <target state="translated">Fábrica de hilos,que se puede utilizar para configurar las propiedades de un nuevo hilo.</target>
        </trans-unit>
        <trans-unit id="3f259cba637903dc7da0506c4d921b66c4b2c1d2" translate="yes" xml:space="preserve">
          <source>Thread with a specified name:</source>
          <target state="translated">Hilo con un nombre específico:</target>
        </trans-unit>
        <trans-unit id="ccd9cecfbe050ef8f7199536919145c98a9ee01e" translate="yes" xml:space="preserve">
          <source>Thread-local storage</source>
          <target state="translated">Almacenamiento local de hilos</target>
        </trans-unit>
        <trans-unit id="031ccc205829651d22cb916d91b65f0a8f208375" translate="yes" xml:space="preserve">
          <source>Thread::borrow</source>
          <target state="translated">Thread::borrow</target>
        </trans-unit>
        <trans-unit id="c95c792ba6b184afddca7a8e36aefd1fbf1d6ade" translate="yes" xml:space="preserve">
          <source>Thread::borrow_mut</source>
          <target state="translated">Thread::borrow_mut</target>
        </trans-unit>
        <trans-unit id="dbb6daabaec761c7c46cdca4426de7d2af20b09f" translate="yes" xml:space="preserve">
          <source>Thread::clone</source>
          <target state="translated">Thread::clone</target>
        </trans-unit>
        <trans-unit id="e27a758e7d203684411b93372f7af767f3888a92" translate="yes" xml:space="preserve">
          <source>Thread::clone_from</source>
          <target state="translated">Thread::clone_from</target>
        </trans-unit>
        <trans-unit id="21aa2dd81c0fa05128232b310f0bc9892cddef0b" translate="yes" xml:space="preserve">
          <source>Thread::clone_into</source>
          <target state="translated">Thread::clone_into</target>
        </trans-unit>
        <trans-unit id="070b95410e1e4362fb02748c2208a536c3a47c62" translate="yes" xml:space="preserve">
          <source>Thread::fmt</source>
          <target state="translated">Thread::fmt</target>
        </trans-unit>
        <trans-unit id="15bec62911f03b003cb69d406b3848ca01770f8f" translate="yes" xml:space="preserve">
          <source>Thread::from</source>
          <target state="translated">Thread::from</target>
        </trans-unit>
        <trans-unit id="4a91eeba81f613beaaf6029aae0e32dad80d38b8" translate="yes" xml:space="preserve">
          <source>Thread::id</source>
          <target state="translated">Thread::id</target>
        </trans-unit>
        <trans-unit id="b2a4ffaaac236ade773000faaa7bef3c1f0cc8f6" translate="yes" xml:space="preserve">
          <source>Thread::into</source>
          <target state="translated">Thread::into</target>
        </trans-unit>
        <trans-unit id="344f7d7a1faf3f99cb05399e695391adc35f7d18" translate="yes" xml:space="preserve">
          <source>Thread::name</source>
          <target state="translated">Thread::name</target>
        </trans-unit>
        <trans-unit id="2dcbcae4f337ba144bfa61f602dbf53a215ffbaa" translate="yes" xml:space="preserve">
          <source>Thread::to_owned</source>
          <target state="translated">Thread::to_owned</target>
        </trans-unit>
        <trans-unit id="08e8a562777dded639d27f7f44cfadcf3bf00a5e" translate="yes" xml:space="preserve">
          <source>Thread::try_from</source>
          <target state="translated">Thread::try_from</target>
        </trans-unit>
        <trans-unit id="ea003eda575d811cf577619ef02836592885180a" translate="yes" xml:space="preserve">
          <source>Thread::try_into</source>
          <target state="translated">Thread::try_into</target>
        </trans-unit>
        <trans-unit id="ee3875fc112ad5bc121f3e391fcecb3da4daa377" translate="yes" xml:space="preserve">
          <source>Thread::type_id</source>
          <target state="translated">Thread::type_id</target>
        </trans-unit>
        <trans-unit id="a2b67a0f80271fce8e8b3bd5ec25f2445ebea8c7" translate="yes" xml:space="preserve">
          <source>Thread::unpark</source>
          <target state="translated">Thread::unpark</target>
        </trans-unit>
        <trans-unit id="cd1b87b64abdd5b00fbed5a0cf0c46e8cabde3e0" translate="yes" xml:space="preserve">
          <source>ThreadId</source>
          <target state="translated">ThreadId</target>
        </trans-unit>
        <trans-unit id="e1f6247a7eef6633e4e5d83608be9b3187e0c969" translate="yes" xml:space="preserve">
          <source>ThreadId::borrow</source>
          <target state="translated">ThreadId::borrow</target>
        </trans-unit>
        <trans-unit id="22f5c0c99a3c51f5db8e51f093d172c44439f9bc" translate="yes" xml:space="preserve">
          <source>ThreadId::borrow_mut</source>
          <target state="translated">ThreadId::borrow_mut</target>
        </trans-unit>
        <trans-unit id="f272ac73f50e66007497d727840b4334ee1f128b" translate="yes" xml:space="preserve">
          <source>ThreadId::clone</source>
          <target state="translated">ThreadId::clone</target>
        </trans-unit>
        <trans-unit id="6c35d53945f00e081a8257913c3ad292495b0c89" translate="yes" xml:space="preserve">
          <source>ThreadId::clone_from</source>
          <target state="translated">ThreadId::clone_from</target>
        </trans-unit>
        <trans-unit id="9abe12a7685c82abc8d5bcbb6509a690fccefb0b" translate="yes" xml:space="preserve">
          <source>ThreadId::clone_into</source>
          <target state="translated">ThreadId::clone_into</target>
        </trans-unit>
        <trans-unit id="1fcd1d752fe2d53f1b3acff5f74fcaa56fbea5a4" translate="yes" xml:space="preserve">
          <source>ThreadId::eq</source>
          <target state="translated">ThreadId::eq</target>
        </trans-unit>
        <trans-unit id="02c70e2223708a5777dae53420e0c974498720e0" translate="yes" xml:space="preserve">
          <source>ThreadId::fmt</source>
          <target state="translated">ThreadId::fmt</target>
        </trans-unit>
        <trans-unit id="b838b903c39a24240409358be89ed6329a9df09a" translate="yes" xml:space="preserve">
          <source>ThreadId::from</source>
          <target state="translated">ThreadId::from</target>
        </trans-unit>
        <trans-unit id="ddc023441f52408bece6bf2ff774b50209750066" translate="yes" xml:space="preserve">
          <source>ThreadId::hash</source>
          <target state="translated">ThreadId::hash</target>
        </trans-unit>
        <trans-unit id="8244a05f09ebefd9016fbce0f8394db6f762584b" translate="yes" xml:space="preserve">
          <source>ThreadId::hash_slice</source>
          <target state="translated">ThreadId::hash_slice</target>
        </trans-unit>
        <trans-unit id="fd5bfcfa29d7d00b83774a3201acbc0e51fa4872" translate="yes" xml:space="preserve">
          <source>ThreadId::into</source>
          <target state="translated">ThreadId::into</target>
        </trans-unit>
        <trans-unit id="a87f4470467c3e753de867438c3b5d2edf68e527" translate="yes" xml:space="preserve">
          <source>ThreadId::ne</source>
          <target state="translated">ThreadId::ne</target>
        </trans-unit>
        <trans-unit id="3cd41ae993fc3fddaa9fb843d50a8938bb01dd02" translate="yes" xml:space="preserve">
          <source>ThreadId::to_owned</source>
          <target state="translated">ThreadId::to_owned</target>
        </trans-unit>
        <trans-unit id="c7ce06f7b4875caccd8b2ef7310bb3589387aaa7" translate="yes" xml:space="preserve">
          <source>ThreadId::try_from</source>
          <target state="translated">ThreadId::try_from</target>
        </trans-unit>
        <trans-unit id="1723d15638b0712b0610f447b496de925bf9fce1" translate="yes" xml:space="preserve">
          <source>ThreadId::try_into</source>
          <target state="translated">ThreadId::try_into</target>
        </trans-unit>
        <trans-unit id="586fd641683540c80a212ba3dd698b0a2d8e64c3" translate="yes" xml:space="preserve">
          <source>ThreadId::type_id</source>
          <target state="translated">ThreadId::type_id</target>
        </trans-unit>
        <trans-unit id="c8f829eec28b00e160b939476f6112a322b89854" translate="yes" xml:space="preserve">
          <source>Threads are able to have associated names for identification purposes. By default, spawned threads are unnamed. To specify a name for a thread, build the thread with &lt;a href=&quot;struct.builder&quot;&gt;&lt;code&gt;Builder&lt;/code&gt;&lt;/a&gt; and pass the desired thread name to &lt;a href=&quot;struct.builder#method.name&quot;&gt;&lt;code&gt;Builder::name&lt;/code&gt;&lt;/a&gt;. To retrieve the thread name from within the thread, use &lt;a href=&quot;struct.thread#method.name&quot;&gt;&lt;code&gt;Thread::name&lt;/code&gt;&lt;/a&gt;. A couple examples of where the name of a thread gets used:</source>
          <target state="translated">Los hilos pueden tener nombres asociados con fines de identificaci&amp;oacute;n. De forma predeterminada, los hilos generados no tienen nombre. Para especificar un nombre para un hilo, cree el hilo con &lt;a href=&quot;struct.builder&quot;&gt; &lt;code&gt;Builder&lt;/code&gt; &lt;/a&gt; y pase el nombre del hilo deseado a &lt;a href=&quot;struct.builder#method.name&quot;&gt; &lt;code&gt;Builder::name&lt;/code&gt; &lt;/a&gt; . Para recuperar el nombre del hilo desde dentro del hilo, use &lt;a href=&quot;struct.thread#method.name&quot;&gt; &lt;code&gt;Thread::name&lt;/code&gt; &lt;/a&gt; . Un par de ejemplos de d&amp;oacute;nde se usa el nombre de un hilo:</target>
        </trans-unit>
        <trans-unit id="fac19ffa706cd7f7c61cd4298da14db7d3225341" translate="yes" xml:space="preserve">
          <source>Threads are represented via the &lt;a href=&quot;struct.thread&quot;&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;/a&gt; type, which you can get in one of two ways:</source>
          <target state="translated">Los &lt;a href=&quot;struct.thread&quot;&gt; &lt;code&gt;Thread&lt;/code&gt; &lt;/a&gt; se representan mediante el tipo de subproceso , que puede obtener de dos formas:</target>
        </trans-unit>
        <trans-unit id="dfac2e4a30b24c7a0b51fc7ce730d2b041ad7fac" translate="yes" xml:space="preserve">
          <source>Threads are represented via the &lt;code&gt;Thread&lt;/code&gt; type, which you can get in one of two ways:</source>
          <target state="translated">Los &lt;code&gt;Thread&lt;/code&gt; se representan mediante el tipo de subproceso , que puede obtener de dos formas:</target>
        </trans-unit>
        <trans-unit id="61ca9f4a8a357e814dec07995e4960f9fb1789c1" translate="yes" xml:space="preserve">
          <source>Threads by default have no name specified:</source>
          <target state="translated">Los hilos por defecto no tienen un nombre especificado:</target>
        </trans-unit>
        <trans-unit id="968a06f03211a8e28589507e83ecbad68bacd321" translate="yes" xml:space="preserve">
          <source>Three examples of &lt;code&gt;extern crate&lt;/code&gt; declarations:</source>
          <target state="translated">Tres ejemplos de declaraciones de &lt;code&gt;extern crate&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="adf3f084c350f9e4e1af9b596fea76609465c5c2" translate="yes" xml:space="preserve">
          <source>Throughout the book, you&amp;rsquo;ve seen examples of many kinds of patterns. In this section, we gather all the syntax valid in patterns and discuss why you might want to use each one.</source>
          <target state="translated">A lo largo del libro, ha visto ejemplos de muchos tipos de patrones. En esta secci&amp;oacute;n, recopilamos toda la sintaxis v&amp;aacute;lida en patrones y discutimos por qu&amp;eacute; es posible que desee utilizar cada uno.</target>
        </trans-unit>
        <trans-unit id="60bf7601d61de03ae0783bd8d23bcd9c972360eb" translate="yes" xml:space="preserve">
          <source>Throughout the documentation, we will follow a few conventions. For all operations, the collection's size is denoted by n. If another collection is involved in the operation, it contains m elements. Operations which have an &lt;em&gt;amortized&lt;/em&gt; cost are suffixed with a &lt;code&gt;*&lt;/code&gt;. Operations with an &lt;em&gt;expected&lt;/em&gt; cost are suffixed with a &lt;code&gt;~&lt;/code&gt;.</source>
          <target state="translated">A lo largo de la documentaci&amp;oacute;n, seguiremos algunas convenciones. Para todas las operaciones, el tama&amp;ntilde;o de la colecci&amp;oacute;n se indica mediante n. Si otra colecci&amp;oacute;n est&amp;aacute; involucrada en la operaci&amp;oacute;n, contiene m elementos. Las operaciones que tienen un costo &lt;em&gt;amortizado&lt;/em&gt; tienen el sufijo &lt;code&gt;*&lt;/code&gt; . Las operaciones con un costo &lt;em&gt;esperado&lt;/em&gt; tienen el sufijo &lt;code&gt;~&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="238f30330684e8f9c133d5faa32478b32bb7092d" translate="yes" xml:space="preserve">
          <source>Throughout this book, we&amp;rsquo;ve used &lt;code&gt;let&lt;/code&gt; like this hundreds of times, and although you might not have realized it, you were using patterns! More formally, a &lt;code&gt;let&lt;/code&gt; statement looks like this:</source>
          <target state="translated">A lo largo de este libro, hemos utilizado &lt;code&gt;let&lt;/code&gt; como esto cientos de veces, y aunque es posible que no haya dado cuenta, que estaba usando patrones! M&amp;aacute;s formalmente, una declaraci&amp;oacute;n &lt;code&gt;let&lt;/code&gt; se ve as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="3b79edbe5b3429757c6a6c5658f9e500a2a9f5f8" translate="yes" xml:space="preserve">
          <source>Thus the pattern of &lt;code&gt;yield&lt;/code&gt;ing after a failed poll is rather common when implementing low-level shared resources or synchronization primitives.</source>
          <target state="translated">Por lo tanto, el patr&amp;oacute;n de &lt;code&gt;yield&lt;/code&gt; despu&amp;eacute;s de una encuesta fallida es bastante com&amp;uacute;n cuando se implementan recursos compartidos de bajo nivel o primitivas de sincronizaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="821dfcf79b1432754988865d9447fbfdba546e04" translate="yes" xml:space="preserve">
          <source>Thus, &lt;code&gt;ref&lt;/code&gt; is not something that is being matched against. Its objective is exclusively to make the matched binding a reference, instead of potentially copying or moving what was matched.</source>
          <target state="translated">Por lo tanto, &lt;code&gt;ref&lt;/code&gt; no es algo con lo que se est&amp;eacute; comparando. Su objetivo es exclusivamente hacer de la encuadernaci&amp;oacute;n emparejada una referencia, en lugar de copiar o mover potencialmente lo que se emparej&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="f25396ffdb747466e5fd6748ffb6e2945d105f98" translate="yes" xml:space="preserve">
          <source>Thus, a sensible way to handle a thread panic is to either:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbe716d48d812e780f5d0c025cd7d8e8d137e139" translate="yes" xml:space="preserve">
          <source>Thus:</source>
          <target state="translated">Thus:</target>
        </trans-unit>
        <trans-unit id="667c88e4323d998577ae614b3d0f0d63105deed4" translate="yes" xml:space="preserve">
          <source>Time complexity</source>
          <target state="translated">La complejidad del tiempo</target>
        </trans-unit>
        <trans-unit id="87e54a385b9de69cf35ac4ab359d69ed9aa1950a" translate="yes" xml:space="preserve">
          <source>To &lt;code id=&quot;to-panic-or-not-to-panic&quot;&gt;panic!&lt;/code&gt; or Not to &lt;code&gt;panic!&lt;/code&gt;</source>
          <target state="translated">&amp;iexcl;Al &lt;code id=&quot;to-panic-or-not-to-panic&quot;&gt;panic!&lt;/code&gt; o &lt;code&gt;panic!&lt;/code&gt; no cunda el p&amp;aacute;nico!</target>
        </trans-unit>
        <trans-unit id="6c0ba38264d0a297ae9df50179b24027837bbba6" translate="yes" xml:space="preserve">
          <source>To add &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt;, we specify &lt;code&gt;impl Add&amp;lt;Meters&amp;gt;&lt;/code&gt; to set the value of the &lt;code&gt;RHS&lt;/code&gt; type parameter instead of using the default of &lt;code&gt;Self&lt;/code&gt;.</source>
          <target state="translated">Para agregar &lt;code&gt;Millimeters&lt;/code&gt; y &lt;code&gt;Meters&lt;/code&gt; , especificamos &lt;code&gt;impl Add&amp;lt;Meters&amp;gt;&lt;/code&gt; para establecer el valor del par&amp;aacute;metro de tipo &lt;code&gt;RHS&lt;/code&gt; en lugar de usar el valor predeterminado de &lt;code&gt;Self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cba3d2f6052bb257fd3b265e03522cd76a90182d" translate="yes" xml:space="preserve">
          <source>To add &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt;, we specify &lt;code&gt;impl Add&amp;lt;Meters&amp;gt;&lt;/code&gt; to set the value of the &lt;code&gt;Rhs&lt;/code&gt; type parameter instead of using the default of &lt;code&gt;Self&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48e27f28761495c993b1d146a55214b33393a503" translate="yes" xml:space="preserve">
          <source>To allow customization in specific cases most users won&amp;rsquo;t need</source>
          <target state="translated">Para permitir la personalizaci&amp;oacute;n en casos espec&amp;iacute;ficos, la mayor&amp;iacute;a de los usuarios no necesitar&amp;aacute;n</target>
        </trans-unit>
        <trans-unit id="b1d5c30e2acf4bd68628daf0a08fcdb7d03b4380" translate="yes" xml:space="preserve">
          <source>To assist with proper design, the following scenarios are explicitly declared legal for single-threaded code:</source>
          <target state="translated">Para ayudar a un diseño adecuado,los siguientes escenarios se declaran explícitamente legales para el código de un solo hilo:</target>
        </trans-unit>
        <trans-unit id="3ff5f80d30f1f493faf134bdcac7192bc4fe0c89" translate="yes" xml:space="preserve">
          <source>To avoid a memory leak the pointer must be converted back to an &lt;code&gt;Arc&lt;/code&gt; using &lt;a href=&quot;struct.arc#method.from_raw&quot;&gt;&lt;code&gt;Arc::from_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para evitar una p&amp;eacute;rdida de memoria, el puntero debe volver a convertirse en un &lt;code&gt;Arc&lt;/code&gt; usando &lt;a href=&quot;struct.arc#method.from_raw&quot;&gt; &lt;code&gt;Arc::from_raw&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c1e40b418899dc58e251a0e3e3662f5034b84fa8" translate="yes" xml:space="preserve">
          <source>To avoid a memory leak the pointer must be converted back to an &lt;code&gt;Rc&lt;/code&gt; using &lt;a href=&quot;struct.rc#method.from_raw&quot;&gt;&lt;code&gt;Rc::from_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para evitar una p&amp;eacute;rdida de memoria, el puntero debe volver a convertirse a un &lt;code&gt;Rc&lt;/code&gt; usando &lt;a href=&quot;struct.rc#method.from_raw&quot;&gt; &lt;code&gt;Rc::from_raw&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4a5ee855a608ecd864fa2e7b73853f23dfbb067b" translate="yes" xml:space="preserve">
          <source>To avoid creating &lt;code&gt;&amp;amp;mut [T]&lt;/code&gt; references that alias, the returned slice borrows its lifetime from the iterator the method is applied on.</source>
          <target state="translated">Para evitar crear referencias de &lt;code&gt;&amp;amp;mut [T]&lt;/code&gt; ese alias, el segmento devuelto toma prestada su vida &amp;uacute;til del iterador en el que se aplica el m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="ffa0cd99296c4663ce93793ddad7c9407847a5e2" translate="yes" xml:space="preserve">
          <source>To avoid creating &lt;code&gt;&amp;amp;mut&lt;/code&gt; references that alias, this is forced to consume the iterator.</source>
          <target state="translated">Para evitar la creaci&amp;oacute;n de &lt;code&gt;&amp;amp;mut&lt;/code&gt; referencias a ese alias, esto se ve obligado a consumir el iterador.</target>
        </trans-unit>
        <trans-unit id="1aefc821eaa401be8625ea8100fecfc992fdeed8" translate="yes" xml:space="preserve">
          <source>To avoid having &lt;code&gt;common&lt;/code&gt; appear in the test output, instead of creating &lt;em&gt;tests/common.rs&lt;/em&gt;, we&amp;rsquo;ll create &lt;em&gt;tests/common/mod.rs&lt;/em&gt;. This is an alternate naming convention that Rust also understands. Naming the file this way tells Rust not to treat the &lt;code&gt;common&lt;/code&gt; module as an integration test file. When we move the &lt;code&gt;setup&lt;/code&gt; function code into &lt;em&gt;tests/common/mod.rs&lt;/em&gt; and delete the &lt;em&gt;tests/common.rs&lt;/em&gt; file, the section in the test output will no longer appear. Files in subdirectories of the &lt;em&gt;tests&lt;/em&gt; directory don&amp;rsquo;t get compiled as separate crates or have sections in the test output.</source>
          <target state="translated">Para evitar tener &lt;code&gt;common&lt;/code&gt; aparece en la salida de la prueba, en lugar de crear &lt;em&gt;pruebas / common.rs&lt;/em&gt; , vamos a crear &lt;em&gt;pruebas / com&amp;uacute;n / mod.rs&lt;/em&gt; . Esta es una convenci&amp;oacute;n de nomenclatura alternativa que Rust tambi&amp;eacute;n comprende. Nombrar el archivo de esta manera le dice a Rust que no trate el m&amp;oacute;dulo &lt;code&gt;common&lt;/code&gt; como un archivo de prueba de integraci&amp;oacute;n. Cuando movemos el c&amp;oacute;digo de la funci&amp;oacute;n de &lt;code&gt;setup&lt;/code&gt; a &lt;em&gt;tests / common / mod.rs&lt;/em&gt; y &lt;em&gt;eliminamos el&lt;/em&gt; archivo &lt;em&gt;tests / common.rs&lt;/em&gt; , la secci&amp;oacute;n en el resultado de la prueba ya no aparecer&amp;aacute;. Los archivos de los subdirectorios del directorio de &lt;em&gt;pruebas&lt;/em&gt; no se compilan como cajas independientes ni tienen secciones en la salida de la prueba.</target>
        </trans-unit>
        <trans-unit id="3621c2a13fc7da454e2221c729cf687e93b1bda8" translate="yes" xml:space="preserve">
          <source>To avoid it, you have to replace the non-constant value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea7a1a1787370230342d01e7d26cc5eb0fdaf231" translate="yes" xml:space="preserve">
          <source>To avoid the error there are a couple of options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1645dd8754fa06f0f760253ea0a8f05162d861bf" translate="yes" xml:space="preserve">
          <source>To avoid this error, first bind the temporary to a named local variable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97ceede3cc5738536ea015edb67ed85c3d3dcd2e" translate="yes" xml:space="preserve">
          <source>To avoid this error, you have to keep only one of them and remove the others. So let's take our example and fix it:</source>
          <target state="translated">Para evitar este error,hay que mantener sólo uno de ellos y eliminar los otros.Así que tomemos nuestro ejemplo y arreglémoslo:</target>
        </trans-unit>
        <trans-unit id="a30b99a191595831b8cb7e0383bc895012a3666a" translate="yes" xml:space="preserve">
          <source>To avoid this kind of error, ensure that at least one local type is referenced by the &lt;code&gt;impl&lt;/code&gt;:</source>
          <target state="translated">Para evitar este tipo de error, aseg&amp;uacute;rese de que al menos un tipo local est&amp;eacute; referenciado por &lt;code&gt;impl&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a83579bf275c61511e259b0f6a5393712638d88c" translate="yes" xml:space="preserve">
          <source>To avoid those issues, you have to make the types match correctly. So we can fix the previous examples like this:</source>
          <target state="translated">Para evitar esos problemas,tienes que hacer que los tipos coincidan correctamente.Así que podemos arreglar los ejemplos anteriores como este:</target>
        </trans-unit>
        <trans-unit id="8cca79e59af2d0e450f9f7893d8b74973a17a0c1" translate="yes" xml:space="preserve">
          <source>To be able to index into a type it needs to implement the &lt;code&gt;std::ops::Index&lt;/code&gt; trait. Example:</source>
          <target state="translated">Para poder indexar en un tipo, necesita implementar el rasgo &lt;code&gt;std::ops::Index&lt;/code&gt; . Ejemplo:</target>
        </trans-unit>
        <trans-unit id="e0c4569eca23f12e74ce8e43ea0b16ae30221104" translate="yes" xml:space="preserve">
          <source>To be clear: most features will be available on all editions. Developers using any Rust edition will continue to see improvements as new stable releases are made. However, in some cases, mainly when new keywords are added, some new features might only be available in later editions. You will need to switch editions if you want to take advantage of such features.</source>
          <target state="translated">Para ser claros:la mayoría de las características estarán disponibles en todas las ediciones.Los desarrolladores que usen cualquier edición de Rust continuarán viendo mejoras a medida que se hagan nuevas versiones estables.Sin embargo,en algunos casos,principalmente cuando se añaden nuevas palabras clave,algunas nuevas características podrían estar disponibles sólo en ediciones posteriores.Tendrá que cambiar de edición si desea aprovechar estas características.</target>
        </trans-unit>
        <trans-unit id="28519d7825ab9ef768276a220fcc5248c6cfd08d" translate="yes" xml:space="preserve">
          <source>To be valid, a matcher must meet the following three invariants. The definitions of FIRST and FOLLOW are described later.</source>
          <target state="translated">Para ser válida,una pareja debe cumplir con las siguientes tres invariantes.Las definiciones de PRIMERA y SEGUIDA se describen más adelante.</target>
        </trans-unit>
        <trans-unit id="4dcb6216e57dabede5c512636b8402fc6577f67d" translate="yes" xml:space="preserve">
          <source>To better understand how these work in Rust, read the &lt;a href=&quot;book/ch13-01-closures&quot;&gt;Closures&lt;/a&gt; chapter of the Book.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d27f02149ea4da378573490ec467ba6b8b5c842f" translate="yes" xml:space="preserve">
          <source>To better understand why we need two separate loops, imagine a scenario with two workers. If we used a single loop to iterate through each worker, on the first iteration a terminate message would be sent down the channel and &lt;code&gt;join&lt;/code&gt; called on the first worker&amp;rsquo;s thread. If that first worker was busy processing a request at that moment, the second worker would pick up the terminate message from the channel and shut down. We would be left waiting on the first worker to shut down, but it never would because the second thread picked up the terminate message. Deadlock!</source>
          <target state="translated">Para comprender mejor por qu&amp;eacute; necesitamos dos ciclos separados, imagine un escenario con dos trabajadores. Si usamos un solo bucle para iterar a trav&amp;eacute;s de cada trabajador, en la primera iteraci&amp;oacute;n se enviar&amp;iacute;a un mensaje de terminaci&amp;oacute;n por el canal y &lt;code&gt;join&lt;/code&gt; llamar&amp;iacute;a a la uni&amp;oacute;n en el hilo del primer trabajador. Si ese primer trabajador estaba ocupado procesando una solicitud en ese momento, el segundo trabajador recoger&amp;iacute;a el mensaje de terminaci&amp;oacute;n del canal y se apagar&amp;iacute;a. Nos dejar&amp;iacute;an esperando a que se apagara el primer trabajador, pero nunca lo har&amp;iacute;a porque el segundo hilo recogi&amp;oacute; el mensaje de terminaci&amp;oacute;n. &amp;iexcl;Punto muerto!</target>
        </trans-unit>
        <trans-unit id="a92bd1b796549d070a95e516f74d8da028284983" translate="yes" xml:space="preserve">
          <source>To bind the matched value of a pattern to a variable, use the syntax &lt;code&gt;variable @ subpattern&lt;/code&gt;. For example, the following binds the value 2 to &lt;code&gt;e&lt;/code&gt; (not the entire range: the range here is a range subpattern).</source>
          <target state="translated">Para vincular el valor coincidente de un patr&amp;oacute;n a una variable, use la &lt;code&gt;variable @ subpattern&lt;/code&gt; sintaxis @ subpattern . Por ejemplo, la siguiente une el valor 2 a &lt;code&gt;e&lt;/code&gt; (no toda la gama: la gama aqu&amp;iacute; es un subpatr&amp;oacute;n rango).</target>
        </trans-unit>
        <trans-unit id="b830c9413c38579d4ef7795bcf7bbde269208939" translate="yes" xml:space="preserve">
          <source>To build or modify paths, use &lt;a href=&quot;struct.pathbuf&quot;&gt;&lt;code&gt;PathBuf&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Para construir o modificar rutas, use &lt;a href=&quot;struct.pathbuf&quot;&gt; &lt;code&gt;PathBuf&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="bfa1e223892bc7e4bd4f7e711edfd1f7972be85d" translate="yes" xml:space="preserve">
          <source>To calculate the layout of a &lt;code&gt;#[repr(C)]&lt;/code&gt; structure and the offsets of the fields from its fields' layouts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a716f5c06d1b56904d9c9ecdfaef8a89e71a7435" translate="yes" xml:space="preserve">
          <source>To calculate the value of &lt;code&gt;prediction&lt;/code&gt;, this code iterates through each of the 12 values in &lt;code&gt;coefficients&lt;/code&gt; and uses the &lt;code&gt;zip&lt;/code&gt; method to pair the coefficient values with the previous 12 values in &lt;code&gt;buffer&lt;/code&gt;. Then, for each pair, we multiply the values together, sum all the results, and shift the bits in the sum &lt;code&gt;qlp_shift&lt;/code&gt; bits to the right.</source>
          <target state="translated">Para calcular el valor de la &lt;code&gt;prediction&lt;/code&gt; , este c&amp;oacute;digo itera a trav&amp;eacute;s de cada uno de los 12 valores en los &lt;code&gt;coefficients&lt;/code&gt; y usa el m&amp;eacute;todo &lt;code&gt;zip&lt;/code&gt; para emparejar los valores de los coeficientes con los 12 valores anteriores en el &lt;code&gt;buffer&lt;/code&gt; . Luego, para cada par, multiplicamos los valores, sumamos todos los resultados y desplazamos los bits de la suma &lt;code&gt;qlp_shift&lt;/code&gt; bits a la derecha.</target>
        </trans-unit>
        <trans-unit id="e1e36c60ac0b0cf3c0b11863470e32d28a059d98" translate="yes" xml:space="preserve">
          <source>To call the &lt;code&gt;fly&lt;/code&gt; methods from either the &lt;code&gt;Pilot&lt;/code&gt; trait or the &lt;code&gt;Wizard&lt;/code&gt; trait, we need to use more explicit syntax to specify which &lt;code&gt;fly&lt;/code&gt; method we mean. Listing 19-18 demonstrates this syntax.</source>
          <target state="translated">Para llamar a los m&amp;eacute;todos &lt;code&gt;fly&lt;/code&gt; desde el rasgo &lt;code&gt;Pilot&lt;/code&gt; o el rasgo &lt;code&gt;Wizard&lt;/code&gt; , necesitamos usar una sintaxis m&amp;aacute;s expl&amp;iacute;cita para especificar a qu&amp;eacute; m&amp;eacute;todo &lt;code&gt;fly&lt;/code&gt; nos referimos. El listado 19-18 demuestra esta sintaxis.</target>
        </trans-unit>
        <trans-unit id="5c07c5eaca75954c044b220e0d9378c6ce45b1a4" translate="yes" xml:space="preserve">
          <source>To call this associated function, we use the &lt;code&gt;::&lt;/code&gt; syntax with the struct name; &lt;code&gt;let sq = Rectangle::square(3);&lt;/code&gt; is an example. This function is namespaced by the struct: the &lt;code&gt;::&lt;/code&gt; syntax is used for both associated functions and namespaces created by modules. We&amp;rsquo;ll discuss modules in Chapter 7.</source>
          <target state="translated">Para llamar a esta funci&amp;oacute;n asociada, usamos la sintaxis &lt;code&gt;::&lt;/code&gt; con el nombre de la estructura; &lt;code&gt;let sq = Rectangle::square(3);&lt;/code&gt; es un ejemplo. Esta funci&amp;oacute;n tiene un espacio de nombres mediante la estructura: la sintaxis &lt;code&gt;::&lt;/code&gt; se utiliza tanto para funciones asociadas como para espacios de nombres creados por m&amp;oacute;dulos. Discutiremos los m&amp;oacute;dulos en el Cap&amp;iacute;tulo 7.</target>
        </trans-unit>
        <trans-unit id="191c93d8beeacd6897f106d1c47af3f257c7dd5f" translate="yes" xml:space="preserve">
          <source>To call this code with only those types that implement the &lt;code&gt;Copy&lt;/code&gt; trait, we can add &lt;code&gt;Copy&lt;/code&gt; to the trait bounds of &lt;code&gt;T&lt;/code&gt;! Listing 10-15 shows the complete code of a generic &lt;code&gt;largest&lt;/code&gt; function that will compile as long as the types of the values in the slice that we pass into the function implement the &lt;code&gt;PartialOrd&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;Copy&lt;/code&gt; traits, like &lt;code&gt;i32&lt;/code&gt; and &lt;code&gt;char&lt;/code&gt; do.</source>
          <target state="translated">Para llamar a este c&amp;oacute;digo solo con aquellos tipos que implementan el rasgo &lt;code&gt;Copy&lt;/code&gt; , podemos agregar &lt;code&gt;Copy&lt;/code&gt; a los l&amp;iacute;mites del rasgo &lt;code&gt;T&lt;/code&gt; ! El Listado 10-15 muestra el c&amp;oacute;digo completo de una funci&amp;oacute;n gen&amp;eacute;rica &lt;code&gt;largest&lt;/code&gt; que se compilar&amp;aacute; siempre que los tipos de valores en el segmento que pasamos a la funci&amp;oacute;n implementen los rasgos &lt;code&gt;PartialOrd&lt;/code&gt; &lt;em&gt;y &lt;/em&gt; &lt;code&gt;Copy&lt;/code&gt; , como &lt;code&gt;i32&lt;/code&gt; y &lt;code&gt;char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ae7caef9479d77c77a3d3a0a7f430defd27a454" translate="yes" xml:space="preserve">
          <source>To change the value that the mutable reference refers to, we have to use the dereference operator (&lt;code&gt;*&lt;/code&gt;) to get to the value in &lt;code&gt;i&lt;/code&gt; before we can use the &lt;code&gt;+=&lt;/code&gt; operator. We&amp;rsquo;ll talk more about the dereference operator in the &lt;a href=&quot;ch15-02-deref#following-the-pointer-to-the-value-with-the-dereference-operator&quot;&gt;&amp;ldquo;Following the Pointer to the Value with the Dereference Operator&amp;rdquo;&lt;/a&gt; section of Chapter 15.</source>
          <target state="translated">Para cambiar el valor al que se refiere la referencia mutable, tenemos que usar el operador de desreferencia ( &lt;code&gt;*&lt;/code&gt; ) para obtener el valor en &lt;code&gt;i&lt;/code&gt; antes de poder usar el operador &lt;code&gt;+=&lt;/code&gt; . Hablaremos m&amp;aacute;s sobre el operador de desreferencia en la secci&amp;oacute;n &lt;a href=&quot;ch15-02-deref#following-the-pointer-to-the-value-with-the-dereference-operator&quot;&gt;&quot;Seguir el puntero al valor con el operador de desreferencia&quot;&lt;/a&gt; del Cap&amp;iacute;tulo 15.</target>
        </trans-unit>
        <trans-unit id="8d0f5fc712b1dc8e53a799fd7ad61e2d58ce4f6e" translate="yes" xml:space="preserve">
          <source>To check the type for the return type of a function with multiple return statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff93ea5d521caed491ca6edf931b71effa3ca726" translate="yes" xml:space="preserve">
          <source>To check whether you have Rust installed correctly, open a shell and enter this line:</source>
          <target state="translated">Para comprobar si tienes el óxido instalado correctamente,abre una concha y entra en esta línea:</target>
        </trans-unit>
        <trans-unit id="b81a5a29868dab97f44f48c2bd716ec3edc16d7e" translate="yes" xml:space="preserve">
          <source>To combine &lt;code&gt;repr(transparent)&lt;/code&gt; with type parameters, &lt;code&gt;PhantomData&lt;/code&gt; may be useful:</source>
          <target state="translated">Para combinar &lt;code&gt;repr(transparent)&lt;/code&gt; con par&amp;aacute;metros de tipo, &lt;code&gt;PhantomData&lt;/code&gt; puede ser &amp;uacute;til:</target>
        </trans-unit>
        <trans-unit id="ac3f03b22205947cc54e2019b2f0993969841a80" translate="yes" xml:space="preserve">
          <source>To confuse things further, &lt;a href=&quot;https://encoding.spec.whatwg.org/&quot;&gt;on the Web&lt;/a&gt;&lt;code&gt;ascii&lt;/code&gt;, &lt;code&gt;iso-8859-1&lt;/code&gt;, and &lt;code&gt;windows-1252&lt;/code&gt; are all aliases for a superset of Windows-1252 that fills the remaining blanks with corresponding C0 and C1 control codes.</source>
          <target state="translated">Para confundir a&amp;uacute;n m&amp;aacute;s las cosas, &lt;a href=&quot;https://encoding.spec.whatwg.org/&quot;&gt;en la Web &lt;/a&gt; &lt;code&gt;ascii&lt;/code&gt; , &lt;code&gt;iso-8859-1&lt;/code&gt; y &lt;code&gt;windows-1252&lt;/code&gt; son todos alias de un superconjunto de Windows-1252 que llena los espacios en blanco restantes con los c&amp;oacute;digos de control C0 y C1 correspondientes.</target>
        </trans-unit>
        <trans-unit id="9e961e97b1bab5bb4d05da5fe7c2fc74357a8b93" translate="yes" xml:space="preserve">
          <source>To consume the old state, the &lt;code&gt;request_review&lt;/code&gt; method needs to take ownership of the state value. This is where the &lt;code&gt;Option&lt;/code&gt; in the &lt;code&gt;state&lt;/code&gt; field of &lt;code&gt;Post&lt;/code&gt; comes in: we call the &lt;code&gt;take&lt;/code&gt; method to take the &lt;code&gt;Some&lt;/code&gt; value out of the &lt;code&gt;state&lt;/code&gt; field and leave a &lt;code&gt;None&lt;/code&gt; in its place, because Rust doesn&amp;rsquo;t let us have unpopulated fields in structs. This lets us move the &lt;code&gt;state&lt;/code&gt; value out of &lt;code&gt;Post&lt;/code&gt; rather than borrowing it. Then we&amp;rsquo;ll set the post&amp;rsquo;s &lt;code&gt;state&lt;/code&gt; value to the result of this operation.</source>
          <target state="translated">Para consumir el estado anterior, el m&amp;eacute;todo &lt;code&gt;request_review&lt;/code&gt; debe tomar posesi&amp;oacute;n del valor del estado. Aqu&amp;iacute; es donde entra la &lt;code&gt;Option&lt;/code&gt; en el campo de &lt;code&gt;state&lt;/code&gt; de &lt;code&gt;Post&lt;/code&gt; : llamamos al m&amp;eacute;todo &lt;code&gt;take&lt;/code&gt; para sacar el valor &lt;code&gt;Some&lt;/code&gt; del campo de &lt;code&gt;state&lt;/code&gt; y dejar un &lt;code&gt;None&lt;/code&gt; en su lugar, porque Rust no nos permite tener campos despoblados en estructuras. Esto nos permite sacar el valor del &lt;code&gt;state&lt;/code&gt; de &lt;code&gt;Post&lt;/code&gt; en lugar de tomarlo prestado. Luego, estableceremos el valor de &lt;code&gt;state&lt;/code&gt; la publicaci&amp;oacute;n en el resultado de esta operaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f337e083c37a19b6c9f78383e9d486a4274f1380" translate="yes" xml:space="preserve">
          <source>To control whether interfaces can be used across modules, Rust checks each use of an item to see whether it should be allowed or not. This is where privacy warnings are generated, or otherwise &quot;you used a private item of another module and weren't allowed to.&quot;</source>
          <target state="translated">Para controlar si las interfaces se pueden utilizar en todos los módulos,Rust comprueba cada uso de un elemento para ver si se debe permitir o no.Aquí es donde se generan las advertencias de privacidad,o de lo contrario &quot;usaste un elemento privado de otro módulo y no se te permitió&quot;.</target>
        </trans-unit>
        <trans-unit id="ba21f5abea5c571067a1a7d57de3d3aa5bc54641" translate="yes" xml:space="preserve">
          <source>To convert a single value to a string, use the &lt;a href=&quot;../string/trait.tostring&quot;&gt;&lt;code&gt;to_string&lt;/code&gt;&lt;/a&gt; method. This will use the &lt;a href=&quot;trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; formatting trait.</source>
          <target state="translated">Para convertir un valor &amp;uacute;nico en una cadena, use el m&amp;eacute;todo &lt;a href=&quot;../string/trait.tostring&quot;&gt; &lt;code&gt;to_string&lt;/code&gt; &lt;/a&gt; . Esto usar&amp;aacute; el rasgo de formato de &lt;a href=&quot;trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3cb338cb9ed195af952f18624a8d65c1ca64787f" translate="yes" xml:space="preserve">
          <source>To convert a single value to a string, use the &lt;a href=&quot;string/trait.tostring&quot;&gt;&lt;code&gt;to_string&lt;/code&gt;&lt;/a&gt; method. This will use the &lt;a href=&quot;fmt/trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; formatting trait.</source>
          <target state="translated">Para convertir un valor &amp;uacute;nico en una cadena, use el m&amp;eacute;todo &lt;a href=&quot;string/trait.tostring&quot;&gt; &lt;code&gt;to_string&lt;/code&gt; &lt;/a&gt; . Esto usar&amp;aacute; el rasgo de formato de &lt;a href=&quot;fmt/trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="015234ea3f6220712aedf5ea26711d734042f76e" translate="yes" xml:space="preserve">
          <source>To create a &lt;code&gt;match&lt;/code&gt; expression that compares the values of the outer &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, rather than introducing a shadowed variable, we would need to use a match guard conditional instead. We&amp;rsquo;ll talk about match guards later in the &lt;a href=&quot;#extra-conditionals-with-match-guards&quot;&gt;&amp;ldquo;Extra Conditionals with Match Guards&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">Para crear una expresi&amp;oacute;n de &lt;code&gt;match&lt;/code&gt; que compare los valores de las &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; externas , en lugar de introducir una variable sombreada, necesitar&amp;iacute;amos utilizar un condicional de protecci&amp;oacute;n de coincidencia. Hablaremos de los guardias de partido m&amp;aacute;s adelante en la secci&amp;oacute;n &lt;a href=&quot;#extra-conditionals-with-match-guards&quot;&gt;&quot;Condiciones adicionales con guardias de partido&quot;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d6a361bf034a44065bf4d983adf9bd5159e505a7" translate="yes" xml:space="preserve">
          <source>To create a new thread, we call the &lt;code&gt;thread::spawn&lt;/code&gt; function and pass it a closure (we talked about closures in Chapter 13) containing the code we want to run in the new thread. The example in Listing 16-1 prints some text from a main thread and other text from a new thread:</source>
          <target state="translated">Para crear un nuevo hilo, llamamos a la funci&amp;oacute;n &lt;code&gt;thread::spawn&lt;/code&gt; y le pasamos un cierre (hablamos de cierres en el Cap&amp;iacute;tulo 13) que contiene el c&amp;oacute;digo que queremos ejecutar en el nuevo hilo. El ejemplo del Listado 16-1 imprime texto de un hilo principal y otro texto de un hilo nuevo:</target>
        </trans-unit>
        <trans-unit id="aa89b2295fcdc6f9c080aa3a4a8e8468c77980e1" translate="yes" xml:space="preserve">
          <source>To create a new, empty vector, we can call the &lt;code&gt;Vec::new&lt;/code&gt; function, as shown in Listing 8-1.</source>
          <target state="translated">Para crear un nuevo vector vac&amp;iacute;o, podemos llamar a la funci&amp;oacute;n &lt;code&gt;Vec::new&lt;/code&gt; , como se muestra en el Listado 8-1.</target>
        </trans-unit>
        <trans-unit id="1a88aa76c7ad4f90214c55053637e980f11dd3a9" translate="yes" xml:space="preserve">
          <source>To create a vector and then add elements to it, we can use the &lt;code&gt;push&lt;/code&gt; method, as shown in Listing 8-3.</source>
          <target state="translated">Para crear un vector y luego agregarle elementos, podemos usar el m&amp;eacute;todo &lt;code&gt;push&lt;/code&gt; , como se muestra en el Listado 8-3.</target>
        </trans-unit>
        <trans-unit id="00c0015adacecd8350d6133979871ae1b1edfe94" translate="yes" xml:space="preserve">
          <source>To define a &lt;code&gt;Point&lt;/code&gt; struct where &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both generics but could have different types, we can use multiple generic type parameters. For example, in Listing 10-8, we can change the definition of &lt;code&gt;Point&lt;/code&gt; to be generic over types &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; where &lt;code&gt;x&lt;/code&gt; is of type &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is of type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">Para definir un &lt;code&gt;Point&lt;/code&gt; estructura donde &lt;code&gt;x&lt;/code&gt; y &lt;code&gt;y&lt;/code&gt; son ambos medicamentos gen&amp;eacute;ricos, pero podr&amp;iacute;an tener diferentes tipos, podemos utilizar varios par&amp;aacute;metros de tipo gen&amp;eacute;rico. Por ejemplo, en el listado 10-8, podemos cambiar la definici&amp;oacute;n de &lt;code&gt;Point&lt;/code&gt; de ser gen&amp;eacute;rico sobre tipos &lt;code&gt;T&lt;/code&gt; y &lt;code&gt;U&lt;/code&gt; , donde &lt;code&gt;x&lt;/code&gt; es de tipo &lt;code&gt;T&lt;/code&gt; y &lt;code&gt;y&lt;/code&gt; es de tipo &lt;code&gt;U&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48e3d6adfbf70e45f3b29de0115bced82f45c8ba" translate="yes" xml:space="preserve">
          <source>To define a macro, you use the &lt;code&gt;macro_rules!&lt;/code&gt; construct. Let&amp;rsquo;s explore how to use &lt;code&gt;macro_rules!&lt;/code&gt; by looking at how the &lt;code&gt;vec!&lt;/code&gt; macro is defined. Chapter 8 covered how we can use the &lt;code&gt;vec!&lt;/code&gt; macro to create a new vector with particular values. For example, the following macro creates a new vector containing three integers:</source>
          <target state="translated">Para definir una macro, usa &lt;code&gt;macro_rules!&lt;/code&gt; construir. &amp;iexcl; &lt;code&gt;macro_rules!&lt;/code&gt; c&amp;oacute;mo usar macro_rules! mirando c&amp;oacute;mo el &lt;code&gt;vec!&lt;/code&gt; macro est&amp;aacute; definida. &amp;iexcl;El cap&amp;iacute;tulo 8 cubri&amp;oacute; c&amp;oacute;mo podemos usar el &lt;code&gt;vec!&lt;/code&gt; macro para crear un nuevo vector con valores particulares. Por ejemplo, la siguiente macro crea un nuevo vector que contiene tres enteros:</target>
        </trans-unit>
        <trans-unit id="0305c11d131bdcb2f62d25c1e047d31c7b279a29" translate="yes" xml:space="preserve">
          <source>To define a struct, we enter the keyword &lt;code&gt;struct&lt;/code&gt; and name the entire struct. A struct&amp;rsquo;s name should describe the significance of the pieces of data being grouped together. Then, inside curly brackets, we define the names and types of the pieces of data, which we call &lt;em&gt;fields&lt;/em&gt;. For example, Listing 5-1 shows a struct that stores information about a user account.</source>
          <target state="translated">Para definir una estructura, ingresamos la palabra clave &lt;code&gt;struct&lt;/code&gt; y nombramos la estructura completa. El nombre de una estructura debe describir la importancia de los datos que se agrupan. Luego, dentro de las llaves, definimos los nombres y tipos de los datos, que llamamos &lt;em&gt;campos&lt;/em&gt; . Por ejemplo, el Listado 5-1 muestra una estructura que almacena informaci&amp;oacute;n sobre una cuenta de usuario.</target>
        </trans-unit>
        <trans-unit id="8f9b83d2cc8d6fc88b967504ac913c99c3032360" translate="yes" xml:space="preserve">
          <source>To define a tuple struct, start with the &lt;code&gt;struct&lt;/code&gt; keyword and the struct name followed by the types in the tuple. For example, here are definitions and usages of two tuple structs named &lt;code&gt;Color&lt;/code&gt; and &lt;code&gt;Point&lt;/code&gt;:</source>
          <target state="translated">Para definir una estructura de tupla, comience con la palabra clave &lt;code&gt;struct&lt;/code&gt; y el nombre de la estructura seguido de los tipos en la tupla. Por ejemplo, aqu&amp;iacute; hay definiciones y usos de dos estructuras de tupla denominadas &lt;code&gt;Color&lt;/code&gt; y &lt;code&gt;Point&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bf22e9ab26d9ba6ee6b2e46fe0b19d5124fc0343" translate="yes" xml:space="preserve">
          <source>To define the function within the context of &lt;code&gt;Rectangle&lt;/code&gt;, we start an &lt;code&gt;impl&lt;/code&gt; (implementation) block. Then we move the &lt;code&gt;area&lt;/code&gt; function within the &lt;code&gt;impl&lt;/code&gt; curly brackets and change the first (and in this case, only) parameter to be &lt;code&gt;self&lt;/code&gt; in the signature and everywhere within the body. In &lt;code&gt;main&lt;/code&gt;, where we called the &lt;code&gt;area&lt;/code&gt; function and passed &lt;code&gt;rect1&lt;/code&gt; as an argument, we can instead use &lt;em&gt;method syntax&lt;/em&gt; to call the &lt;code&gt;area&lt;/code&gt; method on our &lt;code&gt;Rectangle&lt;/code&gt; instance. The method syntax goes after an instance: we add a dot followed by the method name, parentheses, and any arguments.</source>
          <target state="translated">Para definir la funci&amp;oacute;n dentro del contexto de &lt;code&gt;Rectangle&lt;/code&gt; , comenzamos un bloque &lt;code&gt;impl&lt;/code&gt; (implementaci&amp;oacute;n). Luego, movemos la funci&amp;oacute;n de &lt;code&gt;area&lt;/code&gt; dentro de las llaves &lt;code&gt;impl&lt;/code&gt; &amp;iacute;citas y cambiamos el primer par&amp;aacute;metro (y en este caso, el &amp;uacute;nico) para que sea &lt;code&gt;self&lt;/code&gt; en la firma y en todas partes dentro del cuerpo. En &lt;code&gt;main&lt;/code&gt; , donde llamamos a la funci&amp;oacute;n &lt;code&gt;area&lt;/code&gt; y pasamos &lt;code&gt;rect1&lt;/code&gt; como argumento, podemos usar la &lt;em&gt;sintaxis del m&amp;eacute;todo&lt;/em&gt; para llamar al m&amp;eacute;todo &lt;code&gt;area&lt;/code&gt; en nuestra instancia de &lt;code&gt;Rectangle&lt;/code&gt; . La sintaxis del m&amp;eacute;todo va despu&amp;eacute;s de una instancia: agregamos un punto seguido del nombre del m&amp;eacute;todo, par&amp;eacute;ntesis y cualquier argumento.</target>
        </trans-unit>
        <trans-unit id="2de6b544c44b76668f6d2936d8d501f7f9f3abad" translate="yes" xml:space="preserve">
          <source>To demonstrate how to run a subset of tests, we&amp;rsquo;ll create three tests for our &lt;code&gt;add_two&lt;/code&gt; function, as shown in Listing 11-11, and choose which ones to run.</source>
          <target state="translated">Para demostrar c&amp;oacute;mo ejecutar un subconjunto de pruebas, crearemos tres pruebas para nuestra funci&amp;oacute;n &lt;code&gt;add_two&lt;/code&gt; , como se muestra en el Listado 11-11, y elegiremos cu&amp;aacute;les ejecutar.</target>
        </trans-unit>
        <trans-unit id="e75dc3dfe6b153a0ceea282766b5c4d1615452e1" translate="yes" xml:space="preserve">
          <source>To demonstrate, let&amp;rsquo;s create an iterator that will only ever count from 1 to 5. First, we&amp;rsquo;ll create a struct to hold some values. Then we&amp;rsquo;ll make this struct into an iterator by implementing the &lt;code&gt;Iterator&lt;/code&gt; trait and using the values in that implementation.</source>
          <target state="translated">Para demostrarlo, creemos un iterador que solo contar&amp;aacute; del 1 al 5. Primero, crearemos una estructura para contener algunos valores. Luego, convertiremos esta estructura en un iterador implementando el rasgo &lt;code&gt;Iterator&lt;/code&gt; y usando los valores en esa implementaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b6b548838142d67d34f12bfbc64f7cdb12a47cc6" translate="yes" xml:space="preserve">
          <source>To determine how much space to allocate for a &lt;code&gt;Message&lt;/code&gt; value, Rust goes through each of the variants to see which variant needs the most space. Rust sees that &lt;code&gt;Message::Quit&lt;/code&gt; doesn&amp;rsquo;t need any space, &lt;code&gt;Message::Move&lt;/code&gt; needs enough space to store two &lt;code&gt;i32&lt;/code&gt; values, and so forth. Because only one variant will be used, the most space a &lt;code&gt;Message&lt;/code&gt; value will need is the space it would take to store the largest of its variants.</source>
          <target state="translated">Para determinar cu&amp;aacute;nto espacio asignar para un valor de &lt;code&gt;Message&lt;/code&gt; , Rust revisa cada una de las variantes para ver qu&amp;eacute; variante necesita m&amp;aacute;s espacio. Rust ve que &lt;code&gt;Message::Quit&lt;/code&gt; no necesita ning&amp;uacute;n espacio, &lt;code&gt;Message::Move&lt;/code&gt; necesita suficiente espacio para almacenar dos valores de &lt;code&gt;i32&lt;/code&gt; , y as&amp;iacute; sucesivamente. Debido a que solo se usar&amp;aacute; una variante, la mayor cantidad de espacio que necesitar&amp;aacute; un valor de &lt;code&gt;Message&lt;/code&gt; es el espacio que tomar&amp;iacute;a para almacenar la mayor de sus variantes.</target>
        </trans-unit>
        <trans-unit id="375df8edff8c14a24952e9e1d54e255a42b357a9" translate="yes" xml:space="preserve">
          <source>To determine if a &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Foo&lt;/code&gt;, we need to check if &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;Foo&lt;/code&gt;. However, to do this check, we need to determine that &lt;code&gt;Bar&amp;lt;Bar&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; is &lt;code&gt;Foo&lt;/code&gt;. To determine this, we check if &lt;code&gt;Bar&amp;lt;Bar&amp;lt;Bar&amp;lt;T&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; is &lt;code&gt;Foo&lt;/code&gt;, and so on. This is clearly a recursive requirement that can't be resolved directly.</source>
          <target state="translated">Para determinar si una &lt;code&gt;T&lt;/code&gt; es &lt;code&gt;Foo&lt;/code&gt; , debemos verificar si &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; es &lt;code&gt;Foo&lt;/code&gt; . Sin embargo, para hacer esta verificaci&amp;oacute;n, necesitamos determinar que &lt;code&gt;Bar&amp;lt;Bar&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; es &lt;code&gt;Foo&lt;/code&gt; . Para determinar esto, verificamos si &lt;code&gt;Bar&amp;lt;Bar&amp;lt;Bar&amp;lt;T&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; es &lt;code&gt;Foo&lt;/code&gt; , y as&amp;iacute; sucesivamente. Este es claramente un requisito recursivo que no se puede resolver directamente.</target>
        </trans-unit>
        <trans-unit id="b8666f35753eb530d957bee0ef54848c41571aca" translate="yes" xml:space="preserve">
          <source>To determine the total number of seconds represented by the &lt;code&gt;Duration&lt;/code&gt;, use &lt;code&gt;as_secs&lt;/code&gt; in combination with &lt;a href=&quot;#method.subsec_nanos&quot;&gt;&lt;code&gt;subsec_nanos&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Para determinar el n&amp;uacute;mero total de segundos representados por la &lt;code&gt;Duration&lt;/code&gt; , use &lt;code&gt;as_secs&lt;/code&gt; en combinaci&amp;oacute;n con &lt;a href=&quot;#method.subsec_nanos&quot;&gt; &lt;code&gt;subsec_nanos&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="08d2c31864b299072e74b4018700dfb17575ecb3" translate="yes" xml:space="preserve">
          <source>To determine the total number of seconds represented by the &lt;code&gt;Duration&lt;/code&gt;, use &lt;code&gt;as_secs&lt;/code&gt; in combination with &lt;a href=&quot;struct.duration#method.subsec_nanos&quot;&gt;&lt;code&gt;subsec_nanos&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c73fc588227a5e5b304d8e85115a9b2d547b13e" translate="yes" xml:space="preserve">
          <source>To determine whether to use loops or iterators, you need to know which version of our &lt;code&gt;search&lt;/code&gt; functions is faster: the version with an explicit &lt;code&gt;for&lt;/code&gt; loop or the version with iterators.</source>
          <target state="translated">Para determinar si usar bucles o iteradores, necesita saber qu&amp;eacute; versi&amp;oacute;n de nuestras funciones de &lt;code&gt;search&lt;/code&gt; es m&amp;aacute;s r&amp;aacute;pida: la versi&amp;oacute;n con un bucle &lt;code&gt;for&lt;/code&gt; expl&amp;iacute;cito o la versi&amp;oacute;n con iteradores.</target>
        </trans-unit>
        <trans-unit id="235f6ddc8fb93b9bc27bd450e93516c6f056381f" translate="yes" xml:space="preserve">
          <source>To disambiguate and tell Rust that we want to use the implementation of &lt;code&gt;Animal&lt;/code&gt; for &lt;code&gt;Dog&lt;/code&gt;, we need to use fully qualified syntax. Listing 19-21 demonstrates how to use fully qualified syntax.</source>
          <target state="translated">Para eliminar la ambig&amp;uuml;edad y decirle a Rust que queremos usar la implementaci&amp;oacute;n de &lt;code&gt;Animal&lt;/code&gt; for &lt;code&gt;Dog&lt;/code&gt; , necesitamos usar una sintaxis completamente calificada. El Listado 19-21 demuestra c&amp;oacute;mo utilizar una sintaxis totalmente calificada.</target>
        </trans-unit>
        <trans-unit id="f6bc5e83e5f978fc7521ec1ad0ec48fc0bc1e6d4" translate="yes" xml:space="preserve">
          <source>To do this in a language with inheritance, we might define a class named &lt;code&gt;Component&lt;/code&gt; that has a method named &lt;code&gt;draw&lt;/code&gt; on it. The other classes, such as &lt;code&gt;Button&lt;/code&gt;, &lt;code&gt;Image&lt;/code&gt;, and &lt;code&gt;SelectBox&lt;/code&gt;, would inherit from &lt;code&gt;Component&lt;/code&gt; and thus inherit the &lt;code&gt;draw&lt;/code&gt; method. They could each override the &lt;code&gt;draw&lt;/code&gt; method to define their custom behavior, but the framework could treat all of the types as if they were &lt;code&gt;Component&lt;/code&gt; instances and call &lt;code&gt;draw&lt;/code&gt; on them. But because Rust doesn&amp;rsquo;t have inheritance, we need another way to structure the &lt;code&gt;gui&lt;/code&gt; library to allow users to extend it with new types.</source>
          <target state="translated">Para hacer esto en un lenguaje con herencia, podr&amp;iacute;amos definir una clase llamada &lt;code&gt;Component&lt;/code&gt; e que tenga un m&amp;eacute;todo llamado &lt;code&gt;draw&lt;/code&gt; . Las otras clases, como &lt;code&gt;Button&lt;/code&gt; , &lt;code&gt;Image&lt;/code&gt; y &lt;code&gt;SelectBox&lt;/code&gt; , heredar&amp;iacute;an de &lt;code&gt;Component&lt;/code&gt; y, por lo tanto, heredar&amp;iacute;an el m&amp;eacute;todo de &lt;code&gt;draw&lt;/code&gt; . Cada uno podr&amp;iacute;a anular el m&amp;eacute;todo de &lt;code&gt;draw&lt;/code&gt; para definir su comportamiento personalizado, pero el marco podr&amp;iacute;a tratar todos los tipos como si fueran instancias de &lt;code&gt;Component&lt;/code&gt; y llamar a &lt;code&gt;draw&lt;/code&gt; sobre ellos. Pero debido a que Rust no tiene herencia, necesitamos otra forma de estructurar la biblioteca de &lt;code&gt;gui&lt;/code&gt; gr&amp;aacute;fica de usuario para permitir que los usuarios la extiendan con nuevos tipos.</target>
        </trans-unit>
        <trans-unit id="4978131923d35532be220aa91636f57efe0f7f12" translate="yes" xml:space="preserve">
          <source>To easily implement the Clone trait, you can also use &lt;code&gt;#[derive(Clone)]&lt;/code&gt;. Example:</source>
          <target state="translated">Para implementar f&amp;aacute;cilmente el rasgo Clonar, tambi&amp;eacute;n puede usar &lt;code&gt;#[derive(Clone)]&lt;/code&gt; . Ejemplo:</target>
        </trans-unit>
        <trans-unit id="d0cd2dd965d6ad9f646e83059dd95c728c0a97cf" translate="yes" xml:space="preserve">
          <source>To eliminate this duplication, we can create an abstraction by defining a function that operates on any list of integers given to it in a parameter. This solution makes our code clearer and lets us express the concept of finding the largest number in a list abstractly.</source>
          <target state="translated">Para eliminar esta duplicación,podemos crear una abstracción definiendo una función que opere sobre cualquier lista de números enteros que se le dé en un parámetro.Esta solución hace nuestro código más claro y nos permite expresar de forma abstracta el concepto de encontrar el mayor número en una lista.</target>
        </trans-unit>
        <trans-unit id="29cf48fa5d156f2e83366c6a4eab852452303d3f" translate="yes" xml:space="preserve">
          <source>To enable &lt;code&gt;minigrep&lt;/code&gt; to read the values of command line arguments we pass to it, we&amp;rsquo;ll need a function provided in Rust&amp;rsquo;s standard library, which is &lt;code&gt;std::env::args&lt;/code&gt;. This function returns an iterator of the command line arguments that were given to &lt;code&gt;minigrep&lt;/code&gt;. We&amp;rsquo;ll cover iterators fully in &lt;a href=&quot;ch13-00-functional-features&quot;&gt;Chapter 13&lt;/a&gt;. For now, you only need to know two details about iterators: iterators produce a series of values, and we can call the &lt;code&gt;collect&lt;/code&gt; method on an iterator to turn it into a collection, such as a vector, containing all the elements the iterator produces.</source>
          <target state="translated">Para permitir que &lt;code&gt;minigrep&lt;/code&gt; lea los valores de los argumentos de la l&amp;iacute;nea de comandos que le pasamos, necesitaremos una funci&amp;oacute;n proporcionada en la biblioteca est&amp;aacute;ndar de Rust, que es &lt;code&gt;std::env::args&lt;/code&gt; . Esta funci&amp;oacute;n devuelve un iterador de los argumentos de la l&amp;iacute;nea de comandos que se le dieron a &lt;code&gt;minigrep&lt;/code&gt; . Cubriremos los iteradores por completo en el &lt;a href=&quot;ch13-00-functional-features&quot;&gt;Cap&amp;iacute;tulo 13&lt;/a&gt; . Por ahora, solo necesita conocer dos detalles sobre los iteradores: los iteradores producen una serie de valores y podemos llamar al m&amp;eacute;todo de &lt;code&gt;collect&lt;/code&gt; en un iterador para convertirlo en una colecci&amp;oacute;n, como un vector, que contiene todos los elementos que produce el iterador.</target>
        </trans-unit>
        <trans-unit id="ad43deb7c3d4847ed4f9b3c47149e285bd2d149c" translate="yes" xml:space="preserve">
          <source>To enable multiple ownership, Rust has a type called &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;, which is an abbreviation for &lt;em&gt;reference counting&lt;/em&gt;. The &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; type keeps track of the number of references to a value which determines whether or not a value is still in use. If there are zero references to a value, the value can be cleaned up without any references becoming invalid.</source>
          <target state="translated">Para habilitar la propiedad m&amp;uacute;ltiple, Rust tiene un tipo llamado &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; , que es una abreviatura de &lt;em&gt;recuento de referencias&lt;/em&gt; . El tipo &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; realiza un seguimiento del n&amp;uacute;mero de referencias a un valor que determina si un valor todav&amp;iacute;a est&amp;aacute; en uso o no. Si hay cero referencias a un valor, el valor se puede limpiar sin que ninguna referencia sea inv&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="e59e1050701d5494b23014e46f9317fad2eac0b0" translate="yes" xml:space="preserve">
          <source>To enable this feature on a nightly version of rustc, add the &lt;code&gt;const_fn&lt;/code&gt; feature flag:</source>
          <target state="translated">Para habilitar esta funci&amp;oacute;n en una versi&amp;oacute;n nocturna de rustc, agregue la &lt;code&gt;const_fn&lt;/code&gt; funci&amp;oacute;n const_fn :</target>
        </trans-unit>
        <trans-unit id="d24a8c41c8e51812d2f6a3d4df4d4bc30f42fd94" translate="yes" xml:space="preserve">
          <source>To ensure memory safety, there&amp;rsquo;s one more detail to what happens in this situation in Rust. Instead of trying to copy the allocated memory, Rust considers &lt;code&gt;s1&lt;/code&gt; to no longer be valid and, therefore, Rust doesn&amp;rsquo;t need to free anything when &lt;code&gt;s1&lt;/code&gt; goes out of scope. Check out what happens when you try to use &lt;code&gt;s1&lt;/code&gt; after &lt;code&gt;s2&lt;/code&gt; is created; it won&amp;rsquo;t work:</source>
          <target state="translated">Para garantizar la seguridad de la memoria, hay un detalle m&amp;aacute;s de lo que sucede en esta situaci&amp;oacute;n en Rust. En lugar de intentar copiar la memoria asignada, Rust considera que &lt;code&gt;s1&lt;/code&gt; ya no es v&amp;aacute;lido y, por lo tanto, Rust no necesita liberar nada cuando &lt;code&gt;s1&lt;/code&gt; sale de su alcance. Vea lo que sucede cuando intenta usar &lt;code&gt;s1&lt;/code&gt; despu&amp;eacute;s de que se crea &lt;code&gt;s2&lt;/code&gt; ; no funcionar&amp;aacute;:</target>
        </trans-unit>
        <trans-unit id="44d8c4aeacd237bf73174a5745772ccb9ea1f421" translate="yes" xml:space="preserve">
          <source>To ensure soundness, Safe Rust is restricted enough that it can be automatically checked. Sometimes, however, it is necessary to write code that is correct for reasons which are too clever for the compiler to understand. In those cases, you need to use Unsafe Rust.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ccd9133d33f00e1b04fd5409b4bd62ab4182d4d" translate="yes" xml:space="preserve">
          <source>To extend a type without breaking existing code</source>
          <target state="translated">Para extender un tipo sin romper el código existente</target>
        </trans-unit>
        <trans-unit id="7b84fa9a4a555e1a74d29f79dcd3abb8731f5940" translate="yes" xml:space="preserve">
          <source>To find the common type for a series of if branches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f27ddccf4caea85a4bf8ac030a69155b2d937a94" translate="yes" xml:space="preserve">
          <source>To find the common type for a series of match arms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd607b32ed771d3a582f20b6ce2e41a23d6c8021" translate="yes" xml:space="preserve">
          <source>To find the common type for array elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="986aa5a06f6c7eab4fbf8758ab21e34c28998b7b" translate="yes" xml:space="preserve">
          <source>To find the largest number in two different lists of numbers, we can duplicate the code in Listing 10-1 and use the same logic at two different places in the program, as shown in Listing 10-2.</source>
          <target state="translated">Para encontrar el número más grande en dos listas de números diferentes,podemos duplicar el código en la Lista 10-1 y usar la misma lógica en dos lugares diferentes del programa,como se muestra en la Lista 10-2.</target>
        </trans-unit>
        <trans-unit id="886ceb6ce4fcd41c44c60891b1e238be8050a3e5" translate="yes" xml:space="preserve">
          <source>To find the type for the return type of a closure with multiple return statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05412e512ad05fb982373163c001384a6dc6dc41" translate="yes" xml:space="preserve">
          <source>To fix such code, put them in an extern &quot;C&quot; block:</source>
          <target state="translated">Para arreglar ese código,póngalos en un bloque externo &quot;C&quot;:</target>
        </trans-unit>
        <trans-unit id="3f641101a15aa5663f425af7eca864860358c2b4" translate="yes" xml:space="preserve">
          <source>To fix the compiler error in Listing 16-3, we can use the error message&amp;rsquo;s advice:</source>
          <target state="translated">Para corregir el error del compilador en el Listado 16-3, podemos usar el consejo del mensaje de error:</target>
        </trans-unit>
        <trans-unit id="35eb0225e4203818949db81d35253471e9bc1946" translate="yes" xml:space="preserve">
          <source>To fix the issue, remove patterns (&lt;code&gt;_&lt;/code&gt; is allowed though). Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea4b2f5b453763912d29b2bc8e5d29a39885b8b2" translate="yes" xml:space="preserve">
          <source>To fix the issue, remove the duplicate declaration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a982630d24bce9f0c2bacf99524398a473cc7ece" translate="yes" xml:space="preserve">
          <source>To fix the previous code example, we derive &lt;code&gt;PartialEq&lt;/code&gt; and &lt;code&gt;Eq&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a70249adaf4eb50343b8e3cb8c112aee0c4394d" translate="yes" xml:space="preserve">
          <source>To fix the problem where we have a refutable pattern where an irrefutable pattern is needed, we can change the code that uses the pattern: instead of using &lt;code&gt;let&lt;/code&gt;, we can use &lt;code&gt;if let&lt;/code&gt;. Then if the pattern doesn&amp;rsquo;t match, the code will just skip the code in the curly brackets, giving it a way to continue validly. Listing 18-9 shows how to fix the code in Listing 18-8.</source>
          <target state="translated">Para solucionar el problema donde tenemos un patr&amp;oacute;n refutable donde se necesita un patr&amp;oacute;n irrefutable, podemos cambiar el c&amp;oacute;digo que usa el patr&amp;oacute;n: en lugar de usar &lt;code&gt;let&lt;/code&gt; , podemos usar &lt;code&gt;if let&lt;/code&gt; . Luego, si el patr&amp;oacute;n no coincide, el c&amp;oacute;digo simplemente omitir&amp;aacute; el c&amp;oacute;digo entre corchetes, lo que le permitir&amp;aacute; continuar de manera v&amp;aacute;lida. El Listado 18-9 muestra c&amp;oacute;mo corregir el c&amp;oacute;digo del Listado 18-8.</target>
        </trans-unit>
        <trans-unit id="3d38f12fb6a882b38564fce2f1f7c9cb9d1796dd" translate="yes" xml:space="preserve">
          <source>To fix the problem, either remove the unknown meta item, or rename it if you provided the wrong name.</source>
          <target state="translated">Para solucionar el problema,elimine el elemento meta desconocido,o renombrelo si proporcionó el nombre equivocado.</target>
        </trans-unit>
        <trans-unit id="ff15ef440d8fd65fc53847fcd7d27134b37684e0" translate="yes" xml:space="preserve">
          <source>To fix the problem, remove all but one of the meta items with the same key.</source>
          <target state="translated">Para solucionar el problema,elimina todos los meta-elementos menos uno con la misma llave.</target>
        </trans-unit>
        <trans-unit id="ea6969ed4bf2de9ff5e1987bde2a5974361798c0" translate="yes" xml:space="preserve">
          <source>To fix this and consume the iterator, we&amp;rsquo;ll use the &lt;code&gt;collect&lt;/code&gt; method, which we used in Chapter 12 with &lt;code&gt;env::args&lt;/code&gt; in Listing 12-1. This method consumes the iterator and collects the resulting values into a collection data type.</source>
          <target state="translated">Para solucionar esto y consumir el iterador, usaremos el m&amp;eacute;todo de &lt;code&gt;collect&lt;/code&gt; , que usamos en el Cap&amp;iacute;tulo 12 con &lt;code&gt;env::args&lt;/code&gt; en el Listado 12-1. Este m&amp;eacute;todo consume el iterador y recopila los valores resultantes en un tipo de datos de recopilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7ddafefb4eada6e20a8873619c096afec9d9e821" translate="yes" xml:space="preserve">
          <source>To fix this error we need to spell out &lt;code&gt;Self&lt;/code&gt; to &lt;code&gt;S&amp;lt;'a&amp;gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d00f739419dcbd64823b1ea3abe0a10a9be4cbba" translate="yes" xml:space="preserve">
          <source>To fix this error, add a &lt;code&gt;main&lt;/code&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b190c393f2e104afe11b9ff6d75785abc13b4fac" translate="yes" xml:space="preserve">
          <source>To fix this error, add the missing digits:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74f9240b7df9e2cdcc942864074f152c08f49afd" translate="yes" xml:space="preserve">
          <source>To fix this error, add the missing double quote at the end of the string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2a45c1a4916fd6685c913af98c59a6ca44a92d9" translate="yes" xml:space="preserve">
          <source>To fix this error, add the missing quote:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14bc23db223a3a7adb6fd2ea01135a7a51e21b23" translate="yes" xml:space="preserve">
          <source>To fix this error, check that you didn't misspell the field's name or that the field actually exists. Example:</source>
          <target state="translated">Para corregir este error,comprueba que no hayas escrito mal el nombre del campo o que el campo exista realmente.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="75b750ac4b7d89ba0d9d76afc4c969c263359a34" translate="yes" xml:space="preserve">
          <source>To fix this error, compile your code for a Rust target that supports the TrustZone-M extension. The current possible targets are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7f0d68c9258ec3385682a9e7888b4d82a961453" translate="yes" xml:space="preserve">
          <source>To fix this error, declare &lt;code&gt;ss&lt;/code&gt; as mutable by using the &lt;code&gt;mut&lt;/code&gt; keyword:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a10ae82ce30bea6273b20c3ae88287f346a01ba" translate="yes" xml:space="preserve">
          <source>To fix this error, declare your entry function with a C ABI, using &lt;code&gt;extern &quot;C&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec4c03a79b5dd9aa983287afa6ca9be17b72579d" translate="yes" xml:space="preserve">
          <source>To fix this error, don't try to cast directly between thin and fat pointers.</source>
          <target state="translated">Para corregir este error,no intente lanzar directamente entre los punteros delgado y gordo.</target>
        </trans-unit>
        <trans-unit id="851cef01fbc24aa508b07321c6a80e736f5740f3" translate="yes" xml:space="preserve">
          <source>To fix this error, either lessen the expected lifetime or find a way to not have to use this reference outside of its current scope (by running the code directly in the same block for example?):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cf449e499fd02815621561773f0782493f1f5ff" translate="yes" xml:space="preserve">
          <source>To fix this error, either split into multiple match arms:</source>
          <target state="translated">Para arreglar este error,o bien se divide en múltiples brazos de fósforo:</target>
        </trans-unit>
        <trans-unit id="4a625dc9e5fa99f625b4f36ca500334a72e9f93e" translate="yes" xml:space="preserve">
          <source>To fix this error, ensure that each field from the struct's definition is mentioned in the pattern, or use &lt;code&gt;..&lt;/code&gt; to ignore unwanted fields. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59d5e036d18215af29bf5d6026ec79c924cc4630" translate="yes" xml:space="preserve">
          <source>To fix this error, ensure that you don't have any other references to the variable before trying to access it mutably:</source>
          <target state="translated">Para corregir este error,asegúrese de no tener otras referencias a la variable antes de intentar acceder a ella mutablemente:</target>
        </trans-unit>
        <trans-unit id="c41c6753158354db97000bee3e6d1e71d162a5c2" translate="yes" xml:space="preserve">
          <source>To fix this error, ensure the match arm kind is the same as the expression matched.</source>
          <target state="translated">Para corregir este error,asegúrate de que el tipo de brazo de la pareja es el mismo que el de la expresión de la pareja.</target>
        </trans-unit>
        <trans-unit id="0e0f8c883662f36aaeadf872304efd94871b85a2" translate="yes" xml:space="preserve">
          <source>To fix this error, just change the binding's name in order to avoid shadowing one of the following:</source>
          <target state="translated">Para corregir este error,sólo hay que cambiar el nombre de la encuadernación para evitar la sombra de uno de los siguientes:</target>
        </trans-unit>
        <trans-unit id="547cd595fdb912c2692881e0fc69f7e09c4e06b4" translate="yes" xml:space="preserve">
          <source>To fix this error, just specify the type of the variable. Example:</source>
          <target state="translated">Para corregir este error,sólo hay que especificar el tipo de la variable.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="ac9826f4a5f0aca5be2cbd8435bee957e2a23961" translate="yes" xml:space="preserve">
          <source>To fix this error, just use the same mode in both cases. Generally using &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;ref mut&lt;/code&gt; where not already used will fix this:</source>
          <target state="translated">Para corregir este error, utilice el mismo modo en ambos casos. Generalmente usando &lt;code&gt;ref&lt;/code&gt; o &lt;code&gt;ref mut&lt;/code&gt; donde a&amp;uacute;n no se haya utilizado solucionar&amp;aacute; esto:</target>
        </trans-unit>
        <trans-unit id="f5f3bd9b98cede2f9883569f89f15b8f146e95f8" translate="yes" xml:space="preserve">
          <source>To fix this error, please be sure that the module is in scope:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="130e6cb76ab8ba2e39f9316003d15648f16e824e" translate="yes" xml:space="preserve">
          <source>To fix this error, please check that this type implements this binary operation. Example:</source>
          <target state="translated">Para corregir este error,por favor,compruebe que este tipo implementa esta operación binaria.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="5f8bccc6c37b14540562ff31ba77c03a4a691b62" translate="yes" xml:space="preserve">
          <source>To fix this error, please ensure that all the fields of the struct are public, or implement a function for easy instantiation. Examples:</source>
          <target state="translated">Para corregir este error,por favor asegúrese de que todos los campos de la estructura son públicos,o implementar una función para una fácil instanciación.Ejemplos:</target>
        </trans-unit>
        <trans-unit id="342e8c2f7a1ada9b484baabdc9d06d406ca80a54" translate="yes" xml:space="preserve">
          <source>To fix this error, please implement a trait on the type or wrap it in a struct. Example:</source>
          <target state="translated">Para corregir este error,por favor implemente un rasgo en el tipo o envuélvalo en una estructura.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="befadb1ed4ec4a8c074944e9002910bb635c2bda" translate="yes" xml:space="preserve">
          <source>To fix this error, please remove the visibility qualifier when it is not required. Example:</source>
          <target state="translated">Para corregir este error,por favor,quita el calificador de visibilidad cuando no sea necesario.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="dd5bba6de2aa5f4e39e98433e92b409c0d3ccac5" translate="yes" xml:space="preserve">
          <source>To fix this error, please replace the value with a constant. Example:</source>
          <target state="translated">Para corregir este error,por favor,sustituya el valor por una constante.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="29332719480b2d3d455368380fd1815d30eebf29" translate="yes" xml:space="preserve">
          <source>To fix this error, please verify that the method name wasn't misspelled and verify that you are indeed implementing the correct trait items. Example:</source>
          <target state="translated">Para corregir este error,por favor,compruebe que el nombre del método no se ha escrito mal y verifique que está implementando los elementos de rasgos correctos.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="d6526d13f1c406efebc4022cedccc7bfc1d5dbc7" translate="yes" xml:space="preserve">
          <source>To fix this error, please verify you didn't misspell the type name, you did declare it or imported it into the scope. Examples:</source>
          <target state="translated">Para corregir este error,por favor verifique que no haya escrito mal el nombre del tipo,que lo haya declarado o que lo haya importado al ámbito de aplicación.Ejemplos:</target>
        </trans-unit>
        <trans-unit id="e76357808cad4720013a780f0b9c4aca40fe0097" translate="yes" xml:space="preserve">
          <source>To fix this error, remove the null characters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b0aa8ad2a46bb3a87624f0ae14dc2151334230f" translate="yes" xml:space="preserve">
          <source>To fix this error, replace the pattern argument with a regular one. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5459bb70fc45530a8171a7e09df41fa4c970e0d5" translate="yes" xml:space="preserve">
          <source>To fix this error, use a concrete type for the const parameter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca68924d905d97b9f1af1bea1e0a2d8cf16561fb" translate="yes" xml:space="preserve">
          <source>To fix this error, we need to move the &lt;code&gt;Shark&lt;/code&gt; struct inside the &lt;code&gt;Sea&lt;/code&gt; module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="140824e6ec67ac2a81b7a4c3bb6daa38bc47f6d7" translate="yes" xml:space="preserve">
          <source>To fix this error, you can declare &lt;code&gt;create_some&lt;/code&gt; as a constant function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6da3993819cb20099d5b634dd66120eb7048a481" translate="yes" xml:space="preserve">
          <source>To fix this error, you can finish using the closure before using the captured variable:</source>
          <target state="translated">Para corregir este error,puedes terminar de usar el cierre antes de usar la variable capturada:</target>
        </trans-unit>
        <trans-unit id="271f576e3469a4d5c3d47381caa4c74a644868c6" translate="yes" xml:space="preserve">
          <source>To fix this error, you can use the tuple pattern:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3282af9d0d83b5725d812a840935cf798392f05" translate="yes" xml:space="preserve">
          <source>To fix this error, you have to move &lt;code&gt;yield&lt;/code&gt; out of the &lt;code&gt;async&lt;/code&gt; block:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62676a2c0346704243e5e296c782b376a8f848ca" translate="yes" xml:space="preserve">
          <source>To fix this error, you have two solutions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d18371bc4c07ba0c41f6206f4861a5d76f0f6e55" translate="yes" xml:space="preserve">
          <source>To fix this error, you need to mark all the parent implementations as default. Example:</source>
          <target state="translated">Para corregir este error,es necesario marcar todas las implementaciones padres como predeterminadas.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="cf4fd1eefb95ff6d8562a2c0c639ea77e8a69e6e" translate="yes" xml:space="preserve">
          <source>To fix this issue, either use the lifetime in the arguments, or use &lt;code&gt;'static&lt;/code&gt;. Example:</source>
          <target state="translated">Para solucionar este problema, use el tiempo de vida en los argumentos o use &lt;code&gt;'static&lt;/code&gt; . Ejemplo:</target>
        </trans-unit>
        <trans-unit id="9bc21023f3e82d02ae5ca480adede6bb29ef608c" translate="yes" xml:space="preserve">
          <source>To fix this issue, either use the lifetime in the arguments, or use the &lt;code&gt;'static&lt;/code&gt; lifetime. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb2e9d61c37258f8ed9cce9fe2929803d6d2313b" translate="yes" xml:space="preserve">
          <source>To fix this issue, either use the lifetime in the inputs, or use &lt;code&gt;'static&lt;/code&gt;. Example:</source>
          <target state="translated">Para solucionar este problema, utilice la duraci&amp;oacute;n de las entradas o utilice &lt;code&gt;'static&lt;/code&gt; . Ejemplo:</target>
        </trans-unit>
        <trans-unit id="1c9273cf829edc7ecc1d2ffb40566c6ec5264a53" translate="yes" xml:space="preserve">
          <source>To fix this issue, just remove the generics:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47d656f4427ec08945a130e9ab24f44d356e73c6" translate="yes" xml:space="preserve">
          <source>To fix this issue, just remove the return keyword or move the expression into a function. Example:</source>
          <target state="translated">Para solucionar este problema,sólo hay que eliminar la palabra clave de retorno o mover la expresión a una función.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="f7f17c649ffe42ea1218c2db05314ba8b680b067" translate="yes" xml:space="preserve">
          <source>To fix this issue, just remove the super trait:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6045b449bd1ac38773b2f91ba227f233a40af26b" translate="yes" xml:space="preserve">
          <source>To fix this issue, the lifetime in the const generic need to be changed to &lt;code&gt;'static&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9924221c408a112fe763d167c1b4a29e5c450e04" translate="yes" xml:space="preserve">
          <source>To fix this issue, you have to rename at least one of the two imports. Example:</source>
          <target state="translated">Para solucionar este problema,hay que cambiar el nombre de al menos una de las dos importaciones.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="8b92f6f0312b161fc6e42dd1de00eb946169f081" translate="yes" xml:space="preserve">
          <source>To fix this problem, we&amp;rsquo;ll modify the threads so they listen for either a &lt;code&gt;Job&lt;/code&gt; to run or a signal that they should stop listening and exit the infinite loop. Instead of &lt;code&gt;Job&lt;/code&gt; instances, our channel will send one of these two enum variants.</source>
          <target state="translated">Para solucionar este problema, modificaremos los hilos para que escuchen si se ejecuta un &lt;code&gt;Job&lt;/code&gt; o una se&amp;ntilde;al de que deben dejar de escuchar y salir del bucle infinito. En lugar de &lt;code&gt;Job&lt;/code&gt; instancias , nuestro canal enviar&amp;aacute; una de estas dos variantes de enumeraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c3ddf887a4b5f979d5c4754fbe5d3842c28e8398" translate="yes" xml:space="preserve">
          <source>To fix this problem, you can do either of these things:</source>
          <target state="translated">Para arreglar este problema,puedes hacer cualquiera de estas cosas:</target>
        </trans-unit>
        <trans-unit id="d1040dc78ad7b42b1b39bcb93179f38486776a0b" translate="yes" xml:space="preserve">
          <source>To fix this problem, you need to create a local variable to store the value in rather than relying on a temporary. For example, you might change the original program to the following:</source>
          <target state="translated">Para solucionar este problema,es necesario crear una variable local para almacenar el valor en lugar de depender de una temporal.Por ejemplo,podrías cambiar el programa original por el siguiente:</target>
        </trans-unit>
        <trans-unit id="038c4ea9697da9d94b0b431c704689f74be084b1" translate="yes" xml:space="preserve">
          <source>To fix this we have to define the lifetime at the function or impl level and use that lifetime in the &lt;code&gt;impl Trait&lt;/code&gt;. For example you can define the lifetime at the function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="396fe77bfe601f99ac29d2d6217b45f0b4c303c2" translate="yes" xml:space="preserve">
          <source>To fix this we have to use the labeled block properly. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="360a9b00506f1addbb3267f917ea23dd8584e790" translate="yes" xml:space="preserve">
          <source>To fix this, add a label specifying which loop is being broken out of:</source>
          <target state="translated">Para arreglar esto,añade una etiqueta que especifique de qué bucle se está saliendo:</target>
        </trans-unit>
        <trans-unit id="4f4f5291163064ff6fda56abd889a7618c40d282" translate="yes" xml:space="preserve">
          <source>To fix this, add an implementation for each default method from the trait:</source>
          <target state="translated">Para arreglar esto,agregue una implementación para cada método predeterminado del rasgo:</target>
        </trans-unit>
        <trans-unit id="56a92651d517e6a1850a1ad3d4745e7b392eba21" translate="yes" xml:space="preserve">
          <source>To fix this, edit the &lt;em&gt;Cargo.toml&lt;/em&gt; file for the &lt;code&gt;adder&lt;/code&gt; crate and indicate that &lt;code&gt;rand&lt;/code&gt; is a dependency for that crate as well. Building the &lt;code&gt;adder&lt;/code&gt; crate will add &lt;code&gt;rand&lt;/code&gt; to the list of dependencies for &lt;code&gt;adder&lt;/code&gt; in &lt;em&gt;Cargo.lock&lt;/em&gt;, but no additional copies of &lt;code&gt;rand&lt;/code&gt; will be downloaded. Cargo has ensured that every crate in the workspace using the &lt;code&gt;rand&lt;/code&gt; crate will be using the same version. Using the same version of &lt;code&gt;rand&lt;/code&gt; across the workspace saves space because we won&amp;rsquo;t have multiple copies and ensures that the crates in the workspace will be compatible with each other.</source>
          <target state="translated">Para solucionar este problema, edite el archivo &lt;em&gt;Cargo.toml&lt;/em&gt; de la caja de &lt;code&gt;adder&lt;/code&gt; e indique que &lt;code&gt;rand&lt;/code&gt; tambi&amp;eacute;n es una dependencia de esa caja. La construcci&amp;oacute;n de la caja &lt;code&gt;adder&lt;/code&gt; agregar&amp;aacute; &lt;code&gt;rand&lt;/code&gt; a la lista de dependencias para &lt;code&gt;adder&lt;/code&gt; en &lt;em&gt;Cargo.lock&lt;/em&gt; , pero no se descargar&amp;aacute;n copias adicionales de &lt;code&gt;rand&lt;/code&gt; . Cargo se ha asegurado de que todas las cajas del espacio de trabajo que utilizan la caja &lt;code&gt;rand&lt;/code&gt; utilizar&amp;aacute;n la misma versi&amp;oacute;n. Usando la misma versi&amp;oacute;n de &lt;code&gt;rand&lt;/code&gt; en el espacio de trabajo ahorra espacio porque no tendremos m&amp;uacute;ltiples copias y asegura que las cajas en el espacio de trabajo ser&amp;aacute;n compatibles entre s&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="9d9a4693a46d51eb0d6120d0488c70fc938ea0de" translate="yes" xml:space="preserve">
          <source>To fix this, edit the &lt;em&gt;Cargo.toml&lt;/em&gt; file for the &lt;code&gt;adder&lt;/code&gt; package and indicate that &lt;code&gt;rand&lt;/code&gt; is a dependency for it as well. Building the &lt;code&gt;adder&lt;/code&gt; package will add &lt;code&gt;rand&lt;/code&gt; to the list of dependencies for &lt;code&gt;adder&lt;/code&gt; in &lt;em&gt;Cargo.lock&lt;/em&gt;, but no additional copies of &lt;code&gt;rand&lt;/code&gt; will be downloaded. Cargo has ensured that every crate in every package in the workspace using the &lt;code&gt;rand&lt;/code&gt; package will be using the same version. Using the same version of &lt;code&gt;rand&lt;/code&gt; across the workspace saves space because we won&amp;rsquo;t have multiple copies and ensures that the crates in the workspace will be compatible with each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dd753bd45e01fa10b5929e59eda068f06c82e05" translate="yes" xml:space="preserve">
          <source>To fix this, either remove the outer reference:</source>
          <target state="translated">Para arreglar esto,o bien se quita la referencia externa:</target>
        </trans-unit>
        <trans-unit id="cb0074c2565e11e981fa6efe9e6d5af9f075e607" translate="yes" xml:space="preserve">
          <source>To fix this, ensure that any declared variables are initialized before being used. Example:</source>
          <target state="translated">Para solucionarlo,asegúrese de que cualquier variable declarada sea inicializada antes de ser utilizada.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="437601cd4925a7106ff21615c74bc484d85aef14" translate="yes" xml:space="preserve">
          <source>To fix this, ensure that the name was correctly spelled, and that the correct form of initializer was used.</source>
          <target state="translated">Para arreglar esto,asegúrese de que el nombre se escribió correctamente,y que se utilizó la forma correcta de inicialización.</target>
        </trans-unit>
        <trans-unit id="890f488bd89f18960203be014ab27fb39dfc6d22" translate="yes" xml:space="preserve">
          <source>To fix this, it is suggested to use a &lt;code&gt;where Self: Sized&lt;/code&gt; bound similar to the fix for the sub-error above if you do not intend to call the method with type parameters:</source>
          <target state="translated">Para solucionar este problema, se sugiere utilizar un &lt;code&gt;where Self: Sized&lt;/code&gt; l&amp;iacute;mite similar a la soluci&amp;oacute;n para el sub-error anterior si no tiene la intenci&amp;oacute;n de llamar al m&amp;eacute;todo con par&amp;aacute;metros de tipo:</target>
        </trans-unit>
        <trans-unit id="c7b0cc36b1cf18605167b9e261109b879dd0c485" translate="yes" xml:space="preserve">
          <source>To fix this, please set manually the next enum value or put the enum variant with the maximum value at the end of the enum. Examples:</source>
          <target state="translated">Para arreglar esto,por favor,establezca manualmente el siguiente valor del enum o ponga la variante del enum con el valor máximo al final del enum.Ejemplos:</target>
        </trans-unit>
        <trans-unit id="fa4bb08fcba49cd98aef8848abbf20a6a3f3bfcb" translate="yes" xml:space="preserve">
          <source>To fix this, replace the generic parameter with the specializations that you need:</source>
          <target state="translated">Para solucionarlo,sustituya el parámetro genérico por las especializaciones que necesite:</target>
        </trans-unit>
        <trans-unit id="0f9e6f402abcaecb02615cbeb4f9eaf1b18503a7" translate="yes" xml:space="preserve">
          <source>To fix this, the value can be extracted as a const and then used:</source>
          <target state="translated">Para fijar esto,el valor puede ser extraído como una constancia y luego usado:</target>
        </trans-unit>
        <trans-unit id="34e96f574d6d4b3f0139f4794453e1b644fdb7fa" translate="yes" xml:space="preserve">
          <source>To fix this, we implement &lt;code&gt;Display&lt;/code&gt; on &lt;code&gt;Point&lt;/code&gt; and satisfy the constraint that &lt;code&gt;OutlinePrint&lt;/code&gt; requires, like so:</source>
          <target state="translated">Para solucionar esto, implementamos &lt;code&gt;Display&lt;/code&gt; on &lt;code&gt;Point&lt;/code&gt; y satisfacemos la restricci&amp;oacute;n que &lt;code&gt;OutlinePrint&lt;/code&gt; requiere, as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="1afba8b0958bf7d54c00a1e357d6112f94820fbc" translate="yes" xml:space="preserve">
          <source>To fix this, you must reference the lifetime &lt;code&gt;'x&lt;/code&gt; from the return type. For example, changing the return type to &lt;code&gt;impl Trait&amp;lt;'y&amp;gt; + 'x&lt;/code&gt; would work:</source>
          <target state="translated">Para solucionar este problema, debe hacer referencia a la duraci&amp;oacute;n &lt;code&gt;'x&lt;/code&gt; del tipo de devoluci&amp;oacute;n. Por ejemplo, cambiar el tipo de retorno a &lt;code&gt;impl Trait&amp;lt;'y&amp;gt; + 'x&lt;/code&gt; funcionar&amp;iacute;a:</target>
        </trans-unit>
        <trans-unit id="7f876767b17c3198e0a111feeef857c2ed3d8806" translate="yes" xml:space="preserve">
          <source>To forcibly capture a backtrace regardless of environment variables, use the &lt;code&gt;Backtrace::force_capture&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2c5b5034aa90905612a009b913793af12d3e3ac" translate="yes" xml:space="preserve">
          <source>To further refine the game&amp;rsquo;s behavior, rather than crashing the program when the user inputs a non-number, let&amp;rsquo;s make the game ignore a non-number so the user can continue guessing. We can do that by altering the line where &lt;code&gt;guess&lt;/code&gt; is converted from a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;u32&lt;/code&gt;, as shown in Listing 2-5.</source>
          <target state="translated">Para refinar a&amp;uacute;n m&amp;aacute;s el comportamiento del juego, en lugar de bloquear el programa cuando el usuario ingresa un no n&amp;uacute;mero, hagamos que el juego ignore un no n&amp;uacute;mero para que el usuario pueda seguir adivinando. Podemos hacer eso alterando la l&amp;iacute;nea donde la &lt;code&gt;guess&lt;/code&gt; se convierte de &lt;code&gt;String&lt;/code&gt; a &lt;code&gt;u32&lt;/code&gt; , como se muestra en el Listado 2-5.</target>
        </trans-unit>
        <trans-unit id="bea9207f63bde7916694d159ff6b4254f0892dc5" translate="yes" xml:space="preserve">
          <source>To get a mutable string slice instead, see the &lt;a href=&quot;#method.slice_mut_unchecked&quot;&gt;&lt;code&gt;slice_mut_unchecked&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Para obtener un segmento de cadena mutable en su lugar, consulte el m&amp;eacute;todo &lt;a href=&quot;#method.slice_mut_unchecked&quot;&gt; &lt;code&gt;slice_mut_unchecked&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="baed129549ca4f37d13996fe220fb567ab069ac8" translate="yes" xml:space="preserve">
          <source>To get a mutable string slice instead, see the &lt;a href=&quot;../primitive.str#method.slice_mut_unchecked&quot;&gt;&lt;code&gt;slice_mut_unchecked&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8139e232eb226615d326fd45327940952c09f923" translate="yes" xml:space="preserve">
          <source>To get a mutable string slice instead, see the &lt;a href=&quot;primitive.str#method.slice_mut_unchecked&quot;&gt;&lt;code&gt;slice_mut_unchecked&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0238d96367a691acb632dbf4d73cc5fd2a706ad9" translate="yes" xml:space="preserve">
          <source>To get a pointer to a boxed value, dereference the box:</source>
          <target state="translated">Para obtener un puntero a un valor de la caja,desvíe la caja:</target>
        </trans-unit>
        <trans-unit id="8f1e8a2f8899e777c3546c1b586cd81156849069" translate="yes" xml:space="preserve">
          <source>To get a specific value from a struct, we can use dot notation. If we wanted just this user&amp;rsquo;s email address, we could use &lt;code&gt;user1.email&lt;/code&gt; wherever we wanted to use this value. If the instance is mutable, we can change a value by using the dot notation and assigning into a particular field. Listing 5-3 shows how to change the value in the &lt;code&gt;email&lt;/code&gt; field of a mutable &lt;code&gt;User&lt;/code&gt; instance.</source>
          <target state="translated">Para obtener un valor espec&amp;iacute;fico de una estructura, podemos usar la notaci&amp;oacute;n de puntos. Si solo quisi&amp;eacute;ramos la direcci&amp;oacute;n de correo electr&amp;oacute;nico de este usuario, podr&amp;iacute;amos usar &lt;code&gt;user1.email&lt;/code&gt; donde quisi&amp;eacute;ramos usar este valor. Si la instancia es mutable, podemos cambiar un valor usando la notaci&amp;oacute;n de puntos y asign&amp;aacute;ndolo a un campo en particular. El Listado 5-3 muestra c&amp;oacute;mo cambiar el valor en el campo de &lt;code&gt;email&lt;/code&gt; de una instancia de &lt;code&gt;User&lt;/code&gt; mutable .</target>
        </trans-unit>
        <trans-unit id="ffd19be588eb8df1e329d2bc1905f6d517e8c370" translate="yes" xml:space="preserve">
          <source>To get an immutable string slice instead, see the &lt;a href=&quot;#method.slice_unchecked&quot;&gt;&lt;code&gt;slice_unchecked&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Para obtener un segmento de cadena inmutable en su lugar, consulte el m&amp;eacute;todo &lt;a href=&quot;#method.slice_unchecked&quot;&gt; &lt;code&gt;slice_unchecked&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4160b8923a79d4ccc00d36a66c387740f16ca557" translate="yes" xml:space="preserve">
          <source>To get an immutable string slice instead, see the &lt;a href=&quot;../primitive.str#method.slice_unchecked&quot;&gt;&lt;code&gt;slice_unchecked&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ce6e3247525a78442e0ee3f76231a67e813fe82" translate="yes" xml:space="preserve">
          <source>To get an immutable string slice instead, see the &lt;a href=&quot;primitive.str#method.slice_unchecked&quot;&gt;&lt;code&gt;slice_unchecked&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29270bb604499679be31005db9630fdff3a329f3" translate="yes" xml:space="preserve">
          <source>To get immutable string slices instead, see the &lt;a href=&quot;#method.split_at&quot;&gt;&lt;code&gt;split_at&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Para obtener cortes de cadena inmutables en su lugar, consulte el m&amp;eacute;todo &lt;a href=&quot;#method.split_at&quot;&gt; &lt;code&gt;split_at&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1773350f816d14b08d14b8fc6f4503505910e146" translate="yes" xml:space="preserve">
          <source>To get immutable string slices instead, see the &lt;a href=&quot;../primitive.str#method.split_at&quot;&gt;&lt;code&gt;split_at&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="130eb39bd47cd566af1912b3ccb9f5e133aeacd3" translate="yes" xml:space="preserve">
          <source>To get immutable string slices instead, see the &lt;a href=&quot;primitive.str#method.split_at&quot;&gt;&lt;code&gt;split_at&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6bbcb0bb220df37e8c688ef821b8733765b09b5" translate="yes" xml:space="preserve">
          <source>To get mutable string slices instead, see the &lt;a href=&quot;#method.split_at_mut&quot;&gt;&lt;code&gt;split_at_mut&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Para obtener cortes de cadena mutables, consulte el m&amp;eacute;todo &lt;a href=&quot;#method.split_at_mut&quot;&gt; &lt;code&gt;split_at_mut&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7b8786ffc3edfea977e5fb933b851cad79af05d7" translate="yes" xml:space="preserve">
          <source>To get mutable string slices instead, see the &lt;a href=&quot;../primitive.str#method.split_at_mut&quot;&gt;&lt;code&gt;split_at_mut&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46f032d280d4b30ddfbcd15e779b494aafdce282" translate="yes" xml:space="preserve">
          <source>To get mutable string slices instead, see the &lt;a href=&quot;primitive.str#method.split_at_mut&quot;&gt;&lt;code&gt;split_at_mut&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a0349cd0d37a5287741f4237e8c49df43c4e0c6" translate="yes" xml:space="preserve">
          <source>To get this out of the way: you should probably just use &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. These two collections cover most use cases for generic data storage and processing. They are exceptionally good at doing what they do. All the other collections in the standard library have specific use cases where they are the optimal choice, but these cases are borderline &lt;em&gt;niche&lt;/em&gt; in comparison. Even when &lt;code&gt;Vec&lt;/code&gt; and &lt;code&gt;HashMap&lt;/code&gt; are technically suboptimal, they're probably a good enough choice to get started.</source>
          <target state="translated">Para sacar esto del camino: probablemente deber&amp;iacute;a usar &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; . Estas dos colecciones cubren la mayor&amp;iacute;a de los casos de uso para el almacenamiento y procesamiento de datos gen&amp;eacute;ricos. Son excepcionalmente buenos haciendo lo que hacen. Todas las dem&amp;aacute;s colecciones de la biblioteca est&amp;aacute;ndar tienen casos de uso espec&amp;iacute;ficos en los que son la opci&amp;oacute;n &amp;oacute;ptima, pero estos casos son un &lt;em&gt;nicho&lt;/em&gt; l&amp;iacute;mite en comparaci&amp;oacute;n. Incluso cuando &lt;code&gt;Vec&lt;/code&gt; y &lt;code&gt;HashMap&lt;/code&gt; son t&amp;eacute;cnicamente sub&amp;oacute;ptimos, probablemente sean una buena opci&amp;oacute;n para comenzar.</target>
        </trans-unit>
        <trans-unit id="18773042303056fd8c79476f3616f355ff443a51" translate="yes" xml:space="preserve">
          <source>To handle the error case and print a user-friendly message, we need to update &lt;code&gt;main&lt;/code&gt; to handle the &lt;code&gt;Result&lt;/code&gt; being returned by &lt;code&gt;Config::new&lt;/code&gt;, as shown in Listing 12-10. We&amp;rsquo;ll also take the responsibility of exiting the command line tool with a nonzero error code from &lt;code&gt;panic!&lt;/code&gt; and implement it by hand. A nonzero exit status is a convention to signal to the process that called our program that the program exited with an error state.</source>
          <target state="translated">Para manejar el caso de error e imprimir un mensaje f&amp;aacute;cil de usar, necesitamos actualizar &lt;code&gt;main&lt;/code&gt; para manejar el &lt;code&gt;Result&lt;/code&gt; devuelto por &lt;code&gt;Config::new&lt;/code&gt; , como se muestra en el Listado 12-10. &amp;iexcl;Tambi&amp;eacute;n asumiremos la responsabilidad de salir de la herramienta de l&amp;iacute;nea de comandos con un c&amp;oacute;digo de error distinto de cero de &lt;code&gt;panic!&lt;/code&gt; e implementarlo a mano. Un estado de salida distinto de cero es una convenci&amp;oacute;n para se&amp;ntilde;alar al proceso que llam&amp;oacute; a nuestro programa que el programa sali&amp;oacute; con un estado de error.</target>
        </trans-unit>
        <trans-unit id="482ebf3be5fe8298225b2e8f09ccc5e7f7c51bf1" translate="yes" xml:space="preserve">
          <source>To help IDE integration, the Rust project distributes the &lt;em&gt;Rust Language Server&lt;/em&gt; (&lt;code&gt;rls&lt;/code&gt;). This tool speaks the &lt;a href=&quot;http://langserver.org/&quot;&gt;Language Server Protocol&lt;/a&gt;, which is a specification for IDEs and programming languages to communicate with each other. Different clients can use the &lt;code&gt;rls&lt;/code&gt;, such as &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=rust-lang.rust&quot;&gt;the Rust plug-in for Visual Studio Code&lt;/a&gt;.</source>
          <target state="translated">Para ayudar a la integraci&amp;oacute;n de IDE, el proyecto Rust distribuye &lt;em&gt;Rust Language Server&lt;/em&gt; ( &lt;code&gt;rls&lt;/code&gt; ). Esta herramienta habla el &lt;a href=&quot;http://langserver.org/&quot;&gt;Protocolo de servidor de idiomas&lt;/a&gt; , que es una especificaci&amp;oacute;n para que los IDE y los lenguajes de programaci&amp;oacute;n se comuniquen entre s&amp;iacute;. Diferentes clientes pueden usar &lt;code&gt;rls&lt;/code&gt; , como &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=rust-lang.rust&quot;&gt;el complemento Rust para Visual Studio Code&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="20b8f11e3eb504aaf128f283d04500f6915052b5" translate="yes" xml:space="preserve">
          <source>To illustrate situations where closures that can capture their environment are useful as function parameters, let&amp;rsquo;s move on to our next topic: iterators.</source>
          <target state="translated">Para ilustrar situaciones en las que los cierres que pueden capturar su entorno son &amp;uacute;tiles como par&amp;aacute;metros de funci&amp;oacute;n, pasemos al siguiente tema: iteradores.</target>
        </trans-unit>
        <trans-unit id="6bb8bf87527987f23e438b1c1bc78391e818826e" translate="yes" xml:space="preserve">
          <source>To illustrate the rules of ownership, we need a data type that is more complex than the ones we covered in the &lt;a href=&quot;ch03-02-data-types#data-types&quot;&gt;&amp;ldquo;Data Types&amp;rdquo;&lt;/a&gt; section of Chapter 3. The types covered previously are all stored on the stack and popped off the stack when their scope is over, but we want to look at data that is stored on the heap and explore how Rust knows when to clean up that data.</source>
          <target state="translated">Para ilustrar las reglas de propiedad, necesitamos un tipo de datos que sea m&amp;aacute;s complejo que los que cubrimos en la secci&amp;oacute;n &lt;a href=&quot;ch03-02-data-types#data-types&quot;&gt;&quot;Tipos de datos&quot;&lt;/a&gt; del Cap&amp;iacute;tulo 3. Los tipos cubiertos anteriormente se almacenan en la pila y se extraen de la pila cuando su alcance termin&amp;oacute;, pero queremos ver los datos que est&amp;aacute;n almacenados en el mont&amp;oacute;n y explorar c&amp;oacute;mo Rust sabe cu&amp;aacute;ndo limpiar esos datos.</target>
        </trans-unit>
        <trans-unit id="60712450a97e23097bf6dbe8ed26e2265884e8b7" translate="yes" xml:space="preserve">
          <source>To implement the behavior we want &lt;code&gt;gui&lt;/code&gt; to have, we&amp;rsquo;ll define a trait named &lt;code&gt;Draw&lt;/code&gt; that will have one method named &lt;code&gt;draw&lt;/code&gt;. Then we can define a vector that takes a &lt;em&gt;trait object&lt;/em&gt;. A trait object points to both an instance of a type implementing our specified trait as well as a table used to look up trait methods on that type at runtime. We create a trait object by specifying some sort of pointer, such as a &lt;code&gt;&amp;amp;&lt;/code&gt; reference or a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; smart pointer, then the &lt;code&gt;dyn&lt;/code&gt; keyword, and then specifying the relevant trait. (We&amp;rsquo;ll talk about the reason trait objects must use a pointer in Chapter 19 in the section &lt;a href=&quot;ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;&amp;ldquo;Dynamically Sized Types and the &lt;code&gt;Sized&lt;/code&gt; Trait.&amp;rdquo;&lt;/a&gt;) We can use trait objects in place of a generic or concrete type. Wherever we use a trait object, Rust&amp;rsquo;s type system will ensure at compile time that any value used in that context will implement the trait object&amp;rsquo;s trait. Consequently, we don&amp;rsquo;t need to know all the possible types at compile time.</source>
          <target state="translated">Para implementar el comportamiento que queremos que tenga la &lt;code&gt;gui&lt;/code&gt; de usuario , definiremos un rasgo llamado &lt;code&gt;Draw&lt;/code&gt; que tendr&amp;aacute; un m&amp;eacute;todo llamado &lt;code&gt;draw&lt;/code&gt; . Entonces podemos definir un vector que toma un &lt;em&gt;objeto de rasgo&lt;/em&gt; . Un objeto de rasgo apunta tanto a una instancia de un tipo que implementa nuestro rasgo especificado como a una tabla utilizada para buscar m&amp;eacute;todos de rasgo en ese tipo en tiempo de ejecuci&amp;oacute;n. Creamos un objeto de rasgo especificando alg&amp;uacute;n tipo de puntero, como una referencia &lt;code&gt;&amp;amp;&lt;/code&gt; o un puntero inteligente &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; , luego la palabra clave &lt;code&gt;dyn&lt;/code&gt; y luego especificando el rasgo relevante. (Hablaremos sobre la raz&amp;oacute;n por la que los objetos de rasgo deben usar un puntero en el Cap&amp;iacute;tulo 19 en la secci&amp;oacute;n &lt;a href=&quot;ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;&quot;Tipos de tama&amp;ntilde;o din&amp;aacute;mico y el &lt;code&gt;Sized&lt;/code&gt; Rasgo.&quot; &lt;/a&gt;) Podemos usar objetos de rasgo en lugar de un tipo gen&amp;eacute;rico o concreto. Dondequiera que usemos un objeto de rasgo, el sistema de tipos de Rust asegurar&amp;aacute; en el momento de la compilaci&amp;oacute;n que cualquier valor usado en ese contexto implementar&amp;aacute; el rasgo del objeto de rasgo. En consecuencia, no necesitamos conocer todos los tipos posibles en tiempo de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f5e8a5c28a454d1f90112a6c60c0f8aea2b5196d" translate="yes" xml:space="preserve">
          <source>To improve our program, we&amp;rsquo;ll fix four problems that have to do with the program&amp;rsquo;s structure and how it&amp;rsquo;s handling potential errors.</source>
          <target state="translated">Para mejorar nuestro programa, solucionaremos cuatro problemas que tienen que ver con la estructura del programa y c&amp;oacute;mo maneja los posibles errores.</target>
        </trans-unit>
        <trans-unit id="bf9b4462d1a02f4d70e5d13cf8540c79a5e14d1a" translate="yes" xml:space="preserve">
          <source>To incorporate the &lt;code&gt;Message&lt;/code&gt; enum, we need to change &lt;code&gt;Job&lt;/code&gt; to &lt;code&gt;Message&lt;/code&gt; in two places: the definition of &lt;code&gt;ThreadPool&lt;/code&gt; and the signature of &lt;code&gt;Worker::new&lt;/code&gt;. The &lt;code&gt;execute&lt;/code&gt; method of &lt;code&gt;ThreadPool&lt;/code&gt; needs to send jobs wrapped in the &lt;code&gt;Message::NewJob&lt;/code&gt; variant. Then, in &lt;code&gt;Worker::new&lt;/code&gt; where a &lt;code&gt;Message&lt;/code&gt; is received from the channel, the job will be processed if the &lt;code&gt;NewJob&lt;/code&gt; variant is received, and the thread will break out of the loop if the &lt;code&gt;Terminate&lt;/code&gt; variant is received.</source>
          <target state="translated">Para incorporar la enumeraci&amp;oacute;n de &lt;code&gt;Message&lt;/code&gt; , necesitamos cambiar &lt;code&gt;Job&lt;/code&gt; a &lt;code&gt;Message&lt;/code&gt; en dos lugares: la definici&amp;oacute;n de &lt;code&gt;ThreadPool&lt;/code&gt; y la firma de &lt;code&gt;Worker::new&lt;/code&gt; . La &lt;code&gt;execute&lt;/code&gt; el m&amp;eacute;todo de &lt;code&gt;ThreadPool&lt;/code&gt; necesita para enviar trabajos envueltos en el &lt;code&gt;Message::NewJob&lt;/code&gt; variante. Luego, en &lt;code&gt;Worker::new&lt;/code&gt; donde se recibe un &lt;code&gt;Message&lt;/code&gt; del canal, el trabajo se procesar&amp;aacute; si se &lt;code&gt;NewJob&lt;/code&gt; variante NewJob , y el hilo saldr&amp;aacute; del bucle si se recibe la variante &lt;code&gt;Terminate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f9206704ddf29e2ebea715304ccfd9e3f3ba5f3" translate="yes" xml:space="preserve">
          <source>To install &lt;code&gt;rustfmt&lt;/code&gt;, enter the following:</source>
          <target state="translated">Para instalar &lt;code&gt;rustfmt&lt;/code&gt; , ingrese lo siguiente:</target>
        </trans-unit>
        <trans-unit id="35fe5fa9574aed79cc4c533785f5e0d142e0e320" translate="yes" xml:space="preserve">
          <source>To install Clippy, enter the following:</source>
          <target state="translated">Para instalar Clippy,introduzca lo siguiente:</target>
        </trans-unit>
        <trans-unit id="44d584ca391c2045c83ab8a58e67b2e401ab33be" translate="yes" xml:space="preserve">
          <source>To install the &lt;code&gt;rls&lt;/code&gt;, enter the following:</source>
          <target state="translated">Para instalar el &lt;code&gt;rls&lt;/code&gt; , ingrese lo siguiente:</target>
        </trans-unit>
        <trans-unit id="71a54c2518d0f86ead8ba016e32755cf1ca226ed" translate="yes" xml:space="preserve">
          <source>To interact with a &lt;code&gt;Formatter&lt;/code&gt;, you'll call various methods to change the various options related to formatting. For examples, please see the documentation of the methods defined on &lt;code&gt;Formatter&lt;/code&gt; below.</source>
          <target state="translated">Para interactuar con un &lt;code&gt;Formatter&lt;/code&gt; , llamar&amp;aacute; a varios m&amp;eacute;todos para cambiar las diversas opciones relacionadas con el formato. Para obtener ejemplos, consulte la documentaci&amp;oacute;n de los m&amp;eacute;todos definidos en &lt;code&gt;Formatter&lt;/code&gt; a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b498caa788bb95865cf7ae29f319574a69dd854b" translate="yes" xml:space="preserve">
          <source>To isolate unsafe code as much as possible, it&amp;rsquo;s best to enclose unsafe code within a safe abstraction and provide a safe API, which we&amp;rsquo;ll discuss later in the chapter when we examine unsafe functions and methods. Parts of the standard library are implemented as safe abstractions over unsafe code that has been audited. Wrapping unsafe code in a safe abstraction prevents uses of &lt;code&gt;unsafe&lt;/code&gt; from leaking out into all the places that you or your users might want to use the functionality implemented with &lt;code&gt;unsafe&lt;/code&gt; code, because using a safe abstraction is safe.</source>
          <target state="translated">Para aislar el c&amp;oacute;digo inseguro tanto como sea posible, es mejor encerrar el c&amp;oacute;digo inseguro dentro de una abstracci&amp;oacute;n segura y proporcionar una API segura, que discutiremos m&amp;aacute;s adelante en el cap&amp;iacute;tulo cuando examinemos las funciones y m&amp;eacute;todos inseguros. Partes de la biblioteca est&amp;aacute;ndar se implementan como abstracciones seguras sobre c&amp;oacute;digo no seguro que ha sido auditado. Envolver el c&amp;oacute;digo inseguro en una abstracci&amp;oacute;n segura evita que los usos &lt;code&gt;unsafe&lt;/code&gt; filtren a todos los lugares en los que usted o sus usuarios podr&amp;iacute;an querer usar la funcionalidad implementada con c&amp;oacute;digo &lt;code&gt;unsafe&lt;/code&gt; , porque usar una abstracci&amp;oacute;n segura es seguro.</target>
        </trans-unit>
        <trans-unit id="a6753382b748af96b119a035edd05c7a836b948d" translate="yes" xml:space="preserve">
          <source>To learn about the other kinds of collections provided by the standard library, see &lt;a href=&quot;../std/collections/index&quot;&gt;the documentation&lt;/a&gt;.</source>
          <target state="translated">Para conocer los otros tipos de colecciones que proporciona la biblioteca est&amp;aacute;ndar, consulte &lt;a href=&quot;../std/collections/index&quot;&gt;la documentaci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0dbbd03b2e667a7e6b225ed1de228878e32e5817" translate="yes" xml:space="preserve">
          <source>To learn more about allowing access, see the documentation for the &lt;a href=&quot;keyword.pub&quot;&gt;&lt;code&gt;pub&lt;/code&gt;&lt;/a&gt; keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2736d1e6ef2a3faad24038e53f6bde645f76d87" translate="yes" xml:space="preserve">
          <source>To lowercase ASCII characters in addition to non-ASCII characters, use &lt;a href=&quot;#method.to_lowercase&quot;&gt;&lt;code&gt;to_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para escribir caracteres ASCII en min&amp;uacute;sculas adem&amp;aacute;s de los caracteres que no son ASCII, use &lt;a href=&quot;#method.to_lowercase&quot;&gt; &lt;code&gt;to_lowercase&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e94e0d4cfd63a504442f11c93df0afa614a2f0d4" translate="yes" xml:space="preserve">
          <source>To lowercase ASCII characters in addition to non-ASCII characters, use &lt;a href=&quot;../primitive.str#method.to_lowercase&quot;&gt;&lt;code&gt;str::to_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para min&amp;uacute;sculas caracteres ASCII adem&amp;aacute;s de caracteres no ASCII, use &lt;a href=&quot;../primitive.str#method.to_lowercase&quot;&gt; &lt;code&gt;str::to_lowercase&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="63a5fbbc07007136d2c958a62c0c4ca27bbb449c" translate="yes" xml:space="preserve">
          <source>To lowercase ASCII characters in addition to non-ASCII characters, use &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html#method.to_lowercase&quot;&gt;&lt;code&gt;str::to_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ab2513e3de2d60d109900818fb2429fd91b99d2" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;#method.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para poner el valor en min&amp;uacute;sculas en el lugar, use &lt;a href=&quot;#method.make_ascii_lowercase&quot;&gt; &lt;code&gt;make_ascii_lowercase&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ef146744579c27e21ed699daf39b3a3250767c77" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;#tymethod.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para poner el valor en min&amp;uacute;sculas en el lugar, use &lt;a href=&quot;#tymethod.make_ascii_lowercase&quot;&gt; &lt;code&gt;make_ascii_lowercase&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="67608258687aa72b226fb9d75937d3aa5583b343" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;../primitive.str#method.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c6481a0667301c8cf17a1fc74a4e7ea446e2ab9" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;../primitive.u8#method.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a33f76160389c879809056277f95cb426933c88" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;primitive.str#method.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13cfe6c801715fff699dce762afc98ca7e8ff1fa" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;primitive.u8#method.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a0549668b9dec3f8fe6cc76087d773d360d9c8f" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;struct.osstr#method.make_ascii_lowercase&quot;&gt;&lt;code&gt;OsStr::make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd861f60ceee6cd011393e0efbd8975fcac733a1" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;trait.asciiext#tymethod.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21e4a3f169edf0cfb32c3841ee2bea7479d1a5e1" translate="yes" xml:space="preserve">
          <source>To make a struct that holds a closure, we need to specify the type of the closure, because a struct definition needs to know the types of each of its fields. Each closure instance has its own unique anonymous type: that is, even if two closures have the same signature, their types are still considered different. To define structs, enums, or function parameters that use closures, we use generics and trait bounds, as we discussed in Chapter 10.</source>
          <target state="translated">Para hacer una estructura que contenga un cierre,necesitamos especificar el tipo de cierre,porque una definición de estructura necesita saber los tipos de cada uno de sus campos.Cada instancia de cierre tiene su propio tipo anónimo único:es decir,aunque dos cierres tengan la misma firma,sus tipos siguen siendo considerados diferentes.Para definir las estructuras,enums o parámetros de funciones que utilizan cierres,utilizamos los genéricos y los límites de los rasgos,tal como se discutió en el capítulo 10.</target>
        </trans-unit>
        <trans-unit id="f551bbd5751f05a17c69a727dd31a7a20561b4f8" translate="yes" xml:space="preserve">
          <source>To make it valid, write the following:</source>
          <target state="translated">Para que sea válido,escriba lo siguiente:</target>
        </trans-unit>
        <trans-unit id="11b284dcb2ba4ceac9f02b253f7b17b9698ddf3b" translate="yes" xml:space="preserve">
          <source>To make struct &lt;code&gt;Bar&lt;/code&gt; only visible in module &lt;code&gt;foo&lt;/code&gt; the &lt;code&gt;in&lt;/code&gt; keyword should be used:</source>
          <target state="translated">Para hacer struct &lt;code&gt;Bar&lt;/code&gt; ser vistos en el m&amp;oacute;dulo &lt;code&gt;foo&lt;/code&gt; el &lt;code&gt;in&lt;/code&gt; palabra clave se debe utilizar:</target>
        </trans-unit>
        <trans-unit id="fc2021393a94974377e271f291f7d97ada3aa985" translate="yes" xml:space="preserve">
          <source>To make the child node aware of its parent, we need to add a &lt;code&gt;parent&lt;/code&gt; field to our &lt;code&gt;Node&lt;/code&gt; struct definition. The trouble is in deciding what the type of &lt;code&gt;parent&lt;/code&gt; should be. We know it can&amp;rsquo;t contain an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;, because that would create a reference cycle with &lt;code&gt;leaf.parent&lt;/code&gt; pointing to &lt;code&gt;branch&lt;/code&gt; and &lt;code&gt;branch.children&lt;/code&gt; pointing to &lt;code&gt;leaf&lt;/code&gt;, which would cause their &lt;code&gt;strong_count&lt;/code&gt; values to never be 0.</source>
          <target state="translated">Para que el nodo hijo conozca a su padre, necesitamos agregar un campo &lt;code&gt;parent&lt;/code&gt; a nuestra definici&amp;oacute;n de estructura de &lt;code&gt;Node&lt;/code&gt; . El problema est&amp;aacute; en decidir cu&amp;aacute;l debe ser el tipo de &lt;code&gt;parent&lt;/code&gt; . Sabemos que no puede contener un &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; , porque eso crear&amp;iacute;a un ciclo de referencia con &lt;code&gt;leaf.parent&lt;/code&gt; apuntando a &lt;code&gt;branch&lt;/code&gt; y &lt;code&gt;branch.children&lt;/code&gt; apuntando a &lt;code&gt;leaf&lt;/code&gt; , lo que har&amp;iacute;a que sus valores de &lt;code&gt;strong_count&lt;/code&gt; nunca fueran 0.</target>
        </trans-unit>
        <trans-unit id="d22320c45b662fb11c8113dfcbe82f4c5091e1e8" translate="yes" xml:space="preserve">
          <source>To make this work, every element has pointers to its predecessor and successor in the list. Elements can only be added when they are pinned, because moving the elements around would invalidate the pointers. Moreover, the &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; implementation of a linked list element will patch the pointers of its predecessor and successor to remove itself from the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7b483d37995579653b3a66a999867efa81ab8f9" translate="yes" xml:space="preserve">
          <source>To make this work, every element has pointers to its predecessor and successor in the list. Elements can only be added when they are pinned, because moving the elements around would invalidate the pointers. Moreover, the &lt;code&gt;Drop&lt;/code&gt; implementation of a linked list element will patch the pointers of its predecessor and successor to remove itself from the list.</source>
          <target state="translated">Para que esto funcione, cada elemento tiene punteros a su predecesor y sucesor en la lista. Los elementos solo se pueden agregar cuando est&amp;aacute;n anclados, porque mover los elementos invalidar&amp;iacute;a los punteros. Adem&amp;aacute;s, la implementaci&amp;oacute;n &lt;code&gt;Drop&lt;/code&gt; de un elemento de lista enlazada parchear&amp;aacute; los punteros de su predecesor y sucesor para eliminarse de la lista.</target>
        </trans-unit>
        <trans-unit id="addd7b5a3eab2bcc498269d4b5030ddd2652429e" translate="yes" xml:space="preserve">
          <source>To many people, polymorphism is synonymous with inheritance. But it&amp;rsquo;s actually a more general concept that refers to code that can work with data of multiple types. For inheritance, those types are generally subclasses.</source>
          <target state="translated">Para muchas personas, polimorfismo es sin&amp;oacute;nimo de herencia. Pero en realidad es un concepto m&amp;aacute;s general que se refiere al c&amp;oacute;digo que puede funcionar con datos de varios tipos. Para la herencia, esos tipos son generalmente subclases.</target>
        </trans-unit>
        <trans-unit id="e542c92de7f2ff8b0e65e4059a685882563b6c24" translate="yes" xml:space="preserve">
          <source>To measure elapsed time reliably, use &lt;a href=&quot;struct.instant&quot;&gt;&lt;code&gt;Instant&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1808ba5fbc9308fb8282df842ce731348ff5abf" translate="yes" xml:space="preserve">
          <source>To model pointers to opaque types in FFI, until &lt;code&gt;extern type&lt;/code&gt; is stabilized, it is recommended to use a newtype wrapper around an empty byte array. See the &lt;a href=&quot;https://doc.rust-lang.org/nomicon/ffi.html#representing-opaque-structs&quot;&gt;Nomicon&lt;/a&gt; for details.</source>
          <target state="translated">Para modelar punteros a tipos opacos en FFI, hasta que el &lt;code&gt;extern type&lt;/code&gt; se estabilice, se recomienda utilizar un contenedor newtype alrededor de una matriz de bytes vac&amp;iacute;a. Consulte &lt;a href=&quot;https://doc.rust-lang.org/nomicon/ffi.html#representing-opaque-structs&quot;&gt;Nomicon&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="92f1c0826630a6e44e7c7249d92c4a26d91785e3" translate="yes" xml:space="preserve">
          <source>To obtain error description as a string, use &lt;code&gt;to_string()&lt;/code&gt;.</source>
          <target state="translated">Para obtener la descripci&amp;oacute;n del error como una cadena, use &lt;code&gt;to_string()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0354419a51c55b7a4f425ab3291d7b635b1d30c9" translate="yes" xml:space="preserve">
          <source>To parameterize the types in the new function we&amp;rsquo;ll define, we need to name the type parameter, just as we do for the value parameters to a function. You can use any identifier as a type parameter name. But we&amp;rsquo;ll use &lt;code&gt;T&lt;/code&gt; because, by convention, parameter names in Rust are short, often just a letter, and Rust&amp;rsquo;s type-naming convention is CamelCase. Short for &amp;ldquo;type,&amp;rdquo; &lt;code&gt;T&lt;/code&gt; is the default choice of most Rust programmers.</source>
          <target state="translated">Para parametrizar los tipos en la nueva funci&amp;oacute;n que definiremos, necesitamos nombrar el par&amp;aacute;metro de tipo, tal como lo hacemos para los par&amp;aacute;metros de valor de una funci&amp;oacute;n. Puede utilizar cualquier identificador como nombre de par&amp;aacute;metro de tipo. Pero usaremos &lt;code&gt;T&lt;/code&gt; porque, por convenci&amp;oacute;n, los nombres de los par&amp;aacute;metros en Rust son cortos, a menudo solo una letra, y la convenci&amp;oacute;n de nomenclatura de tipos de Rust es CamelCase. Abreviatura de &quot;tipo&quot;, &lt;code&gt;T&lt;/code&gt; es la opci&amp;oacute;n predeterminada de la mayor&amp;iacute;a de los programadores de Rust.</target>
        </trans-unit>
        <trans-unit id="075fa626d389c13dd84df398e2b600267ba414fd" translate="yes" xml:space="preserve">
          <source>To parse a path, you can create a &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; slice from a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; slice and start asking questions:</source>
          <target state="translated">Para analizar una ruta, puede crear un segmento de &lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; partir de un segmento &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; y comenzar a hacer preguntas:</target>
        </trans-unit>
        <trans-unit id="a91f9eb8a09ec43223d4a3a69ca02691cc9a5535" translate="yes" xml:space="preserve">
          <source>To parse a path, you can create a &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; slice from a &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; slice and start asking questions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7f45d830d337ce8a4f493ea8b6014f97c0fb6eb" translate="yes" xml:space="preserve">
          <source>To pass a single argument see &lt;a href=&quot;#method.arg&quot;&gt;&lt;code&gt;arg&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para pasar un solo argumento, vea &lt;a href=&quot;#method.arg&quot;&gt; &lt;code&gt;arg&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="30a7bace681f793e8820181cf7574f94401b280d" translate="yes" xml:space="preserve">
          <source>To pass a single argument see &lt;a href=&quot;struct.command#method.arg&quot;&gt;&lt;code&gt;arg&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f3d970a69fb7cac0396fffe3d7483eb856d59e9" translate="yes" xml:space="preserve">
          <source>To pass multiple arguments see &lt;a href=&quot;#method.args&quot;&gt;&lt;code&gt;args&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para pasar varios argumentos, consulte &lt;a href=&quot;#method.args&quot;&gt; &lt;code&gt;args&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f24e6cb8e923f8cee5441a6183ab318931f04cf1" translate="yes" xml:space="preserve">
          <source>To pass multiple arguments see &lt;a href=&quot;struct.command#method.args&quot;&gt;&lt;code&gt;args&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdc2c49e6f2624612dfa9af5bb72c9d5988a62aa" translate="yes" xml:space="preserve">
          <source>To perform async recursion, the &lt;code&gt;async fn&lt;/code&gt; needs to be desugared such that the &lt;code&gt;Future&lt;/code&gt; is explicit in the return type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af6d76d570505ba666bcda7baecd5871dcf2d3a2" translate="yes" xml:space="preserve">
          <source>To prevent this scenario, we first put all of our &lt;code&gt;Terminate&lt;/code&gt; messages on the channel in one loop; then we join on all the threads in another loop. Each worker will stop receiving requests on the channel once it gets a terminate message. So, we can be sure that if we send the same number of terminate messages as there are workers, each worker will receive a terminate message before &lt;code&gt;join&lt;/code&gt; is called on its thread.</source>
          <target state="translated">Para evitar este escenario, primero colocamos todos nuestros mensajes &lt;code&gt;Terminate&lt;/code&gt; en el canal en un bucle; luego unimos todos los hilos en otro bucle. Cada trabajador dejar&amp;aacute; de recibir solicitudes en el canal una vez que reciba un mensaje de terminaci&amp;oacute;n. Por lo tanto, podemos estar seguros de que si enviamos la misma cantidad de mensajes de terminaci&amp;oacute;n que trabajadores, cada trabajador recibir&amp;aacute; un mensaje de terminaci&amp;oacute;n antes de que se llame a &lt;code&gt;join&lt;/code&gt; en su hilo.</target>
        </trans-unit>
        <trans-unit id="add5b6cf5a307a5e6af227f8cc2b7b101db763e7" translate="yes" xml:space="preserve">
          <source>To protect your program from this sort of vulnerability, if you try to read an element at an index that doesn&amp;rsquo;t exist, Rust will stop execution and refuse to continue. Let&amp;rsquo;s try it and see:</source>
          <target state="translated">Para proteger su programa de este tipo de vulnerabilidad, si intenta leer un elemento en un &amp;iacute;ndice que no existe, Rust detendr&amp;aacute; la ejecuci&amp;oacute;n y se negar&amp;aacute; a continuar. Prob&amp;eacute;moslo y veamos:</target>
        </trans-unit>
        <trans-unit id="fb3ab9d085bae205d404a7ba202d1b27f55784c2" translate="yes" xml:space="preserve">
          <source>To recover from a poisoned mutex:</source>
          <target state="translated">Para recuperarse de un mudo envenenado:</target>
        </trans-unit>
        <trans-unit id="e0f842e4093b64f03623cd49c1c17718cfbe95dc" translate="yes" xml:space="preserve">
          <source>To remove the internal organization from the public API, we can modify the &lt;code&gt;art&lt;/code&gt; crate code in Listing 14-3 to add &lt;code&gt;pub use&lt;/code&gt; statements to re-export the items at the top level, as shown in Listing 14-5:</source>
          <target state="translated">Para eliminar la organizaci&amp;oacute;n interna de la API p&amp;uacute;blica, podemos modificar el c&amp;oacute;digo de la caja de &lt;code&gt;art&lt;/code&gt; e en el Listado 14-3 para agregar declaraciones de &lt;code&gt;pub use&lt;/code&gt; para reexportar los elementos en el nivel superior, como se muestra en el Listado 14-5:</target>
        </trans-unit>
        <trans-unit id="5b0280b8819ec3479f9646e558c6310c8632f058" translate="yes" xml:space="preserve">
          <source>To resolve the ambiguity, the programmer may refer to their desired method or function using more specific paths, types, or traits.</source>
          <target state="translated">Para resolver la ambigüedad,el programador puede referirse al método o función que desee utilizando rutas,tipos o rasgos más específicos.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
