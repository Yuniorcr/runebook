<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="2ec6cd19695748bdc3218a5649d6ac291b66845a" translate="yes" xml:space="preserve">
          <source>BTreeSet::intersection</source>
          <target state="translated">BTreeSet::intersection</target>
        </trans-unit>
        <trans-unit id="d885d81e267a989f9b6f96d27d81a920eec34664" translate="yes" xml:space="preserve">
          <source>BTreeSet::into</source>
          <target state="translated">BTreeSet::into</target>
        </trans-unit>
        <trans-unit id="f09a0e4a6b10a390e2f04fd66332a740593fc953" translate="yes" xml:space="preserve">
          <source>BTreeSet::into_iter</source>
          <target state="translated">BTreeSet::into_iter</target>
        </trans-unit>
        <trans-unit id="a2120b284c22116b26329e55b63c0619a0f8641f" translate="yes" xml:space="preserve">
          <source>BTreeSet::is_disjoint</source>
          <target state="translated">BTreeSet::is_disjoint</target>
        </trans-unit>
        <trans-unit id="fa3982b7c70f77cdc4a183838b7ec4738fe0c535" translate="yes" xml:space="preserve">
          <source>BTreeSet::is_empty</source>
          <target state="translated">BTreeSet::is_empty</target>
        </trans-unit>
        <trans-unit id="f1e3ee85ccb9602474d41d5d154e3e8901defc32" translate="yes" xml:space="preserve">
          <source>BTreeSet::is_subset</source>
          <target state="translated">BTreeSet::is_subset</target>
        </trans-unit>
        <trans-unit id="56a933bbd8f86feb814db247df53b23e17a9695d" translate="yes" xml:space="preserve">
          <source>BTreeSet::is_superset</source>
          <target state="translated">BTreeSet::is_superset</target>
        </trans-unit>
        <trans-unit id="b5818b3b23dd28b80dc81cc819a86f1ec187aacf" translate="yes" xml:space="preserve">
          <source>BTreeSet::iter</source>
          <target state="translated">BTreeSet::iter</target>
        </trans-unit>
        <trans-unit id="de70e88d73a501b174fd29598eceebcee11a3887" translate="yes" xml:space="preserve">
          <source>BTreeSet::le</source>
          <target state="translated">BTreeSet::le</target>
        </trans-unit>
        <trans-unit id="d6f9cf6208fd574420dfb2b2c0da01ae4ce09d55" translate="yes" xml:space="preserve">
          <source>BTreeSet::len</source>
          <target state="translated">BTreeSet::len</target>
        </trans-unit>
        <trans-unit id="b1797fe67e7fb20ec6e3d268d0239e6f0a7e8a35" translate="yes" xml:space="preserve">
          <source>BTreeSet::lt</source>
          <target state="translated">BTreeSet::lt</target>
        </trans-unit>
        <trans-unit id="a9e0d4eb0cfb5c71cb33c6469839efbbe2cc32b4" translate="yes" xml:space="preserve">
          <source>BTreeSet::max</source>
          <target state="translated">BTreeSet::max</target>
        </trans-unit>
        <trans-unit id="05e2ada4eca69c113c843b5a4bf4e82b6cbab803" translate="yes" xml:space="preserve">
          <source>BTreeSet::min</source>
          <target state="translated">BTreeSet::min</target>
        </trans-unit>
        <trans-unit id="1bf7816f409ee91ea7b933df2aa5aafb248eb221" translate="yes" xml:space="preserve">
          <source>BTreeSet::ne</source>
          <target state="translated">BTreeSet::ne</target>
        </trans-unit>
        <trans-unit id="eaf3ecdf9b29068bb6526653c7887b6ce53f95db" translate="yes" xml:space="preserve">
          <source>BTreeSet::new</source>
          <target state="translated">BTreeSet::new</target>
        </trans-unit>
        <trans-unit id="df8c5a54c5b8f9c4c785c5ef82c145a8f51964cb" translate="yes" xml:space="preserve">
          <source>BTreeSet::partial_cmp</source>
          <target state="translated">BTreeSet::partial_cmp</target>
        </trans-unit>
        <trans-unit id="d87bbd755881f1e9919b94d6de0e6bf8ffad49ba" translate="yes" xml:space="preserve">
          <source>BTreeSet::range</source>
          <target state="translated">BTreeSet::range</target>
        </trans-unit>
        <trans-unit id="ef12ebd2434d1cb833ec3822d788df805d7d9bd6" translate="yes" xml:space="preserve">
          <source>BTreeSet::remove</source>
          <target state="translated">BTreeSet::remove</target>
        </trans-unit>
        <trans-unit id="9478913c250333ed4078096ba5b68c78bc2a2420" translate="yes" xml:space="preserve">
          <source>BTreeSet::replace</source>
          <target state="translated">BTreeSet::replace</target>
        </trans-unit>
        <trans-unit id="3c5930911fa948ea3f0f63bb1262c5e03b59d4c8" translate="yes" xml:space="preserve">
          <source>BTreeSet::split_off</source>
          <target state="translated">BTreeSet::split_off</target>
        </trans-unit>
        <trans-unit id="c4362726060659abf8310f7f4e795bc37b50e1bc" translate="yes" xml:space="preserve">
          <source>BTreeSet::sub</source>
          <target state="translated">BTreeSet::sub</target>
        </trans-unit>
        <trans-unit id="1dc28627821fcb677e88cc0779199b1f7545d0d5" translate="yes" xml:space="preserve">
          <source>BTreeSet::symmetric_difference</source>
          <target state="translated">BTreeSet::symmetric_difference</target>
        </trans-unit>
        <trans-unit id="2164e4022af6db54cb98c455e4d65521424dc945" translate="yes" xml:space="preserve">
          <source>BTreeSet::take</source>
          <target state="translated">BTreeSet::take</target>
        </trans-unit>
        <trans-unit id="976d0d251360ff452f9cb215b1b7bd9b85411230" translate="yes" xml:space="preserve">
          <source>BTreeSet::to_owned</source>
          <target state="translated">BTreeSet::to_owned</target>
        </trans-unit>
        <trans-unit id="0992e1b4495c890673b5468165634f32bea3f77d" translate="yes" xml:space="preserve">
          <source>BTreeSet::try_from</source>
          <target state="translated">BTreeSet::try_from</target>
        </trans-unit>
        <trans-unit id="00828429015178852a18ee4ff94e0453f5ca2ad3" translate="yes" xml:space="preserve">
          <source>BTreeSet::try_into</source>
          <target state="translated">BTreeSet::try_into</target>
        </trans-unit>
        <trans-unit id="6292b066b8d0a77ef6636bc177c940749dde0313" translate="yes" xml:space="preserve">
          <source>BTreeSet::type_id</source>
          <target state="translated">BTreeSet::type_id</target>
        </trans-unit>
        <trans-unit id="a20d276d5c8ff0b1126047f789b8548caf5f132d" translate="yes" xml:space="preserve">
          <source>BTreeSet::union</source>
          <target state="translated">BTreeSet::union</target>
        </trans-unit>
        <trans-unit id="a211a3e292d0c406efdf997cbec3abf1f2bc9197" translate="yes" xml:space="preserve">
          <source>BYTE_ESCAPE :</source>
          <target state="translated">BYTE_ESCAPE :</target>
        </trans-unit>
        <trans-unit id="e985813955ef288c8ead5994a2092542fb8c5bfb" translate="yes" xml:space="preserve">
          <source>BYTE_LITERAL :</source>
          <target state="translated">BYTE_LITERAL :</target>
        </trans-unit>
        <trans-unit id="e07c048067fa9215a18b4b2891f03e3f5148f8fe" translate="yes" xml:space="preserve">
          <source>BYTE_STRING_LITERAL :</source>
          <target state="translated">BYTE_STRING_LITERAL :</target>
        </trans-unit>
        <trans-unit id="64dd60fe1a049fe6db3eb1369dec2e42bf428e21" translate="yes" xml:space="preserve">
          <source>Background</source>
          <target state="translated">Background</target>
        </trans-unit>
        <trans-unit id="0ad42765ddcf1bcbae887f2d660cffdf1e817617" translate="yes" xml:space="preserve">
          <source>Background:</source>
          <target state="translated">Background:</target>
        </trans-unit>
        <trans-unit id="a826c283ce6a52f2d32eb19de6510cb9098ad99b" translate="yes" xml:space="preserve">
          <source>Backslash</source>
          <target state="translated">Backslash</target>
        </trans-unit>
        <trans-unit id="2df2f36ad1b16c1667285665d27221aa512fe540" translate="yes" xml:space="preserve">
          <source>Backslash is escaped as &lt;code&gt;\&lt;/code&gt;.</source>
          <target state="translated">La barra invertida se escapa como &lt;code&gt;\&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a92ed9890561e42d2d0eb715d201f51180f68785" translate="yes" xml:space="preserve">
          <source>Backslash is escaped as &lt;code&gt;\\&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb6f955aacbe511f0166d8a199d4db6ed90499a5" translate="yes" xml:space="preserve">
          <source>Backtrace</source>
          <target state="translated">Backtrace</target>
        </trans-unit>
        <trans-unit id="b85c431b74d8d9af7df1e8cd976473ac0177f68e" translate="yes" xml:space="preserve">
          <source>BacktraceStatus</source>
          <target state="translated">BacktraceStatus</target>
        </trans-unit>
        <trans-unit id="6eb0761000f5c4f5765ae1bd324bf97fbcf48d1d" translate="yes" xml:space="preserve">
          <source>Backtraces are attempted to be as accurate as possible, but no guarantees are provided about the exact accuracy of a backtrace. Instruction pointers, symbol names, filenames, line numbers, etc, may all be incorrect when reported. Accuracy is attempted on a best-effort basis, however, and bugs are always welcome to indicate areas of improvement!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10c02649e226d430bd75a5b6315a41c0db9992a2" translate="yes" xml:space="preserve">
          <source>Barrier</source>
          <target state="translated">Barrier</target>
        </trans-unit>
        <trans-unit id="05bc93718262068d5416ebba28511ebef76c4e14" translate="yes" xml:space="preserve">
          <source>Barrier::borrow</source>
          <target state="translated">Barrier::borrow</target>
        </trans-unit>
        <trans-unit id="48d8a6ca5d7ebcc052fa58321357d3bc36aa03a7" translate="yes" xml:space="preserve">
          <source>Barrier::borrow_mut</source>
          <target state="translated">Barrier::borrow_mut</target>
        </trans-unit>
        <trans-unit id="248c7b32ba40054cd50084ccaaff12b9c63d122a" translate="yes" xml:space="preserve">
          <source>Barrier::fmt</source>
          <target state="translated">Barrier::fmt</target>
        </trans-unit>
        <trans-unit id="d7dd85fbb601276305eb0ee52f6cb5d377f1fcc6" translate="yes" xml:space="preserve">
          <source>Barrier::from</source>
          <target state="translated">Barrier::from</target>
        </trans-unit>
        <trans-unit id="b342290a92d4444218a0ad57c6d277b796cd87a3" translate="yes" xml:space="preserve">
          <source>Barrier::into</source>
          <target state="translated">Barrier::into</target>
        </trans-unit>
        <trans-unit id="7468c224f8c905662e2e9c948739eef5bda7db0f" translate="yes" xml:space="preserve">
          <source>Barrier::new</source>
          <target state="translated">Barrier::new</target>
        </trans-unit>
        <trans-unit id="e30be523849f626aaa57ff5ee4069d25af8b70d1" translate="yes" xml:space="preserve">
          <source>Barrier::try_from</source>
          <target state="translated">Barrier::try_from</target>
        </trans-unit>
        <trans-unit id="e446147c6eb4453799cb6b4e470660354d138fed" translate="yes" xml:space="preserve">
          <source>Barrier::try_into</source>
          <target state="translated">Barrier::try_into</target>
        </trans-unit>
        <trans-unit id="97c7cb229080f5ec6d48954bf4e25fbf0b1b07ce" translate="yes" xml:space="preserve">
          <source>Barrier::type_id</source>
          <target state="translated">Barrier::type_id</target>
        </trans-unit>
        <trans-unit id="89f8492b0a8df428938e6f6ec1470925533e2645" translate="yes" xml:space="preserve">
          <source>Barrier::wait</source>
          <target state="translated">Barrier::wait</target>
        </trans-unit>
        <trans-unit id="1fdffd384d740408663001485f7d1d001cd2a0cd" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult</source>
          <target state="translated">BarrierWaitResult</target>
        </trans-unit>
        <trans-unit id="e4a4959fb6b835a4c39d1adf5dc13e01c6574236" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::borrow</source>
          <target state="translated">BarrierWaitResult::borrow</target>
        </trans-unit>
        <trans-unit id="df6d4d2a45b72573796ce25c163ceca562fea277" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::borrow_mut</source>
          <target state="translated">BarrierWaitResult::borrow_mut</target>
        </trans-unit>
        <trans-unit id="ab607187cf3b656038040cc905673df49597a85b" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::fmt</source>
          <target state="translated">BarrierWaitResult::fmt</target>
        </trans-unit>
        <trans-unit id="40c08de59f1f4830ac002ad44e2d3553862e48a4" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::from</source>
          <target state="translated">BarrierWaitResult::from</target>
        </trans-unit>
        <trans-unit id="0ad014a8be36da91076930d7e3b4ff7218ef30aa" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::into</source>
          <target state="translated">BarrierWaitResult::into</target>
        </trans-unit>
        <trans-unit id="24471f5273b1cd68c1f7b8b58afe489ead7b1e9c" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::is_leader</source>
          <target state="translated">BarrierWaitResult::is_leader</target>
        </trans-unit>
        <trans-unit id="30b419cdf31db8213f868433400e90eb5bd6bd09" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::try_from</source>
          <target state="translated">BarrierWaitResult::try_from</target>
        </trans-unit>
        <trans-unit id="917cd48270dee8a42dabe702984f20fa69cc47a8" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::try_into</source>
          <target state="translated">BarrierWaitResult::try_into</target>
        </trans-unit>
        <trans-unit id="29252f73362aacd393a5eec57cfc8edfc91915f8" translate="yes" xml:space="preserve">
          <source>BarrierWaitResult::type_id</source>
          <target state="translated">BarrierWaitResult::type_id</target>
        </trans-unit>
        <trans-unit id="0798504393a70fe84f8d6d8445159e80798bd3ac" translate="yes" xml:space="preserve">
          <source>Barriers are re-usable after all threads have rendezvoused once, and can be used continuously.</source>
          <target state="translated">Las barreras son reutilizables después de que todos los hilos se hayan reunido una vez,y pueden ser usadas continuamente.</target>
        </trans-unit>
        <trans-unit id="b20cbc384159fd820ed034fd3615298ec09f5902" translate="yes" xml:space="preserve">
          <source>Basic Usage</source>
          <target state="translated">Uso básico</target>
        </trans-unit>
        <trans-unit id="e688514e6e0a6b01ae26314b3eb88e5e53881bcb" translate="yes" xml:space="preserve">
          <source>Basic behavior:</source>
          <target state="translated">Comportamiento básico:</target>
        </trans-unit>
        <trans-unit id="11bf4d2856fba52165f40435250d1ec2e6c3316a" translate="yes" xml:space="preserve">
          <source>Basic functions for dealing with memory.</source>
          <target state="translated">Funciones básicas para tratar con la memoria.</target>
        </trans-unit>
        <trans-unit id="ec83756dfd527ebf8f2a042db474987a95d353c4" translate="yes" xml:space="preserve">
          <source>Basic implementation of &lt;code&gt;FromStr&lt;/code&gt; on an example &lt;code&gt;Point&lt;/code&gt; type:</source>
          <target state="translated">Implementaci&amp;oacute;n b&amp;aacute;sica de &lt;code&gt;FromStr&lt;/code&gt; en un tipo de &lt;code&gt;Point&lt;/code&gt; ejemplo :</target>
        </trans-unit>
        <trans-unit id="c3d9f55cf67e9ea4d900c6c2497ec5a08343c0a5" translate="yes" xml:space="preserve">
          <source>Basic mathematical constants.</source>
          <target state="translated">Constantes matemáticas básicas.</target>
        </trans-unit>
        <trans-unit id="03619f20093f70d07eb4c7482bb00f0ec8e3c3fc" translate="yes" xml:space="preserve">
          <source>Basic pattern matching on &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Coincidencia de patrones b&amp;aacute;sicos en la &lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="cb3a8802da5b3164771a468d78ff7995a249f08a" translate="yes" xml:space="preserve">
          <source>Basic usage</source>
          <target state="translated">Uso básico</target>
        </trans-unit>
        <trans-unit id="30a9f8a0441549550539e36ec0f9f9002255cfd0" translate="yes" xml:space="preserve">
          <source>Basic usage example:</source>
          <target state="translated">Ejemplo de uso básico:</target>
        </trans-unit>
        <trans-unit id="4ba20db65bc2f86fd8313d56d1906d6e40c680fc" translate="yes" xml:space="preserve">
          <source>Basic usage with &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt;, a type that implements &lt;code&gt;FromStr&lt;/code&gt;:</source>
          <target state="translated">Uso b&amp;aacute;sico con &lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; , un tipo que implementa &lt;code&gt;FromStr&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e86fea8c030e7f6d48033a20b07738fb6cc7d1e1" translate="yes" xml:space="preserve">
          <source>Basic usage with &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Uso b&amp;aacute;sico con &lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="a8f910f3980e5f4caf7f91e6c92b1c5ff7ef8744" translate="yes" xml:space="preserve">
          <source>Basic usage with &lt;code&gt;&amp;amp;i32&lt;/code&gt;:</source>
          <target state="translated">Uso b&amp;aacute;sico con &lt;code&gt;&amp;amp;i32&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4b7db61f0810a48b5403cec32d70374937db6803" translate="yes" xml:space="preserve">
          <source>Basic usage with &lt;code&gt;f64&lt;/code&gt;:</source>
          <target state="translated">Uso b&amp;aacute;sico con &lt;code&gt;f64&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="473dba01450bbaa0ba0aec1bf0715ab6ef2ccb9f" translate="yes" xml:space="preserve">
          <source>Basic usage with &lt;code&gt;i32&lt;/code&gt;:</source>
          <target state="translated">Uso b&amp;aacute;sico con &lt;code&gt;i32&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="65f639d2a40570f68ed54fc56bf243ceac2035a0" translate="yes" xml:space="preserve">
          <source>Basic usage:</source>
          <target state="translated">Uso básico:</target>
        </trans-unit>
        <trans-unit id="ae854127dfb82027c5681daec7e882045161fa8e" translate="yes" xml:space="preserve">
          <source>Be a &lt;a href=&quot;associated-items#methods&quot;&gt;method&lt;/a&gt; that does not use &lt;code&gt;Self&lt;/code&gt; except in the type of the receiver.</source>
          <target state="translated">Ser un &lt;a href=&quot;associated-items#methods&quot;&gt;m&amp;eacute;todo&lt;/a&gt; que no utilice &lt;code&gt;Self&lt;/code&gt; excepto en el tipo de receptor.</target>
        </trans-unit>
        <trans-unit id="a9609503521663742afb4db6d34fce975c5ef790" translate="yes" xml:space="preserve">
          <source>Be aware that operations on seemingly non-ASCII characters can sometimes have unexpected results. Consider this example:</source>
          <target state="translated">Tengan en cuenta que las operaciones en personajes aparentemente no ASCII pueden tener a veces resultados inesperados.Considere este ejemplo:</target>
        </trans-unit>
        <trans-unit id="f7eed2246078297c7f3c1974fe5ece00f24fc71c" translate="yes" xml:space="preserve">
          <source>Be careful when publishing a crate because a publish is &lt;em&gt;permanent&lt;/em&gt;. The version can never be overwritten, and the code cannot be deleted. One major goal of &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; is to act as a permanent archive of code so that builds of all projects that depend on crates from &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; will continue to work. Allowing version deletions would make fulfilling that goal impossible. However, there is no limit to the number of crate versions you can publish.</source>
          <target state="translated">Tenga cuidado al publicar una caja porque una publicaci&amp;oacute;n es &lt;em&gt;permanente&lt;/em&gt; . La versi&amp;oacute;n nunca se puede sobrescribir y el c&amp;oacute;digo no se puede eliminar. Uno de los objetivos principales de &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; es actuar como un archivo permanente de c&amp;oacute;digo para que se &lt;a href=&quot;https://crates.io/&quot;&gt;compilen&lt;/a&gt; todos los proyectos que dependen de crates de crates.io sigan funcionando. Permitir la eliminaci&amp;oacute;n de versiones har&amp;iacute;a imposible cumplir ese objetivo. Sin embargo, no hay l&amp;iacute;mite para la cantidad de versiones de cajas que puede publicar.</target>
        </trans-unit>
        <trans-unit id="dca86f7e9af3880530e74de899f022486c60c4c6" translate="yes" xml:space="preserve">
          <source>Be representable in the return type &lt;code&gt;Int&lt;/code&gt;, after truncating off its fractional part</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="944c776ebe8836f4d5f40423d2d077f777d1f2db" translate="yes" xml:space="preserve">
          <source>Be sure to copy over any bounds as well:</source>
          <target state="translated">Asegúrate de copiar sobre cualquier límite también:</target>
        </trans-unit>
        <trans-unit id="b7d22470344866c1dcd5a2efc22d2e6cb51a1ab2" translate="yes" xml:space="preserve">
          <source>Bear in mind that methods on infinite iterators, even those for which a result can be determined mathematically in finite time, may not terminate. Specifically, methods such as &lt;a href=&quot;trait.iterator#method.min&quot;&gt;&lt;code&gt;min&lt;/code&gt;&lt;/a&gt;, which in the general case require traversing every element in the iterator, are likely not to return successfully for any infinite iterators.</source>
          <target state="translated">Tenga en cuenta que los m&amp;eacute;todos en iteradores infinitos, incluso aquellos para los que un resultado se puede determinar matem&amp;aacute;ticamente en un tiempo finito, pueden no terminar. Espec&amp;iacute;ficamente, m&amp;eacute;todos como &lt;a href=&quot;trait.iterator#method.min&quot;&gt; &lt;code&gt;min&lt;/code&gt; &lt;/a&gt; , que en el caso general requieren atravesar todos los elementos del iterador, es probable que no regresen con &amp;eacute;xito para ning&amp;uacute;n iterador infinito.</target>
        </trans-unit>
        <trans-unit id="3d00abb1d72a8bac8ecec238c14739dba53b4125" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;Animal::baby_name&lt;/code&gt; is an associated function rather than a method, and thus doesn&amp;rsquo;t have a &lt;code&gt;self&lt;/code&gt; parameter, Rust can&amp;rsquo;t figure out which implementation of &lt;code&gt;Animal::baby_name&lt;/code&gt; we want. We&amp;rsquo;ll get this compiler error:</source>
          <target state="translated">Debido a que &lt;code&gt;Animal::baby_name&lt;/code&gt; es una funci&amp;oacute;n asociada en lugar de un m&amp;eacute;todo, y por lo tanto no tiene un par&amp;aacute;metro &lt;code&gt;self&lt;/code&gt; , Rust no puede averiguar qu&amp;eacute; implementaci&amp;oacute;n de &lt;code&gt;Animal::baby_name&lt;/code&gt; queremos. Obtendremos este error del compilador:</target>
        </trans-unit>
        <trans-unit id="e982f4d1ceaa6ebce2e39ce35fa3517925f4eb60" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;Drop::drop&lt;/code&gt; is used to clean up a value, it may be dangerous to use this value after the method has been called. As &lt;code&gt;Drop::drop&lt;/code&gt; does not take ownership of its input, Rust prevents misuse by not allowing you to call &lt;code&gt;Drop::drop&lt;/code&gt; directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c77d0afa61b96acdbbf5c9bd8c7ad5776b21e2a7" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;Kilometers&lt;/code&gt; and &lt;code&gt;i32&lt;/code&gt; are the same type, we can add values of both types and we can pass &lt;code&gt;Kilometers&lt;/code&gt; values to functions that take &lt;code&gt;i32&lt;/code&gt; parameters. However, using this method, we don&amp;rsquo;t get the type checking benefits that we get from the newtype pattern discussed earlier.</source>
          <target state="translated">Debido a que &lt;code&gt;Kilometers&lt;/code&gt; e &lt;code&gt;i32&lt;/code&gt; son del mismo tipo, podemos sumar valores de ambos tipos y podemos pasar los valores de &lt;code&gt;Kilometers&lt;/code&gt; a funciones que toman par&amp;aacute;metros &lt;code&gt;i32&lt;/code&gt; . Sin embargo, al usar este m&amp;eacute;todo, no obtenemos los beneficios de verificaci&amp;oacute;n de tipos que obtenemos del patr&amp;oacute;n newtype discutido anteriormente.</target>
        </trans-unit>
        <trans-unit id="6b9cbc9e966e04746993324da12bc0b094791922" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; allows mutable borrows checked at runtime, you can mutate the value inside the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; even when the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; is immutable.</source>
          <target state="translated">Debido a que &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; permite que los pr&amp;eacute;stamos mutables se comprueben en tiempo de ejecuci&amp;oacute;n, puede mutar el valor dentro de &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; incluso cuando &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; es inmutable.</target>
        </trans-unit>
        <trans-unit id="3648820fdd060b2ae98ec9efe9a7aa20de6bd4e7" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;_x&lt;/code&gt; is moved into the function, it is automatically dropped before the function returns.</source>
          <target state="translated">Debido a que &lt;code&gt;_x&lt;/code&gt; se mueve a la funci&amp;oacute;n, se elimina autom&amp;aacute;ticamente antes de que la funci&amp;oacute;n regrese.</target>
        </trans-unit>
        <trans-unit id="02501fd298567a0388a172b4febd506fefcf8337" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;collect()&lt;/code&gt; is so general, it can cause problems with type inference. As such, &lt;code&gt;collect()&lt;/code&gt; is one of the few times you'll see the syntax affectionately known as the 'turbofish': &lt;code&gt;::&amp;lt;&amp;gt;&lt;/code&gt;. This helps the inference algorithm understand specifically which collection you're trying to collect into.</source>
          <target state="translated">Debido a que &lt;code&gt;collect()&lt;/code&gt; es tan general, puede causar problemas con la inferencia de tipos. Como tal, &lt;code&gt;collect()&lt;/code&gt; es una de las pocas veces que ver&amp;aacute; la sintaxis cari&amp;ntilde;osamente conocida como 'turbofish': &lt;code&gt;::&amp;lt;&amp;gt;&lt;/code&gt; . Esto ayuda al algoritmo de inferencia a comprender espec&amp;iacute;ficamente en qu&amp;eacute; colecci&amp;oacute;n est&amp;aacute; tratando de recopilar.</target>
        </trans-unit>
        <trans-unit id="f792523afdd09554f3c4c09b932d34d5d3beab5f" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;collect()&lt;/code&gt; only cares about what you're collecting into, you can still use a partial type hint, &lt;code&gt;_&lt;/code&gt;, with the turbofish:</source>
          <target state="translated">Debido a que &lt;code&gt;collect()&lt;/code&gt; solo se preocupa por lo que est&amp;aacute; recolectando, a&amp;uacute;n puede usar una sugerencia de tipo parcial, &lt;code&gt;_&lt;/code&gt; , con el turbofish:</target>
        </trans-unit>
        <trans-unit id="b2e79e04cb1d4d369cbb0462d719cf25107b631b" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;fancy_ref&lt;/code&gt; still holds a reference to &lt;code&gt;fancy_num&lt;/code&gt;, &lt;code&gt;fancy_num&lt;/code&gt; can't be assigned to a new value as it would invalidate the reference.</source>
          <target state="translated">Debido a que &lt;code&gt;fancy_ref&lt;/code&gt; todav&amp;iacute;a contiene una referencia a &lt;code&gt;fancy_num&lt;/code&gt; , &lt;code&gt;fancy_num&lt;/code&gt; no se puede asignar a un nuevo valor ya que invalidar&amp;iacute;a la referencia.</target>
        </trans-unit>
        <trans-unit id="ad62e74aea9006b0878a087eb02874ec0ddf69c6" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;find()&lt;/code&gt; takes a reference, and many iterators iterate over references, this leads to a possibly confusing situation where the argument is a double reference. You can see this effect in the examples below, with &lt;code&gt;&amp;amp;&amp;amp;x&lt;/code&gt;.</source>
          <target state="translated">Debido a que &lt;code&gt;find()&lt;/code&gt; toma una referencia y muchos iteradores iteran sobre las referencias, esto conduce a una situaci&amp;oacute;n posiblemente confusa en la que el argumento es una referencia doble. Puede ver este efecto en los ejemplos siguientes, con &lt;code&gt;&amp;amp;&amp;amp;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8154baa71c56f29ade9fab7717781feba4bbd572" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;if&lt;/code&gt; is an expression, we can use it on the right side of a &lt;code&gt;let&lt;/code&gt; statement, as in Listing 3-2.</source>
          <target state="translated">Porque &lt;code&gt;if&lt;/code&gt; es una expresi&amp;oacute;n, podemos usarla en el lado derecho de una declaraci&amp;oacute;n &lt;code&gt;let&lt;/code&gt; , como en el Listado 3-2.</target>
        </trans-unit>
        <trans-unit id="9997aaaef6017b0cb2af61885b73aab100c2b5f6" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;map&lt;/code&gt; takes a closure, we can specify any operation we want to perform on each item. This is a great example of how closures let you customize some behavior while reusing the iteration behavior that the &lt;code&gt;Iterator&lt;/code&gt; trait provides.</source>
          <target state="translated">Debido a que el &lt;code&gt;map&lt;/code&gt; a tiene un cierre, podemos especificar cualquier operaci&amp;oacute;n que queramos realizar en cada elemento. Este es un gran ejemplo de c&amp;oacute;mo los cierres le permiten personalizar alg&amp;uacute;n comportamiento mientras se reutiliza el comportamiento de iteraci&amp;oacute;n que proporciona el rasgo &lt;code&gt;Iterator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6c4314864b0e06485267f3ca664e542a4a9d24f" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;map_while()&lt;/code&gt; needs to look at the value in order to see if it should be included or not, consuming iterators will see that it is removed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d80f24c4a2216ac3e891c23c7f333250fe61032" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;parse&lt;/code&gt; is so general, it can cause problems with type inference. As such, &lt;code&gt;parse&lt;/code&gt; is one of the few times you'll see the syntax affectionately known as the 'turbofish': &lt;code&gt;::&amp;lt;&amp;gt;&lt;/code&gt;. This helps the inference algorithm understand specifically which type you're trying to parse into.</source>
          <target state="translated">Debido a que el &lt;code&gt;parse&lt;/code&gt; es tan general, puede causar problemas con la inferencia de tipos. Como tal, &lt;code&gt;parse&lt;/code&gt; es una de las pocas veces que ver&amp;aacute; la sintaxis cari&amp;ntilde;osamente conocida como 'turbofish': &lt;code&gt;::&amp;lt;&amp;gt;&lt;/code&gt; . Esto ayuda al algoritmo de inferencia a comprender espec&amp;iacute;ficamente en qu&amp;eacute; tipo est&amp;aacute; tratando de analizar.</target>
        </trans-unit>
        <trans-unit id="f088d61355fe261cd42315fc674f33d7a3ce9310" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;peek()&lt;/code&gt; returns a reference, and many iterators iterate over references, there can be a possibly confusing situation where the return value is a double reference. You can see this effect in the examples below.</source>
          <target state="translated">Debido a que &lt;code&gt;peek()&lt;/code&gt; devuelve una referencia y muchos iteradores iteran sobre las referencias, puede haber una situaci&amp;oacute;n posiblemente confusa en la que el valor de retorno sea una referencia doble. Puede ver este efecto en los ejemplos siguientes.</target>
        </trans-unit>
        <trans-unit id="9a4418890cc2a26bb07a69375b759eb2f8d9d03d" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;peek_mut()&lt;/code&gt; returns a reference, and many iterators iterate over references, there can be a possibly confusing situation where the return value is a double reference. You can see this effect in the examples below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7eb647ad22291b28a51fd607cc84aff6f4abc83" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;rfind()&lt;/code&gt; takes a reference, and many iterators iterate over references, this leads to a possibly confusing situation where the argument is a double reference. You can see this effect in the examples below, with &lt;code&gt;&amp;amp;&amp;amp;x&lt;/code&gt;.</source>
          <target state="translated">Debido a que &lt;code&gt;rfind()&lt;/code&gt; toma una referencia y muchos iteradores iteran sobre las referencias, esto conduce a una situaci&amp;oacute;n posiblemente confusa en la que el argumento es una referencia doble. Puede ver este efecto en los ejemplos siguientes, con &lt;code&gt;&amp;amp;&amp;amp;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ddf1f7383234f0909d810cef598c63fc6f240534" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;s&lt;/code&gt; is created inside &lt;code&gt;dangle&lt;/code&gt;, when the code of &lt;code&gt;dangle&lt;/code&gt; is finished, &lt;code&gt;s&lt;/code&gt; will be deallocated. But we tried to return a reference to it. That means this reference would be pointing to an invalid &lt;code&gt;String&lt;/code&gt;. That&amp;rsquo;s no good! Rust won&amp;rsquo;t let us do this.</source>
          <target state="translated">Debido a que &lt;code&gt;s&lt;/code&gt; se crea dentro de &lt;code&gt;dangle&lt;/code&gt; , cuando el c&amp;oacute;digo de &lt;code&gt;dangle&lt;/code&gt; est&amp;eacute; terminado, &lt;code&gt;s&lt;/code&gt; se desasignar&amp;aacute;. Pero intentamos devolverle una referencia. Eso significa que esta referencia estar&amp;iacute;a apuntando a una &lt;code&gt;String&lt;/code&gt; no v&amp;aacute;lida . &amp;iexcl;Eso no es bueno! Rust no nos dejar&amp;aacute; hacer esto.</target>
        </trans-unit>
        <trans-unit id="ad3a4a81012df51bdd1c2d631b8bd2d26a080ac6" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;take_while()&lt;/code&gt; needs to look at the value in order to see if it should be included or not, consuming iterators will see that it is removed:</source>
          <target state="translated">Debido a que &lt;code&gt;take_while()&lt;/code&gt; necesita mirar el valor para ver si debe incluirse o no, los iteradores consumidores ver&amp;aacute;n que se elimina:</target>
        </trans-unit>
        <trans-unit id="a2c09e5f782c06a87c2e923fecb0abf777de8d4b" translate="yes" xml:space="preserve">
          <source>Because Rust compiles generic code into code that specifies the type in each instance, we pay no runtime cost for using generics. When the code runs, it performs just as it would if we had duplicated each definition by hand. The process of monomorphization makes Rust&amp;rsquo;s generics extremely efficient at runtime.</source>
          <target state="translated">Debido a que Rust compila c&amp;oacute;digo gen&amp;eacute;rico en c&amp;oacute;digo que especifica el tipo en cada instancia, no pagamos ning&amp;uacute;n costo de tiempo de ejecuci&amp;oacute;n por usar gen&amp;eacute;ricos. Cuando se ejecuta el c&amp;oacute;digo, funciona igual que si hubi&amp;eacute;ramos duplicado cada definici&amp;oacute;n a mano. El proceso de monomorfizaci&amp;oacute;n hace que los gen&amp;eacute;ricos de Rust sean extremadamente eficientes en tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="cb2c4627fadc957440586a7d9c240acafefffc6b" translate="yes" xml:space="preserve">
          <source>Because a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; is a pointer, Rust always knows how much space a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; needs: a pointer&amp;rsquo;s size doesn&amp;rsquo;t change based on the amount of data it&amp;rsquo;s pointing to. This means we can put a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; inside the &lt;code&gt;Cons&lt;/code&gt; variant instead of another &lt;code&gt;List&lt;/code&gt; value directly. The &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; will point to the next &lt;code&gt;List&lt;/code&gt; value that will be on the heap rather than inside the &lt;code&gt;Cons&lt;/code&gt; variant. Conceptually, we still have a list, created with lists &amp;ldquo;holding&amp;rdquo; other lists, but this implementation is now more like placing the items next to one another rather than inside one another.</source>
          <target state="translated">Debido a que un &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; es un puntero, Rust siempre sabe cu&amp;aacute;nto espacio necesita un &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; : el tama&amp;ntilde;o de un puntero no cambia seg&amp;uacute;n la cantidad de datos a los que apunta. Esto significa que podemos poner un &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; dentro de la variante &lt;code&gt;Cons&lt;/code&gt; en lugar de otro valor &lt;code&gt;List&lt;/code&gt; directamente. El &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; apuntar&amp;aacute; al siguiente valor de &lt;code&gt;List&lt;/code&gt; a que estar&amp;aacute; en el mont&amp;oacute;n en lugar de dentro de la variante &lt;code&gt;Cons&lt;/code&gt; . Conceptualmente, todav&amp;iacute;a tenemos una lista, creada con listas que &amp;ldquo;contienen&amp;rdquo; otras listas, pero esta implementaci&amp;oacute;n ahora es m&amp;aacute;s como colocar los elementos uno al lado del otro que dentro de otro.</target>
        </trans-unit>
        <trans-unit id="cf81e03b95485ed347873e7e3fe9e72472e6c6b8" translate="yes" xml:space="preserve">
          <source>Because async blocks construct a future, they define an &lt;strong&gt;async context&lt;/strong&gt; which can in turn contain &lt;a href=&quot;await-expr&quot;&gt;&lt;code&gt;await&lt;/code&gt; expressions&lt;/a&gt;. Async contexts are established by async blocks as well as the bodies of async functions, whose semantics are defined in terms of async blocks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1af0938fa6746a245ca497556ef936994388e62f" translate="yes" xml:space="preserve">
          <source>Because captures are often by reference, the following general rules arise:</source>
          <target state="translated">Dado que las capturas son a menudo por referencia,surgen las siguientes reglas generales:</target>
        </trans-unit>
        <trans-unit id="48453fbdaf06b97c2a50276382893c7136610cb4" translate="yes" xml:space="preserve">
          <source>Because forgetting a value is allowed, any &lt;code&gt;unsafe&lt;/code&gt; code you write must allow for this possibility. You cannot return a value and expect that the caller will necessarily run the value's destructor.</source>
          <target state="translated">Debido a que se permite olvidar un valor, cualquier c&amp;oacute;digo &lt;code&gt;unsafe&lt;/code&gt; que escriba debe permitir esta posibilidad. No puede devolver un valor y esperar que el llamador ejecute necesariamente el destructor del valor.</target>
        </trans-unit>
        <trans-unit id="757a75cd5c62512d1ecdcf5444c4066082ba840e" translate="yes" xml:space="preserve">
          <source>Because having variable names match the fields is common and because writing &lt;code&gt;let Point { x: x, y: y } = p;&lt;/code&gt; contains a lot of duplication, there is a shorthand for patterns that match struct fields: you only need to list the name of the struct field, and the variables created from the pattern will have the same names. Listing 18-13 shows code that behaves in the same way as the code in Listing 18-12, but the variables created in the &lt;code&gt;let&lt;/code&gt; pattern are &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; instead of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Porque tener nombres de variables que coincidan con los campos es com&amp;uacute;n y porque escribir &lt;code&gt;let Point { x: x, y: y } = p;&lt;/code&gt; contiene mucha duplicaci&amp;oacute;n, hay una abreviatura para los patrones que coinciden con los campos de estructura: solo necesita enumerar el nombre del campo de estructura y las variables creadas a partir del patr&amp;oacute;n tendr&amp;aacute;n los mismos nombres. Listado 18-13 c&amp;oacute;digo de muestra que se comporta de la misma manera que el c&amp;oacute;digo del listado 18-12, pero las variables creadas en el &lt;code&gt;let&lt;/code&gt; patr&amp;oacute;n son &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; en lugar de &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83438caeb4e092f6346d53e11e3dc5cc7d15ebb0" translate="yes" xml:space="preserve">
          <source>Because marker traits are allowed to have multiple implementations for the same type, it's not allowed to override anything in those implementations, as it would be ambiguous which override should actually be used.</source>
          <target state="translated">Dado que se permite que los rasgos marcadores tengan múltiples implementaciones para el mismo tipo,no se permite anular nada en esas implementaciones,ya que sería ambiguo qué anulación debería utilizarse realmente.</target>
        </trans-unit>
        <trans-unit id="e1154d896f41e24691d4a2066a20e9a97b30a6b0" translate="yes" xml:space="preserve">
          <source>Because of the call to the &lt;code&gt;foo&lt;/code&gt; macro, the compiler guesses that the missing module could be inside it and fails because the macro definition cannot be found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="620af94cb9d051d4dfe9f749a85e09b10b24aa07" translate="yes" xml:space="preserve">
          <source>Because of the early return, &lt;code&gt;try!&lt;/code&gt; can only be used in functions that return &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Debido al regreso temprano, &lt;code&gt;try!&lt;/code&gt; solo se puede usar en funciones que devuelven &lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c9db3f614804b168272d0d3012c3d9bae7f766b" translate="yes" xml:space="preserve">
          <source>Because of this dual purpose, it is possible to create types that are not useful for interfacing with the C programming language.</source>
          <target state="translated">Debido a este doble propósito,es posible crear tipos que no son útiles para interactuar con el lenguaje de programación C.</target>
        </trans-unit>
        <trans-unit id="6eba9459a54a420c4009843eca1a3d7462a26445" translate="yes" xml:space="preserve">
          <source>Because of this recursive dropping, you do not need to implement this trait unless your type needs its own destructor logic.</source>
          <target state="translated">Debido a esta caída recursiva,no necesitas implementar este rasgo a menos que tu tipo necesite su propia lógica destructiva.</target>
        </trans-unit>
        <trans-unit id="df92f9c80443d85d1d1f8c4ed514d9988ba7345d" translate="yes" xml:space="preserve">
          <source>Because of this, the behavior when both &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; exist differs. On Unix, if &lt;code&gt;from&lt;/code&gt; is a directory, &lt;code&gt;to&lt;/code&gt; must also be an (empty) directory. If &lt;code&gt;from&lt;/code&gt; is not a directory, &lt;code&gt;to&lt;/code&gt; must also be not a directory. In contrast, on Windows, &lt;code&gt;from&lt;/code&gt; can be anything, but &lt;code&gt;to&lt;/code&gt; must &lt;em&gt;not&lt;/em&gt; be a directory.</source>
          <target state="translated">Debido a esto, el comportamiento cuando tanto &lt;code&gt;from&lt;/code&gt; y &lt;code&gt;to&lt;/code&gt; diferencia existe. En Unix, si &lt;code&gt;from&lt;/code&gt; es un directorio, &lt;code&gt;to&lt;/code&gt; tambi&amp;eacute;n debe ser un directorio (vac&amp;iacute;o). Si &lt;code&gt;from&lt;/code&gt; no es un directorio, &lt;code&gt;to&lt;/code&gt; tampoco debe ser un directorio. Por el contrario, en Windows, &lt;code&gt;from&lt;/code&gt; Puede ser cualquier cosa, pero &lt;code&gt;to&lt;/code&gt; mosto &lt;em&gt;no&lt;/em&gt; ser un directorio.</target>
        </trans-unit>
        <trans-unit id="edb25a77d997330fe82c62f487b65b2a449f7a57" translate="yes" xml:space="preserve">
          <source>Because of this, you must give the numeric literal or binding a type:</source>
          <target state="translated">Debido a esto,debes dar al numérico literal o vinculante un tipo:</target>
        </trans-unit>
        <trans-unit id="f5828ddf70feaedc77b7fe1498bca4e7ef61a70f" translate="yes" xml:space="preserve">
          <source>Because ownership is a new concept for many programmers, it does take some time to get used to. The good news is that the more experienced you become with Rust and the rules of the ownership system, the more you&amp;rsquo;ll be able to naturally develop code that is safe and efficient. Keep at it!</source>
          <target state="translated">Debido a que la propiedad es un concepto nuevo para muchos programadores, lleva alg&amp;uacute;n tiempo acostumbrarse. La buena noticia es que cuanto m&amp;aacute;s experiencia tenga con Rust y las reglas del sistema de propiedad, m&amp;aacute;s podr&amp;aacute; desarrollar naturalmente c&amp;oacute;digo que sea seguro y eficiente. &amp;iexcl;S&amp;iacute;guelo!</target>
        </trans-unit>
        <trans-unit id="e400474ad8de5abb677ee1fb6adda287a3d95af5" translate="yes" xml:space="preserve">
          <source>Because raw entries provide much more low-level control, it's much easier to put the HashMap into an inconsistent state which, while memory-safe, will cause the map to produce seemingly random results. Higher-level and more foolproof APIs like &lt;code&gt;entry&lt;/code&gt; should be preferred when possible.</source>
          <target state="translated">Debido a que las entradas sin procesar brindan mucho m&amp;aacute;s control de bajo nivel, es mucho m&amp;aacute;s f&amp;aacute;cil poner el HashMap en un estado inconsistente que, aunque seguro para la memoria, har&amp;aacute; que el mapa produzca resultados aparentemente aleatorios. Las API de nivel superior y m&amp;aacute;s infalibles, como la &lt;code&gt;entry&lt;/code&gt; deben preferirse cuando sea posible.</target>
        </trans-unit>
        <trans-unit id="25432f6301bbde0b420035486d49aeb28bde5fd2" translate="yes" xml:space="preserve">
          <source>Because some analysis is impossible, if the Rust compiler can&amp;rsquo;t be sure the code complies with the ownership rules, it might reject a correct program; in this way, it&amp;rsquo;s conservative. If Rust accepted an incorrect program, users wouldn&amp;rsquo;t be able to trust in the guarantees Rust makes. However, if Rust rejects a correct program, the programmer will be inconvenienced, but nothing catastrophic can occur. The &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; type is useful when you&amp;rsquo;re sure your code follows the borrowing rules but the compiler is unable to understand and guarantee that.</source>
          <target state="translated">Debido a que alg&amp;uacute;n an&amp;aacute;lisis es imposible, si el compilador de Rust no puede estar seguro de que el c&amp;oacute;digo cumple con las reglas de propiedad, podr&amp;iacute;a rechazar un programa correcto; de esta manera, es conservador. Si Rust aceptara un programa incorrecto, los usuarios no podr&amp;iacute;an confiar en las garant&amp;iacute;as que ofrece Rust. Sin embargo, si Rust rechaza un programa correcto, el programador sufrir&amp;aacute; inconvenientes, pero no puede ocurrir nada catastr&amp;oacute;fico. El tipo &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; es &amp;uacute;til cuando est&amp;aacute; seguro de que su c&amp;oacute;digo sigue las reglas de pr&amp;eacute;stamo, pero el compilador no puede entenderlo ni garantizarlo.</target>
        </trans-unit>
        <trans-unit id="029a6be2649372b5b88e5ae502ff0638c469c42e" translate="yes" xml:space="preserve">
          <source>Because strings are used for so many things, we can use many different generic APIs for strings, providing us with a lot of options. Some of them can seem redundant, but they all have their place! In this case, &lt;code&gt;String::from&lt;/code&gt; and &lt;code&gt;to_string&lt;/code&gt; do the same thing, so which you choose is a matter of style.</source>
          <target state="translated">Debido a que las cadenas se usan para muchas cosas, podemos usar muchas API gen&amp;eacute;ricas diferentes para cadenas, lo que nos brinda muchas opciones. Algunos de ellos pueden parecer redundantes, &amp;iexcl;pero todos tienen su lugar! En este caso, &lt;code&gt;String::from&lt;/code&gt; y &lt;code&gt;to_string&lt;/code&gt; hacen lo mismo, por lo que elegir es una cuesti&amp;oacute;n de estilo.</target>
        </trans-unit>
        <trans-unit id="1b950a204977447e5ef7cd3c6942f49baa8eb222" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;enumerate&lt;/code&gt; method returns a tuple, we can use patterns to destructure that tuple, just like everywhere else in Rust. So in the &lt;code&gt;for&lt;/code&gt; loop, we specify a pattern that has &lt;code&gt;i&lt;/code&gt; for the index in the tuple and &lt;code&gt;&amp;amp;item&lt;/code&gt; for the single byte in the tuple. Because we get a reference to the element from &lt;code&gt;.iter().enumerate()&lt;/code&gt;, we use &lt;code&gt;&amp;amp;&lt;/code&gt; in the pattern.</source>
          <target state="translated">Debido a que el m&amp;eacute;todo &lt;code&gt;enumerate&lt;/code&gt; devuelve una tupla, podemos usar patrones para desestructurar esa tupla, al igual que en cualquier otro lugar de Rust. Entonces, en el ciclo &lt;code&gt;for&lt;/code&gt; , especificamos un patr&amp;oacute;n que tiene &lt;code&gt;i&lt;/code&gt; para el &amp;iacute;ndice en la tupla y &lt;code&gt;&amp;amp;item&lt;/code&gt; para el byte &amp;uacute;nico en la tupla. Como obtenemos una referencia al elemento de &lt;code&gt;.iter().enumerate()&lt;/code&gt; , usamos &lt;code&gt;&amp;amp;&lt;/code&gt; en el patr&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="4bad4d17c2470c688d65e4cf4cd29dd8d9a6843c" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;fly&lt;/code&gt; method takes a &lt;code&gt;self&lt;/code&gt; parameter, if we had two &lt;em&gt;types&lt;/em&gt; that both implement one &lt;em&gt;trait&lt;/em&gt;, Rust could figure out which implementation of a trait to use based on the type of &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">Debido a que el m&amp;eacute;todo &lt;code&gt;fly&lt;/code&gt; toma un par&amp;aacute;metro &lt;code&gt;self&lt;/code&gt; , si tuvi&amp;eacute;ramos dos &lt;em&gt;tipos&lt;/em&gt; que implementan un &lt;em&gt;rasgo&lt;/em&gt; , Rust podr&amp;iacute;a averiguar qu&amp;eacute; implementaci&amp;oacute;n de un rasgo usar en funci&amp;oacute;n del tipo de &lt;code&gt;self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2dfa04ea7812d8d0a045650338922229931556bb" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;toast&lt;/code&gt; field in the &lt;code&gt;back_of_house::Breakfast&lt;/code&gt; struct is public, in &lt;code&gt;eat_at_restaurant&lt;/code&gt; we can write and read to the &lt;code&gt;toast&lt;/code&gt; field using dot notation. Notice that we can&amp;rsquo;t use the &lt;code&gt;seasonal_fruit&lt;/code&gt; field in &lt;code&gt;eat_at_restaurant&lt;/code&gt; because &lt;code&gt;seasonal_fruit&lt;/code&gt; is private. Try uncommenting the line modifying the &lt;code&gt;seasonal_fruit&lt;/code&gt; field value to see what error you get!</source>
          <target state="translated">Debido a que el campo de &lt;code&gt;toast&lt;/code&gt; en la estructura &lt;code&gt;back_of_house::Breakfast&lt;/code&gt; es p&amp;uacute;blico, en &lt;code&gt;eat_at_restaurant&lt;/code&gt; podemos escribir y leer en el campo de &lt;code&gt;toast&lt;/code&gt; usando la notaci&amp;oacute;n de puntos. Tenga en cuenta que no podemos usar el &lt;code&gt;seasonal_fruit&lt;/code&gt; campo en &lt;code&gt;eat_at_restaurant&lt;/code&gt; porque &lt;code&gt;seasonal_fruit&lt;/code&gt; es privada. Pruebe eliminando el comentario de la l&amp;iacute;nea de la modificaci&amp;oacute;n de la &lt;code&gt;seasonal_fruit&lt;/code&gt; valor del campo para ver qu&amp;eacute; error que se obtiene!</target>
        </trans-unit>
        <trans-unit id="185de19b862032b52b28484b2c6cc55792a266c3" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;write&lt;/code&gt; operation could fail, we use &lt;code&gt;unwrap&lt;/code&gt; on any error result as before. Again, in a real application you would add error handling here. Finally, &lt;code&gt;flush&lt;/code&gt; will wait and prevent the program from continuing until all the bytes are written to the connection; &lt;code&gt;TcpStream&lt;/code&gt; contains an internal buffer to minimize calls to the underlying operating system.</source>
          <target state="translated">Debido a que la operaci&amp;oacute;n de &lt;code&gt;write&lt;/code&gt; podr&amp;iacute;a fallar, usamos &lt;code&gt;unwrap&lt;/code&gt; cualquier resultado de error como antes. Nuevamente, en una aplicaci&amp;oacute;n real, agregar&amp;iacute;a el manejo de errores aqu&amp;iacute;. Finalmente, &lt;code&gt;flush&lt;/code&gt; esperar&amp;aacute; y evitar&amp;aacute; que el programa contin&amp;uacute;e hasta que todos los bytes se escriban en la conexi&amp;oacute;n; &lt;code&gt;TcpStream&lt;/code&gt; contiene un b&amp;uacute;fer interno para minimizar las llamadas al sistema operativo subyacente.</target>
        </trans-unit>
        <trans-unit id="1b1f6fd955e3dd56c20447476cad2f0ff374150c" translate="yes" xml:space="preserve">
          <source>Because the closure passed to &lt;code&gt;filter()&lt;/code&gt; takes a reference, and many iterators iterate over references, this leads to a possibly confusing situation, where the type of the closure is a double reference:</source>
          <target state="translated">Debido a que el cierre pasado a &lt;code&gt;filter()&lt;/code&gt; toma una referencia, y muchos iteradores iteran sobre las referencias, esto conduce a una situaci&amp;oacute;n posiblemente confusa, donde el tipo de cierre es una referencia doble:</target>
        </trans-unit>
        <trans-unit id="58c9579a8a89655df95e712d81cbf2a21bf02a65" translate="yes" xml:space="preserve">
          <source>Because the closure passed to &lt;code&gt;skip_while()&lt;/code&gt; takes a reference, and many iterators iterate over references, this leads to a possibly confusing situation, where the type of the closure is a double reference:</source>
          <target state="translated">Debido a que el cierre pasado a &lt;code&gt;skip_while()&lt;/code&gt; toma una referencia, y muchos iteradores iteran sobre las referencias, esto conduce a una situaci&amp;oacute;n posiblemente confusa, donde el tipo de cierre es una referencia doble:</target>
        </trans-unit>
        <trans-unit id="8479afb170cef741fbbcede9d3610679171e5033" translate="yes" xml:space="preserve">
          <source>Because the closure passed to &lt;code&gt;take_while()&lt;/code&gt; takes a reference, and many iterators iterate over references, this leads to a possibly confusing situation, where the type of the closure is a double reference:</source>
          <target state="translated">Debido a que el cierre pasado a &lt;code&gt;take_while()&lt;/code&gt; toma una referencia, y muchos iteradores iteran sobre las referencias, esto conduce a una situaci&amp;oacute;n posiblemente confusa, donde el tipo de cierre es una referencia doble:</target>
        </trans-unit>
        <trans-unit id="2eb937137f69efc7f4d05e71e805b680ad9ce55c" translate="yes" xml:space="preserve">
          <source>Because the correct result of the &lt;code&gt;can_hold&lt;/code&gt; function in this case is &lt;code&gt;false&lt;/code&gt;, we need to negate that result before we pass it to the &lt;code&gt;assert!&lt;/code&gt; macro. As a result, our test will pass if &lt;code&gt;can_hold&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">Debido a que el resultado correcto de la funci&amp;oacute;n &lt;code&gt;can_hold&lt;/code&gt; en este caso es &lt;code&gt;false&lt;/code&gt; , necesitamos negar ese resultado antes de pasarlo a la &lt;code&gt;assert!&lt;/code&gt; macro. Como resultado, nuestra prueba pasar&amp;aacute; si &lt;code&gt;can_hold&lt;/code&gt; devuelve &lt;code&gt;false&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="90666aa0415ee00d8f72df1807729b34de2b7424" translate="yes" xml:space="preserve">
          <source>Because the function item type explicitly identifies the function, the item types of different functions - different items, or the same item with different generics - are distinct, and mixing them will create a type error:</source>
          <target state="translated">Debido a que el tipo de elemento de la función identifica explícitamente la función,los tipos de elementos de las diferentes funciones-diferentes elementos,o el mismo elemento con diferentes genéricos-son distintos,y mezclarlos creará un error de tipo:</target>
        </trans-unit>
        <trans-unit id="91472ca2849f01f7f3aadf84c45216c15e72f922" translate="yes" xml:space="preserve">
          <source>Because the goal is to keep all these rules inside the structs that implement &lt;code&gt;State&lt;/code&gt;, we call a &lt;code&gt;content&lt;/code&gt; method on the value in &lt;code&gt;state&lt;/code&gt; and pass the post instance (that is, &lt;code&gt;self&lt;/code&gt;) as an argument. Then we return the value that is returned from using the &lt;code&gt;content&lt;/code&gt; method on the &lt;code&gt;state&lt;/code&gt; value.</source>
          <target state="translated">Debido a que el objetivo es mantener todas estas reglas dentro de las estructuras que implementan &lt;code&gt;State&lt;/code&gt; , llamamos a un m&amp;eacute;todo de &lt;code&gt;content&lt;/code&gt; sobre el valor en &lt;code&gt;state&lt;/code&gt; y pasamos la instancia de publicaci&amp;oacute;n (es decir, &lt;code&gt;self&lt;/code&gt; ) como argumento. Luego, devolvemos el valor que se devuelve al usar el m&amp;eacute;todo de &lt;code&gt;content&lt;/code&gt; en el valor de &lt;code&gt;state&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="030b08f8ea47335b102e955f832da8f8f1553c44" translate="yes" xml:space="preserve">
          <source>Because the parameter names and the struct field names are exactly the same in Listing 5-4, we can use the &lt;em&gt;field init shorthand&lt;/em&gt; syntax to rewrite &lt;code&gt;build_user&lt;/code&gt; so that it behaves exactly the same but doesn&amp;rsquo;t have the repetition of &lt;code&gt;email&lt;/code&gt; and &lt;code&gt;username&lt;/code&gt;, as shown in Listing 5-5.</source>
          <target state="translated">Debido a que los nombres de los par&amp;aacute;metros y los nombres del campo de la estructura son exactamente los mismos en el Listado 5-4, podemos usar la sintaxis &lt;em&gt;abreviada&lt;/em&gt; del &lt;em&gt;campo init&lt;/em&gt; para reescribir &lt;code&gt;build_user&lt;/code&gt; de modo que se comporte exactamente igual pero no tenga la repetici&amp;oacute;n de &lt;code&gt;email&lt;/code&gt; y &lt;code&gt;username&lt;/code&gt; , como que se muestra en el Listado 5-5.</target>
        </trans-unit>
        <trans-unit id="d69419dfb414355067e2d4508090380593ccdd03" translate="yes" xml:space="preserve">
          <source>Because the standard library has this blanket implementation, we can call the &lt;code&gt;to_string&lt;/code&gt; method defined by the &lt;code&gt;ToString&lt;/code&gt; trait on any type that implements the &lt;code&gt;Display&lt;/code&gt; trait. For example, we can turn integers into their corresponding &lt;code&gt;String&lt;/code&gt; values like this because integers implement &lt;code&gt;Display&lt;/code&gt;:</source>
          <target state="translated">Debido a que la biblioteca est&amp;aacute;ndar tiene esta implementaci&amp;oacute;n general, podemos llamar al m&amp;eacute;todo &lt;code&gt;to_string&lt;/code&gt; definido por el rasgo &lt;code&gt;ToString&lt;/code&gt; en cualquier tipo que implemente el rasgo &lt;code&gt;Display&lt;/code&gt; . Por ejemplo, podemos convertir enteros en sus correspondientes valores de &lt;code&gt;String&lt;/code&gt; esta manera porque los enteros implementan &lt;code&gt;Display&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="37ef1e15d186d9fd04a65d1942d30d946ce68135" translate="yes" xml:space="preserve">
          <source>Because the third rule really only applies in method signatures, we&amp;rsquo;ll look at lifetimes in that context next to see why the third rule means we don&amp;rsquo;t have to annotate lifetimes in method signatures very often.</source>
          <target state="translated">Debido a que la tercera regla realmente solo se aplica a las firmas de m&amp;eacute;todos, veremos las vidas en ese contexto a continuaci&amp;oacute;n para ver por qu&amp;eacute; la tercera regla significa que no tenemos que anotar las vidas en las firmas de m&amp;eacute;todos con mucha frecuencia.</target>
        </trans-unit>
        <trans-unit id="70d45c4687665d4e0a5b39f62a85fe258555be07" translate="yes" xml:space="preserve">
          <source>Because the value that &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; references might have been dropped, to do anything with the value that a &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; is pointing to, you must make sure the value still exists. Do this by calling the &lt;code&gt;upgrade&lt;/code&gt; method on a &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; instance, which will return an &lt;code&gt;Option&amp;lt;Rc&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;. You&amp;rsquo;ll get a result of &lt;code&gt;Some&lt;/code&gt; if the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value has not been dropped yet and a result of &lt;code&gt;None&lt;/code&gt; if the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value has been dropped. Because &lt;code&gt;upgrade&lt;/code&gt; returns an &lt;code&gt;Option&amp;lt;Rc&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;, Rust will ensure that the &lt;code&gt;Some&lt;/code&gt; case and the &lt;code&gt;None&lt;/code&gt; case are handled, and there won&amp;rsquo;t be an invalid pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8bf4707482fe4f59a8a059222ee5cf8616fe8ba" translate="yes" xml:space="preserve">
          <source>Because the value that &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; references might have been dropped, to do anything with the value that a &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; is pointing to, you must make sure the value still exists. Do this by calling the &lt;code&gt;upgrade&lt;/code&gt; method on a &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; instance, which will return an &lt;code&gt;Option&amp;lt;Rc&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;. You&amp;rsquo;ll get a result of &lt;code&gt;Some&lt;/code&gt; if the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value has not been dropped yet and a result of &lt;code&gt;None&lt;/code&gt; if the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value has been dropped. Because &lt;code&gt;upgrade&lt;/code&gt; returns an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;, Rust will ensure that the &lt;code&gt;Some&lt;/code&gt; case and the &lt;code&gt;None&lt;/code&gt; case are handled, and there won&amp;rsquo;t be an invalid pointer.</source>
          <target state="translated">Debido a que es posible que se haya eliminado el valor al que hace referencia &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; , para hacer algo con el valor al que apunta &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; , debe asegurarse de que el valor a&amp;uacute;n exista. Haga esto llamando al m&amp;eacute;todo de &lt;code&gt;upgrade&lt;/code&gt; en una instancia de &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; , que devolver&amp;aacute; una &lt;code&gt;Option&amp;lt;Rc&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; . Obtendr&amp;aacute; un resultado de &lt;code&gt;Some&lt;/code&gt; si el valor &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; a&amp;uacute;n no se ha eliminado y un resultado de &lt;code&gt;None&lt;/code&gt; si se elimin&amp;oacute; el valor &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; . Debido a que la &lt;code&gt;upgrade&lt;/code&gt; devuelve una &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; , Rust se asegurar&amp;aacute; de que el caso &lt;code&gt;Some&lt;/code&gt; y &lt;code&gt;None&lt;/code&gt; se manejan may&amp;uacute;sculas y min&amp;uacute;sculas, y no habr&amp;aacute; un puntero no v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="14741fffc1dc74532e1921d454b0c26246f646ef" translate="yes" xml:space="preserve">
          <source>Because the vast majority of Rust projects use Cargo, the rest of this book assumes that you&amp;rsquo;re using Cargo too. Cargo comes installed with Rust if you used the official installers discussed in the &lt;a href=&quot;ch01-01-installation#installation&quot;&gt;&amp;ldquo;Installation&amp;rdquo;&lt;/a&gt; section. If you installed Rust through some other means, check whether Cargo is installed by entering the following into your terminal:</source>
          <target state="translated">Debido a que la gran mayor&amp;iacute;a de los proyectos de Rust usan Cargo, el resto de este libro asume que usted tambi&amp;eacute;n usa Cargo. Cargo viene instalado con Rust si us&amp;oacute; los instaladores oficiales discutidos en la secci&amp;oacute;n &lt;a href=&quot;ch01-01-installation#installation&quot;&gt;&quot;Instalaci&amp;oacute;n&quot;&lt;/a&gt; . Si instal&amp;oacute; Rust por otros medios, verifique si Cargo est&amp;aacute; instalado ingresando lo siguiente en su terminal:</target>
        </trans-unit>
        <trans-unit id="50d3009a3e9b08a6e3dea49369c4a3eff85c4a99" translate="yes" xml:space="preserve">
          <source>Because they are traits, &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt; are implemented by a number of other types, and you can implement them for your types too. As such, you'll see a few different types of I/O throughout the documentation in this module: &lt;a href=&quot;../fs/struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;s, &lt;a href=&quot;../net/struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt;s, and sometimes even &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;s. For example, &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; adds a &lt;a href=&quot;trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; method, which we can use on &lt;a href=&quot;../fs/struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;s:</source>
          <target state="translated">Debido a que son rasgos, la &lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt; se implementan mediante varios otros tipos, y tambi&amp;eacute;n puede implementarlos para sus tipos. Como tal, ver&amp;aacute; algunos tipos diferentes de E / S a lo largo de la documentaci&amp;oacute;n de este m&amp;oacute;dulo: &lt;a href=&quot;../fs/struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; s, &lt;a href=&quot;../net/struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; &lt;/a&gt; s y, a veces, incluso &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; s. Por ejemplo, &lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; agrega un m&amp;eacute;todo de &lt;a href=&quot;trait.read#tymethod.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; , que podemos usar en los &lt;a href=&quot;../fs/struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="e07ae336ff59e9ed0b225ca89429b661de0679cf" translate="yes" xml:space="preserve">
          <source>Because this declaration is in the &lt;code&gt;std::io&lt;/code&gt; module, we can use the fully qualified alias &lt;code&gt;std::io::Result&amp;lt;T&amp;gt;&lt;/code&gt;&amp;mdash;that is, a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; with the &lt;code&gt;E&lt;/code&gt; filled in as &lt;code&gt;std::io::Error&lt;/code&gt;. The &lt;code&gt;Write&lt;/code&gt; trait function signatures end up looking like this:</source>
          <target state="translated">Debido a que esta declaraci&amp;oacute;n est&amp;aacute; en el m&amp;oacute;dulo &lt;code&gt;std::io&lt;/code&gt; , podemos usar el alias totalmente calificado &lt;code&gt;std::io::Result&amp;lt;T&amp;gt;&lt;/code&gt; , es decir, un &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; con la &lt;code&gt;E&lt;/code&gt; completada como &lt;code&gt;std::io::Error&lt;/code&gt; . Las firmas de la funci&amp;oacute;n &lt;code&gt;Write&lt;/code&gt; trait terminan luciendo as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="4d78cf22aaa22c544c68896425f6652ea68b656d" translate="yes" xml:space="preserve">
          <source>Because this error message starts with the text we specified, &lt;code&gt;Failed to open hello.txt&lt;/code&gt;, it will be easier to find where in the code this error message is coming from. If we use &lt;code&gt;unwrap&lt;/code&gt; in multiple places, it can take more time to figure out exactly which &lt;code&gt;unwrap&lt;/code&gt; is causing the panic because all &lt;code&gt;unwrap&lt;/code&gt; calls that panic print the same message.</source>
          <target state="translated">Debido a que este mensaje de error comienza con el texto que especificamos, &lt;code&gt;Failed to open hello.txt&lt;/code&gt; , ser&amp;aacute; m&amp;aacute;s f&amp;aacute;cil encontrar de d&amp;oacute;nde proviene este mensaje de error en el c&amp;oacute;digo. Si usamos &lt;code&gt;unwrap&lt;/code&gt; en varios lugares, puede llevar m&amp;aacute;s tiempo averiguar exactamente qu&amp;eacute; &lt;code&gt;unwrap&lt;/code&gt; est&amp;aacute; causando el p&amp;aacute;nico porque todas las llamadas de &lt;code&gt;unwrap&lt;/code&gt; que generan p&amp;aacute;nico imprimen el mismo mensaje.</target>
        </trans-unit>
        <trans-unit id="f9ecc9d043c4a1c0a98d5acfc2202fd98ea778e6" translate="yes" xml:space="preserve">
          <source>Because this function may panic, its use is generally discouraged. Instead, prefer to use pattern matching and handle the &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; case explicitly, or call &lt;a href=&quot;enum.option#method.unwrap_or&quot;&gt;&lt;code&gt;unwrap_or&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.option#method.unwrap_or_else&quot;&gt;&lt;code&gt;unwrap_or_else&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;enum.option#method.unwrap_or_default&quot;&gt;&lt;code&gt;unwrap_or_default&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="324230b46d81d1ff99203ce38c74a82aa7a9a294" translate="yes" xml:space="preserve">
          <source>Because this function may panic, its use is generally discouraged. Instead, prefer to use pattern matching and handle the &lt;a href=&quot;enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; case explicitly, or call &lt;a href=&quot;enum.result#method.unwrap_or&quot;&gt;&lt;code&gt;unwrap_or&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.result#method.unwrap_or_else&quot;&gt;&lt;code&gt;unwrap_or_else&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;enum.result#method.unwrap_or_default&quot;&gt;&lt;code&gt;unwrap_or_default&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4fba9e24de13af0b7e1e106a0a89b1207341158" translate="yes" xml:space="preserve">
          <source>Because this representation delegates type layout to another type, it cannot be used with any other representation.</source>
          <target state="translated">Debido a que esta representación delega la disposición del tipo a otro tipo,no puede ser usada con ninguna otra representación.</target>
        </trans-unit>
        <trans-unit id="210e09fafaa62c8b440f8de035b1059405d433ec" translate="yes" xml:space="preserve">
          <source>Because transparent enums are represented exactly like one of their variants at run time, said variant must be uniquely determined. If there is no variant, or if there are multiple variants, it is not clear how the enum should be represented.</source>
          <target state="translated">Debido a que los enums transparentes se representan exactamente como una de sus variantes en tiempo de ejecución,dicha variante debe ser determinada de manera única.Si no hay ninguna variante,o si hay múltiples variantes,no está claro cómo debe representarse el enum.</target>
        </trans-unit>
        <trans-unit id="fcd01a50be2628ee7e2de7196f3290d3a3e7d1ae" translate="yes" xml:space="preserve">
          <source>Because transparent structs are represented exactly like one of their fields at run time, said field must be uniquely determined. If there is no field, or if there are multiple fields, it is not clear how the struct should be represented. Note that fields of zero-sized types (e.g., &lt;code&gt;PhantomData&lt;/code&gt;) can also exist alongside the field that contains the actual data, they do not count for this error. When generic types are involved (as in the above example), an error is reported because the type parameter could be non-zero-sized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="986c4abde2bf1faaf2d6c694b66e22c945ede5c1" translate="yes" xml:space="preserve">
          <source>Because transparent structs are represented exactly like one of their fields at run time, said field must be uniquely determined. If there is no field, or if there are multiple fields, it is not clear how the struct should be represented. Note that fields of zero-typed types (e.g., &lt;code&gt;PhantomData&lt;/code&gt;) can also exist alongside the field that contains the actual data, they do not count for this error. When generic types are involved (as in the above example), an error is reported because the type parameter could be non-zero-sized.</source>
          <target state="translated">Debido a que las estructuras transparentes se representan exactamente como uno de sus campos en tiempo de ejecuci&amp;oacute;n, dicho campo debe determinarse de forma &amp;uacute;nica. Si no hay ning&amp;uacute;n campo, o si hay varios campos, no est&amp;aacute; claro c&amp;oacute;mo se debe representar la estructura. Tenga en cuenta que los campos de tipos de tipo cero (por ejemplo, &lt;code&gt;PhantomData&lt;/code&gt; ) tambi&amp;eacute;n pueden existir junto al campo que contiene los datos reales, no cuentan para este error. Cuando hay tipos gen&amp;eacute;ricos involucrados (como en el ejemplo anterior), se informa un error porque el par&amp;aacute;metro de tipo podr&amp;iacute;a tener un tama&amp;ntilde;o distinto de cero.</target>
        </trans-unit>
        <trans-unit id="f937fa2c0a9f5f4a819643c4edaf58d80a839cab" translate="yes" xml:space="preserve">
          <source>Because tuple elements don't have a name, they can only be accessed by pattern-matching or by using &lt;code&gt;N&lt;/code&gt; directly as a field to access the &lt;code&gt;N&lt;/code&gt;th element.</source>
          <target state="translated">Debido a que los elementos de tupla no tienen un nombre, solo se puede acceder a ellos mediante la coincidencia de patrones o utilizando &lt;code&gt;N&lt;/code&gt; directamente como campo para acceder al elemento &lt;code&gt;N&lt;/code&gt; - &amp;eacute;simo.</target>
        </trans-unit>
        <trans-unit id="efb0d44a57a7bf30820d634e0cfe1255770c836f" translate="yes" xml:space="preserve">
          <source>Because two equal values need to produce the same hash value, the implementation of &lt;code&gt;Hash&lt;/code&gt; needs to ignore ASCII case, too:</source>
          <target state="translated">Debido a que dos valores iguales deben producir el mismo valor hash, la implementaci&amp;oacute;n de &lt;code&gt;Hash&lt;/code&gt; tambi&amp;eacute;n debe ignorar el caso ASCII:</target>
        </trans-unit>
        <trans-unit id="b787dccee7a3448c9761d599ebe1a0e8e174bf88" translate="yes" xml:space="preserve">
          <source>Because types that are made up of &lt;code&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt; traits are automatically also &lt;code&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt;, we don&amp;rsquo;t have to implement those traits manually. As marker traits, they don&amp;rsquo;t even have any methods to implement. They&amp;rsquo;re just useful for enforcing invariants related to concurrency.</source>
          <target state="translated">Debido a que los tipos que se componen de rasgos &lt;code&gt;Send&lt;/code&gt; y &lt;code&gt;Sync&lt;/code&gt; tambi&amp;eacute;n son &lt;code&gt;Send&lt;/code&gt; y &lt;code&gt;Sync&lt;/code&gt; autom&amp;aacute;ticamente , no tenemos que implementar esos rasgos manualmente. Como rasgos de marcador, ni siquiera tienen ning&amp;uacute;n m&amp;eacute;todo para implementar. Solo son &amp;uacute;tiles para aplicar invariantes relacionados con la concurrencia.</target>
        </trans-unit>
        <trans-unit id="e80dfd56aee472a3a988ee77f8d092b4c7dec341" translate="yes" xml:space="preserve">
          <source>Because we called the function with &lt;code&gt;5&lt;/code&gt; as the value for &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;6&lt;/code&gt; is passed as the value for &lt;code&gt;y&lt;/code&gt;, the two strings are printed with these values.</source>
          <target state="translated">Debido a que llamamos a la funci&amp;oacute;n con &lt;code&gt;5&lt;/code&gt; como valor de &lt;code&gt;x&lt;/code&gt; y &lt;code&gt;6&lt;/code&gt; se pasa como valor de &lt;code&gt;y&lt;/code&gt; , las dos cadenas se imprimen con estos valores.</target>
        </trans-unit>
        <trans-unit id="085b82e8e32a790482293e536266e4e46e15732c" translate="yes" xml:space="preserve">
          <source>Because we didn&amp;rsquo;t cover (and couldn&amp;rsquo;t cover!) every valid value with the pattern &lt;code&gt;Some(x)&lt;/code&gt;, Rust rightfully produces a compiler error.</source>
          <target state="translated">Debido a que no cubrimos (&amp;iexcl;y no pudimos cubrir!) Todos los valores v&amp;aacute;lidos con el patr&amp;oacute;n &lt;code&gt;Some(x)&lt;/code&gt; , Rust produce leg&amp;iacute;timamente un error de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c4e7a282ae038191d5b4c16b5d5eaad3c33d3637" translate="yes" xml:space="preserve">
          <source>Because we don&amp;rsquo;t have any code that pauses or delays in the &lt;code&gt;for&lt;/code&gt; loop in the main thread, we can tell that the main thread is waiting to receive values from the spawned thread.</source>
          <target state="translated">Debido a que no tenemos ning&amp;uacute;n c&amp;oacute;digo que pausa o demora el ciclo &lt;code&gt;for&lt;/code&gt; en el hilo principal, podemos decir que el hilo principal est&amp;aacute; esperando recibir valores del hilo generado.</target>
        </trans-unit>
        <trans-unit id="9a0bac08c9a7a0c19671aaf3dbc27401041da77e" translate="yes" xml:space="preserve">
          <source>Because we don&amp;rsquo;t have any tests we&amp;rsquo;ve marked as ignored, the summary shows &lt;code&gt;0 ignored&lt;/code&gt;. We also haven&amp;rsquo;t filtered the tests being run, so the end of the summary shows &lt;code&gt;0 filtered out&lt;/code&gt;. We&amp;rsquo;ll talk about ignoring and filtering out tests in the next section, &lt;a href=&quot;ch11-02-running-tests#controlling-how-tests-are-run&quot;&gt;&amp;ldquo;Controlling How Tests Are Run.&amp;rdquo;&lt;/a&gt;</source>
          <target state="translated">Debido a que no tenemos ninguna prueba que hayamos marcado como ignorada, el resumen muestra &lt;code&gt;0 ignored&lt;/code&gt; . Tampoco hemos filtrado las pruebas que se est&amp;aacute;n ejecutando, por lo que el final del resumen muestra &lt;code&gt;0 filtered out&lt;/code&gt; . Hablaremos sobre ignorar y filtrar las pruebas en la siguiente secci&amp;oacute;n, &lt;a href=&quot;ch11-02-running-tests#controlling-how-tests-are-run&quot;&gt;&quot;Control de c&amp;oacute;mo se ejecutan las pruebas&quot;.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="19d2af6731059978bb0fd7b94ea0d510b217b381" translate="yes" xml:space="preserve">
          <source>Because we don&amp;rsquo;t need them anymore, let&amp;rsquo;s remove the &lt;code&gt;println!&lt;/code&gt; statements from &lt;em&gt;src/lib.rs&lt;/em&gt; and &lt;em&gt;src/main.rs&lt;/em&gt; that we used to check the program&amp;rsquo;s behavior. Then, in &lt;em&gt;src/lib.rs&lt;/em&gt;, we&amp;rsquo;ll add a &lt;code&gt;tests&lt;/code&gt; module with a test function, as we did in &lt;a href=&quot;ch11-01-writing-tests#the-anatomy-of-a-test-function&quot;&gt;Chapter 11&lt;/a&gt;. The test function specifies the behavior we want the &lt;code&gt;search&lt;/code&gt; function to have: it will take a query and the text to search for the query in, and it will return only the lines from the text that contain the query. Listing 12-15 shows this test, which won&amp;rsquo;t compile yet.</source>
          <target state="translated">Como ya no los necesitamos, &amp;iexcl;eliminemos el &lt;code&gt;println!&lt;/code&gt; declaraciones de &lt;em&gt;src / lib.rs&lt;/em&gt; y &lt;em&gt;src / main.rs&lt;/em&gt; que usamos para verificar el comportamiento del programa. Luego, en &lt;em&gt;src / lib.rs&lt;/em&gt; , agregaremos un m&amp;oacute;dulo de &lt;code&gt;tests&lt;/code&gt; con una funci&amp;oacute;n de prueba, como hicimos en el &lt;a href=&quot;ch11-01-writing-tests#the-anatomy-of-a-test-function&quot;&gt;Cap&amp;iacute;tulo 11&lt;/a&gt; . La funci&amp;oacute;n de prueba especifica el comportamiento que queremos que tenga la funci&amp;oacute;n de &lt;code&gt;search&lt;/code&gt; : tomar&amp;aacute; una consulta y el texto para buscar la consulta, y devolver&amp;aacute; solo las l&amp;iacute;neas del texto que contiene la consulta. El listado 12-15 muestra esta prueba, que a&amp;uacute;n no se compilar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="27d7fc6d652236fca2f45fe08fc889c62e6d8253" translate="yes" xml:space="preserve">
          <source>Because we just mentioned coins, let&amp;rsquo;s use them as an example using &lt;code&gt;match&lt;/code&gt;! We can write a function that can take an unknown United States coin and, in a similar way as the counting machine, determine which coin it is and return its value in cents, as shown here in Listing 6-3.</source>
          <target state="translated">Debido a que acabamos de mencionar las monedas, us&amp;eacute;moslas como ejemplo usando &lt;code&gt;match&lt;/code&gt; ! Podemos escribir una funci&amp;oacute;n que pueda tomar una moneda estadounidense desconocida y, de manera similar a la m&amp;aacute;quina contadora, determinar qu&amp;eacute; moneda es y devolver su valor en centavos, como se muestra aqu&amp;iacute; en el Listado 6-3.</target>
        </trans-unit>
        <trans-unit id="564bbf6a7d7bf6b1e61c40462e20a2bae78026d7" translate="yes" xml:space="preserve">
          <source>Because we made the &lt;code&gt;Appetizer&lt;/code&gt; enum public, we can use the &lt;code&gt;Soup&lt;/code&gt; and &lt;code&gt;Salad&lt;/code&gt; variants in &lt;code&gt;eat_at_restaurant&lt;/code&gt;. Enums aren&amp;rsquo;t very useful unless their variants are public; it would be annoying to have to annotate all enum variants with &lt;code&gt;pub&lt;/code&gt; in every case, so the default for enum variants is to be public. Structs are often useful without their fields being public, so struct fields follow the general rule of everything being private by default unless annotated with &lt;code&gt;pub&lt;/code&gt;.</source>
          <target state="translated">Debido a que hicimos p&amp;uacute;blica la enumeraci&amp;oacute;n &lt;code&gt;Appetizer&lt;/code&gt; , podemos usar las variantes &lt;code&gt;Soup&lt;/code&gt; y &lt;code&gt;Salad&lt;/code&gt; en &lt;code&gt;eat_at_restaurant&lt;/code&gt; . Las enumeraciones no son muy &amp;uacute;tiles a menos que sus variantes sean p&amp;uacute;blicas; Ser&amp;iacute;a molesto tener que anotar todas las variantes de enumeraci&amp;oacute;n con &lt;code&gt;pub&lt;/code&gt; en todos los casos, por lo que el valor predeterminado para las variantes de enumeraci&amp;oacute;n es p&amp;uacute;blico. Las estructuras suelen ser &amp;uacute;tiles sin que sus campos sean p&amp;uacute;blicos, por lo que los campos de estructura siguen la regla general de que todo es privado de forma predeterminada a menos que se anoten con &lt;code&gt;pub&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e429697f925edbd87724bb6af67eea48f644c38e" translate="yes" xml:space="preserve">
          <source>Because we need to go through the &lt;code&gt;String&lt;/code&gt; element by element and check whether a value is a space, we&amp;rsquo;ll convert our &lt;code&gt;String&lt;/code&gt; to an array of bytes using the &lt;code&gt;as_bytes&lt;/code&gt; method:</source>
          <target state="translated">Debido a que necesitamos pasar por el &lt;code&gt;String&lt;/code&gt; elemento por elemento y verificar si un valor es un espacio, convertiremos nuestro &lt;code&gt;String&lt;/code&gt; en una matriz de bytes usando el m&amp;eacute;todo &lt;code&gt;as_bytes&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="78563068540adbc0f963cccfafb7b2fef86f3a05" translate="yes" xml:space="preserve">
          <source>Because we&amp;rsquo;ve encapsulated the implementation details of the struct &lt;code&gt;AveragedCollection&lt;/code&gt;, we can easily change aspects, such as the data structure, in the future. For instance, we could use a &lt;code&gt;HashSet&amp;lt;i32&amp;gt;&lt;/code&gt; instead of a &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; for the &lt;code&gt;list&lt;/code&gt; field. As long as the signatures of the &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, and &lt;code&gt;average&lt;/code&gt; public methods stay the same, code using &lt;code&gt;AveragedCollection&lt;/code&gt; wouldn&amp;rsquo;t need to change. If we made &lt;code&gt;list&lt;/code&gt; public instead, this wouldn&amp;rsquo;t necessarily be the case: &lt;code&gt;HashSet&amp;lt;i32&amp;gt;&lt;/code&gt; and &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; have different methods for adding and removing items, so the external code would likely have to change if it were modifying &lt;code&gt;list&lt;/code&gt; directly.</source>
          <target state="translated">Debido a que hemos encapsulado los detalles de implementaci&amp;oacute;n de la estructura &lt;code&gt;AveragedCollection&lt;/code&gt; , podemos cambiar f&amp;aacute;cilmente aspectos, como la estructura de datos, en el futuro. Por ejemplo, podr&amp;iacute;amos usar un &lt;code&gt;HashSet&amp;lt;i32&amp;gt;&lt;/code&gt; lugar de un &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; para el campo de &lt;code&gt;list&lt;/code&gt; a . Siempre que las firmas de los m&amp;eacute;todos p&amp;uacute;blicos de &lt;code&gt;add&lt;/code&gt; , &lt;code&gt;remove&lt;/code&gt; y &lt;code&gt;average&lt;/code&gt; permanezcan iguales, el c&amp;oacute;digo que usa &lt;code&gt;AveragedCollection&lt;/code&gt; no tendr&amp;iacute;a que cambiar. Si &lt;code&gt;HashSet&amp;lt;i32&amp;gt;&lt;/code&gt; &lt;code&gt;list&lt;/code&gt; a p&amp;uacute;blica en su lugar, este no ser&amp;iacute;a necesariamente el caso: HashSet &amp;lt;i32&amp;gt; y &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; tienen diferentes m&amp;eacute;todos para agregar y eliminar elementos, por lo que el c&amp;oacute;digo externo probablemente tendr&amp;iacute;a que cambiar si estuviera modificando la &lt;code&gt;list&lt;/code&gt; a directamente.</target>
        </trans-unit>
        <trans-unit id="012f083807416b28f83d8847eef6766da2f64d4c" translate="yes" xml:space="preserve">
          <source>Because we&amp;rsquo;ve given initial &lt;code&gt;i32&lt;/code&gt; values, Rust can infer that the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt;, and the type annotation isn&amp;rsquo;t necessary. Next, we&amp;rsquo;ll look at how to modify a vector.</source>
          <target state="translated">Debido a que hemos proporcionado valores de &lt;code&gt;i32&lt;/code&gt; iniciales , Rust puede inferir que el tipo de &lt;code&gt;v&lt;/code&gt; es &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; , y la anotaci&amp;oacute;n de tipo no es necesaria. A continuaci&amp;oacute;n, veremos c&amp;oacute;mo modificar un vector.</target>
        </trans-unit>
        <trans-unit id="9fe6f6ecc3242b6ec15902f2774b2a48334d7481" translate="yes" xml:space="preserve">
          <source>Because we&amp;rsquo;ve specified that &lt;code&gt;OutlinePrint&lt;/code&gt; requires the &lt;code&gt;Display&lt;/code&gt; trait, we can use the &lt;code&gt;to_string&lt;/code&gt; function that is automatically implemented for any type that implements &lt;code&gt;Display&lt;/code&gt;. If we tried to use &lt;code&gt;to_string&lt;/code&gt; without adding a colon and specifying the &lt;code&gt;Display&lt;/code&gt; trait after the trait name, we&amp;rsquo;d get an error saying that no method named &lt;code&gt;to_string&lt;/code&gt; was found for the type &lt;code&gt;&amp;amp;Self&lt;/code&gt; in the current scope.</source>
          <target state="translated">Debido a que especificamos que &lt;code&gt;OutlinePrint&lt;/code&gt; requiere el rasgo &lt;code&gt;Display&lt;/code&gt; , podemos usar la funci&amp;oacute;n &lt;code&gt;to_string&lt;/code&gt; que se implementa autom&amp;aacute;ticamente para cualquier tipo que implemente &lt;code&gt;Display&lt;/code&gt; . Si intent&amp;aacute;ramos usar &lt;code&gt;to_string&lt;/code&gt; sin agregar dos puntos y especificando el rasgo de &lt;code&gt;Display&lt;/code&gt; despu&amp;eacute;s del nombre del rasgo, obtendr&amp;iacute;amos un error que &lt;code&gt;to_string&lt;/code&gt; que no se encontr&amp;oacute; ning&amp;uacute;n m&amp;eacute;todo llamado to_string para el tipo &lt;code&gt;&amp;amp;Self&lt;/code&gt; en el alcance actual.</target>
        </trans-unit>
        <trans-unit id="627748e661f805aeaed04a41d6aadf854f4f0452" translate="yes" xml:space="preserve">
          <source>Because we're not buffering, we write each one in turn, incurring the overhead of a system call per byte written. We can fix this with a &lt;code&gt;BufWriter&amp;lt;W&amp;gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a715fdf861e47ef758515cd362976557a262f981" translate="yes" xml:space="preserve">
          <source>Because we're not buffering, we write each one in turn, incurring the overhead of a system call per byte written. We can fix this with a &lt;code&gt;BufWriter&lt;/code&gt;:</source>
          <target state="translated">Debido a que no estamos almacenando en b&amp;uacute;fer, escribimos cada uno a su vez, incurriendo en la sobrecarga de una llamada al sistema por byte escrito. Podemos solucionar esto con un &lt;code&gt;BufWriter&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cbd558490c4d9352a7af3024ff9549f8d11edc55" translate="yes" xml:space="preserve">
          <source>Because you can stack-allocate a &lt;code&gt;[u8; N]&lt;/code&gt;, and you can take a &lt;a href=&quot;../primitive.slice&quot;&gt;&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;&lt;/a&gt; of it, this function is one way to have a stack-allocated string. There is an example of this in the examples section below.</source>
          <target state="translated">Debido a que puede apilar-asignar un &lt;code&gt;[u8; N]&lt;/code&gt; , y puede tomar un &lt;a href=&quot;../primitive.slice&quot;&gt; &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; &lt;/a&gt; , esta funci&amp;oacute;n es una forma de tener una cadena asignada a la pila. Hay un ejemplo de esto en la secci&amp;oacute;n de ejemplos a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="abb004f87792d4a102d3232d143d81ed4ffc2ed8" translate="yes" xml:space="preserve">
          <source>Before an expression used as a &lt;a href=&quot;statements&quot;&gt;statement&lt;/a&gt;.</source>
          <target state="translated">Antes de una expresi&amp;oacute;n utilizada como &lt;a href=&quot;statements&quot;&gt;declaraci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6fb622789c9cc297dc766f85b7b47e7c5b64a4c2" translate="yes" xml:space="preserve">
          <source>Before diving into generics syntax, let&amp;rsquo;s first look at how to remove duplication that doesn&amp;rsquo;t involve generic types by extracting a function. Then we&amp;rsquo;ll apply this technique to extract a generic function! In the same way that you recognize duplicated code to extract into a function, you&amp;rsquo;ll start to recognize duplicated code that can use generics.</source>
          <target state="translated">Antes de sumergirnos en la sintaxis gen&amp;eacute;rica, veamos primero c&amp;oacute;mo eliminar la duplicaci&amp;oacute;n que no involucre tipos gen&amp;eacute;ricos extrayendo una funci&amp;oacute;n. &amp;iexcl;Luego aplicaremos esta t&amp;eacute;cnica para extraer una funci&amp;oacute;n gen&amp;eacute;rica! De la misma manera que reconoce el c&amp;oacute;digo duplicado para extraerlo en una funci&amp;oacute;n, comenzar&amp;aacute; a reconocer el c&amp;oacute;digo duplicado que puede usar gen&amp;eacute;ricos.</target>
        </trans-unit>
        <trans-unit id="beaf5bffc2c85ad951a60c9ddac3eebe2cec9b8f" translate="yes" xml:space="preserve">
          <source>Before explaining more, let's talk about how this module is structured:</source>
          <target state="translated">Antes de explicar más,hablemos de cómo está estructurado este módulo:</target>
        </trans-unit>
        <trans-unit id="cd09ad07440aee110c115ad35adea181d0515ee9" translate="yes" xml:space="preserve">
          <source>Before running a Rust program, you must compile it using the Rust compiler by entering the &lt;code&gt;rustc&lt;/code&gt; command and passing it the name of your source file, like this:</source>
          <target state="translated">Antes de ejecutar un programa de Rust, debe compilarlo usando el compilador de Rust ingresando el comando &lt;code&gt;rustc&lt;/code&gt; y pas&amp;aacute;ndole el nombre de su archivo fuente, as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="992020b016b482ffafd2657fccaa8d509f2063e9" translate="yes" xml:space="preserve">
          <source>Before the loop, we declare a variable named &lt;code&gt;counter&lt;/code&gt; and initialize it to &lt;code&gt;0&lt;/code&gt;. Then we declare a variable named &lt;code&gt;result&lt;/code&gt; to hold the value returned from the loop. On every iteration of the loop, we add &lt;code&gt;1&lt;/code&gt; to the &lt;code&gt;counter&lt;/code&gt; variable, and then check whether the counter is equal to &lt;code&gt;10&lt;/code&gt;. When it is, we use the &lt;code&gt;break&lt;/code&gt; keyword with the value &lt;code&gt;counter * 2&lt;/code&gt;. After the loop, we use a semicolon to end the statement that assigns the value to &lt;code&gt;result&lt;/code&gt;. Finally, we print the value in &lt;code&gt;result&lt;/code&gt;, which in this case is 20.</source>
          <target state="translated">Antes del ciclo, declaramos una variable llamada &lt;code&gt;counter&lt;/code&gt; y la inicializamos a &lt;code&gt;0&lt;/code&gt; . Luego declaramos una variable llamada &lt;code&gt;result&lt;/code&gt; ado para contener el valor devuelto por el ciclo. En cada iteraci&amp;oacute;n del ciclo, agregamos &lt;code&gt;1&lt;/code&gt; a la variable del &lt;code&gt;counter&lt;/code&gt; y luego verificamos si el contador es igual a &lt;code&gt;10&lt;/code&gt; . Cuando es as&amp;iacute;, usamos la palabra clave &lt;code&gt;break&lt;/code&gt; con el &lt;code&gt;counter * 2&lt;/code&gt; valor * 2 . Despu&amp;eacute;s del ciclo, usamos un punto y coma para finalizar la declaraci&amp;oacute;n que asigna el valor al &lt;code&gt;result&lt;/code&gt; ado . Finalmente, imprimimos el valor en &lt;code&gt;result&lt;/code&gt; ado , que en este caso es 20.</target>
        </trans-unit>
        <trans-unit id="31a496e8ed09fdd1bd621c7cc15fdcecbd8eebc7" translate="yes" xml:space="preserve">
          <source>Before we begin implementing a thread pool, let&amp;rsquo;s talk about what using the pool should look like. When you&amp;rsquo;re trying to design code, writing the client interface first can help guide your design. Write the API of the code so it&amp;rsquo;s structured in the way you want to call it; then implement the functionality within that structure rather than implementing the functionality and then designing the public API.</source>
          <target state="translated">Antes de comenzar a implementar un grupo de subprocesos, hablemos sobre c&amp;oacute;mo deber&amp;iacute;a ser el uso del grupo. Cuando intentas dise&amp;ntilde;ar c&amp;oacute;digo, escribir primero la interfaz del cliente puede ayudarte a guiar tu dise&amp;ntilde;o. Escriba la API del c&amp;oacute;digo para que est&amp;eacute; estructurado de la manera que desee llamarlo; luego implemente la funcionalidad dentro de esa estructura en lugar de implementar la funcionalidad y luego dise&amp;ntilde;ar la API p&amp;uacute;blica.</target>
        </trans-unit>
        <trans-unit id="5531bdacd5e27e11cff8fcc2e36e3c004527f8b8" translate="yes" xml:space="preserve">
          <source>Before we discuss this use case for &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, we&amp;rsquo;ll cover the syntax and how to interact with values stored within a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Antes de discutir este caso de uso para &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; , cubriremos la sintaxis y c&amp;oacute;mo interactuar con los valores almacenados dentro de &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d85d751d3cdedcf3deebd350f36e7cb28a00a5d2" translate="yes" xml:space="preserve">
          <source>Before we go into more details to explain the guarantees and choices associated with &lt;code&gt;Pin&amp;lt;T&amp;gt;&lt;/code&gt;, we discuss some examples for how it might be used. Feel free to &lt;a href=&quot;#drop-guarantee&quot;&gt;skip to where the theoretical discussion continues&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e5cb50dd4a282df49da6b5ffaeda1d9ab676ba8" translate="yes" xml:space="preserve">
          <source>Before you can publish any crates, you need to create an account on &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; and get an API token. To do so, visit the home page at &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; and log in via a GitHub account. (The GitHub account is currently a requirement, but the site might support other ways of creating an account in the future.) Once you&amp;rsquo;re logged in, visit your account settings at &lt;a href=&quot;https://crates.io/me/&quot;&gt;https://crates.io/me/&lt;/a&gt; and retrieve your API key. Then run the &lt;code&gt;cargo login&lt;/code&gt; command with your API key, like this:</source>
          <target state="translated">Antes de que pueda publicar cualquier caja, debe crear una cuenta en &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; y obtener un token de API. Para hacerlo, visite la p&amp;aacute;gina de inicio en &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; e inicie sesi&amp;oacute;n a trav&amp;eacute;s de una cuenta de GitHub. (La cuenta de GitHub es actualmente un requisito, pero el sitio podr&amp;iacute;a admitir otras formas de crear una cuenta en el futuro). Una vez que haya iniciado sesi&amp;oacute;n, visite la configuraci&amp;oacute;n de su cuenta en &lt;a href=&quot;https://crates.io/me/&quot;&gt;https://crates.io/me/&lt;/a&gt; y recupere su Clave API. Luego ejecute el comando de &lt;code&gt;cargo login&lt;/code&gt; con su clave API, as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="842beb51ca9c5417a27f472386d0e0d52dcc074f" translate="yes" xml:space="preserve">
          <source>Before:</source>
          <target state="translated">Before:</target>
        </trans-unit>
        <trans-unit id="bb11daf93347e89962e3d0ed85d6b809ec3ab729" translate="yes" xml:space="preserve">
          <source>Beginning in the 2018 edition, &lt;a href=&quot;use-declarations&quot;&gt;use declarations&lt;/a&gt; can reference crates in the extern prelude, so it is considered unidiomatic to use &lt;code&gt;extern crate&lt;/code&gt;.</source>
          <target state="translated">A partir de la edici&amp;oacute;n 2018, las &lt;a href=&quot;use-declarations&quot;&gt;declaraciones de uso&lt;/a&gt; pueden hacer referencia a cajas en el preludio externo, por lo que se considera unidiom&amp;aacute;tico usar &lt;code&gt;extern crate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f69c63a9aa10f7772ed95a8efc915f42e685135b" translate="yes" xml:space="preserve">
          <source>Beginning in the 2018 edition, &lt;code&gt;dyn&lt;/code&gt; has been promoted to a strict keyword.</source>
          <target state="translated">A partir de la edici&amp;oacute;n de 2018, &lt;code&gt;dyn&lt;/code&gt; se ha promovido a una palabra clave estricta.</target>
        </trans-unit>
        <trans-unit id="747fb066bbb4af54f78aaa8f212256984b77092b" translate="yes" xml:space="preserve">
          <source>Beginning in the 2018 edition, &lt;code&gt;dyn&lt;/code&gt; is a true keyword and is not allowed in paths, so the parentheses are not necessary.</source>
          <target state="translated">A partir de la edici&amp;oacute;n 2018, &lt;code&gt;dyn&lt;/code&gt; es una palabra clave verdadera y no se permite en las rutas, por lo que los par&amp;eacute;ntesis no son necesarios.</target>
        </trans-unit>
        <trans-unit id="88113dc243c443e4dd51d39dc5f37a435a2966eb" translate="yes" xml:space="preserve">
          <source>Beginning in the 2018 edition, function or method parameter patterns are no longer optional. Also, all irrefutable patterns are allowed as long as there is a body. Without a body, the limitations listed above are still in effect.</source>
          <target state="translated">A partir de la edición 2018,los patrones de parámetros de funciones o métodos ya no son opcionales.Además,todos los patrones irrefutables están permitidos mientras haya un cuerpo.Sin un cuerpo,las limitaciones enumeradas anteriormente siguen vigentes.</target>
        </trans-unit>
        <trans-unit id="72201b43a6b1623bf8606d5ddd5bead0602a3d00" translate="yes" xml:space="preserve">
          <source>Beginning with the 2018 Edition, paths starting with &lt;code&gt;::&lt;/code&gt; can only reference crates.</source>
          <target state="translated">A partir de la edici&amp;oacute;n 2018, las rutas que comienzan con &lt;code&gt;::&lt;/code&gt; solo pueden hacer referencia a cajas.</target>
        </trans-unit>
        <trans-unit id="020cfc8d7ce4473da0deda931f3cf2410d4b4068" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;alloc&lt;/code&gt;, but also ensures that the contents are set to zero before being returned.</source>
          <target state="translated">Se comporta como &lt;code&gt;alloc&lt;/code&gt; , pero tambi&amp;eacute;n garantiza que el contenido se establezca en cero antes de ser devuelto.</target>
        </trans-unit>
        <trans-unit id="26b6dab3100989fb3cbafd53582c862ac5c9f9f9" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;alloc&lt;/code&gt;, but also ensures that the contents are set to zero before being returned. &lt;a href=&quot;trait.alloc#method.alloc_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Se comporta como &lt;code&gt;alloc&lt;/code&gt; , pero tambi&amp;eacute;n garantiza que el contenido se establezca en cero antes de ser devuelto. &lt;a href=&quot;trait.alloc#method.alloc_zeroed&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cebb7ac8ceac00cf4605e1537d21a42ae0a8334d" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;alloc&lt;/code&gt;, but also ensures that the contents are set to zero before being returned. &lt;a href=&quot;trait.globalalloc#method.alloc_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Se comporta como &lt;code&gt;alloc&lt;/code&gt; , pero tambi&amp;eacute;n garantiza que el contenido se establezca en cero antes de ser devuelto. &lt;a href=&quot;trait.globalalloc#method.alloc_zeroed&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e653935f1fa40764a2f934dcfa1f795f0a0636d1" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;alloc&lt;/code&gt;, but also ensures that the returned memory is zero-initialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="082a664b538f66f0a51ac4134a98aba6f77d5cde" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;alloc&lt;/code&gt;, but also ensures that the returned memory is zero-initialized. &lt;a href=&quot;alloc/trait.allocref#method.alloc_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be234e6a7de7bb5e73ad2c0df1090886fa61a11b" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;alloc&lt;/code&gt;, but also ensures that the returned memory is zero-initialized. &lt;a href=&quot;trait.allocref#method.alloc_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16853ad48a342bbd03514f294c9cb5b40dbdc15d" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;alloc&lt;/code&gt;, but also returns the whole size of the returned block. For some &lt;code&gt;layout&lt;/code&gt; inputs, like arrays, this may include extra storage usable for additional data.</source>
          <target state="translated">Se comporta como &lt;code&gt;alloc&lt;/code&gt; , pero tambi&amp;eacute;n devuelve el tama&amp;ntilde;o completo del bloque devuelto. Para algunas entradas de &lt;code&gt;layout&lt;/code&gt; , como matrices, esto puede incluir almacenamiento adicional utilizable para datos adicionales.</target>
        </trans-unit>
        <trans-unit id="40c1d1b115b0d7d4586e89d6b5493bd9bd25a35d" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;alloc&lt;/code&gt;, but also returns the whole size of the returned block. For some &lt;code&gt;layout&lt;/code&gt; inputs, like arrays, this may include extra storage usable for additional data. &lt;a href=&quot;trait.alloc#method.alloc_excess&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Se comporta como &lt;code&gt;alloc&lt;/code&gt; , pero tambi&amp;eacute;n devuelve el tama&amp;ntilde;o completo del bloque devuelto. Para algunas entradas de &lt;code&gt;layout&lt;/code&gt; , como matrices, esto puede incluir almacenamiento adicional utilizable para datos adicionales. &lt;a href=&quot;trait.alloc#method.alloc_excess&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9e2179173aab44374db1b01f282be73f03846d7f" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;allocate&lt;/code&gt;, but also ensures that the returned memory is zero-initialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96a2513654f4015a77e125e9a50451e03d6371d9" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;allocate&lt;/code&gt;, but also ensures that the returned memory is zero-initialized. &lt;a href=&quot;alloc/trait.allocator#method.allocate_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb8d63977cd22736576846575120dedadc2c07c4" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;allocate&lt;/code&gt;, but also ensures that the returned memory is zero-initialized. &lt;a href=&quot;trait.allocator#method.allocate_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43a391a0a4b347a23ddcc04fdba39ef2f889911c" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;grow&lt;/code&gt;, but also ensures that the new contents are set to zero before being returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27028f3e8d3b71893211313af49a0378a2b4d868" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;grow&lt;/code&gt;, but also ensures that the new contents are set to zero before being returned. &lt;a href=&quot;alloc/trait.allocator#method.grow_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcc5bb4de65f26b5cfc9c0d306890b6a3dfd8426" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;grow&lt;/code&gt;, but also ensures that the new contents are set to zero before being returned. &lt;a href=&quot;alloc/trait.allocref#method.grow_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="744e0952faceb3c028105041422c82f4480ac4f5" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;grow&lt;/code&gt;, but also ensures that the new contents are set to zero before being returned. &lt;a href=&quot;trait.allocator#method.grow_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b00b17315ce422677165dd747a2622a3bae967c2" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;grow&lt;/code&gt;, but also ensures that the new contents are set to zero before being returned. &lt;a href=&quot;trait.allocref#method.grow_zeroed&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6dee35b4dc6dfa21486bfd27863270c134037f5" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;realloc&lt;/code&gt;, but also returns the whole size of the returned block. For some &lt;code&gt;layout&lt;/code&gt; inputs, like arrays, this may include extra storage usable for additional data.</source>
          <target state="translated">Se comporta como &lt;code&gt;realloc&lt;/code&gt; , pero tambi&amp;eacute;n devuelve el tama&amp;ntilde;o completo del bloque devuelto. Para algunas entradas de &lt;code&gt;layout&lt;/code&gt; , como matrices, esto puede incluir almacenamiento adicional utilizable para datos adicionales.</target>
        </trans-unit>
        <trans-unit id="c12028831748d6fe621f72695ab145b2de0f2ea6" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;realloc&lt;/code&gt;, but also returns the whole size of the returned block. For some &lt;code&gt;layout&lt;/code&gt; inputs, like arrays, this may include extra storage usable for additional data. &lt;a href=&quot;trait.alloc#method.realloc_excess&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Se comporta como &lt;code&gt;realloc&lt;/code&gt; , pero tambi&amp;eacute;n devuelve el tama&amp;ntilde;o completo del bloque devuelto. Para algunas entradas de &lt;code&gt;layout&lt;/code&gt; , como matrices, esto puede incluir almacenamiento adicional utilizable para datos adicionales. &lt;a href=&quot;trait.alloc#method.realloc_excess&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="70cb647a88bd7c9c17d225eecdaf0f898261eb60" translate="yes" xml:space="preserve">
          <source>Behavior</source>
          <target state="translated">Behavior</target>
        </trans-unit>
        <trans-unit id="095fb761bd6565ed9b50c488d53be7f174ad6258" translate="yes" xml:space="preserve">
          <source>Behavior considered undefined</source>
          <target state="translated">Comportamiento considerado indefinido</target>
        </trans-unit>
        <trans-unit id="387f0e642c525f9f6e8bb2a3ac2dfb1f45db317b" translate="yes" xml:space="preserve">
          <source>Behavior during const evaluation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1544a3801fc2d10e0c4fa2700cbde205e380188" translate="yes" xml:space="preserve">
          <source>Behavior is undefined if any of the following conditions are violated:</source>
          <target state="translated">El comportamiento es indefinido si se viola alguna de las siguientes condiciones:</target>
        </trans-unit>
        <trans-unit id="9d1d94b77ecaf322c48c942eb7769975f61f7e1b" translate="yes" xml:space="preserve">
          <source>Behavior not considered &lt;code id=&quot;behavior-not-considered-unsafe&quot;&gt;unsafe&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c89d307ed32970842af58f6e49fccbe4976a8de" translate="yes" xml:space="preserve">
          <source>Behavior not considered &lt;code&gt;unsafe&lt;/code&gt;</source>
          <target state="translated">Comportamiento no considerado &lt;code&gt;unsafe&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="56466d174610967ccd7c4e4d2f8e7fb575e6e68b" translate="yes" xml:space="preserve">
          <source>Being unable to change the value of a variable might have reminded you of another programming concept that most other languages have: &lt;em&gt;constants&lt;/em&gt;. Like immutable variables, constants are values that are bound to a name and are not allowed to change, but there are a few differences between constants and variables.</source>
          <target state="translated">Ser incapaz de cambiar el valor de una variable podr&amp;iacute;a haberle recordado otro concepto de programaci&amp;oacute;n que tienen la mayor&amp;iacute;a de los otros lenguajes: las &lt;em&gt;constantes&lt;/em&gt; . Al igual que las variables inmutables, las constantes son valores que est&amp;aacute;n vinculados a un nombre y no se les permite cambiar, pero existen algunas diferencias entre constantes y variables.</target>
        </trans-unit>
        <trans-unit id="2b1f5f4233d209308eb232700a1ebe15446b03df" translate="yes" xml:space="preserve">
          <source>Believe it or not, there is much more to learn on the topics we discussed in this chapter: Chapter 17 discusses trait objects, which are another way to use traits. Chapter 19 covers more complex scenarios involving lifetime annotations as well as some advanced type system features. But next, you&amp;rsquo;ll learn how to write tests in Rust so you can make sure your code is working the way it should.</source>
          <target state="translated">Lo crea o no, hay mucho m&amp;aacute;s que aprender sobre los temas que discutimos en este cap&amp;iacute;tulo: el Cap&amp;iacute;tulo 17 trata sobre los objetos de rasgo, que son otra forma de usar los rasgos. El Cap&amp;iacute;tulo 19 cubre escenarios m&amp;aacute;s complejos que involucran anotaciones de por vida, as&amp;iacute; como algunas caracter&amp;iacute;sticas avanzadas del sistema de tipos. Pero a continuaci&amp;oacute;n, aprender&amp;aacute; a escribir pruebas en Rust para asegurarse de que su c&amp;oacute;digo funciona como deber&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="58b3731b9aba86dccac77d4faa0d50972846f846" translate="yes" xml:space="preserve">
          <source>Believe it or not, there is much more to learn on the topics we discussed in this chapter: Chapter 17 discusses trait objects, which are another way to use traits. There are also more complex scenarios involving lifetime annotations that you will only need in very advanced scenarios; for those, you should read the &lt;a href=&quot;../reference/index&quot;&gt;Rust Reference&lt;/a&gt;. But next, you&amp;rsquo;ll learn how to write tests in Rust so you can make sure your code is working the way it should.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d677fae0ad7b93321bdf5902d4670326f019ecfb" translate="yes" xml:space="preserve">
          <source>Below are formal inductive definitions for FIRST and LAST.</source>
          <target state="translated">A continuación se presentan definiciones inductivas formales para PRIMERA y ULTIMA.</target>
        </trans-unit>
        <trans-unit id="9aa1c322ef5127bad20114a3c08180f48d6a1ff0" translate="yes" xml:space="preserve">
          <source>Below are some examples of FIRST and LAST. (Note in particular how the special &amp;epsilon; element is introduced and eliminated based on the interaction between the pieces of the input.)</source>
          <target state="translated">A continuaci&amp;oacute;n se muestran algunos ejemplos de FIRST y LAST. (Observe en particular c&amp;oacute;mo se introduce y elimina el elemento especial &amp;epsilon; en funci&amp;oacute;n de la interacci&amp;oacute;n entre las partes de la entrada).</target>
        </trans-unit>
        <trans-unit id="7b50be87542e5985746393609c4b0d26c14c49a1" translate="yes" xml:space="preserve">
          <source>Below is an example that shows under what conditions the compiler keeps a &lt;code&gt;static&lt;/code&gt; item in the output object file.</source>
          <target state="translated">A continuaci&amp;oacute;n se muestra un ejemplo que muestra bajo qu&amp;eacute; condiciones el compilador mantiene un elemento &lt;code&gt;static&lt;/code&gt; en el archivo de objeto de salida.</target>
        </trans-unit>
        <trans-unit id="1aa487609f84f4a503144112602dbfe1aef5f203" translate="yes" xml:space="preserve">
          <source>Below is shown a &lt;code&gt;panic_handler&lt;/code&gt; function that logs the panic message and then halts the thread.</source>
          <target state="translated">A continuaci&amp;oacute;n se muestra una funci&amp;oacute;n &lt;code&gt;panic_handler&lt;/code&gt; que registra el mensaje de p&amp;aacute;nico y luego detiene el hilo.</target>
        </trans-unit>
        <trans-unit id="2a2f598979a5de21d86b57d75eda1c3bfc34d2c7" translate="yes" xml:space="preserve">
          <source>Besides basic data types, the standard library is largely concerned with abstracting over differences in common platforms, most notably Windows and Unix derivatives.</source>
          <target state="translated">Además de los tipos de datos básicos,la biblioteca estándar se ocupa en gran medida de abstraer las diferencias en las plataformas comunes,sobre todo los derivados de Windows y Unix.</target>
        </trans-unit>
        <trans-unit id="f03b60f7e52b7ce49ed1e4f9fa511c452a2185bb" translate="yes" xml:space="preserve">
          <source>Beta</source>
          <target state="translated">Beta</target>
        </trans-unit>
        <trans-unit id="234f044b4bf52384fd2873935962aa4a005b114a" translate="yes" xml:space="preserve">
          <source>Beyond that, there are two important traits that are provided: &lt;a href=&quot;trait.seek&quot;&gt;&lt;code&gt;Seek&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.bufread&quot;&gt;&lt;code&gt;BufRead&lt;/code&gt;&lt;/a&gt;. Both of these build on top of a reader to control how the reading happens. &lt;a href=&quot;trait.seek&quot;&gt;&lt;code&gt;Seek&lt;/code&gt;&lt;/a&gt; lets you control where the next byte is coming from:</source>
          <target state="translated">M&amp;aacute;s all&amp;aacute; de eso, hay dos caracter&amp;iacute;sticas importantes que se proporcionan: &lt;a href=&quot;trait.seek&quot;&gt; &lt;code&gt;Seek&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;trait.bufread&quot;&gt; &lt;code&gt;BufRead&lt;/code&gt; &lt;/a&gt; . Ambos se basan en un lector para controlar c&amp;oacute;mo ocurre la lectura. &lt;a href=&quot;trait.seek&quot;&gt; &lt;code&gt;Seek&lt;/code&gt; &lt;/a&gt; te permite controlar de d&amp;oacute;nde viene el siguiente byte:</target>
        </trans-unit>
        <trans-unit id="66639f7d455dd71faa9147f5d69e5ce885d8bebd" translate="yes" xml:space="preserve">
          <source>Binary</source>
          <target state="translated">Binary</target>
        </trans-unit>
        <trans-unit id="528a653c1337877f018509c599539f6092a1c73c" translate="yes" xml:space="preserve">
          <source>Binary integer</source>
          <target state="translated">Entero binario</target>
        </trans-unit>
        <trans-unit id="c45c03039baf74ccb71d2cd15ae8c1ec54d6c3fc" translate="yes" xml:space="preserve">
          <source>Binary operator expressions (&lt;a href=&quot;expressions/operator-expr#arithmetic-and-logical-binary-operators&quot;&gt;&lt;em&gt;ArithmeticOrLogicalExpression&lt;/em&gt;&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#comparison-operators&quot;&gt;&lt;em&gt;ComparisonExpression&lt;/em&gt;&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#lazy-boolean-operators&quot;&gt;&lt;em&gt;LazyBooleanExpression&lt;/em&gt;&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#type-cast-expressions&quot;&gt;&lt;em&gt;TypeCastExpression&lt;/em&gt;&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;&lt;em&gt;AssignmentExpression&lt;/em&gt;&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#compound-assignment-expressions&quot;&gt;&lt;em&gt;CompoundAssignmentExpression&lt;/em&gt;&lt;/a&gt;).</source>
          <target state="translated">Expresiones de operador binario ( &lt;a href=&quot;expressions/operator-expr#arithmetic-and-logical-binary-operators&quot;&gt;&lt;em&gt;ArithmeticOrLogicalExpression&lt;/em&gt;&lt;/a&gt; , &lt;a href=&quot;expressions/operator-expr#comparison-operators&quot;&gt;&lt;em&gt;ComparisonExpression&lt;/em&gt;&lt;/a&gt; , &lt;a href=&quot;expressions/operator-expr#lazy-boolean-operators&quot;&gt;&lt;em&gt;LazyBooleanExpression&lt;/em&gt;&lt;/a&gt; , &lt;a href=&quot;expressions/operator-expr#type-cast-expressions&quot;&gt;&lt;em&gt;TypeCastExpression&lt;/em&gt;&lt;/a&gt; , &lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;&lt;em&gt;AssignmentExpression&lt;/em&gt;&lt;/a&gt; , &lt;a href=&quot;expressions/operator-expr#compound-assignment-expressions&quot;&gt;&lt;em&gt;CompoundAssignmentExpression&lt;/em&gt;&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="19f576ed80d6aac8fef3b9d639229b5cf1b86087" translate="yes" xml:space="preserve">
          <source>Binary operators expressions are all written with infix notation. This table summarizes the behavior of arithmetic and logical binary operators on primitive types and which traits are used to overload these operators for other types. Remember that signed integers are always represented using two's complement. The operands of all of these operators are evaluated in &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expression context&lt;/a&gt; so are moved or copied.</source>
          <target state="translated">Las expresiones de los operadores binarios est&amp;aacute;n todas escritas con notaci&amp;oacute;n infija. Esta tabla resume el comportamiento de los operadores binarios l&amp;oacute;gicos y aritm&amp;eacute;ticos en tipos primitivos y qu&amp;eacute; rasgos se utilizan para sobrecargar estos operadores para otros tipos. Recuerde que los enteros con signo siempre se representan mediante el complemento a dos. Los operandos de todos estos operadores se eval&amp;uacute;an en el &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;contexto de expresi&amp;oacute;n de valor,&lt;/a&gt; por lo que se mueven o copian.</target>
        </trans-unit>
        <trans-unit id="b6f95426a2cf8937585653a08dca6cfe16953252" translate="yes" xml:space="preserve">
          <source>Binary searches this sorted &lt;code&gt;VecDeque&lt;/code&gt; for a given element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8777ed96f02081635aa44ae43b6a05d44029601f" translate="yes" xml:space="preserve">
          <source>Binary searches this sorted &lt;code&gt;VecDeque&lt;/code&gt; with a comparator function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f6d0c15889ade3f758276e9309a88e8f0daaa91" translate="yes" xml:space="preserve">
          <source>Binary searches this sorted &lt;code&gt;VecDeque&lt;/code&gt; with a key extraction function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb24e7a177053effeaa97b02e6e1d53bea903394" translate="yes" xml:space="preserve">
          <source>Binary searches this sorted slice for a given element.</source>
          <target state="translated">Binario busca en esta rebanada ordenada un elemento dado.</target>
        </trans-unit>
        <trans-unit id="342759ca0bc54fef96ecf37bc0ddadb9e9d73749" translate="yes" xml:space="preserve">
          <source>Binary searches this sorted slice with a comparator function.</source>
          <target state="translated">Binario busca esta rebanada ordenada con una función de comparación.</target>
        </trans-unit>
        <trans-unit id="7bc8abd5fd12b3c23822c666fc1626829d2282bf" translate="yes" xml:space="preserve">
          <source>Binary searches this sorted slice with a key extraction function.</source>
          <target state="translated">Binario busca esta rebanada ordenada con una función de extracción clave.</target>
        </trans-unit>
        <trans-unit id="0f756fdf55ff6fbf54d5489a870831d4c60ffda7" translate="yes" xml:space="preserve">
          <source>Binary::fmt</source>
          <target state="translated">Binary::fmt</target>
        </trans-unit>
        <trans-unit id="f4b68b2fab22d221207f75497f220c953edad9fd" translate="yes" xml:space="preserve">
          <source>BinaryHeap</source>
          <target state="translated">BinaryHeap</target>
        </trans-unit>
        <trans-unit id="dacf4e220750a1b0f951db1cac365b1b687b357f" translate="yes" xml:space="preserve">
          <source>BinaryHeap::append</source>
          <target state="translated">BinaryHeap::append</target>
        </trans-unit>
        <trans-unit id="237581b8c07d3a6f7c2056bca73d832b0ff9b185" translate="yes" xml:space="preserve">
          <source>BinaryHeap::borrow</source>
          <target state="translated">BinaryHeap::borrow</target>
        </trans-unit>
        <trans-unit id="6cc1c3995d6cbe9775c025f1c009843f3a795e95" translate="yes" xml:space="preserve">
          <source>BinaryHeap::borrow_mut</source>
          <target state="translated">BinaryHeap::borrow_mut</target>
        </trans-unit>
        <trans-unit id="ea651796c70f924cd09768869629d83a528f3966" translate="yes" xml:space="preserve">
          <source>BinaryHeap::capacity</source>
          <target state="translated">BinaryHeap::capacity</target>
        </trans-unit>
        <trans-unit id="4db927bbac3d9fd9afcc396f05abd8a6d2369849" translate="yes" xml:space="preserve">
          <source>BinaryHeap::clear</source>
          <target state="translated">BinaryHeap::clear</target>
        </trans-unit>
        <trans-unit id="44380118a5aafd372e4d29c4729fc27883446a63" translate="yes" xml:space="preserve">
          <source>BinaryHeap::clone</source>
          <target state="translated">BinaryHeap::clone</target>
        </trans-unit>
        <trans-unit id="c4238fb46fd7eaa2a0823eded93fee09138cb72e" translate="yes" xml:space="preserve">
          <source>BinaryHeap::clone_from</source>
          <target state="translated">BinaryHeap::clone_from</target>
        </trans-unit>
        <trans-unit id="b77853e2e7d4b57b08f38a8fa17f28d29076c075" translate="yes" xml:space="preserve">
          <source>BinaryHeap::clone_into</source>
          <target state="translated">BinaryHeap::clone_into</target>
        </trans-unit>
        <trans-unit id="d4e562b332ce963cb95b5b307cb7485615e014fc" translate="yes" xml:space="preserve">
          <source>BinaryHeap::default</source>
          <target state="translated">BinaryHeap::default</target>
        </trans-unit>
        <trans-unit id="fdc5438d4f6cad011f4663afcc9664e54dc0d85e" translate="yes" xml:space="preserve">
          <source>BinaryHeap::drain</source>
          <target state="translated">BinaryHeap::drain</target>
        </trans-unit>
        <trans-unit id="0aaca4d42181f37288aa7e21316d709a6ff71f49" translate="yes" xml:space="preserve">
          <source>BinaryHeap::extend</source>
          <target state="translated">BinaryHeap::extend</target>
        </trans-unit>
        <trans-unit id="f4c67172d6c1cdb39c6636230b079c173cf83f2c" translate="yes" xml:space="preserve">
          <source>BinaryHeap::fmt</source>
          <target state="translated">BinaryHeap::fmt</target>
        </trans-unit>
        <trans-unit id="871dac7b5ceedfbec71447a6d6ed9de357acd044" translate="yes" xml:space="preserve">
          <source>BinaryHeap::from</source>
          <target state="translated">BinaryHeap::from</target>
        </trans-unit>
        <trans-unit id="f175a9eb33f99d6629fe67f65984c4a890519755" translate="yes" xml:space="preserve">
          <source>BinaryHeap::from_iter</source>
          <target state="translated">BinaryHeap::from_iter</target>
        </trans-unit>
        <trans-unit id="abdea679542fd107e906ae5d58ce503cb54c014d" translate="yes" xml:space="preserve">
          <source>BinaryHeap::into</source>
          <target state="translated">BinaryHeap::into</target>
        </trans-unit>
        <trans-unit id="45541a8cf8b33e80b63d4c7b7d8a3acfe03252c0" translate="yes" xml:space="preserve">
          <source>BinaryHeap::into_iter</source>
          <target state="translated">BinaryHeap::into_iter</target>
        </trans-unit>
        <trans-unit id="a4f3a26fa362623ceae23603112262e72024f7b9" translate="yes" xml:space="preserve">
          <source>BinaryHeap::into_sorted_vec</source>
          <target state="translated">BinaryHeap::into_sorted_vec</target>
        </trans-unit>
        <trans-unit id="1db086875600549522e8a9e52684ebd526b5b129" translate="yes" xml:space="preserve">
          <source>BinaryHeap::into_vec</source>
          <target state="translated">BinaryHeap::into_vec</target>
        </trans-unit>
        <trans-unit id="a112ebac833a70561b615451c2e74f51b6f19a74" translate="yes" xml:space="preserve">
          <source>BinaryHeap::is_empty</source>
          <target state="translated">BinaryHeap::is_empty</target>
        </trans-unit>
        <trans-unit id="0ee572360922722532c0921740eb1f614a7ab7ce" translate="yes" xml:space="preserve">
          <source>BinaryHeap::iter</source>
          <target state="translated">BinaryHeap::iter</target>
        </trans-unit>
        <trans-unit id="119b277a11fb08dfc4b80fb6b74bafd3221914e4" translate="yes" xml:space="preserve">
          <source>BinaryHeap::len</source>
          <target state="translated">BinaryHeap::len</target>
        </trans-unit>
        <trans-unit id="227d527ad8e44dcb2418c2e7e8e075d2359fb772" translate="yes" xml:space="preserve">
          <source>BinaryHeap::new</source>
          <target state="translated">BinaryHeap::new</target>
        </trans-unit>
        <trans-unit id="1fed1ee8afbb235ea1f87d7947786969b3a00687" translate="yes" xml:space="preserve">
          <source>BinaryHeap::peek</source>
          <target state="translated">BinaryHeap::peek</target>
        </trans-unit>
        <trans-unit id="23133fcfda988b66f1b73cca51b41c4297acc6b5" translate="yes" xml:space="preserve">
          <source>BinaryHeap::peek_mut</source>
          <target state="translated">BinaryHeap::peek_mut</target>
        </trans-unit>
        <trans-unit id="d6e00b82d35a37cd32b1907ca0812180a4fe6813" translate="yes" xml:space="preserve">
          <source>BinaryHeap::pop</source>
          <target state="translated">BinaryHeap::pop</target>
        </trans-unit>
        <trans-unit id="9d087a89ba80a46d773a7b420f9c4e221911780c" translate="yes" xml:space="preserve">
          <source>BinaryHeap::push</source>
          <target state="translated">BinaryHeap::push</target>
        </trans-unit>
        <trans-unit id="f989d57cf0e0868e0ab3e99ccd663f3feb35ed09" translate="yes" xml:space="preserve">
          <source>BinaryHeap::reserve</source>
          <target state="translated">BinaryHeap::reserve</target>
        </trans-unit>
        <trans-unit id="2c3a34b08e6d7927826662441c85562fbe689c5c" translate="yes" xml:space="preserve">
          <source>BinaryHeap::reserve_exact</source>
          <target state="translated">BinaryHeap::reserve_exact</target>
        </trans-unit>
        <trans-unit id="7748954939d681e885fda180afed19fde978c11a" translate="yes" xml:space="preserve">
          <source>BinaryHeap::shrink_to</source>
          <target state="translated">BinaryHeap::shrink_to</target>
        </trans-unit>
        <trans-unit id="a6cb12e1cadaa03dc4bd1cee0a924e07fbf651bc" translate="yes" xml:space="preserve">
          <source>BinaryHeap::shrink_to_fit</source>
          <target state="translated">BinaryHeap::shrink_to_fit</target>
        </trans-unit>
        <trans-unit id="3173fa304efc6acd170d96dcfc16d265f0d5bb04" translate="yes" xml:space="preserve">
          <source>BinaryHeap::to_owned</source>
          <target state="translated">BinaryHeap::to_owned</target>
        </trans-unit>
        <trans-unit id="545a06b62d55dcf95e6aed766f34093361650315" translate="yes" xml:space="preserve">
          <source>BinaryHeap::try_from</source>
          <target state="translated">BinaryHeap::try_from</target>
        </trans-unit>
        <trans-unit id="9ff50e94eaf55b6f7a7c5638416c4db484934500" translate="yes" xml:space="preserve">
          <source>BinaryHeap::try_into</source>
          <target state="translated">BinaryHeap::try_into</target>
        </trans-unit>
        <trans-unit id="337697412c6fd50a3b2ba815044c47d165af3cd6" translate="yes" xml:space="preserve">
          <source>BinaryHeap::type_id</source>
          <target state="translated">BinaryHeap::type_id</target>
        </trans-unit>
        <trans-unit id="8acc5ae886b9efd0dc8fb7d4fc82df425c356c37" translate="yes" xml:space="preserve">
          <source>BinaryHeap::with_capacity</source>
          <target state="translated">BinaryHeap::with_capacity</target>
        </trans-unit>
        <trans-unit id="c33a043d5763d9b3ea7f89a9ac614fa68ca83bc4" translate="yes" xml:space="preserve">
          <source>Bind a TCP listener to an address, listen for connections, and read bytes in nonblocking mode:</source>
          <target state="translated">Vincula a un oyente TCP a una dirección,escucha las conexiones y lee los bytes en modo no bloqueante:</target>
        </trans-unit>
        <trans-unit id="359dde3378dea26f13c20bf3ab1abd7d31ba2c01" translate="yes" xml:space="preserve">
          <source>Bind a value to a variable.</source>
          <target state="translated">Ata un valor a una variable.</target>
        </trans-unit>
        <trans-unit id="d22542d4de6d5029b1ac0ccd7c008fc51102ba8b" translate="yes" xml:space="preserve">
          <source>Bind by reference during pattern matching.</source>
          <target state="translated">Se unen por referencia durante la comparación de patrones.</target>
        </trans-unit>
        <trans-unit id="069dbd36e80b491e8ea0d0898b003375a28c5f42" translate="yes" xml:space="preserve">
          <source>Binding all paths matching a given prefix, using the asterisk wildcard syntax &lt;code&gt;use a::b::*;&lt;/code&gt;.</source>
          <target state="translated">Vinculando todas las rutas que coinciden con un prefijo dado, usando la sintaxis comod&amp;iacute;n de asterisco &lt;code&gt;use a::b::*;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="edac8dc0f66a2e81b54912d09ade5eca329f5dcd" translate="yes" xml:space="preserve">
          <source>Binding modes</source>
          <target state="translated">Modos de vinculación</target>
        </trans-unit>
        <trans-unit id="30c9ed787b1702852e9d605cfb98fe4532008152" translate="yes" xml:space="preserve">
          <source>Binding with a port number of 0 will request that the OS assigns a port to this listener. The port allocated can be queried via the &lt;a href=&quot;#method.local_addr&quot;&gt;&lt;code&gt;local_addr&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">La vinculaci&amp;oacute;n con un n&amp;uacute;mero de puerto de 0 solicitar&amp;aacute; que el sistema operativo asigne un puerto a este oyente. El puerto asignado se puede consultar mediante el m&amp;eacute;todo &lt;a href=&quot;#method.local_addr&quot;&gt; &lt;code&gt;local_addr&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ace7ad2d8af42b873b8f9c931c9515626c9ccb54" translate="yes" xml:space="preserve">
          <source>Binding with a port number of 0 will request that the OS assigns a port to this listener. The port allocated can be queried via the &lt;a href=&quot;struct.tcplistener#method.local_addr&quot;&gt;&lt;code&gt;TcpListener::local_addr&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c4806bd148356225d8f9e9c34e40c18cd70837a" translate="yes" xml:space="preserve">
          <source>Binds a reference to the &lt;code&gt;name&lt;/code&gt; field to the variable &lt;code&gt;person_name&lt;/code&gt;.</source>
          <target state="translated">Vincula una referencia al campo de &lt;code&gt;name&lt;/code&gt; a la variable &lt;code&gt;person_name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="309af9e25956170a810f78e3c71afc45e9766ccf" translate="yes" xml:space="preserve">
          <source>BitAnd</source>
          <target state="translated">BitAnd</target>
        </trans-unit>
        <trans-unit id="597ad73fbf9aa40cebae5f999cfe7db4afecce4e" translate="yes" xml:space="preserve">
          <source>BitAnd::bitand</source>
          <target state="translated">BitAnd::bitand</target>
        </trans-unit>
        <trans-unit id="943b337ab11ab98e677d691725140875e5b353e9" translate="yes" xml:space="preserve">
          <source>BitAndAssign</source>
          <target state="translated">BitAndAssign</target>
        </trans-unit>
        <trans-unit id="f5e3873189453b3d2f6432bcad61a66bb4d9501b" translate="yes" xml:space="preserve">
          <source>BitAndAssign::bitand_assign</source>
          <target state="translated">BitAndAssign::bitand_assign</target>
        </trans-unit>
        <trans-unit id="f64578ede789cb16c75f551e17bc358c839da2a7" translate="yes" xml:space="preserve">
          <source>BitOr</source>
          <target state="translated">BitOr</target>
        </trans-unit>
        <trans-unit id="44191b5eea700acecf61cce1d97b9be216180188" translate="yes" xml:space="preserve">
          <source>BitOr::bitor</source>
          <target state="translated">BitOr::bitor</target>
        </trans-unit>
        <trans-unit id="960e956c7d9aabe97b11d326569299236d4948a9" translate="yes" xml:space="preserve">
          <source>BitOrAssign</source>
          <target state="translated">BitOrAssign</target>
        </trans-unit>
        <trans-unit id="3034c1fbe2a99f07e023c8c2cb9d42ee22ccc4c1" translate="yes" xml:space="preserve">
          <source>BitOrAssign::bitor_assign</source>
          <target state="translated">BitOrAssign::bitor_assign</target>
        </trans-unit>
        <trans-unit id="427e64f1c1cbca75038d127034792de35e048e3d" translate="yes" xml:space="preserve">
          <source>BitXor</source>
          <target state="translated">BitXor</target>
        </trans-unit>
        <trans-unit id="2e397bf0da401d643f9083e54c584225e131c7ca" translate="yes" xml:space="preserve">
          <source>BitXor::bitxor</source>
          <target state="translated">BitXor::bitxor</target>
        </trans-unit>
        <trans-unit id="6a826e6c5b73b200c07a57a2aec1b711ff40e1d4" translate="yes" xml:space="preserve">
          <source>BitXorAssign</source>
          <target state="translated">BitXorAssign</target>
        </trans-unit>
        <trans-unit id="cbbbcfd713c363f58df6976ea8f22e15d59645d6" translate="yes" xml:space="preserve">
          <source>BitXorAssign::bitxor_assign</source>
          <target state="translated">BitXorAssign::bitxor_assign</target>
        </trans-unit>
        <trans-unit id="77e08df74f0783fd374c97b42304776b3399af7d" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;and&quot; with the current value.</source>
          <target state="translated">Un poco &quot;y&quot; con el valor actual.</target>
        </trans-unit>
        <trans-unit id="2c404667875b6822ca47e4a6888c165e459b533c" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;nand&quot; with the current value.</source>
          <target state="translated">Un poco &quot;nand&quot; con el valor actual.</target>
        </trans-unit>
        <trans-unit id="1f35aa22f6cd34a5220faabf04cbbb20527ee643" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;or&quot; with the current value.</source>
          <target state="translated">Un poco &quot;o&quot; con el valor actual.</target>
        </trans-unit>
        <trans-unit id="5c076254fac7febb41ccccf46680d5e14a161fa4" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;xor&quot; with the current value.</source>
          <target state="translated">Bitácora &quot;xor&quot; con el valor actual.</target>
        </trans-unit>
        <trans-unit id="17e80e5f71e9b85954b350f117d4dfeb3c5cf70a" translate="yes" xml:space="preserve">
          <source>Bitwise AND</source>
          <target state="translated">Un poco más inteligente y...</target>
        </trans-unit>
        <trans-unit id="4a9a6c94eeeaf50fe1cbac8c1cdc883b234d3b2b" translate="yes" xml:space="preserve">
          <source>Bitwise AND and assignment</source>
          <target state="translated">Bitwise AND y asignación</target>
        </trans-unit>
        <trans-unit id="714d6d47971ffbb15128b6a55a03723a5c596cc3" translate="yes" xml:space="preserve">
          <source>Bitwise And assignment</source>
          <target state="translated">Bitwise y la asignación</target>
        </trans-unit>
        <trans-unit id="136c3a93310929e09124297eaf66ab9f3782d009" translate="yes" xml:space="preserve">
          <source>Bitwise NOT</source>
          <target state="translated">Bitwise NO</target>
        </trans-unit>
        <trans-unit id="f4be0adcfa81c37e1e7bbf2e23630f30974d164f" translate="yes" xml:space="preserve">
          <source>Bitwise OR</source>
          <target state="translated">Un poco más o menos...</target>
        </trans-unit>
        <trans-unit id="ea162d3eb732111137dc7e851592f946afbda822" translate="yes" xml:space="preserve">
          <source>Bitwise OR and assignment</source>
          <target state="translated">El quirófano y la asignación de los bits</target>
        </trans-unit>
        <trans-unit id="efa8078cf56f653efb920477181cc2fe85068270" translate="yes" xml:space="preserve">
          <source>Bitwise Or assignment</source>
          <target state="translated">Bitwise o asignación</target>
        </trans-unit>
        <trans-unit id="74269e9a4eb117ac43a93ed74bc3c8cd96fd4ff4" translate="yes" xml:space="preserve">
          <source>Bitwise XOR</source>
          <target state="translated">Bitwise XOR</target>
        </trans-unit>
        <trans-unit id="e3e1709ce290a67ec5f21e03a6b6317c9f304436" translate="yes" xml:space="preserve">
          <source>Bitwise XOR assignment</source>
          <target state="translated">Asignación de XOR Bitwise</target>
        </trans-unit>
        <trans-unit id="1f5eabb7a575f79f20f4d75b3fa1ac6c470a8bf6" translate="yes" xml:space="preserve">
          <source>Bitwise and Logical XOR</source>
          <target state="translated">Bitwise y Logical XOR</target>
        </trans-unit>
        <trans-unit id="f5a1528826bb49fb0b14c31ab4934d10465ebdc5" translate="yes" xml:space="preserve">
          <source>Bitwise and with the current value, returning the previous value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad214175503cf05c10c463c5f6a4d2dbb82dbf24" translate="yes" xml:space="preserve">
          <source>Bitwise and with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Bitwise y con el valor actual, devolviendo el valor anterior. La versi&amp;oacute;n estabilizada de este intr&amp;iacute;nseco est&amp;aacute; disponible en los tipos &lt;code&gt;std::sync::atomic&lt;/code&gt; trav&amp;eacute;s del m&amp;eacute;todo &lt;code&gt;fetch_and&lt;/code&gt; pasando &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; como &lt;code&gt;order&lt;/code&gt; . Por ejemplo, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="52dda2454098469eb02e841cfd17da11a1a8b11c" translate="yes" xml:space="preserve">
          <source>Bitwise and with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Bitwise y con el valor actual, devolviendo el valor anterior. La versi&amp;oacute;n estabilizada de este intr&amp;iacute;nseco est&amp;aacute; disponible en los tipos &lt;code&gt;std::sync::atomic&lt;/code&gt; mediante el m&amp;eacute;todo &lt;code&gt;fetch_and&lt;/code&gt; pasando &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; como &lt;code&gt;order&lt;/code&gt; . Por ejemplo, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0c63ecd3d802b04a4e0e8dfab8248d912515dec0" translate="yes" xml:space="preserve">
          <source>Bitwise and with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Bitwise y con el valor actual, devolviendo el valor anterior. La versi&amp;oacute;n estabilizada de este intr&amp;iacute;nseco est&amp;aacute; disponible en los tipos &lt;code&gt;std::sync::atomic&lt;/code&gt; trav&amp;eacute;s del m&amp;eacute;todo &lt;code&gt;fetch_and&lt;/code&gt; pasando &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; como &lt;code&gt;order&lt;/code&gt; . Por ejemplo, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4b6a21a8674eebce391a665fc4970562e774c483" translate="yes" xml:space="preserve">
          <source>Bitwise and with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Bitwise y con el valor actual, devolviendo el valor anterior. La versi&amp;oacute;n estabilizada de este intr&amp;iacute;nseco est&amp;aacute; disponible en los tipos &lt;code&gt;std::sync::atomic&lt;/code&gt; trav&amp;eacute;s del m&amp;eacute;todo &lt;code&gt;fetch_and&lt;/code&gt; pasando &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; como &lt;code&gt;order&lt;/code&gt; . Por ejemplo, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="63f47ad2a1e6e1fb335c5dc45db81e8017584432" translate="yes" xml:space="preserve">
          <source>Bitwise and with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Bitwise y con el valor actual, devolviendo el valor anterior. La versi&amp;oacute;n estabilizada de este intr&amp;iacute;nseco est&amp;aacute; disponible en los tipos &lt;code&gt;std::sync::atomic&lt;/code&gt; mediante el m&amp;eacute;todo &lt;code&gt;fetch_and&lt;/code&gt; pasando &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; como &lt;code&gt;order&lt;/code&gt; . Por ejemplo, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3ba80ac4bf1c4bbad0f4a7d6ddfd25841835e177" translate="yes" xml:space="preserve">
          <source>Bitwise exclusive OR</source>
          <target state="translated">Exclusivo de Bitwise O</target>
        </trans-unit>
        <trans-unit id="87474ce9659a0e1b133611bb2ae41c7ede6c0a5d" translate="yes" xml:space="preserve">
          <source>Bitwise exclusive OR and assignment</source>
          <target state="translated">Bitwise exclusividad de la sala de operaciones y la asignación</target>
        </trans-unit>
        <trans-unit id="868d075a0dad8cd3d8fb9f9f26964659d2c6164a" translate="yes" xml:space="preserve">
          <source>Bitwise nand with the current value, returning the previous value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="544da95df04807eeb86f0e070273fd4dd28cb7cf" translate="yes" xml:space="preserve">
          <source>Bitwise nand with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Nand bit a bit con el valor actual, devolviendo el valor anterior. La versi&amp;oacute;n estabilizada de este intr&amp;iacute;nseco est&amp;aacute; disponible en el tipo &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; trav&amp;eacute;s del m&amp;eacute;todo &lt;code&gt;fetch_nand&lt;/code&gt; pasando &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; como &lt;code&gt;order&lt;/code&gt; . Por ejemplo, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d773083e9bfa18a72e7f0b0ab1c138c37ef42288" translate="yes" xml:space="preserve">
          <source>Bitwise nand with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Nand bit a bit con el valor actual, devolviendo el valor anterior. La versi&amp;oacute;n estabilizada de este intr&amp;iacute;nseco est&amp;aacute; disponible en el tipo &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; trav&amp;eacute;s del m&amp;eacute;todo &lt;code&gt;fetch_nand&lt;/code&gt; pasando &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; como &lt;code&gt;order&lt;/code&gt; . Por ejemplo, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="203338bb702fd121bec1c0bf9d6a954aecd4347e" translate="yes" xml:space="preserve">
          <source>Bitwise nand with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Nand bit a bit con el valor actual, devolviendo el valor anterior. La versi&amp;oacute;n estabilizada de este intr&amp;iacute;nseco est&amp;aacute; disponible en el tipo &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; trav&amp;eacute;s del m&amp;eacute;todo &lt;code&gt;fetch_nand&lt;/code&gt; pasando &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; como &lt;code&gt;order&lt;/code&gt; . Por ejemplo, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6134a1fe2a25d4dbb615e6688200dbe8e85fe9f6" translate="yes" xml:space="preserve">
          <source>Bitwise nand with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Nand bit a bit con el valor actual, devolviendo el valor anterior. La versi&amp;oacute;n estabilizada de este intr&amp;iacute;nseco est&amp;aacute; disponible en el tipo &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; trav&amp;eacute;s del m&amp;eacute;todo &lt;code&gt;fetch_nand&lt;/code&gt; pasando &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; como &lt;code&gt;order&lt;/code&gt; . Por ejemplo, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f8ddb011394cb17fb806f98da48b371ebbb0870e" translate="yes" xml:space="preserve">
          <source>Bitwise nand with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Nand bit a bit con el valor actual, devolviendo el valor anterior. La versi&amp;oacute;n estabilizada de este intr&amp;iacute;nseco est&amp;aacute; disponible en el tipo &lt;code&gt;std::sync::atomic::AtomicBool&lt;/code&gt; trav&amp;eacute;s del m&amp;eacute;todo &lt;code&gt;fetch_nand&lt;/code&gt; pasando &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; como &lt;code&gt;order&lt;/code&gt; . Por ejemplo, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="60a4df2d9448161e88049fa61b8cadfe600ad676" translate="yes" xml:space="preserve">
          <source>Bitwise or logical complement</source>
          <target state="translated">Bitácora o complemento lógico</target>
        </trans-unit>
        <trans-unit id="7b4a22d8edc7cc62ea1716050e10c7737c8c1e1f" translate="yes" xml:space="preserve">
          <source>Bitwise or with the current value, returning the previous value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="535640642d3aa1c0482deebda0463eaa8ec0186f" translate="yes" xml:space="preserve">
          <source>Bitwise or with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Bitwise o con el valor actual, devolviendo el valor anterior. La versi&amp;oacute;n estabilizada de este intr&amp;iacute;nseco est&amp;aacute; disponible en los tipos &lt;code&gt;std::sync::atomic&lt;/code&gt; trav&amp;eacute;s del m&amp;eacute;todo &lt;code&gt;fetch_or&lt;/code&gt; pasando &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; como &lt;code&gt;order&lt;/code&gt; . Por ejemplo, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5bd0c7ff8a606308243e5fe0283ace8408191438" translate="yes" xml:space="preserve">
          <source>Bitwise or with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Bitwise o con el valor actual, devolviendo el valor anterior. La versi&amp;oacute;n estabilizada de este intr&amp;iacute;nseco est&amp;aacute; disponible en los tipos &lt;code&gt;std::sync::atomic&lt;/code&gt; trav&amp;eacute;s del m&amp;eacute;todo &lt;code&gt;fetch_or&lt;/code&gt; pasando &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; como &lt;code&gt;order&lt;/code&gt; . Por ejemplo, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1d6bccdc0a09c0e78855aa36b6446bb0697edc37" translate="yes" xml:space="preserve">
          <source>Bitwise or with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Bitwise o con el valor actual, devolviendo el valor anterior. La versi&amp;oacute;n estabilizada de este intr&amp;iacute;nseco est&amp;aacute; disponible en los tipos &lt;code&gt;std::sync::atomic&lt;/code&gt; trav&amp;eacute;s del m&amp;eacute;todo &lt;code&gt;fetch_or&lt;/code&gt; pasando &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; como &lt;code&gt;order&lt;/code&gt; . Por ejemplo, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7457b18d65f2f07bafb68e32e88a446590597ffd" translate="yes" xml:space="preserve">
          <source>Bitwise or with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Bitwise o con el valor actual, devolviendo el valor anterior. La versi&amp;oacute;n estabilizada de este intr&amp;iacute;nseco est&amp;aacute; disponible en los tipos &lt;code&gt;std::sync::atomic&lt;/code&gt; trav&amp;eacute;s del m&amp;eacute;todo &lt;code&gt;fetch_or&lt;/code&gt; pasando &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; como &lt;code&gt;order&lt;/code&gt; . Por ejemplo, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a1e96dd5049ad694cd97688db2eb461734bf5e6" translate="yes" xml:space="preserve">
          <source>Bitwise or with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Bitwise o con el valor actual, devolviendo el valor anterior. La versi&amp;oacute;n estabilizada de este intr&amp;iacute;nseco est&amp;aacute; disponible en los tipos &lt;code&gt;std::sync::atomic&lt;/code&gt; mediante el m&amp;eacute;todo &lt;code&gt;fetch_or&lt;/code&gt; pasando &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; como &lt;code&gt;order&lt;/code&gt; . Por ejemplo, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="181decb693bb642be494fbe5c52383467e0c228c" translate="yes" xml:space="preserve">
          <source>Bitwise xor with the current value, returning the previous value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa1d7bc97bda02349e1fee1efbf8d66b5e91fc88" translate="yes" xml:space="preserve">
          <source>Bitwise xor with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Bit a bit xor con el valor actual, devolviendo el valor anterior. La versi&amp;oacute;n estabilizada de este intr&amp;iacute;nseco est&amp;aacute; disponible en los tipos &lt;code&gt;std::sync::atomic&lt;/code&gt; mediante el m&amp;eacute;todo &lt;code&gt;fetch_xor&lt;/code&gt; pasando &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; como &lt;code&gt;order&lt;/code&gt; . Por ejemplo, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3805cb63a3c1121fa142484c3b378fcb265aa95c" translate="yes" xml:space="preserve">
          <source>Bitwise xor with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Bit a bit xor con el valor actual, devolviendo el valor anterior. La versi&amp;oacute;n estabilizada de este intr&amp;iacute;nseco est&amp;aacute; disponible en los tipos &lt;code&gt;std::sync::atomic&lt;/code&gt; trav&amp;eacute;s del m&amp;eacute;todo &lt;code&gt;fetch_xor&lt;/code&gt; pasando &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; como &lt;code&gt;order&lt;/code&gt; . Por ejemplo, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c5ce9f030ae16f9b2b741aab2abe9cb20f55a4eb" translate="yes" xml:space="preserve">
          <source>Bitwise xor with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Bit a bit xor con el valor actual, devolviendo el valor anterior. La versi&amp;oacute;n estabilizada de este intr&amp;iacute;nseco est&amp;aacute; disponible en los tipos &lt;code&gt;std::sync::atomic&lt;/code&gt; trav&amp;eacute;s del m&amp;eacute;todo &lt;code&gt;fetch_xor&lt;/code&gt; pasando &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; como &lt;code&gt;order&lt;/code&gt; . Por ejemplo, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="15836191977a94f34a9eedc80d403307d7b6d4ed" translate="yes" xml:space="preserve">
          <source>Bitwise xor with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Bit a bit xor con el valor actual, devolviendo el valor anterior. La versi&amp;oacute;n estabilizada de este intr&amp;iacute;nseco est&amp;aacute; disponible en los tipos &lt;code&gt;std::sync::atomic&lt;/code&gt; mediante el m&amp;eacute;todo &lt;code&gt;fetch_xor&lt;/code&gt; pasando &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; como &lt;code&gt;order&lt;/code&gt; . Por ejemplo, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ffe95ab6a76bb352e681774fae150809af8a6615" translate="yes" xml:space="preserve">
          <source>Bitwise xor with the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Bit a bit xor con el valor actual, devolviendo el valor anterior. La versi&amp;oacute;n estabilizada de este intr&amp;iacute;nseco est&amp;aacute; disponible en los tipos &lt;code&gt;std::sync::atomic&lt;/code&gt; trav&amp;eacute;s del m&amp;eacute;todo &lt;code&gt;fetch_xor&lt;/code&gt; pasando &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; como &lt;code&gt;order&lt;/code&gt; . Por ejemplo, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="88de087af89700f4c1004e0042a100c96cfad709" translate="yes" xml:space="preserve">
          <source>Blanket Implementations</source>
          <target state="translated">Implementación de la manta</target>
        </trans-unit>
        <trans-unit id="7ebf10e8c63d15dc33875a65edf15f33311b088f" translate="yes" xml:space="preserve">
          <source>Blanket implementation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b62ea629ea517115ba87dea634c655ff0a340dd4" translate="yes" xml:space="preserve">
          <source>Blanket implementations appear in the documentation for the trait in the &amp;ldquo;Implementors&amp;rdquo; section.</source>
          <target state="translated">Las implementaciones generales aparecen en la documentaci&amp;oacute;n del rasgo en la secci&amp;oacute;n &quot;Implementadores&quot;.</target>
        </trans-unit>
        <trans-unit id="a06bbda0eab9ea08dbe94577274cbb7b473571d4" translate="yes" xml:space="preserve">
          <source>Block comment</source>
          <target state="translated">Bloquear el comentario...</target>
        </trans-unit>
        <trans-unit id="684096ae991ba36b90c5953d624c41ac5080dfdf" translate="yes" xml:space="preserve">
          <source>Block expression</source>
          <target state="translated">La expresión del bloque</target>
        </trans-unit>
        <trans-unit id="8b403969dc1821977a4545f2dd574d603b1654fd" translate="yes" xml:space="preserve">
          <source>Block expressions</source>
          <target state="translated">Expresiones de bloque</target>
        </trans-unit>
        <trans-unit id="7805c38c778b7b8d59aebeff2b37473f6e635d86" translate="yes" xml:space="preserve">
          <source>Block expressions as elements of &lt;a href=&quot;array-expr&quot;&gt;array expressions&lt;/a&gt;, &lt;a href=&quot;tuple-expr&quot;&gt;tuple expressions&lt;/a&gt;, &lt;a href=&quot;call-expr&quot;&gt;call expressions&lt;/a&gt;, and tuple-style &lt;a href=&quot;struct-expr&quot;&gt;struct&lt;/a&gt; and &lt;a href=&quot;enum-variant-expr&quot;&gt;enum variant&lt;/a&gt; expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e069137567cf4c22756c0a181e015e273f3b097" translate="yes" xml:space="preserve">
          <source>Block expressions as elements of &lt;a href=&quot;array-expr&quot;&gt;array expressions&lt;/a&gt;, &lt;a href=&quot;tuple-expr&quot;&gt;tuple expressions&lt;/a&gt;, &lt;a href=&quot;call-expr&quot;&gt;call expressions&lt;/a&gt;, tuple-style &lt;a href=&quot;struct-expr&quot;&gt;struct&lt;/a&gt; and &lt;a href=&quot;enum-variant-expr&quot;&gt;enum variant&lt;/a&gt; expressions.</source>
          <target state="translated">Expresiones de bloque como elementos de &lt;a href=&quot;array-expr&quot;&gt;expresiones&lt;/a&gt; de matriz , expresiones de &lt;a href=&quot;tuple-expr&quot;&gt;tupla&lt;/a&gt; , &lt;a href=&quot;call-expr&quot;&gt;expresiones de llamada&lt;/a&gt; , &lt;a href=&quot;struct-expr&quot;&gt;estructura de&lt;/a&gt; estilo tupla y expresiones &lt;a href=&quot;enum-variant-expr&quot;&gt;variantes de enumeraci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="502282ec9c201c5e6057f4beae39b5897d6f29ed" translate="yes" xml:space="preserve">
          <source>Block expressions used as a &lt;a href=&quot;../statements&quot;&gt;statement&lt;/a&gt;.</source>
          <target state="translated">Expresiones de bloque utilizadas como &lt;a href=&quot;../statements&quot;&gt;declaraci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d83a4ba900681b1d6bb448e76ababb6b95a22052" translate="yes" xml:space="preserve">
          <source>Blocks are always &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expressions&lt;/a&gt; and evaluate the last expression in value expression context. This can be used to force moving a value if really needed. For example, the following example fails on the call to &lt;code&gt;consume_self&lt;/code&gt; because the struct was moved out of &lt;code&gt;s&lt;/code&gt; in the block expression.</source>
          <target state="translated">Los bloques son siempre &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;expresiones de valor&lt;/a&gt; y eval&amp;uacute;an la &amp;uacute;ltima expresi&amp;oacute;n en el contexto de expresi&amp;oacute;n de valor. Esto se puede usar para forzar el movimiento de un valor si realmente es necesario. Por ejemplo, el siguiente ejemplo falla en la llamada a &lt;code&gt;consume_self&lt;/code&gt; porque la estructura se movi&amp;oacute; fuera de &lt;code&gt;s&lt;/code&gt; en la expresi&amp;oacute;n de bloque.</target>
        </trans-unit>
        <trans-unit id="c18efbe7496c8880dfb8b33f1bb639d10ba9c80d" translate="yes" xml:space="preserve">
          <source>Blocks are written as &lt;code&gt;{&lt;/code&gt;, then any &lt;a href=&quot;../attributes&quot;&gt;inner attributes&lt;/a&gt;, then &lt;a href=&quot;../statements&quot;&gt;statements&lt;/a&gt;, then an optional expression, and finally a &lt;code&gt;}&lt;/code&gt;. Statements are usually required to be followed a semicolon, with two exceptions. Item declaration statements do not need to be followed by a semicolon. Expression statements usually require a following semicolon except if its outer expression is a flow control expression. Furthermore, extra semicolons between statements are allowed, but these semicolons do not affect semantics.</source>
          <target state="translated">Los bloques se escriben como &lt;code&gt;{&lt;/code&gt; , luego cualquier &lt;a href=&quot;../attributes&quot;&gt;atributo interno&lt;/a&gt; , luego &lt;a href=&quot;../statements&quot;&gt;declaraciones&lt;/a&gt; , luego una expresi&amp;oacute;n opcional y finalmente a &lt;code&gt;}&lt;/code&gt; . Por lo general, se requiere que las declaraciones vayan seguidas de un punto y coma, con dos excepciones. Las declaraciones de declaraci&amp;oacute;n de art&amp;iacute;culos no necesitan ir seguidas de un punto y coma. Las declaraciones de expresi&amp;oacute;n generalmente requieren un punto y coma siguiente, excepto si su expresi&amp;oacute;n externa es una expresi&amp;oacute;n de control de flujo. Adem&amp;aacute;s, se permiten puntos y comas adicionales entre declaraciones, pero estos puntos y comas no afectan la sem&amp;aacute;ntica.</target>
        </trans-unit>
        <trans-unit id="ae067769ea09e9988dc3c94bd840ffd9a2112129" translate="yes" xml:space="preserve">
          <source>Blocks are written as &lt;code&gt;{&lt;/code&gt;, then any &lt;a href=&quot;../attributes&quot;&gt;inner attributes&lt;/a&gt;, then &lt;a href=&quot;../statements&quot;&gt;statements&lt;/a&gt;, then an optional expression, and finally a &lt;code&gt;}&lt;/code&gt;. Statements are usually required to be followed by a semicolon, with two exceptions. Item declaration statements do not need to be followed by a semicolon. Expression statements usually require a following semicolon except if its outer expression is a flow control expression. Furthermore, extra semicolons between statements are allowed, but these semicolons do not affect semantics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3b5253f4cf51bfc8b7e410d8b0b217d0e9c0335" translate="yes" xml:space="preserve">
          <source>Blocks the current thread until all threads have rendezvoused here.</source>
          <target state="translated">Bloquea el hilo actual hasta que todos los hilos se hayan reunido aquí.</target>
        </trans-unit>
        <trans-unit id="d45aaa4f52bf36a05dbf87c3a8418aac5e1ca210" translate="yes" xml:space="preserve">
          <source>Blocks the current thread until this condition variable receives a notification and the provided condition is false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fa33f5cb6fe4954947bbb580e0c51b7b87a1d8c" translate="yes" xml:space="preserve">
          <source>Blocks the current thread until this condition variable receives a notification and the required condition is met. Spurious wakeups are ignored and this function will only return once the condition has been met.</source>
          <target state="translated">Bloquea el hilo actual hasta que esta variable de condición reciba una notificación y se cumpla la condición requerida.Los despertares espurios son ignorados y esta función sólo regresará una vez que la condición se haya cumplido.</target>
        </trans-unit>
        <trans-unit id="80e976210b81b30997de305efb4640d505e6cf39" translate="yes" xml:space="preserve">
          <source>Blocks the current thread until this condition variable receives a notification.</source>
          <target state="translated">Bloquea el hilo actual hasta que esta variable de condición reciba una notificación.</target>
        </trans-unit>
        <trans-unit id="410a3ef0dd4f7761ff571ad2f23d0ad96832450b" translate="yes" xml:space="preserve">
          <source>Blocks unless or until the current thread's token is made available or the specified duration has been reached (may wake spuriously).</source>
          <target state="translated">Bloquea a menos o hasta que la ficha del hilo actual esté disponible o se haya alcanzado la duración especificada (puede despertar espuriosamente).</target>
        </trans-unit>
        <trans-unit id="7e4f7a13eb5259dea6da862f685681bb73f6e91b" translate="yes" xml:space="preserve">
          <source>Blocks unless or until the current thread's token is made available.</source>
          <target state="translated">Bloquea a menos o hasta que la ficha del hilo actual esté disponible.</target>
        </trans-unit>
        <trans-unit id="e81a87a7fdc340ba3287800ef9018a00b1adc455" translate="yes" xml:space="preserve">
          <source>Blocks: if a block has type &lt;code&gt;U&lt;/code&gt;, then the last expression in the block (if it is not semicolon-terminated) is a coercion site to &lt;code&gt;U&lt;/code&gt;. This includes blocks which are part of control flow statements, such as &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;, if the block has a known type.</source>
          <target state="translated">Bloques: si un bloque tiene tipo &lt;code&gt;U&lt;/code&gt; , entonces la &amp;uacute;ltima expresi&amp;oacute;n en el bloque (si no est&amp;aacute; terminado por punto y coma) es un sitio de la coacci&amp;oacute;n a &lt;code&gt;U&lt;/code&gt; . Esto incluye bloques que forman parte de declaraciones de flujo de control, como &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; , si el bloque tiene un tipo conocido.</target>
        </trans-unit>
        <trans-unit id="104329f4432c8b8b5d3c19fc3d250dfe2ab027d2" translate="yes" xml:space="preserve">
          <source>Bodies of unsafe functions are effectively &lt;code&gt;unsafe&lt;/code&gt; blocks, so to perform other unsafe operations within an unsafe function, we don&amp;rsquo;t need to add another &lt;code&gt;unsafe&lt;/code&gt; block.</source>
          <target state="translated">Los cuerpos de funciones inseguras son efectivamente bloques &lt;code&gt;unsafe&lt;/code&gt; , por lo que para realizar otras operaciones inseguras dentro de una funci&amp;oacute;n insegura, no es necesario agregar otro bloque &lt;code&gt;unsafe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9a26dc7a812c76d486afec462ae9a205a68b3e6" translate="yes" xml:space="preserve">
          <source>Boolean literals</source>
          <target state="translated">Literales booleanos</target>
        </trans-unit>
        <trans-unit id="49f29c844f200eead7503c6d10737135d242ba2b" translate="yes" xml:space="preserve">
          <source>Boolean type</source>
          <target state="translated">Tipo booleano</target>
        </trans-unit>
        <trans-unit id="cb4702d3f3cd69e09a0563d0dcdc4d54d0023693" translate="yes" xml:space="preserve">
          <source>Borrow</source>
          <target state="translated">Borrow</target>
        </trans-unit>
        <trans-unit id="1fd0a944ea8cfb257b2b56f1afcd67ff9e3b25e2" translate="yes" xml:space="preserve">
          <source>Borrow operators</source>
          <target state="translated">Los operadores de préstamos</target>
        </trans-unit>
        <trans-unit id="08ef91a49ea57c4babbbcf16cff803659fb46ac3" translate="yes" xml:space="preserve">
          <source>Borrow::borrow</source>
          <target state="translated">Borrow::borrow</target>
        </trans-unit>
        <trans-unit id="2928c5f6ce470ed45869ce9bc666a02f1b276c3c" translate="yes" xml:space="preserve">
          <source>BorrowError</source>
          <target state="translated">BorrowError</target>
        </trans-unit>
        <trans-unit id="cd83210bbc26f6a86f78acc2c5aab6cb300d7a3f" translate="yes" xml:space="preserve">
          <source>BorrowError::borrow</source>
          <target state="translated">BorrowError::borrow</target>
        </trans-unit>
        <trans-unit id="522f3d26a1b9c184b1451ca62d5ed845e00d0b54" translate="yes" xml:space="preserve">
          <source>BorrowError::borrow_mut</source>
          <target state="translated">BorrowError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="7a951e76d02cd0d1326baee884b3df884ef7505b" translate="yes" xml:space="preserve">
          <source>BorrowError::cause</source>
          <target state="translated">BorrowError::cause</target>
        </trans-unit>
        <trans-unit id="9346d595a8c0688d171353745aeb9cb098c34080" translate="yes" xml:space="preserve">
          <source>BorrowError::description</source>
          <target state="translated">BorrowError::description</target>
        </trans-unit>
        <trans-unit id="89396ee3db16dbcc29597b262afc46558ed2366f" translate="yes" xml:space="preserve">
          <source>BorrowError::fmt</source>
          <target state="translated">BorrowError::fmt</target>
        </trans-unit>
        <trans-unit id="f021a214bcd178a0ea344c71db12231f4f31c50f" translate="yes" xml:space="preserve">
          <source>BorrowError::from</source>
          <target state="translated">BorrowError::from</target>
        </trans-unit>
        <trans-unit id="886751874954c88f3e019db825f51742642c3fcc" translate="yes" xml:space="preserve">
          <source>BorrowError::into</source>
          <target state="translated">BorrowError::into</target>
        </trans-unit>
        <trans-unit id="26e12b28f77d9243f30385a8268af2b47555aa7c" translate="yes" xml:space="preserve">
          <source>BorrowError::source</source>
          <target state="translated">BorrowError::source</target>
        </trans-unit>
        <trans-unit id="13b09f10b5e2154e8e5ae8b9b7bc53371a685504" translate="yes" xml:space="preserve">
          <source>BorrowError::to_string</source>
          <target state="translated">BorrowError::to_string</target>
        </trans-unit>
        <trans-unit id="2ce8439dd5781fe13a435aac312be62b63c7c5be" translate="yes" xml:space="preserve">
          <source>BorrowError::try_from</source>
          <target state="translated">BorrowError::try_from</target>
        </trans-unit>
        <trans-unit id="433ecad73e66b8dc9a31fe37870bbe334a572245" translate="yes" xml:space="preserve">
          <source>BorrowError::try_into</source>
          <target state="translated">BorrowError::try_into</target>
        </trans-unit>
        <trans-unit id="65acd86f1a255edf5a9bf5a76b81126963ed5e13" translate="yes" xml:space="preserve">
          <source>BorrowError::type_id</source>
          <target state="translated">BorrowError::type_id</target>
        </trans-unit>
        <trans-unit id="7ecce6e07f46ad690e4097354d0bc6aaa0f99008" translate="yes" xml:space="preserve">
          <source>BorrowMut</source>
          <target state="translated">BorrowMut</target>
        </trans-unit>
        <trans-unit id="d9285d895ed643451254273bc8c4bbd62b0abca2" translate="yes" xml:space="preserve">
          <source>BorrowMut::borrow_mut</source>
          <target state="translated">BorrowMut::borrow_mut</target>
        </trans-unit>
        <trans-unit id="05ef9e71b85c91963a382e2cbdd7ebb51b1ef2c3" translate="yes" xml:space="preserve">
          <source>BorrowMutError</source>
          <target state="translated">BorrowMutError</target>
        </trans-unit>
        <trans-unit id="6c84f92cc03620eeb60a2a75a6198806e41c99cf" translate="yes" xml:space="preserve">
          <source>BorrowMutError::borrow</source>
          <target state="translated">BorrowMutError::borrow</target>
        </trans-unit>
        <trans-unit id="c9194e522b34f7f0397b113f83851e0a0750ebff" translate="yes" xml:space="preserve">
          <source>BorrowMutError::borrow_mut</source>
          <target state="translated">BorrowMutError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="320189f255d75bf0531f1d4da80752757ad88765" translate="yes" xml:space="preserve">
          <source>BorrowMutError::cause</source>
          <target state="translated">BorrowMutError::cause</target>
        </trans-unit>
        <trans-unit id="5d91335b7a43a382a81f901fb2092637fc2b1b30" translate="yes" xml:space="preserve">
          <source>BorrowMutError::description</source>
          <target state="translated">BorrowMutError::description</target>
        </trans-unit>
        <trans-unit id="de7386f3e6ce0f0541da576e92b462815d327aa2" translate="yes" xml:space="preserve">
          <source>BorrowMutError::fmt</source>
          <target state="translated">BorrowMutError::fmt</target>
        </trans-unit>
        <trans-unit id="0eaaabb7614aee38df98b183695570760d2a3bd8" translate="yes" xml:space="preserve">
          <source>BorrowMutError::from</source>
          <target state="translated">BorrowMutError::from</target>
        </trans-unit>
        <trans-unit id="f361017eeaa59fd5af6e66dc8387dd7623505766" translate="yes" xml:space="preserve">
          <source>BorrowMutError::into</source>
          <target state="translated">BorrowMutError::into</target>
        </trans-unit>
        <trans-unit id="4c422d071ef6d2a11942aa38c90bd2712b395f0a" translate="yes" xml:space="preserve">
          <source>BorrowMutError::source</source>
          <target state="translated">BorrowMutError::source</target>
        </trans-unit>
        <trans-unit id="2eb0e23a66aa4d528bf24f44d0b10d6fbb428403" translate="yes" xml:space="preserve">
          <source>BorrowMutError::to_string</source>
          <target state="translated">BorrowMutError::to_string</target>
        </trans-unit>
        <trans-unit id="b02bd0326962794fede5f5e186f12a2fd926a13b" translate="yes" xml:space="preserve">
          <source>BorrowMutError::try_from</source>
          <target state="translated">BorrowMutError::try_from</target>
        </trans-unit>
        <trans-unit id="6719140c2e78bc9c851d093ca84a7d95a4fe42cf" translate="yes" xml:space="preserve">
          <source>BorrowMutError::try_into</source>
          <target state="translated">BorrowMutError::try_into</target>
        </trans-unit>
        <trans-unit id="aed34dec1357c0aa84876bb9c79b00511d803df2" translate="yes" xml:space="preserve">
          <source>BorrowMutError::type_id</source>
          <target state="translated">BorrowMutError::type_id</target>
        </trans-unit>
        <trans-unit id="5868e9faf108a7771c407ab907889934dd63b50a" translate="yes" xml:space="preserve">
          <source>Borrowed data.</source>
          <target state="translated">Datos prestados.</target>
        </trans-unit>
        <trans-unit id="c7098078c609573d3fe94c28cfeb29c10812c3db" translate="yes" xml:space="preserve">
          <source>Borrowed pointer type</source>
          <target state="translated">Tipo de puntero prestado</target>
        </trans-unit>
        <trans-unit id="74d965d163933b4d9c245330d676a9a3a774550a" translate="yes" xml:space="preserve">
          <source>Borrowed reference to an OS string (see &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Referencia prestada a una cadena de sistema operativo (consulte &lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="885dff407470f8d8cfa69af65835344b4ec2492e" translate="yes" xml:space="preserve">
          <source>Borrows an iterator, rather than consuming it.</source>
          <target state="translated">Pide prestado un iterador,en lugar de consumirlo.</target>
        </trans-unit>
        <trans-unit id="e4b68387bd9a788e153fefb151f2e36c5cc3e492" translate="yes" xml:space="preserve">
          <source>Borrows an iterator, rather than consuming it. &lt;a href=&quot;../../../iter/trait.iterator#method.by_ref&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Toma prestado un iterador, en lugar de consumirlo. &lt;a href=&quot;../../../iter/trait.iterator#method.by_ref&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4c2a592fe9d3573696dcb4e01f0c58c8f29d9729" translate="yes" xml:space="preserve">
          <source>Borrows an iterator, rather than consuming it. &lt;a href=&quot;../../iter/trait.iterator#method.by_ref&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Toma prestado un iterador, en lugar de consumirlo. &lt;a href=&quot;../../iter/trait.iterator#method.by_ref&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dc9f6098309a428e4660e57ac0d7a128a57eb4f3" translate="yes" xml:space="preserve">
          <source>Borrows an iterator, rather than consuming it. &lt;a href=&quot;../iter/trait.iterator#method.by_ref&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Toma prestado un iterador, en lugar de consumirlo. &lt;a href=&quot;../iter/trait.iterator#method.by_ref&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b4d7aa1610c7d0263c276944863186c7f5b54aca" translate="yes" xml:space="preserve">
          <source>Borrows an iterator, rather than consuming it. &lt;a href=&quot;iter/trait.iterator#method.by_ref&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Toma prestado un iterador, en lugar de consumirlo. &lt;a href=&quot;iter/trait.iterator#method.by_ref&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0448c3473f95cd23244ee44dd3147a10fd3dd487" translate="yes" xml:space="preserve">
          <source>Borrows an iterator, rather than consuming it. &lt;a href=&quot;trait.iterator#method.by_ref&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Toma prestado un iterador, en lugar de consumirlo. &lt;a href=&quot;trait.iterator#method.by_ref&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f99b7e6b9280152eedd396f475e3d3c1511ee27c" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;book/ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&lt;code&gt;dyn Trait&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;book/ch10-02-traits#returning-types-that-implement-traits&quot;&gt;&lt;code&gt;impl Trait&lt;/code&gt;&lt;/a&gt; in return types have a an implicit &lt;code&gt;'static&lt;/code&gt; requirement, meaning that the value implementing them that is being returned has to be either a &lt;code&gt;'static&lt;/code&gt; borrow or an owned value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f521714f9167c57599a72f6be51da170e80a3dd" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;items/constant-items&quot;&gt;constant&lt;/a&gt; and &lt;a href=&quot;items/static-items&quot;&gt;static&lt;/a&gt; declarations of reference types have &lt;em&gt;implicit&lt;/em&gt;&lt;code&gt;'static&lt;/code&gt; lifetimes unless an explicit lifetime is specified. As such, the constant declarations involving &lt;code&gt;'static&lt;/code&gt; above may be written without the lifetimes.</source>
          <target state="translated">Tanto las declaraciones &lt;a href=&quot;items/constant-items&quot;&gt;constantes&lt;/a&gt; como &lt;a href=&quot;items/static-items&quot;&gt;est&amp;aacute;ticas&lt;/a&gt; de tipos de referencia tienen &lt;em&gt;tiempos &lt;/em&gt; &lt;code&gt;'static&lt;/code&gt; vida est&amp;aacute;ticos &lt;em&gt;impl&amp;iacute;citos a&lt;/em&gt; menos que se especifique un tiempo de vida expl&amp;iacute;cito. Como tal, las declaraciones constantes que involucran &lt;code&gt;'static&lt;/code&gt; arriba pueden escribirse sin los tiempos de vida.</target>
        </trans-unit>
        <trans-unit id="05a5142bb4165da20e62a15a12a49d69f51e7d7c" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt;es and &lt;a href=&quot;struct.rwlock&quot;&gt;&lt;code&gt;RwLock&lt;/code&gt;&lt;/a&gt;s are poisoned whenever a thread fails while the lock is held. The precise semantics for when a lock is poisoned is documented on each lock, but once a lock is poisoned then all future acquisitions will return this error.</source>
          <target state="translated">Tanto los &lt;a href=&quot;struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; &lt;/a&gt; como los &lt;a href=&quot;struct.rwlock&quot;&gt; &lt;code&gt;RwLock&lt;/code&gt; &lt;/a&gt; se envenenan cada vez que un hilo falla mientras se mantiene el bloqueo. La sem&amp;aacute;ntica precisa para cuando un bloqueo est&amp;aacute; envenenado est&amp;aacute; documentada en cada bloqueo, pero una vez que un bloqueo est&amp;aacute; envenenado, todas las adquisiciones futuras devolver&amp;aacute;n este error.</target>
        </trans-unit>
        <trans-unit id="92f3e1242e71f216f2553ecade5c0b56c112c46f" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dst&lt;/code&gt; must be properly aligned.</source>
          <target state="translated">Tanto &lt;code&gt;src&lt;/code&gt; como &lt;code&gt;dst&lt;/code&gt; deben estar correctamente alineados.</target>
        </trans-unit>
        <trans-unit id="c1a304706d4634a69f512f48a553ca6de0a57224" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must be &lt;a href=&quot;index#safety&quot;&gt;valid&lt;/a&gt; for both reads and writes of &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62b58df899df91147ad1851a44f1534537b8baae" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must be &lt;a href=&quot;index#safety&quot;&gt;valid&lt;/a&gt; for both reads and writes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2af274f82063aea319dd50db89daaff81dd41c5b" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must be &lt;a href=&quot;index#safety&quot;&gt;valid&lt;/a&gt; for reads and writes of &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes.</source>
          <target state="translated">Tanto &lt;code&gt;x&lt;/code&gt; como &lt;code&gt;y&lt;/code&gt; deben ser &lt;a href=&quot;index#safety&quot;&gt;v&amp;aacute;lidos&lt;/a&gt; para lecturas y escrituras de &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes.</target>
        </trans-unit>
        <trans-unit id="f6aa81faf4ff06762f89afa21d147f447e5913ea" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must be &lt;a href=&quot;index#safety&quot;&gt;valid&lt;/a&gt; for reads and writes.</source>
          <target state="translated">Tanto &lt;code&gt;x&lt;/code&gt; como &lt;code&gt;y&lt;/code&gt; deben ser &lt;a href=&quot;index#safety&quot;&gt;v&amp;aacute;lidos&lt;/a&gt; para lecturas y escrituras.</target>
        </trans-unit>
        <trans-unit id="ab994fd6a56d4038a2b10fa7688bd17375033138" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must be properly aligned.</source>
          <target state="translated">Tanto &lt;code&gt;x&lt;/code&gt; como &lt;code&gt;y&lt;/code&gt; deben estar correctamente alineados.</target>
        </trans-unit>
        <trans-unit id="c79da800bdef51dcfa75d10a65ea136a827d95b9" translate="yes" xml:space="preserve">
          <source>Both absolute and relative paths are followed by one or more identifiers separated by double colons (&lt;code&gt;::&lt;/code&gt;).</source>
          <target state="translated">Tanto las rutas absolutas como las relativas van seguidas de uno o m&amp;aacute;s identificadores separados por dos puntos dobles ( &lt;code&gt;::&lt;/code&gt; :) .</target>
        </trans-unit>
        <trans-unit id="c285e2e79ff8d2abdbcbfce35a32a0f639fd60af" translate="yes" xml:space="preserve">
          <source>Both are equivalent to:</source>
          <target state="translated">Ambos son equivalentes a:</target>
        </trans-unit>
        <trans-unit id="d969a72eda5767cc021898e028fbe0fc071270ae" translate="yes" xml:space="preserve">
          <source>Both attributes can be used on &lt;a href=&quot;../items/functions&quot;&gt;functions&lt;/a&gt;. When applied to a function in a &lt;a href=&quot;../items/traits&quot;&gt;trait&lt;/a&gt;, they apply only to that function when used as a default function for a trait implementation and not to all trait implementations. The attributes have no effect on a trait function without a body.</source>
          <target state="translated">Ambos atributos se pueden utilizar en &lt;a href=&quot;../items/functions&quot;&gt;funciones&lt;/a&gt; . Cuando se aplican a una funci&amp;oacute;n en un &lt;a href=&quot;../items/traits&quot;&gt;rasgo&lt;/a&gt; , se aplican solo a esa funci&amp;oacute;n cuando se usan como una funci&amp;oacute;n predeterminada para una implementaci&amp;oacute;n de rasgo y no a todas las implementaciones de rasgo. Los atributos no tienen ning&amp;uacute;n efecto sobre una funci&amp;oacute;n de rasgo sin un cuerpo.</target>
        </trans-unit>
        <trans-unit id="969434c27ab08daa9144a7ddff09f258b6b015fd" translate="yes" xml:space="preserve">
          <source>Both match arms must produce values of type &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u32.html&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;, but since &lt;code&gt;break&lt;/code&gt; never produces a value at all we know it can never produce a value which isn't a &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u32.html&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;. This illustrates another behaviour of the &lt;code&gt;!&lt;/code&gt; type - expressions with type &lt;code&gt;!&lt;/code&gt; will coerce into any other type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f415dc3d7d35015fcd0e7c895d9cc2c978758324" translate="yes" xml:space="preserve">
          <source>Both match arms must produce values of type &lt;a href=&quot;primitive.str&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;, but since &lt;code&gt;break&lt;/code&gt; never produces a value at all we know it can never produce a value which isn't a &lt;a href=&quot;primitive.str&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;. This illustrates another behaviour of the &lt;code&gt;!&lt;/code&gt; type - expressions with type &lt;code&gt;!&lt;/code&gt; will coerce into any other type.</source>
          <target state="translated">Ambos brazos de coincidencia deben producir valores de tipo &lt;a href=&quot;primitive.str&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; , pero dado que la &lt;code&gt;break&lt;/code&gt; nunca produce un valor, sabemos que nunca puede producir un valor que no sea &lt;a href=&quot;primitive.str&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; . Esto ilustra otro comportamiento del &lt;code&gt;!&lt;/code&gt; tipo - expresiones con tipo &lt;code&gt;!&lt;/code&gt; coaccionar&amp;aacute; a cualquier otro tipo.</target>
        </trans-unit>
        <trans-unit id="cc4e0abfff334b57590e92cdeed48cb0b5815f3f" translate="yes" xml:space="preserve">
          <source>Both of the following must be true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8047c2fba1b8345d0b2a7bfe41d16519cea0cd82" translate="yes" xml:space="preserve">
          <source>Both pointers must be &lt;em&gt;derived from&lt;/em&gt; a pointer to the same object. (See below for an example.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bf778379c09be3c08a3e90c46c05409146c7bf5" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;Post&lt;/code&gt; and &lt;code&gt;DraftPost&lt;/code&gt; structs have a private &lt;code&gt;content&lt;/code&gt; field that stores the blog post text. The structs no longer have the &lt;code&gt;state&lt;/code&gt; field because we&amp;rsquo;re moving the encoding of the state to the types of the structs. The &lt;code&gt;Post&lt;/code&gt; struct will represent a published post, and it has a &lt;code&gt;content&lt;/code&gt; method that returns the &lt;code&gt;content&lt;/code&gt;.</source>
          <target state="translated">Tanto las estructuras &lt;code&gt;Post&lt;/code&gt; como &lt;code&gt;DraftPost&lt;/code&gt; tienen un campo de &lt;code&gt;content&lt;/code&gt; privado que almacena el texto de la publicaci&amp;oacute;n del blog. Las estructuras ya no tienen el campo de &lt;code&gt;state&lt;/code&gt; porque estamos moviendo la codificaci&amp;oacute;n del estado a los tipos de estructuras. La estructura &lt;code&gt;Post&lt;/code&gt; representar&amp;aacute; una publicaci&amp;oacute;n publicada y tiene un m&amp;eacute;todo de &lt;code&gt;content&lt;/code&gt; que devuelve el &lt;code&gt;content&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15171a122c9ce22a8b1a51961d40b1161cecfb6b" translate="yes" xml:space="preserve">
          <source>Both the lower- and upper-bounds (&lt;code&gt;l&lt;/code&gt; and &lt;code&gt;u&lt;/code&gt; respectively) are provided, because an allocator based on size classes could misbehave if one attempts to deallocate a block without providing a correct value for its size (i.e., one within the range &lt;code&gt;[l, u]&lt;/code&gt;).</source>
          <target state="translated">Tanto el bajos y superior l&amp;iacute;mites ( &lt;code&gt;l&lt;/code&gt; y &lt;code&gt;u&lt;/code&gt; respectivamente) se proporcionan, porque un asignador basado en clases de tama&amp;ntilde;o podr&amp;iacute;a comportarse mal si se intenta desasignar un bloque sin proporcionar un valor correcto para su tama&amp;ntilde;o (es decir, uno en el intervalo &lt;code&gt;[l, u]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="98967fc7894aa4615d5bff073afe78f05a767908" translate="yes" xml:space="preserve">
          <source>Both the reading and the writing portions of the &lt;a href=&quot;struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt; should be shut down.</source>
          <target state="translated">Deben apagarse las partes de lectura y escritura de &lt;a href=&quot;struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c7bb49751d5e5b9335e672e163e91914b0f06be3" translate="yes" xml:space="preserve">
          <source>Both the stack and the heap are parts of memory that are available to your code to use at runtime, but they are structured in different ways. The stack stores values in the order it gets them and removes the values in the opposite order. This is referred to as &lt;em&gt;last in, first out&lt;/em&gt;. Think of a stack of plates: when you add more plates, you put them on top of the pile, and when you need a plate, you take one off the top. Adding or removing plates from the middle or bottom wouldn&amp;rsquo;t work as well! Adding data is called &lt;em&gt;pushing onto the stack&lt;/em&gt;, and removing data is called &lt;em&gt;popping off the stack&lt;/em&gt;.</source>
          <target state="translated">Tanto la pila como el mont&amp;oacute;n son partes de la memoria que est&amp;aacute;n disponibles para que su c&amp;oacute;digo las use en tiempo de ejecuci&amp;oacute;n, pero est&amp;aacute;n estructuradas de diferentes maneras. La pila almacena los valores en el orden en que los obtiene y los elimina en el orden opuesto. Esto se conoce como &lt;em&gt;&amp;uacute;ltimo en entrar, primero en salir&lt;/em&gt; . Piense en una pila de platos: cuando agrega m&amp;aacute;s platos, los coloca encima de la pila y cuando necesita un plato, quita uno de la parte superior. &amp;iexcl;Agregar o quitar placas del medio o la parte inferior no funcionar&amp;iacute;a tan bien! Agregar datos se llama &lt;em&gt;empujar hacia la pila&lt;/em&gt; y eliminar datos se llama &lt;em&gt;sacar de la pila&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0d50912827dc83752805291122efdab8614525af" translate="yes" xml:space="preserve">
          <source>Both the starting and other pointer must be either in bounds or one byte past the end of the same allocated object.</source>
          <target state="translated">Tanto el puntero inicial como el otro puntero deben estar en los límites o un byte más allá del final del mismo objeto asignado.</target>
        </trans-unit>
        <trans-unit id="d01b29b32d289e0c8b9a18df5a84772808d7bfc2" translate="yes" xml:space="preserve">
          <source>Both the starting and other pointer must be either in bounds or one byte past the end of the same allocated object. Note that in Rust, every (stack-allocated) variable is considered a separate allocated object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72784f6c1c0665f0bf4dbcd1fd7585be3cfa702f" translate="yes" xml:space="preserve">
          <source>Both the starting and resulting pointer must be either in bounds or one byte past the end of an allocated object. If either pointer is out of bounds or arithmetic overflow occurs then any further use of the returned value will result in undefined behavior.</source>
          <target state="translated">Tanto el puntero inicial como el resultante deben estar en los límites o un byte más allá del final de un objeto asignado.Si cualquiera de los punteros está fuera de los límites o se produce un desbordamiento aritmético,cualquier uso posterior del valor devuelto dará lugar a un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="ab5604b532321bee04b244b342d737f8189eea86" translate="yes" xml:space="preserve">
          <source>Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object.</source>
          <target state="translated">Tanto el puntero inicial como el resultante deben estar en los límites o un byte más allá del final del mismo objeto asignado.</target>
        </trans-unit>
        <trans-unit id="b2aa47636e98a60617bcdd3e67a5924dfb004f66" translate="yes" xml:space="preserve">
          <source>Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object. Note that in Rust, every (stack-allocated) variable is considered a separate allocated object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66fee1cf29e97c8fc0875ae5e9908b627fd1605d" translate="yes" xml:space="preserve">
          <source>Both types must have the same size. Neither the original, nor the result, may be an &lt;a href=&quot;https://doc.rust-lang.org/nomicon/what-unsafe-does.html&quot;&gt;invalid value&lt;/a&gt;.</source>
          <target state="translated">Ambos tipos deben tener el mismo tama&amp;ntilde;o. Ni el original ni el resultado pueden ser un &lt;a href=&quot;https://doc.rust-lang.org/nomicon/what-unsafe-does.html&quot;&gt;valor no v&amp;aacute;lido&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2c346acf685cb1f6817015d7708b959e84444f26" translate="yes" xml:space="preserve">
          <source>Bound</source>
          <target state="translated">Bound</target>
        </trans-unit>
        <trans-unit id="6b7a8fef068d73e848dac8523afae549fc821d96" translate="yes" xml:space="preserve">
          <source>Bound::borrow</source>
          <target state="translated">Bound::borrow</target>
        </trans-unit>
        <trans-unit id="18bb2e890d75080b556aef676184c5919be5992a" translate="yes" xml:space="preserve">
          <source>Bound::borrow_mut</source>
          <target state="translated">Bound::borrow_mut</target>
        </trans-unit>
        <trans-unit id="377e882cd7fc9a872bb54ce900229dd706dfc18e" translate="yes" xml:space="preserve">
          <source>Bound::clone</source>
          <target state="translated">Bound::clone</target>
        </trans-unit>
        <trans-unit id="27441f23a3225df9857b23126eebcbeaa6dcfa57" translate="yes" xml:space="preserve">
          <source>Bound::clone_from</source>
          <target state="translated">Bound::clone_from</target>
        </trans-unit>
        <trans-unit id="d4f69fa455be1a2d7f74f09dcf28628a95d81806" translate="yes" xml:space="preserve">
          <source>Bound::clone_into</source>
          <target state="translated">Bound::clone_into</target>
        </trans-unit>
        <trans-unit id="252db2d859de80913734f1d7a97d46b455067071" translate="yes" xml:space="preserve">
          <source>Bound::cloned</source>
          <target state="translated">Bound::cloned</target>
        </trans-unit>
        <trans-unit id="46c76647f9ac933b457df321f87cbafee078c04b" translate="yes" xml:space="preserve">
          <source>Bound::eq</source>
          <target state="translated">Bound::eq</target>
        </trans-unit>
        <trans-unit id="109b368628394a6771e9026bb249cb9a770aa495" translate="yes" xml:space="preserve">
          <source>Bound::fmt</source>
          <target state="translated">Bound::fmt</target>
        </trans-unit>
        <trans-unit id="d2a47e1914c25c25b3e40fc39fb12d33547d7e82" translate="yes" xml:space="preserve">
          <source>Bound::from</source>
          <target state="translated">Bound::from</target>
        </trans-unit>
        <trans-unit id="ba919ff9d1df1744fb627fa7855b8f05cc2b77ed" translate="yes" xml:space="preserve">
          <source>Bound::hash</source>
          <target state="translated">Bound::hash</target>
        </trans-unit>
        <trans-unit id="5a473f87e1bb852dc398c279b415db545cd4b24e" translate="yes" xml:space="preserve">
          <source>Bound::hash_slice</source>
          <target state="translated">Bound::hash_slice</target>
        </trans-unit>
        <trans-unit id="54778a9e486243aa16573515109523bbf492d0d1" translate="yes" xml:space="preserve">
          <source>Bound::into</source>
          <target state="translated">Bound::into</target>
        </trans-unit>
        <trans-unit id="dedfd5e96791c9889a42b174f98bd419bce5e68f" translate="yes" xml:space="preserve">
          <source>Bound::ne</source>
          <target state="translated">Bound::ne</target>
        </trans-unit>
        <trans-unit id="ab242a98c5b08c66ef7dc6a8a0cb34b4b2961e44" translate="yes" xml:space="preserve">
          <source>Bound::to_owned</source>
          <target state="translated">Bound::to_owned</target>
        </trans-unit>
        <trans-unit id="9a69c2090e4312fb09b145cc8cc6bd670302d586" translate="yes" xml:space="preserve">
          <source>Bound::try_from</source>
          <target state="translated">Bound::try_from</target>
        </trans-unit>
        <trans-unit id="763620a7caa5bb18601b6f9a97d64ddf732e2329" translate="yes" xml:space="preserve">
          <source>Bound::try_into</source>
          <target state="translated">Bound::try_into</target>
        </trans-unit>
        <trans-unit id="f370fdaa52e7ec335a260ab2d97b2ca401271f1b" translate="yes" xml:space="preserve">
          <source>Bound::type_id</source>
          <target state="translated">Bound::type_id</target>
        </trans-unit>
        <trans-unit id="c5964dba854ca10e309192dd054d46319ddd1bae" translate="yes" xml:space="preserve">
          <source>Bounds are constraints on a type or trait. For example, if a bound is placed on the argument a function takes, types passed to that function must abide by that constraint.</source>
          <target state="translated">Los límites son restricciones en un tipo o rasgo.Por ejemplo,si se coloca un límite en el argumento que toma una función,los tipos que se pasan a esa función deben respetar esa restricción.</target>
        </trans-unit>
        <trans-unit id="ca6bc4b3d93728fa4fe8f6d78ae36c82b188ed72" translate="yes" xml:space="preserve">
          <source>Bounds on an item must be satisfied when using the item. When type checking and borrow checking a generic item, the bounds can be used to determine that a trait is implemented for a type. For example, given &lt;code&gt;Ty: Trait&lt;/code&gt;</source>
          <target state="translated">Los l&amp;iacute;mites de un art&amp;iacute;culo deben cumplirse al usar el art&amp;iacute;culo. Cuando se verifica el tipo y se toma prestado un elemento gen&amp;eacute;rico, los l&amp;iacute;mites se pueden usar para determinar que se implementa un rasgo para un tipo. Por ejemplo, dado &lt;code&gt;Ty: Trait&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8db62bb4eebb31a7863a25492026fe5ef94ccb8d" translate="yes" xml:space="preserve">
          <source>Bounds that don't use the item's parameters or higher-ranked lifetimes are checked when the item is defined. It is an error for such a bound to be false.</source>
          <target state="translated">Los límites que no usan los parámetros del artículo o las vidas de mayor rango se comprueban cuando se define el artículo.Es un error que tal límite sea falso.</target>
        </trans-unit>
        <trans-unit id="4b064da5fe9593f583b40c21207783b175e1ebf2" translate="yes" xml:space="preserve">
          <source>Bounds written after declaring a &lt;a href=&quot;items/generics&quot;&gt;generic parameter&lt;/a&gt;: &lt;code&gt;fn f&amp;lt;A: Copy&amp;gt;() {}&lt;/code&gt; is the same as &lt;code&gt;fn f&amp;lt;A&amp;gt; where A: Copy () {}&lt;/code&gt;.</source>
          <target state="translated">L&amp;iacute;mites escritos despu&amp;eacute;s de declarar un &lt;a href=&quot;items/generics&quot;&gt;par&amp;aacute;metro gen&amp;eacute;rico&lt;/a&gt; : &lt;code&gt;fn f&amp;lt;A: Copy&amp;gt;() {}&lt;/code&gt; es lo mismo que &lt;code&gt;fn f&amp;lt;A&amp;gt; where A: Copy () {}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="239ca5767afac9641593464ce02bc454d6ac07a9" translate="yes" xml:space="preserve">
          <source>Box</source>
          <target state="translated">Box</target>
        </trans-unit>
        <trans-unit id="98f85596ae7b9b42504e10a1325d441abcd2486d" translate="yes" xml:space="preserve">
          <source>Box::all</source>
          <target state="translated">Box::all</target>
        </trans-unit>
        <trans-unit id="b639107f3271721c720775da7e802911f662b1b1" translate="yes" xml:space="preserve">
          <source>Box::any</source>
          <target state="translated">Box::any</target>
        </trans-unit>
        <trans-unit id="7c64d4849917073ddc48c9ebb00f360df4c9d7a4" translate="yes" xml:space="preserve">
          <source>Box::as_mut</source>
          <target state="translated">Box::as_mut</target>
        </trans-unit>
        <trans-unit id="6848e42541571d900c21f082d7585fb9168d4af7" translate="yes" xml:space="preserve">
          <source>Box::as_ref</source>
          <target state="translated">Box::as_ref</target>
        </trans-unit>
        <trans-unit id="6d56f42ac2a542e91194b361d21189ab4bd414b3" translate="yes" xml:space="preserve">
          <source>Box::borrow</source>
          <target state="translated">Box::borrow</target>
        </trans-unit>
        <trans-unit id="c99f2a149a7bc2bb960eba8eda77967bcecf0e8d" translate="yes" xml:space="preserve">
          <source>Box::borrow_mut</source>
          <target state="translated">Box::borrow_mut</target>
        </trans-unit>
        <trans-unit id="17f5075e3006cf9d119c727bb0e54e46c7eebaa6" translate="yes" xml:space="preserve">
          <source>Box::by_ref</source>
          <target state="translated">Box::by_ref</target>
        </trans-unit>
        <trans-unit id="61d60a2dfd95d2edba019ae7a505a5a8b6bad430" translate="yes" xml:space="preserve">
          <source>Box::bytes</source>
          <target state="translated">Box::bytes</target>
        </trans-unit>
        <trans-unit id="46fe884decfe5370e5c5fe2408915b53963bbffb" translate="yes" xml:space="preserve">
          <source>Box::call</source>
          <target state="translated">Box::call</target>
        </trans-unit>
        <trans-unit id="374988426e0ba138e6f583dbe0ce037ce343561c" translate="yes" xml:space="preserve">
          <source>Box::call_mut</source>
          <target state="translated">Box::call_mut</target>
        </trans-unit>
        <trans-unit id="221be09338afb54138c6ba69b6155871dd1f1604" translate="yes" xml:space="preserve">
          <source>Box::call_once</source>
          <target state="translated">Box::call_once</target>
        </trans-unit>
        <trans-unit id="212e1a3fbba385ceea9d2d039d37d904ae132bdd" translate="yes" xml:space="preserve">
          <source>Box::cause</source>
          <target state="translated">Box::cause</target>
        </trans-unit>
        <trans-unit id="1eb80191936cdac28f33c70fb0561232cbe1a0ce" translate="yes" xml:space="preserve">
          <source>Box::chain</source>
          <target state="translated">Box::chain</target>
        </trans-unit>
        <trans-unit id="9a890655e788211db3d21c5daf10e4fa6bedbf64" translate="yes" xml:space="preserve">
          <source>Box::clamp</source>
          <target state="translated">Box::clamp</target>
        </trans-unit>
        <trans-unit id="332b16f27092792c1ac7aba3b13ed4a2b647f865" translate="yes" xml:space="preserve">
          <source>Box::clone</source>
          <target state="translated">Box::clone</target>
        </trans-unit>
        <trans-unit id="0511825945441353f0c46a388bf94987ad6afb32" translate="yes" xml:space="preserve">
          <source>Box::clone_from</source>
          <target state="translated">Box::clone_from</target>
        </trans-unit>
        <trans-unit id="df3fac12d073e919e309cdc2ac6374e292180e78" translate="yes" xml:space="preserve">
          <source>Box::clone_into</source>
          <target state="translated">Box::clone_into</target>
        </trans-unit>
        <trans-unit id="6e363e6d0300a78f70074a806f60975e864accad" translate="yes" xml:space="preserve">
          <source>Box::cloned</source>
          <target state="translated">Box::cloned</target>
        </trans-unit>
        <trans-unit id="6c96b7576d584aee2f26ba1a32a3f04121f43e20" translate="yes" xml:space="preserve">
          <source>Box::cmp</source>
          <target state="translated">Box::cmp</target>
        </trans-unit>
        <trans-unit id="eeef833143ebcf0bc697aec2eefdc455624f9e0d" translate="yes" xml:space="preserve">
          <source>Box::collect</source>
          <target state="translated">Box::collect</target>
        </trans-unit>
        <trans-unit id="3d0f23afd6563472c47a167b48b8410fc559e492" translate="yes" xml:space="preserve">
          <source>Box::consume</source>
          <target state="translated">Box::consume</target>
        </trans-unit>
        <trans-unit id="44105eeec746662536d53672c3fb78098daee296" translate="yes" xml:space="preserve">
          <source>Box::copied</source>
          <target state="translated">Box::copied</target>
        </trans-unit>
        <trans-unit id="7ad1e95ce02daa64c1eaef18f06b9d8a7b568791" translate="yes" xml:space="preserve">
          <source>Box::count</source>
          <target state="translated">Box::count</target>
        </trans-unit>
        <trans-unit id="63ba5f4100a0be0c367e10e279bbb76a90044076" translate="yes" xml:space="preserve">
          <source>Box::cycle</source>
          <target state="translated">Box::cycle</target>
        </trans-unit>
        <trans-unit id="3100809b3c22540251ee4d32f870f0ab5d85f812" translate="yes" xml:space="preserve">
          <source>Box::default</source>
          <target state="translated">Box::default</target>
        </trans-unit>
        <trans-unit id="d2afb24813ad916ee3f3c876745772187d20e4b6" translate="yes" xml:space="preserve">
          <source>Box::deref</source>
          <target state="translated">Box::deref</target>
        </trans-unit>
        <trans-unit id="c38310d47b15e572611b4edc0c34463c00ac8351" translate="yes" xml:space="preserve">
          <source>Box::deref_mut</source>
          <target state="translated">Box::deref_mut</target>
        </trans-unit>
        <trans-unit id="4407e689e2360934dc281ec09f440aa221be5ae6" translate="yes" xml:space="preserve">
          <source>Box::description</source>
          <target state="translated">Box::description</target>
        </trans-unit>
        <trans-unit id="3166dd8642b65175a3bd7c7a52199fb715fe0594" translate="yes" xml:space="preserve">
          <source>Box::downcast</source>
          <target state="translated">Box::downcast</target>
        </trans-unit>
        <trans-unit id="daa5d80c59542cc920cd455f7d64b23c983bc609" translate="yes" xml:space="preserve">
          <source>Box::drop</source>
          <target state="translated">Box::drop</target>
        </trans-unit>
        <trans-unit id="1ce09716c9c1deae7f81c32dcf52fa616b12ca02" translate="yes" xml:space="preserve">
          <source>Box::enumerate</source>
          <target state="translated">Box::enumerate</target>
        </trans-unit>
        <trans-unit id="6cf03ef281bd05acc9e8788a558b01545153452e" translate="yes" xml:space="preserve">
          <source>Box::eq</source>
          <target state="translated">Box::eq</target>
        </trans-unit>
        <trans-unit id="4d3c429c86bcb5b6eb5c6bb097bc1d76c3b6d725" translate="yes" xml:space="preserve">
          <source>Box::fill_buf</source>
          <target state="translated">Box::fill_buf</target>
        </trans-unit>
        <trans-unit id="e0cfe090654acd2813dda2cadb04ff611bd40f8c" translate="yes" xml:space="preserve">
          <source>Box::filter</source>
          <target state="translated">Box::filter</target>
        </trans-unit>
        <trans-unit id="883f1c107d0f7a023ce3ace96cd45f32b3a24f77" translate="yes" xml:space="preserve">
          <source>Box::filter_map</source>
          <target state="translated">Box::filter_map</target>
        </trans-unit>
        <trans-unit id="8dba1be2d1b661c2a19ed51cf35f61687ebb811c" translate="yes" xml:space="preserve">
          <source>Box::find</source>
          <target state="translated">Box::find</target>
        </trans-unit>
        <trans-unit id="f1e4c766b00488cdb2e145cf4a27a074f88b9608" translate="yes" xml:space="preserve">
          <source>Box::find_map</source>
          <target state="translated">Box::find_map</target>
        </trans-unit>
        <trans-unit id="c5e9fddfd660282ca666cc6d744b46cd9a98281c" translate="yes" xml:space="preserve">
          <source>Box::finish</source>
          <target state="translated">Box::finish</target>
        </trans-unit>
        <trans-unit id="7698c71e0db1c73d3407ac25452c69edf519bc43" translate="yes" xml:space="preserve">
          <source>Box::flat_map</source>
          <target state="translated">Box::flat_map</target>
        </trans-unit>
        <trans-unit id="59e78e2254012fa056fb63d3af090ff23d9caa18" translate="yes" xml:space="preserve">
          <source>Box::flatten</source>
          <target state="translated">Box::flatten</target>
        </trans-unit>
        <trans-unit id="a6f7e58af02021c1636cef25915365d21c74a8a2" translate="yes" xml:space="preserve">
          <source>Box::flush</source>
          <target state="translated">Box::flush</target>
        </trans-unit>
        <trans-unit id="c6784df312e8ae8f90011ca22e8d36adb66a847a" translate="yes" xml:space="preserve">
          <source>Box::fmt</source>
          <target state="translated">Box::fmt</target>
        </trans-unit>
        <trans-unit id="fddbdef17bce1a8df59157b8fd1db42560d5f3ee" translate="yes" xml:space="preserve">
          <source>Box::fold</source>
          <target state="translated">Box::fold</target>
        </trans-unit>
        <trans-unit id="0a52ad01f142af48e3794dd7e59fc9bc3c7aa5d4" translate="yes" xml:space="preserve">
          <source>Box::for_each</source>
          <target state="translated">Box::for_each</target>
        </trans-unit>
        <trans-unit id="ed62e9121c4c62c0d5ce944ae44d5048012950db" translate="yes" xml:space="preserve">
          <source>Box::from</source>
          <target state="translated">Box::from</target>
        </trans-unit>
        <trans-unit id="91aab981ee80cfea73883f72f3f4a7df87328afd" translate="yes" xml:space="preserve">
          <source>Box::from_iter</source>
          <target state="translated">Box::from_iter</target>
        </trans-unit>
        <trans-unit id="99a56fd56f3eda7092816760238ede7c3fa6109f" translate="yes" xml:space="preserve">
          <source>Box::from_raw</source>
          <target state="translated">Box::from_raw</target>
        </trans-unit>
        <trans-unit id="10348aa1512f4c519b5613b846a2d8d6cfc47b88" translate="yes" xml:space="preserve">
          <source>Box::fuse</source>
          <target state="translated">Box::fuse</target>
        </trans-unit>
        <trans-unit id="530d37fa415cfa7c32ec4b55571698e45da6f959" translate="yes" xml:space="preserve">
          <source>Box::ge</source>
          <target state="translated">Box::ge</target>
        </trans-unit>
        <trans-unit id="4b72a4352f4fe91f47f069cdabc6e6ad95f13b44" translate="yes" xml:space="preserve">
          <source>Box::gt</source>
          <target state="translated">Box::gt</target>
        </trans-unit>
        <trans-unit id="16c6635f4bb22fdb3cea4763415a3155c214ed75" translate="yes" xml:space="preserve">
          <source>Box::hash</source>
          <target state="translated">Box::hash</target>
        </trans-unit>
        <trans-unit id="4c2a4b460b5d8fc9bdda66cc71714fbab479852a" translate="yes" xml:space="preserve">
          <source>Box::hash_slice</source>
          <target state="translated">Box::hash_slice</target>
        </trans-unit>
        <trans-unit id="343ef75a47ac9840e34ddf7a2da0d02c25787582" translate="yes" xml:space="preserve">
          <source>Box::initializer</source>
          <target state="translated">Box::initializer</target>
        </trans-unit>
        <trans-unit id="63ff0ff3838d20603f1ee804508fc3e64e303af2" translate="yes" xml:space="preserve">
          <source>Box::inspect</source>
          <target state="translated">Box::inspect</target>
        </trans-unit>
        <trans-unit id="85607e14d6de81746b803858c2540ca8c6b44bdb" translate="yes" xml:space="preserve">
          <source>Box::into</source>
          <target state="translated">Box::into</target>
        </trans-unit>
        <trans-unit id="f6b1af13daabe54761e736d7c80500ab6b9a1674" translate="yes" xml:space="preserve">
          <source>Box::into_iter</source>
          <target state="translated">Box::into_iter</target>
        </trans-unit>
        <trans-unit id="acbaecb1989ceef80f562e795d009f33656980ca" translate="yes" xml:space="preserve">
          <source>Box::into_pin</source>
          <target state="translated">Box::into_pin</target>
        </trans-unit>
        <trans-unit id="4842429f228dc17504f648e08a5f4f16e0e2062a" translate="yes" xml:space="preserve">
          <source>Box::into_raw</source>
          <target state="translated">Box::into_raw</target>
        </trans-unit>
        <trans-unit id="3f79bc4ecb72c296f646e58c0e20ae529797f781" translate="yes" xml:space="preserve">
          <source>Box::into_raw_non_null</source>
          <target state="translated">Box::into_raw_non_null</target>
        </trans-unit>
        <trans-unit id="3614510072231db3137f0d7aeb928f934f1c493d" translate="yes" xml:space="preserve">
          <source>Box::into_searcher</source>
          <target state="translated">Box::into_searcher</target>
        </trans-unit>
        <trans-unit id="2a8c6b52f333bc0cef92fffa23a800dc8255b691" translate="yes" xml:space="preserve">
          <source>Box::is_contained_in</source>
          <target state="translated">Box::is_contained_in</target>
        </trans-unit>
        <trans-unit id="6f2c2c3465fb0d25bc14172b3cdf438dd8946893" translate="yes" xml:space="preserve">
          <source>Box::is_empty</source>
          <target state="translated">Box::is_empty</target>
        </trans-unit>
        <trans-unit id="5ce85dca8b5589117e52c9eb46ed6631b186778a" translate="yes" xml:space="preserve">
          <source>Box::is_prefix_of</source>
          <target state="translated">Box::is_prefix_of</target>
        </trans-unit>
        <trans-unit id="b2d0a3538bcce4d4341580322555cb175af9e055" translate="yes" xml:space="preserve">
          <source>Box::is_sorted</source>
          <target state="translated">Box::is_sorted</target>
        </trans-unit>
        <trans-unit id="e8bc76461809058c2bf78bd03616e55f959cee1e" translate="yes" xml:space="preserve">
          <source>Box::is_sorted_by</source>
          <target state="translated">Box::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="0a88b0e90b45af6841206b9222039635add3e64f" translate="yes" xml:space="preserve">
          <source>Box::is_sorted_by_key</source>
          <target state="translated">Box::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="a72dc555efdbfa80a6b0d5c0b4f285602f05c856" translate="yes" xml:space="preserve">
          <source>Box::is_suffix_of</source>
          <target state="translated">Box::is_suffix_of</target>
        </trans-unit>
        <trans-unit id="e5727693a6c4cd3248cc40c999eef24607bc94c4" translate="yes" xml:space="preserve">
          <source>Box::last</source>
          <target state="translated">Box::last</target>
        </trans-unit>
        <trans-unit id="d894e0ab37daa6ed36ffcb6dc6f6ae6feafe4d29" translate="yes" xml:space="preserve">
          <source>Box::le</source>
          <target state="translated">Box::le</target>
        </trans-unit>
        <trans-unit id="bb0f72b159e3eafd1c056e394655cd200d490416" translate="yes" xml:space="preserve">
          <source>Box::leak</source>
          <target state="translated">Box::leak</target>
        </trans-unit>
        <trans-unit id="d677d8cc4fbf16dda95f7cc9f6f227fc9bf5458e" translate="yes" xml:space="preserve">
          <source>Box::len</source>
          <target state="translated">Box::len</target>
        </trans-unit>
        <trans-unit id="45bad95b762a8b026bd24017358dab88a4d6860e" translate="yes" xml:space="preserve">
          <source>Box::lines</source>
          <target state="translated">Box::lines</target>
        </trans-unit>
        <trans-unit id="72b25c9787fb55646beeb56c75cec4a153ebed4b" translate="yes" xml:space="preserve">
          <source>Box::lt</source>
          <target state="translated">Box::lt</target>
        </trans-unit>
        <trans-unit id="f2618ca0d7141ef535495cca35bfb5aa17708bc5" translate="yes" xml:space="preserve">
          <source>Box::map</source>
          <target state="translated">Box::map</target>
        </trans-unit>
        <trans-unit id="0bc41a6cab2d616f4a773cadf7a4a0287ec2ab6e" translate="yes" xml:space="preserve">
          <source>Box::max</source>
          <target state="translated">Box::max</target>
        </trans-unit>
        <trans-unit id="b5a62311ec4389dcea655a4a653acc770ae70df8" translate="yes" xml:space="preserve">
          <source>Box::max_by</source>
          <target state="translated">Box::max_by</target>
        </trans-unit>
        <trans-unit id="d0583d8c8a9191551534a635b566f913b18db0e0" translate="yes" xml:space="preserve">
          <source>Box::max_by_key</source>
          <target state="translated">Box::max_by_key</target>
        </trans-unit>
        <trans-unit id="5516ccddf3095fdf20b85d48497a76f13db9f3ab" translate="yes" xml:space="preserve">
          <source>Box::min</source>
          <target state="translated">Box::min</target>
        </trans-unit>
        <trans-unit id="57731c7eaf53528b46c94a8f5b04067977541b8e" translate="yes" xml:space="preserve">
          <source>Box::min_by</source>
          <target state="translated">Box::min_by</target>
        </trans-unit>
        <trans-unit id="5e6b2f4822e5c3d83d1318a14c7f1a3668b8120b" translate="yes" xml:space="preserve">
          <source>Box::min_by_key</source>
          <target state="translated">Box::min_by_key</target>
        </trans-unit>
        <trans-unit id="4df5d8b53f02075451eb004c4d2840a8ab301c06" translate="yes" xml:space="preserve">
          <source>Box::ne</source>
          <target state="translated">Box::ne</target>
        </trans-unit>
        <trans-unit id="1cb94d98d7b75dacb7e7e360644f9c7e2642829f" translate="yes" xml:space="preserve">
          <source>Box::new</source>
          <target state="translated">Box::new</target>
        </trans-unit>
        <trans-unit id="773581cb76ebc7fffb4b726bb7032d772321f18e" translate="yes" xml:space="preserve">
          <source>Box::next</source>
          <target state="translated">Box::next</target>
        </trans-unit>
        <trans-unit id="39a9d8e0d1ae73478ca6c4fc28570233d4f2d14d" translate="yes" xml:space="preserve">
          <source>Box::next_back</source>
          <target state="translated">Box::next_back</target>
        </trans-unit>
        <trans-unit id="ca8b4b8a75b7ab2fc6b63b0e3e0d3d3ac349fcbc" translate="yes" xml:space="preserve">
          <source>Box::nth</source>
          <target state="translated">Box::nth</target>
        </trans-unit>
        <trans-unit id="be1768702f171a2bca631f2dada36573e66e8f4c" translate="yes" xml:space="preserve">
          <source>Box::nth_back</source>
          <target state="translated">Box::nth_back</target>
        </trans-unit>
        <trans-unit id="33b92276543ebbb381ab00cfcca61326250e018b" translate="yes" xml:space="preserve">
          <source>Box::partial_cmp</source>
          <target state="translated">Box::partial_cmp</target>
        </trans-unit>
        <trans-unit id="5b3f3a9486d3aeafde57fba826b8530482d99578" translate="yes" xml:space="preserve">
          <source>Box::partition</source>
          <target state="translated">Box::partition</target>
        </trans-unit>
        <trans-unit id="25aab183ce8da5ce9aed71f8d43b59e269353ccd" translate="yes" xml:space="preserve">
          <source>Box::peekable</source>
          <target state="translated">Box::peekable</target>
        </trans-unit>
        <trans-unit id="7019628ce869ea317ecd4415266260c422269408" translate="yes" xml:space="preserve">
          <source>Box::pin</source>
          <target state="translated">Box::pin</target>
        </trans-unit>
        <trans-unit id="a64f04fc6eed8dea5f38347397b9cc737e345f6e" translate="yes" xml:space="preserve">
          <source>Box::poll</source>
          <target state="translated">Box::poll</target>
        </trans-unit>
        <trans-unit id="66f2f092e4949c0626ea7b22dc1d4ebcf3d8b35e" translate="yes" xml:space="preserve">
          <source>Box::position</source>
          <target state="translated">Box::position</target>
        </trans-unit>
        <trans-unit id="57081d934e6bca1d6c19e21b481ef88439c1ee29" translate="yes" xml:space="preserve">
          <source>Box::product</source>
          <target state="translated">Box::product</target>
        </trans-unit>
        <trans-unit id="ea6a41b1734b82596faa66a349b6d33c1eda5c8d" translate="yes" xml:space="preserve">
          <source>Box::read</source>
          <target state="translated">Box::read</target>
        </trans-unit>
        <trans-unit id="69cd72a2d8a6222800a925198c4edf4f739e25b2" translate="yes" xml:space="preserve">
          <source>Box::read_exact</source>
          <target state="translated">Box::read_exact</target>
        </trans-unit>
        <trans-unit id="59c4bf761ac478484370f960e729c2e181694f6b" translate="yes" xml:space="preserve">
          <source>Box::read_line</source>
          <target state="translated">Box::read_line</target>
        </trans-unit>
        <trans-unit id="225ac79c4a0e4ea7979de019038d83deebd58806" translate="yes" xml:space="preserve">
          <source>Box::read_to_end</source>
          <target state="translated">Box::read_to_end</target>
        </trans-unit>
        <trans-unit id="205cd1994c8e50578c7806614a239f1080cfe645" translate="yes" xml:space="preserve">
          <source>Box::read_to_string</source>
          <target state="translated">Box::read_to_string</target>
        </trans-unit>
        <trans-unit id="4c38943094e12187cb5a7db1759bb984e9e47e21" translate="yes" xml:space="preserve">
          <source>Box::read_until</source>
          <target state="translated">Box::read_until</target>
        </trans-unit>
        <trans-unit id="16e2f9a63976d963a9dadcb35033a821c2fd7839" translate="yes" xml:space="preserve">
          <source>Box::read_vectored</source>
          <target state="translated">Box::read_vectored</target>
        </trans-unit>
        <trans-unit id="be7cce92911dcff76ffbac8e0427e42b77defdcf" translate="yes" xml:space="preserve">
          <source>Box::resume</source>
          <target state="translated">Box::resume</target>
        </trans-unit>
        <trans-unit id="ba5e0dd2c587258859a5333578ab5d32da0e967a" translate="yes" xml:space="preserve">
          <source>Box::rev</source>
          <target state="translated">Box::rev</target>
        </trans-unit>
        <trans-unit id="481e8d3053595c86bd37ed7ee98159dd62804d15" translate="yes" xml:space="preserve">
          <source>Box::rfind</source>
          <target state="translated">Box::rfind</target>
        </trans-unit>
        <trans-unit id="54e7ee564e103a781122b5dcc4e5a645a42b47bd" translate="yes" xml:space="preserve">
          <source>Box::rfold</source>
          <target state="translated">Box::rfold</target>
        </trans-unit>
        <trans-unit id="3a8d8f3503f8d9c26ee23ddbea5e59c9d42ec95c" translate="yes" xml:space="preserve">
          <source>Box::rposition</source>
          <target state="translated">Box::rposition</target>
        </trans-unit>
        <trans-unit id="9ac7a2e2ffe1a294d38f090349bc38f76aec74fc" translate="yes" xml:space="preserve">
          <source>Box::scan</source>
          <target state="translated">Box::scan</target>
        </trans-unit>
        <trans-unit id="96b0a5023a90b5ef63be3a93fee81259968341fc" translate="yes" xml:space="preserve">
          <source>Box::seek</source>
          <target state="translated">Box::seek</target>
        </trans-unit>
        <trans-unit id="74f4a9a8cd31d8cee51b7c80648f8274c91f190c" translate="yes" xml:space="preserve">
          <source>Box::size_hint</source>
          <target state="translated">Box::size_hint</target>
        </trans-unit>
        <trans-unit id="d72a34eac3284a3b3a67c2581cf2c305c16367ed" translate="yes" xml:space="preserve">
          <source>Box::skip</source>
          <target state="translated">Box::skip</target>
        </trans-unit>
        <trans-unit id="ba0e0743f07d0bf5ee26ccb3b8bb456ca5c70a56" translate="yes" xml:space="preserve">
          <source>Box::skip_while</source>
          <target state="translated">Box::skip_while</target>
        </trans-unit>
        <trans-unit id="b4722d8b75a76a5d774eca59914b8e1f4a48cca6" translate="yes" xml:space="preserve">
          <source>Box::source</source>
          <target state="translated">Box::source</target>
        </trans-unit>
        <trans-unit id="6e2bc46519fb279c9f87dbfe9d290154772983d7" translate="yes" xml:space="preserve">
          <source>Box::split</source>
          <target state="translated">Box::split</target>
        </trans-unit>
        <trans-unit id="225ff95675533f61ead8e887a7efbf592dd8a88f" translate="yes" xml:space="preserve">
          <source>Box::step_by</source>
          <target state="translated">Box::step_by</target>
        </trans-unit>
        <trans-unit id="33aa1522a0173cb9f96a98672c2ecf9a96e294c9" translate="yes" xml:space="preserve">
          <source>Box::stream_len</source>
          <target state="translated">Box::stream_len</target>
        </trans-unit>
        <trans-unit id="8371eaea74f952c9831c9ca9261a497c2c38eef9" translate="yes" xml:space="preserve">
          <source>Box::stream_position</source>
          <target state="translated">Box::stream_position</target>
        </trans-unit>
        <trans-unit id="6a478949bfaddf9def7439c2f20d3359d537230c" translate="yes" xml:space="preserve">
          <source>Box::sum</source>
          <target state="translated">Box::sum</target>
        </trans-unit>
        <trans-unit id="3c2abaa93fcb6bfd17a1261c06f7ff566f12ec7e" translate="yes" xml:space="preserve">
          <source>Box::take</source>
          <target state="translated">Box::take</target>
        </trans-unit>
        <trans-unit id="83963a222e9c0ad7e60f41957e4013159d79d919" translate="yes" xml:space="preserve">
          <source>Box::take_while</source>
          <target state="translated">Box::take_while</target>
        </trans-unit>
        <trans-unit id="97ebc881815c3d1efcf8d9cc64f80490df826bb5" translate="yes" xml:space="preserve">
          <source>Box::to_owned</source>
          <target state="translated">Box::to_owned</target>
        </trans-unit>
        <trans-unit id="e508f4dc0d39c5987210d26aebaa3c2b4fce966c" translate="yes" xml:space="preserve">
          <source>Box::to_string</source>
          <target state="translated">Box::to_string</target>
        </trans-unit>
        <trans-unit id="34d3b2ca86670782e3636c41900e981e1db73054" translate="yes" xml:space="preserve">
          <source>Box::try_fold</source>
          <target state="translated">Box::try_fold</target>
        </trans-unit>
        <trans-unit id="4db298c22768eb776696c78cedb8c0ae9382c043" translate="yes" xml:space="preserve">
          <source>Box::try_for_each</source>
          <target state="translated">Box::try_for_each</target>
        </trans-unit>
        <trans-unit id="7ac87b84f99e12af4f84963a001dac862d957033" translate="yes" xml:space="preserve">
          <source>Box::try_from</source>
          <target state="translated">Box::try_from</target>
        </trans-unit>
        <trans-unit id="1190ad3065eb03769687c99bebeafccd52070617" translate="yes" xml:space="preserve">
          <source>Box::try_into</source>
          <target state="translated">Box::try_into</target>
        </trans-unit>
        <trans-unit id="190b967a40f310701525c6f92772eaa4b9d2bd91" translate="yes" xml:space="preserve">
          <source>Box::try_rfold</source>
          <target state="translated">Box::try_rfold</target>
        </trans-unit>
        <trans-unit id="e36c00466fad6adf381b361fedd323c0c0614989" translate="yes" xml:space="preserve">
          <source>Box::type_id</source>
          <target state="translated">Box::type_id</target>
        </trans-unit>
        <trans-unit id="04ea83b7ee01a03b421cd55b0df6992834e06afd" translate="yes" xml:space="preserve">
          <source>Box::unzip</source>
          <target state="translated">Box::unzip</target>
        </trans-unit>
        <trans-unit id="f72865295b955292507dfb70d5c51051dce354f9" translate="yes" xml:space="preserve">
          <source>Box::write</source>
          <target state="translated">Box::write</target>
        </trans-unit>
        <trans-unit id="a94c15e5cef594b7628ec618df5db798a9a567ec" translate="yes" xml:space="preserve">
          <source>Box::write_all</source>
          <target state="translated">Box::write_all</target>
        </trans-unit>
        <trans-unit id="d6fe1ce7bcfe4c269caf62f37074c2cd561a9897" translate="yes" xml:space="preserve">
          <source>Box::write_fmt</source>
          <target state="translated">Box::write_fmt</target>
        </trans-unit>
        <trans-unit id="56912c1495209bdea8854c66cc01bcdf4719afb0" translate="yes" xml:space="preserve">
          <source>Box::write_i128</source>
          <target state="translated">Box::write_i128</target>
        </trans-unit>
        <trans-unit id="d8e0c426cff723fe078d8e082d1a63933f6fa573" translate="yes" xml:space="preserve">
          <source>Box::write_i16</source>
          <target state="translated">Box::write_i16</target>
        </trans-unit>
        <trans-unit id="b68b48a66507e48ff6196e7556e4456e2d325cec" translate="yes" xml:space="preserve">
          <source>Box::write_i32</source>
          <target state="translated">Box::write_i32</target>
        </trans-unit>
        <trans-unit id="1e11f9892c3582d233d19c49b718f4eb56d5716f" translate="yes" xml:space="preserve">
          <source>Box::write_i64</source>
          <target state="translated">Box::write_i64</target>
        </trans-unit>
        <trans-unit id="2c4fbd1565526cebde3d781e65ee574490c3d5c4" translate="yes" xml:space="preserve">
          <source>Box::write_i8</source>
          <target state="translated">Box::write_i8</target>
        </trans-unit>
        <trans-unit id="be62022bb4b9817d94a1db6940ba1ef163a6bd39" translate="yes" xml:space="preserve">
          <source>Box::write_isize</source>
          <target state="translated">Box::write_isize</target>
        </trans-unit>
        <trans-unit id="2096d69d1a029ab28f266f5d6155819f93d05482" translate="yes" xml:space="preserve">
          <source>Box::write_u128</source>
          <target state="translated">Box::write_u128</target>
        </trans-unit>
        <trans-unit id="4bae89c6a373e3f8634ed54d131ceda19618fee5" translate="yes" xml:space="preserve">
          <source>Box::write_u16</source>
          <target state="translated">Box::write_u16</target>
        </trans-unit>
        <trans-unit id="71e4bac27351110d97b5fef0556d35917fbefb90" translate="yes" xml:space="preserve">
          <source>Box::write_u32</source>
          <target state="translated">Box::write_u32</target>
        </trans-unit>
        <trans-unit id="5abd678e805a3ff64f5524701426655948efcbfa" translate="yes" xml:space="preserve">
          <source>Box::write_u64</source>
          <target state="translated">Box::write_u64</target>
        </trans-unit>
        <trans-unit id="cf853a1d87ba811daf4dddf980c6bca3ee9f7551" translate="yes" xml:space="preserve">
          <source>Box::write_u8</source>
          <target state="translated">Box::write_u8</target>
        </trans-unit>
        <trans-unit id="570c96fc9a4d7852a96d0f8be3123d2af8641252" translate="yes" xml:space="preserve">
          <source>Box::write_usize</source>
          <target state="translated">Box::write_usize</target>
        </trans-unit>
        <trans-unit id="8c5f38686db9dd2e3d3338655cf9aa7453b4beec" translate="yes" xml:space="preserve">
          <source>Box::write_vectored</source>
          <target state="translated">Box::write_vectored</target>
        </trans-unit>
        <trans-unit id="58b9235154ec59648f9006bdb375b1a70414fdbc" translate="yes" xml:space="preserve">
          <source>Box::zip</source>
          <target state="translated">Box::zip</target>
        </trans-unit>
        <trans-unit id="1f1c95cf9dbdc5a10d4adddb4bd7ed9693d03299" translate="yes" xml:space="preserve">
          <source>Boxes don&amp;rsquo;t have performance overhead, other than storing their data on the heap instead of on the stack. But they don&amp;rsquo;t have many extra capabilities either. You&amp;rsquo;ll use them most often in these situations:</source>
          <target state="translated">Las cajas no tienen una sobrecarga de rendimiento, aparte de almacenar sus datos en el mont&amp;oacute;n en lugar de en la pila. Pero tampoco tienen muchas capacidades adicionales. Los usar&amp;aacute; con m&amp;aacute;s frecuencia en estas situaciones:</target>
        </trans-unit>
        <trans-unit id="aae55045560cd96320cd77d712fdc24ac8ab83dc" translate="yes" xml:space="preserve">
          <source>Boxes provide only the indirection and heap allocation; they don&amp;rsquo;t have any other special capabilities, like those we&amp;rsquo;ll see with the other smart pointer types. They also don&amp;rsquo;t have any performance overhead that these special capabilities incur, so they can be useful in cases like the cons list where the indirection is the only feature we need. We&amp;rsquo;ll look at more use cases for boxes in Chapter 17, too.</source>
          <target state="translated">Los cuadros proporcionan s&amp;oacute;lo la asignaci&amp;oacute;n indirecta y de pila; no tienen otras capacidades especiales, como las que veremos con los otros tipos de punteros inteligentes. Tampoco tienen ninguna sobrecarga de rendimiento en la que incurren estas capacidades especiales, por lo que pueden ser &amp;uacute;tiles en casos como la lista de contras, donde la indirecci&amp;oacute;n es la &amp;uacute;nica caracter&amp;iacute;stica que necesitamos. Tambi&amp;eacute;n veremos m&amp;aacute;s casos de uso de cajas en el Cap&amp;iacute;tulo 17.</target>
        </trans-unit>
        <trans-unit id="e42a1e70b4003a66462fd8b1b6f1d551425eedd6" translate="yes" xml:space="preserve">
          <source>Bracket</source>
          <target state="translated">Bracket</target>
        </trans-unit>
        <trans-unit id="acb83a12e9c51df23e23f19306bba0bcb0739442" translate="yes" xml:space="preserve">
          <source>Bracket punctuation is used in various parts of the grammar. An open bracket must always be paired with a close bracket. Brackets and the tokens within them are referred to as &quot;token trees&quot; in &lt;a href=&quot;macros-by-example&quot;&gt;macros&lt;/a&gt;. The three types of brackets are:</source>
          <target state="translated">La puntuaci&amp;oacute;n entre corchetes se utiliza en varias partes de la gram&amp;aacute;tica. Un soporte abierto siempre debe combinarse con un soporte cerrado. Los corchetes y los tokens dentro de ellos se denominan &quot;&amp;aacute;rboles de tokens&quot; en las &lt;a href=&quot;macros-by-example&quot;&gt;macros&lt;/a&gt; . Los tres tipos de soportes son:</target>
        </trans-unit>
        <trans-unit id="4a3ba41cdc1bb875b6f34a0f7504f134b4c82482" translate="yes" xml:space="preserve">
          <source>Breaking cycles with &lt;code&gt;Weak&lt;/code&gt;</source>
          <target state="translated">Rompiendo ciclos con &lt;code&gt;Weak&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d3dfd81f5eef2bda69d2fe0e0bb117502ea1d295" translate="yes" xml:space="preserve">
          <source>Breaking the &lt;a href=&quot;http://llvm.org/docs/LangRef.html#pointer-aliasing-rules&quot;&gt;pointer aliasing rules&lt;/a&gt; on accesses through raw pointers; a subset of the rules used by C.</source>
          <target state="translated">Romper las &lt;a href=&quot;http://llvm.org/docs/LangRef.html#pointer-aliasing-rules&quot;&gt;reglas de alias de punteros&lt;/a&gt; en accesos a trav&amp;eacute;s de punteros sin formato; un subconjunto de las reglas utilizadas por C.</target>
        </trans-unit>
        <trans-unit id="f28978f6dd2c2e9099f5d850ca4e0176d065b5c7" translate="yes" xml:space="preserve">
          <source>Breaking the &lt;a href=&quot;http://llvm.org/docs/LangRef.html#pointer-aliasing-rules&quot;&gt;pointer aliasing rules&lt;/a&gt;. &lt;code&gt;&amp;amp;mut T&lt;/code&gt; and &lt;code&gt;&amp;amp;T&lt;/code&gt; follow LLVM&amp;rsquo;s scoped &lt;a href=&quot;http://llvm.org/docs/LangRef.html#noalias&quot;&gt;noalias&lt;/a&gt; model, except if the &lt;code&gt;&amp;amp;T&lt;/code&gt; contains an &lt;a href=&quot;../std/cell/struct.unsafecell&quot;&gt;&lt;code&gt;UnsafeCell&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d59f171a0fa025c3f69ece6ee2db2dff781f37b" translate="yes" xml:space="preserve">
          <source>Breaking the &lt;a href=&quot;https://llvm.org/docs/LangRef.html#pointer-aliasing-rules&quot;&gt;pointer aliasing rules&lt;/a&gt;. &lt;code&gt;&amp;amp;mut T&lt;/code&gt; and &lt;code&gt;&amp;amp;T&lt;/code&gt; follow LLVM&amp;rsquo;s scoped &lt;a href=&quot;https://llvm.org/docs/LangRef.html#noalias&quot;&gt;noalias&lt;/a&gt; model, except if the &lt;code&gt;&amp;amp;T&lt;/code&gt; contains an &lt;a href=&quot;../std/cell/struct.unsafecell&quot;&gt;&lt;code&gt;UnsafeCell&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a02e7efbe4ea860996a720e8eb0268c763977ce" translate="yes" xml:space="preserve">
          <source>Bringing Paths into Scope with the &lt;code id=&quot;bringing-paths-into-scope-with-the-use-keyword&quot;&gt;use&lt;/code&gt; Keyword</source>
          <target state="translated">Llevando rutas al alcance con la palabra clave &lt;code id=&quot;bringing-paths-into-scope-with-the-use-keyword&quot;&gt;use&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="de407e52f1ad71f30175ca74f0b3e4d7802969ce" translate="yes" xml:space="preserve">
          <source>BufRead</source>
          <target state="translated">BufRead</target>
        </trans-unit>
        <trans-unit id="8b3cd1796576fb8d47f83bdc75d05d245fd7a0c8" translate="yes" xml:space="preserve">
          <source>BufRead::consume</source>
          <target state="translated">BufRead::consume</target>
        </trans-unit>
        <trans-unit id="4d60e62622ce6e5b2975982fde7166d4b99157d4" translate="yes" xml:space="preserve">
          <source>BufRead::fill_buf</source>
          <target state="translated">BufRead::fill_buf</target>
        </trans-unit>
        <trans-unit id="6454a42afc6b7f969ba1e20a170de8e3b928a4de" translate="yes" xml:space="preserve">
          <source>BufRead::lines</source>
          <target state="translated">BufRead::lines</target>
        </trans-unit>
        <trans-unit id="a22b5e33039f43dd9be253a22ba693c7821fc40d" translate="yes" xml:space="preserve">
          <source>BufRead::read_line</source>
          <target state="translated">BufRead::read_line</target>
        </trans-unit>
        <trans-unit id="138f0ef5dd5df09e1375e2687113f694b0a114b9" translate="yes" xml:space="preserve">
          <source>BufRead::read_until</source>
          <target state="translated">BufRead::read_until</target>
        </trans-unit>
        <trans-unit id="afb4634d5bb2cfba4eca69e0cbaed77038a91269" translate="yes" xml:space="preserve">
          <source>BufRead::split</source>
          <target state="translated">BufRead::split</target>
        </trans-unit>
        <trans-unit id="232d94f57b3293280b5ad36975b73111f3c6dfa0" translate="yes" xml:space="preserve">
          <source>BufReader</source>
          <target state="translated">BufReader</target>
        </trans-unit>
        <trans-unit id="cb39e958e39ef179b2597f4ef6e19c98ca4fc4d5" translate="yes" xml:space="preserve">
          <source>BufReader and BufWriter</source>
          <target state="translated">BufReader y BufWriter</target>
        </trans-unit>
        <trans-unit id="30498daca312f601d5026a239b4f9877ca9ee7af" translate="yes" xml:space="preserve">
          <source>BufReader::borrow</source>
          <target state="translated">BufReader::borrow</target>
        </trans-unit>
        <trans-unit id="46b667a41b30eb52818f00950425d6b07af15300" translate="yes" xml:space="preserve">
          <source>BufReader::borrow_mut</source>
          <target state="translated">BufReader::borrow_mut</target>
        </trans-unit>
        <trans-unit id="6abdb3c76752714b4a06017a9219fa1f25214580" translate="yes" xml:space="preserve">
          <source>BufReader::buffer</source>
          <target state="translated">BufReader::buffer</target>
        </trans-unit>
        <trans-unit id="8a5b395c3f2044900bdcdf2f9ebf60ebd12d7819" translate="yes" xml:space="preserve">
          <source>BufReader::by_ref</source>
          <target state="translated">BufReader::by_ref</target>
        </trans-unit>
        <trans-unit id="6e8f568e8d439bbf991a8a007e038953a8f83b25" translate="yes" xml:space="preserve">
          <source>BufReader::bytes</source>
          <target state="translated">BufReader::bytes</target>
        </trans-unit>
        <trans-unit id="111bdc9e9c0fa8f11edaf0bb19720dadd4d441c2" translate="yes" xml:space="preserve">
          <source>BufReader::chain</source>
          <target state="translated">BufReader::chain</target>
        </trans-unit>
        <trans-unit id="698d6344bd09525535c43a69fdbd270c56fe0314" translate="yes" xml:space="preserve">
          <source>BufReader::consume</source>
          <target state="translated">BufReader::consume</target>
        </trans-unit>
        <trans-unit id="d753e03e42fea9b39b03754697893d50f45f25ac" translate="yes" xml:space="preserve">
          <source>BufReader::fill_buf</source>
          <target state="translated">BufReader::fill_buf</target>
        </trans-unit>
        <trans-unit id="4002c8a4271852b7c3dc4a005ad07b6218b6d9be" translate="yes" xml:space="preserve">
          <source>BufReader::fmt</source>
          <target state="translated">BufReader::fmt</target>
        </trans-unit>
        <trans-unit id="588a32e3d887d2adc2a42cbd852909e916738169" translate="yes" xml:space="preserve">
          <source>BufReader::from</source>
          <target state="translated">BufReader::from</target>
        </trans-unit>
        <trans-unit id="a565473360a69fedb15e98a54613f95fb3b56dfd" translate="yes" xml:space="preserve">
          <source>BufReader::get_mut</source>
          <target state="translated">BufReader::get_mut</target>
        </trans-unit>
        <trans-unit id="5594c6c6ae64375a5d272ff27f83db1d85077211" translate="yes" xml:space="preserve">
          <source>BufReader::get_ref</source>
          <target state="translated">BufReader::get_ref</target>
        </trans-unit>
        <trans-unit id="1e90aba1df228b628f7c7f3e2ab8e5bae2aa2919" translate="yes" xml:space="preserve">
          <source>BufReader::initializer</source>
          <target state="translated">BufReader::initializer</target>
        </trans-unit>
        <trans-unit id="9dfefe7d50b25c323182190a7738d15409036741" translate="yes" xml:space="preserve">
          <source>BufReader::into</source>
          <target state="translated">BufReader::into</target>
        </trans-unit>
        <trans-unit id="7af433e3bd4af270fc73a60a513c7c29c50b1691" translate="yes" xml:space="preserve">
          <source>BufReader::into_inner</source>
          <target state="translated">BufReader::into_inner</target>
        </trans-unit>
        <trans-unit id="015fca5819c404e186e79049e56378d531c3a868" translate="yes" xml:space="preserve">
          <source>BufReader::lines</source>
          <target state="translated">BufReader::lines</target>
        </trans-unit>
        <trans-unit id="261dc9dd5d56c7bd6b24e8c4987e0bacc36d731b" translate="yes" xml:space="preserve">
          <source>BufReader::new</source>
          <target state="translated">BufReader::new</target>
        </trans-unit>
        <trans-unit id="474a9aceabea88ca192dfa1182137bb4a5716f95" translate="yes" xml:space="preserve">
          <source>BufReader::read</source>
          <target state="translated">BufReader::read</target>
        </trans-unit>
        <trans-unit id="8fb011a69fd96b7a252fae27bab3618d9916ea15" translate="yes" xml:space="preserve">
          <source>BufReader::read_exact</source>
          <target state="translated">BufReader::read_exact</target>
        </trans-unit>
        <trans-unit id="043d1ca9b3f16093053e017427e6b59fce891b84" translate="yes" xml:space="preserve">
          <source>BufReader::read_line</source>
          <target state="translated">BufReader::read_line</target>
        </trans-unit>
        <trans-unit id="0cf3db2b85b3a36c4fe27bb356f920ec381e6a39" translate="yes" xml:space="preserve">
          <source>BufReader::read_to_end</source>
          <target state="translated">BufReader::read_to_end</target>
        </trans-unit>
        <trans-unit id="c014e4bd71ac8b1202507174a0590c77d72041f7" translate="yes" xml:space="preserve">
          <source>BufReader::read_to_string</source>
          <target state="translated">BufReader::read_to_string</target>
        </trans-unit>
        <trans-unit id="bf7f4de24e9cecff5fc9e9886289abdb93482e12" translate="yes" xml:space="preserve">
          <source>BufReader::read_until</source>
          <target state="translated">BufReader::read_until</target>
        </trans-unit>
        <trans-unit id="f1ac9fb503b6a30e103494d5ed7e213639e7e66d" translate="yes" xml:space="preserve">
          <source>BufReader::read_vectored</source>
          <target state="translated">BufReader::read_vectored</target>
        </trans-unit>
        <trans-unit id="b8518cd0ac9ab115738a223331f69d244e196ae1" translate="yes" xml:space="preserve">
          <source>BufReader::seek</source>
          <target state="translated">BufReader::seek</target>
        </trans-unit>
        <trans-unit id="99a5d03be61779b43803bbfee3dbfdce8a113d6d" translate="yes" xml:space="preserve">
          <source>BufReader::seek_relative</source>
          <target state="translated">BufReader::seek_relative</target>
        </trans-unit>
        <trans-unit id="43d93e963620260620093d161241006ece71cae8" translate="yes" xml:space="preserve">
          <source>BufReader::split</source>
          <target state="translated">BufReader::split</target>
        </trans-unit>
        <trans-unit id="e0ac1010e5c4fb0756b34d4592bffff3a410e86d" translate="yes" xml:space="preserve">
          <source>BufReader::stream_len</source>
          <target state="translated">BufReader::stream_len</target>
        </trans-unit>
        <trans-unit id="ca5bf56485cb95f3a60dbe8260139b54147feee2" translate="yes" xml:space="preserve">
          <source>BufReader::stream_position</source>
          <target state="translated">BufReader::stream_position</target>
        </trans-unit>
        <trans-unit id="70fc9c931ae2fc7872314fb275a9549018b33695" translate="yes" xml:space="preserve">
          <source>BufReader::take</source>
          <target state="translated">BufReader::take</target>
        </trans-unit>
        <trans-unit id="4d06dc939cd79e29aeb98db83609f9129bc27937" translate="yes" xml:space="preserve">
          <source>BufReader::try_from</source>
          <target state="translated">BufReader::try_from</target>
        </trans-unit>
        <trans-unit id="9cf0b40fa99c93bde7e68af3011e8e90b8e27ca1" translate="yes" xml:space="preserve">
          <source>BufReader::try_into</source>
          <target state="translated">BufReader::try_into</target>
        </trans-unit>
        <trans-unit id="c0358cb609681901098856ec216b94cf80a87fed" translate="yes" xml:space="preserve">
          <source>BufReader::type_id</source>
          <target state="translated">BufReader::type_id</target>
        </trans-unit>
        <trans-unit id="76a07371464a5bc5c675c8a1103f1bfcdcb90928" translate="yes" xml:space="preserve">
          <source>BufReader::with_capacity</source>
          <target state="translated">BufReader::with_capacity</target>
        </trans-unit>
        <trans-unit id="eb547b03e4fb9da19636fe86aa475ec275f26aea" translate="yes" xml:space="preserve">
          <source>BufWriter</source>
          <target state="translated">BufWriter</target>
        </trans-unit>
        <trans-unit id="c0fe0ec21d292209b8751b7b3bbc325ff8c3dfdd" translate="yes" xml:space="preserve">
          <source>BufWriter::borrow</source>
          <target state="translated">BufWriter::borrow</target>
        </trans-unit>
        <trans-unit id="2adb49e625ca6186b4c41c7d1737d0e2634f05fb" translate="yes" xml:space="preserve">
          <source>BufWriter::borrow_mut</source>
          <target state="translated">BufWriter::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c3ac09907f785459d01129cbdf9eb5797fc53c72" translate="yes" xml:space="preserve">
          <source>BufWriter::buffer</source>
          <target state="translated">BufWriter::buffer</target>
        </trans-unit>
        <trans-unit id="a82155a82c33131bd98d9e864c9f25f36481894a" translate="yes" xml:space="preserve">
          <source>BufWriter::by_ref</source>
          <target state="translated">BufWriter::by_ref</target>
        </trans-unit>
        <trans-unit id="31f24b83e544c2b05b1fbfd0a2b99edbc784d128" translate="yes" xml:space="preserve">
          <source>BufWriter::drop</source>
          <target state="translated">BufWriter::drop</target>
        </trans-unit>
        <trans-unit id="70ed6813c46c4821d4c3ceb922ec9e68c5b46a68" translate="yes" xml:space="preserve">
          <source>BufWriter::flush</source>
          <target state="translated">BufWriter::flush</target>
        </trans-unit>
        <trans-unit id="e322ea4bb3c530e22344a65d6d425dbe30797f57" translate="yes" xml:space="preserve">
          <source>BufWriter::fmt</source>
          <target state="translated">BufWriter::fmt</target>
        </trans-unit>
        <trans-unit id="ae28528b6704424a2fa6c25aacbe28d13e5e2328" translate="yes" xml:space="preserve">
          <source>BufWriter::from</source>
          <target state="translated">BufWriter::from</target>
        </trans-unit>
        <trans-unit id="8f2da80a85c436ae0e170c960857685d65f2c7fa" translate="yes" xml:space="preserve">
          <source>BufWriter::get_mut</source>
          <target state="translated">BufWriter::get_mut</target>
        </trans-unit>
        <trans-unit id="ae8ffbf65314cc80e578ef8e21fd9216b111a598" translate="yes" xml:space="preserve">
          <source>BufWriter::get_ref</source>
          <target state="translated">BufWriter::get_ref</target>
        </trans-unit>
        <trans-unit id="c2bb0d2480650e2a139a3ac97642b7fac7000daf" translate="yes" xml:space="preserve">
          <source>BufWriter::into</source>
          <target state="translated">BufWriter::into</target>
        </trans-unit>
        <trans-unit id="a254cafb67eb39c14e0dd9b99733426aaca0cce1" translate="yes" xml:space="preserve">
          <source>BufWriter::into_inner</source>
          <target state="translated">BufWriter::into_inner</target>
        </trans-unit>
        <trans-unit id="0d50fa17068770487074b33532e6632cdc747a7d" translate="yes" xml:space="preserve">
          <source>BufWriter::new</source>
          <target state="translated">BufWriter::new</target>
        </trans-unit>
        <trans-unit id="8acb320f731050f7faa230a67adf20edf2a91802" translate="yes" xml:space="preserve">
          <source>BufWriter::seek</source>
          <target state="translated">BufWriter::seek</target>
        </trans-unit>
        <trans-unit id="0bc901a9b97e04338c295bff32fc59abb34658a0" translate="yes" xml:space="preserve">
          <source>BufWriter::stream_len</source>
          <target state="translated">BufWriter::stream_len</target>
        </trans-unit>
        <trans-unit id="aef24c4f9e117e8540e0bceb74c3c1079dca3c4a" translate="yes" xml:space="preserve">
          <source>BufWriter::stream_position</source>
          <target state="translated">BufWriter::stream_position</target>
        </trans-unit>
        <trans-unit id="c3a46f518f714d6be6bad831bd9935498f844ddb" translate="yes" xml:space="preserve">
          <source>BufWriter::try_from</source>
          <target state="translated">BufWriter::try_from</target>
        </trans-unit>
        <trans-unit id="d12f6fca054766123bb42142de217202212ff449" translate="yes" xml:space="preserve">
          <source>BufWriter::try_into</source>
          <target state="translated">BufWriter::try_into</target>
        </trans-unit>
        <trans-unit id="8af6d7318c0dbf54915f72f0993742b25781c289" translate="yes" xml:space="preserve">
          <source>BufWriter::type_id</source>
          <target state="translated">BufWriter::type_id</target>
        </trans-unit>
        <trans-unit id="7f3e3e6e70dd67251f7be13ef8952baade49da92" translate="yes" xml:space="preserve">
          <source>BufWriter::with_capacity</source>
          <target state="translated">BufWriter::with_capacity</target>
        </trans-unit>
        <trans-unit id="04509abb12d543e33b20e9a92d6a3a9ce8f7becf" translate="yes" xml:space="preserve">
          <source>BufWriter::write</source>
          <target state="translated">BufWriter::write</target>
        </trans-unit>
        <trans-unit id="7904c0be7d3caaf53c1b1cdb84256218cdaa0206" translate="yes" xml:space="preserve">
          <source>BufWriter::write_all</source>
          <target state="translated">BufWriter::write_all</target>
        </trans-unit>
        <trans-unit id="1656f0c433aa13f34246f1c4269f0f93dd7be7a2" translate="yes" xml:space="preserve">
          <source>BufWriter::write_fmt</source>
          <target state="translated">BufWriter::write_fmt</target>
        </trans-unit>
        <trans-unit id="34b5f10d3b6a9f9a1dbde260a02e2b2206afca57" translate="yes" xml:space="preserve">
          <source>BufWriter::write_vectored</source>
          <target state="translated">BufWriter::write_vectored</target>
        </trans-unit>
        <trans-unit id="930e02964f6bea5730ba5c65d98e4f502a26535a" translate="yes" xml:space="preserve">
          <source>Buffering behavior:</source>
          <target state="translated">Comportamiento de amortiguación:</target>
        </trans-unit>
        <trans-unit id="c236b467cd75457e8973d308434bf8606946e8b7" translate="yes" xml:space="preserve">
          <source>Bugs that happen only in certain situations and are hard to reproduce and fix reliably</source>
          <target state="translated">Bichos que sólo ocurren en ciertas situaciones y que son difíciles de reproducir y arreglar de forma fiable</target>
        </trans-unit>
        <trans-unit id="c123195418c1603314c7d0aac5cbca5fe90623f5" translate="yes" xml:space="preserve">
          <source>Build the thread with &lt;a href=&quot;struct.builder&quot;&gt;&lt;code&gt;Builder&lt;/code&gt;&lt;/a&gt; and pass the desired stack size to &lt;a href=&quot;struct.builder#method.stack_size&quot;&gt;&lt;code&gt;Builder::stack_size&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Genere el hilo con &lt;a href=&quot;struct.builder&quot;&gt; &lt;code&gt;Builder&lt;/code&gt; &lt;/a&gt; y pase el tama&amp;ntilde;o de pila deseado a &lt;a href=&quot;struct.builder#method.stack_size&quot;&gt; &lt;code&gt;Builder::stack_size&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="97ac06ac37241fed7f3a8298db93e9bbc2d242b6" translate="yes" xml:space="preserve">
          <source>BuildHasher</source>
          <target state="translated">BuildHasher</target>
        </trans-unit>
        <trans-unit id="aaba5ed0cc289313d5a04c86f6c4f1a124a0ff97" translate="yes" xml:space="preserve">
          <source>BuildHasher::build_hasher</source>
          <target state="translated">BuildHasher::build_hasher</target>
        </trans-unit>
        <trans-unit id="6972ec88ec81efc886ecfcc5774a514315adaba3" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault</source>
          <target state="translated">BuildHasherDefault</target>
        </trans-unit>
        <trans-unit id="3b3934e3550748f2a7b58e6593d8d16993a3f234" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::borrow</source>
          <target state="translated">BuildHasherDefault::borrow</target>
        </trans-unit>
        <trans-unit id="f55eee0b0d59698190e3d541df7887945783f03c" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::borrow_mut</source>
          <target state="translated">BuildHasherDefault::borrow_mut</target>
        </trans-unit>
        <trans-unit id="9a17d9b6eba5bdb1a3199b04f87f79fe486b4427" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::build_hasher</source>
          <target state="translated">BuildHasherDefault::build_hasher</target>
        </trans-unit>
        <trans-unit id="3378e7d2427ed05874269a577e08932c432618d4" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::clone</source>
          <target state="translated">BuildHasherDefault::clone</target>
        </trans-unit>
        <trans-unit id="010bd4789bebb3ef5a2996e2b1be4fdb5f283ea4" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::clone_from</source>
          <target state="translated">BuildHasherDefault::clone_from</target>
        </trans-unit>
        <trans-unit id="e746cdbc6b12a8b851323bb7c641b3af90edca43" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::clone_into</source>
          <target state="translated">BuildHasherDefault::clone_into</target>
        </trans-unit>
        <trans-unit id="52e1f05a4973d5628107a410168778a062f1bf48" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::default</source>
          <target state="translated">BuildHasherDefault::default</target>
        </trans-unit>
        <trans-unit id="805858a4f2f04c612c4359d30c11b771cbbf2670" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::eq</source>
          <target state="translated">BuildHasherDefault::eq</target>
        </trans-unit>
        <trans-unit id="a489341b69637e6985483361e2ba9bd4e930658e" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::fmt</source>
          <target state="translated">BuildHasherDefault::fmt</target>
        </trans-unit>
        <trans-unit id="7dc7ccadfebe0f90b3109993492f2510fdea1e97" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::from</source>
          <target state="translated">BuildHasherDefault::from</target>
        </trans-unit>
        <trans-unit id="b214b1f4540f86833e16b1674e570a06864bb810" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::into</source>
          <target state="translated">BuildHasherDefault::into</target>
        </trans-unit>
        <trans-unit id="3124ec3e2cb6d3f2d095ae07854f9d9f327708f0" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::ne</source>
          <target state="translated">BuildHasherDefault::ne</target>
        </trans-unit>
        <trans-unit id="3e47f2f0c29a4813a680f3068d5450f9f31a9f4d" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::to_owned</source>
          <target state="translated">BuildHasherDefault::to_owned</target>
        </trans-unit>
        <trans-unit id="36b39c1513469044cd761bd64a80f0c4a9902c0a" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::try_from</source>
          <target state="translated">BuildHasherDefault::try_from</target>
        </trans-unit>
        <trans-unit id="6b3bf2bc5c2ef00504b85f45d8356c19b7018273" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::try_into</source>
          <target state="translated">BuildHasherDefault::try_into</target>
        </trans-unit>
        <trans-unit id="c27d762f5384033048f5c3b6349a62aa6d74a8ff" translate="yes" xml:space="preserve">
          <source>BuildHasherDefault::type_id</source>
          <target state="translated">BuildHasherDefault::type_id</target>
        </trans-unit>
        <trans-unit id="4759bf14d7a511508e86c343c934894b6e8db533" translate="yes" xml:space="preserve">
          <source>Builder</source>
          <target state="translated">Builder</target>
        </trans-unit>
        <trans-unit id="004d20f8006198411988eea17651cdf655cc4482" translate="yes" xml:space="preserve">
          <source>Builder methods are provided to change these defaults and otherwise configure the process.</source>
          <target state="translated">Se proporcionan métodos de construcción para cambiar estos valores predeterminados y configurar el proceso de otra manera.</target>
        </trans-unit>
        <trans-unit id="e817e9752d05edc9cdf54971d106867fe037888c" translate="yes" xml:space="preserve">
          <source>Builder::borrow</source>
          <target state="translated">Builder::borrow</target>
        </trans-unit>
        <trans-unit id="94bb1918ddf68bff15586c79a231491744cc5934" translate="yes" xml:space="preserve">
          <source>Builder::borrow_mut</source>
          <target state="translated">Builder::borrow_mut</target>
        </trans-unit>
        <trans-unit id="f7d73832b38ead1d7c82f9bab9bcef56bfdd3661" translate="yes" xml:space="preserve">
          <source>Builder::fmt</source>
          <target state="translated">Builder::fmt</target>
        </trans-unit>
        <trans-unit id="e7b6a7ffdb6a96182506cdb6f845b1b5f8083113" translate="yes" xml:space="preserve">
          <source>Builder::from</source>
          <target state="translated">Builder::from</target>
        </trans-unit>
        <trans-unit id="c646de2596ac054c72581071ffd5afa499f6b38e" translate="yes" xml:space="preserve">
          <source>Builder::into</source>
          <target state="translated">Builder::into</target>
        </trans-unit>
        <trans-unit id="25158ae2faf4770ff3631697763e4f649748735c" translate="yes" xml:space="preserve">
          <source>Builder::name</source>
          <target state="translated">Builder::name</target>
        </trans-unit>
        <trans-unit id="a2fdc90cb0342f15602e461493244bbda8d11380" translate="yes" xml:space="preserve">
          <source>Builder::new</source>
          <target state="translated">Builder::new</target>
        </trans-unit>
        <trans-unit id="a5c0502ee99c0af55e1f1a9757c75ceb61f0e365" translate="yes" xml:space="preserve">
          <source>Builder::spawn</source>
          <target state="translated">Builder::spawn</target>
        </trans-unit>
        <trans-unit id="d28e4127e494164e81f16f028a028d507078db82" translate="yes" xml:space="preserve">
          <source>Builder::spawn_unchecked</source>
          <target state="translated">Builder::spawn_unchecked</target>
        </trans-unit>
        <trans-unit id="79550b63f469160e0886e9b4b6fb46be05f50a29" translate="yes" xml:space="preserve">
          <source>Builder::stack_size</source>
          <target state="translated">Builder::stack_size</target>
        </trans-unit>
        <trans-unit id="96b55ab18feea8a44f0d0d096d39f3af52a2e131" translate="yes" xml:space="preserve">
          <source>Builder::try_from</source>
          <target state="translated">Builder::try_from</target>
        </trans-unit>
        <trans-unit id="77877ce5fde9f3242e4b6af9ede23afdcb23f7db" translate="yes" xml:space="preserve">
          <source>Builder::try_into</source>
          <target state="translated">Builder::try_into</target>
        </trans-unit>
        <trans-unit id="6247790fc07eec46462f144d1ed4dedc1cb780eb" translate="yes" xml:space="preserve">
          <source>Builder::type_id</source>
          <target state="translated">Builder::type_id</target>
        </trans-unit>
        <trans-unit id="3bf882813c900c304e2632ba4dffda0948193670" translate="yes" xml:space="preserve">
          <source>Building a Single-Threaded Web Server</source>
          <target state="translated">Construir un servidor web de un solo hilo</target>
        </trans-unit>
        <trans-unit id="253443e211e899460868732743aa41ea5e5f944a" translate="yes" xml:space="preserve">
          <source>Building and Running a Cargo Project</source>
          <target state="translated">Construir y dirigir un proyecto de carga</target>
        </trans-unit>
        <trans-unit id="1916501f700c410fd7bea37cffb5b95a293dc381" translate="yes" xml:space="preserve">
          <source>Building for Release</source>
          <target state="translated">Edificio para la liberación</target>
        </trans-unit>
        <trans-unit id="0ad2d2fb6e92d2b6c89500bfdd36e70bf53d31d2" translate="yes" xml:space="preserve">
          <source>Building the &lt;code id=&quot;building-the-threadpool-struct-using-compiler-driven-development&quot;&gt;ThreadPool&lt;/code&gt; Struct Using Compiler Driven Development</source>
          <target state="translated">Creaci&amp;oacute;n de la &lt;code id=&quot;building-the-threadpool-struct-using-compiler-driven-development&quot;&gt;ThreadPool&lt;/code&gt; ThreadPool mediante el desarrollo impulsado por el compilador</target>
        </trans-unit>
        <trans-unit id="20da59d3c16c7bbc43ecdc04a9ed654b4ef329d2" translate="yes" xml:space="preserve">
          <source>Built in &lt;a href=&quot;expressions/operator-expr#negation-operators&quot;&gt;negation&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#arithmetic-and-logical-binary-operators&quot;&gt;arithmetic, logical&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#comparison-operators&quot;&gt;comparison&lt;/a&gt; or &lt;a href=&quot;expressions/operator-expr#lazy-boolean-operators&quot;&gt;lazy boolean&lt;/a&gt; operators used on integer and floating point types, &lt;code&gt;bool&lt;/code&gt; and &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">Construido en &lt;a href=&quot;expressions/operator-expr#negation-operators&quot;&gt;negaci&amp;oacute;n&lt;/a&gt; , &lt;a href=&quot;expressions/operator-expr#arithmetic-and-logical-binary-operators&quot;&gt;aritm&amp;eacute;tica y l&amp;oacute;gica&lt;/a&gt; , &lt;a href=&quot;expressions/operator-expr#comparison-operators&quot;&gt;comparaci&amp;oacute;n&lt;/a&gt; o &lt;a href=&quot;expressions/operator-expr#lazy-boolean-operators&quot;&gt;booleanas perezosos&lt;/a&gt; operadores utilizados en n&amp;uacute;mero entero y tipos de punto flotante, &lt;code&gt;bool&lt;/code&gt; y &lt;code&gt;char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89e36b16f75fb9635eac3a25e8d8d0058e587b9c" translate="yes" xml:space="preserve">
          <source>Built-in &lt;a href=&quot;expressions/operator-expr#negation-operators&quot;&gt;negation&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#arithmetic-and-logical-binary-operators&quot;&gt;arithmetic&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#arithmetic-and-logical-binary-operators&quot;&gt;logical&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#comparison-operators&quot;&gt;comparison&lt;/a&gt; or &lt;a href=&quot;expressions/operator-expr#lazy-boolean-operators&quot;&gt;lazy boolean&lt;/a&gt; operators used on integer and floating point types, &lt;code&gt;bool&lt;/code&gt;, and &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd0f66ac77e682a233d8ddb635dd00b67a90ab76" translate="yes" xml:space="preserve">
          <source>Built-in attributes</source>
          <target state="translated">Atributos incorporados</target>
        </trans-unit>
        <trans-unit id="1dac87263c85b5a8f82799db9805041e3360af6d" translate="yes" xml:space="preserve">
          <source>Built-in attributes index</source>
          <target state="translated">Índice de atributos incorporado</target>
        </trans-unit>
        <trans-unit id="3b55724056edf0c168a344b916c46cc4f550e2f6" translate="yes" xml:space="preserve">
          <source>Built-in types are tightly integrated into the language, in nontrivial ways that are not possible to emulate in user-defined types. User-defined types have limited capabilities.</source>
          <target state="translated">Los tipos incorporados están estrechamente integrados en el lenguaje,de maneras no triviales que no es posible emular en los tipos definidos por el usuario.Los tipos definidos por el usuario tienen capacidades limitadas.</target>
        </trans-unit>
        <trans-unit id="6c6bb0e181beb9458279ac502a39fa01da91b8fe" translate="yes" xml:space="preserve">
          <source>But &lt;code&gt;drain_filter&lt;/code&gt; is easier to use. &lt;code&gt;drain_filter&lt;/code&gt; is also more efficient, because it can backshift the elements of the array in bulk.</source>
          <target state="translated">Pero &lt;code&gt;drain_filter&lt;/code&gt; es m&amp;aacute;s f&amp;aacute;cil de usar. &lt;code&gt;drain_filter&lt;/code&gt; tambi&amp;eacute;n es m&amp;aacute;s eficiente, porque puede retroceder los elementos de la matriz de forma masiva.</target>
        </trans-unit>
        <trans-unit id="ab56537680f4a94c82e8bdfe87270e033203a404" translate="yes" xml:space="preserve">
          <source>But Rust isn&amp;rsquo;t limited to low-level systems programming. It&amp;rsquo;s expressive and ergonomic enough to make CLI apps, web servers, and many other kinds of code quite pleasant to write &amp;mdash; you&amp;rsquo;ll find simple examples of both later in the book. Working with Rust allows you to build skills that transfer from one domain to another; you can learn Rust by writing a web app, then apply those same skills to target your Raspberry Pi.</source>
          <target state="translated">Pero Rust no se limita a la programaci&amp;oacute;n de sistemas de bajo nivel. Es lo suficientemente expresivo y ergon&amp;oacute;mico para hacer que las aplicaciones CLI, los servidores web y muchos otros tipos de c&amp;oacute;digo sean bastante agradables de escribir; encontrar&amp;aacute; ejemplos simples de ambos m&amp;aacute;s adelante en el libro. Trabajar con Rust le permite desarrollar habilidades que se transfieren de un dominio a otro; puede aprender Rust escribiendo una aplicaci&amp;oacute;n web y luego aplicar esas mismas habilidades para apuntar a su Raspberry Pi.</target>
        </trans-unit>
        <trans-unit id="c9bc5d1aa2362cf2e31f1ee01e7de1ef4e0a2d19" translate="yes" xml:space="preserve">
          <source>But again, the compiler gives us a helpful note:</source>
          <target state="translated">Pero de nuevo,el compilador nos da una nota útil:</target>
        </trans-unit>
        <trans-unit id="b5737faee592fa19b426fe0f0898f071a967af3e" translate="yes" xml:space="preserve">
          <source>But are the two implementations truly equivalent? The intuitive assumption might be that the more low-level loop will be faster. Let&amp;rsquo;s talk about performance.</source>
          <target state="translated">Pero, &amp;iquest;son las dos implementaciones realmente equivalentes? La suposici&amp;oacute;n intuitiva podr&amp;iacute;a ser que el bucle de nivel m&amp;aacute;s bajo ser&amp;aacute; m&amp;aacute;s r&amp;aacute;pido. Hablemos de rendimiento.</target>
        </trans-unit>
        <trans-unit id="d5233374bc70817ae86cada9a53675c9bf92e0c7" translate="yes" xml:space="preserve">
          <source>But be sure to remember that valid Unicode scalar values may be made up of more than 1 byte.</source>
          <target state="translated">Pero asegúrate de recordar que los valores escalares válidos de Unicode pueden estar compuestos de más de 1 byte.</target>
        </trans-unit>
        <trans-unit id="0f72ae39afec7a59586e27c05c7b3e5e6adecf93" translate="yes" xml:space="preserve">
          <source>But before we get started, we should mention one detail: the method we&amp;rsquo;ll use won&amp;rsquo;t be the best way to build a web server with Rust. A number of production-ready crates are available on &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; that provide more complete web server and thread pool implementations than we&amp;rsquo;ll build.</source>
          <target state="translated">Pero antes de comenzar, debemos mencionar un detalle: el m&amp;eacute;todo que usaremos no ser&amp;aacute; la mejor manera de construir un servidor web con Rust. Hay varias cajas listas para producci&amp;oacute;n disponibles en &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; que proporcionan implementaciones de servidores web y grupos de subprocesos m&amp;aacute;s completas de las que vamos a construir.</target>
        </trans-unit>
        <trans-unit id="2b053f01b33d2a55c1c75c2c507abf7135d9a246" translate="yes" xml:space="preserve">
          <source>But by default, Cargo will only look for versions greater than &lt;code&gt;0.3.0&lt;/code&gt; and less than &lt;code&gt;0.4.0&lt;/code&gt;. If the &lt;code&gt;rand&lt;/code&gt; crate has released two new versions, &lt;code&gt;0.3.15&lt;/code&gt; and &lt;code&gt;0.4.0&lt;/code&gt;, you would see the following if you ran &lt;code&gt;cargo update&lt;/code&gt;:</source>
          <target state="translated">Pero de forma predeterminada, Cargo solo buscar&amp;aacute; versiones superiores a &lt;code&gt;0.3.0&lt;/code&gt; e inferiores a &lt;code&gt;0.4.0&lt;/code&gt; . Si la caja &lt;code&gt;rand&lt;/code&gt; ha lanzado dos nuevas versiones, &lt;code&gt;0.3.15&lt;/code&gt; y &lt;code&gt;0.4.0&lt;/code&gt; , ver&amp;aacute; lo siguiente si ejecuta &lt;code&gt;cargo update&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="041215ad4156f8d52d141c6b1d6e0db864c4a8a2" translate="yes" xml:space="preserve">
          <source>But by default, Cargo will only look for versions greater than &lt;code&gt;0.5.5&lt;/code&gt; and less than &lt;code&gt;0.6.0&lt;/code&gt;. If the &lt;code&gt;rand&lt;/code&gt; crate has released two new versions, &lt;code&gt;0.5.6&lt;/code&gt; and &lt;code&gt;0.6.0&lt;/code&gt;, you would see the following if you ran &lt;code&gt;cargo update&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48958431e414a42071536586c915fe4c3022be36" translate="yes" xml:space="preserve">
          <source>But for now, let&amp;rsquo;s work around this problem using a handy trick. We can tell Rust explicitly that in this case we can take ownership of the value inside the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; using &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt;; then, once we have ownership of the closure, we can call it. This involves defining a new trait &lt;code&gt;FnBox&lt;/code&gt; with the method &lt;code&gt;call_box&lt;/code&gt; that will use &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; in its signature, defining &lt;code&gt;FnBox&lt;/code&gt; for any type that implements &lt;code&gt;FnOnce()&lt;/code&gt;, changing our type alias to use the new trait, and changing &lt;code&gt;Worker&lt;/code&gt; to use the &lt;code&gt;call_box&lt;/code&gt; method. These changes are shown in Listing 20-21.</source>
          <target state="translated">Pero por ahora, solucionemos este problema con un truco &amp;uacute;til. Podemos decirle a Rust expl&amp;iacute;citamente que en este caso podemos tomar posesi&amp;oacute;n del valor dentro de &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; usando &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; ; luego, una vez que tengamos la propiedad del cierre, podemos llamarlo. Esto implica definir un nuevo rasgo &lt;code&gt;FnBox&lt;/code&gt; con el m&amp;eacute;todo &lt;code&gt;call_box&lt;/code&gt; que usar&amp;aacute; &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; en su firma, definir &lt;code&gt;FnBox&lt;/code&gt; para cualquier tipo que implemente &lt;code&gt;FnOnce()&lt;/code&gt; , cambiar nuestro alias de tipo para usar el nuevo rasgo y cambiar &lt;code&gt;Worker&lt;/code&gt; para usar el m&amp;eacute;todo &lt;code&gt;call_box&lt;/code&gt; . Estos cambios se muestran en el Listado 20-21.</target>
        </trans-unit>
        <trans-unit id="0be702d32a09b655da72a7b7225dc839aaba10a3" translate="yes" xml:space="preserve">
          <source>But for the following two exceptions, this function is semantically equivalent to &lt;a href=&quot;../mem/fn.swap&quot;&gt;&lt;code&gt;mem::swap&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Pero para las siguientes dos excepciones, esta funci&amp;oacute;n es sem&amp;aacute;nticamente equivalente a &lt;a href=&quot;../mem/fn.swap&quot;&gt; &lt;code&gt;mem::swap&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="470268269eb0c32844b8d1e2e02e3f2f66584bd8" translate="yes" xml:space="preserve">
          <source>But if we used the different structs, which each have their own type, we couldn&amp;rsquo;t as easily define a function to take any of these kinds of messages as we could with the &lt;code&gt;Message&lt;/code&gt; enum defined in Listing 6-2, which is a single type.</source>
          <target state="translated">Pero si us&amp;aacute;ramos las diferentes estructuras, cada una de las cuales tiene su propio tipo, no podr&amp;iacute;amos definir tan f&amp;aacute;cilmente una funci&amp;oacute;n para tomar cualquiera de estos tipos de mensajes como podr&amp;iacute;amos con la enumeraci&amp;oacute;n de &lt;code&gt;Message&lt;/code&gt; definida en el Listado 6-2, que es una tipo.</target>
        </trans-unit>
        <trans-unit id="79200d10e04d305f55f7036bcbaaafae7d4d999b" translate="yes" xml:space="preserve">
          <source>But if your closure has state, iterating backwards may act in a way you do not expect. Let's go through an example. First, in the forward direction:</source>
          <target state="translated">Pero si su cierre tiene estado,la iteración hacia atrás puede actuar de una manera que no se espera.Veamos un ejemplo.Primero,en la dirección del avance:</target>
        </trans-unit>
        <trans-unit id="42768b6451354f549c20c5936efbed0901a61a1c" translate="yes" xml:space="preserve">
          <source>But let&amp;rsquo;s see what happens when we instead move &lt;code&gt;handle.join()&lt;/code&gt; before the &lt;code&gt;for&lt;/code&gt; loop in &lt;code&gt;main&lt;/code&gt;, like this:</source>
          <target state="translated">Pero veamos qu&amp;eacute; sucede cuando en su lugar movemos &lt;code&gt;handle.join()&lt;/code&gt; antes del bucle &lt;code&gt;for&lt;/code&gt; en &lt;code&gt;main&lt;/code&gt; , as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="1fbf462a87fb38288cb0e833c1357211d81cfbfe" translate="yes" xml:space="preserve">
          <source>But mutability can be very useful. Variables are immutable only by default; as you did in Chapter 2, you can make them mutable by adding &lt;code&gt;mut&lt;/code&gt; in front of the variable name. In addition to allowing this value to change, &lt;code&gt;mut&lt;/code&gt; conveys intent to future readers of the code by indicating that other parts of the code will be changing this variable value.</source>
          <target state="translated">Pero la mutabilidad puede resultar muy &amp;uacute;til. Las variables son inmutables solo por defecto; como hizo en el Cap&amp;iacute;tulo 2, puede hacerlos mutables agregando &lt;code&gt;mut&lt;/code&gt; delante del nombre de la variable. Adem&amp;aacute;s de permitir que este valor cambie, &lt;code&gt;mut&lt;/code&gt; transmite la intenci&amp;oacute;n a los futuros lectores del c&amp;oacute;digo al indicar que otras partes del c&amp;oacute;digo cambiar&amp;aacute;n el valor de esta variable.</target>
        </trans-unit>
        <trans-unit id="e1df74418ef370eb96db59d017c1ab1ddf4aab63" translate="yes" xml:space="preserve">
          <source>But mutability can be very useful. Variables are immutable only by default; as you did in Chapter 2, you can make them mutable by adding &lt;code&gt;mut&lt;/code&gt; in front of the variable name. In addition to allowing this value to change, &lt;code&gt;mut&lt;/code&gt; conveys intent to future readers of the code by indicating that other parts of the code will be changing this variable&amp;rsquo;s value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca01c2ad1998dcba761dee195dffb89226d07502" translate="yes" xml:space="preserve">
          <source>But mutable references have one big restriction: you can have only one mutable reference to a particular piece of data in a particular scope. This code will fail:</source>
          <target state="translated">Pero las referencias mutables tienen una gran restricción:sólo se puede tener una referencia mutable a un dato concreto en un ámbito determinado.Este código fallará:</target>
        </trans-unit>
        <trans-unit id="c6250d5ccc2a1416a071df325ba8b22edb3b1273" translate="yes" xml:space="preserve">
          <source>But structs aren&amp;rsquo;t the only way you can create custom types: let&amp;rsquo;s turn to Rust&amp;rsquo;s enum feature to add another tool to your toolbox.</source>
          <target state="translated">Pero las estructuras no son la &amp;uacute;nica forma en que puede crear tipos personalizados: pasemos a la funci&amp;oacute;n de enumeraci&amp;oacute;n de Rust para agregar otra herramienta a su caja de herramientas.</target>
        </trans-unit>
        <trans-unit id="e46bfa80d370a9ed637759cea72a8f30b0485064" translate="yes" xml:space="preserve">
          <source>But this approach is error prone; we could cause the program to panic if the index length is incorrect. It&amp;rsquo;s also slow, because the compiler adds runtime code to perform the conditional check on every element on every iteration through the loop.</source>
          <target state="translated">Pero este enfoque es propenso a errores; podr&amp;iacute;amos hacer que el programa entre en p&amp;aacute;nico si la longitud del &amp;iacute;ndice es incorrecta. Tambi&amp;eacute;n es lento, porque el compilador agrega c&amp;oacute;digo de tiempo de ejecuci&amp;oacute;n para realizar la verificaci&amp;oacute;n condicional en cada elemento en cada iteraci&amp;oacute;n a trav&amp;eacute;s del ciclo.</target>
        </trans-unit>
        <trans-unit id="de89e89b70a2e3c19b2a830c292d1b9e969da48e" translate="yes" xml:space="preserve">
          <source>But this code does:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52cdbd656052ab3ea671f0d02157a3b7b3a6c824" translate="yes" xml:space="preserve">
          <source>But this code seems to contradict what we just learned: we don&amp;rsquo;t have a call to &lt;code&gt;clone&lt;/code&gt;, but &lt;code&gt;x&lt;/code&gt; is still valid and wasn&amp;rsquo;t moved into &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">Pero este c&amp;oacute;digo parece contradecir lo que acabamos de aprender: no tenemos una llamada para &lt;code&gt;clone&lt;/code&gt; , pero &lt;code&gt;x&lt;/code&gt; sigue siendo v&amp;aacute;lido y no se movi&amp;oacute; a &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f041deb6530f49ecfbaae593b78e17efac482d38" translate="yes" xml:space="preserve">
          <source>But this is too much ceremony and a lot of work for a concept that should be common. Luckily for us, Rust has a feature for this concept, called &lt;em&gt;references&lt;/em&gt;.</source>
          <target state="translated">Pero esto es demasiada ceremonia y mucho trabajo para un concepto que deber&amp;iacute;a ser com&amp;uacute;n. Afortunadamente para nosotros, Rust tiene una caracter&amp;iacute;stica para este concepto, llamadas &lt;em&gt;referencias&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2ad53668e46657588df9ef2114136e4f4dac0e42" translate="yes" xml:space="preserve">
          <source>But we also have to make some small changes to &lt;code&gt;main&lt;/code&gt;. The &lt;code&gt;request_review&lt;/code&gt; and &lt;code&gt;approve&lt;/code&gt; methods return new instances rather than modifying the struct they&amp;rsquo;re called on, so we need to add more &lt;code&gt;let post =&lt;/code&gt; shadowing assignments to save the returned instances. We also can&amp;rsquo;t have the assertions about the draft and pending review post&amp;rsquo;s contents be empty strings, nor do we need them: we can&amp;rsquo;t compile code that tries to use the content of posts in those states any longer. The updated code in &lt;code&gt;main&lt;/code&gt; is shown in Listing 17-21:</source>
          <target state="translated">Pero tambi&amp;eacute;n tenemos que hacer algunos peque&amp;ntilde;os cambios en &lt;code&gt;main&lt;/code&gt; . El &lt;code&gt;request_review&lt;/code&gt; y &lt;code&gt;approve&lt;/code&gt; m&amp;eacute;todos devuelven nuevas instancias en lugar de modificar la estructura que se llaman sucesivamente, de modo que tenemos que a&amp;ntilde;adir m&amp;aacute;s &lt;code&gt;let post =&lt;/code&gt; sombra asignaciones para guardar los casos devueltos. Tampoco podemos hacer que las afirmaciones sobre el borrador y el contenido de la publicaci&amp;oacute;n pendiente de revisi&amp;oacute;n sean cadenas vac&amp;iacute;as, ni las necesitamos: ya no podemos compilar c&amp;oacute;digo que intente usar el contenido de las publicaciones en esos estados. El c&amp;oacute;digo actualizado en &lt;code&gt;main&lt;/code&gt; se muestra en el Listado 17-21:</target>
        </trans-unit>
        <trans-unit id="08cb86c283fbceae016dfe9e91e73ec38c2b76a7" translate="yes" xml:space="preserve">
          <source>But we can&amp;rsquo;t implement external traits on external types. For example, we can&amp;rsquo;t implement the &lt;code&gt;Display&lt;/code&gt; trait on &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; within our &lt;code&gt;aggregator&lt;/code&gt; crate, because &lt;code&gt;Display&lt;/code&gt; and &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; are defined in the standard library and aren&amp;rsquo;t local to our &lt;code&gt;aggregator&lt;/code&gt; crate. This restriction is part of a property of programs called &lt;em&gt;coherence&lt;/em&gt;, and more specifically the &lt;em&gt;orphan rule&lt;/em&gt;, so named because the parent type is not present. This rule ensures that other people&amp;rsquo;s code can&amp;rsquo;t break your code and vice versa. Without the rule, two crates could implement the same trait for the same type, and Rust wouldn&amp;rsquo;t know which implementation to use.</source>
          <target state="translated">Pero no podemos implementar rasgos externos en tipos externos. Por ejemplo, no podemos implementar el rasgo &lt;code&gt;Display&lt;/code&gt; en &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; dentro de nuestra caja de &lt;code&gt;aggregator&lt;/code&gt; , porque &lt;code&gt;Display&lt;/code&gt; y &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; est&amp;aacute;n definidos en la biblioteca est&amp;aacute;ndar y no son locales para nuestra caja de &lt;code&gt;aggregator&lt;/code&gt; . Esta restricci&amp;oacute;n es parte de una propiedad de los programas llamada &lt;em&gt;coherencia&lt;/em&gt; , y m&amp;aacute;s espec&amp;iacute;ficamente la &lt;em&gt;regla hu&amp;eacute;rfana&lt;/em&gt; , llamada as&amp;iacute; porque el tipo padre no est&amp;aacute; presente. Esta regla asegura que el c&amp;oacute;digo de otras personas no pueda romper su c&amp;oacute;digo y viceversa. Sin la regla, dos cajas podr&amp;iacute;an implementar el mismo rasgo para el mismo tipo, y Rust no sabr&amp;iacute;a qu&amp;eacute; implementaci&amp;oacute;n usar.</target>
        </trans-unit>
        <trans-unit id="e2def28f767ccc15567e67d96a674194d2cda727" translate="yes" xml:space="preserve">
          <source>But we&amp;rsquo;re not quite done yet! In the worker, our closure being passed to &lt;code&gt;thread::spawn&lt;/code&gt; still only &lt;em&gt;references&lt;/em&gt; the receiving end of the channel. Instead, we need the closure to loop forever, asking the receiving end of the channel for a job and running the job when it gets one. Let&amp;rsquo;s make the change shown in Listing 20-20 to &lt;code&gt;Worker::new&lt;/code&gt;.</source>
          <target state="translated">&amp;iexcl;Pero a&amp;uacute;n no hemos terminado! En el trabajador, nuestro cierre que se pasa a &lt;code&gt;thread::spawn&lt;/code&gt; todav&amp;iacute;a solo hace &lt;em&gt;referencia&lt;/em&gt; al extremo receptor del canal. En cambio, necesitamos que el cierre se repita para siempre, solicitando un trabajo al extremo receptor del canal y ejecutando el trabajo cuando lo recibe. Hagamos el cambio que se muestra en el Listado 20-20 a &lt;code&gt;Worker::new&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="91d9b7bfa8f54bae2ca712d22c222ac19da54446" translate="yes" xml:space="preserve">
          <source>But what use is a type you can never create values for? Recall the code from Listing 2-5; we&amp;rsquo;ve reproduced part of it here in Listing 19-26.</source>
          <target state="translated">Pero, &amp;iquest;de qu&amp;eacute; sirve un tipo para el que nunca se pueden crear valores? Recupere el c&amp;oacute;digo del Listado 2-5; hemos reproducido parte de &amp;eacute;l aqu&amp;iacute; en el Listado 19-26.</target>
        </trans-unit>
        <trans-unit id="f5817afbaa27eca7b4e5b48d721c41770590cf6f" translate="yes" xml:space="preserve">
          <source>But when it comes to supporting this in traits, there are &lt;a href=&quot;https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/&quot;&gt;a few implementation issues&lt;/a&gt;. One of them is returning &lt;code&gt;impl Trait&lt;/code&gt; in traits is not supported, as it would require &lt;a href=&quot;https://github.com/rust-lang/rust/issues/44265&quot;&gt;Generic Associated Types&lt;/a&gt; to be supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b1144e8d867db6585bb0fed6af4e27df37f58b6" translate="yes" xml:space="preserve">
          <source>But you&amp;rsquo;ll more often see them used in this format, with the comment on a separate line above the code it&amp;rsquo;s annotating:</source>
          <target state="translated">Pero los ver&amp;aacute; m&amp;aacute;s a menudo usados ​​en este formato, con el comentario en una l&amp;iacute;nea separada sobre el c&amp;oacute;digo que est&amp;aacute; anotando:</target>
        </trans-unit>
        <trans-unit id="14c5580ac9c2810afbb01f7bb2cceb390e04edb0" translate="yes" xml:space="preserve">
          <source>By adding &lt;code&gt;--undo&lt;/code&gt; to the command, you can also undo a yank and allow projects to start depending on a version again:</source>
          <target state="translated">Al agregar &lt;code&gt;--undo&lt;/code&gt; al comando, tambi&amp;eacute;n puede deshacer un tir&amp;oacute;n y permitir que los proyectos comiencen dependiendo de una versi&amp;oacute;n nuevamente:</target>
        </trans-unit>
        <trans-unit id="57268469c25c87f6ad4c099c6346794a32838869" translate="yes" xml:space="preserve">
          <source>By adding the &lt;code&gt;move&lt;/code&gt; keyword before the closure, we force the closure to take ownership of the values it&amp;rsquo;s using rather than allowing Rust to infer that it should borrow the values. The modification to Listing 16-3 shown in Listing 16-5 will compile and run as we intend:</source>
          <target state="translated">Al agregar la palabra clave &lt;code&gt;move&lt;/code&gt; antes del cierre, forzamos al cierre a tomar posesi&amp;oacute;n de los valores que est&amp;aacute; usando en lugar de permitir que Rust infiera que deber&amp;iacute;a tomar prestados los valores. La modificaci&amp;oacute;n del Listado 16-3 que se muestra en el Listado 16-5 se compilar&amp;aacute; y ejecutar&amp;aacute; como pretendemos:</target>
        </trans-unit>
        <trans-unit id="24cf831e0672b0a0d0cb2aabe568cf79d0a637c3" translate="yes" xml:space="preserve">
          <source>By changing &lt;code&gt;impl PartialEq for Book&lt;/code&gt; to &lt;code&gt;impl PartialEq&amp;lt;BookFormat&amp;gt; for Book&lt;/code&gt;, we allow &lt;code&gt;BookFormat&lt;/code&gt;s to be compared with &lt;code&gt;Book&lt;/code&gt;s.</source>
          <target state="translated">Al cambiar &lt;code&gt;impl PartialEq for Book&lt;/code&gt; a &lt;code&gt;impl PartialEq&amp;lt;BookFormat&amp;gt; for Book&lt;/code&gt; , permitimos que &lt;code&gt;BookFormat&lt;/code&gt; s se compare con &lt;code&gt;Book&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="376ca023c76f3036478e22fdb169869008d8aa9e" translate="yes" xml:space="preserve">
          <source>By controlling which tests run, you can make sure your &lt;code&gt;cargo test&lt;/code&gt; results will be fast. When you&amp;rsquo;re at a point where it makes sense to check the results of the &lt;code&gt;ignored&lt;/code&gt; tests and you have time to wait for the results, you can run &lt;code&gt;cargo test -- --ignored&lt;/code&gt; instead.</source>
          <target state="translated">Al controlar qu&amp;eacute; pruebas se ejecutan, puede asegurarse de que los resultados de las &lt;code&gt;cargo test&lt;/code&gt; sean r&amp;aacute;pidos. Cuando se encuentre en un punto en el que tenga sentido verificar los resultados de las pruebas &lt;code&gt;ignored&lt;/code&gt; y tenga tiempo para esperar los resultados, puede ejecutar &lt;code&gt;cargo test -- --ignored&lt;/code&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="5a2bb1d27a87d404cc9474290490c53d74fd41c0" translate="yes" xml:space="preserve">
          <source>By convention, &lt;code&gt;self.cmp(&amp;amp;other)&lt;/code&gt; returns the ordering matching the expression &lt;code&gt;self &amp;lt;operator&amp;gt; other&lt;/code&gt; if true.</source>
          <target state="translated">Por convenci&amp;oacute;n, &lt;code&gt;self.cmp(&amp;amp;other)&lt;/code&gt; devuelve el orden que coincide con la expresi&amp;oacute;n &lt;code&gt;self &amp;lt;operator&amp;gt; other&lt;/code&gt; si es verdadero.</target>
        </trans-unit>
        <trans-unit id="de8a1d92f6dd3bd8db18180b7b2a50fb4ed9f5aa" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;security_qos_flags&lt;/code&gt; is not set. It should be specified when opening a named pipe, to control to which degree a server process can act on behalf of a client process (security impersonation level).</source>
          <target state="translated">De forma predeterminada, &lt;code&gt;security_qos_flags&lt;/code&gt; no est&amp;aacute; configurado. Debe especificarse al abrir una tuber&amp;iacute;a con nombre, para controlar hasta qu&amp;eacute; punto un proceso de servidor puede actuar en nombre de un proceso de cliente (nivel de suplantaci&amp;oacute;n de seguridad).</target>
        </trans-unit>
        <trans-unit id="6095051ff401d433de5d730cac4f12b5941e6537" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;share_mode&lt;/code&gt; is set to &lt;code&gt;FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE&lt;/code&gt;. This allows other processes to read, write, and delete/rename the same file while it is open. Removing any of the flags will prevent other processes from performing the corresponding operation until the file handle is closed.</source>
          <target state="translated">Por defecto, &lt;code&gt;share_mode&lt;/code&gt; est&amp;aacute; establecido en &lt;code&gt;FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE&lt;/code&gt; . Esto permite que otros procesos lean, escriban y eliminen / renombren el mismo archivo mientras est&amp;aacute; abierto. La eliminaci&amp;oacute;n de cualquiera de las banderas evitar&amp;aacute; que otros procesos realicen la operaci&amp;oacute;n correspondiente hasta que se cierre el identificador del archivo.</target>
        </trans-unit>
        <trans-unit id="45de1662a54cdc16cef2847d72223197060768f7" translate="yes" xml:space="preserve">
          <source>By default external blocks assume that the library they are calling uses the standard C ABI on the specific platform. Other ABIs may be specified using an &lt;code&gt;abi&lt;/code&gt; string, as shown here:</source>
          <target state="translated">Por defecto, los bloques externos asumen que la biblioteca a la que est&amp;aacute;n llamando utiliza el est&amp;aacute;ndar C ABI en la plataforma espec&amp;iacute;fica. Se pueden especificar otras ABI mediante una cadena &lt;code&gt;abi&lt;/code&gt; , como se muestra aqu&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="fc473c24bd4f443ffeef08b0cf6f41ff8de8d915" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;keyword.match&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; statements consume all they can, which can sometimes be a problem, when you don't really need the value to be moved and owned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad11d86076f62fa9cc433e025f374e132c103f7a" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;HashMap&lt;/code&gt; uses a &amp;ldquo;cryptographically strong&amp;rdquo;&lt;sup&gt;&lt;a href=&quot;#siphash&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; hashing function that can provide resistance to Denial of Service (DoS) attacks. This is not the fastest hashing algorithm available, but the trade-off for better security that comes with the drop in performance is worth it. If you profile your code and find that the default hash function is too slow for your purposes, you can switch to another function by specifying a different &lt;em&gt;hasher&lt;/em&gt;. A hasher is a type that implements the &lt;code&gt;BuildHasher&lt;/code&gt; trait. We&amp;rsquo;ll talk about traits and how to implement them in Chapter 10. You don&amp;rsquo;t necessarily have to implement your own hasher from scratch; &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; has libraries shared by other Rust users that provide hashers implementing many common hashing algorithms.</source>
          <target state="translated">De forma predeterminada, &lt;code&gt;HashMap&lt;/code&gt; utiliza una funci&amp;oacute;n de hash &quot;criptogr&amp;aacute;ficamente fuerte&quot; &lt;sup&gt;&lt;a href=&quot;#siphash&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; que puede proporcionar resistencia a los ataques de denegaci&amp;oacute;n de servicio (DoS). Este no es el algoritmo hash m&amp;aacute;s r&amp;aacute;pido disponible, pero la compensaci&amp;oacute;n por una mejor seguridad que viene con la ca&amp;iacute;da en el rendimiento vale la pena. Si perfila su c&amp;oacute;digo y descubre que la funci&amp;oacute;n hash predeterminada es demasiado lenta para sus prop&amp;oacute;sitos, puede cambiar a otra funci&amp;oacute;n especificando un &lt;em&gt;hash&lt;/em&gt; diferente . Un hash es un tipo que implementa el rasgo &lt;code&gt;BuildHasher&lt;/code&gt; . Hablaremos sobre los rasgos y c&amp;oacute;mo implementarlos en el Cap&amp;iacute;tulo 10. No es necesario que implementes tu propio hasher desde cero; &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; tiene bibliotecas compartidas por otros usuarios de Rust que proporcionan hash que implementan muchos algoritmos de hash comunes.</target>
        </trans-unit>
        <trans-unit id="da46918183f148a703a5dca98e668e41fe0f6742" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;HashMap&lt;/code&gt; uses a hashing algorithm selected to provide resistance against HashDoS attacks. The algorithm is randomly seeded, and a reasonable best-effort is made to generate this seed from a high quality, secure source of randomness provided by the host without blocking the program. Because of this, the randomness of the seed depends on the output quality of the system's random number generator when the seed is created. In particular, seeds generated when the system's entropy pool is abnormally low such as during system boot may be of a lower quality.</source>
          <target state="translated">De forma predeterminada, &lt;code&gt;HashMap&lt;/code&gt; utiliza un algoritmo hash seleccionado para proporcionar resistencia contra los ataques HashDoS. El algoritmo se siembra aleatoriamente y se hace un esfuerzo razonable para generar esta semilla a partir de una fuente de aleatoriedad segura y de alta calidad proporcionada por el host sin bloquear el programa. Debido a esto, la aleatoriedad de la semilla depende de la calidad de salida del generador de n&amp;uacute;meros aleatorios del sistema cuando se crea la semilla. En particular, las semillas generadas cuando la reserva de entrop&amp;iacute;a del sistema es anormalmente baja, como durante el arranque del sistema, pueden ser de menor calidad.</target>
        </trans-unit>
        <trans-unit id="d651c937af4d96b8135fb3517b9d184e89c5453c" translate="yes" xml:space="preserve">
          <source>By default, Rust brings only a few types into the scope of every program in &lt;a href=&quot;../std/prelude/index&quot;&gt;the &lt;em&gt;prelude&lt;/em&gt;&lt;/a&gt;. If a type you want to use isn&amp;rsquo;t in the prelude, you have to bring that type into scope explicitly with a &lt;code&gt;use&lt;/code&gt; statement. Using the &lt;code&gt;std::io&lt;/code&gt; library provides you with a number of useful features, including the ability to accept user input.</source>
          <target state="translated">Por defecto, Rust trae solo unos pocos tipos al alcance de cada programa en &lt;a href=&quot;../std/prelude/index&quot;&gt;el &lt;em&gt;preludio&lt;/em&gt;&lt;/a&gt; . Si un tipo que desea usar no est&amp;aacute; en el preludio, debe traer ese tipo al alcance expl&amp;iacute;citamente con una declaraci&amp;oacute;n de &lt;code&gt;use&lt;/code&gt; . El uso de la biblioteca &lt;code&gt;std::io&lt;/code&gt; proporciona una serie de funciones &amp;uacute;tiles, incluida la capacidad de aceptar la entrada del usuario.</target>
        </trans-unit>
        <trans-unit id="0c4c1f7def0235335f03f717a82baeaf139f3d6d" translate="yes" xml:space="preserve">
          <source>By default, a macro has no path-based scope. However, if it has the &lt;code&gt;#[macro_export]&lt;/code&gt; attribute, then it is declared in the crate root scope and can be referred to normally as such:</source>
          <target state="translated">De forma predeterminada, una macro no tiene un alcance basado en rutas. Sin embargo, si tiene el atributo &lt;code&gt;#[macro_export]&lt;/code&gt; , entonces se declara en el &amp;aacute;mbito de la ra&amp;iacute;z de la caja y se puede denominar normalmente como tal:</target>
        </trans-unit>
        <trans-unit id="0cbf310ab8fadfa7c76780733e623179e3214d1c" translate="yes" xml:space="preserve">
          <source>By default, all identifiers referred to in a macro are expanded as-is, and are looked up at the macro's invocation site. This can lead to issues if a macro refers to an item or macro which isn't in scope at the invocation site. To alleviate this, the &lt;code&gt;$crate&lt;/code&gt; metavariable can be used at the start of a path to force lookup to occur inside the crate defining the macro.</source>
          <target state="translated">De forma predeterminada, todos los identificadores a los que se hace referencia en una macro se expanden tal cual y se buscan en el sitio de invocaci&amp;oacute;n de la macro. Esto puede generar problemas si una macro se refiere a un elemento o macro que no est&amp;aacute; dentro del alcance del sitio de invocaci&amp;oacute;n. Para aliviar esto, la metavariable &lt;code&gt;$crate&lt;/code&gt; crate se puede usar al comienzo de una ruta para forzar la b&amp;uacute;squeda dentro de la caja que define la macro.</target>
        </trans-unit>
        <trans-unit id="642089d05c107d61f37af46fec5f28d39e938fae" translate="yes" xml:space="preserve">
          <source>By default, all types in Rust are movable. Rust allows passing all types by-value, and common smart-pointer types such as &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;&amp;amp;mut T&lt;/code&gt; allow replacing and moving the values they contain: you can move out of a &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, or you can use &lt;a href=&quot;../mem/fn.swap&quot;&gt;&lt;code&gt;mem::swap&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt; wraps a pointer type &lt;code&gt;P&lt;/code&gt;, so &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; functions much like a regular &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;: when a &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; gets dropped, so do its contents, and the memory gets deallocated. Similarly, &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; is a lot like &lt;code&gt;&amp;amp;mut T&lt;/code&gt;. However, &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt; does not let clients actually obtain a &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;&amp;amp;mut T&lt;/code&gt; to pinned data, which implies that you cannot use operations such as &lt;a href=&quot;../mem/fn.swap&quot;&gt;&lt;code&gt;mem::swap&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85f73f88e9b11f78d793846432896a45a47d865c" translate="yes" xml:space="preserve">
          <source>By default, all types in Rust are movable. Rust allows passing all types by-value, and common smart-pointer types such as &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;amp;mut T&lt;/code&gt; allow replacing and moving the values they contain: you can move out of a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, or you can use &lt;a href=&quot;../mem/fn.swap&quot;&gt;&lt;code&gt;mem::swap&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt; wraps a pointer type &lt;code&gt;P&lt;/code&gt;, so &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; functions much like a regular &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;: when a &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; gets dropped, so do its contents, and the memory gets deallocated. Similarly, &lt;code&gt;Pin&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; is a lot like &lt;code&gt;&amp;amp;mut T&lt;/code&gt;. However, &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt; does not let clients actually obtain a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut T&lt;/code&gt; to pinned data, which implies that you cannot use operations such as &lt;a href=&quot;../mem/fn.swap&quot;&gt;&lt;code&gt;mem::swap&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">De forma predeterminada, todos los tipos de Rust son m&amp;oacute;viles. Rust permite pasar todos los tipos por valor, y los tipos de puntero inteligente comunes como &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; y &lt;code&gt;&amp;amp;mut T&lt;/code&gt; permiten reemplazar y mover los valores que contienen: puede salir de un &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; , o puede usar &lt;a href=&quot;../mem/fn.swap&quot;&gt; &lt;code&gt;mem::swap&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; &lt;/a&gt; envuelve un puntero tipo &lt;code&gt;P&lt;/code&gt; , por lo que &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; funciona de manera muy parecida a una &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; normal : cuando se cae un &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; , tambi&amp;eacute;n lo hace su contenido y la memoria se desasigna . Del mismo modo, &lt;code&gt;Pin&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; se parece mucho a &lt;code&gt;&amp;amp;mut T&lt;/code&gt; . Sin embargo, &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; &lt;/a&gt;no permite que los clientes obtengan un &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; o &lt;code&gt;&amp;amp;mut T&lt;/code&gt; a datos anclados, lo que implica que no puede usar operaciones como &lt;a href=&quot;../mem/fn.swap&quot;&gt; &lt;code&gt;mem::swap&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="df4968e3432ef000f1bcc3fb95cf2b7eb0f19a6b" translate="yes" xml:space="preserve">
          <source>By default, everything in Rust is &lt;em&gt;private&lt;/em&gt;, with two exceptions: Associated items in a &lt;code&gt;pub&lt;/code&gt; Trait are public by default; Enum variants in a &lt;code&gt;pub&lt;/code&gt; enum are also public by default. When an item is declared as &lt;code&gt;pub&lt;/code&gt;, it can be thought of as being accessible to the outside world. For example:</source>
          <target state="translated">De forma predeterminada, todo en Rust es &lt;em&gt;privado&lt;/em&gt; , con dos excepciones: Los elementos asociados en un rasgo de &lt;code&gt;pub&lt;/code&gt; licaci&amp;oacute;n son p&amp;uacute;blicos de forma predeterminada; Las variantes de enumeraci&amp;oacute;n en una enumeraci&amp;oacute;n de &lt;code&gt;pub&lt;/code&gt; tambi&amp;eacute;n son p&amp;uacute;blicas de forma predeterminada. Cuando un art&amp;iacute;culo se declara como &lt;code&gt;pub&lt;/code&gt; , se puede pensar que es accesible para el mundo exterior. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="e8c258fdae97b1ecf4c355834b8cc2789a53356b" translate="yes" xml:space="preserve">
          <source>By default, generic functions will work only on types that have a known size at compile time. However, you can use the following special syntax to relax this restriction:</source>
          <target state="translated">Por defecto,las funciones genéricas funcionarán sólo en los tipos que tengan un tamaño conocido en el momento de la compilación.Sin embargo,puede utilizar la siguiente sintaxis especial para relajar esta restricción:</target>
        </trans-unit>
        <trans-unit id="a9c4cd7fe13c5d5855eca814505fcc712b580495" translate="yes" xml:space="preserve">
          <source>By default, identifier patterns bind a variable to a copy of or move from the matched value depending on whether the matched value implements &lt;a href=&quot;special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;. This can be changed to bind to a reference by using the &lt;code&gt;ref&lt;/code&gt; keyword, or to a mutable reference using &lt;code&gt;ref mut&lt;/code&gt;. For example:</source>
          <target state="translated">De forma predeterminada, los patrones de identificador vinculan una variable a una copia o se mueven desde el valor coincidente dependiendo de si el valor coincidente implementa &lt;a href=&quot;special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; . Esto se puede cambiar para enlazar a una referencia usando la palabra clave &lt;code&gt;ref&lt;/code&gt; , o a una referencia mutable usando &lt;code&gt;ref mut&lt;/code&gt; . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="972aa10d3aec7b320258dca3f2fe0bcadcd844ff" translate="yes" xml:space="preserve">
          <source>By default, if a test passes, Rust&amp;rsquo;s test library captures anything printed to standard output. For example, if we call &lt;code&gt;println!&lt;/code&gt; in a test and the test passes, we won&amp;rsquo;t see the &lt;code&gt;println!&lt;/code&gt; output in the terminal; we&amp;rsquo;ll see only the line that indicates the test passed. If a test fails, we&amp;rsquo;ll see whatever was printed to standard output with the rest of the failure message.</source>
          <target state="translated">De forma predeterminada, si pasa una prueba, la biblioteca de pruebas de Rust captura cualquier cosa impresa en la salida est&amp;aacute;ndar. Por ejemplo, si llamamos &lt;code&gt;println!&lt;/code&gt; en una prueba y la prueba pasa, &amp;iexcl;no veremos el &lt;code&gt;println!&lt;/code&gt; salida en el terminal; veremos solo la l&amp;iacute;nea que indica que la prueba pas&amp;oacute;. Si una prueba falla, veremos lo que se imprimi&amp;oacute; en la salida est&amp;aacute;ndar con el resto del mensaje de falla.</target>
        </trans-unit>
        <trans-unit id="d95184642912361a38b12a6b5acfd4cc05172698" translate="yes" xml:space="preserve">
          <source>By default, stdin, stdout and stderr are inherited from the parent.</source>
          <target state="translated">Por defecto,stdin,stdout y stderr se heredan del padre.</target>
        </trans-unit>
        <trans-unit id="f620f1067d553e3bfb80fd71b1c203148dc846fc" translate="yes" xml:space="preserve">
          <source>By default, stdin, stdout and stderr are inherited from the parent. In order to capture the output into this &lt;code&gt;Result&amp;lt;Output&amp;gt;&lt;/code&gt; it is necessary to create new pipes between parent and child. Use &lt;code&gt;stdout(Stdio::piped())&lt;/code&gt; or &lt;code&gt;stderr(Stdio::piped())&lt;/code&gt;, respectively.</source>
          <target state="translated">De forma predeterminada, stdin, stdout y stderr se heredan del padre. Para capturar la salida en este &lt;code&gt;Result&amp;lt;Output&amp;gt;&lt;/code&gt; es necesario crear nuevos conductos entre padre e hijo. Utilice &lt;code&gt;stdout(Stdio::piped())&lt;/code&gt; o &lt;code&gt;stderr(Stdio::piped())&lt;/code&gt; , respectivamente.</target>
        </trans-unit>
        <trans-unit id="1a3d2a96946537e440c011c1b793bac6cb6bf93c" translate="yes" xml:space="preserve">
          <source>By default, stdout and stderr are captured (and used to provide the resulting output). Stdin is not inherited from the parent and any attempt by the child process to read from the stdin stream will result in the stream immediately closing.</source>
          <target state="translated">Por defecto,se capturan la stdout y la stderr (y se utilizan para proporcionar la salida resultante).La stdin no se hereda del padre y cualquier intento del proceso hijo de leer del flujo stdin hará que el flujo se cierre inmediatamente.</target>
        </trans-unit>
        <trans-unit id="ef6b7759d538ef3f99e9eadac17fdfe2aa668d92" translate="yes" xml:space="preserve">
          <source>By default, variable bindings have 'move semantics.' In other words:</source>
          <target state="translated">Por defecto,los enlaces variables tienen &quot;semántica de movimiento&quot;.En otras palabras:</target>
        </trans-unit>
        <trans-unit id="07d2d74e176689aec98a3f3118957a0424dbbe81" translate="yes" xml:space="preserve">
          <source>By default, variables in Rust are immutable. To fix this error, add the keyword &lt;code&gt;mut&lt;/code&gt; after the keyword &lt;code&gt;let&lt;/code&gt; when declaring the variable. For example:</source>
          <target state="translated">Por defecto, las variables en Rust son inmutables. Para corregir este error, agregue la palabra clave &lt;code&gt;mut&lt;/code&gt; despu&amp;eacute;s de la palabra clave &lt;code&gt;let&lt;/code&gt; al declarar la variable. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="878411518946b9f6ea5793ecae83ce111ee3e9e7" translate="yes" xml:space="preserve">
          <source>By default, when a panic occurs, the program starts &lt;em&gt;unwinding&lt;/em&gt;, which means Rust walks back up the stack and cleans up the data from each function it encounters. But this walking back and cleanup is a lot of work. The alternative is to immediately &lt;em&gt;abort&lt;/em&gt;, which ends the program without cleaning up. Memory that the program was using will then need to be cleaned up by the operating system. If in your project you need to make the resulting binary as small as possible, you can switch from unwinding to aborting upon a panic by adding &lt;code&gt;panic = 'abort'&lt;/code&gt; to the appropriate &lt;code&gt;[profile]&lt;/code&gt; sections in your &lt;em&gt;Cargo.toml&lt;/em&gt; file. For example, if you want to abort on panic in release mode, add this:</source>
          <target state="translated">De forma predeterminada, cuando ocurre un p&amp;aacute;nico, el programa comienza a &lt;em&gt;desenrollarse&lt;/em&gt; , lo que significa que Rust regresa por la pila y limpia los datos de cada funci&amp;oacute;n que encuentra. Pero esta caminata de regreso y limpieza es mucho trabajo. La alternativa es &lt;em&gt;abortar&lt;/em&gt; inmediatamente , lo que finaliza el programa sin limpiar. La memoria que estaba usando el programa deber&amp;aacute; entonces ser limpiada por el sistema operativo. Si en su proyecto necesita hacer que el binario resultante sea lo m&amp;aacute;s peque&amp;ntilde;o posible, puede cambiar de desenrollar a abortar en caso de p&amp;aacute;nico agregando &lt;code&gt;panic = 'abort'&lt;/code&gt; a las secciones apropiadas &lt;code&gt;[profile]&lt;/code&gt; en su archivo &lt;em&gt;Cargo.toml&lt;/em&gt; . Por ejemplo, si desea abortar en caso de p&amp;aacute;nico en el modo de liberaci&amp;oacute;n, agregue esto:</target>
        </trans-unit>
        <trans-unit id="70961236b49c3241db36d35bd68586bfb070a6d8" translate="yes" xml:space="preserve">
          <source>By implementing &lt;code&gt;FromIterator&lt;/code&gt; for a type, you define how it will be created from an iterator. This is common for types which describe a collection of some kind.</source>
          <target state="translated">Al implementar &lt;code&gt;FromIterator&lt;/code&gt; para un tipo, define c&amp;oacute;mo se crear&amp;aacute; a partir de un iterador. Esto es com&amp;uacute;n para los tipos que describen una colecci&amp;oacute;n de alg&amp;uacute;n tipo.</target>
        </trans-unit>
        <trans-unit id="8fe6d2f7538ddf4711df03e9fa6aac2aec872193" translate="yes" xml:space="preserve">
          <source>By implementing &lt;code&gt;IntoIterator&lt;/code&gt; for a type, you define how it will be converted to an iterator. This is common for types which describe a collection of some kind.</source>
          <target state="translated">Al implementar &lt;code&gt;IntoIterator&lt;/code&gt; para un tipo, define c&amp;oacute;mo se convertir&amp;aacute; en un iterador. Esto es com&amp;uacute;n para los tipos que describen una colecci&amp;oacute;n de alg&amp;uacute;n tipo.</target>
        </trans-unit>
        <trans-unit id="a0afc41378ee2d3e0b24873888e49fe44ab2bb88" translate="yes" xml:space="preserve">
          <source>By implementing the state pattern exactly as it&amp;rsquo;s defined for object-oriented languages, we&amp;rsquo;re not taking as full advantage of Rust&amp;rsquo;s strengths as we could. Let&amp;rsquo;s look at some changes we can make to the &lt;code&gt;blog&lt;/code&gt; crate that can make invalid states and transitions into compile time errors.</source>
          <target state="translated">Al implementar el patr&amp;oacute;n de estado exactamente como est&amp;aacute; definido para los lenguajes orientados a objetos, no estamos aprovechando al m&amp;aacute;ximo las fortalezas de Rust como podr&amp;iacute;amos. Veamos algunos cambios que podemos hacer en la caja del &lt;code&gt;blog&lt;/code&gt; que pueden convertir estados inv&amp;aacute;lidos y transiciones en errores de tiempo de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="46180f00b512e17d9f64273f452da441a283a2bb" translate="yes" xml:space="preserve">
          <source>By inserting the &lt;code&gt;unsafe&lt;/code&gt; block around our call to &lt;code&gt;dangerous&lt;/code&gt;, we&amp;rsquo;re asserting to Rust that we&amp;rsquo;ve read the function&amp;rsquo;s documentation, we understand how to use it properly, and we&amp;rsquo;ve verified that we&amp;rsquo;re fulfilling the contract of the function.</source>
          <target state="translated">Al insertar el bloque &lt;code&gt;unsafe&lt;/code&gt; alrededor de nuestra llamada a &lt;code&gt;dangerous&lt;/code&gt; , le estamos afirmando a Rust que hemos le&amp;iacute;do la documentaci&amp;oacute;n de la funci&amp;oacute;n, entendemos c&amp;oacute;mo usarla correctamente y hemos verificado que estamos cumpliendo con el contrato de la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ebd43141acc082c32de2ba198e30637d83a5941d" translate="yes" xml:space="preserve">
          <source>By introducing the explicit &lt;code&gt;let value&lt;/code&gt;, we allocate storage that will last until the end of the enclosing block (when &lt;code&gt;value&lt;/code&gt; goes out of scope). When we borrow &lt;code&gt;&amp;amp;value&lt;/code&gt;, we are borrowing a local variable that already exists, and hence no temporary is created.</source>
          <target state="translated">Al introducir el &lt;code&gt;let value&lt;/code&gt; expl&amp;iacute;cito , asignamos almacenamiento que durar&amp;aacute; hasta el final del bloque adjunto (cuando el &lt;code&gt;value&lt;/code&gt; se sale del alcance). Cuando tomamos prestado &lt;code&gt;&amp;amp;value&lt;/code&gt; , estamos tomando prestada una variable local que ya existe y, por lo tanto, no se crea ninguna temporal.</target>
        </trans-unit>
        <trans-unit id="69e12568cda798dc4c41d36b6782b17be36886bc" translate="yes" xml:space="preserve">
          <source>By now, you&amp;rsquo;ve learned the most commonly used parts of the Rust programming language. Before we do one more project in Chapter 20, we&amp;rsquo;ll look at a few aspects of the language you might run into every once in a while. You can use this chapter as a reference for when you encounter any unknowns when using Rust. The features you&amp;rsquo;ll learn to use in this chapter are useful in very specific situations. Although you might not reach for them often, we want to make sure you have a grasp of all the features Rust has to offer.</source>
          <target state="translated">A estas alturas, ya ha aprendido las partes m&amp;aacute;s utilizadas del lenguaje de programaci&amp;oacute;n Rust. Antes de hacer un proyecto m&amp;aacute;s en el Cap&amp;iacute;tulo 20, veremos algunos aspectos del lenguaje con el que se puede encontrar de vez en cuando. Puede usar este cap&amp;iacute;tulo como referencia para cuando encuentre alguna inc&amp;oacute;gnita al usar Rust. Las funciones que aprender&amp;aacute; a utilizar en este cap&amp;iacute;tulo son &amp;uacute;tiles en situaciones muy espec&amp;iacute;ficas. Aunque es posible que no los busque con frecuencia, queremos asegurarnos de que comprenda todas las caracter&amp;iacute;sticas que Rust tiene para ofrecer.</target>
        </trans-unit>
        <trans-unit id="3b8d2c5ef438bc901d43221175865fde334c590c" translate="yes" xml:space="preserve">
          <source>By opting out of having Rust enforce these guarantees, you can give up guaranteed safety in exchange for greater performance or the ability to interface with another language or hardware where Rust&amp;rsquo;s guarantees don&amp;rsquo;t apply.</source>
          <target state="translated">Al optar por que Rust no haga cumplir estas garant&amp;iacute;as, puede renunciar a la seguridad garantizada a cambio de un mayor rendimiento o la capacidad de interactuar con otro idioma o hardware donde las garant&amp;iacute;as de Rust no se aplican.</target>
        </trans-unit>
        <trans-unit id="27764f2a26f0e207cc2fb6a676294f8c54a5721a" translate="yes" xml:space="preserve">
          <source>By requesting the current thread, using the &lt;a href=&quot;fn.current&quot;&gt;&lt;code&gt;thread::current&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Solicitando el hilo actual, usando la funci&amp;oacute;n &lt;a href=&quot;fn.current&quot;&gt; &lt;code&gt;thread::current&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cbc7153ee55504f6099241a26bcc3f7667184521" translate="yes" xml:space="preserve">
          <source>By spawning a new thread, e.g., using the &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;thread::spawn&lt;/code&gt;&lt;/a&gt; function, and calling &lt;a href=&quot;struct.joinhandle#method.thread&quot;&gt;&lt;code&gt;thread&lt;/code&gt;&lt;/a&gt; on the &lt;a href=&quot;struct.joinhandle&quot;&gt;&lt;code&gt;JoinHandle&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Generando un nuevo hilo, por ejemplo, usando la funci&amp;oacute;n &lt;a href=&quot;fn.spawn&quot;&gt; &lt;code&gt;thread::spawn&lt;/code&gt; &lt;/a&gt; , y llamando al &lt;a href=&quot;struct.joinhandle#method.thread&quot;&gt; &lt;code&gt;thread&lt;/code&gt; &lt;/a&gt; en &lt;a href=&quot;struct.joinhandle&quot;&gt; &lt;code&gt;JoinHandle&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="12606d21fd7d24ec782af86e2fc775ab3b2a1534" translate="yes" xml:space="preserve">
          <source>By the same token, if your slice includes the last byte of the &lt;code&gt;String&lt;/code&gt;, you can drop the trailing number. That means these are equal:</source>
          <target state="translated">Del mismo modo, si su segmento incluye el &amp;uacute;ltimo byte de la &lt;code&gt;String&lt;/code&gt; , puede eliminar el n&amp;uacute;mero final. Eso significa que estos son iguales:</target>
        </trans-unit>
        <trans-unit id="eed2e06fae66dfdcb759c3aa75071abdbcec3d30" translate="yes" xml:space="preserve">
          <source>By using &lt;code&gt;impl Summary&lt;/code&gt; for the return type, we specify that the &lt;code&gt;returns_summarizable&lt;/code&gt; function returns some type that implements the &lt;code&gt;Summary&lt;/code&gt; trait without naming the concrete type. In this case, &lt;code&gt;returns_summarizable&lt;/code&gt; returns a &lt;code&gt;Tweet&lt;/code&gt;, but the code calling this function doesn&amp;rsquo;t know that.</source>
          <target state="translated">Al usar &lt;code&gt;impl Summary&lt;/code&gt; para el tipo de retorno, especificamos que la funci&amp;oacute;n &lt;code&gt;returns_summarizable&lt;/code&gt; devuelve alg&amp;uacute;n tipo que implementa el rasgo &lt;code&gt;Summary&lt;/code&gt; sin nombrar el tipo concreto. En este caso, &lt;code&gt;returns_summarizable&lt;/code&gt; devuelve un &lt;code&gt;Tweet&lt;/code&gt; , pero el c&amp;oacute;digo que llama a esta funci&amp;oacute;n no lo sabe.</target>
        </trans-unit>
        <trans-unit id="e9aacb122cfae0a7a0d083ca40090e9b5f6410c8" translate="yes" xml:space="preserve">
          <source>By using &lt;code&gt;loop&lt;/code&gt; instead and acquiring the lock and a job within the block rather than outside it, the &lt;code&gt;MutexGuard&lt;/code&gt; returned from the &lt;code&gt;lock&lt;/code&gt; method is dropped as soon as the &lt;code&gt;let job&lt;/code&gt; statement ends. This ensures that the lock is held during the call to &lt;code&gt;recv&lt;/code&gt;, but it is released before the call to &lt;code&gt;job.call_box()&lt;/code&gt;, allowing multiple requests to be serviced concurrently.</source>
          <target state="translated">Al usar el &lt;code&gt;loop&lt;/code&gt; lugar y adquirir el bloqueo y un trabajo dentro del bloque en lugar de fuera de &amp;eacute;l, el &lt;code&gt;MutexGuard&lt;/code&gt; devuelto por el m&amp;eacute;todo de &lt;code&gt;lock&lt;/code&gt; elimina tan pronto como finaliza la instrucci&amp;oacute;n &lt;code&gt;let job&lt;/code&gt; . Esto asegura que el bloqueo se mantenga durante la llamada a &lt;code&gt;recv&lt;/code&gt; , pero se libera antes de la llamada a &lt;code&gt;job.call_box()&lt;/code&gt; , lo que permite atender varias solicitudes al mismo tiempo.</target>
        </trans-unit>
        <trans-unit id="a1dc62ff68dd92e2b08c605e1735e02b6fb42d3d" translate="yes" xml:space="preserve">
          <source>By using &lt;code&gt;loop&lt;/code&gt; instead and acquiring the lock without assigning to a variable, the temporary &lt;code&gt;MutexGuard&lt;/code&gt; returned from the &lt;code&gt;lock&lt;/code&gt; method is dropped as soon as the &lt;code&gt;let job&lt;/code&gt; statement ends. This ensures that the lock is held during the call to &lt;code&gt;recv&lt;/code&gt;, but it is released before the call to &lt;code&gt;job()&lt;/code&gt;, allowing multiple requests to be serviced concurrently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96a33cddb0085e977a7cbf3fab6625f1af56ae11" translate="yes" xml:space="preserve">
          <source>By using &lt;code&gt;pub use&lt;/code&gt;, external code can now call the &lt;code&gt;add_to_waitlist&lt;/code&gt; function using &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt;. If we hadn&amp;rsquo;t specified &lt;code&gt;pub use&lt;/code&gt;, the &lt;code&gt;eat_at_restaurant&lt;/code&gt; function could call &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; in its scope, but external code couldn&amp;rsquo;t take advantage of this new path.</source>
          <target state="translated">Al usar el &lt;code&gt;pub use&lt;/code&gt; , el c&amp;oacute;digo externo ahora puede llamar a la funci&amp;oacute;n &lt;code&gt;add_to_waitlist&lt;/code&gt; usando &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; . Si no hubi&amp;eacute;ramos especificado el &lt;code&gt;pub use&lt;/code&gt; , la funci&amp;oacute;n &lt;code&gt;eat_at_restaurant&lt;/code&gt; podr&amp;iacute;a llamar a &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; en su alcance, pero el c&amp;oacute;digo externo no podr&amp;iacute;a aprovechar esta nueva ruta.</target>
        </trans-unit>
        <trans-unit id="433cfee29840720f9bbafd30efe0a38d5e74bfb2" translate="yes" xml:space="preserve">
          <source>By using &lt;code&gt;unsafe impl&lt;/code&gt;, we&amp;rsquo;re promising that we&amp;rsquo;ll uphold the invariants that the compiler can&amp;rsquo;t verify.</source>
          <target state="translated">Al usar &lt;code&gt;unsafe impl&lt;/code&gt; , prometemos que mantendremos las invariantes que el compilador no puede verificar.</target>
        </trans-unit>
        <trans-unit id="9f1a9fce35b987ffd7d1760b4240dc3939988c2c" translate="yes" xml:space="preserve">
          <source>By using a trait bound with an &lt;code&gt;impl&lt;/code&gt; block that uses generic type parameters, we can implement methods conditionally for types that implement the specified traits. For example, the type &lt;code&gt;Pair&amp;lt;T&amp;gt;&lt;/code&gt; in Listing 10-16 always implements the &lt;code&gt;new&lt;/code&gt; function. But &lt;code&gt;Pair&amp;lt;T&amp;gt;&lt;/code&gt; only implements the &lt;code&gt;cmp_display&lt;/code&gt; method if its inner type &lt;code&gt;T&lt;/code&gt; implements the &lt;code&gt;PartialOrd&lt;/code&gt; trait that enables comparison &lt;em&gt;and&lt;/em&gt; the &lt;code&gt;Display&lt;/code&gt; trait that enables printing.</source>
          <target state="translated">Al usar un rasgo enlazado con un bloque &lt;code&gt;impl&lt;/code&gt; que usa par&amp;aacute;metros de tipo gen&amp;eacute;rico, podemos implementar m&amp;eacute;todos condicionalmente para tipos que implementan los rasgos especificados. Por ejemplo, el tipo &lt;code&gt;Pair&amp;lt;T&amp;gt;&lt;/code&gt; en el Listado 10-16 siempre implementa la &lt;code&gt;new&lt;/code&gt; funci&amp;oacute;n. Pero &lt;code&gt;Pair&amp;lt;T&amp;gt;&lt;/code&gt; solo implementa el m&amp;eacute;todo &lt;code&gt;cmp_display&lt;/code&gt; si su tipo interno &lt;code&gt;T&lt;/code&gt; implementa el rasgo &lt;code&gt;PartialOrd&lt;/code&gt; que permite la comparaci&amp;oacute;n &lt;em&gt;y&lt;/em&gt; el rasgo &lt;code&gt;Display&lt;/code&gt; que permite la impresi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e575a61c7bb4198f04719172d2b19e840714927a" translate="yes" xml:space="preserve">
          <source>By using modules, we can group related definitions together and name why they&amp;rsquo;re related. Programmers using this code would have an easier time finding the definitions they wanted to use because they could navigate the code based on the groups rather than having to read through all the definitions. Programmers adding new functionality to this code would know where to place the code to keep the program organized.</source>
          <target state="translated">Al usar m&amp;oacute;dulos, podemos agrupar definiciones relacionadas y nombrar por qu&amp;eacute; est&amp;aacute;n relacionadas. Los programadores que usen este c&amp;oacute;digo tendr&amp;iacute;an m&amp;aacute;s facilidad para encontrar las definiciones que quer&amp;iacute;an usar porque podr&amp;iacute;an navegar por el c&amp;oacute;digo en funci&amp;oacute;n de los grupos en lugar de tener que leer todas las definiciones. Los programadores que agreguen nuevas funciones a este c&amp;oacute;digo sabr&amp;aacute;n d&amp;oacute;nde colocar el c&amp;oacute;digo para mantener el programa organizado.</target>
        </trans-unit>
        <trans-unit id="0b9231ce9a42a6d6d2c8f8b26aa846a1ea4f8ea3" translate="yes" xml:space="preserve">
          <source>By using these and other tools in the Rust ecosystem, developers can be productive while writing systems-level code.</source>
          <target state="translated">Utilizando estas y otras herramientas en el ecosistema de Rust,los desarrolladores pueden ser productivos mientras escriben código a nivel de sistemas.</target>
        </trans-unit>
        <trans-unit id="2b10818a6a4d9d5c0ec3347fc6c8f03ab8bee8b6" translate="yes" xml:space="preserve">
          <source>By using this method, you are making a promise about the &lt;code&gt;P::Deref&lt;/code&gt; and &lt;code&gt;P::DerefMut&lt;/code&gt; implementations, if they exist. Most importantly, they must not move out of their &lt;code&gt;self&lt;/code&gt; arguments: &lt;code&gt;Pin::as_mut&lt;/code&gt; and &lt;code&gt;Pin::as_ref&lt;/code&gt; will call &lt;code&gt;DerefMut::deref_mut&lt;/code&gt; and &lt;code&gt;Deref::deref&lt;/code&gt;&lt;em&gt;on the pinned pointer&lt;/em&gt; and expect these methods to uphold the pinning invariants. Moreover, by calling this method you promise that the reference &lt;code&gt;P&lt;/code&gt; dereferences to will not be moved out of again; in particular, it must not be possible to obtain a &lt;code&gt;&amp;amp;mut P::Target&lt;/code&gt; and then move out of that reference (using, for example &lt;a href=&quot;../mem/fn.swap&quot;&gt;&lt;code&gt;mem::swap&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Al usar este m&amp;eacute;todo, est&amp;aacute; haciendo una promesa sobre las &lt;code&gt;P::Deref&lt;/code&gt; y &lt;code&gt;P::DerefMut&lt;/code&gt; , si existen. Lo m&amp;aacute;s importante, no deben salir de sus &lt;code&gt;self&lt;/code&gt; argumentos: &lt;code&gt;Pin::as_mut&lt;/code&gt; y &lt;code&gt;Pin::as_ref&lt;/code&gt; llamar&amp;aacute;n &lt;code&gt;DerefMut::deref_mut&lt;/code&gt; y &lt;code&gt;Deref::deref&lt;/code&gt; &lt;em&gt;en el puntero clavado&lt;/em&gt; y esperan que estos m&amp;eacute;todos para mantener los invariantes fijaci&amp;oacute;n. Adem&amp;aacute;s, al llamar a este m&amp;eacute;todo, promete que las referencias a &lt;code&gt;P&lt;/code&gt; de referencia no se mover&amp;aacute;n de nuevo; en particular, no debe ser posible obtener un &lt;code&gt;&amp;amp;mut P::Target&lt;/code&gt; y luego salir de esa referencia (usando, por ejemplo, &lt;a href=&quot;../mem/fn.swap&quot;&gt; &lt;code&gt;mem::swap&lt;/code&gt; &lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="bcdb56a053eed7c5213a43f696d9db1ac84162fc" translate="yes" xml:space="preserve">
          <source>By using trait bounds we can accept arguments of different types as long as they can be converted to the specified type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Al usar l&amp;iacute;mites de rasgos, podemos aceptar argumentos de diferentes tipos siempre que se puedan convertir al tipo &lt;code&gt;T&lt;/code&gt; especificado .</target>
        </trans-unit>
        <trans-unit id="301603101f50fc1a91e6b20fad60e030ba9789b8" translate="yes" xml:space="preserve">
          <source>By wrapping the stream with a &lt;code&gt;BufWriter&amp;lt;W&amp;gt;&lt;/code&gt;, these ten writes are all grouped together by the buffer and will all be written out in one system call when the &lt;code&gt;stream&lt;/code&gt; is flushed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dae0e28ac851e86945ef16395330c4f51fd0970" translate="yes" xml:space="preserve">
          <source>By wrapping the stream with a &lt;code&gt;BufWriter&lt;/code&gt;, these ten writes are all grouped together by the buffer, and will all be written out in one system call when the &lt;code&gt;stream&lt;/code&gt; is dropped.</source>
          <target state="translated">Al envolver la secuencia con un &lt;code&gt;BufWriter&lt;/code&gt; , estas diez escrituras se agrupan todas juntas por el b&amp;uacute;fer y todas se escribir&amp;aacute;n en una llamada al sistema cuando se descarte la &lt;code&gt;stream&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1548ce31fadb001aea0a12a579d52d9306c7253a" translate="yes" xml:space="preserve">
          <source>Bypasses Rust's normal memory-initialization checks by pretending to produce a value of type &lt;code&gt;T&lt;/code&gt;, while doing nothing at all.</source>
          <target state="translated">Omite las comprobaciones normales de inicializaci&amp;oacute;n de memoria de Rust pretendiendo producir un valor de tipo &lt;code&gt;T&lt;/code&gt; , sin hacer nada en absoluto.</target>
        </trans-unit>
        <trans-unit id="7803ee252527503b67d1eeb0deb252622746cebd" translate="yes" xml:space="preserve">
          <source>Byte</source>
          <target state="translated">Byte</target>
        </trans-unit>
        <trans-unit id="afdbaede89ef0f8a02124c499ef64ef1f0406d22" translate="yes" xml:space="preserve">
          <source>Byte (&lt;code&gt;u8&lt;/code&gt; only)</source>
          <target state="translated">Byte ( solo &lt;code&gt;u8&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e461b64db66675f3379c1e15d16c6c99827a8b32" translate="yes" xml:space="preserve">
          <source>Byte and byte string literals</source>
          <target state="translated">Literales de cuerda de byte y byte</target>
        </trans-unit>
        <trans-unit id="bed6860ca009a5f59b4930b17f9fae2513fd51cb" translate="yes" xml:space="preserve">
          <source>Byte escapes</source>
          <target state="translated">Byte escapes</target>
        </trans-unit>
        <trans-unit id="2bf9a238164dde110e7112a731c7b6d180525024" translate="yes" xml:space="preserve">
          <source>Byte literals</source>
          <target state="translated">Literal bytes</target>
        </trans-unit>
        <trans-unit id="65c69de6b60d275943eb0b345c38a4da863d03c4" translate="yes" xml:space="preserve">
          <source>Byte order mark</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7860363275fd51d964677e4db11dc87fb2b83e0" translate="yes" xml:space="preserve">
          <source>Byte string</source>
          <target state="translated">Byte string</target>
        </trans-unit>
        <trans-unit id="7510135fa5665d61b3d40af81c44ebe6703847a9" translate="yes" xml:space="preserve">
          <source>Byte string literal; constructs a &lt;code&gt;[u8]&lt;/code&gt; instead of a string</source>
          <target state="translated">Literal de cadena de bytes; construye un &lt;code&gt;[u8]&lt;/code&gt; en lugar de una cadena</target>
        </trans-unit>
        <trans-unit id="d5501080013d3dce57e266b31385c7ea19dd9672" translate="yes" xml:space="preserve">
          <source>Byte string literals</source>
          <target state="translated">Literales de cadena de bytes</target>
        </trans-unit>
        <trans-unit id="013842b4ad25a64e13616ea1267e8fb94bd63a6f" translate="yes" xml:space="preserve">
          <source>Byte-based interfaces are unwieldy and can be inefficient, as we'd need to be making near-constant calls to the operating system. To help with this, &lt;code&gt;std::io&lt;/code&gt; comes with two structs, &lt;a href=&quot;struct.bufreader&quot;&gt;&lt;code&gt;BufReader&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.bufwriter&quot;&gt;&lt;code&gt;BufWriter&lt;/code&gt;&lt;/a&gt;, which wrap readers and writers. The wrapper uses a buffer, reducing the number of calls and providing nicer methods for accessing exactly what you want.</source>
          <target state="translated">Las interfaces basadas en bytes son dif&amp;iacute;ciles de manejar y pueden ser ineficientes, ya que tendr&amp;iacute;amos que hacer llamadas casi constantes al sistema operativo. Para ayudar con esto, &lt;code&gt;std::io&lt;/code&gt; viene con dos estructuras, &lt;a href=&quot;struct.bufreader&quot;&gt; &lt;code&gt;BufReader&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;struct.bufwriter&quot;&gt; &lt;code&gt;BufWriter&lt;/code&gt; &lt;/a&gt; , que envuelven lectores y escritores. El contenedor utiliza un b&amp;uacute;fer, lo que reduce la cantidad de llamadas y proporciona m&amp;eacute;todos m&amp;aacute;s agradables para acceder exactamente a lo que desea.</target>
        </trans-unit>
        <trans-unit id="8e5fdab92dece79d7629d6d901687613ddc6ab5a" translate="yes" xml:space="preserve">
          <source>Bytes</source>
          <target state="translated">Bytes</target>
        </trans-unit>
        <trans-unit id="f4b810da1a34c6717e9522d90aa84dd16327cb38" translate="yes" xml:space="preserve">
          <source>Bytes &lt;code&gt;0..old_layout.size()&lt;/code&gt; are preserved from the original allocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97b74d3f6f2a9ba3378b8d5ad47f1a4ae59fcd37" translate="yes" xml:space="preserve">
          <source>Bytes &lt;code&gt;old_layout.size()..old_size&lt;/code&gt; will either be preserved or zeroed, depending on the allocator implementation. &lt;code&gt;old_size&lt;/code&gt; refers to the size of the memory block prior to the &lt;code&gt;grow_zeroed&lt;/code&gt; call, which may be larger than the size that was originally requested when it was allocated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5598f7ac23eed1d65ff56a4e36412084f03533d" translate="yes" xml:space="preserve">
          <source>Bytes &lt;code&gt;old_size..new_size&lt;/code&gt; are zeroed. &lt;code&gt;new_size&lt;/code&gt; refers to the size of the memory block returned by the &lt;code&gt;grow_zeroed&lt;/code&gt; call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac774cda628eb294788ac5a8af4246ebdb046c2e" translate="yes" xml:space="preserve">
          <source>Bytes and Scalar Values and Grapheme Clusters! Oh My!</source>
          <target state="translated">¡Bytes y valores escalares y racimos de grafito! ¡Oh,Dios!</target>
        </trans-unit>
        <trans-unit id="63a26fef0a88c04dcaa35220a18f6ec6efa06bb9" translate="yes" xml:space="preserve">
          <source>Bytes::all</source>
          <target state="translated">Bytes::all</target>
        </trans-unit>
        <trans-unit id="ce7f0f3ceb8a803663be41eda4062efc6e909fc1" translate="yes" xml:space="preserve">
          <source>Bytes::any</source>
          <target state="translated">Bytes::any</target>
        </trans-unit>
        <trans-unit id="979369045d5514f553522214d3aeb625b48dd8a9" translate="yes" xml:space="preserve">
          <source>Bytes::borrow</source>
          <target state="translated">Bytes::borrow</target>
        </trans-unit>
        <trans-unit id="113f2dc7029b7c717fa9381d4e2943d9b1b2fc76" translate="yes" xml:space="preserve">
          <source>Bytes::borrow_mut</source>
          <target state="translated">Bytes::borrow_mut</target>
        </trans-unit>
        <trans-unit id="34427e43eec5e510b45622026cd37a560d9c2986" translate="yes" xml:space="preserve">
          <source>Bytes::by_ref</source>
          <target state="translated">Bytes::by_ref</target>
        </trans-unit>
        <trans-unit id="f07eec0f48fad142ac4fee1d3559e7e8d852d460" translate="yes" xml:space="preserve">
          <source>Bytes::chain</source>
          <target state="translated">Bytes::chain</target>
        </trans-unit>
        <trans-unit id="e0bf1210a39ee968daf6f1af8bf1ba9b5fc128dd" translate="yes" xml:space="preserve">
          <source>Bytes::clone</source>
          <target state="translated">Bytes::clone</target>
        </trans-unit>
        <trans-unit id="d328e30cabdbfda128a510cf1e8c0e446be3fec8" translate="yes" xml:space="preserve">
          <source>Bytes::clone_from</source>
          <target state="translated">Bytes::clone_from</target>
        </trans-unit>
        <trans-unit id="297e685afff3be463f3a3c3239b3251c10cb9c58" translate="yes" xml:space="preserve">
          <source>Bytes::clone_into</source>
          <target state="translated">Bytes::clone_into</target>
        </trans-unit>
        <trans-unit id="df2a47344e3e5b26dba12c9f96d298455119f06c" translate="yes" xml:space="preserve">
          <source>Bytes::cloned</source>
          <target state="translated">Bytes::cloned</target>
        </trans-unit>
        <trans-unit id="8c02ce01cfc4f2e89b9e4d7eed3369aa07faf8c3" translate="yes" xml:space="preserve">
          <source>Bytes::cmp</source>
          <target state="translated">Bytes::cmp</target>
        </trans-unit>
        <trans-unit id="299642d3a1e23a4fa629457b5fe1a7d7023f1ab5" translate="yes" xml:space="preserve">
          <source>Bytes::collect</source>
          <target state="translated">Bytes::collect</target>
        </trans-unit>
        <trans-unit id="6f693335f9495019383b9eadbf3b449bcfc675f9" translate="yes" xml:space="preserve">
          <source>Bytes::copied</source>
          <target state="translated">Bytes::copied</target>
        </trans-unit>
        <trans-unit id="93d1e678c86a68151617f0b02af7cadb48251558" translate="yes" xml:space="preserve">
          <source>Bytes::count</source>
          <target state="translated">Bytes::count</target>
        </trans-unit>
        <trans-unit id="1e5c00a470b7fc4f8da25723aad0fc52e134f397" translate="yes" xml:space="preserve">
          <source>Bytes::cycle</source>
          <target state="translated">Bytes::cycle</target>
        </trans-unit>
        <trans-unit id="9d81621cbab864e41b9591bee2a211c1e6fb3870" translate="yes" xml:space="preserve">
          <source>Bytes::enumerate</source>
          <target state="translated">Bytes::enumerate</target>
        </trans-unit>
        <trans-unit id="ea17a535e18dd3c17944b57230746af970ccf214" translate="yes" xml:space="preserve">
          <source>Bytes::eq</source>
          <target state="translated">Bytes::eq</target>
        </trans-unit>
        <trans-unit id="491e10ca5d759167723a7ee86c3ca2eea1265ab7" translate="yes" xml:space="preserve">
          <source>Bytes::filter</source>
          <target state="translated">Bytes::filter</target>
        </trans-unit>
        <trans-unit id="9742812b0b1477fbb5396ffff48eb2034a65761d" translate="yes" xml:space="preserve">
          <source>Bytes::filter_map</source>
          <target state="translated">Bytes::filter_map</target>
        </trans-unit>
        <trans-unit id="63e7f3cfad0e9eae54402838e01bfca54ca3afa5" translate="yes" xml:space="preserve">
          <source>Bytes::find</source>
          <target state="translated">Bytes::find</target>
        </trans-unit>
        <trans-unit id="290c24197673b5bfcbef8c08eea1c3d3b80c4622" translate="yes" xml:space="preserve">
          <source>Bytes::find_map</source>
          <target state="translated">Bytes::find_map</target>
        </trans-unit>
        <trans-unit id="9f757e2b209fe7676c23fb7de2d9a9666f266a57" translate="yes" xml:space="preserve">
          <source>Bytes::flat_map</source>
          <target state="translated">Bytes::flat_map</target>
        </trans-unit>
        <trans-unit id="ebffc4bee04033b63ddade2d5c137b7551135bbd" translate="yes" xml:space="preserve">
          <source>Bytes::flatten</source>
          <target state="translated">Bytes::flatten</target>
        </trans-unit>
        <trans-unit id="59f9148fe24ec4969d305fc0671cc3b707da545a" translate="yes" xml:space="preserve">
          <source>Bytes::fmt</source>
          <target state="translated">Bytes::fmt</target>
        </trans-unit>
        <trans-unit id="a8078f4655b1978965a5909b5351cb14c6583a92" translate="yes" xml:space="preserve">
          <source>Bytes::fold</source>
          <target state="translated">Bytes::fold</target>
        </trans-unit>
        <trans-unit id="7f2d08f4da0fc0d0fb55752871e004cb4680946d" translate="yes" xml:space="preserve">
          <source>Bytes::for_each</source>
          <target state="translated">Bytes::for_each</target>
        </trans-unit>
        <trans-unit id="62699a9360bcc212fa6c249680ba5b7f48e3fb42" translate="yes" xml:space="preserve">
          <source>Bytes::from</source>
          <target state="translated">Bytes::from</target>
        </trans-unit>
        <trans-unit id="603aaacbdc014366acd2253fbfbd1087387d3bd3" translate="yes" xml:space="preserve">
          <source>Bytes::fuse</source>
          <target state="translated">Bytes::fuse</target>
        </trans-unit>
        <trans-unit id="ef1515771c9b976e1008ae36cc109565b4569ae9" translate="yes" xml:space="preserve">
          <source>Bytes::ge</source>
          <target state="translated">Bytes::ge</target>
        </trans-unit>
        <trans-unit id="445e8b743c0007a524c7e482f8c83e4f69760410" translate="yes" xml:space="preserve">
          <source>Bytes::gt</source>
          <target state="translated">Bytes::gt</target>
        </trans-unit>
        <trans-unit id="24ede3c149e7de7883c58aaa99ee5d5463be74e6" translate="yes" xml:space="preserve">
          <source>Bytes::inspect</source>
          <target state="translated">Bytes::inspect</target>
        </trans-unit>
        <trans-unit id="8cfa8a5aca1d21185175b454e814b3c9674137dc" translate="yes" xml:space="preserve">
          <source>Bytes::into</source>
          <target state="translated">Bytes::into</target>
        </trans-unit>
        <trans-unit id="28993249bc6a265b1f1403816b2a9c4d5624ad5b" translate="yes" xml:space="preserve">
          <source>Bytes::into_iter</source>
          <target state="translated">Bytes::into_iter</target>
        </trans-unit>
        <trans-unit id="290c12fce35e73f7ad4e780c36b8daeaf1f6eaf9" translate="yes" xml:space="preserve">
          <source>Bytes::is_empty</source>
          <target state="translated">Bytes::is_empty</target>
        </trans-unit>
        <trans-unit id="37772f76db83eabf7ef6ed6382f4a6562ec04eaa" translate="yes" xml:space="preserve">
          <source>Bytes::is_sorted</source>
          <target state="translated">Bytes::is_sorted</target>
        </trans-unit>
        <trans-unit id="63f09c7e5213825da442ff7939106416cc2db665" translate="yes" xml:space="preserve">
          <source>Bytes::is_sorted_by</source>
          <target state="translated">Bytes::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="b26f21acb6f08d8c9a5ac1405c3ead0d4c9a6b00" translate="yes" xml:space="preserve">
          <source>Bytes::is_sorted_by_key</source>
          <target state="translated">Bytes::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="f50aedc8dbbe9f4f7c0a8193c92f7fe881b11817" translate="yes" xml:space="preserve">
          <source>Bytes::last</source>
          <target state="translated">Bytes::last</target>
        </trans-unit>
        <trans-unit id="725cf533de1247b9f7939a230859f03c71c3a394" translate="yes" xml:space="preserve">
          <source>Bytes::le</source>
          <target state="translated">Bytes::le</target>
        </trans-unit>
        <trans-unit id="ae500d3c2531704059d772fbff739f3873572e45" translate="yes" xml:space="preserve">
          <source>Bytes::len</source>
          <target state="translated">Bytes::len</target>
        </trans-unit>
        <trans-unit id="b194acd634d0bc66745521f9549d62c66e9a152e" translate="yes" xml:space="preserve">
          <source>Bytes::lt</source>
          <target state="translated">Bytes::lt</target>
        </trans-unit>
        <trans-unit id="61ba21505c7ffe82b863e8bcbc73617c7e13b85c" translate="yes" xml:space="preserve">
          <source>Bytes::map</source>
          <target state="translated">Bytes::map</target>
        </trans-unit>
        <trans-unit id="fe2bc9537a5830454b8a500254016c0d67be2211" translate="yes" xml:space="preserve">
          <source>Bytes::max</source>
          <target state="translated">Bytes::max</target>
        </trans-unit>
        <trans-unit id="43d95dea33020faf006b7b4de468897537052a42" translate="yes" xml:space="preserve">
          <source>Bytes::max_by</source>
          <target state="translated">Bytes::max_by</target>
        </trans-unit>
        <trans-unit id="f7973f4371d6448647f6bb7f82a3cd4cc0be52b8" translate="yes" xml:space="preserve">
          <source>Bytes::max_by_key</source>
          <target state="translated">Bytes::max_by_key</target>
        </trans-unit>
        <trans-unit id="c3d094313a068051eedc54593c00089e5d5e0eaa" translate="yes" xml:space="preserve">
          <source>Bytes::min</source>
          <target state="translated">Bytes::min</target>
        </trans-unit>
        <trans-unit id="a26247387b6acf6339ec71745edbdff81c2ade56" translate="yes" xml:space="preserve">
          <source>Bytes::min_by</source>
          <target state="translated">Bytes::min_by</target>
        </trans-unit>
        <trans-unit id="f5a98f7f6167a1b442d3efa2009d49ad462460d2" translate="yes" xml:space="preserve">
          <source>Bytes::min_by_key</source>
          <target state="translated">Bytes::min_by_key</target>
        </trans-unit>
        <trans-unit id="be90f56db4ada597b587d016fd327003ea0bc760" translate="yes" xml:space="preserve">
          <source>Bytes::ne</source>
          <target state="translated">Bytes::ne</target>
        </trans-unit>
        <trans-unit id="d23038a4910063cad42deff4ad9cf09d48b283fc" translate="yes" xml:space="preserve">
          <source>Bytes::next</source>
          <target state="translated">Bytes::next</target>
        </trans-unit>
        <trans-unit id="8748f7bca019be483c7116e17eaefea91e8337c8" translate="yes" xml:space="preserve">
          <source>Bytes::next_back</source>
          <target state="translated">Bytes::next_back</target>
        </trans-unit>
        <trans-unit id="1a968f4f100322f4def3905de036617309b7b5ca" translate="yes" xml:space="preserve">
          <source>Bytes::nth</source>
          <target state="translated">Bytes::nth</target>
        </trans-unit>
        <trans-unit id="7015bc5abccea19494e4724bb7c18d8ce992e0ad" translate="yes" xml:space="preserve">
          <source>Bytes::nth_back</source>
          <target state="translated">Bytes::nth_back</target>
        </trans-unit>
        <trans-unit id="984cab5be49f32fc6d25120ded4daae67af8fff5" translate="yes" xml:space="preserve">
          <source>Bytes::partial_cmp</source>
          <target state="translated">Bytes::partial_cmp</target>
        </trans-unit>
        <trans-unit id="c5a60b3f92a5a9558e9901c7ea8df4400c6ec0e1" translate="yes" xml:space="preserve">
          <source>Bytes::partition</source>
          <target state="translated">Bytes::partition</target>
        </trans-unit>
        <trans-unit id="fd964e1b6678d8175a0f6d2defa63df03aeae2a2" translate="yes" xml:space="preserve">
          <source>Bytes::peekable</source>
          <target state="translated">Bytes::peekable</target>
        </trans-unit>
        <trans-unit id="7a779a538f4d43ba65ab857aaed4f38c84785133" translate="yes" xml:space="preserve">
          <source>Bytes::position</source>
          <target state="translated">Bytes::position</target>
        </trans-unit>
        <trans-unit id="e26b896020a4dd543d300e63cedf53c6c693b23f" translate="yes" xml:space="preserve">
          <source>Bytes::product</source>
          <target state="translated">Bytes::product</target>
        </trans-unit>
        <trans-unit id="9520a4396d3dd25e6d144b70f3b61774361a54c7" translate="yes" xml:space="preserve">
          <source>Bytes::rev</source>
          <target state="translated">Bytes::rev</target>
        </trans-unit>
        <trans-unit id="c91ff74ba08c7c6ea28c25fc12b5996c8b1497a4" translate="yes" xml:space="preserve">
          <source>Bytes::rfind</source>
          <target state="translated">Bytes::rfind</target>
        </trans-unit>
        <trans-unit id="6d8c28436a470bc527732d151cc6081f1ba37f43" translate="yes" xml:space="preserve">
          <source>Bytes::rfold</source>
          <target state="translated">Bytes::rfold</target>
        </trans-unit>
        <trans-unit id="952ea423fc26cfa8babe6fc58fba9d219ed14f15" translate="yes" xml:space="preserve">
          <source>Bytes::rposition</source>
          <target state="translated">Bytes::rposition</target>
        </trans-unit>
        <trans-unit id="5ca3ed55d60687599d621bf21650f4ef1969fe93" translate="yes" xml:space="preserve">
          <source>Bytes::scan</source>
          <target state="translated">Bytes::scan</target>
        </trans-unit>
        <trans-unit id="ab036dbdadf0542cb3bddc197d995e0027d66c95" translate="yes" xml:space="preserve">
          <source>Bytes::size_hint</source>
          <target state="translated">Bytes::size_hint</target>
        </trans-unit>
        <trans-unit id="7aea93693f858b30cc323b010a39049b5066d25e" translate="yes" xml:space="preserve">
          <source>Bytes::skip</source>
          <target state="translated">Bytes::skip</target>
        </trans-unit>
        <trans-unit id="1238ebec8be4b2a081cb75d76acedcc89efe036e" translate="yes" xml:space="preserve">
          <source>Bytes::skip_while</source>
          <target state="translated">Bytes::skip_while</target>
        </trans-unit>
        <trans-unit id="9c76a1cf5e4f9d6e469d340364ab845f02735723" translate="yes" xml:space="preserve">
          <source>Bytes::step_by</source>
          <target state="translated">Bytes::step_by</target>
        </trans-unit>
        <trans-unit id="79350f102ae506e77c2e1822a20d032e242e08cf" translate="yes" xml:space="preserve">
          <source>Bytes::sum</source>
          <target state="translated">Bytes::sum</target>
        </trans-unit>
        <trans-unit id="4668fe7f8a3335637251054d9c9c06434224fd9e" translate="yes" xml:space="preserve">
          <source>Bytes::take</source>
          <target state="translated">Bytes::take</target>
        </trans-unit>
        <trans-unit id="8188c9f2c65727da6ad6418e7435a0a4d4ae1b63" translate="yes" xml:space="preserve">
          <source>Bytes::take_while</source>
          <target state="translated">Bytes::take_while</target>
        </trans-unit>
        <trans-unit id="1e3d429d72ab5a83b39ca62419e469d95fab4a82" translate="yes" xml:space="preserve">
          <source>Bytes::to_owned</source>
          <target state="translated">Bytes::to_owned</target>
        </trans-unit>
        <trans-unit id="557ed7e76c591066179253aea6bd6a17cfa01f82" translate="yes" xml:space="preserve">
          <source>Bytes::try_fold</source>
          <target state="translated">Bytes::try_fold</target>
        </trans-unit>
        <trans-unit id="3a174ee7598d8449eeadbf2f070bb9163bfdbeef" translate="yes" xml:space="preserve">
          <source>Bytes::try_for_each</source>
          <target state="translated">Bytes::try_for_each</target>
        </trans-unit>
        <trans-unit id="35ddd98f9595299a1b8243f3586e6b1c8d7fa048" translate="yes" xml:space="preserve">
          <source>Bytes::try_from</source>
          <target state="translated">Bytes::try_from</target>
        </trans-unit>
        <trans-unit id="fdf97aa086611d5f965642e0fa40ebed09455a54" translate="yes" xml:space="preserve">
          <source>Bytes::try_into</source>
          <target state="translated">Bytes::try_into</target>
        </trans-unit>
        <trans-unit id="e81eae2ced7b712e89d1325cb3b29c2687db0961" translate="yes" xml:space="preserve">
          <source>Bytes::try_rfold</source>
          <target state="translated">Bytes::try_rfold</target>
        </trans-unit>
        <trans-unit id="93ac1e902ab13110128cd8b40340c9498d027d14" translate="yes" xml:space="preserve">
          <source>Bytes::type_id</source>
          <target state="translated">Bytes::type_id</target>
        </trans-unit>
        <trans-unit id="b8daa236d91d2a612c5d7612ed9d46cc96bcda6a" translate="yes" xml:space="preserve">
          <source>Bytes::unzip</source>
          <target state="translated">Bytes::unzip</target>
        </trans-unit>
        <trans-unit id="47375bdc573035dbf1f0a151a6ddce0a88145906" translate="yes" xml:space="preserve">
          <source>Bytes::zip</source>
          <target state="translated">Bytes::zip</target>
        </trans-unit>
        <trans-unit id="10de289426da74ae5996820227d1ae99ba3ca1bf" translate="yes" xml:space="preserve">
          <source>C chars are most commonly used to make C strings. Unlike Rust, where the length of a string is included alongside the string, C strings mark the end of a string with the character &lt;code&gt;'\0'&lt;/code&gt;. See &lt;a href=&quot;../../ffi/struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">Los caracteres C se usan m&amp;aacute;s com&amp;uacute;nmente para hacer cadenas C. A diferencia de Rust, donde la longitud de una cadena se incluye junto con la cadena, las cadenas C marcan el final de una cadena con el car&amp;aacute;cter &lt;code&gt;'\0'&lt;/code&gt; . Consulte &lt;a href=&quot;../../ffi/struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ec4ff1ee46ab9f978c49b43b23216a55c335e53d" translate="yes" xml:space="preserve">
          <source>C strings are different from Rust strings:</source>
          <target state="translated">Las cuerdas de Do son diferentes de las cuerdas de óxido:</target>
        </trans-unit>
        <trans-unit id="4d0a3cd3d0843046e9dc208601e2f872fffb7682" translate="yes" xml:space="preserve">
          <source>C#: attributes</source>
          <target state="translated">C#:atributos</target>
        </trans-unit>
        <trans-unit id="8f7e71dd73911b35b0704326383804842772d25d" translate="yes" xml:space="preserve">
          <source>C++: references, RAII, smart pointers, move semantics, monomorphization, memory model</source>
          <target state="translated">C++:referencias,RAII,punteros inteligentes,semántica del movimiento,monomorfización,modelo de memoria</target>
        </trans-unit>
        <trans-unit id="d6f809f9a8c2683f3d057fe632dca0828c0f7e4a" translate="yes" xml:space="preserve">
          <source>C-like enum</source>
          <target state="translated">C-like enum</target>
        </trans-unit>
        <trans-unit id="ce41a223396980a3e03634cbe778c52da0c75b6e" translate="yes" xml:space="preserve">
          <source>CAPITAL</source>
          <target state="translated">CAPITAL</target>
        </trans-unit>
        <trans-unit id="ee6b489f0289728c3819dc331f1663c96ca0785c" translate="yes" xml:space="preserve">
          <source>CHAR_LITERAL</source>
          <target state="translated">CHAR_LITERAL</target>
        </trans-unit>
        <trans-unit id="69b56ccff3a6c4424734f57c05d156739380a264" translate="yes" xml:space="preserve">
          <source>CHAR_LITERAL :</source>
          <target state="translated">CHAR_LITERAL :</target>
        </trans-unit>
        <trans-unit id="c855bb9cac705e9e3b723e75b21f4d07cd808dc4" translate="yes" xml:space="preserve">
          <source>CStr</source>
          <target state="translated">CStr</target>
        </trans-unit>
        <trans-unit id="6d8a542fd21b3338ea60a85ae47f0c199d520fae" translate="yes" xml:space="preserve">
          <source>CStr::as_ptr</source>
          <target state="translated">CStr::as_ptr</target>
        </trans-unit>
        <trans-unit id="1f95e3e4ec8be2f019c66897e9c3b6624d851e96" translate="yes" xml:space="preserve">
          <source>CStr::as_ref</source>
          <target state="translated">CStr::as_ref</target>
        </trans-unit>
        <trans-unit id="d700139dd31629deaacc42e4bc9a9d4d45caef0d" translate="yes" xml:space="preserve">
          <source>CStr::borrow</source>
          <target state="translated">CStr::borrow</target>
        </trans-unit>
        <trans-unit id="cc55b0f7e0eedd59a730a23f4f91745521f7abe7" translate="yes" xml:space="preserve">
          <source>CStr::borrow_mut</source>
          <target state="translated">CStr::borrow_mut</target>
        </trans-unit>
        <trans-unit id="fcca1c0586380cf9ec8aaa4478ef4dea99e9db80" translate="yes" xml:space="preserve">
          <source>CStr::clamp</source>
          <target state="translated">CStr::clamp</target>
        </trans-unit>
        <trans-unit id="95ad44c6acf49d720b284daa7324a4c4e8ee9b77" translate="yes" xml:space="preserve">
          <source>CStr::clone_into</source>
          <target state="translated">CStr::clone_into</target>
        </trans-unit>
        <trans-unit id="17ee9041b05f19b08c9a207a0b264abb06217788" translate="yes" xml:space="preserve">
          <source>CStr::cmp</source>
          <target state="translated">CStr::cmp</target>
        </trans-unit>
        <trans-unit id="ef2eafc91f57240446e72aeaeeb2a32e68e97a8b" translate="yes" xml:space="preserve">
          <source>CStr::default</source>
          <target state="translated">CStr::default</target>
        </trans-unit>
        <trans-unit id="54ffaa14459cec5f2273ff104ef1742c78574036" translate="yes" xml:space="preserve">
          <source>CStr::eq</source>
          <target state="translated">CStr::eq</target>
        </trans-unit>
        <trans-unit id="0c4c69764320e8a42e866e61f90c9ac980102de3" translate="yes" xml:space="preserve">
          <source>CStr::fmt</source>
          <target state="translated">CStr::fmt</target>
        </trans-unit>
        <trans-unit id="e9fd5cc915fb0074a2adb82bcea1b9cf07e8ac22" translate="yes" xml:space="preserve">
          <source>CStr::from</source>
          <target state="translated">CStr::from</target>
        </trans-unit>
        <trans-unit id="fef3690a19e427664444d03dfffa43ae3fa6be59" translate="yes" xml:space="preserve">
          <source>CStr::from_bytes_with_nul</source>
          <target state="translated">CStr::from_bytes_with_nul</target>
        </trans-unit>
        <trans-unit id="75111e68b3cace6dc1f25160989a55c75672d185" translate="yes" xml:space="preserve">
          <source>CStr::from_bytes_with_nul_unchecked</source>
          <target state="translated">CStr::from_bytes_with_nul_unchecked</target>
        </trans-unit>
        <trans-unit id="137aefe4f0efa206a17e644e536709f7164f7036" translate="yes" xml:space="preserve">
          <source>CStr::from_ptr</source>
          <target state="translated">CStr::from_ptr</target>
        </trans-unit>
        <trans-unit id="3445b2e9c6d30848e46a0c458e92c18f5478648a" translate="yes" xml:space="preserve">
          <source>CStr::ge</source>
          <target state="translated">CStr::ge</target>
        </trans-unit>
        <trans-unit id="728fbce40efc66cebd46be16b8f1cf779090113f" translate="yes" xml:space="preserve">
          <source>CStr::gt</source>
          <target state="translated">CStr::gt</target>
        </trans-unit>
        <trans-unit id="be0afeee394794477755e07edeb627b53d61bdf3" translate="yes" xml:space="preserve">
          <source>CStr::hash</source>
          <target state="translated">CStr::hash</target>
        </trans-unit>
        <trans-unit id="bb72c84064e334eba596cbe9844aa70e70ee849a" translate="yes" xml:space="preserve">
          <source>CStr::hash_slice</source>
          <target state="translated">CStr::hash_slice</target>
        </trans-unit>
        <trans-unit id="c6bf567f09e2b2bd042059269552397aad871cae" translate="yes" xml:space="preserve">
          <source>CStr::into_c_string</source>
          <target state="translated">CStr::into_c_string</target>
        </trans-unit>
        <trans-unit id="69ab262092debd4569770196660f4febe98420dc" translate="yes" xml:space="preserve">
          <source>CStr::le</source>
          <target state="translated">CStr::le</target>
        </trans-unit>
        <trans-unit id="f1e9e41f63590d10b51a2a294c025ee665034901" translate="yes" xml:space="preserve">
          <source>CStr::lt</source>
          <target state="translated">CStr::lt</target>
        </trans-unit>
        <trans-unit id="348c458cc35acb0213f545d380dceae16ee7b792" translate="yes" xml:space="preserve">
          <source>CStr::max</source>
          <target state="translated">CStr::max</target>
        </trans-unit>
        <trans-unit id="000883cbb32a65bd5d06415a6ea2b885840b8dea" translate="yes" xml:space="preserve">
          <source>CStr::min</source>
          <target state="translated">CStr::min</target>
        </trans-unit>
        <trans-unit id="9f6acbf3ad450fc26ec407cb9b07020457f45140" translate="yes" xml:space="preserve">
          <source>CStr::ne</source>
          <target state="translated">CStr::ne</target>
        </trans-unit>
        <trans-unit id="7abb5f8b92e7fded6ba1d77d76970093cc652367" translate="yes" xml:space="preserve">
          <source>CStr::partial_cmp</source>
          <target state="translated">CStr::partial_cmp</target>
        </trans-unit>
        <trans-unit id="65caa5cdc2514ebded75efc52eddee11acbc1be0" translate="yes" xml:space="preserve">
          <source>CStr::to_bytes</source>
          <target state="translated">CStr::to_bytes</target>
        </trans-unit>
        <trans-unit id="e4257d44ce77a2f26ac5c252e77fb8c42eef081a" translate="yes" xml:space="preserve">
          <source>CStr::to_bytes_with_nul</source>
          <target state="translated">CStr::to_bytes_with_nul</target>
        </trans-unit>
        <trans-unit id="44ead7aea7dc02cf1786c76006d27afcf9a480c8" translate="yes" xml:space="preserve">
          <source>CStr::to_owned</source>
          <target state="translated">CStr::to_owned</target>
        </trans-unit>
        <trans-unit id="ad62220819d69a73a1b88d26957191be23aa8128" translate="yes" xml:space="preserve">
          <source>CStr::to_str</source>
          <target state="translated">CStr::to_str</target>
        </trans-unit>
        <trans-unit id="f8b6323ef660a7621fafb52f71e3630988494495" translate="yes" xml:space="preserve">
          <source>CStr::to_string_lossy</source>
          <target state="translated">CStr::to_string_lossy</target>
        </trans-unit>
        <trans-unit id="1cc3da01043c1b71efdad57e85215058364b7064" translate="yes" xml:space="preserve">
          <source>CStr::type_id</source>
          <target state="translated">CStr::type_id</target>
        </trans-unit>
        <trans-unit id="10fdabde5da32be8abb7d3568067d963d8ef529e" translate="yes" xml:space="preserve">
          <source>CString</source>
          <target state="translated">CString</target>
        </trans-unit>
        <trans-unit id="52e001b95a1b9cf3308a26a6e981035005eab758" translate="yes" xml:space="preserve">
          <source>CString::as_bytes</source>
          <target state="translated">CString::as_bytes</target>
        </trans-unit>
        <trans-unit id="13cab1dddf5c51f1e61f9eee6b49a5636b9bd814" translate="yes" xml:space="preserve">
          <source>CString::as_bytes_with_nul</source>
          <target state="translated">CString::as_bytes_with_nul</target>
        </trans-unit>
        <trans-unit id="797335508475be49326111108ab36a086a72caa3" translate="yes" xml:space="preserve">
          <source>CString::as_c_str</source>
          <target state="translated">CString::as_c_str</target>
        </trans-unit>
        <trans-unit id="7de000d37b9a976d4527e4c70754ba8afd0351c7" translate="yes" xml:space="preserve">
          <source>CString::as_ptr</source>
          <target state="translated">CString::as_ptr</target>
        </trans-unit>
        <trans-unit id="bc0fb3daa028d7ff58f6946c49b2f5b96bc9d602" translate="yes" xml:space="preserve">
          <source>CString::as_ref</source>
          <target state="translated">CString::as_ref</target>
        </trans-unit>
        <trans-unit id="36a33aa7aa5aa4d2d81432af9a988f0f942736ad" translate="yes" xml:space="preserve">
          <source>CString::borrow</source>
          <target state="translated">CString::borrow</target>
        </trans-unit>
        <trans-unit id="8528461b0edd762ff495176944d805d1dde0f8ec" translate="yes" xml:space="preserve">
          <source>CString::borrow_mut</source>
          <target state="translated">CString::borrow_mut</target>
        </trans-unit>
        <trans-unit id="2a50234e42cd54310e4916caa569a9a5aa96a13c" translate="yes" xml:space="preserve">
          <source>CString::clamp</source>
          <target state="translated">CString::clamp</target>
        </trans-unit>
        <trans-unit id="24f213d2e0d20a811ae38f00f41648ad4c89ab8e" translate="yes" xml:space="preserve">
          <source>CString::clone</source>
          <target state="translated">CString::clone</target>
        </trans-unit>
        <trans-unit id="7f0df7e2af8f0985cf2add0b160cbcac287070e5" translate="yes" xml:space="preserve">
          <source>CString::clone_from</source>
          <target state="translated">CString::clone_from</target>
        </trans-unit>
        <trans-unit id="3cabdc5e34bb6bea49169d33f360d4ee04f6ed25" translate="yes" xml:space="preserve">
          <source>CString::clone_into</source>
          <target state="translated">CString::clone_into</target>
        </trans-unit>
        <trans-unit id="d7277d1a271df4865a6f33570de006450712f4a0" translate="yes" xml:space="preserve">
          <source>CString::cmp</source>
          <target state="translated">CString::cmp</target>
        </trans-unit>
        <trans-unit id="baa89c11dc8118d826240007d81976bd7413a3b6" translate="yes" xml:space="preserve">
          <source>CString::default</source>
          <target state="translated">CString::default</target>
        </trans-unit>
        <trans-unit id="347d98047b56cd9966454be82309f4e8529682ff" translate="yes" xml:space="preserve">
          <source>CString::deref</source>
          <target state="translated">CString::deref</target>
        </trans-unit>
        <trans-unit id="ab34938730f49553f7aecab1bb2c2843aa651704" translate="yes" xml:space="preserve">
          <source>CString::drop</source>
          <target state="translated">CString::drop</target>
        </trans-unit>
        <trans-unit id="60996dc07ecd992dd60d5ceec16cc375ea67d6b9" translate="yes" xml:space="preserve">
          <source>CString::eq</source>
          <target state="translated">CString::eq</target>
        </trans-unit>
        <trans-unit id="e70be0cad84fe664f3a9891f184d6d6a7283a582" translate="yes" xml:space="preserve">
          <source>CString::fmt</source>
          <target state="translated">CString::fmt</target>
        </trans-unit>
        <trans-unit id="cbf381ece793251aee2eeadc010afe3c0f4a86e0" translate="yes" xml:space="preserve">
          <source>CString::from</source>
          <target state="translated">CString::from</target>
        </trans-unit>
        <trans-unit id="a143620acced132aa78acde78ce1bd6ab7b63f7e" translate="yes" xml:space="preserve">
          <source>CString::from_raw</source>
          <target state="translated">CString::from_raw</target>
        </trans-unit>
        <trans-unit id="dc9b49de9e2271c2ed3506615af6e6d8c4861395" translate="yes" xml:space="preserve">
          <source>CString::from_vec_unchecked</source>
          <target state="translated">CString::from_vec_unchecked</target>
        </trans-unit>
        <trans-unit id="1a539736b4bb0e500f677893082fd23c664398df" translate="yes" xml:space="preserve">
          <source>CString::ge</source>
          <target state="translated">CString::ge</target>
        </trans-unit>
        <trans-unit id="668f249df3f7a2e1e7a9e166dd065bd8ea489b01" translate="yes" xml:space="preserve">
          <source>CString::gt</source>
          <target state="translated">CString::gt</target>
        </trans-unit>
        <trans-unit id="e46cf065cca5e3cd1f01cce699aa22189f1cb26b" translate="yes" xml:space="preserve">
          <source>CString::hash</source>
          <target state="translated">CString::hash</target>
        </trans-unit>
        <trans-unit id="0833d863637dfd6ed73ce7a7ea13d011f707f04d" translate="yes" xml:space="preserve">
          <source>CString::hash_slice</source>
          <target state="translated">CString::hash_slice</target>
        </trans-unit>
        <trans-unit id="432d0b1932bbe3eb2d6ef0fa7ec29b9397259ae9" translate="yes" xml:space="preserve">
          <source>CString::index</source>
          <target state="translated">CString::index</target>
        </trans-unit>
        <trans-unit id="cd0ce393340efaa8f18ad5cb50aad07f3d2eeea4" translate="yes" xml:space="preserve">
          <source>CString::into</source>
          <target state="translated">CString::into</target>
        </trans-unit>
        <trans-unit id="59bfaa59d401f415773f033626b7896ccc5c6f79" translate="yes" xml:space="preserve">
          <source>CString::into_boxed_c_str</source>
          <target state="translated">CString::into_boxed_c_str</target>
        </trans-unit>
        <trans-unit id="96b480440e4b607a24895b6512350ea1afafd31c" translate="yes" xml:space="preserve">
          <source>CString::into_bytes</source>
          <target state="translated">CString::into_bytes</target>
        </trans-unit>
        <trans-unit id="cc5eefdedab1063685f507370a9d8ab88c34cbda" translate="yes" xml:space="preserve">
          <source>CString::into_bytes_with_nul</source>
          <target state="translated">CString::into_bytes_with_nul</target>
        </trans-unit>
        <trans-unit id="aefcc1dc128b6b5cd3742344d58563aafb746370" translate="yes" xml:space="preserve">
          <source>CString::into_raw</source>
          <target state="translated">CString::into_raw</target>
        </trans-unit>
        <trans-unit id="f2693a15445d228f3db30100d51e43c8372af6e2" translate="yes" xml:space="preserve">
          <source>CString::into_string</source>
          <target state="translated">CString::into_string</target>
        </trans-unit>
        <trans-unit id="8bee9b3af5aa7e5de7c21a5ebc17b1acccf5ee8e" translate="yes" xml:space="preserve">
          <source>CString::le</source>
          <target state="translated">CString::le</target>
        </trans-unit>
        <trans-unit id="a139512687d9e3c6e3a92b9473958b2f7df1eb47" translate="yes" xml:space="preserve">
          <source>CString::lt</source>
          <target state="translated">CString::lt</target>
        </trans-unit>
        <trans-unit id="eaaa87d3cf20a5d0e070b569e586340d5ecb604f" translate="yes" xml:space="preserve">
          <source>CString::max</source>
          <target state="translated">CString::max</target>
        </trans-unit>
        <trans-unit id="72b7071a2efa7b6ad66daf332571bc9f191bed64" translate="yes" xml:space="preserve">
          <source>CString::min</source>
          <target state="translated">CString::min</target>
        </trans-unit>
        <trans-unit id="2516dc9b57566e8c9c5ced5df9a3f6886f48ed5c" translate="yes" xml:space="preserve">
          <source>CString::ne</source>
          <target state="translated">CString::ne</target>
        </trans-unit>
        <trans-unit id="057c250d247622d3e7250ede8d66d4f4fe5f006a" translate="yes" xml:space="preserve">
          <source>CString::new</source>
          <target state="translated">CString::new</target>
        </trans-unit>
        <trans-unit id="eff1b495447d52f2ff92fe44126c3e0f7e62bd18" translate="yes" xml:space="preserve">
          <source>CString::partial_cmp</source>
          <target state="translated">CString::partial_cmp</target>
        </trans-unit>
        <trans-unit id="ba7cc72bb439ffacb3c246cdf7d4ea38bf7c37ba" translate="yes" xml:space="preserve">
          <source>CString::to_bytes</source>
          <target state="translated">CString::to_bytes</target>
        </trans-unit>
        <trans-unit id="52c93cc3f089d3ead1daed54786cb1adefbefc0e" translate="yes" xml:space="preserve">
          <source>CString::to_bytes_with_nul</source>
          <target state="translated">CString::to_bytes_with_nul</target>
        </trans-unit>
        <trans-unit id="d066a96cc2aeab0a52ff35a69bfade1ebb5b679e" translate="yes" xml:space="preserve">
          <source>CString::to_owned</source>
          <target state="translated">CString::to_owned</target>
        </trans-unit>
        <trans-unit id="2511594a074122956a7b9aac6c3b45531240e7fc" translate="yes" xml:space="preserve">
          <source>CString::to_str</source>
          <target state="translated">CString::to_str</target>
        </trans-unit>
        <trans-unit id="b9d046be15dc8b7b1d4ad0b19b0da5323bf450ae" translate="yes" xml:space="preserve">
          <source>CString::to_string_lossy</source>
          <target state="translated">CString::to_string_lossy</target>
        </trans-unit>
        <trans-unit id="9d84fa601d6e1d36b0d57472ca64c553b64dab03" translate="yes" xml:space="preserve">
          <source>CString::try_from</source>
          <target state="translated">CString::try_from</target>
        </trans-unit>
        <trans-unit id="f11ef73d8e97b738c053ffd9938664b3d2273bd5" translate="yes" xml:space="preserve">
          <source>CString::try_into</source>
          <target state="translated">CString::try_into</target>
        </trans-unit>
        <trans-unit id="1a51fb95b46c52bf3add938b9cfe7d50ef6bacbf" translate="yes" xml:space="preserve">
          <source>CString::type_id</source>
          <target state="translated">CString::type_id</target>
        </trans-unit>
        <trans-unit id="ec9fe493034beaebc0e01624240518933e14a78a" translate="yes" xml:space="preserve">
          <source>Caching values is a generally useful behavior that we might want to use in other parts of our code with different closures. However, there are two problems with the current implementation of &lt;code&gt;Cacher&lt;/code&gt; that would make reusing it in different contexts difficult.</source>
          <target state="translated">El almacenamiento en cach&amp;eacute; de valores es un comportamiento generalmente &amp;uacute;til que podr&amp;iacute;amos querer usar en otras partes de nuestro c&amp;oacute;digo con cierres diferentes. Sin embargo, existen dos problemas con la implementaci&amp;oacute;n actual de &lt;code&gt;Cacher&lt;/code&gt; que dificultar&amp;iacute;an su reutilizaci&amp;oacute;n en diferentes contextos.</target>
        </trans-unit>
        <trans-unit id="ca70ff3bbc1574ec864e13a85775af1c9fd2dc54" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;self&lt;/code&gt; + &lt;code&gt;rhs&lt;/code&gt;</source>
          <target state="translated">Calcula &lt;code&gt;self&lt;/code&gt; + &lt;code&gt;rhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c60cc01325d6ae275f88e47a24f1234f7eab35f7" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;self&lt;/code&gt; - &lt;code&gt;rhs&lt;/code&gt;</source>
          <target state="translated">Calcula &lt;code&gt;self&lt;/code&gt; - &lt;code&gt;rhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a2ce2b6e7049ed5ebef3ea78f7f49e41b51d70f5" translate="yes" xml:space="preserve">
          <source>Calculates Euclidean division, the matching method for &lt;code&gt;rem_euclid&lt;/code&gt;.</source>
          <target state="translated">Calcula la divisi&amp;oacute;n euclidiana, el m&amp;eacute;todo de coincidencia para &lt;code&gt;rem_euclid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f1a1acd0979000f557bd9fe260b8e844069c43f" translate="yes" xml:space="preserve">
          <source>Calculates the distance between two pointers. The returned value is in units of T: the distance in bytes is divided by &lt;code&gt;mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt;.</source>
          <target state="translated">Calcula la distancia entre dos punteros. El valor devuelto est&amp;aacute; en unidades de T: la distancia en bytes se divide por &lt;code&gt;mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5127f08bc025120d1faa493287d1d0eee0006108" translate="yes" xml:space="preserve">
          <source>Calculates the divisor when &lt;code&gt;self&lt;/code&gt; is divided by &lt;code&gt;rhs&lt;/code&gt;.</source>
          <target state="translated">Calcula el divisor cuando &lt;code&gt;self&lt;/code&gt; se divide por &lt;code&gt;rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc217ee649e4f99c72864fd7fe451c173d18439f" translate="yes" xml:space="preserve">
          <source>Calculates the least nonnegative remainder of &lt;code&gt;self (mod rhs)&lt;/code&gt;.</source>
          <target state="translated">Calcula el resto menos no negativo de &lt;code&gt;self (mod rhs)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa698abba4132e7de76a90696509e57b698e9680" translate="yes" xml:space="preserve">
          <source>Calculates the least remainder of &lt;code&gt;self (mod rhs)&lt;/code&gt;.</source>
          <target state="translated">Calcula el resto m&amp;iacute;nimo de &lt;code&gt;self (mod rhs)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7ea3c4efe85a6701802881e07221808f6b72f10" translate="yes" xml:space="preserve">
          <source>Calculates the length of the hypotenuse of a right-angle triangle given legs of length &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">Calcula la longitud de la hipotenusa de un tri&amp;aacute;ngulo rect&amp;aacute;ngulo dados los catetos de longitud &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2204ea9d183af2eb3c958e206adf62733fcb72b8" translate="yes" xml:space="preserve">
          <source>Calculates the multiplication of &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;.</source>
          <target state="translated">Calcula la multiplicaci&amp;oacute;n de &lt;code&gt;self&lt;/code&gt; y &lt;code&gt;rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1f0a45d6193bb4f48999acaf0e6da752bd21197" translate="yes" xml:space="preserve">
          <source>Calculates the offset from a pointer (convenience for &lt;code&gt;.offset((count as isize).wrapping_neg())&lt;/code&gt;).</source>
          <target state="translated">Calcula el desplazamiento a partir de un puntero (conveniencia para &lt;code&gt;.offset((count as isize).wrapping_neg())&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2cdd04036e314797a2d49a1129ff94310c799250" translate="yes" xml:space="preserve">
          <source>Calculates the offset from a pointer (convenience for &lt;code&gt;.offset(count as isize)&lt;/code&gt;).</source>
          <target state="translated">Calcula el desplazamiento a partir de un puntero (conveniencia para &lt;code&gt;.offset(count as isize)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5c58135d353fa0b65d9d7d232ccec38157ca294b" translate="yes" xml:space="preserve">
          <source>Calculates the offset from a pointer using wrapping arithmetic.</source>
          <target state="translated">Calcula el desplazamiento de un puntero usando aritmética de envoltura.</target>
        </trans-unit>
        <trans-unit id="3a96ac2990d9d6aa59d405db07b7ab3697d51ab5" translate="yes" xml:space="preserve">
          <source>Calculates the offset from a pointer using wrapping arithmetic. (convenience for &lt;code&gt;.wrapping_offset((count as isize).wrapping_sub())&lt;/code&gt;)</source>
          <target state="translated">Calcula el desplazamiento de un puntero mediante aritm&amp;eacute;tica de ajuste. (conveniencia para &lt;code&gt;.wrapping_offset((count as isize).wrapping_sub())&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="4437f7540901d3da485cf44951a321623f5d54ea" translate="yes" xml:space="preserve">
          <source>Calculates the offset from a pointer using wrapping arithmetic. (convenience for &lt;code&gt;.wrapping_offset(count as isize)&lt;/code&gt;)</source>
          <target state="translated">Calcula el desplazamiento de un puntero mediante aritm&amp;eacute;tica de ajuste. (conveniencia para &lt;code&gt;.wrapping_offset(count as isize)&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="fced3b907bf59a9a00c1e327030e6d3af8cc26ee" translate="yes" xml:space="preserve">
          <source>Calculates the offset from a pointer using wrapping arithmetic. &lt;code&gt;count&lt;/code&gt; is in units of T; e.g., a &lt;code&gt;count&lt;/code&gt; of 3 represents a pointer offset of &lt;code&gt;3 * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes.</source>
          <target state="translated">Calcula el desplazamiento de un puntero mediante aritm&amp;eacute;tica de ajuste. &lt;code&gt;count&lt;/code&gt; est&amp;aacute; en unidades de T; por ejemplo, una &lt;code&gt;count&lt;/code&gt; de 3 representa un desplazamiento de puntero de &lt;code&gt;3 * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes.</target>
        </trans-unit>
        <trans-unit id="bb349c3d2b61d501336bb2fe8cf2ff557d376135" translate="yes" xml:space="preserve">
          <source>Calculates the offset from a pointer, potentially wrapping.</source>
          <target state="translated">Calcula el desplazamiento de un puntero,potencialmente envolvente.</target>
        </trans-unit>
        <trans-unit id="bceae705a5fda0d95a2adc01d7e85d8d0a2f7b90" translate="yes" xml:space="preserve">
          <source>Calculates the offset from a pointer.</source>
          <target state="translated">Calcula la desviación de un puntero.</target>
        </trans-unit>
        <trans-unit id="20e05ec484d26186b0ee114ebaa6c93c15ef1c02" translate="yes" xml:space="preserve">
          <source>Calculates the quotient of Euclidean division &lt;code&gt;self.div_euclid(rhs)&lt;/code&gt;.</source>
          <target state="translated">Calcula el cociente de la divisi&amp;oacute;n euclidiana &lt;code&gt;self.div_euclid(rhs)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39720ba2c3f54664835e5cfd429b8dbb6ddb3ddb" translate="yes" xml:space="preserve">
          <source>Calculates the quotient of Euclidean division of &lt;code&gt;self&lt;/code&gt; by &lt;code&gt;rhs&lt;/code&gt;.</source>
          <target state="translated">Calcula el cociente de la divisi&amp;oacute;n euclidiana de &lt;code&gt;self&lt;/code&gt; por &lt;code&gt;rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5a8c64bc432948fb8acbf8240c8594765e8fa48" translate="yes" xml:space="preserve">
          <source>Calculates the remainder &lt;code&gt;self.rem_euclid(rhs)&lt;/code&gt; as if by Euclidean division.</source>
          <target state="translated">Calcula el resto &lt;code&gt;self.rem_euclid(rhs)&lt;/code&gt; como por divisi&amp;oacute;n euclidiana.</target>
        </trans-unit>
        <trans-unit id="dd73ba699034056b9c5150298e8d456b025d264b" translate="yes" xml:space="preserve">
          <source>Calculates the remainder when &lt;code&gt;self&lt;/code&gt; is divided by &lt;code&gt;rhs&lt;/code&gt;.</source>
          <target state="translated">Calcula el resto cuando &lt;code&gt;self&lt;/code&gt; se divide por &lt;code&gt;rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="beb148e8941aab843a69c5323a4e82bfc27fae30" translate="yes" xml:space="preserve">
          <source>Calculations in applications like audio decoders often prioritize performance most highly. Here, we&amp;rsquo;re creating an iterator, using two adaptors, and then consuming the value. What assembly code would this Rust code compile to? Well, as of this writing, it compiles down to the same assembly you&amp;rsquo;d write by hand. There&amp;rsquo;s no loop at all corresponding to the iteration over the values in &lt;code&gt;coefficients&lt;/code&gt;: Rust knows that there are 12 iterations, so it &amp;ldquo;unrolls&amp;rdquo; the loop. &lt;em&gt;Unrolling&lt;/em&gt; is an optimization that removes the overhead of the loop controlling code and instead generates repetitive code for each iteration of the loop.</source>
          <target state="translated">Los c&amp;aacute;lculos en aplicaciones como los decodificadores de audio a menudo dan mayor prioridad al rendimiento. Aqu&amp;iacute;, estamos creando un iterador, usando dos adaptadores y luego consumiendo el valor. &amp;iquest;En qu&amp;eacute; c&amp;oacute;digo ensamblador se compilar&amp;iacute;a este c&amp;oacute;digo de Rust? Bueno, al momento de escribir esto, se compila en el mismo ensamblaje que escribir&amp;iacute;as a mano. No hay ning&amp;uacute;n bucle correspondiente a la iteraci&amp;oacute;n sobre los valores en &lt;code&gt;coefficients&lt;/code&gt; : Rust sabe que hay 12 iteraciones, por lo que &quot;desenrolla&quot; el bucle. &lt;em&gt;El desenrollado&lt;/em&gt; es una optimizaci&amp;oacute;n que elimina la sobrecarga del c&amp;oacute;digo de control de bucle y, en su lugar, genera c&amp;oacute;digo repetitivo para cada iteraci&amp;oacute;n del bucle.</target>
        </trans-unit>
        <trans-unit id="f8b36fa1c392c82310456798302780289916c221" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;unsafe&lt;/code&gt; functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21f282ae75f0466a6ba7a1e840066c459209e8a0" translate="yes" xml:space="preserve">
          <source>Call an unsafe function or method</source>
          <target state="translated">Llamar a una función o método inseguro</target>
        </trans-unit>
        <trans-unit id="0298ffd4d4d74b375411d1b2e3969f0f3205473d" translate="yes" xml:space="preserve">
          <source>Call expressions</source>
          <target state="translated">Expresiones de llamada</target>
        </trans-unit>
        <trans-unit id="6249f8a9ffd810d4ed69b84e3c802196af864e8b" translate="yes" xml:space="preserve">
          <source>Call traits and coercions</source>
          <target state="translated">Llama a los rasgos y a las coacciones</target>
        </trans-unit>
        <trans-unit id="0c2ff20766f3c9231511aafd553b6c2bff815c3d" translate="yes" xml:space="preserve">
          <source>Callers in turn must expect the source to be in any state that is consistent with its public API since adapters sitting between it and the source have the same access. In particular an adapter may have consumed more elements than strictly necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c586bbc683322c086eef8701f61479b8313e2e3" translate="yes" xml:space="preserve">
          <source>Callers of memory allocation APIs wishing to abort computation in response to an allocation error are encouraged to call this function, rather than directly invoking &lt;code&gt;panic!&lt;/code&gt; or similar.</source>
          <target state="translated">Se recomienda a las personas que llaman a las API de asignaci&amp;oacute;n de memoria que deseen abortar el c&amp;aacute;lculo en respuesta a un error de asignaci&amp;oacute;n que llamen a esta funci&amp;oacute;n, en lugar de invocar directamente el &lt;code&gt;panic!&lt;/code&gt; o similar.</target>
        </trans-unit>
        <trans-unit id="0a1fed80ce769e9299beec7ef90b5a7b9c915af1" translate="yes" xml:space="preserve">
          <source>Callers of this function are responsible that these preconditions are satisfied:</source>
          <target state="translated">Los llamantes de esta función son responsables de que se cumplan estas condiciones previas:</target>
        </trans-unit>
        <trans-unit id="d1c291d9a0fdcacf48fd819bb42d20e5d81ebaea" translate="yes" xml:space="preserve">
          <source>Callers of this function are responsible that three preconditions are satisfied:</source>
          <target state="translated">Los llamantes de esta función son responsables de que se cumplan tres condiciones previas:</target>
        </trans-unit>
        <trans-unit id="7d8639a217f023f0e5aaf72760a98b8b29436661" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; (or other functions that wrap around it) will make the parent process wait until the child has actually exited before continuing.</source>
          <target state="translated">Llamar a &lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; (u otras funciones que lo rodean) har&amp;aacute; que el proceso padre espere hasta que el hijo haya salido antes de continuar.</target>
        </trans-unit>
        <trans-unit id="481d687176f898ccda26367fc40f1ddb55f0bae7" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;struct.child#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; (or other functions that wrap around it) will make the parent process wait until the child has actually exited before continuing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5deeaea616be877d309408666a16c136418ff8a" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/a&gt; guarantees that at least one value of the iterator's underlying source has been moved out and the result of the iterator chain could be inserted in its place, assuming structural constraints of the source allow such an insertion. In other words this trait indicates that an iterator pipeline can be collected in place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e7c98d8910ba30f7a29fe334c3bdf59a65f7d25" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; this way gets repetitive. Rust has a construct which can call &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; on your iterator, until it reaches &lt;code&gt;None&lt;/code&gt;. Let's go over that next.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="062a68bd5946d6865cea7336de4cb67da3dd476e" translate="yes" xml:space="preserve">
          <source>Calling &lt;code id=&quot;calling-confignew-and-handling-errors&quot;&gt;Config::new&lt;/code&gt; and Handling Errors</source>
          <target state="translated">Llamando a &lt;code id=&quot;calling-confignew-and-handling-errors&quot;&gt;Config::new&lt;/code&gt; y manejando errores</target>
        </trans-unit>
        <trans-unit id="05271cdf6db26718c2abf90da7409799d4703173" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;advance_back_by(0)&lt;/code&gt; does not consume any elements and always returns &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(())&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2db88eb30c547ef9dcc31ceb834f1125361cdd6" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;advance_back_by(0)&lt;/code&gt; does not consume any elements and always returns [&lt;code&gt;Ok(())&lt;/code&gt;].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df6f9e29581ee3a7fb3292d54be3a75552132038" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;advance_by(0)&lt;/code&gt; does not consume any elements and always returns &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(())&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29810a8b26f09a3007bc1a15cd51bd68ab82979c" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;advance_by(0)&lt;/code&gt; does not consume any elements and always returns [&lt;code&gt;Ok(())&lt;/code&gt;].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e40c65454f5635fc0b10e5666dc4831c6b5a85ea" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;into_owned&lt;/code&gt; on a &lt;code&gt;Cow::Borrowed&lt;/code&gt; clones the underlying data and becomes a &lt;code&gt;Cow::Owned&lt;/code&gt;:</source>
          <target state="translated">Llamar a &lt;code&gt;into_owned&lt;/code&gt; en una &lt;code&gt;Cow::Borrowed&lt;/code&gt; clona los datos subyacentes y se convierte en una &lt;code&gt;Cow::Owned&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d45f4417b85022c3db61725f3af3e2cc322eb41e" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;into_owned&lt;/code&gt; on a &lt;code&gt;Cow::Owned&lt;/code&gt; is a no-op:</source>
          <target state="translated">Llamar a &lt;code&gt;into_owned&lt;/code&gt; en una &lt;code&gt;Cow::Owned&lt;/code&gt; es una operaci&amp;oacute;n :</target>
        </trans-unit>
        <trans-unit id="695c031ebd8b1d35a483a10782e7c17d879fd0d1" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;join&lt;/code&gt; on the handle blocks the thread currently running until the thread represented by the handle terminates. &lt;em&gt;Blocking&lt;/em&gt; a thread means that thread is prevented from performing work or exiting. Because we&amp;rsquo;ve put the call to &lt;code&gt;join&lt;/code&gt; after the main thread&amp;rsquo;s &lt;code&gt;for&lt;/code&gt; loop, running Listing 16-2 should produce output similar to this:</source>
          <target state="translated">Llamar a &lt;code&gt;join&lt;/code&gt; en el identificador bloquea el hilo que se est&amp;aacute; ejecutando actualmente hasta que el hilo representado por el identificador termina. &lt;em&gt;Bloquear&lt;/em&gt; un hilo significa que el hilo no puede realizar el trabajo o salir. Debido a que hemos puesto la llamada a &lt;code&gt;join&lt;/code&gt; despu&amp;eacute;s del bucle &lt;code&gt;for&lt;/code&gt; del hilo principal , ejecutar el Listado 16-2 deber&amp;iacute;a producir una salida similar a esta:</target>
        </trans-unit>
        <trans-unit id="bba53e5336fa9eed56530a5c7e1f4d704c60b408" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;next()&lt;/code&gt; this way gets repetitive. Rust has a construct which can call &lt;code&gt;next()&lt;/code&gt; on your iterator, until it reaches &lt;code&gt;None&lt;/code&gt;. Let's go over that next.</source>
          <target state="translated">Llamar a &lt;code&gt;next()&lt;/code&gt; esta manera se vuelve repetitivo. Rust tiene una construcci&amp;oacute;n que puede llamar a &lt;code&gt;next()&lt;/code&gt; en su iterador, hasta que llega a &lt;code&gt;None&lt;/code&gt; . Repasemos eso a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="52eefc013b01e5d9adae0a652dc16672febe75fe" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;nth()&lt;/code&gt; multiple times doesn't rewind the iterator:</source>
          <target state="translated">Llamar a &lt;code&gt;nth()&lt;/code&gt; varias veces no rebobina el iterador:</target>
        </trans-unit>
        <trans-unit id="162f7cd67f7da63727e6f1ac3373291fc6afc8f1" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;nth_back()&lt;/code&gt; multiple times doesn't rewind the iterator:</source>
          <target state="translated">Llamar a &lt;code&gt;nth_back()&lt;/code&gt; varias veces no rebobina el iterador:</target>
        </trans-unit>
        <trans-unit id="c598d6b0bb84ae897f110d0577b80a5562b3ffe9" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;to_string_lossy&lt;/code&gt; on a &lt;code&gt;CStr&lt;/code&gt; containing invalid UTF-8:</source>
          <target state="translated">Llamar a &lt;code&gt;to_string_lossy&lt;/code&gt; en un &lt;code&gt;CStr&lt;/code&gt; que contiene UTF-8 no v&amp;aacute;lido:</target>
        </trans-unit>
        <trans-unit id="7e6835821e80fa4f9f034eef42e8cd6c55d7f554" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;to_string_lossy&lt;/code&gt; on a &lt;code&gt;CStr&lt;/code&gt; containing valid UTF-8:</source>
          <target state="translated">Llamar a &lt;code&gt;to_string_lossy&lt;/code&gt; en un &lt;code&gt;CStr&lt;/code&gt; que contenga UTF-8 v&amp;aacute;lido:</target>
        </trans-unit>
        <trans-unit id="7c7011eb1a41a55a7c56907e801179e9dea5b3cf" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;to_string_lossy&lt;/code&gt; on a &lt;code&gt;Path&lt;/code&gt; with valid unicode:</source>
          <target state="translated">Llamar a &lt;code&gt;to_string_lossy&lt;/code&gt; en una &lt;code&gt;Path&lt;/code&gt; con unicode v&amp;aacute;lido:</target>
        </trans-unit>
        <trans-unit id="f31c7c45b0c7aeef2d4d0ffc68da4406c29790a0" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;to_string_lossy&lt;/code&gt; on an &lt;code&gt;OsStr&lt;/code&gt; with invalid unicode:</source>
          <target state="translated">Llamar a &lt;code&gt;to_string_lossy&lt;/code&gt; en un &lt;code&gt;OsStr&lt;/code&gt; con unicode no v&amp;aacute;lido:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
