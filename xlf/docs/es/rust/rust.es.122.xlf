<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="d4945a59276bcf1f4830f2a8c1b3defd3c68cde5" translate="yes" xml:space="preserve">
          <source>Namespace path</source>
          <target state="translated">Ruta del espacio de nombres</target>
        </trans-unit>
        <trans-unit id="59cb29ad5b08231ec027d2b58b07b4db4094a48e" translate="yes" xml:space="preserve">
          <source>Naming hardcoded values used throughout your program as constants is useful in conveying the meaning of that value to future maintainers of the code. It also helps to have only one place in your code you would need to change if the hardcoded value needed to be updated in the future.</source>
          <target state="translated">Nombrar los valores de código duro utilizados en todo el programa como constantes es útil para transmitir el significado de ese valor a los futuros mantenedores del código.También ayuda tener sólo un lugar en su código que tendría que cambiar si el valor hardcoded necesitara ser actualizado en el futuro.</target>
        </trans-unit>
        <trans-unit id="4ea0a808e9b003709a882c3eda3364c5952aaed6" translate="yes" xml:space="preserve">
          <source>Naming threads</source>
          <target state="translated">Nombrar los hilos</target>
        </trans-unit>
        <trans-unit id="2773f0d2f9f4e7e59e9c30b201b04dd1a5c30189" translate="yes" xml:space="preserve">
          <source>Native threads.</source>
          <target state="translated">Hilos nativos.</target>
        </trans-unit>
        <trans-unit id="f736bf35e196e5f8a2152cf612783a7b401c2cad" translate="yes" xml:space="preserve">
          <source>Ne</source>
          <target state="translated">Ne</target>
        </trans-unit>
        <trans-unit id="ad9041802b2ad5cd647573800f68f895c77cc8fe" translate="yes" xml:space="preserve">
          <source>Neg</source>
          <target state="translated">Neg</target>
        </trans-unit>
        <trans-unit id="64377c7ff3fff06094951f56bcf30132ee73161a" translate="yes" xml:space="preserve">
          <source>Neg::neg</source>
          <target state="translated">Neg::neg</target>
        </trans-unit>
        <trans-unit id="2133424c311abcb51295591d17f0ab0ae52b1f1a" translate="yes" xml:space="preserve">
          <source>Negates self in an overflowing fashion.</source>
          <target state="translated">Se niega a sí mismo de forma desbordante.</target>
        </trans-unit>
        <trans-unit id="163f10b84a51abc2d56ad3b9131ea073b011f340" translate="yes" xml:space="preserve">
          <source>Negates self, overflowing if this is equal to the minimum value.</source>
          <target state="translated">Se niega a sí mismo,desbordándose si es igual al valor mínimo.</target>
        </trans-unit>
        <trans-unit id="24048c04eba343a323fecac37d642445c66f6c28" translate="yes" xml:space="preserve">
          <source>Negation</source>
          <target state="translated">Negation</target>
        </trans-unit>
        <trans-unit id="f43c19cc20dec09f56a336941f1748c0f4c49844" translate="yes" xml:space="preserve">
          <source>Negation operators</source>
          <target state="translated">Operadores de negación</target>
        </trans-unit>
        <trans-unit id="17843c0405b3d56c0f1f2a9c5762b3ce7f769007" translate="yes" xml:space="preserve">
          <source>Negation*</source>
          <target state="translated">Negation*</target>
        </trans-unit>
        <trans-unit id="b07705471769113a1673291a380e793691cb93d8" translate="yes" xml:space="preserve">
          <source>Negative implementations are a promise that the trait will never be implemented for the given types. Therefore, both cannot exists at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b31bd178b9fc5ff620f5314f9aa5aa57ccd4286" translate="yes" xml:space="preserve">
          <source>Negative impls are not allowed to have any items. Negative impls declare that a trait is &lt;strong&gt;not&lt;/strong&gt; implemented (and never will be) and hence there is no need to specify the values for trait methods or other items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e113717082f98a849bcb00740af62ca1b508554b" translate="yes" xml:space="preserve">
          <source>Negative impls are only allowed for auto traits. For more information see the &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md&quot;&gt;opt-in builtin traits RFC&lt;/a&gt;.</source>
          <target state="translated">Las implicaciones negativas solo se permiten para rasgos autom&amp;aacute;ticos. Para obtener m&amp;aacute;s informaci&amp;oacute;n, consulte el &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md&quot;&gt;RFC de caracter&amp;iacute;sticas incorporadas de suscripci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0615e40800cad75c4988298cdebe16d2bc992b36" translate="yes" xml:space="preserve">
          <source>Negative impls cannot be default impls. A default impl supplies default values for the items within to be used by other impls, whereas a negative impl declares that there are no other impls. Combining it does not make sense.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="075388f0e224328f0ef13d31f89995f6f2c54896" translate="yes" xml:space="preserve">
          <source>Negative infinity</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb6b7b244457f2bc0330b32b4347438278828967" translate="yes" xml:space="preserve">
          <source>Negative infinity (&amp;minus;&amp;infin;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31031ada08602da6a93f5f5a6962d2039849eda8" translate="yes" xml:space="preserve">
          <source>Negative infinity (&amp;minus;&amp;infin;). Use &lt;a href=&quot;../primitive.f32#associatedconstant.NEG_INFINITY&quot;&gt;&lt;code&gt;f32::NEG_INFINITY&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f342b4f8475b808f61b1967602254bedfcdc5688" translate="yes" xml:space="preserve">
          <source>Negative infinity (&amp;minus;&amp;infin;). Use &lt;a href=&quot;../primitive.f64#associatedconstant.NEG_INFINITY&quot;&gt;&lt;code&gt;f64::NEG_INFINITY&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0bc318765f26abdc2b2efb29b7106a82fb8fb4b" translate="yes" xml:space="preserve">
          <source>Negative infinity (-&amp;infin;).</source>
          <target state="translated">Infinito negativo (-&amp;infin;).</target>
        </trans-unit>
        <trans-unit id="0b247e3c8355086599e15be9efdc87a68cb4c92b" translate="yes" xml:space="preserve">
          <source>Negative numbers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72021c01935802b94d4bcd9c9615be5e2c464ac9" translate="yes" xml:space="preserve">
          <source>Negative quiet NaN</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bb8a4159eba393bec0f206dd4b2eb1942475e21" translate="yes" xml:space="preserve">
          <source>Negative signaling NaN</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16ee7bf9e7ed5622172a82905b10c817e30e7444" translate="yes" xml:space="preserve">
          <source>Negative subnormal numbers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbee361595328b1b81f0564c184162939e173b0f" translate="yes" xml:space="preserve">
          <source>Negative zero</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecf5959ac45ac960a39abb26044226e763422de4" translate="yes" xml:space="preserve">
          <source>Neither value is dropped.</source>
          <target state="translated">Ninguno de los dos valores se ha reducido.</target>
        </trans-unit>
        <trans-unit id="4826200965c37ead358d19d4ff8ed0153fd42955" translate="yes" xml:space="preserve">
          <source>Neither will this, which is a syntax error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="665ede9ba12690daf481e44869ce86ddcafb335a" translate="yes" xml:space="preserve">
          <source>Nesting groups of the previous features multiple times, such as &lt;code&gt;use a::b::{self as ab, c, d::{*, e::f}};&lt;/code&gt;</source>
          <target state="translated">Anidar grupos de las caracter&amp;iacute;sticas anteriores varias veces, como &lt;code&gt;use a::b::{self as ab, c, d::{*, e::f}};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c4245fc09474f28a0f0142b9ff14b33a73b77c8f" translate="yes" xml:space="preserve">
          <source>Networking primitives for TCP/UDP communication.</source>
          <target state="translated">Primitivas de red para la comunicación TCP/UDP.</target>
        </trans-unit>
        <trans-unit id="0512d9d610f7bd86dbd1ca707603a7ad85ac4816" translate="yes" xml:space="preserve">
          <source>Never type</source>
          <target state="translated">Nunca escribas.</target>
        </trans-unit>
        <trans-unit id="34989675de773cc2985533af4611fcdec5ac0eea" translate="yes" xml:space="preserve">
          <source>New instances of a &lt;code&gt;struct&lt;/code&gt; can be constructed with a &lt;a href=&quot;../expressions/struct-expr&quot;&gt;struct expression&lt;/a&gt;.</source>
          <target state="translated">Se pueden construir nuevas instancias de una &lt;code&gt;struct&lt;/code&gt; con una &lt;a href=&quot;../expressions/struct-expr&quot;&gt;expresi&amp;oacute;n de estructura&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="474d969a41224d27a052b2157645ae6ea6fdc69d" translate="yes" xml:space="preserve">
          <source>New instances of an &lt;code&gt;enum&lt;/code&gt; can be constructed in an &lt;a href=&quot;../expressions/enum-variant-expr&quot;&gt;enumeration variant expression&lt;/a&gt;.</source>
          <target state="translated">Se pueden construir nuevas instancias de una &lt;code&gt;enum&lt;/code&gt; eraci&amp;oacute;n en una &lt;a href=&quot;../expressions/enum-variant-expr&quot;&gt;expresi&amp;oacute;n de variante de enumeraci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="83c2612a110d45187eac1c39a648ac614b8c7d56" translate="yes" xml:space="preserve">
          <source>New versions of Unicode are released regularly and subsequently all methods in the standard library depending on Unicode are updated. Therefore the behavior of some &lt;code&gt;char&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt; methods and the value of this constant changes over time. This is &lt;em&gt;not&lt;/em&gt; considered to be a breaking change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d706a7f27906e3a8bf4f4fed0f9c3d7edc4a240a" translate="yes" xml:space="preserve">
          <source>Newline</source>
          <target state="translated">Newline</target>
        </trans-unit>
        <trans-unit id="d783d54db2abcb54d1f3f2d8b19273a6830adb8c" translate="yes" xml:space="preserve">
          <source>Newsqueak, Alef, Limbo: channels, concurrency</source>
          <target state="translated">Newsqueak,Alef,Limbo:canales,concurrencia</target>
        </trans-unit>
        <trans-unit id="9000cfe362fe35a00622dc16de8a42fe71435817" translate="yes" xml:space="preserve">
          <source>Newtypes can also hide internal implementation. For example, we could provide a &lt;code&gt;People&lt;/code&gt; type to wrap a &lt;code&gt;HashMap&amp;lt;i32, String&amp;gt;&lt;/code&gt; that stores a person&amp;rsquo;s ID associated with their name. Code using &lt;code&gt;People&lt;/code&gt; would only interact with the public API we provide, such as a method to add a name string to the &lt;code&gt;People&lt;/code&gt; collection; that code wouldn&amp;rsquo;t need to know that we assign an &lt;code&gt;i32&lt;/code&gt; ID to names internally. The newtype pattern is a lightweight way to achieve encapsulation to hide implementation details, which we discussed in the &lt;a href=&quot;ch17-01-what-is-oo#encapsulation-that-hides-implementation-details&quot;&gt;&amp;ldquo;Encapsulation that Hides Implementation Details&amp;rdquo;&lt;/a&gt; section of Chapter 17.</source>
          <target state="translated">Los nuevos tipos tambi&amp;eacute;n pueden ocultar la implementaci&amp;oacute;n interna. Por ejemplo, podr&amp;iacute;amos proporcionar un tipo de &lt;code&gt;People&lt;/code&gt; para envolver un &lt;code&gt;HashMap&amp;lt;i32, String&amp;gt;&lt;/code&gt; que almacena la identificaci&amp;oacute;n de una persona asociada con su nombre. El c&amp;oacute;digo que usa &lt;code&gt;People&lt;/code&gt; solo interactuar&amp;iacute;a con la API p&amp;uacute;blica que proporcionamos, como un m&amp;eacute;todo para agregar una cadena de nombre a la colecci&amp;oacute;n &lt;code&gt;People&lt;/code&gt; ; ese c&amp;oacute;digo no necesitar&amp;iacute;a saber que asignamos un ID de &lt;code&gt;i32&lt;/code&gt; a los nombres internamente. El patr&amp;oacute;n newtype es una forma ligera de lograr la encapsulaci&amp;oacute;n para ocultar los detalles de implementaci&amp;oacute;n, que discutimos en la secci&amp;oacute;n &lt;a href=&quot;ch17-01-what-is-oo#encapsulation-that-hides-implementation-details&quot;&gt;&amp;ldquo;Encapsulaci&amp;oacute;n que oculta los detalles de implementaci&amp;oacute;n&amp;rdquo;&lt;/a&gt; del Cap&amp;iacute;tulo 17.</target>
        </trans-unit>
        <trans-unit id="7bae91cced3da7b704f84e06989b7947e80e541e" translate="yes" xml:space="preserve">
          <source>Next are the &lt;code&gt;match&lt;/code&gt; arms. An arm has two parts: a pattern and some code. The first arm here has a pattern that is the value &lt;code&gt;Coin::Penny&lt;/code&gt; and then the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator that separates the pattern and the code to run. The code in this case is just the value &lt;code&gt;1&lt;/code&gt;. Each arm is separated from the next with a comma.</source>
          <target state="translated">Luego est&amp;aacute;n los brazos de &lt;code&gt;match&lt;/code&gt; . Un brazo tiene dos partes: un patr&amp;oacute;n y un c&amp;oacute;digo. El primer brazo aqu&amp;iacute; tiene un patr&amp;oacute;n que es el valor &lt;code&gt;Coin::Penny&lt;/code&gt; y luego el operador &lt;code&gt;=&amp;gt;&lt;/code&gt; que separa el patr&amp;oacute;n y el c&amp;oacute;digo a ejecutar. El c&amp;oacute;digo en este caso es solo el valor &lt;code&gt;1&lt;/code&gt; . Cada brazo est&amp;aacute; separado del siguiente con una coma.</target>
        </trans-unit>
        <trans-unit id="bf7420cff34f7205e5c081be758df804f4a3397f" translate="yes" xml:space="preserve">
          <source>Next is the &lt;code&gt;main&lt;/code&gt; function, which contains the parts of the workout app important for this example. This function represents the code that the app will call when a user asks for a workout plan. Because the interaction with the app&amp;rsquo;s frontend isn&amp;rsquo;t relevant to the use of closures, we&amp;rsquo;ll hardcode values representing inputs to our program and print the outputs.</source>
          <target state="translated">La siguiente es la funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; , que contiene las partes de la aplicaci&amp;oacute;n de entrenamiento importantes para este ejemplo. Esta funci&amp;oacute;n representa el c&amp;oacute;digo al que llamar&amp;aacute; la aplicaci&amp;oacute;n cuando un usuario solicite un plan de entrenamiento. Debido a que la interacci&amp;oacute;n con la interfaz de la aplicaci&amp;oacute;n no es relevante para el uso de cierres, codificaremos los valores que representan las entradas a nuestro programa e imprimiremos las salidas.</target>
        </trans-unit>
        <trans-unit id="c65bbe969462e1bc44ee3000579ab22fe481fd4c" translate="yes" xml:space="preserve">
          <source>Next, for the penultimate chapter of the book, we&amp;rsquo;ll look at some advanced aspects of a variety of Rust&amp;rsquo;s features.</source>
          <target state="translated">A continuaci&amp;oacute;n, para el pen&amp;uacute;ltimo cap&amp;iacute;tulo del libro, veremos algunos aspectos avanzados de una variedad de caracter&amp;iacute;sticas de Rust.</target>
        </trans-unit>
        <trans-unit id="52208e82490358e0e353201224729d0b32e9211f" translate="yes" xml:space="preserve">
          <source>Next, in the &lt;em&gt;add&lt;/em&gt; directory, we create the &lt;em&gt;Cargo.toml&lt;/em&gt; file that will configure the entire workspace. This file won&amp;rsquo;t have a &lt;code&gt;[package]&lt;/code&gt; section or the metadata we&amp;rsquo;ve seen in other &lt;em&gt;Cargo.toml&lt;/em&gt; files. Instead, it will start with a &lt;code&gt;[workspace]&lt;/code&gt; section that will allow us to add members to the workspace by specifying the path to our binary crate; in this case, that path is &lt;em&gt;adder&lt;/em&gt;:</source>
          <target state="translated">A continuaci&amp;oacute;n, en el directorio &lt;em&gt;add&lt;/em&gt; , creamos el archivo &lt;em&gt;Cargo.toml&lt;/em&gt; que configurar&amp;aacute; todo el espacio de trabajo. Este archivo no tendr&amp;aacute; una secci&amp;oacute;n &lt;code&gt;[package]&lt;/code&gt; o los metadatos que hemos visto en otros archivos &lt;em&gt;Cargo.toml&lt;/em&gt; . En su lugar, comenzar&amp;aacute; con una secci&amp;oacute;n &lt;code&gt;[workspace]&lt;/code&gt; que nos permitir&amp;aacute; agregar miembros al espacio de trabajo especificando la ruta a nuestra caja binaria; en este caso, esa ruta es &lt;em&gt;sumadora&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="cf3583fbb6ba42fdef61381eb0f22f26cc65cb4c" translate="yes" xml:space="preserve">
          <source>Next, in the &lt;em&gt;add&lt;/em&gt; directory, we create the &lt;em&gt;Cargo.toml&lt;/em&gt; file that will configure the entire workspace. This file won&amp;rsquo;t have a &lt;code&gt;[package]&lt;/code&gt; section or the metadata we&amp;rsquo;ve seen in other &lt;em&gt;Cargo.toml&lt;/em&gt; files. Instead, it will start with a &lt;code&gt;[workspace]&lt;/code&gt; section that will allow us to add members to the workspace by specifying the path to the package with our binary crate; in this case, that path is &lt;em&gt;adder&lt;/em&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d5673d4c0782df5e2ab93b6ac7b7285949caf0a" translate="yes" xml:space="preserve">
          <source>Next, let&amp;rsquo;s create another member crate in the workspace and call it &lt;code&gt;add-one&lt;/code&gt;. Change the top-level &lt;em&gt;Cargo.toml&lt;/em&gt; to specify the &lt;em&gt;add-one&lt;/em&gt; path in the &lt;code&gt;members&lt;/code&gt; list:</source>
          <target state="translated">A continuaci&amp;oacute;n, creemos otra caja de miembros en el espacio de trabajo y llam&amp;eacute;mosla &lt;code&gt;add-one&lt;/code&gt; . Cambie el &lt;em&gt;Cargo.toml de&lt;/em&gt; nivel &lt;em&gt;superior&lt;/em&gt; para especificar la ruta del &lt;em&gt;complemento&lt;/em&gt; en la lista de &lt;code&gt;members&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9b3259a6676f65921f501e882bdad69e2021df7f" translate="yes" xml:space="preserve">
          <source>Next, let&amp;rsquo;s create another member package in the workspace and call it &lt;code&gt;add-one&lt;/code&gt;. Change the top-level &lt;em&gt;Cargo.toml&lt;/em&gt; to specify the &lt;em&gt;add-one&lt;/em&gt; path in the &lt;code&gt;members&lt;/code&gt; list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ba0c012105d9f7e5a4cb08c9812f147ef92fc3f" translate="yes" xml:space="preserve">
          <source>Next, let&amp;rsquo;s explore how the other kinds of procedural macros differ from custom derive macros.</source>
          <target state="translated">A continuaci&amp;oacute;n, exploremos en qu&amp;eacute; se diferencian los otros tipos de macros de procedimiento de las macros de derivaci&amp;oacute;n personalizadas.</target>
        </trans-unit>
        <trans-unit id="7388ce6c4f87a59e05725876ec1ba13ab5a6c132" translate="yes" xml:space="preserve">
          <source>Next, let&amp;rsquo;s look at macros!</source>
          <target state="translated">A continuaci&amp;oacute;n, &amp;iexcl;veamos las macros!</target>
        </trans-unit>
        <trans-unit id="a41ab1aeb6ce0234b517ca6ca3124ad3db811d40" translate="yes" xml:space="preserve">
          <source>Next, let&amp;rsquo;s try an example that shows that the lifetime of the reference in &lt;code&gt;result&lt;/code&gt; must be the smaller lifetime of the two arguments. We&amp;rsquo;ll move the declaration of the &lt;code&gt;result&lt;/code&gt; variable outside the inner scope but leave the assignment of the value to the &lt;code&gt;result&lt;/code&gt; variable inside the scope with &lt;code&gt;string2&lt;/code&gt;. Then we&amp;rsquo;ll move the &lt;code&gt;println!&lt;/code&gt; that uses &lt;code&gt;result&lt;/code&gt; outside the inner scope, after the inner scope has ended. The code in Listing 10-24 will not compile.</source>
          <target state="translated">A continuaci&amp;oacute;n, intentemos un ejemplo que muestra que la vida &amp;uacute;til de la referencia en el &lt;code&gt;result&lt;/code&gt; ado debe ser la vida &amp;uacute;til menor de los dos argumentos. Moviremos la declaraci&amp;oacute;n de la variable de &lt;code&gt;result&lt;/code&gt; ado fuera del alcance interno, pero dejaremos la asignaci&amp;oacute;n del valor a la variable de &lt;code&gt;result&lt;/code&gt; ado dentro del alcance con &lt;code&gt;string2&lt;/code&gt; . &amp;iexcl;Entonces moveremos el &lt;code&gt;println!&lt;/code&gt; que usa el &lt;code&gt;result&lt;/code&gt; ado fuera del alcance interno, despu&amp;eacute;s de que el alcance interno ha finalizado. El c&amp;oacute;digo del Listado 10-24 no se compilar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="4cd72ee75b765bce66036759ad44f05bffbba3a1" translate="yes" xml:space="preserve">
          <source>Next, let&amp;rsquo;s use the &lt;code&gt;add_one&lt;/code&gt; function from the &lt;code&gt;add-one&lt;/code&gt; crate in the &lt;code&gt;adder&lt;/code&gt; crate. Open the &lt;em&gt;adder/src/main.rs&lt;/em&gt; file and add a &lt;code&gt;use&lt;/code&gt; line at the top to bring the new &lt;code&gt;add-one&lt;/code&gt; library crate into scope. Then change the &lt;code&gt;main&lt;/code&gt; function to call the &lt;code&gt;add_one&lt;/code&gt; function, as in Listing 14-7.</source>
          <target state="translated">A continuaci&amp;oacute;n, usemos la funci&amp;oacute;n &lt;code&gt;add_one&lt;/code&gt; de la caja &lt;code&gt;add-one&lt;/code&gt; en la caja &lt;code&gt;adder&lt;/code&gt; . Abra el archivo &lt;em&gt;adder / src / main.rs&lt;/em&gt; y agregue una l&amp;iacute;nea de &lt;code&gt;use&lt;/code&gt; en la parte superior para traer la nueva caja de biblioteca &lt;code&gt;add-one&lt;/code&gt; al alcance. Luego cambie la funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; para llamar a la funci&amp;oacute;n &lt;code&gt;add_one&lt;/code&gt; , como en el Listado 14-7.</target>
        </trans-unit>
        <trans-unit id="e1fe2a2a98ce9e857e8667aa0e6390f716cb1d28" translate="yes" xml:space="preserve">
          <source>Next, make a new source file and call it &lt;em&gt;main.rs&lt;/em&gt;. Rust files always end with the &lt;em&gt;.rs&lt;/em&gt; extension. If you&amp;rsquo;re using more than one word in your filename, use an underscore to separate them. For example, use &lt;em&gt;hello_world.rs&lt;/em&gt; rather than &lt;em&gt;helloworld.rs&lt;/em&gt;.</source>
          <target state="translated">A continuaci&amp;oacute;n, crea un nuevo archivo de origen y lo llaman &lt;em&gt;main.rs&lt;/em&gt; . Los archivos Rust siempre terminan con la extensi&amp;oacute;n &lt;em&gt;.rs&lt;/em&gt; . Si usa m&amp;aacute;s de una palabra en su nombre de archivo, use un gui&amp;oacute;n bajo para separarlas. Por ejemplo, use &lt;em&gt;hello_world.rs en&lt;/em&gt; lugar de &lt;em&gt;helloworld.rs&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="03d3c37a590f1ae7381c9279be8f7a97b6800076" translate="yes" xml:space="preserve">
          <source>Next, we add a call to &lt;code&gt;to_lowercase&lt;/code&gt; on each &lt;code&gt;line&lt;/code&gt; before we check whether it contains &lt;code&gt;query&lt;/code&gt; to lowercase all characters. Now that we&amp;rsquo;ve converted &lt;code&gt;line&lt;/code&gt; and &lt;code&gt;query&lt;/code&gt; to lowercase, we&amp;rsquo;ll find matches no matter what the case of the query is.</source>
          <target state="translated">A continuaci&amp;oacute;n, agregamos una llamada a &lt;code&gt;to_lowercase&lt;/code&gt; en cada &lt;code&gt;line&lt;/code&gt; antes de verificar si contiene una &lt;code&gt;query&lt;/code&gt; para poner todos los caracteres en min&amp;uacute;scula. Ahora que hemos convertido la &lt;code&gt;line&lt;/code&gt; y la &lt;code&gt;query&lt;/code&gt; a min&amp;uacute;sculas, encontraremos coincidencias sin importar cu&amp;aacute;l sea el caso de la consulta.</target>
        </trans-unit>
        <trans-unit id="8e52d9272848f0823ca640fddf0b693b0608206b" translate="yes" xml:space="preserve">
          <source>Next, we create an iterator over the array of bytes using the &lt;code&gt;iter&lt;/code&gt; method:</source>
          <target state="translated">A continuaci&amp;oacute;n, creamos un iterador sobre la matriz de bytes usando el m&amp;eacute;todo &lt;code&gt;iter&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fbb5669be934c8d9daa09d2fb6f075709e7fa5e2" translate="yes" xml:space="preserve">
          <source>Next, we implement a method named &lt;code&gt;value&lt;/code&gt; that borrows &lt;code&gt;self&lt;/code&gt;, doesn&amp;rsquo;t have any other parameters, and returns an &lt;code&gt;i32&lt;/code&gt;. This kind of method is sometimes called a &lt;em&gt;getter&lt;/em&gt;, because its purpose is to get some data from its fields and return it. This public method is necessary because the &lt;code&gt;value&lt;/code&gt; field of the &lt;code&gt;Guess&lt;/code&gt; struct is private. It&amp;rsquo;s important that the &lt;code&gt;value&lt;/code&gt; field be private so code using the &lt;code&gt;Guess&lt;/code&gt; struct is not allowed to set &lt;code&gt;value&lt;/code&gt; directly: code outside the module &lt;em&gt;must&lt;/em&gt; use the &lt;code&gt;Guess::new&lt;/code&gt; function to create an instance of &lt;code&gt;Guess&lt;/code&gt;, thereby ensuring there&amp;rsquo;s no way for a &lt;code&gt;Guess&lt;/code&gt; to have a &lt;code&gt;value&lt;/code&gt; that hasn&amp;rsquo;t been checked by the conditions in the &lt;code&gt;Guess::new&lt;/code&gt; function.</source>
          <target state="translated">A continuaci&amp;oacute;n, poner en pr&amp;aacute;ctica un m&amp;eacute;todo llamado &lt;code&gt;value&lt;/code&gt; que toma prestado &lt;code&gt;self&lt;/code&gt; , no tiene ning&amp;uacute;n otro par&amp;aacute;metro, y devuelve un &lt;code&gt;i32&lt;/code&gt; . Este tipo de m&amp;eacute;todo a veces se denomina &lt;em&gt;getter&lt;/em&gt; , porque su prop&amp;oacute;sito es obtener algunos datos de sus campos y devolverlos. Este m&amp;eacute;todo p&amp;uacute;blico es necesario porque el campo de &lt;code&gt;value&lt;/code&gt; de la estructura &lt;code&gt;Guess&lt;/code&gt; es privado. Es importante que el campo de &lt;code&gt;value&lt;/code&gt; sea ​​privado, por lo que el c&amp;oacute;digo que usa la estructura &lt;code&gt;Guess&lt;/code&gt; no puede establecer un &lt;code&gt;value&lt;/code&gt; directamente: el c&amp;oacute;digo fuera del m&amp;oacute;dulo &lt;em&gt;debe&lt;/em&gt; usar la funci&amp;oacute;n &lt;code&gt;Guess::new&lt;/code&gt; para crear una instancia de &lt;code&gt;Guess&lt;/code&gt; , lo que garantiza que no hay forma de que un &lt;code&gt;Guess&lt;/code&gt; tenga un &lt;code&gt;value&lt;/code&gt; que no haya sido verificado por las condiciones en la funci&amp;oacute;n &lt;code&gt;Guess::new&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="605d6de7987c12e157a0df6ee5c1a07b22d453f2" translate="yes" xml:space="preserve">
          <source>Next, we implement the &lt;code&gt;FnBox&lt;/code&gt; trait for any type &lt;code&gt;F&lt;/code&gt; that implements the &lt;code&gt;FnOnce()&lt;/code&gt; trait. Effectively, this means that any &lt;code&gt;FnOnce()&lt;/code&gt; closures can use our &lt;code&gt;call_box&lt;/code&gt; method. The implementation of &lt;code&gt;call_box&lt;/code&gt; uses &lt;code&gt;(*self)()&lt;/code&gt; to move the closure out of the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; and call the closure.</source>
          <target state="translated">A continuaci&amp;oacute;n, implementamos el rasgo &lt;code&gt;FnBox&lt;/code&gt; para cualquier tipo &lt;code&gt;F&lt;/code&gt; que implemente el rasgo &lt;code&gt;FnOnce()&lt;/code&gt; . Efectivamente, esto significa que cualquier &lt;code&gt;FnOnce()&lt;/code&gt; puede usar nuestro m&amp;eacute;todo &lt;code&gt;call_box&lt;/code&gt; . La implementaci&amp;oacute;n de &lt;code&gt;call_box&lt;/code&gt; usa &lt;code&gt;(*self)()&lt;/code&gt; para mover el cierre fuera de &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; y llamar al cierre.</target>
        </trans-unit>
        <trans-unit id="813cf7c3c4cb11a394f89f5d5322e12f202af557" translate="yes" xml:space="preserve">
          <source>Next, we need to actually read from the stream. We do this in two steps: first, we declare a &lt;code&gt;buffer&lt;/code&gt; on the stack to hold the data that is read in. We&amp;rsquo;ve made the buffer 1024 bytes in size, which is big enough to hold the data of a basic request and sufficient for our purposes in this chapter. If we wanted to handle requests of an arbitrary size, buffer management would need to be more complicated; we&amp;rsquo;ll keep it simple for now. We pass the buffer to &lt;code&gt;stream.read&lt;/code&gt;, which will read bytes from the &lt;code&gt;TcpStream&lt;/code&gt; and put them in the buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cc7c952c5d6180788b66b960a497f1bbb0d5cfe" translate="yes" xml:space="preserve">
          <source>Next, we need to actually read from the stream. We do this in two steps: first, we declare a &lt;code&gt;buffer&lt;/code&gt; on the stack to hold the data that is read in. We&amp;rsquo;ve made the buffer 512 bytes in size, which is big enough to hold the data of a basic request and sufficient for our purposes in this chapter. If we wanted to handle requests of an arbitrary size, buffer management would need to be more complicated; we&amp;rsquo;ll keep it simple for now. We pass the buffer to &lt;code&gt;stream.read&lt;/code&gt;, which will read bytes from the &lt;code&gt;TcpStream&lt;/code&gt; and put them in the buffer.</source>
          <target state="translated">A continuaci&amp;oacute;n, necesitamos leer realmente de la transmisi&amp;oacute;n. Hacemos esto en dos pasos: primero, declaramos un &lt;code&gt;buffer&lt;/code&gt; en la pila para contener los datos que se leen. Hemos creado el b&amp;uacute;fer de 512 bytes de tama&amp;ntilde;o, que es lo suficientemente grande para contener los datos de una solicitud b&amp;aacute;sica y suficiente para nuestros prop&amp;oacute;sitos en este cap&amp;iacute;tulo. Si quisi&amp;eacute;ramos manejar solicitudes de un tama&amp;ntilde;o arbitrario, la administraci&amp;oacute;n del b&amp;uacute;fer tendr&amp;iacute;a que ser m&amp;aacute;s complicada; lo haremos simple por ahora. Pasamos el b&amp;uacute;fer a &lt;code&gt;stream.read&lt;/code&gt; , que leer&amp;aacute; bytes del &lt;code&gt;TcpStream&lt;/code&gt; y los colocar&amp;aacute; en el b&amp;uacute;fer.</target>
        </trans-unit>
        <trans-unit id="76351bb871037a13a112e6c874825b1ebb4611c8" translate="yes" xml:space="preserve">
          <source>Next, we need to add functionality to request a review of a post, which should change its state from &lt;code&gt;Draft&lt;/code&gt; to &lt;code&gt;PendingReview&lt;/code&gt;. Listing 17-15 shows this code:</source>
          <target state="translated">A continuaci&amp;oacute;n, necesitamos agregar funcionalidad para solicitar una revisi&amp;oacute;n de una publicaci&amp;oacute;n, que deber&amp;iacute;a cambiar su estado de &lt;code&gt;Draft&lt;/code&gt; a &lt;code&gt;PendingReview&lt;/code&gt; . El listado 17-15 muestra este c&amp;oacute;digo:</target>
        </trans-unit>
        <trans-unit id="92e1faec54108ffc0dae30cd9cc0b93fd8d1895e" translate="yes" xml:space="preserve">
          <source>Next, we need to generate a secret number that the user will try to guess. The secret number should be different every time so the game is fun to play more than once. Let&amp;rsquo;s use a random number between 1 and 100 so the game isn&amp;rsquo;t too difficult. Rust doesn&amp;rsquo;t yet include random number functionality in its standard library. However, the Rust team does provide a &lt;a href=&quot;https://crates.io/crates/rand&quot;&gt;&lt;code&gt;rand&lt;/code&gt; crate&lt;/a&gt;.</source>
          <target state="translated">A continuaci&amp;oacute;n, necesitamos generar un n&amp;uacute;mero secreto que el usuario intentar&amp;aacute; adivinar. El n&amp;uacute;mero secreto debe ser diferente cada vez para que el juego sea divertido de jugar m&amp;aacute;s de una vez. Usemos un n&amp;uacute;mero aleatorio entre 1 y 100 para que el juego no sea demasiado dif&amp;iacute;cil. Rust a&amp;uacute;n no incluye la funcionalidad de n&amp;uacute;meros aleatorios en su biblioteca est&amp;aacute;ndar. Sin embargo, el equipo de Rust proporciona una &lt;a href=&quot;https://crates.io/crates/rand&quot;&gt;caja de &lt;/a&gt; &lt;code&gt;rand&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b3048ae1981e29d8fc7bb24867dd28498448fb02" translate="yes" xml:space="preserve">
          <source>Next, we need to update the definition of &lt;code&gt;Config::new&lt;/code&gt;. In your I/O project&amp;rsquo;s &lt;em&gt;src/lib.rs&lt;/em&gt; file, let&amp;rsquo;s change the signature of &lt;code&gt;Config::new&lt;/code&gt; to look like Listing 13-26. This still won&amp;rsquo;t compile because we need to update the function body.</source>
          <target state="translated">A continuaci&amp;oacute;n, necesitamos actualizar la definici&amp;oacute;n de &lt;code&gt;Config::new&lt;/code&gt; . En el archivo &lt;em&gt;src / lib.rs de&lt;/em&gt; su proyecto de E / S , cambiemos la firma de &lt;code&gt;Config::new&lt;/code&gt; para que se parezca al Listado 13-26. Esto todav&amp;iacute;a no se compilar&amp;aacute; porque necesitamos actualizar el cuerpo de la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f7002fc97279e473d70d4660362de14f1e116f1c" translate="yes" xml:space="preserve">
          <source>Next, we use &lt;code&gt;format!&lt;/code&gt; to add the file&amp;rsquo;s contents as the body of the success response.</source>
          <target state="translated">A continuaci&amp;oacute;n, usamos &lt;code&gt;format!&lt;/code&gt; para agregar el contenido del archivo como el cuerpo de la respuesta de &amp;eacute;xito.</target>
        </trans-unit>
        <trans-unit id="5f1848680d22a75c771965dd71d24a16003163fc" translate="yes" xml:space="preserve">
          <source>Next, we use &lt;code&gt;format!&lt;/code&gt; to add the file&amp;rsquo;s contents as the body of the success response. To ensure a valid HTTP response, we add the &lt;code&gt;Content-Length&lt;/code&gt; header which is set to the size of our response body, in this case the size of &lt;code&gt;hello.html&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1cb8822a67321b8c02da9e7e8c260dc9c0b608d" translate="yes" xml:space="preserve">
          <source>Next, we want to enable a request for a review of the post, and we want &lt;code&gt;content&lt;/code&gt; to return an empty string while waiting for the review. When the post receives approval, it should get published, meaning the text of the post will be returned when &lt;code&gt;content&lt;/code&gt; is called.</source>
          <target state="translated">A continuaci&amp;oacute;n, queremos habilitar una solicitud para una revisi&amp;oacute;n de la publicaci&amp;oacute;n, y queremos que el &lt;code&gt;content&lt;/code&gt; devuelva una cadena vac&amp;iacute;a mientras espera la revisi&amp;oacute;n. Cuando la publicaci&amp;oacute;n recibe la aprobaci&amp;oacute;n, debe publicarse, lo que significa que el texto de la publicaci&amp;oacute;n se devolver&amp;aacute; cuando el &lt;code&gt;content&lt;/code&gt; se llame .</target>
        </trans-unit>
        <trans-unit id="dc0c1d1b57e4826864a1d45c2ceee72d00bff7d9" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll check whether the current line contains our query string. Fortunately, strings have a helpful method named &lt;code&gt;contains&lt;/code&gt; that does this for us! Add a call to the &lt;code&gt;contains&lt;/code&gt; method in the &lt;code&gt;search&lt;/code&gt; function, as shown in Listing 12-18. Note this still won&amp;rsquo;t compile yet.</source>
          <target state="translated">A continuaci&amp;oacute;n, comprobaremos si la l&amp;iacute;nea actual contiene nuestra cadena de consulta. Afortunadamente, las cadenas tienen un m&amp;eacute;todo &amp;uacute;til llamado &lt;code&gt;contains&lt;/code&gt; que hace esto por nosotros. Agregar una llamada al m&amp;eacute;todo &lt;code&gt;contains&lt;/code&gt; en la &lt;code&gt;search&lt;/code&gt; funci&amp;oacute;n de , como se muestra en el Listado 12-18. Tenga en cuenta que esto todav&amp;iacute;a no se compilar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="5ac1479b99a85012a6bea69ba1759d1f7cc3ad30" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll create a place to store the user input, like this:</source>
          <target state="translated">A continuaci&amp;oacute;n, crearemos un lugar para almacenar la entrada del usuario, como este:</target>
        </trans-unit>
        <trans-unit id="e5a328539b3bbff608c05675d0f98ba529495a33" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll create a raw pointer whose validity we can&amp;rsquo;t be so certain of. Listing 19-2 shows how to create a raw pointer to an arbitrary location in memory. Trying to use arbitrary memory is undefined: there might be data at that address or there might not, the compiler might optimize the code so there is no memory access, or the program might error with a segmentation fault. Usually, there is no good reason to write code like this, but it is possible.</source>
          <target state="translated">A continuaci&amp;oacute;n, crearemos un puntero sin formato de cuya validez no podemos estar tan seguros. El listado 19-2 muestra c&amp;oacute;mo crear un puntero sin formato a una ubicaci&amp;oacute;n arbitraria en la memoria. Intentar usar memoria arbitraria no est&amp;aacute; definido: puede haber datos en esa direcci&amp;oacute;n o puede que no, el compilador puede optimizar el c&amp;oacute;digo para que no haya acceso a la memoria, o el programa puede producir un error de segmentaci&amp;oacute;n. Por lo general, no hay una buena raz&amp;oacute;n para escribir c&amp;oacute;digo como este, pero es posible.</target>
        </trans-unit>
        <trans-unit id="629644a5201c55cb9634591304da90b26a4571c8" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll create the &lt;code&gt;adder&lt;/code&gt; binary crate by running &lt;code&gt;cargo new&lt;/code&gt; within the &lt;em&gt;add&lt;/em&gt; directory:</source>
          <target state="translated">A continuaci&amp;oacute;n, crearemos la caja binaria &lt;code&gt;adder&lt;/code&gt; ejecutando &lt;code&gt;cargo new&lt;/code&gt; dentro del &lt;em&gt;add&lt;/em&gt; directorio :</target>
        </trans-unit>
        <trans-unit id="4c8171dc56214044bf871f6ef39d7d39bc7a5954" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll define the &lt;code&gt;HelloMacro&lt;/code&gt; trait and its associated function:</source>
          <target state="translated">A continuaci&amp;oacute;n, definiremos &lt;code&gt;HelloMacro&lt;/code&gt; rasgo y su funci&amp;oacute;n asociada:</target>
        </trans-unit>
        <trans-unit id="a47fb6ac34c3efb030b781d2a69ff8c26654e8b7" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll explore some Rust features that were influenced by functional languages: closures and iterators.</source>
          <target state="translated">A continuaci&amp;oacute;n, exploraremos algunas caracter&amp;iacute;sticas de Rust que fueron influenciadas por lenguajes funcionales: cierres e iteradores.</target>
        </trans-unit>
        <trans-unit id="de89b671f67de5d1f170a1b7712e3f2c4f2d52b0" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll explore some advanced features related to functions and closures, which include function pointers and returning closures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df380b1f8d3c4226cb4356e67a4308029f7b04af" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll fix the body of &lt;code&gt;Config::new&lt;/code&gt;. The standard library documentation also mentions that &lt;code&gt;std::env::Args&lt;/code&gt; implements the &lt;code&gt;Iterator&lt;/code&gt; trait, so we know we can call the &lt;code&gt;next&lt;/code&gt; method on it! Listing 13-27 updates the code from Listing 12-23 to use the &lt;code&gt;next&lt;/code&gt; method:</source>
          <target state="translated">A continuaci&amp;oacute;n, arreglaremos el cuerpo de &lt;code&gt;Config::new&lt;/code&gt; . La documentaci&amp;oacute;n de la biblioteca est&amp;aacute;ndar tambi&amp;eacute;n menciona que &lt;code&gt;std::env::Args&lt;/code&gt; implementa el &lt;code&gt;Iterator&lt;/code&gt; de rasgos, por lo que sabemos que podemos llamar al &lt;code&gt;next&lt;/code&gt; m&amp;eacute;todo en &amp;eacute;l! El Listado 13-27 actualiza el c&amp;oacute;digo del Listado 12-23 para usar el &lt;code&gt;next&lt;/code&gt; m&amp;eacute;todo:</target>
        </trans-unit>
        <trans-unit id="3a19f54b1a11fc876360a8c3cf621da7fa07cef6" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll implement the &lt;code&gt;Iterator&lt;/code&gt; trait for our &lt;code&gt;Counter&lt;/code&gt; type by defining the body of the &lt;code&gt;next&lt;/code&gt; method to specify what we want to happen when this iterator is used, as shown in Listing 13-21:</source>
          <target state="translated">A continuaci&amp;oacute;n, implementaremos el rasgo &lt;code&gt;Iterator&lt;/code&gt; para nuestro tipo de &lt;code&gt;Counter&lt;/code&gt; definiendo el cuerpo del &lt;code&gt;next&lt;/code&gt; m&amp;eacute;todo para especificar lo que queremos que suceda cuando se use este iterador, como se muestra en el Listado 13-21:</target>
        </trans-unit>
        <trans-unit id="8192333a1969b9548e0a4b704aec1d71dbd5da8d" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll look at a different kind of reference: slices.</source>
          <target state="translated">A continuaci&amp;oacute;n, veremos un tipo diferente de referencia: cortes.</target>
        </trans-unit>
        <trans-unit id="4634a5dae53b28ce905455154ee2c8f9020614d5" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll look at patterns, which are another of Rust&amp;rsquo;s features that enable lots of flexibility. We&amp;rsquo;ve looked at them briefly throughout the book but haven&amp;rsquo;t seen their full capability yet. Let&amp;rsquo;s go!</source>
          <target state="translated">A continuaci&amp;oacute;n, veremos los patrones, que son otra de las caracter&amp;iacute;sticas de Rust que permiten mucha flexibilidad. Los hemos examinado brevemente a lo largo del libro, pero a&amp;uacute;n no hemos visto su capacidad completa. &amp;iexcl;Vamonos!</target>
        </trans-unit>
        <trans-unit id="c7d28f3c2f2542f898d8da87d4a31466a385d3a6" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll put everything we&amp;rsquo;ve discussed throughout the book into practice and do one more project!</source>
          <target state="translated">A continuaci&amp;oacute;n, pondremos en pr&amp;aacute;ctica todo lo que hemos comentado a lo largo del libro y haremos un proyecto m&amp;aacute;s.</target>
        </trans-unit>
        <trans-unit id="b241e1c5f37c0baa3f70582a9ac2883d59e35af5" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll talk about concurrency in Rust. You&amp;rsquo;ll even learn about a few new smart pointers.</source>
          <target state="translated">A continuaci&amp;oacute;n, hablaremos de concurrencia en Rust. Incluso aprender&amp;aacute; sobre algunos nuevos consejos inteligentes.</target>
        </trans-unit>
        <trans-unit id="03a59d930c382bd744dde7a012f05351047ee5cc" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll talk about functions and closures!</source>
          <target state="translated">A continuaci&amp;oacute;n, &amp;iexcl;hablaremos de funciones y cierres!</target>
        </trans-unit>
        <trans-unit id="1fde554107211f23cac1a0bbf25be3203f7855d9" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll talk about idiomatic ways to model problems and structure solutions as your Rust programs get bigger. In addition, we&amp;rsquo;ll discuss how Rust&amp;rsquo;s idioms relate to those you might be familiar with from object-oriented programming.</source>
          <target state="translated">A continuaci&amp;oacute;n, hablaremos sobre formas idiom&amp;aacute;ticas de modelar problemas y estructurar soluciones a medida que sus programas de Rust se hacen m&amp;aacute;s grandes. Adem&amp;aacute;s, discutiremos c&amp;oacute;mo los modismos de Rust se relacionan con aquellos con los que podr&amp;iacute;a estar familiarizado en la programaci&amp;oacute;n orientada a objetos.</target>
        </trans-unit>
        <trans-unit id="12c381a078ea586c1a6dde5139c1770828ccdb51" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll use our struct definition and create one &lt;code&gt;Node&lt;/code&gt; instance named &lt;code&gt;leaf&lt;/code&gt; with the value 3 and no children, and another instance named &lt;code&gt;branch&lt;/code&gt; with the value 5 and &lt;code&gt;leaf&lt;/code&gt; as one of its children, as shown in Listing 15-27:</source>
          <target state="translated">A continuaci&amp;oacute;n, usaremos nuestra definici&amp;oacute;n de estructura y crearemos una instancia de &lt;code&gt;Node&lt;/code&gt; llamada &lt;code&gt;leaf&lt;/code&gt; con el valor 3 y sin hijos, y otra instancia llamada &lt;code&gt;branch&lt;/code&gt; con el valor 5 y &lt;code&gt;leaf&lt;/code&gt; como uno de sus hijos, como se muestra en el Listado 15-27:</target>
        </trans-unit>
        <trans-unit id="49cce52cf3729ef44c726e5a417fc215b857117b" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll use these same steps with generics to reduce code duplication in different ways. In the same way that the function body can operate on an abstract &lt;code&gt;list&lt;/code&gt; instead of specific values, generics allow code to operate on abstract types.</source>
          <target state="translated">A continuaci&amp;oacute;n, usaremos estos mismos pasos con gen&amp;eacute;ricos para reducir la duplicaci&amp;oacute;n de c&amp;oacute;digo de diferentes maneras. De la misma manera que el cuerpo de la funci&amp;oacute;n puede operar en una &lt;code&gt;list&lt;/code&gt; a abstracta en lugar de valores espec&amp;iacute;ficos, los gen&amp;eacute;ricos permiten que el c&amp;oacute;digo opere en tipos abstractos.</target>
        </trans-unit>
        <trans-unit id="05f6878762b08e453ff7c9c981e816c32f84aa8d" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;re adding two lines in the middle. The &lt;code&gt;rand::thread_rng&lt;/code&gt; function will give us the particular random number generator that we&amp;rsquo;re going to use: one that is local to the current thread of execution and seeded by the operating system. Then we call the &lt;code&gt;gen_range&lt;/code&gt; method on the random number generator. This method is defined by the &lt;code&gt;Rng&lt;/code&gt; trait that we brought into scope with the &lt;code&gt;use rand::Rng&lt;/code&gt; statement. The &lt;code&gt;gen_range&lt;/code&gt; method takes two numbers as arguments and generates a random number between them. It&amp;rsquo;s inclusive on the lower bound but exclusive on the upper bound, so we need to specify &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;101&lt;/code&gt; to request a number between 1 and 100.</source>
          <target state="translated">A continuaci&amp;oacute;n, agregamos dos l&amp;iacute;neas en el medio. La funci&amp;oacute;n &lt;code&gt;rand::thread_rng&lt;/code&gt; nos dar&amp;aacute; el generador de n&amp;uacute;meros aleatorios particular que vamos a usar: uno que sea local al hilo de ejecuci&amp;oacute;n actual y sembrado por el sistema operativo. Luego llamamos al m&amp;eacute;todo &lt;code&gt;gen_range&lt;/code&gt; en el generador de n&amp;uacute;meros aleatorios. Este m&amp;eacute;todo est&amp;aacute; definido por el rasgo &lt;code&gt;Rng&lt;/code&gt; que trajimos al alcance con la declaraci&amp;oacute;n &lt;code&gt;use rand::Rng&lt;/code&gt; . El m&amp;eacute;todo &lt;code&gt;gen_range&lt;/code&gt; toma dos n&amp;uacute;meros como argumentos y genera un n&amp;uacute;mero aleatorio entre ellos. Es inclusivo en el l&amp;iacute;mite inferior pero exclusivo en el l&amp;iacute;mite superior, por lo que debemos especificar &lt;code&gt;1&lt;/code&gt; y &lt;code&gt;101&lt;/code&gt; para solicitar un n&amp;uacute;mero entre 1 y 100.</target>
        </trans-unit>
        <trans-unit id="188a1831aead9f2050d9903c88b40256b8d0ba24" translate="yes" xml:space="preserve">
          <source>Nice! Even though spaces were added before the guess, the program still figured out that the user guessed 76. Run the program a few times to verify the different behavior with different kinds of input: guess the number correctly, guess a number that is too high, and guess a number that is too low.</source>
          <target state="translated">¡Bien! Aunque se añadieron espacios antes de la suposición,el programa aún descubrió que el usuario adivinó 76.Ejecute el programa varias veces para verificar el comportamiento diferente con diferentes tipos de entrada:adivine el número correctamente,adivine un número demasiado alto y adivine un número demasiado bajo.</target>
        </trans-unit>
        <trans-unit id="41d756e582a9b7133fefe3aba97d94609533d175" translate="yes" xml:space="preserve">
          <source>Nice! It&amp;rsquo;s not the prettiest output, but it shows the values of all the fields for this instance, which would definitely help during debugging. When we have larger structs, it&amp;rsquo;s useful to have output that&amp;rsquo;s a bit easier to read; in those cases, we can use &lt;code&gt;{:#?}&lt;/code&gt; instead of &lt;code&gt;{:?}&lt;/code&gt; in the &lt;code&gt;println!&lt;/code&gt; string. When we use the &lt;code&gt;{:#?}&lt;/code&gt; style in the example, the output will look like this:</source>
          <target state="translated">&amp;iexcl;Agradable! No es la salida m&amp;aacute;s bonita, pero muestra los valores de todos los campos para esta instancia, lo que definitivamente ayudar&amp;iacute;a durante la depuraci&amp;oacute;n. Cuando tenemos estructuras m&amp;aacute;s grandes, es &amp;uacute;til tener una salida que sea un poco m&amp;aacute;s f&amp;aacute;cil de leer; en esos casos, podemos usar &lt;code&gt;{:#?}&lt;/code&gt; en lugar de &lt;code&gt;{:?}&lt;/code&gt; en &lt;code&gt;println!&lt;/code&gt; cuerda. Cuando usamos el &lt;code&gt;{:#?}&lt;/code&gt; En el ejemplo, la salida se ver&amp;aacute; as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="c9e429b1798d0142b8b31e82c1f9da5d8e0c9420" translate="yes" xml:space="preserve">
          <source>Nightly</source>
          <target state="translated">Nightly</target>
        </trans-unit>
        <trans-unit id="0e61ca1796e0a674ec697f05ff94882071738de7" translate="yes" xml:space="preserve">
          <source>No &lt;a href=&quot;../glossary#uncovered-type&quot;&gt;uncovered type&lt;/a&gt; parameters &lt;code&gt;P1..=Pn&lt;/code&gt; may appear in &lt;code&gt;T0..Ti&lt;/code&gt; (excluding &lt;code&gt;Ti&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dabebe1f19f9827a4f8cf661fd813509cd607c6" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;main&lt;/code&gt; function was found in a binary crate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3334d46bace193a18342fe23d9ec73cf45eeee44" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;main&lt;/code&gt; function was found in a binary crate. To fix this error, add a &lt;code&gt;main&lt;/code&gt; function. For example:</source>
          <target state="translated">No se encontr&amp;oacute; ninguna funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; en una caja binaria. Para solucionar este error, agregue un &lt;code&gt;main&lt;/code&gt; funci&amp;oacute;n . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="40e9183fb0e170dc10c265ea9f5ac313b7e7824e" translate="yes" xml:space="preserve">
          <source>No arguments to the program</source>
          <target state="translated">No hay argumentos para el programa</target>
        </trans-unit>
        <trans-unit id="86e59c19b9b6a6d88fc2db18875d3bedb5eeda2c" translate="yes" xml:space="preserve">
          <source>No code is generated for this intrinsic, but the optimizer will try to preserve it (and its condition) between passes, which may interfere with optimization of surrounding code and reduce performance. It should not be used if the invariant can be discovered by the optimizer on its own, or if it does not enable any significant optimizations.</source>
          <target state="translated">No se genera ningún código para este intrínseco,pero el optimizador tratará de preservarlo (y su condición)entre pasadas,lo que puede interferir con la optimización del código circundante y reducir el rendimiento.No debe utilizarse si la invariante puede ser descubierta por el optimizador por sí sola,o si no permite ninguna optimización significativa.</target>
        </trans-unit>
        <trans-unit id="6d24aa51295019d1b05b76a7e56a3b4b701ef15c" translate="yes" xml:space="preserve">
          <source>No data is allocated on the heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b940936fa4a1fc768ca623a652084963506c1c89" translate="yes" xml:space="preserve">
          <source>No file is allowed to exist at the target location, also no (dangling) symlink. In this way, if the call succeeds, the file returned is guaranteed to be new.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd44839870a9b58128d358fce877ecbaa11fd40a" translate="yes" xml:space="preserve">
          <source>No formal timeline for turning the warnings into errors has been set. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/58781&quot;&gt;GitHub issue 58781&lt;/a&gt; for more information.</source>
          <target state="translated">No se ha establecido un cronograma formal para convertir las advertencias en errores. Consulte el &lt;a href=&quot;https://github.com/rust-lang/rust/issues/58781&quot;&gt;n&amp;uacute;mero 58781 de GitHub.&lt;/a&gt; de para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f506aac03a59ef1406f6d0689bfcd0dc4c05822a" translate="yes" xml:space="preserve">
          <source>No guarantees are provided about the contents of &lt;code&gt;buf&lt;/code&gt; when this function is called, implementations cannot rely on any property of the contents of &lt;code&gt;buf&lt;/code&gt; being true. It is recommended that &lt;em&gt;implementations&lt;/em&gt; only write data to &lt;code&gt;buf&lt;/code&gt; instead of reading its contents.</source>
          <target state="translated">No se proporcionan garant&amp;iacute;as sobre el contenido de &lt;code&gt;buf&lt;/code&gt; cuando se llama a esta funci&amp;oacute;n, las implementaciones no pueden depender de que ninguna propiedad del contenido de &lt;code&gt;buf&lt;/code&gt; sea ​​verdadera. Se recomienda que las &lt;em&gt;implementaciones&lt;/em&gt; solo escriban datos en &lt;code&gt;buf&lt;/code&gt; en lugar de leer su contenido.</target>
        </trans-unit>
        <trans-unit id="4f0a95bf47b8945eb4629fd1207fec71669b8c5c" translate="yes" xml:space="preserve">
          <source>No guarantees are provided about the contents of &lt;code&gt;buf&lt;/code&gt; when this function is called, implementations cannot rely on any property of the contents of &lt;code&gt;buf&lt;/code&gt; being true. It is recommended that implementations only write data to &lt;code&gt;buf&lt;/code&gt; instead of reading its contents.</source>
          <target state="translated">No se proporcionan garant&amp;iacute;as sobre el contenido de &lt;code&gt;buf&lt;/code&gt; cuando se llama a esta funci&amp;oacute;n, las implementaciones no pueden depender de que ninguna propiedad del contenido de &lt;code&gt;buf&lt;/code&gt; sea ​​verdadera. Se recomienda que las implementaciones solo escriban datos en &lt;code&gt;buf&lt;/code&gt; en lugar de leer su contenido.</target>
        </trans-unit>
        <trans-unit id="44c3fb55dfa5ac1ea3e6cc8751e2f98b499318f5" translate="yes" xml:space="preserve">
          <source>No guarantees are provided about the contents of &lt;code&gt;buf&lt;/code&gt; when this function is called, implementations cannot rely on any property of the contents of &lt;code&gt;buf&lt;/code&gt; being true. It is recommended that implementations only write data to &lt;code&gt;buf&lt;/code&gt; instead of reading its contents. The documentation on &lt;a href=&quot;trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; has a more detailed explanation on this subject.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce0692c18a626152270d81a21a828cf37a6f5e5b" translate="yes" xml:space="preserve">
          <source>No matter whether or not you think Rust is an object-oriented language after reading this chapter, you now know that you can use trait objects to get some object-oriented features in Rust. Dynamic dispatch can give your code some flexibility in exchange for a bit of runtime performance. You can use this flexibility to implement object-oriented patterns that can help your code&amp;rsquo;s maintainability. Rust also has other features, like ownership, that object-oriented languages don&amp;rsquo;t have. An object-oriented pattern won&amp;rsquo;t always be the best way to take advantage of Rust&amp;rsquo;s strengths, but is an available option.</source>
          <target state="translated">No importa si piensa o no que Rust es un lenguaje orientado a objetos despu&amp;eacute;s de leer este cap&amp;iacute;tulo, ahora sabe que puede usar objetos de caracter&amp;iacute;sticas para obtener algunas caracter&amp;iacute;sticas orientadas a objetos en Rust. El env&amp;iacute;o din&amp;aacute;mico puede darle a su c&amp;oacute;digo cierta flexibilidad a cambio de un poco de rendimiento en tiempo de ejecuci&amp;oacute;n. Puede usar esta flexibilidad para implementar patrones orientados a objetos que pueden ayudar a mantener su c&amp;oacute;digo. Rust tambi&amp;eacute;n tiene otras caracter&amp;iacute;sticas, como la propiedad, que los lenguajes orientados a objetos no tienen. Un patr&amp;oacute;n orientado a objetos no siempre ser&amp;aacute; la mejor manera de aprovechar las fortalezas de Rust, pero es una opci&amp;oacute;n disponible.</target>
        </trans-unit>
        <trans-unit id="11ac1612603c0c3d5163e13082f76411af9ee697" translate="yes" xml:space="preserve">
          <source>No ordering constraints, only atomic operations.</source>
          <target state="translated">No hay restricciones de orden,sólo operaciones atómicas.</target>
        </trans-unit>
        <trans-unit id="2d3c73825e4a8031f1bb82e1a976c1ab255294e6" translate="yes" xml:space="preserve">
          <source>No truncation occurs when &lt;code&gt;len&lt;/code&gt; is greater than the vector's current length:</source>
          <target state="translated">No se produce ning&amp;uacute;n truncamiento cuando &lt;code&gt;len&lt;/code&gt; es mayor que la longitud actual del vector:</target>
        </trans-unit>
        <trans-unit id="9d9d7a3fa61acc7fab275007c75a11f20d8c99c2" translate="yes" xml:space="preserve">
          <source>No uncovered type parameters &lt;code&gt;P1..=Pm&lt;/code&gt; may appear in &lt;code&gt;T0..Ti&lt;/code&gt; (excluding &lt;code&gt;Ti&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d402441c3b972c1257d41a23a0cf7d56800bfb6" translate="yes" xml:space="preserve">
          <source>No value</source>
          <target state="translated">No tiene valor</target>
        </trans-unit>
        <trans-unit id="b8b9f1367ad6269845f5ec54d66262066092883f" translate="yes" xml:space="preserve">
          <source>No.</source>
          <target state="translated">No.</target>
        </trans-unit>
        <trans-unit id="e1e00ea722ddcc62dfc3b69613fb2a2d565490a9" translate="yes" xml:space="preserve">
          <source>Nominal types</source>
          <target state="translated">Tipos nominales</target>
        </trans-unit>
        <trans-unit id="cdb02ce94d87fb6259e95b77d6deab219ecd04ba" translate="yes" xml:space="preserve">
          <source>Nominal types &amp;mdash; &lt;a href=&quot;types/struct&quot;&gt;structs&lt;/a&gt;, &lt;a href=&quot;types/enum&quot;&gt;enumerations&lt;/a&gt; and &lt;a href=&quot;types/union&quot;&gt;unions&lt;/a&gt; &amp;mdash; may be recursive. That is, each &lt;code&gt;enum&lt;/code&gt; variant or &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;union&lt;/code&gt; field may refer, directly or indirectly, to the enclosing &lt;code&gt;enum&lt;/code&gt; or &lt;code&gt;struct&lt;/code&gt; type itself. Such recursion has restrictions:</source>
          <target state="translated">Los tipos nominales ( &lt;a href=&quot;types/struct&quot;&gt;estructuras&lt;/a&gt; , &lt;a href=&quot;types/enum&quot;&gt;enumeraciones&lt;/a&gt; y &lt;a href=&quot;types/union&quot;&gt;uniones&lt;/a&gt; ) pueden ser recursivos. Es decir, cada variante de &lt;code&gt;enum&lt;/code&gt; eraci&amp;oacute;n , &lt;code&gt;struct&lt;/code&gt; o campo de &lt;code&gt;union&lt;/code&gt; puede hacer referencia, directa o indirectamente, al tipo de &lt;code&gt;struct&lt;/code&gt; o &lt;code&gt;enum&lt;/code&gt; eraci&amp;oacute;nadjunta . Tal recursi&amp;oacute;n tiene restricciones:</target>
        </trans-unit>
        <trans-unit id="f4149c46b37e254e72be155dd7b9caf947125984" translate="yes" xml:space="preserve">
          <source>Nominal types &amp;mdash; &lt;a href=&quot;types/struct&quot;&gt;structs&lt;/a&gt;, &lt;a href=&quot;types/enum&quot;&gt;enumerations&lt;/a&gt;, and &lt;a href=&quot;types/union&quot;&gt;unions&lt;/a&gt; &amp;mdash; may be recursive. That is, each &lt;code&gt;enum&lt;/code&gt; variant or &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;union&lt;/code&gt; field may refer, directly or indirectly, to the enclosing &lt;code&gt;enum&lt;/code&gt; or &lt;code&gt;struct&lt;/code&gt; type itself. Such recursion has restrictions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2b8571666155408fb60b3d7bfe218ca438c97ed" translate="yes" xml:space="preserve">
          <source>Nominal types without a &lt;code&gt;repr&lt;/code&gt; attribute have the default representation. Informally, this representation is also called the &lt;code&gt;rust&lt;/code&gt; representation.</source>
          <target state="translated">Los tipos nominales sin un atributo &lt;code&gt;repr&lt;/code&gt; tienen la representaci&amp;oacute;n predeterminada. De manera informal, esta representaci&amp;oacute;n tambi&amp;eacute;n se denomina representaci&amp;oacute;n de &lt;code&gt;rust&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5059fea19d0d88b99facd98e04beb3723c567878" translate="yes" xml:space="preserve">
          <source>Non capturing closures to &lt;code&gt;fn&lt;/code&gt; pointers</source>
          <target state="translated">Cierres sin captura a punteros &lt;code&gt;fn&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a51a0d057519ba84abe774072805e81677bec4c4" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;mut&lt;/code&gt; static items that contain a type that is not &lt;a href=&quot;../interior-mutability&quot;&gt;interior mutable&lt;/a&gt; may be placed in read-only memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1983af4c53629f3985aabae2faea197763bce6d6" translate="yes" xml:space="preserve">
          <source>Non-UTF-8 byte sequences in a &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Secuencias de bytes que no son UTF-8 en una &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7afa6ec3e9abfb77b76d7813a424b3a22eeb6a6" translate="yes" xml:space="preserve">
          <source>Non-allocating substring search.</source>
          <target state="translated">Búsqueda de subcadenas no asignadas.</target>
        </trans-unit>
        <trans-unit id="918c67058d00d25e0f0f3d637bc930eba67e9f26" translate="yes" xml:space="preserve">
          <source>Non-ascii can be used as module names if it is inlined or if a &lt;code&gt;#[path]&lt;/code&gt; attribute is specified. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dcd44915e2ff9a86c47e1f5d9c641f6ca3a035b" translate="yes" xml:space="preserve">
          <source>Non-doc comments</source>
          <target state="translated">Comentarios no médicos</target>
        </trans-unit>
        <trans-unit id="824440476584993bab7b4958488eb74ef1df4ce3" translate="yes" xml:space="preserve">
          <source>Non-doc comments are interpreted as a form of whitespace.</source>
          <target state="translated">Los comentarios no médicos se interpretan como una forma de espacio en blanco.</target>
        </trans-unit>
        <trans-unit id="aa21851a9f906887214ca347fd6a9f54a7e9f855" translate="yes" xml:space="preserve">
          <source>Non-exhaustive enums could have additional variants added in future. Therefore, when matching against variants of non-exhaustive enums, an extra wildcard arm must be added to account for any future variants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10cecc28192fc5e84850b4a3c1cd7bbfd836407b" translate="yes" xml:space="preserve">
          <source>Non-exhaustive enums could have additional variants added in future. Therefore, when matching against variants of non-exhaustive enums, an extra wildcard arm must be added to account for any future variants.&lt;span id=&quot;variant.Empty&quot;&gt;&lt;code id=&quot;Empty.v&quot;&gt;Empty&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">Las enumeraciones no exhaustivas podr&amp;iacute;an tener variantes adicionales agregadas en el futuro. Por lo tanto, al comparar variantes de enumeraciones no exhaustivas, se debe agregar un brazo comod&amp;iacute;n adicional para tener en cuenta las variantes futuras. &lt;span id=&quot;variant.Empty&quot;&gt; &lt;code id=&quot;Empty.v&quot;&gt;Empty&lt;/code&gt; &lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="c2d926eda1237eaff90e4752c522197b25cce1b5" translate="yes" xml:space="preserve">
          <source>Non-exhaustive enums could have additional variants added in future. Therefore, when matching against variants of non-exhaustive enums, an extra wildcard arm must be added to account for any future variants.&lt;span id=&quot;variant.NotFound&quot;&gt;&lt;code id=&quot;NotFound.v&quot;&gt;NotFound&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">Las enumeraciones no exhaustivas podr&amp;iacute;an tener variantes adicionales agregadas en el futuro. Por lo tanto, al comparar variantes de enumeraciones no exhaustivas, se debe agregar un brazo comod&amp;iacute;n adicional para tener en cuenta las variantes futuras. &lt;span id=&quot;variant.NotFound&quot;&gt; &lt;code id=&quot;NotFound.v&quot;&gt;NotFound&lt;/code&gt; &lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="9ffc5a4a3c3cd6c9da0af373638cb3d4d5bda691" translate="yes" xml:space="preserve">
          <source>Non-exhaustive enums could have additional variants added in future. Therefore, when matching against variants of non-exhaustive enums, an extra wildcard arm must be added to account for any future variants.&lt;span id=&quot;variant.Relaxed&quot;&gt;&lt;code id=&quot;Relaxed.v&quot;&gt;Relaxed&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">Las enumeraciones no exhaustivas podr&amp;iacute;an tener variantes adicionales agregadas en el futuro. Por lo tanto, al comparar variantes de enumeraciones no exhaustivas, se debe agregar un brazo comod&amp;iacute;n adicional para tener en cuenta las variantes futuras. &lt;span id=&quot;variant.Relaxed&quot;&gt; &lt;code id=&quot;Relaxed.v&quot;&gt;Relaxed&lt;/code&gt; &lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="0eb9bd2ad410dc2a883c07d5cdc83ffe0afd40df" translate="yes" xml:space="preserve">
          <source>Non-exhaustive types are always considered inhabited in downstream crates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c1a6b0df00b9143148ae426e200b78dbd7fb89f" translate="yes" xml:space="preserve">
          <source>Non-exhaustive types cannot be constructed outside of the defining crate:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f438ec02f71051c0a40ce9311998d29382298836" translate="yes" xml:space="preserve">
          <source>Non-exhaustive variants (&lt;a href=&quot;../items/structs&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt; variant&lt;/a&gt;) cannot be constructed with a &lt;a href=&quot;../expressions/struct-expr&quot;&gt;&lt;em&gt;StructExpression&lt;/em&gt;&lt;/a&gt; (including with &lt;a href=&quot;../expressions/struct-expr#functional-update-syntax&quot;&gt;functional update syntax&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="677ced73d5856aaca0b6f678eabc91c14dca818b" translate="yes" xml:space="preserve">
          <source>Non-operator Symbols</source>
          <target state="translated">Símbolos de no-operador</target>
        </trans-unit>
        <trans-unit id="4e30c9c45a102a66eb26f8221fcbff4ef463e321" translate="yes" xml:space="preserve">
          <source>NonNull</source>
          <target state="translated">NonNull</target>
        </trans-unit>
        <trans-unit id="4406dddaf8fa2617ceb6cc8c44402048c8cf820a" translate="yes" xml:space="preserve">
          <source>NonNull::as_mut</source>
          <target state="translated">NonNull::as_mut</target>
        </trans-unit>
        <trans-unit id="2114c5e9abc5430a075844ac84cde8dc1be1fea6" translate="yes" xml:space="preserve">
          <source>NonNull::as_ptr</source>
          <target state="translated">NonNull::as_ptr</target>
        </trans-unit>
        <trans-unit id="1cabae6d82425bb900a0d474f79596c63d831307" translate="yes" xml:space="preserve">
          <source>NonNull::as_ref</source>
          <target state="translated">NonNull::as_ref</target>
        </trans-unit>
        <trans-unit id="6ed17b6bc3c37842c56b35d303eedea6a7299966" translate="yes" xml:space="preserve">
          <source>NonNull::borrow</source>
          <target state="translated">NonNull::borrow</target>
        </trans-unit>
        <trans-unit id="7e334211ca12677d4c793a4a4f5aff0a42317022" translate="yes" xml:space="preserve">
          <source>NonNull::borrow_mut</source>
          <target state="translated">NonNull::borrow_mut</target>
        </trans-unit>
        <trans-unit id="d14ea41704eb3153152593ae4083750dca37c043" translate="yes" xml:space="preserve">
          <source>NonNull::cast</source>
          <target state="translated">NonNull::cast</target>
        </trans-unit>
        <trans-unit id="898faa9b1446e51151d3471366dee5a575326bb3" translate="yes" xml:space="preserve">
          <source>NonNull::clamp</source>
          <target state="translated">NonNull::clamp</target>
        </trans-unit>
        <trans-unit id="bf5ade412290b7a0e9f887083d2f7add59f5a5fc" translate="yes" xml:space="preserve">
          <source>NonNull::clone</source>
          <target state="translated">NonNull::clone</target>
        </trans-unit>
        <trans-unit id="d26e757d1bc68cfc66ec9cac7468feab54ad3bf1" translate="yes" xml:space="preserve">
          <source>NonNull::clone_from</source>
          <target state="translated">NonNull::clone_from</target>
        </trans-unit>
        <trans-unit id="ec88376a17645ec47ad005ff58328f13df7dd535" translate="yes" xml:space="preserve">
          <source>NonNull::clone_into</source>
          <target state="translated">NonNull::clone_into</target>
        </trans-unit>
        <trans-unit id="fd33327c1c03c18157e310949eb3ee49adc1b771" translate="yes" xml:space="preserve">
          <source>NonNull::cmp</source>
          <target state="translated">NonNull::cmp</target>
        </trans-unit>
        <trans-unit id="987e425f6d75ea2d5d6595ecf927bb4ee065890c" translate="yes" xml:space="preserve">
          <source>NonNull::dangling</source>
          <target state="translated">NonNull::dangling</target>
        </trans-unit>
        <trans-unit id="c22e4114ed2e98fa57926d0f979b5e4f67cb57d4" translate="yes" xml:space="preserve">
          <source>NonNull::eq</source>
          <target state="translated">NonNull::eq</target>
        </trans-unit>
        <trans-unit id="d00b2d876766572056074e351b4e54188d623d2b" translate="yes" xml:space="preserve">
          <source>NonNull::fmt</source>
          <target state="translated">NonNull::fmt</target>
        </trans-unit>
        <trans-unit id="920d1fd41b172fec04d2e45bb2bdef697e4fe777" translate="yes" xml:space="preserve">
          <source>NonNull::from</source>
          <target state="translated">NonNull::from</target>
        </trans-unit>
        <trans-unit id="e069f30f0197691ef84cfb150cfed51e68e388e1" translate="yes" xml:space="preserve">
          <source>NonNull::ge</source>
          <target state="translated">NonNull::ge</target>
        </trans-unit>
        <trans-unit id="c04dde85527ee18200a552eae552b457a7f99bd6" translate="yes" xml:space="preserve">
          <source>NonNull::gt</source>
          <target state="translated">NonNull::gt</target>
        </trans-unit>
        <trans-unit id="1962f7d627fcf30051ef24ad505c0bc5f914d525" translate="yes" xml:space="preserve">
          <source>NonNull::hash</source>
          <target state="translated">NonNull::hash</target>
        </trans-unit>
        <trans-unit id="947f5524bfbda623a81d3a1c8013f457968a7a86" translate="yes" xml:space="preserve">
          <source>NonNull::hash_slice</source>
          <target state="translated">NonNull::hash_slice</target>
        </trans-unit>
        <trans-unit id="389c43bbeacefc5b6764890179f4b9b2032438f2" translate="yes" xml:space="preserve">
          <source>NonNull::into</source>
          <target state="translated">NonNull::into</target>
        </trans-unit>
        <trans-unit id="47e7802874702c46a2e861846c1495c139c4c850" translate="yes" xml:space="preserve">
          <source>NonNull::le</source>
          <target state="translated">NonNull::le</target>
        </trans-unit>
        <trans-unit id="9345c04e2a031789eec4e0c10625a029c4ae6f61" translate="yes" xml:space="preserve">
          <source>NonNull::lt</source>
          <target state="translated">NonNull::lt</target>
        </trans-unit>
        <trans-unit id="7a29d42be85ea3d359fc0499cfc787631cbd8fc5" translate="yes" xml:space="preserve">
          <source>NonNull::max</source>
          <target state="translated">NonNull::max</target>
        </trans-unit>
        <trans-unit id="61df043b4cb69b06e977ed45aa61b72a55c0c1a7" translate="yes" xml:space="preserve">
          <source>NonNull::min</source>
          <target state="translated">NonNull::min</target>
        </trans-unit>
        <trans-unit id="abded46d5ba3ed8a510f52a6c525d34081184868" translate="yes" xml:space="preserve">
          <source>NonNull::ne</source>
          <target state="translated">NonNull::ne</target>
        </trans-unit>
        <trans-unit id="28098f7280cb4f6eb94dfb98674503d36042312c" translate="yes" xml:space="preserve">
          <source>NonNull::new</source>
          <target state="translated">NonNull::new</target>
        </trans-unit>
        <trans-unit id="faebd85a1d1a684a9974b3cced67816fb864d3e2" translate="yes" xml:space="preserve">
          <source>NonNull::new_unchecked</source>
          <target state="translated">NonNull::new_unchecked</target>
        </trans-unit>
        <trans-unit id="daad03caa96878a899bd74268cdf22f8762238fc" translate="yes" xml:space="preserve">
          <source>NonNull::partial_cmp</source>
          <target state="translated">NonNull::partial_cmp</target>
        </trans-unit>
        <trans-unit id="4a54ca911ffa7ae9c156cb290778a55bb5102986" translate="yes" xml:space="preserve">
          <source>NonNull::to_owned</source>
          <target state="translated">NonNull::to_owned</target>
        </trans-unit>
        <trans-unit id="9c8c974cd30a86ae9347bdcc34e89477c2ec64af" translate="yes" xml:space="preserve">
          <source>NonNull::try_from</source>
          <target state="translated">NonNull::try_from</target>
        </trans-unit>
        <trans-unit id="cbe36570c4b5d03cc4de672aa3768cec6ff79fc7" translate="yes" xml:space="preserve">
          <source>NonNull::try_into</source>
          <target state="translated">NonNull::try_into</target>
        </trans-unit>
        <trans-unit id="5c4656d738141e414301ef5f2fc675edf57dbe67" translate="yes" xml:space="preserve">
          <source>NonNull::type_id</source>
          <target state="translated">NonNull::type_id</target>
        </trans-unit>
        <trans-unit id="3551d2c727366d003ebd8c642167f4ef9debfb26" translate="yes" xml:space="preserve">
          <source>NonZeroI128</source>
          <target state="translated">NonZeroI128</target>
        </trans-unit>
        <trans-unit id="f7717a5e03944c9f7da8d5810a2b468333e1dd38" translate="yes" xml:space="preserve">
          <source>NonZeroI128::borrow</source>
          <target state="translated">NonZeroI128::borrow</target>
        </trans-unit>
        <trans-unit id="f964efe706788bf3868121236c120eec56d477d3" translate="yes" xml:space="preserve">
          <source>NonZeroI128::borrow_mut</source>
          <target state="translated">NonZeroI128::borrow_mut</target>
        </trans-unit>
        <trans-unit id="5ff8443b26f494de74b190931a04e5ad0a0f8bce" translate="yes" xml:space="preserve">
          <source>NonZeroI128::clamp</source>
          <target state="translated">NonZeroI128::clamp</target>
        </trans-unit>
        <trans-unit id="b41821f2bbc6d793e496bf8cf8e0961c8c6cf20e" translate="yes" xml:space="preserve">
          <source>NonZeroI128::clone</source>
          <target state="translated">NonZeroI128::clone</target>
        </trans-unit>
        <trans-unit id="86b0e71b93cf7cfc8d3f88502fefd684a7508a83" translate="yes" xml:space="preserve">
          <source>NonZeroI128::clone_from</source>
          <target state="translated">NonZeroI128::clone_from</target>
        </trans-unit>
        <trans-unit id="e87976c36fbb769fdf82eb4fc79b3850621b2d11" translate="yes" xml:space="preserve">
          <source>NonZeroI128::clone_into</source>
          <target state="translated">NonZeroI128::clone_into</target>
        </trans-unit>
        <trans-unit id="1fbab26faccad65c9594c9912db60595257c834d" translate="yes" xml:space="preserve">
          <source>NonZeroI128::cmp</source>
          <target state="translated">NonZeroI128::cmp</target>
        </trans-unit>
        <trans-unit id="e40f0ecb53bba7364d61eeddde211916e2de23b0" translate="yes" xml:space="preserve">
          <source>NonZeroI128::eq</source>
          <target state="translated">NonZeroI128::eq</target>
        </trans-unit>
        <trans-unit id="06203fb0241e3db251fdbeb37b55ecf55bc73b90" translate="yes" xml:space="preserve">
          <source>NonZeroI128::fmt</source>
          <target state="translated">NonZeroI128::fmt</target>
        </trans-unit>
        <trans-unit id="0fc860ac20708b78eba2f88aebf4c0cae43f1b01" translate="yes" xml:space="preserve">
          <source>NonZeroI128::from</source>
          <target state="translated">NonZeroI128::from</target>
        </trans-unit>
        <trans-unit id="e9225e88cc3a187fc6e8da37813f50d8aace8352" translate="yes" xml:space="preserve">
          <source>NonZeroI128::from_str</source>
          <target state="translated">NonZeroI128::from_str</target>
        </trans-unit>
        <trans-unit id="1060cfd82a1c5a4f9319951b3ccf33667960e338" translate="yes" xml:space="preserve">
          <source>NonZeroI128::ge</source>
          <target state="translated">NonZeroI128::ge</target>
        </trans-unit>
        <trans-unit id="1174fff40e9915f0fddc11dc5e858638caff1eb7" translate="yes" xml:space="preserve">
          <source>NonZeroI128::get</source>
          <target state="translated">NonZeroI128::get</target>
        </trans-unit>
        <trans-unit id="6360aa3b732a77c2367a197d6649d264398a3733" translate="yes" xml:space="preserve">
          <source>NonZeroI128::gt</source>
          <target state="translated">NonZeroI128::gt</target>
        </trans-unit>
        <trans-unit id="74c9ab59cffa5d7149b9a4669f4269b74eeb9074" translate="yes" xml:space="preserve">
          <source>NonZeroI128::hash</source>
          <target state="translated">NonZeroI128::hash</target>
        </trans-unit>
        <trans-unit id="683d8b9cc521cc55c631921795be0979d992e3f0" translate="yes" xml:space="preserve">
          <source>NonZeroI128::hash_slice</source>
          <target state="translated">NonZeroI128::hash_slice</target>
        </trans-unit>
        <trans-unit id="aa52174afecb1310862de00467bdc35c65937a26" translate="yes" xml:space="preserve">
          <source>NonZeroI128::into</source>
          <target state="translated">NonZeroI128::into</target>
        </trans-unit>
        <trans-unit id="148aa4d7eea87fc4622065d40fb8f2ec58899a47" translate="yes" xml:space="preserve">
          <source>NonZeroI128::le</source>
          <target state="translated">NonZeroI128::le</target>
        </trans-unit>
        <trans-unit id="4cab526460d9eafdf6e790d31dfeefc0f6385568" translate="yes" xml:space="preserve">
          <source>NonZeroI128::lt</source>
          <target state="translated">NonZeroI128::lt</target>
        </trans-unit>
        <trans-unit id="c0e0f0d6f1984e61de46b50df3dd15bb2c3be699" translate="yes" xml:space="preserve">
          <source>NonZeroI128::max</source>
          <target state="translated">NonZeroI128::max</target>
        </trans-unit>
        <trans-unit id="afd96d69d525973449f87aee12afd0af77bb90ff" translate="yes" xml:space="preserve">
          <source>NonZeroI128::min</source>
          <target state="translated">NonZeroI128::min</target>
        </trans-unit>
        <trans-unit id="246cde0659cbc3a878d28d1aa05929c570deac33" translate="yes" xml:space="preserve">
          <source>NonZeroI128::ne</source>
          <target state="translated">NonZeroI128::ne</target>
        </trans-unit>
        <trans-unit id="8673425a72ca5491b6fece38839c045e52eb4d36" translate="yes" xml:space="preserve">
          <source>NonZeroI128::new</source>
          <target state="translated">NonZeroI128::new</target>
        </trans-unit>
        <trans-unit id="83c86c3acc20bd4fdf03572b0722c1f12370f0bb" translate="yes" xml:space="preserve">
          <source>NonZeroI128::new_unchecked</source>
          <target state="translated">NonZeroI128::new_unchecked</target>
        </trans-unit>
        <trans-unit id="7d31a0e09cd71a4a287a5059ffc925fb40c7ce05" translate="yes" xml:space="preserve">
          <source>NonZeroI128::partial_cmp</source>
          <target state="translated">NonZeroI128::partial_cmp</target>
        </trans-unit>
        <trans-unit id="608c27b25bdd1b009cc3a24d8a6782000bd55a1c" translate="yes" xml:space="preserve">
          <source>NonZeroI128::to_owned</source>
          <target state="translated">NonZeroI128::to_owned</target>
        </trans-unit>
        <trans-unit id="744cd6d60888a33636a82b0368460edf2109a4f4" translate="yes" xml:space="preserve">
          <source>NonZeroI128::to_string</source>
          <target state="translated">NonZeroI128::to_string</target>
        </trans-unit>
        <trans-unit id="ac99be0bfb14a319fad21b69b5e280921b9604e7" translate="yes" xml:space="preserve">
          <source>NonZeroI128::try_from</source>
          <target state="translated">NonZeroI128::try_from</target>
        </trans-unit>
        <trans-unit id="2abe344dbf2f82320c3d223157d57b6766d23549" translate="yes" xml:space="preserve">
          <source>NonZeroI128::try_into</source>
          <target state="translated">NonZeroI128::try_into</target>
        </trans-unit>
        <trans-unit id="10a577a305c3efc3499cc94da566386465669213" translate="yes" xml:space="preserve">
          <source>NonZeroI128::type_id</source>
          <target state="translated">NonZeroI128::type_id</target>
        </trans-unit>
        <trans-unit id="36f429958b2bd2e0923475b148a0c1f6e808e911" translate="yes" xml:space="preserve">
          <source>NonZeroI16</source>
          <target state="translated">NonZeroI16</target>
        </trans-unit>
        <trans-unit id="18b48de75cdc24dca01c5ee1c28e20115a7eb2a1" translate="yes" xml:space="preserve">
          <source>NonZeroI16::borrow</source>
          <target state="translated">NonZeroI16::borrow</target>
        </trans-unit>
        <trans-unit id="bdbca21815164e23bce622eb47091fb5f9f2176c" translate="yes" xml:space="preserve">
          <source>NonZeroI16::borrow_mut</source>
          <target state="translated">NonZeroI16::borrow_mut</target>
        </trans-unit>
        <trans-unit id="2541826a258687d3b644073478113268e63c74af" translate="yes" xml:space="preserve">
          <source>NonZeroI16::clamp</source>
          <target state="translated">NonZeroI16::clamp</target>
        </trans-unit>
        <trans-unit id="115ee98eb9f17414d1638645fa06af3167003827" translate="yes" xml:space="preserve">
          <source>NonZeroI16::clone</source>
          <target state="translated">NonZeroI16::clone</target>
        </trans-unit>
        <trans-unit id="0278b33294858e10f554d1971ffc6f87bb8f5b09" translate="yes" xml:space="preserve">
          <source>NonZeroI16::clone_from</source>
          <target state="translated">NonZeroI16::clone_from</target>
        </trans-unit>
        <trans-unit id="c7c71d2e0fcced1b160e7459dff80d6f48dcbc4f" translate="yes" xml:space="preserve">
          <source>NonZeroI16::clone_into</source>
          <target state="translated">NonZeroI16::clone_into</target>
        </trans-unit>
        <trans-unit id="850888fdd17f8d9104362438c1677057b27654a4" translate="yes" xml:space="preserve">
          <source>NonZeroI16::cmp</source>
          <target state="translated">NonZeroI16::cmp</target>
        </trans-unit>
        <trans-unit id="f05c890da588a6175c01f462a0b77681853ea3b1" translate="yes" xml:space="preserve">
          <source>NonZeroI16::eq</source>
          <target state="translated">NonZeroI16::eq</target>
        </trans-unit>
        <trans-unit id="afd24843e5add4461be3e24eb291a9cc7627956c" translate="yes" xml:space="preserve">
          <source>NonZeroI16::fmt</source>
          <target state="translated">NonZeroI16::fmt</target>
        </trans-unit>
        <trans-unit id="4858ff995b8e659abd51265d63ea466463440d7f" translate="yes" xml:space="preserve">
          <source>NonZeroI16::from</source>
          <target state="translated">NonZeroI16::from</target>
        </trans-unit>
        <trans-unit id="e029bc06979cac03c696126c7078fc97b9d215f8" translate="yes" xml:space="preserve">
          <source>NonZeroI16::from_str</source>
          <target state="translated">NonZeroI16::from_str</target>
        </trans-unit>
        <trans-unit id="bafd6163144db642a0a88ae9a0d1f67a9aa327c8" translate="yes" xml:space="preserve">
          <source>NonZeroI16::ge</source>
          <target state="translated">NonZeroI16::ge</target>
        </trans-unit>
        <trans-unit id="8aabc8e5c65d44f1317cc2c944b8544a7d7743b4" translate="yes" xml:space="preserve">
          <source>NonZeroI16::get</source>
          <target state="translated">NonZeroI16::get</target>
        </trans-unit>
        <trans-unit id="f4bd402ef0cb908aeee7f003297047e0d4730ffe" translate="yes" xml:space="preserve">
          <source>NonZeroI16::gt</source>
          <target state="translated">NonZeroI16::gt</target>
        </trans-unit>
        <trans-unit id="eea24fe60c2ee511de571b916e274e0b8b9953ea" translate="yes" xml:space="preserve">
          <source>NonZeroI16::hash</source>
          <target state="translated">NonZeroI16::hash</target>
        </trans-unit>
        <trans-unit id="2072b7c0817666ffd6461a331c7f56a7e3159241" translate="yes" xml:space="preserve">
          <source>NonZeroI16::hash_slice</source>
          <target state="translated">NonZeroI16::hash_slice</target>
        </trans-unit>
        <trans-unit id="609c336f653a5586992a687fdc21a4e12e0e5bfc" translate="yes" xml:space="preserve">
          <source>NonZeroI16::into</source>
          <target state="translated">NonZeroI16::into</target>
        </trans-unit>
        <trans-unit id="dcd26dca67e989e320ea7d8ce4a6b4b2f5a19253" translate="yes" xml:space="preserve">
          <source>NonZeroI16::le</source>
          <target state="translated">NonZeroI16::le</target>
        </trans-unit>
        <trans-unit id="764441ce7cfb74845e4e5601e7c04d15cb44d34d" translate="yes" xml:space="preserve">
          <source>NonZeroI16::lt</source>
          <target state="translated">NonZeroI16::lt</target>
        </trans-unit>
        <trans-unit id="ba011aa8171b9001b2fd20e4d332efc5ad115b12" translate="yes" xml:space="preserve">
          <source>NonZeroI16::max</source>
          <target state="translated">NonZeroI16::max</target>
        </trans-unit>
        <trans-unit id="a323327b77c7bebd588241f8e49fcd0eb80d98c1" translate="yes" xml:space="preserve">
          <source>NonZeroI16::min</source>
          <target state="translated">NonZeroI16::min</target>
        </trans-unit>
        <trans-unit id="2ea2360fbbb5c24f384364e47a1ccf667fabf208" translate="yes" xml:space="preserve">
          <source>NonZeroI16::ne</source>
          <target state="translated">NonZeroI16::ne</target>
        </trans-unit>
        <trans-unit id="8a2d9c5311b2f8e5e740b1521cf3f032afe2075a" translate="yes" xml:space="preserve">
          <source>NonZeroI16::new</source>
          <target state="translated">NonZeroI16::new</target>
        </trans-unit>
        <trans-unit id="d31ab8bc0d5d31927c609f1a69be30fb3accda97" translate="yes" xml:space="preserve">
          <source>NonZeroI16::new_unchecked</source>
          <target state="translated">NonZeroI16::new_unchecked</target>
        </trans-unit>
        <trans-unit id="9f248594130914dc8c1850b1503ca6a5baa9ab10" translate="yes" xml:space="preserve">
          <source>NonZeroI16::partial_cmp</source>
          <target state="translated">NonZeroI16::partial_cmp</target>
        </trans-unit>
        <trans-unit id="e47f6505b2ad746102f22ad01953cb709a47b9ca" translate="yes" xml:space="preserve">
          <source>NonZeroI16::to_owned</source>
          <target state="translated">NonZeroI16::to_owned</target>
        </trans-unit>
        <trans-unit id="9e491563b10305c5dc822fc5b251f24741e46929" translate="yes" xml:space="preserve">
          <source>NonZeroI16::to_string</source>
          <target state="translated">NonZeroI16::to_string</target>
        </trans-unit>
        <trans-unit id="f4ff4d972a8c42fa8c0abaffc2f1e2b76fcb4197" translate="yes" xml:space="preserve">
          <source>NonZeroI16::try_from</source>
          <target state="translated">NonZeroI16::try_from</target>
        </trans-unit>
        <trans-unit id="63b8ff5cf42ec223a0adb54868428b7e995a5c22" translate="yes" xml:space="preserve">
          <source>NonZeroI16::try_into</source>
          <target state="translated">NonZeroI16::try_into</target>
        </trans-unit>
        <trans-unit id="c06a21dec83a42f8edb2e0d6693bc0ed2ab66da7" translate="yes" xml:space="preserve">
          <source>NonZeroI16::type_id</source>
          <target state="translated">NonZeroI16::type_id</target>
        </trans-unit>
        <trans-unit id="e97bcb5feaee0189523545e2b1d1eaf6c4e683e0" translate="yes" xml:space="preserve">
          <source>NonZeroI32</source>
          <target state="translated">NonZeroI32</target>
        </trans-unit>
        <trans-unit id="54c92b19f0c002e52d95b9a54c687cabaec7d0c3" translate="yes" xml:space="preserve">
          <source>NonZeroI32::borrow</source>
          <target state="translated">NonZeroI32::borrow</target>
        </trans-unit>
        <trans-unit id="6269e913feb8c230d29ea7ab62da579bdbf5a4eb" translate="yes" xml:space="preserve">
          <source>NonZeroI32::borrow_mut</source>
          <target state="translated">NonZeroI32::borrow_mut</target>
        </trans-unit>
        <trans-unit id="1224c3cd7e71ba3386431b31298d37d70f8c5b82" translate="yes" xml:space="preserve">
          <source>NonZeroI32::clamp</source>
          <target state="translated">NonZeroI32::clamp</target>
        </trans-unit>
        <trans-unit id="84582bf1efcf9bffacf576b2dc9d228ded21783f" translate="yes" xml:space="preserve">
          <source>NonZeroI32::clone</source>
          <target state="translated">NonZeroI32::clone</target>
        </trans-unit>
        <trans-unit id="6d253c4ffdb7629f523cd7bb9f9e369a62759084" translate="yes" xml:space="preserve">
          <source>NonZeroI32::clone_from</source>
          <target state="translated">NonZeroI32::clone_from</target>
        </trans-unit>
        <trans-unit id="1193f158b2ad7d7a268d3f866cb7f7b1315214d1" translate="yes" xml:space="preserve">
          <source>NonZeroI32::clone_into</source>
          <target state="translated">NonZeroI32::clone_into</target>
        </trans-unit>
        <trans-unit id="4b603b1e9d2c2afaaf494daaf899ac95dbaaf60d" translate="yes" xml:space="preserve">
          <source>NonZeroI32::cmp</source>
          <target state="translated">NonZeroI32::cmp</target>
        </trans-unit>
        <trans-unit id="36ea7e2e5a4bb27588581579d297e2d75bde8c04" translate="yes" xml:space="preserve">
          <source>NonZeroI32::eq</source>
          <target state="translated">NonZeroI32::eq</target>
        </trans-unit>
        <trans-unit id="1edda6e591f89ce442f2cb26f60edda071d57e45" translate="yes" xml:space="preserve">
          <source>NonZeroI32::fmt</source>
          <target state="translated">NonZeroI32::fmt</target>
        </trans-unit>
        <trans-unit id="ddd4914f74fdfcbf44e61dac8ed824dc7daf8835" translate="yes" xml:space="preserve">
          <source>NonZeroI32::from</source>
          <target state="translated">NonZeroI32::from</target>
        </trans-unit>
        <trans-unit id="40c6ed7e5bb0241e56fda5056b11bd5c06468ef7" translate="yes" xml:space="preserve">
          <source>NonZeroI32::from_str</source>
          <target state="translated">NonZeroI32::from_str</target>
        </trans-unit>
        <trans-unit id="ade03fa8f0e3d00c9d57318b69563c321a5de2eb" translate="yes" xml:space="preserve">
          <source>NonZeroI32::ge</source>
          <target state="translated">NonZeroI32::ge</target>
        </trans-unit>
        <trans-unit id="1d06e8a039855892a9b222f01348adf7e49edc4d" translate="yes" xml:space="preserve">
          <source>NonZeroI32::get</source>
          <target state="translated">NonZeroI32::get</target>
        </trans-unit>
        <trans-unit id="fa60ed7434a0539f3d9490e5fd97303495e8e4c6" translate="yes" xml:space="preserve">
          <source>NonZeroI32::gt</source>
          <target state="translated">NonZeroI32::gt</target>
        </trans-unit>
        <trans-unit id="f8325277d4aaaad37e3f8e3f7eea57d33a82b14d" translate="yes" xml:space="preserve">
          <source>NonZeroI32::hash</source>
          <target state="translated">NonZeroI32::hash</target>
        </trans-unit>
        <trans-unit id="15d30eee444980fbb702c19bb0e763a3a3edcf54" translate="yes" xml:space="preserve">
          <source>NonZeroI32::hash_slice</source>
          <target state="translated">NonZeroI32::hash_slice</target>
        </trans-unit>
        <trans-unit id="803e758732aa4ff1933498c8c223c849e07ecb60" translate="yes" xml:space="preserve">
          <source>NonZeroI32::into</source>
          <target state="translated">NonZeroI32::into</target>
        </trans-unit>
        <trans-unit id="790804224c71a8a913941fd99262449cfc4eae1f" translate="yes" xml:space="preserve">
          <source>NonZeroI32::le</source>
          <target state="translated">NonZeroI32::le</target>
        </trans-unit>
        <trans-unit id="67201699a9447f0b39d54ba4f84c3b95336721f4" translate="yes" xml:space="preserve">
          <source>NonZeroI32::lt</source>
          <target state="translated">NonZeroI32::lt</target>
        </trans-unit>
        <trans-unit id="ed55b8cb9ce6596e0102020b3149699afc739afa" translate="yes" xml:space="preserve">
          <source>NonZeroI32::max</source>
          <target state="translated">NonZeroI32::max</target>
        </trans-unit>
        <trans-unit id="ea9de8a6d3342c8565ee626a42eaee51ddecb252" translate="yes" xml:space="preserve">
          <source>NonZeroI32::min</source>
          <target state="translated">NonZeroI32::min</target>
        </trans-unit>
        <trans-unit id="b4954c9a76b0d358e8ac80094df9a4364fff4cb7" translate="yes" xml:space="preserve">
          <source>NonZeroI32::ne</source>
          <target state="translated">NonZeroI32::ne</target>
        </trans-unit>
        <trans-unit id="6049048c2192264cafbbf66dce8946d4e59179cf" translate="yes" xml:space="preserve">
          <source>NonZeroI32::new</source>
          <target state="translated">NonZeroI32::new</target>
        </trans-unit>
        <trans-unit id="fffc2d80845e3795deaddee315cce1ed09540038" translate="yes" xml:space="preserve">
          <source>NonZeroI32::new_unchecked</source>
          <target state="translated">NonZeroI32::new_unchecked</target>
        </trans-unit>
        <trans-unit id="da01db7b3738e2a15dd55235e9cf2517c43505ad" translate="yes" xml:space="preserve">
          <source>NonZeroI32::partial_cmp</source>
          <target state="translated">NonZeroI32::partial_cmp</target>
        </trans-unit>
        <trans-unit id="86e152a0c12749dda033dd64bbf2468b20925901" translate="yes" xml:space="preserve">
          <source>NonZeroI32::to_owned</source>
          <target state="translated">NonZeroI32::to_owned</target>
        </trans-unit>
        <trans-unit id="c8e2c1746dcaaf891c7f0924e2a7d50565492f1c" translate="yes" xml:space="preserve">
          <source>NonZeroI32::to_string</source>
          <target state="translated">NonZeroI32::to_string</target>
        </trans-unit>
        <trans-unit id="55a921f848a7b22a94032abe096e9e693c57d8c2" translate="yes" xml:space="preserve">
          <source>NonZeroI32::try_from</source>
          <target state="translated">NonZeroI32::try_from</target>
        </trans-unit>
        <trans-unit id="153dc660977b7dbd63100838a1c1f00c97814fda" translate="yes" xml:space="preserve">
          <source>NonZeroI32::try_into</source>
          <target state="translated">NonZeroI32::try_into</target>
        </trans-unit>
        <trans-unit id="d326f8bf5b1e05bd3e854148e764814dfa31fec6" translate="yes" xml:space="preserve">
          <source>NonZeroI32::type_id</source>
          <target state="translated">NonZeroI32::type_id</target>
        </trans-unit>
        <trans-unit id="47326afc55d69221c5bab6f6fc50b489aa6e615c" translate="yes" xml:space="preserve">
          <source>NonZeroI64</source>
          <target state="translated">NonZeroI64</target>
        </trans-unit>
        <trans-unit id="dc475e1ce0d61071c86badb53c4876f712060aa4" translate="yes" xml:space="preserve">
          <source>NonZeroI64::borrow</source>
          <target state="translated">NonZeroI64::borrow</target>
        </trans-unit>
        <trans-unit id="b34344f17d4f0c2fd181fff34ce7e309683eb1f9" translate="yes" xml:space="preserve">
          <source>NonZeroI64::borrow_mut</source>
          <target state="translated">NonZeroI64::borrow_mut</target>
        </trans-unit>
        <trans-unit id="ed2423a4aa70c798c0ab5645f6d832bd412161f6" translate="yes" xml:space="preserve">
          <source>NonZeroI64::clamp</source>
          <target state="translated">NonZeroI64::clamp</target>
        </trans-unit>
        <trans-unit id="f5d711fdbab29c1437fb83b2a0f49dcbcc2c895c" translate="yes" xml:space="preserve">
          <source>NonZeroI64::clone</source>
          <target state="translated">NonZeroI64::clone</target>
        </trans-unit>
        <trans-unit id="267a861768f4cde9358a3ce3dea2c45f82d2d70c" translate="yes" xml:space="preserve">
          <source>NonZeroI64::clone_from</source>
          <target state="translated">NonZeroI64::clone_from</target>
        </trans-unit>
        <trans-unit id="5cb0bd8479d4a4e335894c67e9f47406638b985a" translate="yes" xml:space="preserve">
          <source>NonZeroI64::clone_into</source>
          <target state="translated">NonZeroI64::clone_into</target>
        </trans-unit>
        <trans-unit id="62c821c3e10a9bc5dda6564e62e097e6d1aaded4" translate="yes" xml:space="preserve">
          <source>NonZeroI64::cmp</source>
          <target state="translated">NonZeroI64::cmp</target>
        </trans-unit>
        <trans-unit id="69e086a251f574f1bcd8ddeee49f798091de65ae" translate="yes" xml:space="preserve">
          <source>NonZeroI64::eq</source>
          <target state="translated">NonZeroI64::eq</target>
        </trans-unit>
        <trans-unit id="4628e95346886a1385b96213a08e94cab6a3e3ec" translate="yes" xml:space="preserve">
          <source>NonZeroI64::fmt</source>
          <target state="translated">NonZeroI64::fmt</target>
        </trans-unit>
        <trans-unit id="fa74211c65ed03702df0d7fec92011a00e46da4e" translate="yes" xml:space="preserve">
          <source>NonZeroI64::from</source>
          <target state="translated">NonZeroI64::from</target>
        </trans-unit>
        <trans-unit id="374c31c818806d2d53cf7d6521ef765de951d640" translate="yes" xml:space="preserve">
          <source>NonZeroI64::from_str</source>
          <target state="translated">NonZeroI64::from_str</target>
        </trans-unit>
        <trans-unit id="716f09379283859a96964aa90f9488fffda7f930" translate="yes" xml:space="preserve">
          <source>NonZeroI64::ge</source>
          <target state="translated">NonZeroI64::ge</target>
        </trans-unit>
        <trans-unit id="2826557154d33d398abcd879206752804a2bdf65" translate="yes" xml:space="preserve">
          <source>NonZeroI64::get</source>
          <target state="translated">NonZeroI64::get</target>
        </trans-unit>
        <trans-unit id="c03423dc02e1ef948358b0f5f0ef5c13016b5d96" translate="yes" xml:space="preserve">
          <source>NonZeroI64::gt</source>
          <target state="translated">NonZeroI64::gt</target>
        </trans-unit>
        <trans-unit id="7c084405e2fa1d7847475c21cc64bd06540a721b" translate="yes" xml:space="preserve">
          <source>NonZeroI64::hash</source>
          <target state="translated">NonZeroI64::hash</target>
        </trans-unit>
        <trans-unit id="bb8f897598ee6dc20d33aa36af3c10e2b97e157a" translate="yes" xml:space="preserve">
          <source>NonZeroI64::hash_slice</source>
          <target state="translated">NonZeroI64::hash_slice</target>
        </trans-unit>
        <trans-unit id="ef8da458756764d04abbf9c4bf5a7d43687e9799" translate="yes" xml:space="preserve">
          <source>NonZeroI64::into</source>
          <target state="translated">NonZeroI64::into</target>
        </trans-unit>
        <trans-unit id="361205d1a32febcfc1190394e636de20cf9980ff" translate="yes" xml:space="preserve">
          <source>NonZeroI64::le</source>
          <target state="translated">NonZeroI64::le</target>
        </trans-unit>
        <trans-unit id="bfa76864905ebec51d3cd7370cb21f3b8325bc2a" translate="yes" xml:space="preserve">
          <source>NonZeroI64::lt</source>
          <target state="translated">NonZeroI64::lt</target>
        </trans-unit>
        <trans-unit id="d05fd485f6f48cbcf9797f21c7f72b7da774ef73" translate="yes" xml:space="preserve">
          <source>NonZeroI64::max</source>
          <target state="translated">NonZeroI64::max</target>
        </trans-unit>
        <trans-unit id="4445fa7cd5899e3dddfe813b834bacaadd0b1f16" translate="yes" xml:space="preserve">
          <source>NonZeroI64::min</source>
          <target state="translated">NonZeroI64::min</target>
        </trans-unit>
        <trans-unit id="0e8b97484e878d06b6ee68465379752feed3cd3d" translate="yes" xml:space="preserve">
          <source>NonZeroI64::ne</source>
          <target state="translated">NonZeroI64::ne</target>
        </trans-unit>
        <trans-unit id="bde2e9f1fb06520bab485b2e3afb4e80b33dba82" translate="yes" xml:space="preserve">
          <source>NonZeroI64::new</source>
          <target state="translated">NonZeroI64::new</target>
        </trans-unit>
        <trans-unit id="f82a0245493af04b7985ed399fa466dc4edc8ced" translate="yes" xml:space="preserve">
          <source>NonZeroI64::new_unchecked</source>
          <target state="translated">NonZeroI64::new_unchecked</target>
        </trans-unit>
        <trans-unit id="ff0c4a829e7306aac0aa333126abf09bbe21f706" translate="yes" xml:space="preserve">
          <source>NonZeroI64::partial_cmp</source>
          <target state="translated">NonZeroI64::partial_cmp</target>
        </trans-unit>
        <trans-unit id="12b3dd3db76faeb57eec7254b2c1977c25f88349" translate="yes" xml:space="preserve">
          <source>NonZeroI64::to_owned</source>
          <target state="translated">NonZeroI64::to_owned</target>
        </trans-unit>
        <trans-unit id="898927cce217ffb93b1463253607e0954996b3fd" translate="yes" xml:space="preserve">
          <source>NonZeroI64::to_string</source>
          <target state="translated">NonZeroI64::to_string</target>
        </trans-unit>
        <trans-unit id="2d19979b95b66165d9cce2a874b5b50774c07fee" translate="yes" xml:space="preserve">
          <source>NonZeroI64::try_from</source>
          <target state="translated">NonZeroI64::try_from</target>
        </trans-unit>
        <trans-unit id="a50be005ecf5a07bc843f676f748462b8adca096" translate="yes" xml:space="preserve">
          <source>NonZeroI64::try_into</source>
          <target state="translated">NonZeroI64::try_into</target>
        </trans-unit>
        <trans-unit id="0134deb92dae159c2082bceaef595cfc9df55dce" translate="yes" xml:space="preserve">
          <source>NonZeroI64::type_id</source>
          <target state="translated">NonZeroI64::type_id</target>
        </trans-unit>
        <trans-unit id="de2b631972cf994d47d76eac38bd59ef1aa6e707" translate="yes" xml:space="preserve">
          <source>NonZeroI8</source>
          <target state="translated">NonZeroI8</target>
        </trans-unit>
        <trans-unit id="02a97b1be1b57111983e0f301eaade35ec979636" translate="yes" xml:space="preserve">
          <source>NonZeroI8::borrow</source>
          <target state="translated">NonZeroI8::borrow</target>
        </trans-unit>
        <trans-unit id="585184585d76b6d884767a1ba1173bf3fdcf9087" translate="yes" xml:space="preserve">
          <source>NonZeroI8::borrow_mut</source>
          <target state="translated">NonZeroI8::borrow_mut</target>
        </trans-unit>
        <trans-unit id="61d82766a6745e76c9a921124d58b68ee8622344" translate="yes" xml:space="preserve">
          <source>NonZeroI8::clamp</source>
          <target state="translated">NonZeroI8::clamp</target>
        </trans-unit>
        <trans-unit id="9639aa6f98547170260a0dbed71fe42368a45037" translate="yes" xml:space="preserve">
          <source>NonZeroI8::clone</source>
          <target state="translated">NonZeroI8::clone</target>
        </trans-unit>
        <trans-unit id="69bea805436f5d9faeecb421d3ad1efbed040ab0" translate="yes" xml:space="preserve">
          <source>NonZeroI8::clone_from</source>
          <target state="translated">NonZeroI8::clone_from</target>
        </trans-unit>
        <trans-unit id="f79563630b90126fa16369923d147a8e6ffaf90f" translate="yes" xml:space="preserve">
          <source>NonZeroI8::clone_into</source>
          <target state="translated">NonZeroI8::clone_into</target>
        </trans-unit>
        <trans-unit id="2e5b078a7705aaa646d49606a0e296d4af0f1acd" translate="yes" xml:space="preserve">
          <source>NonZeroI8::cmp</source>
          <target state="translated">NonZeroI8::cmp</target>
        </trans-unit>
        <trans-unit id="cdfffa6f6db5c090ca460987b1da2d174ad3dd70" translate="yes" xml:space="preserve">
          <source>NonZeroI8::eq</source>
          <target state="translated">NonZeroI8::eq</target>
        </trans-unit>
        <trans-unit id="303fe1ff3066af96ac1869cf4c4fcfeeee433dc7" translate="yes" xml:space="preserve">
          <source>NonZeroI8::fmt</source>
          <target state="translated">NonZeroI8::fmt</target>
        </trans-unit>
        <trans-unit id="77bf7d94ae999f9b201e336425c9ca11763912ae" translate="yes" xml:space="preserve">
          <source>NonZeroI8::from</source>
          <target state="translated">NonZeroI8::from</target>
        </trans-unit>
        <trans-unit id="058ab838a9faa626f87b01a68a1ab8af9ceffa5e" translate="yes" xml:space="preserve">
          <source>NonZeroI8::from_str</source>
          <target state="translated">NonZeroI8::from_str</target>
        </trans-unit>
        <trans-unit id="5ffec8af45e4b9e098c857beafee4bb4710502df" translate="yes" xml:space="preserve">
          <source>NonZeroI8::ge</source>
          <target state="translated">NonZeroI8::ge</target>
        </trans-unit>
        <trans-unit id="39931bb71d49054bdf1fb8e4a5d156766e03a349" translate="yes" xml:space="preserve">
          <source>NonZeroI8::get</source>
          <target state="translated">NonZeroI8::get</target>
        </trans-unit>
        <trans-unit id="47babee6888e0103956b5d6fb324645bab23db7a" translate="yes" xml:space="preserve">
          <source>NonZeroI8::gt</source>
          <target state="translated">NonZeroI8::gt</target>
        </trans-unit>
        <trans-unit id="93874d53399c77a41bf9531800d5f0fa474a4cda" translate="yes" xml:space="preserve">
          <source>NonZeroI8::hash</source>
          <target state="translated">NonZeroI8::hash</target>
        </trans-unit>
        <trans-unit id="29013108ddf40e18600983e97e9034bd5257369c" translate="yes" xml:space="preserve">
          <source>NonZeroI8::hash_slice</source>
          <target state="translated">NonZeroI8::hash_slice</target>
        </trans-unit>
        <trans-unit id="037dc348d54512f4eac4bc525c27d1f766b25a1a" translate="yes" xml:space="preserve">
          <source>NonZeroI8::into</source>
          <target state="translated">NonZeroI8::into</target>
        </trans-unit>
        <trans-unit id="0515501fa1d050e6a321477214d1c4d9c56b0a91" translate="yes" xml:space="preserve">
          <source>NonZeroI8::le</source>
          <target state="translated">NonZeroI8::le</target>
        </trans-unit>
        <trans-unit id="7cad17cf5fce8924f80e26fc0cc84eaa9e833005" translate="yes" xml:space="preserve">
          <source>NonZeroI8::lt</source>
          <target state="translated">NonZeroI8::lt</target>
        </trans-unit>
        <trans-unit id="90330e65e0da907071c3c4c3d6a116bb84c932c4" translate="yes" xml:space="preserve">
          <source>NonZeroI8::max</source>
          <target state="translated">NonZeroI8::max</target>
        </trans-unit>
        <trans-unit id="e20ad8db00b5d962f11dd424a9bc3a6c8e774305" translate="yes" xml:space="preserve">
          <source>NonZeroI8::min</source>
          <target state="translated">NonZeroI8::min</target>
        </trans-unit>
        <trans-unit id="73e8e9fd3f901d81ee2336d6e8ea9cf220fba88b" translate="yes" xml:space="preserve">
          <source>NonZeroI8::ne</source>
          <target state="translated">NonZeroI8::ne</target>
        </trans-unit>
        <trans-unit id="af45d6c29f79e266eb5d7ab85309f358f8208a69" translate="yes" xml:space="preserve">
          <source>NonZeroI8::new</source>
          <target state="translated">NonZeroI8::new</target>
        </trans-unit>
        <trans-unit id="81a02f698c1e4f2332bb4e3e7c3edf4ff27a1c50" translate="yes" xml:space="preserve">
          <source>NonZeroI8::new_unchecked</source>
          <target state="translated">NonZeroI8::new_unchecked</target>
        </trans-unit>
        <trans-unit id="2686fbb343af79a855c02e59fa60522e101b42ae" translate="yes" xml:space="preserve">
          <source>NonZeroI8::partial_cmp</source>
          <target state="translated">NonZeroI8::partial_cmp</target>
        </trans-unit>
        <trans-unit id="cd75ff5beac899fb4e419778f9513cbe1ad0b2a5" translate="yes" xml:space="preserve">
          <source>NonZeroI8::to_owned</source>
          <target state="translated">NonZeroI8::to_owned</target>
        </trans-unit>
        <trans-unit id="2b4fc6493819df1f404760f50612536b8bbfc7bd" translate="yes" xml:space="preserve">
          <source>NonZeroI8::to_string</source>
          <target state="translated">NonZeroI8::to_string</target>
        </trans-unit>
        <trans-unit id="44995331a911be947ba3e877e13ce380ef4d9378" translate="yes" xml:space="preserve">
          <source>NonZeroI8::try_from</source>
          <target state="translated">NonZeroI8::try_from</target>
        </trans-unit>
        <trans-unit id="c6edd8a860f42d4c84935088ebf51ade98d95115" translate="yes" xml:space="preserve">
          <source>NonZeroI8::try_into</source>
          <target state="translated">NonZeroI8::try_into</target>
        </trans-unit>
        <trans-unit id="694926ab4cd6b261f66a7c4ea43bd5a538ca07a5" translate="yes" xml:space="preserve">
          <source>NonZeroI8::type_id</source>
          <target state="translated">NonZeroI8::type_id</target>
        </trans-unit>
        <trans-unit id="39eb2a5ae94e10b055d94f86300fae4bd3a2c861" translate="yes" xml:space="preserve">
          <source>NonZeroIsize</source>
          <target state="translated">NonZeroIsize</target>
        </trans-unit>
        <trans-unit id="4075b4a43affee6576128660a15087ef7d46f01c" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::borrow</source>
          <target state="translated">NonZeroIsize::borrow</target>
        </trans-unit>
        <trans-unit id="ec545959e67fee5329d2293a10abf7982b0e5d27" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::borrow_mut</source>
          <target state="translated">NonZeroIsize::borrow_mut</target>
        </trans-unit>
        <trans-unit id="a61bacb1affb3b3a864b9054448b3c878abd8923" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::clamp</source>
          <target state="translated">NonZeroIsize::clamp</target>
        </trans-unit>
        <trans-unit id="191e1ee11e03e2904eddf99c3224190191357bac" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::clone</source>
          <target state="translated">NonZeroIsize::clone</target>
        </trans-unit>
        <trans-unit id="5dc48b7609417f7ce614e10e63d58e556492bcf9" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::clone_from</source>
          <target state="translated">NonZeroIsize::clone_from</target>
        </trans-unit>
        <trans-unit id="d38a3dead1294ded03ccb72c57ad049cf009cb60" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::clone_into</source>
          <target state="translated">NonZeroIsize::clone_into</target>
        </trans-unit>
        <trans-unit id="ca7ed6d7cb5393e8a7ba6e95fd43e5b4d5bb7809" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::cmp</source>
          <target state="translated">NonZeroIsize::cmp</target>
        </trans-unit>
        <trans-unit id="2fe615f032ce982861bba71b45a232958641a0cd" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::eq</source>
          <target state="translated">NonZeroIsize::eq</target>
        </trans-unit>
        <trans-unit id="d9ec29b8a341c99081d89a3bd91dc15ff5f6812f" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::fmt</source>
          <target state="translated">NonZeroIsize::fmt</target>
        </trans-unit>
        <trans-unit id="817a465d80d81fe1b61c88aca0859799182b0ced" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::from</source>
          <target state="translated">NonZeroIsize::from</target>
        </trans-unit>
        <trans-unit id="d2cfcb21d317b6fab455622f5d899c19b4caab20" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::from_str</source>
          <target state="translated">NonZeroIsize::from_str</target>
        </trans-unit>
        <trans-unit id="955b4cb4cf6dd3e94857ccb753d3fe4d1fb111bb" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::ge</source>
          <target state="translated">NonZeroIsize::ge</target>
        </trans-unit>
        <trans-unit id="94dfb4eb2acf5d4199e2494aa3141f234b7ec552" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::get</source>
          <target state="translated">NonZeroIsize::get</target>
        </trans-unit>
        <trans-unit id="ee800c8db94226df90984d0310a1c3b583e90f13" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::gt</source>
          <target state="translated">NonZeroIsize::gt</target>
        </trans-unit>
        <trans-unit id="36fffe56efef4816a331398e4562a265e92bfb10" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::hash</source>
          <target state="translated">NonZeroIsize::hash</target>
        </trans-unit>
        <trans-unit id="cf00fd8ca399a52d34e9a8feac17a1b26fe0bcee" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::hash_slice</source>
          <target state="translated">NonZeroIsize::hash_slice</target>
        </trans-unit>
        <trans-unit id="882f34faf603e4c98fc372332977f902076ab5a0" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::into</source>
          <target state="translated">NonZeroIsize::into</target>
        </trans-unit>
        <trans-unit id="0d24785358cfb27caebb3a32bf5c7678cb2e30ee" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::le</source>
          <target state="translated">NonZeroIsize::le</target>
        </trans-unit>
        <trans-unit id="f8f7c7c85f4aab3786722bfd2d7aefb8b686bd6e" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::lt</source>
          <target state="translated">NonZeroIsize::lt</target>
        </trans-unit>
        <trans-unit id="19c94dc6fa11f95d35e7c7c4f115e86acb80fc00" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::max</source>
          <target state="translated">NonZeroIsize::max</target>
        </trans-unit>
        <trans-unit id="9bf079159116a040501bb2bee238b98de390d6b7" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::min</source>
          <target state="translated">NonZeroIsize::min</target>
        </trans-unit>
        <trans-unit id="78420580500ef47e7d9c63e510686240542d08c3" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::ne</source>
          <target state="translated">NonZeroIsize::ne</target>
        </trans-unit>
        <trans-unit id="9b5caea647537e28a582a1b68216f403a92bdea7" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::new</source>
          <target state="translated">NonZeroIsize::new</target>
        </trans-unit>
        <trans-unit id="f92bdba42fa66b6909fc4ad5b38b7d0a8808cced" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::new_unchecked</source>
          <target state="translated">NonZeroIsize::new_unchecked</target>
        </trans-unit>
        <trans-unit id="2b55347d5d71b451caf945bb5b1b4cacc28afc98" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::partial_cmp</source>
          <target state="translated">NonZeroIsize::partial_cmp</target>
        </trans-unit>
        <trans-unit id="717d7fcf3dd2db66a5b657bdcd5df3b72e3ca14d" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::to_owned</source>
          <target state="translated">NonZeroIsize::to_owned</target>
        </trans-unit>
        <trans-unit id="1a88ee49d5b8865561ef951ccbe17add31975cf3" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::to_string</source>
          <target state="translated">NonZeroIsize::to_string</target>
        </trans-unit>
        <trans-unit id="aeed335ba630cd0f02972d3792f625986e0da579" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::try_from</source>
          <target state="translated">NonZeroIsize::try_from</target>
        </trans-unit>
        <trans-unit id="3b703381eaac2b4d7c2b865c4b56d5e07385cb0d" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::try_into</source>
          <target state="translated">NonZeroIsize::try_into</target>
        </trans-unit>
        <trans-unit id="cfd236d892fc65a9056aca980b3c2a0c1b08fc90" translate="yes" xml:space="preserve">
          <source>NonZeroIsize::type_id</source>
          <target state="translated">NonZeroIsize::type_id</target>
        </trans-unit>
        <trans-unit id="0044d6a252510995bf93ecb1dd199ad6280b0298" translate="yes" xml:space="preserve">
          <source>NonZeroU128</source>
          <target state="translated">NonZeroU128</target>
        </trans-unit>
        <trans-unit id="d33cdcef0f6bce3ae4d1c100820f29fb8e8de6be" translate="yes" xml:space="preserve">
          <source>NonZeroU128::borrow</source>
          <target state="translated">NonZeroU128::borrow</target>
        </trans-unit>
        <trans-unit id="3f647fdd084e34cb19c62fa95a5df0d0b02f7830" translate="yes" xml:space="preserve">
          <source>NonZeroU128::borrow_mut</source>
          <target state="translated">NonZeroU128::borrow_mut</target>
        </trans-unit>
        <trans-unit id="6dd84c262632c4ce99cd20fd6d4cce46ad766f6c" translate="yes" xml:space="preserve">
          <source>NonZeroU128::clamp</source>
          <target state="translated">NonZeroU128::clamp</target>
        </trans-unit>
        <trans-unit id="54a6620faedc0c0d7296506b17b24167c833f343" translate="yes" xml:space="preserve">
          <source>NonZeroU128::clone</source>
          <target state="translated">NonZeroU128::clone</target>
        </trans-unit>
        <trans-unit id="361f908936891415e62dbb126d73b91cdd535809" translate="yes" xml:space="preserve">
          <source>NonZeroU128::clone_from</source>
          <target state="translated">NonZeroU128::clone_from</target>
        </trans-unit>
        <trans-unit id="95b289a7b3408284866f730f49c7cefc4940ea32" translate="yes" xml:space="preserve">
          <source>NonZeroU128::clone_into</source>
          <target state="translated">NonZeroU128::clone_into</target>
        </trans-unit>
        <trans-unit id="939d6fc64a58c3aad5a29fd29b5cb1ddf18ffa03" translate="yes" xml:space="preserve">
          <source>NonZeroU128::cmp</source>
          <target state="translated">NonZeroU128::cmp</target>
        </trans-unit>
        <trans-unit id="e3d76ecf73e9d2bddfdc690dd3583c65cb4e8c6b" translate="yes" xml:space="preserve">
          <source>NonZeroU128::eq</source>
          <target state="translated">NonZeroU128::eq</target>
        </trans-unit>
        <trans-unit id="cf1f402d3b803071978d5c02ef20145ad5e75f93" translate="yes" xml:space="preserve">
          <source>NonZeroU128::fmt</source>
          <target state="translated">NonZeroU128::fmt</target>
        </trans-unit>
        <trans-unit id="1cb47e3de5cf28c31000e229db50c161ce7a7c28" translate="yes" xml:space="preserve">
          <source>NonZeroU128::from</source>
          <target state="translated">NonZeroU128::from</target>
        </trans-unit>
        <trans-unit id="04a3a610d61c54fe04e5c4fb7dc3736c9608563d" translate="yes" xml:space="preserve">
          <source>NonZeroU128::from_str</source>
          <target state="translated">NonZeroU128::from_str</target>
        </trans-unit>
        <trans-unit id="b8dacf31071a7dcf6913c1d5f60e1467a0c7b52c" translate="yes" xml:space="preserve">
          <source>NonZeroU128::ge</source>
          <target state="translated">NonZeroU128::ge</target>
        </trans-unit>
        <trans-unit id="bc070e9b4c11812f956c2c3942dbeeb60e1907d7" translate="yes" xml:space="preserve">
          <source>NonZeroU128::get</source>
          <target state="translated">NonZeroU128::get</target>
        </trans-unit>
        <trans-unit id="bf61b92a5979f684a74d24d35e7223a980f74915" translate="yes" xml:space="preserve">
          <source>NonZeroU128::gt</source>
          <target state="translated">NonZeroU128::gt</target>
        </trans-unit>
        <trans-unit id="66888226d70c2e49258374545510affc0bdd95ec" translate="yes" xml:space="preserve">
          <source>NonZeroU128::hash</source>
          <target state="translated">NonZeroU128::hash</target>
        </trans-unit>
        <trans-unit id="11f423a193c168fdc5ff7611f300ac57dfd70171" translate="yes" xml:space="preserve">
          <source>NonZeroU128::hash_slice</source>
          <target state="translated">NonZeroU128::hash_slice</target>
        </trans-unit>
        <trans-unit id="b29bc2e8eba682c97ef473e0bd889b9b87439b43" translate="yes" xml:space="preserve">
          <source>NonZeroU128::into</source>
          <target state="translated">NonZeroU128::into</target>
        </trans-unit>
        <trans-unit id="dd97daae9ce7a0b9ab85c6cf73bd03826d2dacad" translate="yes" xml:space="preserve">
          <source>NonZeroU128::le</source>
          <target state="translated">NonZeroU128::le</target>
        </trans-unit>
        <trans-unit id="4c5ffedb155e243e75eb535bd12d40831e3c5755" translate="yes" xml:space="preserve">
          <source>NonZeroU128::lt</source>
          <target state="translated">NonZeroU128::lt</target>
        </trans-unit>
        <trans-unit id="cefe09ff65521779b9f59c83b8f0425d577bc41f" translate="yes" xml:space="preserve">
          <source>NonZeroU128::max</source>
          <target state="translated">NonZeroU128::max</target>
        </trans-unit>
        <trans-unit id="66bc9dddfd54e67077a2f3098f5b87831d049d31" translate="yes" xml:space="preserve">
          <source>NonZeroU128::min</source>
          <target state="translated">NonZeroU128::min</target>
        </trans-unit>
        <trans-unit id="1af4ac1a95b7f36c718aa21d748fb13ce2e824ee" translate="yes" xml:space="preserve">
          <source>NonZeroU128::ne</source>
          <target state="translated">NonZeroU128::ne</target>
        </trans-unit>
        <trans-unit id="774e6ffc8823e6223f1ffa87fab102416ea1637d" translate="yes" xml:space="preserve">
          <source>NonZeroU128::new</source>
          <target state="translated">NonZeroU128::new</target>
        </trans-unit>
        <trans-unit id="80588590ec2ef5a265edf292dba20ca05ed9ff1d" translate="yes" xml:space="preserve">
          <source>NonZeroU128::new_unchecked</source>
          <target state="translated">NonZeroU128::new_unchecked</target>
        </trans-unit>
        <trans-unit id="4f33be7cbf8c678c8187f371f4f5d027a69d0647" translate="yes" xml:space="preserve">
          <source>NonZeroU128::partial_cmp</source>
          <target state="translated">NonZeroU128::partial_cmp</target>
        </trans-unit>
        <trans-unit id="3dea4243dcea470ba4d4f180f81f6eecca14e04e" translate="yes" xml:space="preserve">
          <source>NonZeroU128::to_owned</source>
          <target state="translated">NonZeroU128::to_owned</target>
        </trans-unit>
        <trans-unit id="24acde94eff6342ff2fba2e9d267a2fdb25acd94" translate="yes" xml:space="preserve">
          <source>NonZeroU128::to_string</source>
          <target state="translated">NonZeroU128::to_string</target>
        </trans-unit>
        <trans-unit id="b21ef37ea8ca3269318a2c852c86163df43432be" translate="yes" xml:space="preserve">
          <source>NonZeroU128::try_from</source>
          <target state="translated">NonZeroU128::try_from</target>
        </trans-unit>
        <trans-unit id="6c546400526ea1ed6ea89201862535a6549699f1" translate="yes" xml:space="preserve">
          <source>NonZeroU128::try_into</source>
          <target state="translated">NonZeroU128::try_into</target>
        </trans-unit>
        <trans-unit id="5b4b31430f7adfc4f26872a558ae35d43d7da9ff" translate="yes" xml:space="preserve">
          <source>NonZeroU128::type_id</source>
          <target state="translated">NonZeroU128::type_id</target>
        </trans-unit>
        <trans-unit id="70d9b595abe5e850f484266bc477e3d70b58c790" translate="yes" xml:space="preserve">
          <source>NonZeroU16</source>
          <target state="translated">NonZeroU16</target>
        </trans-unit>
        <trans-unit id="a2e830bdc612e459ecbf94a5d900db9adf22d552" translate="yes" xml:space="preserve">
          <source>NonZeroU16::borrow</source>
          <target state="translated">NonZeroU16::borrow</target>
        </trans-unit>
        <trans-unit id="84a81450427618c9efd99c6046bdcfcb15a8f7bb" translate="yes" xml:space="preserve">
          <source>NonZeroU16::borrow_mut</source>
          <target state="translated">NonZeroU16::borrow_mut</target>
        </trans-unit>
        <trans-unit id="4eb94e8343ecdde314f21ae1472878c2e5be4f43" translate="yes" xml:space="preserve">
          <source>NonZeroU16::clamp</source>
          <target state="translated">NonZeroU16::clamp</target>
        </trans-unit>
        <trans-unit id="4f9cad5198a59312536b10433f5195716121d4f5" translate="yes" xml:space="preserve">
          <source>NonZeroU16::clone</source>
          <target state="translated">NonZeroU16::clone</target>
        </trans-unit>
        <trans-unit id="d8ef4ec4d957a02aaa882335c6f3d0a67035a3c7" translate="yes" xml:space="preserve">
          <source>NonZeroU16::clone_from</source>
          <target state="translated">NonZeroU16::clone_from</target>
        </trans-unit>
        <trans-unit id="3808aec2130dc48a153e5a520294b26744b3e702" translate="yes" xml:space="preserve">
          <source>NonZeroU16::clone_into</source>
          <target state="translated">NonZeroU16::clone_into</target>
        </trans-unit>
        <trans-unit id="9d0062487248621e89b96fe5bf643abe821bb17a" translate="yes" xml:space="preserve">
          <source>NonZeroU16::cmp</source>
          <target state="translated">NonZeroU16::cmp</target>
        </trans-unit>
        <trans-unit id="41a2d5bd4797b2d1eb6b20161786347a9f0dd370" translate="yes" xml:space="preserve">
          <source>NonZeroU16::eq</source>
          <target state="translated">NonZeroU16::eq</target>
        </trans-unit>
        <trans-unit id="4e58083d69fb5df5404d73e024559cb858948a6f" translate="yes" xml:space="preserve">
          <source>NonZeroU16::fmt</source>
          <target state="translated">NonZeroU16::fmt</target>
        </trans-unit>
        <trans-unit id="f40fdab8202fbcb58f6fbdbc2b16303b0de2f1ee" translate="yes" xml:space="preserve">
          <source>NonZeroU16::from</source>
          <target state="translated">NonZeroU16::from</target>
        </trans-unit>
        <trans-unit id="97bb49319fe5098129502422bda785cd16c5234a" translate="yes" xml:space="preserve">
          <source>NonZeroU16::from_str</source>
          <target state="translated">NonZeroU16::from_str</target>
        </trans-unit>
        <trans-unit id="12e676e778fbbdbfffb5d2b98fabd5a4306c10e5" translate="yes" xml:space="preserve">
          <source>NonZeroU16::ge</source>
          <target state="translated">NonZeroU16::ge</target>
        </trans-unit>
        <trans-unit id="1313691aadbfef04a5d2c70132da7c9072b9834a" translate="yes" xml:space="preserve">
          <source>NonZeroU16::get</source>
          <target state="translated">NonZeroU16::get</target>
        </trans-unit>
        <trans-unit id="e4a7103dfe5dfdaccf5405172a6bfb6564cbb39e" translate="yes" xml:space="preserve">
          <source>NonZeroU16::gt</source>
          <target state="translated">NonZeroU16::gt</target>
        </trans-unit>
        <trans-unit id="4843257888dce95e20cf1eaff515263fe997bf35" translate="yes" xml:space="preserve">
          <source>NonZeroU16::hash</source>
          <target state="translated">NonZeroU16::hash</target>
        </trans-unit>
        <trans-unit id="b9c900dd5aa52134650740a33c407b05339dc782" translate="yes" xml:space="preserve">
          <source>NonZeroU16::hash_slice</source>
          <target state="translated">NonZeroU16::hash_slice</target>
        </trans-unit>
        <trans-unit id="83aabdee7d487ec9cb728178e573f802394226b4" translate="yes" xml:space="preserve">
          <source>NonZeroU16::into</source>
          <target state="translated">NonZeroU16::into</target>
        </trans-unit>
        <trans-unit id="7970d0eb118d83ab0b72df82542034727ba2a453" translate="yes" xml:space="preserve">
          <source>NonZeroU16::le</source>
          <target state="translated">NonZeroU16::le</target>
        </trans-unit>
        <trans-unit id="2e5e858925d50659f9b1b6d9aae3740085d6d25b" translate="yes" xml:space="preserve">
          <source>NonZeroU16::lt</source>
          <target state="translated">NonZeroU16::lt</target>
        </trans-unit>
        <trans-unit id="5d3b1652b96c8f150360a583d2605f47b1963560" translate="yes" xml:space="preserve">
          <source>NonZeroU16::max</source>
          <target state="translated">NonZeroU16::max</target>
        </trans-unit>
        <trans-unit id="1e4034b09df30190832a52072bcf8af6041bbf4d" translate="yes" xml:space="preserve">
          <source>NonZeroU16::min</source>
          <target state="translated">NonZeroU16::min</target>
        </trans-unit>
        <trans-unit id="815e8d53bff937d8e0463d3319f42f6179bc0760" translate="yes" xml:space="preserve">
          <source>NonZeroU16::ne</source>
          <target state="translated">NonZeroU16::ne</target>
        </trans-unit>
        <trans-unit id="23ac83515dc8fab41df4280bc33fe4bc456b4ff2" translate="yes" xml:space="preserve">
          <source>NonZeroU16::new</source>
          <target state="translated">NonZeroU16::new</target>
        </trans-unit>
        <trans-unit id="bb140336d169ad21d933a68a3d8746b26d1b8b72" translate="yes" xml:space="preserve">
          <source>NonZeroU16::new_unchecked</source>
          <target state="translated">NonZeroU16::new_unchecked</target>
        </trans-unit>
        <trans-unit id="d8dd3cac934926e6de446e12a7408c3a4890b68e" translate="yes" xml:space="preserve">
          <source>NonZeroU16::partial_cmp</source>
          <target state="translated">NonZeroU16::partial_cmp</target>
        </trans-unit>
        <trans-unit id="93b1877253643b0a75cda9a47fc455fc67b284f7" translate="yes" xml:space="preserve">
          <source>NonZeroU16::to_owned</source>
          <target state="translated">NonZeroU16::to_owned</target>
        </trans-unit>
        <trans-unit id="450d0b2017abf1787e4b40c9180053f5f1c5d6b5" translate="yes" xml:space="preserve">
          <source>NonZeroU16::to_string</source>
          <target state="translated">NonZeroU16::to_string</target>
        </trans-unit>
        <trans-unit id="565d7bfa4f368119e8eb8c597666eee168d3ec36" translate="yes" xml:space="preserve">
          <source>NonZeroU16::try_from</source>
          <target state="translated">NonZeroU16::try_from</target>
        </trans-unit>
        <trans-unit id="c9ffda0c65ec9d2c6dac8e1259fd7cb09818b7a4" translate="yes" xml:space="preserve">
          <source>NonZeroU16::try_into</source>
          <target state="translated">NonZeroU16::try_into</target>
        </trans-unit>
        <trans-unit id="35a3919e55cf0455983744e7e8ab659cda957d3b" translate="yes" xml:space="preserve">
          <source>NonZeroU16::type_id</source>
          <target state="translated">NonZeroU16::type_id</target>
        </trans-unit>
        <trans-unit id="027b94edf209f9b339fcc3f9fcbe95bea73b0fff" translate="yes" xml:space="preserve">
          <source>NonZeroU32</source>
          <target state="translated">NonZeroU32</target>
        </trans-unit>
        <trans-unit id="19103157b2dd994e271093d37a26558f253c1df5" translate="yes" xml:space="preserve">
          <source>NonZeroU32::borrow</source>
          <target state="translated">NonZeroU32::borrow</target>
        </trans-unit>
        <trans-unit id="d5900a35010072cf8f8a0e31e3295500e147138f" translate="yes" xml:space="preserve">
          <source>NonZeroU32::borrow_mut</source>
          <target state="translated">NonZeroU32::borrow_mut</target>
        </trans-unit>
        <trans-unit id="a3d0eea5bcf469a951789307713538f7dd48cc64" translate="yes" xml:space="preserve">
          <source>NonZeroU32::clamp</source>
          <target state="translated">NonZeroU32::clamp</target>
        </trans-unit>
        <trans-unit id="ca9c328d071b73e6fec77d280d2dec16c6afe8be" translate="yes" xml:space="preserve">
          <source>NonZeroU32::clone</source>
          <target state="translated">NonZeroU32::clone</target>
        </trans-unit>
        <trans-unit id="4d0cce4f0af9fe9b58667070ea3aae8608af18fc" translate="yes" xml:space="preserve">
          <source>NonZeroU32::clone_from</source>
          <target state="translated">NonZeroU32::clone_from</target>
        </trans-unit>
        <trans-unit id="beeb1f8a7db4e17dce219e3b75ed85a27a214ce6" translate="yes" xml:space="preserve">
          <source>NonZeroU32::clone_into</source>
          <target state="translated">NonZeroU32::clone_into</target>
        </trans-unit>
        <trans-unit id="66de3d60d49a5fd2460c7fce4fc4af569dea2ea8" translate="yes" xml:space="preserve">
          <source>NonZeroU32::cmp</source>
          <target state="translated">NonZeroU32::cmp</target>
        </trans-unit>
        <trans-unit id="b9a64d225fbd880a1d363e7928600204954c435d" translate="yes" xml:space="preserve">
          <source>NonZeroU32::eq</source>
          <target state="translated">NonZeroU32::eq</target>
        </trans-unit>
        <trans-unit id="d198043d6e6b2dcbdbd140d6e9a9832d41ef00b0" translate="yes" xml:space="preserve">
          <source>NonZeroU32::fmt</source>
          <target state="translated">NonZeroU32::fmt</target>
        </trans-unit>
        <trans-unit id="f99dcfdc314e32f70a453660a94f7ab9fd67185e" translate="yes" xml:space="preserve">
          <source>NonZeroU32::from</source>
          <target state="translated">NonZeroU32::from</target>
        </trans-unit>
        <trans-unit id="298799838c58c16143fcd9e2418534b329517ba2" translate="yes" xml:space="preserve">
          <source>NonZeroU32::from_str</source>
          <target state="translated">NonZeroU32::from_str</target>
        </trans-unit>
        <trans-unit id="6cd1cc0b365f1d3d480575dcbc2de54dae6a1d17" translate="yes" xml:space="preserve">
          <source>NonZeroU32::ge</source>
          <target state="translated">NonZeroU32::ge</target>
        </trans-unit>
        <trans-unit id="1dbe40ea77f784440de6e51cfcfb8778482bc067" translate="yes" xml:space="preserve">
          <source>NonZeroU32::get</source>
          <target state="translated">NonZeroU32::get</target>
        </trans-unit>
        <trans-unit id="e88628f83bc918c532752959c92d4ac82adbf0fd" translate="yes" xml:space="preserve">
          <source>NonZeroU32::gt</source>
          <target state="translated">NonZeroU32::gt</target>
        </trans-unit>
        <trans-unit id="7104f6c9a14d29e93513632fa9934f8edd1d6e95" translate="yes" xml:space="preserve">
          <source>NonZeroU32::hash</source>
          <target state="translated">NonZeroU32::hash</target>
        </trans-unit>
        <trans-unit id="ed57c71253659bc0210251e89d76fbd4f29b25de" translate="yes" xml:space="preserve">
          <source>NonZeroU32::hash_slice</source>
          <target state="translated">NonZeroU32::hash_slice</target>
        </trans-unit>
        <trans-unit id="708299fe453aae6d855b8d5980451e3d6fa01e3f" translate="yes" xml:space="preserve">
          <source>NonZeroU32::into</source>
          <target state="translated">NonZeroU32::into</target>
        </trans-unit>
        <trans-unit id="18cade9c6a5784c63e5e9e3cd947c01187616ffa" translate="yes" xml:space="preserve">
          <source>NonZeroU32::le</source>
          <target state="translated">NonZeroU32::le</target>
        </trans-unit>
        <trans-unit id="258acfab28050bc7bb168cbfd4ef30a6d48665c5" translate="yes" xml:space="preserve">
          <source>NonZeroU32::lt</source>
          <target state="translated">NonZeroU32::lt</target>
        </trans-unit>
        <trans-unit id="030aea2e6963a8f4da13cbc262733cb19ce4afc3" translate="yes" xml:space="preserve">
          <source>NonZeroU32::max</source>
          <target state="translated">NonZeroU32::max</target>
        </trans-unit>
        <trans-unit id="ec7f1e7d4f631759d2fa095faa8ca43552f8684a" translate="yes" xml:space="preserve">
          <source>NonZeroU32::min</source>
          <target state="translated">NonZeroU32::min</target>
        </trans-unit>
        <trans-unit id="1339b30fe6c5981bffbab3f00e68cdd9c9f8a0bc" translate="yes" xml:space="preserve">
          <source>NonZeroU32::ne</source>
          <target state="translated">NonZeroU32::ne</target>
        </trans-unit>
        <trans-unit id="0d42ac2122a8ce6e542130048262c73787d65cfa" translate="yes" xml:space="preserve">
          <source>NonZeroU32::new</source>
          <target state="translated">NonZeroU32::new</target>
        </trans-unit>
        <trans-unit id="53b766be632e74846603297c0e0ac6f9ccfdb9cc" translate="yes" xml:space="preserve">
          <source>NonZeroU32::new_unchecked</source>
          <target state="translated">NonZeroU32::new_unchecked</target>
        </trans-unit>
        <trans-unit id="8d058b61ea076257a2a74125c037a43db242bed9" translate="yes" xml:space="preserve">
          <source>NonZeroU32::partial_cmp</source>
          <target state="translated">NonZeroU32::partial_cmp</target>
        </trans-unit>
        <trans-unit id="daeb2592a753cbd5361feb58a583b78797b11fc9" translate="yes" xml:space="preserve">
          <source>NonZeroU32::to_owned</source>
          <target state="translated">NonZeroU32::to_owned</target>
        </trans-unit>
        <trans-unit id="60aaf34cff920dc42256dc10eec23c5ea806feec" translate="yes" xml:space="preserve">
          <source>NonZeroU32::to_string</source>
          <target state="translated">NonZeroU32::to_string</target>
        </trans-unit>
        <trans-unit id="73f9e4f2ad5073070910a47ac63d54b649f8d6e8" translate="yes" xml:space="preserve">
          <source>NonZeroU32::try_from</source>
          <target state="translated">NonZeroU32::try_from</target>
        </trans-unit>
        <trans-unit id="63d1c4723bc8f38b153bb0f2590c96abef27a5d0" translate="yes" xml:space="preserve">
          <source>NonZeroU32::try_into</source>
          <target state="translated">NonZeroU32::try_into</target>
        </trans-unit>
        <trans-unit id="97923d854095a52b24576bacbd79fc9ba83145d4" translate="yes" xml:space="preserve">
          <source>NonZeroU32::type_id</source>
          <target state="translated">NonZeroU32::type_id</target>
        </trans-unit>
        <trans-unit id="ff9af574bd71ecdb8a94e5c11d8cb03c995c903e" translate="yes" xml:space="preserve">
          <source>NonZeroU64</source>
          <target state="translated">NonZeroU64</target>
        </trans-unit>
        <trans-unit id="9174928c781d84aa02c125b176a43aa320ff0a5d" translate="yes" xml:space="preserve">
          <source>NonZeroU64::borrow</source>
          <target state="translated">NonZeroU64::borrow</target>
        </trans-unit>
        <trans-unit id="84bb893e16a6e53a0c100c76ec3f68a95e3e668d" translate="yes" xml:space="preserve">
          <source>NonZeroU64::borrow_mut</source>
          <target state="translated">NonZeroU64::borrow_mut</target>
        </trans-unit>
        <trans-unit id="fcf340d75d4265672f320969bda5046bdb409e81" translate="yes" xml:space="preserve">
          <source>NonZeroU64::clamp</source>
          <target state="translated">NonZeroU64::clamp</target>
        </trans-unit>
        <trans-unit id="183552bd8482c37ff61fe2a742c9ddb1ea0ca355" translate="yes" xml:space="preserve">
          <source>NonZeroU64::clone</source>
          <target state="translated">NonZeroU64::clone</target>
        </trans-unit>
        <trans-unit id="0eb415342585f28f35047e6cd3c2974cdbbe66bd" translate="yes" xml:space="preserve">
          <source>NonZeroU64::clone_from</source>
          <target state="translated">NonZeroU64::clone_from</target>
        </trans-unit>
        <trans-unit id="6ab29e679c166bbe4bda6532e91d9eeb91acad3c" translate="yes" xml:space="preserve">
          <source>NonZeroU64::clone_into</source>
          <target state="translated">NonZeroU64::clone_into</target>
        </trans-unit>
        <trans-unit id="a63a17006148383604de4d3fcb995f84d18aaa77" translate="yes" xml:space="preserve">
          <source>NonZeroU64::cmp</source>
          <target state="translated">NonZeroU64::cmp</target>
        </trans-unit>
        <trans-unit id="9de4084186275b67715c01bdf2631108a20373b3" translate="yes" xml:space="preserve">
          <source>NonZeroU64::eq</source>
          <target state="translated">NonZeroU64::eq</target>
        </trans-unit>
        <trans-unit id="f701376286f75acabb93bc338425e6cae42fdba1" translate="yes" xml:space="preserve">
          <source>NonZeroU64::fmt</source>
          <target state="translated">NonZeroU64::fmt</target>
        </trans-unit>
        <trans-unit id="e6c78a21f2934d9a2da92dd578a35b8157419529" translate="yes" xml:space="preserve">
          <source>NonZeroU64::from</source>
          <target state="translated">NonZeroU64::from</target>
        </trans-unit>
        <trans-unit id="546bd47a252bfe7b85af380602d87da22806650f" translate="yes" xml:space="preserve">
          <source>NonZeroU64::from_str</source>
          <target state="translated">NonZeroU64::from_str</target>
        </trans-unit>
        <trans-unit id="9aadba2a2b721871fd6af482b4623eee945bd2ca" translate="yes" xml:space="preserve">
          <source>NonZeroU64::ge</source>
          <target state="translated">NonZeroU64::ge</target>
        </trans-unit>
        <trans-unit id="23badb59c2bf64bbfd600b89c65d6464f288c34e" translate="yes" xml:space="preserve">
          <source>NonZeroU64::get</source>
          <target state="translated">NonZeroU64::get</target>
        </trans-unit>
        <trans-unit id="70ba0bfc2ee5de3dc8d77e5c800ac26d942aad60" translate="yes" xml:space="preserve">
          <source>NonZeroU64::gt</source>
          <target state="translated">NonZeroU64::gt</target>
        </trans-unit>
        <trans-unit id="1be0d3fa424fa8f1c9033db1563822faa87d86bc" translate="yes" xml:space="preserve">
          <source>NonZeroU64::hash</source>
          <target state="translated">NonZeroU64::hash</target>
        </trans-unit>
        <trans-unit id="9ef89b20cd332d28440efb1ab8c800e464dbc0c5" translate="yes" xml:space="preserve">
          <source>NonZeroU64::hash_slice</source>
          <target state="translated">NonZeroU64::hash_slice</target>
        </trans-unit>
        <trans-unit id="9cf4c75c1bac7fde4346dcdbc35fda963e585282" translate="yes" xml:space="preserve">
          <source>NonZeroU64::into</source>
          <target state="translated">NonZeroU64::into</target>
        </trans-unit>
        <trans-unit id="7376c3fefec318f3031bdc950d6f8f2a3089d974" translate="yes" xml:space="preserve">
          <source>NonZeroU64::le</source>
          <target state="translated">NonZeroU64::le</target>
        </trans-unit>
        <trans-unit id="9c3837210065694f326259c4c009fcf151ab8938" translate="yes" xml:space="preserve">
          <source>NonZeroU64::lt</source>
          <target state="translated">NonZeroU64::lt</target>
        </trans-unit>
        <trans-unit id="e88a4e86bb9a247b011285115d5e4adc34155d05" translate="yes" xml:space="preserve">
          <source>NonZeroU64::max</source>
          <target state="translated">NonZeroU64::max</target>
        </trans-unit>
        <trans-unit id="3ca2447656d5c5bf7e39124b2a8d6630ff253464" translate="yes" xml:space="preserve">
          <source>NonZeroU64::min</source>
          <target state="translated">NonZeroU64::min</target>
        </trans-unit>
        <trans-unit id="bf2706867bfa59da3e12e574c1c7a042c0c7fa0a" translate="yes" xml:space="preserve">
          <source>NonZeroU64::ne</source>
          <target state="translated">NonZeroU64::ne</target>
        </trans-unit>
        <trans-unit id="2fb761a04a1a28848d5bbb8c94562514f64738e6" translate="yes" xml:space="preserve">
          <source>NonZeroU64::new</source>
          <target state="translated">NonZeroU64::new</target>
        </trans-unit>
        <trans-unit id="a84ebe37c16ccdf34c145d075dd2d1ae8e718fd7" translate="yes" xml:space="preserve">
          <source>NonZeroU64::new_unchecked</source>
          <target state="translated">NonZeroU64::new_unchecked</target>
        </trans-unit>
        <trans-unit id="424d3fd0d71ac1783106c5f073cedfafd2433e33" translate="yes" xml:space="preserve">
          <source>NonZeroU64::partial_cmp</source>
          <target state="translated">NonZeroU64::partial_cmp</target>
        </trans-unit>
        <trans-unit id="689c6172e5e5fa7d743f6d9ea54feb2a2c45360e" translate="yes" xml:space="preserve">
          <source>NonZeroU64::to_owned</source>
          <target state="translated">NonZeroU64::to_owned</target>
        </trans-unit>
        <trans-unit id="0f770ca97d17ac208580e4663b1cb35d1585cd0a" translate="yes" xml:space="preserve">
          <source>NonZeroU64::to_string</source>
          <target state="translated">NonZeroU64::to_string</target>
        </trans-unit>
        <trans-unit id="b3edffffa9ccb083ef6dc98f9a91d2ee62a6a140" translate="yes" xml:space="preserve">
          <source>NonZeroU64::try_from</source>
          <target state="translated">NonZeroU64::try_from</target>
        </trans-unit>
        <trans-unit id="2309bbba28296004c54d80642075d1ce6e4cf120" translate="yes" xml:space="preserve">
          <source>NonZeroU64::try_into</source>
          <target state="translated">NonZeroU64::try_into</target>
        </trans-unit>
        <trans-unit id="ddce3cce76f837592f485e87ab5ddde6cfce8cd0" translate="yes" xml:space="preserve">
          <source>NonZeroU64::type_id</source>
          <target state="translated">NonZeroU64::type_id</target>
        </trans-unit>
        <trans-unit id="93acae18872d78f1044f122c7fa386b8e0790d18" translate="yes" xml:space="preserve">
          <source>NonZeroU8</source>
          <target state="translated">NonZeroU8</target>
        </trans-unit>
        <trans-unit id="6ff1a3cea907e661f3495c1cde07624988c92d18" translate="yes" xml:space="preserve">
          <source>NonZeroU8::borrow</source>
          <target state="translated">NonZeroU8::borrow</target>
        </trans-unit>
        <trans-unit id="63abe3b6e90de29270a227a14eb1cd95090ba8b5" translate="yes" xml:space="preserve">
          <source>NonZeroU8::borrow_mut</source>
          <target state="translated">NonZeroU8::borrow_mut</target>
        </trans-unit>
        <trans-unit id="803a11a99b517fd90ac23a43eefbdfca5457f48a" translate="yes" xml:space="preserve">
          <source>NonZeroU8::clamp</source>
          <target state="translated">NonZeroU8::clamp</target>
        </trans-unit>
        <trans-unit id="5c11d86db1fbb6b9b9c0d8f7f4a28a4bf6afbb24" translate="yes" xml:space="preserve">
          <source>NonZeroU8::clone</source>
          <target state="translated">NonZeroU8::clone</target>
        </trans-unit>
        <trans-unit id="670ad8364fc1871b9629299e869bcbacc5da96b2" translate="yes" xml:space="preserve">
          <source>NonZeroU8::clone_from</source>
          <target state="translated">NonZeroU8::clone_from</target>
        </trans-unit>
        <trans-unit id="6c6784a6e074a57a017f865c39fe9469883e2de8" translate="yes" xml:space="preserve">
          <source>NonZeroU8::clone_into</source>
          <target state="translated">NonZeroU8::clone_into</target>
        </trans-unit>
        <trans-unit id="693fb00ea40fa5aabc302b79d7c8e3718e6c8088" translate="yes" xml:space="preserve">
          <source>NonZeroU8::cmp</source>
          <target state="translated">NonZeroU8::cmp</target>
        </trans-unit>
        <trans-unit id="2158bd65bbc659ddb6d6412bd01916cb5d982ed3" translate="yes" xml:space="preserve">
          <source>NonZeroU8::eq</source>
          <target state="translated">NonZeroU8::eq</target>
        </trans-unit>
        <trans-unit id="3c80d10814d815cf1d99f1b13a12df65b0875877" translate="yes" xml:space="preserve">
          <source>NonZeroU8::fmt</source>
          <target state="translated">NonZeroU8::fmt</target>
        </trans-unit>
        <trans-unit id="7deaab84759c8ba54fbc5d91e72a59bd1aeb6577" translate="yes" xml:space="preserve">
          <source>NonZeroU8::from</source>
          <target state="translated">NonZeroU8::from</target>
        </trans-unit>
        <trans-unit id="2756bc8cdd2a9198a79f5cf73b9e1d572f0f1491" translate="yes" xml:space="preserve">
          <source>NonZeroU8::from_str</source>
          <target state="translated">NonZeroU8::from_str</target>
        </trans-unit>
        <trans-unit id="96e3274a26e461fa91c098ddcfa2558cac9c4747" translate="yes" xml:space="preserve">
          <source>NonZeroU8::ge</source>
          <target state="translated">NonZeroU8::ge</target>
        </trans-unit>
        <trans-unit id="922117f87c8142145cb8b8abbabb7402b5e2bc53" translate="yes" xml:space="preserve">
          <source>NonZeroU8::get</source>
          <target state="translated">NonZeroU8::get</target>
        </trans-unit>
        <trans-unit id="9d9dcce691d917ac54e2661132eb0950cc45d9a7" translate="yes" xml:space="preserve">
          <source>NonZeroU8::gt</source>
          <target state="translated">NonZeroU8::gt</target>
        </trans-unit>
        <trans-unit id="86ed98098229a654859aa731e5195157190e73cb" translate="yes" xml:space="preserve">
          <source>NonZeroU8::hash</source>
          <target state="translated">NonZeroU8::hash</target>
        </trans-unit>
        <trans-unit id="cb3adb90e777f04027a60a7879f9d135f08d1607" translate="yes" xml:space="preserve">
          <source>NonZeroU8::hash_slice</source>
          <target state="translated">NonZeroU8::hash_slice</target>
        </trans-unit>
        <trans-unit id="b79391b251df236d1d6289790b5260179dbdacc9" translate="yes" xml:space="preserve">
          <source>NonZeroU8::into</source>
          <target state="translated">NonZeroU8::into</target>
        </trans-unit>
        <trans-unit id="349980dfec87decceb14ada089c45ad6b63c099a" translate="yes" xml:space="preserve">
          <source>NonZeroU8::le</source>
          <target state="translated">NonZeroU8::le</target>
        </trans-unit>
        <trans-unit id="d736ad9511ba8ef5fa21ea6939ea1822c7d2dcb0" translate="yes" xml:space="preserve">
          <source>NonZeroU8::lt</source>
          <target state="translated">NonZeroU8::lt</target>
        </trans-unit>
        <trans-unit id="a284bcab69108d0fe7e56d5c4b3448e94a95b9b7" translate="yes" xml:space="preserve">
          <source>NonZeroU8::max</source>
          <target state="translated">NonZeroU8::max</target>
        </trans-unit>
        <trans-unit id="5a9a87bf0c351a8fa498461781bb9417c3bc85f9" translate="yes" xml:space="preserve">
          <source>NonZeroU8::min</source>
          <target state="translated">NonZeroU8::min</target>
        </trans-unit>
        <trans-unit id="950681f0c85136301d4d8bc7bd384530cbe0ad13" translate="yes" xml:space="preserve">
          <source>NonZeroU8::ne</source>
          <target state="translated">NonZeroU8::ne</target>
        </trans-unit>
        <trans-unit id="32bcfbfa6acfd6ddd32e20022619e9223f40a94f" translate="yes" xml:space="preserve">
          <source>NonZeroU8::new</source>
          <target state="translated">NonZeroU8::new</target>
        </trans-unit>
        <trans-unit id="c65bae8471e01bcbc9a0141783aef01900f64a4c" translate="yes" xml:space="preserve">
          <source>NonZeroU8::new_unchecked</source>
          <target state="translated">NonZeroU8::new_unchecked</target>
        </trans-unit>
        <trans-unit id="60e3a745d7919f9cebc4387f60a9049fdd9960a9" translate="yes" xml:space="preserve">
          <source>NonZeroU8::partial_cmp</source>
          <target state="translated">NonZeroU8::partial_cmp</target>
        </trans-unit>
        <trans-unit id="814facf57cfd7397aa0ec4ff5934741dc1504d0a" translate="yes" xml:space="preserve">
          <source>NonZeroU8::to_owned</source>
          <target state="translated">NonZeroU8::to_owned</target>
        </trans-unit>
        <trans-unit id="b5e9e73145a1a10790ac2c4b4ee56c85d1e6f97f" translate="yes" xml:space="preserve">
          <source>NonZeroU8::to_string</source>
          <target state="translated">NonZeroU8::to_string</target>
        </trans-unit>
        <trans-unit id="2b735ce2d45697df8d25226cb8808f268d9dad27" translate="yes" xml:space="preserve">
          <source>NonZeroU8::try_from</source>
          <target state="translated">NonZeroU8::try_from</target>
        </trans-unit>
        <trans-unit id="2b02b5ef9beb40480c74f9952d3ce821f4d69911" translate="yes" xml:space="preserve">
          <source>NonZeroU8::try_into</source>
          <target state="translated">NonZeroU8::try_into</target>
        </trans-unit>
        <trans-unit id="8c0fc32ec166f66886b38f57ea7d3cb7a7835fe2" translate="yes" xml:space="preserve">
          <source>NonZeroU8::type_id</source>
          <target state="translated">NonZeroU8::type_id</target>
        </trans-unit>
        <trans-unit id="b35788d3f6ffc592ab0774878cef29486e7e5bd4" translate="yes" xml:space="preserve">
          <source>NonZeroUsize</source>
          <target state="translated">NonZeroUsize</target>
        </trans-unit>
        <trans-unit id="c419d78f65ceafa9adf9a16c8a0459bf66be0bb0" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::borrow</source>
          <target state="translated">NonZeroUsize::borrow</target>
        </trans-unit>
        <trans-unit id="c7ac97a8de687d7597163c213da2788ada2700d7" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::borrow_mut</source>
          <target state="translated">NonZeroUsize::borrow_mut</target>
        </trans-unit>
        <trans-unit id="d423dc3c41f93a9c06c0e4ce6ae7fc621e805056" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::clamp</source>
          <target state="translated">NonZeroUsize::clamp</target>
        </trans-unit>
        <trans-unit id="47e7faa665db9da3adc8893ed9e5dcaa815fe4b2" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::clone</source>
          <target state="translated">NonZeroUsize::clone</target>
        </trans-unit>
        <trans-unit id="cb938c36bd0b3049477f6ad99f18c0d0ed6bf26f" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::clone_from</source>
          <target state="translated">NonZeroUsize::clone_from</target>
        </trans-unit>
        <trans-unit id="030e5620dfbf55afbbfe2d9c96c1e322152959d2" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::clone_into</source>
          <target state="translated">NonZeroUsize::clone_into</target>
        </trans-unit>
        <trans-unit id="a38099d022e9104d990e7e4e2d00982504357f0e" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::cmp</source>
          <target state="translated">NonZeroUsize::cmp</target>
        </trans-unit>
        <trans-unit id="57469c189c9f0d01b944369669232584fcab48be" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::eq</source>
          <target state="translated">NonZeroUsize::eq</target>
        </trans-unit>
        <trans-unit id="a3e007978854dfec2ea17781a918799b74afb325" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::fmt</source>
          <target state="translated">NonZeroUsize::fmt</target>
        </trans-unit>
        <trans-unit id="f78a5853c07aa978500a70738e411232664860cc" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::from</source>
          <target state="translated">NonZeroUsize::from</target>
        </trans-unit>
        <trans-unit id="7712061538648151dde34c4415be3b5d61f5877b" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::from_str</source>
          <target state="translated">NonZeroUsize::from_str</target>
        </trans-unit>
        <trans-unit id="f4728f09de22bd70d445970426411f10a0225b43" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::ge</source>
          <target state="translated">NonZeroUsize::ge</target>
        </trans-unit>
        <trans-unit id="b1cdf6cf2409f8c0f48ff7b3ba56ccc5ce5115e9" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::get</source>
          <target state="translated">NonZeroUsize::get</target>
        </trans-unit>
        <trans-unit id="a20bd2dec9d5657f43798c2c990e62953392115c" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::gt</source>
          <target state="translated">NonZeroUsize::gt</target>
        </trans-unit>
        <trans-unit id="801d8bc95574bf029e7d684d2cf3f771b60cd725" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::hash</source>
          <target state="translated">NonZeroUsize::hash</target>
        </trans-unit>
        <trans-unit id="6e0922eea57f8699c098adb3c035a1605d38f3df" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::hash_slice</source>
          <target state="translated">NonZeroUsize::hash_slice</target>
        </trans-unit>
        <trans-unit id="fb7586f1fe5330ac7ebbf29da06f142f1a81f679" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::into</source>
          <target state="translated">NonZeroUsize::into</target>
        </trans-unit>
        <trans-unit id="2236d0a73fe65fdff9ad7360c0db597b0672828c" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::le</source>
          <target state="translated">NonZeroUsize::le</target>
        </trans-unit>
        <trans-unit id="9347ed4b41dd70587e1703f7c2e07851b56cb2e9" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::lt</source>
          <target state="translated">NonZeroUsize::lt</target>
        </trans-unit>
        <trans-unit id="751ac4d697954b225e6f1616e4b4e0881bb6a41f" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::max</source>
          <target state="translated">NonZeroUsize::max</target>
        </trans-unit>
        <trans-unit id="00f9ea1a8ab80868d5583ca29a5d8f2c152f6d4b" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::min</source>
          <target state="translated">NonZeroUsize::min</target>
        </trans-unit>
        <trans-unit id="a3adc830a3d6e8e1f76b36c1da867853c22f3352" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::ne</source>
          <target state="translated">NonZeroUsize::ne</target>
        </trans-unit>
        <trans-unit id="b482e2411d650436386f31aaaee9d529c27faf6c" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::new</source>
          <target state="translated">NonZeroUsize::new</target>
        </trans-unit>
        <trans-unit id="0a63ca14c98c0ba3afecce88c1ee164dbbe678b5" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::new_unchecked</source>
          <target state="translated">NonZeroUsize::new_unchecked</target>
        </trans-unit>
        <trans-unit id="d2e829a9fc8b73a5ec3a806953ba65e782b63e4f" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::partial_cmp</source>
          <target state="translated">NonZeroUsize::partial_cmp</target>
        </trans-unit>
        <trans-unit id="0fc32bf985ee7be65f7708751121df22adec3ee2" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::to_owned</source>
          <target state="translated">NonZeroUsize::to_owned</target>
        </trans-unit>
        <trans-unit id="368109929572f9725530c9b5e66c0770d0254f6c" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::to_string</source>
          <target state="translated">NonZeroUsize::to_string</target>
        </trans-unit>
        <trans-unit id="87d57ca9ccbaaeab13b116376180c23efda524d3" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::try_from</source>
          <target state="translated">NonZeroUsize::try_from</target>
        </trans-unit>
        <trans-unit id="f36d6ccda72162b66595cff5afa6abcccb3ef47a" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::try_into</source>
          <target state="translated">NonZeroUsize::try_into</target>
        </trans-unit>
        <trans-unit id="661478a23cc64b875358e2c7f6262c9eb208bcf8" translate="yes" xml:space="preserve">
          <source>NonZeroUsize::type_id</source>
          <target state="translated">NonZeroUsize::type_id</target>
        </trans-unit>
        <trans-unit id="36aa77cbc45a62a558a375b317bc9b3804badfce" translate="yes" xml:space="preserve">
          <source>NoneError</source>
          <target state="translated">NoneError</target>
        </trans-unit>
        <trans-unit id="8def7b12f8f65fd01050dafd05df50f8287c0655" translate="yes" xml:space="preserve">
          <source>NoneError::borrow</source>
          <target state="translated">NoneError::borrow</target>
        </trans-unit>
        <trans-unit id="411f23ffccc2c350e97a02f83bb00bb04a9c1832" translate="yes" xml:space="preserve">
          <source>NoneError::borrow_mut</source>
          <target state="translated">NoneError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="a4d6154b1c340d1443c5a20d251329f398af2e11" translate="yes" xml:space="preserve">
          <source>NoneError::clamp</source>
          <target state="translated">NoneError::clamp</target>
        </trans-unit>
        <trans-unit id="555a6fa6139d1928ed4e7fa787af07b254f8f631" translate="yes" xml:space="preserve">
          <source>NoneError::clone</source>
          <target state="translated">NoneError::clone</target>
        </trans-unit>
        <trans-unit id="b7be3f1dfae027d0e36e44675d36fbd402d1e26e" translate="yes" xml:space="preserve">
          <source>NoneError::clone_from</source>
          <target state="translated">NoneError::clone_from</target>
        </trans-unit>
        <trans-unit id="dc67355563b52eb89e32ff38b5504d3dd52d77c9" translate="yes" xml:space="preserve">
          <source>NoneError::clone_into</source>
          <target state="translated">NoneError::clone_into</target>
        </trans-unit>
        <trans-unit id="65e99ec3e2a6e151575264b82499d7f2e38008ff" translate="yes" xml:space="preserve">
          <source>NoneError::cmp</source>
          <target state="translated">NoneError::cmp</target>
        </trans-unit>
        <trans-unit id="0611d16ae0dbf1df9ec05c20e45d31816b7a33e3" translate="yes" xml:space="preserve">
          <source>NoneError::eq</source>
          <target state="translated">NoneError::eq</target>
        </trans-unit>
        <trans-unit id="ddc77b796895a55df93a0b820a464b4aa338d41d" translate="yes" xml:space="preserve">
          <source>NoneError::fmt</source>
          <target state="translated">NoneError::fmt</target>
        </trans-unit>
        <trans-unit id="f69f3c5a7bc9e57ba1c80a5b7f03fced9bacf61f" translate="yes" xml:space="preserve">
          <source>NoneError::from</source>
          <target state="translated">NoneError::from</target>
        </trans-unit>
        <trans-unit id="ea4b13c4f12ac04af5fe2cbffa33fc963c8d5a26" translate="yes" xml:space="preserve">
          <source>NoneError::ge</source>
          <target state="translated">NoneError::ge</target>
        </trans-unit>
        <trans-unit id="80a0b1216e8cf201b9e9391df5c095172374f508" translate="yes" xml:space="preserve">
          <source>NoneError::gt</source>
          <target state="translated">NoneError::gt</target>
        </trans-unit>
        <trans-unit id="3cade823dfb903a695b6582abf8a0356daee7927" translate="yes" xml:space="preserve">
          <source>NoneError::hash</source>
          <target state="translated">NoneError::hash</target>
        </trans-unit>
        <trans-unit id="2c1acaeb04c59b2f4a9a10620721a7a1d4aa42f7" translate="yes" xml:space="preserve">
          <source>NoneError::hash_slice</source>
          <target state="translated">NoneError::hash_slice</target>
        </trans-unit>
        <trans-unit id="46b77ff1d8e23b12f242a6cf68b6e7dd11a9e430" translate="yes" xml:space="preserve">
          <source>NoneError::into</source>
          <target state="translated">NoneError::into</target>
        </trans-unit>
        <trans-unit id="ba9c0b7fd1b90ee18de8e25f5e5340671555fa67" translate="yes" xml:space="preserve">
          <source>NoneError::le</source>
          <target state="translated">NoneError::le</target>
        </trans-unit>
        <trans-unit id="41e697d230de0c7c6e3ccd553c26214e3ef30472" translate="yes" xml:space="preserve">
          <source>NoneError::lt</source>
          <target state="translated">NoneError::lt</target>
        </trans-unit>
        <trans-unit id="02bc1b16e164540afd825f0ab014879760deedcf" translate="yes" xml:space="preserve">
          <source>NoneError::max</source>
          <target state="translated">NoneError::max</target>
        </trans-unit>
        <trans-unit id="03ed85d18288e8c6efca69c28f3c605bc8004901" translate="yes" xml:space="preserve">
          <source>NoneError::min</source>
          <target state="translated">NoneError::min</target>
        </trans-unit>
        <trans-unit id="0cf87dcf59fc2d8f60cce9e0913e3c5ea01c71c6" translate="yes" xml:space="preserve">
          <source>NoneError::ne</source>
          <target state="translated">NoneError::ne</target>
        </trans-unit>
        <trans-unit id="88b27454a88f2b6d19dafb3a30b27e9e4799a66b" translate="yes" xml:space="preserve">
          <source>NoneError::partial_cmp</source>
          <target state="translated">NoneError::partial_cmp</target>
        </trans-unit>
        <trans-unit id="d76800607ec208e0e9251b9a3a41ceabc49a331f" translate="yes" xml:space="preserve">
          <source>NoneError::to_owned</source>
          <target state="translated">NoneError::to_owned</target>
        </trans-unit>
        <trans-unit id="a3e3b0d2121e13d536f0151b0514e0d6c2c50efe" translate="yes" xml:space="preserve">
          <source>NoneError::try_from</source>
          <target state="translated">NoneError::try_from</target>
        </trans-unit>
        <trans-unit id="b6f9326f4f9275b1c9ee9bf38430eb240361bf0b" translate="yes" xml:space="preserve">
          <source>NoneError::try_into</source>
          <target state="translated">NoneError::try_into</target>
        </trans-unit>
        <trans-unit id="2ed007421edc30616530d31dc1a9b886d8f905b6" translate="yes" xml:space="preserve">
          <source>NoneError::type_id</source>
          <target state="translated">NoneError::type_id</target>
        </trans-unit>
        <trans-unit id="59bdf32f963e32403610f535ed38d94ab9fa57b3" translate="yes" xml:space="preserve">
          <source>Nonequality comparison</source>
          <target state="translated">Comparación de no calidad</target>
        </trans-unit>
        <trans-unit id="aa380f41959815056bfdd3029c1845bf486477df" translate="yes" xml:space="preserve">
          <source>Nor can you use direct field access to do field-by-field gradual initialization:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19eddb0e70179b2e619be3068cd8376966632800" translate="yes" xml:space="preserve">
          <source>Nor will this:</source>
          <target state="translated">Tampoco esto:</target>
        </trans-unit>
        <trans-unit id="9b417a21d4e30df48f9cabc1eb07b9ff439a8913" translate="yes" xml:space="preserve">
          <source>Normally, here, one would use &lt;a href=&quot;#method.clear&quot;&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/a&gt; instead to correctly drop the contents and thus not leak memory.</source>
          <target state="translated">Normalmente, aqu&amp;iacute;, se usar&amp;iacute;a &lt;a href=&quot;#method.clear&quot;&gt; &lt;code&gt;clear&lt;/code&gt; en su&lt;/a&gt; lugar para eliminar correctamente el contenido y, por lo tanto, no perder memoria.</target>
        </trans-unit>
        <trans-unit id="5084dc27f957de7bc8c196b5f20cd9275d3c3a4f" translate="yes" xml:space="preserve">
          <source>Normally, here, one would use &lt;a href=&quot;struct.vec#method.clear&quot;&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/a&gt; instead to correctly drop the contents and thus not leak memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca1dd39379254ab3f3c73dbffb0d03d628b27d20" translate="yes" xml:space="preserve">
          <source>Not</source>
          <target state="translated">Not</target>
        </trans-unit>
        <trans-unit id="7531cdd8037edc1069a4fd743641ffecf0edfa83" translate="yes" xml:space="preserve">
          <source>Not Equal</source>
          <target state="translated">No es igual</target>
        </trans-unit>
        <trans-unit id="f8548a3657bfc32a33e876b215b140f301134c05" translate="yes" xml:space="preserve">
          <source>Not a Number (NaN).</source>
          <target state="translated">No es un número (NaN).</target>
        </trans-unit>
        <trans-unit id="d52a965ff185906c6e9fb5c36534475faa112b26" translate="yes" xml:space="preserve">
          <source>Not a Number (NaN). Use &lt;a href=&quot;../primitive.f32#associatedconstant.NAN&quot;&gt;&lt;code&gt;f32::NAN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd484bf7d113fac0a06fa50cec141b09e01e967e" translate="yes" xml:space="preserve">
          <source>Not a Number (NaN). Use &lt;a href=&quot;../primitive.f64#associatedconstant.NAN&quot;&gt;&lt;code&gt;f64::NAN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64507e89e4bdf04e8f9c77f8ac34253ff22412a5" translate="yes" xml:space="preserve">
          <source>Not all platforms that libstd compiles for support capturing backtraces. Some platforms simply do nothing when capturing a backtrace. To check whether the platform supports capturing backtraces you can consult the &lt;code&gt;BacktraceStatus&lt;/code&gt; enum as a result of &lt;code&gt;Backtrace::status&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="736e9bdbdcdd4b04a6c46d181f239630b7b9a187" translate="yes" xml:space="preserve">
          <source>Not all uses of &lt;code&gt;unsafe&lt;/code&gt; are equivalent: some are here to mark the existence of a contract the programmer must check, others are to say &quot;I have checked the contract, go ahead and do this&quot;. The following &lt;a href=&quot;https://internals.rust-lang.org/t/what-does-unsafe-mean/6696&quot;&gt;discussion on Rust Internals&lt;/a&gt; has more in-depth explanations about this but here is a summary of the main points:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2508d67aae4fe16b65d89f08837d02c03c4df29" translate="yes" xml:space="preserve">
          <source>Not be &lt;code&gt;NaN&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d13ee2c7e4ca985d57b930eb6ea7f0b33421d3e0" translate="yes" xml:space="preserve">
          <source>Not be infinite</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eb5b8bcff17673aebb4af5a3aeb0b4ab1932316" translate="yes" xml:space="preserve">
          <source>Not equal</source>
          <target state="translated">No es igual</target>
        </trans-unit>
        <trans-unit id="a2b674143c807a9d4d57ac721ad16bfa7f8e15e8" translate="yes" xml:space="preserve">
          <source>Not finding the pattern:</source>
          <target state="translated">No encontrar el patrón:</target>
        </trans-unit>
        <trans-unit id="ba8cbd3db6c5866f33c337f17d9969faf64a68a8" translate="yes" xml:space="preserve">
          <source>Not have any type parameters (although lifetime parameters are allowed), and</source>
          <target state="translated">No tienen ningún tipo de parámetros (aunque se permiten parámetros de vida útil),y</target>
        </trans-unit>
        <trans-unit id="fcaef0deabf89559da493cc8fdbfb1b73c922bc5" translate="yes" xml:space="preserve">
          <source>Not having to worry about incorrectly assuming a not-null value helps you to be more confident in your code. In order to have a value that can possibly be null, you must explicitly opt in by making the type of that value &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;. Then, when you use that value, you are required to explicitly handle the case when the value is null. Everywhere that a value has a type that isn&amp;rsquo;t an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;, you &lt;em&gt;can&lt;/em&gt; safely assume that the value isn&amp;rsquo;t null. This was a deliberate design decision for Rust to limit null&amp;rsquo;s pervasiveness and increase the safety of Rust code.</source>
          <target state="translated">No tener que preocuparse por asumir incorrectamente un valor no nulo le ayuda a tener m&amp;aacute;s confianza en su c&amp;oacute;digo. Para tener un valor que posiblemente pueda ser nulo, debe optar expl&amp;iacute;citamente haciendo el tipo de ese valor &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; . Luego, cuando usa ese valor, debe manejar expl&amp;iacute;citamente el caso cuando el valor es nulo. Dondequiera que un valor tenga un tipo que no sea una &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; , &lt;em&gt;puede&lt;/em&gt; asumir con seguridad que el valor no es nulo. Esta fue una decisi&amp;oacute;n de dise&amp;ntilde;o deliberada de Rust para limitar la omnipresencia de null y aumentar la seguridad del c&amp;oacute;digo de Rust.</target>
        </trans-unit>
        <trans-unit id="c51294854fb6314b2caed8c3d6d50e7adbd261e2" translate="yes" xml:space="preserve">
          <source>Not running destructors</source>
          <target state="translated">No correr los destructores</target>
        </trans-unit>
        <trans-unit id="b24fd225d5f013f2fa70d00cf4c24dafb25feaf7" translate="yes" xml:space="preserve">
          <source>Not running destructors in Rust is safe even if it has a type that isn't &lt;code&gt;'static&lt;/code&gt;. &lt;a href=&quot;../std/mem/struct.manuallydrop&quot;&gt;&lt;code&gt;std::mem::ManuallyDrop&lt;/code&gt;&lt;/a&gt; provides a wrapper to prevent a variable or field from being dropped automatically.</source>
          <target state="translated">No ejecutar destructores en Rust es seguro incluso si tiene un tipo que no es &lt;code&gt;'static&lt;/code&gt; . &lt;a href=&quot;../std/mem/struct.manuallydrop&quot;&gt; &lt;code&gt;std::mem::ManuallyDrop&lt;/code&gt; &lt;/a&gt; proporciona un contenedor para evitar que una variable o campo se elimine autom&amp;aacute;ticamente.</target>
        </trans-unit>
        <trans-unit id="0c7cc856a7f3d9cb5a50a65d04097b3b7b8538aa" translate="yes" xml:space="preserve">
          <source>Not that this function returns NaN if the initial value was NaN as well.</source>
          <target state="translated">No es que esta función devuelva NaN si el valor inicial también era NaN.</target>
        </trans-unit>
        <trans-unit id="c78919f021b1d754a66fe9891819ec98d0a80ddf" translate="yes" xml:space="preserve">
          <source>Not::not</source>
          <target state="translated">Not::not</target>
        </trans-unit>
        <trans-unit id="67e3ba0677bb45d7937c81385c061373c31498a8" translate="yes" xml:space="preserve">
          <source>Notable exception is made for situations where any of the directories specified in the &lt;code&gt;path&lt;/code&gt; could not be created as it was being created concurrently. Such cases are considered to be successful. That is, calling &lt;code&gt;create_dir_all&lt;/code&gt; concurrently from multiple threads or processes is guaranteed not to fail due to a race condition with itself.</source>
          <target state="translated">Se hace una excepci&amp;oacute;n notable para situaciones en las que alguno de los directorios especificados en la &lt;code&gt;path&lt;/code&gt; no se pudo crear ya que se estaba creando al mismo tiempo. Estos casos se consideran exitosos. Es decir, se &lt;code&gt;create_dir_all&lt;/code&gt; llamar a create_dir_all simult&amp;aacute;neamente desde m&amp;uacute;ltiples subprocesos o procesos no fallar&amp;aacute; debido a una condici&amp;oacute;n de carrera consigo mismo.</target>
        </trans-unit>
        <trans-unit id="23a734e9b17de37ddc28f39d989ac717c3bd9ad8" translate="yes" xml:space="preserve">
          <source>Notable features that const contexts have, but const fn haven't are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="215a4bdf475a8ec68726e515897b581b10444b3f" translate="yes" xml:space="preserve">
          <source>Notable traits for &amp;amp;'_ [u8]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d369df1510ca517b58a49f8cd6e6bb0e489ca52a" translate="yes" xml:space="preserve">
          <source>Notable traits for &amp;amp;'_ mut F</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e37dfc133bc97ebdeab9c07032473d9272189b3" translate="yes" xml:space="preserve">
          <source>Notable traits for &amp;amp;'_ mut I</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cb09acdfe424fff47bc90762c736658052520f0" translate="yes" xml:space="preserve">
          <source>Notable traits for Ancestors&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49884a82c86f5e2dcfd40b1838c34bab8f05e373" translate="yes" xml:space="preserve">
          <source>Notable traits for ArrayChunks&amp;lt;'a, T, N&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cd325ab96ff06257d643a3909af2cf159e2fa33" translate="yes" xml:space="preserve">
          <source>Notable traits for ArrayChunksMut&amp;lt;'a, T, N&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e4c4055a5d727f7480702b2cc7fa22ff495757b" translate="yes" xml:space="preserve">
          <source>Notable traits for ArrayWindows&amp;lt;'a, T, N&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8627fe98c009205a399c633908682c9a3e1ee4d" translate="yes" xml:space="preserve">
          <source>Notable traits for Box&amp;lt;F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9870581aecb430500b110feb6009781a8a35709" translate="yes" xml:space="preserve">
          <source>Notable traits for Box&amp;lt;F, A&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01102f0879a5c2ca5c62809ffff0c0b0bad939d6" translate="yes" xml:space="preserve">
          <source>Notable traits for BufReader&amp;lt;R&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcafa8b1481fa65c646affea37accfbcf24f6580" translate="yes" xml:space="preserve">
          <source>Notable traits for BufWriter&amp;lt;W&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73e8f6f48862fb0efc8b91d4c920e5075c8f689b" translate="yes" xml:space="preserve">
          <source>Notable traits for Bytes&amp;lt;'_&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be95aee73944208a8cbfa7ffa1a48d80537a439d" translate="yes" xml:space="preserve">
          <source>Notable traits for Bytes&amp;lt;R&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3aa0ca54ac23d2115ba17da930b0b2c7d22ecc0" translate="yes" xml:space="preserve">
          <source>Notable traits for Chain&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="425c2e101149bb0adbc3f3833b4e9a88563fb4a0" translate="yes" xml:space="preserve">
          <source>Notable traits for Chain&amp;lt;A, B&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a7e1c82210baf0b46d0937fbf969162cf98c76c" translate="yes" xml:space="preserve">
          <source>Notable traits for Chain&amp;lt;T, U&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd4d751abd8ab3ab6e55826ec326c6f4c431564f" translate="yes" xml:space="preserve">
          <source>Notable traits for CharIndices&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08171c5effb66b03601f395559057c5c02e5ba5f" translate="yes" xml:space="preserve">
          <source>Notable traits for Chars&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9df882063622aa637c014b3eaf06c558ffb8da5" translate="yes" xml:space="preserve">
          <source>Notable traits for Chunks&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e432bd66d3f874ed890c86d21283df436f2bbd0" translate="yes" xml:space="preserve">
          <source>Notable traits for ChunksExact&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="584a1b10a62ffb190941baeea973451d496428d5" translate="yes" xml:space="preserve">
          <source>Notable traits for ChunksExactMut&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95cc072812a01dbd66f6d2c5f3918fc1eecb2a25" translate="yes" xml:space="preserve">
          <source>Notable traits for ChunksMut&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fefa79cd49091a7a7a4ec1ce49b7dc2c3e8635da" translate="yes" xml:space="preserve">
          <source>Notable traits for Cloned&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae1c1d71ecdd9048c788733f05c8ee9170150c39" translate="yes" xml:space="preserve">
          <source>Notable traits for CommandArgs&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1d93748b1b05464de3995712c8cd56c0fc09338" translate="yes" xml:space="preserve">
          <source>Notable traits for CommandEnvs&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a97de3ec8fdabeefc703a8e7d7547f9f3496a716" translate="yes" xml:space="preserve">
          <source>Notable traits for Components&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d315c976ebb90a2389ef7743e81e7feecc3a3a82" translate="yes" xml:space="preserve">
          <source>Notable traits for Copied&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baf59bdb6fb943dc984c5feb9e03a98364bc20d8" translate="yes" xml:space="preserve">
          <source>Notable traits for Cursor&amp;lt;T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d59f29f61cd42c0f0ff909de6d45f9e90f184a20" translate="yes" xml:space="preserve">
          <source>Notable traits for Cycle&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c53b4ea31bf598b85ea40c284bdb3c0198881f8c" translate="yes" xml:space="preserve">
          <source>Notable traits for DecodeUtf16&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5127544158054e8bfb051274dd2021f84d9c3e7" translate="yes" xml:space="preserve">
          <source>Notable traits for Difference&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49894b4bfbcd9313cd8e1fca37fff62b0d5fe327" translate="yes" xml:space="preserve">
          <source>Notable traits for Difference&amp;lt;'a, T, S&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bc7c96c5bc0e2db809df1de91687bd4053c4024" translate="yes" xml:space="preserve">
          <source>Notable traits for Drain&amp;lt;'_&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0c298a9ee76878fdf90e4aa0fdba569c9110023" translate="yes" xml:space="preserve">
          <source>Notable traits for Drain&amp;lt;'_, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfff38769221a3bcf19fc3461189daa684992a6d" translate="yes" xml:space="preserve">
          <source>Notable traits for Drain&amp;lt;'a, K&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="958272eb22af639d41c1f50e43d47fb61a6b14ef" translate="yes" xml:space="preserve">
          <source>Notable traits for Drain&amp;lt;'a, K, V&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0daba3253b1d0ae9af8dc2745c8744b02b11222b" translate="yes" xml:space="preserve">
          <source>Notable traits for DrainFilter&amp;lt;'_, K, F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2385be6e59fcef027951939bd378844cfa66cc4e" translate="yes" xml:space="preserve">
          <source>Notable traits for DrainFilter&amp;lt;'_, K, V, F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="830f76c13044b7581905cb940dcf417e291d507b" translate="yes" xml:space="preserve">
          <source>Notable traits for DrainFilter&amp;lt;'_, T, F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="304a6f343623430e09952339820090a6a8ba207e" translate="yes" xml:space="preserve">
          <source>Notable traits for DrainSorted&amp;lt;'_, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac510d8e5089a326a2eb18feaee192a8adc0a137" translate="yes" xml:space="preserve">
          <source>Notable traits for Empty&amp;lt;T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3573695011deffd446de805daa200465e4ba04e" translate="yes" xml:space="preserve">
          <source>Notable traits for EncodeUtf16&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e43fb28465d3894c2c42629f7fcac035e497cddd" translate="yes" xml:space="preserve">
          <source>Notable traits for EncodeWide&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f89d4ae7f36a369049ddb4e7f3c8216010d3419d" translate="yes" xml:space="preserve">
          <source>Notable traits for Enumerate&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df3db15928fc8d95aa51b8ec8568ffb5eabd15ff" translate="yes" xml:space="preserve">
          <source>Notable traits for EscapeDebug</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c8ea88e979fa0c14d5d9cdbbd9d161b88b39045" translate="yes" xml:space="preserve">
          <source>Notable traits for EscapeDebug&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="098a62e8683b0a13c0908e723720ee9c6810fedc" translate="yes" xml:space="preserve">
          <source>Notable traits for EscapeDefault</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1190462f1941cfb82dacec2de3ad04f7c9541203" translate="yes" xml:space="preserve">
          <source>Notable traits for EscapeDefault&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac599426120513bc277a63e47f672a5774b2c3d2" translate="yes" xml:space="preserve">
          <source>Notable traits for EscapeUnicode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8024ca6f7e281ae2b2c49427386c5bf3564e02b9" translate="yes" xml:space="preserve">
          <source>Notable traits for EscapeUnicode&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09f685f90ec7f2abae36adf82f3e91f906928c37" translate="yes" xml:space="preserve">
          <source>Notable traits for File</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c974ed1aff38ed15c92fd39174e5a139046f0e34" translate="yes" xml:space="preserve">
          <source>Notable traits for Filter&amp;lt;I, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0176f9f85bf66bf907565450c64018c10c6cb978" translate="yes" xml:space="preserve">
          <source>Notable traits for FilterMap&amp;lt;I, F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bcdf064b818fb335120a0a13f2aad0c77345394" translate="yes" xml:space="preserve">
          <source>Notable traits for FlatMap&amp;lt;I, U, F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1073550fde927671db722e47a13215279dc8806e" translate="yes" xml:space="preserve">
          <source>Notable traits for Flatten&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3bb84e817e2df7af3ebf4adf8af3eae4361fbed" translate="yes" xml:space="preserve">
          <source>Notable traits for FromFn&amp;lt;F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dab5351ad5f13713d82cab1221966fc7e75e9d94" translate="yes" xml:space="preserve">
          <source>Notable traits for Fuse&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98b96e5efed1886b8e4bb59473b0f591f83aa189" translate="yes" xml:space="preserve">
          <source>Notable traits for Incoming&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69f0a4d3c756c850a0608c731279e5ac5c5ca49c" translate="yes" xml:space="preserve">
          <source>Notable traits for Inspect&amp;lt;I, F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f01a7c49836f7656e92d546f4185d1aefd357b8" translate="yes" xml:space="preserve">
          <source>Notable traits for Intersection&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20846e5c04b975b9bee849726ac0019c4f7b197d" translate="yes" xml:space="preserve">
          <source>Notable traits for Intersection&amp;lt;'a, T, S&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4917b9b001be9af84b1ad65c2d45310be0927721" translate="yes" xml:space="preserve">
          <source>Notable traits for IntoIter&amp;lt;A&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1104b62a63a5899e12eeb37d5678f9df68b057f0" translate="yes" xml:space="preserve">
          <source>Notable traits for IntoIter&amp;lt;K&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b19c0d62a927883656bbd747f944a9ce1ae1de8" translate="yes" xml:space="preserve">
          <source>Notable traits for IntoIter&amp;lt;K, V&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5480768feb968b4174c1ae6ddf0dcc0e359f66ea" translate="yes" xml:space="preserve">
          <source>Notable traits for IntoIter&amp;lt;T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3722bff12524c5b2d2d05cda59ba23d190ce3bfe" translate="yes" xml:space="preserve">
          <source>Notable traits for IntoIter&amp;lt;T, N&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c2d3479bd2162e028960fa1d767fb2598f2f013" translate="yes" xml:space="preserve">
          <source>Notable traits for IntoIterSorted&amp;lt;T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ad4c5fe36c7d254f4808dae95121b2bb0b54801" translate="yes" xml:space="preserve">
          <source>Notable traits for IntoKeys&amp;lt;K, V&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da31fc5c3cf56bab8c815369c2547a6911c833ba" translate="yes" xml:space="preserve">
          <source>Notable traits for IntoValues&amp;lt;K, V&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80895d49113bdb3cb86cfb4506bc6ebd9cd990ad" translate="yes" xml:space="preserve">
          <source>Notable traits for Iter&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d36ae4aeecd3653ca01fd74624e132869451eaf4" translate="yes" xml:space="preserve">
          <source>Notable traits for Iter&amp;lt;'a, A&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d5c2ab959e5631dfaa0a10009806935497b8c43" translate="yes" xml:space="preserve">
          <source>Notable traits for Iter&amp;lt;'a, K&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b3bc881963ccadbe18c6746d9bbee3015f5abf1" translate="yes" xml:space="preserve">
          <source>Notable traits for Iter&amp;lt;'a, K, V&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00b543ae90963f05f96f4dd377980b1713d5159b" translate="yes" xml:space="preserve">
          <source>Notable traits for Iter&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b070bfb60176569efaa6c1a4d324dc380b18332" translate="yes" xml:space="preserve">
          <source>Notable traits for IterMut&amp;lt;'a, A&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c915012f89d1a99c63f545f2ebffcef019fb4f2d" translate="yes" xml:space="preserve">
          <source>Notable traits for IterMut&amp;lt;'a, K, V&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7bfb298a8fa281946d7580611e184273523102f" translate="yes" xml:space="preserve">
          <source>Notable traits for IterMut&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e5811113cb7885323072cf61d5667a2b362dde2" translate="yes" xml:space="preserve">
          <source>Notable traits for Keys&amp;lt;'a, K, V&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99c669d87d53a9eb6f676c0605066d307d9e6144" translate="yes" xml:space="preserve">
          <source>Notable traits for LineWriter&amp;lt;W&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6228658663ccbd3f41a5107629651e3c2771c99b" translate="yes" xml:space="preserve">
          <source>Notable traits for Lines&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9213f8c618faa944ed6f22753d61edcc9d4ecdf2" translate="yes" xml:space="preserve">
          <source>Notable traits for Lines&amp;lt;B&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6a5e49b0d0ee24c230282dd8f08580ff2f4ffb7" translate="yes" xml:space="preserve">
          <source>Notable traits for LinesAny&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b99d80dc293caeb573cce051072ed906b6f15c5e" translate="yes" xml:space="preserve">
          <source>Notable traits for Map&amp;lt;I, F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="172f87d0793ddf7da88be709a2311741cbd4b363" translate="yes" xml:space="preserve">
          <source>Notable traits for MapWhile&amp;lt;I, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64729c888eeabe7cf12e1842e01480ed82b337ff" translate="yes" xml:space="preserve">
          <source>Notable traits for MatchIndices&amp;lt;'a, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0d2b75e66e9e050b8169e3218de5ee791479721" translate="yes" xml:space="preserve">
          <source>Notable traits for Matches&amp;lt;'a, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25ae519d64a28536d279768ad769256299621686" translate="yes" xml:space="preserve">
          <source>Notable traits for Once&amp;lt;T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8b307122c682ff77253a547508bfd2ee6faae04" translate="yes" xml:space="preserve">
          <source>Notable traits for OnceWith&amp;lt;F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed7b3a034e2d225ecfcc33f32f2f83f5b7d3d90b" translate="yes" xml:space="preserve">
          <source>Notable traits for Peekable&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b8f81a496f377f17826b87b054d41b9d3f6cb71" translate="yes" xml:space="preserve">
          <source>Notable traits for Pending&amp;lt;T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74be0fa24b2449c87cf0033da73af99abb038226" translate="yes" xml:space="preserve">
          <source>Notable traits for Pin&amp;lt;P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf6ce59e954214088a5388d7abe14ace680afd30" translate="yes" xml:space="preserve">
          <source>Notable traits for RChunks&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff0549023d3e07da72d7eaec8fd8c7d3b1bfc8bb" translate="yes" xml:space="preserve">
          <source>Notable traits for RChunksExact&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1891d732a25cb1a2d6470e2f1e61d90d79932069" translate="yes" xml:space="preserve">
          <source>Notable traits for RChunksExactMut&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="272511b477fb6f4d7e66f455a8927b6aa68fd2ce" translate="yes" xml:space="preserve">
          <source>Notable traits for RChunksMut&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bc67e64b7ea3bfd3fc10ece7ec2491353da6e9d" translate="yes" xml:space="preserve">
          <source>Notable traits for RMatchIndices&amp;lt;'a, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae7b6da19243fedcfa70bfd82f4cf8717d322f80" translate="yes" xml:space="preserve">
          <source>Notable traits for RMatches&amp;lt;'a, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aa09ee60858aa32b9e0f1689cc4891931af0d24" translate="yes" xml:space="preserve">
          <source>Notable traits for RSplit&amp;lt;'a, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0fe88a7318fe9810ff3810f98339d43244a6877" translate="yes" xml:space="preserve">
          <source>Notable traits for RSplit&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70be06d4120000b8b8b94371aec7e2580c6b381b" translate="yes" xml:space="preserve">
          <source>Notable traits for RSplitMut&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b31a8c9c6cb2046e7ec9e536ce72d0609e4c5c4" translate="yes" xml:space="preserve">
          <source>Notable traits for RSplitN&amp;lt;'a, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19040f24ad7c9687e49caaeab46d848dc263b5ea" translate="yes" xml:space="preserve">
          <source>Notable traits for RSplitN&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1988fde6a09875d4b04a7b9e55d197b9d9a90765" translate="yes" xml:space="preserve">
          <source>Notable traits for RSplitNMut&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="907edfb9c1524174e07ccbc24ecb37a8cbb06d65" translate="yes" xml:space="preserve">
          <source>Notable traits for RSplitTerminator&amp;lt;'a, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9198631706611f9de2afa1f3a5e4389cd7cb8e7a" translate="yes" xml:space="preserve">
          <source>Notable traits for Range&amp;lt;'a, K, V&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d3fe2b23ebaced9425f58daf076814b8c0291d9" translate="yes" xml:space="preserve">
          <source>Notable traits for Range&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0614892f74433d616b37d2ae04d67fe7f14ad105" translate="yes" xml:space="preserve">
          <source>Notable traits for Range&amp;lt;A&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beebcbfc8cc5133e5166a3028ebbd90ecdb7055f" translate="yes" xml:space="preserve">
          <source>Notable traits for RangeFrom&amp;lt;A&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f744d9434a4d9b5c37c99f5c97d2b2cc90b13077" translate="yes" xml:space="preserve">
          <source>Notable traits for RangeInclusive&amp;lt;A&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a4e925f094b7a69f246e42e8b50c5128f8129c7" translate="yes" xml:space="preserve">
          <source>Notable traits for RangeMut&amp;lt;'a, K, V&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abd184a89bc10bea6baedba72d627209bea1056f" translate="yes" xml:space="preserve">
          <source>Notable traits for Ready&amp;lt;T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64702f1280547e388d11ff5ae890bb729b733d36" translate="yes" xml:space="preserve">
          <source>Notable traits for Repeat&amp;lt;A&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49a3b2a3770cc905b8da25f64e140b4ab80c6ffe" translate="yes" xml:space="preserve">
          <source>Notable traits for RepeatWith&amp;lt;F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0ad194cda463ad2c6dd1506daf0367114be5c8e" translate="yes" xml:space="preserve">
          <source>Notable traits for Rev&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ff8f63be235b7ea2055383c2e9b72b84c7bd07e" translate="yes" xml:space="preserve">
          <source>Notable traits for Scan&amp;lt;I, St, F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="985d073dbfe88a46f9a5d9a064d7c96c1a9ddbdb" translate="yes" xml:space="preserve">
          <source>Notable traits for Skip&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f0eaba444b8b7b51819626fe7d8a57f993cdf9a" translate="yes" xml:space="preserve">
          <source>Notable traits for SkipWhile&amp;lt;I, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca8f82912aa693cda641dbb9a8f2619f7e15ddea" translate="yes" xml:space="preserve">
          <source>Notable traits for Splice&amp;lt;'_, I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef399e09acd6419098e7cfcabf45df6744dbfbc6" translate="yes" xml:space="preserve">
          <source>Notable traits for Split&amp;lt;'a, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1f967c2a861c03dbdc5cf356551e97bb60b084f" translate="yes" xml:space="preserve">
          <source>Notable traits for Split&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e39a8c3f513e0738a443ac406858d3b7bc026953" translate="yes" xml:space="preserve">
          <source>Notable traits for Split&amp;lt;B&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1d5f710d040b4a11a5d716baa68dcf2d617217b" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitAsciiWhitespace&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb7865e840a56b3e0895b5ec1bdbc829b951351d" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitInclusive&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9818f4f1fdfe2d933ac6655c5c4953e8aff5a7e1" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitInclusiveMut&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0838dd01ca950ce33cd2058b8d0ff4fd43821113" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitMut&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5880f295f9b58cf5125e602e8fae3c01c02bfbe" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitN&amp;lt;'a, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7599a2d009c0938be30293d468e1a75ce65377d5" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitN&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37e0cb911750681c09ba0b190a9557e42adc2590" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitNMut&amp;lt;'a, T, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f48dc2915683e916503c8dcf3e59f491126656bf" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitTerminator&amp;lt;'a, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d707147c6fab5cc551e32ce5467c609e374e4f50" translate="yes" xml:space="preserve">
          <source>Notable traits for SplitWhitespace&amp;lt;'a&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="437caeb56851568308dca5cb78609789356f0853" translate="yes" xml:space="preserve">
          <source>Notable traits for StderrLock&amp;lt;'_&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48c194fa1f0bd2541f390bd24896165b0c23c7e5" translate="yes" xml:space="preserve">
          <source>Notable traits for StdinLock&amp;lt;'_&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee33f3797cb0a601933ebede73fe50f827c75b6e" translate="yes" xml:space="preserve">
          <source>Notable traits for StdoutLock&amp;lt;'_&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e0ae991bfa5ac7c9c453dec86d28b7d72d47073" translate="yes" xml:space="preserve">
          <source>Notable traits for StepBy&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83f5fe0a710de90155479f39d5f77c153488c0a5" translate="yes" xml:space="preserve">
          <source>Notable traits for Successors&amp;lt;T, F&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="647ebf3b1fc10e80b4ce476f35a75fa114a5fab1" translate="yes" xml:space="preserve">
          <source>Notable traits for SymmetricDifference&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e0deb017937ef51088c94bb895f3902110ffe16" translate="yes" xml:space="preserve">
          <source>Notable traits for SymmetricDifference&amp;lt;'a, T, S&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b271862886a9e625b5ac46fc4e49bcce91334f9" translate="yes" xml:space="preserve">
          <source>Notable traits for Take&amp;lt;I&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d1491004df1c3cd73af985e7889ffe06072d374" translate="yes" xml:space="preserve">
          <source>Notable traits for Take&amp;lt;T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c484c47892ef31d80e9449405b6a45f7812a953" translate="yes" xml:space="preserve">
          <source>Notable traits for TakeWhile&amp;lt;I, P&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce43b5e8ae4c3d3abba449747c3b74da4e5cf5b2" translate="yes" xml:space="preserve">
          <source>Notable traits for TcpStream</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e1590902cedb9997418d686f3b41f48a7faa5a8" translate="yes" xml:space="preserve">
          <source>Notable traits for ToLowercase</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71cea9ba6a0245158a668390fdcdb390b3ee3a95" translate="yes" xml:space="preserve">
          <source>Notable traits for ToUppercase</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bc316517c095ef6246876fb36dafafef8842df0" translate="yes" xml:space="preserve">
          <source>Notable traits for TryIter&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36cd3ac7d99db311332b377e21251e4fba5322ec" translate="yes" xml:space="preserve">
          <source>Notable traits for Union&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1623bf8aee40498694e04160abcc7cc94e51160" translate="yes" xml:space="preserve">
          <source>Notable traits for Union&amp;lt;'a, T, S&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41fbaa40eb7f00c2be283feaa1fbb38e29701e83" translate="yes" xml:space="preserve">
          <source>Notable traits for UnixStream</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c50d1662883c24d433db05a688c0aa44526ac2e" translate="yes" xml:space="preserve">
          <source>Notable traits for Values&amp;lt;'a, K, V&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58c872469ad3d287548b76d4b848eba9a4a4c7d9" translate="yes" xml:space="preserve">
          <source>Notable traits for ValuesMut&amp;lt;'a, K, V&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34aac67be859564d9e8c0c60e00e2a029f471028" translate="yes" xml:space="preserve">
          <source>Notable traits for Vec&amp;lt;u8&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f1ce7df300d5a68156470029c1320d12946032a" translate="yes" xml:space="preserve">
          <source>Notable traits for Windows&amp;lt;'a, T&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8ed148e4a8689fea1373b25b6f60ce6eb17047c" translate="yes" xml:space="preserve">
          <source>Notable traits for Zip&amp;lt;A, B&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8f7449873c705105af159faa9949fb17717e319" translate="yes" xml:space="preserve">
          <source>Notably this function ignores the &lt;code&gt;flag&lt;/code&gt; parameters.</source>
          <target state="translated">En particular, esta funci&amp;oacute;n ignora los par&amp;aacute;metros de la &lt;code&gt;flag&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a8a9d000182248a3513e5a205741807831d1022" translate="yes" xml:space="preserve">
          <source>Notably: &lt;a href=&quot;variables&quot;&gt;variables&lt;/a&gt;, function parameters, &lt;a href=&quot;items/constant-items&quot;&gt;const&lt;/a&gt; and &lt;a href=&quot;items/static-items&quot;&gt;static&lt;/a&gt; items must be &lt;code&gt;Sized&lt;/code&gt;.</source>
          <target state="translated">En particular: las &lt;a href=&quot;variables&quot;&gt;variables&lt;/a&gt; , los par&amp;aacute;metros de funci&amp;oacute;n, los elementos &lt;a href=&quot;items/constant-items&quot;&gt;constantes&lt;/a&gt; y &lt;a href=&quot;items/static-items&quot;&gt;est&amp;aacute;ticos&lt;/a&gt; deben &lt;code&gt;Sized&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f3163ffda0d3418a1866865fdb1ef76cb2dbf4b" translate="yes" xml:space="preserve">
          <source>Notation</source>
          <target state="translated">Notation</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="c3fe4ddff5db29b0cb1f0eb2b355940acc3e474c" translate="yes" xml:space="preserve">
          <source>Note 1: The element range is removed even if the iterator is not consumed until the end.</source>
          <target state="translated">Nota 1:El rango de elementos se elimina aunque el iterador no se consuma hasta el final.</target>
        </trans-unit>
        <trans-unit id="73bad292ab0326c274afe69e790430a32b7dd7b6" translate="yes" xml:space="preserve">
          <source>Note 1: The element range is removed even if the iterator is only partially consumed or not consumed at all.</source>
          <target state="translated">Nota 1:El rango de elementos se elimina aunque el iterador se consuma sólo parcialmente o no se consuma en absoluto.</target>
        </trans-unit>
        <trans-unit id="375f6bc156b4954ecc954926534e181389ad6af2" translate="yes" xml:space="preserve">
          <source>Note 1: The first element of the iterator will always be returned, regardless of the step given.</source>
          <target state="translated">Nota 1:El primer elemento del iterador siempre será devuelto,independientemente del paso dado.</target>
        </trans-unit>
        <trans-unit id="0b81032a73d39d946d8d288ed04acdd88cf53ecf" translate="yes" xml:space="preserve">
          <source>Note 2: It is unspecified how many elements are removed from the deque, if the &lt;code&gt;Drain&lt;/code&gt; value is not dropped, but the borrow it holds expires (e.g., due to &lt;code&gt;mem::forget&lt;/code&gt;).</source>
          <target state="translated">Nota 2: No se especifica cu&amp;aacute;ntos elementos se eliminan de la deque, si el valor de &lt;code&gt;Drain&lt;/code&gt; no se elimina , pero el pr&amp;eacute;stamo que contiene expira (por ejemplo, debido a &lt;code&gt;mem::forget&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2ad2f022b2009c4ce2fc1713a74b64ee404e87d1" translate="yes" xml:space="preserve">
          <source>Note 2: It is unspecified how many elements are removed from the vector if the &lt;code&gt;Drain&lt;/code&gt; value is leaked.</source>
          <target state="translated">Nota 2: No se especifica cu&amp;aacute;ntos elementos se eliminan del vector si se filtra el valor de &lt;code&gt;Drain&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="506d02500f5463906be1bc26ef13102642229ab6" translate="yes" xml:space="preserve">
          <source>Note 2: The time at which ignored elements are pulled is not fixed. &lt;code&gt;StepBy&lt;/code&gt; behaves like the sequence &lt;code&gt;next(), nth(step-1), nth(step-1), &amp;hellip;&lt;/code&gt;, but is also free to behave like the sequence &lt;code&gt;advance_n_and_return_first(step), advance_n_and_return_first(step), &amp;hellip;&lt;/code&gt; Which way is used may change for some iterators for performance reasons. The second way will advance the iterator earlier and may consume more items.</source>
          <target state="translated">Nota 2: El momento en el que se extraen los elementos ignorados no es fijo. &lt;code&gt;StepBy&lt;/code&gt; se comporta como la secuencia &lt;code&gt;next(), nth(step-1), nth(step-1), &amp;hellip;&lt;/code&gt; , pero tambi&amp;eacute;n es libre de comportarse como la secuencia &lt;code&gt;advance_n_and_return_first(step), advance_n_and_return_first(step), &amp;hellip;&lt;/code&gt; forma en que se usa puede cambiar para algunos iteradores por razones de rendimiento. La segunda forma har&amp;aacute; avanzar el iterador antes y puede consumir m&amp;aacute;s elementos.</target>
        </trans-unit>
        <trans-unit id="3276127b29ca84c8dd6a3e6919af65a48a707afa" translate="yes" xml:space="preserve">
          <source>Note also that in Listing 19-1 and 19-3, we created &lt;code&gt;*const i32&lt;/code&gt; and &lt;code&gt;*mut i32&lt;/code&gt; raw pointers that both pointed to the same memory location, where &lt;code&gt;num&lt;/code&gt; is stored. If we instead tried to create an immutable and a mutable reference to &lt;code&gt;num&lt;/code&gt;, the code would not have compiled because Rust&amp;rsquo;s ownership rules don&amp;rsquo;t allow a mutable reference at the same time as any immutable references. With raw pointers, we can create a mutable pointer and an immutable pointer to the same location and change data through the mutable pointer, potentially creating a data race. Be careful!</source>
          <target state="translated">Note tambi&amp;eacute;n que en el Listado 19-1 y 19-3, creamos punteros sin formato &lt;code&gt;*const i32&lt;/code&gt; y &lt;code&gt;*mut i32&lt;/code&gt; que apuntaban a la misma ubicaci&amp;oacute;n de memoria, donde se almacena &lt;code&gt;num&lt;/code&gt; . Si, en cambio, intent&amp;aacute;ramos crear una referencia inmutable y mutable a &lt;code&gt;num&lt;/code&gt; , el c&amp;oacute;digo no se habr&amp;iacute;a compilado porque las reglas de propiedad de Rust no permiten una referencia mutable al mismo tiempo que cualquier referencia inmutable. Con punteros sin procesar, podemos crear un puntero mutable y un puntero inmutable a la misma ubicaci&amp;oacute;n y cambiar los datos a trav&amp;eacute;s del puntero mutable, creando potencialmente una carrera de datos. &amp;iexcl;Ten cuidado!</target>
        </trans-unit>
        <trans-unit id="6de37aeaf259b01294052b110f1c5546480ac1df" translate="yes" xml:space="preserve">
          <source>Note also that in the context of this formalism, the term &quot;token&quot; generally &lt;em&gt;includes&lt;/em&gt; simple NTs.</source>
          <target state="translated">Tenga en cuenta tambi&amp;eacute;n que en el contexto de este formalismo, el t&amp;eacute;rmino &quot;token&quot; generalmente &lt;em&gt;incluye&lt;/em&gt; NT simples.</target>
        </trans-unit>
        <trans-unit id="ddbcd5d0f2ca8f557f88753b63844e194aa420bc" translate="yes" xml:space="preserve">
          <source>Note however that:</source>
          <target state="translated">Sin embargo,note que:</target>
        </trans-unit>
        <trans-unit id="ac8dc1e3e610d665d4339a3068108ed3e4e3d7f2" translate="yes" xml:space="preserve">
          <source>Note however, that &lt;code&gt;black_box&lt;/code&gt; is only (and can only be) provided on a &quot;best-effort&quot; basis. The extent to which it can block optimisations may vary depending upon the platform and code-gen backend used. Programs cannot rely on &lt;code&gt;black_box&lt;/code&gt; for &lt;em&gt;correctness&lt;/em&gt; in any way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09b6433b842ad661442a50c48f705bbda92a3877" translate="yes" xml:space="preserve">
          <source>Note on locale</source>
          <target state="translated">Nota sobre el lugar</target>
        </trans-unit>
        <trans-unit id="6dac41f357fcb628dff23b9354a4451a8f0457e9" translate="yes" xml:space="preserve">
          <source>Note that &amp;amp;Any is limited to testing whether a value is of a specified concrete type, and cannot be used to test whether a type implements a trait.</source>
          <target state="translated">Tenga en cuenta que &amp;amp; Any se limita a probar si un valor es de un tipo concreto espec&amp;iacute;fico y no se puede usar para probar si un tipo implementa un rasgo.</target>
        </trans-unit>
        <trans-unit id="57e530ae79447e200db1291082ac88c201431874" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt;&lt;code&gt;drop_in_place&lt;/code&gt;&lt;/a&gt; already performs this check, so if your workload can be reduced to some small number of &lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt;&lt;code&gt;drop_in_place&lt;/code&gt;&lt;/a&gt; calls, using this is unnecessary. In particular note that you can &lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt;&lt;code&gt;drop_in_place&lt;/code&gt;&lt;/a&gt; a slice, and that will do a single needs_drop check for all the values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bf762ffc91bdd3eff38c069a4a949827e702fcc" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../sync/mpsc/index&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt;s for example are implemented using this primitive. Indeed when you call &lt;code&gt;send&lt;/code&gt; or &lt;code&gt;recv&lt;/code&gt;, which are blocking, they will yield if the channel is not available.</source>
          <target state="translated">Tenga en cuenta que los &lt;a href=&quot;../sync/mpsc/index&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt; , por ejemplo, se implementan utilizando esta primitiva. De hecho, cuando llame a &lt;code&gt;send&lt;/code&gt; o &lt;code&gt;recv&lt;/code&gt; , que est&amp;aacute;n bloqueando, ceder&amp;aacute;n si el canal no est&amp;aacute; disponible.</target>
        </trans-unit>
        <trans-unit id="b25a38a73d437340101dfed415d44fe9cc8bfeca" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;struct.childstderr&quot;&gt;&lt;code&gt;ChildStderr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.childstdout&quot;&gt;&lt;code&gt;ChildStdout&lt;/code&gt;&lt;/a&gt; implement &lt;a href=&quot;../io/trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.childstdin&quot;&gt;&lt;code&gt;ChildStdin&lt;/code&gt;&lt;/a&gt; implements &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Tenga en cuenta que &lt;a href=&quot;struct.childstderr&quot;&gt; &lt;code&gt;ChildStderr&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;struct.childstdout&quot;&gt; &lt;code&gt;ChildStdout&lt;/code&gt; &lt;/a&gt; implementan &lt;a href=&quot;../io/trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;struct.childstdin&quot;&gt; &lt;code&gt;ChildStdin&lt;/code&gt; &lt;/a&gt; implementa &lt;a href=&quot;../io/trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="cb54b0f71bbcbfc437ecfe318e92da06296ef44e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&amp;amp;dyn Any&lt;/code&gt; is limited to testing whether a value is of a specified concrete type, and cannot be used to test whether a type implements a trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40772281e6e9e65973c825aa35cf8a449645ff88" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;(T,)&lt;/code&gt; always denotes the type of a 1-tuple containing an element of type &lt;code&gt;T&lt;/code&gt;. The comma is necessary for syntactic disambiguation.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;(T,)&lt;/code&gt; siempre indica el tipo de un 1-tupla que contiene un elemento de tipo &lt;code&gt;T&lt;/code&gt; . La coma es necesaria para la desambiguaci&amp;oacute;n sint&amp;aacute;ctica.</target>
        </trans-unit>
        <trans-unit id="83c24ee2be7e8854e259c9b6dfc4dd85416ed0a7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;CoerceUnsized&lt;/code&gt; is mainly used by smart pointers like &lt;code&gt;Box&lt;/code&gt;, &lt;code&gt;Rc&lt;/code&gt; and &lt;code&gt;Arc&lt;/code&gt; to be able to mark that they can coerce unsized types that they are pointing at.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;CoerceUnsized&lt;/code&gt; es utilizado principalmente por punteros inteligentes como &lt;code&gt;Box&lt;/code&gt; , &lt;code&gt;Rc&lt;/code&gt; y &lt;code&gt;Arc&lt;/code&gt; para poder marcar que pueden coaccionar tipos sin tama&amp;ntilde;o a los que apuntan.</target>
        </trans-unit>
        <trans-unit id="67f3e9957b8f2c4f460edc12ad2bfe3cbc26e031" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; is only for use in single-threaded scenarios. When we discuss concurrency in Chapter 16, we&amp;rsquo;ll cover how to do reference counting in multithreaded programs.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; solo se utiliza en escenarios de un solo subproceso. Cuando analicemos la simultaneidad en el Cap&amp;iacute;tulo 16, cubriremos c&amp;oacute;mo realizar el recuento de referencias en programas multiproceso.</target>
        </trans-unit>
        <trans-unit id="5d99e9077b96e1db0f895f5becbb122b93be4c0b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Rhs&lt;/code&gt; is &lt;code&gt;Self&lt;/code&gt; by default, but this is not mandatory.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;Rhs&lt;/code&gt; es &lt;code&gt;Self&lt;/code&gt; por defecto, pero esto no es obligatorio.</target>
        </trans-unit>
        <trans-unit id="2200d088885b3a3d42f0732955184ac9e811ecb3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Rhs&lt;/code&gt; is &lt;code&gt;Self&lt;/code&gt; by default, but this is not mandatory. For example, &lt;a href=&quot;../time/struct.systemtime&quot;&gt;&lt;code&gt;std::time::SystemTime&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;Add&amp;lt;Duration&amp;gt;&lt;/code&gt;, which permits operations of the form &lt;code&gt;SystemTime = SystemTime + Duration&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;Rhs&lt;/code&gt; es &lt;code&gt;Self&lt;/code&gt; por defecto, pero esto no es obligatorio. Por ejemplo, &lt;a href=&quot;../time/struct.systemtime&quot;&gt; &lt;code&gt;std::time::SystemTime&lt;/code&gt; &lt;/a&gt; implementa &lt;code&gt;Add&amp;lt;Duration&amp;gt;&lt;/code&gt; , que permite operaciones de la forma &lt;code&gt;SystemTime = SystemTime + Duration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6326c7ae251a36c65278ccf6246055e8e4c505f9" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Rhs&lt;/code&gt; is &lt;code&gt;Self&lt;/code&gt; by default, but this is not mandatory. For example, &lt;a href=&quot;../time/struct.systemtime&quot;&gt;&lt;code&gt;std::time::SystemTime&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;Sub&amp;lt;Duration&amp;gt;&lt;/code&gt;, which permits operations of the form &lt;code&gt;SystemTime = SystemTime - Duration&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;Rhs&lt;/code&gt; es &lt;code&gt;Self&lt;/code&gt; por defecto, pero esto no es obligatorio. Por ejemplo, &lt;a href=&quot;../time/struct.systemtime&quot;&gt; &lt;code&gt;std::time::SystemTime&lt;/code&gt; &lt;/a&gt; implementa &lt;code&gt;Sub&amp;lt;Duration&amp;gt;&lt;/code&gt; , que permite operaciones de la forma &lt;code&gt;SystemTime = SystemTime - Duration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d4b833ed91bb546ce7e87843871f8e854946fd3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;T&lt;/code&gt; does not necessarily implement &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, so it can't even clone and reset &lt;code&gt;self.buf&lt;/code&gt;. But &lt;code&gt;replace&lt;/code&gt; can be used to disassociate the original value of &lt;code&gt;self.buf&lt;/code&gt; from &lt;code&gt;self&lt;/code&gt;, allowing it to be returned:</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;T&lt;/code&gt; no necesariamente implementa &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; , por lo que ni siquiera puede clonar y restablecer &lt;code&gt;self.buf&lt;/code&gt; . Pero &lt;code&gt;replace&lt;/code&gt; se puede usar para disociar el valor original de &lt;code&gt;self.buf&lt;/code&gt; de &lt;code&gt;self&lt;/code&gt; , lo que permite que se devuelva:</target>
        </trans-unit>
        <trans-unit id="ce9900f79b589dea762e357b371f9431cba99bba" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;T&lt;/code&gt; does not necessarily implement &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, so it can't even clone and reset &lt;code&gt;self.buf&lt;/code&gt;. But &lt;code&gt;take&lt;/code&gt; can be used to disassociate the original value of &lt;code&gt;self.buf&lt;/code&gt; from &lt;code&gt;self&lt;/code&gt;, allowing it to be returned:</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;T&lt;/code&gt; no necesariamente implementa &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; , por lo que ni siquiera puede clonar y restablecer &lt;code&gt;self.buf&lt;/code&gt; . Pero &lt;code&gt;take&lt;/code&gt; puede usarse para disociar el valor original de &lt;code&gt;self.buf&lt;/code&gt; de &lt;code&gt;self&lt;/code&gt; , permitiendo que se devuelva:</target>
        </trans-unit>
        <trans-unit id="ac00b6421a53f1cb355d37f763df7d0ab6908815" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;T&lt;/code&gt; does not necessarily implement &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, so we can't even clone &lt;code&gt;self.buf[i]&lt;/code&gt; to avoid the move. But &lt;code&gt;replace&lt;/code&gt; can be used to disassociate the original value at that index from &lt;code&gt;self&lt;/code&gt;, allowing it to be returned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7210db58c23cf5014deeb9448717499ab480d12" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;a &amp;lt;= b&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; imply &lt;code&gt;steps_between(&amp;amp;a, &amp;amp;b) != None&lt;/code&gt;; this is the case when it would require more than &lt;code&gt;usize::MAX&lt;/code&gt; steps to get to &lt;code&gt;b&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d217a13df9cefce26828e70c341f97e6fe273cac" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;drain_filter&lt;/code&gt; also lets you mutate every element in the filter closure, regardless of whether you choose to keep or remove it.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;drain_filter&lt;/code&gt; tambi&amp;eacute;n le permite mutar cada elemento en el cierre del filtro, independientemente de si elige mantenerlo o eliminarlo.</target>
        </trans-unit>
        <trans-unit id="98dacb5f160d6bac2dc7474d61b47f1366bd10c0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;drain_filter&lt;/code&gt; lets you mutate every element in the filter closure, regardless of whether you choose to keep or remove it.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;drain_filter&lt;/code&gt; permite mutar todos los elementos del cierre del filtro, independientemente de si elige mantenerlo o eliminarlo.</target>
        </trans-unit>
        <trans-unit id="5c2297eec650eb177080c75bea870e375a760bc0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;drain_filter&lt;/code&gt; lets you mutate every value in the filter closure, regardless of whether you choose to keep or remove it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="900305edc91345ae356f030caba1b6142733f009" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;iter.filter(f).next()&lt;/code&gt; is equivalent to &lt;code&gt;iter.find(f)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7d482051dadae6146f69f3e213d64c34dd92558" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;iter.find(f)&lt;/code&gt; is equivalent to &lt;code&gt;iter.filter(f).next()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a3d7e41ea7c72a3b5b7e84cc631a89a603d2cd0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;ptr::drop_in_place&lt;/code&gt; already performs this check, so if your workload can be reduced to some small number of drop_in_place calls, using this is unnecessary. In particular note that you can drop_in_place a slice, and that will do a single needs_drop check for all the values.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;ptr::drop_in_place&lt;/code&gt; ya realiza esta comprobaci&amp;oacute;n, por lo que si su carga de trabajo puede reducirse a una peque&amp;ntilde;a cantidad de llamadas drop_in_place, no es necesario utilizarlo. En particular, tenga en cuenta que puede colocar_en_lugar un segmento, y eso har&amp;aacute; una &amp;uacute;nica verificaci&amp;oacute;n de need_drop para todos los valores.</target>
        </trans-unit>
        <trans-unit id="437bc8fdeeb2ba2175b3e963d9a28d86c8a4a21f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;query&lt;/code&gt; is now a &lt;code&gt;String&lt;/code&gt; rather than a string slice, because calling &lt;code&gt;to_lowercase&lt;/code&gt; creates new data rather than referencing existing data. Say the query is &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt;, as an example: that string slice doesn&amp;rsquo;t contain a lowercase &lt;code&gt;u&lt;/code&gt; or &lt;code&gt;t&lt;/code&gt; for us to use, so we have to allocate a new &lt;code&gt;String&lt;/code&gt; containing &lt;code&gt;&quot;rust&quot;&lt;/code&gt;. When we pass &lt;code&gt;query&lt;/code&gt; as an argument to the &lt;code&gt;contains&lt;/code&gt; method now, we need to add an ampersand because the signature of &lt;code&gt;contains&lt;/code&gt; is defined to take a string slice.</source>
          <target state="translated">Tenga en cuenta que la &lt;code&gt;query&lt;/code&gt; ahora es una &lt;code&gt;String&lt;/code&gt; lugar de un segmento de cadena, porque llamar a &lt;code&gt;to_lowercase&lt;/code&gt; crea nuevos datos en lugar de hacer referencia a los datos existentes. Digamos que la consulta es &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt; , como ejemplo: ese segmento de cadena no contiene una &lt;code&gt;u&lt;/code&gt; o &lt;code&gt;t&lt;/code&gt; min&amp;uacute;scula para que la usemos, as&amp;iacute; que tenemos que asignar una nueva &lt;code&gt;String&lt;/code&gt; contenga &lt;code&gt;&quot;rust&quot;&lt;/code&gt; . Cuando pasamos la &lt;code&gt;query&lt;/code&gt; como argumento al m&amp;eacute;todo &lt;code&gt;contains&lt;/code&gt; ahora, necesitamos agregar un ampersand porque la firma de &lt;code&gt;contains&lt;/code&gt; est&amp;aacute; definida para tomar un segmento de cadena.</target>
        </trans-unit>
        <trans-unit id="d0952252c7abd133f9767b9cae9e5576b814cc56" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;std::env::args&lt;/code&gt; will panic if any argument contains invalid Unicode. If your program needs to accept arguments containing invalid Unicode, use &lt;code&gt;std::env::args_os&lt;/code&gt; instead. That function returns an iterator that produces &lt;code&gt;OsString&lt;/code&gt; values instead of &lt;code&gt;String&lt;/code&gt; values. We&amp;rsquo;ve chosen to use &lt;code&gt;std::env::args&lt;/code&gt; here for simplicity, because &lt;code&gt;OsString&lt;/code&gt; values differ per platform and are more complex to work with than &lt;code&gt;String&lt;/code&gt; values.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;std::env::args&lt;/code&gt; entrar&amp;aacute; en p&amp;aacute;nico si alg&amp;uacute;n argumento contiene Unicode no v&amp;aacute;lido. Si su programa necesita aceptar argumentos que contengan Unicode no v&amp;aacute;lido, utilice &lt;code&gt;std::env::args_os&lt;/code&gt; en su lugar. Esa funci&amp;oacute;n devuelve un iterador que produce valores &lt;code&gt;OsString&lt;/code&gt; en lugar de valores &lt;code&gt;String&lt;/code&gt; . Hemos elegido usar &lt;code&gt;std::env::args&lt;/code&gt; aqu&amp;iacute; por simplicidad, porque los valores de &lt;code&gt;OsString&lt;/code&gt; difieren seg&amp;uacute;n la plataforma y es m&amp;aacute;s complejo trabajar con ellos que los valores de &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46299fa0ac2a6d6905de493039f518d4e56af3e6" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;zip&lt;/code&gt; produces only four pairs; the theoretical fifth pair &lt;code&gt;(5, None)&lt;/code&gt; is never produced because &lt;code&gt;zip&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt; when either of its input iterators return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;zip&lt;/code&gt; produce solo cuatro pares; el quinto par te&amp;oacute;rico &lt;code&gt;(5, None)&lt;/code&gt; nunca se produce porque &lt;code&gt;zip&lt;/code&gt; devuelve &lt;code&gt;None&lt;/code&gt; cuando cualquiera de sus iteradores de entrada devuelve &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df23fedf4cb715b65ef5d705d642f0cedf378647" translate="yes" xml:space="preserve">
          <source>Note that Rust does not have a notion of optional function arguments or variadic functions (except for its C-FFI).</source>
          <target state="translated">Nótese que Rust no tiene una noción de argumentos de funciones opcionales o funciones variadas (excepto su C-FFI).</target>
        </trans-unit>
        <trans-unit id="9dba02396ec6e8b7b0a98dc4c9d2e9628008b426" translate="yes" xml:space="preserve">
          <source>Note that a &quot;best effort&quot; is made to ensure that destructors for types stored in thread local storage are run, but not all platforms can guarantee that destructors will be run for all types in thread local storage. For example, there are a number of known caveats where destructors are not run:</source>
          <target state="translated">Obsérvese que se hace el &quot;mejor esfuerzo&quot; para asegurar que se ejecuten los destructores para los tipos almacenados en el almacenamiento local de hilos,pero no todas las plataformas pueden garantizar que se ejecuten los destructores para todos los tipos en el almacenamiento local de hilos.Por ejemplo,hay una serie de advertencias conocidas en las que los destructores no se ejecutan:</target>
        </trans-unit>
        <trans-unit id="aa61dce391cdbcb5b806d9a3fb49147f0dba491d" translate="yes" xml:space="preserve">
          <source>Note that a &lt;code&gt;()&lt;/code&gt;-returning &lt;code&gt;main&lt;/code&gt; implicitly results in a successful termination, so there's no need to return this from &lt;code&gt;main&lt;/code&gt; unless you're also returning other possible codes.</source>
          <target state="translated">Tenga en cuenta que un &lt;code&gt;()&lt;/code&gt; -returning &lt;code&gt;main&lt;/code&gt; impl&amp;iacute;citamente da como resultado una terminaci&amp;oacute;n exitosa, por lo que no es necesario devolver esto desde &lt;code&gt;main&lt;/code&gt; a menos que tambi&amp;eacute;n est&amp;eacute; devolviendo otros c&amp;oacute;digos posibles.</target>
        </trans-unit>
        <trans-unit id="8c3f037daacb11aa4c63650c08cd568774329dcc" translate="yes" xml:space="preserve">
          <source>Note that a capture will either move or borrow a variable, but in this situation, the closure is borrowing the variable. Take a look at http://rustbyexample.com/fn/closures/capture.html for more information about capturing.</source>
          <target state="translated">Tenga en cuenta que una captura moverá o tomará prestada una variable,pero en esta situación,el cierre está tomando prestada la variable.Echa un vistazo a http://rustbyexample.com/fn/closures/capture.html para más información sobre la captura.</target>
        </trans-unit>
        <trans-unit id="d28236ceeda3d941466d94520f9be31d9496ffc8" translate="yes" xml:space="preserve">
          <source>Note that a capture will either move or borrow a variable, but in this situation, the closure is borrowing the variable. Take a look at the chapter on &lt;a href=&quot;https://doc.rust-lang.org/stable/rust-by-example/fn/closures/capture.html&quot;&gt;Capturing&lt;/a&gt; in Rust By Example for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b647009da3543b51ed32c9ce05f0008653d4bcc6" translate="yes" xml:space="preserve">
          <source>Note that a matcher is merely a token tree. A &quot;simple NT&quot;, as mentioned above, is an meta-variable NT; thus it is a non-repetition. For example, &lt;code&gt;$foo:ty&lt;/code&gt; is a simple NT but &lt;code&gt;$($foo:ty)+&lt;/code&gt; is a complex NT.</source>
          <target state="translated">Tenga en cuenta que un comparador es simplemente un &amp;aacute;rbol de fichas. Un &quot;NT simple&quot;, como se mencion&amp;oacute; anteriormente, es un NT metavariable; por tanto, es una no repetici&amp;oacute;n. Por ejemplo, &lt;code&gt;$foo:ty&lt;/code&gt; es un NT simple pero &lt;code&gt;$($foo:ty)+&lt;/code&gt; es un NT complejo.</target>
        </trans-unit>
        <trans-unit id="166c645f512c5060e3e63517e9e2f60db5770e99" translate="yes" xml:space="preserve">
          <source>Note that a reference&amp;rsquo;s scope starts from where it is introduced and continues through the last time that reference is used. For instance, this code will compile because the last usage of the immutable references occurs before the mutable reference is introduced:</source>
          <target state="translated">Tenga en cuenta que el alcance de una referencia comienza desde donde se introduce y contin&amp;uacute;a hasta la &amp;uacute;ltima vez que se utiliz&amp;oacute; esa referencia. Por ejemplo, este c&amp;oacute;digo se compilar&amp;aacute; porque el &amp;uacute;ltimo uso de las referencias inmutables ocurre antes de que se introduzca la referencia mutable:</target>
        </trans-unit>
        <trans-unit id="f3f4807c52376e81ba95b7f4b622c918a83cf1d4" translate="yes" xml:space="preserve">
          <source>Note that a successful send does &lt;em&gt;not&lt;/em&gt; guarantee that the receiver will ever see the data if there is a buffer on this channel. Items may be enqueued in the internal buffer for the receiver to receive at a later time. If the buffer size is 0, however, the channel becomes a rendezvous channel and it guarantees that the receiver has indeed received the data if this function returns success.</source>
          <target state="translated">Tenga en cuenta que un env&amp;iacute;o exitoso &lt;em&gt;no&lt;/em&gt; garantiza que el receptor vea los datos si hay un b&amp;uacute;fer en este canal. Los elementos se pueden poner en cola en el b&amp;uacute;fer interno para que el receptor los reciba en un momento posterior. Sin embargo, si el tama&amp;ntilde;o del b&amp;uacute;fer es 0, el canal se convierte en un canal de encuentro y garantiza que el receptor ha recibido los datos si esta funci&amp;oacute;n devuelve correctamente.</target>
        </trans-unit>
        <trans-unit id="1f0335bd5206c4df046874965f0d18fc2183ed51" translate="yes" xml:space="preserve">
          <source>Note that accessing the value inside a &lt;code&gt;ManuallyDrop&amp;lt;T&amp;gt;&lt;/code&gt; is safe. This means that a &lt;code&gt;ManuallyDrop&amp;lt;T&amp;gt;&lt;/code&gt; whose content has been dropped must not be exposed through a public safe API. Correspondingly, &lt;code&gt;ManuallyDrop::drop&lt;/code&gt; is unsafe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5885b8aa2d181f8795166dedd7f6344e9a60f6b3" translate="yes" xml:space="preserve">
          <source>Note that alignment may not be implemented by some types. In particular, it is not generally implemented for the &lt;code&gt;Debug&lt;/code&gt; trait. A good way to ensure padding is applied is to format your input, then pad this resulting string to obtain your output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3a19fce9bb891c546eeeb563b1b7a91ed25675f" translate="yes" xml:space="preserve">
          <source>Note that alignment may not be implemented by some types. In particular, it is not generally implemented for the &lt;code&gt;Debug&lt;/code&gt; trait. A good way to ensure padding is applied is to format your input, then use this resulting string to pad your output.</source>
          <target state="translated">Tenga en cuenta que es posible que algunos tipos no implementen la alineaci&amp;oacute;n. En particular, generalmente no se implementa para el rasgo &lt;code&gt;Debug&lt;/code&gt; . Una buena forma de asegurarse de que se aplique el relleno es formatear su entrada y luego usar esta cadena resultante para rellenar su salida.</target>
        </trans-unit>
        <trans-unit id="76db1b0ab7636a80673dac1a141ed05d052cb403" translate="yes" xml:space="preserve">
          <source>Note that all &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s are valid &lt;a href=&quot;../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s, and can be cast to one with &lt;code&gt;as&lt;/code&gt;:</source>
          <target state="translated">Tenga en cuenta que todos los &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; s son v&amp;aacute;lidos &lt;a href=&quot;../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; s, y pueden convertirse a uno con &lt;code&gt;as&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="516c2ce158a14ccb1ab369bf0a62cbade5443e81" translate="yes" xml:space="preserve">
          <source>Note that all &lt;code&gt;char&lt;/code&gt;s are valid &lt;a href=&quot;primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s, and can be cast to one with &lt;code&gt;as&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0494b2e843f4a073b41bb1890333a63fc3eaceb" translate="yes" xml:space="preserve">
          <source>Note that all elements between the end and the returned element will be consumed, including the returned element. This also means that calling &lt;code&gt;nth_back(0)&lt;/code&gt; multiple times on the same iterator will return different elements.</source>
          <target state="translated">Tenga en cuenta que se consumir&amp;aacute;n todos los elementos entre el final y el elemento devuelto, incluido el elemento devuelto. Esto tambi&amp;eacute;n significa que llamar a &lt;code&gt;nth_back(0)&lt;/code&gt; varias veces en el mismo iterador devolver&amp;aacute; diferentes elementos.</target>
        </trans-unit>
        <trans-unit id="50ea5f0e3ab7dc58cad2b538ddb240e9c4984ee9" translate="yes" xml:space="preserve">
          <source>Note that all preceding elements, as well as the returned element, will be consumed from the iterator. That means that the preceding elements will be discarded, and also that calling &lt;code&gt;nth(0)&lt;/code&gt; multiple times on the same iterator will return different elements.</source>
          <target state="translated">Tenga en cuenta que todos los elementos anteriores, as&amp;iacute; como el elemento devuelto, se consumir&amp;aacute;n del iterador. Eso significa que los elementos anteriores se descartar&amp;aacute;n y tambi&amp;eacute;n que llamar a &lt;code&gt;nth(0)&lt;/code&gt; varias veces en el mismo iterador devolver&amp;aacute; elementos diferentes.</target>
        </trans-unit>
        <trans-unit id="491da8d1616c74f297c93c3f76ed9c42830ffa59" translate="yes" xml:space="preserve">
          <source>Note that any code in earlier iterations of &lt;em&gt;The Rust Programming Language&lt;/em&gt; that compiled will continue to compile without &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in the project&amp;rsquo;s &lt;em&gt;Cargo.toml&lt;/em&gt;, even as you update the Rust compiler version you&amp;rsquo;re using. That&amp;rsquo;s Rust&amp;rsquo;s backward compatibility guarantees at work!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8557ae8a9f894db68722639fc1170d53ad338fd1" translate="yes" xml:space="preserve">
          <source>Note that any code in the first printing of &lt;em&gt;The Rust Programming Language&lt;/em&gt; that compiled will continue to compile without &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in the project&amp;rsquo;s &lt;em&gt;Cargo.toml&lt;/em&gt;, even as you update the Rust compiler version you&amp;rsquo;re using. That&amp;rsquo;s Rust&amp;rsquo;s backward compatibility guarantees at work!</source>
          <target state="translated">Tenga en cuenta que cualquier c&amp;oacute;digo en la primera impresi&amp;oacute;n de &lt;em&gt;The Rust Programming Language&lt;/em&gt; que se compil&amp;oacute; continuar&amp;aacute; compil&amp;aacute;ndose sin &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; en el &lt;em&gt;Cargo.toml&lt;/em&gt; del proyecto , incluso cuando actualice la versi&amp;oacute;n del compilador de Rust que est&amp;aacute; usando. &amp;iexcl;Esas son las garant&amp;iacute;as de compatibilidad con versiones anteriores de Rust en funcionamiento!</target>
        </trans-unit>
        <trans-unit id="816a2f31fb1f17b4e41f02fda3eaa37e852b4d6e" translate="yes" xml:space="preserve">
          <source>Note that any leftover data in the internal buffer is lost.</source>
          <target state="translated">Tenga en cuenta que cualquier dato sobrante en el buffer interno se pierde.</target>
        </trans-unit>
        <trans-unit id="2a041883f7bee5eb6e6f55708c727c8ab3a3ed00" translate="yes" xml:space="preserve">
          <source>Note that any leftover data in the internal buffer is lost. Therefore, a following read from the underlying reader may lead to data loss.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45719b2fc23ab9d812a1864bec0c46011337290e" translate="yes" xml:space="preserve">
          <source>Note that because this function never returns, and that it terminates the process, no destructors on the current stack or any other thread's stack will be run.</source>
          <target state="translated">Tenga en cuenta que debido a que esta función nunca regresa,y que termina el proceso,no se ejecutarán los destructores de la pila actual o de cualquier otra pila de hilos.</target>
        </trans-unit>
        <trans-unit id="8ee637b0f22097f2447433c9e30b0952e702b8b7" translate="yes" xml:space="preserve">
          <source>Note that because this function never returns, and that it terminates the process, no destructors on the current stack or any other thread's stack will be run. If a clean shutdown is needed it is recommended to only call this function at a known point where there are no more destructors left to run.</source>
          <target state="translated">Tenga en cuenta que como esta función nunca regresa,y que termina el proceso,no se ejecutarán los destructores de la pila actual o de cualquier otra pila de hilos.Si se necesita un cierre limpio,se recomienda llamar a esta función sólo en un punto conocido donde no queden más destructores por ejecutar.</target>
        </trans-unit>
        <trans-unit id="25d3aa7c2b95febeff16d7f5e6ce36387044d531" translate="yes" xml:space="preserve">
          <source>Note that because we defined the &lt;code&gt;Summary&lt;/code&gt; trait and the &lt;code&gt;NewsArticle&lt;/code&gt; and &lt;code&gt;Tweet&lt;/code&gt; types in the same &lt;em&gt;lib.rs&lt;/em&gt; in Listing 10-13, they&amp;rsquo;re all in the same scope. Let&amp;rsquo;s say this &lt;em&gt;lib.rs&lt;/em&gt; is for a crate we&amp;rsquo;ve called &lt;code&gt;aggregator&lt;/code&gt; and someone else wants to use our crate&amp;rsquo;s functionality to implement the &lt;code&gt;Summary&lt;/code&gt; trait on a struct defined within their library&amp;rsquo;s scope. They would need to bring the trait into their scope first. They would do so by specifying &lt;code&gt;use aggregator::Summary;&lt;/code&gt;, which then would enable them to implement &lt;code&gt;Summary&lt;/code&gt; for their type. The &lt;code&gt;Summary&lt;/code&gt; trait would also need to be a public trait for another crate to implement it, which it is because we put the &lt;code&gt;pub&lt;/code&gt; keyword before &lt;code&gt;trait&lt;/code&gt; in Listing 10-12.</source>
          <target state="translated">Tenga en cuenta que debido a que definimos el rasgo &lt;code&gt;Summary&lt;/code&gt; y los tipos &lt;code&gt;NewsArticle&lt;/code&gt; y &lt;code&gt;Tweet&lt;/code&gt; en los mismos &lt;em&gt;lib.rs&lt;/em&gt; en el Listado 10-13, todos est&amp;aacute;n en el mismo alcance. Digamos que este &lt;em&gt;lib.rs&lt;/em&gt; es para una caja que hemos llamado &lt;code&gt;aggregator&lt;/code&gt; y alguien m&amp;aacute;s quiere usar la funcionalidad de nuestra caja para implementar el rasgo &lt;code&gt;Summary&lt;/code&gt; en una estructura definida dentro del alcance de su biblioteca. Primero tendr&amp;iacute;an que llevar el rasgo a su alcance. Lo har&amp;iacute;an especificando &lt;code&gt;use aggregator::Summary;&lt;/code&gt; , lo que les permitir&amp;iacute;a implementar &lt;code&gt;Summary&lt;/code&gt; para su tipo. El &lt;code&gt;Summary&lt;/code&gt; El rasgo tambi&amp;eacute;n deber&amp;iacute;a ser un rasgo p&amp;uacute;blico para que otra caja lo implemente, lo cual se debe a que colocamos la palabra clave &lt;code&gt;pub&lt;/code&gt; antes del &lt;code&gt;trait&lt;/code&gt; en el Listado 10-12.</target>
        </trans-unit>
        <trans-unit id="5c2746c98858012c4f3f702901d1b8fef09f722f" translate="yes" xml:space="preserve">
          <source>Note that because we&amp;rsquo;ve used only one generic type to define &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt;, this definition says that the &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; struct is generic over some type &lt;code&gt;T&lt;/code&gt;, and the fields &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are &lt;em&gt;both&lt;/em&gt; that same type, whatever that type may be. If we create an instance of a &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; that has values of different types, as in Listing 10-7, our code won&amp;rsquo;t compile.</source>
          <target state="translated">Tenga en cuenta que debido a que hemos utilizado s&amp;oacute;lo un tipo gen&amp;eacute;rico para definir &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; , esta definici&amp;oacute;n dice que el &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; struct es gen&amp;eacute;rico sobre alg&amp;uacute;n tipo &lt;code&gt;T&lt;/code&gt; , y los campos &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; son &lt;em&gt;ambos&lt;/em&gt; el mismo tipo, lo que ese tipo de tal vez. Si creamos una instancia de &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; que tiene valores de diferentes tipos, como en el Listado 10-7, nuestro c&amp;oacute;digo no se compilar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="ee83d2a98a726eb4d0819a08ff35a51d203bcc33" translate="yes" xml:space="preserve">
          <source>Note that capturing a backtrace can be an expensive operation on some platforms, so this should be used with caution in performance-sensitive parts of code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b44ef6f5d455a7524a366399e247106ccce266f" translate="yes" xml:space="preserve">
          <source>Note that dropping a &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; will never call &lt;code&gt;T&lt;/code&gt;'s drop code. It is your responsibility to make sure &lt;code&gt;T&lt;/code&gt; gets dropped if it got initialized.</source>
          <target state="translated">Tenga en cuenta que soltar un &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; nunca llamar&amp;aacute; al c&amp;oacute;digo de ca&amp;iacute;da de &lt;code&gt;T&lt;/code&gt; .Es su responsabilidad asegurarse de que &lt;code&gt;T&lt;/code&gt; se elimine si se inicializ&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="1ca6aa2552d35e463ab42d6ea3dc8e136eb4776f" translate="yes" xml:space="preserve">
          <source>Note that due to method call deref coercion, simply calling a trait method will act like they work on references as well as they do on owned values! The implementations described here are meant for generic contexts, where the final type &lt;code&gt;T&lt;/code&gt; is a type parameter or otherwise not locally known.</source>
          <target state="translated">Tenga en cuenta que debido a la coerci&amp;oacute;n deref de la llamada al m&amp;eacute;todo, &amp;iexcl;simplemente llamar a un m&amp;eacute;todo de rasgo actuar&amp;aacute; como si funcionaran en referencias tan bien como lo hacen en valores propios! Las implementaciones descritas aqu&amp;iacute; est&amp;aacute;n pensadas para contextos gen&amp;eacute;ricos, donde el tipo final &lt;code&gt;T&lt;/code&gt; es un par&amp;aacute;metro de tipo o no es conocido localmente.</target>
        </trans-unit>
        <trans-unit id="1de74eaeec2a2aa72b741e1bb4ba4ee5991fbccf" translate="yes" xml:space="preserve">
          <source>Note that empty arrays &lt;code&gt;[T; 0]&lt;/code&gt; have the same alignment requirement as the element type &lt;code&gt;T&lt;/code&gt;. Also note that the error is conservatively reported even when the alignment of the zero-sized type is less than or equal to the data field's alignment.</source>
          <target state="translated">Tenga en cuenta que las matrices vac&amp;iacute;as &lt;code&gt;[T; 0]&lt;/code&gt; tiene el mismo requisito de alineaci&amp;oacute;n tal como el tipo de elemento &lt;code&gt;T&lt;/code&gt; . Tambi&amp;eacute;n tenga en cuenta que el error se informa de forma conservadora incluso cuando la alineaci&amp;oacute;n del tipo de tama&amp;ntilde;o cero es menor o igual que la alineaci&amp;oacute;n del campo de datos.</target>
        </trans-unit>
        <trans-unit id="03aca4023a1e7014a85e0b59db326c1054412c53" translate="yes" xml:space="preserve">
          <source>Note that environment variable names are case-insensitive (but case-preserving) on Windows, and case-sensitive on all other platforms.</source>
          <target state="translated">Tenga en cuenta que los nombres de las variables de entorno no distinguen entre mayúsculas y minúsculas (pero sí entre mayúsculas y minúsculas)en Windows,y entre mayúsculas y minúsculas en todas las demás plataformas.</target>
        </trans-unit>
        <trans-unit id="af3176ad62da7d96f31254f9c337151434d91850" translate="yes" xml:space="preserve">
          <source>Note that even if &lt;code&gt;T&lt;/code&gt; has size &lt;code&gt;0&lt;/code&gt;, the pointer must be non-NULL and properly aligned.</source>
          <target state="translated">Tenga en cuenta que incluso si &lt;code&gt;T&lt;/code&gt; tiene tama&amp;ntilde;o &lt;code&gt;0&lt;/code&gt; , el puntero debe ser no NULL y estar correctamente alineado.</target>
        </trans-unit>
        <trans-unit id="58d2d77f2d5d331bda29fe5d0af29fd62177b001" translate="yes" xml:space="preserve">
          <source>Note that even if &lt;code&gt;T&lt;/code&gt; has size &lt;code&gt;0&lt;/code&gt;, the pointer must be non-NULL.</source>
          <target state="translated">Tenga en cuenta que incluso si &lt;code&gt;T&lt;/code&gt; tiene un tama&amp;ntilde;o &lt;code&gt;0&lt;/code&gt; , el puntero no debe ser NULL.</target>
        </trans-unit>
        <trans-unit id="aca2272e34501c47a8d86a387930c81a45160055" translate="yes" xml:space="preserve">
          <source>Note that even if &lt;code&gt;T&lt;/code&gt; has size &lt;code&gt;0&lt;/code&gt;, the pointers must be non-NULL and properly aligned.</source>
          <target state="translated">Tenga en cuenta que incluso si &lt;code&gt;T&lt;/code&gt; tiene tama&amp;ntilde;o &lt;code&gt;0&lt;/code&gt; , los punteros deben ser no NULL y estar alineados correctamente.</target>
        </trans-unit>
        <trans-unit id="9806a4590799343d8c64ae41117a4958b8386ffa" translate="yes" xml:space="preserve">
          <source>Note that even if the effectively copied size (&lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt;) is &lt;code&gt;0&lt;/code&gt;, the pointer must be non-NULL and properly aligned.</source>
          <target state="translated">Tenga en cuenta que incluso si el tama&amp;ntilde;o efectivamente copiado ( &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; ) es &lt;code&gt;0&lt;/code&gt; , el puntero debe ser no NULL y estar alineado correctamente.</target>
        </trans-unit>
        <trans-unit id="851cd0d9eb90b03ed21845664c6d4ace9ece4acd" translate="yes" xml:space="preserve">
          <source>Note that even if the effectively copied size (&lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt;) is &lt;code&gt;0&lt;/code&gt;, the pointers must be non-NULL and properly aligned.</source>
          <target state="translated">Tenga en cuenta que incluso si el tama&amp;ntilde;o efectivamente copiado ( &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; ) es &lt;code&gt;0&lt;/code&gt; , los punteros deben ser no NULL y estar correctamente alineados.</target>
        </trans-unit>
        <trans-unit id="6c1ad3562574888b0c8c8e999ed33eff7030ffcd" translate="yes" xml:space="preserve">
          <source>Note that even if this panics, the value is considered to be dropped; you must not cause &lt;code&gt;drop&lt;/code&gt; to be called again. This is normally automatically handled by the compiler, but when using unsafe code, can sometimes occur unintentionally, particularly when using &lt;a href=&quot;../ptr/fn.drop_in_place&quot;&gt;&lt;code&gt;ptr::drop_in_place&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e70094585dad750582f0b20dfaa8a3722d32400a" translate="yes" xml:space="preserve">
          <source>Note that even though the standard library contains a definition for &lt;code&gt;IpAddr&lt;/code&gt;, we can still create and use our own definition without conflict because we haven&amp;rsquo;t brought the standard library&amp;rsquo;s definition into our scope. We&amp;rsquo;ll talk more about bringing types into scope in Chapter 7.</source>
          <target state="translated">Tenga en cuenta que aunque la biblioteca est&amp;aacute;ndar contiene una definici&amp;oacute;n para &lt;code&gt;IpAddr&lt;/code&gt; , a&amp;uacute;n podemos crear y usar nuestra propia definici&amp;oacute;n sin conflicto porque no hemos tra&amp;iacute;do la definici&amp;oacute;n de la biblioteca est&amp;aacute;ndar a nuestro alcance. Hablaremos m&amp;aacute;s sobre c&amp;oacute;mo incorporar los tipos al alcance en el Cap&amp;iacute;tulo 7.</target>
        </trans-unit>
        <trans-unit id="31c2c0947f08a70cf66a5f5539b0e2dc387b144b" translate="yes" xml:space="preserve">
          <source>Note that future platforms may be added that also do not have support for some atomic operations. Maximally portable code will want to be careful about which atomic types are used. &lt;code&gt;AtomicUsize&lt;/code&gt; and &lt;code&gt;AtomicIsize&lt;/code&gt; are generally the most portable, but even then they're not available everywhere. For reference, the &lt;code&gt;std&lt;/code&gt; library requires pointer-sized atomics, although &lt;code&gt;core&lt;/code&gt; does not.</source>
          <target state="translated">Tenga en cuenta que es posible que se agreguen plataformas futuras que tampoco tengan soporte para algunas operaciones at&amp;oacute;micas. El c&amp;oacute;digo de m&amp;aacute;xima portabilidad querr&amp;aacute; tener cuidado con los tipos at&amp;oacute;micos que se utilizan. &lt;code&gt;AtomicUsize&lt;/code&gt; y &lt;code&gt;AtomicIsize&lt;/code&gt; son generalmente los m&amp;aacute;s port&amp;aacute;tiles, pero aun as&amp;iacute; no est&amp;aacute;n disponibles en todas partes. Como referencia, la biblioteca &lt;code&gt;std&lt;/code&gt; requiere atomics del tama&amp;ntilde;o de un puntero, aunque el &lt;code&gt;core&lt;/code&gt; no lo hace.</target>
        </trans-unit>
        <trans-unit id="59fbfedac3227479331b23c365329ce5aabd1a1b" translate="yes" xml:space="preserve">
          <source>Note that generic arguments for enum variant constructors go after the variant, not after the enum. For example, you would write &lt;code&gt;Option::None::&amp;lt;u32&amp;gt;&lt;/code&gt;, rather than &lt;code&gt;Option::&amp;lt;u32&amp;gt;::None&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que los argumentos gen&amp;eacute;ricos para los constructores de variantes de enumeraci&amp;oacute;n van despu&amp;eacute;s de la variante, no despu&amp;eacute;s de la enumeraci&amp;oacute;n. Por ejemplo, escribir&amp;iacute;a &lt;code&gt;Option::None::&amp;lt;u32&amp;gt;&lt;/code&gt; , en lugar de &lt;code&gt;Option::&amp;lt;u32&amp;gt;::None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6e3284112fc89aa89918b12b076295886a2da9b" translate="yes" xml:space="preserve">
          <source>Note that here the call to &lt;a href=&quot;mem/fn.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; is for clarity - it indicates that we are done with the given value and it should be destroyed.</source>
          <target state="translated">Tenga en cuenta que aqu&amp;iacute; la llamada a &lt;a href=&quot;mem/fn.drop&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt; es para mayor claridad: indica que hemos terminado con el valor dado y debe ser destruido.</target>
        </trans-unit>
        <trans-unit id="0753b6373f6f1d65a2eb747fb24056dce4b9d211" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;Self::Item&lt;/code&gt; is only &lt;code&gt;PartialOrd&lt;/code&gt;, but not &lt;code&gt;Ord&lt;/code&gt;, the above definition implies that this function returns &lt;code&gt;false&lt;/code&gt; if any two consecutive items are not comparable.</source>
          <target state="translated">Tenga en cuenta que si &lt;code&gt;Self::Item&lt;/code&gt; es solo &lt;code&gt;PartialOrd&lt;/code&gt; , pero no &lt;code&gt;Ord&lt;/code&gt; , la definici&amp;oacute;n anterior implica que esta funci&amp;oacute;n devuelve &lt;code&gt;false&lt;/code&gt; si dos elementos consecutivos no son comparables.</target>
        </trans-unit>
        <trans-unit id="b91bc8063fbfefef1d18b41e7b347e2c6fec2abd" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; both point to the same file, then the file will likely get truncated by this operation.</source>
          <target state="translated">Tenga en cuenta que si &lt;code&gt;from&lt;/code&gt; y &lt;code&gt;to&lt;/code&gt; ambos apuntan al mismo archivo, es probable que esta operaci&amp;oacute;n lo trunque.</target>
        </trans-unit>
        <trans-unit id="9d3e37ab6666f6f897eee8b56db717458b005ac3" translate="yes" xml:space="preserve">
          <source>Note that if a function takes multiple type arguments but you want the compiler to infer some of them, you can use type placeholders:</source>
          <target state="translated">Tenga en cuenta que si una función toma múltiples argumentos de tipo pero quiere que el compilador infiera algunos de ellos,puede usar marcadores de tipo:</target>
        </trans-unit>
        <trans-unit id="cd535d6f6d4b53f3c244d297f7914a6181acf961" translate="yes" xml:space="preserve">
          <source>Note that if the &lt;code&gt;static&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt; items include function or closure references, which themselves include references, the compiler will first try the standard elision rules. If it is unable to resolve the lifetimes by its usual rules, then it will error. By way of example:</source>
          <target state="translated">Tenga en cuenta que si la &lt;code&gt;static&lt;/code&gt; o &lt;code&gt;const&lt;/code&gt; antes incluyen referencias de funci&amp;oacute;n o cierre, que a su vez incluyen referencias, el compilador probar&amp;aacute; primero las reglas de elisi&amp;oacute;n est&amp;aacute;ndar. Si no puede resolver las duraciones seg&amp;uacute;n sus reglas habituales, se producir&amp;aacute; un error. A modo de ejemplo:</target>
        </trans-unit>
        <trans-unit id="9ef199153d75a42174c42cff6fb7c6c1476957fd" translate="yes" xml:space="preserve">
          <source>Note that implementations do not necessarily have to provide access to the inner-most source of a pipeline. A stateful intermediate adapter might eagerly evaluate a part of the pipeline and expose its internal storage as source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0702815af49297e37a4e0bb02d65562e392c8a7" translate="yes" xml:space="preserve">
          <source>Note that in Rust, structs can only contain an unsized type if the field containing the unsized type is the last and only unsized type field in the struct.</source>
          <target state="translated">Obsérvese que en Rust,las estructuras sólo pueden contener un tipo sin tamaño si el campo que contiene el tipo sin tamaño es el último y único campo de tipo sin tamaño de la estructura.</target>
        </trans-unit>
        <trans-unit id="523c7fb2b8819c356a6b0490b2a0d8371495e11f" translate="yes" xml:space="preserve">
          <source>Note that in some languages and test frameworks, the parameters to the functions that assert two values are equal are called &lt;code&gt;expected&lt;/code&gt; and &lt;code&gt;actual&lt;/code&gt;, and the order in which we specify the arguments matters. However, in Rust, they&amp;rsquo;re called &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt;, and the order in which we specify the value we expect and the value that the code under test produces doesn&amp;rsquo;t matter. We could write the assertion in this test as &lt;code&gt;assert_eq!(add_two(2), 4)&lt;/code&gt;, which would result in a failure message that displays &lt;code&gt;assertion failed: `(left == right)`&lt;/code&gt; and that &lt;code&gt;left&lt;/code&gt; was &lt;code&gt;5&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; was &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que en algunos lenguajes y marcos de prueba, los par&amp;aacute;metros de las funciones que afirman que dos valores son iguales se denominan &lt;code&gt;expected&lt;/code&gt; y &lt;code&gt;actual&lt;/code&gt; , y el orden en el que especificamos los argumentos es importante. Sin embargo, en Rust, se llaman &lt;code&gt;left&lt;/code&gt; y &lt;code&gt;right&lt;/code&gt; , y el orden en el que especificamos el valor que esperamos y el valor que produce el c&amp;oacute;digo bajo prueba no importa. Podr&amp;iacute;amos escribir la aserci&amp;oacute;n en esta prueba como &lt;code&gt;assert_eq!(add_two(2), 4)&lt;/code&gt; , lo que dar&amp;iacute;a como resultado un mensaje de falla que muestra la &lt;code&gt;assertion failed: `(left == right)`&lt;/code&gt; y que la &lt;code&gt;left&lt;/code&gt; era &lt;code&gt;5&lt;/code&gt; y la &lt;code&gt;right&lt;/code&gt; era &lt;code&gt;4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd234e5e31b58a835a7427c6ccb9ea99860e96d4" translate="yes" xml:space="preserve">
          <source>Note that introducing another &lt;code&gt;struct&lt;/code&gt; just to have a place for the other attributes may have unintended side effects on the representation:</source>
          <target state="translated">Tenga en cuenta que la introducci&amp;oacute;n de otro &lt;code&gt;struct&lt;/code&gt; solo para tener un lugar para los otros atributos puede tener efectos secundarios no deseados en la representaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="6abfc6c98c1133dd19e39dfc110c77706058a67e" translate="yes" xml:space="preserve">
          <source>Note that it is impossible to link in native dynamic dependencies to a static library, and in this case warnings will be printed about all unlinked native dynamic dependencies.</source>
          <target state="translated">Obsérvese que es imposible vincular las dependencias dinámicas nativas a una biblioteca estática,y en este caso se imprimirán advertencias sobre todas las dependencias dinámicas nativas no vinculadas.</target>
        </trans-unit>
        <trans-unit id="213f52c82816211eed8a84af1c6306ce11d2042d" translate="yes" xml:space="preserve">
          <source>Note that it isn&amp;rsquo;t possible to call the default implementation from an overriding implementation of that same method.</source>
          <target state="translated">Tenga en cuenta que no es posible llamar a la implementaci&amp;oacute;n predeterminada desde una implementaci&amp;oacute;n predominante de ese mismo m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="431dfb333d11627033bd73c3c12aac0f9ce02166" translate="yes" xml:space="preserve">
          <source>Note that length of a stream can change over time (for example, when data is appended to a file). So calling this method multiple times does not necessarily return the same length each time.</source>
          <target state="translated">Obsérvese que la longitud de una corriente puede cambiar con el tiempo (por ejemplo,cuando se añaden datos a un archivo).Por lo tanto,llamar a este método varias veces no necesariamente devuelve la misma longitud cada vez.</target>
        </trans-unit>
        <trans-unit id="313ba1495decd5683c08865a1c2d8bbad489994a" translate="yes" xml:space="preserve">
          <source>Note that negating any positive integer will overflow.</source>
          <target state="translated">Tengan en cuenta que negar cualquier número entero positivo se desbordará.</target>
        </trans-unit>
        <trans-unit id="0310d257cad5180cd2a5706628685feb28fa8baa" translate="yes" xml:space="preserve">
          <source>Note that no other normalization takes place; in particular, &lt;code&gt;a/c&lt;/code&gt; and &lt;code&gt;a/b/../c&lt;/code&gt; are distinct, to account for the possibility that &lt;code&gt;b&lt;/code&gt; is a symbolic link (so its parent isn't &lt;code&gt;a&lt;/code&gt;).</source>
          <target state="translated">Tenga en cuenta que no se produce ninguna otra normalizaci&amp;oacute;n; en particular, &lt;code&gt;a/c&lt;/code&gt; y &lt;code&gt;a/b/../c&lt;/code&gt; son distintos, para tener en cuenta la posibilidad de que &lt;code&gt;b&lt;/code&gt; es un enlace simb&amp;oacute;lico (por lo que su padre no es &lt;code&gt;a&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0f36d8aec30ccdcaddeba64d187fcf335e3e550e" translate="yes" xml:space="preserve">
          <source>Note that not all errors contain a &lt;code&gt;Backtrace&lt;/code&gt;. Also note that a &lt;code&gt;Backtrace&lt;/code&gt; may actually be empty. For more information consult the &lt;code&gt;Backtrace&lt;/code&gt; type itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6048f485eb4e07bdf2aa23e3dab346aa63dbf7f5" translate="yes" xml:space="preserve">
          <source>Note that not all platforms will keep this field update in a file's metadata, for example Windows has an option to disable updating this time when files are accessed and Linux similarly has &lt;code&gt;noatime&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que no todas las plataformas mantendr&amp;aacute;n esta actualizaci&amp;oacute;n de campo en los metadatos de un archivo, por ejemplo, Windows tiene una opci&amp;oacute;n para deshabilitar la actualizaci&amp;oacute;n esta vez cuando se accede a los archivos y Linux de manera similar tiene &lt;code&gt;noatime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5ed45efedb5980a8a1a6af222c209c849963838" translate="yes" xml:space="preserve">
          <source>Note that nowhere in this output do we see &lt;code&gt;I got the value 4&lt;/code&gt;, which is what is printed when the test that passes runs. That output has been captured. The output from the test that failed, &lt;code&gt;I got the value 8&lt;/code&gt;, appears in the section of the test summary output, which also shows the cause of the test failure.</source>
          <target state="translated">Tenga en cuenta que en ninguna parte de esta salida vemos &lt;code&gt;I got the value 4&lt;/code&gt; , que es lo que se imprime cuando se ejecuta la prueba que pasa. Esa salida ha sido capturada. El resultado de la prueba que fall&amp;oacute;, &lt;code&gt;I got the value 8&lt;/code&gt; , aparece en la secci&amp;oacute;n de la salida de resumen de la prueba, que tambi&amp;eacute;n muestra la causa de la falla de la prueba.</target>
        </trans-unit>
        <trans-unit id="5a80c5201601b7cd22253cd99d33bff329ba0af9" translate="yes" xml:space="preserve">
          <source>Note that on multiple calls to &lt;code&gt;poll&lt;/code&gt;, only the &lt;a href=&quot;../task/struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; from the &lt;a href=&quot;../task/struct.context&quot;&gt;&lt;code&gt;Context&lt;/code&gt;&lt;/a&gt; passed to the most recent call should be scheduled to receive a wakeup.</source>
          <target state="translated">Tenga en cuenta que en varias llamadas para &lt;code&gt;poll&lt;/code&gt; , solo el &lt;a href=&quot;../task/struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt; del &lt;a href=&quot;../task/struct.context&quot;&gt; &lt;code&gt;Context&lt;/code&gt; &lt;/a&gt; pasado a la llamada m&amp;aacute;s reciente debe programarse para recibir un despertador.</target>
        </trans-unit>
        <trans-unit id="55bd215fbbafcd54535dc669556609d05462d431" translate="yes" xml:space="preserve">
          <source>Note that one cannot pass &lt;code&gt;CannotReallocInPlace&lt;/code&gt; to the &lt;code&gt;handle_alloc_error&lt;/code&gt; function; clients are expected either to be able to recover from &lt;code&gt;grow_in_place&lt;/code&gt; failures without aborting, or to fall back on another reallocation method before resorting to an abort.</source>
          <target state="translated">Tenga en cuenta que no se puede pasar &lt;code&gt;CannotReallocInPlace&lt;/code&gt; a la funci&amp;oacute;n &lt;code&gt;handle_alloc_error&lt;/code&gt; ; Se espera que los clientes puedan recuperarse de &lt;code&gt;grow_in_place&lt;/code&gt; fallas de grow_in_place sin abortar, o recurrir a otro m&amp;eacute;todo de reasignaci&amp;oacute;n antes de recurrir a un aborto.</target>
        </trans-unit>
        <trans-unit id="b9605ecaf6269fd2f9ec9b6cd8fec45c27c798c5" translate="yes" xml:space="preserve">
          <source>Note that one cannot pass &lt;code&gt;CannotReallocInPlace&lt;/code&gt; to the &lt;code&gt;handle_alloc_error&lt;/code&gt; function; clients are expected either to be able to recover from &lt;code&gt;shrink_in_place&lt;/code&gt; failures without aborting, or to fall back on another reallocation method before resorting to an abort.</source>
          <target state="translated">Tenga en cuenta que no se puede pasar &lt;code&gt;CannotReallocInPlace&lt;/code&gt; a la funci&amp;oacute;n &lt;code&gt;handle_alloc_error&lt;/code&gt; ; se espera que los clientes puedan recuperarse de &lt;code&gt;shrink_in_place&lt;/code&gt; fallas de sin abortar, o recurrir a otro m&amp;eacute;todo de reasignaci&amp;oacute;n antes de recurrir a un aborto.</target>
        </trans-unit>
        <trans-unit id="b6bbee529e21d8d6f27eb0394a352b9a59dfbecb" translate="yes" xml:space="preserve">
          <source>Note that panics in Rust are not always implemented via unwinding, but they may be implemented by aborting the process. If this function is called when panics are implemented this way then this function will abort the process, not trigger an unwind.</source>
          <target state="translated">Obsérvese que los pánicos en el óxido no siempre se implementan por medio del desenrollado,sino que pueden implementarse abortando el proceso.Si se llama a esta función cuando los pánicos se implementan de esta manera,entonces esta función abortará el proceso,no desencadenará un desenrollado.</target>
        </trans-unit>
        <trans-unit id="5e3c061738b40532446b85ef7e5e80f755eaa54c" translate="yes" xml:space="preserve">
          <source>Note that parts of this block are in use:</source>
          <target state="translated">Observe que algunas partes de este bloque están en uso:</target>
        </trans-unit>
        <trans-unit id="fff05e35d755803ade4b50f50d29c987f0007787" translate="yes" xml:space="preserve">
          <source>Note that pinning and &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; only affect the pointed-to type &lt;code&gt;P::Target&lt;/code&gt;, not the pointer type &lt;code&gt;P&lt;/code&gt; itself that got wrapped in &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt;. For example, whether or not &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; has no effect on the behavior of &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; (here, &lt;code&gt;T&lt;/code&gt; is the pointed-to type).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8df6e9ecf182c2febaad6a991ebf5bacd1fab01f" translate="yes" xml:space="preserve">
          <source>Note that pinning and &lt;code&gt;Unpin&lt;/code&gt; only affect the pointed-to type &lt;code&gt;P::Target&lt;/code&gt;, not the pointer type &lt;code&gt;P&lt;/code&gt; itself that got wrapped in &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;. For example, whether or not &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;Unpin&lt;/code&gt; has no effect on the behavior of &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; (here, &lt;code&gt;T&lt;/code&gt; is the pointed-to type).</source>
          <target state="translated">Tenga en cuenta que anclar y &lt;code&gt;Unpin&lt;/code&gt; solo afectan al tipo &lt;code&gt;P::Target&lt;/code&gt; apuntado, no al tipo de puntero &lt;code&gt;P&lt;/code&gt; en s&amp;iacute; que se envolvi&amp;oacute; en &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; . Por ejemplo, si &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; es &lt;code&gt;Unpin&lt;/code&gt; o no, no tiene ning&amp;uacute;n efecto en el comportamiento de &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; (aqu&amp;iacute;, &lt;code&gt;T&lt;/code&gt; es el tipo apuntado).</target>
        </trans-unit>
        <trans-unit id="2fe7274dabcb32334d2b65bc1dce4238c4a816f1" translate="yes" xml:space="preserve">
          <source>Note that reading updates the slice to point to the yet unread part. The slice will be empty when EOF is reached.</source>
          <target state="translated">Note que la lectura actualiza la rebanada para apuntar a la parte aún no leída.El trozo estará vacío cuando se alcance el EOF.</target>
        </trans-unit>
        <trans-unit id="4175de8081524003025f4bfc586324edc516ca55" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;a href=&quot;../../../fs/struct.file#method.read&quot;&gt;&lt;code&gt;File::read&lt;/code&gt;&lt;/a&gt;, it is not an error to return with a short read.</source>
          <target state="translated">Tenga en cuenta que similar a &lt;a href=&quot;../../../fs/struct.file#method.read&quot;&gt; &lt;code&gt;File::read&lt;/code&gt; &lt;/a&gt; , no es un error volver con una lectura corta.</target>
        </trans-unit>
        <trans-unit id="78d8286e3fe0bd2fe84e388fefe8408d278761d1" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;a href=&quot;../../../fs/struct.file#method.write&quot;&gt;&lt;code&gt;File::write&lt;/code&gt;&lt;/a&gt;, it is not an error to return a short write.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18a21f083a37ce3c0667ef89806f56b48c052291" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;a href=&quot;../../../fs/struct.file#write.v&quot;&gt;&lt;code&gt;File::write&lt;/code&gt;&lt;/a&gt;, it is not an error to return a short write.</source>
          <target state="translated">Tenga en cuenta que similar a &lt;a href=&quot;../../../fs/struct.file#write.v&quot;&gt; &lt;code&gt;File::write&lt;/code&gt; &lt;/a&gt; , no es un error devolver una escritura corta.</target>
        </trans-unit>
        <trans-unit id="c9ab4b26c6a7bf726c988738e7c68f1f0c9fa972" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;code&gt;File::read&lt;/code&gt;, it is not an error to return with a short read. When returning from such a short read, the file pointer is still updated.</source>
          <target state="translated">Tenga en cuenta que similar a &lt;code&gt;File::read&lt;/code&gt; , no es un error volver con una lectura corta. Al regresar de una lectura tan corta, el puntero del archivo a&amp;uacute;n se actualiza.</target>
        </trans-unit>
        <trans-unit id="1f1bfbbca00b5726c71935536de215a864a82741" translate="yes" xml:space="preserve">
          <source>Note that similar to &lt;code&gt;File::write&lt;/code&gt;, it is not an error to return a short write. When returning from such a short write, the file pointer is still updated.</source>
          <target state="translated">Tenga en cuenta que al igual que &lt;code&gt;File::write&lt;/code&gt; , no es un error devolver una escritura corta. Al regresar de una escritura tan corta, el puntero del archivo a&amp;uacute;n se actualiza.</target>
        </trans-unit>
        <trans-unit id="eea44851a548460d198f033df0aa2c78011af765" translate="yes" xml:space="preserve">
          <source>Note that some platforms may simply implement this in terms of &lt;a href=&quot;struct.file#method.sync_all&quot;&gt;&lt;code&gt;sync_all&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Tenga en cuenta que algunas plataformas pueden simplemente implementar esto en t&amp;eacute;rminos de &lt;a href=&quot;struct.file#method.sync_all&quot;&gt; &lt;code&gt;sync_all&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="903a64802e8ba87174caa993876c0922efd29b51" translate="yes" xml:space="preserve">
          <source>Note that stdout is frequently line-buffered by default so it may be necessary to use &lt;a href=&quot;io/trait.write#tymethod.flush&quot;&gt;&lt;code&gt;io::stdout().flush()&lt;/code&gt;&lt;/a&gt; to ensure the output is emitted immediately.</source>
          <target state="translated">Tenga en cuenta que stdout con frecuencia se almacena en b&amp;uacute;fer de l&amp;iacute;nea de forma predeterminada, por lo que puede ser necesario usar &lt;a href=&quot;io/trait.write#tymethod.flush&quot;&gt; &lt;code&gt;io::stdout().flush()&lt;/code&gt; &lt;/a&gt; para garantizar que la salida se emita inmediatamente.</target>
        </trans-unit>
        <trans-unit id="b78b962ade7d55d80fe60c36c51b53741b559cf7" translate="yes" xml:space="preserve">
          <source>Note that thanks to Rust's safety guarantees, accessing global (static) variables requires &lt;code&gt;unsafe&lt;/code&gt; code, assuming we don't use any of the synchronization primitives in this module.</source>
          <target state="translated">Tenga en cuenta que gracias a las garant&amp;iacute;as de seguridad de Rust, el acceso a las variables globales (est&amp;aacute;ticos) requiere &lt;code&gt;unsafe&lt;/code&gt; c&amp;oacute;digo , asumiendo que no usamos ninguna de las primitivas de sincronizaci&amp;oacute;n en este m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="7e334bbf7d2932e1e0dab50b1bbb42d3e778d93e" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; operators short-circuit, i.e., they only evaluate their second operand if it contributes to the result. Since this behavior is not enforceable by traits, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; are not supported as overloadable operators.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; y &lt;code&gt;||&lt;/code&gt; los operadores cortocircuitan, es decir, solo eval&amp;uacute;an su segundo operando si contribuye al resultado. Dado que este comportamiento no se puede hacer cumplir por rasgos, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; y &lt;code&gt;||&lt;/code&gt; no se admiten como operadores sobrecargables.</target>
        </trans-unit>
        <trans-unit id="eabb54c531ee493a23016d47151401e59c37e082" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;*&lt;/code&gt; operator is replaced with a call to the &lt;code&gt;deref&lt;/code&gt; method and then a call to the &lt;code&gt;*&lt;/code&gt; operator just once, each time we use a &lt;code&gt;*&lt;/code&gt; in our code. Because the substitution of the &lt;code&gt;*&lt;/code&gt; operator does not recurse infinitely, we end up with data of type &lt;code&gt;i32&lt;/code&gt;, which matches the &lt;code&gt;5&lt;/code&gt; in &lt;code&gt;assert_eq!&lt;/code&gt; in Listing 15-9.</source>
          <target state="translated">Tenga en cuenta que el operador &lt;code&gt;*&lt;/code&gt; se reemplaza con una llamada al m&amp;eacute;todo &lt;code&gt;deref&lt;/code&gt; y luego una llamada al operador &lt;code&gt;*&lt;/code&gt; solo una vez, cada vez que usamos un &lt;code&gt;*&lt;/code&gt; en nuestro c&amp;oacute;digo. Debido a que la sustituci&amp;oacute;n del operador &lt;code&gt;*&lt;/code&gt; no se repite infinitamente, terminamos con datos de tipo &lt;code&gt;i32&lt;/code&gt; , &amp;iexcl;que coincide con el &lt;code&gt;5&lt;/code&gt; en &lt;code&gt;assert_eq!&lt;/code&gt; en el Listado 15-9.</target>
        </trans-unit>
        <trans-unit id="42a41979051d804f1901f27167063da0694efa1d" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;Backtrace::force_capture&lt;/code&gt; function can be used to ignore these environment variables. Also note that the state of environment variables is cached once the first backtrace is created, so altering &lt;code&gt;RUST_LIB_BACKTRACE&lt;/code&gt; or &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; at runtime may not actually change how backtraces are captured.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c6dbff824203032252330e130f2e622a82a7979" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;FromFn&lt;/code&gt; iterator doesn&amp;rsquo;t make assumptions about the behavior of the closure, and therefore conservatively does not implement &lt;a href=&quot;trait.fusediterator&quot;&gt;&lt;code&gt;FusedIterator&lt;/code&gt;&lt;/a&gt;, or override &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;Iterator::size_hint()&lt;/code&gt;&lt;/a&gt; from its default &lt;code&gt;(0, None)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f63b935f8ce4492cffe03bd17e920a6c5bccf71" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;FromFn&lt;/code&gt; iterator doesn&amp;rsquo;t make assumptions about the behavior of the closure, and therefore conservatively does not implement &lt;a href=&quot;trait.fusediterator&quot;&gt;&lt;code&gt;FusedIterator&lt;/code&gt;&lt;/a&gt;, or override &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;Iterator::size_hint&lt;/code&gt;&lt;/a&gt; from its default &lt;code&gt;(0, None)&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que el iterador &lt;code&gt;FromFn&lt;/code&gt; no hace suposiciones sobre el comportamiento del cierre y, por lo tanto, de manera conservadora no implementa &lt;a href=&quot;trait.fusediterator&quot;&gt; &lt;code&gt;FusedIterator&lt;/code&gt; &lt;/a&gt; , ni anula &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;Iterator::size_hint&lt;/code&gt; &lt;/a&gt; de su valor predeterminado &lt;code&gt;(0, None)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bea015d687dff2009a1239b5a7393bd8adb473e8" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;PrimaryColor&lt;/code&gt; and &lt;code&gt;SecondaryColor&lt;/code&gt; types aren&amp;rsquo;t listed on the front page, nor is the &lt;code&gt;mix&lt;/code&gt; function. We have to click &lt;code&gt;kinds&lt;/code&gt; and &lt;code&gt;utils&lt;/code&gt; to see them.</source>
          <target state="translated">Tenga en cuenta que los tipos &lt;code&gt;PrimaryColor&lt;/code&gt; y &lt;code&gt;SecondaryColor&lt;/code&gt; no aparecen en la p&amp;aacute;gina principal, ni tampoco la funci&amp;oacute;n de &lt;code&gt;mix&lt;/code&gt; . Tenemos que hacer clic en &lt;code&gt;kinds&lt;/code&gt; y &lt;code&gt;utils&lt;/code&gt; para verlos.</target>
        </trans-unit>
        <trans-unit id="8f49c43ce4bf9debfde5b04db98c0212ba6c8e15" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;SOME_PROPERTY&lt;/code&gt; associated constant would not compile, as its type &lt;code&gt;bool&lt;/code&gt; refers to the struct, rather than to the primitive bool type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="659da6617a0c6362038e0166dcdb0fdd380d7b37" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;black&lt;/code&gt; and &lt;code&gt;origin&lt;/code&gt; values are different types, because they&amp;rsquo;re instances of different tuple structs. Each struct you define is its own type, even though the fields within the struct have the same types. For example, a function that takes a parameter of type &lt;code&gt;Color&lt;/code&gt; cannot take a &lt;code&gt;Point&lt;/code&gt; as an argument, even though both types are made up of three &lt;code&gt;i32&lt;/code&gt; values. Otherwise, tuple struct instances behave like tuples: you can destructure them into their individual pieces, you can use a &lt;code&gt;.&lt;/code&gt; followed by the index to access an individual value, and so on.</source>
          <target state="translated">Tenga en cuenta que los valores de &lt;code&gt;origin&lt;/code&gt; y &lt;code&gt;black&lt;/code&gt; son de diferentes tipos, porque son instancias de diferentes estructuras de tupla. Cada estructura que defina es de su propio tipo, aunque los campos dentro de la estructura tienen los mismos tipos. Por ejemplo, una funci&amp;oacute;n que toma un par&amp;aacute;metro de tipo &lt;code&gt;Color&lt;/code&gt; no puede tomar un &lt;code&gt;Point&lt;/code&gt; como argumento, aunque ambos tipos se componen de tres valores &lt;code&gt;i32&lt;/code&gt; . De lo contrario, las instancias de estructura de tupla se comportan como tuplas: puede desestructurarlas en sus partes individuales, puede usar un archivo &lt;code&gt;.&lt;/code&gt; seguido del &amp;iacute;ndice para acceder a un valor individual, y as&amp;iacute; sucesivamente.</target>
        </trans-unit>
        <trans-unit id="7585cdf9a53bb6203f72700ad7d5c4700090428d" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;internal_adder&lt;/code&gt; function is not marked as &lt;code&gt;pub&lt;/code&gt;, but because tests are just Rust code and the &lt;code&gt;tests&lt;/code&gt; module is just another module, you can bring &lt;code&gt;internal_adder&lt;/code&gt; into a test&amp;rsquo;s scope and call it. If you don&amp;rsquo;t think private functions should be tested, there&amp;rsquo;s nothing in Rust that will compel you to do so.</source>
          <target state="translated">Tenga en cuenta que la funci&amp;oacute;n &lt;code&gt;internal_adder&lt;/code&gt; no est&amp;aacute; marcada como &lt;code&gt;pub&lt;/code&gt; , pero debido a que las pruebas son solo c&amp;oacute;digo de Rust y el m&amp;oacute;dulo de &lt;code&gt;tests&lt;/code&gt; es solo otro m&amp;oacute;dulo, puede traer &lt;code&gt;internal_adder&lt;/code&gt; al alcance de una prueba y llamarlo. Si no cree que las funciones privadas deban probarse, no hay nada en Rust que lo obligue a hacerlo.</target>
        </trans-unit>
        <trans-unit id="1dfcc45249eab2386a4a77c00ed86344264ef031" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;mod common;&lt;/code&gt; declaration is the same as the module declaration we demonstrated in Listing 7-21. Then in the test function, we can call the &lt;code&gt;common::setup()&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2416a0788bd332296b9d3351af29231165e12f7f" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;mod common;&lt;/code&gt; declaration is the same as the module declaration we demonstrated in Listing 7-25. Then in the test function, we can call the &lt;code&gt;common::setup()&lt;/code&gt; function.</source>
          <target state="translated">Tenga en cuenta que el &lt;code&gt;mod common;&lt;/code&gt; La declaraci&amp;oacute;n es la misma que la declaraci&amp;oacute;n del m&amp;oacute;dulo que demostramos en el Listado 7-25. Luego, en la funci&amp;oacute;n de prueba, podemos llamar a la funci&amp;oacute;n &lt;code&gt;common::setup()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b202266f93986284846e418aa656da415bb5e7b" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;pub use crate::front_of_house::hosting&lt;/code&gt; statement in &lt;em&gt;src/lib.rs&lt;/em&gt; also hasn&amp;rsquo;t changed, nor does &lt;code&gt;use&lt;/code&gt; have any impact on what files are compiled as part of the crate. The &lt;code&gt;mod&lt;/code&gt; keyword declares modules, and Rust looks in a file with the same name as the module for the code that goes into that module.</source>
          <target state="translated">Tenga en cuenta que la declaraci&amp;oacute;n &lt;code&gt;pub use crate::front_of_house::hosting&lt;/code&gt; en &lt;em&gt;src / lib.rs&lt;/em&gt; tampoco ha cambiado, ni el &lt;code&gt;use&lt;/code&gt; tiene ning&amp;uacute;n impacto en los archivos que se compilan como parte de la caja. La palabra clave &lt;code&gt;mod&lt;/code&gt; declara m&amp;oacute;dulos, y Rust busca en un archivo con el mismo nombre que el m&amp;oacute;dulo el c&amp;oacute;digo que entra en ese m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="ebf0b34b8114310255f844126e635bca0217f44d" translate="yes" xml:space="preserve">
          <source>Note that the Rust syntax considers &lt;code&gt;-1i8&lt;/code&gt; as an application of the &lt;a href=&quot;expressions/operator-expr#negation-operators&quot;&gt;unary minus operator&lt;/a&gt; to an integer literal &lt;code&gt;1i8&lt;/code&gt;, rather than a single integer literal.</source>
          <target state="translated">Tenga en cuenta que la sintaxis de Rust considera &lt;code&gt;-1i8&lt;/code&gt; como una aplicaci&amp;oacute;n del &lt;a href=&quot;expressions/operator-expr#negation-operators&quot;&gt;operador unario menos&lt;/a&gt; a un literal entero &lt;code&gt;1i8&lt;/code&gt; , en lugar de un solo literal entero.</target>
        </trans-unit>
        <trans-unit id="56aae01ce79d910a619efda10dafe9ed6c6133a8" translate="yes" xml:space="preserve">
          <source>Note that the alignment of the resulting layout will be the maximum of those of &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt;, in order to ensure alignment of both parts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7d6c6c7cc7587fa146a6b97e717ca83d5839bcb" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="translated">Tenga en cuenta que el asignador puede dar a la colecci&amp;oacute;n m&amp;aacute;s espacio del que solicita. Por lo tanto, no se puede confiar en que la capacidad sea precisamente m&amp;iacute;nima. Prefiera &lt;a href=&quot;#method.reserve&quot;&gt; &lt;code&gt;reserve&lt;/code&gt; &lt;/a&gt; si se esperan inserciones futuras.</target>
        </trans-unit>
        <trans-unit id="3c27c4a17236d84a273debe0206e2acee86fe4f0" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;../struct.binaryheap#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b0700ca055cbce179ecc3d9a30bb5baa7a6c28e" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;../struct.vecdeque#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="088614193a26ec5fa144e1468834aa2d40a502e0" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;struct.binaryheap#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e71fe50cc784bf479a83f567c5fb33ac0db88d1d" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer &lt;a href=&quot;struct.vecdeque#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; if future insertions are expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e47a0cb986bfab2cf7630c87b9673550639fc541" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore, capacity can not be relied upon to be precisely minimal. Prefer &lt;code&gt;reserve&lt;/code&gt; if future insertions are expected.</source>
          <target state="translated">Tenga en cuenta que el asignador puede dar a la colecci&amp;oacute;n m&amp;aacute;s espacio del que solicita. Por lo tanto, no se puede confiar en que la capacidad sea precisamente m&amp;iacute;nima. Prefiera &lt;code&gt;reserve&lt;/code&gt; si se esperan inserciones futuras.</target>
        </trans-unit>
        <trans-unit id="a8effc4910252eded99b791d1c4a5c812a34bdf2" translate="yes" xml:space="preserve">
          <source>Note that the allocator may give the collection more space than it requests. Therefore, capacity can not be relied upon to be precisely minimal. Prefer reserve if future insertions are expected.</source>
          <target state="translated">Tenga en cuenta que el asignador puede dar a la colección más espacio del que solicita.Por lo tanto,no se puede confiar en que la capacidad sea precisamente mínima.Prefiera la reserva si se esperan futuras inserciones.</target>
        </trans-unit>
        <trans-unit id="08c862951a6a3b03e0330454b0efc29b2b754947" translate="yes" xml:space="preserve">
          <source>Note that the argument is not passed through a shell, but given literally to the program. This means that shell syntax like quotes, escaped characters, word splitting, glob patterns, substitution, etc. have no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba0769350c5d5d78015e993d43a239511a252097" translate="yes" xml:space="preserve">
          <source>Note that the arguments are not passed through a shell, but given literally to the program. This means that shell syntax like quotes, escaped characters, word splitting, glob patterns, substitution, etc. have no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7c41ef52ce2694587693c73f46ceb1c3c96783c" translate="yes" xml:space="preserve">
          <source>Note that the best effort is made to ensure that the time waited is measured with a monotonic clock, and not affected by the changes made to the system time.</source>
          <target state="translated">Nótese que se hace el mejor esfuerzo para asegurar que el tiempo esperado se mide con un reloj monótono,y que no se ve afectado por los cambios realizados en el tiempo del sistema.</target>
        </trans-unit>
        <trans-unit id="0ef4b3d8d9fa38a1ed8bb900aa8106bdb93d4e77" translate="yes" xml:space="preserve">
          <source>Note that the best effort is made to ensure that the time waited is measured with a monotonic clock, and not affected by the changes made to the system time. This function is susceptible to spurious wakeups. Condition variables normally have a boolean predicate associated with them, and the predicate must always be checked each time this function returns to protect against spurious wakeups. Additionally, it is typically desirable for the time-out to not exceed some duration in spite of spurious wakes, thus the sleep-duration is decremented by the amount slept. Alternatively, use the &lt;code&gt;wait_timeout_until&lt;/code&gt; method to wait until a condition is met with a total time-out regardless of spurious wakes.</source>
          <target state="translated">Tenga en cuenta que se hace el mejor esfuerzo para garantizar que el tiempo esperado se mida con un reloj mon&amp;oacute;tono y no se vea afectado por los cambios realizados en la hora del sistema. Esta funci&amp;oacute;n es susceptible de reactivaciones falsas. Las variables de condici&amp;oacute;n normalmente tienen un predicado booleano asociado, y el predicado siempre debe ser verificado cada vez que esta funci&amp;oacute;n regresa para proteger contra reactivaciones esp&amp;uacute;reas. Adem&amp;aacute;s, normalmente es deseable que el tiempo de espera no exceda cierta duraci&amp;oacute;n a pesar de los despertares espurios, por lo que la duraci&amp;oacute;n del sue&amp;ntilde;o se reduce por la cantidad de sue&amp;ntilde;o. Alternativamente, use el m&amp;eacute;todo &lt;code&gt;wait_timeout_until&lt;/code&gt; para esperar hasta que se cumpla una condici&amp;oacute;n con un tiempo de espera total independientemente de las vigilias espurias.</target>
        </trans-unit>
        <trans-unit id="a6a58cc27a5e657fb0a670643552701080e58296" translate="yes" xml:space="preserve">
          <source>Note that the best effort is made to ensure that the time waited is measured with a monotonic clock, and not affected by the changes made to the system time. This function is susceptible to spurious wakeups. Condition variables normally have a boolean predicate associated with them, and the predicate must always be checked each time this function returns to protect against spurious wakeups. Additionally, it is typically desirable for the timeout to not exceed some duration in spite of spurious wakes, thus the sleep-duration is decremented by the amount slept. Alternatively, use the &lt;code&gt;wait_timeout_while&lt;/code&gt; method to wait with a timeout while a predicate is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f53fcb70ba490adf24ce12bac9972be4901a158" translate="yes" xml:space="preserve">
          <source>Note that the capacity of &lt;code&gt;self&lt;/code&gt; does not change.</source>
          <target state="translated">Tenga en cuenta que la capacidad del &lt;code&gt;self&lt;/code&gt; no cambia.</target>
        </trans-unit>
        <trans-unit id="e939a8d32c47b3615c351b8f5ecdfdb4467cf4dc" translate="yes" xml:space="preserve">
          <source>Note that the entire instance must be mutable; Rust doesn&amp;rsquo;t allow us to mark only certain fields as mutable. As with any expression, we can construct a new instance of the struct as the last expression in the function body to implicitly return that new instance.</source>
          <target state="translated">Tenga en cuenta que toda la instancia debe ser mutable; Rust no nos permite marcar solo ciertos campos como mutables. Como con cualquier expresi&amp;oacute;n, podemos construir una nueva instancia de la estructura como la &amp;uacute;ltima expresi&amp;oacute;n en el cuerpo de la funci&amp;oacute;n para devolver impl&amp;iacute;citamente esa nueva instancia.</target>
        </trans-unit>
        <trans-unit id="893d3a404a478f2bef24f1a4da4b0eecf6cccd02" translate="yes" xml:space="preserve">
          <source>Note that the error here is in the definition of the generic function: Although we only call it with a parameter that does implement &lt;code&gt;Debug&lt;/code&gt;, the compiler still rejects the function: It must work with all possible input types. In order to make this example compile, we need to restrict the generic type we're accepting:</source>
          <target state="translated">Tenga en cuenta que el error aqu&amp;iacute; est&amp;aacute; en la definici&amp;oacute;n de la funci&amp;oacute;n gen&amp;eacute;rica: aunque solo la llamamos con un par&amp;aacute;metro que implementa &lt;code&gt;Debug&lt;/code&gt; , el compilador a&amp;uacute;n rechaza la funci&amp;oacute;n: debe funcionar con todos los tipos de entrada posibles. Para poder compilar este ejemplo, necesitamos restringir el tipo gen&amp;eacute;rico que estamos aceptando:</target>
        </trans-unit>
        <trans-unit id="06b34748b35f43179a334f500ab5063640caf614" translate="yes" xml:space="preserve">
          <source>Note that the expanded results of the input tokens may change in the future. You should be careful if you rely on the output.</source>
          <target state="translated">Tenga en cuenta que los resultados ampliados de las fichas de entrada pueden cambiar en el futuro.Debe tener cuidado si confía en la salida.</target>
        </trans-unit>
        <trans-unit id="b4d3e131a7a31ae2f39a3a9a0dd9a292fd33ee3f" translate="yes" xml:space="preserve">
          <source>Note that the innermost object sets the bound, so &lt;code&gt;&amp;amp;'a Box&amp;lt;dyn Foo&amp;gt;&lt;/code&gt; is still &lt;code&gt;&amp;amp;'a Box&amp;lt;dyn Foo + 'static&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que el objeto m&amp;aacute;s interno establece el l&amp;iacute;mite, por lo que &lt;code&gt;&amp;amp;'a Box&amp;lt;dyn Foo&amp;gt;&lt;/code&gt; sigue siendo &lt;code&gt;&amp;amp;'a Box&amp;lt;dyn Foo + 'static&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20accbf3ad080e6a83efff23cbdda0ba37be7c3a" translate="yes" xml:space="preserve">
          <source>Note that the lowercase dotted 'i' is the same as the Latin. Therefore:</source>
          <target state="translated">Observe que la &quot;i&quot; minúscula punteada es la misma que la del latín.Por lo tanto:</target>
        </trans-unit>
        <trans-unit id="0529503c0b783f1fa295149899ee5a9048a3f3e4" translate="yes" xml:space="preserve">
          <source>Note that the macro is intended as a debugging tool and therefore you should avoid having uses of it in version control for long periods. Use cases involving debug output that should be added to version control are better served by macros such as &lt;a href=&quot;https://docs.rs/log/*/log/macro.debug.html&quot;&gt;&lt;code&gt;debug!&lt;/code&gt;&lt;/a&gt; from the &lt;a href=&quot;https://crates.io/crates/log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; crate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33af38a46c0f54bbd2f36a31035d5f75fa5f8705" translate="yes" xml:space="preserve">
          <source>Note that the macro is intended as a debugging tool and therefore you should avoid having uses of it in version control for longer periods. Use cases involving debug output that should be added to version control are better served by macros such as &lt;a href=&quot;https://docs.rs/log/*/log/macro.debug.html&quot;&gt;&lt;code&gt;debug!&lt;/code&gt;&lt;/a&gt; from the &lt;a href=&quot;https://crates.io/crates/log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; crate.</source>
          <target state="translated">Tenga en cuenta que la macro est&amp;aacute; destinada a ser una herramienta de depuraci&amp;oacute;n y, por lo tanto, debe evitar utilizarla en el control de versiones durante per&amp;iacute;odos m&amp;aacute;s prolongados. Los casos de uso que involucran resultados de depuraci&amp;oacute;n que deber&amp;iacute;an agregarse al control de versiones son mejor atendidos por macros como &lt;a href=&quot;https://docs.rs/log/*/log/macro.debug.html&quot;&gt; &lt;code&gt;debug!&lt;/code&gt; &lt;/a&gt;de la caja de &lt;a href=&quot;https://crates.io/crates/log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f68f549dc0f6cc4029741bd007637b70e59d35a0" translate="yes" xml:space="preserve">
          <source>Note that the output for the tests and the test results are interleaved; the reason is that the tests are running in parallel, as we talked about in the previous section. Try using the &lt;code&gt;--test-threads=1&lt;/code&gt; option and the &lt;code&gt;--nocapture&lt;/code&gt; flag, and see what the output looks like then!</source>
          <target state="translated">Tenga en cuenta que la salida de las pruebas y los resultados de las pruebas est&amp;aacute;n intercalados; la raz&amp;oacute;n es que las pruebas se est&amp;aacute;n ejecutando en paralelo, como hablamos en la secci&amp;oacute;n anterior. Intente usar la &lt;code&gt;--test-threads=1&lt;/code&gt; y la &lt;code&gt;--nocapture&lt;/code&gt; , &amp;iexcl;y vea c&amp;oacute;mo se ve la salida entonces!</target>
        </trans-unit>
        <trans-unit id="a844a8727324231842256b1e8aa12a2943bbaceb" translate="yes" xml:space="preserve">
          <source>Note that the pointer value may potentially represent a valid pointer to a &lt;code&gt;T&lt;/code&gt;, which means this must not be used as a &quot;not yet initialized&quot; sentinel value. Types that lazily allocate must track initialization by some other means.</source>
          <target state="translated">Tenga en cuenta que el valor del puntero puede representar potencialmente un puntero v&amp;aacute;lido a una &lt;code&gt;T&lt;/code&gt; , lo que significa que no debe utilizarse como un valor centinela &quot;a&amp;uacute;n no inicializado&quot;. Los tipos que asignan perezosamente deben realizar un seguimiento de la inicializaci&amp;oacute;n por otros medios.</target>
        </trans-unit>
        <trans-unit id="219a901fc4bbd905770e11b959092de46ce1a4b3" translate="yes" xml:space="preserve">
          <source>Note that the pointer value may potentially represent a valid pointer, which means this must not be used as a &quot;not yet initialized&quot; sentinel value. Types that lazily allocate must track initialization by some other means.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e42d22c3d181aaaed5a33c43a08345afdbe2126" translate="yes" xml:space="preserve">
          <source>Note that the stack size of the main thread is &lt;em&gt;not&lt;/em&gt; determined by Rust.</source>
          <target state="translated">Tenga en cuenta que el tama&amp;ntilde;o de la pila del hilo principal &lt;em&gt;no lo&lt;/em&gt; determina Rust.</target>
        </trans-unit>
        <trans-unit id="5317fa424b787d9e3193b4c178e1e274e73ebdb4" translate="yes" xml:space="preserve">
          <source>Note that the standard library (&lt;code&gt;std&lt;/code&gt;) is also a crate that&amp;rsquo;s external to our package. Because the standard library is shipped with the Rust language, we don&amp;rsquo;t need to change &lt;em&gt;Cargo.toml&lt;/em&gt; to include &lt;code&gt;std&lt;/code&gt;. But we do need to refer to it with &lt;code&gt;use&lt;/code&gt; to bring items from there into our package&amp;rsquo;s scope. For example, with &lt;code&gt;HashMap&lt;/code&gt; we would use this line:</source>
          <target state="translated">Tenga en cuenta que la biblioteca est&amp;aacute;ndar ( &lt;code&gt;std&lt;/code&gt; ) tambi&amp;eacute;n es una caja externa a nuestro paquete. Debido a que la biblioteca est&amp;aacute;ndar se env&amp;iacute;a con el lenguaje Rust, no necesitamos cambiar &lt;em&gt;Cargo.toml&lt;/em&gt; para incluir &lt;code&gt;std&lt;/code&gt; . Pero necesitamos referirnos a &amp;eacute;l con &lt;code&gt;use&lt;/code&gt; para traer elementos desde all&amp;iacute; al alcance de nuestro paquete. Por ejemplo, con &lt;code&gt;HashMap&lt;/code&gt; usar&amp;iacute;amos esta l&amp;iacute;nea:</target>
        </trans-unit>
        <trans-unit id="81d14f271d71ceb8a4e63a395e2c2b18f3026e6e" translate="yes" xml:space="preserve">
          <source>Note that the traits &lt;a href=&quot;../convert/trait.asref&quot;&gt;&lt;code&gt;AsRef&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../convert/trait.asmut&quot;&gt;&lt;code&gt;AsMut&lt;/code&gt;&lt;/a&gt; provide similar methods for types that may not be fixed-size arrays. Implementors should prefer those traits instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="405821d50e551ea851eed49e6fdd0bf01f98b46a" translate="yes" xml:space="preserve">
          <source>Note that the traits AsRef and AsMut provide similar methods for types that may not be fixed-size arrays. Implementors should prefer those traits instead.</source>
          <target state="translated">Obsérvese que los rasgos AsRef y AsMut proporcionan métodos similares para tipos que pueden no ser conjuntos de tamaño fijo.Los implementadores deberían preferir esos rasgos en su lugar.</target>
        </trans-unit>
        <trans-unit id="6289f32f721dc9ae628a24b212ad3154b1e5c872" translate="yes" xml:space="preserve">
          <source>Note that the type of &lt;code&gt;v&lt;/code&gt; can now be inferred from the type of &lt;code&gt;temp&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que el tipo de &lt;code&gt;v&lt;/code&gt; ahora se puede inferir del tipo de &lt;code&gt;temp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6cb7f36bf472ae404403c7eb996727201edfc32d" translate="yes" xml:space="preserve">
          <source>Note that the underlying iterator is still advanced when &lt;a href=&quot;struct.peekable#method.peek&quot;&gt;&lt;code&gt;peek&lt;/code&gt;&lt;/a&gt; is called for the first time: In order to retrieve the next element, &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; is called on the underlying iterator, hence any side effects (i.e. anything other than fetching the next value) of the &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; method will occur.</source>
          <target state="translated">Tenga en cuenta que el iterador subyacente todav&amp;iacute;a est&amp;aacute; avanzado cuando se llama a &lt;a href=&quot;struct.peekable#method.peek&quot;&gt; &lt;code&gt;peek&lt;/code&gt; &lt;/a&gt; por primera vez: para recuperar el siguiente elemento, se llama a &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; en el iterador subyacente, por lo tanto, cualquier efecto secundario (es decir, cualquier cosa que no sea obtener el siguiente valor) del &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; ocurrir&amp;aacute; el m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="5e9890cf8ac181c5bdc0d2e127263d39bf20f96f" translate="yes" xml:space="preserve">
          <source>Note that the utility of the returned value requires &lt;code&gt;align&lt;/code&gt; to be less than or equal to the alignment of the starting address for the whole allocated block of memory. One way to satisfy this constraint is to ensure &lt;code&gt;align &amp;lt;= self.align()&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que la utilidad del valor devuelto requiere que la &lt;code&gt;align&lt;/code&gt; sea ​​menor o igual que la alineaci&amp;oacute;n de la direcci&amp;oacute;n inicial para todo el bloque de memoria asignado. Una forma de satisfacer esta restricci&amp;oacute;n es asegurarse de que &lt;code&gt;align &amp;lt;= self.align()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d911cb36c04dcf8463355e9c033efd2983dc723" translate="yes" xml:space="preserve">
          <source>Note that the variants of the enum are namespaced under its identifier, and we use a double colon to separate the two. The reason this is useful is that now both values &lt;code&gt;IpAddrKind::V4&lt;/code&gt; and &lt;code&gt;IpAddrKind::V6&lt;/code&gt; are of the same type: &lt;code&gt;IpAddrKind&lt;/code&gt;. We can then, for instance, define a function that takes any &lt;code&gt;IpAddrKind&lt;/code&gt;:</source>
          <target state="translated">Tenga en cuenta que las variantes de la enumeraci&amp;oacute;n tienen un espacio de nombres debajo de su identificador, y usamos dos puntos dobles para separar los dos. La raz&amp;oacute;n por la que esto es &amp;uacute;til es que ahora ambos valores &lt;code&gt;IpAddrKind::V4&lt;/code&gt; e &lt;code&gt;IpAddrKind::V6&lt;/code&gt; son del mismo tipo: &lt;code&gt;IpAddrKind&lt;/code&gt; . Entonces podemos, por ejemplo, definir una funci&amp;oacute;n que tome cualquier &lt;code&gt;IpAddrKind&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="16c052a3290e3d52e2b4ef43bfa0c661287a1967" translate="yes" xml:space="preserve">
          <source>Note that there is a subtle difference between using only &lt;code&gt;_&lt;/code&gt; and using a name that starts with an underscore. The syntax &lt;code&gt;_x&lt;/code&gt; still binds the value to the variable, whereas &lt;code&gt;_&lt;/code&gt; doesn&amp;rsquo;t bind at all. To show a case where this distinction matters, Listing 18-21 will provide us with an error.</source>
          <target state="translated">Tenga en cuenta que existe una sutil diferencia entre usar solo &lt;code&gt;_&lt;/code&gt; y usar un nombre que comience con un gui&amp;oacute;n bajo. La sintaxis &lt;code&gt;_x&lt;/code&gt; a&amp;uacute;n vincula el valor a la variable, mientras que &lt;code&gt;_&lt;/code&gt; no vincula en absoluto. Para mostrar un caso en el que esta distinci&amp;oacute;n es importante, el Listado 18-21 nos proporcionar&amp;aacute; un error.</target>
        </trans-unit>
        <trans-unit id="a9f69008c63ee1bbbd3dca68ce2579a7f11ccac4" translate="yes" xml:space="preserve">
          <source>Note that there is no guarantee that the file is immediately deleted (e.g., depending on platform, other open file descriptors may prevent immediate removal).</source>
          <target state="translated">Tenga en cuenta que no hay garantía de que el archivo se elimine inmediatamente (por ejemplo,dependiendo de la plataforma,otros descriptores de archivos abiertos pueden impedir la eliminación inmediata).</target>
        </trans-unit>
        <trans-unit id="c1d60a1d35c01b7a3e982971929136941cc6d773" translate="yes" xml:space="preserve">
          <source>Note that there might be more than one &lt;code&gt;Reject&lt;/code&gt; between two &lt;code&gt;Match&lt;/code&gt;es, there is no requirement for them to be combined into one.</source>
          <target state="translated">Tenga en cuenta que puede haber m&amp;aacute;s de un &lt;code&gt;Reject&lt;/code&gt; entre dos &lt;code&gt;Match&lt;/code&gt; , no es necesario que se combinen en una sola.</target>
        </trans-unit>
        <trans-unit id="66991018cda906aad5fc546c336b3be880291e4b" translate="yes" xml:space="preserve">
          <source>Note that these outputs are stackable in the sense that if multiple are specified, then the compiler will produce each form of output at once without having to recompile. However, this only applies for outputs specified by the same method. If only &lt;code&gt;crate_type&lt;/code&gt; attributes are specified, then they will all be built, but if one or more &lt;code&gt;--crate-type&lt;/code&gt; command line flags are specified, then only those outputs will be built.</source>
          <target state="translated">Tenga en cuenta que estas salidas son apilables en el sentido de que si se especifican varias, el compilador producir&amp;aacute; cada forma de salida a la vez sin tener que volver a compilar. Sin embargo, esto solo se aplica a las salidas especificadas por el mismo m&amp;eacute;todo. Si solo se especifican los atributos &lt;code&gt;crate_type&lt;/code&gt; , entonces se construir&amp;aacute;n todos, pero si se especifican uno o m&amp;aacute;s &lt;code&gt;--crate-type&lt;/code&gt; l&amp;iacute;nea de comando --crate-type , solo se construir&amp;aacute;n esas salidas.</target>
        </trans-unit>
        <trans-unit id="68d9fc76dd03b0153bd61663810434ccc46dcc2c" translate="yes" xml:space="preserve">
          <source>Note that these requirements mean that the trait itself must be implemented symmetrically and transitively: if &lt;code&gt;T: PartialEq&amp;lt;U&amp;gt;&lt;/code&gt; and &lt;code&gt;U: PartialEq&amp;lt;V&amp;gt;&lt;/code&gt; then &lt;code&gt;U: PartialEq&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;T: PartialEq&amp;lt;V&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que estos requisitos significan que el rasgo en s&amp;iacute; debe implementarse de manera sim&amp;eacute;trica y transitiva: si &lt;code&gt;T: PartialEq&amp;lt;U&amp;gt;&lt;/code&gt; y &lt;code&gt;U: PartialEq&amp;lt;V&amp;gt;&lt;/code&gt; entonces &lt;code&gt;U: PartialEq&amp;lt;T&amp;gt;&lt;/code&gt; y &lt;code&gt;T: PartialEq&amp;lt;V&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68c8d8134a3ad3fb6c3b8c1e1d2d42e5a3391556" translate="yes" xml:space="preserve">
          <source>Note that these requirements mean that the trait itself must be implemented symmetrically and transitively: if &lt;code&gt;T: PartialOrd&amp;lt;U&amp;gt;&lt;/code&gt; and &lt;code&gt;U: PartialOrd&amp;lt;V&amp;gt;&lt;/code&gt; then &lt;code&gt;U: PartialOrd&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;T: PartialOrd&amp;lt;V&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que estos requisitos significan que el rasgo en s&amp;iacute; debe implementarse de forma sim&amp;eacute;trica y transitiva: si &lt;code&gt;T: PartialOrd&amp;lt;U&amp;gt;&lt;/code&gt; y &lt;code&gt;U: PartialOrd&amp;lt;V&amp;gt;&lt;/code&gt; entonces &lt;code&gt;U: PartialOrd&amp;lt;T&amp;gt;&lt;/code&gt; y &lt;code&gt;T: PartialOrd&amp;lt;V&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a875078880a05f44d1479047dbce85f081dc8bf" translate="yes" xml:space="preserve">
          <source>Note that this &lt;code&gt;let&lt;/code&gt; statement means &lt;code&gt;expensive_closure&lt;/code&gt; contains the &lt;em&gt;definition&lt;/em&gt; of an anonymous function, not the &lt;em&gt;resulting value&lt;/em&gt; of calling the anonymous function. Recall that we&amp;rsquo;re using a closure because we want to define the code to call at one point, store that code, and call it at a later point; the code we want to call is now stored in &lt;code&gt;expensive_closure&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que esta declaraci&amp;oacute;n &lt;code&gt;let&lt;/code&gt; significa que &lt;code&gt;expensive_closure&lt;/code&gt; contiene la &lt;em&gt;definici&amp;oacute;n&lt;/em&gt; de funci&amp;oacute;n an&amp;oacute;nima, no el &lt;em&gt;valor resultante&lt;/em&gt; de llamar a la funci&amp;oacute;n an&amp;oacute;nima. Recuerde que estamos usando un cierre porque queremos definir el c&amp;oacute;digo para llamar en un punto, almacenar ese c&amp;oacute;digo y llamarlo en un punto posterior; el c&amp;oacute;digo que queremos llamar ahora est&amp;aacute; almacenado en &lt;code&gt;expensive_closure&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f79a43777883bf04ed897be6d605f1d017ef8797" translate="yes" xml:space="preserve">
          <source>Note that this approach needs a reference to S with lifetime &lt;code&gt;'a&lt;/code&gt;. Nothing shorter than &lt;code&gt;'a&lt;/code&gt; will suffice: a shorter lifetime would imply that after &lt;code&gt;demo&lt;/code&gt; finishes executing, something else (such as the destructor!) could access &lt;code&gt;s.data&lt;/code&gt; after the end of that shorter lifetime, which would again violate the &lt;code&gt;&amp;amp;mut&lt;/code&gt;-borrow's exclusive access.</source>
          <target state="translated">Tenga en cuenta que este enfoque necesita una referencia a S con vida &amp;uacute;til &lt;code&gt;'a&lt;/code&gt; . Nada m&amp;aacute;s corto que &lt;code&gt;'a&lt;/code&gt; will ser&amp;aacute; suficiente: una vida m&amp;aacute;s corta implicar&amp;iacute;a que despu&amp;eacute;s de que la &lt;code&gt;demo&lt;/code&gt; straci&amp;oacute;n termine de ejecutarse, algo m&amp;aacute;s (&amp;iexcl;como el destructor!) Podr&amp;iacute;a acceder a los &lt;code&gt;s.data&lt;/code&gt; despu&amp;eacute;s del final de esa vida m&amp;aacute;s corta, lo que nuevamente violar&amp;iacute;a la exclusiva de &lt;code&gt;&amp;amp;mut&lt;/code&gt; -borrow acceso.</target>
        </trans-unit>
        <trans-unit id="c27fe5a5d1e022b605f9e160ee6f188847c0730a" translate="yes" xml:space="preserve">
          <source>Note that this behavior is a consequence of the desugaring to a function that returns an &lt;code&gt;impl Future&lt;/code&gt; -- in this case, the function we desugar to is an &lt;code&gt;unsafe&lt;/code&gt; function, but the return value remains the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d559316d5513a320d9bd5dde1c5db0aa4a3ef581" translate="yes" xml:space="preserve">
          <source>Note that this differs from the behavior of &lt;a href=&quot;../rc/struct.rc#method.make_mut&quot;&gt;&lt;code&gt;Rc::make_mut&lt;/code&gt;&lt;/a&gt; which disassociates any remaining &lt;code&gt;Weak&lt;/code&gt; pointers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3192c9f3997431085906a96d26c01c024cf3788d" translate="yes" xml:space="preserve">
          <source>Note that this does &lt;strong&gt;not&lt;/strong&gt; return the number of bytes in the string in OS string form.</source>
          <target state="translated">Tenga en cuenta que esto &lt;strong&gt;no&lt;/strong&gt; devuelve el n&amp;uacute;mero de bytes en la cadena en forma de cadena del sistema operativo.</target>
        </trans-unit>
        <trans-unit id="80ff79baf2f49c9d290848de9fb000d654394ab7" translate="yes" xml:space="preserve">
          <source>Note that this does not move &lt;code&gt;v&lt;/code&gt; (unlike &lt;code&gt;transmute&lt;/code&gt;), and may need a call to &lt;code&gt;mem::forget(v)&lt;/code&gt; in case you want to avoid destructors being called.</source>
          <target state="translated">Tenga en cuenta que esto no mueve &lt;code&gt;v&lt;/code&gt; (a diferencia de &lt;code&gt;transmute&lt;/code&gt; ), y puede necesitar una llamada a &lt;code&gt;mem::forget(v)&lt;/code&gt; en caso de que quiera evitar que se llamen a los destructores.</target>
        </trans-unit>
        <trans-unit id="7810f8cddc029bde853e42fc348f1144623db2c4" translate="yes" xml:space="preserve">
          <source>Note that this example uses &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; and not &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt;. &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;s are for single-threaded scenarios. Consider using &lt;code&gt;RwLock&amp;lt;T&amp;gt;&lt;/code&gt; or &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; if you need shared mutability in a multi-threaded situation.</source>
          <target state="translated">Tenga en cuenta que este ejemplo usa &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; y no &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; . &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; s son para escenarios de un solo subproceso. Considere usar &lt;code&gt;RwLock&amp;lt;T&amp;gt;&lt;/code&gt; o &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; si necesita mutabilidad compartida en una situaci&amp;oacute;n de m&amp;uacute;ltiples subprocesos.</target>
        </trans-unit>
        <trans-unit id="cdd8e4eb74f462e708e2264904eba6fd4dc6a6a0" translate="yes" xml:space="preserve">
          <source>Note that this example won&amp;rsquo;t compile just yet; we&amp;rsquo;ll explain why in a bit.</source>
          <target state="translated">Tenga en cuenta que este ejemplo no se compilar&amp;aacute; todav&amp;iacute;a; explicaremos por qu&amp;eacute; en un momento.</target>
        </trans-unit>
        <trans-unit id="5bd9e1731fac8ae0cac27d3b3c2a1bac0e799687" translate="yes" xml:space="preserve">
          <source>Note that this function &lt;strong&gt;may not catch all panics&lt;/strong&gt; in Rust. A panic in Rust is not always implemented via unwinding, but can be implemented by aborting the process as well. This function &lt;em&gt;only&lt;/em&gt; catches unwinding panics, not those that abort the process.</source>
          <target state="translated">Tenga en cuenta que esta funci&amp;oacute;n &lt;strong&gt;puede no detectar todos los p&amp;aacute;nicos&lt;/strong&gt; en Rust. Un p&amp;aacute;nico en Rust no siempre se implementa mediante el desenrollado, pero tambi&amp;eacute;n se puede implementar abortando el proceso. Esta funci&amp;oacute;n &lt;em&gt;solo&lt;/em&gt; detecta los p&amp;aacute;nicos que se relajan, no los que abortan el proceso.</target>
        </trans-unit>
        <trans-unit id="d3651367d7bc20ea65e217082fe9e78b8f819776" translate="yes" xml:space="preserve">
          <source>Note that this function does not always agree with the &lt;a href=&quot;cmp/trait.partialord&quot;&gt;&lt;code&gt;PartialOrd&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt; implementations of &lt;code&gt;f32&lt;/code&gt;. In particular, they regard negative and positive zero as equal, while &lt;code&gt;total_cmp&lt;/code&gt; doesn't.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d6a1415dd489b9fd2f261b68de74159561b45e0" translate="yes" xml:space="preserve">
          <source>Note that this function does not always agree with the &lt;a href=&quot;cmp/trait.partialord&quot;&gt;&lt;code&gt;PartialOrd&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt; implementations of &lt;code&gt;f64&lt;/code&gt;. In particular, they regard negative and positive zero as equal, while &lt;code&gt;total_cmp&lt;/code&gt; doesn't.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19f0a1a5449c981a5e246c3b5e6a9fcf303b7fa2" translate="yes" xml:space="preserve">
          <source>Note that this function is distinct from &lt;code&gt;as&lt;/code&gt; casting, which attempts to preserve the &lt;em&gt;numeric&lt;/em&gt; value, and not the bitwise value.</source>
          <target state="translated">Tenga en cuenta que esta funci&amp;oacute;n es distinta de &lt;code&gt;as&lt;/code&gt; fundici&amp;oacute;n, que los intentos de preservar la &lt;em&gt;num&amp;eacute;rico&lt;/em&gt; valor, y no el valor bit a bit.</target>
        </trans-unit>
        <trans-unit id="d63eb9d4a24784000530071fbe51104de3bf3f2c" translate="yes" xml:space="preserve">
          <source>Note that this function is same as &lt;a href=&quot;#method.extend&quot;&gt;&lt;code&gt;extend&lt;/code&gt;&lt;/a&gt; except that it is specialized to work with slices instead. If and when Rust gets specialization this function will likely be deprecated (but still available).</source>
          <target state="translated">Tenga en cuenta que esta funci&amp;oacute;n es la misma que &lt;a href=&quot;#method.extend&quot;&gt; &lt;code&gt;extend&lt;/code&gt; er,&lt;/a&gt; excepto que est&amp;aacute; especializada para trabajar con sectores. Si Rust se especializa, es probable que esta funci&amp;oacute;n quede obsoleta (pero a&amp;uacute;n est&amp;eacute; disponible).</target>
        </trans-unit>
        <trans-unit id="0f406b6d417033b808228cce14b8dbb1120d5c7d" translate="yes" xml:space="preserve">
          <source>Note that this function is same as &lt;a href=&quot;struct.vec#method.extend&quot;&gt;&lt;code&gt;extend&lt;/code&gt;&lt;/a&gt; except that it is specialized to work with slices instead. If and when Rust gets specialization this function will likely be deprecated (but still available).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65def495fd9076c99d32e3ed9abc467516100c9b" translate="yes" xml:space="preserve">
          <source>Note that this function is susceptible to spurious wakeups. Condition variables normally have a boolean predicate associated with them, and the predicate must always be checked each time this function returns to protect against spurious wakeups.</source>
          <target state="translated">Tenga en cuenta que esta función es susceptible de despertar espurios.Las variables de condición normalmente tienen asociado un predicado booleano,y el predicado siempre debe ser comprobado cada vez que esta función vuelve para protegerse contra despertares espurios.</target>
        </trans-unit>
        <trans-unit id="313e92b88c0b90cea2623eaa38278951f5c4defe" translate="yes" xml:space="preserve">
          <source>Note that this function may block the current thread while resolution is performed.</source>
          <target state="translated">Tenga en cuenta que esta función puede bloquear el hilo actual mientras se realiza la resolución.</target>
        </trans-unit>
        <trans-unit id="380b102b57d47b1e80ead440741eb736cbc5acae" translate="yes" xml:space="preserve">
          <source>Note that this function returns NaN if the initial value was NaN as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="041273b62662865c4b0b3972fa9f215d6a183216" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;also&lt;/em&gt; different from Windows-1252 a.k.a. code page 1252, which is a superset ISO/IEC 8859-1 that assigns some (not all!) blanks to punctuation and various Latin characters.</source>
          <target state="translated">Tenga en cuenta que esto &lt;em&gt;tambi&amp;eacute;n&lt;/em&gt; es diferente de Windows-1252, tambi&amp;eacute;n conocido como p&amp;aacute;gina de c&amp;oacute;digos 1252, que es un superconjunto ISO / IEC 8859-1 que asigna algunos espacios en blanco (&amp;iexcl;no todos!) A la puntuaci&amp;oacute;n y varios caracteres latinos.</target>
        </trans-unit>
        <trans-unit id="c12e3030c3946db5f00ad56e92693e7a60e9d4f4" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-left; the RHS of a wrapping shift-left is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;a href=&quot;#method.rotate_left&quot;&gt;&lt;code&gt;rotate_left&lt;/code&gt;&lt;/a&gt; function, which may be what you want instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d05d921ff847b716a1e90578f4bb30e691402415" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-left; the RHS of a wrapping shift-left is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;code&gt;[&lt;/code&gt;rotate_left`](#method.rotate_left) function, which may be what you want instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b16eb422b8b7fd380457bb98366ee9e32e4eb27b" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-left; the RHS of a wrapping shift-left is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;code&gt;rotate_left&lt;/code&gt; function, which may be what you want instead.</source>
          <target state="translated">Tenga en cuenta que esto &lt;em&gt;no&lt;/em&gt; es &lt;em&gt;lo&lt;/em&gt; mismo que rotar a la izquierda; el RHS de un desplazamiento de envoltura a la izquierda est&amp;aacute; restringido al rango del tipo, en lugar de que los bits desplazados fuera del LHS se devuelvan al otro extremo. Todos los tipos de enteros primitivos implementan una funci&amp;oacute;n &lt;code&gt;rotate_left&lt;/code&gt; , que puede ser lo que usted desee.</target>
        </trans-unit>
        <trans-unit id="3efbf7b6ffbe371fa44b1cbc24ab53cb5dc43bf3" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-right; the RHS of a wrapping shift-right is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;a href=&quot;#method.rotate_right&quot;&gt;&lt;code&gt;rotate_right&lt;/code&gt;&lt;/a&gt; function, which may be what you want instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e2418939b1c8a1ff22ccadf416147fa70a3f1d3" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; the same as a rotate-right; the RHS of a wrapping shift-right is restricted to the range of the type, rather than the bits shifted out of the LHS being returned to the other end. The primitive integer types all implement a &lt;code&gt;rotate_right&lt;/code&gt; function, which may be what you want instead.</source>
          <target state="translated">Tenga en cuenta que esto &lt;em&gt;no&lt;/em&gt; es &lt;em&gt;lo&lt;/em&gt; mismo que rotar a la derecha; el RHS de un desplazamiento a la derecha de envoltura est&amp;aacute; restringido al rango del tipo, en lugar de que los bits desplazados fuera del LHS se devuelvan al otro extremo. Todos los tipos primitivos de enteros implementan una funci&amp;oacute;n &lt;code&gt;rotate_right&lt;/code&gt; , que puede ser lo que quieras.</target>
        </trans-unit>
        <trans-unit id="5e7c41ce1c84929477918f04b930178589599b47" translate="yes" xml:space="preserve">
          <source>Note that this is different from ISO/IEC 8859-1 a.k.a. ISO 8859-1 (with one less hyphen), which leaves some &quot;blanks&quot;, byte values that are not assigned to any character. ISO-8859-1 (the IANA one) assigns them to the C0 and C1 control codes.</source>
          <target state="translated">Obsérvese que esto es diferente de la norma ISO/CEI 8859-1,también conocida como ISO 8859-1 (con un guión menos),que deja algunos &quot;espacios en blanco&quot;,valores de bytes que no se asignan a ningún carácter.La ISO-8859-1 (la de la IANA)los asigna a los códigos de control C0 y C1.</target>
        </trans-unit>
        <trans-unit id="8c4108681b9fe84accc050cbc8f424a5d8e729f9" translate="yes" xml:space="preserve">
          <source>Note that this is not fully supported yet.</source>
          <target state="translated">Tenga en cuenta que esto aún no está totalmente respaldado.</target>
        </trans-unit>
        <trans-unit id="f63d3c3ade69b60f12aa852f379afa06c0c1f9ef" translate="yes" xml:space="preserve">
          <source>Note that this list may get tweaked over time as clarifications are made in the future.</source>
          <target state="translated">Tenga en cuenta que esta lista puede ser modificada con el tiempo a medida que se hagan las aclaraciones en el futuro.</target>
        </trans-unit>
        <trans-unit id="03886768677567c6f0e7dd2acec0f3c2f274c587" translate="yes" xml:space="preserve">
          <source>Note that this may not have any affect on IPv6 sockets.</source>
          <target state="translated">Tenga en cuenta que esto puede no tener ningún efecto en los enchufes IPv6.</target>
        </trans-unit>
        <trans-unit id="75b3dfc6f40c762d7bf2bac499b7412fe6b10302" translate="yes" xml:space="preserve">
          <source>Note that this may not have any effect on IPv6 sockets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dd32cd539a7711b8e3e1fa20fa744535b499c0b" translate="yes" xml:space="preserve">
          <source>Note that this method alters the content of the underlying file, even though it takes &lt;code&gt;&amp;amp;self&lt;/code&gt; rather than &lt;code&gt;&amp;amp;mut self&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que este m&amp;eacute;todo altera el contenido del archivo subyacente, aunque toma &lt;code&gt;&amp;amp;self&lt;/code&gt; lugar de &lt;code&gt;&amp;amp;mut self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="108aecbc7f980094cc29f71b2bba33a5524e868d" translate="yes" xml:space="preserve">
          <source>Note that this method alters the permissions of the underlying file, even though it takes &lt;code&gt;&amp;amp;self&lt;/code&gt; rather than &lt;code&gt;&amp;amp;mut self&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que este m&amp;eacute;todo altera los permisos del archivo subyacente, aunque toma &lt;code&gt;&amp;amp;self&lt;/code&gt; lugar de &lt;code&gt;&amp;amp;mut self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2935aad8d6fdca6a365f84d6feb6723528101b9" translate="yes" xml:space="preserve">
          <source>Note that this method does not add any padding to the overall size, regardless of whether the returned layout has a different alignment. In other words, if &lt;code&gt;K&lt;/code&gt; has size 16, &lt;code&gt;K.align_to(32)&lt;/code&gt; will &lt;em&gt;still&lt;/em&gt; have size 16.</source>
          <target state="translated">Tenga en cuenta que este m&amp;eacute;todo no agrega ning&amp;uacute;n relleno al tama&amp;ntilde;o general, independientemente de si el dise&amp;ntilde;o devuelto tiene una alineaci&amp;oacute;n diferente. En otras palabras, si &lt;code&gt;K&lt;/code&gt; tiene el tama&amp;ntilde;o 16, &lt;code&gt;K.align_to(32)&lt;/code&gt; seguir&amp;aacute; &lt;em&gt;teniendo el&lt;/em&gt; tama&amp;ntilde;o 16.</target>
        </trans-unit>
        <trans-unit id="be7d3b69a88f7138cbd894fa652fd4db3b576956" translate="yes" xml:space="preserve">
          <source>Note that this method has no effect on the allocated capacity of the string</source>
          <target state="translated">Obsérvese que este método no tiene ningún efecto sobre la capacidad asignada de la cadena</target>
        </trans-unit>
        <trans-unit id="c7737d7dae93fa9ff008b32d416192e1953f17cf" translate="yes" xml:space="preserve">
          <source>Note that this method has no effect on the allocated capacity of the vector.</source>
          <target state="translated">Obsérvese que este método no tiene ningún efecto sobre la capacidad asignada del vector.</target>
        </trans-unit>
        <trans-unit id="89e693fcdc5244de65fc2d6120edee9bdcd4b3ee" translate="yes" xml:space="preserve">
          <source>Note that this structure is &lt;strong&gt;not&lt;/strong&gt;&lt;code&gt;repr(C)&lt;/code&gt; and is not recommended to be placed in the signatures of FFI functions. Instead, safe wrappers of FFI functions may leverage the unsafe &lt;a href=&quot;#method.from_ptr&quot;&gt;&lt;code&gt;from_ptr&lt;/code&gt;&lt;/a&gt; constructor to provide a safe interface to other consumers.</source>
          <target state="translated">Tenga en cuenta que esta estructura &lt;strong&gt;no&lt;/strong&gt; es &lt;code&gt;repr(C)&lt;/code&gt; y no se recomienda colocarla en las firmas de las funciones de FFI. En cambio, los envoltorios seguros de funciones FFI pueden aprovechar el constructor inseguro &lt;a href=&quot;#method.from_ptr&quot;&gt; &lt;code&gt;from_ptr&lt;/code&gt; &lt;/a&gt; para proporcionar una interfaz segura a otros consumidores.</target>
        </trans-unit>
        <trans-unit id="9aac27458abae34c90a97df1aff42a3fdeee40a4" translate="yes" xml:space="preserve">
          <source>Note that this structure is &lt;strong&gt;not&lt;/strong&gt;&lt;code&gt;repr(C)&lt;/code&gt; and is not recommended to be placed in the signatures of FFI functions. Instead, safe wrappers of FFI functions may leverage the unsafe &lt;a href=&quot;struct.cstr#method.from_ptr&quot;&gt;&lt;code&gt;CStr::from_ptr&lt;/code&gt;&lt;/a&gt; constructor to provide a safe interface to other consumers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5da6d2d2aa3f48414658a9bcd539c6d50d1d673" translate="yes" xml:space="preserve">
          <source>Note that this technique can also be used in the arms of a match expression:</source>
          <target state="translated">Tenga en cuenta que esta técnica también puede ser utilizada en los brazos de una expresión de partido:</target>
        </trans-unit>
        <trans-unit id="b13210c5a5854d88abb024233653585819c00385" translate="yes" xml:space="preserve">
          <source>Note that this will drop any excess capacity.</source>
          <target state="translated">Tenga en cuenta que esto reducirá cualquier exceso de capacidad.</target>
        </trans-unit>
        <trans-unit id="6affebf246a6b9323b472569ce7b0d2dca1b6504" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;a href=&quot;trait.iterator#method.take_while&quot;&gt;&lt;code&gt;take_while&lt;/code&gt;&lt;/a&gt; this iterator is &lt;strong&gt;not&lt;/strong&gt; fused. It is also not specified what this iterator returns after the first&lt;code&gt; None&lt;/code&gt; is returned. If you need fused iterator, use &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt;&lt;code&gt;fuse&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d98fb91c14420919b7eff367a1230b8f150b713" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;code&gt;wait&lt;/code&gt;, this function will not attempt to drop stdin.</source>
          <target state="translated">Tenga en cuenta que, a diferencia de &lt;code&gt;wait&lt;/code&gt; , esta funci&amp;oacute;n no intentar&amp;aacute; eliminar stdin.</target>
        </trans-unit>
        <trans-unit id="cb34ec44c63eee46c533ae8549230c0956f06438" translate="yes" xml:space="preserve">
          <source>Note that unlike array expressions this syntax supports all elements which implement &lt;a href=&quot;clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; and the number of elements doesn't have to be a constant.</source>
          <target state="translated">Tenga en cuenta que, a diferencia de las expresiones de matriz, esta sintaxis admite todos los elementos que implementan &lt;a href=&quot;clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; y el n&amp;uacute;mero de elementos no tiene que ser una constante.</target>
        </trans-unit>
        <trans-unit id="09bd0257d3adc41b553ee0c1fba837b27ed6d43d" translate="yes" xml:space="preserve">
          <source>Note that unsized types have many possible null pointers, as only the raw data pointer is considered, not their length, vtable, etc. Therefore, two pointers that are null may still not compare equal to each other.</source>
          <target state="translated">Obsérvese que los tipos sin tamaño tienen muchos posibles punteros nulos,ya que sólo se considera el puntero de datos en bruto,no su longitud,vtable,etc.Por lo tanto,dos punteros que son nulos pueden no compararse igual entre sí.</target>
        </trans-unit>
        <trans-unit id="1f2131c92cffd468fb8e9760cfdc9ed5b9347fe9" translate="yes" xml:space="preserve">
          <source>Note that using &lt;code&gt;self&lt;/code&gt; in this way might not be necessary in the future; it&amp;rsquo;s an inconsistency in the language that Rust developers are working to eliminate.</source>
          <target state="translated">Tenga en cuenta que, en el futuro, puede que no sea necesario utilizar el &lt;code&gt;self&lt;/code&gt; de esta forma; es una inconsistencia en el lenguaje que los desarrolladores de Rust est&amp;aacute;n tratando de eliminar.</target>
        </trans-unit>
        <trans-unit id="d0ff9c8a29cb263c7447b50b428f4e5035b7a3bd" translate="yes" xml:space="preserve">
          <source>Note that using the &lt;code&gt;type&lt;/code&gt; keyword does not work here because &lt;code&gt;type&lt;/code&gt; only introduces a type alias:</source>
          <target state="translated">Tenga en cuenta que el uso del &lt;code&gt;type&lt;/code&gt; palabra clave no funciona aqu&amp;iacute; porque &lt;code&gt;type&lt;/code&gt; solo introduce un alias de tipo:</target>
        </trans-unit>
        <trans-unit id="bb6b42394e9bea5f3f448212418ce1a68b9d76c5" translate="yes" xml:space="preserve">
          <source>Note that using these trait methods will result in a heap allocation per-function-call. This is not a significant cost for the vast majority of applications, but should be considered when deciding whether to use this functionality in the public API of a low-level function that is expected to be called millions of times a second.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96eb45dab421603d86bba0634bd20e8a1fa6f567" translate="yes" xml:space="preserve">
          <source>Note that variants without a manually specified discriminant are numbered from top to bottom starting from 0, so clashes can occur with seemingly unrelated variants.</source>
          <target state="translated">Obsérvese que las variantes sin un discriminante especificado manualmente se numeran de arriba a abajo empezando por el 0,por lo que pueden producirse choques con variantes aparentemente no relacionadas.</target>
        </trans-unit>
        <trans-unit id="76fed75fcc53f6083929938f0584d1d34ef49d4d" translate="yes" xml:space="preserve">
          <source>Note that we added a type annotation here. Because we aren&amp;rsquo;t inserting any values into this vector, Rust doesn&amp;rsquo;t know what kind of elements we intend to store. This is an important point. Vectors are implemented using generics; we&amp;rsquo;ll cover how to use generics with your own types in Chapter 10. For now, know that the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; type provided by the standard library can hold any type, and when a specific vector holds a specific type, the type is specified within angle brackets. In Listing 8-1, we&amp;rsquo;ve told Rust that the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; in &lt;code&gt;v&lt;/code&gt; will hold elements of the &lt;code&gt;i32&lt;/code&gt; type.</source>
          <target state="translated">Tenga en cuenta que agregamos una anotaci&amp;oacute;n de tipo aqu&amp;iacute;. Debido a que no estamos insertando ning&amp;uacute;n valor en este vector, Rust no sabe qu&amp;eacute; tipo de elementos pretendemos almacenar. &amp;Eacute;ste es un punto importante. Los vectores se implementan usando gen&amp;eacute;ricos; cubriremos c&amp;oacute;mo usar gen&amp;eacute;ricos con sus propios tipos en el Cap&amp;iacute;tulo 10. Por ahora, sepa que el tipo &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; proporcionado por la biblioteca est&amp;aacute;ndar puede contener cualquier tipo, y cuando un vector espec&amp;iacute;fico contiene un tipo espec&amp;iacute;fico, el tipo es especificado entre par&amp;eacute;ntesis angulares. En el Listado 8-1, le hemos dicho a Rust que &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; en &lt;code&gt;v&lt;/code&gt; contendr&amp;aacute; elementos del tipo &lt;code&gt;i32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c79056cb286ed85ac028f7264150a40f531f9d9" translate="yes" xml:space="preserve">
          <source>Note that we added the &lt;code&gt;case_sensitive&lt;/code&gt; field that holds a Boolean. Next, we need the &lt;code&gt;run&lt;/code&gt; function to check the &lt;code&gt;case_sensitive&lt;/code&gt; field&amp;rsquo;s value and use that to decide whether to call the &lt;code&gt;search&lt;/code&gt; function or the &lt;code&gt;search_case_insensitive&lt;/code&gt; function, as shown in Listing 12-22. Note this still won&amp;rsquo;t compile yet.</source>
          <target state="translated">Tenga en cuenta que agregamos el campo &lt;code&gt;case_sensitive&lt;/code&gt; que contiene un booleano. Luego, necesitamos la funci&amp;oacute;n de &lt;code&gt;run&lt;/code&gt; para verificar el valor del campo &lt;code&gt;case_sensitive&lt;/code&gt; y usarlo para decidir si llamar a la funci&amp;oacute;n de &lt;code&gt;search&lt;/code&gt; o la funci&amp;oacute;n &lt;code&gt;search_case_insensitive&lt;/code&gt; , como se muestra en el Listado 12-22. Tenga en cuenta que esto todav&amp;iacute;a no se compilar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="d033b37f19d17a68bf9778f4a3805418777a67e9" translate="yes" xml:space="preserve">
          <source>Note that we don&amp;rsquo;t need to mark the resulting &lt;code&gt;split_at_mut&lt;/code&gt; function as &lt;code&gt;unsafe&lt;/code&gt;, and we can call this function from safe Rust. We&amp;rsquo;ve created a safe abstraction to the unsafe code with an implementation of the function that uses &lt;code&gt;unsafe&lt;/code&gt; code in a safe way, because it creates only valid pointers from the data this function has access to.</source>
          <target state="translated">Tenga en cuenta que no necesitamos marcar la funci&amp;oacute;n &lt;code&gt;split_at_mut&lt;/code&gt; resultante como &lt;code&gt;unsafe&lt;/code&gt; , y podemos llamar a esta funci&amp;oacute;n desde Safe Rust. Hemos creado una abstracci&amp;oacute;n segura del c&amp;oacute;digo inseguro con una implementaci&amp;oacute;n de la funci&amp;oacute;n que usa c&amp;oacute;digo &lt;code&gt;unsafe&lt;/code&gt; de una manera segura, porque crea solo punteros v&amp;aacute;lidos a partir de los datos a los que tiene acceso esta funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="79f8d5116fd5bb5dc0c20baa33c391d983b3d588" translate="yes" xml:space="preserve">
          <source>Note that we have to declare &lt;code&gt;T&lt;/code&gt; just after &lt;code&gt;impl&lt;/code&gt; so we can use it to specify that we&amp;rsquo;re implementing methods on the type &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt;. By declaring &lt;code&gt;T&lt;/code&gt; as a generic type after &lt;code&gt;impl&lt;/code&gt;, Rust can identify that the type in the angle brackets in &lt;code&gt;Point&lt;/code&gt; is a generic type rather than a concrete type.</source>
          <target state="translated">Tenga en cuenta que tenemos que declarar &lt;code&gt;T&lt;/code&gt; justo despu&amp;eacute;s de &lt;code&gt;impl&lt;/code&gt; para que podamos usarlo para especificar que estamos implementando m&amp;eacute;todos en el tipo &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; . Declarando &lt;code&gt;T&lt;/code&gt; como un tipo gen&amp;eacute;rico despu&amp;eacute;s de &lt;code&gt;impl&lt;/code&gt; , Rust puede identificar que el tipo entre par&amp;eacute;ntesis angulares en &lt;code&gt;Point&lt;/code&gt; es un tipo gen&amp;eacute;rico en lugar de un tipo concreto.</target>
        </trans-unit>
        <trans-unit id="21933f931bffb1331e5d307d3ac351285280040d" translate="yes" xml:space="preserve">
          <source>Note that we must use the fully qualified syntax that we talked about earlier in the &lt;a href=&quot;ch19-03-advanced-traits#advanced-traits&quot;&gt;&amp;ldquo;Advanced Traits&amp;rdquo;&lt;/a&gt; section because there are multiple functions available named &lt;code&gt;to_string&lt;/code&gt;. Here, we&amp;rsquo;re using the &lt;code&gt;to_string&lt;/code&gt; function defined in the &lt;code&gt;ToString&lt;/code&gt; trait, which the standard library has implemented for any type that implements &lt;code&gt;Display&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que debemos utilizar la sintaxis completa de la que hablamos anteriormente en la secci&amp;oacute;n &lt;a href=&quot;ch19-03-advanced-traits#advanced-traits&quot;&gt;&quot;Caracter&amp;iacute;sticas avanzadas&quot;&lt;/a&gt; porque hay varias funciones disponibles llamadas &lt;code&gt;to_string&lt;/code&gt; . Aqu&amp;iacute;, estamos usando la funci&amp;oacute;n &lt;code&gt;to_string&lt;/code&gt; definida en el rasgo &lt;code&gt;ToString&lt;/code&gt; , que la biblioteca est&amp;aacute;ndar ha implementado para cualquier tipo que implemente &lt;code&gt;Display&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="096f913e45816f67a5f4300a1107c11162218bda" translate="yes" xml:space="preserve">
          <source>Note that we need lifetime annotations on this method, as we discussed in Chapter 10. We&amp;rsquo;re taking a reference to a &lt;code&gt;post&lt;/code&gt; as an argument and returning a reference to part of that &lt;code&gt;post&lt;/code&gt;, so the lifetime of the returned reference is related to the lifetime of the &lt;code&gt;post&lt;/code&gt; argument.</source>
          <target state="translated">Tenga en cuenta que necesitamos anotaciones de por vida en este m&amp;eacute;todo, como discutimos en el Cap&amp;iacute;tulo 10. Tomamos una referencia a una &lt;code&gt;post&lt;/code&gt; como argumento y devolvemos una referencia a parte de esa &lt;code&gt;post&lt;/code&gt; , por lo que la vida &amp;uacute;til de la referencia devuelta est&amp;aacute; relacionada con la vida de la &lt;code&gt;post&lt;/code&gt; argumento posterior .</target>
        </trans-unit>
        <trans-unit id="0a3ac30cf1c59aeb030a71d5cf7a71a2b0dfbcb7" translate="yes" xml:space="preserve">
          <source>Note that we need to first &lt;code&gt;use&lt;/code&gt; the &lt;code&gt;HashMap&lt;/code&gt; from the collections portion of the standard library. Of our three common collections, this one is the least often used, so it&amp;rsquo;s not included in the features brought into scope automatically in the prelude. Hash maps also have less support from the standard library; there&amp;rsquo;s no built-in macro to construct them, for example.</source>
          <target state="translated">Tenga en cuenta que primero debemos &lt;code&gt;use&lt;/code&gt; el &lt;code&gt;HashMap&lt;/code&gt; de la parte de colecciones de la biblioteca est&amp;aacute;ndar. De nuestras tres colecciones comunes, esta es la que se usa con menos frecuencia, por lo que no se incluye en las funciones incluidas en el alcance autom&amp;aacute;ticamente en el preludio. Los mapas hash tambi&amp;eacute;n tienen menos soporte de la biblioteca est&amp;aacute;ndar; no hay una macro incorporada para construirlos, por ejemplo.</target>
        </trans-unit>
        <trans-unit id="5da3fc4decf52dc450c6e612f0f2c00362fc9669" translate="yes" xml:space="preserve">
          <source>Note that we needed the &lt;code&gt;: Vec&amp;lt;i32&amp;gt;&lt;/code&gt; on the left-hand side. This is because we could collect into, for example, a &lt;a href=&quot;../collections/struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; instead:</source>
          <target state="translated">Tenga en cuenta que necesit&amp;aacute;bamos &lt;code&gt;: Vec&amp;lt;i32&amp;gt;&lt;/code&gt; en el lado izquierdo. Esto se debe a que podr&amp;iacute;amos recopilar, por ejemplo, en un &lt;a href=&quot;../collections/struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; lugar:</target>
        </trans-unit>
        <trans-unit id="75b55fff64dcfe7729e494e2a0b5e033941b67c8" translate="yes" xml:space="preserve">
          <source>Note that we needed to make &lt;code&gt;v1_iter&lt;/code&gt; mutable: calling the &lt;code&gt;next&lt;/code&gt; method on an iterator changes internal state that the iterator uses to keep track of where it is in the sequence. In other words, this code &lt;em&gt;consumes&lt;/em&gt;, or uses up, the iterator. Each call to &lt;code&gt;next&lt;/code&gt; eats up an item from the iterator. We didn&amp;rsquo;t need to make &lt;code&gt;v1_iter&lt;/code&gt; mutable when we used a &lt;code&gt;for&lt;/code&gt; loop because the loop took ownership of &lt;code&gt;v1_iter&lt;/code&gt; and made it mutable behind the scenes.</source>
          <target state="translated">Tenga en cuenta que necesit&amp;aacute;bamos hacer &lt;code&gt;v1_iter&lt;/code&gt; mutable: llamar al &lt;code&gt;next&lt;/code&gt; m&amp;eacute;todo en un iterador cambia el estado interno que el iterador usa para realizar un seguimiento de d&amp;oacute;nde est&amp;aacute; en la secuencia. En otras palabras, este c&amp;oacute;digo &lt;em&gt;consume&lt;/em&gt; o &lt;em&gt;agota&lt;/em&gt; el iterador. Cada llamada al &lt;code&gt;next&lt;/code&gt; consume un elemento del iterador. No necesit&amp;aacute;bamos hacer &lt;code&gt;v1_iter&lt;/code&gt; mutable cuando usamos un bucle &lt;code&gt;for&lt;/code&gt; porque el bucle tom&amp;oacute; posesi&amp;oacute;n de &lt;code&gt;v1_iter&lt;/code&gt; y lo hizo mutable detr&amp;aacute;s de escena.</target>
        </trans-unit>
        <trans-unit id="5994cd1512c44aaad650a1803fdb7c349136ad1d" translate="yes" xml:space="preserve">
          <source>Note that we want the function to take string slices, which are references, because we don&amp;rsquo;t want the &lt;code&gt;longest&lt;/code&gt; function to take ownership of its parameters. Refer to the &lt;a href=&quot;ch04-03-slices#string-slices-as-parameters&quot;&gt;&amp;ldquo;String Slices as Parameters&amp;rdquo;&lt;/a&gt; section in Chapter 4 for more discussion about why the parameters we use in Listing 10-20 are the ones we want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ee6c1ea883902ac8da8cc6969cf6510f9cd8cc8" translate="yes" xml:space="preserve">
          <source>Note that we want the function to take string slices, which are references, because we don&amp;rsquo;t want the &lt;code&gt;longest&lt;/code&gt; function to take ownership of its parameters. We want to allow the function to accept slices of a &lt;code&gt;String&lt;/code&gt; (the type stored in the variable &lt;code&gt;string1&lt;/code&gt;) as well as string literals (which is what variable &lt;code&gt;string2&lt;/code&gt; contains).</source>
          <target state="translated">Tenga en cuenta que queremos que la funci&amp;oacute;n tome segmentos de cadena, que son referencias, porque no queremos que la funci&amp;oacute;n &lt;code&gt;longest&lt;/code&gt; se apropie de sus par&amp;aacute;metros. Queremos permitir que la funci&amp;oacute;n acepte porciones de una &lt;code&gt;String&lt;/code&gt; (el tipo almacenado en la variable &lt;code&gt;string1&lt;/code&gt; ) as&amp;iacute; como literales de cadena (que es lo que contiene la variable &lt;code&gt;string2&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f37dca568a2a5ec6c0b22f134958fd92838997bb" translate="yes" xml:space="preserve">
          <source>Note that we&amp;rsquo;ve added a new line inside the &lt;code&gt;tests&lt;/code&gt; module: &lt;code&gt;use super::*;&lt;/code&gt;. The &lt;code&gt;tests&lt;/code&gt; module is a regular module that follows the usual visibility rules we covered in Chapter 7 in the &lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;&amp;ldquo;Modules as the Privacy Boundary&amp;rdquo;&lt;/a&gt; section. Because the &lt;code&gt;tests&lt;/code&gt; module is an inner module, we need to bring the code under test in the outer module into the scope of the inner module. We use a glob here so anything we define in the outer module is available to this &lt;code&gt;tests&lt;/code&gt; module.</source>
          <target state="translated">Tenga en cuenta que hemos agregado una nueva l&amp;iacute;nea dentro del m&amp;oacute;dulo de &lt;code&gt;tests&lt;/code&gt; : &lt;code&gt;use super::*;&lt;/code&gt; . El m&amp;oacute;dulo de &lt;code&gt;tests&lt;/code&gt; es un m&amp;oacute;dulo regular que sigue las reglas de visibilidad habituales que cubrimos en el Cap&amp;iacute;tulo 7 en la secci&amp;oacute;n &lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;&amp;ldquo;M&amp;oacute;dulos como l&amp;iacute;mite de privacidad&amp;rdquo;&lt;/a&gt; . Debido a que el m&amp;oacute;dulo de &lt;code&gt;tests&lt;/code&gt; es un m&amp;oacute;dulo interno, necesitamos llevar el c&amp;oacute;digo bajo prueba en el m&amp;oacute;dulo externo al alcance del m&amp;oacute;dulo interno. Usamos un glob aqu&amp;iacute; para que cualquier cosa que definamos en el m&amp;oacute;dulo externo est&amp;eacute; disponible para este m&amp;oacute;dulo de &lt;code&gt;tests&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e05c11c9aa8615f8372dccd3f7625301eed4295" translate="yes" xml:space="preserve">
          <source>Note that we&amp;rsquo;ve added a new line inside the &lt;code&gt;tests&lt;/code&gt; module: &lt;code&gt;use super::*;&lt;/code&gt;. The &lt;code&gt;tests&lt;/code&gt; module is a regular module that follows the usual visibility rules we covered in Chapter 7 in the &lt;a href=&quot;ch07-03-paths-for-referring-to-an-item-in-the-module-tree&quot;&gt;&amp;ldquo;Paths for Referring to an Item in the Module Tree&amp;rdquo;&lt;/a&gt; section. Because the &lt;code&gt;tests&lt;/code&gt; module is an inner module, we need to bring the code under test in the outer module into the scope of the inner module. We use a glob here so anything we define in the outer module is available to this &lt;code&gt;tests&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26a0be4b24350107b09144aaaa2ad0fb91731191" translate="yes" xml:space="preserve">
          <source>Note that we&amp;rsquo;ve edited the old test&amp;rsquo;s &lt;code&gt;contents&lt;/code&gt; too. We&amp;rsquo;ve added a new line with the text &lt;code&gt;&quot;Duct tape.&quot;&lt;/code&gt; using a capital D that shouldn&amp;rsquo;t match the query &lt;code&gt;&quot;duct&quot;&lt;/code&gt; when we&amp;rsquo;re searching in a case-sensitive manner. Changing the old test in this way helps ensure that we don&amp;rsquo;t accidentally break the case-sensitive search functionality that we&amp;rsquo;ve already implemented. This test should pass now and should continue to pass as we work on the case-insensitive search.</source>
          <target state="translated">Tenga en cuenta que tambi&amp;eacute;n hemos editado el &lt;code&gt;contents&lt;/code&gt; la prueba anterior . Hemos agregado una nueva l&amp;iacute;nea con el texto &lt;code&gt;&quot;Duct tape.&quot;&lt;/code&gt; utilizando una D may&amp;uacute;scula que no deber&amp;iacute;a coincidir con la consulta &lt;code&gt;&quot;duct&quot;&lt;/code&gt; cuando estamos buscando de manera sensible a may&amp;uacute;sculas y min&amp;uacute;sculas. Cambiar la prueba anterior de esta manera ayuda a garantizar que no rompamos accidentalmente la funcionalidad de b&amp;uacute;squeda que distingue entre may&amp;uacute;sculas y min&amp;uacute;sculas que ya hemos implementado. Esta prueba deber&amp;iacute;a pasar ahora y deber&amp;iacute;a seguir haci&amp;eacute;ndolo mientras trabajamos en la b&amp;uacute;squeda que no distingue entre may&amp;uacute;sculas y min&amp;uacute;sculas.</target>
        </trans-unit>
        <trans-unit id="2e87959963706a5a2e57c9724a365d2a982bba5d" translate="yes" xml:space="preserve">
          <source>Note that when the wildcard &lt;code&gt;*&lt;/code&gt; is used on a type, it does not import its methods (though for &lt;code&gt;enum&lt;/code&gt;s it imports the variants, as shown in the example below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b7bbbf14e1bc0dbc3662e9181bd406f83393130" translate="yes" xml:space="preserve">
          <source>Note that where ties occur, &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; is generally going to be faster than &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt; is generally going to be faster than &lt;a href=&quot;struct.linkedlist&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Tenga en cuenta que cuando se producen v&amp;iacute;nculos, &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; generalmente ser&amp;aacute; m&amp;aacute;s r&amp;aacute;pido que &lt;a href=&quot;struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; &lt;/a&gt; , y &lt;a href=&quot;struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; &lt;/a&gt; generalmente ser&amp;aacute; m&amp;aacute;s r&amp;aacute;pido que &lt;a href=&quot;struct.linkedlist&quot;&gt; &lt;code&gt;LinkedList&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b62f50352e9e786c961cd72638314895b5c9fdfc" translate="yes" xml:space="preserve">
          <source>Note that while concurrent access to environment variables is safe in Rust, some platforms only expose inherently unsafe non-threadsafe APIs for inspecting the environment. As a result extra care needs to be taken when auditing calls to unsafe external FFI functions to ensure that any external environment accesses are properly synchronized with accesses in Rust.</source>
          <target state="translated">Tenga en cuenta que,aunque el acceso simultáneo a las variables del entorno es seguro en Rust,algunas plataformas sólo exponen APIs inherentemente inseguras y no seguras para inspeccionar el entorno.Como resultado,es necesario tener un cuidado especial al auditar las llamadas a funciones FFI externas no seguras para garantizar que cualquier acceso al entorno externo esté correctamente sincronizado con los accesos en Rust.</target>
        </trans-unit>
        <trans-unit id="d3954c01ae7015c1edc03c422ae6922dcf56ba11" translate="yes" xml:space="preserve">
          <source>Note that while concurrent access to environment variables is safe in Rust, some platforms only expose inherently unsafe non-threadsafe APIs for inspecting the environment. As a result, extra care needs to be taken when auditing calls to unsafe external FFI functions to ensure that any external environment accesses are properly synchronized with accesses in Rust.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="324300377b3c3f353b3f11bc282603959b1e1422" translate="yes" xml:space="preserve">
          <source>Note that while mutating or mutably aliasing the contents of an &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; is ok (provided you enforce the invariants some other way), it is still undefined behavior to have multiple &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; aliases.</source>
          <target state="translated">Tenga en cuenta que aunque mutar o aliasar de forma mutante el contenido de un &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; est&amp;aacute; bien (siempre que aplique los invariantes de alguna otra manera), a&amp;uacute;n es un comportamiento indefinido tener m&amp;uacute;ltiples &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; alias de .</target>
        </trans-unit>
        <trans-unit id="9eb90457458f8170cc06094675d04f9c0e8116dd" translate="yes" xml:space="preserve">
          <source>Note that whilst mutating the contents of an &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; (even while other &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; references alias the cell) is ok (provided you enforce the above invariants some other way), it is still undefined behavior to have multiple &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; aliases. That is, &lt;code&gt;UnsafeCell&lt;/code&gt; is a wrapper designed to have a special interaction with &lt;em&gt;shared&lt;/em&gt; accesses (&lt;em&gt;i.e.&lt;/em&gt;, through an &lt;code&gt;&amp;amp;UnsafeCell&amp;lt;_&amp;gt;&lt;/code&gt; reference); there is no magic whatsoever when dealing with &lt;em&gt;exclusive&lt;/em&gt; accesses (&lt;em&gt;e.g.&lt;/em&gt;, through an &lt;code&gt;&amp;amp;mut UnsafeCell&amp;lt;_&amp;gt;&lt;/code&gt;): neither the cell nor the wrapped value may be aliased for the duration of that &lt;code&gt;&amp;amp;mut&lt;/code&gt; borrow. This is showcased by the &lt;a href=&quot;struct.unsafecell#method.get_mut&quot;&gt;&lt;code&gt;.get_mut()&lt;/code&gt;&lt;/a&gt; accessor, which is a non-&lt;code&gt;unsafe&lt;/code&gt; getter that yields a &lt;code&gt;&amp;amp;mut T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ea0c44d2eb4a19014b1a6e779035e8b52686247" translate="yes" xml:space="preserve">
          <source>Note that with this function, the new thread will be stopped when the main thread ends, whether or not it has finished running. The output from this program might be a little different every time, but it will look similar to the following:</source>
          <target state="translated">Tenga en cuenta que con esta función,el nuevo hilo se detendrá cuando el hilo principal termine,tanto si ha terminado de correr como si no.La salida de este programa puede ser un poco diferente cada vez,pero tendrá un aspecto similar al siguiente:</target>
        </trans-unit>
        <trans-unit id="499913d6f995a629a9ad09275a1ae60af65eff00" translate="yes" xml:space="preserve">
          <source>Note that writing updates the slice to point to the yet unwritten part. The slice will be empty when it has been completely overwritten.</source>
          <target state="translated">Note que la escritura actualiza la rebanada para señalar la parte aún no escrita.El trozo estará vacío cuando se haya sobrescrito completamente.</target>
        </trans-unit>
        <trans-unit id="30da6e410f76967402353bb250335b332eb88eb5" translate="yes" xml:space="preserve">
          <source>Note that you cannot use the &lt;a href=&quot;../../book/appendix-02-operators&quot;&gt;&lt;code&gt;?&lt;/code&gt; operator&lt;/a&gt; in functions that do not return a &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;. Instead, you can call &lt;a href=&quot;../result/enum.result#method.unwrap&quot;&gt;&lt;code&gt;.unwrap()&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;match&lt;/code&gt; on the return value to catch any possible errors:</source>
          <target state="translated">Tenga en cuenta que no puede utilizar el &lt;a href=&quot;../../book/appendix-02-operators&quot;&gt; &lt;code&gt;?&lt;/code&gt; operador&lt;/a&gt; en funciones que no devuelven un &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; &lt;/a&gt; . En su lugar, puede llamar a &lt;a href=&quot;../result/enum.result#method.unwrap&quot;&gt; &lt;code&gt;.unwrap()&lt;/code&gt; &lt;/a&gt; o hacer &lt;code&gt;match&lt;/code&gt; el valor de retorno para detectar cualquier posible error:</target>
        </trans-unit>
        <trans-unit id="8cd9969c1871eeacc0200593b93cdcffbccf3e66" translate="yes" xml:space="preserve">
          <source>Note that, although read and write methods require a &lt;code&gt;&amp;amp;mut File&lt;/code&gt;, because of the interfaces for &lt;a href=&quot;../io/trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt;, the holder of a &lt;code&gt;&amp;amp;File&lt;/code&gt; can still modify the file, either through methods that take &lt;code&gt;&amp;amp;File&lt;/code&gt; or by retrieving the underlying OS object and modifying the file that way. Additionally, many operating systems allow concurrent modification of files by different processes. Avoid assuming that holding a &lt;code&gt;&amp;amp;File&lt;/code&gt; means that the file will not change.</source>
          <target state="translated">Tenga en cuenta que, aunque los m&amp;eacute;todos de lectura y escritura requieren un &lt;code&gt;&amp;amp;mut File&lt;/code&gt; , debido a las interfaces de &lt;a href=&quot;../io/trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../io/trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt; , el titular de un &lt;code&gt;&amp;amp;File&lt;/code&gt; a&amp;uacute;n puede modificar el archivo, ya sea mediante m&amp;eacute;todos que toman &lt;code&gt;&amp;amp;File&lt;/code&gt; o recuperando el objeto del sistema operativo subyacente y modificando el archivo. de esa manera. Adem&amp;aacute;s, muchos sistemas operativos permiten la modificaci&amp;oacute;n simult&amp;aacute;nea de archivos mediante diferentes procesos. Evite asumir que tener un &lt;code&gt;&amp;amp;File&lt;/code&gt; significa que el archivo no cambiar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="1d0cf8461e762586f36c776928c774ad1d9122e5" translate="yes" xml:space="preserve">
          <source>Note that, because &lt;code&gt;$crate&lt;/code&gt; refers to the current crate, it must be used with a fully qualified module path when referring to non-macro items:</source>
          <target state="translated">Tenga en cuenta que, debido a que &lt;code&gt;$crate&lt;/code&gt; refiere a la caja actual, debe usarse con una ruta de m&amp;oacute;dulo completamente calificada cuando se refiere a elementos que no son macro:</target>
        </trans-unit>
        <trans-unit id="160864ae0e83232cc21d9f02b2b16fec0e686a4e" translate="yes" xml:space="preserve">
          <source>Note that, like the &lt;code&gt;Option&lt;/code&gt; enum, the &lt;code&gt;Result&lt;/code&gt; enum and its variants have been brought into scope by the prelude, so we don&amp;rsquo;t need to specify &lt;code&gt;Result::&lt;/code&gt; before the &lt;code&gt;Ok&lt;/code&gt; and &lt;code&gt;Err&lt;/code&gt; variants in the &lt;code&gt;match&lt;/code&gt; arms.</source>
          <target state="translated">Tenga en cuenta que, al igual que la enumeraci&amp;oacute;n &lt;code&gt;Option&lt;/code&gt; , la enumeraci&amp;oacute;n &lt;code&gt;Result&lt;/code&gt; y sus variantes se han incluido en el alcance del preludio, por lo que no es necesario especificar &lt;code&gt;Result::&lt;/code&gt; antes de las variantes &lt;code&gt;Ok&lt;/code&gt; y &lt;code&gt;Err&lt;/code&gt; en los brazos de &lt;code&gt;match&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="669f2ea820772978e72d4c3d94e7389c9756f1a1" translate="yes" xml:space="preserve">
          <source>Note that, this &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;may change in the future&lt;/a&gt;.</source>
          <target state="translated">Tenga en cuenta que esto &lt;a href=&quot;../io/index#platform-specific-behavior&quot;&gt;puede cambiar en el futuro&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="169cf16d0a1c963eafd20679aea07a420f4eaf39" translate="yes" xml:space="preserve">
          <source>Note that, unlike &lt;code&gt;repeat&lt;/code&gt;, &lt;code&gt;repeat_packed&lt;/code&gt; does not guarantee that the repeated instances of &lt;code&gt;self&lt;/code&gt; will be properly aligned, even if a given instance of &lt;code&gt;self&lt;/code&gt; is properly aligned. In other words, if the layout returned by &lt;code&gt;repeat_packed&lt;/code&gt; is used to allocate an array, it is not guaranteed that all elements in the array will be properly aligned.</source>
          <target state="translated">Tenga en cuenta que, a diferencia de &lt;code&gt;repeat&lt;/code&gt; , &lt;code&gt;repeat_packed&lt;/code&gt; no garantiza que las instancias repetidas de &lt;code&gt;self&lt;/code&gt; est&amp;eacute;n correctamente alineadas, incluso si una instancia determinada de &lt;code&gt;self&lt;/code&gt; est&amp;aacute; correctamente alineada. En otras palabras, si el dise&amp;ntilde;o devuelto por &lt;code&gt;repeat_packed&lt;/code&gt; se usa para asignar una matriz, no se garantiza que todos los elementos de la matriz est&amp;eacute;n alineados correctamente.</target>
        </trans-unit>
        <trans-unit id="285f98e8d01e4962eff6724b78a3c6724d0931e6" translate="yes" xml:space="preserve">
          <source>Note that:</source>
          <target state="translated">Fíjese en eso:</target>
        </trans-unit>
        <trans-unit id="fc7308ef65a4b47d9c6953435d548f4e965b07bd" translate="yes" xml:space="preserve">
          <source>Note the documentation for the primitives &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;slice/index&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; (also called 'slice'). Many method calls on &lt;a href=&quot;string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; are actually calls to methods on &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;slice/index&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; respectively, via &lt;a href=&quot;../book/ch15-02-deref#implicit-deref-coercions-with-functions-and-methods&quot;&gt;deref coercions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6d8fcef27cc36a94771021effc9ea114018af44" translate="yes" xml:space="preserve">
          <source>Note the documentation for the primitives &lt;a href=&quot;primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;primitive.slice&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; (also called 'slice'). Many method calls on &lt;a href=&quot;string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;vec/index&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; are actually calls to methods on &lt;a href=&quot;primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;primitive.slice&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; respectively, via &lt;a href=&quot;../book/ch15-02-deref#implicit-deref-coercions-with-functions-and-methods&quot;&gt;deref coercions&lt;/a&gt;.</source>
          <target state="translated">Tenga en cuenta la documentaci&amp;oacute;n de las primitivas &lt;a href=&quot;primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;primitive.slice&quot;&gt; &lt;code&gt;[T]&lt;/code&gt; &lt;/a&gt; (tambi&amp;eacute;n llamado 'segmento'). Muchas llamadas a m&amp;eacute;todos en &lt;a href=&quot;string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;vec/index&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; son en realidad llamadas a m&amp;eacute;todos en &lt;a href=&quot;primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;primitive.slice&quot;&gt; &lt;code&gt;[T]&lt;/code&gt; &lt;/a&gt; respectivamente, a trav&amp;eacute;s de &lt;a href=&quot;../book/ch15-02-deref#implicit-deref-coercions-with-functions-and-methods&quot;&gt;coacciones deref&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9ca3cd3caadb8f1bb227db05f6c5c7202e5bbf2b" translate="yes" xml:space="preserve">
          <source>Note to Implementors</source>
          <target state="translated">Nota para los ejecutores</target>
        </trans-unit>
        <trans-unit id="c4cf4c3bcaeb43c85321fdb977bbc1c650a58e54" translate="yes" xml:space="preserve">
          <source>Note to implementors: If this returns &lt;code&gt;Ok(ptr)&lt;/code&gt;, then &lt;code&gt;ptr&lt;/code&gt; must be considered &quot;currently allocated&quot; and must be acceptable input to methods such as &lt;code&gt;realloc&lt;/code&gt; or &lt;code&gt;dealloc&lt;/code&gt;, &lt;em&gt;even if&lt;/em&gt;&lt;code&gt;T&lt;/code&gt; is a zero-sized type. In other words, if your &lt;code&gt;Alloc&lt;/code&gt; implementation overrides this method in a manner that can return a zero-sized &lt;code&gt;ptr&lt;/code&gt;, then all reallocation and deallocation methods need to be similarly overridden to accept such values as input.</source>
          <target state="translated">Nota para los implementadores: si esto devuelve &lt;code&gt;Ok(ptr)&lt;/code&gt; , entonces &lt;code&gt;ptr&lt;/code&gt; debe considerarse &quot;actualmente asignado&quot; y debe ser una entrada aceptable para m&amp;eacute;todos como &lt;code&gt;realloc&lt;/code&gt; o &lt;code&gt;dealloc&lt;/code&gt; , &lt;em&gt;incluso si &lt;/em&gt; &lt;code&gt;T&lt;/code&gt; es un tipo de tama&amp;ntilde;o cero. En otras palabras, si su implementaci&amp;oacute;n de &lt;code&gt;Alloc&lt;/code&gt; anula este m&amp;eacute;todo de una manera que puede devolver un &lt;code&gt;ptr&lt;/code&gt; de tama&amp;ntilde;o cero , entonces todos los m&amp;eacute;todos de reasignaci&amp;oacute;n y desasignaci&amp;oacute;n deben anularse de manera similar para aceptar tales valores como entrada.</target>
        </trans-unit>
        <trans-unit id="eb0cc1533f57d8d34b3b5bb324e9cedcd986a56b" translate="yes" xml:space="preserve">
          <source>Note two details here. First, we use the index value of &lt;code&gt;2&lt;/code&gt; to get the third element: vectors are indexed by number, starting at zero. Second, the two ways to get the third element are by using &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;[]&lt;/code&gt;, which gives us a reference, or by using the &lt;code&gt;get&lt;/code&gt; method with the index passed as an argument, which gives us an &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta dos detalles aqu&amp;iacute;. Primero, usamos el valor de &amp;iacute;ndice de &lt;code&gt;2&lt;/code&gt; para obtener el tercer elemento: los vectores est&amp;aacute;n indexados por n&amp;uacute;mero, comenzando en cero. En segundo lugar, las dos formas de obtener el tercer elemento son usando &lt;code&gt;&amp;amp;&lt;/code&gt; y &lt;code&gt;[]&lt;/code&gt; , que nos da una referencia, o usando el m&amp;eacute;todo &lt;code&gt;get&lt;/code&gt; con el &amp;iacute;ndice pasado como argumento, lo que nos da una &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c6f9d9871d6089da68d73e5351d58428691fe43" translate="yes" xml:space="preserve">
          <source>Note, &lt;code&gt;OsString&lt;/code&gt; and &lt;a href=&quot;struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; internally do not necessarily hold strings in the form native to the platform; While on Unix, strings are stored as a sequence of 8-bit values, on Windows, where strings are 16-bit value based as just discussed, strings are also actually stored as a sequence of 8-bit values, encoded in a less-strict variant of UTF-8. This is useful to understand when handling capacity and length values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c01e48a0e7e3eba8ed1aa3834f9c910b228bd638" translate="yes" xml:space="preserve">
          <source>Note, &lt;code&gt;OsString&lt;/code&gt; and &lt;code&gt;OsStr&lt;/code&gt; internally do not necessarily hold strings in the form native to the platform; While on Unix, strings are stored as a sequence of 8-bit values, on Windows, where strings are 16-bit value based as just discussed, strings are also actually stored as a sequence of 8-bit values, encoded in a less-strict variant of UTF-8. This is useful to understand when handling capacity and length values.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;OsString&lt;/code&gt; y &lt;code&gt;OsStr&lt;/code&gt; internamente no contienen necesariamente cadenas en la forma nativa de la plataforma; Mientras que en Unix, las cadenas se almacenan como una secuencia de valores de 8 bits, en Windows, donde las cadenas se basan en valores de 16 bits como se acaba de discutir, las cadenas tambi&amp;eacute;n se almacenan en realidad como una secuencia de valores de 8 bits, codificados en un formato menos variante estricta de UTF-8. Es &amp;uacute;til comprender esto cuando se manejan valores de capacidad y longitud.</target>
        </trans-unit>
        <trans-unit id="1b6562c6a35d081cb513ca527b316f894645e45c" translate="yes" xml:space="preserve">
          <source>Note, however, that instants are not guaranteed to be &lt;strong&gt;steady&lt;/strong&gt;. In other words, each tick of the underlying clock may not be the same length (e.g. some seconds may be longer than others). An instant may jump forwards or experience time dilation (slow down or speed up), but it will never go backwards.</source>
          <target state="translated">Sin embargo, tenga en cuenta que no se garantiza que los instantes sean &lt;strong&gt;estables&lt;/strong&gt; . En otras palabras, cada tic del reloj subyacente puede no tener la misma duraci&amp;oacute;n (por ejemplo, algunos segundos pueden ser m&amp;aacute;s largos que otros). Un instante puede saltar hacia adelante o experimentar una dilataci&amp;oacute;n del tiempo (ralentizar o acelerar), pero nunca retroceder&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="9fd9dfc12db2bc0dbc56fcf4d3cda55381327924" translate="yes" xml:space="preserve">
          <source>Note, however, that items with the same name are allowed for inherent &lt;code&gt;impl&lt;/code&gt; blocks that don't overlap:</source>
          <target state="translated">Sin embargo, tenga en cuenta que los elementos con el mismo nombre est&amp;aacute;n permitidos para bloques &lt;code&gt;impl&lt;/code&gt; inherentes que no se superponen:</target>
        </trans-unit>
        <trans-unit id="bba68cd3cf8ae8ea0e35e174666c8e34f0cdd55c" translate="yes" xml:space="preserve">
          <source>Note, however, that this is not an unsafe trait, so there is not a succinct contract that this trait is providing. Instead it is intended as more of a &quot;speed bump&quot; to alert users of &lt;code&gt;catch_unwind&lt;/code&gt; that broken invariants may be witnessed and may need to be accounted for.</source>
          <target state="translated">Sin embargo, tenga en cuenta que este no es un rasgo inseguro, por lo que no hay un contrato sucinto que este rasgo proporcione. En su lugar, tiene la intenci&amp;oacute;n de ser m&amp;aacute;s como un &quot;golpe de velocidad&quot; para alertar a los usuarios de &lt;code&gt;catch_unwind&lt;/code&gt; que se pueden presenciar invariantes rotos y es posible que deban tenerse en cuenta.</target>
        </trans-unit>
        <trans-unit id="d9f40e0b31d5319e2e2946733cad557830f8c197" translate="yes" xml:space="preserve">
          <source>Note, in many cases, the &lt;code&gt;.parse()&lt;/code&gt; method on &lt;code&gt;str&lt;/code&gt; is more proper.</source>
          <target state="translated">Tenga en cuenta que, en muchos casos, el m&amp;eacute;todo &lt;code&gt;.parse()&lt;/code&gt; en &lt;code&gt;str&lt;/code&gt; es m&amp;aacute;s adecuado.</target>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="74d10a535a759833af93c81cb97d5c0957382347" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;Pin&lt;/code&gt; also implements &lt;code&gt;Deref&lt;/code&gt; to the target, which can be used to access the inner value. However, &lt;code&gt;Deref&lt;/code&gt; only provides a reference that lives for as long as the borrow of the &lt;code&gt;Pin&lt;/code&gt;, not the lifetime of the &lt;code&gt;Pin&lt;/code&gt; itself. This method allows turning the &lt;code&gt;Pin&lt;/code&gt; into a reference with the same lifetime as the original &lt;code&gt;Pin&lt;/code&gt;.</source>
          <target state="translated">Nota: &lt;code&gt;Pin&lt;/code&gt; tambi&amp;eacute;n implementa &lt;code&gt;Deref&lt;/code&gt; en el objetivo, que se puede usar para acceder al valor interno. Sin embargo, &lt;code&gt;Deref&lt;/code&gt; solo proporciona una referencia que dura tanto como el &lt;code&gt;Pin&lt;/code&gt; prestado , no la vida &amp;uacute;til del &lt;code&gt;Pin&lt;/code&gt; en s&amp;iacute;. Este m&amp;eacute;todo permite convertir el &lt;code&gt;Pin&lt;/code&gt; en una referencia con la misma vida &amp;uacute;til que el &lt;code&gt;Pin&lt;/code&gt; original .</target>
        </trans-unit>
        <trans-unit id="e10aafb3dc6afa8d8827646e5b1be7126b35103b" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;Pin&lt;/code&gt; also implements &lt;code&gt;DerefMut&lt;/code&gt; to the data, which can be used to access the inner value. However, &lt;code&gt;DerefMut&lt;/code&gt; only provides a reference that lives for as long as the borrow of the &lt;code&gt;Pin&lt;/code&gt;, not the lifetime of the &lt;code&gt;Pin&lt;/code&gt; itself. This method allows turning the &lt;code&gt;Pin&lt;/code&gt; into a reference with the same lifetime as the original &lt;code&gt;Pin&lt;/code&gt;.</source>
          <target state="translated">Nota: &lt;code&gt;Pin&lt;/code&gt; tambi&amp;eacute;n implementa &lt;code&gt;DerefMut&lt;/code&gt; en los datos, que se pueden usar para acceder al valor interno. Sin embargo, &lt;code&gt;DerefMut&lt;/code&gt; solo proporciona una referencia que dura tanto como el &lt;code&gt;Pin&lt;/code&gt; prestado , no la vida &amp;uacute;til del &lt;code&gt;Pin&lt;/code&gt; en s&amp;iacute;. Este m&amp;eacute;todo permite convertir el &lt;code&gt;Pin&lt;/code&gt; en una referencia con la misma vida &amp;uacute;til que el &lt;code&gt;Pin&lt;/code&gt; original .</target>
        </trans-unit>
        <trans-unit id="fe08fa35bb3e2ac30191647bef4f566cd6842a4b" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;core&lt;/code&gt; provides &lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.Location.html#method.caller&quot;&gt;&lt;code&gt;core::panic::Location::caller&lt;/code&gt;&lt;/a&gt; for observing caller locations. It wraps the &lt;a href=&quot;https://doc.rust-lang.org/core/intrinsics/fn.caller_location.html&quot;&gt;&lt;code&gt;core::intrinsics::caller_location&lt;/code&gt;&lt;/a&gt; intrinsic implemented by &lt;code&gt;rustc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da175d20fbd0f82cb13b82934a46d444a5435526" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;fold()&lt;/code&gt;, and similar methods that traverse the entire iterator, may not terminate for infinite iterators, even on traits for which a result is determinable in finite time.</source>
          <target state="translated">Nota: &lt;code&gt;fold()&lt;/code&gt; y m&amp;eacute;todos similares que atraviesan todo el iterador pueden no terminar para iteradores infinitos, incluso en rasgos para los que un resultado es determinable en tiempo finito.</target>
        </trans-unit>
        <trans-unit id="e47db031d7d5048ad3ea3101c6bbce09857b0d75" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;move&lt;/code&gt; closures may still implement &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, even though they capture variables by move. This is because the traits implemented by a closure type are determined by what the closure does with captured values, not how it captures them.</source>
          <target state="translated">Nota: los cierres de &lt;code&gt;move&lt;/code&gt; a&amp;uacute;n pueden implementar &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt; , aunque capturan variables por movimiento. Esto se debe a que los rasgos implementados por un tipo de cierre est&amp;aacute;n determinados por lo que hace el cierre con los valores capturados, no por c&amp;oacute;mo los captura.</target>
        </trans-unit>
        <trans-unit id="ddaee189fcb99b6fc9ed6acd8de34bd62f953e86" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;move&lt;/code&gt; closures may still implement &lt;a href=&quot;ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, even though they capture variables by &lt;code&gt;move&lt;/code&gt;. This is because the traits implemented by a closure type are determined by &lt;em&gt;what&lt;/em&gt; the closure does with captured values, not &lt;em&gt;how&lt;/em&gt; it captures them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="690213e0deea1a6806299e07c579a3daee97b81a" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;rustc&lt;/code&gt; currently recognizes the tools &quot;clippy&quot; and &quot;rustfmt&quot;.</source>
          <target state="translated">Nota: &lt;code&gt;rustc&lt;/code&gt; actualmente reconoce las herramientas &quot;clippy&quot; y &quot;rustfmt&quot;.</target>
        </trans-unit>
        <trans-unit id="16697ad37b7a39052ef81a40c40ae4ac1a88fc27" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;rustc&lt;/code&gt; has a default set of features enabled for each target and CPU. The CPU may be chosen with the &lt;a href=&quot;https://doc.rust-lang.org/rustc/codegen-options/index.html#target-cpu&quot;&gt;&lt;code&gt;-C target-cpu&lt;/code&gt;&lt;/a&gt; flag. Individual features may be enabled or disabled for an entire crate with the &lt;a href=&quot;https://doc.rust-lang.org/rustc/codegen-options/index.html#target-feature&quot;&gt;&lt;code&gt;-C target-feature&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">Nota: &lt;code&gt;rustc&lt;/code&gt; tiene un conjunto predeterminado de funciones habilitadas para cada destino y CPU. La CPU puede elegirse con el indicador &lt;a href=&quot;https://doc.rust-lang.org/rustc/codegen-options/index.html#target-cpu&quot;&gt; &lt;code&gt;-C target-cpu&lt;/code&gt; &lt;/a&gt; . Las caracter&amp;iacute;sticas individuales pueden habilitarse o inhabilitarse para una caja completa con el indicador de &lt;a href=&quot;https://doc.rust-lang.org/rustc/codegen-options/index.html#target-feature&quot;&gt; &lt;code&gt;-C target-feature&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3f9c395bf29ddc7654449b79d4dc0411e7becef5" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;str&lt;/code&gt; in &lt;code&gt;Concat&amp;lt;str&amp;gt;&lt;/code&gt; is not meaningful here. This type parameter of the trait only exists to enable another impl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0d79cac345f205a82618d9422d71b4ef0b8bd13" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;union&lt;/code&gt;s with non-&lt;code&gt;Copy&lt;/code&gt; fields are unstable, see &lt;a href=&quot;https://github.com/rust-lang/rust/issues/55149&quot;&gt;55149&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03f067cb5c2a75451afd3b78affad51470bfd979" translate="yes" xml:space="preserve">
          <source>Note: A saying you might hear about languages with strict compilers, such as Haskell and Rust, is &amp;ldquo;if the code compiles, it works.&amp;rdquo; But this saying is not universally true. Our project compiles, but it does absolutely nothing! If we were building a real, complete project, this would be a good time to start writing unit tests to check that the code compiles &lt;em&gt;and&lt;/em&gt; has the behavior we want.</source>
          <target state="translated">Nota: Un dicho que puede escuchar acerca de lenguajes con compiladores estrictos, como Haskell y Rust, es &quot;si el c&amp;oacute;digo se compila, funciona&quot;. Pero este dicho no es universalmente cierto. Nuestro proyecto se compila, &amp;iexcl;pero no hace absolutamente nada! Si estuvi&amp;eacute;ramos construyendo un proyecto real y completo, este ser&amp;iacute;a un buen momento para empezar a escribir pruebas unitarias para comprobar que el c&amp;oacute;digo se compila &lt;em&gt;y&lt;/em&gt; tiene el comportamiento que queremos.</target>
        </trans-unit>
        <trans-unit id="84c66645b448fa01124ab16b053b24421063478c" translate="yes" xml:space="preserve">
          <source>Note: Although Rust, like any other language, can be implemented by an interpreter as well as a compiler, the only existing implementation is a compiler, and the language has always been designed to be compiled. For these reasons, this section assumes a compiler.</source>
          <target state="translated">Nota:Aunque Rust,como cualquier otro lenguaje,puede ser implementado tanto por un intérprete como por un compilador,la única implementación existente es un compilador,y el lenguaje siempre ha sido diseñado para ser compilado.Por estas razones,esta sección asume un compilador.</target>
        </trans-unit>
        <trans-unit id="549bd43e93414c7d2e6a9dbfe6f61cd7449ba2c8" translate="yes" xml:space="preserve">
          <source>Note: As a consequence of the representation being an attribute on the item, the representation does not depend on generic parameters. Any two types with the same name have the same representation. For example, &lt;code&gt;Foo&amp;lt;Bar&amp;gt;&lt;/code&gt; and &lt;code&gt;Foo&amp;lt;Baz&amp;gt;&lt;/code&gt; both have the same representation.</source>
          <target state="translated">Nota: Como consecuencia de que la representaci&amp;oacute;n es un atributo del art&amp;iacute;culo, la representaci&amp;oacute;n no depende de par&amp;aacute;metros gen&amp;eacute;ricos. Dos tipos cualesquiera con el mismo nombre tienen la misma representaci&amp;oacute;n. Por ejemplo, &lt;code&gt;Foo&amp;lt;Bar&amp;gt;&lt;/code&gt; y &lt;code&gt;Foo&amp;lt;Baz&amp;gt;&lt;/code&gt; tienen la misma representaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="4eecc607640ace8103d5bc0d89cfb23325aabecd" translate="yes" xml:space="preserve">
          <source>Note: As a control flow expression, if a block expression is the outer expression of an expression statement, the expected type is &lt;code&gt;()&lt;/code&gt; unless it is followed immediately by a semicolon.</source>
          <target state="translated">Nota: Como expresi&amp;oacute;n de flujo de control, si una expresi&amp;oacute;n de bloque es la expresi&amp;oacute;n externa de una declaraci&amp;oacute;n de expresi&amp;oacute;n, el tipo esperado es &lt;code&gt;()&lt;/code&gt; a menos que est&amp;eacute; seguida inmediatamente por un punto y coma.</target>
        </trans-unit>
        <trans-unit id="09b47fffa556007259b32260e62d1512eb70865a" translate="yes" xml:space="preserve">
          <source>Note: Due to the representation of &lt;code&gt;repr(C)&lt;/code&gt; structs and unions, if a variant has a single field there is no difference between putting that field directly in the union or wrapping it in a struct; any system which wishes to manipulate such an &lt;code&gt;enum&lt;/code&gt;'s representation may therefore use whichever form is more convenient or consistent for them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4faa88d09ab8f796d3c14502d5099ff92578c5dd" translate="yes" xml:space="preserve">
          <source>Note: Except for lints, it is idiomatic to only use outer attributes on function items.</source>
          <target state="translated">Nota:Excepto por las pelusas,es idiomático utilizar sólo los atributos externos en los elementos de función.</target>
        </trans-unit>
        <trans-unit id="6b662a83fcf6e331b5fc245d3658b8a2a3115d43" translate="yes" xml:space="preserve">
          <source>Note: For clarity, it is recommended to always use the &lt;code&gt;dyn&lt;/code&gt; keyword on your trait objects unless your codebase supports compiling with Rust 1.26 or lower.</source>
          <target state="translated">Nota: Para mayor claridad, se recomienda usar siempre la palabra clave &lt;code&gt;dyn&lt;/code&gt; en sus objetos de caracter&amp;iacute;sticas a menos que su base de c&amp;oacute;digo admita la compilaci&amp;oacute;n con Rust 1.26 o inferior.</target>
        </trans-unit>
        <trans-unit id="1aaba7d58782adfa40a3a8e21596376db2da64ca" translate="yes" xml:space="preserve">
          <source>Note: For more on the implementation details of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; type, see &amp;ldquo;The Rustonomicon&amp;rdquo; at https://doc.rust-lang.org/stable/nomicon/vec.html.</source>
          <target state="translated">Nota: Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre los detalles de implementaci&amp;oacute;n del tipo &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; , consulte &quot;El Rustonomicon&quot; en https://doc.rust-lang.org/stable/nomicon/vec.html.</target>
        </trans-unit>
        <trans-unit id="12ed0cecef028f179120e48d11efd24c874bfd2d" translate="yes" xml:space="preserve">
          <source>Note: For more on the implementation details of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; type, see &lt;a href=&quot;https://doc.rust-lang.org/nomicon/vec.html&quot;&gt;&amp;ldquo;The Rustonomicon&amp;rdquo;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e05c47a1f80ea2f9b4aa153e205bdf1032d2902" translate="yes" xml:space="preserve">
          <source>Note: For simplicity&amp;rsquo;s sake, we&amp;rsquo;ll refer to many of the problems as &lt;em&gt;concurrent&lt;/em&gt; rather than being more precise by saying &lt;em&gt;concurrent and/or parallel&lt;/em&gt;. If this book were about concurrency and/or parallelism, we&amp;rsquo;d be more specific. For this chapter, please mentally substitute &lt;em&gt;concurrent and/or parallel&lt;/em&gt; whenever we use &lt;em&gt;concurrent&lt;/em&gt;.</source>
          <target state="translated">Nota: En aras de la simplicidad, nos referiremos a muchos de los problemas como &lt;em&gt;concurrentes.&lt;/em&gt; lugar de ser m&amp;aacute;s precisos al decir &lt;em&gt;concurrentes y / o paralelos&lt;/em&gt; . Si este libro fuera sobre concurrencia y / o paralelismo, ser&amp;iacute;amos m&amp;aacute;s espec&amp;iacute;ficos. Para este cap&amp;iacute;tulo, sustituya mentalmente &lt;em&gt;concurrente y / o paralelo&lt;/em&gt; siempre que usemos &lt;em&gt;concurrente&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f2bcd0ee14b84ad9b9e572efa4f60a2cdc02453c" translate="yes" xml:space="preserve">
          <source>Note: Functions can implement all three of the &lt;code&gt;Fn&lt;/code&gt; traits too. If what we want to do doesn&amp;rsquo;t require capturing a value from the environment, we can use a function rather than a closure where we need something that implements an &lt;code&gt;Fn&lt;/code&gt; trait.</source>
          <target state="translated">Nota: Las funciones tambi&amp;eacute;n pueden implementar los tres rasgos &lt;code&gt;Fn&lt;/code&gt; . Si lo que queremos hacer no requiere capturar un valor del entorno, podemos usar una funci&amp;oacute;n en lugar de un cierre donde necesitamos algo que implemente un rasgo &lt;code&gt;Fn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d3096da378822b99ae4c5c058d93a4ddaf9860b" translate="yes" xml:space="preserve">
          <source>Note: Git is a common version control system. You can change &lt;code&gt;cargo new&lt;/code&gt; to use a different version control system or no version control system by using the &lt;code&gt;--vcs&lt;/code&gt; flag. Run &lt;code&gt;cargo new --help&lt;/code&gt; to see the available options.</source>
          <target state="translated">Nota: Git es un sistema de control de versiones com&amp;uacute;n. Puedes cambiar &lt;code&gt;cargo new&lt;/code&gt; para usar un sistema de control de versiones diferente o ning&amp;uacute;n sistema de control de versiones usando la &lt;code&gt;--vcs&lt;/code&gt; . Ejecutar &lt;code&gt;cargo new --help&lt;/code&gt; para ver las opciones disponibles.</target>
        </trans-unit>
        <trans-unit id="0df14a643f96169ae07176fb1e5faadaf3d41970" translate="yes" xml:space="preserve">
          <source>Note: Historically, place expressions were called &lt;em&gt;lvalues&lt;/em&gt; and value expressions were called &lt;em&gt;rvalues&lt;/em&gt;.</source>
          <target state="translated">Nota: Hist&amp;oacute;ricamente, las expresiones de lugar se llamaban &lt;em&gt; lvalues&lt;/em&gt; y expresiones de valor fueron llamados &lt;em&gt;rvalues&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="95d17fa37d73d94b4ba6d7a45e2dff4566bcf95b" translate="yes" xml:space="preserve">
          <source>Note: If the &lt;code&gt;PeekMut&lt;/code&gt; value is leaked, the heap may be in an inconsistent state.</source>
          <target state="translated">Nota: Si se &lt;code&gt;PeekMut&lt;/code&gt; valor de PeekMut , el mont&amp;oacute;n puede estar en un estado incoherente.</target>
        </trans-unit>
        <trans-unit id="b84582c8d2e5caf9e744d83f9c53f4f316f3938a" translate="yes" xml:space="preserve">
          <source>Note: If you prefer not to use &lt;code&gt;rustup&lt;/code&gt; for some reason, please see &lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;the Rust installation page&lt;/a&gt; for other options.</source>
          <target state="translated">Nota: si prefiere no utilizar &lt;code&gt;rustup&lt;/code&gt; por alg&amp;uacute;n motivo, consulte &lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;la p&amp;aacute;gina de instalaci&amp;oacute;n de Rust&lt;/a&gt; para conocer otras opciones.</target>
        </trans-unit>
        <trans-unit id="0d58c0919378a7a1e84f8dd3400503ede165358e" translate="yes" xml:space="preserve">
          <source>Note: In C++, this pattern of deallocating resources at the end of an item&amp;rsquo;s lifetime is sometimes called &lt;em&gt;Resource Acquisition Is Initialization (RAII)&lt;/em&gt;. The &lt;code&gt;drop&lt;/code&gt; function in Rust will be familiar to you if you&amp;rsquo;ve used RAII patterns.</source>
          <target state="translated">Nota: En C ++, este patr&amp;oacute;n de desasignaci&amp;oacute;n de recursos al final de la vida &amp;uacute;til de un elemento a veces se denomina &lt;em&gt;Adquisici&amp;oacute;n de recursos es inicializaci&amp;oacute;n (RAII)&lt;/em&gt; . La funci&amp;oacute;n de &lt;code&gt;drop&lt;/code&gt; en Rust le resultar&amp;aacute; familiar si ha utilizado patrones RAII.</target>
        </trans-unit>
        <trans-unit id="54b56211cde322330df3d7c8028b1e66317b030b" translate="yes" xml:space="preserve">
          <source>Note: In general, you should not use &lt;code&gt;FusedIterator&lt;/code&gt; in generic bounds if you need a fused iterator. Instead, you should just call &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt;&lt;code&gt;Iterator::fuse()&lt;/code&gt;&lt;/a&gt; on the iterator. If the iterator is already fused, the additional &lt;a href=&quot;struct.fuse&quot;&gt;&lt;code&gt;Fuse&lt;/code&gt;&lt;/a&gt; wrapper will be a no-op with no performance penalty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de232dc8ccf3ad3cf06506f2846d4c5ae30df0ce" translate="yes" xml:space="preserve">
          <source>Note: In general, you should not use &lt;code&gt;FusedIterator&lt;/code&gt; in generic bounds if you need a fused iterator. Instead, you should just call &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt;&lt;code&gt;Iterator::fuse&lt;/code&gt;&lt;/a&gt; on the iterator. If the iterator is already fused, the additional &lt;a href=&quot;struct.fuse&quot;&gt;&lt;code&gt;Fuse&lt;/code&gt;&lt;/a&gt; wrapper will be a no-op with no performance penalty.</source>
          <target state="translated">Nota: En general, no debe usar &lt;code&gt;FusedIterator&lt;/code&gt; en l&amp;iacute;mites gen&amp;eacute;ricos si necesita un iterador fusionado. En su lugar, deber&amp;iacute;a llamar a &lt;a href=&quot;trait.iterator#method.fuse&quot;&gt; &lt;code&gt;Iterator::fuse&lt;/code&gt; &lt;/a&gt; en el iterador. Si el iterador ya est&amp;aacute; fusionado, el &lt;a href=&quot;struct.fuse&quot;&gt; &lt;code&gt;Fuse&lt;/code&gt; &lt;/a&gt; adicional contenedor no ser&amp;aacute; operativo sin penalizaci&amp;oacute;n de rendimiento.</target>
        </trans-unit>
        <trans-unit id="30cece00231291046dd06875e4aca4bb16fbdc74" translate="yes" xml:space="preserve">
          <source>Note: In the edge case where you're seeking with &lt;a href=&quot;enum.seekfrom#variant.Current&quot;&gt;&lt;code&gt;SeekFrom::Current&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(n)&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; minus the internal buffer length overflows an &lt;code&gt;i64&lt;/code&gt;, two seeks will be performed instead of one. If the second seek returns &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;, the underlying reader will be left at the same position it would have if you called &lt;code&gt;seek&lt;/code&gt; with &lt;a href=&quot;enum.seekfrom#variant.Current&quot;&gt;&lt;code&gt;SeekFrom::Current&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(0)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
