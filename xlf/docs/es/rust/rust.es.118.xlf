<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="d19c3fd1002bae38df7f3d3cb85b6b1334bcacb4" translate="yes" xml:space="preserve">
          <source>If you're creating a collection, implementing &lt;a href=&quot;trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; for it will allow your collection to be used with the &lt;code&gt;for&lt;/code&gt; loop.</source>
          <target state="translated">Si est&amp;aacute; creando una colecci&amp;oacute;n, implementar &lt;a href=&quot;trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt; para ella permitir&amp;aacute; que su colecci&amp;oacute;n se use con el bucle &lt;code&gt;for&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a422eed6103cbb87db1af03fc39e19d93bd47305" translate="yes" xml:space="preserve">
          <source>If you're doing some sort of side effect, prefer &lt;a href=&quot;../../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;map()&lt;/code&gt;:</source>
          <target state="translated">Si est&amp;aacute;s haciendo alg&amp;uacute;n tipo de efecto secundario, prefieren &lt;a href=&quot;../../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt; que &lt;code&gt;map()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="50fae5c17f1680200b10a72b86983fc6d83252f1" translate="yes" xml:space="preserve">
          <source>If you're fine with just getting a prefix of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, you can call &lt;a href=&quot;../vec/struct.vec#method.truncate&quot;&gt;&lt;code&gt;.truncate(N)&lt;/code&gt;&lt;/a&gt; first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="657123c4239a0672bb847d20cff32727a933d93f" translate="yes" xml:space="preserve">
          <source>If you're fine with just getting a prefix of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, you can call &lt;a href=&quot;struct.vec#method.truncate&quot;&gt;&lt;code&gt;.truncate(N)&lt;/code&gt;&lt;/a&gt; first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2c18403b0527c315799b70edeca9e66be8c0011" translate="yes" xml:space="preserve">
          <source>If you're fine with just getting a prefix of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, you can call &lt;a href=&quot;vec/struct.vec#method.truncate&quot;&gt;&lt;code&gt;.truncate(N)&lt;/code&gt;&lt;/a&gt; first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9afd2d591bc8d95f3d42da1a03f80ebc1b1aa2ee" translate="yes" xml:space="preserve">
          <source>If you're only returning this and &lt;code&gt;SUCCESS&lt;/code&gt; from &lt;code&gt;main&lt;/code&gt;, consider instead returning &lt;code&gt;Err(_)&lt;/code&gt; and &lt;code&gt;Ok(())&lt;/code&gt; respectively, which will return the same codes (but will also &lt;code&gt;eprintln!&lt;/code&gt; the error).</source>
          <target state="translated">Si solo est&amp;aacute; devolviendo esto y &lt;code&gt;SUCCESS&lt;/code&gt; de &lt;code&gt;main&lt;/code&gt; , considere en su lugar devolver &lt;code&gt;Err(_)&lt;/code&gt; y &lt;code&gt;Ok(())&lt;/code&gt; respectivamente, que devolver&amp;aacute;n los mismos c&amp;oacute;digos (pero tambi&amp;eacute;n &lt;code&gt;eprintln!&lt;/code&gt; El error).</target>
        </trans-unit>
        <trans-unit id="f631fe468a2c97e4c088457880f99d9a4e107ff3" translate="yes" xml:space="preserve">
          <source>If you're sure you want to override the lint check, you can change &lt;code&gt;forbid&lt;/code&gt; to &lt;code&gt;deny&lt;/code&gt; (or use &lt;code&gt;-D&lt;/code&gt; instead of &lt;code&gt;-F&lt;/code&gt; if the &lt;code&gt;forbid&lt;/code&gt; setting was given as a command-line option) to allow the inner lint check attribute:</source>
          <target state="translated">Si est&amp;aacute; seguro de que desea anular la verificaci&amp;oacute;n de pelusa, puede cambiar &lt;code&gt;forbid&lt;/code&gt; a &lt;code&gt;deny&lt;/code&gt; (o usar &lt;code&gt;-D&lt;/code&gt; en lugar de &lt;code&gt;-F&lt;/code&gt; si la configuraci&amp;oacute;n de &lt;code&gt;forbid&lt;/code&gt; se proporcion&amp;oacute; como una opci&amp;oacute;n de l&amp;iacute;nea de comandos) para permitir el atributo de verificaci&amp;oacute;n de pelusa interna:</target>
        </trans-unit>
        <trans-unit id="9708dfd947b0f617c80eaf862c93f6be07e715ad" translate="yes" xml:space="preserve">
          <source>If you're using PowerShell, you will need to set the environment variable and run the program as separate commands:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7026945961ed8f6ca8800fb0c4e20b697752c2a9" translate="yes" xml:space="preserve">
          <source>If you're using a nightly version of rustc, just add the corresponding feature to be able to use it:</source>
          <target state="translated">Si estás usando una versión nocturna de rustc,sólo tienes que añadir la característica correspondiente para poder usarla:</target>
        </trans-unit>
        <trans-unit id="576937c9d8ed13353425e007feb4c070a940e8cb" translate="yes" xml:space="preserve">
          <source>If you're using a stable or a beta version of rustc, you won't be able to use any unstable features. In order to do so, please switch to a nightly version of rustc (by using rustup).</source>
          <target state="translated">Si usas una versión estable o una versión beta de rustc,no podrás usar ninguna característica inestable.Para ello,por favor cambia a una versión nocturna de rustc (usando rustup).</target>
        </trans-unit>
        <trans-unit id="395533f4484790ce7a8392319e82621aa7e5325d" translate="yes" xml:space="preserve">
          <source>If you're writing an &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, you can use it with a &lt;code&gt;for&lt;/code&gt; loop.</source>
          <target state="translated">Si est&amp;aacute; escribiendo un &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; , puede usarlo con un bucle &lt;code&gt;for&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39b96bd78ad2447973090132f0c782a06fee701a" translate="yes" xml:space="preserve">
          <source>If you've expected to use a crate name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fb2ecfb4c92e4052c3107bd77c1eec1689462b3" translate="yes" xml:space="preserve">
          <source>If you've found yourself with a collection of some kind, and needed to perform an operation on the elements of said collection, you'll quickly run into 'iterators'. Iterators are heavily used in idiomatic Rust code, so it's worth becoming familiar with them.</source>
          <target state="translated">Si te encuentras con una colección de algún tipo,y necesitas realizar una operación sobre los elementos de dicha colección,rápidamente te encontrarás con &quot;iteradores&quot;.Los iteradores son muy utilizados en el código idiomático de Rust,así que vale la pena familiarizarse con ellos.</target>
        </trans-unit>
        <trans-unit id="bba321adc53e908723f50dd512716ff5bec65b5c" translate="yes" xml:space="preserve">
          <source>If your struct does not in fact &lt;em&gt;own&lt;/em&gt; the data of type &lt;code&gt;T&lt;/code&gt;, it is better to use a reference type, like &lt;code&gt;PhantomData&amp;lt;&amp;amp;'a T&amp;gt;&lt;/code&gt; (ideally) or &lt;code&gt;PhantomData&amp;lt;*const T&amp;gt;&lt;/code&gt; (if no lifetime applies), so as not to indicate ownership.</source>
          <target state="translated">Si su estructura de hecho no &lt;em&gt;posee&lt;/em&gt; los datos de tipo &lt;code&gt;T&lt;/code&gt; , es mejor usar un tipo de referencia, como &lt;code&gt;PhantomData&amp;lt;&amp;amp;'a T&amp;gt;&lt;/code&gt; (idealmente) o &lt;code&gt;PhantomData&amp;lt;*const T&amp;gt;&lt;/code&gt; (si no se aplica una vida &amp;uacute;til), de modo que para no indicar propiedad.</target>
        </trans-unit>
        <trans-unit id="1f6b5f80968da1047a776f5803bbfc765104a318" translate="yes" xml:space="preserve">
          <source>If your type is &lt;a href=&quot;trait.ord&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt;, you can implement &lt;a href=&quot;trait.partialord#tymethod.partial_cmp&quot;&gt;&lt;code&gt;partial_cmp&lt;/code&gt;&lt;/a&gt; by using &lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt;&lt;code&gt;cmp&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35168f4f4ac93dd52237413aa76a27a7ee5549a6" translate="yes" xml:space="preserve">
          <source>If your type is &lt;code&gt;Ord&lt;/code&gt;, you can implement &lt;code&gt;partial_cmp()&lt;/code&gt; by using &lt;code&gt;cmp()&lt;/code&gt;:</source>
          <target state="translated">Si su tipo es &lt;code&gt;Ord&lt;/code&gt; , puede implementar &lt;code&gt;partial_cmp()&lt;/code&gt; usando &lt;code&gt;cmp()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7bfd0ea25f9360aa8168faba44b4ab62b5c11325" translate="yes" xml:space="preserve">
          <source>If your type uses pinning (such as the two examples above), you have to be careful when implementing &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; function takes &lt;code&gt;&amp;amp;mut self&lt;/code&gt;, but this is called &lt;em&gt;even if your type was previously pinned&lt;/em&gt;! It is as if the compiler automatically called &lt;a href=&quot;struct.pin#method.get_unchecked_mut&quot;&gt;&lt;code&gt;Pin::get_unchecked_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d37aa76a1e9c0f7fae52e7041a8731a25ef02a02" translate="yes" xml:space="preserve">
          <source>If your type uses pinning (such as the two examples above), you have to be careful when implementing &lt;code&gt;Drop&lt;/code&gt;. The &lt;code&gt;drop&lt;/code&gt; function takes &lt;code&gt;&amp;amp;mut self&lt;/code&gt;, but this is called &lt;em&gt;even if your type was previously pinned&lt;/em&gt;! It is as if the compiler automatically called &lt;code&gt;get_unchecked_mut&lt;/code&gt;.</source>
          <target state="translated">Si su tipo usa anclado (como los dos ejemplos anteriores), debe tener cuidado al implementar &lt;code&gt;Drop&lt;/code&gt; . La funci&amp;oacute;n de &lt;code&gt;drop&lt;/code&gt; toma &lt;code&gt;&amp;amp;mut self&lt;/code&gt; , pero esto se llama &lt;em&gt;incluso si su tipo fue anclado previamente&lt;/em&gt; . Es como si el compilador llamara autom&amp;aacute;ticamente &lt;code&gt;get_unchecked_mut&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="598868642b3bffa6f49c642a95c3be204b7800a8" translate="yes" xml:space="preserve">
          <source>If, instead, the closure were to use &lt;code&gt;self.vec&lt;/code&gt; directly, then it would attempt to capture &lt;code&gt;self&lt;/code&gt; by mutable reference. But since &lt;code&gt;self.set&lt;/code&gt; is already borrowed to iterate over, the code would not compile.</source>
          <target state="translated">Si, en cambio, el cierre fuera a usar &lt;code&gt;self.vec&lt;/code&gt; directamente, entonces intentar&amp;iacute;a capturar a &lt;code&gt;self&lt;/code&gt; mediante una referencia mutable. Pero dado que &lt;code&gt;self.set&lt;/code&gt; ya est&amp;aacute; prestado para iterar, el c&amp;oacute;digo no se compilar&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="48ed828a4ed281ea3d0c9ba3174c378a545d73df" translate="yes" xml:space="preserve">
          <source>Ignores the rest of the fields of &lt;code&gt;person&lt;/code&gt;. The remaining fields can have any value and are not bound to any variables.</source>
          <target state="translated">Ignora el resto de los campos de la &lt;code&gt;person&lt;/code&gt; a . Los campos restantes pueden tener cualquier valor y no est&amp;aacute;n vinculados a ninguna variable.</target>
        </trans-unit>
        <trans-unit id="c31c1e950d31bcf9e1a5b1976cfae488d68d470b" translate="yes" xml:space="preserve">
          <source>Ignoring Parts of a Value with a Nested &lt;code id=&quot;ignoring-parts-of-a-value-with-a-nested-_&quot;&gt;_&lt;/code&gt;</source>
          <target state="translated">Ignorar partes de un valor con un &lt;code id=&quot;ignoring-parts-of-a-value-with-a-nested-_&quot;&gt;_&lt;/code&gt; anidado</target>
        </trans-unit>
        <trans-unit id="cb76cccb46d6bf3b21aff42c2840779a648e9316" translate="yes" xml:space="preserve">
          <source>Ignoring Remaining Parts of a Value with &lt;code id=&quot;ignoring-remaining-parts-of-a-value-with-&quot;&gt;..&lt;/code&gt;</source>
          <target state="translated">Ignorar las partes restantes de un valor con &lt;code id=&quot;ignoring-remaining-parts-of-a-value-with-&quot;&gt;..&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72be1acfce70ef6fdf12c4ca3bdb755a5f3c62e1" translate="yes" xml:space="preserve">
          <source>Ignoring Some Tests Unless Specifically Requested</source>
          <target state="translated">Ignorar algunas pruebas a menos que se solicite específicamente</target>
        </trans-unit>
        <trans-unit id="7b50129a075aa818d7462a8d02141718c690d22a" translate="yes" xml:space="preserve">
          <source>Ignoring Values in a Pattern</source>
          <target state="translated">Ignorar los valores en un patrón</target>
        </trans-unit>
        <trans-unit id="b8aa95dab57398b05fdba8a4d4f5449c83a52c55" translate="yes" xml:space="preserve">
          <source>Ignoring an Entire Value with &lt;code id=&quot;ignoring-an-entire-value-with-_&quot;&gt;_&lt;/code&gt;</source>
          <target state="translated">Ignorar un valor completo con &lt;code id=&quot;ignoring-an-entire-value-with-_&quot;&gt;_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="824175d05fddba8fd3dcc503b0a53c542e4c9636" translate="yes" xml:space="preserve">
          <source>Ignoring an Unused Variable by Starting Its Name with &lt;code id=&quot;ignoring-an-unused-variable-by-starting-its-name-with-_&quot;&gt;_&lt;/code&gt;</source>
          <target state="translated">Ignorar una variable no utilizada comenzando su nombre con &lt;code id=&quot;ignoring-an-unused-variable-by-starting-its-name-with-_&quot;&gt;_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1de0ff71d627d79a5461c11415378b869fce1c05" translate="yes" xml:space="preserve">
          <source>Imagine &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; as a TV in a family room. When one person enters to watch TV, they turn it on. Others can come into the room and watch the TV. When the last person leaves the room, they turn off the TV because it&amp;rsquo;s no longer being used. If someone turns off the TV while others are still watching it, there would be uproar from the remaining TV watchers!</source>
          <target state="translated">Imag&amp;iacute;nese &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; como un televisor en una sala familiar. Cuando una persona entra a ver la televisi&amp;oacute;n, la enciende. Otros pueden entrar a la habitaci&amp;oacute;n y ver la televisi&amp;oacute;n. Cuando la &amp;uacute;ltima persona sale de la habitaci&amp;oacute;n, apagan el televisor porque ya no se usa. Si alguien apaga la televisi&amp;oacute;n mientras otros todav&amp;iacute;a la miran, &amp;iexcl;habr&amp;aacute; un alboroto de los espectadores restantes!</target>
        </trans-unit>
        <trans-unit id="aef09d55e979d01186c3ad5b4d52e9895c1e4d0b" translate="yes" xml:space="preserve">
          <source>Immutable raw entries have very limited use; you might instead want &lt;code&gt;raw_entry_mut&lt;/code&gt;.</source>
          <target state="translated">Las entradas crudas inmutables tienen un uso muy limitado; en su lugar, podr&amp;iacute;a querer &lt;code&gt;raw_entry_mut&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9cb7da282b676f1a9147f47cf20eae1312e8018" translate="yes" xml:space="preserve">
          <source>Immutable slice iterator</source>
          <target state="translated">Inmutable iterador de rebanadas</target>
        </trans-unit>
        <trans-unit id="f279b41bdff0c313061e7e8d87d0d00890c662fd" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value.</source>
          <target state="translated">Toma prestado inmediatamente de un valor propio.</target>
        </trans-unit>
        <trans-unit id="47c37e5ca590da5f0c3ce78d39f05441cd662917" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;../../../borrow/trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Inmutablemente toma prestado de un valor propio. &lt;a href=&quot;../../../borrow/trait.borrow#tymethod.borrow&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="861dc028ab0a94d2afc2d7df8d5b5cf1a45ca3fc" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;../../borrow/trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Inmutablemente toma prestado de un valor propio. &lt;a href=&quot;../../borrow/trait.borrow#tymethod.borrow&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e8a010bb86c5762cd52b4abd0dab0aa2a3ef476" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;../borrow/trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Inmutablemente toma prestado de un valor propio. &lt;a href=&quot;../borrow/trait.borrow#tymethod.borrow&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8833e74ed05076c118bef1874883c610436d6d5b" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;borrow/trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Inmutablemente toma prestado de un valor propio. &lt;a href=&quot;borrow/trait.borrow#tymethod.borrow&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="73be65582534de0a648096eb5ca5552095f43fdb" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Inmutablemente toma prestado de un valor propio. &lt;a href=&quot;trait.borrow#tymethod.borrow&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="809dd297db758cb75c4bd86bf3c73c53b0063ba0" translate="yes" xml:space="preserve">
          <source>Immutably borrows the wrapped value, returning an error if the value is currently mutably borrowed.</source>
          <target state="translated">Toma prestado inmediatamente el valor envuelto,devolviendo un error si el valor está actualmente mutablemente prestado.</target>
        </trans-unit>
        <trans-unit id="24dd024f910c8d7d6dfa29d6bf4e9500dd4642a7" translate="yes" xml:space="preserve">
          <source>Immutably borrows the wrapped value.</source>
          <target state="translated">Inmediatamente toma prestado el valor envuelto.</target>
        </trans-unit>
        <trans-unit id="0e1a9c7b22b101d3c2b0d138208b984996a848ee" translate="yes" xml:space="preserve">
          <source>Impl blocks declare lifetime parameters separately. You need to add lifetime parameters to an impl block if you're implementing a type that has a lifetime parameter of its own. For example:</source>
          <target state="translated">Los bloques de implantes declaran los parámetros de vida útil por separado.Es necesario añadir parámetros de vida útil a un bloque impl si se implementa un tipo que tiene un parámetro de vida útil propio.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="f0ab384ef00ad7380000aad709dff9a6e1b2d5e6" translate="yes" xml:space="preserve">
          <source>Impl trait</source>
          <target state="translated">Implantar el rasgo</target>
        </trans-unit>
        <trans-unit id="21127244da70324da76b7c0c9aa099a69f9c571a" translate="yes" xml:space="preserve">
          <source>Implement &lt;code&gt;unsafe&lt;/code&gt;&lt;a href=&quot;keyword.trait&quot;&gt;&lt;code&gt;trait&lt;/code&gt;&lt;/a&gt;s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d519e5f322d6b68d828741615581f614c79da78c" translate="yes" xml:space="preserve">
          <source>Implement an unsafe trait</source>
          <target state="translated">Implementar un rasgo inseguro</target>
        </trans-unit>
        <trans-unit id="442776eaaeebdf7e0bded5bbb09142472fe053b1" translate="yes" xml:space="preserve">
          <source>Implement some functionality for a type.</source>
          <target state="translated">Implementar alguna funcionalidad para un tipo.</target>
        </trans-unit>
        <trans-unit id="a512d32b6a8299d839d23927a30d0946b2b3937e" translate="yes" xml:space="preserve">
          <source>Implement the &lt;a href=&quot;trait.asmut&quot;&gt;&lt;code&gt;AsMut&lt;/code&gt;&lt;/a&gt; trait for cheap mutable-to-mutable conversions</source>
          <target state="translated">Implemente el rasgo &lt;a href=&quot;trait.asmut&quot;&gt; &lt;code&gt;AsMut&lt;/code&gt; &lt;/a&gt; para conversiones mutables a mutables baratas</target>
        </trans-unit>
        <trans-unit id="db05cb4c5fcad93a1bd13ef8e272ade5dcf5a9ed" translate="yes" xml:space="preserve">
          <source>Implement the &lt;a href=&quot;trait.asref&quot;&gt;&lt;code&gt;AsRef&lt;/code&gt;&lt;/a&gt; trait for cheap reference-to-reference conversions</source>
          <target state="translated">Implementar el rasgo &lt;a href=&quot;trait.asref&quot;&gt; &lt;code&gt;AsRef&lt;/code&gt; &lt;/a&gt; para conversiones de referencia a referencia econ&amp;oacute;micas</target>
        </trans-unit>
        <trans-unit id="24c2adeb5e2bfc607a7c5a50fd8f988a4093654a" translate="yes" xml:space="preserve">
          <source>Implement the &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; trait for consuming value-to-value conversions</source>
          <target state="translated">Implementar el rasgo &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; para consumir conversiones de valor a valor</target>
        </trans-unit>
        <trans-unit id="d27046965d37bd5d8cbb845498a9420dd8d95023" translate="yes" xml:space="preserve">
          <source>Implement the &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; trait for consuming value-to-value conversions to types outside the current crate</source>
          <target state="translated">Implementar el rasgo &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; para consumir conversiones de valor a valor a tipos fuera de la caja actual</target>
        </trans-unit>
        <trans-unit id="06e095af43d83707d7766a25b59d1943f1d5e7c9" translate="yes" xml:space="preserve">
          <source>Implement the &lt;code&gt;Copy&lt;/code&gt; trait on the type.</source>
          <target state="translated">Implemente el rasgo &lt;code&gt;Copy&lt;/code&gt; en el tipo.</target>
        </trans-unit>
        <trans-unit id="08a1e21e463e48ea6ec85aff968b0108176c62c8" translate="yes" xml:space="preserve">
          <source>Implementation details of logically-immutable methods</source>
          <target state="translated">Detalles de la aplicación de los métodos lógicamente inmutables</target>
        </trans-unit>
        <trans-unit id="1ddfd1ff2f1e0a2e2b1429c49bcda0a3059a1caa" translate="yes" xml:space="preserve">
          <source>Implementation details of logically-immutable methods.</source>
          <target state="translated">Detalles de la aplicación de los métodos lógicamente inmutables.</target>
        </trans-unit>
        <trans-unit id="e0bf2dc952ab6d2617aa9b9ee013534f9eeb5b62" translate="yes" xml:space="preserve">
          <source>Implementation notes</source>
          <target state="translated">Notas de aplicación</target>
        </trans-unit>
        <trans-unit id="cbd0574adde4a73750817df1b9bf6659b05baae3" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;../primitive.slice#method.concat&quot;&gt;&lt;code&gt;[T]::concat&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f209c5111fdc43ea4ba2b99ff5e91a185c5ba5f" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;../primitive.slice#method.join&quot;&gt;&lt;code&gt;[T]::join&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d07ae3ae0632c811bda0590dcd36a31748f12009" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;primitive.slice#method.concat&quot;&gt;&lt;code&gt;[T]::concat&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6523b8f0fa5de5a2e923accee11e86f6d33eb03c" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;primitive.slice#method.join&quot;&gt;&lt;code&gt;[T]::join&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59900d07c9905339bce32756f7c459df8b522597" translate="yes" xml:space="preserve">
          <source>Implementations</source>
          <target state="translated">Implementations</target>
        </trans-unit>
        <trans-unit id="a1e59e75f259fa9d9ba19603eb2d3e33d9fd3444" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to return &lt;code&gt;Err&lt;/code&gt; on memory exhaustion rather than panicking or aborting, but this is not a strict requirement. (Specifically: it is &lt;em&gt;legal&lt;/em&gt; to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)</source>
          <target state="translated">Se recomienda que las implementaciones devuelvan &lt;code&gt;Err&lt;/code&gt; al agotarse la memoria en lugar de entrar en p&amp;aacute;nico o abortar, pero este no es un requisito estricto. (Espec&amp;iacute;ficamente: es &lt;em&gt;legal&lt;/em&gt; implementar este rasgo encima de una biblioteca de asignaci&amp;oacute;n nativa subyacente que aborta cuando se agota la memoria).</target>
        </trans-unit>
        <trans-unit id="e30a5263932dd8adb2b92f110648d956dfcf128e" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to return null on memory exhaustion rather than aborting, but this is not a strict requirement. (Specifically: it is &lt;em&gt;legal&lt;/em&gt; to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)</source>
          <target state="translated">Se recomienda que las implementaciones devuelvan un valor nulo cuando se agote la memoria en lugar de abortar, pero esto no es un requisito estricto. (Espec&amp;iacute;ficamente: es &lt;em&gt;legal&lt;/em&gt; implementar este rasgo encima de una biblioteca de asignaci&amp;oacute;n nativa subyacente que aborta cuando se agota la memoria).</target>
        </trans-unit>
        <trans-unit id="7241603f3511aeef16c3bb5af01750a5d8ec0991" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to return null on memory exhaustion rather than panicking or aborting, but this is not a strict requirement. (Specifically: it is &lt;em&gt;legal&lt;/em&gt; to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)</source>
          <target state="translated">Se recomienda que las implementaciones devuelvan un valor nulo por agotamiento de la memoria en lugar de entrar en p&amp;aacute;nico o abortar, pero esto no es un requisito estricto. (Espec&amp;iacute;ficamente: es &lt;em&gt;legal&lt;/em&gt; implementar este rasgo encima de una biblioteca de asignaci&amp;oacute;n nativa subyacente que aborta cuando se agota la memoria).</target>
        </trans-unit>
        <trans-unit id="d9c40308bcf0812b701640d510d3be57409b94be" translate="yes" xml:space="preserve">
          <source>Implementations may contain outer &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; before the &lt;code&gt;impl&lt;/code&gt; keyword and inner &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; inside the brackets that contain the associated items. Inner attributes must come before any associated items. That attributes that have meaning here are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;.</source>
          <target state="translated">Las implementaciones pueden contener &lt;a href=&quot;../attributes&quot;&gt;atributos&lt;/a&gt; externos antes de la palabra clave &lt;code&gt;impl&lt;/code&gt; y &lt;a href=&quot;../attributes&quot;&gt;atributos&lt;/a&gt; internos dentro de los corchetes que contienen los elementos asociados. Los atributos internos deben ir antes que los elementos asociados. Los atributos que tienen significado aqu&amp;iacute; son &lt;a href=&quot;../conditional-compilation&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt; &lt;code&gt;doc&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;los atributos lint check&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d5c6183888e78c3e46f39fb71a3e11db5b02b618" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;a href=&quot;trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trait.partialord&quot;&gt;&lt;code&gt;PartialOrd&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;Ord&lt;/code&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. That is, &lt;code&gt;a.cmp(b) == Ordering::Equal&lt;/code&gt; if and only if &lt;code&gt;a == b&lt;/code&gt; and &lt;code&gt;Some(a.cmp(b)) == a.partial_cmp(b)&lt;/code&gt; for all &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="906e45c0ce13a452d5ad583acf7c948d36606488" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;a href=&quot;trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;PartialOrd&lt;/code&gt;, and &lt;a href=&quot;trait.ord&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c77f28f9797beb5e60c442300cafb1661e149f7" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;PartialEq&lt;/code&gt;, &lt;a href=&quot;trait.partialord&quot;&gt;&lt;code&gt;PartialOrd&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;trait.ord&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a14c265aa9aabd883301abe69f139e487531c5f2" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;PartialEq&lt;/code&gt;, &lt;code&gt;PartialOrd&lt;/code&gt;, and &lt;code&gt;Ord&lt;/code&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="translated">Las implementaciones de &lt;code&gt;PartialEq&lt;/code&gt; , &lt;code&gt;PartialOrd&lt;/code&gt; y &lt;code&gt;Ord&lt;/code&gt; &lt;em&gt;deben&lt;/em&gt; coincidir entre s&amp;iacute;. Es f&amp;aacute;cil hacer que no est&amp;eacute;n de acuerdo accidentalmente derivando algunos de los rasgos e implementando manualmente otros.</target>
        </trans-unit>
        <trans-unit id="0c5f5c9c85290b9df99598b15b458f58a9e2a332" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;PartialEq&lt;/code&gt;, &lt;code&gt;PartialOrd&lt;/code&gt;, and &lt;code&gt;Ord&lt;/code&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. That is, &lt;code&gt;a.cmp(b) == Ordering::Equal&lt;/code&gt; if and only if &lt;code&gt;a == b&lt;/code&gt; and &lt;code&gt;Some(a.cmp(b)) == a.partial_cmp(b)&lt;/code&gt; for all &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="translated">Las implementaciones de &lt;code&gt;PartialEq&lt;/code&gt; , &lt;code&gt;PartialOrd&lt;/code&gt; y &lt;code&gt;Ord&lt;/code&gt; &lt;em&gt;deben&lt;/em&gt; coincidir entre s&amp;iacute;. Es decir, &lt;code&gt;a.cmp(b) == Ordering::Equal&lt;/code&gt; si y s&amp;oacute;lo si &lt;code&gt;a == b&lt;/code&gt; y &lt;code&gt;Some(a.cmp(b)) == a.partial_cmp(b)&lt;/code&gt; para todos &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; . Es f&amp;aacute;cil hacer que no est&amp;eacute;n de acuerdo accidentalmente derivando algunos de los rasgos e implementando manualmente otros.</target>
        </trans-unit>
        <trans-unit id="f03739953743b6047f7ae8d466b9ff10b313f420" translate="yes" xml:space="preserve">
          <source>Implementations of must return the same mutable reference for their lifetime, unless replaced by a caller. Callers may only replace the reference when they stopped iteration and drop the iterator pipeline after extracting the source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="244386dfeb06556af9dc80db20c0c2ce222c9de8" translate="yes" xml:space="preserve">
          <source>Implementations of operator traits should be unsurprising in their respective contexts, keeping in mind their usual meanings and &lt;a href=&quot;../../reference/expressions#expression-precedence&quot;&gt;operator precedence&lt;/a&gt;. For example, when implementing &lt;a href=&quot;trait.mul&quot;&gt;&lt;code&gt;Mul&lt;/code&gt;&lt;/a&gt;, the operation should have some resemblance to multiplication (and share expected properties like associativity).</source>
          <target state="translated">Las implementaciones de los rasgos del operador no deber&amp;iacute;an sorprender en sus respectivos contextos, teniendo en cuenta sus significados habituales y la &lt;a href=&quot;../../reference/expressions#expression-precedence&quot;&gt;precedencia del operador&lt;/a&gt; . Por ejemplo, al implementar &lt;a href=&quot;trait.mul&quot;&gt; &lt;code&gt;Mul&lt;/code&gt; &lt;/a&gt; , la operaci&amp;oacute;n debe tener alg&amp;uacute;n parecido con la multiplicaci&amp;oacute;n (y compartir propiedades esperadas como la asociatividad).</target>
        </trans-unit>
        <trans-unit id="28805d0834dc067733940cf0a40b27bcfa746deb" translate="yes" xml:space="preserve">
          <source>Implementations of things like &lt;code&gt;Eq&lt;/code&gt; for fixed-length arrays up to a certain length. Eventually we should able to generalize to all lengths.</source>
          <target state="translated">Implementaciones de cosas como &lt;code&gt;Eq&lt;/code&gt; para arreglos de longitud fija hasta una cierta longitud. Con el tiempo, deber&amp;iacute;amos poder generalizar a todos los niveles.</target>
        </trans-unit>
        <trans-unit id="2f5aa5cbed1b025d1b2126e25480e69829ce743f" translate="yes" xml:space="preserve">
          <source>Implementations of things like &lt;code&gt;Eq&lt;/code&gt; for fixed-length arrays up to a certain length. Eventually, we should be able to generalize to all lengths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="118b3aed38f3812ad05266c0985ae4538e945007" translate="yes" xml:space="preserve">
          <source>Implementations of this trait have to promise that if the argument to &lt;code&gt;get_(mut_)unchecked&lt;/code&gt; is a safe reference, then so is the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb48644c15fbf48baad224f4f022b99ee1d0994" translate="yes" xml:space="preserve">
          <source>Implementations on Foreign Types</source>
          <target state="translated">Implementación de los tipos extranjeros</target>
        </trans-unit>
        <trans-unit id="1fc22c1620f81044690a14be1c43ca68e7e41355" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code id=&quot;implementing-send-and-sync-manually-is-unsafe&quot;&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt; Manually Is Unsafe</source>
          <target state="translated">Implementar &lt;code id=&quot;implementing-send-and-sync-manually-is-unsafe&quot;&gt;Send&lt;/code&gt; y &lt;code&gt;Sync&lt;/code&gt; manualmente no es seguro</target>
        </trans-unit>
        <trans-unit id="c7837b27bbf3d0dab1929c207399a6b0791244d8" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Add&lt;/code&gt; with generics</source>
          <target state="translated">Implementar &lt;code&gt;Add&lt;/code&gt; con gen&amp;eacute;ricos</target>
        </trans-unit>
        <trans-unit id="7dd172ca4f8bed0af8ee189dac34d629ede7f550" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Binary&lt;/code&gt; on a type:</source>
          <target state="translated">Implementando &lt;code&gt;Binary&lt;/code&gt; en un tipo:</target>
        </trans-unit>
        <trans-unit id="1493517ce3938521fcf7eadbd7d37ee08422c800" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Deref&lt;/code&gt; for smart pointers makes accessing the data behind them convenient, which is why they implement &lt;code&gt;Deref&lt;/code&gt;. On the other hand, the rules regarding &lt;code&gt;Deref&lt;/code&gt; and &lt;a href=&quot;trait.derefmut&quot;&gt;&lt;code&gt;DerefMut&lt;/code&gt;&lt;/a&gt; were designed specifically to accommodate smart pointers. Because of this, &lt;strong&gt;&lt;code&gt;Deref&lt;/code&gt; should only be implemented for smart pointers&lt;/strong&gt; to avoid confusion.</source>
          <target state="translated">La implementaci&amp;oacute;n de &lt;code&gt;Deref&lt;/code&gt; para punteros inteligentes hace que acceder a los datos detr&amp;aacute;s de ellos sea conveniente, por lo que implementan &lt;code&gt;Deref&lt;/code&gt; . Por otro lado, las reglas relativas a &lt;code&gt;Deref&lt;/code&gt; y &lt;a href=&quot;trait.derefmut&quot;&gt; &lt;code&gt;DerefMut&lt;/code&gt; &lt;/a&gt; se dise&amp;ntilde;aron espec&amp;iacute;ficamente para adaptarse a los punteros inteligentes. Debido a esto, &lt;strong&gt; &lt;code&gt;Deref&lt;/code&gt; solo debe implementarse para punteros inteligentes&lt;/strong&gt; para evitar confusiones.</target>
        </trans-unit>
        <trans-unit id="50891607fd39352027fce2fd66191f4d13f39144" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;DerefMut&lt;/code&gt; for smart pointers makes mutating the data behind them convenient, which is why they implement &lt;code&gt;DerefMut&lt;/code&gt;. On the other hand, the rules regarding &lt;a href=&quot;trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;DerefMut&lt;/code&gt; were designed specifically to accommodate smart pointers. Because of this, &lt;strong&gt;&lt;code&gt;DerefMut&lt;/code&gt; should only be implemented for smart pointers&lt;/strong&gt; to avoid confusion.</source>
          <target state="translated">La implementaci&amp;oacute;n de &lt;code&gt;DerefMut&lt;/code&gt; para punteros inteligentes hace que mutar los datos detr&amp;aacute;s de ellos sea conveniente, por eso implementan &lt;code&gt;DerefMut&lt;/code&gt; . Por otro lado, las reglas relativas a &lt;a href=&quot;trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt; y &lt;code&gt;DerefMut&lt;/code&gt; se dise&amp;ntilde;aron espec&amp;iacute;ficamente para adaptarse a los punteros inteligentes. Debido a esto, &lt;strong&gt; &lt;code&gt;DerefMut&lt;/code&gt; solo debe implementarse para punteros inteligentes&lt;/strong&gt; para evitar confusiones.</target>
        </trans-unit>
        <trans-unit id="8fb3ada706bbd2ce93453f2096c2280f1c5218cd" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Display&lt;/code&gt; on a type:</source>
          <target state="translated">Implementaci&amp;oacute;n de &lt;code&gt;Display&lt;/code&gt; en un tipo:</target>
        </trans-unit>
        <trans-unit id="19c2782a069f688b67217fbb710cab6e8fa425b0" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Drop&lt;/code&gt;</source>
          <target state="translated">Implementando &lt;code&gt;Drop&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fbf86abd91a91734cbbf99bafbece882a53975c0" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Extend&lt;/code&gt;:</source>
          <target state="translated">Implementando &lt;code&gt;Extend&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="55075e933ba7659b07b95de59bbad9f493028a57" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;FromIterator&lt;/code&gt; for your type:</source>
          <target state="translated">Implementando &lt;code&gt;FromIterator&lt;/code&gt; para su tipo:</target>
        </trans-unit>
        <trans-unit id="714405414f007a14389378ee0e0e1ef6296723bb" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Hash&lt;/code&gt;</source>
          <target state="translated">Implementando &lt;code&gt;Hash&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bd2490e0169b082204c99b8a05144dcf3715c4d7" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Into&lt;/code&gt; for conversions to external types</source>
          <target state="translated">Implementaci&amp;oacute;n &lt;code&gt;Into&lt;/code&gt; para conversiones a tipos externos</target>
        </trans-unit>
        <trans-unit id="47b64f6f87d5b0f43159c63203037214de4fae2c" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Into&lt;/code&gt; for conversions to external types in old versions of Rust</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6231ea57468a3a20172e55bfccdb5ea4af3eeb4" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;IntoIterator&lt;/code&gt; for your type:</source>
          <target state="translated">Implementando &lt;code&gt;IntoIterator&lt;/code&gt; para su tipo:</target>
        </trans-unit>
        <trans-unit id="147cae7152009bed2fea43b659a8a180c932938a" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;LowerExp&lt;/code&gt; on a type:</source>
          <target state="translated">Implementando &lt;code&gt;LowerExp&lt;/code&gt; en un tipo:</target>
        </trans-unit>
        <trans-unit id="69b1d57e51514796d74ae7e951b469bb891b71b2" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;LowerHex&lt;/code&gt; on a type:</source>
          <target state="translated">Implementaci&amp;oacute;n de &lt;code&gt;LowerHex&lt;/code&gt; en un tipo:</target>
        </trans-unit>
        <trans-unit id="77c550c1021e38d5e793ac99f6aef22c9d7b959a" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Octal&lt;/code&gt; on a type:</source>
          <target state="translated">Implementando &lt;code&gt;Octal&lt;/code&gt; en un tipo:</target>
        </trans-unit>
        <trans-unit id="4470ff81326a926c53b3562296af892e9472f832" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Pointer&lt;/code&gt; on a type:</source>
          <target state="translated">Implementando &lt;code&gt;Pointer&lt;/code&gt; en un tipo:</target>
        </trans-unit>
        <trans-unit id="ef0bab8534f2ce76a65ec1c5fd2792b4367f2e5b" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Sub&lt;/code&gt; with generics</source>
          <target state="translated">Implementando &lt;code&gt;Sub&lt;/code&gt; con gen&amp;eacute;ricos</target>
        </trans-unit>
        <trans-unit id="c36bf4b44d4c5b354ab37fe91e9d4c947758aacb" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;TryInto&lt;/code&gt;</source>
          <target state="translated">Implementando &lt;code&gt;TryInto&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ad299d14ee500d50f7ee89bb1d193e8f0dd8e2ea" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;UpperExp&lt;/code&gt; on a type:</source>
          <target state="translated">Implementando &lt;code&gt;UpperExp&lt;/code&gt; en un tipo:</target>
        </trans-unit>
        <trans-unit id="e594e74c4265d12e94c709d795a23f7132ef459e" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;UpperHex&lt;/code&gt; on a type:</source>
          <target state="translated">Implementando &lt;code&gt;UpperHex&lt;/code&gt; en un tipo:</target>
        </trans-unit>
        <trans-unit id="b2b4da88a0c30dc16a40a8acf8dff33108062af0" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;split_at_mut&lt;/code&gt;:</source>
          <target state="translated">Implementando &lt;code&gt;split_at_mut&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="77e25b21a8bf8e36c99842f5744d7e5c80adaf35" translate="yes" xml:space="preserve">
          <source>Implementing Iterator</source>
          <target state="translated">Implementar el Iterator</target>
        </trans-unit>
        <trans-unit id="0e4c93262368adc6172d82967b0b3a7ef8563873" translate="yes" xml:space="preserve">
          <source>Implementing Transitions as Transformations into Different Types</source>
          <target state="translated">Implementación de las transiciones como transformaciones en diferentes tipos</target>
        </trans-unit>
        <trans-unit id="3fc3cd424d3e34fdc8a1a744d196849e48c653de" translate="yes" xml:space="preserve">
          <source>Implementing a Trait on a Type</source>
          <target state="translated">Aplicación de un rasgo en un tipo</target>
        </trans-unit>
        <trans-unit id="15241dc16be9c86fd5c43587d3e88552aecb53a6" translate="yes" xml:space="preserve">
          <source>Implementing a trait on a type is similar to implementing regular methods. The difference is that after &lt;code&gt;impl&lt;/code&gt;, we put the trait name that we want to implement, then use the &lt;code&gt;for&lt;/code&gt; keyword, and then specify the name of the type we want to implement the trait for. Within the &lt;code&gt;impl&lt;/code&gt; block, we put the method signatures that the trait definition has defined. Instead of adding a semicolon after each signature, we use curly brackets and fill in the method body with the specific behavior that we want the methods of the trait to have for the particular type.</source>
          <target state="translated">Implementar un rasgo en un tipo es similar a implementar m&amp;eacute;todos regulares. La diferencia es que despu&amp;eacute;s de &lt;code&gt;impl&lt;/code&gt; , colocamos el nombre del rasgo que queremos implementar, luego usamos la palabra clave &lt;code&gt;for&lt;/code&gt; y luego especificamos el nombre del tipo para el que queremos implementar el rasgo. Dentro del bloque &lt;code&gt;impl&lt;/code&gt; , colocamos las firmas del m&amp;eacute;todo que la definici&amp;oacute;n del rasgo ha definido. En lugar de agregar un punto y coma despu&amp;eacute;s de cada firma, usamos llaves y completamos el cuerpo del m&amp;eacute;todo con el comportamiento espec&amp;iacute;fico que queremos que tengan los m&amp;eacute;todos del rasgo para el tipo en particular.</target>
        </trans-unit>
        <trans-unit id="52069ac07360b321a9102676a5d535746dd3971d" translate="yes" xml:space="preserve">
          <source>Implementing an &lt;a href=&quot;items/traits#unsafe-traits&quot;&gt;unsafe trait&lt;/a&gt;.</source>
          <target state="translated">Implementar un &lt;a href=&quot;items/traits#unsafe-traits&quot;&gt;rasgo inseguro&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a9e954962053f990d74213e5dbc3064a18dca7ad" translate="yes" xml:space="preserve">
          <source>Implementing an Object-Oriented Design Pattern</source>
          <target state="translated">Implementación de un patrón de diseño orientado a objetos</target>
        </trans-unit>
        <trans-unit id="9d35a11b4c4266f39d4667e1f1d83da884c8f6f2" translate="yes" xml:space="preserve">
          <source>Implementing an Unsafe Trait</source>
          <target state="translated">Implementación de un rasgo inseguro</target>
        </trans-unit>
        <trans-unit id="d729cb73986bbb9227ce3a73ce58a9f0f6e86093" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code id=&quot;implementing-the-drop-trait-on-threadpool&quot;&gt;Drop&lt;/code&gt; Trait on &lt;code&gt;ThreadPool&lt;/code&gt;</source>
          <target state="translated">Implementaci&amp;oacute;n del rasgo de &lt;code id=&quot;implementing-the-drop-trait-on-threadpool&quot;&gt;Drop&lt;/code&gt; en &lt;code&gt;ThreadPool&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="101c900375f64c03b1a8afd7a6a0fe94b0211873" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code id=&quot;implementing-the-execute-method&quot;&gt;execute&lt;/code&gt; Method</source>
          <target state="translated">Implementando el &lt;code id=&quot;implementing-the-execute-method&quot;&gt;execute&lt;/code&gt; m&amp;eacute;todo de ejecuci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="91e9cf1a72455d39636a847c09900ca81ea1ede1" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code id=&quot;implementing-the-search_case_insensitive-function&quot;&gt;search_case_insensitive&lt;/code&gt; Function</source>
          <target state="translated">Implementaci&amp;oacute;n de &lt;code id=&quot;implementing-the-search_case_insensitive-function&quot;&gt;search_case_insensitive&lt;/code&gt; funci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="3f2c422307f69f3d1ab1dc7b97ac7fa95dab102e" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code&gt;Deref&lt;/code&gt; trait allows you to customize the behavior of the &lt;em&gt;dereference operator&lt;/em&gt;, &lt;code&gt;*&lt;/code&gt; (as opposed to the multiplication or glob operator). By implementing &lt;code&gt;Deref&lt;/code&gt; in such a way that a smart pointer can be treated like a regular reference, you can write code that operates on references and use that code with smart pointers too.</source>
          <target state="translated">La implementaci&amp;oacute;n del rasgo &lt;code&gt;Deref&lt;/code&gt; le permite personalizar el comportamiento del &lt;em&gt;operador de desreferencia&lt;/em&gt; , &lt;code&gt;*&lt;/code&gt; (en contraposici&amp;oacute;n al operador de multiplicaci&amp;oacute;n o glob). Implementando &lt;code&gt;Deref&lt;/code&gt; de tal manera que un puntero inteligente pueda tratarse como una referencia regular, puede escribir c&amp;oacute;digo que opere sobre referencias y usar ese c&amp;oacute;digo tambi&amp;eacute;n con punteros inteligentes.</target>
        </trans-unit>
        <trans-unit id="0f9c556a4371185e579cbc710c1fc95eeb3c1d8f" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code&gt;Unpin&lt;/code&gt; trait for &lt;code&gt;T&lt;/code&gt; lifts the restrictions of pinning off the type, which then allows moving &lt;code&gt;T&lt;/code&gt; out of &lt;a href=&quot;../pin/struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt; with functions such as &lt;a href=&quot;../mem/fn.replace&quot;&gt;&lt;code&gt;mem::replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d230053d77d384522d54d81ff99e98d1f875f924" translate="yes" xml:space="preserve">
          <source>Implementing the Trait</source>
          <target state="translated">Implementación del rasgo</target>
        </trans-unit>
        <trans-unit id="b82c6b339ac0349fc9ead7cdf10b339a39a68691" translate="yes" xml:space="preserve">
          <source>Implementing these traits allows you to overload certain operators.</source>
          <target state="translated">La implementación de estos rasgos permite sobrecargar a ciertos operadores.</target>
        </trans-unit>
        <trans-unit id="eda774fd99643b19395b54fc514042bb2ec818cd" translate="yes" xml:space="preserve">
          <source>Implementing this method means adapters relinquish private-only access to their source and can only rely on guarantees made based on method receiver types. The lack of restricted access also requires that adapters must uphold the source's public API even when they have access to its internals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca73abeab36da273c6bc9f449021752cd0c1e57b" translate="yes" xml:space="preserve">
          <source>Implementing this trait lifts the restrictions of pinning off a type, which then allows it to move out with functions such as &lt;a href=&quot;../mem/fn.replace&quot;&gt;&lt;code&gt;mem::replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La implementaci&amp;oacute;n de este rasgo elimina las restricciones de anclar un tipo, lo que luego le permite moverse con funciones como &lt;a href=&quot;../mem/fn.replace&quot;&gt; &lt;code&gt;mem::replace&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0a118bbde46189d417f967d1c407afa2b062e337" translate="yes" xml:space="preserve">
          <source>Implementors</source>
          <target state="translated">Implementors</target>
        </trans-unit>
        <trans-unit id="d41c99e77922bf02d10d8206c4ebca64efb50ed3" translate="yes" xml:space="preserve">
          <source>Implementors of the &lt;code&gt;Read&lt;/code&gt; trait are called 'readers'.</source>
          <target state="translated">Los implementadores del rasgo &lt;code&gt;Read&lt;/code&gt; se denominan &quot;lectores&quot;.</target>
        </trans-unit>
        <trans-unit id="514197376900c36ae488796364d18374db39a755" translate="yes" xml:space="preserve">
          <source>Implementors of the &lt;code&gt;Write&lt;/code&gt; trait are sometimes called 'writers'.</source>
          <target state="translated">Los implementadores del rasgo &lt;code&gt;Write&lt;/code&gt; a veces se denominan &quot;escritores&quot;.</target>
        </trans-unit>
        <trans-unit id="7b51391f063265e762b93ff05cea534b40f36cab" translate="yes" xml:space="preserve">
          <source>Implements &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implementa &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../marker/trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a29b7cdf7ecad32a88da5f080db151e6782b6cbd" translate="yes" xml:space="preserve">
          <source>Implements comparison of arrays &lt;a href=&quot;cmp/trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b3e920e06f6ab852e47c92d5907d33f79db03f9" translate="yes" xml:space="preserve">
          <source>Implements comparison of arrays &lt;a href=&quot;trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b100c6b8306d80c3deac3c66eb144722bfbf34" translate="yes" xml:space="preserve">
          <source>Implements comparison of arrays lexicographically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a9bfc1f72bab87b52d6e0bc8ae9d29b981a8471" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors &lt;a href=&quot;cmp/trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1d4e2f4157c9478fac1167b8d36a099c3612234" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors &lt;a href=&quot;trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10b74ce308f3638c8dc26a321e4788cd3549d889" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors lexicographically.</source>
          <target state="translated">Implementa la comparación de vectores lexicográficamente.</target>
        </trans-unit>
        <trans-unit id="8c72616b99bde1fdb32f3ac1428fa28fcbc9bbe4" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors, &lt;a href=&quot;../cmp/trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="121392f51a7cb90c886bedc6219cb1e615ac17eb" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors, &lt;a href=&quot;trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb0984094b6e313cb053dba105c8a5fe1518709" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors, lexicographically.</source>
          <target state="translated">Implementa la comparación de vectores,lexicográficamente.</target>
        </trans-unit>
        <trans-unit id="c623dbf45db1a1dd3155e5aa00891729d9911a75" translate="yes" xml:space="preserve">
          <source>Implements comparison operations on strings.</source>
          <target state="translated">Implementa operaciones de comparación en las cuerdas.</target>
        </trans-unit>
        <trans-unit id="fa422ad638e34def3ed61f76d643f937ad273390" translate="yes" xml:space="preserve">
          <source>Implements ordering of strings.</source>
          <target state="translated">Implementa el orden de las cuerdas.</target>
        </trans-unit>
        <trans-unit id="35489c538a41efaebde69fb1cc4bd86b19d3be17" translate="yes" xml:space="preserve">
          <source>Implements ordering of vectors, &lt;a href=&quot;../cmp/trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0d293e0c8158270fc97cffd60669c60a1be015e" translate="yes" xml:space="preserve">
          <source>Implements ordering of vectors, &lt;a href=&quot;trait.ord#lexicographical-comparison&quot;&gt;lexicographically&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="971e74fed270cce031930eefae039d50cd565e60" translate="yes" xml:space="preserve">
          <source>Implements ordering of vectors, lexicographically.</source>
          <target state="translated">Implementa el ordenamiento de los vectores,lexicográficamente.</target>
        </trans-unit>
        <trans-unit id="58680944d0462c99ce50feabef36368106c01977" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[.. end]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[.. end]&lt;/code&gt;.</source>
          <target state="translated">Implementa la divisi&amp;oacute;n de subcadenas con la sintaxis &lt;code&gt;&amp;amp;self[.. end]&lt;/code&gt; o &lt;code&gt;&amp;amp;mut self[.. end]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bf1f89bacc4ebdf2c2a2d9a87f72a0cbee11668" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[..= end]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[..= end]&lt;/code&gt;.</source>
          <target state="translated">Implementa la divisi&amp;oacute;n de subcadenas con la sintaxis &lt;code&gt;&amp;amp;self[..= end]&lt;/code&gt; o &lt;code&gt;&amp;amp;mut self[..= end]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da645ed385fdda76f9f961ac5448a881f907e224" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[..]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[..]&lt;/code&gt;.</source>
          <target state="translated">Implementa la divisi&amp;oacute;n de subcadenas con la sintaxis &lt;code&gt;&amp;amp;self[..]&lt;/code&gt; o &lt;code&gt;&amp;amp;mut self[..]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c82188764e977bacdfe21b9530d35069e941412" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[begin .. end]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[begin .. end]&lt;/code&gt;.</source>
          <target state="translated">Implementa la divisi&amp;oacute;n de subcadenas con la sintaxis &lt;code&gt;&amp;amp;self[begin .. end]&lt;/code&gt; o &lt;code&gt;&amp;amp;mut self[begin .. end]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a07fed60a46af26079807bf7a0b3e1b8a8d87bb3" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[begin ..= end]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[begin ..= end]&lt;/code&gt;.</source>
          <target state="translated">Implementa la divisi&amp;oacute;n de subcadenas con la sintaxis &lt;code&gt;&amp;amp;self[begin ..= end]&lt;/code&gt; o &lt;code&gt;&amp;amp;mut self[begin ..= end]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1537ec46c2d0a4e7e9dc461c66dd7e3cbe98aa22" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[begin ..]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[begin ..]&lt;/code&gt;.</source>
          <target state="translated">Implementa la divisi&amp;oacute;n de subcadenas con la sintaxis &lt;code&gt;&amp;amp;self[begin ..]&lt;/code&gt; o &lt;code&gt;&amp;amp;mut self[begin ..]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d223234199abe8bb4c0bfb887abef9197c31b0b9" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;+&lt;/code&gt; operator for concatenating two strings.</source>
          <target state="translated">Implementa el operador &lt;code&gt;+&lt;/code&gt; para concatenar dos cadenas.</target>
        </trans-unit>
        <trans-unit id="a62b7d81ea62737514c99985edc740e2f4893f26" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;+=&lt;/code&gt; operator for appending to a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">Implementa el operador &lt;code&gt;+=&lt;/code&gt; para agregar a una &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08b4a374d5ecdf82a3bd7fcf0a3e5cd5e3d002b0" translate="yes" xml:space="preserve">
          <source>Implicit Borrows</source>
          <target state="translated">Préstamos implícitos</target>
        </trans-unit>
        <trans-unit id="52d69fbd753e37f89d007646ca34b62401a67b65" translate="yes" xml:space="preserve">
          <source>Implicit Deref Coercions with Functions and Methods</source>
          <target state="translated">Coacciones derivadas implícitas con funciones y métodos</target>
        </trans-unit>
        <trans-unit id="9cd3fd2c19032ec0693dd3e0bb3e6864c82344f9" translate="yes" xml:space="preserve">
          <source>Implicit borrows may be taken in the following expressions:</source>
          <target state="translated">Los préstamos implícitos pueden tomarse en las siguientes expresiones:</target>
        </trans-unit>
        <trans-unit id="0961d46086f62e40321101d8fe037c3242c1dca6" translate="yes" xml:space="preserve">
          <source>Implicitly Enables</source>
          <target state="translated">Implícitamente permite</target>
        </trans-unit>
        <trans-unit id="8d3c039379d281862e761701f9524d54eb568424" translate="yes" xml:space="preserve">
          <source>Import or rename items from other crates or modules.</source>
          <target state="translated">Importar o renombrar artículos de otras cajas o módulos.</target>
        </trans-unit>
        <trans-unit id="a3bc444ee7d2e0f0563ef80376cca1e4bb0a9a91" translate="yes" xml:space="preserve">
          <source>Importing with &lt;code&gt;_&lt;/code&gt; to only import the methods of a trait without binding it to a name (to avoid conflict for example): &lt;code&gt;use ::std::io::Read as _;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29b127da2c62a0f25a7fa91c02ddc3226003ecc1" translate="yes" xml:space="preserve">
          <source>Imports (&lt;code&gt;use&lt;/code&gt; statements) are not allowed after non-item statements, such as variable declarations and expression statements.</source>
          <target state="translated">Las importaciones ( declaraciones de &lt;code&gt;use&lt;/code&gt; ) no est&amp;aacute;n permitidas despu&amp;eacute;s de declaraciones que no son elementos, como declaraciones de variables y declaraciones de expresi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d2aaf30df627c6b455b6a60c943334e191311021" translate="yes" xml:space="preserve">
          <source>Improve the throughput of our server with a thread pool.</source>
          <target state="translated">Mejorar el rendimiento de nuestro servidor con un pool de hilos.</target>
        </trans-unit>
        <trans-unit id="8267a696e1fca0bf8e1c78b12f8b41535d37f29b" translate="yes" xml:space="preserve">
          <source>Improving Our I/O Project</source>
          <target state="translated">Mejorando nuestro proyecto de E/S</target>
        </trans-unit>
        <trans-unit id="36118f9610eaa573d453c935f24819cf14a02463" translate="yes" xml:space="preserve">
          <source>Improving Throughput with a Thread Pool</source>
          <target state="translated">Mejorando el rendimiento con una piscina de hilos</target>
        </trans-unit>
        <trans-unit id="6bb602ffe1a1796a0ed0994f72e464f54eb4f21f" translate="yes" xml:space="preserve">
          <source>Improving the Error Message</source>
          <target state="translated">Mejorando el mensaje de error</target>
        </trans-unit>
        <trans-unit id="e4f837d4943a95698d5ec4f9d39820ea86b85e18" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ThreadPool::new&lt;/code&gt;, use the &lt;code&gt;for&lt;/code&gt; loop counter to generate an &lt;code&gt;id&lt;/code&gt;, create a new &lt;code&gt;Worker&lt;/code&gt; with that &lt;code&gt;id&lt;/code&gt;, and store the worker in the vector.</source>
          <target state="translated">En &lt;code&gt;ThreadPool::new&lt;/code&gt; , use el contador de bucle &lt;code&gt;for&lt;/code&gt; para generar una &lt;code&gt;id&lt;/code&gt; entificaci&amp;oacute;n , cree un nuevo &lt;code&gt;Worker&lt;/code&gt; con esa &lt;code&gt;id&lt;/code&gt; entificaci&amp;oacute;n y almacene el trabajador en el vector.</target>
        </trans-unit>
        <trans-unit id="100c202393da689d751f40d7d7c72d2eb2131665" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ThreadPool::new&lt;/code&gt;, we create our new channel and have the pool hold the sending end. This will successfully compile, still with warnings.</source>
          <target state="translated">En &lt;code&gt;ThreadPool::new&lt;/code&gt; , creamos nuestro nuevo canal y hacemos que el grupo mantenga el extremo de env&amp;iacute;o. Esto se compilar&amp;aacute; correctamente, a&amp;uacute;n con advertencias.</target>
        </trans-unit>
        <trans-unit id="cd9ea4b1362ab818a61083cc410122b19426aee3" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ThreadPool::new&lt;/code&gt;, we put the receiving end of the channel in an &lt;code&gt;Arc&lt;/code&gt; and a &lt;code&gt;Mutex&lt;/code&gt;. For each new worker, we clone the &lt;code&gt;Arc&lt;/code&gt; to bump the reference count so the workers can share ownership of the receiving end.</source>
          <target state="translated">En &lt;code&gt;ThreadPool::new&lt;/code&gt; , colocamos el extremo receptor del canal en un &lt;code&gt;Arc&lt;/code&gt; y un &lt;code&gt;Mutex&lt;/code&gt; . Para cada nuevo trabajador, clonamos &lt;code&gt;Arc&lt;/code&gt; para aumentar el recuento de referencias para que los trabajadores puedan compartir la propiedad del extremo receptor.</target>
        </trans-unit>
        <trans-unit id="f2d294f487d8a5d6835e163c33ed5e5a47eb006a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we call the &lt;code&gt;Dog::baby_name&lt;/code&gt; function, which calls the associated function defined on &lt;code&gt;Dog&lt;/code&gt; directly. This code prints the following:</source>
          <target state="translated">En &lt;code&gt;main&lt;/code&gt; , llamamos a la funci&amp;oacute;n &lt;code&gt;Dog::baby_name&lt;/code&gt; , que llama a la funci&amp;oacute;n asociada definida en &lt;code&gt;Dog&lt;/code&gt; directamente a . Este c&amp;oacute;digo imprime lo siguiente:</target>
        </trans-unit>
        <trans-unit id="b126874c95de4c61a2b8e325eb70f8ef2e22596f" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we create two instances of &lt;code&gt;CustomSmartPointer&lt;/code&gt; and then print &lt;code&gt;CustomSmartPointers created.&lt;/code&gt;. At the end of &lt;code&gt;main&lt;/code&gt;, our instances of &lt;code&gt;CustomSmartPointer&lt;/code&gt; will go out of scope, and Rust will call the code we put in the &lt;code&gt;drop&lt;/code&gt; method, printing our final message. Note that we didn&amp;rsquo;t need to call the &lt;code&gt;drop&lt;/code&gt; method explicitly.</source>
          <target state="translated">En &lt;code&gt;main&lt;/code&gt; , creamos dos instancias de &lt;code&gt;CustomSmartPointer&lt;/code&gt; y luego imprimimos &lt;code&gt;CustomSmartPointers created.&lt;/code&gt; . Al final de &lt;code&gt;main&lt;/code&gt; , nuestras instancias de &lt;code&gt;CustomSmartPointer&lt;/code&gt; saldr&amp;aacute;n del alcance y Rust llamar&amp;aacute; al c&amp;oacute;digo que pusimos en el m&amp;eacute;todo &lt;code&gt;drop&lt;/code&gt; , imprimiendo nuestro mensaje final. Tenga en cuenta que no necesitamos llamar al m&amp;eacute;todo &lt;code&gt;drop&lt;/code&gt; expl&amp;iacute;citamente.</target>
        </trans-unit>
        <trans-unit id="80fb329de5f9b05c42fffbe0f4f0674e4bf17666" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we create two instances of &lt;code&gt;CustomSmartPointer&lt;/code&gt; and then print &lt;code&gt;CustomSmartPointers created&lt;/code&gt;. At the end of &lt;code&gt;main&lt;/code&gt;, our instances of &lt;code&gt;CustomSmartPointer&lt;/code&gt; will go out of scope, and Rust will call the code we put in the &lt;code&gt;drop&lt;/code&gt; method, printing our final message. Note that we didn&amp;rsquo;t need to call the &lt;code&gt;drop&lt;/code&gt; method explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46b07b2a2c9642ffdec1ea49c3a0a4bddfa6c2fc" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we&amp;rsquo;ve added a new statement: &lt;code&gt;fs::read_to_string&lt;/code&gt; takes the &lt;code&gt;filename&lt;/code&gt;, opens that file, and returns a &lt;code&gt;Result&amp;lt;String&amp;gt;&lt;/code&gt; of the file&amp;rsquo;s contents.</source>
          <target state="translated">En &lt;code&gt;main&lt;/code&gt; , hemos agregado una nueva declaraci&amp;oacute;n: &lt;code&gt;fs::read_to_string&lt;/code&gt; toma el &lt;code&gt;filename&lt;/code&gt; del archivo , abre ese archivo y devuelve un &lt;code&gt;Result&amp;lt;String&amp;gt;&lt;/code&gt; del contenido del archivo.</target>
        </trans-unit>
        <trans-unit id="e1e44a817bac208c6df64d33b0859e2cb13dbc28" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we&amp;rsquo;ve defined a &lt;code&gt;Point&lt;/code&gt; that has an &lt;code&gt;i32&lt;/code&gt; for &lt;code&gt;x&lt;/code&gt; (with value &lt;code&gt;5&lt;/code&gt;) and an &lt;code&gt;f64&lt;/code&gt; for &lt;code&gt;y&lt;/code&gt; (with value &lt;code&gt;10.4&lt;/code&gt;). The &lt;code&gt;p2&lt;/code&gt; variable is a &lt;code&gt;Point&lt;/code&gt; struct that has a string slice for &lt;code&gt;x&lt;/code&gt; (with value &lt;code&gt;&quot;Hello&quot;&lt;/code&gt;) and a &lt;code&gt;char&lt;/code&gt; for &lt;code&gt;y&lt;/code&gt; (with value &lt;code&gt;c&lt;/code&gt;). Calling &lt;code&gt;mixup&lt;/code&gt; on &lt;code&gt;p1&lt;/code&gt; with the argument &lt;code&gt;p2&lt;/code&gt; gives us &lt;code&gt;p3&lt;/code&gt;, which will have an &lt;code&gt;i32&lt;/code&gt; for &lt;code&gt;x&lt;/code&gt;, because &lt;code&gt;x&lt;/code&gt; came from &lt;code&gt;p1&lt;/code&gt;. The &lt;code&gt;p3&lt;/code&gt; variable will have a &lt;code&gt;char&lt;/code&gt; for &lt;code&gt;y&lt;/code&gt;, because &lt;code&gt;y&lt;/code&gt; came from &lt;code&gt;p2&lt;/code&gt;. The &lt;code&gt;println!&lt;/code&gt; macro call will print &lt;code&gt;p3.x = 5, p3.y = c&lt;/code&gt;.</source>
          <target state="translated">En &lt;code&gt;main&lt;/code&gt; , hemos definido un &lt;code&gt;Point&lt;/code&gt; que tiene un &lt;code&gt;i32&lt;/code&gt; para &lt;code&gt;x&lt;/code&gt; (con valor &lt;code&gt;5&lt;/code&gt; ) y un &lt;code&gt;f64&lt;/code&gt; para &lt;code&gt;y&lt;/code&gt; (con valor &lt;code&gt;10.4&lt;/code&gt; ). La variable &lt;code&gt;p2&lt;/code&gt; es una estructura &lt;code&gt;Point&lt;/code&gt; que tiene un segmento de cadena para &lt;code&gt;x&lt;/code&gt; (con valor &lt;code&gt;&quot;Hello&quot;&lt;/code&gt; ) y un &lt;code&gt;char&lt;/code&gt; para &lt;code&gt;y&lt;/code&gt; (con valor &lt;code&gt;c&lt;/code&gt; ). Llamar a la &lt;code&gt;mixup&lt;/code&gt; en &lt;code&gt;p1&lt;/code&gt; con el argumento &lt;code&gt;p2&lt;/code&gt; nos da &lt;code&gt;p3&lt;/code&gt; , que tendr&amp;aacute; un &lt;code&gt;i32&lt;/code&gt; para &lt;code&gt;x&lt;/code&gt; , porque &lt;code&gt;x&lt;/code&gt; vino de &lt;code&gt;p1&lt;/code&gt; . La variable &lt;code&gt;p3&lt;/code&gt; tendr&amp;aacute; un &lt;code&gt;char&lt;/code&gt; para &lt;code&gt;y&lt;/code&gt; , porque &lt;code&gt;y&lt;/code&gt; vino de &lt;code&gt;p2&lt;/code&gt; . &amp;iexcl;El &lt;code&gt;println!&lt;/code&gt; la llamada de macro imprimir&amp;aacute; &lt;code&gt;p3.x = 5, p3.y = c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bba4ad5fa0c6788a8a98dbb77c65406e530ab490" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;match&lt;/code&gt; expressions, you can match multiple patterns using the &lt;code&gt;|&lt;/code&gt; syntax, which means &lt;em&gt;or&lt;/em&gt;. For example, the following code matches the value of &lt;code&gt;x&lt;/code&gt; against the match arms, the first of which has an &lt;em&gt;or&lt;/em&gt; option, meaning if the value of &lt;code&gt;x&lt;/code&gt; matches either of the values in that arm, that arm&amp;rsquo;s code will run:</source>
          <target state="translated">En las expresiones de &lt;code&gt;match&lt;/code&gt; , puede hacer coincidir varios patrones utilizando el &lt;code&gt;|&lt;/code&gt; sintaxis, que significa &lt;em&gt;o&lt;/em&gt; . Por ejemplo, el siguiente c&amp;oacute;digo hace coincidir el valor de &lt;code&gt;x&lt;/code&gt; con los brazos de coincidencia, el primero de los cuales tiene una opci&amp;oacute;n &lt;em&gt;o&lt;/em&gt; , lo que significa que si el valor de &lt;code&gt;x&lt;/code&gt; coincide con cualquiera de los valores en ese brazo, el c&amp;oacute;digo de ese brazo se ejecutar&amp;aacute;:</target>
        </trans-unit>
        <trans-unit id="471f0502f020cdf6e90a94b9a608c70253a470d4" translate="yes" xml:space="preserve">
          <source>In C and C++, two different operators are used for calling methods: you use &lt;code&gt;.&lt;/code&gt; if you&amp;rsquo;re calling a method on the object directly and &lt;code&gt;-&amp;gt;&lt;/code&gt; if you&amp;rsquo;re calling the method on a pointer to the object and need to dereference the pointer first. In other words, if &lt;code&gt;object&lt;/code&gt; is a pointer, &lt;code&gt;object-&amp;gt;something()&lt;/code&gt; is similar to &lt;code&gt;(*object).something()&lt;/code&gt;.</source>
          <target state="translated">En C y C ++, se utilizan dos operadores diferentes para llamar a los m&amp;eacute;todos: you use &lt;code&gt;.&lt;/code&gt; si est&amp;aacute; llamando a un m&amp;eacute;todo en el objeto directamente y &lt;code&gt;-&amp;gt;&lt;/code&gt; si est&amp;aacute; llamando al m&amp;eacute;todo en un puntero al objeto y necesita desreferenciar el puntero primero. En otras palabras, si el &lt;code&gt;object&lt;/code&gt; es un puntero, &lt;code&gt;object-&amp;gt;something()&lt;/code&gt; es similar a &lt;code&gt;(*object).something()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13a07dbff3d7bb71ba41c886c11573397f976542" translate="yes" xml:space="preserve">
          <source>In C, attempting to read beyond the end of a data structure is undefined behavior. You might get whatever is at the location in memory that would correspond to that element in the data structure, even though the memory doesn&amp;rsquo;t belong to that structure. This is called a &lt;em&gt;buffer overread&lt;/em&gt; and can lead to security vulnerabilities if an attacker is able to manipulate the index in such a way as to read data they shouldn&amp;rsquo;t be allowed to that is stored after the data structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64fdbbe6b968fb04c1bbec44c80cb2463dbf6c14" translate="yes" xml:space="preserve">
          <source>In Chapter 1, you saw that &lt;code&gt;cargo new&lt;/code&gt; adds a bit of metadata to your &lt;em&gt;Cargo.toml&lt;/em&gt; file about an edition. This appendix talks about what that means!</source>
          <target state="translated">En el Cap&amp;iacute;tulo 1, vio que &lt;code&gt;cargo new&lt;/code&gt; agrega un poco de metadatos a su archivo &lt;em&gt;Cargo.toml&lt;/em&gt; sobre una edici&amp;oacute;n. &amp;iexcl;Este ap&amp;eacute;ndice habla de lo que eso significa!</target>
        </trans-unit>
        <trans-unit id="419cbad0fac9867b4734602903e0b31a93310f44" translate="yes" xml:space="preserve">
          <source>In Chapter 10 in the &lt;a href=&quot;ch10-02-traits#implementing-a-trait-on-a-type&quot;&gt;&amp;ldquo;Implementing a Trait on a Type&amp;rdquo;&lt;/a&gt; section, we mentioned the orphan rule that states we&amp;rsquo;re allowed to implement a trait on a type as long as either the trait or the type are local to our crate. It&amp;rsquo;s possible to get around this restriction using the &lt;em&gt;newtype pattern&lt;/em&gt;, which involves creating a new type in a tuple struct. (We covered tuple structs in the &lt;a href=&quot;ch05-01-defining-structs#using-tuple-structs-without-named-fields-to-create-different-types&quot;&gt;&amp;ldquo;Using Tuple Structs without Named Fields to Create Different Types&amp;rdquo;&lt;/a&gt; section of Chapter 5.) The tuple struct will have one field and be a thin wrapper around the type we want to implement a trait for. Then the wrapper type is local to our crate, and we can implement the trait on the wrapper. &lt;em&gt;Newtype&lt;/em&gt; is a term that originates from the Haskell programming language. There is no runtime performance penalty for using this pattern, and the wrapper type is elided at compile time.</source>
          <target state="translated">En el Cap&amp;iacute;tulo 10, en la secci&amp;oacute;n &lt;a href=&quot;ch10-02-traits#implementing-a-trait-on-a-type&quot;&gt;&amp;ldquo;Implementaci&amp;oacute;n de un rasgo en un tipo&amp;rdquo;&lt;/a&gt; , mencionamos la regla hu&amp;eacute;rfana que establece que se nos permite implementar un rasgo en un tipo siempre que el rasgo o el tipo sean locales de nuestra caja. Es posible sortear esta restricci&amp;oacute;n usando el &lt;em&gt;patr&amp;oacute;n newtype&lt;/em&gt; , que implica la creaci&amp;oacute;n de un nuevo tipo en una estructura de tupla. (Cubrimos las estructuras de tupla en la &lt;a href=&quot;ch05-01-defining-structs#using-tuple-structs-without-named-fields-to-create-different-types&quot;&gt;secci&amp;oacute;n &amp;ldquo;Uso de&lt;/a&gt; estructuras de tupla sin campos con nombre para crear tipos diferentes&amp;rdquo; del Cap&amp;iacute;tulo 5.) La estructura de tupla tendr&amp;aacute; un campo y ser&amp;aacute; una envoltura delgada alrededor del tipo para el que queremos implementar un rasgo. Entonces, el tipo de contenedor es local para nuestra caja y podemos implementar el rasgo en el contenedor.&lt;em&gt; Nuevo tipo&lt;/em&gt;es un t&amp;eacute;rmino que se origina en el lenguaje de programaci&amp;oacute;n Haskell. No hay ninguna penalizaci&amp;oacute;n de rendimiento en tiempo de ejecuci&amp;oacute;n por usar este patr&amp;oacute;n y el tipo de contenedor se elide en tiempo de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6e8eda75a8ab9306f12acf53c046575d81b5e2dd" translate="yes" xml:space="preserve">
          <source>In Chapter 10, we&amp;rsquo;ll discuss how to fix these errors so you can store references in structs, but for now, we&amp;rsquo;ll fix errors like these using owned types like &lt;code&gt;String&lt;/code&gt; instead of references like &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">En el Cap&amp;iacute;tulo 10, discutiremos c&amp;oacute;mo corregir estos errores para que pueda almacenar referencias en estructuras, pero por ahora, corregiremos errores como estos usando tipos &lt;code&gt;String&lt;/code&gt; como String en lugar de referencias como &lt;code&gt;&amp;amp;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6dd5d2912e04922d837d86cebbd6cbd63896a277" translate="yes" xml:space="preserve">
          <source>In Chapter 12, we built a package that included a binary crate and a library crate. As your project develops, you might find that the library crate continues to get bigger and you want to split up your package further into multiple library crates. In this situation, Cargo offers a feature called &lt;em&gt;workspaces&lt;/em&gt; that can help manage multiple related packages that are developed in tandem.</source>
          <target state="translated">En el Cap&amp;iacute;tulo 12, creamos un paquete que inclu&amp;iacute;a una caja binaria y una caja de biblioteca. A medida que se desarrolla su proyecto, es posible que descubra que la caja de la biblioteca sigue creciendo y desea dividir su paquete en varias cajas de la biblioteca. En esta situaci&amp;oacute;n, Cargo ofrece una funci&amp;oacute;n denominada &lt;em&gt;espacios de trabajo&lt;/em&gt; que puede ayudar a administrar m&amp;uacute;ltiples paquetes relacionados que se desarrollan en conjunto.</target>
        </trans-unit>
        <trans-unit id="49c36b868291ef37c009d9056785bf6564cfe5b0" translate="yes" xml:space="preserve">
          <source>In Chapter 13, we mentioned we can use the &lt;code&gt;move&lt;/code&gt; keyword before the parameter list of a closure to force the closure to take ownership of the values it uses in the environment. This technique is especially useful when creating new threads in order to transfer ownership of values from one thread to another.</source>
          <target state="translated">En el Cap&amp;iacute;tulo 13, mencionamos que podemos usar la palabra clave &lt;code&gt;move&lt;/code&gt; antes de la lista de par&amp;aacute;metros de un cierre para forzar al cierre a tomar posesi&amp;oacute;n de los valores que usa en el entorno. Esta t&amp;eacute;cnica es especialmente &amp;uacute;til al crear nuevos hilos para transferir la propiedad de los valores de un hilo a otro.</target>
        </trans-unit>
        <trans-unit id="9616d4847d514e47da8c019bd296575902cae104" translate="yes" xml:space="preserve">
          <source>In Chapter 15, we gave a value multiple owners by using the smart pointer &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; to create a reference counted value. Let&amp;rsquo;s do the same here and see what happens. We&amp;rsquo;ll wrap the &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; in &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; in Listing 16-14 and clone the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; before moving ownership to the thread. Now that we&amp;rsquo;ve seen the errors, we&amp;rsquo;ll also switch back to using the &lt;code&gt;for&lt;/code&gt; loop, and we&amp;rsquo;ll keep the &lt;code&gt;move&lt;/code&gt; keyword with the closure.</source>
          <target state="translated">En el Cap&amp;iacute;tulo 15, dimos un valor a varios propietarios mediante el uso del puntero inteligente &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; para crear un valor contado de referencia. Hagamos lo mismo aqu&amp;iacute; y veamos qu&amp;eacute; pasa. Envolveremos el &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; en &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; en el Listado 16-14 y clonaremos el &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; antes de mover la propiedad al hilo. Ahora que hemos visto los errores, tambi&amp;eacute;n volveremos a usar el ciclo &lt;code&gt;for&lt;/code&gt; y mantendremos la palabra clave &lt;code&gt;move&lt;/code&gt; con el cierre.</target>
        </trans-unit>
        <trans-unit id="524e710ff3be8a916b101bc286117de87c9609ca" translate="yes" xml:space="preserve">
          <source>In Chapter 16, we&amp;rsquo;ll walk through different models of concurrent programming and talk about how Rust helps you to program in multiple threads fearlessly. Chapter 17 looks at how Rust idioms compare to object-oriented programming principles you might be familiar with.</source>
          <target state="translated">En el Cap&amp;iacute;tulo 16, analizaremos diferentes modelos de programaci&amp;oacute;n concurrente y hablaremos sobre c&amp;oacute;mo Rust lo ayuda a programar en m&amp;uacute;ltiples subprocesos sin temor. El cap&amp;iacute;tulo 17 analiza c&amp;oacute;mo se comparan los modismos de Rust con los principios de programaci&amp;oacute;n orientada a objetos con los que puede estar familiarizado.</target>
        </trans-unit>
        <trans-unit id="b254c18823eda209cde7cf6f8cea34605d9c5def" translate="yes" xml:space="preserve">
          <source>In Chapter 16, you learned about &lt;em&gt;channels&lt;/em&gt;&amp;mdash;a simple way to communicate between two threads&amp;mdash;that would be perfect for this use case. We&amp;rsquo;ll use a channel to function as the queue of jobs, and &lt;code&gt;execute&lt;/code&gt; will send a job from the &lt;code&gt;ThreadPool&lt;/code&gt; to the &lt;code&gt;Worker&lt;/code&gt; instances, which will send the job to its thread. Here is the plan:</source>
          <target state="translated">En el Cap&amp;iacute;tulo 16, aprendi&amp;oacute; sobre los &lt;em&gt;canales&lt;/em&gt; , una forma sencilla de comunicarse entre dos subprocesos, que ser&amp;iacute;a perfecta para este caso de uso. Usaremos un canal para funcionar como la cola de trabajos, y la &lt;code&gt;execute&lt;/code&gt; enviar&amp;aacute; un trabajo desde &lt;code&gt;ThreadPool&lt;/code&gt; a las instancias de &lt;code&gt;Worker&lt;/code&gt; , que enviar&amp;aacute;n el trabajo a su hilo. Aqu&amp;iacute; est&amp;aacute; el plan:</target>
        </trans-unit>
        <trans-unit id="3e1e00d25fb2f54374f9cdbbf2a3175b4803a287" translate="yes" xml:space="preserve">
          <source>In Chapter 2, we programmed a guessing game project that used an external package called &lt;code&gt;rand&lt;/code&gt; to get random numbers. To use &lt;code&gt;rand&lt;/code&gt; in our project, we added this line to &lt;em&gt;Cargo.toml&lt;/em&gt;:</source>
          <target state="translated">En el Cap&amp;iacute;tulo 2, programamos un proyecto de juego de adivinanzas que usaba un paquete externo llamado &lt;code&gt;rand&lt;/code&gt; para obtener n&amp;uacute;meros aleatorios. Para usar &lt;code&gt;rand&lt;/code&gt; en nuestro proyecto, agregamos esta l&amp;iacute;nea a &lt;em&gt;Cargo.toml&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="bee04de80d9266da1b5a5bfd7fdbec672bcfa89d" translate="yes" xml:space="preserve">
          <source>In Chapter 20, we&amp;rsquo;ll complete a project in which we&amp;rsquo;ll implement a low-level multithreaded web server!</source>
          <target state="translated">En el Cap&amp;iacute;tulo 20, completaremos un proyecto en el que implementaremos un servidor web multiproceso de bajo nivel.</target>
        </trans-unit>
        <trans-unit id="da4870a8b39d1e60ec313b35fcf304bfbc8e23e3" translate="yes" xml:space="preserve">
          <source>In Chapter 3, we mentioned that the &lt;code&gt;for&lt;/code&gt; loop is the most common loop construction in Rust code, but we haven&amp;rsquo;t yet discussed the pattern that &lt;code&gt;for&lt;/code&gt; takes. In a &lt;code&gt;for&lt;/code&gt; loop, the pattern is the value that directly follows the keyword &lt;code&gt;for&lt;/code&gt;, so in &lt;code&gt;for x in y&lt;/code&gt; the &lt;code&gt;x&lt;/code&gt; is the pattern.</source>
          <target state="translated">En el cap&amp;iacute;tulo 3, mencionamos que el &lt;code&gt;for&lt;/code&gt; bucle es la construcci&amp;oacute;n de lazos com&amp;uacute;n en la mayor&amp;iacute;a de c&amp;oacute;digo Rust, pero a&amp;uacute;n no han discutido el patr&amp;oacute;n que &lt;code&gt;for&lt;/code&gt; toma. En un bucle &lt;code&gt;for&lt;/code&gt; , el patr&amp;oacute;n es el valor que sigue directamente a la palabra clave &lt;code&gt;for&lt;/code&gt; , por lo que en &lt;code&gt;for x in y&lt;/code&gt; la &lt;code&gt;x&lt;/code&gt; es el patr&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="2a6b931e0d8436c1034f6b7e378a03d10cebb868" translate="yes" xml:space="preserve">
          <source>In Chapter 4, in the &lt;a href=&quot;ch04-02-references-and-borrowing#dangling-references&quot;&gt;&amp;ldquo;Dangling References&amp;rdquo;&lt;/a&gt; section, we mentioned that the compiler ensures references are always valid. Unsafe Rust has two new types called &lt;em&gt;raw pointers&lt;/em&gt; that are similar to references. As with references, raw pointers can be immutable or mutable and are written as &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt;, respectively. The asterisk isn&amp;rsquo;t the dereference operator; it&amp;rsquo;s part of the type name. In the context of raw pointers, &lt;em&gt;immutable&lt;/em&gt; means that the pointer can&amp;rsquo;t be directly assigned to after being dereferenced.</source>
          <target state="translated">En el Cap&amp;iacute;tulo 4, en la secci&amp;oacute;n &lt;a href=&quot;ch04-02-references-and-borrowing#dangling-references&quot;&gt;&quot;Referencias colgantes&quot;&lt;/a&gt; , mencionamos que el compilador garantiza que las referencias sean siempre v&amp;aacute;lidas. Unsafe Rust tiene dos nuevos tipos llamados &lt;em&gt;punteros sin procesar&lt;/em&gt; que son similares a las referencias. Al igual que con las referencias, los punteros en bruto pueden ser inmutables o mutables y se escriben como &lt;code&gt;*const T&lt;/code&gt; y &lt;code&gt;*mut T&lt;/code&gt; , respectivamente. El asterisco no es el operador de desreferencia; es parte del nombre del tipo. En el contexto de los punteros sin formato, &lt;em&gt;inmutable&lt;/em&gt; significa que el puntero no se puede asignar directamente despu&amp;eacute;s de ser desreferenciado.</target>
        </trans-unit>
        <trans-unit id="9616acd550b92d5d17bfb0c9bd8cbc2238060146" translate="yes" xml:space="preserve">
          <source>In Chapter 5, Listing 5-15, we used a &lt;code&gt;Rectangle&lt;/code&gt; struct and a &lt;code&gt;can_hold&lt;/code&gt; method, which are repeated here in Listing 11-5. Let&amp;rsquo;s put this code in the &lt;em&gt;src/lib.rs&lt;/em&gt; file and write some tests for it using the &lt;code&gt;assert!&lt;/code&gt; macro.</source>
          <target state="translated">En el Cap&amp;iacute;tulo 5, Listado 5-15, usamos una estructura &lt;code&gt;Rectangle&lt;/code&gt; y un m&amp;eacute;todo &lt;code&gt;can_hold&lt;/code&gt; , que se repiten aqu&amp;iacute; en el Listado 11-5. &amp;iexcl;Pongamos este c&amp;oacute;digo en el archivo &lt;em&gt;src / lib.rs&lt;/em&gt; y escribamos algunas pruebas para &amp;eacute;l usando el &lt;em&gt;comando &lt;/em&gt; &lt;code&gt;assert!&lt;/code&gt; macro.</target>
        </trans-unit>
        <trans-unit id="d64a393b249bd7e0a04108160fbc20ff47d94fee" translate="yes" xml:space="preserve">
          <source>In Chapter 6 we discussed how to use &lt;code&gt;if let&lt;/code&gt; expressions mainly as a shorter way to write the equivalent of a &lt;code&gt;match&lt;/code&gt; that only matches one case. Optionally, &lt;code&gt;if let&lt;/code&gt; can have a corresponding &lt;code&gt;else&lt;/code&gt; containing code to run if the pattern in the &lt;code&gt;if let&lt;/code&gt; doesn&amp;rsquo;t match.</source>
          <target state="translated">En el Cap&amp;iacute;tulo 6 discutimos c&amp;oacute;mo usar las expresiones &lt;code&gt;if let&lt;/code&gt; principalmente como una forma m&amp;aacute;s corta de escribir el equivalente de una &lt;code&gt;match&lt;/code&gt; que solo coincide con un caso. Opcionalmente, &lt;code&gt;if let&lt;/code&gt; puede tener un &lt;code&gt;else&lt;/code&gt; correspondiente que contenga el c&amp;oacute;digo para ejecutar si el patr&amp;oacute;n en &lt;code&gt;if let&lt;/code&gt; no coincide.</target>
        </trans-unit>
        <trans-unit id="ff49c1ea64c951562a8bcde89d13031f272fed75" translate="yes" xml:space="preserve">
          <source>In Chapter 7, we covered how to organize our code into modules using the &lt;code&gt;mod&lt;/code&gt; keyword, how to make items public using the &lt;code&gt;pub&lt;/code&gt; keyword, and how to bring items into a scope with the &lt;code&gt;use&lt;/code&gt; keyword. However, the structure that makes sense to you while you&amp;rsquo;re developing a crate might not be very convenient for your users. You might want to organize your structs in a hierarchy containing multiple levels, but then people who want to use a type you&amp;rsquo;ve defined deep in the hierarchy might have trouble finding out that type exists. They might also be annoyed at having to enter &lt;code&gt;use&lt;/code&gt;&lt;code&gt;my_crate::some_module::another_module::UsefulType;&lt;/code&gt; rather than &lt;code&gt;use&lt;/code&gt;&lt;code&gt;my_crate::UsefulType;&lt;/code&gt;.</source>
          <target state="translated">En el Cap&amp;iacute;tulo 7, cubrimos c&amp;oacute;mo organizar nuestro c&amp;oacute;digo en m&amp;oacute;dulos usando la palabra clave &lt;code&gt;mod&lt;/code&gt; , c&amp;oacute;mo hacer p&amp;uacute;blicos los elementos usando la palabra clave &lt;code&gt;pub&lt;/code&gt; y c&amp;oacute;mo traer elementos a un &amp;aacute;mbito con la palabra clave &lt;code&gt;use&lt;/code&gt; . Sin embargo, la estructura que tiene sentido para usted mientras est&amp;aacute; desarrollando una caja puede no ser muy conveniente para sus usuarios. Es posible que desee organizar sus estructuras en una jerarqu&amp;iacute;a que contenga varios niveles, pero las personas que quieran usar un tipo que haya definido en lo profundo de la jerarqu&amp;iacute;a podr&amp;iacute;an tener problemas para descubrir que ese tipo existe. Tambi&amp;eacute;n pueden estar molestos por tener que ingresar &lt;code&gt;use&lt;/code&gt; &lt;code&gt;my_crate::some_module::another_module::UsefulType;&lt;/code&gt; en lugar de &lt;code&gt;use&lt;/code&gt; &lt;code&gt;my_crate::UsefulType;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02801cfc606033e06bb49c81943aa261a440dd2d" translate="yes" xml:space="preserve">
          <source>In Chapter 7, you&amp;rsquo;ll learn about Rust&amp;rsquo;s module system and about privacy rules for organizing your code and its public Application Programming Interface (API). Chapter 8 discusses some common collection data structures that the standard library provides, such as vectors, strings, and hash maps. Chapter 9 explores Rust&amp;rsquo;s error-handling philosophy and techniques.</source>
          <target state="translated">En el Cap&amp;iacute;tulo 7, aprender&amp;aacute; sobre el sistema de m&amp;oacute;dulos de Rust y las reglas de privacidad para organizar su c&amp;oacute;digo y su Interfaz de programaci&amp;oacute;n de aplicaciones (API) p&amp;uacute;blica. El Cap&amp;iacute;tulo 8 analiza algunas estructuras de datos de colecci&amp;oacute;n comunes que proporciona la biblioteca est&amp;aacute;ndar, como vectores, cadenas y mapas hash. El Cap&amp;iacute;tulo 9 explora la filosof&amp;iacute;a y las t&amp;eacute;cnicas de manejo de errores de Rust.</target>
        </trans-unit>
        <trans-unit id="e7f4fbe5cc4d72a766ad29608655fb9ff4930d83" translate="yes" xml:space="preserve">
          <source>In Chapter 8, we mentioned that one limitation of vectors is that they can store elements of only one type. We created a workaround in Listing 8-10 where we defined a &lt;code&gt;SpreadsheetCell&lt;/code&gt; enum that had variants to hold integers, floats, and text. This meant we could store different types of data in each cell and still have a vector that represented a row of cells. This is a perfectly good solution when our interchangeable items are a fixed set of types that we know when our code is compiled.</source>
          <target state="translated">En el cap&amp;iacute;tulo 8, mencionamos que una limitaci&amp;oacute;n de los vectores es que pueden almacenar elementos de un solo tipo. Creamos una soluci&amp;oacute;n en el Listado 8-10 donde definimos una enumeraci&amp;oacute;n &lt;code&gt;SpreadsheetCell&lt;/code&gt; que ten&amp;iacute;a variantes para contener enteros, flotantes y texto. Esto significaba que pod&amp;iacute;amos almacenar diferentes tipos de datos en cada celda y a&amp;uacute;n tener un vector que representaba una fila de celdas. Esta es una soluci&amp;oacute;n perfectamente buena cuando nuestros elementos intercambiables son un conjunto fijo de tipos que conocemos cuando se compila nuestro c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="e267a053c2b31342cb5ac845e840508abfe7bbb3" translate="yes" xml:space="preserve">
          <source>In Enum Definitions</source>
          <target state="translated">Definiciones In Enum</target>
        </trans-unit>
        <trans-unit id="d08f333361cce04633f52b106d6b6ade62115445" translate="yes" xml:space="preserve">
          <source>In Function Definitions</source>
          <target state="translated">En las definiciones de la función</target>
        </trans-unit>
        <trans-unit id="952ef560c212771bbd3d16f99bce32435686fed6" translate="yes" xml:space="preserve">
          <source>In Listing 10-3, we extracted the code that finds the largest number into a function named &lt;code&gt;largest&lt;/code&gt;. Unlike the code in Listing 10-1, which can find the largest number in only one particular list, this program can find the largest number in two different lists.</source>
          <target state="translated">En el Listado 10-3, extrajimos el c&amp;oacute;digo que encuentra el n&amp;uacute;mero m&amp;aacute;s grande en una funci&amp;oacute;n llamada &lt;code&gt;largest&lt;/code&gt; . A diferencia del c&amp;oacute;digo del Listado 10-1, que puede encontrar el n&amp;uacute;mero m&amp;aacute;s grande en una sola lista en particular, este programa puede encontrar el n&amp;uacute;mero m&amp;aacute;s grande en dos listas diferentes.</target>
        </trans-unit>
        <trans-unit id="251e784aeacbd80cde739b539768704abe3ddc6d" translate="yes" xml:space="preserve">
          <source>In Listing 11-7, we write a function named &lt;code&gt;add_two&lt;/code&gt; that adds &lt;code&gt;2&lt;/code&gt; to its parameter and returns the result. Then we test this function using the &lt;code&gt;assert_eq!&lt;/code&gt; macro.</source>
          <target state="translated">En el Listado 11-7, escribimos una funci&amp;oacute;n llamada &lt;code&gt;add_two&lt;/code&gt; que agrega &lt;code&gt;2&lt;/code&gt; a su par&amp;aacute;metro y devuelve el resultado. &amp;iexcl;Entonces probamos esta funci&amp;oacute;n usando el &lt;code&gt;assert_eq!&lt;/code&gt; macro.</target>
        </trans-unit>
        <trans-unit id="d82e9fd957ce66c3c7a26e3dace06a42f3599199" translate="yes" xml:space="preserve">
          <source>In Listing 12-6, we added code that took a slice of &lt;code&gt;String&lt;/code&gt; values and created an instance of the &lt;code&gt;Config&lt;/code&gt; struct by indexing into the slice and cloning the values, allowing the &lt;code&gt;Config&lt;/code&gt; struct to own those values. In Listing 13-24, we&amp;rsquo;ve reproduced the implementation of the &lt;code&gt;Config::new&lt;/code&gt; function as it was in Listing 12-23:</source>
          <target state="translated">En el Listado 12-6, agregamos c&amp;oacute;digo que tom&amp;oacute; una porci&amp;oacute;n de valores &lt;code&gt;String&lt;/code&gt; y cre&amp;oacute; una instancia de la estructura &lt;code&gt;Config&lt;/code&gt; indexando en la porci&amp;oacute;n y clonando los valores, permitiendo que la estructura &lt;code&gt;Config&lt;/code&gt; posea esos valores. En el Listado 13-24, hemos reproducido la implementaci&amp;oacute;n de la funci&amp;oacute;n &lt;code&gt;Config::new&lt;/code&gt; como estaba en el Listado 12-23:</target>
        </trans-unit>
        <trans-unit id="5c6ece155f6f659be90dea5131241132de1cb17f" translate="yes" xml:space="preserve">
          <source>In Listing 12-8, we add a check in the &lt;code&gt;new&lt;/code&gt; function that will verify that the slice is long enough before accessing index 1 and 2. If the slice isn&amp;rsquo;t long enough, the program panics and displays a better error message than the &lt;code&gt;index out of bounds&lt;/code&gt; message.</source>
          <target state="translated">En el Listado 12-8, agregamos una marca en la &lt;code&gt;new&lt;/code&gt; funci&amp;oacute;n que verificar&amp;aacute; que el segmento sea lo suficientemente largo antes de acceder al &amp;iacute;ndice 1 y 2. Si el segmento no es lo suficientemente largo, el programa entra en p&amp;aacute;nico y muestra un mensaje de error mejor que el mensaje de &lt;code&gt;index out of bounds&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a621c68344fc07697a4c57219c3ad610f989fc9" translate="yes" xml:space="preserve">
          <source>In Listing 13-18, we collect the results of iterating over the iterator that&amp;rsquo;s returned from the call to &lt;code&gt;map&lt;/code&gt; into a vector. This vector will end up containing each item from the original vector incremented by 1.</source>
          <target state="translated">En el Listado 13-18, recopilamos los resultados de la iteraci&amp;oacute;n sobre el iterador que devuelve la llamada para &lt;code&gt;map&lt;/code&gt; ear en un vector. Este vector terminar&amp;aacute; conteniendo cada elemento del vector original incrementado en 1.</target>
        </trans-unit>
        <trans-unit id="e328aca1efe77dcb66a14beff2cb9b70d383d6ea" translate="yes" xml:space="preserve">
          <source>In Listing 13-19, we use &lt;code&gt;filter&lt;/code&gt; with a closure that captures the &lt;code&gt;shoe_size&lt;/code&gt; variable from its environment to iterate over a collection of &lt;code&gt;Shoe&lt;/code&gt; struct instances. It will return only shoes that are the specified size.</source>
          <target state="translated">En el Listado 13-19, usamos un &lt;code&gt;filter&lt;/code&gt; con un cierre que captura la variable &lt;code&gt;shoe_size&lt;/code&gt; de su entorno para iterar sobre una colecci&amp;oacute;n de instancias de estructura &lt;code&gt;Shoe&lt;/code&gt; . Solo devolver&amp;aacute; zapatos del tama&amp;ntilde;o especificado.</target>
        </trans-unit>
        <trans-unit id="6a1682e0b3a9e5c47b274321d74d735f83965745" translate="yes" xml:space="preserve">
          <source>In Listing 15-19, we&amp;rsquo;ll change &lt;code&gt;main&lt;/code&gt; so it has an inner scope around list &lt;code&gt;c&lt;/code&gt;; then we can see how the reference count changes when &lt;code&gt;c&lt;/code&gt; goes out of scope.</source>
          <target state="translated">En el Listado 15-19, cambiaremos &lt;code&gt;main&lt;/code&gt; para que tenga un alcance interno alrededor de la lista &lt;code&gt;c&lt;/code&gt; ; entonces podemos ver c&amp;oacute;mo cambia el recuento de referencias cuando &lt;code&gt;c&lt;/code&gt; sale del alcance.</target>
        </trans-unit>
        <trans-unit id="9f9626bbec497c54ebb40a79e403600ad23d1aab" translate="yes" xml:space="preserve">
          <source>In Listing 15-26, we&amp;rsquo;re adding a &lt;code&gt;main&lt;/code&gt; function that uses the definitions in Listing 15-25. This code creates a list in &lt;code&gt;a&lt;/code&gt; and a list in &lt;code&gt;b&lt;/code&gt; that points to the list in &lt;code&gt;a&lt;/code&gt;. Then it modifies the list in &lt;code&gt;a&lt;/code&gt; to point to &lt;code&gt;b&lt;/code&gt;, creating a reference cycle. There are &lt;code&gt;println!&lt;/code&gt; statements along the way to show what the reference counts are at various points in this process.</source>
          <target state="translated">En el Listado 15-26, agregamos una funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; que usa las definiciones del Listado 15-25. Este c&amp;oacute;digo crea una lista en &lt;code&gt;a&lt;/code&gt; y una lista de &lt;code&gt;b&lt;/code&gt; que apunta a la lista en &lt;code&gt;a&lt;/code&gt; . Luego modifica la lista en &lt;code&gt;a&lt;/code&gt; para que apunte &lt;code&gt;b&lt;/code&gt; , creando un ciclo de referencia. &amp;iexcl;Hay &lt;code&gt;println!&lt;/code&gt; declaraciones en el camino para mostrar cu&amp;aacute;les son los recuentos de referencia en varios puntos de este proceso.</target>
        </trans-unit>
        <trans-unit id="f237ef95544abe33f20082c2caecb5f5e32b6fb4" translate="yes" xml:space="preserve">
          <source>In Listing 16-8, we&amp;rsquo;ll get the value from the receiving end of the channel in the main thread. This is like retrieving the rubber duck from the water at the end of the river or like getting a chat message.</source>
          <target state="translated">En el Listado 16-8, obtendremos el valor del extremo receptor del canal en el hilo principal. Esto es como recuperar el patito de goma del agua al final del r&amp;iacute;o o como recibir un mensaje de chat.</target>
        </trans-unit>
        <trans-unit id="d280dcdadbaa3eeba45c56f7de104a2c1d73e794" translate="yes" xml:space="preserve">
          <source>In Listing 18-11, we mentioned that we could use match guards to solve our pattern-shadowing problem. Recall that a new variable was created inside the pattern in the &lt;code&gt;match&lt;/code&gt; expression instead of using the variable outside the &lt;code&gt;match&lt;/code&gt;. That new variable meant we couldn&amp;rsquo;t test against the value of the outer variable. Listing 18-27 shows how we can use a match guard to fix this problem.</source>
          <target state="translated">En el listado 18-11, mencionamos que podr&amp;iacute;amos usar protectores de coincidencias para resolver nuestro problema de sombreado de patrones. Recuerde que se cre&amp;oacute; una nueva variable dentro del patr&amp;oacute;n en la expresi&amp;oacute;n de &lt;code&gt;match&lt;/code&gt; lugar de utilizar la variable fuera de la &lt;code&gt;match&lt;/code&gt; . Esa nueva variable significaba que no pod&amp;iacute;amos probar el valor de la variable externa. El Listado 18-27 muestra c&amp;oacute;mo podemos usar un protector de partidos para solucionar este problema.</target>
        </trans-unit>
        <trans-unit id="abca10c8f21596ea1dcac6548e565013c9ca5e54" translate="yes" xml:space="preserve">
          <source>In Listing 7-11, we bring the &lt;code&gt;crate::front_of_house::hosting&lt;/code&gt; module into the scope of the &lt;code&gt;eat_at_restaurant&lt;/code&gt; function so we only have to specify &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; to call the &lt;code&gt;add_to_waitlist&lt;/code&gt; function in &lt;code&gt;eat_at_restaurant&lt;/code&gt;.</source>
          <target state="translated">En el listado 7-11, traemos el &lt;code&gt;crate::front_of_house::hosting&lt;/code&gt; m&amp;oacute;dulo en el &amp;aacute;mbito de la &lt;code&gt;eat_at_restaurant&lt;/code&gt; funci&amp;oacute;n tan s&amp;oacute;lo tenemos que especificar &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; a llamar a la &lt;code&gt;add_to_waitlist&lt;/code&gt; funci&amp;oacute;n en &lt;code&gt;eat_at_restaurant&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4980a71413b7bee6107bccf8cc848ba4479eb5f7" translate="yes" xml:space="preserve">
          <source>In Listing 7-11, you might have wondered why we specified &lt;code&gt;use crate::front_of_house::hosting&lt;/code&gt; and then called &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; in &lt;code&gt;eat_at_restaurant&lt;/code&gt; rather than specifying the &lt;code&gt;use&lt;/code&gt; path all the way out to the &lt;code&gt;add_to_waitlist&lt;/code&gt; function to achieve the same result, as in Listing 7-13.</source>
          <target state="translated">En el Listado 7-11, es posible que se haya preguntado por qu&amp;eacute; especificamos &lt;code&gt;use crate::front_of_house::hosting&lt;/code&gt; y luego llamamos &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; en &lt;code&gt;eat_at_restaurant&lt;/code&gt; en lugar de especificar la ruta de &lt;code&gt;use&lt;/code&gt; hasta la funci&amp;oacute;n &lt;code&gt;add_to_waitlist&lt;/code&gt; para lograr el mismo resultado, como en el Listado 7-13.</target>
        </trans-unit>
        <trans-unit id="e4a8944a57a6797c5d37540cb53feeffc923077a" translate="yes" xml:space="preserve">
          <source>In Method Definitions</source>
          <target state="translated">En las definiciones de los métodos</target>
        </trans-unit>
        <trans-unit id="6bcea9677a17f227f763c241c0436f8dec05cc75" translate="yes" xml:space="preserve">
          <source>In Rust 1.3, the default object lifetime bounds are expected to change, as described in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md&quot;&gt;RFC 1156&lt;/a&gt;. You are getting a warning because the compiler thinks it is possible that this change will cause a compilation error in your code. It is possible, though unlikely, that this is a false alarm.</source>
          <target state="translated">En Rust 1.3, se espera que cambien los l&amp;iacute;mites de duraci&amp;oacute;n del objeto predeterminados, como se describe en &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md&quot;&gt;RFC 1156&lt;/a&gt; . Recibir&amp;aacute; una advertencia porque el compilador cree que es posible que este cambio provoque un error de compilaci&amp;oacute;n en su c&amp;oacute;digo. Es posible, aunque poco probable, que se trate de una falsa alarma.</target>
        </trans-unit>
        <trans-unit id="024c5bd925d0560baf0e3312c1764bcb998284df" translate="yes" xml:space="preserve">
          <source>In Rust 2015, paths in &lt;code&gt;use&lt;/code&gt; statements are relative to the crate root. To import items relative to the current and parent modules, use the &lt;code&gt;self::&lt;/code&gt; and &lt;code&gt;super::&lt;/code&gt; prefixes, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1dd28b00244d1766f66dc28a5630ffdd59cfac9" translate="yes" xml:space="preserve">
          <source>In Rust 2018 the &lt;code&gt;extern crate&lt;/code&gt; declaration is not required and you can instead just &lt;code&gt;use&lt;/code&gt; it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b256b3c7dd03072851511683d3f9db1e7f94539a" translate="yes" xml:space="preserve">
          <source>In Rust 2018, paths in &lt;code&gt;use&lt;/code&gt; statements are relative to the current module unless they begin with the name of a crate or a literal &lt;code&gt;crate::&lt;/code&gt;, in which case they start from the crate root. As in Rust 2015 code, the &lt;code&gt;self::&lt;/code&gt; and &lt;code&gt;super::&lt;/code&gt; prefixes refer to the current and parent modules respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="712e6f56bd66b2c2324289d3a7246a32df88ce1c" translate="yes" xml:space="preserve">
          <source>In Rust a function can &quot;return&quot; early if it either panics or calls a function which transitively panics. This sort of control flow is not always anticipated, and has the possibility of causing subtle bugs through a combination of two critical components:</source>
          <target state="translated">En el óxido,una función puede &quot;volver&quot; antes si entra en pánico o llama a una función que entra en pánico de manera transitoria.Este tipo de flujo de control no siempre se anticipa,y tiene la posibilidad de causar sutiles errores a través de una combinación de dos componentes críticos:</target>
        </trans-unit>
        <trans-unit id="9bc4180eb9646df4526201ce99ed1c8e848a3716" translate="yes" xml:space="preserve">
          <source>In Rust, &lt;em&gt;release profiles&lt;/em&gt; are predefined and customizable profiles with different configurations that allow a programmer to have more control over various options for compiling code. Each profile is configured independently of the others.</source>
          <target state="translated">En Rust, los &lt;em&gt;perfiles de lanzamiento&lt;/em&gt; son &lt;em&gt;perfiles&lt;/em&gt; predefinidos y personalizables con diferentes configuraciones que permiten al programador tener m&amp;aacute;s control sobre varias opciones para compilar c&amp;oacute;digo. Cada perfil se configura independientemente de los dem&amp;aacute;s.</target>
        </trans-unit>
        <trans-unit id="7767a9661c12c424875cfc28277bdd9f242eed45" translate="yes" xml:space="preserve">
          <source>In Rust, comments must start with two slashes and continue until the end of the line. For comments that extend beyond a single line, you&amp;rsquo;ll need to include &lt;code&gt;//&lt;/code&gt; on each line, like this:</source>
          <target state="translated">En Rust, los comentarios deben comenzar con dos barras y continuar hasta el final de la l&amp;iacute;nea. Para los comentarios que se extienden m&amp;aacute;s all&amp;aacute; de una sola l&amp;iacute;nea, deber&amp;aacute; incluir &lt;code&gt;//&lt;/code&gt; en cada l&amp;iacute;nea, as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="2b870cbcd5d9e116b1796136a551009e4fc668b1" translate="yes" xml:space="preserve">
          <source>In Rust, global variables are called &lt;em&gt;static&lt;/em&gt; variables. Listing 19-9 shows an example declaration and use of a static variable with a string slice as a value.</source>
          <target state="translated">En Rust, las variables globales se denominan variables &lt;em&gt;est&amp;aacute;ticas&lt;/em&gt; . El Listado 19-9 muestra una declaraci&amp;oacute;n de ejemplo y el uso de una variable est&amp;aacute;tica con un segmento de cadena como valor.</target>
        </trans-unit>
        <trans-unit id="9017f450d5ec005f20ca12643e0bd4fe5612a944" translate="yes" xml:space="preserve">
          <source>In Rust, integration tests are entirely external to your library. They use your library in the same way any other code would, which means they can only call functions that are part of your library&amp;rsquo;s public API. Their purpose is to test whether many parts of your library work together correctly. Units of code that work correctly on their own could have problems when integrated, so test coverage of the integrated code is important as well. To create integration tests, you first need a &lt;em&gt;tests&lt;/em&gt; directory.</source>
          <target state="translated">En Rust, las pruebas de integraci&amp;oacute;n son completamente externas a su biblioteca. Usan su biblioteca de la misma manera que lo har&amp;iacute;a cualquier otro c&amp;oacute;digo, lo que significa que solo pueden llamar a funciones que forman parte de la API p&amp;uacute;blica de su biblioteca. Su prop&amp;oacute;sito es probar si muchas partes de su biblioteca funcionan juntas correctamente. Las unidades de c&amp;oacute;digo que funcionan correctamente por s&amp;iacute; solas pueden tener problemas cuando se integran, por lo que la cobertura de prueba del c&amp;oacute;digo integrado tambi&amp;eacute;n es importante. Para crear pruebas de integraci&amp;oacute;n, primero necesita un directorio de &lt;em&gt;pruebas&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="dec0f2165acd76f17d012b2a448b31c87c4a44df" translate="yes" xml:space="preserve">
          <source>In Rust, it is common to provide different representations of a type for different use cases. For instance, storage location and management for a value can be specifically chosen as appropriate for a particular use via pointer types such as &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. Beyond these generic wrappers that can be used with any type, some types provide optional facets providing potentially costly functionality. An example for such a type is &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; which adds the ability to extend a string to the basic &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. This requires keeping additional information unnecessary for a simple, immutable string.</source>
          <target state="translated">En Rust, es com&amp;uacute;n proporcionar diferentes representaciones de un tipo para diferentes casos de uso. Por ejemplo, la ubicaci&amp;oacute;n de almacenamiento y la gesti&amp;oacute;n de un valor se pueden elegir espec&amp;iacute;ficamente seg&amp;uacute;n sea apropiado para un uso particular mediante tipos de puntero como &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; . M&amp;aacute;s all&amp;aacute; de estos envoltorios gen&amp;eacute;ricos que se pueden usar con cualquier tipo, algunos tipos proporcionan facetas opcionales que proporcionan una funcionalidad potencialmente costosa. Un ejemplo de tal tipo es &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; ,&lt;/a&gt; que agrega la capacidad de extender una cadena a la &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; b&amp;aacute;sica . Esto requiere mantener informaci&amp;oacute;n adicional innecesaria para una cadena simple e inmutable.</target>
        </trans-unit>
        <trans-unit id="82ce18dba324f3792ac22c2d57152d85262e47df" translate="yes" xml:space="preserve">
          <source>In Rust, it's more common to pass slices as arguments rather than vectors when you just want to provide a read access. The same goes for &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">En Rust, es m&amp;aacute;s com&amp;uacute;n pasar segmentos como argumentos en lugar de vectores cuando solo desea proporcionar acceso de lectura. Lo mismo ocurre con &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fa445d9bc6ce3579a8b9343d188f81a07982bc87" translate="yes" xml:space="preserve">
          <source>In Rust, it's more common to pass slices as arguments rather than vectors when you just want to provide read access. The same goes for &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26c54c2fe2f6156c5b713520cfa95f63f7a98f30" translate="yes" xml:space="preserve">
          <source>In Rust, iterators are &lt;em&gt;lazy&lt;/em&gt;, meaning they have no effect until you call methods that consume the iterator to use it up. For example, the code in Listing 13-13 creates an iterator over the items in the vector &lt;code&gt;v1&lt;/code&gt; by calling the &lt;code&gt;iter&lt;/code&gt; method defined on &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. This code by itself doesn&amp;rsquo;t do anything useful.</source>
          <target state="translated">En Rust, los iteradores son &lt;em&gt;perezosos&lt;/em&gt; , lo que significa que no tienen ning&amp;uacute;n efecto hasta que llama a m&amp;eacute;todos que consumen el iterador para usarlo. Por ejemplo, el c&amp;oacute;digo del Listado 13-13 crea un iterador sobre los elementos del vector &lt;code&gt;v1&lt;/code&gt; llamando al m&amp;eacute;todo &lt;code&gt;iter&lt;/code&gt; definido en &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; . Este c&amp;oacute;digo por s&amp;iacute; solo no hace nada &amp;uacute;til.</target>
        </trans-unit>
        <trans-unit id="94113c6270ca76a6260b8782567c46273149927b" translate="yes" xml:space="preserve">
          <source>In Rust, some simple types are &quot;implicitly copyable&quot; and when you assign them or pass them as arguments, the receiver will get a copy, leaving the original value in place. These types do not require allocation to copy and do not have finalizers (i.e., they do not contain owned boxes or implement &lt;a href=&quot;../ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt;), so the compiler considers them cheap and safe to copy. For other types copies must be made explicitly, by convention implementing the &lt;a href=&quot;trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; trait and calling the &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">En Rust, algunos tipos simples son &quot;copiables impl&amp;iacute;citamente&quot; y cuando los asigna o los pasa como argumentos, el receptor obtendr&amp;aacute; una copia, dejando el valor original en su lugar. Estos tipos no requieren asignaci&amp;oacute;n para copiar y no tienen finalizadores (es decir, no contienen cajas propias ni implementan &lt;a href=&quot;../ops/trait.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; &lt;/a&gt; ), por lo que el compilador los considera baratos y seguros de copiar. Para otros tipos, las copias deben hacerse expl&amp;iacute;citamente, por convenci&amp;oacute;n, implementando el rasgo &lt;a href=&quot;trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; y llamando al m&amp;eacute;todo &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2fcd990460e8b6d0fc26ae7880ea98a98c91ad7c" translate="yes" xml:space="preserve">
          <source>In Rust, some simple types are &quot;implicitly copyable&quot; and when you assign them or pass them as arguments, the receiver will get a copy, leaving the original value in place. These types do not require allocation to copy and do not have finalizers (i.e., they do not contain owned boxes or implement &lt;a href=&quot;../ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt;), so the compiler considers them cheap and safe to copy. For other types copies must be made explicitly, by convention implementing the &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; trait and calling the &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d027227e4e1f4e8516c4cd730528f3ec982d46a" translate="yes" xml:space="preserve">
          <source>In Rust, some types don't have a known size at compile-time. For example, in a slice type like &lt;code&gt;[u32]&lt;/code&gt;, the number of elements is not known at compile-time and hence the overall size cannot be computed. As a result, such types can only be manipulated through a reference (e.g., &lt;code&gt;&amp;amp;T&lt;/code&gt; or &lt;code&gt;&amp;amp;mut T&lt;/code&gt;) or other pointer-type (e.g., &lt;code&gt;Box&lt;/code&gt; or &lt;code&gt;Rc&lt;/code&gt;). Try casting to a reference instead:</source>
          <target state="translated">En Rust, algunos tipos no tienen un tama&amp;ntilde;o conocido en tiempo de compilaci&amp;oacute;n. Por ejemplo, en un tipo de segmento como &lt;code&gt;[u32]&lt;/code&gt; , el n&amp;uacute;mero de elementos no se conoce en tiempo de compilaci&amp;oacute;n y, por lo tanto, no se puede calcular el tama&amp;ntilde;o total. Como resultado, estos tipos solo se pueden manipular a trav&amp;eacute;s de una referencia (por ejemplo, &lt;code&gt;&amp;amp;T&lt;/code&gt; o &lt;code&gt;&amp;amp;mut T&lt;/code&gt; ) u otro tipo de puntero (por ejemplo, &lt;code&gt;Box&lt;/code&gt; o &lt;code&gt;Rc&lt;/code&gt; ). En su lugar, intente transmitir a una referencia:</target>
        </trans-unit>
        <trans-unit id="9fe024fcbc9eb5fd9138b820c96a155b436c6f2b" translate="yes" xml:space="preserve">
          <source>In Rust, strings are always valid UTF-8, which may contain zeros.</source>
          <target state="translated">En Rust,las cuerdas son siempre válidas UTF-8,que pueden contener ceros.</target>
        </trans-unit>
        <trans-unit id="47b3f71c4c3ef3117002e8cd6753431d26cd2f16" translate="yes" xml:space="preserve">
          <source>In Rust, the compiler guarantees that when you state that a value won&amp;rsquo;t change, it really won&amp;rsquo;t change. That means that when you&amp;rsquo;re reading and writing code, you don&amp;rsquo;t have to keep track of how and where a value might change. Your code is thus easier to reason through.</source>
          <target state="translated">En Rust, el compilador garantiza que cuando declaras que un valor no cambiar&amp;aacute;, realmente no cambiar&amp;aacute;. Eso significa que cuando lee y escribe c&amp;oacute;digo, no tiene que hacer un seguimiento de c&amp;oacute;mo y d&amp;oacute;nde puede cambiar un valor. Por lo tanto, su c&amp;oacute;digo es m&amp;aacute;s f&amp;aacute;cil de razonar.</target>
        </trans-unit>
        <trans-unit id="187bd10d150e89528422d52ad5b94f3768fbf136" translate="yes" xml:space="preserve">
          <source>In Rust, the idiomatic comment style starts a comment with two slashes, and the comment continues until the end of the line. For comments that extend beyond a single line, you&amp;rsquo;ll need to include &lt;code&gt;//&lt;/code&gt; on each line, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6617fc32e8b52f8e6973b5aca9e078db6c9e5e4e" translate="yes" xml:space="preserve">
          <source>In Rust, the values going into an array are written as a comma-separated list inside square brackets:</source>
          <target state="translated">En Rust,los valores que van en una matriz se escriben como una lista separada por comas dentro de corchetes:</target>
        </trans-unit>
        <trans-unit id="a0eeda0b6efe2675308b78561e1528ea9b8ef8e6" translate="yes" xml:space="preserve">
          <source>In Rust, which uses the concept of ownership and borrowing, an additional difference between references and smart pointers is that references are pointers that only borrow data; in contrast, in many cases, smart pointers &lt;em&gt;own&lt;/em&gt; the data they point to.</source>
          <target state="translated">En Rust, que utiliza el concepto de propiedad y pr&amp;eacute;stamo, una diferencia adicional entre referencias y punteros inteligentes es que las referencias son punteros que solo toman prestados datos; por el contrario, en muchos casos, los punteros inteligentes &lt;em&gt;poseen&lt;/em&gt; los datos a los que apuntan.</target>
        </trans-unit>
        <trans-unit id="691eb1f4f0d39b9fa142187d5288e88e969f7b55" translate="yes" xml:space="preserve">
          <source>In Rust, you can only move a value when its size is known at compile time.</source>
          <target state="translated">En Rust,sólo se puede mover un valor cuando se conoce su tamaño en el momento de la compilación.</target>
        </trans-unit>
        <trans-unit id="a157248f3dcdf6e31faebd518fa0921b01977a17" translate="yes" xml:space="preserve">
          <source>In Struct Definitions</source>
          <target state="translated">En Definiciones de Estructuras</target>
        </trans-unit>
        <trans-unit id="d100734dbe9aad18e3d33332b24c477c5b5bbfb9" translate="yes" xml:space="preserve">
          <source>In Turkish, the equivalent of 'i' in Latin has five forms instead of two:</source>
          <target state="translated">En turco,el equivalente de la &quot;i&quot; en latín tiene cinco formas en lugar de dos:</target>
        </trans-unit>
        <trans-unit id="95435691c2a2f4eefe5ecbf90205f41c0b8b41fb" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;keyword.trait&quot;&gt;&lt;code&gt;trait&lt;/code&gt;&lt;/a&gt; definition and related &lt;a href=&quot;keyword.impl&quot;&gt;&lt;code&gt;impl&lt;/code&gt;&lt;/a&gt; block:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b57043cd55b10d931a7fc7d67ec1a60b6e68743" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;fn&lt;/code&gt; type, a lifetime appears only in the return type and not in the arguments types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ed6a36e0bfb7f0da5796e97aada1c92ba3960ed" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;fn&lt;/code&gt; type, a lifetime appears only in the return type, and not in the arguments types.</source>
          <target state="translated">En un &lt;code&gt;fn&lt;/code&gt; tipo , una duraci&amp;oacute;n aparece solo en el tipo de retorno y no en los tipos de argumentos.</target>
        </trans-unit>
        <trans-unit id="f577fe622a880c803e2735f577b8d078ed3ef1c7" translate="yes" xml:space="preserve">
          <source>In a given program, the standard library has one &amp;ldquo;global&amp;rdquo; memory allocator that is used for example by &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">En un programa dado, la biblioteca est&amp;aacute;ndar tiene un asignador de memoria &quot;global&quot; que se utiliza, por ejemplo, por &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; y &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46b9760c06657f51a003601c090db16f5dbd5990" translate="yes" xml:space="preserve">
          <source>In a match expression, only numbers and characters can be matched against a range. This is because the compiler checks that the range is non-empty at compile-time, and is unable to evaluate arbitrary comparison functions. If you want to capture values of an orderable type between two end-points, you can use a guard.</source>
          <target state="translated">En una expresión de coincidencia,sólo los números y los caracteres pueden coincidir con un rango.Esto se debe a que el compilador comprueba que el rango no está vacío en tiempo de compilación,y no puede evaluar funciones de comparación arbitrarias.Si desea capturar valores de un tipo ordenable entre dos puntos finales,puede utilizar un protector.</target>
        </trans-unit>
        <trans-unit id="33cf96775891f63612a2b18790b9f75c00ddb97e" translate="yes" xml:space="preserve">
          <source>In a more ideal world, we could check that requirement by just checking that the given type implements both (1.) the &lt;code&gt;StructuralPartialEq&lt;/code&gt; trait &lt;em&gt;and&lt;/em&gt; (2.) the &lt;code&gt;Eq&lt;/code&gt; trait. However, you can have ADTs that &lt;em&gt;do&lt;/em&gt;&lt;code&gt;derive(PartialEq, Eq)&lt;/code&gt;, and be a case that we want the compiler to accept, and yet the constant's type fails to implement &lt;code&gt;Eq&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41334b21dc400411b3cbc2d397bfe91718ef4ea6" translate="yes" xml:space="preserve">
          <source>In a pattern, all values that don't implement the &lt;code&gt;Copy&lt;/code&gt; trait have to be bound the same way. The goal here is to avoid binding simultaneously by-move and by-ref.</source>
          <target state="translated">En un patr&amp;oacute;n, todos los valores que no implementan la &lt;code&gt;Copy&lt;/code&gt; rasgo deben estar vinculados de la misma manera. El objetivo aqu&amp;iacute; es evitar atar simult&amp;aacute;neamente por movimiento y por ref.</target>
        </trans-unit>
        <trans-unit id="af5a9dd7adf13b2c4101e8e1cf8cfb6e4f72a459" translate="yes" xml:space="preserve">
          <source>In a pattern: inclusive range pattern</source>
          <target state="translated">En un patrón:patrón de rango inclusivo</target>
        </trans-unit>
        <trans-unit id="83c0ddf34fdbd1317fa94180ff2437b5be9c9767" translate="yes" xml:space="preserve">
          <source>In a similar fashion to the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; protocol, once a &lt;code&gt;DoubleEndedIterator&lt;/code&gt; returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; from a &lt;a href=&quot;trait.doubleendediterator#tymethod.next_back&quot;&gt;&lt;code&gt;next_back()&lt;/code&gt;&lt;/a&gt;, calling it again may or may not ever return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt; again. &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.doubleendediterator#tymethod.next_back&quot;&gt;&lt;code&gt;next_back()&lt;/code&gt;&lt;/a&gt; are interchangeable for this purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="697b27e185f89dd645c18a1dc354fc3f1802ced3" translate="yes" xml:space="preserve">
          <source>In a similar fashion to the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; protocol, once a &lt;code&gt;DoubleEndedIterator&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt; from a &lt;code&gt;next_back()&lt;/code&gt;, calling it again may or may not ever return &lt;code&gt;Some&lt;/code&gt; again. &lt;code&gt;next()&lt;/code&gt; and &lt;code&gt;next_back()&lt;/code&gt; are interchangeable for this purpose.</source>
          <target state="translated">De una manera similar a la &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; protocolo, una vez al &lt;code&gt;DoubleEndedIterator&lt;/code&gt; vuelve &lt;code&gt;None&lt;/code&gt; de un &lt;code&gt;next_back()&lt;/code&gt; , llamando de nuevo puede o no volver jam&amp;aacute;s &lt;code&gt;Some&lt;/code&gt; de nuevo. &lt;code&gt;next()&lt;/code&gt; y &lt;code&gt;next_back()&lt;/code&gt; son intercambiables para este prop&amp;oacute;sito.</target>
        </trans-unit>
        <trans-unit id="88eab3fc134ebcc83a18f11603e4f9bb4c35397e" translate="yes" xml:space="preserve">
          <source>In a way, channels in any programming language are similar to single ownership, because once you transfer a value down a channel, you should no longer use that value. Shared memory concurrency is like multiple ownership: multiple threads can access the same memory location at the same time. As you saw in Chapter 15, where smart pointers made multiple ownership possible, multiple ownership can add complexity because these different owners need managing. Rust&amp;rsquo;s type system and ownership rules greatly assist in getting this management correct. For an example, let&amp;rsquo;s look at mutexes, one of the more common concurrency primitives for shared memory.</source>
          <target state="translated">En cierto modo, los canales en cualquier lenguaje de programaci&amp;oacute;n son similares a la propiedad individual, porque una vez que transfieres un valor a un canal, ya no debes usar ese valor. La simultaneidad de la memoria compartida es como propiedad m&amp;uacute;ltiple: varios subprocesos pueden acceder a la misma ubicaci&amp;oacute;n de memoria al mismo tiempo. Como vio en el Cap&amp;iacute;tulo 15, donde los punteros inteligentes hicieron posible la propiedad m&amp;uacute;ltiple, la propiedad m&amp;uacute;ltiple puede agregar complejidad porque estos diferentes propietarios necesitan administraci&amp;oacute;n. El sistema de tipos y las reglas de propiedad de Rust ayudan enormemente a que esta gesti&amp;oacute;n sea correcta. Por ejemplo, veamos las exclusiones mutuas, una de las primitivas de concurrencia m&amp;aacute;s comunes para la memoria compartida.</target>
        </trans-unit>
        <trans-unit id="48cbc9de09384450c3743b99a8ac852e0f936580" translate="yes" xml:space="preserve">
          <source>In addition to being used for explicit dereferencing operations with the (unary) &lt;code&gt;*&lt;/code&gt; operator in immutable contexts, &lt;code&gt;Deref&lt;/code&gt; is also used implicitly by the compiler in many circumstances. This mechanism is called &lt;a href=&quot;#more-on-deref-coercion&quot;&gt;'&lt;code&gt;Deref&lt;/code&gt; coercion'&lt;/a&gt;. In mutable contexts, &lt;a href=&quot;trait.derefmut&quot;&gt;&lt;code&gt;DerefMut&lt;/code&gt;&lt;/a&gt; is used.</source>
          <target state="translated">Adem&amp;aacute;s de usarse para operaciones expl&amp;iacute;citas de desreferenciaci&amp;oacute;n con el operador (unario) &lt;code&gt;*&lt;/code&gt; en contextos inmutables, el &lt;code&gt;Deref&lt;/code&gt; tambi&amp;eacute;n usa impl&amp;iacute;citamente Deref en muchas circunstancias. Este mecanismo se llama &lt;a href=&quot;#more-on-deref-coercion&quot;&gt;&quot; coerci&amp;oacute;n de &lt;code&gt;Deref&lt;/code&gt; &quot;&lt;/a&gt; . En contextos mutables, se usa &lt;a href=&quot;trait.derefmut&quot;&gt; &lt;code&gt;DerefMut&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="af3b06fb6100259de10ad5265fd070edc0ff47dc" translate="yes" xml:space="preserve">
          <source>In addition to being used for explicit dereferencing operations with the (unary) &lt;code&gt;*&lt;/code&gt; operator in mutable contexts, &lt;code&gt;DerefMut&lt;/code&gt; is also used implicitly by the compiler in many circumstances. This mechanism is called &lt;a href=&quot;#more-on-deref-coercion&quot;&gt;'&lt;code&gt;Deref&lt;/code&gt; coercion'&lt;/a&gt;. In immutable contexts, &lt;a href=&quot;trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; is used.</source>
          <target state="translated">Adem&amp;aacute;s de usarse para operaciones de desreferenciaci&amp;oacute;n expl&amp;iacute;citas con el operador (unario) &lt;code&gt;*&lt;/code&gt; en contextos mutables, el &lt;code&gt;DerefMut&lt;/code&gt; tambi&amp;eacute;n usa impl&amp;iacute;citamente DerefMut en muchas circunstancias. Este mecanismo se llama &lt;a href=&quot;#more-on-deref-coercion&quot;&gt;&quot; coerci&amp;oacute;n de &lt;code&gt;Deref&lt;/code&gt; &quot;&lt;/a&gt; . En contextos inmutables, se usa &lt;a href=&quot;trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="abb02b5058d0ef49ec9e5d67ae93248f0d00150f" translate="yes" xml:space="preserve">
          <source>In addition to checking that our code returns the correct values we expect, it&amp;rsquo;s also important to check that our code handles error conditions as we expect. For example, consider the &lt;code&gt;Guess&lt;/code&gt; type that we created in Chapter 9, Listing 9-10. Other code that uses &lt;code&gt;Guess&lt;/code&gt; depends on the guarantee that &lt;code&gt;Guess&lt;/code&gt; instances will contain only values between 1 and 100. We can write a test that ensures that attempting to create a &lt;code&gt;Guess&lt;/code&gt; instance with a value outside that range panics.</source>
          <target state="translated">Adem&amp;aacute;s de verificar que nuestro c&amp;oacute;digo devuelva los valores correctos que esperamos, tambi&amp;eacute;n es importante verificar que nuestro c&amp;oacute;digo maneje las condiciones de error como esperamos. Por ejemplo, considere el tipo &lt;code&gt;Guess&lt;/code&gt; que creamos en el Cap&amp;iacute;tulo 9, Listado 9-10. Otro c&amp;oacute;digo que usa &lt;code&gt;Guess&lt;/code&gt; depende de la garant&amp;iacute;a de que las instancias de &lt;code&gt;Guess&lt;/code&gt; contendr&amp;aacute;n solo valores entre 1 y 100. Podemos escribir una prueba que asegure que intentar crear una instancia de &lt;code&gt;Guess&lt;/code&gt; con un valor fuera de ese rango entra en p&amp;aacute;nico.</target>
        </trans-unit>
        <trans-unit id="365e97bba6e57bb996028209ce11038273821045" translate="yes" xml:space="preserve">
          <source>In addition to destructuring through pattern matching, we can access a tuple element directly by using a period (&lt;code&gt;.&lt;/code&gt;) followed by the index of the value we want to access. For example:</source>
          <target state="translated">Adem&amp;aacute;s de la desestructuraci&amp;oacute;n mediante la coincidencia de patrones, podemos acceder a un elemento de tupla directamente usando un punto ( &lt;code&gt;.&lt;/code&gt; ) Seguido del &amp;iacute;ndice del valor al que queremos acceder. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="47ed7b4173b1b21a3fd1fe7ba6e3f3784fea24f1" translate="yes" xml:space="preserve">
          <source>In addition to fitting the block of memory &lt;code&gt;layout&lt;/code&gt;, the alignment of the &lt;code&gt;layout&lt;/code&gt; must match the alignment used to allocate that block of memory.</source>
          <target state="translated">Adem&amp;aacute;s de ajustar el &lt;code&gt;layout&lt;/code&gt; del bloque de memoria , la alineaci&amp;oacute;n del &lt;code&gt;layout&lt;/code&gt; debe coincidir con la alineaci&amp;oacute;n utilizada para asignar ese bloque de memoria.</target>
        </trans-unit>
        <trans-unit id="858e151181f26f5ae0ab57f08e577f173bb29c01" translate="yes" xml:space="preserve">
          <source>In addition to grouping functionality, encapsulating implementation details lets you reuse code at a higher level: once you&amp;rsquo;ve implemented an operation, other code can call that code via the code&amp;rsquo;s public interface without knowing how the implementation works. The way you write code defines which parts are public for other code to use and which parts are private implementation details that you reserve the right to change. This is another way to limit the amount of detail you have to keep in your head.</source>
          <target state="translated">Adem&amp;aacute;s de la funcionalidad de agrupaci&amp;oacute;n, encapsular los detalles de la implementaci&amp;oacute;n le permite reutilizar el c&amp;oacute;digo en un nivel superior: una vez que haya implementado una operaci&amp;oacute;n, otro c&amp;oacute;digo puede llamar a ese c&amp;oacute;digo a trav&amp;eacute;s de la interfaz p&amp;uacute;blica del c&amp;oacute;digo sin saber c&amp;oacute;mo funciona la implementaci&amp;oacute;n. La forma en que escribe el c&amp;oacute;digo define qu&amp;eacute; partes son p&amp;uacute;blicas para que las use otro c&amp;oacute;digo y qu&amp;eacute; partes son detalles de implementaci&amp;oacute;n privados que se reserva el derecho de cambiar. Esta es otra forma de limitar la cantidad de detalles que debe tener en la cabeza.</target>
        </trans-unit>
        <trans-unit id="d459ee4d2bcede7c5e1530b0662bf25061170f15" translate="yes" xml:space="preserve">
          <source>In addition to presenting fixed types in the form of &lt;code&gt;fn name(arg: type, ..) -&amp;gt; return_type&lt;/code&gt;, functions can also declare a list of type parameters along with trait bounds that they fall into.</source>
          <target state="translated">Adem&amp;aacute;s de presentar tipos fijos en forma de &lt;code&gt;fn name(arg: type, ..) -&amp;gt; return_type&lt;/code&gt; , las funciones tambi&amp;eacute;n pueden declarar una lista de par&amp;aacute;metros de tipo junto con los l&amp;iacute;mites de rasgos en los que caen.</target>
        </trans-unit>
        <trans-unit id="d6b811c43ad4130bc5a6536fe58f23b2b67258a1" translate="yes" xml:space="preserve">
          <source>In addition to public and private, Rust allows users to declare an item as visible only within a given scope. The rules for &lt;code&gt;pub&lt;/code&gt; restrictions are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef3214c58b982aa2702311df460d3b874a884211" translate="yes" xml:space="preserve">
          <source>In addition to public and private, Rust allows users to declare an item as visible within a given scope. The rules for &lt;code&gt;pub&lt;/code&gt; restrictions are as follows:</source>
          <target state="translated">Adem&amp;aacute;s de p&amp;uacute;blico y privado, Rust permite a los usuarios declarar un elemento como visible dentro de un alcance determinado. Las reglas para las restricciones de &lt;code&gt;pub&lt;/code&gt; son las siguientes:</target>
        </trans-unit>
        <trans-unit id="3a4fd8d0332edcf68d5aa98b13a167d67e20f89e" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;#implementors&quot;&gt;implementors listed below&lt;/a&gt;, the following types also implement &lt;code&gt;Clone&lt;/code&gt;:</source>
          <target state="translated">Adem&amp;aacute;s de los &lt;a href=&quot;#implementors&quot;&gt;implementadores que se enumeran a continuaci&amp;oacute;n&lt;/a&gt; , los siguientes tipos tambi&amp;eacute;n implementan &lt;code&gt;Clone&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ace5e2ba5f74b469af0997ea9c80ff822efcee75" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;#implementors&quot;&gt;implementors listed below&lt;/a&gt;, the following types also implement &lt;code&gt;Copy&lt;/code&gt;:</source>
          <target state="translated">Adem&amp;aacute;s de los &lt;a href=&quot;#implementors&quot;&gt;implementadores que se enumeran a continuaci&amp;oacute;n&lt;/a&gt; , los siguientes tipos tambi&amp;eacute;n implementan &lt;code&gt;Copy&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2b65cf249390a35c8db24cb36bc73dc17e310a62" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;#[cfg]&lt;/code&gt; attribute, this macro is provided to allow boolean expression evaluation of configuration flags. This frequently leads to less duplicated code.</source>
          <target state="translated">Adem&amp;aacute;s del atributo &lt;code&gt;#[cfg]&lt;/code&gt; , esta macro se proporciona para permitir la evaluaci&amp;oacute;n de expresiones booleanas de los indicadores de configuraci&amp;oacute;n. Con frecuencia, esto conduce a un c&amp;oacute;digo menos duplicado.</target>
        </trans-unit>
        <trans-unit id="9928bdeaf0664bcb4ac6ed66b9b662d8e9fba451" translate="yes" xml:space="preserve">
          <source>In addition to the parsed &lt;a href=&quot;enum.prefix&quot;&gt;&lt;code&gt;Prefix&lt;/code&gt;&lt;/a&gt; information returned by &lt;a href=&quot;#method.kind&quot;&gt;&lt;code&gt;kind&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;PrefixComponent&lt;/code&gt; also holds the raw and unparsed &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; slice, returned by &lt;a href=&quot;#method.as_os_str&quot;&gt;&lt;code&gt;as_os_str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Adem&amp;aacute;s de la informaci&amp;oacute;n de &lt;a href=&quot;enum.prefix&quot;&gt; &lt;code&gt;Prefix&lt;/code&gt; &lt;/a&gt; analizada devuelta por &lt;a href=&quot;#method.kind&quot;&gt; &lt;code&gt;kind&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;PrefixComponent&lt;/code&gt; tambi&amp;eacute;n contiene el segmento &lt;a href=&quot;../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; sin&lt;/a&gt; analizar y sin analizar , devuelto por &lt;a href=&quot;#method.as_os_str&quot;&gt; &lt;code&gt;as_os_str&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5eb0888677903038da8d3a6a5332c2add97dc4d4" translate="yes" xml:space="preserve">
          <source>In addition to the parsed &lt;a href=&quot;enum.prefix&quot;&gt;&lt;code&gt;Prefix&lt;/code&gt;&lt;/a&gt; information returned by &lt;a href=&quot;struct.prefixcomponent#method.kind&quot;&gt;&lt;code&gt;kind&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;PrefixComponent&lt;/code&gt; also holds the raw and unparsed &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; slice, returned by &lt;a href=&quot;struct.prefixcomponent#method.as_os_str&quot;&gt;&lt;code&gt;as_os_str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0480691b89aace6e481aff35265293b818ddc02e" translate="yes" xml:space="preserve">
          <source>In addition to varying based on their signature, function pointers come in two flavors: safe and unsafe. Plain &lt;code&gt;fn()&lt;/code&gt; function pointers can only point to safe functions, while &lt;code&gt;unsafe fn()&lt;/code&gt; function pointers can point to safe or unsafe functions.</source>
          <target state="translated">Adem&amp;aacute;s de variar en funci&amp;oacute;n de su firma, los indicadores de funci&amp;oacute;n vienen en dos sabores: seguros e inseguros. Los punteros de funci&amp;oacute;n &lt;code&gt;fn()&lt;/code&gt; simples solo pueden apuntar a funciones seguras, mientras que los punteros de funci&amp;oacute;n &lt;code&gt;unsafe fn()&lt;/code&gt; pueden apuntar a funciones seguras o no seguras.</target>
        </trans-unit>
        <trans-unit id="63d3d13a6b16bc95491afdee798f040bc422692b" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;unsafe&lt;/code&gt; does not mean the code inside the block is necessarily dangerous or that it will definitely have memory safety problems: the intent is that as the programmer, you&amp;rsquo;ll ensure the code inside an &lt;code&gt;unsafe&lt;/code&gt; block will access memory in a valid way.</source>
          <target state="translated">Adem&amp;aacute;s, &lt;code&gt;unsafe&lt;/code&gt; no significa que el c&amp;oacute;digo dentro del bloque sea necesariamente peligroso o que definitivamente tendr&amp;aacute; problemas de seguridad de la memoria: la intenci&amp;oacute;n es que, como programador, se asegure de que el c&amp;oacute;digo dentro de un bloque &lt;code&gt;unsafe&lt;/code&gt; acceda a la memoria de manera v&amp;aacute;lida. .</target>
        </trans-unit>
        <trans-unit id="2b037e46e14761e122095139862caa141b1230d1" translate="yes" xml:space="preserve">
          <source>In addition, function pointers of &lt;em&gt;any&lt;/em&gt; signature, ABI, or safety are &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, and all &lt;em&gt;safe&lt;/em&gt; function pointers implement &lt;a href=&quot;ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;ops/trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt;. This works because these traits are specially known to the compiler.</source>
          <target state="translated">Adem&amp;aacute;s, los punteros de funci&amp;oacute;n de &lt;em&gt;cualquier&lt;/em&gt; firma, ABI o seguridad son &lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; , y todos &lt;em&gt;los&lt;/em&gt; punteros de funci&amp;oacute;n &lt;em&gt;segura&lt;/em&gt; implementan &lt;a href=&quot;ops/trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;ops/trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;ops/trait.fnonce&quot;&gt; &lt;code&gt;FnOnce&lt;/code&gt; &lt;/a&gt; . Esto funciona porque el compilador conoce especialmente estos rasgos.</target>
        </trans-unit>
        <trans-unit id="136cc8b49dd7ef1ec81fe965f37fef063a4440bd" translate="yes" xml:space="preserve">
          <source>In addition, there&amp;rsquo;s a design choice that&amp;rsquo;s implied by this: Rust will never automatically create &amp;ldquo;deep&amp;rdquo; copies of your data. Therefore, any &lt;em&gt;automatic&lt;/em&gt; copying can be assumed to be inexpensive in terms of runtime performance.</source>
          <target state="translated">Adem&amp;aacute;s, hay una opci&amp;oacute;n de dise&amp;ntilde;o impl&amp;iacute;cita en esto: Rust nunca crear&amp;aacute; autom&amp;aacute;ticamente copias &quot;profundas&quot; de sus datos. Por lo tanto, se puede suponer que cualquier copia &lt;em&gt;autom&amp;aacute;tica&lt;/em&gt; es econ&amp;oacute;mica en t&amp;eacute;rminos de rendimiento en tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="3ea562ca4457a0f2edce71b5e5d5d3d508efc799" translate="yes" xml:space="preserve">
          <source>In addition, we&amp;rsquo;ll cover the &lt;em&gt;interior mutability&lt;/em&gt; pattern where an immutable type exposes an API for mutating an interior value. We&amp;rsquo;ll also discuss &lt;em&gt;reference cycles&lt;/em&gt;: how they can leak memory and how to prevent them.</source>
          <target state="translated">Adem&amp;aacute;s, cubriremos el patr&amp;oacute;n de &lt;em&gt;mutabilidad interior&lt;/em&gt; donde un tipo inmutable expone una API para mutar un valor interior. Tambi&amp;eacute;n discutiremos los &lt;em&gt;ciclos de referencia&lt;/em&gt; : c&amp;oacute;mo pueden perder memoria y c&amp;oacute;mo prevenirlos.</target>
        </trans-unit>
        <trans-unit id="665a1277188bff1c69c683d1be5f9fbcfa42875d" translate="yes" xml:space="preserve">
          <source>In all other cases (if either &lt;code&gt;setting_value&lt;/code&gt; or &lt;code&gt;new_setting_value&lt;/code&gt; are &lt;code&gt;None&lt;/code&gt;) expressed by the &lt;code&gt;_&lt;/code&gt; pattern in the second arm, we want to allow &lt;code&gt;new_setting_value&lt;/code&gt; to become &lt;code&gt;setting_value&lt;/code&gt;.</source>
          <target state="translated">En todos los dem&amp;aacute;s casos (si &lt;code&gt;setting_value&lt;/code&gt; o &lt;code&gt;new_setting_value&lt;/code&gt; son &lt;code&gt;None&lt;/code&gt; ) expresados ​​por el patr&amp;oacute;n &lt;code&gt;_&lt;/code&gt; en el segundo brazo, queremos permitir que &lt;code&gt;new_setting_value&lt;/code&gt; se convierta en &lt;code&gt;setting_value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50f872ce73ab8e1e8a7650611ee67d38d3b2ccb6" translate="yes" xml:space="preserve">
          <source>In all other cases the attributes get ignored.</source>
          <target state="translated">En todos los demás casos los atributos son ignorados.</target>
        </trans-unit>
        <trans-unit id="7d8a9a3640946afedd6187bd88567e66ef40d8ba" translate="yes" xml:space="preserve">
          <source>In all these errors, a type was expected. For example, in the first error, if we want to return the &lt;code&gt;Born&lt;/code&gt; variant from the &lt;code&gt;Dragon&lt;/code&gt; enum, we must set the function to return the enum and not its variant:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a19757cafa1e47c029cbe2ba1f57c4bdca558327" translate="yes" xml:space="preserve">
          <source>In all these errors, a type was expected. For example, in the first error, we tried to instantiate the &lt;code&gt;Mordor&lt;/code&gt; module, which is impossible. If you want to instantiate a type inside a module, you can do it as follow:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c47f29567923fe326970ee49948a1a1d55a18345" translate="yes" xml:space="preserve">
          <source>In an &lt;a href=&quot;keyword.extern&quot;&gt;&lt;code&gt;extern&lt;/code&gt;&lt;/a&gt; block:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f98ac0f1fa0dec56de41fe3ea37987b03944662" translate="yes" xml:space="preserve">
          <source>In an &lt;a href=&quot;keyword.impl&quot;&gt;&lt;code&gt;impl&lt;/code&gt;&lt;/a&gt; block:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35e764e206cbb7f7f22d345fb8c210bd54217a9f" translate="yes" xml:space="preserve">
          <source>In an intrusive doubly-linked list, the collection does not actually allocate the memory for the elements itself. Allocation is controlled by the clients, and elements can live on a stack frame that lives shorter than the collection does.</source>
          <target state="translated">En una lista intrusiva de doble enlace,la colección no asigna realmente la memoria para los elementos en sí.La asignación es controlada por los clientes,y los elementos pueden vivir en un marco de pila que vive menos tiempo que la colección.</target>
        </trans-unit>
        <trans-unit id="d614cd101c88d0fcc72d7ca1ff622264cb285eeb" translate="yes" xml:space="preserve">
          <source>In bigger programs, bringing many items into scope from the same crate or module using nested paths can reduce the number of separate &lt;code&gt;use&lt;/code&gt; statements needed by a lot!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e822bbbd5e19b7e72569624aa953246414cef9f" translate="yes" xml:space="preserve">
          <source>In bigger programs, bringing many items into scope from the same package or module using nested paths can reduce the number of separate &lt;code&gt;use&lt;/code&gt; statements needed by a lot!</source>
          <target state="translated">En programas m&amp;aacute;s grandes, traer muchos elementos al alcance del mismo paquete o m&amp;oacute;dulo usando rutas anidadas puede reducir mucho la cantidad de instrucciones de &lt;code&gt;use&lt;/code&gt; separadas necesarias.</target>
        </trans-unit>
        <trans-unit id="411e743273ff9b097675015034e11f98bb60f0a1" translate="yes" xml:space="preserve">
          <source>In both cases, we're declaring a variable (called &lt;code&gt;_&lt;/code&gt;) and we're giving it a type. However, &lt;code&gt;&amp;lt;u8 as Rick&amp;gt;::Morty&lt;/code&gt; and &lt;code&gt;&amp;lt;u8 as Age&amp;gt;::Mythology&lt;/code&gt; aren't types, therefore the compiler throws an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9090e4aabed5325b4009a735999c912f0f910934" translate="yes" xml:space="preserve">
          <source>In both of these examples, '&amp;szlig;' takes two bytes to encode.</source>
          <target state="translated">En ambos ejemplos, '&amp;szlig;' requiere dos bytes para codificarse.</target>
        </trans-unit>
        <trans-unit id="cecc69a558cba8a6dc73cb622945faf2e5653ab1" translate="yes" xml:space="preserve">
          <source>In both of these examples, '𝕊' takes two &lt;code&gt;u16&lt;/code&gt;s to encode.</source>
          <target state="translated">En ambos ejemplos, '𝕊' necesita dos &lt;code&gt;u16&lt;/code&gt; s para codificar.</target>
        </trans-unit>
        <trans-unit id="3bd0c40bcc38a21de271423b14aaff21406fde9d" translate="yes" xml:space="preserve">
          <source>In both the matcher and the transcriber, the &lt;code&gt;$&lt;/code&gt; token is used to invoke special behaviours from the macro engine (described below in &lt;a href=&quot;#metavariables&quot;&gt;Metavariables&lt;/a&gt; and &lt;a href=&quot;#repetitions&quot;&gt;Repetitions&lt;/a&gt;). Tokens that aren't part of such an invocation are matched and transcribed literally, with one exception. The exception is that the outer delimiters for the matcher will match any pair of delimiters. Thus, for instance, the matcher &lt;code&gt;(())&lt;/code&gt; will match &lt;code&gt;{()}&lt;/code&gt; but not &lt;code&gt;{{}}&lt;/code&gt;. The character &lt;code&gt;$&lt;/code&gt; cannot be matched or transcribed literally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b2b1898136ef5633d7de6bd1a25b5873a3b910c" translate="yes" xml:space="preserve">
          <source>In both the matcher and the transcriber, the &lt;code&gt;$&lt;/code&gt; token is used to invoke special behaviours from the macro engine (described below in &lt;a href=&quot;macros-by-example#metavariables&quot;&gt;Metavariables&lt;/a&gt; and &lt;a href=&quot;macros-by-example#repetitions&quot;&gt;Repetitions&lt;/a&gt;). Tokens that aren't part of such an invocation are matched and transcribed literally, with one exception. The exception is that the outer delimiters for the matcher will match any pair of delimiters. Thus, for instance, the matcher &lt;code&gt;(())&lt;/code&gt; will match &lt;code&gt;{()}&lt;/code&gt; but not &lt;code&gt;{{}}&lt;/code&gt;. The character &lt;code&gt;$&lt;/code&gt; cannot be matched or transcribed literally.</source>
          <target state="translated">Tanto en el comparador como en el transcriptor, el token &lt;code&gt;$&lt;/code&gt; se usa para invocar comportamientos especiales del motor de macros (que se describe a continuaci&amp;oacute;n en &lt;a href=&quot;macros-by-example#metavariables&quot;&gt;Metavariables&lt;/a&gt; y &lt;a href=&quot;macros-by-example#repetitions&quot;&gt;repeticiones&lt;/a&gt; ). Los tokens que no forman parte de dicha invocaci&amp;oacute;n se combinan y transcriben literalmente, con una excepci&amp;oacute;n. La excepci&amp;oacute;n es que los delimitadores externos del comparador coincidir&amp;aacute;n con cualquier par de delimitadores. As&amp;iacute;, por ejemplo, el comparador &lt;code&gt;(())&lt;/code&gt; coincidir&amp;aacute; con &lt;code&gt;{()}&lt;/code&gt; pero no con &lt;code&gt;{{}}&lt;/code&gt; . El car&amp;aacute;cter &lt;code&gt;$&lt;/code&gt; no se puede emparejar ni transcribir literalmente.</target>
        </trans-unit>
        <trans-unit id="6fa90f15a6602bac9e50b98bba1b4d2d430ba8af" translate="yes" xml:space="preserve">
          <source>In both the matcher and transcriber, repetitions are indicated by placing the tokens to be repeated inside &lt;code&gt;$(&lt;/code&gt;&amp;hellip;&lt;code&gt;)&lt;/code&gt;, followed by a repetition operator, optionally with a separator token between. The separator token can be any token other than a delimiter or one of the repetition operators, but &lt;code&gt;;&lt;/code&gt; and &lt;code&gt;,&lt;/code&gt; are the most common. For instance, &lt;code&gt;$( $i:ident ),*&lt;/code&gt; represents any number of identifiers separated by commas. Nested repetitions are permitted.</source>
          <target state="translated">Tanto en el comparador como en el transcriptor, las repeticiones se indican colocando las fichas que se repetir&amp;aacute;n dentro de &lt;code&gt;$(&lt;/code&gt; &amp;hellip; &lt;code&gt;)&lt;/code&gt; , seguido de un operador de repetici&amp;oacute;n, opcionalmente con un token de separaci&amp;oacute;n entre ellos. El s&amp;iacute;mbolo del separador puede ser cualquier s&amp;iacute;mbolo que no sea un delimitador o uno de los operadores de repetici&amp;oacute;n, pero &lt;code&gt;;&lt;/code&gt; y &lt;code&gt;,&lt;/code&gt; son los m&amp;aacute;s comunes. Por ejemplo, &lt;code&gt;$( $i:ident ),*&lt;/code&gt; representa cualquier n&amp;uacute;mero de identificadores separados por comas. Se permiten repeticiones anidadas.</target>
        </trans-unit>
        <trans-unit id="bda412bf4ac443ace6b933eedb9b5ef6ed17c2eb" translate="yes" xml:space="preserve">
          <source>In case &lt;code&gt;self&lt;/code&gt; is a (fat) pointer to an unsized type, this operation will only affect the pointer part, whereas for (thin) pointers to sized types, this has the same effect as a simple assignment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13a4f6c5542d522a1d64efb05e7cb21f75cdc110" translate="yes" xml:space="preserve">
          <source>In case of the &lt;code&gt;Err&lt;/code&gt; variant, it retrieves the inner error. &lt;code&gt;try!&lt;/code&gt; then performs conversion using &lt;code&gt;From&lt;/code&gt;. This provides automatic conversion between specialized errors and more general ones. The resulting error is then immediately returned.</source>
          <target state="translated">En el caso de la variante &lt;code&gt;Err&lt;/code&gt; , recupera el error interno. &lt;code&gt;try!&lt;/code&gt; luego realiza la conversi&amp;oacute;n usando &lt;code&gt;From&lt;/code&gt; . Esto proporciona conversi&amp;oacute;n autom&amp;aacute;tica entre errores especializados y errores m&amp;aacute;s generales. El error resultante se devuelve inmediatamente.</target>
        </trans-unit>
        <trans-unit id="941cab2e6d7a9cf7c0181840706fdb117ee2d348" translate="yes" xml:space="preserve">
          <source>In case the item is a function inside an &lt;code&gt;impl&lt;/code&gt;, defining a private helper function might be easier:</source>
          <target state="translated">En caso de que el elemento sea una funci&amp;oacute;n dentro de un &lt;code&gt;impl&lt;/code&gt; , definir una funci&amp;oacute;n auxiliar privada podr&amp;iacute;a ser m&amp;aacute;s f&amp;aacute;cil:</target>
        </trans-unit>
        <trans-unit id="e819f47e8194440086ecc95f22e7c6f58bfe9e72" translate="yes" xml:space="preserve">
          <source>In case you want to document the item following the doc comment, you might want to use outer doc comment:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b1af6acd0d5d83e834a292ebeca257005964bbd" translate="yes" xml:space="preserve">
          <source>In cases where there are many nested modules, re-exporting the types at the top level with &lt;code&gt;pub use&lt;/code&gt; can make a significant difference in the experience of people who use the crate.</source>
          <target state="translated">En los casos en los que hay muchos m&amp;oacute;dulos anidados, la reexportaci&amp;oacute;n de los tipos en el nivel superior con &lt;code&gt;pub use&lt;/code&gt; puede marcar una diferencia significativa en la experiencia de las personas que usan la caja.</target>
        </trans-unit>
        <trans-unit id="bf128a40829b30190a1501e6919bf7db04f1c0f1" translate="yes" xml:space="preserve">
          <source>In certain cases Rust doesn't have enough information to make this conversion, known as &lt;a href=&quot;../ops/trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; coercion. In the following example a string slice &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;'a str&lt;/code&gt;&lt;/a&gt; implements the trait &lt;code&gt;TraitExample&lt;/code&gt;, and the function &lt;code&gt;example_func&lt;/code&gt; takes anything that implements the trait. In this case Rust would need to make two implicit conversions, which Rust doesn't have the means to do. For that reason, the following example will not compile.</source>
          <target state="translated">En ciertos casos, Rust no tiene suficiente informaci&amp;oacute;n para realizar esta conversi&amp;oacute;n, conocida como coerci&amp;oacute;n de &lt;a href=&quot;../ops/trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt; . En el siguiente ejemplo, un segmento de cadena &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;'a str&lt;/code&gt; &lt;/a&gt; implementa el rasgo &lt;code&gt;TraitExample&lt;/code&gt; , y la funci&amp;oacute;n &lt;code&gt;example_func&lt;/code&gt; toma cualquier cosa que implemente el rasgo. En este caso, Rust necesitar&amp;iacute;a realizar dos conversiones impl&amp;iacute;citas, lo que Rust no tiene los medios para hacer. Por esa raz&amp;oacute;n, el siguiente ejemplo no se compilar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="05789113cec31f9ba27c211f5de8eaee1029d96b" translate="yes" xml:space="preserve">
          <source>In certain cases it is possible for sub-bindings to violate memory safety. Updates to the borrow checker in a future version of Rust may remove this restriction, but for now patterns must be rewritten without sub-bindings.</source>
          <target state="translated">En ciertos casos es posible que los subenclaves violen la seguridad de la memoria.Las actualizaciones del verificador de préstamos en una futura versión de Rust pueden eliminar esta restricción,pero por ahora los patrones deben ser reescritos sin subencuadernaciones.</target>
        </trans-unit>
        <trans-unit id="d394f1aae10ef8b092ba2c671f6d9b214faf89ad" translate="yes" xml:space="preserve">
          <source>In comparison, a &lt;a href=&quot;struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt; does not distinguish between readers or writers that acquire the lock, therefore blocking any threads waiting for the lock to become available. An &lt;code&gt;RwLock&lt;/code&gt; will allow any number of readers to acquire the lock as long as a writer is not holding the lock.</source>
          <target state="translated">En comparaci&amp;oacute;n, un &lt;a href=&quot;struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; &lt;/a&gt; no distingue entre lectores o escritores que adquieren el bloqueo, por lo que bloquea los hilos que esperan que el bloqueo est&amp;eacute; disponible. Un &lt;code&gt;RwLock&lt;/code&gt; permitir&amp;aacute; que cualquier n&amp;uacute;mero de lectores adquiera el bloqueo siempre y cuando un escritor no lo mantenga presionado.</target>
        </trans-unit>
        <trans-unit id="c115328cd5dddf39c58dad4ab7eb1715dbdfb6a2" translate="yes" xml:space="preserve">
          <source>In conclusion: always check if the index you want to get really exists before doing it.</source>
          <target state="translated">En conclusión:siempre comprueba si el índice que quieres obtener existe realmente antes de hacerlo.</target>
        </trans-unit>
        <trans-unit id="bc5067b36d2a80d931bdadd8da0d1762cb0d699b" translate="yes" xml:space="preserve">
          <source>In contrast, if we make an enum public, all of its variants are then public. We only need the &lt;code&gt;pub&lt;/code&gt; before the &lt;code&gt;enum&lt;/code&gt; keyword, as shown in Listing 7-10.</source>
          <target state="translated">Por el contrario, si hacemos p&amp;uacute;blica una enumeraci&amp;oacute;n, todas sus variantes son p&amp;uacute;blicas. Solo necesitamos el &lt;code&gt;pub&lt;/code&gt; antes del &lt;code&gt;enum&lt;/code&gt; palabra clave enum , como se muestra en el Listado 7-10.</target>
        </trans-unit>
        <trans-unit id="eef3a39c643559e323c1398fc6cc1dee8d7cdd7b" translate="yes" xml:space="preserve">
          <source>In contrast, statements in Rust serve &lt;em&gt;mostly&lt;/em&gt; to contain and explicitly sequence expression evaluation.</source>
          <target state="translated">Por el contrario, las declaraciones en Rust sirven &lt;em&gt; principalmente&lt;/em&gt; para contener y secuenciar expl&amp;iacute;citamente la evaluaci&amp;oacute;n de expresiones.</target>
        </trans-unit>
        <trans-unit id="ff04b6c4317002c1756854a2d669fb7993a6fc92" translate="yes" xml:space="preserve">
          <source>In contrast, the use of &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; in Listing 19-7 would likely crash when the slice is used. This code takes an arbitrary memory location and creates a slice 10,000 items long.</source>
          <target state="translated">Por el contrario, el uso de &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; en el Listado 19-7 probablemente fallar&amp;iacute;a cuando se usara la porci&amp;oacute;n. Este c&amp;oacute;digo toma una ubicaci&amp;oacute;n de memoria arbitraria y crea un segmento de 10,000 elementos de largo.</target>
        </trans-unit>
        <trans-unit id="b352fcdc1230066708e3119b26e7a9dddf361692" translate="yes" xml:space="preserve">
          <source>In each such case, there are a set of types &lt;code&gt;T0..Tn&lt;/code&gt; to be mutually coerced to some target type &lt;code&gt;T_t&lt;/code&gt;, which is unknown to start. Computing the LUB coercion is done iteratively. The target type &lt;code&gt;T_t&lt;/code&gt; begins as the type &lt;code&gt;T0&lt;/code&gt;. For each new type &lt;code&gt;Ti&lt;/code&gt;, we consider whether</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="759bae86a2327a6965c49083e94e3f6d305cc988" translate="yes" xml:space="preserve">
          <source>In either of the two scenarios above, we reject usage of such a constant in a pattern match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06e667f68e56d5242973de51944bcdddd7e82fb4" translate="yes" xml:space="preserve">
          <source>In essence, &lt;code&gt;*const c_void&lt;/code&gt; is equivalent to C's &lt;code&gt;const void*&lt;/code&gt; and &lt;code&gt;*mut c_void&lt;/code&gt; is equivalent to C's &lt;code&gt;void*&lt;/code&gt;. That said, this is &lt;em&gt;not&lt;/em&gt; the same as C's &lt;code&gt;void&lt;/code&gt; return type, which is Rust's &lt;code&gt;()&lt;/code&gt; type.</source>
          <target state="translated">En esencia, &lt;code&gt;*const c_void&lt;/code&gt; es equivalente al &lt;code&gt;const void*&lt;/code&gt; de C y &lt;code&gt;*mut c_void&lt;/code&gt; es equivalente al &lt;code&gt;void*&lt;/code&gt; de C * . Dicho esto, &lt;em&gt;no&lt;/em&gt; es &lt;em&gt;lo&lt;/em&gt; mismo que el tipo de retorno &lt;code&gt;void&lt;/code&gt; de C , que es el tipo de Rust &lt;code&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0739de72e1deacfa1d546c048ef9f93475a4ab03" translate="yes" xml:space="preserve">
          <source>In function signatures, you &lt;em&gt;must&lt;/em&gt; declare the type of each parameter. This is a deliberate decision in Rust&amp;rsquo;s design: requiring type annotations in function definitions means the compiler almost never needs you to use them elsewhere in the code to figure out what you mean.</source>
          <target state="translated">En firmas de funciones, &lt;em&gt; debe&lt;/em&gt; declarar el tipo de cada par&amp;aacute;metro. Esta es una decisi&amp;oacute;n deliberada en el dise&amp;ntilde;o de Rust: requerir anotaciones de tipo en las definiciones de funciones significa que el compilador casi nunca necesita que las use en otra parte del c&amp;oacute;digo para averiguar lo que quiere decir.</target>
        </trans-unit>
        <trans-unit id="a163a5fc2f2f3cf5125dad843b5d152fd8d96ed5" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;--crate-type=bin&lt;/code&gt; or &lt;code&gt;--crate-type=lib&lt;/code&gt; should be sufficient for all compilation needs, and the other options are just available if more fine-grained control is desired over the output format of a crate.</source>
          <target state="translated">En general, &lt;code&gt;--crate-type=bin&lt;/code&gt; o &lt;code&gt;--crate-type=lib&lt;/code&gt; deber&amp;iacute;a ser suficiente para todas las necesidades de compilaci&amp;oacute;n, y las otras opciones solo est&amp;aacute;n disponibles si se desea un control m&amp;aacute;s detallado sobre el formato de salida de una caja.</target>
        </trans-unit>
        <trans-unit id="7777bf666faebd9aefa18991fe8e03e45c4f9bd4" translate="yes" xml:space="preserve">
          <source>In general, C++ implementations obey the zero-overhead principle: What you don&amp;rsquo;t use, you don&amp;rsquo;t pay for. And further: What you do use, you couldn&amp;rsquo;t hand code any better.</source>
          <target state="translated">En general, las implementaciones de C ++ obedecen al principio de cero gastos generales: lo que no usa, no paga. Y m&amp;aacute;s: lo que usas, no podr&amp;iacute;as codificar mejor.</target>
        </trans-unit>
        <trans-unit id="3a3df1206a7a0ce3ee2a987af627c57e92761a96" translate="yes" xml:space="preserve">
          <source>In general, any cast that can be performed via ascribing the type can also be done using &lt;code&gt;as&lt;/code&gt;, so instead of writing &lt;code&gt;let x: u32 = 123&lt;/code&gt;, you can write &lt;code&gt;let x = 123 as u32&lt;/code&gt; (Note: &lt;code&gt;let x: u32 = 123&lt;/code&gt; would be best in that situation). The same is not true in the other direction, however, explicitly using &lt;code&gt;as&lt;/code&gt; allows a few more coercions that aren't allowed implicitly, such as changing the type of a raw pointer or turning closures into raw pointers.</source>
          <target state="translated">En general, cualquier lanzamiento que se pueda realizar mediante la atribuci&amp;oacute;n del tipo tambi&amp;eacute;n se puede hacer usando &lt;code&gt;as&lt;/code&gt; , por lo que en lugar de escribir &lt;code&gt;let x: u32 = 123&lt;/code&gt; , puede escribir &lt;code&gt;let x = 123 as u32&lt;/code&gt; (Nota: &lt;code&gt;let x: u32 = 123&lt;/code&gt; ser&amp;iacute;a ser el mejor en esa situaci&amp;oacute;n). Lo mismo no es cierto en la otra direcci&amp;oacute;n, sin embargo, usando expl&amp;iacute;citamente &lt;code&gt;as&lt;/code&gt; permite algunas coacciones m&amp;aacute;s que no se permiten impl&amp;iacute;citamente, como cambiar el tipo de un puntero sin formato o convertir cierres en punteros sin formato.</target>
        </trans-unit>
        <trans-unit id="3ee5af53911e508508beef41bbd5529b831af173" translate="yes" xml:space="preserve">
          <source>In general, any cast that can be performed via ascribing the type can also be done using &lt;code&gt;as&lt;/code&gt;, so instead of writing &lt;code&gt;let x: u32 = 123&lt;/code&gt;, you can write &lt;code&gt;let x = 123 as u32&lt;/code&gt; (note: &lt;code&gt;let x: u32 = 123&lt;/code&gt; would be best in that situation). The same is not true in the other direction, however; explicitly using &lt;code&gt;as&lt;/code&gt; allows a few more coercions that aren't allowed implicitly, such as changing the type of a raw pointer or turning closures into raw pointers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5001dd632e7b54d8c780b39311ea5efcf079833" translate="yes" xml:space="preserve">
          <source>In general, because this function may panic, its use is discouraged. Instead, prefer to use pattern matching and handle the &lt;a href=&quot;#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; case explicitly.</source>
          <target state="translated">En general, debido a que esta funci&amp;oacute;n puede entrar en p&amp;aacute;nico, se desaconseja su uso. En su lugar, prefiera utilizar la coincidencia de patrones y manejar &lt;a href=&quot;#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; caso expl&amp;iacute;citamente.</target>
        </trans-unit>
        <trans-unit id="0358df2536c58bf0115d699da84271da00e22fdc" translate="yes" xml:space="preserve">
          <source>In general, fully qualified syntax is defined as follows:</source>
          <target state="translated">En general,la sintaxis plenamente cualificada se define de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="7487c2808663723e7c1f944b2e8eea78a2788483" translate="yes" xml:space="preserve">
          <source>In general, in order to use an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; value, you want to have code that will handle each variant. You want some code that will run only when you have a &lt;code&gt;Some(T)&lt;/code&gt; value, and this code is allowed to use the inner &lt;code&gt;T&lt;/code&gt;. You want some other code to run if you have a &lt;code&gt;None&lt;/code&gt; value, and that code doesn&amp;rsquo;t have a &lt;code&gt;T&lt;/code&gt; value available. The &lt;code&gt;match&lt;/code&gt; expression is a control flow construct that does just this when used with enums: it will run different code depending on which variant of the enum it has, and that code can use the data inside the matching value.</source>
          <target state="translated">En general, para usar un valor &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; , desea tener un c&amp;oacute;digo que maneje cada variante. Desea alg&amp;uacute;n c&amp;oacute;digo que se ejecute solo cuando tenga un valor &lt;code&gt;Some(T)&lt;/code&gt; , y este c&amp;oacute;digo puede usar la &lt;code&gt;T&lt;/code&gt; interna . Desea que se ejecute alg&amp;uacute;n otro c&amp;oacute;digo si tiene un valor &lt;code&gt;None&lt;/code&gt; y ese c&amp;oacute;digo no tiene un valor &lt;code&gt;T&lt;/code&gt; disponible. El &lt;code&gt;match&lt;/code&gt; expresi&amp;oacute;n de es una construcci&amp;oacute;n de flujo de control que hace exactamente esto cuando se usa con enumeraciones: ejecutar&amp;aacute; c&amp;oacute;digo diferente seg&amp;uacute;n la variante de la enumeraci&amp;oacute;n que tenga, y ese c&amp;oacute;digo puede usar los datos dentro del valor coincidente.</target>
        </trans-unit>
        <trans-unit id="fe5910a656bafc28cb04b104db1abacc502046d7" translate="yes" xml:space="preserve">
          <source>In general, the size of a type is not stable across compilations, but specific types such as primitives are.</source>
          <target state="translated">En general,el tamaño de un tipo no es estable en todas las compilaciones,pero los tipos específicos como los primitivos sí lo son.</target>
        </trans-unit>
        <trans-unit id="9278a820cf286fae1a78be16430b1781c0f65837" translate="yes" xml:space="preserve">
          <source>In general, this book assumes that you&amp;rsquo;re reading it in sequence from front to back. Later chapters build on concepts in earlier chapters, and earlier chapters might not delve into details on a topic; we typically revisit the topic in a later chapter.</source>
          <target state="translated">En general, este libro asume que lo est&amp;aacute; leyendo en secuencia de adelante hacia atr&amp;aacute;s. Los cap&amp;iacute;tulos posteriores se basan en conceptos de cap&amp;iacute;tulos anteriores, y es posible que los cap&amp;iacute;tulos anteriores no profundicen en los detalles de un tema; normalmente revisamos el tema en un cap&amp;iacute;tulo posterior.</target>
        </trans-unit>
        <trans-unit id="977ea6d6c942b4c170b22ed11bf03379c02b9dfe" translate="yes" xml:space="preserve">
          <source>In general, you shouldn&amp;rsquo;t have to worry about the distinction between refutable and irrefutable patterns; however, you do need to be familiar with the concept of refutability so you can respond when you see it in an error message. In those cases, you&amp;rsquo;ll need to change either the pattern or the construct you&amp;rsquo;re using the pattern with, depending on the intended behavior of the code.</source>
          <target state="translated">En general, no deber&amp;iacute;a tener que preocuparse por la distinci&amp;oacute;n entre patrones refutables e irrefutables; sin embargo, debe estar familiarizado con el concepto de refutabilidad para poder responder cuando lo vea en un mensaje de error. En esos casos, deber&amp;aacute; cambiar el patr&amp;oacute;n o la construcci&amp;oacute;n con la que est&amp;aacute; utilizando el patr&amp;oacute;n, seg&amp;uacute;n el comportamiento previsto del c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="060df941ecb41c6d059208976354e6aeaa04999f" translate="yes" xml:space="preserve">
          <source>In here, &lt;code&gt;jon_snow&lt;/code&gt; is already borrowed by the &lt;code&gt;nights_watch&lt;/code&gt; reference, so it cannot be borrowed by the &lt;code&gt;starks&lt;/code&gt; closure at the same time. To fix this issue, you can create the closure after the borrow has ended:</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;jon_snow&lt;/code&gt; ya est&amp;aacute; prestado por la referencia &lt;code&gt;nights_watch&lt;/code&gt; , por lo que no puede ser prestado por el cierre de &lt;code&gt;starks&lt;/code&gt; al mismo tiempo. Para solucionar este problema, puede crear el cierre una vez finalizado el pr&amp;eacute;stamo:</target>
        </trans-unit>
        <trans-unit id="2eeaad023e9112af1e8f815d9f7d440dc203c89a" translate="yes" xml:space="preserve">
          <source>In here, &lt;code&gt;x&lt;/code&gt; isn't mutable, so when we try to mutably borrow it in &lt;code&gt;y&lt;/code&gt;, it fails. To fix this error, you need to make &lt;code&gt;x&lt;/code&gt; mutable:</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;x&lt;/code&gt; no es mutable, por lo que cuando intentamos tomarlo prestado de manera mutante en &lt;code&gt;y&lt;/code&gt; , falla. Para corregir este error, necesita hacer &lt;code&gt;x&lt;/code&gt; mutable:</target>
        </trans-unit>
        <trans-unit id="81d6b3668007d5f159cb30ea0bd675623ee7c869" translate="yes" xml:space="preserve">
          <source>In here, &lt;code&gt;y&lt;/code&gt; is dropped at the end of the inner scope, but it is borrowed by &lt;code&gt;x&lt;/code&gt; until the &lt;code&gt;println&lt;/code&gt;. To fix the previous example, just remove the scope so that &lt;code&gt;y&lt;/code&gt; isn't dropped until after the println</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;y&lt;/code&gt; se coloca al final del &amp;aacute;mbito interno, pero &lt;code&gt;x&lt;/code&gt; lo toma prestado hasta que &lt;code&gt;println&lt;/code&gt; . Para corregir el ejemplo anterior, simplemente elimine el alcance para que &lt;code&gt;y&lt;/code&gt; no se elimine hasta despu&amp;eacute;s de println</target>
        </trans-unit>
        <trans-unit id="08dfb3c33a779adcd494f821429d48fd85e32c31" translate="yes" xml:space="preserve">
          <source>In his 1972 essay &amp;ldquo;The Humble Programmer,&amp;rdquo; Edsger W. Dijkstra said that &amp;ldquo;Program testing can be a very effective way to show the presence of bugs, but it is hopelessly inadequate for showing their absence.&amp;rdquo; That doesn&amp;rsquo;t mean we shouldn&amp;rsquo;t try to test as much as we can!</source>
          <target state="translated">En su ensayo de 1972 &quot;The Humble Programmer&quot;, Edsger W. Dijkstra dijo que &quot;las pruebas de programas pueden ser una forma muy eficaz de mostrar la presencia de errores, pero es desesperadamente inadecuada para mostrar su ausencia&quot;. &amp;iexcl;Eso no significa que no debamos intentar probar tanto como podamos!</target>
        </trans-unit>
        <trans-unit id="ae6d2c496cd6d4afe298d6ce8f4a6cee4e357ed4" translate="yes" xml:space="preserve">
          <source>In his 2009 presentation &amp;ldquo;Null References: The Billion Dollar Mistake,&amp;rdquo; Tony Hoare, the inventor of null, has this to say:</source>
          <target state="translated">En su presentaci&amp;oacute;n de 2009 &quot;Null References: The Billion Dollar Mistake&quot;, Tony Hoare, el inventor de null, dice lo siguiente:</target>
        </trans-unit>
        <trans-unit id="c66d30f8ac627ea5119575fc56779340f4bd49e0" translate="yes" xml:space="preserve">
          <source>In immutable contexts, &lt;code&gt;*x&lt;/code&gt; (where &lt;code&gt;T&lt;/code&gt; is neither a reference nor a raw pointer) is equivalent to &lt;code&gt;*Deref::deref(&amp;amp;x)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45d9087614e2245b4983911ff32ea54b22230bdc" translate="yes" xml:space="preserve">
          <source>In immutable contexts, &lt;code&gt;*x&lt;/code&gt; on non-pointer types is equivalent to &lt;code&gt;*Deref::deref(&amp;amp;x)&lt;/code&gt;.</source>
          <target state="translated">En contextos inmutables, &lt;code&gt;*x&lt;/code&gt; en tipos que no son punteros es equivalente a &lt;code&gt;*Deref::deref(&amp;amp;x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34a59a9afbc47f966db9cd49be041253f3860e79" translate="yes" xml:space="preserve">
          <source>In its thread, the &lt;code&gt;Worker&lt;/code&gt; will loop over its receiving side of the channel and execute the closures of any jobs it receives.</source>
          <target state="translated">En su hilo, el &lt;code&gt;Worker&lt;/code&gt; recorrer&amp;aacute; su lado receptor del canal y ejecutar&amp;aacute; los cierres de cualquier trabajo que reciba.</target>
        </trans-unit>
        <trans-unit id="942b73624a3734e7f84234cddf5d7ae090876792" translate="yes" xml:space="preserve">
          <source>In languages that don&amp;rsquo;t have iterators provided by their standard libraries, you would likely write this same functionality by starting a variable at index 0, using that variable to index into the vector to get a value, and incrementing the variable value in a loop until it reached the total number of items in the vector.</source>
          <target state="translated">En los lenguajes que no tienen iteradores proporcionados por sus bibliotecas est&amp;aacute;ndar, probablemente escribir&amp;iacute;a esta misma funcionalidad comenzando una variable en el &amp;iacute;ndice 0, usando esa variable para indexar en el vector para obtener un valor e incrementando el valor de la variable en un ciclo hasta alcanzar el n&amp;uacute;mero total de elementos del vector.</target>
        </trans-unit>
        <trans-unit id="148bb2115d5f741226fa757de3c9723acba277f4" translate="yes" xml:space="preserve">
          <source>In languages with pointers, it&amp;rsquo;s easy to erroneously create a &lt;em&gt;dangling pointer&lt;/em&gt;, a pointer that references a location in memory that may have been given to someone else, by freeing some memory while preserving a pointer to that memory. In Rust, by contrast, the compiler guarantees that references will never be dangling references: if you have a reference to some data, the compiler will ensure that the data will not go out of scope before the reference to the data does.</source>
          <target state="translated">En lenguajes con punteros, es f&amp;aacute;cil crear err&amp;oacute;neamente un &lt;em&gt;puntero colgante&lt;/em&gt; , un puntero que hace referencia a una ubicaci&amp;oacute;n en la memoria que se le puede haber dado a otra persona, liberando algo de memoria mientras se conserva un puntero a esa memoria. En Rust, por el contrario, el compilador garantiza que las referencias nunca ser&amp;aacute;n referencias colgantes: si tiene una referencia a algunos datos, el compilador se asegurar&amp;aacute; de que los datos no se salgan del alcance antes de que lo haga la referencia a los datos.</target>
        </trans-unit>
        <trans-unit id="c69f662a72816b0c83c46e48583efed26b50f091" translate="yes" xml:space="preserve">
          <source>In many other programming languages, accessing individual characters in a string by referencing them by index is a valid and common operation. However, if you try to access parts of a &lt;code&gt;String&lt;/code&gt; using indexing syntax in Rust, you&amp;rsquo;ll get an error. Consider the invalid code in Listing 8-19.</source>
          <target state="translated">En muchos otros lenguajes de programaci&amp;oacute;n, acceder a caracteres individuales en una cadena haciendo referencia a ellos por &amp;iacute;ndice es una operaci&amp;oacute;n v&amp;aacute;lida y com&amp;uacute;n. Sin embargo, si intenta acceder a partes de una &lt;code&gt;String&lt;/code&gt; utilizando la sintaxis de indexaci&amp;oacute;n en Rust, obtendr&amp;aacute; un error. Considere el c&amp;oacute;digo no v&amp;aacute;lido del Listado 8-19.</target>
        </trans-unit>
        <trans-unit id="53fc7ae898feca654262cacac0837b1725d55798" translate="yes" xml:space="preserve">
          <source>In many programming languages, you don&amp;rsquo;t have to think about the stack and the heap very often. But in a systems programming language like Rust, whether a value is on the stack or the heap has more of an effect on how the language behaves and why you have to make certain decisions. Parts of ownership will be described in relation to the stack and the heap later in this chapter, so here is a brief explanation in preparation.</source>
          <target state="translated">En muchos lenguajes de programaci&amp;oacute;n, no es necesario pensar en la pila y el mont&amp;oacute;n con mucha frecuencia. Pero en un lenguaje de programaci&amp;oacute;n de sistemas como Rust, el hecho de que un valor est&amp;eacute; en la pila o en el mont&amp;oacute;n tiene m&amp;aacute;s efecto sobre c&amp;oacute;mo se comporta el lenguaje y por qu&amp;eacute; tiene que tomar ciertas decisiones. Las partes de la propiedad se describir&amp;aacute;n en relaci&amp;oacute;n con la pila y el mont&amp;oacute;n m&amp;aacute;s adelante en este cap&amp;iacute;tulo, por lo que aqu&amp;iacute; hay una breve explicaci&amp;oacute;n en preparaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a71b0804f74afde789f1f323a88f714aecff2fd9" translate="yes" xml:space="preserve">
          <source>In method signatures inside the &lt;code&gt;impl&lt;/code&gt; block, references might be tied to the lifetime of references in the struct&amp;rsquo;s fields, or they might be independent. In addition, the lifetime elision rules often make it so that lifetime annotations aren&amp;rsquo;t necessary in method signatures. Let&amp;rsquo;s look at some examples using the struct named &lt;code&gt;ImportantExcerpt&lt;/code&gt; that we defined in Listing 10-25.</source>
          <target state="translated">En las firmas de m&amp;eacute;todos dentro del bloque &lt;code&gt;impl&lt;/code&gt; , las referencias pueden estar vinculadas a la vida &amp;uacute;til de las referencias en los campos de la estructura, o pueden ser independientes. Adem&amp;aacute;s, las reglas de elisi&amp;oacute;n de por vida a menudo hacen que las anotaciones de por vida no sean necesarias en las firmas de m&amp;eacute;todos. Veamos algunos ejemplos usando la estructura llamada &lt;code&gt;ImportantExcerpt&lt;/code&gt; que definimos en el Listado 10-25.</target>
        </trans-unit>
        <trans-unit id="56b091fc8b5e112138b2d81b03cef11eb14a4977" translate="yes" xml:space="preserve">
          <source>In method signatures there is another rule</source>
          <target state="translated">En las firmas de métodos hay otra regla</target>
        </trans-unit>
        <trans-unit id="4f7f26526673f7e0758f04fd37bb64448ac73dee" translate="yes" xml:space="preserve">
          <source>In more realistic code, Rust can often infer the type of value you want to store once you insert values, so you rarely need to do this type annotation. It&amp;rsquo;s more common to create a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; that has initial values, and Rust provides the &lt;code&gt;vec!&lt;/code&gt; macro for convenience. The macro will create a new vector that holds the values you give it. Listing 8-2 creates a new &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; that holds the values &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, and &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">En un c&amp;oacute;digo m&amp;aacute;s realista, Rust a menudo puede inferir el tipo de valor que desea almacenar una vez que inserta los valores, por lo que rara vez necesita hacer este tipo de anotaci&amp;oacute;n. Es m&amp;aacute;s com&amp;uacute;n crear un &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; que tenga valores iniciales, &amp;iexcl;y Rust proporciona el &lt;code&gt;vec!&lt;/code&gt; macro por conveniencia. La macro crear&amp;aacute; un nuevo vector que contiene los valores que le des. El Listado 8-2 crea un nuevo &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; que contiene los valores &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; y &lt;code&gt;3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa2c751f0fffe581147bea700ab4a27b2b536a1b" translate="yes" xml:space="preserve">
          <source>In more realistic code, Rust can often infer the type of value you want to store once you insert values, so you rarely need to do this type annotation. It&amp;rsquo;s more common to create a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; that has initial values, and Rust provides the &lt;code&gt;vec!&lt;/code&gt; macro for convenience. The macro will create a new vector that holds the values you give it. Listing 8-2 creates a new &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; that holds the values &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, and &lt;code&gt;3&lt;/code&gt;. The integer type is &lt;code&gt;i32&lt;/code&gt; because that&amp;rsquo;s the default integer type, as we discussed in the &lt;a href=&quot;ch03-02-data-types#data-types&quot;&gt;&amp;ldquo;Data Types&amp;rdquo;&lt;/a&gt; section of Chapter 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f61ae2da01f7f174aa9072fda333fb0da9180ccf" translate="yes" xml:space="preserve">
          <source>In most cases (if not all), using just one representation hint is more than enough. If you want to have a representation hint depending on the current architecture, use &lt;code&gt;cfg_attr&lt;/code&gt;. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf5efe0547b39e89a71b61a6014e248867460fb1" translate="yes" xml:space="preserve">
          <source>In most cases when you no longer need a particular function parameter, you would change the signature so it doesn&amp;rsquo;t include the unused parameter. Ignoring a function parameter can be especially useful in some cases, for example, when implementing a trait when you need a certain type signature but the function body in your implementation doesn&amp;rsquo;t need one of the parameters. The compiler will then not warn about unused function parameters, as it would if you used a name instead.</source>
          <target state="translated">En la mayor&amp;iacute;a de los casos, cuando ya no necesita un par&amp;aacute;metro de funci&amp;oacute;n en particular, debe cambiar la firma para que no incluya el par&amp;aacute;metro no utilizado. Ignorar un par&amp;aacute;metro de funci&amp;oacute;n puede ser especialmente &amp;uacute;til en algunos casos, por ejemplo, cuando se implementa un rasgo cuando se necesita una determinada firma de tipo, pero el cuerpo de la funci&amp;oacute;n en su implementaci&amp;oacute;n no necesita uno de los par&amp;aacute;metros. El compilador no advertir&amp;aacute; sobre los par&amp;aacute;metros de funci&amp;oacute;n no utilizados, como lo har&amp;iacute;a si utilizara un nombre en su lugar.</target>
        </trans-unit>
        <trans-unit id="85959f6561074f86f5f458df7e8bde59a19923db" translate="yes" xml:space="preserve">
          <source>In most cases, it's either a forgotten import or a typo. However, let's look at how you can have such a type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26e080b759ded4bafe71b2a50d6f7fff275a8902" translate="yes" xml:space="preserve">
          <source>In most cases, references can be used much like the original value. Field access, method calling, and indexing work the same (save for mutability rules, of course). In addition, the comparison operators transparently defer to the referent's implementation, allowing references to be compared the same as owned values.</source>
          <target state="translated">En la mayoría de los casos,las referencias pueden utilizarse de manera muy similar al valor original.El acceso a los campos,la llamada a métodos y la indexación funcionan de la misma manera (salvo por las reglas de mutabilidad,por supuesto).Además,los operadores de comparación se someten con transparencia a la aplicación del referente,lo que permite que las referencias se comparen de la misma manera que los valores de propiedad.</target>
        </trans-unit>
        <trans-unit id="cb1a853128acc3d6c0a0581a5f8b082bf00d635a" translate="yes" xml:space="preserve">
          <source>In most current operating systems, an executed program&amp;rsquo;s code is run in a &lt;em&gt;process&lt;/em&gt;, and the operating system manages multiple processes at once. Within your program, you can also have independent parts that run simultaneously. The features that run these independent parts are called &lt;em&gt;threads&lt;/em&gt;.</source>
          <target state="translated">En la mayor&amp;iacute;a de los sistemas operativos actuales, el c&amp;oacute;digo de un programa ejecutado se ejecuta en un &lt;em&gt;proceso&lt;/em&gt; y el sistema operativo administra varios procesos a la vez. Dentro de su programa, tambi&amp;eacute;n puede tener partes independientes que se ejecutan simult&amp;aacute;neamente. Las funciones que ejecutan estas partes independientes se denominan &lt;em&gt;subprocesos&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="78e7514eee61487e2e785a94b5ca9176768d676e" translate="yes" xml:space="preserve">
          <source>In most situations, we&amp;rsquo;ll lead you to the correct version of any code that doesn&amp;rsquo;t compile.</source>
          <target state="translated">En la mayor&amp;iacute;a de las situaciones, lo llevaremos a la versi&amp;oacute;n correcta de cualquier c&amp;oacute;digo que no se compile.</target>
        </trans-unit>
        <trans-unit id="c68d3ee8b930a30d24c024ab8aa0750ac37303d5" translate="yes" xml:space="preserve">
          <source>In mutable contexts, &lt;code&gt;*x&lt;/code&gt; (where &lt;code&gt;T&lt;/code&gt; is neither a reference nor a raw pointer) is equivalent to &lt;code&gt;*DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b734ae92655f6d1fea340617e159a961db4d096" translate="yes" xml:space="preserve">
          <source>In mutable contexts, &lt;code&gt;*x&lt;/code&gt; on non-pointer types is equivalent to &lt;code&gt;*DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt;.</source>
          <target state="translated">En contextos mutables, &lt;code&gt;*x&lt;/code&gt; en tipos que no son punteros es equivalente a &lt;code&gt;*DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69b6246a1999e07c08f9e609157264f54e6ef863" translate="yes" xml:space="preserve">
          <source>In one session of compilation, the compiler can generate multiple artifacts through the usage of either command line flags or the &lt;code&gt;crate_type&lt;/code&gt; attribute. If one or more command line flags are specified, all &lt;code&gt;crate_type&lt;/code&gt; attributes will be ignored in favor of only building the artifacts specified by command line.</source>
          <target state="translated">En una sesi&amp;oacute;n de compilaci&amp;oacute;n, el compilador puede generar m&amp;uacute;ltiples artefactos mediante el uso de indicadores de l&amp;iacute;nea de comando o el atributo &lt;code&gt;crate_type&lt;/code&gt; . Si se especifican uno o m&amp;aacute;s indicadores de l&amp;iacute;nea de comando, todos los atributos &lt;code&gt;crate_type&lt;/code&gt; se ignorar&amp;aacute;n a favor de construir solo los artefactos especificados por la l&amp;iacute;nea de comando.</target>
        </trans-unit>
        <trans-unit id="39ef695f2f217a58a60f492df45908959e1ce256" translate="yes" xml:space="preserve">
          <source>In one way, this program is better. Tuples let us add a bit of structure, and we&amp;rsquo;re now passing just one argument. But in another way, this version is less clear: tuples don&amp;rsquo;t name their elements, so our calculation has become more confusing because we have to index into the parts of the tuple.</source>
          <target state="translated">De alguna manera, este programa es mejor. Las tuplas nos permiten agregar un poco de estructura, y ahora solo estamos pasando un argumento. Pero de otra manera, esta versi&amp;oacute;n es menos clara: las tuplas no nombran sus elementos, por lo que nuestro c&amp;aacute;lculo se ha vuelto m&amp;aacute;s confuso porque tenemos que indexar en las partes de la tupla.</target>
        </trans-unit>
        <trans-unit id="622cc33b53324bf6d0c97dce1d56dd6b2940830c" translate="yes" xml:space="preserve">
          <source>In order for a type to implement this trait, it must not only provide implementations for every method, but it must specify the type &lt;code&gt;E&lt;/code&gt;. Here's an implementation of &lt;code&gt;Container&lt;/code&gt; for the standard library type &lt;code&gt;Vec&lt;/code&gt;:</source>
          <target state="translated">Para que un tipo de implementar esta caracter&amp;iacute;stica, no s&amp;oacute;lo debe proporcionar implementaciones para cada m&amp;eacute;todo, pero debe especificar el tipo &lt;code&gt;E&lt;/code&gt; . Aqu&amp;iacute; hay una implementaci&amp;oacute;n de &lt;code&gt;Container&lt;/code&gt; para el tipo de biblioteca est&amp;aacute;ndar &lt;code&gt;Vec&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="19c7f913e08cfe33ae3164f0e143039e6e29b1bd" translate="yes" xml:space="preserve">
          <source>In order for the file to be created, &lt;a href=&quot;#method.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#method.append&quot;&gt;&lt;code&gt;append&lt;/code&gt;&lt;/a&gt; access must be used.</source>
          <target state="translated">Para que se cree el archivo, se debe utilizar el acceso de &lt;a href=&quot;#method.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;#method.append&quot;&gt; &lt;code&gt;append&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b17e4fe4c4cad25a01268fcf2e26864d2a26e310" translate="yes" xml:space="preserve">
          <source>In order for the file to be created, &lt;a href=&quot;struct.openoptions#method.write&quot;&gt;&lt;code&gt;OpenOptions::write&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.openoptions#method.append&quot;&gt;&lt;code&gt;OpenOptions::append&lt;/code&gt;&lt;/a&gt; access must be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="961d3f038f800fcb79e8e066158ebbffb2dcbb67" translate="yes" xml:space="preserve">
          <source>In order to be consistent with Rust's lack of global type inference, type and const placeholders are disallowed by design in item signatures.</source>
          <target state="translated">Para ser coherente con la falta de inferencia de tipo global de Rust,los marcadores de posición de tipo y const están desautorizados por diseño en las firmas de los artículos.</target>
        </trans-unit>
        <trans-unit id="8a65853b278eb7154e9a97a3b9168563f7fe07ac" translate="yes" xml:space="preserve">
          <source>In order to change the requirement from &lt;code&gt;'static&lt;/code&gt; to be a lifetime derived from its arguments, you can add an explicit bound, either to an anonymous lifetime &lt;code&gt;'_&lt;/code&gt; or some appropriate named lifetime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12fa624eb80e06baae2665fd37db20bf0778d0e3" translate="yes" xml:space="preserve">
          <source>In order to encode this kind of constraint, a &lt;code&gt;where&lt;/code&gt; clause and a new type parameter are needed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9667d5a282ae24dfeac4aaa28cc09c9d5311dfe4" translate="yes" xml:space="preserve">
          <source>In order to express that we want a generic function to take all arguments that can be converted to a specified type &lt;code&gt;T&lt;/code&gt;, we can use a trait bound of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt;. For example: The function &lt;code&gt;is_hello&lt;/code&gt; takes all arguments that can be converted into a &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f043234d0ac3953b89a91d738afd1e8d1c0c3577" translate="yes" xml:space="preserve">
          <source>In order to express that we want a generic function to take all arguments that can be converted to a specified type &lt;code&gt;T&lt;/code&gt;, we can use a trait bound of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt;. For example: The function &lt;code&gt;is_hello&lt;/code&gt; takes all arguments that can be converted into a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Para expresar que queremos que una funci&amp;oacute;n gen&amp;eacute;rica tome todos los argumentos que se pueden convertir a un tipo &lt;code&gt;T&lt;/code&gt; especificado , podemos usar un l&amp;iacute;mite de rasgo de &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; . Por ejemplo: la funci&amp;oacute;n &lt;code&gt;is_hello&lt;/code&gt; toma todos los argumentos que se pueden convertir en un &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0303aa2ff8dce24c97377d14d0409dbdf1ce9cff" translate="yes" xml:space="preserve">
          <source>In order to fix this error, verify that the type you're using does implement the trait. Example:</source>
          <target state="translated">Para corregir este error,verifique que el tipo que está usando implemente el rasgo.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="16814ae1bb835500e448e8f35cc53da6f0ca0628" translate="yes" xml:space="preserve">
          <source>In order to fix this error, you need to make the item public by using the &lt;code&gt;pub&lt;/code&gt; keyword. Example:</source>
          <target state="translated">Para corregir este error, debe hacer p&amp;uacute;blico el elemento mediante la palabra clave &lt;code&gt;pub&lt;/code&gt; . Ejemplo:</target>
        </trans-unit>
        <trans-unit id="0f266e5d780b399f0089fa40c8b0e4ea12c652ab" translate="yes" xml:space="preserve">
          <source>In order to make an intrinsic usable at compile-time, one needs to copy the implementation from &lt;a href=&quot;https://github.com/rust-lang/miri/blob/master/src/shims/intrinsics.rs&quot;&gt;https://github.com/rust-lang/miri/blob/master/src/shims/intrinsics.rs&lt;/a&gt; to &lt;code&gt;compiler/rustc_mir/src/interpret/intrinsics.rs&lt;/code&gt; and add a &lt;code&gt;#[rustc_const_unstable(feature = &quot;foo&quot;, issue = &quot;01234&quot;)]&lt;/code&gt; to the intrinsic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7221777f5fa03d42ac87ea82e0b30794fd67a12c" translate="yes" xml:space="preserve">
          <source>In order to make an intrinsic usable at compile-time, one needs to copy the implementation from https://github.com/rust-lang/miri/blob/master/src/shims/intrinsics.rs to &lt;code&gt;compiler/rustc_mir/src/interpret/intrinsics.rs&lt;/code&gt; and add a &lt;code&gt;#[rustc_const_unstable(feature = &quot;foo&quot;, issue = &quot;01234&quot;)]&lt;/code&gt; to the intrinsic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b32572b0c44c50ef0b6442f048eb1d80506db1f" translate="yes" xml:space="preserve">
          <source>In order to make common patterns more ergonomic, lifetime arguments can be &lt;em&gt;elided&lt;/em&gt; in &lt;a href=&quot;types/function-item&quot;&gt;function item&lt;/a&gt;, &lt;a href=&quot;types/function-pointer&quot;&gt;function pointer&lt;/a&gt; and &lt;a href=&quot;types/closure&quot;&gt;closure trait&lt;/a&gt; signatures. The following rules are used to infer lifetime parameters for elided lifetimes. It is an error to elide lifetime parameters that cannot be inferred. The placeholder lifetime, &lt;code&gt;'_&lt;/code&gt;, can also be used to have a lifetime inferred in the same way. For lifetimes in paths, using &lt;code&gt;'_&lt;/code&gt; is preferred. Trait object lifetimes follow different rules discussed &lt;a href=&quot;lifetime-elision#default-trait-object-lifetimes&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">Con el fin de hacer que los patrones comunes sean m&amp;aacute;s ergon&amp;oacute;micos, los argumentos de duraci&amp;oacute;n se pueden &lt;em&gt;elidir&lt;/em&gt; en el &lt;a href=&quot;types/function-item&quot;&gt;elemento de &lt;/a&gt;&lt;a href=&quot;types/function-pointer&quot;&gt;funci&amp;oacute;n&lt;/a&gt; , el puntero de funci&amp;oacute;n y las firmas de &lt;a href=&quot;types/closure&quot;&gt;rasgos de cierre&lt;/a&gt; . Las siguientes reglas se utilizan para inferir par&amp;aacute;metros de vida &amp;uacute;til para vidas elididas. Es un error eludir par&amp;aacute;metros de vida &amp;uacute;til que no se pueden inferir. La duraci&amp;oacute;n del marcador de posici&amp;oacute;n, &lt;code&gt;'_&lt;/code&gt; , tambi&amp;eacute;n se puede utilizar para inferir una duraci&amp;oacute;n de la misma forma. Para vidas en caminos, se prefiere usar &lt;code&gt;'_&lt;/code&gt; . La vida de los objetos rasgo sigue diferentes reglas que se describen a &lt;a href=&quot;lifetime-elision#default-trait-object-lifetimes&quot;&gt;continuaci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8c05c9e0569d955006204f9ccd8d44e873f7454e" translate="yes" xml:space="preserve">
          <source>In order to make common patterns more ergonomic, lifetime arguments can be &lt;em&gt;elided&lt;/em&gt; in &lt;a href=&quot;types/function-item&quot;&gt;function item&lt;/a&gt;, &lt;a href=&quot;types/function-pointer&quot;&gt;function pointer&lt;/a&gt;, and &lt;a href=&quot;types/closure&quot;&gt;closure trait&lt;/a&gt; signatures. The following rules are used to infer lifetime parameters for elided lifetimes. It is an error to elide lifetime parameters that cannot be inferred. The placeholder lifetime, &lt;code&gt;'_&lt;/code&gt;, can also be used to have a lifetime inferred in the same way. For lifetimes in paths, using &lt;code&gt;'_&lt;/code&gt; is preferred. Trait object lifetimes follow different rules discussed &lt;a href=&quot;#default-trait-object-lifetimes&quot;&gt;below&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d27121a6ebe29fbef52ed61a820dd624d21ff0c" translate="yes" xml:space="preserve">
          <source>In order to match C representation layout &lt;code&gt;repr(C)&lt;/code&gt;, you should call &lt;code&gt;pad_to_align&lt;/code&gt; after extending the layout with all fields. (There is no way to match the default Rust representation layout &lt;code&gt;repr(Rust)&lt;/code&gt;, as it is unspecified.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2072ffa181cdd9bbeca38913d9e7ffc8a4c68a24" translate="yes" xml:space="preserve">
          <source>In order to provide a well-organized API to your users that is straightforward to use and only exposes exactly what your users will need, let&amp;rsquo;s now turn to Rust&amp;rsquo;s modules.</source>
          <target state="translated">Para proporcionar una API bien organizada a sus usuarios que sea f&amp;aacute;cil de usar y solo exponga exactamente lo que sus usuarios necesitar&amp;aacute;n, pasemos ahora a los m&amp;oacute;dulos de Rust.</target>
        </trans-unit>
        <trans-unit id="62f97a59b8d70df8d4c8aedef19af999118a740d" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;x.wrapping_offset((y as usize).wrapping_sub(x as usize) / size_of::&amp;lt;T&amp;gt;())&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; the same as &lt;code&gt;y&lt;/code&gt;, and dereferencing it is undefined behavior unless &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; point into the same allocated object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f05491651266ee56252066973243e4d59fd4986f" translate="yes" xml:space="preserve">
          <source>In other words, all &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;s implement &lt;a href=&quot;trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt;, by just returning themselves. This means two things:</source>
          <target state="translated">En otras palabras, todo &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; es aplicar &lt;a href=&quot;trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt; , que acaban de volver a s&amp;iacute; mismos. Esto significa dos cosas:</target>
        </trans-unit>
        <trans-unit id="5e34b91de407d76f531f3eb575c5f8c03b7057c6" translate="yes" xml:space="preserve">
          <source>In other words, each &lt;a href=&quot;struct.thread&quot;&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;/a&gt; acts a bit like a spinlock that can be locked and unlocked using &lt;code&gt;park&lt;/code&gt; and &lt;code&gt;unpark&lt;/code&gt;.</source>
          <target state="translated">En otras palabras, cada &lt;a href=&quot;struct.thread&quot;&gt; &lt;code&gt;Thread&lt;/code&gt; &lt;/a&gt; act&amp;uacute;a un poco como un bloqueo &lt;code&gt;unpark&lt;/code&gt; que se puede bloquear y desbloquear utilizando &lt;code&gt;park&lt;/code&gt; y desbloquear .</target>
        </trans-unit>
        <trans-unit id="017a22416220a22bb237e68a2935592375fcdbd8" translate="yes" xml:space="preserve">
          <source>In other words, if a zero-sized pointer can flow out of an allocator, then that allocator must likewise accept that pointer flowing back into its deallocation and reallocation methods.</source>
          <target state="translated">En otras palabras,si un puntero de tamaño cero puede fluir fuera de un asignador,entonces ese asignador debe igualmente aceptar que ese puntero fluya de vuelta a sus métodos de asignación y reasignación.</target>
        </trans-unit>
        <trans-unit id="e3d6e585c04e6960f4a4daf614d13944251e6245" translate="yes" xml:space="preserve">
          <source>In other words, if two keys are equal, their hashes must also be equal. &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../collections/struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt; both rely on this behavior.</source>
          <target state="translated">En otras palabras, si dos claves son iguales, sus valores hash tambi&amp;eacute;n deben ser iguales. &lt;a href=&quot;../collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../collections/struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; se&lt;/a&gt; basan en este comportamiento.</target>
        </trans-unit>
        <trans-unit id="0806744b814432ac5eeb9bbe9aaec55997c24ce4" translate="yes" xml:space="preserve">
          <source>In other words, if two keys are equal, their hashes must be equal.</source>
          <target state="translated">En otras palabras,si dos llaves son iguales,sus hashes deben ser iguales.</target>
        </trans-unit>
        <trans-unit id="651e99e3b0937bfaed54c38e268ae7294b8d7b90" translate="yes" xml:space="preserve">
          <source>In other words, if you tried to explicitly call &lt;code&gt;Drop::drop&lt;/code&gt; in the above example, you'd get a compiler error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f6bdd62db2c3d1c564fe1508c5d510fa5ae36fe" translate="yes" xml:space="preserve">
          <source>In other words, it links two iterators together, in a chain. 🔗</source>
          <target state="translated">En otras palabras,une dos iteradores en una cadena.🔗</target>
        </trans-unit>
        <trans-unit id="54f872e9b6db688afe70a73782dd0f6ed1033af8" translate="yes" xml:space="preserve">
          <source>In other words, it removes the &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; layer automatically. If your mapping is already returning an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and you want to skip over &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;s, then &lt;code&gt;filter_map&lt;/code&gt; is much, much nicer to use.</source>
          <target state="translated">En otras palabras, elimina la capa &lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; autom&amp;aacute;ticamente. Si su mapeo ya est&amp;aacute; devolviendo una &lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; y desea omitir &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , entonces &lt;code&gt;filter_map&lt;/code&gt; es mucho, mucho m&amp;aacute;s agradable de usar.</target>
        </trans-unit>
        <trans-unit id="89979b2fec011c660ad3e7734fd58ee8f629327f" translate="yes" xml:space="preserve">
          <source>In other words, it zips two iterators together, into a single one.</source>
          <target state="translated">En otras palabras,junta dos iteradores en uno solo.</target>
        </trans-unit>
        <trans-unit id="b3e56b5cdfc19448d528331ce8acb937d8705430" translate="yes" xml:space="preserve">
          <source>In other words, remove all characters &lt;code&gt;c&lt;/code&gt; such that &lt;code&gt;f(c)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. This method operates in place, visiting each character exactly once in the original order, and preserves the order of the retained characters.</source>
          <target state="translated">En otras palabras, elimine todos los caracteres &lt;code&gt;c&lt;/code&gt; de modo que &lt;code&gt;f(c)&lt;/code&gt; devuelva &lt;code&gt;false&lt;/code&gt; . Este m&amp;eacute;todo funciona en el lugar, visitando cada car&amp;aacute;cter exactamente una vez en el orden original y conserva el orden de los caracteres retenidos.</target>
        </trans-unit>
        <trans-unit id="da3db680c88a9b20c1061ab552177a6db2b7f021" translate="yes" xml:space="preserve">
          <source>In other words, remove all elements &lt;code&gt;e&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">En otras palabras, elimine todos los elementos &lt;code&gt;e&lt;/code&gt; d manera que &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; devuelva &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="326bae5baf07932f414f02dbcc5ff71283bf4bd0" translate="yes" xml:space="preserve">
          <source>In other words, remove all elements &lt;code&gt;e&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. The elements are visited in unsorted (and unspecified) order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e07775077ea9082d7402b02d807e4e57d5847374" translate="yes" xml:space="preserve">
          <source>In other words, remove all elements &lt;code&gt;e&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. This method operates in place, visiting each element exactly once in the original order, and preserves the order of the retained elements.</source>
          <target state="translated">En otras palabras, elimine todos los elementos &lt;code&gt;e&lt;/code&gt; d manera que &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; devuelva &lt;code&gt;false&lt;/code&gt; . Este m&amp;eacute;todo opera en el lugar, visitando cada elemento exactamente una vez en el orden original y preserva el orden de los elementos retenidos.</target>
        </trans-unit>
        <trans-unit id="6acdfc87ca3bbf1858881abbc8aa3fe29f18bd27" translate="yes" xml:space="preserve">
          <source>In other words, remove all elements &lt;code&gt;e&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; returns false. This method operates in place, visiting each element exactly once in the original order, and preserves the order of the retained elements.</source>
          <target state="translated">En otras palabras, elimine todos los elementos &lt;code&gt;e&lt;/code&gt; d manera que &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; devuelva falso. Este m&amp;eacute;todo opera en el lugar, visitando cada elemento exactamente una vez en el orden original y preserva el orden de los elementos retenidos.</target>
        </trans-unit>
        <trans-unit id="f592c733f4a495d9c0b5f64b20924cb17921a1b4" translate="yes" xml:space="preserve">
          <source>In other words, remove all pairs &lt;code&gt;(k, v)&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;k, &amp;amp;mut v)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="409ac6d61a4514fa20ba9e42bf2bc871e22e3383" translate="yes" xml:space="preserve">
          <source>In other words, remove all pairs &lt;code&gt;(k, v)&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;k,&amp;amp;mut v)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">En otras palabras, elimine todos los pares &lt;code&gt;(k, v)&lt;/code&gt; modo que &lt;code&gt;f(&amp;amp;k,&amp;amp;mut v)&lt;/code&gt; devuelva &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db6a61aac7244549da2135cbc7c5d55db0ae8143" translate="yes" xml:space="preserve">
          <source>In other words, the result is &lt;code&gt;self / rhs&lt;/code&gt; rounded to the integer &lt;code&gt;n&lt;/code&gt; such that &lt;code&gt;self &amp;gt;= n * rhs&lt;/code&gt;. If &lt;code&gt;self &amp;gt; 0&lt;/code&gt;, this is equal to round towards zero (the default in Rust); if &lt;code&gt;self &amp;lt; 0&lt;/code&gt;, this is equal to round towards +/- infinity.</source>
          <target state="translated">En otras palabras, el resultado es &lt;code&gt;self / rhs&lt;/code&gt; redondeado al entero &lt;code&gt;n&lt;/code&gt; tal que &lt;code&gt;self &amp;gt;= n * rhs&lt;/code&gt; . Si &lt;code&gt;self &amp;gt; 0&lt;/code&gt; , esto es igual a redondear hacia cero (el valor predeterminado en Rust); si &lt;code&gt;self &amp;lt; 0&lt;/code&gt; , esto es igual a redondear hacia +/- infinito.</target>
        </trans-unit>
        <trans-unit id="f3eceeaf0b00ea5c9de839f6b4c98970d8bf7ccc" translate="yes" xml:space="preserve">
          <source>In other words, there are two important points in time here:</source>
          <target state="translated">En otras palabras,hay dos puntos importantes en el tiempo aquí:</target>
        </trans-unit>
        <trans-unit id="514a6e60d538677dfc818a6af055ba7f84a3873f" translate="yes" xml:space="preserve">
          <source>In other words, we tell Rust that the data returned by the &lt;code&gt;search&lt;/code&gt; function will live as long as the data passed into the &lt;code&gt;search&lt;/code&gt; function in the &lt;code&gt;contents&lt;/code&gt; argument. This is important! The data referenced &lt;em&gt;by&lt;/em&gt; a slice needs to be valid for the reference to be valid; if the compiler assumes we&amp;rsquo;re making string slices of &lt;code&gt;query&lt;/code&gt; rather than &lt;code&gt;contents&lt;/code&gt;, it will do its safety checking incorrectly.</source>
          <target state="translated">En otras palabras, le decimos a Rust que los datos devueltos por la funci&amp;oacute;n de &lt;code&gt;search&lt;/code&gt; vivir&amp;aacute;n mientras los datos pasados ​​a la funci&amp;oacute;n de &lt;code&gt;search&lt;/code&gt; en el argumento de &lt;code&gt;contents&lt;/code&gt; . &amp;iexcl;Esto es importante! Los datos referenciados &lt;em&gt;por&lt;/em&gt; unas necesidades rebanada sea v&amp;aacute;lida para que la referencia sea v&amp;aacute;lida; si el compilador asume que estamos haciendo secciones de cadena de &lt;code&gt;query&lt;/code&gt; lugar de &lt;code&gt;contents&lt;/code&gt; , har&amp;aacute; su verificaci&amp;oacute;n de seguridad de manera incorrecta.</target>
        </trans-unit>
        <trans-unit id="804ea33dad59d1c5c89d408ead7e387f0a985972" translate="yes" xml:space="preserve">
          <source>In other words, you can think of &lt;code&gt;if let&lt;/code&gt; as syntax sugar for a &lt;code&gt;match&lt;/code&gt; that runs code when the value matches one pattern and then ignores all other values.</source>
          <target state="translated">En otras palabras, puede pensar en &lt;code&gt;if let&lt;/code&gt; como az&amp;uacute;car de sintaxis para una &lt;code&gt;match&lt;/code&gt; que ejecuta c&amp;oacute;digo cuando el valor coincide con un patr&amp;oacute;n y luego ignora todos los dem&amp;aacute;s valores.</target>
        </trans-unit>
        <trans-unit id="6334c9849815dfecdd814af745b203f67c22a399" translate="yes" xml:space="preserve">
          <source>In other words, you have to convert an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; to a &lt;code&gt;T&lt;/code&gt; before you can perform &lt;code&gt;T&lt;/code&gt; operations with it. Generally, this helps catch one of the most common issues with null: assuming that something isn&amp;rsquo;t null when it actually is.</source>
          <target state="translated">En otras palabras, debe convertir una &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; en una &lt;code&gt;T&lt;/code&gt; antes de poder realizar operaciones &lt;code&gt;T&lt;/code&gt; con ella. Generalmente, esto ayuda a detectar uno de los problemas m&amp;aacute;s comunes con nulo: asumir que algo no es nulo cuando en realidad lo es.</target>
        </trans-unit>
        <trans-unit id="0196eaac5628739fbf6cb05a071b0a88467b2539" translate="yes" xml:space="preserve">
          <source>In other words: t &amp;isin; FOLLOW(M) if and only if there exists (potentially empty) token sequences &amp;alpha;, &amp;beta;, &amp;gamma;, &amp;delta; where:</source>
          <target state="translated">En otras palabras: t &amp;isin; SIGUE (M) si y solo si existen secuencias de tokens (potencialmente vac&amp;iacute;as) &amp;alpha;, &amp;beta;, &amp;gamma;, &amp;delta; donde:</target>
        </trans-unit>
        <trans-unit id="3cd75e15c4f05dc1708639a16368fd49e4de241e" translate="yes" xml:space="preserve">
          <source>In our erroneous example, however, we're referencing a single concrete type. Since we know for certain that &lt;code&gt;Wrapper&amp;lt;u32&amp;gt;&lt;/code&gt; implements &lt;code&gt;Clone&lt;/code&gt;, there's no reason to also specify it in a &lt;code&gt;where&lt;/code&gt; clause.</source>
          <target state="translated">Sin embargo, en nuestro ejemplo err&amp;oacute;neo, estamos haciendo referencia a un solo tipo de hormig&amp;oacute;n. Dado que sabemos con certeza que &lt;code&gt;Wrapper&amp;lt;u32&amp;gt;&lt;/code&gt; implementa &lt;code&gt;Clone&lt;/code&gt; , no hay raz&amp;oacute;n para especificarlo tambi&amp;eacute;n en una cl&amp;aacute;usula &lt;code&gt;where&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="293c59c6ff48105f3a4a79bd57b559d1a88006c4" translate="yes" xml:space="preserve">
          <source>In particular &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt; and &lt;code&gt;Hash&lt;/code&gt; must be equivalent for borrowed and owned values: &lt;code&gt;x.borrow() == y.borrow()&lt;/code&gt; should give the same result as &lt;code&gt;x == y&lt;/code&gt;.</source>
          <target state="translated">En particular , &lt;code&gt;Eq&lt;/code&gt; , &lt;code&gt;Ord&lt;/code&gt; y &lt;code&gt;Hash&lt;/code&gt; deben ser equivalentes para valores prestados y &lt;code&gt;x.borrow() == y.borrow()&lt;/code&gt; : x.borrow () == y.borrow () debe dar el mismo resultado que &lt;code&gt;x == y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75333f3519a07df1c42a5d8eddbdb687099bae84" translate="yes" xml:space="preserve">
          <source>In particular, coercing a function with &lt;code&gt;#[track_caller]&lt;/code&gt; to a function pointer creates a shim which appears to observers to have been called at the attributed function's definition site, losing actual caller information across virtual calls. A common example of this coercion is the creation of a trait object whose methods are attributed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fc02ea574ea8868955711f77244bfddf7cf3916" translate="yes" xml:space="preserve">
          <source>In particular, if one has a memory block allocated via a given allocator &lt;code&gt;a&lt;/code&gt; and layout &lt;code&gt;k&lt;/code&gt; where &lt;code&gt;a.usable_size(k)&lt;/code&gt; returns &lt;code&gt;(l, u)&lt;/code&gt;, then one can pass that block to &lt;code&gt;a.dealloc()&lt;/code&gt; with a layout in the size range [l, u].</source>
          <target state="translated">En particular, si uno tiene un bloque de memoria asignado a trav&amp;eacute;s de un asignador dado &lt;code&gt;a&lt;/code&gt; y un dise&amp;ntilde;o &lt;code&gt;k&lt;/code&gt; donde &lt;code&gt;a.usable_size(k)&lt;/code&gt; devuelve &lt;code&gt;(l, u)&lt;/code&gt; , entonces uno puede pasar ese bloque a &lt;code&gt;a.dealloc()&lt;/code&gt; con un dise&amp;ntilde;o en el tama&amp;ntilde;o rango [l, u].</target>
        </trans-unit>
        <trans-unit id="d30439b36bf2c88bac9a70141d7e2e3a34d9cecb" translate="yes" xml:space="preserve">
          <source>In particular, it can happen if you forgot the closing bracket of a register constraint (see issue #51430), like in the previous code example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1d6c2afe57e4288fb19b871bba2fa73f6a44e31" translate="yes" xml:space="preserve">
          <source>In particular, it can happen if you forgot the closing bracket of a register constraint (see issue #51430):</source>
          <target state="translated">En particular,puede suceder si se olvida el paréntesis de cierre de una restricción de registro (véase el número 51430):</target>
        </trans-unit>
        <trans-unit id="f7716ba7e6003b68172172b437c60f14481d71f9" translate="yes" xml:space="preserve">
          <source>In particular, the hash used to initialized the raw entry must still be consistent with the hash of the key that is ultimately stored in the entry. This is because implementations of HashMap may need to recompute hashes when resizing, at which point only the keys are available.</source>
          <target state="translated">En particular,el hash utilizado para inicializar la entrada en bruto debe seguir siendo coherente con el hash de la clave que se almacena en última instancia en la entrada.Esto se debe a que las implementaciones de HashMap pueden necesitar volver a calcular los hash al redimensionar,momento en el que sólo están disponibles las claves.</target>
        </trans-unit>
        <trans-unit id="1f0c47f31f9dc083f9c5c01ccece4c74f77d799d" translate="yes" xml:space="preserve">
          <source>In particular, the resulting pointer remains attached to the same allocated object that &lt;code&gt;self&lt;/code&gt; points to. It may &lt;em&gt;not&lt;/em&gt; be used to access a different allocated object. Note that in Rust, every (stack-allocated) variable is considered a separate allocated object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b3f61d7a53e26f34f171feb26ed7836eaeaa8a1" translate="yes" xml:space="preserve">
          <source>In particular, the return value &lt;code&gt;r&lt;/code&gt; satisfies &lt;code&gt;0.0 &amp;lt;= r &amp;lt; rhs.abs()&lt;/code&gt; in most cases. However, due to a floating point round-off error it can result in &lt;code&gt;r == rhs.abs()&lt;/code&gt;, violating the mathematical definition, if &lt;code&gt;self&lt;/code&gt; is much smaller than &lt;code&gt;rhs.abs()&lt;/code&gt; in magnitude and &lt;code&gt;self &amp;lt; 0.0&lt;/code&gt;. This result is not an element of the function's codomain, but it is the closest floating point number in the real numbers and thus fulfills the property &lt;code&gt;self == self.div_euclid(rhs) * rhs + self.rem_euclid(rhs)&lt;/code&gt; approximatively.</source>
          <target state="translated">En particular, el valor de retorno &lt;code&gt;r&lt;/code&gt; satisface &lt;code&gt;0.0 &amp;lt;= r &amp;lt; rhs.abs()&lt;/code&gt; en la mayor&amp;iacute;a de los casos. Sin embargo, debido a un error de redondeo de coma flotante, puede resultar en &lt;code&gt;r == rhs.abs()&lt;/code&gt; , violando la definici&amp;oacute;n matem&amp;aacute;tica, si &lt;code&gt;self&lt;/code&gt; es mucho m&amp;aacute;s peque&amp;ntilde;o que &lt;code&gt;rhs.abs()&lt;/code&gt; en magnitud y &lt;code&gt;self &amp;lt; 0.0&lt;/code&gt; . Este resultado no es un elemento del codominio de la funci&amp;oacute;n, pero es el n&amp;uacute;mero de punto flotante m&amp;aacute;s cercano en los n&amp;uacute;meros reales y, por lo tanto, cumple la propiedad &lt;code&gt;self == self.div_euclid(rhs) * rhs + self.rem_euclid(rhs)&lt;/code&gt; aproximadamente.</target>
        </trans-unit>
        <trans-unit id="5ace8c101adbcb8f417784f9525d6b6b04d2023a" translate="yes" xml:space="preserve">
          <source>In particular, try to have this call &lt;code&gt;fold()&lt;/code&gt; on the internal parts from which this iterator is composed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebe8059d8d4f315af9e0c1a14935b000c2ce3c36" translate="yes" xml:space="preserve">
          <source>In particular, try to have this call &lt;code&gt;try_fold()&lt;/code&gt; on the internal parts from which this iterator is composed. If multiple calls are needed, the &lt;code&gt;?&lt;/code&gt; operator may be convenient for chaining the accumulator value along, but beware any invariants that need to be upheld before those early returns. This is a &lt;code&gt;&amp;amp;mut self&lt;/code&gt; method, so iteration needs to be resumable after hitting an error here.</source>
          <target state="translated">En particular, intente tener esta llamada &lt;code&gt;try_fold()&lt;/code&gt; en las partes internas de las que est&amp;aacute; compuesto este iterador. Si se necesitan varias llamadas, el &lt;code&gt;?&lt;/code&gt; El operador puede ser conveniente para encadenar el valor del acumulador, pero tenga cuidado con cualquier invariante que deba mantenerse antes de esos retornos anticipados. Este es un m&amp;eacute;todo de &lt;code&gt;&amp;amp;mut self&lt;/code&gt; , por lo que la iteraci&amp;oacute;n debe poder reanudarse despu&amp;eacute;s de encontrar un error aqu&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="b28ffdb986ba0682e9d2b9fe7fe1c75ddd8df192" translate="yes" xml:space="preserve">
          <source>In rare situations, it&amp;rsquo;s more appropriate to write code that panics instead of returning a &lt;code&gt;Result&lt;/code&gt;. Let&amp;rsquo;s explore why it&amp;rsquo;s appropriate to panic in examples, prototype code, and tests. Then we&amp;rsquo;ll discuss situations in which the compiler can&amp;rsquo;t tell that failure is impossible, but you as a human can. The chapter will conclude with some general guidelines on how to decide whether to panic in library code.</source>
          <target state="translated">En situaciones raras, es m&amp;aacute;s apropiado escribir c&amp;oacute;digo que entre en p&amp;aacute;nico en lugar de devolver un &lt;code&gt;Result&lt;/code&gt; . Exploremos por qu&amp;eacute; es apropiado entrar en p&amp;aacute;nico en ejemplos, c&amp;oacute;digo prototipo y pruebas. Luego discutiremos situaciones en las que el compilador no puede decir que el fracaso es imposible, pero usted, como humano, puede hacerlo. El cap&amp;iacute;tulo concluir&amp;aacute; con algunas pautas generales sobre c&amp;oacute;mo decidir si entrar en p&amp;aacute;nico en el c&amp;oacute;digo de la biblioteca.</target>
        </trans-unit>
        <trans-unit id="080a5588048a460fe7952d8098cb9c6856c84518" translate="yes" xml:space="preserve">
          <source>In short, because &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; (where &lt;code&gt;T&lt;/code&gt; can be any type) are different types, the compiler won&amp;rsquo;t let us use an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; value as if it were definitely a valid value. For example, this code won&amp;rsquo;t compile because it&amp;rsquo;s trying to add an &lt;code&gt;i8&lt;/code&gt; to an &lt;code&gt;Option&amp;lt;i8&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">En resumen, debido a que &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; y &lt;code&gt;T&lt;/code&gt; (donde &lt;code&gt;T&lt;/code&gt; puede ser de cualquier tipo) son tipos diferentes, el compilador no nos permitir&amp;aacute; usar un valor &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; como si fuera definitivamente un valor v&amp;aacute;lido. Por ejemplo, este c&amp;oacute;digo no se compilar&amp;aacute; porque est&amp;aacute; intentando agregar un &lt;code&gt;i8&lt;/code&gt; a una &lt;code&gt;Option&amp;lt;i8&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="21e76fec2b332ec53cb1d4a54f13b33bbe0752a4" translate="yes" xml:space="preserve">
          <source>In single-threaded scenarios, this can cause issues when writing signal handlers or certain kinds of low-level code. Use &lt;a href=&quot;atomic/fn.compiler_fence&quot;&gt;compiler fences&lt;/a&gt; to prevent this reordering.</source>
          <target state="translated">En escenarios de un solo subproceso, esto puede causar problemas al escribir controladores de se&amp;ntilde;ales o ciertos tipos de c&amp;oacute;digo de bajo nivel. Utilice &lt;a href=&quot;atomic/fn.compiler_fence&quot;&gt;vallas del compilador&lt;/a&gt; para evitar este reordenamiento.</target>
        </trans-unit>
        <trans-unit id="6eccde4f87031328924ef4f1acaf135f499b7802" translate="yes" xml:space="preserve">
          <source>In some contexts, the compiler must coerce together multiple types to try and find the most general type. This is called a &quot;Least Upper Bound&quot; coercion. LUB coercion is used and only used in the following situations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0772e28e9cf06b8832079dff483fbb65fa8253ca" translate="yes" xml:space="preserve">
          <source>In some languages, the programmer must call code to free memory or resources every time they finish using an instance of a smart pointer. If they forget, the system might become overloaded and crash. In Rust, you can specify that a particular bit of code be run whenever a value goes out of scope, and the compiler will insert this code automatically. As a result, you don&amp;rsquo;t need to be careful about placing cleanup code everywhere in a program that an instance of a particular type is finished with&amp;mdash;you still won&amp;rsquo;t leak resources!</source>
          <target state="translated">En algunos lenguajes, el programador debe llamar al c&amp;oacute;digo para liberar memoria o recursos cada vez que terminan de usar una instancia de un puntero inteligente. Si se olvidan, el sistema podr&amp;iacute;a sobrecargarse y bloquearse. En Rust, puede especificar que se ejecute un fragmento de c&amp;oacute;digo en particular cada vez que un valor salga del alcance, y el compilador insertar&amp;aacute; este c&amp;oacute;digo autom&amp;aacute;ticamente. Como resultado, no necesita tener cuidado al colocar c&amp;oacute;digo de limpieza en cualquier lugar de un programa con el que termine una instancia de un tipo en particular; &amp;iexcl;a&amp;uacute;n no perder&amp;aacute; recursos!</target>
        </trans-unit>
        <trans-unit id="37072e6e82bbf9d96cc9281defd328d5ab53bf93" translate="yes" xml:space="preserve">
          <source>In some programming languages, the behavior of string formatting functions depends on the operating system's locale setting. The format functions provided by Rust's standard library do not have any concept of locale and will produce the same results on all systems regardless of user configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1e113cf6d44a0a189f70b8c727f406e2c0c6aed" translate="yes" xml:space="preserve">
          <source>In some situations the combination of types may be ambiguous. Use parentheses around a type to avoid ambiguity. For example, the &lt;code&gt;+&lt;/code&gt; operator for &lt;a href=&quot;trait-bounds&quot;&gt;type boundaries&lt;/a&gt; within a &lt;a href=&quot;types/pointer#shared-references-&quot;&gt;reference type&lt;/a&gt; is unclear where the boundary applies, so the use of parentheses is required. Grammar rules that require this disambiguation use the &lt;a href=&quot;types#type-expressions&quot;&gt;&lt;em&gt;TypeNoBounds&lt;/em&gt;&lt;/a&gt; rule instead of &lt;a href=&quot;types#type-expressions&quot;&gt;&lt;em&gt;Type&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">En algunas situaciones, la combinaci&amp;oacute;n de tipos puede ser ambigua. Use par&amp;eacute;ntesis alrededor de un tipo para evitar ambig&amp;uuml;edades. Por ejemplo, el operador &lt;code&gt;+&lt;/code&gt; para los &lt;a href=&quot;trait-bounds&quot;&gt;l&amp;iacute;mites de tipo&lt;/a&gt; dentro de un &lt;a href=&quot;types/pointer#shared-references-&quot;&gt;tipo de referencia&lt;/a&gt; no est&amp;aacute; claro d&amp;oacute;nde se aplica el l&amp;iacute;mite, por lo que se requiere el uso de par&amp;eacute;ntesis. Las reglas gramaticales que requieren esta desambiguaci&amp;oacute;n utilizan la regla &lt;a href=&quot;types#type-expressions&quot;&gt;&lt;em&gt;TypeNoBounds en&lt;/em&gt;&lt;/a&gt; lugar de &lt;a href=&quot;types#type-expressions&quot;&gt;&lt;em&gt;Type&lt;/em&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="78a25e5b990fcd1740e4efa791bdb025c393c864" translate="yes" xml:space="preserve">
          <source>In some situations, some strings that should create a valid float instead return an error. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/31407&quot;&gt;issue #31407&lt;/a&gt; for details.</source>
          <target state="translated">En algunas situaciones, algunas cadenas que deber&amp;iacute;an crear un flotante v&amp;aacute;lido devuelven un error. Consulte el &lt;a href=&quot;https://github.com/rust-lang/rust/issues/31407&quot;&gt;n&amp;uacute;mero 31407&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="e28b9cfae095cd08e8afd62032026a0b23bc39f7" translate="yes" xml:space="preserve">
          <source>In statements like &lt;code&gt;let x = 5;&lt;/code&gt; with a variable name in the &lt;code&gt;PATTERN&lt;/code&gt; slot, the variable name is just a particularly simple form of a pattern. Rust compares the expression against the pattern and assigns any names it finds. So in the &lt;code&gt;let x = 5;&lt;/code&gt; example, &lt;code&gt;x&lt;/code&gt; is a pattern that means &amp;ldquo;bind what matches here to the variable &lt;code&gt;x&lt;/code&gt;.&amp;rdquo; Because the name &lt;code&gt;x&lt;/code&gt; is the whole pattern, this pattern effectively means &amp;ldquo;bind everything to the variable &lt;code&gt;x&lt;/code&gt;, whatever the value is.&amp;rdquo;</source>
          <target state="translated">En declaraciones como &lt;code&gt;let x = 5;&lt;/code&gt; con un nombre de variable en el espacio &lt;code&gt;PATTERN&lt;/code&gt; , el nombre de la variable es solo una forma particularmente simple de un patr&amp;oacute;n. Rust compara la expresi&amp;oacute;n con el patr&amp;oacute;n y asigna los nombres que encuentra. Entonces, en el caso &lt;code&gt;let x = 5;&lt;/code&gt; Por ejemplo, &lt;code&gt;x&lt;/code&gt; es un patr&amp;oacute;n que significa &quot;vincular lo que coincida aqu&amp;iacute; con la variable &lt;code&gt;x&lt;/code&gt; &quot;. Debido a que el nombre &lt;code&gt;x&lt;/code&gt; es el patr&amp;oacute;n completo, este patr&amp;oacute;n significa efectivamente &quot;vincular todo a la variable &lt;code&gt;x&lt;/code&gt; , sea cual sea el valor&quot;.</target>
        </trans-unit>
        <trans-unit id="ab76c75fb8be2531be195781f70554fa526d2349" translate="yes" xml:space="preserve">
          <source>In such a case, the compiler cannot predict the return type of &lt;code&gt;foo()&lt;/code&gt; in a situation like the following:</source>
          <target state="translated">En tal caso, el compilador no puede predecir el tipo de retorno de &lt;code&gt;foo()&lt;/code&gt; en una situaci&amp;oacute;n como la siguiente:</target>
        </trans-unit>
        <trans-unit id="a84c028b3015af78e467c76bddbf22405a6992e9" translate="yes" xml:space="preserve">
          <source>In sum, here are the steps we took to change the code from Listing 10-2 to Listing 10-3:</source>
          <target state="translated">En resumen,estos son los pasos que dimos para cambiar el código de la Lista 10-2 a la Lista 10-3:</target>
        </trans-unit>
        <trans-unit id="b66a6766ec59e5aa720a0c750a221736c0a524da" translate="yes" xml:space="preserve">
          <source>In terms of &lt;a href=&quot;../sync/atomic/index&quot;&gt;atomic memory orderings&lt;/a&gt;, the completion of the associated thread synchronizes with this function returning. In other words, all operations performed by that thread are ordered before all operations that happen after &lt;code&gt;join&lt;/code&gt; returns.</source>
          <target state="translated">En t&amp;eacute;rminos de &lt;a href=&quot;../sync/atomic/index&quot;&gt;ordenaciones de memoria at&amp;oacute;mica&lt;/a&gt; , la finalizaci&amp;oacute;n del hilo asociado se sincroniza con el retorno de esta funci&amp;oacute;n. En otras palabras, todas las operaciones realizadas por ese hilo se ordenan antes de todas las operaciones que suceden despu&amp;eacute;s de que &lt;code&gt;join&lt;/code&gt; devuelva la combinaci&amp;oacute;n .</target>
        </trans-unit>
        <trans-unit id="49ebdf4d886162df5d53e77b9ab0d51282c8c87c" translate="yes" xml:space="preserve">
          <source>In the 2015 edition parameters pattern where not needed for traits:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fb4dfd79140995a00d7f2f4a091910c0bb3584f" translate="yes" xml:space="preserve">
          <source>In the 2015 edition, &lt;a href=&quot;types/trait-object&quot;&gt;&lt;code&gt;dyn&lt;/code&gt;&lt;/a&gt; is a keyword when used in a type position followed by a path that does not start with &lt;code&gt;::&lt;/code&gt;.</source>
          <target state="translated">En la edici&amp;oacute;n de 2015, &lt;a href=&quot;types/trait-object&quot;&gt; &lt;code&gt;dyn&lt;/code&gt; &lt;/a&gt; es una palabra clave cuando se usa en una posici&amp;oacute;n de tipo seguida de una ruta que no comienza con &lt;code&gt;::&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5c533200fa356e0f6f01942ecd077fd12144d48" translate="yes" xml:space="preserve">
          <source>In the 2015 edition, the pattern for a trait function or method parameter is optional:</source>
          <target state="translated">En la edición de 2015,el patrón para una función de rasgo o un parámetro de método es opcional:</target>
        </trans-unit>
        <trans-unit id="ead217a846b182b1c7c3895bb636fcdc53cf3da8" translate="yes" xml:space="preserve">
          <source>In the 2018 edition, if an in-scope item has the same name as an external crate, then &lt;code&gt;use&lt;/code&gt; of that crate name requires a leading &lt;code&gt;::&lt;/code&gt; to unambiguously select the crate name. This is to retain compatibility with potential future changes.</source>
          <target state="translated">En la edici&amp;oacute;n 2018, si un elemento dentro del alcance tiene el mismo nombre que una caja externa, entonces el &lt;code&gt;use&lt;/code&gt; de ese nombre de caja requiere un &lt;code&gt;::&lt;/code&gt; para seleccionar sin ambig&amp;uuml;edades el nombre de la caja. Esto es para mantener la compatibilidad con posibles cambios futuros.</target>
        </trans-unit>
        <trans-unit id="a3999cf3a0362f5c3017eea167e996c61b1004cc" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://www.unicode.org/versions/latest/&quot;&gt;Unicode Standard&lt;/a&gt;, Chapter 4 (Character Properties) discusses case mapping in general and Chapter 3 (Conformance) discusses the default algorithm for case conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac8c3e671a7bc9e2a3ca26713c444ad82025ac40" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;index&quot;&gt;module level docs&lt;/a&gt;, we implemented an &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;Counter&lt;/code&gt;. Let's implement &lt;code&gt;ExactSizeIterator&lt;/code&gt; for it as well:</source>
          <target state="translated">En los &lt;a href=&quot;index&quot;&gt;documentos de nivel de m&amp;oacute;dulo&lt;/a&gt; , implementamos un &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;Counter&lt;/code&gt; . Implementemos &lt;code&gt;ExactSizeIterator&lt;/code&gt; tambi&amp;eacute;n para &amp;eacute;l:</target>
        </trans-unit>
        <trans-unit id="29a70e5936b8ef90f87c3d79c860b1701d924dbc" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;index&quot;&gt;module-level docs&lt;/a&gt;, we implemented an &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;Counter&lt;/code&gt;. Let's implement &lt;code&gt;ExactSizeIterator&lt;/code&gt; for it as well:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="542be6c89aa5ea78dd9931c09f1fa338c6d41b0e" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;User&lt;/code&gt; struct definition in Listing 5-1, we used the owned &lt;code&gt;String&lt;/code&gt; type rather than the &lt;code&gt;&amp;amp;str&lt;/code&gt; string slice type. This is a deliberate choice because we want instances of this struct to own all of its data and for that data to be valid for as long as the entire struct is valid.</source>
          <target state="translated">En la definici&amp;oacute;n de estructura de &lt;code&gt;User&lt;/code&gt; en el Listado 5-1, usamos el tipo de &lt;code&gt;String&lt;/code&gt; propiedad en lugar del tipo de segmento de cadena &lt;code&gt;&amp;amp;str&lt;/code&gt; . Esta es una elecci&amp;oacute;n deliberada porque queremos que las instancias de esta estructura posean todos sus datos y que esos datos sean v&amp;aacute;lidos mientras la estructura completa sea v&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="86f5e9e4af3e5d42db41973d9449d9469f700ef8" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;handle_connection&lt;/code&gt; function, we&amp;rsquo;ve made the &lt;code&gt;stream&lt;/code&gt; parameter mutable. The reason is that the &lt;code&gt;TcpStream&lt;/code&gt; instance keeps track of what data it returns to us internally. It might read more data than we asked for and save that data for the next time we ask for data. It therefore needs to be &lt;code&gt;mut&lt;/code&gt; because its internal state might change; usually, we think of &amp;ldquo;reading&amp;rdquo; as not needing mutation, but in this case we need the &lt;code&gt;mut&lt;/code&gt; keyword.</source>
          <target state="translated">En la funci&amp;oacute;n &lt;code&gt;handle_connection&lt;/code&gt; , hemos hecho que el par&amp;aacute;metro de &lt;code&gt;stream&lt;/code&gt; mutable. La raz&amp;oacute;n es que la instancia de &lt;code&gt;TcpStream&lt;/code&gt; realiza un seguimiento de los datos que nos devuelve internamente. Puede leer m&amp;aacute;s datos de los que solicitamos y guardarlos para la pr&amp;oacute;xima vez que solicitemos datos. Por lo tanto, debe ser &lt;code&gt;mut&lt;/code&gt; porque su estado interno podr&amp;iacute;a cambiar; por lo general, pensamos que &quot;lectura&quot; no necesita mutaci&amp;oacute;n, pero en este caso necesitamos la palabra clave &lt;code&gt;mut&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41e5d381e8adcfa53c11fefa07fcde5916d77703" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;Cargo.toml&lt;/em&gt; file, everything that follows a header is part of a section that continues until another section starts. The &lt;code&gt;[dependencies]&lt;/code&gt; section is where you tell Cargo which external crates your project depends on and which versions of those crates you require. In this case, we&amp;rsquo;ll specify the &lt;code&gt;rand&lt;/code&gt; crate with the semantic version specifier &lt;code&gt;0.3.14&lt;/code&gt;. Cargo understands &lt;a href=&quot;http://semver.org&quot;&gt;Semantic Versioning&lt;/a&gt; (sometimes called &lt;em&gt;SemVer&lt;/em&gt;), which is a standard for writing version numbers. The number &lt;code&gt;0.3.14&lt;/code&gt; is actually shorthand for &lt;code&gt;^0.3.14&lt;/code&gt;, which means &amp;ldquo;any version that has a public API compatible with version 0.3.14.&amp;rdquo;</source>
          <target state="translated">En el archivo &lt;em&gt;Cargo.toml&lt;/em&gt; , todo lo que sigue a un encabezado es parte de una secci&amp;oacute;n que contin&amp;uacute;a hasta que comienza otra secci&amp;oacute;n. La secci&amp;oacute;n &lt;code&gt;[dependencies]&lt;/code&gt; es donde le dice a Cargo de qu&amp;eacute; cajas externas depende su proyecto y qu&amp;eacute; versiones de esas cajas necesita. En este caso, especificaremos la caja &lt;code&gt;rand&lt;/code&gt; con el especificador de versi&amp;oacute;n sem&amp;aacute;ntica &lt;code&gt;0.3.14&lt;/code&gt; . Cargo comprende el &lt;a href=&quot;http://semver.org&quot;&gt;control de versiones sem&amp;aacute;ntico&lt;/a&gt; (a veces llamado &lt;em&gt;SemVer&lt;/em&gt; ), que es un est&amp;aacute;ndar para escribir n&amp;uacute;meros de versi&amp;oacute;n. El n&amp;uacute;mero &lt;code&gt;0.3.14&lt;/code&gt; es en realidad una abreviatura de &lt;code&gt;^0.3.14&lt;/code&gt; , que significa &quot;cualquier versi&amp;oacute;n que tenga una API p&amp;uacute;blica compatible con la versi&amp;oacute;n 0.3.14&quot;.</target>
        </trans-unit>
        <trans-unit id="ba414d8766c29269cba8897672efd77d70e901b9" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;Cargo.toml&lt;/em&gt; file, everything that follows a header is part of a section that continues until another section starts. The &lt;code&gt;[dependencies]&lt;/code&gt; section is where you tell Cargo which external crates your project depends on and which versions of those crates you require. In this case, we&amp;rsquo;ll specify the &lt;code&gt;rand&lt;/code&gt; crate with the semantic version specifier &lt;code&gt;0.5.5&lt;/code&gt;. Cargo understands &lt;a href=&quot;http://semver.org&quot;&gt;Semantic Versioning&lt;/a&gt; (sometimes called &lt;em&gt;SemVer&lt;/em&gt;), which is a standard for writing version numbers. The number &lt;code&gt;0.5.5&lt;/code&gt; is actually shorthand for &lt;code&gt;^0.5.5&lt;/code&gt;, which means &amp;ldquo;any version that has a public API compatible with version 0.5.5.&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7177f5dba94e8e93990faf2d2454fb646d49847" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;add-one/src/lib.rs&lt;/em&gt; file, let&amp;rsquo;s add an &lt;code&gt;add_one&lt;/code&gt; function:</source>
          <target state="translated">En el archivo &lt;em&gt;add-one / src / lib.rs&lt;/em&gt; , agreguemos una funci&amp;oacute;n &lt;code&gt;add_one&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3da0b39e8b4dc5e8ab87b83cc0f936c2b1215ca7" translate="yes" xml:space="preserve">
          <source>In the above example &lt;code&gt;T&lt;/code&gt; is unknowable by the compiler. To fix this you must bind &lt;code&gt;T&lt;/code&gt; to a concrete type such as &lt;code&gt;String&lt;/code&gt; so that a generator can then be constructed:</source>
          <target state="translated">En el ejemplo anterior, el compilador no puede conocer &lt;code&gt;T&lt;/code&gt; .Para solucionar esto, debe vincular &lt;code&gt;T&lt;/code&gt; a un tipo concreto como &lt;code&gt;String&lt;/code&gt; para que luego se pueda construir un generador:</target>
        </trans-unit>
        <trans-unit id="dac108bef6e0aa0c5a3c87c1e1dd002eec20cb12" translate="yes" xml:space="preserve">
          <source>In the absolute path, we start with &lt;code&gt;crate&lt;/code&gt;, the root of our crate&amp;rsquo;s module tree. Then the &lt;code&gt;front_of_house&lt;/code&gt; module is defined in the crate root. The &lt;code&gt;front_of_house&lt;/code&gt; module isn&amp;rsquo;t public, but because the &lt;code&gt;eat_at_restaurant&lt;/code&gt; function is defined in the same module as &lt;code&gt;front_of_house&lt;/code&gt; (that is, &lt;code&gt;eat_at_restaurant&lt;/code&gt; and &lt;code&gt;front_of_house&lt;/code&gt; are siblings), we can refer to &lt;code&gt;front_of_house&lt;/code&gt; from &lt;code&gt;eat_at_restaurant&lt;/code&gt;. Next is the &lt;code&gt;hosting&lt;/code&gt; module marked with &lt;code&gt;pub&lt;/code&gt;. We can access the parent module of &lt;code&gt;hosting&lt;/code&gt;, so we can access &lt;code&gt;hosting&lt;/code&gt;. Finally, the &lt;code&gt;add_to_waitlist&lt;/code&gt; function is marked with &lt;code&gt;pub&lt;/code&gt; and we can access its parent module, so this function call works!</source>
          <target state="translated">En la ruta absoluta, comenzamos con &lt;code&gt;crate&lt;/code&gt; , la ra&amp;iacute;z del &amp;aacute;rbol de m&amp;oacute;dulos de nuestro crate. Luego, el m&amp;oacute;dulo &lt;code&gt;front_of_house&lt;/code&gt; se define en la ra&amp;iacute;z de la caja. El m&amp;oacute;dulo &lt;code&gt;front_of_house&lt;/code&gt; no es p&amp;uacute;blico, pero debido a que la funci&amp;oacute;n &lt;code&gt;eat_at_restaurant&lt;/code&gt; se define en el mismo m&amp;oacute;dulo que &lt;code&gt;front_of_house&lt;/code&gt; (es decir, &lt;code&gt;eat_at_restaurant&lt;/code&gt; y &lt;code&gt;front_of_house&lt;/code&gt; son hermanos), podemos referirnos a &lt;code&gt;front_of_house&lt;/code&gt; desde &lt;code&gt;eat_at_restaurant&lt;/code&gt; . El siguiente es el m&amp;oacute;dulo de &lt;code&gt;hosting&lt;/code&gt; marcado con &lt;code&gt;pub&lt;/code&gt; . Podemos acceder al m&amp;oacute;dulo principal de &lt;code&gt;hosting&lt;/code&gt; , por lo que podemos acceder &lt;code&gt;hosting&lt;/code&gt; .. Finalmente, la funci&amp;oacute;n &lt;code&gt;add_to_waitlist&lt;/code&gt; est&amp;aacute; marcada con &lt;code&gt;pub&lt;/code&gt; y podemos acceder a su m&amp;oacute;dulo principal, &amp;iexcl;as&amp;iacute; que esta llamada a funci&amp;oacute;n funciona!</target>
        </trans-unit>
        <trans-unit id="e8a74d26ff6bb6812e6769b94696470ac83d32c8" translate="yes" xml:space="preserve">
          <source>In the body of &lt;code&gt;largest&lt;/code&gt; we wanted to compare two values of type &lt;code&gt;T&lt;/code&gt; using the greater than (&lt;code&gt;&amp;gt;&lt;/code&gt;) operator. Because that operator is defined as a default method on the standard library trait &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt;, we need to specify &lt;code&gt;PartialOrd&lt;/code&gt; in the trait bounds for &lt;code&gt;T&lt;/code&gt; so the &lt;code&gt;largest&lt;/code&gt; function can work on slices of any type that we can compare. We don&amp;rsquo;t need to bring &lt;code&gt;PartialOrd&lt;/code&gt; into scope because it&amp;rsquo;s in the prelude. Change the signature of &lt;code&gt;largest&lt;/code&gt; to look like this:</source>
          <target state="translated">En el cuerpo de &lt;code&gt;largest&lt;/code&gt; quer&amp;iacute;amos comparar dos valores de tipo &lt;code&gt;T&lt;/code&gt; usando el operador mayor que ( &lt;code&gt;&amp;gt;&lt;/code&gt; ). Debido a que ese operador est&amp;aacute; definido como un m&amp;eacute;todo predeterminado en el rasgo est&amp;aacute;ndar de la biblioteca &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt; , necesitamos especificar &lt;code&gt;PartialOrd&lt;/code&gt; en los l&amp;iacute;mites del rasgo para &lt;code&gt;T&lt;/code&gt; para que la funci&amp;oacute;n &lt;code&gt;largest&lt;/code&gt; pueda trabajar en cortes de cualquier tipo que podamos comparar. No necesitamos traer &lt;code&gt;PartialOrd&lt;/code&gt; al alcance porque est&amp;aacute; en el preludio. Cambie la firma del &lt;code&gt;largest&lt;/code&gt; para que se vea as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="9eeb876353faccbcba2ce19feeb7d0dafe4faead" translate="yes" xml:space="preserve">
          <source>In the body of &lt;code&gt;shoes_in_my_size&lt;/code&gt;, we call &lt;code&gt;into_iter&lt;/code&gt; to create an iterator that takes ownership of the vector. Then we call &lt;code&gt;filter&lt;/code&gt; to adapt that iterator into a new iterator that only contains elements for which the closure returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">En el cuerpo de &lt;code&gt;shoes_in_my_size&lt;/code&gt; , llamamos &lt;code&gt;into_iter&lt;/code&gt; para crear un iterador que se apropie del vector. Luego, llamamos a &lt;code&gt;filter&lt;/code&gt; para adaptar ese iterador a un nuevo iterador que solo contiene elementos para los que el cierre devuelve &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ccc28c109f469220d7a0f86ba3d92af7a489d690" translate="yes" xml:space="preserve">
          <source>In the body of a generic function, methods from &lt;code&gt;Trait&lt;/code&gt; can be called on &lt;code&gt;Ty&lt;/code&gt; values. Likewise associated constants on the &lt;code&gt;Trait&lt;/code&gt; can be used.</source>
          <target state="translated">En el cuerpo de una funci&amp;oacute;n gen&amp;eacute;rica, los m&amp;eacute;todos de &lt;code&gt;Trait&lt;/code&gt; se pueden llamar en valores &lt;code&gt;Ty&lt;/code&gt; . Asimismo, se pueden usar constantes asociadas en el &lt;code&gt;Trait&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed9b56a6d3a5e9ebb3e76d9359071c31eee0aecc" translate="yes" xml:space="preserve">
          <source>In the case a &lt;code&gt;loop&lt;/code&gt; has an associated &lt;code&gt;break&lt;/code&gt;, it is not considered diverging, and the &lt;code&gt;loop&lt;/code&gt; must have a type compatible with each &lt;code&gt;break&lt;/code&gt; expression. &lt;code&gt;break&lt;/code&gt; without an expression is considered identical to &lt;code&gt;break&lt;/code&gt; with expression &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">En el caso de que un &lt;code&gt;loop&lt;/code&gt; tenga una &lt;code&gt;break&lt;/code&gt; asociada , no se considera divergente y el &lt;code&gt;loop&lt;/code&gt; debe tener un tipo compatible con cada expresi&amp;oacute;n de &lt;code&gt;break&lt;/code&gt; . &lt;code&gt;break&lt;/code&gt; sin una expresi&amp;oacute;n se considera id&amp;eacute;ntico a &lt;code&gt;break&lt;/code&gt; con expresi&amp;oacute;n &lt;code&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e9ac885fce76186450b96a37f179bf757255fd6" translate="yes" xml:space="preserve">
          <source>In the case of a &lt;a href=&quot;expressions/block-expr&quot;&gt;block expression&lt;/a&gt;, the scope for the block and the expression are the same scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57fe262eb9d9754ab04dac149861a78ef7f9cbdf" translate="yes" xml:space="preserve">
          <source>In the case of a string literal, we know the contents at compile time, so the text is hardcoded directly into the final executable. This is why string literals are fast and efficient. But these properties only come from the string literal&amp;rsquo;s immutability. Unfortunately, we can&amp;rsquo;t put a blob of memory into the binary for each piece of text whose size is unknown at compile time and whose size might change while running the program.</source>
          <target state="translated">En el caso de un literal de cadena, conocemos el contenido en el momento de la compilaci&amp;oacute;n, por lo que el texto se codifica directamente en el ejecutable final. Es por eso que los literales de cadena son r&amp;aacute;pidos y eficientes. Pero estas propiedades solo provienen de la inmutabilidad del literal de cadena. Desafortunadamente, no podemos poner una gota de memoria en el binario para cada fragmento de texto cuyo tama&amp;ntilde;o se desconoce en el momento de la compilaci&amp;oacute;n y cuyo tama&amp;ntilde;o puede cambiar mientras se ejecuta el programa.</target>
        </trans-unit>
        <trans-unit id="174ee51902d80b0fa89335cd9be3f224ff39dd4c" translate="yes" xml:space="preserve">
          <source>In the case of implicitly-wrapped overflow, implementations must provide well-defined (even if still considered erroneous) results by using two's complement overflow conventions.</source>
          <target state="translated">En el caso de un desbordamiento implícito,las implementaciones deben proporcionar resultados bien definidos (aunque todavía se consideren erróneos)mediante el uso de las convenciones de desbordamiento del complemento de dos.</target>
        </trans-unit>
        <trans-unit id="ad072c8ebb70bdab55dbb950bf9d58e7b04bb9e3" translate="yes" xml:space="preserve">
          <source>In the case where &lt;code&gt;File::open&lt;/code&gt; succeeds, the value in the variable &lt;code&gt;f&lt;/code&gt; will be an instance of &lt;code&gt;Ok&lt;/code&gt; that contains a file handle. In the case where it fails, the value in &lt;code&gt;f&lt;/code&gt; will be an instance of &lt;code&gt;Err&lt;/code&gt; that contains more information about the kind of error that happened.</source>
          <target state="translated">En el caso de que &lt;code&gt;File::open&lt;/code&gt; tenga &amp;eacute;xito, el valor de la variable &lt;code&gt;f&lt;/code&gt; ser&amp;aacute; una instancia de &lt;code&gt;Ok&lt;/code&gt; que contiene un identificador de archivo. En el caso de que falle, el valor de &lt;code&gt;f&lt;/code&gt; ser&amp;aacute; una instancia de &lt;code&gt;Err&lt;/code&gt; que contiene m&amp;aacute;s informaci&amp;oacute;n sobre el tipo de error que ocurri&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="98ff22c3c9a8db90c4e7212603caadebf4d948d5" translate="yes" xml:space="preserve">
          <source>In the code above, the function is returning data borrowed from either &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt;, but the &lt;code&gt;'a&lt;/code&gt; annotation indicates that it is returning data only from &lt;code&gt;x&lt;/code&gt;. To fix the error, the signature and the body must be made to match. Typically, this is done by updating the function signature. So, in this case, we change the type of &lt;code&gt;y&lt;/code&gt; to &lt;code&gt;&amp;amp;'a i32&lt;/code&gt;, like so:</source>
          <target state="translated">En el c&amp;oacute;digo anterior, la funci&amp;oacute;n devuelve datos tomados de &lt;code&gt;x&lt;/code&gt; o &lt;code&gt;y&lt;/code&gt; , pero la anotaci&amp;oacute;n &lt;code&gt;'a&lt;/code&gt; indica que solo devuelve datos de &lt;code&gt;x&lt;/code&gt; . Para corregir el error, la firma y el cuerpo deben coincidir. Normalmente, esto se hace actualizando la firma de la funci&amp;oacute;n. Entonces, en este caso, cambiamos el tipo de &lt;code&gt;y&lt;/code&gt; a &lt;code&gt;&amp;amp;'a i32&lt;/code&gt; , as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="47d276ce9763d36114b6391e5e3702972a6d1fd2" translate="yes" xml:space="preserve">
          <source>In the context of Listing 9-7, the &lt;code&gt;?&lt;/code&gt; at the end of the &lt;code&gt;File::open&lt;/code&gt; call will return the value inside an &lt;code&gt;Ok&lt;/code&gt; to the variable &lt;code&gt;f&lt;/code&gt;. If an error occurs, the &lt;code&gt;?&lt;/code&gt; operator will return early out of the whole function and give any &lt;code&gt;Err&lt;/code&gt; value to the calling code. The same thing applies to the &lt;code&gt;?&lt;/code&gt; at the end of the &lt;code&gt;read_to_string&lt;/code&gt; call.</source>
          <target state="translated">En el contexto del Listado 9-7, el &lt;code&gt;?&lt;/code&gt; al final de la llamada &lt;code&gt;File::open&lt;/code&gt; devolver&amp;aacute; el valor dentro de un &lt;code&gt;Ok&lt;/code&gt; a la variable &lt;code&gt;f&lt;/code&gt; . Si ocurre un error, el &lt;code&gt;?&lt;/code&gt; El operador regresar&amp;aacute; temprano de toda la funci&amp;oacute;n y dar&amp;aacute; cualquier valor &lt;code&gt;Err&lt;/code&gt; al c&amp;oacute;digo de llamada. Lo mismo se aplica a la &lt;code&gt;?&lt;/code&gt; al final de la llamada &lt;code&gt;read_to_string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c49979de4803e07d7682a6dac88ad65cf9bdcef3" translate="yes" xml:space="preserve">
          <source>In the end, this means that you may need to pair &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; with some sort of &lt;a href=&quot;index&quot;&gt;&lt;code&gt;std::sync&lt;/code&gt;&lt;/a&gt; type, usually &lt;a href=&quot;struct.mutex&quot;&gt;&lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Al final, esto significa que es posible que deba emparejar &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; con alg&amp;uacute;n tipo de &lt;a href=&quot;index&quot;&gt; &lt;code&gt;std::sync&lt;/code&gt; &lt;/a&gt; , generalmente &lt;a href=&quot;struct.mutex&quot;&gt; &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5a1b716ed41677dd2be556cd6b10193bd9fd8fb5" translate="yes" xml:space="preserve">
          <source>In the erroneous code example above, the wrong name was provided, so changing to a correct one it will fix the error. Example:</source>
          <target state="translated">En el ejemplo de código erróneo de arriba,se proporcionó el nombre equivocado,así que al cambiar a uno correcto se corregirá el error.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="a13ba9220a713242d839758de54b6d6a213f5d7c" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;closure&lt;/code&gt; is an &lt;code&gt;FnOnce&lt;/code&gt; closure whereas the &lt;code&gt;bar&lt;/code&gt; function expected an &lt;code&gt;Fn&lt;/code&gt; closure. In this case, it's simple to fix the issue, you just have to implement &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Clone&lt;/code&gt; traits on &lt;code&gt;struct X&lt;/code&gt; and it'll be ok:</source>
          <target state="translated">En el ejemplo anterior, el &lt;code&gt;closure&lt;/code&gt; es un cierre &lt;code&gt;FnOnce&lt;/code&gt; mientras que la funci&amp;oacute;n de &lt;code&gt;bar&lt;/code&gt; ra esperaba un cierre &lt;code&gt;Fn&lt;/code&gt; . En este caso, es simple solucionar el problema, solo tiene que implementar los rasgos &lt;code&gt;Copy&lt;/code&gt; y &lt;code&gt;Clone&lt;/code&gt; en la &lt;code&gt;struct X&lt;/code&gt; y estar&amp;aacute; bien:</target>
        </trans-unit>
        <trans-unit id="0a2556b76fed59d4f25e18f6058b48758d96fe76" translate="yes" xml:space="preserve">
          <source>In the example below, &lt;code&gt;name&lt;/code&gt; is moved out of &lt;code&gt;person&lt;/code&gt;, trying to use &lt;code&gt;person&lt;/code&gt; as a whole or &lt;code&gt;person.name&lt;/code&gt; would result in an error because of &lt;em&gt;partial move&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4e63cece27f012d6cb0c3b410a4800e38cdde84" translate="yes" xml:space="preserve">
          <source>In the example below, we implement a &lt;code&gt;Point&lt;/code&gt; type. Because it only stores two integers, we opt-out of ownership semantics with &lt;code&gt;Copy&lt;/code&gt;. Then we can &lt;code&gt;let p2 = p1&lt;/code&gt; without &lt;code&gt;p1&lt;/code&gt; being moved.</source>
          <target state="translated">En el siguiente ejemplo, implementamos un tipo de &lt;code&gt;Point&lt;/code&gt; . Debido a que solo almacena dos enteros, optamos por no participar en la sem&amp;aacute;ntica de propiedad con &lt;code&gt;Copy&lt;/code&gt; . Entonces podemos &lt;code&gt;let p2 = p1&lt;/code&gt; sin que &lt;code&gt;p1&lt;/code&gt; se mueva.</target>
        </trans-unit>
        <trans-unit id="c1f21adbe43e342921b2cfef575b2b17bbbed822" translate="yes" xml:space="preserve">
          <source>In the example, the type cannot have a well-defined size, because it needs to be arbitrarily large (since we would be able to nest &lt;code&gt;ListNode&lt;/code&gt;s to any depth). Specifically,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dce7e71b1b63c6637f941a4911789744e653ecbd" translate="yes" xml:space="preserve">
          <source>In the first case, the output lifetime is inferred to be the same as the unique input lifetime. In the second case, the lifetime is instead inferred to be the same as the lifetime on &lt;code&gt;&amp;amp;self&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self&lt;/code&gt;.</source>
          <target state="translated">En el primer caso, se infiere que la vida &amp;uacute;til de la salida es la misma que la vida &amp;uacute;til de la entrada &amp;uacute;nica. En el segundo caso, en cambio, se infiere que la vida es la misma que la vida en &lt;code&gt;&amp;amp;self&lt;/code&gt; o &lt;code&gt;&amp;amp;mut self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fd5720ef4de3e0fbc4e279820c08cbec7f12fa8" translate="yes" xml:space="preserve">
          <source>In the first code example, the compiler cannot infer what the type of &lt;code&gt;x&lt;/code&gt; should be: &lt;code&gt;Vec&amp;lt;char&amp;gt;&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; are both suitable candidates. To specify which type to use, you can use a type annotation on &lt;code&gt;x&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="874b3aefadd7a8d78fd78ecf2f3f7b20564e4f86" translate="yes" xml:space="preserve">
          <source>In the first example, the lowercased string is represented &lt;code&gt;&quot;cafe\u{301}&quot;&lt;/code&gt; (the last character is an acute accent &lt;a href=&quot;https://en.wikipedia.org/wiki/Combining_character&quot;&gt;combining character&lt;/a&gt;). Unlike the other characters in the string, the combining character will not get mapped to an uppercase variant, resulting in &lt;code&gt;&quot;CAFE\u{301}&quot;&lt;/code&gt;. In the second example, the lowercased string is represented &lt;code&gt;&quot;caf\u{e9}&quot;&lt;/code&gt; (the last character is a single Unicode character representing an 'e' with an acute accent). Since the last character is defined outside the scope of ASCII, it will not get mapped to an uppercase variant, resulting in &lt;code&gt;&quot;CAF\u{e9}&quot;&lt;/code&gt;.</source>
          <target state="translated">En el primer ejemplo, la cadena en min&amp;uacute;sculas se representa &lt;code&gt;&quot;cafe\u{301}&quot;&lt;/code&gt; (el &amp;uacute;ltimo car&amp;aacute;cter es un &lt;a href=&quot;https://en.wikipedia.org/wiki/Combining_character&quot;&gt;car&amp;aacute;cter de combinaci&amp;oacute;n de&lt;/a&gt; acento agudo ). A diferencia de los dem&amp;aacute;s caracteres de la cadena, el car&amp;aacute;cter de combinaci&amp;oacute;n no se asignar&amp;aacute; a una variante en may&amp;uacute;sculas, lo que dar&amp;aacute; como resultado &lt;code&gt;&quot;CAFE\u{301}&quot;&lt;/code&gt; . En el segundo ejemplo, la cadena en min&amp;uacute;sculas se representa &lt;code&gt;&quot;caf\u{e9}&quot;&lt;/code&gt; (el &amp;uacute;ltimo car&amp;aacute;cter es un &amp;uacute;nico car&amp;aacute;cter Unicode que representa una 'e' con acento agudo). Dado que el &amp;uacute;ltimo car&amp;aacute;cter est&amp;aacute; definido fuera del alcance de ASCII, no se asignar&amp;aacute; a una variante en may&amp;uacute;sculas, lo que dar&amp;aacute; como resultado &lt;code&gt;&quot;CAF\u{e9}&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e492b1a4744d12effe76c9a0dc29e53bf345ccf" translate="yes" xml:space="preserve">
          <source>In the first match expression, the value is copied (or moved). In the second match, a reference to the same memory location is bound to the variable value. This syntax is needed because in destructuring subpatterns the &lt;code&gt;&amp;amp;&lt;/code&gt; operator can't be applied to the value's fields. For example, the following is not valid:</source>
          <target state="translated">En la primera expresi&amp;oacute;n de coincidencia, el valor se copia (o mueve). En la segunda coincidencia, una referencia a la misma ubicaci&amp;oacute;n de la memoria est&amp;aacute; vinculada al valor de la variable. Esta sintaxis es necesaria porque al desestructurar subpatrones, el operador &lt;code&gt;&amp;amp;&lt;/code&gt; no se puede aplicar a los campos del valor. Por ejemplo, lo siguiente no es v&amp;aacute;lido:</target>
        </trans-unit>
        <trans-unit id="963b4be1c96ed23abf1f14a5ca37f0831c8c64ef" translate="yes" xml:space="preserve">
          <source>In the following example, we make the &lt;code&gt;call_from_c&lt;/code&gt; function accessible from C code, after it&amp;rsquo;s compiled to a shared library and linked from C:</source>
          <target state="translated">En el siguiente ejemplo, hacemos que la funci&amp;oacute;n &lt;code&gt;call_from_c&lt;/code&gt; sea accesible desde el c&amp;oacute;digo C, despu&amp;eacute;s de que se compila en una biblioteca compartida y se vincula desde C:</target>
        </trans-unit>
        <trans-unit id="ab9b978885ac92b130a921c64c6e0cb297ec938c" translate="yes" xml:space="preserve">
          <source>In the general case, collecting into &lt;code&gt;Arc&amp;lt;[T]&amp;gt;&lt;/code&gt; is done by first collecting into a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. That is, when writing the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="068c8963b2ca078d181d2b0a51e8af10dd52ecbb" translate="yes" xml:space="preserve">
          <source>In the general case, collecting into &lt;code&gt;Rc&amp;lt;[T]&amp;gt;&lt;/code&gt; is done by first collecting into a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. That is, when writing the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acbd16055f21eb6fdaf455bf26541bd9198ef8ac" translate="yes" xml:space="preserve">
          <source>In the implementation of &lt;code&gt;outline_print&lt;/code&gt;, we want to use the &lt;code&gt;Display&lt;/code&gt; trait&amp;rsquo;s functionality. Therefore, we need to specify that the &lt;code&gt;OutlinePrint&lt;/code&gt; trait will work only for types that also implement &lt;code&gt;Display&lt;/code&gt; and provide the functionality that &lt;code&gt;OutlinePrint&lt;/code&gt; needs. We can do that in the trait definition by specifying &lt;code&gt;OutlinePrint: Display&lt;/code&gt;. This technique is similar to adding a trait bound to the trait. Listing 19-22 shows an implementation of the &lt;code&gt;OutlinePrint&lt;/code&gt; trait.</source>
          <target state="translated">En la implementaci&amp;oacute;n de &lt;code&gt;outline_print&lt;/code&gt; , queremos usar la funcionalidad de &lt;code&gt;Display&lt;/code&gt; trait. Por lo tanto, debemos especificar que el rasgo &lt;code&gt;OutlinePrint&lt;/code&gt; funcionar&amp;aacute; solo para tipos que tambi&amp;eacute;n implementan &lt;code&gt;Display&lt;/code&gt; y brindan la funcionalidad que &lt;code&gt;OutlinePrint&lt;/code&gt; necesita. Podemos hacer eso en la definici&amp;oacute;n del rasgo especificando &lt;code&gt;OutlinePrint: Display&lt;/code&gt; . Esta t&amp;eacute;cnica es similar a agregar un rasgo vinculado al rasgo. El listado 19-22 muestra una implementaci&amp;oacute;n del rasgo &lt;code&gt;OutlinePrint&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81a422714f2fa87b38ce332890d1f64c8678f1a7" translate="yes" xml:space="preserve">
          <source>In the last arm, where we&amp;rsquo;ve specified a variable without a range, we do have the value available to use in the arm&amp;rsquo;s code in a variable named &lt;code&gt;id&lt;/code&gt;. The reason is that we&amp;rsquo;ve used the struct field shorthand syntax. But we haven&amp;rsquo;t applied any test to the value in the &lt;code&gt;id&lt;/code&gt; field in this arm, as we did with the first two arms: any value would match this pattern.</source>
          <target state="translated">En el &amp;uacute;ltimo brazo, donde especificamos una variable sin rango, tenemos el valor disponible para usar en el c&amp;oacute;digo del brazo en una variable llamada &lt;code&gt;id&lt;/code&gt; . La raz&amp;oacute;n es que hemos utilizado la sintaxis abreviada del campo de estructura. Pero no hemos aplicado ninguna prueba al valor en el campo &lt;code&gt;id&lt;/code&gt; en este brazo, como hicimos con los dos primeros brazos: cualquier valor coincidir&amp;iacute;a con este patr&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8a42fbeac9d5cd28add8db6a4c34d47e67684d80" translate="yes" xml:space="preserve">
          <source>In the main thread, we collect all the join handles. Then, as we did in Listing 16-2, we call &lt;code&gt;join&lt;/code&gt; on each handle to make sure all the threads finish. At that point, the main thread will acquire the lock and print the result of this program.</source>
          <target state="translated">En el hilo principal, recopilamos todos los identificadores de uni&amp;oacute;n. Luego, como hicimos en el Listado 16-2, llamamos a &lt;code&gt;join&lt;/code&gt; en cada identificador para asegurarnos de que todos los hilos terminen. En ese punto, el hilo principal adquirir&amp;aacute; el bloqueo e imprimir&amp;aacute; el resultado de este programa.</target>
        </trans-unit>
        <trans-unit id="04da7f268aa71a2c6ae0063d0f79d0cc060f8123" translate="yes" xml:space="preserve">
          <source>In the main thread, we&amp;rsquo;re not calling the &lt;code&gt;recv&lt;/code&gt; function explicitly anymore: instead, we&amp;rsquo;re treating &lt;code&gt;rx&lt;/code&gt; as an iterator. For each value received, we&amp;rsquo;re printing it. When the channel is closed, iteration will end.</source>
          <target state="translated">En el hilo principal, ya no llamamos expl&amp;iacute;citamente a la funci&amp;oacute;n &lt;code&gt;recv&lt;/code&gt; : en su lugar, tratamos a &lt;code&gt;rx&lt;/code&gt; como un iterador. Por cada valor recibido, lo imprimimos. Cuando el canal est&amp;aacute; cerrado, la iteraci&amp;oacute;n terminar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="6a6bd022f18026c156e26cea87623c8cec496bfa" translate="yes" xml:space="preserve">
          <source>In the majority of cases, ownership is clear: you know exactly which variable owns a given value. However, there are cases when a single value might have multiple owners. For example, in graph data structures, multiple edges might point to the same node, and that node is conceptually owned by all of the edges that point to it. A node shouldn&amp;rsquo;t be cleaned up unless it doesn&amp;rsquo;t have any edges pointing to it.</source>
          <target state="translated">En la mayor&amp;iacute;a de los casos, la propiedad es clara: sabes exactamente qu&amp;eacute; variable posee un valor dado. Sin embargo, hay casos en los que un &amp;uacute;nico valor puede tener varios propietarios. Por ejemplo, en las estructuras de datos de gr&amp;aacute;ficos, varios bordes pueden apuntar al mismo nodo, y ese nodo es conceptualmente propiedad de todos los bordes que apuntan a &amp;eacute;l. Un nodo no debe limpiarse a menos que no tenga ning&amp;uacute;n borde apuntando hacia &amp;eacute;l.</target>
        </trans-unit>
        <trans-unit id="b4fe9ca25f444c9952c260922e7715e70a50aab9" translate="yes" xml:space="preserve">
          <source>In the match expression for this code, we add a variable called &lt;code&gt;state&lt;/code&gt; to the pattern that matches values of the variant &lt;code&gt;Coin::Quarter&lt;/code&gt;. When a &lt;code&gt;Coin::Quarter&lt;/code&gt; matches, the &lt;code&gt;state&lt;/code&gt; variable will bind to the value of that quarter&amp;rsquo;s state. Then we can use &lt;code&gt;state&lt;/code&gt; in the code for that arm, like so:</source>
          <target state="translated">En la expresi&amp;oacute;n de coincidencia para este c&amp;oacute;digo, agregamos una variable llamada &lt;code&gt;state&lt;/code&gt; al patr&amp;oacute;n que coincide con los valores de la variante &lt;code&gt;Coin::Quarter&lt;/code&gt; . Cuando &lt;code&gt;Coin::Quarter&lt;/code&gt; coincide, la variable de &lt;code&gt;state&lt;/code&gt; se vincular&amp;aacute; al valor del estado de ese trimestre. Entonces podemos usar &lt;code&gt;state&lt;/code&gt; en el c&amp;oacute;digo para ese brazo, as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="37676c5799bfd02feed7afe648d55c20c391e411" translate="yes" xml:space="preserve">
          <source>In the matcher, &lt;code&gt;$&lt;/code&gt;&lt;em&gt;name&lt;/em&gt;&lt;code&gt;:&lt;/code&gt;&lt;em&gt;fragment-specifier&lt;/em&gt; matches a Rust syntax fragment of the kind specified and binds it to the metavariable &lt;code&gt;$&lt;/code&gt;&lt;em&gt;name&lt;/em&gt;. Valid fragment specifiers are:</source>
          <target state="translated">En el comparador, &lt;code&gt;$&lt;/code&gt; &lt;em&gt;name &lt;/em&gt; &lt;code&gt;:&lt;/code&gt; &lt;em&gt;fragment-specifier&lt;/em&gt; coincide con un fragmento de sintaxis de Rust del tipo especificado y lo vincula a la metavariable &lt;code&gt;$&lt;/code&gt; &lt;em&gt;name&lt;/em&gt; . Los especificadores de fragmentos v&amp;aacute;lidos son:</target>
        </trans-unit>
        <trans-unit id="963b3e8473b4ab06c6410ca4e20e74e946590848" translate="yes" xml:space="preserve">
          <source>In the next chapter, we&amp;rsquo;ll look at some collection data structures in the standard library that you can use in your neatly organized code.</source>
          <target state="translated">En el pr&amp;oacute;ximo cap&amp;iacute;tulo, veremos algunas estructuras de datos de colecci&amp;oacute;n en la biblioteca est&amp;aacute;ndar que puede usar en su c&amp;oacute;digo perfectamente organizado.</target>
        </trans-unit>
        <trans-unit id="62f755e3daa908e0af290719bd4bb3bcad378eef" translate="yes" xml:space="preserve">
          <source>In the output in Listing 9-2, line 12 of the backtrace points to the line in our project that&amp;rsquo;s causing the problem: line 4 of &lt;em&gt;src/main.rs&lt;/em&gt;. If we don&amp;rsquo;t want our program to panic, the location pointed to by the first line mentioning a file we wrote is where we should start investigating. In Listing 9-1, where we deliberately wrote code that would panic in order to demonstrate how to use backtraces, the way to fix the panic is to not request an element at index 99 from a vector that only contains 3 items. When your code panics in the future, you&amp;rsquo;ll need to figure out what action the code is taking with what values to cause the panic and what the code should do instead.</source>
          <target state="translated">En la salida del listado 9-2, la l&amp;iacute;nea 12 de los puntos backtrace a la l&amp;iacute;nea en nuestro proyecto que est&amp;aacute; causando el problema: la l&amp;iacute;nea 4 de &lt;em&gt;src / main.rs&lt;/em&gt; . Si no queremos que nuestro programa entre en p&amp;aacute;nico, la ubicaci&amp;oacute;n apuntada por la primera l&amp;iacute;nea que menciona un archivo que escribimos es donde debemos comenzar a investigar. En el Listado 9-1, donde deliberadamente escribimos c&amp;oacute;digo que entrar&amp;iacute;a en p&amp;aacute;nico para demostrar c&amp;oacute;mo usar backtraces, la forma de solucionar el p&amp;aacute;nico es no solicitar un elemento en el &amp;iacute;ndice 99 de un vector que solo contiene 3 elementos. Cuando su c&amp;oacute;digo entre en p&amp;aacute;nico en el futuro, deber&amp;aacute; averiguar qu&amp;eacute; acci&amp;oacute;n est&amp;aacute; tomando el c&amp;oacute;digo con qu&amp;eacute; valores causar el p&amp;aacute;nico y qu&amp;eacute; deber&amp;iacute;a hacer el c&amp;oacute;digo en su lugar.</target>
        </trans-unit>
        <trans-unit id="c97b14b94a5006f9b4ef147bf12f463db5d6141e" translate="yes" xml:space="preserve">
          <source>In the output in Listing 9-2, line 17 of the backtrace points to the line in our project that&amp;rsquo;s causing the problem: line 4 of &lt;em&gt;src/main.rs&lt;/em&gt;. If we don&amp;rsquo;t want our program to panic, the location pointed to by the first line mentioning a file we wrote is where we should start investigating. In Listing 9-1, where we deliberately wrote code that would panic in order to demonstrate how to use backtraces, the way to fix the panic is to not request an element at index 99 from a vector that only contains 3 items. When your code panics in the future, you&amp;rsquo;ll need to figure out what action the code is taking with what values to cause the panic and what the code should do instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff1955a5e30929ce37102fab2f4935897b292825" translate="yes" xml:space="preserve">
          <source>In the previous section, we looked at how the &lt;code&gt;IpAddr&lt;/code&gt; enum let us use Rust&amp;rsquo;s type system to encode more information than just the data into our program. This section explores a case study of &lt;code&gt;Option&lt;/code&gt;, which is another enum defined by the standard library. The &lt;code&gt;Option&lt;/code&gt; type is used in many places because it encodes the very common scenario in which a value could be something or it could be nothing. Expressing this concept in terms of the type system means the compiler can check whether you&amp;rsquo;ve handled all the cases you should be handling; this functionality can prevent bugs that are extremely common in other programming languages.</source>
          <target state="translated">En la secci&amp;oacute;n anterior, vimos c&amp;oacute;mo la enumeraci&amp;oacute;n &lt;code&gt;IpAddr&lt;/code&gt; nos permiti&amp;oacute; usar el sistema de tipos de Rust para codificar m&amp;aacute;s informaci&amp;oacute;n que solo los datos en nuestro programa. Esta secci&amp;oacute;n explora un estudio de caso de &lt;code&gt;Option&lt;/code&gt; , que es otra enumeraci&amp;oacute;n definida por la biblioteca est&amp;aacute;ndar. El tipo &lt;code&gt;Option&lt;/code&gt; se usa en muchos lugares porque codifica el escenario muy com&amp;uacute;n en el que un valor podr&amp;iacute;a ser algo o podr&amp;iacute;a ser nada. Expresar este concepto en t&amp;eacute;rminos del sistema de tipos significa que el compilador puede verificar si ha manejado todos los casos que deber&amp;iacute;a estar manejando; esta funcionalidad puede prevenir errores que son extremadamente comunes en otros lenguajes de programaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7166e371e82ca092dfca006916f5e7d27ed3dcc0" translate="yes" xml:space="preserve">
          <source>In the previous section, we wanted to get the inner &lt;code&gt;T&lt;/code&gt; value out of the &lt;code&gt;Some&lt;/code&gt; case when using &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;; we can also handle &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; using &lt;code&gt;match&lt;/code&gt; as we did with the &lt;code&gt;Coin&lt;/code&gt; enum! Instead of comparing coins, we&amp;rsquo;ll compare the variants of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;, but the way that the &lt;code&gt;match&lt;/code&gt; expression works remains the same.</source>
          <target state="translated">En la secci&amp;oacute;n anterior, quer&amp;iacute;amos obtener el valor &lt;code&gt;T&lt;/code&gt; interno del caso &lt;code&gt;Some&lt;/code&gt; cuando usamos &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; ; &amp;iexcl;tambi&amp;eacute;n podemos manejar &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; usando &lt;code&gt;match&lt;/code&gt; como hicimos con la enumeraci&amp;oacute;n &lt;code&gt;Coin&lt;/code&gt; ! En lugar de comparar monedas, compararemos las variantes de &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; , pero la forma en que funciona la expresi&amp;oacute;n de &lt;code&gt;match&lt;/code&gt; sigue siendo la misma.</target>
        </trans-unit>
        <trans-unit id="021531d5da5d15cfe5b7187998d391941c64c620" translate="yes" xml:space="preserve">
          <source>In the relative path, the logic is the same as the absolute path except for the first step: rather than starting from the crate root, the path starts from &lt;code&gt;front_of_house&lt;/code&gt;. The &lt;code&gt;front_of_house&lt;/code&gt; module is defined within the same module as &lt;code&gt;eat_at_restaurant&lt;/code&gt;, so the relative path starting from the module in which &lt;code&gt;eat_at_restaurant&lt;/code&gt; is defined works. Then, because &lt;code&gt;hosting&lt;/code&gt; and &lt;code&gt;add_to_waitlist&lt;/code&gt; are marked with &lt;code&gt;pub&lt;/code&gt;, the rest of the path works, and this function call is valid!</source>
          <target state="translated">En la ruta relativa, la l&amp;oacute;gica es la misma que la ruta absoluta excepto por el primer paso: en lugar de comenzar desde la ra&amp;iacute;z de la caja, la ruta comienza desde &lt;code&gt;front_of_house&lt;/code&gt; . El m&amp;oacute;dulo &lt;code&gt;front_of_house&lt;/code&gt; se define dentro del mismo m&amp;oacute;dulo que &lt;code&gt;eat_at_restaurant&lt;/code&gt; , por lo que funciona la ruta relativa a partir del m&amp;oacute;dulo en el que se define &lt;code&gt;eat_at_restaurant&lt;/code&gt; . Entonces, debido a que &lt;code&gt;hosting&lt;/code&gt; y &lt;code&gt;add_to_waitlist&lt;/code&gt; est&amp;aacute;n marcados con &lt;code&gt;pub&lt;/code&gt; , el resto de la ruta funciona, &amp;iexcl;y esta llamada de funci&amp;oacute;n es v&amp;aacute;lida!</target>
        </trans-unit>
        <trans-unit id="34eddaeb0b0b8fe0265b13cd54b792a68e5d0a8d" translate="yes" xml:space="preserve">
          <source>In the restaurant industry, some parts of a restaurant are referred to as &lt;em&gt;front of house&lt;/em&gt; and others as &lt;em&gt;back of house&lt;/em&gt;. Front of house is where customers are; this is where hosts seat customers, servers take orders and payment, and bartenders make drinks. Back of house is where the chefs and cooks work in the kitchen, dishwashers clean up, and managers do administrative work.</source>
          <target state="translated">En la industria de los restaurantes, algunas partes de un restaurante se conocen como parte &lt;em&gt;delantera de la casa&lt;/em&gt; y otras como parte &lt;em&gt;trasera de la casa&lt;/em&gt; . El frente de la casa es donde est&amp;aacute;n los clientes; aqu&amp;iacute; es donde los anfitriones sientan a los clientes, los meseros toman los pedidos y el pago y los camareros preparan las bebidas. La parte trasera de la casa es donde los chefs y cocineros trabajan en la cocina, los lavavajillas limpian y los gerentes hacen el trabajo administrativo.</target>
        </trans-unit>
        <trans-unit id="d2fbd57442ab7172a121e226a86228020af2eb14" translate="yes" xml:space="preserve">
          <source>In the second &lt;code&gt;use&lt;/code&gt; statement, we chose the new name &lt;code&gt;IoResult&lt;/code&gt; for the &lt;code&gt;std::io::Result&lt;/code&gt; type, which won&amp;rsquo;t conflict with the &lt;code&gt;Result&lt;/code&gt; from &lt;code&gt;std::fmt&lt;/code&gt; that we&amp;rsquo;ve also brought into scope. Listing 7-15 and Listing 7-16 are considered idiomatic, so the choice is up to you!</source>
          <target state="translated">En la segunda declaraci&amp;oacute;n de &lt;code&gt;use&lt;/code&gt; , elegimos el nuevo nombre &lt;code&gt;IoResult&lt;/code&gt; para el tipo &lt;code&gt;std::io::Result&lt;/code&gt; , que no entrar&amp;aacute; en conflicto con el &lt;code&gt;Result&lt;/code&gt; de &lt;code&gt;std::fmt&lt;/code&gt; que tambi&amp;eacute;n hemos incluido en el alcance. El Listado 7-15 y el Listado 7-16 se consideran idiom&amp;aacute;ticos, &amp;iexcl;as&amp;iacute; que la elecci&amp;oacute;n depende de usted!</target>
        </trans-unit>
        <trans-unit id="adc1d9d12c1d2bddf332118061c6c7cd3ce7bb85" translate="yes" xml:space="preserve">
          <source>In the second arm, where we only have a range specified in the pattern, the code associated with the arm doesn&amp;rsquo;t have a variable that contains the actual value of the &lt;code&gt;id&lt;/code&gt; field. The &lt;code&gt;id&lt;/code&gt; field&amp;rsquo;s value could have been 10, 11, or 12, but the code that goes with that pattern doesn&amp;rsquo;t know which it is. The pattern code isn&amp;rsquo;t able to use the value from the &lt;code&gt;id&lt;/code&gt; field, because we haven&amp;rsquo;t saved the &lt;code&gt;id&lt;/code&gt; value in a variable.</source>
          <target state="translated">En el segundo brazo, donde solo tenemos un rango especificado en el patr&amp;oacute;n, el c&amp;oacute;digo asociado con el brazo no tiene una variable que contenga el valor real del campo &lt;code&gt;id&lt;/code&gt; . El valor del campo &lt;code&gt;id&lt;/code&gt; podr&amp;iacute;a haber sido 10, 11 o 12, pero el c&amp;oacute;digo que acompa&amp;ntilde;a a ese patr&amp;oacute;n no sabe cu&amp;aacute;l es. El c&amp;oacute;digo de patr&amp;oacute;n no puede usar el valor del campo &lt;code&gt;id&lt;/code&gt; , porque no hemos guardado el valor &lt;code&gt;id&lt;/code&gt; en una variable.</target>
        </trans-unit>
        <trans-unit id="555ee2d5bf80e581edd3155ac1632a3804b80f34" translate="yes" xml:space="preserve">
          <source>In the second case, it mentions that a private item &quot;can be accessed&quot; by the current module and its descendants, but the exact meaning of accessing an item depends on what the item is. Accessing a module, for example, would mean looking inside of it (to import more items). On the other hand, accessing a function would mean that it is invoked. Additionally, path expressions and import statements are considered to access an item in the sense that the import/expression is only valid if the destination is in the current visibility scope.</source>
          <target state="translated">En el segundo caso,menciona que un elemento privado &quot;puede ser accedido&quot; por el módulo actual y sus descendientes,pero el significado exacto de acceder a un elemento depende de lo que sea el elemento.Acceder a un módulo,por ejemplo,significaría mirar dentro de él (para importar más artículos).Por otra parte,acceder a una función significaría que se la invoca.Además,se considera que las expresiones de ruta y las declaraciones de importación acceden a un artículo en el sentido de que la importación/expresión sólo es válida si el destino se encuentra en el ámbito de visibilidad actual.</target>
        </trans-unit>
        <trans-unit id="16e34afb2acb9f1c8b1247e4ecd62d975388d5ff" translate="yes" xml:space="preserve">
          <source>In the second error, we tried to bind the &lt;code&gt;Jak&lt;/code&gt; enum directly, which is not possible: you can only bind one of its variants. To do so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75974ca9e444bb30cc1d72502f982a23696566b5" translate="yes" xml:space="preserve">
          <source>In the second error, you can't implement something on an item, only on types. We would need to create a new type if we wanted to do something similar:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3e1b0f0f7f1d23b0a9789a638c11ce7f83e6698" translate="yes" xml:space="preserve">
          <source>In the second you can do it by simply removing &lt;code&gt;'b&lt;/code&gt; so they both use &lt;code&gt;'a&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde08af4b5bbaaf0718281f4cc2fdcf3ef098583" translate="yes" xml:space="preserve">
          <source>In the signature for &lt;code&gt;area&lt;/code&gt;, we use &lt;code&gt;&amp;amp;self&lt;/code&gt; instead of &lt;code&gt;rectangle: &amp;amp;Rectangle&lt;/code&gt; because Rust knows the type of &lt;code&gt;self&lt;/code&gt; is &lt;code&gt;Rectangle&lt;/code&gt; due to this method&amp;rsquo;s being inside the &lt;code&gt;impl Rectangle&lt;/code&gt; context. Note that we still need to use the &lt;code&gt;&amp;amp;&lt;/code&gt; before &lt;code&gt;self&lt;/code&gt;, just as we did in &lt;code&gt;&amp;amp;Rectangle&lt;/code&gt;. Methods can take ownership of &lt;code&gt;self&lt;/code&gt;, borrow &lt;code&gt;self&lt;/code&gt; immutably as we&amp;rsquo;ve done here, or borrow &lt;code&gt;self&lt;/code&gt; mutably, just as they can any other parameter.</source>
          <target state="translated">En la firma para el &lt;code&gt;area&lt;/code&gt; , usamos &lt;code&gt;&amp;amp;self&lt;/code&gt; lugar de &lt;code&gt;rectangle: &amp;amp;Rectangle&lt;/code&gt; porque Rust sabe que el tipo de &lt;code&gt;self&lt;/code&gt; es &lt;code&gt;Rectangle&lt;/code&gt; debido a que este m&amp;eacute;todo est&amp;aacute; dentro del contexto &lt;code&gt;impl Rectangle&lt;/code&gt; . Tenga en cuenta que todav&amp;iacute;a necesitamos usar &lt;code&gt;&amp;amp;&lt;/code&gt; antes de &lt;code&gt;self&lt;/code&gt; , tal como lo hicimos en &lt;code&gt;&amp;amp;Rectangle&lt;/code&gt; . Los m&amp;eacute;todos pueden tomar posesi&amp;oacute;n de &lt;code&gt;self&lt;/code&gt; , tomar prestado &lt;code&gt;self&lt;/code&gt; inmutable como lo hemos hecho aqu&amp;iacute;, o tomar prestado &lt;code&gt;self&lt;/code&gt; mutante, al igual que cualquier otro par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="15bf74e663ebaabe244e5b40c6c296178b0d40e8" translate="yes" xml:space="preserve">
          <source>In the standard library, pointer types generally do not have structural pinning, and thus they do not offer pinning projections. This is why &lt;code&gt;Box&amp;lt;T&amp;gt;: Unpin&lt;/code&gt; holds for all &lt;code&gt;T&lt;/code&gt;. It makes sense to do this for pointer types, because moving the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; does not actually move the &lt;code&gt;T&lt;/code&gt;: the &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; can be freely movable (aka &lt;code&gt;Unpin&lt;/code&gt;) even if the &lt;code&gt;T&lt;/code&gt; is not. In fact, even &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; and &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; are always &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; themselves, for the same reason: their contents (the &lt;code&gt;T&lt;/code&gt;) are pinned, but the pointers themselves can be moved without moving the pinned data. For both &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;, whether the content is pinned is entirely independent of whether the pointer is pinned, meaning pinning is &lt;em&gt;not&lt;/em&gt; structural.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b01eb539066ab2d6a68111a77de7d3391be1abdf" translate="yes" xml:space="preserve">
          <source>In the standard library, pointer types generally do not have structural pinning, and thus they do not offer pinning projections. This is why &lt;code&gt;Box&amp;lt;T&amp;gt;: Unpin&lt;/code&gt; holds for all &lt;code&gt;T&lt;/code&gt;. It makes sense to do this for pointer types, because moving the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; does not actually move the &lt;code&gt;T&lt;/code&gt;: the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; can be freely movable (aka &lt;code&gt;Unpin&lt;/code&gt;) even if the &lt;code&gt;T&lt;/code&gt; is not. In fact, even &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;Pin&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; are always &lt;code&gt;Unpin&lt;/code&gt; themselves, for the same reason: their contents (the &lt;code&gt;T&lt;/code&gt;) are pinned, but the pointers themselves can be moved without moving the pinned data. For both &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;, whether the content is pinned is entirely independent of whether the pointer is pinned, meaning pinning is &lt;em&gt;not&lt;/em&gt; structural.</source>
          <target state="translated">En la biblioteca est&amp;aacute;ndar, los tipos de puntero generalmente no tienen fijaci&amp;oacute;n estructural y, por lo tanto, no ofrecen proyecciones de fijaci&amp;oacute;n. Esta es la raz&amp;oacute;n por &lt;code&gt;Box&amp;lt;T&amp;gt;: Unpin&lt;/code&gt; se mantiene para todos los &lt;code&gt;T&lt;/code&gt; . Tiene sentido hacer esto para los tipos de puntero, porque mover la &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; no mueve realmente la &lt;code&gt;T&lt;/code&gt; : la &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; puede moverse libremente (tambi&amp;eacute;n &lt;code&gt;Unpin&lt;/code&gt; como Desanclar ) incluso si la &lt;code&gt;T&lt;/code&gt; no lo es. De hecho, incluso el &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; y el &lt;code&gt;Pin&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; siempre se &lt;code&gt;Unpin&lt;/code&gt; , por la misma raz&amp;oacute;n: su contenido (la &lt;code&gt;T&lt;/code&gt; ) est&amp;aacute; anclado, pero los punteros en s&amp;iacute; se pueden mover sin mover los datos anclados. Para ambos &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; y &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; , si el contenido est&amp;aacute; anclado es totalmente independiente de si el puntero est&amp;aacute; anclado, lo que significa que la fijaci&amp;oacute;n &lt;em&gt;no&lt;/em&gt; es estructural.</target>
        </trans-unit>
        <trans-unit id="69a1bd27469eb2f59075cae2a36951b2f4c30b0e" translate="yes" xml:space="preserve">
          <source>In the test, we&amp;rsquo;re testing what happens when the &lt;code&gt;LimitTracker&lt;/code&gt; is told to set &lt;code&gt;value&lt;/code&gt; to something that is more than 75 percent of the &lt;code&gt;max&lt;/code&gt; value. First, we create a new &lt;code&gt;MockMessenger&lt;/code&gt;, which will start with an empty list of messages. Then we create a new &lt;code&gt;LimitTracker&lt;/code&gt; and give it a reference to the new &lt;code&gt;MockMessenger&lt;/code&gt; and a &lt;code&gt;max&lt;/code&gt; value of 100. We call the &lt;code&gt;set_value&lt;/code&gt; method on the &lt;code&gt;LimitTracker&lt;/code&gt; with a value of 80, which is more than 75 percent of 100. Then we assert that the list of messages that the &lt;code&gt;MockMessenger&lt;/code&gt; is keeping track of should now have one message in it.</source>
          <target state="translated">En la prueba, estamos probando lo que sucede cuando se le dice al &lt;code&gt;LimitTracker&lt;/code&gt; que establezca un &lt;code&gt;value&lt;/code&gt; en algo que sea m&amp;aacute;s del 75 por ciento del valor &lt;code&gt;max&lt;/code&gt; . Primero, creamos un nuevo &lt;code&gt;MockMessenger&lt;/code&gt; , que comenzar&amp;aacute; con una lista vac&amp;iacute;a de mensajes. Luego creamos un nuevo &lt;code&gt;LimitTracker&lt;/code&gt; y le damos una referencia al nuevo &lt;code&gt;MockMessenger&lt;/code&gt; y un valor &lt;code&gt;max&lt;/code&gt; de 100. Llamamos al m&amp;eacute;todo &lt;code&gt;set_value&lt;/code&gt; en el &lt;code&gt;LimitTracker&lt;/code&gt; con un valor de 80, que es m&amp;aacute;s del 75 por ciento de 100. Luego afirmamos que el La lista de mensajes de los que &lt;code&gt;MockMessenger&lt;/code&gt; est&amp;aacute; realizando un seguimiento ahora deber&amp;iacute;a tener un mensaje.</target>
        </trans-unit>
        <trans-unit id="adba8ce512afb3223e0e44bbc4efd34311d66e90" translate="yes" xml:space="preserve">
          <source>In the third case, we tried to only expect one variant of the &lt;code&gt;Wizard&lt;/code&gt; enum, which is not possible. To make this work, we need to using pattern matching over the &lt;code&gt;Wizard&lt;/code&gt; enum:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fe4d3d8b095874ffa846390a6fba933c59176e6" translate="yes" xml:space="preserve">
          <source>In the transcriber, metavariables are referred to simply by &lt;code&gt;$&lt;/code&gt;&lt;em&gt;name&lt;/em&gt;, since the fragment kind is specified in the matcher. Metavariables are replaced with the syntax element that matched them. The keyword metavariable &lt;code&gt;$crate&lt;/code&gt; can be used to refer to the current crate; see &lt;a href=&quot;#hygiene&quot;&gt;Hygiene&lt;/a&gt; below. Metavariables can be transcribed more than once or not at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="474cfc53c29ed4a7f5438f6a16ce96a820777966" translate="yes" xml:space="preserve">
          <source>In the transcriber, metavariables are referred to simply by &lt;code&gt;$&lt;/code&gt;&lt;em&gt;name&lt;/em&gt;, since the fragment kind is specified in the matcher. Metavariables are replaced with the syntax element that matched them. The keyword metavariable &lt;code&gt;$crate&lt;/code&gt; can be used to refer to the current crate; see &lt;a href=&quot;macros-by-example#hygiene&quot;&gt;Hygiene&lt;/a&gt; below. Metavariables can be transcribed more than once or not at all.</source>
          <target state="translated">En el transcriptor, las metavariables se denominan simplemente por &lt;code&gt;$&lt;/code&gt; &lt;em&gt;name&lt;/em&gt; , ya que el tipo de fragmento se especifica en el comparador. Las metavariables se reemplazan con el elemento de sintaxis que las empareja. La palabra clave metavariable &lt;code&gt;$crate&lt;/code&gt; puede usarse para referirse a la caja actual; consulte &lt;a href=&quot;macros-by-example#hygiene&quot;&gt;Higiene a&lt;/a&gt; continuaci&amp;oacute;n. Las metavariables se pueden transcribir m&amp;aacute;s de una vez o no se pueden transcribir en absoluto.</target>
        </trans-unit>
        <trans-unit id="fc28b1beae2c194779de6e426a53754bfb37f82e" translate="yes" xml:space="preserve">
          <source>In the workout generator example, we only used closures as inline anonymous functions. However, closures have an additional capability that functions don&amp;rsquo;t have: they can capture their environment and access variables from the scope in which they&amp;rsquo;re defined.</source>
          <target state="translated">En el ejemplo del generador de ejercicios, solo usamos cierres como funciones an&amp;oacute;nimas en l&amp;iacute;nea. Sin embargo, los cierres tienen una capacidad adicional que las funciones no tienen: pueden capturar su entorno y acceder a las variables desde el &amp;aacute;mbito en el que est&amp;aacute;n definidos.</target>
        </trans-unit>
        <trans-unit id="402986500120f551bc8e41d90bdabaccacec9185" translate="yes" xml:space="preserve">
          <source>In the worst case, the algorithm allocates temporary storage in a &lt;code&gt;Vec&amp;lt;(K, usize)&amp;gt;&lt;/code&gt; the length of the slice.</source>
          <target state="translated">En el peor de los casos, el algoritmo asigna almacenamiento temporal en un &lt;code&gt;Vec&amp;lt;(K, usize)&amp;gt;&lt;/code&gt; la longitud del segmento.</target>
        </trans-unit>
        <trans-unit id="2792c27ad83efd64abffe24df3a1fb1485fd08bf" translate="yes" xml:space="preserve">
          <source>In these examples, types of the &lt;code&gt;ba*&lt;/code&gt; are found by LUB coercion. And the compiler checks whether LUB coercion result of &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt; is &lt;code&gt;i32&lt;/code&gt; in the processing of the function &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bc14d5532165c49508408bd484b7e97e6ac2646" translate="yes" xml:space="preserve">
          <source>In this appendix, we provide a reference of all the traits in the standard library that you can use with &lt;code&gt;derive&lt;/code&gt;. Each section covers:</source>
          <target state="translated">En este ap&amp;eacute;ndice, proporcionamos una referencia de todos los rasgos en la biblioteca est&amp;aacute;ndar que puede usar con &lt;code&gt;derive&lt;/code&gt; . Cada secci&amp;oacute;n cubre:</target>
        </trans-unit>
        <trans-unit id="0046a6cf07943993e17ce12f3c78298391a2264f" translate="yes" xml:space="preserve">
          <source>In this appendix, we talk about some useful development tools that the Rust project provides. We&amp;rsquo;ll look at automatic formatting, quick ways to apply warning fixes, a linter, and integrating with IDEs.</source>
          <target state="translated">En este ap&amp;eacute;ndice, hablamos sobre algunas herramientas de desarrollo &amp;uacute;tiles que proporciona el proyecto Rust. Veremos el formato autom&amp;aacute;tico, las formas r&amp;aacute;pidas de aplicar correcciones de advertencia, un linter y la integraci&amp;oacute;n con IDE.</target>
        </trans-unit>
        <trans-unit id="ac9b1080783742689a97db16c3344339516e90c0" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;Foo&lt;/code&gt; is undefined, so it inherently isn't anything, and definitely not a struct.</source>
          <target state="translated">En este caso, &lt;code&gt;Foo&lt;/code&gt; no est&amp;aacute; definido, por lo que inherentemente no es nada y definitivamente no es una estructura.</target>
        </trans-unit>
        <trans-unit id="afe608724d7fcb6b165ca3da57f4af8c6e2f8834" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;Question&lt;/code&gt; would need to implement the &lt;code&gt;std::ops::Not&lt;/code&gt; trait in order to be able to use &lt;code&gt;!&lt;/code&gt; on it. Let's implement it:</source>
          <target state="translated">En este caso, &lt;code&gt;Question&lt;/code&gt; necesitar&amp;iacute;a implementar el rasgo &lt;code&gt;std::ops::Not&lt;/code&gt; para poder usar &lt;code&gt;!&lt;/code&gt; en eso. Implement&amp;eacute;moslo:</target>
        </trans-unit>
        <trans-unit id="4b7473dc279144e44448cca5746abb04e0fa8694" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;c_double&lt;/code&gt; has the same size as &lt;code&gt;f64&lt;/code&gt; so we can use it directly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3b4ba6190447ccb2a7d84efd7c0391f36cf1b3c" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;foo&lt;/code&gt; is defined, but is not a struct, so Rust can't use it as one.</source>
          <target state="translated">En este caso, &lt;code&gt;foo&lt;/code&gt; est&amp;aacute; definido, pero no es una estructura, por lo que Rust no puede usarlo como uno.</target>
        </trans-unit>
        <trans-unit id="e3897adfb1b49645b05c0b83e391e1fc19ac894e" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;len&lt;/code&gt; will be 4, which means the vector storing the string &amp;ldquo;Hola&amp;rdquo; is 4 bytes long. Each of these letters takes 1 byte when encoded in UTF-8. But what about the following line? (Note that this string begins with the capital Cyrillic letter Ze, not the Arabic number 3.)</source>
          <target state="translated">En este caso, &lt;code&gt;len&lt;/code&gt; ser&amp;aacute; 4, lo que significa que el vector que almacena la cadena &quot;Hola&quot; tiene 4 bytes de longitud. Cada una de estas letras ocupa 1 byte cuando se codifica en UTF-8. Pero, &amp;iquest;qu&amp;eacute; pasa con la siguiente l&amp;iacute;nea? (Tenga en cuenta que esta cadena comienza con la letra cir&amp;iacute;lica may&amp;uacute;scula Ze, no el n&amp;uacute;mero ar&amp;aacute;bigo 3).</target>
        </trans-unit>
        <trans-unit id="8561b972a9830d06a3e257ff13fef28acb8d1808" translate="yes" xml:space="preserve">
          <source>In this case, borrowing &lt;code&gt;x&lt;/code&gt; mutably is not possible, because &lt;code&gt;x&lt;/code&gt; is not &lt;code&gt;mut&lt;/code&gt;. But at the same time, borrowing &lt;code&gt;x&lt;/code&gt; immutably would make the assignment illegal, because a &lt;code&gt;&amp;amp; &amp;amp;mut&lt;/code&gt; reference may not be unique, so it cannot safely be used to modify a value. So a unique immutable borrow is used: it borrows &lt;code&gt;x&lt;/code&gt; immutably, but like a mutable borrow, it must be unique. In the above example, uncommenting the declaration of &lt;code&gt;y&lt;/code&gt; will produce an error because it would violate the uniqueness of the closure's borrow of &lt;code&gt;x&lt;/code&gt;; the declaration of z is valid because the closure's lifetime has expired at the end of the block, releasing the borrow.</source>
          <target state="translated">En este caso, no es posible tomar prestado &lt;code&gt;x&lt;/code&gt; de manera mutante, porque &lt;code&gt;x&lt;/code&gt; no es &lt;code&gt;mut&lt;/code&gt; . Pero al mismo tiempo, tomar prestado &lt;code&gt;x&lt;/code&gt; de manera inmutable har&amp;iacute;a ilegal la asignaci&amp;oacute;n, porque una referencia &lt;code&gt;&amp;amp; &amp;amp;mut&lt;/code&gt; puede no ser &amp;uacute;nica, por lo que no se puede usar de manera segura para modificar un valor. Por tanto, se utiliza un pr&amp;eacute;stamo &amp;uacute;nico e inmutable: se pide prestado &lt;code&gt;x&lt;/code&gt; inmutablemente, pero como un pr&amp;eacute;stamo mutable, debe ser &amp;uacute;nico. En el ejemplo anterior, descomentar la declaraci&amp;oacute;n de &lt;code&gt;y&lt;/code&gt; producir&amp;aacute; un error porque violar&amp;iacute;a la unicidad del pr&amp;eacute;stamo de &lt;code&gt;x&lt;/code&gt; del cierre ; la declaraci&amp;oacute;n de z es v&amp;aacute;lida porque la vida &amp;uacute;til del cierre ha expirado al final del bloque, liberando el pr&amp;eacute;stamo.</target>
        </trans-unit>
        <trans-unit id="bf5da830ba52c31b3f48f71542b74085fca253da" translate="yes" xml:space="preserve">
          <source>In this case, right after we create the reference cycle, the program ends. The consequences of this cycle aren&amp;rsquo;t very dire. However, if a more complex program allocated lots of memory in a cycle and held onto it for a long time, the program would use more memory than it needed and might overwhelm the system, causing it to run out of available memory.</source>
          <target state="translated">En este caso, justo despu&amp;eacute;s de crear el ciclo de referencia, el programa finaliza. Las consecuencias de este ciclo no son muy graves. Sin embargo, si un programa m&amp;aacute;s complejo asign&amp;oacute; mucha memoria en un ciclo y la retuvo durante mucho tiempo, el programa usar&amp;iacute;a m&amp;aacute;s memoria de la que necesitaba y podr&amp;iacute;a sobrecargar el sistema, provocando que se quedara sin memoria disponible.</target>
        </trans-unit>
        <trans-unit id="94ade146c6864efc0d837c6a05c5b82eb67849f1" translate="yes" xml:space="preserve">
          <source>In this case, the compiler cannot infer what the type of &lt;code&gt;x&lt;/code&gt; should be: &lt;code&gt;Vec&amp;lt;char&amp;gt;&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; are both suitable candidates. To specify which type to use, you can use a type annotation on &lt;code&gt;x&lt;/code&gt;:</source>
          <target state="translated">En este caso, el compilador no puede inferir cu&amp;aacute;l deber&amp;iacute;a ser el tipo de &lt;code&gt;x&lt;/code&gt; : &lt;code&gt;Vec&amp;lt;char&amp;gt;&lt;/code&gt; y &lt;code&gt;String&lt;/code&gt; son candidatos adecuados. Para especificar qu&amp;eacute; tipo usar, puede usar una anotaci&amp;oacute;n de tipo en &lt;code&gt;x&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f275640cc613a55c1aac0d980097965aad345a42" translate="yes" xml:space="preserve">
          <source>In this case, the line indicated is part of our code, and if we go to that line, we see the &lt;code&gt;panic!&lt;/code&gt; macro call. In other cases, the &lt;code&gt;panic!&lt;/code&gt; call might be in code that our code calls, and the filename and line number reported by the error message will be someone else&amp;rsquo;s code where the &lt;code&gt;panic!&lt;/code&gt; macro is called, not the line of our code that eventually led to the &lt;code&gt;panic!&lt;/code&gt; call. We can use the backtrace of the functions the &lt;code&gt;panic!&lt;/code&gt; call came from to figure out the part of our code that is causing the problem. We&amp;rsquo;ll discuss what a backtrace is in more detail next.</source>
          <target state="translated">En este caso, la l&amp;iacute;nea indicada es parte de nuestro c&amp;oacute;digo, y si vamos a esa l&amp;iacute;nea, &amp;iexcl;vemos el &lt;code&gt;panic!&lt;/code&gt; llamada macro. En otros casos, &amp;iexcl;el &lt;code&gt;panic!&lt;/code&gt; La llamada puede estar en el c&amp;oacute;digo que llama nuestro c&amp;oacute;digo, y el nombre de archivo y el n&amp;uacute;mero de l&amp;iacute;nea informado por el mensaje de error ser&amp;aacute; el c&amp;oacute;digo de otra persona donde el &lt;code&gt;panic!&lt;/code&gt; se llama macro, no la l&amp;iacute;nea de nuestro c&amp;oacute;digo que eventualmente llev&amp;oacute; al &lt;code&gt;panic!&lt;/code&gt; llamada. &amp;iexcl;Podemos usar el seguimiento de las funciones del &lt;code&gt;panic!&lt;/code&gt; provino de la llamada para averiguar la parte de nuestro c&amp;oacute;digo que est&amp;aacute; causando el problema. A continuaci&amp;oacute;n, analizaremos con m&amp;aacute;s detalle qu&amp;eacute; es un backtrace.</target>
        </trans-unit>
        <trans-unit id="a03c0650d25cf706ca4c711a0b4fa0c7cdd46367" translate="yes" xml:space="preserve">
          <source>In this case, you need to implement the &lt;code&gt;chocolate&lt;/code&gt; method to fix the error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dfdeb564b13d0de24ae4a70c8a6c9f64176934b" translate="yes" xml:space="preserve">
          <source>In this chapter and throughout the book, we&amp;rsquo;ll show some commands used in the terminal. Lines that you should enter in a terminal all start with &lt;code&gt;$&lt;/code&gt;. You don&amp;rsquo;t need to type in the &lt;code&gt;$&lt;/code&gt; character; it indicates the start of each command. Lines that don&amp;rsquo;t start with &lt;code&gt;$&lt;/code&gt; typically show the output of the previous command. Additionally, PowerShell-specific examples will use &lt;code&gt;&amp;gt;&lt;/code&gt; rather than &lt;code&gt;$&lt;/code&gt;.</source>
          <target state="translated">En este cap&amp;iacute;tulo y a lo largo del libro, mostraremos algunos comandos utilizados en la terminal. Todas las l&amp;iacute;neas que debe ingresar en una terminal comienzan con &lt;code&gt;$&lt;/code&gt; . No es necesario escribir el car&amp;aacute;cter &lt;code&gt;$&lt;/code&gt; ; indica el inicio de cada comando. Las l&amp;iacute;neas que no comienzan con &lt;code&gt;$&lt;/code&gt; suelen mostrar el resultado del comando anterior. Adem&amp;aacute;s, los ejemplos espec&amp;iacute;ficos de PowerShell usar&amp;aacute;n &lt;code&gt;&amp;gt;&lt;/code&gt; en lugar de &lt;code&gt;$&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f1d6f9bd53aa4df418aa201b887fdd6df55aeab" translate="yes" xml:space="preserve">
          <source>In this chapter we&amp;rsquo;ll look at &lt;em&gt;enumerations&lt;/em&gt;, also referred to as &lt;em&gt;enums&lt;/em&gt;. Enums allow you to define a type by enumerating its possible &lt;em&gt;variants&lt;/em&gt;. First, we&amp;rsquo;ll define and use an enum to show how an enum can encode meaning along with data. Next, we&amp;rsquo;ll explore a particularly useful enum, called &lt;code&gt;Option&lt;/code&gt;, which expresses that a value can be either something or nothing. Then we&amp;rsquo;ll look at how pattern matching in the &lt;code&gt;match&lt;/code&gt; expression makes it easy to run different code for different values of an enum. Finally, we&amp;rsquo;ll cover how the &lt;code&gt;if let&lt;/code&gt; construct is another convenient and concise idiom available to you to handle enums in your code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="511940d9b79e52eebc6c566f728bbaeb0dd1dd34" translate="yes" xml:space="preserve">
          <source>In this chapter we&amp;rsquo;ll look at &lt;em&gt;enumerations&lt;/em&gt;, also referred to as &lt;em&gt;enums&lt;/em&gt;. Enums allow you to define a type by enumerating its possible values. First, we&amp;rsquo;ll define and use an enum to show how an enum can encode meaning along with data. Next, we&amp;rsquo;ll explore a particularly useful enum, called &lt;code&gt;Option&lt;/code&gt;, which expresses that a value can be either something or nothing. Then we&amp;rsquo;ll look at how pattern matching in the &lt;code&gt;match&lt;/code&gt; expression makes it easy to run different code for different values of an enum. Finally, we&amp;rsquo;ll cover how the &lt;code&gt;if let&lt;/code&gt; construct is another convenient and concise idiom available to you to handle enums in your code.</source>
          <target state="translated">En este cap&amp;iacute;tulo veremos las &lt;em&gt;enumeraciones&lt;/em&gt; , tambi&amp;eacute;n denominadas &lt;em&gt;enums&lt;/em&gt; . Las enumeraciones le permiten definir un tipo enumerando sus posibles valores. Primero, definiremos y usaremos una enumeraci&amp;oacute;n para mostrar c&amp;oacute;mo una enumeraci&amp;oacute;n puede codificar el significado junto con los datos. A continuaci&amp;oacute;n, exploraremos una enumeraci&amp;oacute;n particularmente &amp;uacute;til, llamada &lt;code&gt;Option&lt;/code&gt; , que expresa que un valor puede ser algo o nada. Luego, veremos c&amp;oacute;mo la coincidencia de patrones en la expresi&amp;oacute;n de &lt;code&gt;match&lt;/code&gt; facilita la ejecuci&amp;oacute;n de c&amp;oacute;digo diferente para diferentes valores de una enumeraci&amp;oacute;n. Finalmente, cubriremos c&amp;oacute;mo la construcci&amp;oacute;n &lt;code&gt;if let&lt;/code&gt; es otro modismo conveniente y conciso disponible para manejar enumeraciones en su c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="54bfe40f65e4baf089b3fdf58b27393a8784f4c8" translate="yes" xml:space="preserve">
          <source>In this chapter, we won&amp;rsquo;t debate the issue of what functional programming is or isn&amp;rsquo;t but will instead discuss some features of Rust that are similar to features in many languages often referred to as functional.</source>
          <target state="translated">En este cap&amp;iacute;tulo, no debatiremos el tema de qu&amp;eacute; es o no es la programaci&amp;oacute;n funcional, sino que analizaremos algunas caracter&amp;iacute;sticas de Rust que son similares a las caracter&amp;iacute;sticas en muchos lenguajes que a menudo se denominan funcionales.</target>
        </trans-unit>
        <trans-unit id="1a7486659e0b2248f370c5b62acbfa92d0246aa8" translate="yes" xml:space="preserve">
          <source>In this chapter, we&amp;rsquo;ll cover all these features, discuss how they interact, and explain how to use them to manage scope. By the end, you should have a solid understanding of the module system and be able to work with scopes like a pro!</source>
          <target state="translated">En este cap&amp;iacute;tulo, cubriremos todas estas caracter&amp;iacute;sticas, discutiremos c&amp;oacute;mo interact&amp;uacute;an y explicaremos c&amp;oacute;mo usarlas para administrar el alcance. Al final, deber&amp;aacute;s tener un conocimiento s&amp;oacute;lido del sistema de m&amp;oacute;dulos y ser capaz de trabajar con osciloscopios como un profesional.</target>
        </trans-unit>
        <trans-unit id="323ae7b14fd96e68551f003142bf4b84170544d5" translate="yes" xml:space="preserve">
          <source>In this chapter, we&amp;rsquo;ll cover:</source>
          <target state="translated">En este cap&amp;iacute;tulo, cubriremos:</target>
        </trans-unit>
        <trans-unit id="a4639a7fb71c7cc2724cbe31da70376d99c56baa" translate="yes" xml:space="preserve">
          <source>In this code, the first and last value are matched with &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt;. The &lt;code&gt;..&lt;/code&gt; will match and ignore everything in the middle.</source>
          <target state="translated">En este c&amp;oacute;digo, el primer y &amp;uacute;ltimo valor se comparan con el &lt;code&gt;first&lt;/code&gt; y el &lt;code&gt;last&lt;/code&gt; . El &lt;code&gt;..&lt;/code&gt; coincidir&amp;aacute; e ignorar&amp;aacute; todo lo que est&amp;eacute; en el medio.</target>
        </trans-unit>
        <trans-unit id="145a83e849a55e3baebf66ad497473ddcd7f5f55" translate="yes" xml:space="preserve">
          <source>In this code, the same thing happens as in the &lt;code&gt;match&lt;/code&gt; in Listing 19-26: Rust sees that &lt;code&gt;val&lt;/code&gt; has the type &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;panic!&lt;/code&gt; has the type &lt;code&gt;!&lt;/code&gt;, so the result of the overall &lt;code&gt;match&lt;/code&gt; expression is &lt;code&gt;T&lt;/code&gt;. This code works because &lt;code&gt;panic!&lt;/code&gt; doesn&amp;rsquo;t produce a value; it ends the program. In the &lt;code&gt;None&lt;/code&gt; case, we won&amp;rsquo;t be returning a value from &lt;code&gt;unwrap&lt;/code&gt;, so this code is valid.</source>
          <target state="translated">En este c&amp;oacute;digo, sucede lo mismo que en la &lt;code&gt;match&lt;/code&gt; Listado 19-26: Rust ve que &lt;code&gt;val&lt;/code&gt; tiene el tipo &lt;code&gt;T&lt;/code&gt; y &lt;code&gt;panic!&lt;/code&gt; tiene el tipo &lt;code&gt;!&lt;/code&gt; , Por lo que el resultado global del &lt;code&gt;match&lt;/code&gt; expresi&amp;oacute;n es &lt;code&gt;T&lt;/code&gt; . &amp;iexcl;Este c&amp;oacute;digo funciona porque &lt;code&gt;panic!&lt;/code&gt; no produce un valor; finaliza el programa. En el caso &lt;code&gt;None&lt;/code&gt; , no devolveremos un valor de &lt;code&gt;unwrap&lt;/code&gt; , por lo que este c&amp;oacute;digo es v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="844247dc89592da735fc5622f72eb35876e2a2a2" translate="yes" xml:space="preserve">
          <source>In this code, you have two ways to solve this issue:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f5f63902ac52a2fdb77ae9b0aaf168362307239" translate="yes" xml:space="preserve">
          <source>In this context, by &lt;em&gt;runtime&lt;/em&gt; we mean code that is included by the language in every binary. This code can be large or small depending on the language, but every non-assembly language will have some amount of runtime code. For that reason, colloquially when people say a language has &amp;ldquo;no runtime,&amp;rdquo; they often mean &amp;ldquo;small runtime.&amp;rdquo; Smaller runtimes have fewer features but have the advantage of resulting in smaller binaries, which make it easier to combine the language with other languages in more contexts. Although many languages are okay with increasing the runtime size in exchange for more features, Rust needs to have nearly no runtime and cannot compromise on being able to call into C to maintain performance.</source>
          <target state="translated">En este contexto, por &lt;em&gt;tiempo&lt;/em&gt; de &lt;em&gt;ejecuci&amp;oacute;n&lt;/em&gt; nos referimos al c&amp;oacute;digo que est&amp;aacute; incluido por el lenguaje en cada binario. Este c&amp;oacute;digo puede ser grande o peque&amp;ntilde;o seg&amp;uacute;n el lenguaje, pero cada lenguaje que no sea ensamblador tendr&amp;aacute; cierta cantidad de c&amp;oacute;digo de tiempo de ejecuci&amp;oacute;n. Por esa raz&amp;oacute;n, coloquialmente cuando las personas dicen que un idioma &quot;no tiene tiempo de ejecuci&amp;oacute;n&quot;, a menudo se refieren a &quot;peque&amp;ntilde;o tiempo de ejecuci&amp;oacute;n&quot;. Los tiempos de ejecuci&amp;oacute;n m&amp;aacute;s peque&amp;ntilde;os tienen menos funciones, pero tienen la ventaja de generar binarios m&amp;aacute;s peque&amp;ntilde;os, lo que facilita la combinaci&amp;oacute;n del idioma con otros idiomas en m&amp;aacute;s contextos. Aunque muchos lenguajes est&amp;aacute;n de acuerdo con aumentar el tama&amp;ntilde;o del tiempo de ejecuci&amp;oacute;n a cambio de m&amp;aacute;s funciones, Rust no necesita casi ning&amp;uacute;n tiempo de ejecuci&amp;oacute;n y no puede comprometer la posibilidad de llamar a C para mantener el rendimiento.</target>
        </trans-unit>
        <trans-unit id="3f10f5106c28699182d72488c5b199580b51f515" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;2&lt;/code&gt; is destroyed right after the assignment, which means that &lt;code&gt;ptr&lt;/code&gt; now points to an unavailable location.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16ee00cd14e3198e4bb4ed77351c13a68c4d2964" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;BoxCar&lt;/code&gt; has two super-traits: &lt;code&gt;Vehicle&lt;/code&gt; and &lt;code&gt;Box&lt;/code&gt;. Both of these traits define an associated type &lt;code&gt;Color&lt;/code&gt;. &lt;code&gt;BoxCar&lt;/code&gt; inherits two types with that name from both super-traits. Because of this, we need to use the fully qualified path syntax to refer to the appropriate &lt;code&gt;Color&lt;/code&gt; associated type, either &lt;code&gt;&amp;lt;BoxCar as Vehicle&amp;gt;::Color&lt;/code&gt; or &lt;code&gt;&amp;lt;BoxCar as Box&amp;gt;::Color&lt;/code&gt;, but this syntax is not allowed to be used in a function signature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e0ee0316ee57e8497270b5ce77464ecb56adca2" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;Cat&lt;/code&gt; is a &lt;em&gt;struct-like enum variant&lt;/em&gt;, whereas &lt;code&gt;Dog&lt;/code&gt; is simply called an enum variant. Each enum instance has a &lt;em&gt;discriminant&lt;/em&gt; which is an integer associated to it that is used to determine which variant it holds. An opaque reference to this discriminant can be obtained with the &lt;a href=&quot;../../std/mem/fn.discriminant&quot;&gt;&lt;code&gt;mem::discriminant&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">En este ejemplo, &lt;code&gt;Cat&lt;/code&gt; es una &lt;em&gt;variante de enumeraci&amp;oacute;n similar a&lt;/em&gt; una &lt;em&gt;estructura&lt;/em&gt; , mientras que &lt;code&gt;Dog&lt;/code&gt; simplemente se denomina variante de enumeraci&amp;oacute;n. Cada instancia de enumeraci&amp;oacute;n tiene un &lt;em&gt;discriminante&lt;/em&gt; que es un n&amp;uacute;mero entero asociado que se usa para determinar qu&amp;eacute; variante contiene. Se puede obtener una referencia opaca a este discriminante con la funci&amp;oacute;n &lt;a href=&quot;../../std/mem/fn.discriminant&quot;&gt; &lt;code&gt;mem::discriminant&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7bb9799e70052b9e454a954f47a55d73983d300f" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;Foo&lt;/code&gt; defines an associated type &lt;code&gt;A&lt;/code&gt;. &lt;code&gt;Bar&lt;/code&gt; inherits that type from &lt;code&gt;Foo&lt;/code&gt;, and defines another associated type of the same name. As a result, when we attempt to use &lt;code&gt;Self::A&lt;/code&gt;, it's ambiguous whether we mean the &lt;code&gt;A&lt;/code&gt; defined by &lt;code&gt;Foo&lt;/code&gt; or the one defined by &lt;code&gt;Bar&lt;/code&gt;.</source>
          <target state="translated">En este ejemplo, &lt;code&gt;Foo&lt;/code&gt; define un tipo &lt;code&gt;A&lt;/code&gt; asociado . &lt;code&gt;Bar&lt;/code&gt; hereda ese tipo de &lt;code&gt;Foo&lt;/code&gt; y define otro tipo asociado del mismo nombre. Como resultado, cuando intentamos usar &lt;code&gt;Self::A&lt;/code&gt; , es ambiguo si nos referimos a la &lt;code&gt;A&lt;/code&gt; definida por &lt;code&gt;Foo&lt;/code&gt; o la definida por &lt;code&gt;Bar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8cedc14f701bbdf96ac8102b9f064b1dca2f26cb" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;Y&lt;/code&gt; cannot refer to &lt;code&gt;X&lt;/code&gt; here. To fix this, the value can be extracted as a const and then used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea4ed47b5eac4878ae970fa360382b182707dcb9" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;string1&lt;/code&gt; is valid until the end of the outer scope, &lt;code&gt;string2&lt;/code&gt; is valid until the end of the inner scope, and &lt;code&gt;result&lt;/code&gt; references something that is valid until the end of the inner scope. Run this code, and you&amp;rsquo;ll see that the borrow checker approves of this code; it will compile and print &lt;code&gt;The longest string is long string is long&lt;/code&gt;.</source>
          <target state="translated">En este ejemplo, &lt;code&gt;string1&lt;/code&gt; es v&amp;aacute;lido hasta el final del alcance externo, &lt;code&gt;string2&lt;/code&gt; es v&amp;aacute;lido hasta el final del alcance interno y el &lt;code&gt;result&lt;/code&gt; ado hace referencia a algo que es v&amp;aacute;lido hasta el final del alcance interno. Ejecute este c&amp;oacute;digo y ver&amp;aacute; que el verificador de pr&amp;eacute;stamos aprueba este c&amp;oacute;digo; compilar&amp;aacute; e imprimir&amp;aacute; &lt;code&gt;The longest string is long string is long&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a21a4f7cf44738665bcf722c117e87d97dd2b44" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;value&lt;/code&gt; is mutably borrowed by &lt;code&gt;borrow&lt;/code&gt; and cannot be used to calculate &lt;code&gt;sum&lt;/code&gt;. This is not possible because this would violate Rust's mutability rules.</source>
          <target state="translated">En este ejemplo, &lt;code&gt;value&lt;/code&gt; se mutably prestado por el &lt;code&gt;borrow&lt;/code&gt; y no puede ser usada para calcular &lt;code&gt;sum&lt;/code&gt; . Esto no es posible porque violar&amp;iacute;a las reglas de mutabilidad de Rust.</target>
        </trans-unit>
        <trans-unit id="ee5fd415a36736dbb42604438d3e115f3ef63293" translate="yes" xml:space="preserve">
          <source>In this example, if &lt;code&gt;x&lt;/code&gt; matches the pattern &lt;code&gt;(0, _)&lt;/code&gt;, the second field is set to &lt;code&gt;y&lt;/code&gt;. If it matches &lt;code&gt;(_, 0)&lt;/code&gt;, the first field is set to &lt;code&gt;y&lt;/code&gt;; so in all cases &lt;code&gt;y&lt;/code&gt; is set to some value.</source>
          <target state="translated">En este ejemplo, si &lt;code&gt;x&lt;/code&gt; coincide con el patr&amp;oacute;n &lt;code&gt;(0, _)&lt;/code&gt; , el segundo campo se establece en &lt;code&gt;y&lt;/code&gt; . Si coincide con &lt;code&gt;(_, 0)&lt;/code&gt; , el primer campo se establece en &lt;code&gt;y&lt;/code&gt; ; por lo que en todos los casos &lt;code&gt;y&lt;/code&gt; se establece en alg&amp;uacute;n valor.</target>
        </trans-unit>
        <trans-unit id="7fe9cc71a505a06c66b5d9f57153a2d3327a9165" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;'SnowWhite&lt;/code&gt; lifetime is supposed to outlive the &lt;code&gt;'kiss&lt;/code&gt; lifetime but the declaration of the &lt;code&gt;Prince&lt;/code&gt; struct doesn't enforce it. To fix this issue, you need to specify it:</source>
          <target state="translated">En este ejemplo, el &lt;code&gt;'SnowWhite&lt;/code&gt; se supone que la duraci&amp;oacute;n de 'SnowWhite sobrevive a la &lt;code&gt;'kiss&lt;/code&gt; duraci&amp;oacute;n del beso, pero la declaraci&amp;oacute;n de la estructura &lt;code&gt;Prince&lt;/code&gt; no la impone. Para solucionar este problema, debe especificarlo:</target>
        </trans-unit>
        <trans-unit id="5793bd2e6d3c5293d83c901c5867d17a61fb1b7b" translate="yes" xml:space="preserve">
          <source>In this example, the closure does not satisfy the &lt;code&gt;'static&lt;/code&gt; lifetime constraint. To fix this error, you need to double check the lifetime of the type. Here, we can fix this problem by giving &lt;code&gt;s&lt;/code&gt; a static lifetime:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c61f98e2cee2baaabf8be1956ffb960bd279fb24" translate="yes" xml:space="preserve">
          <source>In this example, the module &lt;code&gt;quux&lt;/code&gt; re-exports two public names defined in &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">En este ejemplo, el m&amp;oacute;dulo &lt;code&gt;quux&lt;/code&gt; reexporta dos nombres p&amp;uacute;blicos definidos en &lt;code&gt;foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4350bf464e116b6d57c761b20a820cb5925c37d3" translate="yes" xml:space="preserve">
          <source>In this example, the spawned thread is &quot;detached&quot; from the current thread. This means that it can outlive its parent (the thread that spawned it), unless this parent is the main thread.</source>
          <target state="translated">En este ejemplo,el hilo engendrado se &quot;desprende&quot; del hilo actual.Esto significa que puede sobrevivir a su padre (el hilo que lo engendró),a menos que este padre sea el hilo principal.</target>
        </trans-unit>
        <trans-unit id="adb1f627c4f5f533a368664ad1bfd6b52635fef6" translate="yes" xml:space="preserve">
          <source>In this example, the trait &lt;code&gt;Foo&lt;/code&gt; and the trait method &lt;code&gt;do_something_else&lt;/code&gt; both define a type parameter &lt;code&gt;T&lt;/code&gt;. This is not allowed: if the method wishes to define a type parameter, it must use a different name for it.</source>
          <target state="translated">En este ejemplo, el rasgo &lt;code&gt;Foo&lt;/code&gt; y el m&amp;eacute;todo rasgo &lt;code&gt;do_something_else&lt;/code&gt; tanto definen un tipo de par&amp;aacute;metro &lt;code&gt;T&lt;/code&gt; . Esto no est&amp;aacute; permitido: si el m&amp;eacute;todo desea definir un par&amp;aacute;metro de tipo, debe usar un nombre diferente para &amp;eacute;l.</target>
        </trans-unit>
        <trans-unit id="5106de7dace445aa59aa82effd4989b6c9358ae0" translate="yes" xml:space="preserve">
          <source>In this example, the trait &lt;code&gt;Printable&lt;/code&gt; occurs as a trait object in both the type signature of &lt;code&gt;print&lt;/code&gt;, and the cast expression in &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">En este ejemplo, el rasgo &lt;code&gt;Printable&lt;/code&gt; aparece como un objeto de rasgo tanto en la firma de tipo de &lt;code&gt;print&lt;/code&gt; como en la expresi&amp;oacute;n de conversi&amp;oacute;n en &lt;code&gt;main&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c7b2451157bfe66dfc5ae3bcc7df818cb052f87" translate="yes" xml:space="preserve">
          <source>In this example, the value &lt;code&gt;p&lt;/code&gt; matches the second arm by virtue of &lt;code&gt;x&lt;/code&gt; containing a 0, so this code will print &lt;code&gt;On the y axis at 7&lt;/code&gt;.</source>
          <target state="translated">En este ejemplo, el valor &lt;code&gt;p&lt;/code&gt; coincide con el segundo brazo en virtud de que &lt;code&gt;x&lt;/code&gt; contiene un 0, por lo que este c&amp;oacute;digo se imprimir&amp;aacute; &lt;code&gt;On the y axis at 7&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76e376bb135f5c25de32c031f91a381023081f30" translate="yes" xml:space="preserve">
          <source>In this example, the variable named &lt;code&gt;first&lt;/code&gt; will get the value &lt;code&gt;1&lt;/code&gt;, because that is the value at index &lt;code&gt;[0]&lt;/code&gt; in the array. The variable named &lt;code&gt;second&lt;/code&gt; will get the value &lt;code&gt;2&lt;/code&gt; from index &lt;code&gt;[1]&lt;/code&gt; in the array.</source>
          <target state="translated">En este ejemplo, la variable nombrada &lt;code&gt;first&lt;/code&gt; obtendr&amp;aacute; el valor &lt;code&gt;1&lt;/code&gt; , porque ese es el valor en el &amp;iacute;ndice &lt;code&gt;[0]&lt;/code&gt; en la matriz. La variable denominada &lt;code&gt;second&lt;/code&gt; obtendr&amp;aacute; el valor &lt;code&gt;2&lt;/code&gt; del &amp;iacute;ndice &lt;code&gt;[1]&lt;/code&gt; en la matriz.</target>
        </trans-unit>
        <trans-unit id="db1c89f552fe6cd5046ff6bd0d230e80deb004f6" translate="yes" xml:space="preserve">
          <source>In this example, we are asserting that the destructor for &lt;code&gt;Foo&lt;/code&gt; will not access any data of type &lt;code&gt;X&lt;/code&gt;, and require this assertion to be true for overall safety in our program. The compiler does not currently attempt to verify this assertion; therefore we must tag this &lt;code&gt;impl&lt;/code&gt; as unsafe.</source>
          <target state="translated">En este ejemplo, afirmamos que el destructor de &lt;code&gt;Foo&lt;/code&gt; no acceder&amp;aacute; a ning&amp;uacute;n dato de tipo &lt;code&gt;X&lt;/code&gt; , y requerimos que esta afirmaci&amp;oacute;n sea cierta para la seguridad general de nuestro programa. Actualmente, el compilador no intenta verificar esta afirmaci&amp;oacute;n; por lo tanto, debemos etiquetar este &lt;code&gt;impl&lt;/code&gt; &amp;iacute;cito como inseguro.</target>
        </trans-unit>
        <trans-unit id="5b639017ef60ffaf0981282e4da6c27fcdd578e1" translate="yes" xml:space="preserve">
          <source>In this example, we define a function &lt;code&gt;ten_times&lt;/code&gt; that takes a higher-order function argument, and we then call it with a closure expression as an argument, followed by a closure expression that moves values from its environment.</source>
          <target state="translated">En este ejemplo, definimos una funci&amp;oacute;n &lt;code&gt;ten_times&lt;/code&gt; que toma un argumento de funci&amp;oacute;n de orden superior, y luego la llamamos con una expresi&amp;oacute;n de cierre como argumento, seguida de una expresi&amp;oacute;n de cierre que mueve valores de su entorno.</target>
        </trans-unit>
        <trans-unit id="9be8015724a60f5a7de7fc8be3cf3fbc9130aa82" translate="yes" xml:space="preserve">
          <source>In this example, we tried to set a value with an incompatible lifetime to another one (&lt;code&gt;'long&lt;/code&gt; is unrelated to &lt;code&gt;'short&lt;/code&gt;). We can solve this issue in two different ways:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8385385b7c5acae88f390fa2486165f8a8931f92" translate="yes" xml:space="preserve">
          <source>In this example, we tried to use the non-existent associated type &lt;code&gt;You&lt;/code&gt; of the &lt;code&gt;Hello&lt;/code&gt; trait. To fix this error, use an existing associated type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bbce52117883bf5718cfbbb01cfe64f9309a2ae" translate="yes" xml:space="preserve">
          <source>In this example, we&amp;rsquo;ve specified a lifetime parameter &lt;code&gt;'a&lt;/code&gt; for the parameter &lt;code&gt;x&lt;/code&gt; and the return type, but not for the parameter &lt;code&gt;y&lt;/code&gt;, because the lifetime of &lt;code&gt;y&lt;/code&gt; does not have any relationship with the lifetime of &lt;code&gt;x&lt;/code&gt; or the return value.</source>
          <target state="translated">En este ejemplo, hemos especificado un par&amp;aacute;metro de duraci&amp;oacute;n &lt;code&gt;'a&lt;/code&gt; para el par&amp;aacute;metro &lt;code&gt;x&lt;/code&gt; y el tipo de retorno, pero no para el par&amp;aacute;metro &lt;code&gt;y&lt;/code&gt; , porque la duraci&amp;oacute;n de &lt;code&gt;y&lt;/code&gt; no tiene ninguna relaci&amp;oacute;n con la duraci&amp;oacute;n de &lt;code&gt;x&lt;/code&gt; o el valor de retorno.</target>
        </trans-unit>
        <trans-unit id="2185efdb59ae63a632adf24d45f191ffee2411df" translate="yes" xml:space="preserve">
          <source>In this example, when we assign the integer value 5 to &lt;code&gt;x&lt;/code&gt;, we let the compiler know that the generic type &lt;code&gt;T&lt;/code&gt; will be an integer for this instance of &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt;. Then when we specify 4.0 for &lt;code&gt;y&lt;/code&gt;, which we&amp;rsquo;ve defined to have the same type as &lt;code&gt;x&lt;/code&gt;, we&amp;rsquo;ll get a type mismatch error like this:</source>
          <target state="translated">En este ejemplo, cuando asignamos el valor entero 5 &lt;code&gt;x&lt;/code&gt; , le dejamos saber al compilador que el tipo gen&amp;eacute;rico &lt;code&gt;T&lt;/code&gt; ser&amp;aacute; un n&amp;uacute;mero entero para esta instancia de &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; . Luego, cuando especificamos 4.0 para &lt;code&gt;y&lt;/code&gt; , que hemos definido para tener el mismo tipo que &lt;code&gt;x&lt;/code&gt; , obtendremos un error de falta de coincidencia de tipos como este:</target>
        </trans-unit>
        <trans-unit id="af5f4c7efbea71694085e036fb3fca287f7c1342" translate="yes" xml:space="preserve">
          <source>In this example, you can see that &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; enables mutation inside an immutable struct. In other words, it enables &quot;interior mutability&quot;.</source>
          <target state="translated">En este ejemplo, puede ver que &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; habilita la mutaci&amp;oacute;n dentro de una estructura inmutable. En otras palabras, permite la &quot;mutabilidad interior&quot;.</target>
        </trans-unit>
        <trans-unit id="28ad91d98b4c69b8725ca2927cbfaca53b3c5e8d" translate="yes" xml:space="preserve">
          <source>In this implementation, the &lt;code&gt;to_string&lt;/code&gt; method panics if the &lt;code&gt;Display&lt;/code&gt; implementation returns an error. This indicates an incorrect &lt;code&gt;Display&lt;/code&gt; implementation since &lt;code&gt;fmt::Write for String&lt;/code&gt; never returns an error itself.</source>
          <target state="translated">En esta implementaci&amp;oacute;n, el m&amp;eacute;todo &lt;code&gt;to_string&lt;/code&gt; entra en p&amp;aacute;nico si la implementaci&amp;oacute;n de &lt;code&gt;Display&lt;/code&gt; devuelve un error. Esto indica una implementaci&amp;oacute;n de &lt;code&gt;Display&lt;/code&gt; incorrecta ya que &lt;code&gt;fmt::Write for String&lt;/code&gt; nunca devuelve un error en s&amp;iacute; mismo.</target>
        </trans-unit>
        <trans-unit id="7cf45f5e676953372bb64ede268b0f879c84bec0" translate="yes" xml:space="preserve">
          <source>In this listing, we&amp;rsquo;ve used a method we haven&amp;rsquo;t covered before: &lt;code&gt;unwrap_or_else&lt;/code&gt;, which is defined on &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; by the standard library. Using &lt;code&gt;unwrap_or_else&lt;/code&gt; allows us to define some custom, non-&lt;code&gt;panic!&lt;/code&gt; error handling. If the &lt;code&gt;Result&lt;/code&gt; is an &lt;code&gt;Ok&lt;/code&gt; value, this method&amp;rsquo;s behavior is similar to &lt;code&gt;unwrap&lt;/code&gt;: it returns the inner value &lt;code&gt;Ok&lt;/code&gt; is wrapping. However, if the value is an &lt;code&gt;Err&lt;/code&gt; value, this method calls the code in the &lt;em&gt;closure&lt;/em&gt;, which is an anonymous function we define and pass as an argument to &lt;code&gt;unwrap_or_else&lt;/code&gt;. We&amp;rsquo;ll cover closures in more detail in &lt;a href=&quot;ch13-00-functional-features&quot;&gt;Chapter 13&lt;/a&gt;. For now, you just need to know that &lt;code&gt;unwrap_or_else&lt;/code&gt; will pass the inner value of the &lt;code&gt;Err&lt;/code&gt;, which in this case is the static string &lt;code&gt;not enough arguments&lt;/code&gt; that we added in Listing 12-9, to our closure in the argument &lt;code&gt;err&lt;/code&gt; that appears between the vertical pipes. The code in the closure can then use the &lt;code&gt;err&lt;/code&gt; value when it runs.</source>
          <target state="translated">En esta lista, hemos utilizado un m&amp;eacute;todo que no hemos cubierto antes: &lt;code&gt;unwrap_or_else&lt;/code&gt; , que est&amp;aacute; definido en &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; por la biblioteca est&amp;aacute;ndar. El uso de &lt;code&gt;unwrap_or_else&lt;/code&gt; nos permite definir algunos personalizados, &amp;iexcl;sin &lt;code&gt;panic!&lt;/code&gt; manejo de errores. Si el &lt;code&gt;Result&lt;/code&gt; es un valor &lt;code&gt;Ok&lt;/code&gt; , el comportamiento de este m&amp;eacute;todo es similar a &lt;code&gt;unwrap&lt;/code&gt; : devuelve el valor interno que &lt;code&gt;Ok&lt;/code&gt; est&amp;aacute; envolviendo. Sin embargo, si el valor es un valor &lt;code&gt;Err&lt;/code&gt; , este m&amp;eacute;todo llama al c&amp;oacute;digo en el &lt;em&gt;cierre&lt;/em&gt; , que es una funci&amp;oacute;n an&amp;oacute;nima que definimos y pasamos como argumento a &lt;code&gt;unwrap_or_else&lt;/code&gt; . Cubriremos los cierres con m&amp;aacute;s detalle en&lt;a href=&quot;ch13-00-functional-features&quot;&gt;Cap&amp;iacute;tulo 13&lt;/a&gt; . Por ahora, solo necesita saber que &lt;code&gt;unwrap_or_else&lt;/code&gt; pasar&amp;aacute; el valor interno de &lt;code&gt;Err&lt;/code&gt; , que en este caso es la cadena est&amp;aacute;tica, &lt;code&gt;not enough arguments&lt;/code&gt; que agregamos en el Listado 12-9, a nuestro cierre en el argumento &lt;code&gt;err&lt;/code&gt; que aparece entre los Tuber&amp;iacute;as verticales. El c&amp;oacute;digo en el cierre puede usar el valor de &lt;code&gt;err&lt;/code&gt; or cuando se ejecuta.</target>
        </trans-unit>
        <trans-unit id="bd1efd0f88f5695bb09cde72e8a0904d7ad1c207" translate="yes" xml:space="preserve">
          <source>In this more complex example, we use &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;.debug_set()&lt;/code&gt; to build a list of match arms:</source>
          <target state="translated">En este ejemplo m&amp;aacute;s complejo, usamos &lt;a href=&quot;../macro.format_args&quot;&gt; &lt;code&gt;format_args!&lt;/code&gt; &lt;/a&gt;y &lt;code&gt;.debug_set()&lt;/code&gt; para construir una lista de brazos coincidentes:</target>
        </trans-unit>
        <trans-unit id="b03c6712fd2fec1eec14a91751691024a72c4d16" translate="yes" xml:space="preserve">
          <source>In this next example, &lt;code&gt;init_after_if&lt;/code&gt; is initialized after the &lt;a href=&quot;expressions/if-expr#if-expressions&quot;&gt;&lt;code&gt;if&lt;/code&gt; expression&lt;/a&gt; while &lt;code&gt;uninit_after_if&lt;/code&gt; is not because it is not initialized in the &lt;code&gt;else&lt;/code&gt; case.</source>
          <target state="translated">En el siguiente ejemplo, &lt;code&gt;init_after_if&lt;/code&gt; se inicializa despu&amp;eacute;s de la &lt;a href=&quot;expressions/if-expr#if-expressions&quot;&gt;expresi&amp;oacute;n &lt;/a&gt; &lt;code&gt;if&lt;/code&gt; , mientras que &lt;code&gt;uninit_after_if&lt;/code&gt; no lo es porque no se inicializa en el caso &lt;code&gt;else&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c69b4c18cf4fe1c7e28ef21ab7b9243778f0c95" translate="yes" xml:space="preserve">
          <source>In this process, the compiler does the opposite of the steps we used to create the generic function in Listing 10-5: the compiler looks at all the places where generic code is called and generates code for the concrete types the generic code is called with.</source>
          <target state="translated">En este proceso,el compilador hace lo contrario de los pasos que usamos para crear la función genérica en la Lista 10-5:el compilador mira todos los lugares en los que se llama el código genérico y genera código para los tipos concretos con los que se llama el código genérico.</target>
        </trans-unit>
        <trans-unit id="9b2eecf1196adab0e0b7bc0dd52bfa9ea4118939" translate="yes" xml:space="preserve">
          <source>In this section, we&amp;rsquo;ll add the searching logic to the &lt;code&gt;minigrep&lt;/code&gt; program by using the Test-driven development (TDD) process. This software development technique follows these steps:</source>
          <target state="translated">En esta secci&amp;oacute;n, agregaremos la l&amp;oacute;gica de b&amp;uacute;squeda al programa &lt;code&gt;minigrep&lt;/code&gt; mediante el proceso de desarrollo impulsado por pruebas (TDD). Esta t&amp;eacute;cnica de desarrollo de software sigue estos pasos:</target>
        </trans-unit>
        <trans-unit id="35594ca80fb0c4ca7018f39776903a474d1cfb0f" translate="yes" xml:space="preserve">
          <source>In this section, we&amp;rsquo;ll talk about modules and other parts of the module system, namely &lt;em&gt;paths&lt;/em&gt; that allow you to name items; the &lt;code&gt;use&lt;/code&gt; keyword that brings a path into scope; and the &lt;code&gt;pub&lt;/code&gt; keyword to make items public. We&amp;rsquo;ll also discuss the &lt;code&gt;as&lt;/code&gt; keyword, external packages, and the glob operator. For now, let&amp;rsquo;s focus on modules!</source>
          <target state="translated">En esta secci&amp;oacute;n, hablaremos sobre m&amp;oacute;dulos y otras partes del sistema de m&amp;oacute;dulos, a saber, &lt;em&gt;rutas&lt;/em&gt; que le permiten nombrar elementos; la palabra clave &lt;code&gt;use&lt;/code&gt; que trae una ruta al alcance; y la palabra clave &lt;code&gt;pub&lt;/code&gt; para hacer p&amp;uacute;blicos los elementos. Tambi&amp;eacute;n discutiremos la palabra clave &lt;code&gt;as&lt;/code&gt; , los paquetes externos y el operador glob. &amp;iexcl;Por ahora, centr&amp;eacute;monos en los m&amp;oacute;dulos!</target>
        </trans-unit>
        <trans-unit id="b9ddbf2b08f89e10bfeee4884b118c18fb0ff1c3" translate="yes" xml:space="preserve">
          <source>In this situation, even the &lt;code&gt;ref&lt;/code&gt; keyword cannot solve it, since borrowed content cannot be moved. This problem cannot be solved generally. If the value can be cloned, here is a not-so-specific solution:</source>
          <target state="translated">En esta situaci&amp;oacute;n, incluso la palabra clave &lt;code&gt;ref&lt;/code&gt; no puede resolverlo, ya que el contenido prestado no se puede mover. Este problema no se puede resolver en general. Si el valor se puede clonar, aqu&amp;iacute; hay una soluci&amp;oacute;n no tan espec&amp;iacute;fica:</target>
        </trans-unit>
        <trans-unit id="66f6d7f6d5b6dce217f5225ca67e0e2ff88fca0a" translate="yes" xml:space="preserve">
          <source>In this specific case there's a good chance that the transmute is harmless (but this is not guaranteed by Rust). However, when alignment and enum optimizations come into the picture, it's quite likely that the sizes may or may not match with different type parameter substitutions. It's not possible to check this for &lt;em&gt;all&lt;/em&gt; possible types, so &lt;code&gt;transmute()&lt;/code&gt; simply only accepts types without any unsubstituted type parameters.</source>
          <target state="translated">En este caso espec&amp;iacute;fico, existe una buena posibilidad de que la transmutaci&amp;oacute;n sea inofensiva (pero Rust no lo garantiza). Sin embargo, cuando las optimizaciones de alineaci&amp;oacute;n y enumeraci&amp;oacute;n entran en juego, es bastante probable que los tama&amp;ntilde;os coincidan o no con las sustituciones de par&amp;aacute;metros de tipo diferente. No es posible verificar esto para &lt;em&gt;todos&lt;/em&gt; los tipos posibles, por lo que &lt;code&gt;transmute()&lt;/code&gt; simplemente solo acepta tipos sin ning&amp;uacute;n par&amp;aacute;metro de tipo no sustituido.</target>
        </trans-unit>
        <trans-unit id="fe9b2052803d3d7b3dd78aa5085c8137d21478b8" translate="yes" xml:space="preserve">
          <source>In this suggestion, &amp;ldquo;indirection&amp;rdquo; means that instead of storing a value directly, we&amp;rsquo;ll change the data structure to store the value indirectly by storing a pointer to the value instead.</source>
          <target state="translated">En esta sugerencia, &quot;indirecci&amp;oacute;n&quot; significa que en lugar de almacenar un valor directamente, cambiaremos la estructura de datos para almacenar el valor indirectamente almacenando un puntero al valor.</target>
        </trans-unit>
        <trans-unit id="ace1483441c50f77553551974f43198070533a0e" translate="yes" xml:space="preserve">
          <source>In this way, the structure of expressions dictates the structure of execution. Blocks are just another kind of expression, so blocks, statements, expressions, and blocks again can recursively nest inside each other to an arbitrary depth.</source>
          <target state="translated">De esta manera,la estructura de las expresiones dicta la estructura de la ejecución.Los bloques son sólo otro tipo de expresión,por lo que los bloques,declaraciones,expresiones y bloques de nuevo pueden anidar recursivamente dentro de cada uno a una profundidad arbitraria.</target>
        </trans-unit>
        <trans-unit id="3c64ce605c02c94d28e3d47caa98671818a3b2ae" translate="yes" xml:space="preserve">
          <source>In those cases, you need to provide the type explicitly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f60575dd030bfd74d0c69219e41591057c41df3" translate="yes" xml:space="preserve">
          <source>In trait declarations as &lt;a href=&quot;items/traits#supertraits&quot;&gt;supertraits&lt;/a&gt;: &lt;code&gt;trait Circle : Shape {}&lt;/code&gt; is equivalent to &lt;code&gt;trait Circle where Self : Shape {}&lt;/code&gt;.</source>
          <target state="translated">En declaraciones de rasgos como &lt;a href=&quot;items/traits#supertraits&quot;&gt;supertraits&lt;/a&gt; : &lt;code&gt;trait Circle : Shape {}&lt;/code&gt; es equivalente al &lt;code&gt;trait Circle where Self : Shape {}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4f93075a116db72d1570a79e9e24585b192c4ef" translate="yes" xml:space="preserve">
          <source>In trait declarations as bounds on &lt;a href=&quot;items/associated-items#associated-types&quot;&gt;associated types&lt;/a&gt;: &lt;code&gt;trait A { type B: Copy; }&lt;/code&gt; is equivalent to &lt;code&gt;trait A where Self::B: Copy { type B; }&lt;/code&gt;.</source>
          <target state="translated">En declaraciones de rasgos como l&amp;iacute;mites en &lt;a href=&quot;items/associated-items#associated-types&quot;&gt;tipos asociados&lt;/a&gt; : &lt;code&gt;trait A { type B: Copy; }&lt;/code&gt; es equivalente al &lt;code&gt;trait A where Self::B: Copy { type B; }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d593169be70ffe063ab15f461603b04fb19d3943" translate="yes" xml:space="preserve">
          <source>In traits, &lt;code&gt;type&lt;/code&gt; is used to declare an &lt;a href=&quot;../reference/items/associated-items#associated-types&quot;&gt;associated type&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31d52c1f8837d60baebd5fe1bd8acd4770d12408" translate="yes" xml:space="preserve">
          <source>In types, the &lt;code&gt;+&lt;/code&gt; type operator has low precedence, so it is often necessary to use parentheses.</source>
          <target state="translated">En tipos, el operador de tipo &lt;code&gt;+&lt;/code&gt; tiene baja precedencia, por lo que a menudo es necesario utilizar par&amp;eacute;ntesis.</target>
        </trans-unit>
        <trans-unit id="f9490ac1bbc7d37c9f2c0e3e394c8775ef19ff65" translate="yes" xml:space="preserve">
          <source>In types, the &lt;code&gt;+&lt;/code&gt; type operator has low precedence, so it is often necessary to use parentheses:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd1daf40491a926084464e0388144e6ba829d637" translate="yes" xml:space="preserve">
          <source>In various places in the book, we&amp;rsquo;ve discussed the &lt;code&gt;derive&lt;/code&gt; attribute, which you can apply to a struct or enum definition. The &lt;code&gt;derive&lt;/code&gt; attribute generates code that will implement a trait with its own default implementation on the type you&amp;rsquo;ve annotated with the &lt;code&gt;derive&lt;/code&gt; syntax.</source>
          <target state="translated">En varios lugares del libro, hemos discutido el atributo &lt;code&gt;derive&lt;/code&gt; , que puede aplicar a una definici&amp;oacute;n de estructura o enumeraci&amp;oacute;n. El atributo &lt;code&gt;derive&lt;/code&gt; genera c&amp;oacute;digo que implementar&amp;aacute; un rasgo con su propia implementaci&amp;oacute;n predeterminada en el tipo que ha anotado con la sintaxis &lt;code&gt;derive&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cebe38e502b4e0d3a49a067f9739636c8c7567e" translate="yes" xml:space="preserve">
          <source>In very rare edge cases, this may happen when loading &lt;code&gt;core&lt;/code&gt; or &lt;code&gt;std&lt;/code&gt; twice, once with &lt;code&gt;check&lt;/code&gt; metadata and once with &lt;code&gt;build&lt;/code&gt; metadata. For more information, see &lt;a href=&quot;https://github.com/rust-lang/rust/pull/75176#issuecomment-683234468&quot;&gt;#75176&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fcacf884bdd57e38c179c26c2a445daf0a3b88d" translate="yes" xml:space="preserve">
          <source>In-band lifetimes cannot be mixed with explicit lifetime binders. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c1253e722ca01693911433634c27b9199fbe1b5" translate="yes" xml:space="preserve">
          <source>In-band lifetimes cannot be used in &lt;code&gt;fn&lt;/code&gt;/&lt;code&gt;Fn&lt;/code&gt; syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0307fb1316fe032b75c2eab1c02683137e89f74" translate="yes" xml:space="preserve">
          <source>In-band lifetimes were mixed with explicit lifetime binders.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71195f6d729d094826e987475aa2b83d4c3354c6" translate="yes" xml:space="preserve">
          <source>InPlaceIterable</source>
          <target state="translated">InPlaceIterable</target>
        </trans-unit>
        <trans-unit id="0d84c9de7449d934ab38cca665ee24ab8d418e04" translate="yes" xml:space="preserve">
          <source>Includes a UTF-8 encoded file as a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42e257e75b3e4fa6d9e9989f973afa801a9a03f0" translate="yes" xml:space="preserve">
          <source>Includes a file as a reference to a byte array.</source>
          <target state="translated">Incluye un archivo como referencia a una matriz de bytes.</target>
        </trans-unit>
        <trans-unit id="9c140715e3185328a980b4bc60a18b0febc51520" translate="yes" xml:space="preserve">
          <source>Includes a utf8-encoded file as a string.</source>
          <target state="translated">Incluye un archivo codificado en utf8 como cadena.</target>
        </trans-unit>
        <trans-unit id="0c11e0c644b5890be96bab7620a548663254f1f7" translate="yes" xml:space="preserve">
          <source>Includes all extension traits, and some important type definitions.</source>
          <target state="translated">Incluye todos los rasgos de extensión y algunas definiciones de tipos importantes.</target>
        </trans-unit>
        <trans-unit id="a9c615b9e833ee226ac08cb33f93df17a615ca30" translate="yes" xml:space="preserve">
          <source>Incoming</source>
          <target state="translated">Incoming</target>
        </trans-unit>
        <trans-unit id="805a014cffe854e2c811b260ab089d2eda0bbeb7" translate="yes" xml:space="preserve">
          <source>Incoming::all</source>
          <target state="translated">Incoming::all</target>
        </trans-unit>
        <trans-unit id="83bd443d175b9e89de0c8b8872961ea2816dcfb6" translate="yes" xml:space="preserve">
          <source>Incoming::any</source>
          <target state="translated">Incoming::any</target>
        </trans-unit>
        <trans-unit id="f9822b9a823019e577bdfe3ac98493f3aa60473c" translate="yes" xml:space="preserve">
          <source>Incoming::borrow</source>
          <target state="translated">Incoming::borrow</target>
        </trans-unit>
        <trans-unit id="db57c16634c0af16618401e02b9b1b14cfb90675" translate="yes" xml:space="preserve">
          <source>Incoming::borrow_mut</source>
          <target state="translated">Incoming::borrow_mut</target>
        </trans-unit>
        <trans-unit id="909a090d9b0ea3ec427658ae73388b50d4bfbc1f" translate="yes" xml:space="preserve">
          <source>Incoming::by_ref</source>
          <target state="translated">Incoming::by_ref</target>
        </trans-unit>
        <trans-unit id="6d7e9108e413d8a837bb790d96b999eaae29b3f2" translate="yes" xml:space="preserve">
          <source>Incoming::chain</source>
          <target state="translated">Incoming::chain</target>
        </trans-unit>
        <trans-unit id="30254dbd6651bc8d2ce9a6489cb59513c462d366" translate="yes" xml:space="preserve">
          <source>Incoming::cloned</source>
          <target state="translated">Incoming::cloned</target>
        </trans-unit>
        <trans-unit id="8a2bf20be5038460f2e5f09718d4cb6a21fb4c03" translate="yes" xml:space="preserve">
          <source>Incoming::cmp</source>
          <target state="translated">Incoming::cmp</target>
        </trans-unit>
        <trans-unit id="5ed0bcc65453a7978586b3e2016dacfbc14352fe" translate="yes" xml:space="preserve">
          <source>Incoming::collect</source>
          <target state="translated">Incoming::collect</target>
        </trans-unit>
        <trans-unit id="e70d0d30256802ac0658826bed8a56d75ffa6c45" translate="yes" xml:space="preserve">
          <source>Incoming::copied</source>
          <target state="translated">Incoming::copied</target>
        </trans-unit>
        <trans-unit id="a1ce4c03ba198d6862609c9bca7b4fdfd0e790c1" translate="yes" xml:space="preserve">
          <source>Incoming::count</source>
          <target state="translated">Incoming::count</target>
        </trans-unit>
        <trans-unit id="445c24f8aeffb804abbe66eac8d728adfa6384c3" translate="yes" xml:space="preserve">
          <source>Incoming::cycle</source>
          <target state="translated">Incoming::cycle</target>
        </trans-unit>
        <trans-unit id="c7373d860bdcd6bd00f58afd7287948921f2cf3d" translate="yes" xml:space="preserve">
          <source>Incoming::enumerate</source>
          <target state="translated">Incoming::enumerate</target>
        </trans-unit>
        <trans-unit id="422e90f2e0427cea81726aa22dde243c959e3442" translate="yes" xml:space="preserve">
          <source>Incoming::eq</source>
          <target state="translated">Incoming::eq</target>
        </trans-unit>
        <trans-unit id="d82ad0962be1b645dba4415057b56c8c71d2db6c" translate="yes" xml:space="preserve">
          <source>Incoming::filter</source>
          <target state="translated">Incoming::filter</target>
        </trans-unit>
        <trans-unit id="f2d060b73d6c431a592011fdcaf80f72c4327ea7" translate="yes" xml:space="preserve">
          <source>Incoming::filter_map</source>
          <target state="translated">Incoming::filter_map</target>
        </trans-unit>
        <trans-unit id="ec24aef48051e0d66dfbf513fbece0b535e8173a" translate="yes" xml:space="preserve">
          <source>Incoming::find</source>
          <target state="translated">Incoming::find</target>
        </trans-unit>
        <trans-unit id="9f1745b317ce967f0969bdd91f79615c9788ba14" translate="yes" xml:space="preserve">
          <source>Incoming::find_map</source>
          <target state="translated">Incoming::find_map</target>
        </trans-unit>
        <trans-unit id="57ed09c2ac8fbae367da14cf88b9a1cf3a0b0f16" translate="yes" xml:space="preserve">
          <source>Incoming::flat_map</source>
          <target state="translated">Incoming::flat_map</target>
        </trans-unit>
        <trans-unit id="aa8cfa9877df81bdf6f3e26ae8c327e4f18e7ca7" translate="yes" xml:space="preserve">
          <source>Incoming::flatten</source>
          <target state="translated">Incoming::flatten</target>
        </trans-unit>
        <trans-unit id="f534c99639d2a7b60622d67e3da268c1b2dbd8a2" translate="yes" xml:space="preserve">
          <source>Incoming::fmt</source>
          <target state="translated">Incoming::fmt</target>
        </trans-unit>
        <trans-unit id="7bf954d9f452b8f0bff229d58d17ebe667b8bdaa" translate="yes" xml:space="preserve">
          <source>Incoming::fold</source>
          <target state="translated">Incoming::fold</target>
        </trans-unit>
        <trans-unit id="f45d04534657562b3b8e1ac8b93f0995c4f52ffc" translate="yes" xml:space="preserve">
          <source>Incoming::for_each</source>
          <target state="translated">Incoming::for_each</target>
        </trans-unit>
        <trans-unit id="146d704978de3d221c4a8b538e653f767ff7d0cc" translate="yes" xml:space="preserve">
          <source>Incoming::from</source>
          <target state="translated">Incoming::from</target>
        </trans-unit>
        <trans-unit id="8d00e730beb7664120c689b2165fe55c7e43696b" translate="yes" xml:space="preserve">
          <source>Incoming::fuse</source>
          <target state="translated">Incoming::fuse</target>
        </trans-unit>
        <trans-unit id="d6f3fa46377ae997728223371f8e2928bbcd46ee" translate="yes" xml:space="preserve">
          <source>Incoming::ge</source>
          <target state="translated">Incoming::ge</target>
        </trans-unit>
        <trans-unit id="ed38c0b5ef84ea5163b2da693e4b72183ddee0ec" translate="yes" xml:space="preserve">
          <source>Incoming::gt</source>
          <target state="translated">Incoming::gt</target>
        </trans-unit>
        <trans-unit id="b1345261a277f185321d6adb9b350bcb58cd599e" translate="yes" xml:space="preserve">
          <source>Incoming::inspect</source>
          <target state="translated">Incoming::inspect</target>
        </trans-unit>
        <trans-unit id="59abb681c116c064869e4b015c6b1cd16fb45598" translate="yes" xml:space="preserve">
          <source>Incoming::into</source>
          <target state="translated">Incoming::into</target>
        </trans-unit>
        <trans-unit id="95a20422d3926772d9c359f121355edbd8f745f9" translate="yes" xml:space="preserve">
          <source>Incoming::into_iter</source>
          <target state="translated">Incoming::into_iter</target>
        </trans-unit>
        <trans-unit id="77b7ce153ce8067d29a7d019ff3fcc043c2fdd8e" translate="yes" xml:space="preserve">
          <source>Incoming::is_sorted</source>
          <target state="translated">Incoming::is_sorted</target>
        </trans-unit>
        <trans-unit id="4dfdf545d2798411e8ee50244269b54395d86c9a" translate="yes" xml:space="preserve">
          <source>Incoming::is_sorted_by</source>
          <target state="translated">Incoming::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="d90a5dfb897aff5c068a0a4a12a54de5b9bdf1da" translate="yes" xml:space="preserve">
          <source>Incoming::is_sorted_by_key</source>
          <target state="translated">Incoming::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="f1c770fca353b885ee610fe1f519139cdebcc0ee" translate="yes" xml:space="preserve">
          <source>Incoming::last</source>
          <target state="translated">Incoming::last</target>
        </trans-unit>
        <trans-unit id="f5c79843bca5e97321f55d85100e1ac93d537dd7" translate="yes" xml:space="preserve">
          <source>Incoming::le</source>
          <target state="translated">Incoming::le</target>
        </trans-unit>
        <trans-unit id="41753aa4086d7645034ac6f543870deca487abbb" translate="yes" xml:space="preserve">
          <source>Incoming::lt</source>
          <target state="translated">Incoming::lt</target>
        </trans-unit>
        <trans-unit id="42262cd6a3c45e0c4ccd2f403ab3dde4f31c999d" translate="yes" xml:space="preserve">
          <source>Incoming::map</source>
          <target state="translated">Incoming::map</target>
        </trans-unit>
        <trans-unit id="b14fbc258acb1391be68964dacf06c868d0223ee" translate="yes" xml:space="preserve">
          <source>Incoming::max</source>
          <target state="translated">Incoming::max</target>
        </trans-unit>
        <trans-unit id="e598cfd5a561805bab3a055536a7ce8d4cbc0d87" translate="yes" xml:space="preserve">
          <source>Incoming::max_by</source>
          <target state="translated">Incoming::max_by</target>
        </trans-unit>
        <trans-unit id="02e8830cd577c40509d7ca817740c861b52c07c0" translate="yes" xml:space="preserve">
          <source>Incoming::max_by_key</source>
          <target state="translated">Incoming::max_by_key</target>
        </trans-unit>
        <trans-unit id="e522553048356a9c7e3aafb53205e73c814823fd" translate="yes" xml:space="preserve">
          <source>Incoming::min</source>
          <target state="translated">Incoming::min</target>
        </trans-unit>
        <trans-unit id="8b1b84ed0cee495bc315c75dc85c4916ce7f680f" translate="yes" xml:space="preserve">
          <source>Incoming::min_by</source>
          <target state="translated">Incoming::min_by</target>
        </trans-unit>
        <trans-unit id="94a6455843a6def08f4247ddbcf5a373aff6a12c" translate="yes" xml:space="preserve">
          <source>Incoming::min_by_key</source>
          <target state="translated">Incoming::min_by_key</target>
        </trans-unit>
        <trans-unit id="af6f0e0d448b8971f8088a94ecfe2c2c28074b20" translate="yes" xml:space="preserve">
          <source>Incoming::ne</source>
          <target state="translated">Incoming::ne</target>
        </trans-unit>
        <trans-unit id="ad9f2df7e05588db669a49fe0bfa35787281e257" translate="yes" xml:space="preserve">
          <source>Incoming::next</source>
          <target state="translated">Incoming::next</target>
        </trans-unit>
        <trans-unit id="15fdadbdf731ff5f14bd01d14581b0031b5aa856" translate="yes" xml:space="preserve">
          <source>Incoming::nth</source>
          <target state="translated">Incoming::nth</target>
        </trans-unit>
        <trans-unit id="f584fdb6a022a6b9c2041ae0049adb844c00af0a" translate="yes" xml:space="preserve">
          <source>Incoming::partial_cmp</source>
          <target state="translated">Incoming::partial_cmp</target>
        </trans-unit>
        <trans-unit id="d6e7347d2f13179a0246ad8c2f8f8c42d5ea1e8b" translate="yes" xml:space="preserve">
          <source>Incoming::partition</source>
          <target state="translated">Incoming::partition</target>
        </trans-unit>
        <trans-unit id="d15dc3a739c395fba4cdef1bb3db41863ef399f5" translate="yes" xml:space="preserve">
          <source>Incoming::peekable</source>
          <target state="translated">Incoming::peekable</target>
        </trans-unit>
        <trans-unit id="cab06ddc3af8abd52b92e45544310b0faa110219" translate="yes" xml:space="preserve">
          <source>Incoming::position</source>
          <target state="translated">Incoming::position</target>
        </trans-unit>
        <trans-unit id="bb23c8eb76a6d68dfc63c6d32849abe960c1b856" translate="yes" xml:space="preserve">
          <source>Incoming::product</source>
          <target state="translated">Incoming::product</target>
        </trans-unit>
        <trans-unit id="b3d90889f7b30454426b3ed4e11228f5d9d8ee9f" translate="yes" xml:space="preserve">
          <source>Incoming::rev</source>
          <target state="translated">Incoming::rev</target>
        </trans-unit>
        <trans-unit id="d662587d11104ca4324befe21e5aaa1cf3ed3fa3" translate="yes" xml:space="preserve">
          <source>Incoming::rposition</source>
          <target state="translated">Incoming::rposition</target>
        </trans-unit>
        <trans-unit id="6b42372525b119239ec4bd20dc7bf69a1a105a08" translate="yes" xml:space="preserve">
          <source>Incoming::scan</source>
          <target state="translated">Incoming::scan</target>
        </trans-unit>
        <trans-unit id="c1399e28a107bc4249663ed0d2b97e798127c9c6" translate="yes" xml:space="preserve">
          <source>Incoming::size_hint</source>
          <target state="translated">Incoming::size_hint</target>
        </trans-unit>
        <trans-unit id="85ee70ca43a998ef206f4a945f59006b6f40ddfa" translate="yes" xml:space="preserve">
          <source>Incoming::skip</source>
          <target state="translated">Incoming::skip</target>
        </trans-unit>
        <trans-unit id="fdd32c3e0206952202e83705e9d627eb48f607e6" translate="yes" xml:space="preserve">
          <source>Incoming::skip_while</source>
          <target state="translated">Incoming::skip_while</target>
        </trans-unit>
        <trans-unit id="5a589e1b9602c4ff48aa22e65968275507ea9485" translate="yes" xml:space="preserve">
          <source>Incoming::step_by</source>
          <target state="translated">Incoming::step_by</target>
        </trans-unit>
        <trans-unit id="d9ed48df44b20a36de8b0990f9b0c9b964475772" translate="yes" xml:space="preserve">
          <source>Incoming::sum</source>
          <target state="translated">Incoming::sum</target>
        </trans-unit>
        <trans-unit id="bcf6381c826c50e1aaea7423243d1529dca214b8" translate="yes" xml:space="preserve">
          <source>Incoming::take</source>
          <target state="translated">Incoming::take</target>
        </trans-unit>
        <trans-unit id="981c1e08f556e3870dd2af3a144f3176473200b7" translate="yes" xml:space="preserve">
          <source>Incoming::take_while</source>
          <target state="translated">Incoming::take_while</target>
        </trans-unit>
        <trans-unit id="2f0356552ebde5f1c3f3f3ad37fa03b3d1bf90bd" translate="yes" xml:space="preserve">
          <source>Incoming::try_fold</source>
          <target state="translated">Incoming::try_fold</target>
        </trans-unit>
        <trans-unit id="5c1f1df01cacdbf861258e63eb2cb8581f88d043" translate="yes" xml:space="preserve">
          <source>Incoming::try_for_each</source>
          <target state="translated">Incoming::try_for_each</target>
        </trans-unit>
        <trans-unit id="9a58299e31b9803379553db37123ab15774b671d" translate="yes" xml:space="preserve">
          <source>Incoming::try_from</source>
          <target state="translated">Incoming::try_from</target>
        </trans-unit>
        <trans-unit id="fff541a38a97a609e5012c516e4164326cfb79eb" translate="yes" xml:space="preserve">
          <source>Incoming::try_into</source>
          <target state="translated">Incoming::try_into</target>
        </trans-unit>
        <trans-unit id="946f55dc3e1af640cd291f2aaa8528234e768102" translate="yes" xml:space="preserve">
          <source>Incoming::type_id</source>
          <target state="translated">Incoming::type_id</target>
        </trans-unit>
        <trans-unit id="bf46b8f3bb432660f79899dee66baf3e9f087f95" translate="yes" xml:space="preserve">
          <source>Incoming::unzip</source>
          <target state="translated">Incoming::unzip</target>
        </trans-unit>
        <trans-unit id="96a8cde7e0e4c52965055072fd39e0d341071072" translate="yes" xml:space="preserve">
          <source>Incoming::zip</source>
          <target state="translated">Incoming::zip</target>
        </trans-unit>
        <trans-unit id="bcbf83cd2f0ed89c4d2689129dde9ed148866efc" translate="yes" xml:space="preserve">
          <source>Incorrect bytes:</source>
          <target state="translated">Bytes incorrectos:</target>
        </trans-unit>
        <trans-unit id="2a70492a6aefdfa404f3b9ac0c6d0448b88be337" translate="yes" xml:space="preserve">
          <source>Incorrect usage</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d7c0e61e47d8d76b1fdbcd2b9644ebc448b482b" translate="yes" xml:space="preserve">
          <source>Increments the strong reference count on the &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; associated with the provided pointer by one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="52cb15ca8d9c1e4b950b26ef1f32246271f50339" translate="yes" xml:space="preserve">
          <source>Index expressions on arrays and slices</source>
          <target state="translated">Expresiones de índice en matrices y cortes</target>
        </trans-unit>
        <trans-unit id="361d6f89c121ce39bb2ed14f7085cd248645d21b" translate="yes" xml:space="preserve">
          <source>Index expressions, &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;array indexing&lt;/a&gt; or &lt;a href=&quot;types/slice&quot;&gt;slice&lt;/a&gt; with a &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">Expresiones de &amp;iacute;ndice, &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;indexaci&amp;oacute;n de matrices&lt;/a&gt; o &lt;a href=&quot;types/slice&quot;&gt;corte&lt;/a&gt; con un &lt;code&gt;usize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="528b0ff12e28b750b5aeda40648664d5f6804c7c" translate="yes" xml:space="preserve">
          <source>Index::index</source>
          <target state="translated">Index::index</target>
        </trans-unit>
        <trans-unit id="21d657443793a7fc6c319cfc186e761fac77191e" translate="yes" xml:space="preserve">
          <source>IndexMut</source>
          <target state="translated">IndexMut</target>
        </trans-unit>
        <trans-unit id="24f9ef47b9bb8985e28653af23b1accbf6cd2d9b" translate="yes" xml:space="preserve">
          <source>IndexMut::index_mut</source>
          <target state="translated">IndexMut::index_mut</target>
        </trans-unit>
        <trans-unit id="bda8e2dcef8324d4ce1ba450c4e2e0cae96a9a4a" translate="yes" xml:space="preserve">
          <source>Indexes must be within bounds of the original slice;</source>
          <target state="translated">Los índices deben estar dentro de los límites de la rebanada original;</target>
        </trans-unit>
        <trans-unit id="fa74cb6623de227628f45b4ae93159daddea90b3" translate="yes" xml:space="preserve">
          <source>Indexes must lie on UTF-8 sequence boundaries.</source>
          <target state="translated">Los índices deben estar en los límites de la secuencia UTF-8.</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="8e33bba2a2fe8c945dee904cfed37743c8dd2807" translate="yes" xml:space="preserve">
          <source>Indexing into Strings</source>
          <target state="translated">La indexación en las cadenas</target>
        </trans-unit>
        <trans-unit id="bc1a7f445eecf9a21ddaa6928da85497c3f808d7" translate="yes" xml:space="preserve">
          <source>Indexing into a string is often a bad idea because it&amp;rsquo;s not clear what the return type of the string-indexing operation should be: a byte value, a character, a grapheme cluster, or a string slice. Therefore, Rust asks you to be more specific if you really need to use indices to create string slices. To be more specific in your indexing and indicate that you want a string slice, rather than indexing using &lt;code&gt;[]&lt;/code&gt; with a single number, you can use &lt;code&gt;[]&lt;/code&gt; with a range to create a string slice containing particular bytes:</source>
          <target state="translated">La indexaci&amp;oacute;n en una cadena suele ser una mala idea porque no est&amp;aacute; claro cu&amp;aacute;l deber&amp;iacute;a ser el tipo de retorno de la operaci&amp;oacute;n de indexaci&amp;oacute;n de cadenas: un valor de byte, un car&amp;aacute;cter, un grupo de grafemas o un segmento de cadena. Por lo tanto, Rust le pide que sea m&amp;aacute;s espec&amp;iacute;fico si realmente necesita usar &amp;iacute;ndices para crear cortes de cadenas. Para ser m&amp;aacute;s espec&amp;iacute;fico en su indexaci&amp;oacute;n e indicar que desea un segmento de cadena, en lugar de indexar usando &lt;code&gt;[]&lt;/code&gt; con un solo n&amp;uacute;mero, puede usar &lt;code&gt;[]&lt;/code&gt; con un rango para crear un segmento de cadena que contenga bytes particulares:</target>
        </trans-unit>
        <trans-unit id="6b92d7c5b5fd6e80ddd2c2e71ae6f53dabf14469" translate="yes" xml:space="preserve">
          <source>Indexing is intended to be a constant-time operation, but UTF-8 encoding does not allow us to do this. Furthermore, it's not clear what sort of thing the index should return: a byte, a codepoint, or a grapheme cluster. The &lt;a href=&quot;#method.bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.chars&quot;&gt;&lt;code&gt;chars&lt;/code&gt;&lt;/a&gt; methods return iterators over the first two, respectively.</source>
          <target state="translated">La indexaci&amp;oacute;n est&amp;aacute; destinada a ser una operaci&amp;oacute;n de tiempo constante, pero la codificaci&amp;oacute;n UTF-8 no nos permite hacer esto. Adem&amp;aacute;s, no est&amp;aacute; claro qu&amp;eacute; tipo de cosa deber&amp;iacute;a devolver el &amp;iacute;ndice: un byte, un punto de c&amp;oacute;digo o un grupo de grafemas. Los m&amp;eacute;todos &lt;a href=&quot;#method.bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#method.chars&quot;&gt; &lt;code&gt;chars&lt;/code&gt; &lt;/a&gt; devuelven iteradores sobre los dos primeros, respectivamente.</target>
        </trans-unit>
        <trans-unit id="ceeb8ddb5f53fcb5614444876f148bbebee79484" translate="yes" xml:space="preserve">
          <source>Indexing is intended to be a constant-time operation, but UTF-8 encoding does not allow us to do this. Furthermore, it's not clear what sort of thing the index should return: a byte, a codepoint, or a grapheme cluster. The &lt;a href=&quot;../primitive.str#method.bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.str#method.chars&quot;&gt;&lt;code&gt;chars&lt;/code&gt;&lt;/a&gt; methods return iterators over the first two, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aba4d1ffc3e50a35d8e6bb2627a9921d36e96c9" translate="yes" xml:space="preserve">
          <source>Indexing outside of the bounds of an object with &lt;a href=&quot;../std/primitive.pointer#method.offset&quot;&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/a&gt; with the exception of one byte past the end of the object.</source>
          <target state="translated">Indexaci&amp;oacute;n fuera de los l&amp;iacute;mites de un objeto con &lt;a href=&quot;../std/primitive.pointer#method.offset&quot;&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/a&gt; con la excepci&amp;oacute;n de un byte m&amp;aacute;s all&amp;aacute; del final del objeto.</target>
        </trans-unit>
        <trans-unit id="27caa1fa7c65a4437e649a4888fe129281a79568" translate="yes" xml:space="preserve">
          <source>Indicates if a buffer should be initialized.</source>
          <target state="translated">Indica si se debe inicializar una memoria intermedia.</target>
        </trans-unit>
        <trans-unit id="c4c4786e638c55c48e8eb353954207ab6043189e" translate="yes" xml:space="preserve">
          <source>Indicates that directories should be created recursively, creating all parent directories. Parents that do not exist are created with the same security and permissions settings.</source>
          <target state="translated">Indica que los directorios deben ser creados recursivamente,creando todos los directorios padres.Los padres que no existen se crean con la misma configuración de seguridad y permisos.</target>
        </trans-unit>
        <trans-unit id="4856479107baf14ea55cfdf8d4985b8807716a64" translate="yes" xml:space="preserve">
          <source>Indicates the manner in which a thread exited.</source>
          <target state="translated">Indica la forma en que salió un hilo.</target>
        </trans-unit>
        <trans-unit id="075cfaf01d924967ba4b76beb1cc86c1b8ffbe22" translate="yes" xml:space="preserve">
          <source>Indicates the time-to-live value of outgoing multicast packets for this socket. The default value is 1 which means that multicast packets don't leave the local network unless explicitly requested.</source>
          <target state="translated">Indica el valor de tiempo de vida de los paquetes multicast salientes para este enchufe.El valor por defecto es 1,lo que significa que los paquetes multicast no salen de la red local a menos que se solicite explícitamente.</target>
        </trans-unit>
        <trans-unit id="888a497d6d0feb54c4bc51c8bbfa14e4db0f048b" translate="yes" xml:space="preserve">
          <source>Indicates unfinished code.</source>
          <target state="translated">Indica que el código no está terminado.</target>
        </trans-unit>
        <trans-unit id="35472c24a202b583e18e139d3d561c6674911e84" translate="yes" xml:space="preserve">
          <source>Indicates unimplemented code by panicking with a message of &quot;not implemented&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4862445239fb7cd37f48e6ace7775dcd354d2d14" translate="yes" xml:space="preserve">
          <source>Indicates unreachable code.</source>
          <target state="translated">Indica un código inalcanzable.</target>
        </trans-unit>
        <trans-unit id="cd5cea6e94489fba68a0399bcc4d11feffb0cbe4" translate="yes" xml:space="preserve">
          <source>Indicates whether a value is available or if the current task has been scheduled to receive a wakeup instead.</source>
          <target state="translated">Indica si un valor está disponible o si la tarea actual ha sido programada para recibir un despertar en su lugar.</target>
        </trans-unit>
        <trans-unit id="a5d9b716629f981c5e75c2880c16718258347eb9" translate="yes" xml:space="preserve">
          <source>Indication that contents should be center-aligned.</source>
          <target state="translated">Indicación de que el contenido debe estar alineado en el centro.</target>
        </trans-unit>
        <trans-unit id="582259f836deeb40225aa78333ee7027acddbdbe" translate="yes" xml:space="preserve">
          <source>Indication that contents should be left-aligned.</source>
          <target state="translated">Indicación de que el contenido debe estar alineado a la izquierda.</target>
        </trans-unit>
        <trans-unit id="30524864694504eb9866802047ab21c114fa2091" translate="yes" xml:space="preserve">
          <source>Indication that contents should be right-aligned.</source>
          <target state="translated">Indicación de que el contenido debe estar alineado a la derecha.</target>
        </trans-unit>
        <trans-unit id="f2cd68a3153c21de89ed40993772ed6007b02a6f" translate="yes" xml:space="preserve">
          <source>Indices are zero-based for arrays and slices. Array access is a &lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant expression&lt;/a&gt;, so bounds can be checked at compile-time with a constant index value. Otherwise a check will be performed at run-time that will put the thread in a &lt;em&gt;panicked state&lt;/em&gt; if it fails.</source>
          <target state="translated">Los &amp;iacute;ndices se basan en cero para matrices y sectores. El acceso a la matriz es una &lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;expresi&amp;oacute;n constante&lt;/a&gt; , por lo que los l&amp;iacute;mites se pueden verificar en tiempo de compilaci&amp;oacute;n con un valor de &amp;iacute;ndice constante. De lo contrario, se realizar&amp;aacute; una verificaci&amp;oacute;n en tiempo de ejecuci&amp;oacute;n que pondr&amp;aacute; al hilo en un &lt;em&gt;estado de p&amp;aacute;nico&lt;/em&gt; si falla.</target>
        </trans-unit>
        <trans-unit id="e7d8ee4a5140f0e6e32c94f9ff32453c7e40a4a3" translate="yes" xml:space="preserve">
          <source>Inequality for two &lt;code&gt;Arc&lt;/code&gt;s.</source>
          <target state="translated">Desigualdad por dos &lt;code&gt;Arc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8aa90054db987f32eec9e62690e9b9862d6f642a" translate="yes" xml:space="preserve">
          <source>Inequality for two &lt;code&gt;Rc&lt;/code&gt;s.</source>
          <target state="translated">Desigualdad por dos &lt;code&gt;Rc&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="5d55264281a8b8357477a0b1f6f6a4a72582a08d" translate="yes" xml:space="preserve">
          <source>Inert helper attributes used by procedural macro attributes applied to items are also allowed but be careful to not include these inert attributes in your final &lt;code&gt;TokenStream&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32565cc43897d204c904c25aeddc29a5a2fe5f4d" translate="yes" xml:space="preserve">
          <source>Infallible</source>
          <target state="translated">Infallible</target>
        </trans-unit>
        <trans-unit id="327440953e8036a6b78b97c190dedc5d1ddc1d6f" translate="yes" xml:space="preserve">
          <source>Infallible errors</source>
          <target state="translated">Errores infalibles</target>
        </trans-unit>
        <trans-unit id="379d563f62e4c026be425a08a60de86e8b28b34e" translate="yes" xml:space="preserve">
          <source>Infallible::borrow</source>
          <target state="translated">Infallible::borrow</target>
        </trans-unit>
        <trans-unit id="ffd9adf91cadc5963cf564501d6440dfcb9953d6" translate="yes" xml:space="preserve">
          <source>Infallible::borrow_mut</source>
          <target state="translated">Infallible::borrow_mut</target>
        </trans-unit>
        <trans-unit id="d5161b5d2a0dd973c7749267f912225db6f86b3c" translate="yes" xml:space="preserve">
          <source>Infallible::clamp</source>
          <target state="translated">Infallible::clamp</target>
        </trans-unit>
        <trans-unit id="f9dfe17efa7693fd64ca4bce650f4693dec46e6a" translate="yes" xml:space="preserve">
          <source>Infallible::clone</source>
          <target state="translated">Infallible::clone</target>
        </trans-unit>
        <trans-unit id="7c7c7505a3bdd3e6bbbfabe3c0aa36eea42c2f97" translate="yes" xml:space="preserve">
          <source>Infallible::clone_from</source>
          <target state="translated">Infallible::clone_from</target>
        </trans-unit>
        <trans-unit id="6af6b86ef345c274a60c49262dbedb50a8323471" translate="yes" xml:space="preserve">
          <source>Infallible::clone_into</source>
          <target state="translated">Infallible::clone_into</target>
        </trans-unit>
        <trans-unit id="3f4e892d27a40b0bfaf9fee7ba4a2719e5f0e03b" translate="yes" xml:space="preserve">
          <source>Infallible::cmp</source>
          <target state="translated">Infallible::cmp</target>
        </trans-unit>
        <trans-unit id="465ca79819acd2f64e9c25bd2a18d141db20f7e4" translate="yes" xml:space="preserve">
          <source>Infallible::eq</source>
          <target state="translated">Infallible::eq</target>
        </trans-unit>
        <trans-unit id="7b0120f9faa0f0e51d2f41f2228ccb58415bb901" translate="yes" xml:space="preserve">
          <source>Infallible::fmt</source>
          <target state="translated">Infallible::fmt</target>
        </trans-unit>
        <trans-unit id="7699715e87167505521e297f0cc5acf9571073ba" translate="yes" xml:space="preserve">
          <source>Infallible::from</source>
          <target state="translated">Infallible::from</target>
        </trans-unit>
        <trans-unit id="9ed64ca1536a61aeb71e791f8b0cd35996768800" translate="yes" xml:space="preserve">
          <source>Infallible::ge</source>
          <target state="translated">Infallible::ge</target>
        </trans-unit>
        <trans-unit id="6bc6944b5c980e7843d508d02dcd2bfaf58a503d" translate="yes" xml:space="preserve">
          <source>Infallible::gt</source>
          <target state="translated">Infallible::gt</target>
        </trans-unit>
        <trans-unit id="be25a1605cddc636f6f076ea8d21d97812f2aa85" translate="yes" xml:space="preserve">
          <source>Infallible::into</source>
          <target state="translated">Infallible::into</target>
        </trans-unit>
        <trans-unit id="acae0cd14002a94fe132d6ca88f1fdd5ca563403" translate="yes" xml:space="preserve">
          <source>Infallible::le</source>
          <target state="translated">Infallible::le</target>
        </trans-unit>
        <trans-unit id="2b7d09de5fbcd932797ca9cc160818ef628164b0" translate="yes" xml:space="preserve">
          <source>Infallible::lt</source>
          <target state="translated">Infallible::lt</target>
        </trans-unit>
        <trans-unit id="d981e531de4db6af3fa624928233a62cc48506b0" translate="yes" xml:space="preserve">
          <source>Infallible::max</source>
          <target state="translated">Infallible::max</target>
        </trans-unit>
        <trans-unit id="4e77b6f968c067dfd00c877ce693a33816232a84" translate="yes" xml:space="preserve">
          <source>Infallible::min</source>
          <target state="translated">Infallible::min</target>
        </trans-unit>
        <trans-unit id="1b9bdf4c04b01562bf66a579b3902b4d24df2814" translate="yes" xml:space="preserve">
          <source>Infallible::ne</source>
          <target state="translated">Infallible::ne</target>
        </trans-unit>
        <trans-unit id="593cf3934010f07d135bbd81984d0e7b07060f05" translate="yes" xml:space="preserve">
          <source>Infallible::partial_cmp</source>
          <target state="translated">Infallible::partial_cmp</target>
        </trans-unit>
        <trans-unit id="171d7fff4d94e2b47d18a78e5a1c94a683078c15" translate="yes" xml:space="preserve">
          <source>Infallible::to_owned</source>
          <target state="translated">Infallible::to_owned</target>
        </trans-unit>
        <trans-unit id="256be91884f5591734d76be10903ead44c9f209f" translate="yes" xml:space="preserve">
          <source>Infallible::to_string</source>
          <target state="translated">Infallible::to_string</target>
        </trans-unit>
        <trans-unit id="c3635403870a783a099eedcae587acfb8a52bc1f" translate="yes" xml:space="preserve">
          <source>Infallible::try_from</source>
          <target state="translated">Infallible::try_from</target>
        </trans-unit>
        <trans-unit id="3c8ee4706115d8499f3abf4d51e35db72e1ffd2e" translate="yes" xml:space="preserve">
          <source>Infallible::try_into</source>
          <target state="translated">Infallible::try_into</target>
        </trans-unit>
        <trans-unit id="9701bd213ca2d8e7962b353284539a737fba44f7" translate="yes" xml:space="preserve">
          <source>Infallible::type_id</source>
          <target state="translated">Infallible::type_id</target>
        </trans-unit>
        <trans-unit id="c548ca9534f0b8a6c18d5933d5460cae1f620bec" translate="yes" xml:space="preserve">
          <source>Inferred type</source>
          <target state="translated">Tipo inferido</target>
        </trans-unit>
        <trans-unit id="85dc47997d86458573535c2b6419f71eaedb8bec" translate="yes" xml:space="preserve">
          <source>Infinite iterators like &lt;code&gt;repeat()&lt;/code&gt; are often used with adapters like &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;Iterator::take()&lt;/code&gt;&lt;/a&gt;, in order to make them finite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b827f3090a9999d7251035ec3accdcd8d4fbe7d" translate="yes" xml:space="preserve">
          <source>Infinite iterators like &lt;code&gt;repeat()&lt;/code&gt; are often used with adapters like &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;, in order to make them finite.</source>
          <target state="translated">Los iteradores infinitos como &lt;code&gt;repeat()&lt;/code&gt; se usan a menudo con adaptadores como &lt;a href=&quot;trait.iterator#method.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; , para hacerlos finitos.</target>
        </trans-unit>
        <trans-unit id="2872d343e29a3d0faf1e93a846c0ad3b8146eceb" translate="yes" xml:space="preserve">
          <source>Infinite iterators like &lt;code&gt;repeat_with()&lt;/code&gt; are often used with adapters like &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;Iterator::take()&lt;/code&gt;&lt;/a&gt;, in order to make them finite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e414b3978173634ff311532d9eb1dc73109f5119" translate="yes" xml:space="preserve">
          <source>Infinite iterators like &lt;code&gt;repeat_with()&lt;/code&gt; are often used with adapters like &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;, in order to make them finite.</source>
          <target state="translated">Los iteradores infinitos como &lt;code&gt;repeat_with()&lt;/code&gt; se utilizan a menudo con adaptadores como &lt;a href=&quot;trait.iterator#method.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; , para hacerlos finitos.</target>
        </trans-unit>
        <trans-unit id="a2550f47e7bda60f30b73b2126315e72f6a1181f" translate="yes" xml:space="preserve">
          <source>Infinite loops</source>
          <target state="translated">Bucles infinitos</target>
        </trans-unit>
        <trans-unit id="0219fd54bd5841008b18c414a5b2dea331bad1c5" translate="yes" xml:space="preserve">
          <source>Infinity</source>
          <target state="translated">Infinity</target>
        </trans-unit>
        <trans-unit id="2caa9882f0053ecda17ba6be06a5251c1ec2645f" translate="yes" xml:space="preserve">
          <source>Infinity (&amp;infin;).</source>
          <target state="translated">Infinito (&amp;infin;).</target>
        </trans-unit>
        <trans-unit id="87a3bea62fc4aac2370741613d6bad23fc5e7898" translate="yes" xml:space="preserve">
          <source>Infinity (&amp;infin;). Use &lt;a href=&quot;../primitive.f32#associatedconstant.INFINITY&quot;&gt;&lt;code&gt;f32::INFINITY&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5889ff563c59beba5ff715c644770f8c520445a" translate="yes" xml:space="preserve">
          <source>Infinity (&amp;infin;). Use &lt;a href=&quot;../primitive.f64#associatedconstant.INFINITY&quot;&gt;&lt;code&gt;f64::INFINITY&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="584304393b0ea6955cb4308163835ca022286a68" translate="yes" xml:space="preserve">
          <source>Influences</source>
          <target state="translated">Influences</target>
        </trans-unit>
        <trans-unit id="d42473cc429103c815ee41c99ce227e6800bc064" translate="yes" xml:space="preserve">
          <source>Informally:</source>
          <target state="translated">Informally:</target>
        </trans-unit>
        <trans-unit id="50473fcaee3f0826f522b7d9bde1dee298665a6b" translate="yes" xml:space="preserve">
          <source>Informs the compiler that this point in the code is not reachable, enabling further optimizations.</source>
          <target state="translated">Informa al compilador de que este punto del código no es alcanzable,lo que permite mayores optimizaciones.</target>
        </trans-unit>
        <trans-unit id="da26edc8a2a6b051f930b8dc35ea3b2d2eb04a3f" translate="yes" xml:space="preserve">
          <source>Informs the optimizer that a condition is always true. If the condition is false, the behavior is undefined.</source>
          <target state="translated">Informa al optimizador de que una condición es siempre verdadera.Si la condición es falsa,el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="7ae97ac101c4619f2cdd3e3df7584b679394eca7" translate="yes" xml:space="preserve">
          <source>Inhabited</source>
          <target state="translated">Inhabited</target>
        </trans-unit>
        <trans-unit id="b07b5b517980bf88c19321ee29f23f8a21e0b4de" translate="yes" xml:space="preserve">
          <source>Inherent Implementations</source>
          <target state="translated">Implementaciones inherentes</target>
        </trans-unit>
        <trans-unit id="bf73ea65fd18a78a9021507f0c11c78ed2ec5124" translate="yes" xml:space="preserve">
          <source>Inherent associated types were part of &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md&quot;&gt;RFC 195&lt;/a&gt; but are not yet implemented. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/8995&quot;&gt;the tracking issue&lt;/a&gt; for the status of this implementation.</source>
          <target state="translated">Los tipos asociados inherentes eran parte de &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md&quot;&gt;RFC 195&lt;/a&gt; pero a&amp;uacute;n no se han implementado. Consulte &lt;a href=&quot;https://github.com/rust-lang/rust/issues/8995&quot;&gt;el problema de seguimiento&lt;/a&gt; para conocer el estado de esta implementaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f47cc0e78be269b94ff1fbb506eefabb2d14cd1d" translate="yes" xml:space="preserve">
          <source>Inherent implementation</source>
          <target state="translated">Aplicación inherente</target>
        </trans-unit>
        <trans-unit id="89d8c2e2efc6fafd98f5603953f0cb702613d6d3" translate="yes" xml:space="preserve">
          <source>Inherent implementations (one that do not implement a trait but provide methods associated with a type) are always safe because they are not implementing an unsafe trait. Removing the &lt;code&gt;unsafe&lt;/code&gt; keyword from the inherent implementation will resolve this error.</source>
          <target state="translated">Las implementaciones inherentes (una que no implementa un rasgo pero proporciona m&amp;eacute;todos asociados con un tipo) siempre son seguras porque no implementan un rasgo inseguro. Eliminar la palabra clave &lt;code&gt;unsafe&lt;/code&gt; de la implementaci&amp;oacute;n inherente resolver&amp;aacute; este error.</target>
        </trans-unit>
        <trans-unit id="02407dbce9ca24cc02710598fc24ae8f49c07a7e" translate="yes" xml:space="preserve">
          <source>Inherent implementations associate the contained items to the implementing type. Inherent implementations can contain &lt;a href=&quot;associated-items#associated-functions-and-methods&quot;&gt;associated functions&lt;/a&gt; (including methods) and &lt;a href=&quot;associated-items#associated-constants&quot;&gt;associated constants&lt;/a&gt;. They cannot contain associated type aliases.</source>
          <target state="translated">Las implementaciones inherentes asocian los elementos contenidos al tipo de implementaci&amp;oacute;n. Las implementaciones inherentes pueden contener &lt;a href=&quot;associated-items#associated-functions-and-methods&quot;&gt;funciones asociadas&lt;/a&gt; (incluidos m&amp;eacute;todos) y &lt;a href=&quot;associated-items#associated-constants&quot;&gt;constantes asociadas&lt;/a&gt; . No pueden contener alias de tipo asociados.</target>
        </trans-unit>
        <trans-unit id="4ccb704ced0ac70357d35287cb1c67388f967d06" translate="yes" xml:space="preserve">
          <source>Inherent method</source>
          <target state="translated">Método inherente</target>
        </trans-unit>
        <trans-unit id="c7a774bf3dce2aac99ad48347458653bbd55d325" translate="yes" xml:space="preserve">
          <source>Inherit stdin/stdout/stderr for &lt;code&gt;spawn&lt;/code&gt; or &lt;code&gt;status&lt;/code&gt;, but create pipes for &lt;code&gt;output&lt;/code&gt;</source>
          <target state="translated">Herede stdin / stdout / stderr para &lt;code&gt;spawn&lt;/code&gt; o &lt;code&gt;status&lt;/code&gt; , pero cree tuber&amp;iacute;as para la &lt;code&gt;output&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9f4e94fb7b802199fb91e731b50847b79d9607c1" translate="yes" xml:space="preserve">
          <source>Inherit the current process's environment</source>
          <target state="translated">Heredar el entorno del proceso actual</target>
        </trans-unit>
        <trans-unit id="44c348c84d3785ac5adb30ee3d2d10f68e971317" translate="yes" xml:space="preserve">
          <source>Inherit the current process's working directory</source>
          <target state="translated">Heredar el directorio de trabajo del proceso actual</target>
        </trans-unit>
        <trans-unit id="6325b69277e854d2ebda5c6558b946870708063a" translate="yes" xml:space="preserve">
          <source>Inheritance as a Type System and as Code Sharing</source>
          <target state="translated">La herencia como sistema de tipos y como código compartido</target>
        </trans-unit>
        <trans-unit id="c561edc4e8c488ada0373bbdca70237bf7b2c36a" translate="yes" xml:space="preserve">
          <source>Inheritance has recently fallen out of favor as a programming design solution in many programming languages because it&amp;rsquo;s often at risk of sharing more code than necessary. Subclasses shouldn&amp;rsquo;t always share all characteristics of their parent class but will do so with inheritance. This can make a program&amp;rsquo;s design less flexible. It also introduces the possibility of calling methods on subclasses that don&amp;rsquo;t make sense or that cause errors because the methods don&amp;rsquo;t apply to the subclass. In addition, some languages will only allow a subclass to inherit from one class, further restricting the flexibility of a program&amp;rsquo;s design.</source>
          <target state="translated">La herencia ha ca&amp;iacute;do recientemente en desgracia como soluci&amp;oacute;n de dise&amp;ntilde;o de programaci&amp;oacute;n en muchos lenguajes de programaci&amp;oacute;n porque a menudo se corre el riesgo de compartir m&amp;aacute;s c&amp;oacute;digo del necesario. Las subclases no siempre deben compartir todas las caracter&amp;iacute;sticas de su clase principal, pero lo har&amp;aacute;n con herencia. Esto puede hacer que el dise&amp;ntilde;o de un programa sea menos flexible. Tambi&amp;eacute;n introduce la posibilidad de llamar a m&amp;eacute;todos en subclases que no tienen sentido o que causan errores porque los m&amp;eacute;todos no se aplican a la subclase. Adem&amp;aacute;s, algunos lenguajes solo permitir&amp;aacute;n que una subclase herede de una clase, restringiendo a&amp;uacute;n m&amp;aacute;s la flexibilidad del dise&amp;ntilde;o de un programa.</target>
        </trans-unit>
        <trans-unit id="2e8b04bb573d36dddf2182bf5af08f053f087e52" translate="yes" xml:space="preserve">
          <source>Initial values</source>
          <target state="translated">Valores iniciales</target>
        </trans-unit>
        <trans-unit id="c904b3e1f2d0c5d733b728b7a681f23a1ee75fda" translate="yes" xml:space="preserve">
          <source>Initialization and Destruction</source>
          <target state="translated">Inicialización y destrucción</target>
        </trans-unit>
        <trans-unit id="13d802cdbafe0031cbe0ff944c50f80b718c2135" translate="yes" xml:space="preserve">
          <source>Initialization invariant</source>
          <target state="translated">Invariante de inicialización</target>
        </trans-unit>
        <trans-unit id="e4de29eb027f99abd844645c1796c2a7a7d72482" translate="yes" xml:space="preserve">
          <source>Initialization is dynamically performed on the first call to &lt;a href=&quot;struct.localkey#method.with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; within a thread, and values that implement &lt;a href=&quot;../ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; get destructed when a thread exits. Some caveats apply, which are explained below.</source>
          <target state="translated">La inicializaci&amp;oacute;n se realiza din&amp;aacute;micamente en la primera llamada a &lt;a href=&quot;struct.localkey#method.with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; dentro de un hilo, y los valores que implementan &lt;a href=&quot;../ops/trait.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; &lt;/a&gt; se destruyen cuando sale un hilo. Se aplican algunas advertencias, que se explican a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b12d9d28ca06ab166730d1a0be67505b54f2b263" translate="yes" xml:space="preserve">
          <source>Initialization of a union</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db21316277d9b77e6330bd9b3d2303f36118171f" translate="yes" xml:space="preserve">
          <source>Initialization value for static &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; values.</source>
          <target state="translated">Valor de inicializaci&amp;oacute;n para valores &lt;a href=&quot;struct.once&quot;&gt; &lt;code&gt;Once&lt;/code&gt; &lt;/a&gt; est&amp;aacute;ticos .</target>
        </trans-unit>
        <trans-unit id="777041461872120636aa50d7bf36c832a7f4df98" translate="yes" xml:space="preserve">
          <source>Initialize a result to &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; before a loop:</source>
          <target state="translated">Inicialice un resultado en &lt;a href=&quot;enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; antes de un bucle:</target>
        </trans-unit>
        <trans-unit id="26ac5e37d496de00bf60e19d042275381e3527b3" translate="yes" xml:space="preserve">
          <source>Initialized</source>
          <target state="translated">Initialized</target>
        </trans-unit>
        <trans-unit id="0c55ba13e2bd9dbfd35641ebe93792c6061e39cd" translate="yes" xml:space="preserve">
          <source>Initializer</source>
          <target state="translated">Initializer</target>
        </trans-unit>
        <trans-unit id="cb5407ce66e9cc74c7b9cdad45d317b358a42346" translate="yes" xml:space="preserve">
          <source>Initializer::borrow</source>
          <target state="translated">Initializer::borrow</target>
        </trans-unit>
        <trans-unit id="9329992da7e67d3d87b950443458d66c568d4935" translate="yes" xml:space="preserve">
          <source>Initializer::borrow_mut</source>
          <target state="translated">Initializer::borrow_mut</target>
        </trans-unit>
        <trans-unit id="8b338b461eda8eab3ac52c21c7ba950b55ddab77" translate="yes" xml:space="preserve">
          <source>Initializer::fmt</source>
          <target state="translated">Initializer::fmt</target>
        </trans-unit>
        <trans-unit id="370ad1ce33d717e00bfed251c3d4bf09120c4049" translate="yes" xml:space="preserve">
          <source>Initializer::from</source>
          <target state="translated">Initializer::from</target>
        </trans-unit>
        <trans-unit id="26ef6fd69d6de0da79344847b51c3c8c83e2b8cc" translate="yes" xml:space="preserve">
          <source>Initializer::initialize</source>
          <target state="translated">Initializer::initialize</target>
        </trans-unit>
        <trans-unit id="bdae64fb5268754bb9cc8ae6c8db2ab2a08fdbc3" translate="yes" xml:space="preserve">
          <source>Initializer::into</source>
          <target state="translated">Initializer::into</target>
        </trans-unit>
        <trans-unit id="a79949e93a459b7f8ca5406e877e55f5660e5c75" translate="yes" xml:space="preserve">
          <source>Initializer::nop</source>
          <target state="translated">Initializer::nop</target>
        </trans-unit>
        <trans-unit id="dcb257db32b009bda392da62101575610abd1f91" translate="yes" xml:space="preserve">
          <source>Initializer::should_initialize</source>
          <target state="translated">Initializer::should_initialize</target>
        </trans-unit>
        <trans-unit id="bcab8cf375f63f790f0ce8e05777079bda310ea7" translate="yes" xml:space="preserve">
          <source>Initializer::try_from</source>
          <target state="translated">Initializer::try_from</target>
        </trans-unit>
        <trans-unit id="1ce33c3dc308ea20a9c3e23385d3fd4e6cdbc2f0" translate="yes" xml:space="preserve">
          <source>Initializer::try_into</source>
          <target state="translated">Initializer::try_into</target>
        </trans-unit>
        <trans-unit id="7015bd93154feb364c2957b0fc2cdb3fe5bb0863" translate="yes" xml:space="preserve">
          <source>Initializer::type_id</source>
          <target state="translated">Initializer::type_id</target>
        </trans-unit>
        <trans-unit id="38d15bea38cc632ed42db7368869a2581cd9ac0d" translate="yes" xml:space="preserve">
          <source>Initializer::zeroing</source>
          <target state="translated">Initializer::zeroing</target>
        </trans-unit>
        <trans-unit id="b02eff8ddabee28d5ce99312e8bd3930e76e09a5" translate="yes" xml:space="preserve">
          <source>Initializes a buffer if necessary.</source>
          <target state="translated">Inicializa un buffer si es necesario.</target>
        </trans-unit>
        <trans-unit id="c1014a628ca9687c4db754c43f3628d84e3050c5" translate="yes" xml:space="preserve">
          <source>Initializing a struct field-by-field</source>
          <target state="translated">Iniciando una estructura campo por campo</target>
        </trans-unit>
        <trans-unit id="6d9d88d804a2b918f6a240e649b5e1a2aa5a1b6e" translate="yes" xml:space="preserve">
          <source>Initializing an array element-by-element</source>
          <target state="translated">Iniciando una matriz elemento por elemento</target>
        </trans-unit>
        <trans-unit id="e30e79f506a4a7b48aa6bd2ea1d1c98586736d96" translate="yes" xml:space="preserve">
          <source>Initially, the Rust team thought that ensuring memory safety and preventing concurrency problems were two separate challenges to be solved with different methods. Over time, the team discovered that the ownership and type systems are a powerful set of tools to help manage memory safety &lt;em&gt;and&lt;/em&gt; concurrency problems! By leveraging ownership and type checking, many concurrency errors are compile-time errors in Rust rather than runtime errors. Therefore, rather than making you spend lots of time trying to reproduce the exact circumstances under which a runtime concurrency bug occurs, incorrect code will refuse to compile and present an error explaining the problem. As a result, you can fix your code while you&amp;rsquo;re working on it rather than potentially after it has been shipped to production. We&amp;rsquo;ve nicknamed this aspect of Rust &lt;em&gt;fearless&lt;/em&gt;&lt;em&gt;concurrency&lt;/em&gt;. Fearless concurrency allows you to write code that is free of subtle bugs and is easy to refactor without introducing new bugs.</source>
          <target state="translated">Inicialmente, el equipo de Rust pens&amp;oacute; que garantizar la seguridad de la memoria y prevenir problemas de concurrencia eran dos desaf&amp;iacute;os separados que deb&amp;iacute;an resolverse con diferentes m&amp;eacute;todos. Con el tiempo, el equipo descubri&amp;oacute; que los sistemas de propiedad y tipo son un poderoso conjunto de herramientas para ayudar a administrar la seguridad de la memoria &lt;em&gt;y&lt;/em&gt;problemas de concurrencia! Al aprovechar la propiedad y la verificaci&amp;oacute;n de tipos, muchos errores de concurrencia son errores en tiempo de compilaci&amp;oacute;n en Rust en lugar de errores en tiempo de ejecuci&amp;oacute;n. Por lo tanto, en lugar de hacerle pasar mucho tiempo tratando de reproducir las circunstancias exactas en las que ocurre un error de concurrencia en tiempo de ejecuci&amp;oacute;n, el c&amp;oacute;digo incorrecto se negar&amp;aacute; a compilar y presentar&amp;aacute; un error que explica el problema. Como resultado, puede corregir su c&amp;oacute;digo mientras trabaja en &amp;eacute;l en lugar de potencialmente despu&amp;eacute;s de que se haya enviado a producci&amp;oacute;n. Hemos apodado este aspecto de la &lt;em&gt;intr&amp;eacute;pida &lt;/em&gt;&lt;em&gt;concurrencia&lt;/em&gt; de Rust . La simultaneidad intr&amp;eacute;pida le permite escribir c&amp;oacute;digo que est&amp;aacute; libre de errores sutiles y es f&amp;aacute;cil de refactorizar sin introducir errores nuevos.</target>
        </trans-unit>
        <trans-unit id="377c3360b199ab4bedae33ce6d834fe07f041fe6" translate="yes" xml:space="preserve">
          <source>Inline assembly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7a13c17feda3ff04e933d53202cd41c94dace05" translate="yes" xml:space="preserve">
          <source>Inner attribute</source>
          <target state="translated">Atributo interno</target>
        </trans-unit>
        <trans-unit id="565c802152b12c7dd9aea0fe59ebaacf3d1a82a3" translate="yes" xml:space="preserve">
          <source>Inner block doc comment</source>
          <target state="translated">Comentario del médico del bloque interno</target>
        </trans-unit>
        <trans-unit id="af507067e5f2cec421f889124df4ee46c1a92bbf" translate="yes" xml:space="preserve">
          <source>Inner document can only be used before items. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ca5fb7f033a9d40e84c1a1a0c29b149dc2c2561" translate="yes" xml:space="preserve">
          <source>Inner functions do not have access to their containing environment. To fix this error, you can replace the function with a closure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10264f133a74f365cfab7999c77a7091803d2786" translate="yes" xml:space="preserve">
          <source>Inner items do not inherit type or const parameters from the functions they are embedded in.</source>
          <target state="translated">Los elementos internos no heredan parámetros de tipo o constancia de las funciones en las que están incrustados.</target>
        </trans-unit>
        <trans-unit id="6909dc9a044dcde9a4fe7603daf0a9a52557aba3" translate="yes" xml:space="preserve">
          <source>Inner line doc comment</source>
          <target state="translated">Comentario del doctor de la línea interna</target>
        </trans-unit>
        <trans-unit id="1b77a7f4983f9ce773f466c761a7f6e9771bf925" translate="yes" xml:space="preserve">
          <source>Input format</source>
          <target state="translated">Formato de entrada</target>
        </trans-unit>
        <trans-unit id="daf107c7f6d6d3a06676862d762621e314a3de24" translate="yes" xml:space="preserve">
          <source>Insert and complex keys</source>
          <target state="translated">Insertar y teclas complejas</target>
        </trans-unit>
        <trans-unit id="3d9eeb934e6164d2c24b6394e6758d068509ccb2" translate="yes" xml:space="preserve">
          <source>Insertion and popping the largest element have &lt;code&gt;O(log n)&lt;/code&gt; time complexity. Checking the largest element is &lt;code&gt;O(1)&lt;/code&gt;. Converting a vector to a binary heap can be done in-place, and has &lt;code&gt;O(n)&lt;/code&gt; complexity. A binary heap can also be converted to a sorted vector in-place, allowing it to be used for an &lt;code&gt;O(n log n)&lt;/code&gt; in-place heapsort.</source>
          <target state="translated">La inserci&amp;oacute;n y la extracci&amp;oacute;n del elemento m&amp;aacute;s grande tienen una complejidad de tiempo &lt;code&gt;O(log n)&lt;/code&gt; . La verificaci&amp;oacute;n del elemento m&amp;aacute;s grande es &lt;code&gt;O(1)&lt;/code&gt; . La conversi&amp;oacute;n de un vector en un mont&amp;oacute;n binario se puede realizar en el lugar y tiene una complejidad &lt;code&gt;O(n)&lt;/code&gt; . Un mont&amp;oacute;n binario tambi&amp;eacute;n se puede convertir en un vector ordenado en el lugar, lo que permite que se utilice para un heapsort local &lt;code&gt;O(n log n)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3054fc5d210400311e9f74c38361908c7518246" translate="yes" xml:space="preserve">
          <source>Insertion and popping the largest element have &lt;em&gt;O&lt;/em&gt;(log(&lt;em&gt;n&lt;/em&gt;)) time complexity. Checking the largest element is &lt;em&gt;O&lt;/em&gt;(1). Converting a vector to a binary heap can be done in-place, and has &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) complexity. A binary heap can also be converted to a sorted vector in-place, allowing it to be used for an &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt; * log(&lt;em&gt;n&lt;/em&gt;)) in-place heapsort.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0b51cb1a3f7392b32f519dbb88d97e332d11c69" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;v&lt;/code&gt; into the option if it is &lt;a href=&quot;#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then returns a mutable reference to the contained value.</source>
          <target state="translated">Inserta &lt;code&gt;v&lt;/code&gt; en la opci&amp;oacute;n si es &lt;a href=&quot;#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , luego devuelve una referencia mutable al valor contenido.</target>
        </trans-unit>
        <trans-unit id="ea064b5e532406cd5efbee55897b1c3c1824866f" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;v&lt;/code&gt; into the option if it is &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then returns a mutable reference to the contained value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94836515b3818e2e9860b9063cc6b9696a633f85" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; into the option if it is &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then returns a mutable reference to the contained value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec673856ac415b2c56f7363563f20a74b9ab6742" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; into the option then returns a mutable reference to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="633ef776ac14fc1a5ba3722ac27ba6e3e9e74927" translate="yes" xml:space="preserve">
          <source>Inserts a character into this &lt;code&gt;String&lt;/code&gt; at a byte position.</source>
          <target state="translated">Inserta un car&amp;aacute;cter en esta &lt;code&gt;String&lt;/code&gt; en una posici&amp;oacute;n de byte.</target>
        </trans-unit>
        <trans-unit id="0a96531a2ad16ab4c68e8dd30a04fcb8b88d0c9e" translate="yes" xml:space="preserve">
          <source>Inserts a key-value pair into the map.</source>
          <target state="translated">Inserta un par clave-valor en el mapa.</target>
        </trans-unit>
        <trans-unit id="bc42a512a6b6856f7f8d324cb00ee4762d1d8f2a" translate="yes" xml:space="preserve">
          <source>Inserts a new element into the &lt;code&gt;LinkedList&lt;/code&gt; after the current one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72f7ad47cd6a43af311ed7238acb4e8855c0abcd" translate="yes" xml:space="preserve">
          <source>Inserts a new element into the &lt;code&gt;LinkedList&lt;/code&gt; before the current one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f07650e645ae306862b323d418b09fad3b7f7a0" translate="yes" xml:space="preserve">
          <source>Inserts a string slice into this &lt;code&gt;String&lt;/code&gt; at a byte position.</source>
          <target state="translated">Inserta un segmento de cadena en esta &lt;code&gt;String&lt;/code&gt; en una posici&amp;oacute;n de byte.</target>
        </trans-unit>
        <trans-unit id="7d8655d30bbaeaee48aa3f55378c0fe2a4d62e4c" translate="yes" xml:space="preserve">
          <source>Inserts a value computed from &lt;code&gt;f&lt;/code&gt; into the option if it is &lt;a href=&quot;#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then returns a mutable reference to the contained value.</source>
          <target state="translated">Inserta un valor calculado a partir de &lt;code&gt;f&lt;/code&gt; en la opci&amp;oacute;n si es &lt;a href=&quot;#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , luego devuelve una referencia mutable al valor contenido.</target>
        </trans-unit>
        <trans-unit id="cf859e7e91bd94533ccef650a59dbaf129cf0d1c" translate="yes" xml:space="preserve">
          <source>Inserts a value computed from &lt;code&gt;f&lt;/code&gt; into the option if it is &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then returns a mutable reference to the contained value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd878e1d7609b46228a7e1a93fb6e8fa8ab178e1" translate="yes" xml:space="preserve">
          <source>Inserts a value computed from &lt;code&gt;f&lt;/code&gt; into the set if the given &lt;code&gt;value&lt;/code&gt; is not present, then returns a reference to the value in the set.</source>
          <target state="translated">Inserta un valor calculado a partir de &lt;code&gt;f&lt;/code&gt; en el conjunto si el &lt;code&gt;value&lt;/code&gt; dado no est&amp;aacute; presente, luego devuelve una referencia al valor en el conjunto.</target>
        </trans-unit>
        <trans-unit id="e4c367e5c15ba31d0f216cb7099e2418408fa476" translate="yes" xml:space="preserve">
          <source>Inserts all new key-values from the iterator and replaces values with existing keys with new values returned from the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="033e5469d3495f120ca34f88432068fa89f314f7" translate="yes" xml:space="preserve">
          <source>Inserts an element at &lt;code&gt;index&lt;/code&gt; within the &lt;code&gt;VecDeque&lt;/code&gt;, shifting all elements with indices greater than or equal to &lt;code&gt;index&lt;/code&gt; towards the back.</source>
          <target state="translated">Inserta un elemento en el &lt;code&gt;index&lt;/code&gt; dentro de &lt;code&gt;VecDeque&lt;/code&gt; , desplazando todos los elementos con &amp;iacute;ndices mayores o iguales al &lt;code&gt;index&lt;/code&gt; hacia la parte posterior.</target>
        </trans-unit>
        <trans-unit id="12d5beb4f208ab2afd01a906d06c0928be9bf9f4" translate="yes" xml:space="preserve">
          <source>Inserts an element at position &lt;code&gt;index&lt;/code&gt; within the vector, shifting all elements after it to the right.</source>
          <target state="translated">Inserta un elemento en el &lt;code&gt;index&lt;/code&gt; posici&amp;oacute;n dentro del vector, desplazando todos los elementos a la derecha.</target>
        </trans-unit>
        <trans-unit id="9bb4759e4324e0dbf38962bc28c2aed1b8022c83" translate="yes" xml:space="preserve">
          <source>Inserts an owned copy of the given &lt;code&gt;value&lt;/code&gt; into the set if it is not present, then returns a reference to the value in the set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32004441f1f355a905cf795d20839963739fd9b1" translate="yes" xml:space="preserve">
          <source>Inserts or updates an environment variable mapping.</source>
          <target state="translated">Inserta o actualiza un mapa de variables de entorno.</target>
        </trans-unit>
        <trans-unit id="d407882b4597c3f9cc373c79e663633b3651a26e" translate="yes" xml:space="preserve">
          <source>Inserts the elements from the given &lt;code&gt;LinkedList&lt;/code&gt; after the current one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f751f427f5a00ba1f4ba152bfd16fef910d4b118" translate="yes" xml:space="preserve">
          <source>Inserts the elements from the given &lt;code&gt;LinkedList&lt;/code&gt; before the current one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec935fc4eff4c401230b5e9494768220ac04ae85" translate="yes" xml:space="preserve">
          <source>Inserts the given &lt;code&gt;value&lt;/code&gt; into the set if it is not present, then returns a reference to the value in the set.</source>
          <target state="translated">Inserta el &lt;code&gt;value&lt;/code&gt; dado en el conjunto si no est&amp;aacute; presente, luego devuelve una referencia al valor en el conjunto.</target>
        </trans-unit>
        <trans-unit id="10a95bea4ce01379ab8d7b752bb3fe35f6abf8b1" translate="yes" xml:space="preserve">
          <source>Inserts the given element just after the element most recently returned by &lt;code&gt;.next()&lt;/code&gt;. The inserted element does not appear in the iteration.</source>
          <target state="translated">Inserta el elemento dado justo despu&amp;eacute;s del elemento devuelto m&amp;aacute;s recientemente por &lt;code&gt;.next()&lt;/code&gt; . El elemento insertado no aparece en la iteraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="af470e35471ccbf3c83cd6c715dc2e1540c10617" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;for&lt;/code&gt; loop, we search for the byte that represents the space by using the byte literal syntax. If we find a space, we return the position. Otherwise, we return the length of the string by using &lt;code&gt;s.len()&lt;/code&gt;:</source>
          <target state="translated">Dentro del bucle &lt;code&gt;for&lt;/code&gt; , buscamos el byte que representa el espacio usando la sintaxis literal de byte. Si encontramos un espacio, devolvemos la posici&amp;oacute;n. De lo contrario, devolvemos la longitud de la cadena usando &lt;code&gt;s.len()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="49f499d15e7cb0aca0c18bf8de68e4d96c591f23" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;main&lt;/code&gt; function is the following code:</source>
          <target state="translated">Dentro de la funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; encuentra el siguiente c&amp;oacute;digo:</target>
        </trans-unit>
        <trans-unit id="743099d758832aebc06d09f96504a2db95574113" translate="yes" xml:space="preserve">
          <source>Inside the function signature and body, the name of the type parameter can be used as a type name. &lt;a href=&quot;traits&quot;&gt;Trait&lt;/a&gt; bounds can be specified for type parameters to allow methods with that trait to be called on values of that type. This is specified using the &lt;code&gt;where&lt;/code&gt; syntax:</source>
          <target state="translated">Dentro de la firma y el cuerpo de la funci&amp;oacute;n, el nombre del par&amp;aacute;metro de tipo se puede utilizar como nombre de tipo. &lt;a href=&quot;traits&quot;&gt;Trait&lt;/a&gt; l&amp;iacute;mites se pueden especificar para los par&amp;aacute;metros de tipo para permitir m&amp;eacute;todos con ese rasgo a ser llamados valores de ese tipo. Esto se especifica usando la sintaxis &lt;code&gt;where&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="18ca87afec4298d9de864e32b4eeb6a31786e496" translate="yes" xml:space="preserve">
          <source>Inspect</source>
          <target state="translated">Inspect</target>
        </trans-unit>
        <trans-unit id="82ab79e7a84c19ee615f55de9576c57f6039cbaf" translate="yes" xml:space="preserve">
          <source>Inspect::all</source>
          <target state="translated">Inspect::all</target>
        </trans-unit>
        <trans-unit id="af62c7ee7c236c7e17a30a78c2b4fcf9f79c0b4b" translate="yes" xml:space="preserve">
          <source>Inspect::any</source>
          <target state="translated">Inspect::any</target>
        </trans-unit>
        <trans-unit id="b077905231123238f4a7bb9fcc60ce75f6089a93" translate="yes" xml:space="preserve">
          <source>Inspect::borrow</source>
          <target state="translated">Inspect::borrow</target>
        </trans-unit>
        <trans-unit id="dac186ed9d0b7d57d599f5ce890d1950aca83d7e" translate="yes" xml:space="preserve">
          <source>Inspect::borrow_mut</source>
          <target state="translated">Inspect::borrow_mut</target>
        </trans-unit>
        <trans-unit id="eff030734cfa782924c1060ba45ae2c9617ddff7" translate="yes" xml:space="preserve">
          <source>Inspect::by_ref</source>
          <target state="translated">Inspect::by_ref</target>
        </trans-unit>
        <trans-unit id="c6e04f66ee740f870c7db51ddce5c394c1f5b366" translate="yes" xml:space="preserve">
          <source>Inspect::chain</source>
          <target state="translated">Inspect::chain</target>
        </trans-unit>
        <trans-unit id="af5a3161569b3cc4b1af16e096368ee36af988fd" translate="yes" xml:space="preserve">
          <source>Inspect::clone</source>
          <target state="translated">Inspect::clone</target>
        </trans-unit>
        <trans-unit id="4b8f1150495fa883babb18b3738d6b381ca35719" translate="yes" xml:space="preserve">
          <source>Inspect::clone_from</source>
          <target state="translated">Inspect::clone_from</target>
        </trans-unit>
        <trans-unit id="f20fee187ea64cd2682fd76ef634f46c65ea7337" translate="yes" xml:space="preserve">
          <source>Inspect::clone_into</source>
          <target state="translated">Inspect::clone_into</target>
        </trans-unit>
        <trans-unit id="91d60f6fbbeb3649b6191055cd46e14268f30490" translate="yes" xml:space="preserve">
          <source>Inspect::cloned</source>
          <target state="translated">Inspect::cloned</target>
        </trans-unit>
        <trans-unit id="85a2573bc9e0fcf94624c4b800d4b5742004e819" translate="yes" xml:space="preserve">
          <source>Inspect::cmp</source>
          <target state="translated">Inspect::cmp</target>
        </trans-unit>
        <trans-unit id="bb80987b9610829409c7cf311bd83c99cafb9358" translate="yes" xml:space="preserve">
          <source>Inspect::collect</source>
          <target state="translated">Inspect::collect</target>
        </trans-unit>
        <trans-unit id="6c4755e22c04a1a561bd40c8f7ed7cc9e14afdd5" translate="yes" xml:space="preserve">
          <source>Inspect::copied</source>
          <target state="translated">Inspect::copied</target>
        </trans-unit>
        <trans-unit id="d91465c1eb8c20ff2aaf256018f191b4b51027db" translate="yes" xml:space="preserve">
          <source>Inspect::count</source>
          <target state="translated">Inspect::count</target>
        </trans-unit>
        <trans-unit id="f6a3530affc366af3c3031653f04c92d94544c6f" translate="yes" xml:space="preserve">
          <source>Inspect::cycle</source>
          <target state="translated">Inspect::cycle</target>
        </trans-unit>
        <trans-unit id="2ef8727649c440036fbfd895887f256337974360" translate="yes" xml:space="preserve">
          <source>Inspect::enumerate</source>
          <target state="translated">Inspect::enumerate</target>
        </trans-unit>
        <trans-unit id="90d29ac40ce8f2f13585d9242b559870d571b0d2" translate="yes" xml:space="preserve">
          <source>Inspect::eq</source>
          <target state="translated">Inspect::eq</target>
        </trans-unit>
        <trans-unit id="3c8af74b0f8d034e93cc2689eb1582aea35cd194" translate="yes" xml:space="preserve">
          <source>Inspect::filter</source>
          <target state="translated">Inspect::filter</target>
        </trans-unit>
        <trans-unit id="0c1d967d962d5542a61729409b6700ebf061e41a" translate="yes" xml:space="preserve">
          <source>Inspect::filter_map</source>
          <target state="translated">Inspect::filter_map</target>
        </trans-unit>
        <trans-unit id="ef11d99b08eee4456cbbcf30c8d5eaf30c8a59bd" translate="yes" xml:space="preserve">
          <source>Inspect::find</source>
          <target state="translated">Inspect::find</target>
        </trans-unit>
        <trans-unit id="de75c9aaf20b405a1c60fd94f4dbe93e04bb79b9" translate="yes" xml:space="preserve">
          <source>Inspect::find_map</source>
          <target state="translated">Inspect::find_map</target>
        </trans-unit>
        <trans-unit id="4bdd706bdfb04e01d1c9af213d5586e2748a2444" translate="yes" xml:space="preserve">
          <source>Inspect::flat_map</source>
          <target state="translated">Inspect::flat_map</target>
        </trans-unit>
        <trans-unit id="adc62575b9ec6c48f327e8e73d67dd12a37fd54f" translate="yes" xml:space="preserve">
          <source>Inspect::flatten</source>
          <target state="translated">Inspect::flatten</target>
        </trans-unit>
        <trans-unit id="bf64f53f8ddafacb88390ac8654fa5e287a73a7c" translate="yes" xml:space="preserve">
          <source>Inspect::fmt</source>
          <target state="translated">Inspect::fmt</target>
        </trans-unit>
        <trans-unit id="e1203b82ecf5e7d86eeb57728448c3072c4d31ca" translate="yes" xml:space="preserve">
          <source>Inspect::fold</source>
          <target state="translated">Inspect::fold</target>
        </trans-unit>
        <trans-unit id="e36f213246f9d2f573670ffad6151bd06e3fa586" translate="yes" xml:space="preserve">
          <source>Inspect::for_each</source>
          <target state="translated">Inspect::for_each</target>
        </trans-unit>
        <trans-unit id="e7c3f5132be9e5287630addcdee29ef7865ef06d" translate="yes" xml:space="preserve">
          <source>Inspect::from</source>
          <target state="translated">Inspect::from</target>
        </trans-unit>
        <trans-unit id="fe4bfacc82f6be56fbd2cbdacbd9f9c98dbeb4d0" translate="yes" xml:space="preserve">
          <source>Inspect::fuse</source>
          <target state="translated">Inspect::fuse</target>
        </trans-unit>
        <trans-unit id="18e6f5734f2efd739f3505c74a0c0d087a45dc44" translate="yes" xml:space="preserve">
          <source>Inspect::ge</source>
          <target state="translated">Inspect::ge</target>
        </trans-unit>
        <trans-unit id="51b9499c2f6bcf728ec327afb3eadb4e80054ef7" translate="yes" xml:space="preserve">
          <source>Inspect::gt</source>
          <target state="translated">Inspect::gt</target>
        </trans-unit>
        <trans-unit id="df78def6e9a15f9326fc866aa7162363317dfe3c" translate="yes" xml:space="preserve">
          <source>Inspect::inspect</source>
          <target state="translated">Inspect::inspect</target>
        </trans-unit>
        <trans-unit id="cde84bc6a1ac6acfa3ca27e39148f1683f7a639a" translate="yes" xml:space="preserve">
          <source>Inspect::into</source>
          <target state="translated">Inspect::into</target>
        </trans-unit>
        <trans-unit id="0c85f8b299a3868a074eadb647478881cca1f5f2" translate="yes" xml:space="preserve">
          <source>Inspect::into_iter</source>
          <target state="translated">Inspect::into_iter</target>
        </trans-unit>
        <trans-unit id="93bdbca2f9e35d0382950f48be8119f4c4cd8c39" translate="yes" xml:space="preserve">
          <source>Inspect::is_empty</source>
          <target state="translated">Inspect::is_empty</target>
        </trans-unit>
        <trans-unit id="6cb061e34832197156e0eae9b796318c52eae21c" translate="yes" xml:space="preserve">
          <source>Inspect::is_sorted</source>
          <target state="translated">Inspect::is_sorted</target>
        </trans-unit>
        <trans-unit id="0b700978aa9715e5aeabd053030f7e06e5dfdbe8" translate="yes" xml:space="preserve">
          <source>Inspect::is_sorted_by</source>
          <target state="translated">Inspect::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="01522e5b03123c9816813cfbecb670d36dcf9bae" translate="yes" xml:space="preserve">
          <source>Inspect::is_sorted_by_key</source>
          <target state="translated">Inspect::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="97c7968340cdbfc55e6279e63210f8319602c3b1" translate="yes" xml:space="preserve">
          <source>Inspect::last</source>
          <target state="translated">Inspect::last</target>
        </trans-unit>
        <trans-unit id="1641c5ab204a86bd76b52647b967fa3844ee555e" translate="yes" xml:space="preserve">
          <source>Inspect::le</source>
          <target state="translated">Inspect::le</target>
        </trans-unit>
        <trans-unit id="8fedbf984d9131a9c32910d0dd8cd507c9ae41f1" translate="yes" xml:space="preserve">
          <source>Inspect::len</source>
          <target state="translated">Inspect::len</target>
        </trans-unit>
        <trans-unit id="2aae13f70bf251eedf4d622e3c8e8d7ebe509466" translate="yes" xml:space="preserve">
          <source>Inspect::lt</source>
          <target state="translated">Inspect::lt</target>
        </trans-unit>
        <trans-unit id="3c10daeba2bb0af4fb652f56b13c4f712081ee60" translate="yes" xml:space="preserve">
          <source>Inspect::map</source>
          <target state="translated">Inspect::map</target>
        </trans-unit>
        <trans-unit id="d7ab985e5175dcb4007a24ad2073cd92e1ee725b" translate="yes" xml:space="preserve">
          <source>Inspect::max</source>
          <target state="translated">Inspect::max</target>
        </trans-unit>
        <trans-unit id="5548cb84f4f36e68e97b0766437c90e71bec388e" translate="yes" xml:space="preserve">
          <source>Inspect::max_by</source>
          <target state="translated">Inspect::max_by</target>
        </trans-unit>
        <trans-unit id="dce539004497e98e80382919f2b44ac4f343a42e" translate="yes" xml:space="preserve">
          <source>Inspect::max_by_key</source>
          <target state="translated">Inspect::max_by_key</target>
        </trans-unit>
        <trans-unit id="588f749d074427554e4d2614e02fff13ad9cd053" translate="yes" xml:space="preserve">
          <source>Inspect::min</source>
          <target state="translated">Inspect::min</target>
        </trans-unit>
        <trans-unit id="60fe678c3fd98d803d7a0a967cf63b451cdaf79c" translate="yes" xml:space="preserve">
          <source>Inspect::min_by</source>
          <target state="translated">Inspect::min_by</target>
        </trans-unit>
        <trans-unit id="2487d43ef493a331b1b717bc22f40361c1ef635a" translate="yes" xml:space="preserve">
          <source>Inspect::min_by_key</source>
          <target state="translated">Inspect::min_by_key</target>
        </trans-unit>
        <trans-unit id="ffc55c77a0a3cf78936319f186df9927df3e0ccd" translate="yes" xml:space="preserve">
          <source>Inspect::ne</source>
          <target state="translated">Inspect::ne</target>
        </trans-unit>
        <trans-unit id="a43fcb5b031c0ce3926f10977d7f6a10a43f6208" translate="yes" xml:space="preserve">
          <source>Inspect::next</source>
          <target state="translated">Inspect::next</target>
        </trans-unit>
        <trans-unit id="6febe3467ee6ea45f701752f64651a80fe8404ab" translate="yes" xml:space="preserve">
          <source>Inspect::next_back</source>
          <target state="translated">Inspect::next_back</target>
        </trans-unit>
        <trans-unit id="0f9d290f3781cb4ac95ed05a1829eb899359b7f9" translate="yes" xml:space="preserve">
          <source>Inspect::nth</source>
          <target state="translated">Inspect::nth</target>
        </trans-unit>
        <trans-unit id="633dbdd78d8cdd2854d53a34adbb447ab4e90331" translate="yes" xml:space="preserve">
          <source>Inspect::nth_back</source>
          <target state="translated">Inspect::nth_back</target>
        </trans-unit>
        <trans-unit id="fc4ec8ac3236397826a770a15ac100842f901223" translate="yes" xml:space="preserve">
          <source>Inspect::partial_cmp</source>
          <target state="translated">Inspect::partial_cmp</target>
        </trans-unit>
        <trans-unit id="40853e163585e56c8285d38aa5808ca70dc06c35" translate="yes" xml:space="preserve">
          <source>Inspect::partition</source>
          <target state="translated">Inspect::partition</target>
        </trans-unit>
        <trans-unit id="9434c28e5a571fffcf6e901ec452b5ae6a98ab38" translate="yes" xml:space="preserve">
          <source>Inspect::peekable</source>
          <target state="translated">Inspect::peekable</target>
        </trans-unit>
        <trans-unit id="43968189a660c3e4fac603b379bde0cd86ad697c" translate="yes" xml:space="preserve">
          <source>Inspect::position</source>
          <target state="translated">Inspect::position</target>
        </trans-unit>
        <trans-unit id="89b4972ffab1f05ea2fbde1d69c01d599123b156" translate="yes" xml:space="preserve">
          <source>Inspect::product</source>
          <target state="translated">Inspect::product</target>
        </trans-unit>
        <trans-unit id="0443653aa8a5d69a1b0d33c9f17e2c9254f5f5d7" translate="yes" xml:space="preserve">
          <source>Inspect::rev</source>
          <target state="translated">Inspect::rev</target>
        </trans-unit>
        <trans-unit id="7cb21ca083cda72535e929cef63f871b4f3cf651" translate="yes" xml:space="preserve">
          <source>Inspect::rfind</source>
          <target state="translated">Inspect::rfind</target>
        </trans-unit>
        <trans-unit id="f79e10ec84996051e8312ada6ac965fccb6846de" translate="yes" xml:space="preserve">
          <source>Inspect::rfold</source>
          <target state="translated">Inspect::rfold</target>
        </trans-unit>
        <trans-unit id="f78976291c9758ab5955ca36b2caedb636e425a2" translate="yes" xml:space="preserve">
          <source>Inspect::rposition</source>
          <target state="translated">Inspect::rposition</target>
        </trans-unit>
        <trans-unit id="2392835414c1e0b5afa2ace3b96de2ef5ff9083c" translate="yes" xml:space="preserve">
          <source>Inspect::scan</source>
          <target state="translated">Inspect::scan</target>
        </trans-unit>
        <trans-unit id="3e468495e996e3f520360765bb1983040761bf4d" translate="yes" xml:space="preserve">
          <source>Inspect::size_hint</source>
          <target state="translated">Inspect::size_hint</target>
        </trans-unit>
        <trans-unit id="65d5d88728cb3772dee70aa6ae26fe906858cdfa" translate="yes" xml:space="preserve">
          <source>Inspect::skip</source>
          <target state="translated">Inspect::skip</target>
        </trans-unit>
        <trans-unit id="e4df02a7fa585f7bf67e2c2e7620ec2b27bf223a" translate="yes" xml:space="preserve">
          <source>Inspect::skip_while</source>
          <target state="translated">Inspect::skip_while</target>
        </trans-unit>
        <trans-unit id="81611aac4ee662fdf8e1bb6309a5396db2852250" translate="yes" xml:space="preserve">
          <source>Inspect::step_by</source>
          <target state="translated">Inspect::step_by</target>
        </trans-unit>
        <trans-unit id="333ad3419c346fac8b8d3c0fd4cc6a07785ed3a9" translate="yes" xml:space="preserve">
          <source>Inspect::sum</source>
          <target state="translated">Inspect::sum</target>
        </trans-unit>
        <trans-unit id="07c4846ffa005c2b497a796ecdc14a564003a4a8" translate="yes" xml:space="preserve">
          <source>Inspect::take</source>
          <target state="translated">Inspect::take</target>
        </trans-unit>
        <trans-unit id="4f28a1534dff8b2e2c944f0bfaafe96286e1baaa" translate="yes" xml:space="preserve">
          <source>Inspect::take_while</source>
          <target state="translated">Inspect::take_while</target>
        </trans-unit>
        <trans-unit id="2a423ad3eae2fec9385b69311ba93e53244f0ad5" translate="yes" xml:space="preserve">
          <source>Inspect::to_owned</source>
          <target state="translated">Inspect::to_owned</target>
        </trans-unit>
        <trans-unit id="a6362c52c757937e435b1eeef2d9ab055596b389" translate="yes" xml:space="preserve">
          <source>Inspect::try_fold</source>
          <target state="translated">Inspect::try_fold</target>
        </trans-unit>
        <trans-unit id="b44f87043be8c6e37fe81b5e52b558de6e2af9af" translate="yes" xml:space="preserve">
          <source>Inspect::try_for_each</source>
          <target state="translated">Inspect::try_for_each</target>
        </trans-unit>
        <trans-unit id="2933e22002dc23a223d51ac3b5541e6507691dd0" translate="yes" xml:space="preserve">
          <source>Inspect::try_from</source>
          <target state="translated">Inspect::try_from</target>
        </trans-unit>
        <trans-unit id="b21cad5abb074d64e5dc5deb026a557335ea6176" translate="yes" xml:space="preserve">
          <source>Inspect::try_into</source>
          <target state="translated">Inspect::try_into</target>
        </trans-unit>
        <trans-unit id="1fd81bf07a71bc1209ac8f8b1e33f27ed1378a45" translate="yes" xml:space="preserve">
          <source>Inspect::try_rfold</source>
          <target state="translated">Inspect::try_rfold</target>
        </trans-unit>
        <trans-unit id="0e9b8b3f317cc849ace42df081dd27ff57c0541e" translate="yes" xml:space="preserve">
          <source>Inspect::type_id</source>
          <target state="translated">Inspect::type_id</target>
        </trans-unit>
        <trans-unit id="41140164c66c290cc48804ad982a4e7115e22da9" translate="yes" xml:space="preserve">
          <source>Inspect::unzip</source>
          <target state="translated">Inspect::unzip</target>
        </trans-unit>
        <trans-unit id="fe0d4b72621d75d8a76f592b0efd07f85c74dca9" translate="yes" xml:space="preserve">
          <source>Inspect::zip</source>
          <target state="translated">Inspect::zip</target>
        </trans-unit>
        <trans-unit id="8a955d8f62cddda7e4b47eb2772b795f5ac4e929" translate="yes" xml:space="preserve">
          <source>Inspecting a foreign C string:</source>
          <target state="translated">Inspeccionando una cadena C extranjera:</target>
        </trans-unit>
        <trans-unit id="24c028aad5e4f71eb7323a7fdf907c77523124b6" translate="yes" xml:space="preserve">
          <source>Inspection and manipulation of the process's environment.</source>
          <target state="translated">Inspección y manipulación del entorno del proceso.</target>
        </trans-unit>
        <trans-unit id="2cc2859dfe537be8955a457d12a963c9483cf55a" translate="yes" xml:space="preserve">
          <source>Inspects an environment variable at compile time.</source>
          <target state="translated">Inspecciona una variable de entorno en el momento de la compilación.</target>
        </trans-unit>
        <trans-unit id="da805945f5409d032b925fa086323fea9942dc3f" translate="yes" xml:space="preserve">
          <source>Install binaries from &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;</source>
          <target state="translated">Instalar binarios desde &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="27807feadc6086bb00cc2f2fc11c34f918ce0b35" translate="yes" xml:space="preserve">
          <source>Install the latest stable version of Rust using &lt;code&gt;rustup&lt;/code&gt;</source>
          <target state="translated">Instale la &amp;uacute;ltima versi&amp;oacute;n estable de Rust usando &lt;code&gt;rustup&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="8bc95ab544ffc801a72a650102cb1b4b0031b02c" translate="yes" xml:space="preserve">
          <source>Installing &lt;code id=&quot;installing-rustup-on-linux-or-macos&quot;&gt;rustup&lt;/code&gt; on Linux or macOS</source>
          <target state="translated">Instalaci&amp;oacute;n de &lt;code id=&quot;installing-rustup-on-linux-or-macos&quot;&gt;rustup&lt;/code&gt; en Linux o macOS</target>
        </trans-unit>
        <trans-unit id="d41546865affb2f20149c73fe77f1fc24d402ca2" translate="yes" xml:space="preserve">
          <source>Installing &lt;code id=&quot;installing-rustup-on-windows&quot;&gt;rustup&lt;/code&gt; on Windows</source>
          <target state="translated">Instalaci&amp;oacute;n de &lt;code id=&quot;installing-rustup-on-windows&quot;&gt;rustup&lt;/code&gt; en Windows</target>
        </trans-unit>
        <trans-unit id="e19f38815d4acff6e4f527222a8aef2789228129" translate="yes" xml:space="preserve">
          <source>Installing Binaries from Crates.io with &lt;code id=&quot;installing-binaries-from-cratesio-with-cargo-install&quot;&gt;cargo install&lt;/code&gt;</source>
          <target state="translated">Instalaci&amp;oacute;n de binarios desde Crates.io con &lt;code id=&quot;installing-binaries-from-cratesio-with-cargo-install&quot;&gt;cargo install&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b810516d3307cdf27a35ee79c057d48b6aa21230" translate="yes" xml:space="preserve">
          <source>Installing Rust on Linux, macOS, and Windows</source>
          <target state="translated">Instalando Rust en Linux,macOS y Windows</target>
        </trans-unit>
        <trans-unit id="2c30b9b10b587e1e4e3853ef85ec4740848abbd7" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;Fn&lt;/code&gt; can be called repeatedly without mutating state.</source>
          <target state="translated">Las instancias de &lt;code&gt;Fn&lt;/code&gt; se pueden llamar repetidamente sin estado mutante.</target>
        </trans-unit>
        <trans-unit id="1322a032825805d3a73d3fe7e3a12985cf1de692" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;FnMut&lt;/code&gt; can be called repeatedly and may mutate state.</source>
          <target state="translated">Las instancias de &lt;code&gt;FnMut&lt;/code&gt; se pueden llamar repetidamente y pueden cambiar de estado.</target>
        </trans-unit>
        <trans-unit id="b9bc8df98d67671ea9af2ebbd9472094277d62c7" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;FnOnce&lt;/code&gt; can be called, but might not be callable multiple times. Because of this, if the only thing known about a type is that it implements &lt;code&gt;FnOnce&lt;/code&gt;, it can only be called once.</source>
          <target state="translated">&lt;code&gt;FnOnce&lt;/code&gt; pueden llamar instancias de FnOnce , pero es posible que no se puedan llamar varias veces. Por eso, si lo &amp;uacute;nico que se sabe de un tipo es que implementa &lt;code&gt;FnOnce&lt;/code&gt; , solo se puede llamar una vez.</target>
        </trans-unit>
        <trans-unit id="5b9d31413b772c5dc3e318115ee395c8ad114636" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;Hasher&lt;/code&gt; usually represent state that is changed while hashing data.</source>
          <target state="translated">Las instancias de &lt;code&gt;Hasher&lt;/code&gt; generalmente representan el estado que se cambia mientras se procesan los datos.</target>
        </trans-unit>
        <trans-unit id="21ec3e515a993282791572f7098d9de91b54a575" translate="yes" xml:space="preserve">
          <source>Instances of this &lt;code&gt;struct&lt;/code&gt; can be obtained by matching against the &lt;a href=&quot;enum.component#variant.Prefix&quot;&gt;&lt;code&gt;Prefix&lt;/code&gt; variant&lt;/a&gt; on &lt;a href=&quot;enum.component&quot;&gt;&lt;code&gt;Component&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Las instancias de esta &lt;code&gt;struct&lt;/code&gt; se pueden obtener comparando con la &lt;a href=&quot;enum.component#variant.Prefix&quot;&gt;variante &lt;/a&gt; &lt;code&gt;Prefix&lt;/code&gt; en &lt;a href=&quot;enum.component&quot;&gt; &lt;code&gt;Component&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e5dd7083ff5f07cec7b9b34c02884013f777ac05" translate="yes" xml:space="preserve">
          <source>Instant</source>
          <target state="translated">Instant</target>
        </trans-unit>
        <trans-unit id="b5ac78fce22209b999309e8a7436e97b10622104" translate="yes" xml:space="preserve">
          <source>Instant::add</source>
          <target state="translated">Instant::add</target>
        </trans-unit>
        <trans-unit id="e5c83578445bb46f2191fb87fb2e970bfde98993" translate="yes" xml:space="preserve">
          <source>Instant::add_assign</source>
          <target state="translated">Instant::add_assign</target>
        </trans-unit>
        <trans-unit id="0c8c3b63eb155a52c73bfac3155d0197dd1a085d" translate="yes" xml:space="preserve">
          <source>Instant::borrow</source>
          <target state="translated">Instant::borrow</target>
        </trans-unit>
        <trans-unit id="f0f79568d43ec6cff172ef06950242a1e38ab9d4" translate="yes" xml:space="preserve">
          <source>Instant::borrow_mut</source>
          <target state="translated">Instant::borrow_mut</target>
        </trans-unit>
        <trans-unit id="2e29432f378f62b734e945a4acd41b7defd436d4" translate="yes" xml:space="preserve">
          <source>Instant::checked_add</source>
          <target state="translated">Instant::checked_add</target>
        </trans-unit>
        <trans-unit id="eb4f8d11d037399c427f9a46cdb4e74b0b9fb310" translate="yes" xml:space="preserve">
          <source>Instant::checked_duration_since</source>
          <target state="translated">Instant::checked_duration_since</target>
        </trans-unit>
        <trans-unit id="f623e63718dd7f5e08fc4822d3ea1e552e483468" translate="yes" xml:space="preserve">
          <source>Instant::checked_sub</source>
          <target state="translated">Instant::checked_sub</target>
        </trans-unit>
        <trans-unit id="f7961f96937c07d9b42758cbb78758eeb1202726" translate="yes" xml:space="preserve">
          <source>Instant::clamp</source>
          <target state="translated">Instant::clamp</target>
        </trans-unit>
        <trans-unit id="a221c46ded2b61b64dcb1f60bfcb2b2993a3a5c9" translate="yes" xml:space="preserve">
          <source>Instant::clone</source>
          <target state="translated">Instant::clone</target>
        </trans-unit>
        <trans-unit id="0e4e4ec37ffa30c7418b3d4c01f925199339bd78" translate="yes" xml:space="preserve">
          <source>Instant::clone_from</source>
          <target state="translated">Instant::clone_from</target>
        </trans-unit>
        <trans-unit id="8b5bc24c2667bb02ad8d0c988c0c260c44857a92" translate="yes" xml:space="preserve">
          <source>Instant::clone_into</source>
          <target state="translated">Instant::clone_into</target>
        </trans-unit>
        <trans-unit id="e2495f5ad07793d7e77643dd4f486d02627866e1" translate="yes" xml:space="preserve">
          <source>Instant::cmp</source>
          <target state="translated">Instant::cmp</target>
        </trans-unit>
        <trans-unit id="5bb91176ea9d1de93e298e46888f1699788ffa0c" translate="yes" xml:space="preserve">
          <source>Instant::duration_since</source>
          <target state="translated">Instant::duration_since</target>
        </trans-unit>
        <trans-unit id="afcae638aa376f5908f1f30bd28087f8ac6046bd" translate="yes" xml:space="preserve">
          <source>Instant::elapsed</source>
          <target state="translated">Instant::elapsed</target>
        </trans-unit>
        <trans-unit id="243a247fce13eeb9a4a84c1d5fb1dac67574f6d1" translate="yes" xml:space="preserve">
          <source>Instant::eq</source>
          <target state="translated">Instant::eq</target>
        </trans-unit>
        <trans-unit id="c0e9c53ccf6d3d28525b5acc190c32004eb85ec8" translate="yes" xml:space="preserve">
          <source>Instant::fmt</source>
          <target state="translated">Instant::fmt</target>
        </trans-unit>
        <trans-unit id="91e13bb77c7e58f374e2d3daa91a9fc513ccb0bb" translate="yes" xml:space="preserve">
          <source>Instant::from</source>
          <target state="translated">Instant::from</target>
        </trans-unit>
        <trans-unit id="666400c2a2e214fcba1e53bc6d351d576dedbf88" translate="yes" xml:space="preserve">
          <source>Instant::ge</source>
          <target state="translated">Instant::ge</target>
        </trans-unit>
        <trans-unit id="e1545f7a496f8f598ffee1a4b219bdc08ac325eb" translate="yes" xml:space="preserve">
          <source>Instant::gt</source>
          <target state="translated">Instant::gt</target>
        </trans-unit>
        <trans-unit id="41c216d5664a8a7e6d226c8c88076fb379772e86" translate="yes" xml:space="preserve">
          <source>Instant::hash</source>
          <target state="translated">Instant::hash</target>
        </trans-unit>
        <trans-unit id="754e2486a3657aa16f85c8a3399792e46fc3859e" translate="yes" xml:space="preserve">
          <source>Instant::hash_slice</source>
          <target state="translated">Instant::hash_slice</target>
        </trans-unit>
        <trans-unit id="77b8dcf93181fdfb9c2ccd019961362f091bc10d" translate="yes" xml:space="preserve">
          <source>Instant::into</source>
          <target state="translated">Instant::into</target>
        </trans-unit>
        <trans-unit id="27c580d98c20ea09e90f23c4e7129dd284f1e540" translate="yes" xml:space="preserve">
          <source>Instant::le</source>
          <target state="translated">Instant::le</target>
        </trans-unit>
        <trans-unit id="077dca8f66a9fddef8fd3afcd25ba70cba946a7c" translate="yes" xml:space="preserve">
          <source>Instant::lt</source>
          <target state="translated">Instant::lt</target>
        </trans-unit>
        <trans-unit id="5f279b9b945d564222473676176af94a42a66352" translate="yes" xml:space="preserve">
          <source>Instant::max</source>
          <target state="translated">Instant::max</target>
        </trans-unit>
        <trans-unit id="1fef472f05cd2b320ab2c2019b4644689c5cb2f0" translate="yes" xml:space="preserve">
          <source>Instant::min</source>
          <target state="translated">Instant::min</target>
        </trans-unit>
        <trans-unit id="2607167b08c7b923c8543daeccd1a89c638f791c" translate="yes" xml:space="preserve">
          <source>Instant::ne</source>
          <target state="translated">Instant::ne</target>
        </trans-unit>
        <trans-unit id="2e89ed9eeb6e6fedfd76e029598f95d52ac89e9c" translate="yes" xml:space="preserve">
          <source>Instant::now</source>
          <target state="translated">Instant::now</target>
        </trans-unit>
        <trans-unit id="ef217fe283814eb7e0d5fb84203270e40f97b8d2" translate="yes" xml:space="preserve">
          <source>Instant::partial_cmp</source>
          <target state="translated">Instant::partial_cmp</target>
        </trans-unit>
        <trans-unit id="bf1b8520fb2822b3f5cb83bccfd646a516fffcbf" translate="yes" xml:space="preserve">
          <source>Instant::saturating_duration_since</source>
          <target state="translated">Instant::saturating_duration_since</target>
        </trans-unit>
        <trans-unit id="9ed1ccf1a589fe42420c89b940730dc8b7982f7d" translate="yes" xml:space="preserve">
          <source>Instant::sub</source>
          <target state="translated">Instant::sub</target>
        </trans-unit>
        <trans-unit id="57ade0b6d4dcc1517fdb9cf85b73a61857e80559" translate="yes" xml:space="preserve">
          <source>Instant::sub_assign</source>
          <target state="translated">Instant::sub_assign</target>
        </trans-unit>
        <trans-unit id="bdec0c97db20d86ebdd661571569d5a69a65be45" translate="yes" xml:space="preserve">
          <source>Instant::to_owned</source>
          <target state="translated">Instant::to_owned</target>
        </trans-unit>
        <trans-unit id="0901e5a9482040c503269599b849e7e300181ba0" translate="yes" xml:space="preserve">
          <source>Instant::try_from</source>
          <target state="translated">Instant::try_from</target>
        </trans-unit>
        <trans-unit id="5df3e1f653d0b4e8c037a1c9641f59e6a8cbc24c" translate="yes" xml:space="preserve">
          <source>Instant::try_into</source>
          <target state="translated">Instant::try_into</target>
        </trans-unit>
        <trans-unit id="69f76dc23d56db8a52e6e54a74ec2db10116eb78" translate="yes" xml:space="preserve">
          <source>Instant::type_id</source>
          <target state="translated">Instant::type_id</target>
        </trans-unit>
        <trans-unit id="001172aad080d8306d5d4d1b5dc437b8d68f3a48" translate="yes" xml:space="preserve">
          <source>Instantiating enum variants involves explicitly using the enum's name as its namespace, followed by one of its variants. &lt;code&gt;SimpleEnum::SecondVariant&lt;/code&gt; would be an example from above. When data follows along with a variant, such as with rust's built-in &lt;a href=&quot;option/enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; type, the data is added as the type describes, for example &lt;code&gt;Option::Some(123)&lt;/code&gt;. The same follows with struct-like variants, with things looking like &lt;code&gt;ComplexEnum::LotsOfThings { usual_struct_stuff: true, blah: &quot;hello!&quot;.to_string(), }&lt;/code&gt;. Empty Enums are similar to () in that they cannot be instantiated at all, and are used mainly to mess with the type system in interesting ways.</source>
          <target state="translated">La creaci&amp;oacute;n de instancias de variantes de enumeraci&amp;oacute;n implica usar expl&amp;iacute;citamente el nombre de la enumeraci&amp;oacute;n como su espacio de nombres, seguido de una de sus variantes. &lt;code&gt;SimpleEnum::SecondVariant&lt;/code&gt; ser&amp;iacute;a un ejemplo de arriba. Cuando los datos siguen junto con una variante, como con el tipo &lt;a href=&quot;option/enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; incorporado de rust , los datos se agregan como describe el tipo, por ejemplo &lt;code&gt;Option::Some(123)&lt;/code&gt; . Lo mismo sigue con variantes de estructura similar, con cosas que se &lt;code&gt;ComplexEnum::LotsOfThings { usual_struct_stuff: true, blah: &quot;hello!&quot;.to_string(), }&lt;/code&gt; como ComplexEnum :: LotsOfThings {usual_struct_stuff: true, blah: &quot;hola!&quot;. To_string (),} . Las enumeraciones vac&amp;iacute;as son similares a () en que no se pueden instanciar en absoluto y se utilizan principalmente para alterar el sistema de tipos de formas interesantes.</target>
        </trans-unit>
        <trans-unit id="2c525f735dffbb0093cdbc000d1e1854b0b45f32" translate="yes" xml:space="preserve">
          <source>Instantiating enum variants involves explicitly using the enum's name as its namespace, followed by one of its variants. &lt;code&gt;SimpleEnum::SecondVariant&lt;/code&gt; would be an example from above. When data follows along with a variant, such as with rust's built-in &lt;a href=&quot;option/enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; type, the data is added as the type describes, for example &lt;code&gt;Option::Some(123)&lt;/code&gt;. The same follows with struct-like variants, with things looking like &lt;code&gt;ComplexEnum::LotsOfThings { usual_struct_stuff: true, blah: &quot;hello!&quot;.to_string(), }&lt;/code&gt;. Empty Enums are similar to &lt;a href=&quot;primitive.never&quot;&gt;&lt;code&gt;!&lt;/code&gt;&lt;/a&gt; in that they cannot be instantiated at all, and are used mainly to mess with the type system in interesting ways.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89d417c0066da918ab986006990b8c13e4a1c9d4" translate="yes" xml:space="preserve">
          <source>Instantiation</source>
          <target state="translated">Instantiation</target>
        </trans-unit>
        <trans-unit id="b9d10d744d3b830949e2bf595c80e084be4f440a" translate="yes" xml:space="preserve">
          <source>Instantiations of struct or variant fields</source>
          <target state="translated">Instancias de campos estructurales o variantes</target>
        </trans-unit>
        <trans-unit id="052f953d4dc163101293e43033ca426c81cc5b70" translate="yes" xml:space="preserve">
          <source>Instantiations of struct, union, or enum variant fields</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7b4faec33775d5b4afedfc919179e22bbcfd3c9" translate="yes" xml:space="preserve">
          <source>Instants are always guaranteed to be no less than any previously measured instant when created, and are often useful for tasks such as measuring benchmarks or timing how long an operation takes.</source>
          <target state="translated">Siempre se garantiza que los instantes no son menos que cualquier instante previamente medido cuando se crean,y a menudo son útiles para tareas como la medición de puntos de referencia o para cronometrar el tiempo de una operación.</target>
        </trans-unit>
        <trans-unit id="283f4073d67eb71b9aee283558af89f84e2066b3" translate="yes" xml:space="preserve">
          <source>Instants are opaque types that can only be compared to one another. There is no method to get &quot;the number of seconds&quot; from an instant. Instead, it only allows measuring the duration between two instants (or comparing two instants).</source>
          <target state="translated">Los instantáneos son tipos opacos que sólo pueden compararse entre sí.No hay ningún método para obtener &quot;el número de segundos&quot; de un instante.En cambio,sólo permite medir la duración entre dos instantes (o comparar dos instantes).</target>
        </trans-unit>
        <trans-unit id="61804bc8442fc7d7bb4e71e306aef5c0aea1b60a" translate="yes" xml:space="preserve">
          <source>Instead it is used to prevent moves through the type system, by controlling the behavior of pointers &lt;code&gt;P&lt;/code&gt; wrapped in the &lt;a href=&quot;../pin/struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt; wrapper, which &quot;pin&quot; the type in place by not allowing it to be moved out of them. See the &lt;a href=&quot;../pin/index&quot;&gt;&lt;code&gt;pin module&lt;/code&gt;&lt;/a&gt; documentation for more information on pinning.</source>
          <target state="translated">En su lugar, se utiliza para evitar movimientos a trav&amp;eacute;s del sistema de tipos, controlando el comportamiento de los punteros &lt;code&gt;P&lt;/code&gt; envueltos en la envoltura &lt;a href=&quot;../pin/struct.pin&quot;&gt; &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; &lt;/a&gt; , que &quot;fijan&quot; el tipo en su lugar al no permitir que se muevan fuera de ellos. Consulte la documentaci&amp;oacute;n del &lt;a href=&quot;../pin/index&quot;&gt; &lt;code&gt;pin module&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n sobre la colocaci&amp;oacute;n de clavijas.</target>
        </trans-unit>
        <trans-unit id="3589fb3ebd4ad6821bd6d9b7e8dfdf86bb935287" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;ok&lt;/code&gt;, the line &lt;code&gt;test tests::another&lt;/code&gt; shows &lt;code&gt;FAILED&lt;/code&gt;. Two new sections appear between the individual results and the summary: the first section displays the detailed reason for each test failure. In this case, &lt;code&gt;another&lt;/code&gt; failed because it &lt;code&gt;panicked at 'Make this test fail'&lt;/code&gt;, which happened on line 10 in the &lt;em&gt;src/lib.rs&lt;/em&gt; file. The next section lists just the names of all the failing tests, which is useful when there are lots of tests and lots of detailed failing test output. We can use the name of a failing test to run just that test to more easily debug it; we&amp;rsquo;ll talk more about ways to run tests in the &lt;a href=&quot;ch11-02-running-tests#controlling-how-tests-are-run&quot;&gt;&amp;ldquo;Controlling How Tests Are Run&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">En lugar de &lt;code&gt;ok&lt;/code&gt; , la l&amp;iacute;nea &lt;code&gt;test tests::another&lt;/code&gt; muestra &lt;code&gt;FAILED&lt;/code&gt; . Aparecen dos secciones nuevas entre los resultados individuales y el resumen: la primera secci&amp;oacute;n muestra el motivo detallado de cada falla de la prueba. En este caso, &lt;code&gt;another&lt;/code&gt; fall&amp;oacute; porque &lt;code&gt;panicked at 'Make this test fail'&lt;/code&gt; , lo que sucedi&amp;oacute; en la l&amp;iacute;nea 10 en el archivo &lt;em&gt;src / lib.rs.&lt;/em&gt; La siguiente secci&amp;oacute;n enumera solo los nombres de todas las pruebas fallidas, lo cual es &amp;uacute;til cuando hay muchas pruebas y muchos resultados detallados de pruebas fallidas. Podemos usar el nombre de una prueba fallida para ejecutar solo esa prueba y depurarla m&amp;aacute;s f&amp;aacute;cilmente; hablaremos m&amp;aacute;s sobre las formas de ejecutar pruebas en la secci&amp;oacute;n &lt;a href=&quot;ch11-02-running-tests#controlling-how-tests-are-run&quot;&gt;&quot;Control de c&amp;oacute;mo se&lt;/a&gt; ejecutan las pruebas &quot; .</target>
        </trans-unit>
        <trans-unit id="1a520d0103dd9e1e65d5d07eb5562a910a387f00" translate="yes" xml:space="preserve">
          <source>Instead of a concrete type for the &lt;code&gt;item&lt;/code&gt; parameter, we specify the &lt;code&gt;impl&lt;/code&gt; keyword and the trait name. This parameter accepts any type that implements the specified trait. In the body of &lt;code&gt;notify&lt;/code&gt;, we can call any methods on &lt;code&gt;item&lt;/code&gt; that come from the &lt;code&gt;Summary&lt;/code&gt; trait, such as &lt;code&gt;summarize&lt;/code&gt;. We can call &lt;code&gt;notify&lt;/code&gt; and pass in any instance of &lt;code&gt;NewsArticle&lt;/code&gt; or &lt;code&gt;Tweet&lt;/code&gt;. Code that calls the function with any other type, such as a &lt;code&gt;String&lt;/code&gt; or an &lt;code&gt;i32&lt;/code&gt;, won&amp;rsquo;t compile because those types don&amp;rsquo;t implement &lt;code&gt;Summary&lt;/code&gt;.</source>
          <target state="translated">En lugar de un tipo concreto para el par&amp;aacute;metro del &lt;code&gt;item&lt;/code&gt; , especificamos la palabra clave &lt;code&gt;impl&lt;/code&gt; y el nombre del rasgo. Este par&amp;aacute;metro acepta cualquier tipo que implemente el rasgo especificado. En el cuerpo de la &lt;code&gt;notify&lt;/code&gt; , podemos llamar a cualquier m&amp;eacute;todo en el &lt;code&gt;item&lt;/code&gt; que provenga del rasgo &lt;code&gt;Summary&lt;/code&gt; , como &lt;code&gt;summarize&lt;/code&gt; . Podemos llamar a &lt;code&gt;notify&lt;/code&gt; y pasar en cualquier instancia de &lt;code&gt;NewsArticle&lt;/code&gt; o &lt;code&gt;Tweet&lt;/code&gt; . El c&amp;oacute;digo que llama a la funci&amp;oacute;n con cualquier otro tipo, como &lt;code&gt;String&lt;/code&gt; o &lt;code&gt;i32&lt;/code&gt; , no se compilar&amp;aacute; porque esos tipos no implementan &lt;code&gt;Summary&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c586c2da19eaf29595cd7783a0bdd1aaa4af1f4c" translate="yes" xml:space="preserve">
          <source>Instead of adding the &lt;code&gt;assert!&lt;/code&gt; macro as we&amp;rsquo;ve done here, we could make &lt;code&gt;new&lt;/code&gt; return a &lt;code&gt;Result&lt;/code&gt; like we did with &lt;code&gt;Config::new&lt;/code&gt; in the I/O project in Listing 12-9. But we&amp;rsquo;ve decided in this case that trying to create a thread pool without any threads should be an unrecoverable error. If you&amp;rsquo;re feeling ambitious, try to write a version of &lt;code&gt;new&lt;/code&gt; with the following signature to compare both versions:</source>
          <target state="translated">&amp;iexcl;En lugar de agregar la &lt;code&gt;assert!&lt;/code&gt; macro como lo hemos hecho aqu&amp;iacute;, podr&amp;iacute;amos hacer &lt;code&gt;new&lt;/code&gt; return un &lt;code&gt;Result&lt;/code&gt; como hicimos con &lt;code&gt;Config::new&lt;/code&gt; en el proyecto de E / S en el Listado 12-9. Pero hemos decidido en este caso que intentar crear un grupo de subprocesos sin subprocesos deber&amp;iacute;a ser un error irrecuperable. Si se siente ambicioso, intente escribir una versi&amp;oacute;n de &lt;code&gt;new&lt;/code&gt; con la siguiente firma para comparar ambas versiones:</target>
        </trans-unit>
        <trans-unit id="9745bfc2f2927dceb9288ed29cf395b852078f44" translate="yes" xml:space="preserve">
          <source>Instead of always calling the &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; function before the &lt;code&gt;if&lt;/code&gt; blocks, we can define a closure and store the &lt;em&gt;closure&lt;/em&gt; in a variable rather than storing the result of the function call, as shown in Listing 13-5. We can actually move the whole body of &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; within the closure we&amp;rsquo;re introducing here.</source>
          <target state="translated">En lugar de llamar siempre a la funci&amp;oacute;n &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; antes de los bloques &lt;code&gt;if&lt;/code&gt; , podemos definir un cierre y almacenar el &lt;em&gt;cierre&lt;/em&gt; en una variable en lugar de almacenar el resultado de la llamada a la funci&amp;oacute;n, como se muestra en el Listado 13-5. De hecho, podemos mover todo el cuerpo del &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; dentro del cierre que presentamos aqu&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="ae67e98f84394870dad9c2dee4383fa199b41a3d" translate="yes" xml:space="preserve">
          <source>Instead of comparing the iterator's elements directly, this function compares the keys of the elements, as determined by &lt;code&gt;f&lt;/code&gt;. Apart from that, it's equivalent to &lt;a href=&quot;trait.iterator#method.is_sorted&quot;&gt;&lt;code&gt;is_sorted&lt;/code&gt;&lt;/a&gt;; see its documentation for more information.</source>
          <target state="translated">En lugar de comparar los elementos del iterador directamente, esta funci&amp;oacute;n compara las claves de los elementos, seg&amp;uacute;n lo determinado por &lt;code&gt;f&lt;/code&gt; . Aparte de eso, es equivalente a &lt;a href=&quot;trait.iterator#method.is_sorted&quot;&gt; &lt;code&gt;is_sorted&lt;/code&gt; &lt;/a&gt; ; consulte su documentaci&amp;oacute;n para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="3f4a03c266892c8db13bbe1ed2f70b65c01aa093" translate="yes" xml:space="preserve">
          <source>Instead of comparing the slice's elements directly, this function compares the keys of the elements, as determined by &lt;code&gt;f&lt;/code&gt;. Apart from that, it's equivalent to &lt;a href=&quot;#method.is_sorted&quot;&gt;&lt;code&gt;is_sorted&lt;/code&gt;&lt;/a&gt;; see its documentation for more information.</source>
          <target state="translated">En lugar de comparar los elementos del segmento directamente, esta funci&amp;oacute;n compara las claves de los elementos, seg&amp;uacute;n lo determinado por &lt;code&gt;f&lt;/code&gt; . Aparte de eso, es equivalente a &lt;a href=&quot;#method.is_sorted&quot;&gt; &lt;code&gt;is_sorted&lt;/code&gt; &lt;/a&gt; ; consulte su documentaci&amp;oacute;n para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ab414c3f0e8d06ac0d388f321dffd0ec64ba1540" translate="yes" xml:space="preserve">
          <source>Instead of defining an inherent implementation on a reference, you could also move the reference inside the implementation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf669630673f131e83096baf2080a7fff2853dbb" translate="yes" xml:space="preserve">
          <source>Instead of saving the closure in a variable directly, we save a new instance of &lt;code&gt;Cacher&lt;/code&gt; that holds the closure. Then, in each place we want the result, we call the &lt;code&gt;value&lt;/code&gt; method on the &lt;code&gt;Cacher&lt;/code&gt; instance. We can call the &lt;code&gt;value&lt;/code&gt; method as many times as we want, or not call it at all, and the expensive calculation will be run a maximum of once.</source>
          <target state="translated">En lugar de guardar el cierre en una variable directamente, guardamos una nueva instancia de &lt;code&gt;Cacher&lt;/code&gt; que contiene el cierre. Luego, en cada lugar donde queremos el resultado, llamamos al m&amp;eacute;todo &lt;code&gt;value&lt;/code&gt; en la instancia de &lt;code&gt;Cacher&lt;/code&gt; . Podemos llamar al m&amp;eacute;todo de &lt;code&gt;value&lt;/code&gt; tantas veces como queramos, o no llamarlo en absoluto, y el c&amp;aacute;lculo costoso se ejecutar&amp;aacute; un m&amp;aacute;ximo de una vez.</target>
        </trans-unit>
        <trans-unit id="007ce9d48190918926ae8e5decfb3ba7fb1ee115" translate="yes" xml:space="preserve">
          <source>Instead of saving the result of the build in the same directory as our code, Cargo stores it in the &lt;em&gt;target/debug&lt;/em&gt; directory.</source>
          <target state="translated">En lugar de guardar el resultado de la compilaci&amp;oacute;n en el mismo directorio que nuestro c&amp;oacute;digo, Cargo lo almacena en el directorio &lt;em&gt;target / debug&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="12c9e09de719f2e7a3f500e0f9b7335d3a4a658d" translate="yes" xml:space="preserve">
          <source>Instead of stopping at &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, the iterator will instead start again, from the beginning. After iterating again, it will start at the beginning again. And again. And again. Forever.</source>
          <target state="translated">En lugar de detenerse en &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , el iterador comenzar&amp;aacute; de nuevo, desde el principio. Despu&amp;eacute;s de iterar nuevamente, comenzar&amp;aacute; nuevamente desde el principio. Y otra vez. Y otra vez. Siempre.</target>
        </trans-unit>
        <trans-unit id="57207c003495c85f3158cd50928c0d6b80c8565c" translate="yes" xml:space="preserve">
          <source>Instead of storing a vector of &lt;code&gt;JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; instances in the thread pool, we&amp;rsquo;ll store instances of the &lt;code&gt;Worker&lt;/code&gt; struct. Each &lt;code&gt;Worker&lt;/code&gt; will store a single &lt;code&gt;JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; instance. Then we&amp;rsquo;ll implement a method on &lt;code&gt;Worker&lt;/code&gt; that will take a closure of code to run and send it to the already running thread for execution. We&amp;rsquo;ll also give each worker an &lt;code&gt;id&lt;/code&gt; so we can distinguish between the different workers in the pool when logging or debugging.</source>
          <target state="translated">En lugar de almacenar un vector de &lt;code&gt;JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; en el grupo de subprocesos, almacenaremos instancias de la estructura &lt;code&gt;Worker&lt;/code&gt; . Cada &lt;code&gt;Worker&lt;/code&gt; almacenar&amp;aacute; una &amp;uacute;nica &lt;code&gt;JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; . Luego, implementaremos un m&amp;eacute;todo en &lt;code&gt;Worker&lt;/code&gt; que tomar&amp;aacute; un cierre de c&amp;oacute;digo para ejecutarse y lo enviar&amp;aacute; al hilo que ya se est&amp;aacute; ejecutando para su ejecuci&amp;oacute;n. Tambi&amp;eacute;n le daremos a cada trabajador una &lt;code&gt;id&lt;/code&gt; entificaci&amp;oacute;n para que podamos distinguir entre los diferentes trabajadores en el grupo al iniciar sesi&amp;oacute;n o depurar.</target>
        </trans-unit>
        <trans-unit id="e496da216bd15fab37b8868b5d0249983379dbc2" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;PartialOrd::partial_cmp&lt;/code&gt;, this function uses the given &lt;code&gt;compare&lt;/code&gt; function to determine the ordering of two elements. Apart from that, it's equivalent to &lt;a href=&quot;#method.is_sorted&quot;&gt;&lt;code&gt;is_sorted&lt;/code&gt;&lt;/a&gt;; see its documentation for more information.</source>
          <target state="translated">En lugar de usar &lt;code&gt;PartialOrd::partial_cmp&lt;/code&gt; , esta funci&amp;oacute;n usa la funci&amp;oacute;n de &lt;code&gt;compare&lt;/code&gt; dada para determinar el orden de dos elementos. Aparte de eso, es equivalente a &lt;a href=&quot;#method.is_sorted&quot;&gt; &lt;code&gt;is_sorted&lt;/code&gt; &lt;/a&gt; ; consulte su documentaci&amp;oacute;n para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c10b23d92f193b5b7c4a31db6e9dd35bde4c84df" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;PartialOrd::partial_cmp&lt;/code&gt;, this function uses the given &lt;code&gt;compare&lt;/code&gt; function to determine the ordering of two elements. Apart from that, it's equivalent to &lt;a href=&quot;trait.iterator#method.is_sorted&quot;&gt;&lt;code&gt;is_sorted&lt;/code&gt;&lt;/a&gt;; see its documentation for more information.</source>
          <target state="translated">En lugar de usar &lt;code&gt;PartialOrd::partial_cmp&lt;/code&gt; , esta funci&amp;oacute;n usa la funci&amp;oacute;n de &lt;code&gt;compare&lt;/code&gt; dada para determinar el orden de dos elementos. Aparte de eso, es equivalente a &lt;a href=&quot;trait.iterator#method.is_sorted&quot;&gt; &lt;code&gt;is_sorted&lt;/code&gt; &lt;/a&gt; ; consulte su documentaci&amp;oacute;n para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="78836dae939176c5518d6cb16a8bc88f88e60ed0" translate="yes" xml:space="preserve">
          <source>Instead, the &lt;code&gt;get&lt;/code&gt; method is generic over the type of the underlying key data, called &lt;code&gt;Q&lt;/code&gt; in the method signature above. It states that &lt;code&gt;K&lt;/code&gt; borrows as a &lt;code&gt;Q&lt;/code&gt; by requiring that &lt;code&gt;K: Borrow&amp;lt;Q&amp;gt;&lt;/code&gt;. By additionally requiring &lt;code&gt;Q: Hash + Eq&lt;/code&gt;, it signals the requirement that &lt;code&gt;K&lt;/code&gt; and &lt;code&gt;Q&lt;/code&gt; have implementations of the &lt;code&gt;Hash&lt;/code&gt; and &lt;code&gt;Eq&lt;/code&gt; traits that produce identical results.</source>
          <target state="translated">En cambio, el m&amp;eacute;todo &lt;code&gt;get&lt;/code&gt; es gen&amp;eacute;rico sobre el tipo de datos clave subyacentes, llamado &lt;code&gt;Q&lt;/code&gt; en la firma del m&amp;eacute;todo anterior. Establece que &lt;code&gt;K&lt;/code&gt; toma prestado como &lt;code&gt;Q&lt;/code&gt; al requerir que &lt;code&gt;K: Borrow&amp;lt;Q&amp;gt;&lt;/code&gt; . Al requerir adicionalmente &lt;code&gt;Q: Hash + Eq&lt;/code&gt; , indica el requisito de que &lt;code&gt;K&lt;/code&gt; y &lt;code&gt;Q&lt;/code&gt; tengan implementaciones de los rasgos &lt;code&gt;Hash&lt;/code&gt; y &lt;code&gt;Eq&lt;/code&gt; que produzcan resultados id&amp;eacute;nticos.</target>
        </trans-unit>
        <trans-unit id="878f7237ad30bf50b95fb9667897fe778bbcf6bb" translate="yes" xml:space="preserve">
          <source>Instead, we can make a new type and put the validations in a function to create an instance of the type rather than repeating the validations everywhere. That way, it&amp;rsquo;s safe for functions to use the new type in their signatures and confidently use the values they receive. Listing 9-10 shows one way to define a &lt;code&gt;Guess&lt;/code&gt; type that will only create an instance of &lt;code&gt;Guess&lt;/code&gt; if the &lt;code&gt;new&lt;/code&gt; function receives a value between 1 and 100.</source>
          <target state="translated">En su lugar, podemos crear un nuevo tipo y colocar las validaciones en una funci&amp;oacute;n para crear una instancia del tipo en lugar de repetir las validaciones en todas partes. De esa manera, es seguro que las funciones usen el nuevo tipo en sus firmas y usen con confianza los valores que reciben. El Listado 9-10 muestra una forma de definir un tipo &lt;code&gt;Guess&lt;/code&gt; que solo crear&amp;aacute; una instancia de &lt;code&gt;Guess&lt;/code&gt; si la &lt;code&gt;new&lt;/code&gt; funci&amp;oacute;n recibe un valor entre 1 y 100.</target>
        </trans-unit>
        <trans-unit id="4262f2636f484912c23478cb754110e371d9c5c5" translate="yes" xml:space="preserve">
          <source>Instead, we can use nested paths to bring the same items into scope in one line. We do this by specifying the common part of the path, followed by two colons, and then curly brackets around a list of the parts of the paths that differ, as shown in Listing 7-18.</source>
          <target state="translated">En su lugar,podemos usar rutas anidadas para poner los mismos artículos en una línea.Lo hacemos especificando la parte común del camino,seguida de dos dos puntos,y luego entre corchetes alrededor de una lista de las partes de los caminos que difieren,como se muestra en la Lista 7-18.</target>
        </trans-unit>
        <trans-unit id="5890f5912d1fb9403515b5a5574c224c2a726c72" translate="yes" xml:space="preserve">
          <source>Instead, we could write this in a shorter way using &lt;code&gt;if let&lt;/code&gt;. The following code behaves the same as the &lt;code&gt;match&lt;/code&gt; in Listing 6-6:</source>
          <target state="translated">En cambio, podr&amp;iacute;amos escribir esto de una manera m&amp;aacute;s corta usando &lt;code&gt;if let&lt;/code&gt; . El siguiente c&amp;oacute;digo se comporta igual que la &lt;code&gt;match&lt;/code&gt; Listado 6-6:</target>
        </trans-unit>
        <trans-unit id="f97c87a1b2b6afb4bd47b58a7850a17ba4dcea9b" translate="yes" xml:space="preserve">
          <source>Instead, we get the following error that talks about lifetimes:</source>
          <target state="translated">En su lugar,obtenemos el siguiente error que habla de las vidas:</target>
        </trans-unit>
        <trans-unit id="e71162b50e657665aeaa9b501b8264cb1685df94" translate="yes" xml:space="preserve">
          <source>Instead, we&amp;rsquo;ll change our definition of &lt;code&gt;List&lt;/code&gt; to use &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; in place of &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, as shown in Listing 15-18. Each &lt;code&gt;Cons&lt;/code&gt; variant will now hold a value and an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; pointing to a &lt;code&gt;List&lt;/code&gt;. When we create &lt;code&gt;b&lt;/code&gt;, instead of taking ownership of &lt;code&gt;a&lt;/code&gt;, we&amp;rsquo;ll clone the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; that &lt;code&gt;a&lt;/code&gt; is holding, thereby increasing the number of references from one to two and letting &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; share ownership of the data in that &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt;. We&amp;rsquo;ll also clone &lt;code&gt;a&lt;/code&gt; when creating &lt;code&gt;c&lt;/code&gt;, increasing the number of references from two to three. Every time we call &lt;code&gt;Rc::clone&lt;/code&gt;, the reference count to the data within the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; will increase, and the data won&amp;rsquo;t be cleaned up unless there are zero references to it.</source>
          <target state="translated">En su lugar, cambiaremos nuestra definici&amp;oacute;n de &lt;code&gt;List&lt;/code&gt; a para usar &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; en lugar de &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; , como se muestra en el Listado 15-18. Cada variante de &lt;code&gt;Cons&lt;/code&gt; ahora tendr&amp;aacute; un valor y un &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; apuntando a una &lt;code&gt;List&lt;/code&gt; a . Cuando creamos &lt;code&gt;b&lt;/code&gt; , en lugar de tomar la propiedad de &lt;code&gt;a&lt;/code&gt; , vamos a clonar el &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; que &lt;code&gt;a&lt;/code&gt; est&amp;aacute; llevando a cabo, lo que aumenta el n&amp;uacute;mero de referencias de uno a dos y dejando &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; propiedad de las acciones de los datos en los que &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; . Tambi&amp;eacute;n clonaremos &lt;code&gt;a&lt;/code&gt; al crear &lt;code&gt;c&lt;/code&gt; , aumentando el n&amp;uacute;mero de referencias de dos a tres. Cada vez que llamamos a &lt;code&gt;Rc::clone&lt;/code&gt; , el recuento de referencias a los datos dentro de &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; aumentar&amp;aacute; y los datos no se limpiar&amp;aacute;n a menos que no haya ninguna referencia a ellos.</target>
        </trans-unit>
        <trans-unit id="2890fe24db6f7388a46470ac6834b80784db6337" translate="yes" xml:space="preserve">
          <source>Instructions can execute in a different order from the one we define, due to various reasons:</source>
          <target state="translated">Las instrucciones pueden ejecutarse en un orden diferente al que definimos,debido a varias razones:</target>
        </trans-unit>
        <trans-unit id="b74294f827b0d4541ba12662271114a470d6d7a4" translate="yes" xml:space="preserve">
          <source>IntErrorKind</source>
          <target state="translated">IntErrorKind</target>
        </trans-unit>
        <trans-unit id="80fb7220d8146322b259aee21dfef8944e427bb7" translate="yes" xml:space="preserve">
          <source>IntErrorKind::borrow</source>
          <target state="translated">IntErrorKind::borrow</target>
        </trans-unit>
        <trans-unit id="bb7aa40e4b4db6e736d2b09e30f31443f1c9b44c" translate="yes" xml:space="preserve">
          <source>IntErrorKind::borrow_mut</source>
          <target state="translated">IntErrorKind::borrow_mut</target>
        </trans-unit>
        <trans-unit id="86f2a2b8f3ab0b9d3e18ee8e7279ac3646f5e5b6" translate="yes" xml:space="preserve">
          <source>IntErrorKind::clone</source>
          <target state="translated">IntErrorKind::clone</target>
        </trans-unit>
        <trans-unit id="dd987594d4a6731556fb4db2a25b883f8e6e834a" translate="yes" xml:space="preserve">
          <source>IntErrorKind::clone_from</source>
          <target state="translated">IntErrorKind::clone_from</target>
        </trans-unit>
        <trans-unit id="8f1809c6588a2cc665ccd543289e14a938828a70" translate="yes" xml:space="preserve">
          <source>IntErrorKind::clone_into</source>
          <target state="translated">IntErrorKind::clone_into</target>
        </trans-unit>
        <trans-unit id="a5e2ed2cdfa8d2140437ae0a8783a450793b17a2" translate="yes" xml:space="preserve">
          <source>IntErrorKind::eq</source>
          <target state="translated">IntErrorKind::eq</target>
        </trans-unit>
        <trans-unit id="92fce40d27d225b47d39433e8ff156d8c2c93e18" translate="yes" xml:space="preserve">
          <source>IntErrorKind::fmt</source>
          <target state="translated">IntErrorKind::fmt</target>
        </trans-unit>
        <trans-unit id="cd16b5df7c131824209cf18f2e5abfbebb79b75a" translate="yes" xml:space="preserve">
          <source>IntErrorKind::from</source>
          <target state="translated">IntErrorKind::from</target>
        </trans-unit>
        <trans-unit id="e6625420510ba7fab278784b2593fb38c7566390" translate="yes" xml:space="preserve">
          <source>IntErrorKind::into</source>
          <target state="translated">IntErrorKind::into</target>
        </trans-unit>
        <trans-unit id="9d0115c16bd4f87138d516953bbe461d1bf9ec02" translate="yes" xml:space="preserve">
          <source>IntErrorKind::ne</source>
          <target state="translated">IntErrorKind::ne</target>
        </trans-unit>
        <trans-unit id="14958c3a69f5e70cdde8bcf9555c598ab9bb336b" translate="yes" xml:space="preserve">
          <source>IntErrorKind::to_owned</source>
          <target state="translated">IntErrorKind::to_owned</target>
        </trans-unit>
        <trans-unit id="6415d36e18efe91e53b209d52b6293cb58ff6bfa" translate="yes" xml:space="preserve">
          <source>IntErrorKind::try_from</source>
          <target state="translated">IntErrorKind::try_from</target>
        </trans-unit>
        <trans-unit id="03f332b4c41b3659819ff1f646ef37a2e67d10fd" translate="yes" xml:space="preserve">
          <source>IntErrorKind::try_into</source>
          <target state="translated">IntErrorKind::try_into</target>
        </trans-unit>
        <trans-unit id="b726776952bee36d5bafae04149385980bc0b309" translate="yes" xml:space="preserve">
          <source>IntErrorKind::type_id</source>
          <target state="translated">IntErrorKind::type_id</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="65424b5083b7bb599ce3d3b760be23e671c074b2" translate="yes" xml:space="preserve">
          <source>Integer Overflow</source>
          <target state="translated">Desbordamiento del entero</target>
        </trans-unit>
        <trans-unit id="dee2f95e5c81fdaa601cb7ca5b7396c9d7532488" translate="yes" xml:space="preserve">
          <source>Integer Types</source>
          <target state="translated">tipos enteros</target>
        </trans-unit>
        <trans-unit id="6977c92d9e82d5b8f471a2623681e1d1d400b4fb" translate="yes" xml:space="preserve">
          <source>Integer and floating point literals are stringified in order to be concatenated.</source>
          <target state="translated">Los literales enteros y en coma flotante se encadenan para ser concatenados.</target>
        </trans-unit>
        <trans-unit id="eea9a8e4af8d6805a657b383a298ba05a67ec8a4" translate="yes" xml:space="preserve">
          <source>Integer is too large to store in target integer type.</source>
          <target state="translated">El número entero es demasiado grande para almacenarlo en el tipo de número entero objetivo.</target>
        </trans-unit>
        <trans-unit id="25419a68a3cc357926618f13c044ff7b1347aa8b" translate="yes" xml:space="preserve">
          <source>Integer is too small to store in target integer type.</source>
          <target state="translated">El número entero es demasiado pequeño para almacenarlo en el tipo de número entero objetivo.</target>
        </trans-unit>
        <trans-unit id="13c9f1f069c2155e025409b7880e9bda6c11b765" translate="yes" xml:space="preserve">
          <source>Integer literals</source>
          <target state="translated">Literales enteros</target>
        </trans-unit>
        <trans-unit id="f64049bb9bdfd33c50813111908ece46c327c630" translate="yes" xml:space="preserve">
          <source>Integer operators will panic when they overflow when compiled in debug mode. The &lt;code&gt;-C debug-assertions&lt;/code&gt; and &lt;code&gt;-C overflow-checks&lt;/code&gt; compiler flags can be used to control this more directly. The following things are considered to be overflow:</source>
          <target state="translated">Los operadores de enteros entrar&amp;aacute;n en p&amp;aacute;nico cuando se desborden cuando se compilan en modo de depuraci&amp;oacute;n. Los indicadores del compilador &lt;code&gt;-C debug-assertions&lt;/code&gt; y &lt;code&gt;-C overflow-checks&lt;/code&gt; se pueden usar para controlar esto de manera m&amp;aacute;s directa. Las siguientes cosas se consideran desbordamiento:</target>
        </trans-unit>
        <trans-unit id="16d3c89b38e84e433e4fbd3b3a5bad55571258af" translate="yes" xml:space="preserve">
          <source>Integer or Float type</source>
          <target state="translated">Tipo entero o flotante</target>
        </trans-unit>
        <trans-unit id="3a26a4e37ae1b89c4b86a6d96e9ccef63b9ca764" translate="yes" xml:space="preserve">
          <source>Integer overflow</source>
          <target state="translated">Desbordamiento del entero</target>
        </trans-unit>
        <trans-unit id="60c11385ec83a73512788efd527bda9740331202" translate="yes" xml:space="preserve">
          <source>Integer suffixes</source>
          <target state="translated">Sufijos enteros</target>
        </trans-unit>
        <trans-unit id="f59b20cbbdd5ddf3c9bd85fd552a52f66ae334d9" translate="yes" xml:space="preserve">
          <source>Integer type</source>
          <target state="translated">Tipo entero</target>
        </trans-unit>
        <trans-unit id="876569ad85ebaf17d9149dea5706aba22e882fe8" translate="yes" xml:space="preserve">
          <source>Integer types</source>
          <target state="translated">Tipos enteros</target>
        </trans-unit>
        <trans-unit id="19f28971f5db0ac7dee3fee9af716d1da8917af3" translate="yes" xml:space="preserve">
          <source>Integer types (u8, i8, u16, i16, usize, isize, etc.).</source>
          <target state="translated">Tipos enteros (u8,i8,u16,i16,usize,isize,etc.).</target>
        </trans-unit>
        <trans-unit id="a83667e8fbc7d07069b4ce287d78c06adec56630" translate="yes" xml:space="preserve">
          <source>Integers and other types implementing &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; are unaffected by &lt;code&gt;drop&lt;/code&gt;.</source>
          <target state="translated">Los n&amp;uacute;meros enteros y otros tipos que implementan &lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; no se ven afectados por la &lt;code&gt;drop&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="036a5d47efaf84af91b96bca27d0e3394108b032" translate="yes" xml:space="preserve">
          <source>Integration Tests</source>
          <target state="translated">Pruebas de integración</target>
        </trans-unit>
        <trans-unit id="d9b3c69227b8b09ee6557a63d6eadc1309909958" translate="yes" xml:space="preserve">
          <source>Integration Tests for Binary Crates</source>
          <target state="translated">Pruebas de integración para cajas binarias</target>
        </trans-unit>
        <trans-unit id="22d0f1d4f5d8a4b65c3ed4d1e121eaf3dc6e87d2" translate="yes" xml:space="preserve">
          <source>Intended for use for errors not exposed to the user, where allocating onto the heap (for normal construction via Error::new) is too costly.</source>
          <target state="translated">Destinado a ser utilizado para errores no expuestos al usuario,donde la asignación al montón (para la construcción normal a través de Error::new)es demasiado costosa.</target>
        </trans-unit>
        <trans-unit id="8b67f9d330a2d3ef64e53c30ab32b2a3ac9f06b6" translate="yes" xml:space="preserve">
          <source>Intense! In effect, this error message means that Rust doesn&amp;rsquo;t understand how to add an &lt;code&gt;i8&lt;/code&gt; and an &lt;code&gt;Option&amp;lt;i8&amp;gt;&lt;/code&gt;, because they&amp;rsquo;re different types. When we have a value of a type like &lt;code&gt;i8&lt;/code&gt; in Rust, the compiler will ensure that we always have a valid value. We can proceed confidently without having to check for null before using that value. Only when we have an &lt;code&gt;Option&amp;lt;i8&amp;gt;&lt;/code&gt; (or whatever type of value we&amp;rsquo;re working with) do we have to worry about possibly not having a value, and the compiler will make sure we handle that case before using the value.</source>
          <target state="translated">&amp;iexcl;Intenso! En efecto, este mensaje de error significa que Rust no entiende c&amp;oacute;mo agregar un &lt;code&gt;i8&lt;/code&gt; y una &lt;code&gt;Option&amp;lt;i8&amp;gt;&lt;/code&gt; , porque son de diferentes tipos. Cuando tenemos un valor de un tipo como &lt;code&gt;i8&lt;/code&gt; en Rust, el compilador se asegurar&amp;aacute; de que siempre tengamos un valor v&amp;aacute;lido. Podemos proceder con confianza sin tener que verificar si hay un valor nulo antes de usar ese valor. Solo cuando tenemos una &lt;code&gt;Option&amp;lt;i8&amp;gt;&lt;/code&gt; (o cualquier tipo de valor con el que estemos trabajando) tenemos que preocuparnos por la posibilidad de no tener un valor, y el compilador se asegurar&amp;aacute; de que manejemos ese caso antes de usar el valor.</target>
        </trans-unit>
        <trans-unit id="ffafe2f71610dfdf28d74f6f54bc9015fbb24203" translate="yes" xml:space="preserve">
          <source>Interestingly, the Rust language has &lt;em&gt;very&lt;/em&gt; few concurrency features. Almost every concurrency feature we&amp;rsquo;ve talked about so far in this chapter has been part of the standard library, not the language. Your options for handling concurrency are not limited to the language or the standard library; you can write your own concurrency features or use those written by others.</source>
          <target state="translated">Curiosamente, el lenguaje Rust tiene &lt;em&gt;muy&lt;/em&gt; pocas funciones de concurrencia. Casi todas las funciones de simultaneidad de las que hemos hablado hasta ahora en este cap&amp;iacute;tulo han sido parte de la biblioteca est&amp;aacute;ndar, no del lenguaje. Sus opciones para manejar la simultaneidad no se limitan al idioma o la biblioteca est&amp;aacute;ndar; puede escribir sus propias caracter&amp;iacute;sticas de simultaneidad o utilizar las escritas por otros.</target>
        </trans-unit>
        <trans-unit id="21bdfe87f76bf3a6413dde02708bb83e04770512" translate="yes" xml:space="preserve">
          <source>Interior Mutability</source>
          <target state="translated">Mutabilidad interior</target>
        </trans-unit>
        <trans-unit id="88bf37967a115d0f3e4ede63c58d62ebf4f74d5a" translate="yes" xml:space="preserve">
          <source>Interior Mutability: A Mutable Borrow to an Immutable Value</source>
          <target state="translated">Mutabilidad interior:Un préstamo mutable a un valor inmutable</target>
        </trans-unit>
        <trans-unit id="bb56d65f2c6cb59165a8429fad875c4b21a44fc9" translate="yes" xml:space="preserve">
          <source>Interior mutability is required.</source>
          <target state="translated">Se requiere una mutabilidad interior.</target>
        </trans-unit>
        <trans-unit id="ca7ba6473fcf9f5318db96e54bb8153323ab66d4" translate="yes" xml:space="preserve">
          <source>Internal Representation</source>
          <target state="translated">Representación interna</target>
        </trans-unit>
        <trans-unit id="951194525a57d9119eb003c4910a0f82fea56f08" translate="yes" xml:space="preserve">
          <source>Internally uses an alias to &lt;a href=&quot;trait.ord#method.max&quot;&gt;&lt;code&gt;Ord::max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acf9ba348896a745b094371c98fa0f28a4195e87" translate="yes" xml:space="preserve">
          <source>Internally uses an alias to &lt;a href=&quot;trait.ord#method.min&quot;&gt;&lt;code&gt;Ord::min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8e983bc961f2f79520b6f7bb3705df394320c6d" translate="yes" xml:space="preserve">
          <source>Internally uses an alias to &lt;code&gt;Ord::max&lt;/code&gt;.</source>
          <target state="translated">Utiliza internamente un alias para &lt;code&gt;Ord::max&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="944d65bab4f9ee9f9e2c120271148593d01f1819" translate="yes" xml:space="preserve">
          <source>Internally uses an alias to &lt;code&gt;Ord::min&lt;/code&gt;.</source>
          <target state="translated">Utiliza internamente un alias para &lt;code&gt;Ord::min&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="068003ac53324bf3f0b64c29929ac10bbe1c05ab" translate="yes" xml:space="preserve">
          <source>Internet socket addresses consist of an &lt;a href=&quot;enum.ipaddr&quot;&gt;IP address&lt;/a&gt;, a 16-bit port number, as well as possibly some version-dependent additional information. See &lt;a href=&quot;struct.socketaddrv4&quot;&gt;&lt;code&gt;SocketAddrV4&lt;/code&gt;&lt;/a&gt;'s and &lt;a href=&quot;struct.socketaddrv6&quot;&gt;&lt;code&gt;SocketAddrV6&lt;/code&gt;&lt;/a&gt;'s respective documentation for more details.</source>
          <target state="translated">Las direcciones de conexi&amp;oacute;n de Internet constan de una &lt;a href=&quot;enum.ipaddr&quot;&gt;direcci&amp;oacute;n IP&lt;/a&gt; , un n&amp;uacute;mero de puerto de 16 bits y posiblemente alguna informaci&amp;oacute;n adicional dependiente de la versi&amp;oacute;n. Ver &lt;a href=&quot;struct.socketaddrv4&quot;&gt; &lt;code&gt;SocketAddrV4&lt;/code&gt; &lt;/a&gt; 's y &lt;a href=&quot;struct.socketaddrv6&quot;&gt; &lt;code&gt;SocketAddrV6&lt;/code&gt; &lt;/a&gt; ' s respectiva documentaci&amp;oacute;n para m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="ff358fd17c71b9310a296d32bf0fad9d3ef93b34" translate="yes" xml:space="preserve">
          <source>Interprets &lt;code&gt;src&lt;/code&gt; as having type &lt;code&gt;&amp;amp;U&lt;/code&gt;, and then reads &lt;code&gt;src&lt;/code&gt; without moving the contained value.</source>
          <target state="translated">Interpreta que &lt;code&gt;src&lt;/code&gt; tiene el tipo &lt;code&gt;&amp;amp;U&lt;/code&gt; , y luego lee &lt;code&gt;src&lt;/code&gt; sin mover el valor contenido.</target>
        </trans-unit>
        <trans-unit id="6a36b9396eb19f7860ffbd9cb812832709b1a0ee" translate="yes" xml:space="preserve">
          <source>Interrupted operations can typically be retried.</source>
          <target state="translated">Las operaciones interrumpidas pueden ser típicamente reintentadas.</target>
        </trans-unit>
        <trans-unit id="d0f596ba112a353008597117b57b10b067fc620b" translate="yes" xml:space="preserve">
          <source>Intersection</source>
          <target state="translated">Intersection</target>
        </trans-unit>
        <trans-unit id="d937d21f811516b74380ee512b99e31251a84531" translate="yes" xml:space="preserve">
          <source>Into</source>
          <target state="translated">Into</target>
        </trans-unit>
        <trans-unit id="5bfe78f7766048c0532cc66994c73d1126acb835" translate="yes" xml:space="preserve">
          <source>Into::into</source>
          <target state="translated">Into::into</target>
        </trans-unit>
        <trans-unit id="44f9db19d74f7cdef0547d820fed0d75c60f0beb" translate="yes" xml:space="preserve">
          <source>IntoFuture</source>
          <target state="translated">IntoFuture</target>
        </trans-unit>
        <trans-unit id="77f5dd8de42c3fb03062223e3c47c92129133f82" translate="yes" xml:space="preserve">
          <source>IntoInnerError</source>
          <target state="translated">IntoInnerError</target>
        </trans-unit>
        <trans-unit id="3f3157b39d55c6291f5fe8213b30cc7d15253d48" translate="yes" xml:space="preserve">
          <source>IntoInnerError::borrow</source>
          <target state="translated">IntoInnerError::borrow</target>
        </trans-unit>
        <trans-unit id="8dfa8d9b4ac06c1a6626ce8031f10e6de0dc0387" translate="yes" xml:space="preserve">
          <source>IntoInnerError::borrow_mut</source>
          <target state="translated">IntoInnerError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="7c332dec4b157cd5d25efcbb73292737fbcafa2a" translate="yes" xml:space="preserve">
          <source>IntoInnerError::cause</source>
          <target state="translated">IntoInnerError::cause</target>
        </trans-unit>
        <trans-unit id="824ab9811aae7de9a48a47b240a825897e788412" translate="yes" xml:space="preserve">
          <source>IntoInnerError::description</source>
          <target state="translated">IntoInnerError::description</target>
        </trans-unit>
        <trans-unit id="83d6a8f5f81bfae0852073773b72a21c220d1541" translate="yes" xml:space="preserve">
          <source>IntoInnerError::error</source>
          <target state="translated">IntoInnerError::error</target>
        </trans-unit>
        <trans-unit id="b1804b3db5a18e0f8ea6f6cff9edd76e45db12ed" translate="yes" xml:space="preserve">
          <source>IntoInnerError::fmt</source>
          <target state="translated">IntoInnerError::fmt</target>
        </trans-unit>
        <trans-unit id="74ec382ed3daa2186fca394930d62ea36a8c17d2" translate="yes" xml:space="preserve">
          <source>IntoInnerError::from</source>
          <target state="translated">IntoInnerError::from</target>
        </trans-unit>
        <trans-unit id="f77ca8c3b2a09378cb7ab11a7034bfe301502366" translate="yes" xml:space="preserve">
          <source>IntoInnerError::into</source>
          <target state="translated">IntoInnerError::into</target>
        </trans-unit>
        <trans-unit id="b64935fe113c6776466d9f925b72b58f10a95d0a" translate="yes" xml:space="preserve">
          <source>IntoInnerError::into_inner</source>
          <target state="translated">IntoInnerError::into_inner</target>
        </trans-unit>
        <trans-unit id="b98cd1e7eff5f2d406e34cac12fb4fec6a0205d4" translate="yes" xml:space="preserve">
          <source>IntoInnerError::source</source>
          <target state="translated">IntoInnerError::source</target>
        </trans-unit>
        <trans-unit id="b27666ff3803b78aee0d747dc0d776b1f36b641a" translate="yes" xml:space="preserve">
          <source>IntoInnerError::to_string</source>
          <target state="translated">IntoInnerError::to_string</target>
        </trans-unit>
        <trans-unit id="0b54c908cc8363881d303f189af2d3a384fbe644" translate="yes" xml:space="preserve">
          <source>IntoInnerError::try_from</source>
          <target state="translated">IntoInnerError::try_from</target>
        </trans-unit>
        <trans-unit id="496358b49c2805d5e6526e43d48129b6eb94e5f4" translate="yes" xml:space="preserve">
          <source>IntoInnerError::try_into</source>
          <target state="translated">IntoInnerError::try_into</target>
        </trans-unit>
        <trans-unit id="b48124715dd42f1aa190750b7aa9535327b5b2db" translate="yes" xml:space="preserve">
          <source>IntoInnerError::type_id</source>
          <target state="translated">IntoInnerError::type_id</target>
        </trans-unit>
        <trans-unit id="d5bc3a63a8bde6cc5fb0c0c11c8f6e6a2d150f75" translate="yes" xml:space="preserve">
          <source>IntoIter</source>
          <target state="translated">IntoIter</target>
        </trans-unit>
        <trans-unit id="169272921e3355905d2215419cf69783d5e1115d" translate="yes" xml:space="preserve">
          <source>IntoIter::all</source>
          <target state="translated">IntoIter::all</target>
        </trans-unit>
        <trans-unit id="a15574f60107e9d0464eff7cacee4bccf74dd72e" translate="yes" xml:space="preserve">
          <source>IntoIter::any</source>
          <target state="translated">IntoIter::any</target>
        </trans-unit>
        <trans-unit id="51c36bf4138559f11f65b74500f686e06c1f07c6" translate="yes" xml:space="preserve">
          <source>IntoIter::as_mut_slice</source>
          <target state="translated">IntoIter::as_mut_slice</target>
        </trans-unit>
        <trans-unit id="375d884ce90ecd76e63b6eebc5d52f38165f98ea" translate="yes" xml:space="preserve">
          <source>IntoIter::as_slice</source>
          <target state="translated">IntoIter::as_slice</target>
        </trans-unit>
        <trans-unit id="945728e84b93878ccde99bc6b6c902e3add25ce9" translate="yes" xml:space="preserve">
          <source>IntoIter::borrow</source>
          <target state="translated">IntoIter::borrow</target>
        </trans-unit>
        <trans-unit id="4db752fa4ec7a9c0d095aaf0baac141df030f531" translate="yes" xml:space="preserve">
          <source>IntoIter::borrow_mut</source>
          <target state="translated">IntoIter::borrow_mut</target>
        </trans-unit>
        <trans-unit id="aaf973384105c3d31f532c4ad4e6dc925ca8038e" translate="yes" xml:space="preserve">
          <source>IntoIter::by_ref</source>
          <target state="translated">IntoIter::by_ref</target>
        </trans-unit>
        <trans-unit id="bcd8f637007c65386e7e2794c338143218170c6f" translate="yes" xml:space="preserve">
          <source>IntoIter::chain</source>
          <target state="translated">IntoIter::chain</target>
        </trans-unit>
        <trans-unit id="4b7971718173fafccbf11a50c2db440035e10f18" translate="yes" xml:space="preserve">
          <source>IntoIter::clone</source>
          <target state="translated">IntoIter::clone</target>
        </trans-unit>
        <trans-unit id="cdb70f02920a7096b80eae8222a39e9acc9946ce" translate="yes" xml:space="preserve">
          <source>IntoIter::clone_from</source>
          <target state="translated">IntoIter::clone_from</target>
        </trans-unit>
        <trans-unit id="a82a0721b8481c0815dcd502e84574a2073e6632" translate="yes" xml:space="preserve">
          <source>IntoIter::clone_into</source>
          <target state="translated">IntoIter::clone_into</target>
        </trans-unit>
        <trans-unit id="50371856061d6c57455d0ce1dfd33e8f9cb33e2b" translate="yes" xml:space="preserve">
          <source>IntoIter::cloned</source>
          <target state="translated">IntoIter::cloned</target>
        </trans-unit>
        <trans-unit id="e8ad516621215eb3804081635021e01bb0d15b51" translate="yes" xml:space="preserve">
          <source>IntoIter::cmp</source>
          <target state="translated">IntoIter::cmp</target>
        </trans-unit>
        <trans-unit id="8fbe1060e2b348d75cd8e260134f4152fb629580" translate="yes" xml:space="preserve">
          <source>IntoIter::collect</source>
          <target state="translated">IntoIter::collect</target>
        </trans-unit>
        <trans-unit id="49b1597675bf50c85b1e156757a3fba15d6379b2" translate="yes" xml:space="preserve">
          <source>IntoIter::copied</source>
          <target state="translated">IntoIter::copied</target>
        </trans-unit>
        <trans-unit id="1b07d7fdfbcbc77dd6f739fc3349c3f2c936082e" translate="yes" xml:space="preserve">
          <source>IntoIter::count</source>
          <target state="translated">IntoIter::count</target>
        </trans-unit>
        <trans-unit id="abc24391b60331e5b16547b639bace5c08a577cf" translate="yes" xml:space="preserve">
          <source>IntoIter::cycle</source>
          <target state="translated">IntoIter::cycle</target>
        </trans-unit>
        <trans-unit id="076c1a1b603e193e4eb4e0757f8c8cf292b8dfb5" translate="yes" xml:space="preserve">
          <source>IntoIter::drop</source>
          <target state="translated">IntoIter::drop</target>
        </trans-unit>
        <trans-unit id="c4d617218636a45df4ca846f67499ffba56d0009" translate="yes" xml:space="preserve">
          <source>IntoIter::enumerate</source>
          <target state="translated">IntoIter::enumerate</target>
        </trans-unit>
        <trans-unit id="203a6dcfb8a13fd0add782bc832058504307c28c" translate="yes" xml:space="preserve">
          <source>IntoIter::eq</source>
          <target state="translated">IntoIter::eq</target>
        </trans-unit>
        <trans-unit id="c908d336a9125db6fbd5e895b62999e14ef83fab" translate="yes" xml:space="preserve">
          <source>IntoIter::filter</source>
          <target state="translated">IntoIter::filter</target>
        </trans-unit>
        <trans-unit id="dffdf83b64aeaec0f8093868f1a7bbb32780e9ca" translate="yes" xml:space="preserve">
          <source>IntoIter::filter_map</source>
          <target state="translated">IntoIter::filter_map</target>
        </trans-unit>
        <trans-unit id="ab410a5d7b7cbc92b7134e524269b1fa848fc30b" translate="yes" xml:space="preserve">
          <source>IntoIter::find</source>
          <target state="translated">IntoIter::find</target>
        </trans-unit>
        <trans-unit id="27ee1265a09c796da003def69a36560ceff2b181" translate="yes" xml:space="preserve">
          <source>IntoIter::find_map</source>
          <target state="translated">IntoIter::find_map</target>
        </trans-unit>
        <trans-unit id="eddd95067e023ebec6158e4fd0749c395bbce3b5" translate="yes" xml:space="preserve">
          <source>IntoIter::flat_map</source>
          <target state="translated">IntoIter::flat_map</target>
        </trans-unit>
        <trans-unit id="24f22711986263a8d0e02c113bb93328c331ce4c" translate="yes" xml:space="preserve">
          <source>IntoIter::flatten</source>
          <target state="translated">IntoIter::flatten</target>
        </trans-unit>
        <trans-unit id="e538b5a92b4ad8916bfeef8710693a5e5266e987" translate="yes" xml:space="preserve">
          <source>IntoIter::fmt</source>
          <target state="translated">IntoIter::fmt</target>
        </trans-unit>
        <trans-unit id="d818332c13e9dac3c39cfd50a50265cfaea983ac" translate="yes" xml:space="preserve">
          <source>IntoIter::fold</source>
          <target state="translated">IntoIter::fold</target>
        </trans-unit>
        <trans-unit id="ebce24dad77f86422316868125c1ce1b1376c47d" translate="yes" xml:space="preserve">
          <source>IntoIter::for_each</source>
          <target state="translated">IntoIter::for_each</target>
        </trans-unit>
        <trans-unit id="63d5fee827e27caa7f9e5b809ff35ace75693193" translate="yes" xml:space="preserve">
          <source>IntoIter::from</source>
          <target state="translated">IntoIter::from</target>
        </trans-unit>
        <trans-unit id="d10213dec7222893569b1e32a4313a41a6aaecb0" translate="yes" xml:space="preserve">
          <source>IntoIter::fuse</source>
          <target state="translated">IntoIter::fuse</target>
        </trans-unit>
        <trans-unit id="2c8a9a1c31b0f9b10030a7c20db1f8dae0614589" translate="yes" xml:space="preserve">
          <source>IntoIter::ge</source>
          <target state="translated">IntoIter::ge</target>
        </trans-unit>
        <trans-unit id="104a30acd770869920244c22e6c1a727cdee6dae" translate="yes" xml:space="preserve">
          <source>IntoIter::gt</source>
          <target state="translated">IntoIter::gt</target>
        </trans-unit>
        <trans-unit id="ab8d2e8c457b63ffae7769711a00e1a87b2a56eb" translate="yes" xml:space="preserve">
          <source>IntoIter::inspect</source>
          <target state="translated">IntoIter::inspect</target>
        </trans-unit>
        <trans-unit id="c0c222348756fc6dca4ff42b109916a4d5aa1041" translate="yes" xml:space="preserve">
          <source>IntoIter::into</source>
          <target state="translated">IntoIter::into</target>
        </trans-unit>
        <trans-unit id="00014741248dda82e6a92af65524e8bc527d5270" translate="yes" xml:space="preserve">
          <source>IntoIter::into_iter</source>
          <target state="translated">IntoIter::into_iter</target>
        </trans-unit>
        <trans-unit id="5136432030a36a1b23033a0d753895604b4149ac" translate="yes" xml:space="preserve">
          <source>IntoIter::is_empty</source>
          <target state="translated">IntoIter::is_empty</target>
        </trans-unit>
        <trans-unit id="cf791dcb18f1b7d93faf9bdd64add013d8076499" translate="yes" xml:space="preserve">
          <source>IntoIter::is_sorted</source>
          <target state="translated">IntoIter::is_sorted</target>
        </trans-unit>
        <trans-unit id="5c6daaffe95fe047d7827bfe50f3fd317d40c563" translate="yes" xml:space="preserve">
          <source>IntoIter::is_sorted_by</source>
          <target state="translated">IntoIter::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="9f7c1ed14fd6d8b0ea5624c99850ff1ba4ac8f4c" translate="yes" xml:space="preserve">
          <source>IntoIter::is_sorted_by_key</source>
          <target state="translated">IntoIter::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="e39349aed40aa6fcfd458252b9c0e111206b7d16" translate="yes" xml:space="preserve">
          <source>IntoIter::last</source>
          <target state="translated">IntoIter::last</target>
        </trans-unit>
        <trans-unit id="965a66efe77546764045f5f96e42028dbb177b19" translate="yes" xml:space="preserve">
          <source>IntoIter::le</source>
          <target state="translated">IntoIter::le</target>
        </trans-unit>
        <trans-unit id="22be990e0e582b87c69cd8c67de2cfd9920d77cd" translate="yes" xml:space="preserve">
          <source>IntoIter::len</source>
          <target state="translated">IntoIter::len</target>
        </trans-unit>
        <trans-unit id="8440a9053eaee6916d3cec75da248b9b8410507f" translate="yes" xml:space="preserve">
          <source>IntoIter::lt</source>
          <target state="translated">IntoIter::lt</target>
        </trans-unit>
        <trans-unit id="e3e2d404675aba8735567f55b57c588d0c0c351a" translate="yes" xml:space="preserve">
          <source>IntoIter::map</source>
          <target state="translated">IntoIter::map</target>
        </trans-unit>
        <trans-unit id="181026e325e14528b026dfe68716b7b26ecd2d2d" translate="yes" xml:space="preserve">
          <source>IntoIter::max</source>
          <target state="translated">IntoIter::max</target>
        </trans-unit>
        <trans-unit id="dd9a47d87f8a0e2db21c65ae146ddcfdf6e0f952" translate="yes" xml:space="preserve">
          <source>IntoIter::max_by</source>
          <target state="translated">IntoIter::max_by</target>
        </trans-unit>
        <trans-unit id="32723c1a1514dde11ed20c922fc56eff6425fcc8" translate="yes" xml:space="preserve">
          <source>IntoIter::max_by_key</source>
          <target state="translated">IntoIter::max_by_key</target>
        </trans-unit>
        <trans-unit id="c528958b5dc23955203383c2f66331a5a91f6f86" translate="yes" xml:space="preserve">
          <source>IntoIter::min</source>
          <target state="translated">IntoIter::min</target>
        </trans-unit>
        <trans-unit id="390fd21e220a5da046b34c827add37c65b895f97" translate="yes" xml:space="preserve">
          <source>IntoIter::min_by</source>
          <target state="translated">IntoIter::min_by</target>
        </trans-unit>
        <trans-unit id="05a738d3c9912a808e8d6c464d2a7c6d5e602efc" translate="yes" xml:space="preserve">
          <source>IntoIter::min_by_key</source>
          <target state="translated">IntoIter::min_by_key</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
