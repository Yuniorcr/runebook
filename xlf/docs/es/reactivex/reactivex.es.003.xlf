<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="reactivex">
    <body>
      <group id="reactivex">
        <trans-unit id="5e8309810456d4c8a3fb450f989511d4ca97a5f2" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;retry&lt;/code&gt;.</source>
          <target state="translated">RxPHP implementa este operador como &lt;code&gt;retry&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96be0190f3d3fc503c91d590063f44a320119576" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;scan&lt;/code&gt;.</source>
          <target state="translated">RxPHP implementa este operador como &lt;code&gt;scan&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1f0adb2d5724b28a03046eb2fab6cbfbe6b5aaf" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;share&lt;/code&gt;.</source>
          <target state="translated">RxPHP implementa este operador como recurso &lt;code&gt;share&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07fce018a2c4e1d4d94e654bd3c25c477e5c0c91" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;skip&lt;/code&gt;.</source>
          <target state="translated">RxPHP implementa este operador como &lt;code&gt;skip&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6570ec1baeff52881f92e79c2ad9a4da861a904f" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;skipLast&lt;/code&gt;.</source>
          <target state="translated">RxPHP implementa este operador como &lt;code&gt;skipLast&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1dff7eb9ed29c2313f0cfe0f58e8fba3b2c63e5a" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;skipUntil&lt;/code&gt;.</source>
          <target state="translated">RxPHP implementa este operador como &lt;code&gt;skipUntil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="513b3a413de80dce65d0e00666f5ef5b4c9bf1aa" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;skipWhile&lt;/code&gt;.</source>
          <target state="translated">RxPHP implementa este operador como &lt;code&gt;skipWhile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e88c511ae3daafbdf76d321b9151b57384484df" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;start&lt;/code&gt;.</source>
          <target state="translated">RxPHP implementa este operador como &lt;code&gt;start&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0c92b4fc46698d2ae7e26b71de9c32b8c2f6d57e" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;startWith&lt;/code&gt;.</source>
          <target state="translated">RxPHP implementa este operador como &lt;code&gt;startWith&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="832b05105e23624efd86948b924c0f1751818125" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;subscribe&lt;/code&gt;.</source>
          <target state="translated">RxPHP implementa este operador como &lt;code&gt;subscribe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c957f67ad24104a39df6f836fb6b54d70740467" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;sum&lt;/code&gt;.</source>
          <target state="translated">RxPHP implementa este operador como &lt;code&gt;sum&lt;/code&gt; a .</target>
        </trans-unit>
        <trans-unit id="8bdaa3c05aeaf63bae13f0195ca2226795340d12" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;switch&lt;/code&gt;.</source>
          <target state="translated">RxPHP implementa este operador como &lt;code&gt;switch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce05f8533b11c7671d9d453c18145c2e8aed7a22" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;take&lt;/code&gt;.</source>
          <target state="translated">RxPHP implementa este operador como &lt;code&gt;take&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2e8faa39d887fc4a77c0cbb2a2c07c63d30adbe" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;takeLast&lt;/code&gt;.</source>
          <target state="translated">RxPHP implementa este operador como &lt;code&gt;takeLast&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9becd98fcde7eb00ee90cbeb4094c495b3d5449" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;takeUntil&lt;/code&gt;.</source>
          <target state="translated">RxPHP implementa este operador como &lt;code&gt;takeUntil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7223b628e1c69a31ea40c4223bef42898a005c0e" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;takeWhile&lt;/code&gt;.</source>
          <target state="translated">RxPHP implementa este operador como &lt;code&gt;takeWhile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b814ec6e39fbd54b10a0d923b95126e6d3bdfd9b" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;throttle&lt;/code&gt;.</source>
          <target state="translated">RxPHP implementa este operador como &lt;code&gt;throttle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="254b8b5c4b6eb7da28ffdb42f62793a649138295" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">RxPHP implementa este operador como &lt;code&gt;timeout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63a0ffc10f609a37f26f3bbd9752db98ae852d52" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;timer&lt;/code&gt;.</source>
          <target state="translated">RxPHP implementa este operador como &lt;code&gt;timer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b5a871540bb6d5bbc165c1c3a01d55f9f615992" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;timestamp&lt;/code&gt;.</source>
          <target state="translated">RxPHP implementa este operador como &lt;code&gt;timestamp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9e559c3811597bfc4934e6a3753e9dd2d48a76d" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;toArray&lt;/code&gt;.</source>
          <target state="translated">RxPHP implementa este operador como &lt;code&gt;toArray&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d89610894d0e11591b07a8d0b5f707e52e20aff" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;zip&lt;/code&gt;.</source>
          <target state="translated">RxPHP implementa este operador como &lt;code&gt;zip&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="693dd13c486759895879d696fa0d950298a01163" translate="yes" xml:space="preserve">
          <source>RxPY &lt;code&gt;buffer buffer_with_count buffer_with_time buffer_with_time_or_count pairwise&lt;/code&gt;</source>
          <target state="translated">RxPY &lt;code&gt;buffer buffer_with_count buffer_with_time buffer_with_time_or_count pairwise&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b08fa4aafa83a12fa7ebfe42e4da8aa1978130dc" translate="yes" xml:space="preserve">
          <source>RxPY &lt;code&gt;catch_exception on_error_resume_next&lt;/code&gt;</source>
          <target state="translated">RxPY &lt;code&gt;catch_exception on_error_resume_next&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f487b92c7d1f5f02bf47e49e97edd32c9562bb8b" translate="yes" xml:space="preserve">
          <source>RxPY &lt;code&gt;concat concatAll&lt;/code&gt;</source>
          <target state="translated">RxPY &lt;code&gt;concat concatAll&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6d7f9553e8f51cdbaa07acff1e4f8c35eb5adb9f" translate="yes" xml:space="preserve">
          <source>RxPY &lt;code&gt;count&lt;/code&gt;</source>
          <target state="translated">RxPY &lt;code&gt;count&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7140c2e79a019dcc0f9830e029714291144461e3" translate="yes" xml:space="preserve">
          <source>RxPY &lt;code&gt;merge merge_all merge_observable&lt;/code&gt;</source>
          <target state="translated">RxPY &lt;code&gt;merge merge_all merge_observable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c0c81899aa32f6f63c27070385f97d5d03d71bd" translate="yes" xml:space="preserve">
          <source>RxPY &lt;code&gt;retry&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;retry&lt;/code&gt; RxPY</target>
        </trans-unit>
        <trans-unit id="ad2236de8db3968c25d85d2b6cf0e5652cd401c7" translate="yes" xml:space="preserve">
          <source>RxPY &lt;code&gt;start_with&lt;/code&gt;</source>
          <target state="translated">RxPY &lt;code&gt;start_with&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0daa3267a7976fd4c6108e56152747f06dda4357" translate="yes" xml:space="preserve">
          <source>RxPY &lt;code&gt;window window_with_count window_with_time window_with_time_or_count&lt;/code&gt;</source>
          <target state="translated">RxPY &lt;code&gt;window window_with_count window_with_time window_with_time_or_count&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="270f2d48778b0f06758b9264a8433fde64b901fd" translate="yes" xml:space="preserve">
          <source>RxPY has several Buffer variants: &lt;code&gt;buffer&lt;/code&gt;, &lt;code&gt;buffer_with_count&lt;/code&gt;, &lt;code&gt;buffer_with_time&lt;/code&gt;, and &lt;code&gt;buffer_with_time_or_count&lt;/code&gt;. For each of these variants there are optional parameters that change the behavior of the operator. As always in RxPY, when an operator may take more than one optional parameter, be sure to name the parameter in the parameter list when you call the operator so as to avoid ambiguity.</source>
          <target state="translated">RxPY tiene varias variantes de Buffer: &lt;code&gt;buffer&lt;/code&gt; , &lt;code&gt;buffer_with_count&lt;/code&gt; , &lt;code&gt;buffer_with_time&lt;/code&gt; y &lt;code&gt;buffer_with_time_or_count&lt;/code&gt; . Para cada una de estas variantes existen par&amp;aacute;metros opcionales que cambian el comportamiento del operador. Como siempre en RxPY, cuando un operador puede tomar m&amp;aacute;s de un par&amp;aacute;metro opcional, aseg&amp;uacute;rese de nombrar el par&amp;aacute;metro en la lista de par&amp;aacute;metros cuando llame al operador para evitar ambig&amp;uuml;edades.</target>
        </trans-unit>
        <trans-unit id="1fd6654db5dccbd88806c19c104c30fa3099b447" translate="yes" xml:space="preserve">
          <source>RxPY implements the Catch operator with two distinct operators:</source>
          <target state="translated">RxPY implementa el operador de captura con dos operadores distintos:</target>
        </trans-unit>
        <trans-unit id="997bbecd73d735cf76caff6f3e11f3b5f278d21c" translate="yes" xml:space="preserve">
          <source>RxPY implements this operator as &lt;code&gt;merge&lt;/code&gt; and &lt;code&gt;merge_all&lt;/code&gt;/&lt;code&gt;merge_observable&lt;/code&gt;.</source>
          <target state="translated">RxPY implementa este operador como &lt;code&gt;merge&lt;/code&gt; y &lt;code&gt;merge_all&lt;/code&gt; / &lt;code&gt;merge_observable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64854a6b85df528ef6e41cdcd85374b370c89a23" translate="yes" xml:space="preserve">
          <source>RxPY implements this operator as &lt;code&gt;retry&lt;/code&gt;:</source>
          <target state="translated">RxPY implementa este operador como &lt;code&gt;retry&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ad669011fa261f9e28135fcb0af82aed927e312b" translate="yes" xml:space="preserve">
          <source>RxPY implements this operator as &lt;code&gt;start_with&lt;/code&gt;. It accepts an array of items which it prepends to the resulting Observable sequence in the order they appear in the array before it emits the items from the source Observable.</source>
          <target state="translated">RxPY implementa este operador como &lt;code&gt;start_with&lt;/code&gt; . Acepta una matriz de elementos que antepone a la secuencia Observable resultante en el orden en que aparecen en la matriz antes de emitir los elementos del Observable de origen.</target>
        </trans-unit>
        <trans-unit id="7ec7900945bed69788945e976470cea403e81661" translate="yes" xml:space="preserve">
          <source>RxPY implements this operator with several variants of four different functions.</source>
          <target state="translated">RxPY implementa este operador con varias variantes de cuatro funciones diferentes.</target>
        </trans-unit>
        <trans-unit id="f1d67170a06e97a4449045c839dc5d1e2382b69d" translate="yes" xml:space="preserve">
          <source>RxScala &lt;code&gt;+:&lt;/code&gt;</source>
          <target state="translated">RxScala &lt;code&gt;+:&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dcef499d4c4fb2f6d94f8c4cef84a8b26d465d06" translate="yes" xml:space="preserve">
          <source>RxScala &lt;code&gt;concat ++&lt;/code&gt;</source>
          <target state="translated">RxScala &lt;code&gt;concat ++&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e990f0e0a54de0238f215152d4442c39ce492c0" translate="yes" xml:space="preserve">
          <source>RxScala &lt;code&gt;count length longCount size&lt;/code&gt;</source>
          <target state="translated">Longitud del &lt;code&gt;count length longCount size&lt;/code&gt; RxScala largo Tama&amp;ntilde;o del recuento</target>
        </trans-unit>
        <trans-unit id="ed829eaad25e9f641868bfa691741709980df995" translate="yes" xml:space="preserve">
          <source>RxScala &lt;code&gt;flatten flattenDelayError merge mergeDelayError&lt;/code&gt;</source>
          <target state="translated">RxScala &lt;code&gt;flatten flattenDelayError merge mergeDelayError&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6d9b6011a4b7d18c76b5a21d4203132c6cd933ab" translate="yes" xml:space="preserve">
          <source>RxScala &lt;code&gt;onErrorFlatMap onErrorResumeNext onErrorReturn onExceptionResumeNext&lt;/code&gt;</source>
          <target state="translated">RxScala &lt;code&gt;onErrorFlatMap onErrorResumeNext onErrorReturn onExceptionResumeNext&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="563a94ee27ba81015d3aeed667733daeed349e03" translate="yes" xml:space="preserve">
          <source>RxScala &lt;code&gt;retry retryWhen&lt;/code&gt;</source>
          <target state="translated">RxScala &lt;code&gt;retry retryWhen&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1e07e71d4f4652a21fd420d1ab1de3e2951e86f7" translate="yes" xml:space="preserve">
          <source>RxScala &lt;code&gt;sliding tumbling&lt;/code&gt;</source>
          <target state="translated">RxScala &lt;code&gt;sliding tumbling&lt;/code&gt; volteando</target>
        </trans-unit>
        <trans-unit id="4ba1f219f82e8f92570a08b4c69107dc38cc7ceb" translate="yes" xml:space="preserve">
          <source>RxScala &lt;code&gt;slidingBuffer tumblingBuffer&lt;/code&gt;</source>
          <target state="translated">RxScala &lt;code&gt;slidingBuffer tumblingBuffer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="39a7d257695fedcf6f7513b3c29a4532e1ea9e0b" translate="yes" xml:space="preserve">
          <source>RxScala has two varieties of Buffer &amp;mdash; &lt;code&gt;slidingBuffer&lt;/code&gt; and &lt;code&gt;tumblingBuffer&lt;/code&gt; &amp;mdash; each of which has variants with different ways of assembling the buffers they emit:</source>
          <target state="translated">RxScala tiene dos variedades de b&amp;uacute;fer, &lt;code&gt;slidingBuffer&lt;/code&gt; y &lt;code&gt;tumblingBuffer&lt;/code&gt; , cada una de las cuales tiene variantes con diferentes formas de ensamblar los b&amp;uacute;feres que emiten:</target>
        </trans-unit>
        <trans-unit id="49dbca94ff276bf9d442df62b994dee8a001be10" translate="yes" xml:space="preserve">
          <source>RxScala has two versions of this operator: &lt;code&gt;retry&lt;/code&gt; and &lt;code&gt;retryWhen&lt;/code&gt;.</source>
          <target state="translated">RxScala tiene dos versiones de este operador: &lt;code&gt;retry&lt;/code&gt; y reintentar &lt;code&gt;retryWhen&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a52c08948f140da58bfdcde6019760eb047a5893" translate="yes" xml:space="preserve">
          <source>RxScala implements this operator as &lt;code&gt;flatten&lt;/code&gt;, &lt;code&gt;flattenDelayError&lt;/code&gt;, &lt;code&gt;merge&lt;/code&gt;, and &lt;code&gt;mergeDelayError&lt;/code&gt;.</source>
          <target state="translated">RxScala implementa este operador como &lt;code&gt;flatten&lt;/code&gt; , &lt;code&gt;flattenDelayError&lt;/code&gt; , &lt;code&gt;merge&lt;/code&gt; y &lt;code&gt;mergeDelayError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39eccc9709809defbe492077eaf3cc6d83d3e433" translate="yes" xml:space="preserve">
          <source>RxScala implements this operator as &lt;code&gt;sliding&lt;/code&gt; (creates windows that may overlap or have gaps) and &lt;code&gt;tumbling&lt;/code&gt; (creates windows whose collective emissions match those of the source Observable one-to-one).</source>
          <target state="translated">RxScala implementa este operador como &lt;code&gt;sliding&lt;/code&gt; (crea ventanas que pueden superponerse o tener huecos) y &lt;code&gt;tumbling&lt;/code&gt; (crea ventanas cuyas emisiones colectivas coinciden con las de la fuente Observable uno a uno).</target>
        </trans-unit>
        <trans-unit id="abd5b95c1e25b6159372d87c175648f0d5290301" translate="yes" xml:space="preserve">
          <source>RxScala implements this operator in two ways. There is a &lt;code&gt;concat&lt;/code&gt; operator that accepts an Observable of Observables as its parameter, and then concatenates each of these Observables in the order they are emitted. There is also a &lt;code&gt;++&lt;/code&gt; operator that concatenates one Observable to another.</source>
          <target state="translated">RxScala implementa este operador de dos formas. Hay un operador &lt;code&gt;concat&lt;/code&gt; que acepta un Observable of Observables como su par&amp;aacute;metro, y luego concatena cada uno de estos Observables en el orden en que se emiten. Tambi&amp;eacute;n hay un operador &lt;code&gt;++&lt;/code&gt; que concatena un Observable con otro.</target>
        </trans-unit>
        <trans-unit id="cea120686efc2c1a225b8c5d36b8c8a2546ed795" translate="yes" xml:space="preserve">
          <source>RxScala implements this operator with &lt;code&gt;+:&lt;/code&gt; It takes an item and an Observable as parameters, and prepends the item to the items emitted by the Observable as its own Observable sequence.</source>
          <target state="translated">RxScala implementa este operador con &lt;code&gt;+:&lt;/code&gt; Toma un &amp;iacute;tem y un Observable como par&amp;aacute;metros, y antepone el &amp;iacute;tem a los &amp;iacute;tems emitidos por el Observable como su propia secuencia Observable.</target>
        </trans-unit>
        <trans-unit id="7aee45e741f377a8920ab095d941fa4d0aa645e1" translate="yes" xml:space="preserve">
          <source>RxSwift &lt;code&gt;create generate&lt;/code&gt;</source>
          <target state="translated">RxSwift &lt;code&gt;create generate&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3db1b8cf654b640f6385d1a6b05692292a59ad5f" translate="yes" xml:space="preserve">
          <source>RxSwift &lt;code&gt;from toObservable&lt;/code&gt;</source>
          <target state="translated">RxSwift &lt;code&gt;from toObservable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c4c9d6bed1ede16cf84de597f7384adbcd65a4df" translate="yes" xml:space="preserve">
          <source>RxSwift &lt;code&gt;just sequenceOf&lt;/code&gt;</source>
          <target state="translated">RxSwift &lt;code&gt;just sequenceOf&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2d4e8e91a479b7c9366d77f396ae487f990b467c" translate="yes" xml:space="preserve">
          <source>RxSwift &lt;code&gt;merge&lt;/code&gt;</source>
          <target state="translated">RxSwift &lt;code&gt;merge&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a00334313be967429412cd5d38086f0879ce4fd" translate="yes" xml:space="preserve">
          <source>RxSwift implements this operator as &lt;code&gt;create&lt;/code&gt;.</source>
          <target state="translated">RxSwift implementa este operador como &lt;code&gt;create&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="588e95814c5e31b0ac881ca2f54f2f8d85b98a60" translate="yes" xml:space="preserve">
          <source>RxSwift implements this operator as &lt;code&gt;merge&lt;/code&gt;.</source>
          <target state="translated">RxSwift implementa este operador como &lt;code&gt;merge&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08fe3e272ac8a840ae0419188778167b77dfba85" translate="yes" xml:space="preserve">
          <source>Rxrb &lt;code&gt;buffer_with_count buffer_with_time&lt;/code&gt;</source>
          <target state="translated">Rxrb &lt;code&gt;buffer_with_count buffer_with_time&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85e804e67cc2836d4ddbb8cf5a880cac3b949246" translate="yes" xml:space="preserve">
          <source>Rxrb &lt;code&gt;concat merge_all&lt;/code&gt;</source>
          <target state="translated">Rxrb &lt;code&gt;concat merge_all&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf397e3bfea0116e080b5016e227d6d855282363" translate="yes" xml:space="preserve">
          <source>Rxrb &lt;code&gt;count&lt;/code&gt;</source>
          <target state="translated">RXRB &lt;code&gt;count&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c58630d6a27e4165c3459321a03d4d7999ee328" translate="yes" xml:space="preserve">
          <source>Rxrb &lt;code&gt;merge merge_all merge_concurrent&lt;/code&gt;</source>
          <target state="translated">Rxrb &lt;code&gt;merge merge_all merge_concurrent&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="42b8dfaca4f34d142d3e9d8366843183b5a84671" translate="yes" xml:space="preserve">
          <source>Rxrb &lt;code&gt;on_error_resume_next rescue_error&lt;/code&gt;</source>
          <target state="translated">Rxrb &lt;code&gt;on_error_resume_next rescue_error&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df48fa3e5b8f8a30e164ea1f4851bd4e9bed232c" translate="yes" xml:space="preserve">
          <source>Rxrb &lt;code&gt;retry retry_infinitely&lt;/code&gt;</source>
          <target state="translated">Rxrb &lt;code&gt;retry retry_infinitely&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a50ff5d458a6a3a00e213fe188f13ef8d6625fa8" translate="yes" xml:space="preserve">
          <source>Rxrb &lt;code&gt;start_with&lt;/code&gt;</source>
          <target state="translated">Rxrb &lt;code&gt;start_with&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="714fa5ff8b3c9def68b57d14f6d9b843dccdf5c5" translate="yes" xml:space="preserve">
          <source>Rxrb &lt;code&gt;window_with_count&lt;/code&gt;</source>
          <target state="translated">Rxrb &lt;code&gt;window_with_count&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="58fabfa70811950fc1a8c6e0d56faec87e4e08cb" translate="yes" xml:space="preserve">
          <source>Sample</source>
          <target state="translated">Sample</target>
        </trans-unit>
        <trans-unit id="db412b35391491a23074f474e3dd7ab6ca4b7fa3" translate="yes" xml:space="preserve">
          <source>Sample Code</source>
          <target state="translated">Código de muestra</target>
        </trans-unit>
        <trans-unit id="28cba55d2aadf568463a9e7e645f8c7b1eed5e8b" translate="yes" xml:space="preserve">
          <source>Scan</source>
          <target state="translated">Scan</target>
        </trans-unit>
        <trans-unit id="cdcb4d8493703e86ddd0f22eb1ff805a9c89e0d9" translate="yes" xml:space="preserve">
          <source>Scheduler</source>
          <target state="translated">Scheduler</target>
        </trans-unit>
        <trans-unit id="e87e52ff4851168a4b90a0a3101d9e9213c6f05e" translate="yes" xml:space="preserve">
          <source>Schedulers</source>
          <target state="translated">Schedulers</target>
        </trans-unit>
        <trans-unit id="67373bb92cd7ecbf243edb9d60ad6f00f86a6052" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">Ver también</target>
        </trans-unit>
        <trans-unit id="61a08f389a25b863d0fca5015a2885ff6fd5c8cd" translate="yes" xml:space="preserve">
          <source>See Also:</source>
          <target state="translated">Ver también:</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">Ver también</target>
        </trans-unit>
        <trans-unit id="fe62ba3ec2492fa0dd21300f90b4d59db54088d3" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;start&quot;&gt;Start&lt;/a&gt; operator for more information about those operators.</source>
          <target state="translated">Consulte el operador &lt;a href=&quot;start&quot;&gt;Iniciar&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n sobre esos operadores.</target>
        </trans-unit>
        <trans-unit id="49229070d9275f2e39ff0135c499c3ec82be4d2d" translate="yes" xml:space="preserve">
          <source>SequenceEqual</source>
          <target state="translated">SequenceEqual</target>
        </trans-unit>
        <trans-unit id="6d6721069e94a67d89931555797dda0103cb23bb" translate="yes" xml:space="preserve">
          <source>Serialize</source>
          <target state="translated">Serialize</target>
        </trans-unit>
        <trans-unit id="dd1186892a2f5c2bd17cd7d41f90482e39bd02c5" translate="yes" xml:space="preserve">
          <source>Single</source>
          <target state="translated">Single</target>
        </trans-unit>
        <trans-unit id="3da474537ac378c616d6b301acc1674bc348cecd" translate="yes" xml:space="preserve">
          <source>Skip</source>
          <target state="translated">Skip</target>
        </trans-unit>
        <trans-unit id="cff8beecc61f3252bacde95ccb2d21cb2c7bb3de" translate="yes" xml:space="preserve">
          <source>SkipLast</source>
          <target state="translated">SkipLast</target>
        </trans-unit>
        <trans-unit id="bd69ea5a210dcd2d5ba05305f96e8abd8c637cac" translate="yes" xml:space="preserve">
          <source>SkipUntil</source>
          <target state="translated">SkipUntil</target>
        </trans-unit>
        <trans-unit id="22e179bea92af551a86509fda88cb097314902ec" translate="yes" xml:space="preserve">
          <source>SkipWhile</source>
          <target state="translated">SkipWhile</target>
        </trans-unit>
        <trans-unit id="58ecadbac79fe5cc51359cb68804c30a5376637e" translate="yes" xml:space="preserve">
          <source>Some Notes on Naming Conventions</source>
          <target state="translated">Algunas notas sobre las convenciones de denominación</target>
        </trans-unit>
        <trans-unit id="0b85a6daf91059f7033cbb077e016fc28a7f815d" translate="yes" xml:space="preserve">
          <source>Some Observable operators in RxGroovy have alternate forms that allow you to set which Scheduler the operator will use for (at least some part of) its operation. Others do not operate on any particular Scheduler, or operate on a particular default Scheduler. Those that have a particular default Scheduler include:</source>
          <target state="translated">Algunos operadores observables en RxGroovy tienen formas alternativas que le permiten establecer qué programador utilizará el operador para (al menos alguna parte de)su operación.Otros no operan en ningún Planificador en particular,o operan en un Planificador predeterminado en particular.Los que tienen un Planificador predeterminado en particular incluyen:</target>
        </trans-unit>
        <trans-unit id="fbcdf6312e8b52916c1de7617e91f5554391d0ef" translate="yes" xml:space="preserve">
          <source>Some Observable operators in RxJava have alternate forms that allow you to set which Scheduler the operator will use for (at least some part of) its operation. Others do not operate on any particular Scheduler, or operate on a particular default Scheduler. Those that have a particular default Scheduler include:</source>
          <target state="translated">Algunos operadores observables en RxJava tienen formas alternativas que le permiten establecer qué programador utilizará el operador para (al menos alguna parte de)su operación.Otros no operan en ningún Planificador en particular,ni operan en un Planificador predeterminado en particular.Los que tienen un Planificador predeterminado en particular incluyen:</target>
        </trans-unit>
        <trans-unit id="38cb086c4a233cb1a5333ff9d36f701c059eb82f" translate="yes" xml:space="preserve">
          <source>Some ReactiveX Observable operators have variants that take a Scheduler as a parameter. These instruct the operator to do some or all of its work on a particular Scheduler.</source>
          <target state="translated">Algunos operadores de ReactiveX Observable tienen variantes que toman un Scheduler como parámetro.Éstas instruyen al operador para que haga parte o todo su trabajo en un Planificador determinado.</target>
        </trans-unit>
        <trans-unit id="4ac9202dc9541026835ce69df02b385e6fb504c2" translate="yes" xml:space="preserve">
          <source>Somewhat confusingly, there are also &lt;code&gt;BlockingObservable&lt;/code&gt; operators called &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;firstOrDefault&lt;/code&gt; that block and then return items, rather than immediately returning Observables.</source>
          <target state="translated">De manera algo confusa, tambi&amp;eacute;n hay operadores &lt;code&gt;BlockingObservable&lt;/code&gt; llamados &lt;code&gt;first&lt;/code&gt; y &lt;code&gt;firstOrDefault&lt;/code&gt; que bloquean y luego devuelven elementos, en lugar de devolver Observables inmediatamente.</target>
        </trans-unit>
        <trans-unit id="1fee22cfdb8ade626b92fda4b1958a7e7558e18d" translate="yes" xml:space="preserve">
          <source>Somewhat confusingly, there are also &lt;code&gt;BlockingObservable&lt;/code&gt; operators called &lt;code&gt;last&lt;/code&gt; and &lt;code&gt;lastOrDefault&lt;/code&gt; that block and then return items, rather than immediately returning Observables.</source>
          <target state="translated">Algo confuso, tambi&amp;eacute;n hay operadores &lt;code&gt;BlockingObservable&lt;/code&gt; llamados &lt;code&gt;last&lt;/code&gt; y &lt;code&gt;lastOrDefault&lt;/code&gt; que bloquean y luego devuelven elementos, en lugar de devolver Observables inmediatamente.</target>
        </trans-unit>
        <trans-unit id="2083d000ffd0eaf7ff35e1d13313255d25a9dcad" translate="yes" xml:space="preserve">
          <source>Specialty Observables that have more precisely-controlled subscription dynamics</source>
          <target state="translated">Observables especializados que tienen una dinámica de suscripción controlada con mayor precisión</target>
        </trans-unit>
        <trans-unit id="952f375412e89ff213a8aca383d18e5691354347" translate="yes" xml:space="preserve">
          <source>Start</source>
          <target state="translated">Start</target>
        </trans-unit>
        <trans-unit id="c0fcf7ef2af334dc9a60fd70a03cde9ff6d0d67c" translate="yes" xml:space="preserve">
          <source>StartWith</source>
          <target state="translated">StartWith</target>
        </trans-unit>
        <trans-unit id="1bee4f94669039b2e98e1615609a98c4999cb704" translate="yes" xml:space="preserve">
          <source>Store the return value from that method in a variable.</source>
          <target state="translated">Guarda el valor de retorno de ese método en una variable.</target>
        </trans-unit>
        <trans-unit id="8d183dbdcea3b29906090bd83fa6fa37923cc8ec" translate="yes" xml:space="preserve">
          <source>Subject</source>
          <target state="translated">Subject</target>
        </trans-unit>
        <trans-unit id="d6981f74767d6c63d6062ad21b3bdfcd0d0d6602" translate="yes" xml:space="preserve">
          <source>Subscribe</source>
          <target state="translated">Subscribe</target>
        </trans-unit>
        <trans-unit id="b64e02707b3e5c59a9924b22e0b846d7b7419584" translate="yes" xml:space="preserve">
          <source>SubscribeOn</source>
          <target state="translated">SubscribeOn</target>
        </trans-unit>
        <trans-unit id="d43687ae3f766f223ccfd61d7f61537fe7c5cb98" translate="yes" xml:space="preserve">
          <source>Subscribing and Unsubscribing</source>
          <target state="translated">Suscripción y anulación de la suscripción</target>
        </trans-unit>
        <trans-unit id="fc9ce14b28c6f2c3b72caf056ca604b2b96f7d2b" translate="yes" xml:space="preserve">
          <source>Sum</source>
          <target state="translated">Sum</target>
        </trans-unit>
        <trans-unit id="3e44c920427e845df4958295eb8c3045b55fcfd5" translate="yes" xml:space="preserve">
          <source>Switch</source>
          <target state="translated">Switch</target>
        </trans-unit>
        <trans-unit id="a5692ec6b5b1da2cd6263a5d9d0a45278c9c4f55" translate="yes" xml:space="preserve">
          <source>Switch subscribes to an Observable that emits Observables. Each time it observes one of these emitted Observables, the Observable returned by Switch unsubscribes from the previously-emitted Observable begins emitting items from the latest Observable. Note that it will unsubscribe from the previously-emitted Observable when a new Observable is emitted from the source Observable, not when the new Observable emits an item. This means that items emitted by the previous Observable between the time the subsequent Observable is emitted and the time that subsequent Observable itself begins emitting items will be dropped (as with the yellow circle in the diagram above).</source>
          <target state="translated">Switch se suscribe a un Observable que emite Observables.Cada vez que observa uno de estos Observables emitidos,el Observable devuelto por Switch se desabona del Observable emitido previamente comienza a emitir elementos del último Observable.Observe que se dará de baja del Observable emitido anteriormente cuando un nuevo Observable sea emitido desde el Observable de origen,no cuando el nuevo Observable emita un elemento.Esto significa que los elementos emitidos por el Observable anterior entre el momento en que se emite el Observable posterior y el momento en que el propio Observable posterior comienza a emitir elementos serán eliminados (como en el círculo amarillo del diagrama anterior).</target>
        </trans-unit>
        <trans-unit id="c2c53d66948214258a26ca9ca845d7ac0c17f8e7" translate="yes" xml:space="preserve">
          <source>T</source>
          <target state="translated">T</target>
        </trans-unit>
        <trans-unit id="56806a1ffdde7ef9980b8850997e6a7523aaf863" translate="yes" xml:space="preserve">
          <source>Take</source>
          <target state="translated">Take</target>
        </trans-unit>
        <trans-unit id="5dcddcd939a62e3fadc4a275cfbff50387ce425c" translate="yes" xml:space="preserve">
          <source>TakeLast</source>
          <target state="translated">TakeLast</target>
        </trans-unit>
        <trans-unit id="9fcf25633e653a4948dd51bdc131ece0fd641fd5" translate="yes" xml:space="preserve">
          <source>TakeLastBuffer</source>
          <target state="translated">TakeLastBuffer</target>
        </trans-unit>
        <trans-unit id="6aa5940e9dd4c148413441073a4cc00a8f767785" translate="yes" xml:space="preserve">
          <source>TakeUntil</source>
          <target state="translated">TakeUntil</target>
        </trans-unit>
        <trans-unit id="3a51f26ad628e90629aea4f7cb0d24e3af6895e3" translate="yes" xml:space="preserve">
          <source>TakeWhile</source>
          <target state="translated">TakeWhile</target>
        </trans-unit>
        <trans-unit id="460dcd29ba7372ee8c706f180c5f17bea77b1f32" translate="yes" xml:space="preserve">
          <source>Takes a transforming function that operates on each element.</source>
          <target state="translated">Tiene una función transformadora que opera en cada elemento.</target>
        </trans-unit>
        <trans-unit id="f7b71bba78008ddb77fc959998b4ce8821595bc5" translate="yes" xml:space="preserve">
          <source>Techniques like &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html&quot;&gt;Java Futures&lt;/a&gt; are straightforward to use for &lt;a href=&quot;https://gist.github.com/4670979&quot;&gt;a single level of asynchronous execution&lt;/a&gt; but they start to add &lt;a href=&quot;https://gist.github.com/4671081&quot;&gt;non-trivial complexity&lt;/a&gt; when they&amp;rsquo;re nested.</source>
          <target state="translated">T&amp;eacute;cnicas como &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html&quot;&gt;Java Futures&lt;/a&gt; son f&amp;aacute;ciles de usar para &lt;a href=&quot;https://gist.github.com/4670979&quot;&gt;un solo nivel de ejecuci&amp;oacute;n asincr&amp;oacute;nica,&lt;/a&gt; pero comienzan a agregar &lt;a href=&quot;https://gist.github.com/4671081&quot;&gt;una complejidad no trivial&lt;/a&gt; cuando est&amp;aacute;n anidadas.</target>
        </trans-unit>
        <trans-unit id="dd8118896f61d1f07d69ebf7d91ff45f22736deb" translate="yes" xml:space="preserve">
          <source>Test Scheduler</source>
          <target state="translated">Programador de pruebas</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="d10b3f041bfb2c3ec591fc7431252ff0aa39e7c9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;merge&quot;&gt;Merge&lt;/a&gt; operator is also similar. It combines the emissions of two or more Observables, but may interleave them, whereas Concat never interleaves the emissions from multiple Observables.</source>
          <target state="translated">El operador &lt;a href=&quot;merge&quot;&gt;Merge&lt;/a&gt; tambi&amp;eacute;n es similar. Combina las emisiones de dos o m&amp;aacute;s Observables, pero puede intercalarlas, mientras que Concat nunca intercala las emisiones de m&amp;uacute;ltiples Observables.</target>
        </trans-unit>
        <trans-unit id="6baefa7e9f9fcf85d05a1f29dafd893921c34fe3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;observeon&quot;&gt;ObserveOn&lt;/a&gt; operator is similar, but more limited. It instructs the Observable to send notifications to observers on a specified Scheduler.</source>
          <target state="translated">El operador &lt;a href=&quot;observeon&quot;&gt;ObserveOn&lt;/a&gt; es similar, pero m&amp;aacute;s limitado. Indica al Observable que env&amp;iacute;e notificaciones a los observadores en un Programador espec&amp;iacute;fico.</target>
        </trans-unit>
        <trans-unit id="f304d9aafcbc1e3a4ceb81b1ed4873b673f3f5eb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;startwith&quot;&gt;StartWith&lt;/a&gt; operator is similar to Concat, but &lt;em&gt;prepends&lt;/em&gt;, rather than appends, items or emissions of items to those emitted by a source Observable.</source>
          <target state="translated">El operador &lt;a href=&quot;startwith&quot;&gt;StartWith&lt;/a&gt; es similar a Concat, pero &lt;em&gt;antepone&lt;/em&gt; , en lugar de agregar, elementos o emisiones de elementos a los emitidos por una fuente Observable.</target>
        </trans-unit>
        <trans-unit id="b4fbf4d3f33e46f4107fb78991ae6736b2b937af" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;subscribeon&quot;&gt;SubscribeOn&lt;/a&gt; operator is similar, but it instructs the Observable to &lt;em&gt;itself&lt;/em&gt; operate on the specified Scheduler, as well as notifying its observers on that Scheduler.</source>
          <target state="translated">El &lt;a href=&quot;subscribeon&quot;&gt;SubscribeOn&lt;/a&gt; operador es similar, pero da instrucciones al observable a &lt;em&gt;s&amp;iacute;&lt;/em&gt; operan en el planificador especificado, as&amp;iacute; como notificar a sus observadores en ese Programador.</target>
        </trans-unit>
        <trans-unit id="49008cbd0eaec3057954e658f6781db5c9ae198a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;window&quot;&gt;Window&lt;/a&gt; operator is similar to Buffer but collects items into separate Observables rather than into data structures before reemitting them.</source>
          <target state="translated">El operador de &lt;a href=&quot;window&quot;&gt;ventana&lt;/a&gt; es similar a Buffer pero recopila elementos en Observables separados en lugar de en estructuras de datos antes de volver a enviarlos.</target>
        </trans-unit>
        <trans-unit id="b199fbd77dba31c34f4c4ce3e9dfed07aa603b91" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Action&lt;/code&gt; accepts an &lt;code&gt;Observer&lt;/code&gt; and a &lt;code&gt;Subscription&lt;/code&gt;. It uses the &lt;code&gt;Subscription&lt;/code&gt; to check for the &lt;code&gt;isUnsubscribed&lt;/code&gt; condition, upon which it will stop emitting items. You can also manually stop a &lt;code&gt;StoppableObservable&lt;/code&gt; at any time by calling its &lt;code&gt;unsubscribe&lt;/code&gt; method (which will also unsubscribe the &lt;code&gt;Subscription&lt;/code&gt; you have associated with the &lt;code&gt;StoppableObservable&lt;/code&gt;).</source>
          <target state="translated">La &lt;code&gt;Action&lt;/code&gt; acepta un &lt;code&gt;Observer&lt;/code&gt; y una &lt;code&gt;Subscription&lt;/code&gt; . Utiliza la &lt;code&gt;Subscription&lt;/code&gt; para comprobar la condici&amp;oacute;n &lt;code&gt;isUnsubscribed&lt;/code&gt; , en la que dejar&amp;aacute; de emitir elementos. Tambi&amp;eacute;n puede detener manualmente un &lt;code&gt;StoppableObservable&lt;/code&gt; en cualquier momento llamando a su m&amp;eacute;todo de &lt;code&gt;unsubscribe&lt;/code&gt; (que tambi&amp;eacute;n cancelar&amp;aacute; la &lt;code&gt;Subscription&lt;/code&gt; que ha asociado con el &lt;code&gt;StoppableObservable&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4c70ce024057f9c87440087a96f9e5498f333be4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BlockingObservable&lt;/code&gt; Methods</source>
          <target state="translated">Los m&amp;eacute;todos de &lt;code&gt;BlockingObservable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ad1dffc2751d9cb748f91bf966099a5d8311f9ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BlockingObservable&lt;/code&gt; methods do not transform an Observable into another, filtered Observable, but rather they break out of the Observable cascade, blocking until the Observable emits the desired item, and then return that item itself.</source>
          <target state="translated">Los m&amp;eacute;todos &lt;code&gt;BlockingObservable&lt;/code&gt; no transforman un Observable en otro Observable filtrado, sino que salen de la cascada Observable, bloque&amp;aacute;ndose hasta que el Observable emite el elemento deseado y luego devuelve ese elemento en s&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="e36745296ecb1b3339f4a779c2c85cc4ac305d93" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Catch&lt;/code&gt; operator has a variant that allows you to specify which sort of Exception you want to catch. If you use that variant of the operator, any other Exceptions will be passed through to the observer as if the &lt;code&gt;Catch&lt;/code&gt; operator had not been applied.</source>
          <target state="translated">El operador de &lt;code&gt;Catch&lt;/code&gt; tiene una variante que le permite especificar qu&amp;eacute; tipo de excepci&amp;oacute;n desea capturar. Si usa esa variante del operador, cualquier otra excepci&amp;oacute;n se pasar&amp;aacute; al observador como si no se hubiera aplicado el operador &lt;code&gt;Catch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdf5a795f14235ad0056e88296b8e1c0457d71fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ElementAt&lt;/code&gt; operator pulls an item located at a specified index location in the sequence of items emitted by the source Observable and emits that item as its own sole emission.</source>
          <target state="translated">El operador &lt;code&gt;ElementAt&lt;/code&gt; extrae un elemento ubicado en una ubicaci&amp;oacute;n de &amp;iacute;ndice espec&amp;iacute;fica en la secuencia de elementos emitidos por la fuente Observable y emite ese elemento como su &amp;uacute;nica emisi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c9ca6a8982e977288317bbaf760bb05436d1fac1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Join&lt;/code&gt; operator combines the items emitted by two Observables, and selects which items to combine based on duration-windows that you define on a per-item basis. You implement these windows as Observables whose lifespans begin with each item emitted by either Observable. When such a window-defining Observable either emits an item or completes, the window for the item it is associated with closes. So long as an item&amp;rsquo;s window is open, it will combine with any item emitted by the other Observable. You define the function by which the items combine.</source>
          <target state="translated">El operador &lt;code&gt;Join&lt;/code&gt; combina los elementos emitidos por dos Observables y selecciona qu&amp;eacute; elementos combinar en funci&amp;oacute;n de las ventanas de duraci&amp;oacute;n que defina por elemento. Implementa estas ventanas como Observables, cuya vida &amp;uacute;til comienza con cada elemento emitido por cualquiera de los Observables. Cuando un Observable que define una ventana de este tipo emite un elemento o se completa, la ventana del elemento al que est&amp;aacute; asociado se cierra. Mientras la ventana de un elemento est&amp;eacute; abierta, se combinar&amp;aacute; con cualquier elemento emitido por el otro Observable. Defina la funci&amp;oacute;n mediante la cual se combinan los art&amp;iacute;culos.</target>
        </trans-unit>
        <trans-unit id="49b6f233307919ab9a0d77721efeeeb85eb2427b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;StringObservable&lt;/code&gt; class, which is not a default part of RxGroovy, also includes the &lt;code&gt;decode&lt;/code&gt; operator which converts a stream of multibyte characters into an Observable that emits byte arrays that respect the character boundaries.</source>
          <target state="translated">La clase &lt;code&gt;StringObservable&lt;/code&gt; , que no es una parte predeterminada de RxGroovy, tambi&amp;eacute;n incluye el operador de &lt;code&gt;decode&lt;/code&gt; que convierte una secuencia de caracteres multibyte en un Observable que emite matrices de bytes que respetan los l&amp;iacute;mites de los caracteres.</target>
        </trans-unit>
        <trans-unit id="4647c758a074dfb5917c11c1702ea9f0320221fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Worker&lt;/code&gt; is also a &lt;code&gt;Subscription&lt;/code&gt; and so you can (and should, eventually) call its &lt;code&gt;unsubscribe&lt;/code&gt; method to signal that it can halt work and release resources:</source>
          <target state="translated">El &lt;code&gt;Worker&lt;/code&gt; tambi&amp;eacute;n es una &lt;code&gt;Subscription&lt;/code&gt; y, por lo tanto, puede (y deber&amp;iacute;a, eventualmente) llamar a su m&amp;eacute;todo de &lt;code&gt;unsubscribe&lt;/code&gt; para indicar que puede detener el trabajo y liberar recursos:</target>
        </trans-unit>
        <trans-unit id="62aae628c204daa23511b0a50e55402c802b725c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Zip&lt;/code&gt; method returns an Observable that applies a function of your choosing to the combination of items emitted, in sequence, by two (or more) other Observables, with the results of this function becoming the items emitted by the returned Observable. It applies this function in strict sequence, so the first item emitted by the new Observable will be the result of the function applied to the first item emitted by Observable #1 and the first item emitted by Observable #2; the second item emitted by the new zip-Observable will be the result of the function applied to the second item emitted by Observable #1 and the second item emitted by Observable #2; and so forth. It will only emit as many items as the number of items emitted by the source Observable that emits the fewest items.</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;Zip&lt;/code&gt; devuelve un Observable que aplica una funci&amp;oacute;n de su elecci&amp;oacute;n a la combinaci&amp;oacute;n de elementos emitidos, en secuencia, por dos (o m&amp;aacute;s) otros Observables, y los resultados de esta funci&amp;oacute;n se convierten en los elementos emitidos por el Observable devuelto. Aplica esta funci&amp;oacute;n en secuencia estricta, por lo que el primer elemento emitido por el nuevo Observable ser&amp;aacute; el resultado de la funci&amp;oacute;n aplicada al primer elemento emitido por Observable # 1 y el primer elemento emitido por Observable # 2; el segundo elemento emitido por el nuevo zip-Observable ser&amp;aacute; el resultado de la funci&amp;oacute;n aplicada al segundo elemento emitido por Observable # 1 y el segundo elemento emitido por Observable # 2; Etc&amp;eacute;tera. Solo emitir&amp;aacute; tantos elementos como el n&amp;uacute;mero de elementos emitidos por la fuente Observable que emite la menor cantidad de elementos.</target>
        </trans-unit>
        <trans-unit id="e5691c91ab07a55b1c3fb75c15c16429d75b4d53" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cast&lt;/code&gt; operator is a specialized version of Map that transforms each item from the source Observable by casting it into a particular Class before reemitting it.</source>
          <target state="translated">El &lt;code&gt;cast&lt;/code&gt; del operador es una versi&amp;oacute;n especializada de mapa que transforma cada elemento de la fuente observable por colada en una clase particular antes de que reemitting.</target>
        </trans-unit>
        <trans-unit id="2d52bc5228a5c99adbd13b94db13bf682b4106af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;collect&lt;/code&gt; operator is similar to &lt;code&gt;reduce&lt;/code&gt; but is specialized for the purpose of collecting the whole set of items emitted by the source Observable into a single mutable data structure to be emitted by the resulting Observable. Pass it two parameters:</source>
          <target state="translated">El operador de &lt;code&gt;collect&lt;/code&gt; es similar a &lt;code&gt;reduce&lt;/code&gt; pero est&amp;aacute; especializado con el fin de recopilar todo el conjunto de elementos emitidos por el Observable de origen en una &amp;uacute;nica estructura de datos mutable para ser emitidos por el Observable resultante. Pasarle dos par&amp;aacute;metros:</target>
        </trans-unit>
        <trans-unit id="6cf0adfab79277c51e5dafe6774782092f0c83c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;concat*&lt;/code&gt; operator concatenates the Observables emitted by an Observable together, in the order in which they are emitted.</source>
          <target state="translated">El operador &lt;code&gt;concat*&lt;/code&gt; concatena los Observables emitidos por un Observable juntos, en el orden en que se emiten.</target>
        </trans-unit>
        <trans-unit id="262174a50de88e018bb2bb7470c296853e50fc00" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;connect&lt;/code&gt; method returns a &lt;code&gt;Disposable&lt;/code&gt;. You can call that &lt;code&gt;Disposable&lt;/code&gt; object&amp;rsquo;s &lt;code&gt;dispose&lt;/code&gt; method to instruct the Observable to stop emitting items to its Subscribers.</source>
          <target state="translated">El m&amp;eacute;todo de &lt;code&gt;connect&lt;/code&gt; devuelve un &lt;code&gt;Disposable&lt;/code&gt; . Puede llamar al m&amp;eacute;todo de &lt;code&gt;dispose&lt;/code&gt; ese objeto &lt;code&gt;Disposable&lt;/code&gt; para indicarle al Observable que deje de emitir elementos a sus suscriptores.</target>
        </trans-unit>
        <trans-unit id="0f476bb86d90183235c41e4ed71417a68f5fc2ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;connect&lt;/code&gt; method returns a &lt;code&gt;Subscription&lt;/code&gt;. You can call that &lt;code&gt;Subscription&lt;/code&gt; object&amp;rsquo;s &lt;code&gt;unsubscribe&lt;/code&gt; method to instruct the Observable to stop emitting items to its Subscribers.</source>
          <target state="translated">El m&amp;eacute;todo de &lt;code&gt;connect&lt;/code&gt; devuelve una &lt;code&gt;Subscription&lt;/code&gt; . Puede llamar al m&amp;eacute;todo de &lt;code&gt;unsubscribe&lt;/code&gt; &lt;code&gt;Subscription&lt;/code&gt; ese objeto de suscripci&amp;oacute;n para indicar al Observable que deje de emitir elementos a sus suscriptores.</target>
        </trans-unit>
        <trans-unit id="32a0f2e47fcf367aab2c4d2fea54935a14d32d23" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;contains&lt;/code&gt; operator in RxJS takes an optional second parameter: a zero-based index into the source Observable&amp;rsquo;s sequence at which to start searching for the item.</source>
          <target state="translated">El operador &lt;code&gt;contains&lt;/code&gt; en RxJS toma un segundo par&amp;aacute;metro opcional: un &amp;iacute;ndice de base cero en la secuencia del Observable de origen en el que comenzar a buscar el elemento.</target>
        </trans-unit>
        <trans-unit id="13a54029acae7bece88ccff45131ab5c099597a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;debounceWithSelector&lt;/code&gt; operator throttles the source Observable by applying a function to each item it emits, this function generating an Observable. If the source Observable emits another item before this newly-generated Observable terminates, &lt;code&gt;debounce&lt;/code&gt; will suppress the item.</source>
          <target state="translated">El operador &lt;code&gt;debounceWithSelector&lt;/code&gt; regula la fuente Observable aplicando una funci&amp;oacute;n a cada elemento que emite, esta funci&amp;oacute;n genera un Observable. Si el Observable de origen emite otro elemento antes de que este Observable reci&amp;eacute;n generado termine, el &lt;code&gt;debounce&lt;/code&gt; suprimir&amp;aacute; el elemento.</target>
        </trans-unit>
        <trans-unit id="e81c335785cb73611f872b22bd602a71298e93a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doAfterTerminate&lt;/code&gt; operator registers an &lt;code&gt;Action&lt;/code&gt; which will be called just &lt;em&gt;after&lt;/em&gt; the resulting Observable terminates, whether normally or with an error.</source>
          <target state="translated">El operador &lt;code&gt;doAfterTerminate&lt;/code&gt; registra una &lt;code&gt;Action&lt;/code&gt; que se llamar&amp;aacute; justo &lt;em&gt;despu&amp;eacute;s de&lt;/em&gt; que termine el Observable resultante, ya sea normalmente o con un error.</target>
        </trans-unit>
        <trans-unit id="0623a20ead85e594b09a4929adac2bbbb7b3f224" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doOnCompleted&lt;/code&gt; operator registers an &lt;code&gt;Action&lt;/code&gt; which will be called if the resulting Observable terminates normally, calling &lt;code&gt;onCompleted&lt;/code&gt;.</source>
          <target state="translated">El operador &lt;code&gt;doOnCompleted&lt;/code&gt; registra una &lt;code&gt;Action&lt;/code&gt; que se llamar&amp;aacute; si el Observable resultante termina normalmente, llamando a &lt;code&gt;onCompleted&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0026ae0169af251d209c2da5abd0bfa704cfab1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doOnEach&lt;/code&gt; operator allows you to establish a callback that the resulting Observable will call each time it emits an item. You can pass this callback either in the form of an &lt;code&gt;Action&lt;/code&gt; that takes an &lt;code&gt;onNext&lt;/code&gt; variety of &lt;code&gt;Notification&lt;/code&gt; as its sole parameter, or you can pass in an Observer whose &lt;code&gt;onNext&lt;/code&gt; method will be called as if it had subscribed to the Observable.</source>
          <target state="translated">El operador &lt;code&gt;doOnEach&lt;/code&gt; le permite establecer una devoluci&amp;oacute;n de llamada que el Observable resultante llamar&amp;aacute; cada vez que emita un elemento. Puede pasar esta devoluci&amp;oacute;n de llamada en forma de una &lt;code&gt;Action&lt;/code&gt; que toma una variedad de &lt;code&gt;Notification&lt;/code&gt; &lt;code&gt;onNext&lt;/code&gt; como su &amp;uacute;nico par&amp;aacute;metro, o puede pasar un Observer cuyo m&amp;eacute;todo &lt;code&gt;onNext&lt;/code&gt; se llamar&amp;aacute; como si se hubiera suscrito al Observable.</target>
        </trans-unit>
        <trans-unit id="eabd4c3f21534a441bc83130020ea0729317f2bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doOnError&lt;/code&gt; operator registers an &lt;code&gt;Action&lt;/code&gt; which will be called if the resulting Observable terminates abnormally, calling &lt;code&gt;onError&lt;/code&gt;. This &lt;code&gt;Action&lt;/code&gt; will be passed the &lt;code&gt;Throwable&lt;/code&gt; representing the error.</source>
          <target state="translated">El operador &lt;code&gt;doOnError&lt;/code&gt; registra una &lt;code&gt;Action&lt;/code&gt; que se llamar&amp;aacute; si el Observable resultante termina de forma anormal, llamando a &lt;code&gt;onError&lt;/code&gt; . A esta &lt;code&gt;Action&lt;/code&gt; se le pasar&amp;aacute; el &lt;code&gt;Throwable&lt;/code&gt; que representa el error.</target>
        </trans-unit>
        <trans-unit id="a69c5948b6c36fdf006d228347957b8e8b5a82cb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doOnNext&lt;/code&gt; operator is much like &lt;code&gt;doOnEach(Action1)&lt;/code&gt; except that the &lt;code&gt;Action&lt;/code&gt; that you pass it as a parameter does not accept a &lt;code&gt;Notification&lt;/code&gt; but instead simply accepts the emitted item.</source>
          <target state="translated">El operador &lt;code&gt;doOnNext&lt;/code&gt; es muy parecido a &lt;code&gt;doOnEach(Action1)&lt;/code&gt; excepto que la &lt;code&gt;Action&lt;/code&gt; que le pasa como par&amp;aacute;metro no acepta una &lt;code&gt;Notification&lt;/code&gt; sino que simplemente acepta el elemento emitido.</target>
        </trans-unit>
        <trans-unit id="47b3486778ac1c48193054633dd037f987fce4ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doOnRequest&lt;/code&gt; operator (new in RxGroovy 1.1) registers an &lt;code&gt;Action&lt;/code&gt; which will be called whenever an observer requests additional items from the resulting Observable. That &lt;code&gt;Action&lt;/code&gt; receives as its parameter the number of items that the observer is requesting.</source>
          <target state="translated">El operador &lt;code&gt;doOnRequest&lt;/code&gt; (nuevo en RxGroovy 1.1) registra una &lt;code&gt;Action&lt;/code&gt; que se llamar&amp;aacute; cada vez que un observador solicite elementos adicionales del Observable resultante. Esa &lt;code&gt;Action&lt;/code&gt; recibe como par&amp;aacute;metro el n&amp;uacute;mero de elementos que solicita el observador.</target>
        </trans-unit>
        <trans-unit id="ae2db8da5cb25f3493e2edbab4c991c3a890fa95" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doOnRequest&lt;/code&gt; operator (new in RxJava 1.1) registers an &lt;code&gt;Action&lt;/code&gt; which will be called whenever an observer requests additional items from the resulting Observable. That &lt;code&gt;Action&lt;/code&gt; receives as its parameter the number of items that the observer is requesting.</source>
          <target state="translated">El operador &lt;code&gt;doOnRequest&lt;/code&gt; (nuevo en RxJava 1.1) registra una &lt;code&gt;Action&lt;/code&gt; que se llamar&amp;aacute; siempre que un observador solicite elementos adicionales del Observable resultante. Esa &lt;code&gt;Action&lt;/code&gt; recibe como par&amp;aacute;metro el n&amp;uacute;mero de elementos que solicita el observador.</target>
        </trans-unit>
        <trans-unit id="a7c2c85aa48da67b4394be68c9693a243657f00f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doOnSubscribe&lt;/code&gt; operator registers an &lt;code&gt;Action&lt;/code&gt; which will be called whenever an observer subscribes to the resulting Observable.</source>
          <target state="translated">El operador &lt;code&gt;doOnSubscribe&lt;/code&gt; registra una &lt;code&gt;Action&lt;/code&gt; que se llamar&amp;aacute; cada vez que un observador se suscriba al Observable resultante.</target>
        </trans-unit>
        <trans-unit id="22e4b3cb15d1500d61d8e8dd0104bea7baad9fd3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doOnTerminate&lt;/code&gt; operator registers an &lt;code&gt;Action&lt;/code&gt; which will be called just &lt;em&gt;before&lt;/em&gt; the resulting Observable terminates, whether normally or with an error.</source>
          <target state="translated">El operador &lt;code&gt;doOnTerminate&lt;/code&gt; registra una &lt;code&gt;Action&lt;/code&gt; que se llamar&amp;aacute; justo &lt;em&gt;antes de&lt;/em&gt; que finalice el Observable resultante, ya sea normalmente o con un error.</target>
        </trans-unit>
        <trans-unit id="c98415bf041e0eacfd89ab746aa429e8bbfe6ad5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doOnUnsubscribe&lt;/code&gt; operator registers an &lt;code&gt;Action&lt;/code&gt; which will be called whenever an observer unsubscribes from the resulting Observable.</source>
          <target state="translated">El operador &lt;code&gt;doOnUnsubscribe&lt;/code&gt; registra una &lt;code&gt;Action&lt;/code&gt; que se llamar&amp;aacute; cada vez que un observador se d&amp;eacute; de baja del Observable resultante.</target>
        </trans-unit>
        <trans-unit id="f94bf58f6f661938712ce1a2d3b96c007a0d9cc3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;finallyDo&lt;/code&gt; operator registers an &lt;code&gt;Action&lt;/code&gt; which will be called just &lt;em&gt;after&lt;/em&gt; the resulting Observable terminates, whether normally or with an error.</source>
          <target state="translated">El operador &lt;code&gt;finallyDo&lt;/code&gt; registra una &lt;code&gt;Action&lt;/code&gt; que se llamar&amp;aacute; justo &lt;em&gt;despu&amp;eacute;s de&lt;/em&gt; que finalice el Observable resultante, ya sea normalmente o con un error.</target>
        </trans-unit>
        <trans-unit id="ab085823e86e31a61ddfb7113f37699ef32a735d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;find&lt;/code&gt; operator is much like &lt;code&gt;first&lt;/code&gt; except that the predicate argument is mandatory, and it behaves differently if no item from the source Observable matches the predicate. While &lt;code&gt;first&lt;/code&gt; will send an &lt;code&gt;onError&lt;/code&gt; notification in such a case, &lt;code&gt;find&lt;/code&gt; will instead emit an &lt;code&gt;undefined&lt;/code&gt; item.</source>
          <target state="translated">El operador de &lt;code&gt;find&lt;/code&gt; es muy parecido al &lt;code&gt;first&lt;/code&gt; excepto que el argumento del predicado es obligatorio y se comporta de manera diferente si ning&amp;uacute;n elemento de la fuente Observable coincide con el predicado. Si bien &lt;code&gt;first&lt;/code&gt; enviar&amp;aacute; una notificaci&amp;oacute;n de &lt;code&gt;onError&lt;/code&gt; en tal caso, &lt;code&gt;find&lt;/code&gt; en su lugar emitir&amp;aacute; un elemento &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c6c877a3737234f454d67e02db333027e5f3786" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;findIndex&lt;/code&gt; operator in RxJS takes as its parameter a predicate function. It returns an Observable that emits either a single number &amp;mdash; the zero-based index of the first item in the source Observable sequence that matches the predicate &amp;mdash; or &lt;code&gt;&amp;minus;1&lt;/code&gt; if no such item matches.</source>
          <target state="translated">El operador &lt;code&gt;findIndex&lt;/code&gt; en RxJS toma como par&amp;aacute;metro una funci&amp;oacute;n de predicado. Devuelve un Observable que emite un solo n&amp;uacute;mero (el &amp;iacute;ndice de base cero del primer elemento de la secuencia Observable de origen que coincide con el predicado) o &lt;code&gt;&amp;minus;1&lt;/code&gt; si no coincide ning&amp;uacute;n elemento.</target>
        </trans-unit>
        <trans-unit id="ed0159e9a2450a5d952076a8e5cd9627bcd97c41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;findIndex&lt;/code&gt; operator is similar to &lt;code&gt;find&lt;/code&gt;, except that instead of emitting the item that matches the predicate (or &lt;code&gt;undefined&lt;/code&gt;), it emits the zero-based index of that item in the source Observable&amp;rsquo;s sequence (or &lt;code&gt;-1&lt;/code&gt;).</source>
          <target state="translated">El operador &lt;code&gt;findIndex&lt;/code&gt; es similar a &lt;code&gt;find&lt;/code&gt; , excepto que en lugar de emitir el elemento que coincide con el predicado (o &lt;code&gt;undefined&lt;/code&gt; ), emite el &amp;iacute;ndice de base cero de ese elemento en la secuencia del Observable de origen (o &lt;code&gt;-1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="49be14c47d2aafe03c88558e00c4c6dde3f02fbc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;firstOrDefault&lt;/code&gt; operator is similar to &lt;code&gt;first&lt;/code&gt;, but you pass it a default item that it can emit if the source Observable fails to emit any items</source>
          <target state="translated">El operador &lt;code&gt;firstOrDefault&lt;/code&gt; es similar al &lt;code&gt;first&lt;/code&gt; , pero le pasa un elemento predeterminado que puede emitir si la fuente Observable no emite ning&amp;uacute;n elemento</target>
        </trans-unit>
        <trans-unit id="488465a4fa2c1a64f9853dcc9ecfc03937a36cce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flatMapIterable&lt;/code&gt; variants pair up source items and generated &lt;code&gt;Iterable&lt;/code&gt;s rather than source items and generated Observables, but otherwise work in much the same way.</source>
          <target state="translated">Las variantes &lt;code&gt;flatMapIterable&lt;/code&gt; emparejan elementos de origen y generan &lt;code&gt;Iterable&lt;/code&gt; s en lugar de elementos de origen y Observables generados, pero por lo dem&amp;aacute;s funcionan de la misma manera.</target>
        </trans-unit>
        <trans-unit id="c4df8dce680a0580207e8db092ab428c79083578" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flatMapLatest&lt;/code&gt; operator behaves much like the standard FlatMap operator, except that whenever a new item is emitted by the source Observable, it will unsubscribe to and stop mirroring the Observable that was generated from the previously-emitted item, and begin only mirroring the current one.</source>
          <target state="translated">El operador &lt;code&gt;flatMapLatest&lt;/code&gt; se comporta de manera muy similar al operador FlatMap est&amp;aacute;ndar, excepto que cada vez que el Observable de origen emite un nuevo elemento, se cancelar&amp;aacute; la suscripci&amp;oacute;n y dejar&amp;aacute; de duplicar el Observable que se gener&amp;oacute; a partir del elemento emitido anteriormente, y comenzar&amp;aacute; a duplicar solo el actual. .</target>
        </trans-unit>
        <trans-unit id="c482ae55d97cbd55598c3be35323d33a7e002821" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; operator (and its alias, &lt;code&gt;forIn&lt;/code&gt;) is very similar to &lt;code&gt;concatMap&lt;/code&gt;, though it has a converse flexibility. While &lt;code&gt;concatMap&lt;/code&gt; operates on an Observable source and can use Observable, Promise, or array intermediaries to generate its output sequence; &lt;code&gt;for&lt;/code&gt; always uses Observables as its intermediaries, but can operate on a source that is either an Observable, a Promise, or an array.</source>
          <target state="translated">El operador &lt;code&gt;for&lt;/code&gt; (y su alias, &lt;code&gt;forIn&lt;/code&gt; ) es muy similar a &lt;code&gt;concatMap&lt;/code&gt; , aunque tiene una flexibilidad inversa. Mientras que &lt;code&gt;concatMap&lt;/code&gt; opera en una fuente observable y puede usar intermediarios observables, promesas o de matriz para generar su secuencia de salida; &lt;code&gt;for&lt;/code&gt; siempre utiliza Observables como intermediarios, pero puede operar en una fuente que sea Observable, Promise o array.</target>
        </trans-unit>
        <trans-unit id="f48d8db17cfa63ab694c9c09d245ea6942591cf0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;forEach&lt;/code&gt; operators are simpler versions of &lt;code&gt;subscribe&lt;/code&gt;. You can pass them between one and three functions, which will be interpreted as follows:</source>
          <target state="translated">Los operadores &lt;code&gt;forEach&lt;/code&gt; son versiones m&amp;aacute;s simples de &lt;code&gt;subscribe&lt;/code&gt; . Puedes pasarlas entre una y tres funciones, que se interpretar&amp;aacute;n de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="1a921457487d3264a61dac1881821287ea0f75ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fromCallback&lt;/code&gt; operator takes a function as a parameter, calls this function, and emits the value returned from it as its single emission.</source>
          <target state="translated">El operador &lt;code&gt;fromCallback&lt;/code&gt; toma una funci&amp;oacute;n como par&amp;aacute;metro, llama a esta funci&amp;oacute;n y emite el valor devuelto como su &amp;uacute;nica emisi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b504d654fb237651e5ac6a12e8bcfa06d02077fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fromEvent&lt;/code&gt; operator takes an &amp;ldquo;element&amp;rdquo; and an event name as parameters, and it then listens for events of that name taking place on that element. It returns an Observable that emits those events. An &amp;ldquo;element&amp;rdquo; may be a simple</source>
          <target state="translated">El operador &lt;code&gt;fromEvent&lt;/code&gt; toma un &quot;elemento&quot; y un nombre de evento como par&amp;aacute;metros, y luego escucha los eventos de ese nombre que tienen lugar en ese elemento. Devuelve un Observable que emite esos eventos. Un &quot;elemento&quot; puede ser un simple</target>
        </trans-unit>
        <trans-unit id="0cebc7b8cc69c87290f5ce391d54f63ba6b5075c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fromEventPattern&lt;/code&gt; operator is similar, except that instead of taking an element and an event name as parameters, it takes two functions as parameters. The first function attaches an event listener to a variety of events on a variety of elements; the second function removes this set of listeners. In this way you can establish a single Observable that emits items representing a variety of events and a variety of target elements.</source>
          <target state="translated">El operador &lt;code&gt;fromEventPattern&lt;/code&gt; es similar, excepto que en lugar de tomar un elemento y un nombre de evento como par&amp;aacute;metros, toma dos funciones como par&amp;aacute;metros. La primera funci&amp;oacute;n adjunta un detector de eventos a una variedad de eventos en una variedad de elementos; la segunda funci&amp;oacute;n elimina este conjunto de oyentes. De esta manera, puede establecer un Observable &amp;uacute;nico que emite elementos que representan una variedad de eventos y una variedad de elementos de destino.</target>
        </trans-unit>
        <trans-unit id="d0506ce1478017fe5fb5c14f3f465e3af698614d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getIterator&lt;/code&gt; operator applies to the &lt;code&gt;BlockingObservable&lt;/code&gt; subclass, so in order to use it, you must first convert your source Observable into a &lt;code&gt;BlockingObservable&lt;/code&gt; by means of either the &lt;code&gt;BlockingObservable.from&lt;/code&gt; method or the &lt;code&gt;Observable.toBlocking&lt;/code&gt; operator.</source>
          <target state="translated">El operador &lt;code&gt;getIterator&lt;/code&gt; se aplica a la subclase &lt;code&gt;BlockingObservable&lt;/code&gt; , por lo que para poder usarlo, primero debe convertir su fuente Observable en un &lt;code&gt;BlockingObservable&lt;/code&gt; mediante el m&amp;eacute;todo &lt;code&gt;BlockingObservable.from&lt;/code&gt; o el operador &lt;code&gt;Observable.toBlocking&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fdfd2efb1b4f9b5b207f496d9028e62a7244995f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;groupJoin&lt;/code&gt; operator takes four parameters:</source>
          <target state="translated">El operador &lt;code&gt;groupJoin&lt;/code&gt; toma cuatro par&amp;aacute;metros:</target>
        </trans-unit>
        <trans-unit id="29d22ca65d9c540689bc8b0ce26cca9ce3db4440" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;indexOf&lt;/code&gt; operator in RxJS is similar to &lt;code&gt;contains&lt;/code&gt; but rather than returning an Observable that emits &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; it returns an Observable that emits the index of the item in the source Observable sequence, or &lt;code&gt;&amp;minus;1&lt;/code&gt; if no such item was emitted.</source>
          <target state="translated">El operador &lt;code&gt;indexOf&lt;/code&gt; en RxJS es similar a &lt;code&gt;contains&lt;/code&gt; , pero en lugar de devolver un Observable que emite &lt;code&gt;true&lt;/code&gt; o &lt;code&gt;false&lt;/code&gt; , devuelve un Observable que emite el &amp;iacute;ndice del elemento en la secuencia Observable de origen, o &lt;code&gt;&amp;minus;1&lt;/code&gt; si no se emiti&amp;oacute; tal elemento.</target>
        </trans-unit>
        <trans-unit id="77be1ee57cc41fc2f9e2f8bfb2756ab14303f199" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;indexOf&lt;/code&gt; operator takes an optional second parameter: a zero-based index into the source Observable&amp;rsquo;s sequence at which to start searching for the item. The index value that the resulting Observable emits will be relative to this start point, not to the beginning of the sequence.</source>
          <target state="translated">El operador &lt;code&gt;indexOf&lt;/code&gt; toma un segundo par&amp;aacute;metro opcional: un &amp;iacute;ndice de base cero en la secuencia del Observable de origen en el que comenzar a buscar el elemento. El valor de &amp;iacute;ndice que emite el Observable resultante ser&amp;aacute; relativo a este punto de inicio, no al comienzo de la secuencia.</target>
        </trans-unit>
        <trans-unit id="5552c7e46b5a139352e9da9264ebc154edea5fd5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;join&lt;/code&gt; operator takes four parameters:</source>
          <target state="translated">El operador de &lt;code&gt;join&lt;/code&gt; toma cuatro par&amp;aacute;metros:</target>
        </trans-unit>
        <trans-unit id="96dab761cc41cd45ea19644cf7e7ad30cb22e0aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lastOrDefault&lt;/code&gt; operator is similar to &lt;code&gt;last&lt;/code&gt;, but you pass it a default item that it can emit if the source Observable fails to emit any items.</source>
          <target state="translated">El operador &lt;code&gt;lastOrDefault&lt;/code&gt; es similar al &lt;code&gt;last&lt;/code&gt; , pero le pasa un elemento predeterminado que puede emitir si la fuente Observable no puede emitir ning&amp;uacute;n elemento.</target>
        </trans-unit>
        <trans-unit id="bb5672f422c4c2cb70cc9c1f677ba66ad8eba847" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;latest&lt;/code&gt; operator is similar, but rather than blocking to wait for the next emitted item, it immediately returns the most-recently-emitted item, and only blocks if the Observable has not yet emitted anything.</source>
          <target state="translated">El &lt;code&gt;latest&lt;/code&gt; operador es similar, pero en lugar de bloquear para esperar el siguiente elemento emitido, devuelve inmediatamente el elemento emitido m&amp;aacute;s recientemente y solo se bloquea si el Observable a&amp;uacute;n no ha emitido nada.</target>
        </trans-unit>
        <trans-unit id="72bbe7b92507d29558aef3a62856379c4ffcb4c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let&lt;/code&gt; (or &lt;code&gt;letBind&lt;/code&gt;) operator is available in the following packages:</source>
          <target state="translated">El operador &lt;code&gt;let&lt;/code&gt; (o &lt;code&gt;letBind&lt;/code&gt; ) est&amp;aacute; disponible en los siguientes paquetes:</target>
        </trans-unit>
        <trans-unit id="d3bdb3993ae70293143f7eee67ab351fa4c6141f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;manySelect&lt;/code&gt; operator is often described as a &amp;ldquo;comonadic bind.&amp;rdquo; If that clears things up for you, you&amp;rsquo;re welcome. Elsewise, here&amp;rsquo;s an explanation:</source>
          <target state="translated">El operador &lt;code&gt;manySelect&lt;/code&gt; se describe a menudo como un &quot;enlace comon&amp;aacute;dico&quot;. Si eso te aclara las cosas, eres bienvenido. De lo contrario, aqu&amp;iacute; hay una explicaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="36db071dc02b975954bc90d1b46fa778860971d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;maxBy&lt;/code&gt; operator is similar to &lt;code&gt;max&lt;/code&gt;, but instead of emitting the item with the maximum value, it emits the item with the maximum &lt;em&gt;key&lt;/em&gt;, where that key is generated based on a function you provide to &lt;code&gt;maxBy&lt;/code&gt;</source>
          <target state="translated">El operador &lt;code&gt;maxBy&lt;/code&gt; es similar a &lt;code&gt;max&lt;/code&gt; , pero en lugar de emitir el elemento con el valor m&amp;aacute;ximo, emite el elemento con la &lt;em&gt;clave&lt;/em&gt; m&amp;aacute;xima , donde esa clave se genera en funci&amp;oacute;n de una funci&amp;oacute;n que usted proporciona a &lt;code&gt;maxBy&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="13aa9ca81dae630ad2f0bf87c356c068d922d3c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;maxBy&lt;/code&gt; operator is similar to &lt;code&gt;max&lt;/code&gt;, but instead of emitting the item with the maximum value, it emits the item with the maximum &lt;em&gt;key&lt;/em&gt;, where that key is generated based on a function you provide to &lt;code&gt;maxBy&lt;/code&gt;. &lt;code&gt;maxBy&lt;/code&gt; also takes an optional second parameter: a comparer function that it will use instead of its default to compare the keys of the two items.</source>
          <target state="translated">El operador &lt;code&gt;maxBy&lt;/code&gt; es similar a &lt;code&gt;max&lt;/code&gt; , pero en lugar de emitir el elemento con el valor m&amp;aacute;ximo, emite el elemento con la &lt;em&gt;clave&lt;/em&gt; m&amp;aacute;xima , donde esa clave se genera en funci&amp;oacute;n de una funci&amp;oacute;n que usted proporciona a &lt;code&gt;maxBy&lt;/code&gt; . &lt;code&gt;maxBy&lt;/code&gt; tambi&amp;eacute;n toma un segundo par&amp;aacute;metro opcional: una funci&amp;oacute;n de comparaci&amp;oacute;n que usar&amp;aacute; en lugar de su predeterminada para comparar las claves de los dos elementos.</target>
        </trans-unit>
        <trans-unit id="e62a7b488d66dfd66eccaab522c33c28dcfbaa4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;merge_all&lt;/code&gt; operator, despite its name, really behaves like a Concat variant in Rx.rb. It accepts an Observable of Observables as its parameter, and concatenates the emissions from these Observables.</source>
          <target state="translated">El operador &lt;code&gt;merge_all&lt;/code&gt; , a pesar de su nombre, realmente se comporta como una variante de Concat en Rx.rb. Acepta un Observable de Observables como par&amp;aacute;metro y concatena las emisiones de estos Observables.</target>
        </trans-unit>
        <trans-unit id="591507d6d1fd978b9d1b908bc6f44f533f339a37" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;minBy&lt;/code&gt; operator is similar to &lt;code&gt;min&lt;/code&gt;, but instead of emitting the item with the minimum value, it emits the item with the minimum &lt;em&gt;key&lt;/em&gt;, where that key is generated based on a function you provide to &lt;code&gt;minBy&lt;/code&gt;</source>
          <target state="translated">El operador &lt;code&gt;minBy&lt;/code&gt; es similar a &lt;code&gt;min&lt;/code&gt; , pero en lugar de emitir el elemento con el valor m&amp;iacute;nimo, emite el elemento con la &lt;em&gt;clave&lt;/em&gt; m&amp;iacute;nima , donde esa clave se genera en funci&amp;oacute;n de una funci&amp;oacute;n que usted proporciona a &lt;code&gt;minBy&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6d75ab372e084506ae5ab756f24870c2c7e50227" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;minBy&lt;/code&gt; operator is similar to &lt;code&gt;min&lt;/code&gt;, but instead of emitting the item with the minimum value, it emits the item with the minimum &lt;em&gt;key&lt;/em&gt;, where that key is generated based on a function you provide to &lt;code&gt;minBy&lt;/code&gt;. &lt;code&gt;minBy&lt;/code&gt; also takes an optional second parameter: a comparer function that it will use instead of its default to compare the keys of the two items.</source>
          <target state="translated">El operador &lt;code&gt;minBy&lt;/code&gt; es similar a &lt;code&gt;min&lt;/code&gt; , pero en lugar de emitir el elemento con el valor m&amp;iacute;nimo, emite el elemento con la &lt;em&gt;clave&lt;/em&gt; m&amp;iacute;nima , donde esa clave se genera en funci&amp;oacute;n de una funci&amp;oacute;n que usted proporciona a &lt;code&gt;minBy&lt;/code&gt; . &lt;code&gt;minBy&lt;/code&gt; tambi&amp;eacute;n toma un segundo par&amp;aacute;metro opcional: una funci&amp;oacute;n de comparaci&amp;oacute;n que usar&amp;aacute; en lugar de su predeterminada para comparar las claves de los dos elementos.</target>
        </trans-unit>
        <trans-unit id="d97994082600972d411b156dd140c1aa7e0d3d6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mostRecent&lt;/code&gt; operator similarly allows you to iterate over the emissions of a &lt;code&gt;BlockingObservable&lt;/code&gt;, but its Iterable always immediately returns a value: either a default item you provide (if the &lt;code&gt;BlockingObservable&lt;/code&gt; has not yet emitted an item), or the latest item the &lt;code&gt;BlockingObservable&lt;/code&gt; has emitted.</source>
          <target state="translated">El operador &lt;code&gt;mostRecent&lt;/code&gt; tambi&amp;eacute;n le permite iterar sobre las emisiones de un &lt;code&gt;BlockingObservable&lt;/code&gt; , pero su Iterable siempre devuelve inmediatamente un valor: un elemento predeterminado que usted proporciona (si el &lt;code&gt;BlockingObservable&lt;/code&gt; a&amp;uacute;n no ha emitido un elemento) o el &amp;uacute;ltimo elemento que ha emitido el &lt;code&gt;BlockingObservable&lt;/code&gt; . .</target>
        </trans-unit>
        <trans-unit id="40070d4eb2002addde3a0bbcd673ca113e9d039a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;multicast&lt;/code&gt; operator is available in the following packages:</source>
          <target state="translated">El operador de &lt;code&gt;multicast&lt;/code&gt; est&amp;aacute; disponible en los siguientes paquetes:</target>
        </trans-unit>
        <trans-unit id="d99a2921d18b7527e96c7b586a0ec6bb398d2cba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;next&lt;/code&gt; operator blocks until the &lt;code&gt;BlockingObservable&lt;/code&gt; emits another item, and then returns that item. You can call this function repeatedly to get successive items from the &lt;code&gt;BlockingObservable&lt;/code&gt;, effectively iterating over its emissions in a blocking fashion.</source>
          <target state="translated">El &lt;code&gt;next&lt;/code&gt; operador bloquea hasta que &lt;code&gt;BlockingObservable&lt;/code&gt; emite otro elemento y luego devuelve ese elemento. Puede llamar a esta funci&amp;oacute;n repetidamente para obtener elementos sucesivos de &lt;code&gt;BlockingObservable&lt;/code&gt; , iterando de manera efectiva sobre sus emisiones en forma de bloqueo.</target>
        </trans-unit>
        <trans-unit id="85e2b7ee1fbcbbebfd708d668c59aba89dff308d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;of&lt;/code&gt; operator accepts a number of items as parameters, and returns an Observable that emits each of these parameters, in order, as its emitted sequence.</source>
          <target state="translated">El operador &lt;code&gt;of&lt;/code&gt; acepta una serie de elementos como par&amp;aacute;metros y devuelve un Observable que emite cada uno de estos par&amp;aacute;metros, en orden, como su secuencia de emisi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="0a820b931d7dd03c56a7bc833c9808fde84e35de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onErrorResumeNext&lt;/code&gt; method returns an Observable that mirrors the behavior of the source Observable, unless that Observable invokes &lt;code&gt;onError&lt;/code&gt; in which case, rather than propagating that error to the observer, &lt;code&gt;onErrorResumeNext&lt;/code&gt; will instead begin mirroring a second, backup Observable, as shown in the following sample code:</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;onErrorResumeNext&lt;/code&gt; devuelve un Observable que refleja el comportamiento del Observable de origen, a menos que el Observable invoca a &lt;code&gt;onError&lt;/code&gt; , en cuyo caso, en lugar de propagar ese error al observador, &lt;code&gt;onErrorResumeNext&lt;/code&gt; comenzar&amp;aacute; a reflejar un segundo Observable de respaldo, como se muestra en el siguiente ejemplo c&amp;oacute;digo:</target>
        </trans-unit>
        <trans-unit id="ad40b93d8ffe52cf75d26afebbdddd1c044c1f25" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onErrorResumeNext&lt;/code&gt; method returns an Observable that mirrors the behavior of the source Observable, unless that Observable invokes &lt;code&gt;onError&lt;/code&gt; in which case, rather than propagating that error to the observer, &lt;code&gt;onErrorResumeNext&lt;/code&gt; will instead begin mirroring a second, backup Observable.</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;onErrorResumeNext&lt;/code&gt; devuelve un Observable que refleja el comportamiento del Observable de origen, a menos que Observable invoca a &lt;code&gt;onError&lt;/code&gt; , en cuyo caso, en lugar de propagar ese error al observador, &lt;code&gt;onErrorResumeNext&lt;/code&gt; comenzar&amp;aacute; a reflejar un segundo Observable de respaldo.</target>
        </trans-unit>
        <trans-unit id="c4940c7c617c2992ba7a9a3fde9d89a1bdc8cbef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onErrorReturn&lt;/code&gt; method returns an Observable that mirrors the behavior of the source Observable, unless that Observable invokes &lt;code&gt;onError&lt;/code&gt; in which case, rather than propagating that error to the observer, &lt;code&gt;onErrorReturn&lt;/code&gt; will instead emit a specified item and invoke the observer&amp;rsquo;s &lt;code&gt;onCompleted&lt;/code&gt; method, as shown in the following sample code:</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;onErrorReturn&lt;/code&gt; devuelve un Observable que refleja el comportamiento del Observable de origen, a menos que el Observable invoca a &lt;code&gt;onError&lt;/code&gt; , en cuyo caso, en lugar de propagar ese error al observador, &lt;code&gt;onErrorReturn&lt;/code&gt; emitir&amp;aacute; un elemento especificado e invocar&amp;aacute; el m&amp;eacute;todo &lt;code&gt;onCompleted&lt;/code&gt; del observador , como se muestra en el siguiente c&amp;oacute;digo de muestra:</target>
        </trans-unit>
        <trans-unit id="c06d877f3382ecaf88c2f18aa56d9eaa6fd9a9b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onErrorReturn&lt;/code&gt; method returns an Observable that mirrors the behavior of the source Observable, unless that Observable invokes &lt;code&gt;onError&lt;/code&gt; in which case, rather than propagating that error to the observer, &lt;code&gt;onErrorReturn&lt;/code&gt; will instead emit a specified item and invoke the observer&amp;rsquo;s &lt;code&gt;onCompleted&lt;/code&gt; method.</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;onErrorReturn&lt;/code&gt; devuelve un Observable que refleja el comportamiento del Observable de origen, a menos que el Observable invoca a &lt;code&gt;onError&lt;/code&gt; , en cuyo caso, en lugar de propagar ese error al observador, &lt;code&gt;onErrorReturn&lt;/code&gt; emitir&amp;aacute; un elemento espec&amp;iacute;fico e invocar&amp;aacute; el m&amp;eacute;todo &lt;code&gt;onCompleted&lt;/code&gt; del observador .</target>
        </trans-unit>
        <trans-unit id="2be807f21af7c141df25f9522d621998041537c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;publishLast&lt;/code&gt; operator is similar to &lt;code&gt;publish&lt;/code&gt;, and takes a similarly-behaving function as its parameter. It differs from &lt;code&gt;publish&lt;/code&gt; in that instead of applying that function to, and emitting an item for &lt;em&gt;every&lt;/em&gt; item emitted by the source Observable subsequent to the connection, it only applies that function to and emits an item for the &lt;em&gt;last&lt;/em&gt; item that was emitted by the source Observable, when that source Observable terminates normally.</source>
          <target state="translated">El operador &lt;code&gt;publishLast&lt;/code&gt; es similar a &lt;code&gt;publish&lt;/code&gt; y toma una funci&amp;oacute;n de comportamiento similar como par&amp;aacute;metro. Se diferencia de &lt;code&gt;publish&lt;/code&gt; en que, en lugar de aplicar esa funci&amp;oacute;n y emitir un elemento para &lt;em&gt;cada&lt;/em&gt; elemento emitido por la fuente Observable despu&amp;eacute;s de la conexi&amp;oacute;n, solo aplica esa funci&amp;oacute;n y emite un elemento para el &lt;em&gt;&amp;uacute;ltimo&lt;/em&gt; elemento que fue emitido por la fuente. Observable, cuando esa fuente Observable termina normalmente.</target>
        </trans-unit>
        <trans-unit id="0ad4a30567f8a80138c1fb085ce842dcf7162d10" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;publishValue&lt;/code&gt; operator takes, in addition to the function described above, an initial item to be emitted by the resulting &lt;code&gt;ConnectableObservable&lt;/code&gt; at connection time before emitting the items from the source Observable. It will not, however, emit this initial item to observers that subscribe after the time of connection.</source>
          <target state="translated">El operador &lt;code&gt;publishValue&lt;/code&gt; toma, adem&amp;aacute;s de la funci&amp;oacute;n descrita anteriormente, un elemento inicial que ser&amp;aacute; emitido por el &lt;code&gt;ConnectableObservable&lt;/code&gt; resultante en el momento de la conexi&amp;oacute;n antes de emitir los elementos de la fuente Observable. Sin embargo, no emitir&amp;aacute; este elemento inicial a los observadores que se suscriban despu&amp;eacute;s del tiempo de conexi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ef3ba3331ca4825acc2f08213d614824f15ad040" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reduce&lt;/code&gt; operator returns an Observable that applies a function of your choosing to the first item emitted by a source Observable, then feeds the result of that function along with the second item emitted by the source Observable into the same function, then feeds the result of that function along with the third item into the same function, and so on until all items have been emitted by the source Observable. Then it emits the final result from the final call to your function as the sole output from the returned Observable.</source>
          <target state="translated">El operador &lt;code&gt;reduce&lt;/code&gt; devuelve un Observable que aplica una funci&amp;oacute;n de su elecci&amp;oacute;n al primer elemento emitido por una fuente Observable, luego alimenta el resultado de esa funci&amp;oacute;n junto con el segundo elemento emitido por la fuente Observable en la misma funci&amp;oacute;n, luego alimenta el resultado de que funcionan junto con el tercer elemento en la misma funci&amp;oacute;n, y as&amp;iacute; sucesivamente hasta que todos los elementos hayan sido emitidos por la fuente Observable. Luego emite el resultado final de la llamada final a su funci&amp;oacute;n como la &amp;uacute;nica salida del Observable devuelto.</target>
        </trans-unit>
        <trans-unit id="c50635278b4d9cf4361974e6d4a3581ebf3b7068" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;retryWhen&lt;/code&gt; operator is similar to &lt;code&gt;retry&lt;/code&gt; but decides whether or not to resubscribe to and mirror the source Observable by passing the Throwable from the &lt;code&gt;onError&lt;/code&gt; notification to a function that generates a second Observable, and observes its result to determine what to do. If that result is an emitted item, &lt;code&gt;retryWhen&lt;/code&gt; resubscribes to and mirrors the source and the process repeats; if that result is an &lt;code&gt;onError&lt;/code&gt; notification, &lt;code&gt;retryWhen&lt;/code&gt; passes this notification on to its observers and terminates.</source>
          <target state="translated">El operador &lt;code&gt;retryWhen&lt;/code&gt; es similar a &lt;code&gt;retry&lt;/code&gt; pero decide si volver a suscribirse y reflejar el Observable de origen pasando el &lt;code&gt;onError&lt;/code&gt; notificaci&amp;oacute;n onError a una funci&amp;oacute;n que genera un segundo Observable y observa su resultado para determinar qu&amp;eacute; hacer. Si ese resultado es un elemento emitido, &lt;code&gt;retryWhen&lt;/code&gt; vuelva a suscribir y refleje la fuente y el proceso se repita; si ese resultado es una notificaci&amp;oacute;n de &lt;code&gt;onError&lt;/code&gt; , &lt;code&gt;retryWhen&lt;/code&gt; pasa esta notificaci&amp;oacute;n a sus observadores y finaliza.</target>
        </trans-unit>
        <trans-unit id="1e6bf6540cbdcb6dcb36a0ac93c13041a34e1638" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rxjava-async&lt;/code&gt; module also includes the &lt;code&gt;deferFuture&lt;/code&gt; operator. You pass it a function that returns a &lt;code&gt;Future&lt;/code&gt; that returns an Observable. &lt;code&gt;deferFuture&lt;/code&gt; returns an Observable, but does not call the function you provide until such time as an observer subscribes to the Observable it returns. When it does so, it immediately calls &lt;code&gt;get&lt;/code&gt; on the resulting &lt;code&gt;Future&lt;/code&gt;, and then mirrors the emissions from the Observable returned by the &lt;code&gt;Future&lt;/code&gt; as its own emissions.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;code&gt;rxjava-async&lt;/code&gt; tambi&amp;eacute;n incluye el operador &lt;code&gt;deferFuture&lt;/code&gt; . Le pasa una funci&amp;oacute;n que devuelve un &lt;code&gt;Future&lt;/code&gt; que devuelve un observable. &lt;code&gt;deferFuture&lt;/code&gt; devuelve un Observable, pero no llama a la funci&amp;oacute;n que proporcionas hasta que un observador se suscribe al Observable que devuelve. Cuando lo hace, inmediatamente llama a &lt;code&gt;get&lt;/code&gt; el &lt;code&gt;Future&lt;/code&gt; resultante y luego refleja las emisiones del Observable devueltas por el &lt;code&gt;Future&lt;/code&gt; como sus propias emisiones.</target>
        </trans-unit>
        <trans-unit id="b6770bc4bfc1cbd7c9c042c3a7028aadacca1d7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rxjava-async&lt;/code&gt; module also includes the &lt;code&gt;forEachFuture&lt;/code&gt; operator. It is not really a variant of the Start operator, but something all its own. You pass &lt;code&gt;forEachFuture&lt;/code&gt; some subset of the typical observer methods (&lt;code&gt;onNext&lt;/code&gt;, &lt;code&gt;onError&lt;/code&gt;, and &lt;code&gt;onCompleted&lt;/code&gt;) and the Observable will call these methods in the usual way. But &lt;code&gt;forEachFuture&lt;/code&gt; itself returns a &lt;code&gt;Future&lt;/code&gt; that blocks on &lt;code&gt;get&lt;/code&gt; until the source Observable completes, then returns either the completion or error, depending on how the Observable completed.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;code&gt;rxjava-async&lt;/code&gt; tambi&amp;eacute;n incluye el operador &lt;code&gt;forEachFuture&lt;/code&gt; . No es realmente una variante del operador de Inicio, sino algo en s&amp;iacute; mismo. &lt;code&gt;forEachFuture&lt;/code&gt; a forEachFuture alg&amp;uacute;n subconjunto de los m&amp;eacute;todos de observador t&amp;iacute;picos ( &lt;code&gt;onNext&lt;/code&gt; , &lt;code&gt;onError&lt;/code&gt; y &lt;code&gt;onCompleted&lt;/code&gt; ) y el Observable llamar&amp;aacute; a estos m&amp;eacute;todos de la forma habitual. Pero &lt;code&gt;forEachFuture&lt;/code&gt; en s&amp;iacute; mismo devuelve un &lt;code&gt;Future&lt;/code&gt; que se bloquea en &lt;code&gt;get&lt;/code&gt; hasta que el Observable de origen se completa, luego devuelve la finalizaci&amp;oacute;n o el error, dependiendo de c&amp;oacute;mo se complet&amp;oacute; el Observable.</target>
        </trans-unit>
        <trans-unit id="af59112ac4850a63fc254aa64a91b1cced9a1539" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rxjava-async&lt;/code&gt; module also includes the &lt;code&gt;fromAction&lt;/code&gt; operator. It accepts an &lt;code&gt;Action&lt;/code&gt; as its parameter, and returns an Observable that emits the item you pass to &lt;code&gt;fromAction&lt;/code&gt; upon termination of the &lt;code&gt;Action&lt;/code&gt;</source>
          <target state="translated">El m&amp;oacute;dulo &lt;code&gt;rxjava-async&lt;/code&gt; tambi&amp;eacute;n incluye el operador &lt;code&gt;fromAction&lt;/code&gt; . Acepta una &lt;code&gt;Action&lt;/code&gt; como par&amp;aacute;metro y devuelve un Observable que emite el elemento al que le &lt;code&gt;fromAction&lt;/code&gt; desde Acci&amp;oacute;n al finalizar la &lt;code&gt;Action&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eeead452a5c5a5cc79393668e2fbe3048778760f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rxjava-async&lt;/code&gt; module also includes the &lt;code&gt;fromCallable&lt;/code&gt; operator. It accepts a &lt;code&gt;Callable&lt;/code&gt; as its parameter, and returns an Observable that emits the result of this callable as its sole emission.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;code&gt;rxjava-async&lt;/code&gt; tambi&amp;eacute;n incluye el operador &lt;code&gt;fromCallable&lt;/code&gt; . Acepta un &lt;code&gt;Callable&lt;/code&gt; como par&amp;aacute;metro y devuelve un Observable que emite el resultado de este invocable como su &amp;uacute;nica emisi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="869f3624eb8dd7143ac5769078e3b3bf39bdeacb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rxjava-async&lt;/code&gt; module also includes the &lt;code&gt;fromRunnable&lt;/code&gt; operator. It accepts a &lt;code&gt;Runnable&lt;/code&gt; as its parameter, and returns an Observable that emits the item you pass to &lt;code&gt;fromRunnable&lt;/code&gt; upon termination of the &lt;code&gt;Runnable&lt;/code&gt;</source>
          <target state="translated">El m&amp;oacute;dulo &lt;code&gt;rxjava-async&lt;/code&gt; tambi&amp;eacute;n incluye el operador &lt;code&gt;fromRunnable&lt;/code&gt; . Acepta un &lt;code&gt;Runnable&lt;/code&gt; como par&amp;aacute;metro y devuelve un Observable que emite el elemento al que pasas de &lt;code&gt;fromRunnable&lt;/code&gt; al finalizar el &lt;code&gt;Runnable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="469f2cf19937130bc28a1acc9ff8718d9ef9be41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rxjava-async&lt;/code&gt; module also includes the &lt;code&gt;runAsync&lt;/code&gt; operator. It is peculiar in that it creates a specialization of an Observable called a &lt;code&gt;StoppableObservable&lt;/code&gt;.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;code&gt;rxjava-async&lt;/code&gt; tambi&amp;eacute;n incluye el operador &lt;code&gt;runAsync&lt;/code&gt; . Es peculiar porque crea una especializaci&amp;oacute;n de un Observable llamado &lt;code&gt;StoppableObservable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1442c42f4ea4865297a5c8db2d9c56e62b53341d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rxjava-async&lt;/code&gt; module also includes the &lt;code&gt;startFuture&lt;/code&gt; operator. You pass it a function that returns a &lt;code&gt;Future&lt;/code&gt;. &lt;code&gt;startFuture&lt;/code&gt; calls this function immediately to obtain the &lt;code&gt;Future&lt;/code&gt;, and calls the &lt;code&gt;Future&lt;/code&gt;&amp;rsquo;s &lt;code&gt;get&lt;/code&gt; method to try to obtain its value. It returns an Observable to which it will emit this value to any subsequent observers.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;code&gt;rxjava-async&lt;/code&gt; tambi&amp;eacute;n incluye el operador &lt;code&gt;startFuture&lt;/code&gt; . Le pasa una funci&amp;oacute;n que devuelve un &lt;code&gt;Future&lt;/code&gt; . &lt;code&gt;startFuture&lt;/code&gt; llama a esta funci&amp;oacute;n inmediatamente para obtener el &lt;code&gt;Future&lt;/code&gt; , y llama al &lt;code&gt;Future&lt;/code&gt; &amp;lsquo;s &lt;code&gt;get&lt;/code&gt; m&amp;eacute;todo para tratar de obtener su valor. Devuelve un Observable al que emitir&amp;aacute; este valor a cualquier observador posterior.</target>
        </trans-unit>
        <trans-unit id="0110d272415178479fa0159e8336538a9e94137d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rxjava-async&lt;/code&gt; module also includes the &lt;code&gt;toAsync&lt;/code&gt;, &lt;code&gt;asyncAction&lt;/code&gt;, and &lt;code&gt;asyncFunc&lt;/code&gt; operators. These accept a function or an Action as their parameter. In the case of a function, this variant of the operator calls that function to retrieve a value, and then returns an Observable that will emit that value to each subsequent observer (just as the &lt;code&gt;start&lt;/code&gt; operator does).</source>
          <target state="translated">El m&amp;oacute;dulo &lt;code&gt;rxjava-async&lt;/code&gt; tambi&amp;eacute;n incluye los &lt;code&gt;toAsync&lt;/code&gt; , &lt;code&gt;asyncAction&lt;/code&gt; y &lt;code&gt;asyncFunc&lt;/code&gt; . Aceptan una funci&amp;oacute;n o una acci&amp;oacute;n como par&amp;aacute;metro. En el caso de una funci&amp;oacute;n, esta variante del operador llama a esa funci&amp;oacute;n para recuperar un valor, y luego devuelve un Observable que emitir&amp;aacute; ese valor a cada observador posterior (tal como lo hace el operador de &lt;code&gt;start&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7be42e7b16a28f4014f78f36d0e314f07de76b6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rxjava-async&lt;/code&gt; module includes the &lt;code&gt;start&lt;/code&gt; operator, which accepts a function as its parameter, calls that function to retrieve a value, and then returns an Observable that will emit that value to each subsequent observer.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;code&gt;rxjava-async&lt;/code&gt; incluye el operador de &lt;code&gt;start&lt;/code&gt; , que acepta una funci&amp;oacute;n como par&amp;aacute;metro, llama a esa funci&amp;oacute;n para recuperar un valor y luego devuelve un Observable que emitir&amp;aacute; ese valor a cada observador posterior.</target>
        </trans-unit>
        <trans-unit id="4f8c7e051e0ffc1dd123fcc2382d4e1c11f27579" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;single&lt;/code&gt; operator is similar to &lt;code&gt;first&lt;/code&gt;, but throws a &lt;code&gt;NoSuchElementException&lt;/code&gt; if the source Observable does not emit exactly one item before successfully completing.</source>
          <target state="translated">El operador &lt;code&gt;single&lt;/code&gt; es similar al &lt;code&gt;first&lt;/code&gt; , pero arroja una &lt;code&gt;NoSuchElementException&lt;/code&gt; si la fuente Observable no emite exactamente un elemento antes de completar con &amp;eacute;xito.</target>
        </trans-unit>
        <trans-unit id="bb64af0ef2e08065bfe61294a45e041863a9ac27" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;single&lt;/code&gt; operator is similar, except that it only emits its item once the source Observable successfully completes after emitting one item (or one item that matches the predicate). If it emits either no such items or more than one such item, &lt;code&gt;single&lt;/code&gt; will terminate with an &lt;code&gt;onError&lt;/code&gt; notitifcation (&amp;ldquo;&lt;code&gt;Sequence contains no elements.&lt;/code&gt;&amp;rdquo;).</source>
          <target state="translated">El operador &lt;code&gt;single&lt;/code&gt; es similar, excepto que solo emite su elemento una vez que la fuente Observable se completa con &amp;eacute;xito despu&amp;eacute;s de emitir un elemento (o un elemento que coincide con el predicado). Si no emite ninguno de esos elementos o m&amp;aacute;s de uno, &lt;code&gt;single&lt;/code&gt; terminar&amp;aacute; con una &lt;code&gt;onError&lt;/code&gt; error (&amp;ldquo;La &lt;code&gt;Sequence contains no elements.&lt;/code&gt; &amp;rdquo;).</target>
        </trans-unit>
        <trans-unit id="975834fced6458372b9bc9efc7befcc06fefa34a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;skipLastWithTime&lt;/code&gt; operator takes a temporal duration rather than a quantity of items. It drops those items that are emitted during that final duration of the source Observable&amp;rsquo;s lifespan. You set this duration by passing in a number of milliseconds as a parameter to &lt;code&gt;skipLastWithTime&lt;/code&gt;.</source>
          <target state="translated">El operador &lt;code&gt;skipLastWithTime&lt;/code&gt; toma una duraci&amp;oacute;n temporal en lugar de una cantidad de elementos. Deja caer los elementos que se emiten durante la duraci&amp;oacute;n final de la vida &amp;uacute;til de la fuente Observable. Establece esta duraci&amp;oacute;n pasando una cantidad de milisegundos como par&amp;aacute;metro para &lt;code&gt;skipLastWithTime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="42674eed65675fac56a7f9c41a8d7093c454e05d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;skipWhile&lt;/code&gt; operator returns an Observable that discards items emitted by the source Observable until such time as a function, applied to an item emitted by that Observable, returns &lt;code&gt;false&lt;/code&gt;, whereupon the new Observable emits that item and the remainder of the items emitted by the source Observable.</source>
          <target state="translated">El operador &lt;code&gt;skipWhile&lt;/code&gt; devuelve un Observable que descarta elementos emitidos por la fuente Observable hasta que una funci&amp;oacute;n, aplicada a un elemento emitido por ese Observable, devuelve &lt;code&gt;false&lt;/code&gt; , con lo cual el nuevo Observable emite ese elemento y el resto de los elementos emitidos por la fuente Observable.</target>
        </trans-unit>
        <trans-unit id="61e37780715c55b30e2b068ed45a07ffc42fa7ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;takeFirst&lt;/code&gt; operator behaves similarly to &lt;code&gt;first&lt;/code&gt;, with the exception of how these operators behave wihen the source Observable emits no items that satisfy the predicate. In such a case, &lt;code&gt;first&lt;/code&gt; will throw a &lt;code&gt;NoSuchElementException&lt;/code&gt; while &lt;code&gt;takeFirst&lt;/code&gt; will return an empty Observable (one that calls &lt;code&gt;onCompleted&lt;/code&gt; but never calls &lt;code&gt;onNext&lt;/code&gt;).</source>
          <target state="translated">El operador &lt;code&gt;takeFirst&lt;/code&gt; se comporta de manera similar a &lt;code&gt;first&lt;/code&gt; , con la excepci&amp;oacute;n de c&amp;oacute;mo se comportan estos operadores cuando el Observable de origen no emite elementos que satisfagan el predicado. En tal caso, &lt;code&gt;first&lt;/code&gt; lanzar&amp;aacute; una &lt;code&gt;NoSuchElementException&lt;/code&gt; mientras que &lt;code&gt;takeFirst&lt;/code&gt; devolver&amp;aacute; un Observable vac&amp;iacute;o (uno que llama a &lt;code&gt;onCompleted&lt;/code&gt; pero nunca llama a &lt;code&gt;onNext&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f059b182f05a90e4230cc52c9c5f554288c6cca6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;takeLastWithTime&lt;/code&gt; operator takes a temporal duration rather than a quantity of items. It emits only those items that are emitted during that final duration of the source Observable&amp;rsquo;s lifespan. You set this duration by passing in a number of milliseconds as a parameter to &lt;code&gt;takeLastWithTime&lt;/code&gt;.</source>
          <target state="translated">El operador &lt;code&gt;takeLastWithTime&lt;/code&gt; toma una duraci&amp;oacute;n temporal en lugar de una cantidad de elementos. Emite solo aquellos elementos que se emiten durante la duraci&amp;oacute;n final de la vida &amp;uacute;til de la fuente Observable. Establece esta duraci&amp;oacute;n pasando una cantidad de milisegundos como par&amp;aacute;metro para &lt;code&gt;takeLastWithTime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d94b28280db1122b56b19ce27ccbcf5cc220169d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;takeWhile&lt;/code&gt; operator returns an Observable that mirrors the behavior of the source Observable until such time as a function, applied to an item emitted by that Observable, returns &lt;code&gt;false&lt;/code&gt;, whereupon the new Observable terminates with an &lt;code&gt;onCompleted&lt;/code&gt; notification.</source>
          <target state="translated">El operador &lt;code&gt;takeWhile&lt;/code&gt; devuelve un Observable que refleja el comportamiento de la fuente Observable hasta que una funci&amp;oacute;n, aplicada a un elemento emitido por ese Observable, devuelve &lt;code&gt;false&lt;/code&gt; , con lo cual el nuevo Observable termina con una notificaci&amp;oacute;n &lt;code&gt;onCompleted&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae782d3a96f85e5b21ff4352810ad74a7d494b59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeInterval&lt;/code&gt; operator converts a source Observable into an Observable that emits indications of the amount of time lapsed between consecutive emissions of the source Observable. The first emission from this new Observable indicates the amount of time lapsed between the time when the observer subscribed to the Observable and the time when the source Observable emitted its first item. There is no corresponding emission marking the amount of time lapsed between the last emission of the source Observable and the subsequent call to &lt;code&gt;onCompleted&lt;/code&gt;.</source>
          <target state="translated">El operador &lt;code&gt;timeInterval&lt;/code&gt; convierte una fuente Observable en Observable que emite indicaciones de la cantidad de tiempo transcurrido entre las emisiones consecutivas de la fuente Observable. La primera emisi&amp;oacute;n de este nuevo Observable indica la cantidad de tiempo transcurrido entre el momento en que el observador se suscribi&amp;oacute; al Observable y el momento en que la fuente Observable emiti&amp;oacute; su primer elemento. No hay una emisi&amp;oacute;n correspondiente que marque la cantidad de tiempo transcurrido entre la &amp;uacute;ltima emisi&amp;oacute;n de la fuente Observable y la siguiente llamada a &lt;code&gt;onCompleted&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfd66b7722a88e540f0f6db427e117d46daa8c75" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timestamp&lt;/code&gt; method attaches a timestamp to each item emitted by the source Observable before emitting that item as part of its own sequence. The timestamp indicates when the item was emitted by the source Observable.</source>
          <target state="translated">El m&amp;eacute;todo de &lt;code&gt;timestamp&lt;/code&gt; adjunta una marca de tiempo a cada elemento emitido por la fuente Observable antes de emitir ese elemento como parte de su propia secuencia. La marca de tiempo indica cu&amp;aacute;ndo el elemento fue emitido por la fuente Observable.</target>
        </trans-unit>
        <trans-unit id="d062c9b41bc51b27701d92c9cfc8c88e8ea2c104" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timestamp&lt;/code&gt; method converts an Observable that emits items of type</source>
          <target state="translated">El m&amp;eacute;todo de &lt;code&gt;timestamp&lt;/code&gt; convierte un Observable que emite elementos de tipo</target>
        </trans-unit>
        <trans-unit id="4e038e086711c592371f2bd9b8f09e9f604e3815" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;toFuture&lt;/code&gt; operator applies to the &lt;code&gt;BlockingObservable&lt;/code&gt; subclass, so in order to use it, you must first convert your source Observable into a &lt;code&gt;BlockingObservable&lt;/code&gt; by means of either the &lt;code&gt;BlockingObservable.from&lt;/code&gt; method or the &lt;code&gt;Observable.toBlocking&lt;/code&gt; operator.</source>
          <target state="translated">El operador &lt;code&gt;toFuture&lt;/code&gt; se aplica a la subclase &lt;code&gt;BlockingObservable&lt;/code&gt; , por lo que para poder usarlo, primero debe convertir su fuente Observable en un &lt;code&gt;BlockingObservable&lt;/code&gt; mediante el m&amp;eacute;todo &lt;code&gt;BlockingObservable.from&lt;/code&gt; o el operador &lt;code&gt;Observable.toBlocking&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73cc88f0171268077175c8d986e14f4bd5fa9b9e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;toIterable&lt;/code&gt; operator applies to the &lt;code&gt;BlockingObservable&lt;/code&gt; subclass, so in order to use it, you must first convert your source Observable into a &lt;code&gt;BlockingObservable&lt;/code&gt; by means of either the &lt;code&gt;BlockingObservable.from&lt;/code&gt; method or the &lt;code&gt;Observable.toBlocking&lt;/code&gt; operator.</source>
          <target state="translated">El operador &lt;code&gt;toIterable&lt;/code&gt; se aplica a la subclase &lt;code&gt;BlockingObservable&lt;/code&gt; , por lo que para usarlo, primero debe convertir su fuente Observable en un &lt;code&gt;BlockingObservable&lt;/code&gt; mediante el m&amp;eacute;todo &lt;code&gt;BlockingObservable.from&lt;/code&gt; o el operador &lt;code&gt;Observable.toBlocking&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10c97d4a81b3f34d3ab42da8c6e198078743bb1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;toMap&lt;/code&gt; operator collects the items emitted by the source Observable into a &lt;code&gt;Map&lt;/code&gt; and then emits that map. You supply a function that generates the key for each emitted item. You may also optionally supply a function that converts an emitted item into the value to be stored in the map (by default, the item itself is this value).</source>
          <target state="translated">El operador &lt;code&gt;toMap&lt;/code&gt; recopila los elementos emitidos por la fuente Observable en un &lt;code&gt;Map&lt;/code&gt; y luego emite ese mapa. Proporciona una funci&amp;oacute;n que genera la clave para cada elemento emitido. Tambi&amp;eacute;n puede proporcionar opcionalmente una funci&amp;oacute;n que convierta un elemento emitido en el valor que se almacenar&amp;aacute; en el mapa (de forma predeterminada, el elemento en s&amp;iacute; es este valor).</target>
        </trans-unit>
        <trans-unit id="bd3162034b145b60b1dabc6e226bf4a2715689b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;toMap&lt;/code&gt; operator collects the items emitted by the source Observable into a map (by default, a &lt;code&gt;HashMap&lt;/code&gt;, but you can optionally supply a factory function that generates another &lt;code&gt;Map&lt;/code&gt; variety) and then emits that map. You supply a function that generates the key for each emitted item. You may also optionally supply a function that converts an emitted item into the value to be stored in the map (by default, the item itself is this value).</source>
          <target state="translated">El operador &lt;code&gt;toMap&lt;/code&gt; recopila los elementos emitidos por la fuente Observable en un mapa (de forma predeterminada, un &lt;code&gt;HashMap&lt;/code&gt; , pero opcionalmente puede proporcionar una funci&amp;oacute;n de f&amp;aacute;brica que genere otra variedad de &lt;code&gt;Map&lt;/code&gt; a ) y luego emite ese mapa. Proporciona una funci&amp;oacute;n que genera la clave para cada elemento emitido. Tambi&amp;eacute;n puede proporcionar opcionalmente una funci&amp;oacute;n que convierta un elemento emitido en el valor que se almacenar&amp;aacute; en el mapa (de forma predeterminada, el elemento en s&amp;iacute; es este valor).</target>
        </trans-unit>
        <trans-unit id="8c85856ebe3a9af3c38faf028b0cefff356663db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;toMultiMap&lt;/code&gt; operator is similar to &lt;code&gt;toMap&lt;/code&gt; except that the map it generates is also an &lt;code&gt;ArrayList&lt;/code&gt; (by default; or you can pass an optional factory method as a fourth parameter by which you generate the variety of collection you prefer).</source>
          <target state="translated">El operador &lt;code&gt;toMultiMap&lt;/code&gt; es similar a &lt;code&gt;toMap&lt;/code&gt; excepto que el mapa que genera tambi&amp;eacute;n es un &lt;code&gt;ArrayList&lt;/code&gt; (por defecto; o puede pasar un m&amp;eacute;todo de f&amp;aacute;brica opcional como un cuarto par&amp;aacute;metro mediante el cual genera la variedad de colecci&amp;oacute;n que prefiera).</target>
        </trans-unit>
        <trans-unit id="b17e7ff34781fb007d4e482cc00354dcd6940aeb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;toSortedList&lt;/code&gt; operator behaves much like &lt;code&gt;toList&lt;/code&gt; except that it sorts the resulting list. By default it sorts the list naturally in ascending order by means of the &lt;code&gt;Comparable&lt;/code&gt; interface. If any of the items emitted by the Observable does not support &lt;code&gt;Comparable&lt;/code&gt; with respect to the type of every other item emitted by the Observable, &lt;code&gt;toSortedList&lt;/code&gt; will throw an exception. However, you can change this default behavior by also passing in to &lt;code&gt;toSortedList&lt;/code&gt; a function that takes as its parameters two items and returns a number; &lt;code&gt;toSortedList&lt;/code&gt; will then use that function instead of &lt;code&gt;Comparable&lt;/code&gt; to sort the items.</source>
          <target state="translated">El operador &lt;code&gt;toSortedList&lt;/code&gt; se comporta de manera muy similar a &lt;code&gt;toList&lt;/code&gt; , excepto que ordena la lista resultante. Por defecto, ordena la lista de forma natural en orden ascendente mediante la interfaz &lt;code&gt;Comparable&lt;/code&gt; . Si alguno de los elementos emitidos por Observable no es compatible con &lt;code&gt;Comparable&lt;/code&gt; con respecto al tipo de cualquier otro elemento emitido por Observable, &lt;code&gt;toSortedList&lt;/code&gt; lanzar&amp;aacute; una excepci&amp;oacute;n. Sin embargo, puede cambiar este comportamiento predeterminado pasando tambi&amp;eacute;n a &lt;code&gt;toSortedList&lt;/code&gt; una funci&amp;oacute;n que toma como par&amp;aacute;metros dos elementos y devuelve un n&amp;uacute;mero; &lt;code&gt;toSortedList&lt;/code&gt; usar&amp;aacute; esa funci&amp;oacute;n en lugar de &lt;code&gt;Comparable&lt;/code&gt; para ordenar los elementos.</target>
        </trans-unit>
        <trans-unit id="3179857647a979a434a7b8365890ceca652b913a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;zipWith&lt;/code&gt; instance version of this operator always takes two parameters. The first parameter may be either a simple Observable, or an iterable (as in the illustration above).</source>
          <target state="translated">La versi&amp;oacute;n de la instancia &lt;code&gt;zipWith&lt;/code&gt; de este operador siempre toma dos par&amp;aacute;metros. El primer par&amp;aacute;metro puede ser simple Observable o iterable (como en la ilustraci&amp;oacute;n anterior).</target>
        </trans-unit>
        <trans-unit id="0c52166841e40a260b713af70e53c187dda20628" translate="yes" xml:space="preserve">
          <source>The Average operator operates on an Observable that emits numbers (or items that can be evaluated as numbers), and emits a single value: the average of all of the numbers emitted by the source Observable.</source>
          <target state="translated">El operador Promedio opera en un Observable que emite números (o elementos que pueden ser evaluados como números),y emite un único valor:el promedio de todos los números emitidos por la fuente Observable.</target>
        </trans-unit>
        <trans-unit id="fc6a2968bca993acc6e3b8fced16ce05fe639169" translate="yes" xml:space="preserve">
          <source>The Buffer operator transforms an Observable that emits items into an Observable that emits buffered collections of those items. There are a number of variants in the various language-specific implementations of Buffer that differ in how they choose which items go in which buffers.</source>
          <target state="translated">El operador de la memoria intermedia transforma un observable que emite artículos en un observable que emite colecciones de esos artículos con memoria intermedia.Hay un número de variantes en las diversas implementaciones de Buffer específicas del lenguaje que difieren en la forma de elegir qué artículos van en cada buffer.</target>
        </trans-unit>
        <trans-unit id="b37590bfa8c82144f5bf2ba003877989832559fd" translate="yes" xml:space="preserve">
          <source>The Catch operator intercepts an &lt;code&gt;onError&lt;/code&gt; notification from the source Observable and, instead of passing it through to any observers, replaces it with some other item or sequence of items, potentially allowing the resulting Observable to terminate normally or not to terminate at all.</source>
          <target state="translated">El operador Catch intercepta una notificaci&amp;oacute;n de &lt;code&gt;onError&lt;/code&gt; de la fuente Observable y, en lugar de pasarla a cualquier observador, la reemplaza con alg&amp;uacute;n otro elemento o secuencia de elementos, permitiendo potencialmente que el Observable resultante termine normalmente o no termine en absoluto.</target>
        </trans-unit>
        <trans-unit id="cfe27529276a28575971e7809bb99f71747e9097" translate="yes" xml:space="preserve">
          <source>The CombineLatest operator behaves in a similar way to Zip, but while Zip emits items only when &lt;em&gt;each&lt;/em&gt; of the zipped source Observables have emitted a previously unzipped item, CombineLatest emits an item whenever &lt;em&gt;any&lt;/em&gt; of the source Observables emits an item (so long as each of the source Observables has emitted at least one item). When any of the source Observables emits an item, CombineLatest combines the most recently emitted items from each of the other source Observables, using a function you provide, and emits the return value from that function.</source>
          <target state="translated">El operador CombineLatest se comporta de manera similar a Zip, pero mientras que Zip emite elementos solo cuando &lt;em&gt;cada uno&lt;/em&gt; de los Observables de origen comprimido ha emitido un elemento previamente descomprimido, CombineLatest emite un elemento cada vez que &lt;em&gt;cualquiera&lt;/em&gt; de los Observables de origen emite un elemento (siempre que cada uno de los la fuente Observables ha emitido al menos un elemento). Cuando cualquiera de los Observables de origen emite un elemento, CombineLatest combina los elementos emitidos m&amp;aacute;s recientemente de cada uno de los otros Observables de origen, utilizando una funci&amp;oacute;n que usted proporcione, y emite el valor de retorno de esa funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="4854908f534b02106795e7f1522975b573795081" translate="yes" xml:space="preserve">
          <source>The Concat operator concatenates the output of multiple Observables so that they act like a single Observable, with all of the items emitted by the first Observable being emitted before any of the items emitted by the second Observable (and so forth, if there are more than two).</source>
          <target state="translated">El operador del Concat concatena la salida de múltiples Observables de manera que actúen como un solo Observable,emitiendo todos los elementos emitidos por el primer Observable antes que los emitidos por el segundo (y así sucesivamente,si hay más de dos).</target>
        </trans-unit>
        <trans-unit id="90fa54f98f8f36aa66596ae7ba4f7c4c568cf2d8" translate="yes" xml:space="preserve">
          <source>The Contract Governing Notifications</source>
          <target state="translated">El contrato que rige las notificaciones</target>
        </trans-unit>
        <trans-unit id="716ae1fda32d1fa3b632bdf5455ead7fa3ced17a" translate="yes" xml:space="preserve">
          <source>The Count operator transforms an Observable that emits items into an Observable that emits a single value that represents the number of items emitted by the source Observable.</source>
          <target state="translated">El operador de conteo transforma un observable que emite artículos en un observable que emite un único valor que representa el número de artículos emitidos por el observable de la fuente.</target>
        </trans-unit>
        <trans-unit id="eefbe49fbb86c9fbec17d91d5ce7f466a4fe2e49" translate="yes" xml:space="preserve">
          <source>The Debounce operator filters out items emitted by the source Observable that are rapidly followed by another emitted item.</source>
          <target state="translated">El operador de Debounce filtra los artículos emitidos por la fuente Observable que son rápidamente seguidos por otro artículo emitido.</target>
        </trans-unit>
        <trans-unit id="36b504754ec03844f1798737da9f41be4f33e797" translate="yes" xml:space="preserve">
          <source>The DefaultIfEmpty operator simply mirrors the source Observable exactly if the source Observable emits any items. If the source Observable terminates normally (with an &lt;code&gt;onComplete&lt;/code&gt;) without emitting any items, the Observable returned from DefaultIfEmpty will instead emit a default item of your choosing before it too completes.</source>
          <target state="translated">El operador DefaultIfEmpty simplemente refleja la fuente Observable exactamente si la fuente Observable emite alg&amp;uacute;n elemento. Si el Observable de origen termina normalmente (con un &lt;code&gt;onComplete&lt;/code&gt; ) sin emitir ning&amp;uacute;n elemento, el Observable devuelto de DefaultIfEmpty emitir&amp;aacute; un elemento predeterminado de su elecci&amp;oacute;n antes de que tambi&amp;eacute;n se complete.</target>
        </trans-unit>
        <trans-unit id="8094e68c11bae1e54b9179fa5c2f24a885dbe086" translate="yes" xml:space="preserve">
          <source>The Defer operator waits until an observer subscribes to it, and then it generates an Observable, typically with an Observable factory function. It does this afresh for each subscriber, so although each subscriber may think it is subscribing to the same Observable, in fact each subscriber gets its own individual sequence.</source>
          <target state="translated">El operador del Defer espera hasta que un observador se suscribe a él,y entonces genera un Observable,típicamente con una función de fábrica de Observable.Lo hace de nuevo para cada abonado,de modo que aunque cada abonado pueda pensar que está suscrito al mismo Observable,de hecho cada abonado obtiene su propia secuencia individual.</target>
        </trans-unit>
        <trans-unit id="4453fd69500a642f20d1c4768d4bf67d31976c31" translate="yes" xml:space="preserve">
          <source>The Delay operator modifies its source Observable by pausing for a particular increment of time (that you specify) before emitting each of the source Observable&amp;rsquo;s items. This has the effect of shifting the entire sequence of items emitted by the Observable forward in time by that specified increment.</source>
          <target state="translated">El operador Delay modifica su Observable de origen haciendo una pausa durante un incremento de tiempo particular (que usted especifique) antes de emitir cada uno de los elementos del Observable de origen. Esto tiene el efecto de desplazar la secuencia completa de elementos emitidos por el Observable hacia adelante en el tiempo por ese incremento especificado.</target>
        </trans-unit>
        <trans-unit id="43e2b2596602d7cec271e9c62cbe5303137d7dc9" translate="yes" xml:space="preserve">
          <source>The Dematerialize operator reverses this process. It operates on an Observable that has previously been transformed by Materialize and returns it to its original form.</source>
          <target state="translated">El operador de Desmaterializar invierte este proceso.Opera sobre un Observable que ha sido previamente transformado por Materializar y lo devuelve a su forma original.</target>
        </trans-unit>
        <trans-unit id="b62495a350947c5ebd5c22f8327b5c1e7b3d4cd9" translate="yes" xml:space="preserve">
          <source>The Distinct operator filters an Observable by only allowing items through that have not already been emitted.</source>
          <target state="translated">El operador Distinto filtra un Observable permitiendo el paso sólo de artículos que no han sido ya emitidos.</target>
        </trans-unit>
        <trans-unit id="02a861b98764748360b643c6b91378962eece519" translate="yes" xml:space="preserve">
          <source>The Empty, Never, and Throw operators generate Observables with very specific and limited behavior. These are useful for testing purposes, and sometimes also for combining with other Observables or as parameters to operators that expect other Observables as parameters.</source>
          <target state="translated">Los operadores de Vaciar,Nunca y Lanzar generan Observables con un comportamiento muy específico y limitado.Son útiles para fines de prueba,y a veces también para combinarlos con otros Observables o como parámetros para los operadores que esperan otros Observables como parámetros.</target>
        </trans-unit>
        <trans-unit id="b833020b17b2958e2855725d6a76e2d9fa4b4dca" translate="yes" xml:space="preserve">
          <source>The Filter operator filters an Observable by only allowing items through that pass a test that you specify in the form of a predicate function.</source>
          <target state="translated">El operador del filtro filtra un observable permitiendo solamente que los artículos que pasan una prueba que usted especifica en la forma de una función predicada.</target>
        </trans-unit>
        <trans-unit id="69c03b864d44f0df8a889b8aea1579db6062a264" translate="yes" xml:space="preserve">
          <source>The Filtering Operators</source>
          <target state="translated">Los operadores de filtrado</target>
        </trans-unit>
        <trans-unit id="35e86997505ba385effc0556a5f7cfa65bd4638e" translate="yes" xml:space="preserve">
          <source>The FlatMap operator transforms an Observable by applying a function that you specify to each item emitted by the source Observable, where that function returns an Observable that itself emits items. FlatMap then merges the emissions of these resulting Observables, emitting these merged results as its own sequence.</source>
          <target state="translated">El operador FlatMap transforma un Observable aplicando una función que se especifica a cada elemento emitido por el Observable de la fuente,donde esa función devuelve un Observable que a su vez emite elementos.FlatMap entonces fusiona las emisiones de estos Observables resultantes,emitiendo estos resultados fusionados como su propia secuencia.</target>
        </trans-unit>
        <trans-unit id="fd1bbbdbc4127c19ee97953d85194e7977a5f6a3" translate="yes" xml:space="preserve">
          <source>The GroupBy operator divides an Observable that emits items into an Observable that emits Observables, each one of which emits some subset of the items from the original source Observable. Which items end up on which Observable is typically decided by a discriminating function that evaluates each item and assigns it a key. All items with the same key are emitted by the same Observable.</source>
          <target state="translated">El operador GroupBy divide un Observable que emite artículos en un Observable que emite Observables,cada uno de los cuales emite algún subconjunto de los artículos del Observable de la fuente original.Los elementos que terminan en un Observable se deciden típicamente por una función discriminatoria que evalúa cada elemento y le asigna una clave.Todos los elementos con la misma clave son emitidos por el mismo Observable.</target>
        </trans-unit>
        <trans-unit id="4906ba388d3e33ac64376a578c10705e279fef4b" translate="yes" xml:space="preserve">
          <source>The IgnoreElements operator suppresses all of the items emitted by the source Observable, but allows its termination notification (either &lt;code&gt;onError&lt;/code&gt; or &lt;code&gt;onCompleted&lt;/code&gt;) to pass through unchanged.</source>
          <target state="translated">El operador IgnoreElements suprime todos los elementos emitidos por el Observable de origen, pero permite que su notificaci&amp;oacute;n de terminaci&amp;oacute;n (ya sea &lt;code&gt;onError&lt;/code&gt; o &lt;code&gt;onCompleted&lt;/code&gt; ) pase sin cambios.</target>
        </trans-unit>
        <trans-unit id="244dd77637d5c3358021f0f2debf08aa419dec57" translate="yes" xml:space="preserve">
          <source>The Interval operator returns an Observable that emits an infinite sequence of ascending integers, with a constant interval of time of your choosing between emissions.</source>
          <target state="translated">El operador de Intervalo devuelve un Observable que emite una secuencia infinita de números enteros ascendentes,con un intervalo de tiempo constante de su elección entre las emisiones.</target>
        </trans-unit>
        <trans-unit id="83607c5f15eb7b829a081b94cbd6b0b250bb3353" translate="yes" xml:space="preserve">
          <source>The Just operator converts an item into an Observable that emits that item.</source>
          <target state="translated">El operador Just convierte un elemento en un Observable que emite ese elemento.</target>
        </trans-unit>
        <trans-unit id="5bd2b8fa13d538c5571233b8167d384ea2844854" translate="yes" xml:space="preserve">
          <source>The Map operator applies a function of your choosing to each item emitted by the source Observable, and returns an Observable that emits the results of these function applications.</source>
          <target state="translated">El operador del Mapa aplica una función de su elección a cada elemento emitido por el Observable de la fuente,y devuelve un Observable que emite los resultados de estas aplicaciones de la función.</target>
        </trans-unit>
        <trans-unit id="2e2bf97ad1f3f2ffc00e16ec5b3d4fbcf84a3701" translate="yes" xml:space="preserve">
          <source>The Max operator operates on an Observable that emits numbers (or items that can be evaluated as numbers), and emits a single item: the item with the largest number.</source>
          <target state="translated">El operador del Max opera en un Observable que emite números (o elementos que pueden ser evaluados como números),y emite un solo elemento:el elemento con el mayor número.</target>
        </trans-unit>
        <trans-unit id="09deece6c140d29e662b3b8432858ad0d37f4465" translate="yes" xml:space="preserve">
          <source>The Min operator operates on an Observable that emits numbers (or items that can be evaluated as numbers), and emits a single item: the item with the smallest number.</source>
          <target state="translated">El operador del Min opera en un observatorio que emite números (o elementos que pueden ser evaluados como números),y emite un solo elemento:el elemento con el número más pequeño.</target>
        </trans-unit>
        <trans-unit id="247ee8fc9c213eb2ead2d9c86fe90bf5295d1c49" translate="yes" xml:space="preserve">
          <source>The Observable Contract</source>
          <target state="translated">El contrato observable</target>
        </trans-unit>
        <trans-unit id="afbdd322f220a1cf0b12ad4fca765fe243613c51" translate="yes" xml:space="preserve">
          <source>The Observable type adds two missing semantics to &lt;a href=&quot;http://en.wikipedia.org/wiki/Observer_pattern&quot;&gt;the Gang of Four&amp;rsquo;s Observer pattern&lt;/a&gt;, to match those that are available in the Iterable type:</source>
          <target state="translated">El tipo Observable agrega dos sem&amp;aacute;nticas faltantes al &lt;a href=&quot;http://en.wikipedia.org/wiki/Observer_pattern&quot;&gt;patr&amp;oacute;n Observador de Gang of Four&lt;/a&gt; , para que coincida con las que est&amp;aacute;n disponibles en el tipo Iterable:</target>
        </trans-unit>
        <trans-unit id="f03703c1687e9f63689cb91bc87825dd48181098" translate="yes" xml:space="preserve">
          <source>The Operators of ReactiveX</source>
          <target state="translated">Los operadores de ReactiveX</target>
        </trans-unit>
        <trans-unit id="bcdd731b4af0f836d80c51d8a9da6714524f68a6" translate="yes" xml:space="preserve">
          <source>The Range operator emits a range of sequential integers, in order, where you select the start of the range and its length.</source>
          <target state="translated">El operador del rango emite un rango de números enteros secuenciales,por orden,donde se selecciona el inicio del rango y su longitud.</target>
        </trans-unit>
        <trans-unit id="1292751da07b37b3a1750a8a6de0cbc7053adb8e" translate="yes" xml:space="preserve">
          <source>The ReactiveX Observable model allows you to treat streams of asynchronous events with the same sort of simple, composable operations that you use for collections of data items like arrays. It frees you from tangled webs of callbacks, and thereby makes your code more readable and less prone to bugs.</source>
          <target state="translated">El modelo Observable ReactiveX permite tratar flujos de eventos asíncronos con el mismo tipo de operaciones simples y componibles que se utilizan para las colecciones de elementos de datos como las matrices.Te libera de las enredadas redes de llamadas,y por lo tanto hace que tu código sea más legible y menos propenso a los errores.</target>
        </trans-unit>
        <trans-unit id="cc1f638a75607049534396bafa35741b496cbeea" translate="yes" xml:space="preserve">
          <source>The Reduce operator applies a function to the first item emitted by the source Observable and then feeds the result of the function back into the function along with the second item emitted by the source Observable, continuing this process until the source Observable emits its final item and completes, whereupon the Observable returned from Reduce emits the final value returned from the function.</source>
          <target state="translated">El operador del Reductor aplica una función al primer elemento emitido por el Observable de la fuente y luego devuelve el resultado de la función a la función junto con el segundo elemento emitido por el Observable de la fuente,continuando este proceso hasta que el Observable de la fuente emita su último elemento y lo complete,con lo cual el Observable devuelto del Reductor emite el valor final devuelto de la función.</target>
        </trans-unit>
        <trans-unit id="7f8c08d1ff0948c74616bcf19db4f6f8a4e9fe87" translate="yes" xml:space="preserve">
          <source>The RefCount operator automates the process of connecting to and disconnecting from a connectable Observable. It operates on a connectable Observable and returns an ordinary Observable. When the first observer subscribes to this Observable, RefCount connects to the underlying connectable Observable. RefCount then keeps track of how many other observers subscribe to it and does not disconnect from the underlying connectable Observable until the last observer has done so.</source>
          <target state="translated">El operador RefCount automatiza el proceso de conexión y desconexión de un Observable conectable.Opera en un Observable conectable y devuelve un Observable ordinario.Cuando el primer observador se suscribe a este Observable,RefCount se conecta al Observable conectable subyacente.RefCount lleva entonces un registro de cuántos otros observadores se suscriben a él y no se desconecta del observable conectable subyacente hasta que lo hace el último observador.</target>
        </trans-unit>
        <trans-unit id="1cea294e1ffba2cbf07229f7aff488094f37bf6f" translate="yes" xml:space="preserve">
          <source>The Repeat operator emits an item repeatedly. Some implementations of this operator allow you to repeat a &lt;em&gt;sequence&lt;/em&gt; of items, and some permit you to limit the number of repetitions.</source>
          <target state="translated">El operador de repetici&amp;oacute;n emite un elemento repetidamente. Algunas implementaciones de este operador le permiten repetir una &lt;em&gt;secuencia&lt;/em&gt; de elementos y algunas le permiten limitar el n&amp;uacute;mero de repeticiones.</target>
        </trans-unit>
        <trans-unit id="badd34737b53e718812dd79b36e046f4b576f530" translate="yes" xml:space="preserve">
          <source>The Retry operator responds to an &lt;code&gt;onError&lt;/code&gt; notification from the source Observable by not passing that call through to its observers, but instead by resubscribing to the source Observable and giving it another opportunity to complete its sequence without error. Retry always passes &lt;code&gt;onNext&lt;/code&gt; notifications through to its observers, even from sequences that terminate with an error, so this can cause duplicate emissions (as shown in the diagram above).</source>
          <target state="translated">El operador Retry responde a una notificaci&amp;oacute;n de &lt;code&gt;onError&lt;/code&gt; de la fuente Observable no pasando esa llamada a sus observadores, sino volviendo a suscribirse a la fuente Observable y d&amp;aacute;ndole otra oportunidad para completar su secuencia sin errores. Retry siempre pasa &lt;code&gt;onNext&lt;/code&gt; notificaciones onNext a sus observadores, incluso de secuencias que terminan con un error, por lo que esto puede causar emisiones duplicadas (como se muestra en el diagrama anterior).</target>
        </trans-unit>
        <trans-unit id="f9e7265419f42c07e2f8a5a6eb856db0dde19aff" translate="yes" xml:space="preserve">
          <source>The Sample operator periodically looks at an Observable and emits whichever item it has most recently emitted since the previous sampling.</source>
          <target state="translated">El operador de la muestra examina periódicamente un observable y emite el elemento que haya emitido más recientemente desde el muestreo anterior.</target>
        </trans-unit>
        <trans-unit id="399e6bf961037a1119d6673c281659e506bab0ce" translate="yes" xml:space="preserve">
          <source>The Scan operator applies a function to the first item emitted by the source Observable and then emits the result of that function as its own first emission. It also feeds the result of the function back into the function along with the second item emitted by the source Observable in order to generate its second emission. It continues to feed back its own subsequent emissions along with the subsequent emissions from the source Observable in order to create the rest of its sequence.</source>
          <target state="translated">El operador del escáner aplica una función al primer elemento emitido por la fuente observable y luego emite el resultado de esa función como su propia primera emisión.También devuelve el resultado de la función a la función junto con el segundo elemento emitido por la fuente observable para generar su segunda emisión.Continúa retroalimentando sus propias emisiones subsiguientes junto con las emisiones subsiguientes de la fuente Observable para crear el resto de su secuencia.</target>
        </trans-unit>
        <trans-unit id="8619aba5918a01d54d25dd0af57ab74dbd5313ec" translate="yes" xml:space="preserve">
          <source>The SkipUntil subscribes to the source Observable, but ignores its emissions until such time as a second Observable emits an item, at which point SkipUntil begins to mirror the source Observable.</source>
          <target state="translated">El SkipUntil se suscribe a la fuente Observable,pero ignora sus emisiones hasta el momento en que un segundo Observable emite un elemento,en cuyo momento SkipUntil comienza a reflejar la fuente Observable.</target>
        </trans-unit>
        <trans-unit id="6bb80afbe18d713aa7db356067ed9ca165eb2ac8" translate="yes" xml:space="preserve">
          <source>The SkipWhile subscribes to the source Observable, but ignores its emissions until such time as some condition you specify becomes false, at which point SkipWhile begins to mirror the source Observable.</source>
          <target state="translated">El SkipWhile se suscribe a la fuente Observable,pero ignora sus emisiones hasta el momento en que alguna condición que especifique se vuelve falsa,en cuyo momento SkipWhile comienza a reflejar la fuente Observable.</target>
        </trans-unit>
        <trans-unit id="321f848f6f6b99a515297203275ce7935c3c1b6c" translate="yes" xml:space="preserve">
          <source>The Subscribe operator is the glue that connects an observer to an Observable. In order for an observer to see the items being emitted by an Observable, or to receive error or completed notifications from the Observable, it must first subscribe to that Observable with this operator.</source>
          <target state="translated">El operador de Suscripción es el pegamento que conecta a un observador con un Observador.Para que un observador pueda ver los elementos emitidos por un observatorio,o recibir notificaciones de error o completadas del observatorio,debe suscribirse primero a ese observatorio con este operador.</target>
        </trans-unit>
        <trans-unit id="68817eb3363e4643e27a12a3a79cfd77fbc75f84" translate="yes" xml:space="preserve">
          <source>The Sum operator operates on an Observable that emits numbers (or items that can be evaluated as numbers), and emits a single value: the sum of all of the numbers emitted by the source Observable.</source>
          <target state="translated">El operador de la suma opera en un observable que emite números (o elementos que pueden ser evaluados como números),y emite un único valor:la suma de todos los números emitidos por la fuente observable.</target>
        </trans-unit>
        <trans-unit id="5499fa88e4c4fbb3fd161535ad060b25542b021f" translate="yes" xml:space="preserve">
          <source>The TakeUntil subscribes and begins mirroring the source Observable. It also monitors a second Observable that you provide. If this second Observable emits an item or sends a termination notification, the Observable returned by TakeUntil stops mirroring the source Observable and terminates.</source>
          <target state="translated">El TakeUntil se suscribe y comienza a reflejar la fuente Observable.También monitorea un segundo Observable que tú provees.Si este segundo Observable emite un ítem o envía una notificación de terminación,el Observable devuelto por TakeUntil deja de reflejar la fuente Observable y termina.</target>
        </trans-unit>
        <trans-unit id="d6300871c96270a7b7ca7ce40e8b54e51ae2bbe3" translate="yes" xml:space="preserve">
          <source>The TakeWhile mirrors the source Observable until such time as some condition you specify becomes false, at which point TakeWhile stops mirroring the source Observable and terminates its own Observable.</source>
          <target state="translated">El TakeWhile refleja la fuente Observable hasta el momento en que alguna condición que usted especifique se vuelva falsa,en cuyo momento el TakeWhile deja de reflejar la fuente Observable y termina su propio Observable.</target>
        </trans-unit>
        <trans-unit id="9b9d7306675e43c2b6a657987c0d20922a8ac2b2" translate="yes" xml:space="preserve">
          <source>The TimeInterval operator intercepts the items from the source Observable and emits in their place objects that indicate the amount of time that elapsed between pairs of emissions.</source>
          <target state="translated">El operador del Intervalo de Tiempo intercepta los elementos de la fuente Observable y emite en su lugar objetos que indican la cantidad de tiempo que ha transcurrido entre los pares de emisiones.</target>
        </trans-unit>
        <trans-unit id="606d848af5e8d890114a4201e94f633faae68708" translate="yes" xml:space="preserve">
          <source>The Timeout operator allows you to abort an Observable with an &lt;code&gt;onError&lt;/code&gt; termination if that Observable fails to emit any items during a specified span of time.</source>
          <target state="translated">El operador de tiempo de espera le permite cancelar un Observable con una terminaci&amp;oacute;n &lt;code&gt;onError&lt;/code&gt; si ese Observable no emite ning&amp;uacute;n elemento durante un per&amp;iacute;odo de tiempo espec&amp;iacute;fico.</target>
        </trans-unit>
        <trans-unit id="c92d7746cdf82983c7af4d7a45f125b462cfb156" translate="yes" xml:space="preserve">
          <source>The Timer operator creates an Observable that emits one particular item after a span of time that you specify.</source>
          <target state="translated">El operador del Timer crea un Observable que emite un artículo en particular después de un lapso de tiempo que usted especifica.</target>
        </trans-unit>
        <trans-unit id="d6f22a25ac9ea4e36d2fb3e2fc77ff657b78a01f" translate="yes" xml:space="preserve">
          <source>The Timestamp operator attaches a timestamp to each item emitted by the source Observable before reemitting that item in its own sequence. The timestamp indicates at what time the item was emitted.</source>
          <target state="translated">El operador de la marca de tiempo adjunta una marca de tiempo a cada elemento emitido por la fuente observable antes de volver a emitir ese elemento en su propia secuencia.La marca de tiempo indica a qué hora se emitió el elemento.</target>
        </trans-unit>
        <trans-unit id="f72aef25813cb6cd23e767b6322029a7b84433dd" translate="yes" xml:space="preserve">
          <source>The Using operator is a way you can instruct an Observable to create a resource that exists only during the lifespan of the Observable and is disposed of when the Observable terminates.</source>
          <target state="translated">El operador de uso es una forma de instruir a un Observador para crear un recurso que existe sólo durante la vida útil del Observador y que se desecha cuando éste termina.</target>
        </trans-unit>
        <trans-unit id="28cafaed855fc19783c71ce1747806f4b0aa50d5" translate="yes" xml:space="preserve">
          <source>The above operators are available in the following packages:</source>
          <target state="translated">Los operadores mencionados están disponibles en los siguientes paquetes:</target>
        </trans-unit>
        <trans-unit id="c7faf4cedb9be89a2fe4a7e2e6bb1c77cd930efc" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;subscribe&lt;/code&gt; returns an object that implements the &lt;code&gt;Subscription&lt;/code&gt; interface. This interface includes the &lt;code&gt;unsubscribe&lt;/code&gt; method that you can call at any time to sever the subscription that &lt;code&gt;subscribe&lt;/code&gt; established between the Observable and the observer (or the methods that stand in for the observer).</source>
          <target state="translated">La llamada a &lt;code&gt;subscribe&lt;/code&gt; devuelve un objeto que implementa la interfaz de &lt;code&gt;Subscription&lt;/code&gt; . Esta interfaz incluye la &lt;code&gt;unsubscribe&lt;/code&gt; m&amp;eacute;todo que puede llamar en cualquier momento para cortar la suscripci&amp;oacute;n que &lt;code&gt;subscribe&lt;/code&gt; establece entre lo observable y el observador (o los m&amp;eacute;todos que se interponen en el observador).</target>
        </trans-unit>
        <trans-unit id="89f14f94d842a0f3914f20a36dfd9eb22a7c4ee7" translate="yes" xml:space="preserve">
          <source>The combination of the And, Then, and When operators behave much like the Zip operator, but they do so by means of intermediate data structures. And accepts two or more Observables and combines the emissions from each, one set at a time, into &lt;code&gt;Pattern&lt;/code&gt; objects. Then operates on such &lt;code&gt;Pattern&lt;/code&gt; objects, transforming them in a &lt;code&gt;Plan&lt;/code&gt;. When in turn transforms these various &lt;code&gt;Plan&lt;/code&gt; objects into emissions from an Observable.</source>
          <target state="translated">La combinaci&amp;oacute;n de los operadores And, Then y When se comporta de manera muy similar al operador Zip, pero lo hacen mediante estructuras de datos intermedias. Y acepta dos o m&amp;aacute;s Observables y combina las emisiones de cada uno, un conjunto a la vez, en objetos &lt;code&gt;Pattern&lt;/code&gt; . Luego opera sobre tales objetos &lt;code&gt;Pattern&lt;/code&gt; , transform&amp;aacute;ndolos en un &lt;code&gt;Plan&lt;/code&gt; . Cuando a su vez transforma estos diversos objetos del &lt;code&gt;Plan&lt;/code&gt; en emisiones de un Observable.</target>
        </trans-unit>
        <trans-unit id="db1846a8b74a433edfdaca33027d099c7038cffa" translate="yes" xml:space="preserve">
          <source>The difference between this and &lt;code&gt;Observable.from&lt;/code&gt; is that the latter's parameter is an array or a sequence, and emits each of its element as one emission.</source>
          <target state="translated">La diferencia entre this y &lt;code&gt;Observable.from&lt;/code&gt; es que el par&amp;aacute;metro de este &amp;uacute;ltimo es una matriz o una secuencia, y emite cada uno de sus elementos como una emisi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="3dd77ae05f13d67f165ceb07a061686373523030" translate="yes" xml:space="preserve">
          <source>The first variant &amp;mdash; called either &lt;code&gt;debounce&lt;/code&gt; or &lt;code&gt;throttleWithTimeout&lt;/code&gt; &amp;mdash; accepts as its parameter a duration, defined as an integer number of milliseconds, and it suppresses any emitted items that are followed by other emitted items during that duration since the first item&amp;rsquo;s emission.</source>
          <target state="translated">La primera variante, denominada &lt;code&gt;debounce&lt;/code&gt; o &lt;code&gt;throttleWithTimeout&lt;/code&gt; , acepta como par&amp;aacute;metro una duraci&amp;oacute;n, definida como un n&amp;uacute;mero entero de milisegundos, y suprime cualquier elemento emitido que sea seguido por otros elementos emitidos durante esa duraci&amp;oacute;n desde la emisi&amp;oacute;n del primer elemento.</target>
        </trans-unit>
        <trans-unit id="0c61ffb36d85b092e0b11ad4b92c123ffd6cbe1d" translate="yes" xml:space="preserve">
          <source>The first variant accepts as its parameter a periodicity, defined as an integer number of milliseconds, and it samples the source Observable periodically at that frequency.</source>
          <target state="translated">La primera variante acepta como parámetro una periodicidad,definida como un número entero de milisegundos,y muestrea la fuente observable periódicamente a esa frecuencia.</target>
        </trans-unit>
        <trans-unit id="4d4daf5fefc143f2fe82e85dd951f60c3b004540" translate="yes" xml:space="preserve">
          <source>The first variant accepts parameters that define a duration of time (a quantity of time, and a &lt;code&gt;TimeUnit&lt;/code&gt; that this quantity is denominated in). Each time the source Observable emits an item, &lt;code&gt;timeout&lt;/code&gt; starts a timer, and if that timer exceeds the duration before the source Observable emits another item, &lt;code&gt;timeout&lt;/code&gt; terminates its Observable with an error (&lt;code&gt;TimeoutException&lt;/code&gt;).</source>
          <target state="translated">La primera variante acepta par&amp;aacute;metros que definen una duraci&amp;oacute;n de tiempo (una cantidad de tiempo, y una &lt;code&gt;TimeUnit&lt;/code&gt; en la que se denomina esta cantidad). Cada vez que la fuente Observable emite un elemento, el &lt;code&gt;timeout&lt;/code&gt; inicia un temporizador, y si ese temporizador excede la duraci&amp;oacute;n antes de que la fuente Observable emita otro elemento, el &lt;code&gt;timeout&lt;/code&gt; termina su Observable con un error ( &lt;code&gt;TimeoutException&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8cc80ffffa2d22148369eee22ce57927273f33be" translate="yes" xml:space="preserve">
          <source>The first variant of &lt;code&gt;delay&lt;/code&gt; accepts parameters that define a duration of time (a quantity of time, and a &lt;code&gt;TimeUnit&lt;/code&gt; that this quantity is denominated in). Each time the source Observable emits an item, &lt;code&gt;delay&lt;/code&gt; starts a timer, and when that timer reaches the given duration, the Observable returned from &lt;code&gt;delay&lt;/code&gt; emits the same item.</source>
          <target state="translated">La primera variante de &lt;code&gt;delay&lt;/code&gt; acepta par&amp;aacute;metros que definen una duraci&amp;oacute;n de tiempo (una cantidad de tiempo y una &lt;code&gt;TimeUnit&lt;/code&gt; en la que se denomina esta cantidad). Cada vez que la fuente Observable emite un elemento, la &lt;code&gt;delay&lt;/code&gt; inicia un temporizador, y cuando ese temporizador alcanza la duraci&amp;oacute;n dada, el Observable devuelto por la &lt;code&gt;delay&lt;/code&gt; emite el mismo elemento.</target>
        </trans-unit>
        <trans-unit id="46f0163399b285d3092a9a3d89985a4428677721" translate="yes" xml:space="preserve">
          <source>The first variant of &lt;code&gt;merge&lt;/code&gt; is an instance operator that takes a variable number of Observables as parameters, merging each of these Observables with the source (instance) Observables to produce its single output Observable.</source>
          <target state="translated">La primera variante de &lt;code&gt;merge&lt;/code&gt; es un operador de instancia que toma un n&amp;uacute;mero variable de Observables como par&amp;aacute;metros, fusionando cada uno de estos Observables con los Observables de origen (instancia) para producir su &amp;uacute;nica salida Observable.</target>
        </trans-unit>
        <trans-unit id="aa4845689320f7786a7ce0dd8a6cc3a35c2ebdd4" translate="yes" xml:space="preserve">
          <source>The first version of &lt;code&gt;timer&lt;/code&gt; returns an Observable that emits a single item after a delay period you specify. You can specify the delay either as a &lt;code&gt;Date&lt;/code&gt; object (which means, delay until that absolute moment) or as an integer (which means, delay that many milliseconds).</source>
          <target state="translated">La primera versi&amp;oacute;n del &lt;code&gt;timer&lt;/code&gt; devuelve un Observable que emite un solo elemento despu&amp;eacute;s de un per&amp;iacute;odo de retraso que especifique. Puede especificar la demora como un objeto de &lt;code&gt;Date&lt;/code&gt; (lo que significa, demora hasta ese momento absoluto) o como un n&amp;uacute;mero entero (lo que significa, demora esa cantidad de milisegundos).</target>
        </trans-unit>
        <trans-unit id="654d2ddaea67b293e03667eacbdc39c059d37abf" translate="yes" xml:space="preserve">
          <source>The following code constructs an Observable that emits the numbers between one and a million, and then samples that Observable every ten milliseconds to see what number it is emitting at that moment.</source>
          <target state="translated">El siguiente código construye un Observable que emite los números entre uno y un millón,y luego muestrea ese Observable cada diez milisegundos para ver qué número está emitiendo en ese momento.</target>
        </trans-unit>
        <trans-unit id="2de73bda505de7252f71c673c86fe20f971b7d67" translate="yes" xml:space="preserve">
          <source>The following example shows how you can chain a custom operator (in this example: &lt;code&gt;myOperator&lt;/code&gt;) along with standard RxJava operators by using the &lt;code&gt;lift( )&lt;/code&gt; operator:</source>
          <target state="translated">El siguiente ejemplo muestra c&amp;oacute;mo puede encadenar un operador personalizado (en este ejemplo: &lt;code&gt;myOperator&lt;/code&gt; ) junto con operadores RxJava est&amp;aacute;ndar mediante el operador &lt;code&gt;lift( )&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8d81c2a7bcb04a9212a58697cff7090bccdb6252" translate="yes" xml:space="preserve">
          <source>The following sample code uses &lt;code&gt;groupBy&lt;/code&gt; to transform a list of numbers into two lists, grouped by whether or not the numbers are even:</source>
          <target state="translated">El siguiente c&amp;oacute;digo de muestra usa &lt;code&gt;groupBy&lt;/code&gt; para transformar una lista de n&amp;uacute;meros en dos listas, agrupadas por si los n&amp;uacute;meros son pares o no:</target>
        </trans-unit>
        <trans-unit id="ea6ac1a648626d38582a5054601f86ada31f1cdf" translate="yes" xml:space="preserve">
          <source>The following section will show how to form the scaffolding of your operator so that it will work correctly with &lt;code&gt;lift( )&lt;/code&gt;.</source>
          <target state="translated">La siguiente secci&amp;oacute;n le mostrar&amp;aacute; c&amp;oacute;mo formar el andamio de su operador para que funcione correctamente con &lt;code&gt;lift( )&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="253b6d42be3a506a59fbdcf2b0d6ab30d54c2bb5" translate="yes" xml:space="preserve">
          <source>The following sections of this page will give marble diagrams that explain these operators schematically. This diagram explains how Singles are represented in marble diagrams:</source>
          <target state="translated">En las siguientes secciones de esta página se ofrecen diagramas de mármol que explican estos operadores de forma esquemática.Este diagrama explica cómo se representan los solteros en los diagramas de mármol:</target>
        </trans-unit>
        <trans-unit id="a84f1d1885dd7b824328237a193222ffa087c297" translate="yes" xml:space="preserve">
          <source>The functions described in this section are all found in each of the following distributions:</source>
          <target state="translated">Las funciones descritas en esta sección se encuentran en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="aaf5e9f52491f23699e57321ab3d9e121b260a8e" translate="yes" xml:space="preserve">
          <source>The instance version of &lt;code&gt;merge&lt;/code&gt; is &lt;code&gt;mergeWith&lt;/code&gt;, so, for example, in the code sample above, instead of writing &lt;code&gt;Observable.merge(odds,evens)&lt;/code&gt; you could also write &lt;code&gt;odds.mergeWith(evens)&lt;/code&gt;.</source>
          <target state="translated">La versi&amp;oacute;n de instancia de &lt;code&gt;merge&lt;/code&gt; es &lt;code&gt;mergeWith&lt;/code&gt; , por lo que, por ejemplo, en el ejemplo de c&amp;oacute;digo anterior, en lugar de escribir &lt;code&gt;Observable.merge(odds,evens)&lt;/code&gt; , tambi&amp;eacute;n podr&amp;iacute;a escribir &lt;code&gt;odds.mergeWith(evens)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25e8c42029acb7473a36750cf098482de5a83900" translate="yes" xml:space="preserve">
          <source>The instance version of &lt;code&gt;merge&lt;/code&gt; is &lt;code&gt;mergeWith&lt;/code&gt;, so, for example, instead of writing &lt;code&gt;Observable.merge(odds,evens)&lt;/code&gt; you could also write &lt;code&gt;odds.mergeWith(evens)&lt;/code&gt;.</source>
          <target state="translated">La versi&amp;oacute;n de instancia de &lt;code&gt;merge&lt;/code&gt; es &lt;code&gt;mergeWith&lt;/code&gt; , por lo que, por ejemplo, en lugar de escribir &lt;code&gt;Observable.merge(odds,evens)&lt;/code&gt; , tambi&amp;eacute;n puede escribir &lt;code&gt;odds.mergeWith(evens)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c8953a5933d5a16119ad112dc5a75d223543853" translate="yes" xml:space="preserve">
          <source>The last argument to &lt;code&gt;zip&lt;/code&gt; is a function that accepts an item from each of the Observables being zipped and emits an item to be emitted in response by the Observable returned from &lt;code&gt;zip&lt;/code&gt;. You can provide the Observables to be zipped together to &lt;code&gt;zip&lt;/code&gt; either as between two and nine individual parameters, or as a single parameter: either an Iterable of Observables or an Observable that emits Observables (as in the illustration above).</source>
          <target state="translated">El &amp;uacute;ltimo argumento para &lt;code&gt;zip&lt;/code&gt; es una funci&amp;oacute;n que acepta un elemento de cada uno de los Observables que se est&amp;aacute; comprimiendo y emite un elemento para ser emitido en respuesta por el Observable devuelto desde &lt;code&gt;zip&lt;/code&gt; . Puede proporcionar los Observables para comprimirlos juntos para &lt;code&gt;zip&lt;/code&gt; como entre dos y nueve par&amp;aacute;metros individuales, o como un solo par&amp;aacute;metro: ya sea un Iterable de Observables o un Observable que emite Observables (como en la ilustraci&amp;oacute;n anterior).</target>
        </trans-unit>
        <trans-unit id="5fb92e256f51bccbbcb15f80dac8fed9a700c156" translate="yes" xml:space="preserve">
          <source>The parameter, whether a tuple (i.e. &lt;code&gt;(1, 2, 3)&lt;/code&gt;) or an array (i.e. &lt;code&gt;[1,2,3]&lt;/code&gt;) is produced as one emission.</source>
          <target state="translated">El par&amp;aacute;metro, ya sea una tupla (es decir, &lt;code&gt;(1, 2, 3)&lt;/code&gt; ) o una matriz (es decir, &lt;code&gt;[1,2,3]&lt;/code&gt; 1, 2, 3 ] ) se produce como una emisi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e6863eccf319c5c010a867abbdb3ab75de53a4cc" translate="yes" xml:space="preserve">
          <source>The predicate function itself takes three arguments:</source>
          <target state="translated">La función de predicado en sí misma requiere tres argumentos:</target>
        </trans-unit>
        <trans-unit id="55144d4df6ac43ab12e89905c1250932b67b903c" translate="yes" xml:space="preserve">
          <source>The predicate function takes three parameters:</source>
          <target state="translated">La función de predicado toma tres parámetros:</target>
        </trans-unit>
        <trans-unit id="f2e56bda3ccada06fa656085e73c8b6e0dee801d" translate="yes" xml:space="preserve">
          <source>The real power comes with the &amp;ldquo;reactive extensions&amp;rdquo; (hence &amp;ldquo;ReactiveX&amp;rdquo;) &amp;mdash; operators that allow you to transform, combine, manipulate, and work with the sequences of items emitted by Observables.</source>
          <target state="translated">El poder real viene con las &quot;extensiones reactivas&quot; (de ah&amp;iacute; &quot;ReactiveX&quot;), operadores que le permiten transformar, combinar, manipular y trabajar con las secuencias de elementos emitidos por Observables.</target>
        </trans-unit>
        <trans-unit id="44eca70b029fe849bd6ef526e9e90e367585dfc9" translate="yes" xml:space="preserve">
          <source>The results of this unsubscription will cascade back through the chain of operators that applies to the Observable that the observer subscribed to, and this will cause each link in the chain to stop emitting items. This is not guaranteed to happen immediately, however, and it is possible for an Observable to generate and attempt to emit items for a while even after no observers remain to observe these emissions.</source>
          <target state="translated">Los resultados de esta cancelación se verán reflejados en la cadena de operadores que se aplica al observable al que se ha suscrito el observador,lo que hará que cada eslabón de la cadena deje de emitir artículos.Sin embargo,no se garantiza que esto ocurra inmediatamente,y es posible que un Observador genere e intente emitir artículos durante un tiempo incluso después de que no queden observadores para observar estas emisiones.</target>
        </trans-unit>
        <trans-unit id="0f7d52b3373d09ac8d1c47f35ca4249eb74f508c" translate="yes" xml:space="preserve">
          <source>The second variant accepts as its parameter an Observable, and it samples the source Observable whenever this second Observable emits an item.</source>
          <target state="translated">La segunda variante acepta como parámetro un Observable,y toma una muestra de la fuente Observable siempre que este segundo Observable emita un elemento.</target>
        </trans-unit>
        <trans-unit id="96a965140ca52079c513552d1152f6627ca655d7" translate="yes" xml:space="preserve">
          <source>The second variant of &lt;code&gt;merge&lt;/code&gt; is a prototype (class) operator that accepts two parameters. The second of these is an Observable that emits the Observables you want to merge. The first is a number that indicates the maximum number of these emitted Observables that you want &lt;code&gt;merge&lt;/code&gt; to attempt to be subscribed to at any moment. Once it reaches this maximum subscription count, it will refrain from subscribing to any other Observables emitted by the source Observable until such time as one of the already-subscribed-to Observables issues an &lt;code&gt;onCompleted&lt;/code&gt; notification.</source>
          <target state="translated">La segunda variante de &lt;code&gt;merge&lt;/code&gt; es un operador de prototipo (clase) que acepta dos par&amp;aacute;metros. El segundo de estos es un Observable que emite los Observables que desea fusionar. El primero es un n&amp;uacute;mero que indica el n&amp;uacute;mero m&amp;aacute;ximo de estos Observables emitidos a los que desea &lt;code&gt;merge&lt;/code&gt; para intentar suscribirse en cualquier momento. Una vez que se alcanza este n&amp;uacute;mero m&amp;aacute;ximo de suscripci&amp;oacute;n, se abstendr&amp;aacute; de suscribirse a cualquier otro observables emitidos por la fuente observable hasta que una de las una ya suscrito a cuestiones observables &lt;code&gt;onCompleted&lt;/code&gt; notificaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e968e081d2b1a1b80a32c5783a3beb2f47d20ff6" translate="yes" xml:space="preserve">
          <source>The transforming function gets three parameters:</source>
          <target state="translated">La función de transformación tiene tres parámetros:</target>
        </trans-unit>
        <trans-unit id="d776b341ab49eb64280d0e25e6eb6356060e9290" translate="yes" xml:space="preserve">
          <source>The variant of &lt;code&gt;delay&lt;/code&gt; that uses a per-item Observable to set the delay has a variant that allows you to pass in a function that returns an Observable that acts as a delay timer for the subscription to the source Observable (in the absence of this, &lt;code&gt;delay&lt;/code&gt; subscribes to the source Observable as soon as an observer subscribes to the Observable returned by &lt;code&gt;delay&lt;/code&gt;).</source>
          <target state="translated">La variante de &lt;code&gt;delay&lt;/code&gt; que usa un Observable por elemento para establecer el retraso tiene una variante que le permite pasar una funci&amp;oacute;n que devuelve un Observable que act&amp;uacute;a como un temporizador de retraso para la suscripci&amp;oacute;n a la fuente Observable (en ausencia de este, &lt;code&gt;delay&lt;/code&gt; se suscribe a la fuente Observable tan pronto como un observador se suscribe al Observable devuelto por &lt;code&gt;delay&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="adc1ba9017e6bcdf3a2740ab73cfafc6559474ce" translate="yes" xml:space="preserve">
          <source>The variant of &lt;code&gt;timeout&lt;/code&gt; that uses a per-item Observable to set the timeout has a variant that allows you to pass in a function that returns an Observable that acts as a timeout timer for the very first item emitted by the source Observable (in the absence of this, there would be no timeout for the first item).</source>
          <target state="translated">La variante de &lt;code&gt;timeout&lt;/code&gt; de espera que utiliza un Observable por elemento para establecer el tiempo de espera tiene una variante que le permite pasar una funci&amp;oacute;n que devuelve un Observable que act&amp;uacute;a como un temporizador de tiempo de espera para el primer elemento emitido por la fuente Observable (en ausencia de esto, no habr&amp;iacute;a tiempo de espera para el primer elemento).</target>
        </trans-unit>
        <trans-unit id="dac97b2b169057bbb0f51b05b81737a793abbd1a" translate="yes" xml:space="preserve">
          <source>The variant of &lt;code&gt;timeoutWithSelector&lt;/code&gt; that uses a per-item Observable to set the timeout has a variant that allows you to pass in an Observable that acts as a timeout timer for the very first item emitted by the source Observable (in the absence of this, there would be no timeout for the first item; that is to say, the default Observable that governs this first timeout period is &lt;code&gt;Rx.Observable.never()&lt;/code&gt;).</source>
          <target state="translated">La variante de &lt;code&gt;timeoutWithSelector&lt;/code&gt; que usa un Observable por elemento para establecer el tiempo de espera tiene una variante que le permite pasar un Observable que act&amp;uacute;a como un temporizador de tiempo de espera para el primer elemento emitido por la fuente Observable (en ausencia de esto, hay no habr&amp;iacute;a tiempo de espera para el primer elemento; es decir, el Observable predeterminado que gobierna este primer per&amp;iacute;odo de tiempo de espera es &lt;code&gt;Rx.Observable.never()&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="76e86c71c2cfc919caec20c620ae9ee1c2891b71" translate="yes" xml:space="preserve">
          <source>The various RxGroovy implementations of Start are found in the optional &lt;code&gt;rxjava-async&lt;/code&gt; module.</source>
          <target state="translated">Las diversas implementaciones de RxGroovy de Start se encuentran en el &lt;code&gt;rxjava-async&lt;/code&gt; opcional rxjava-async .</target>
        </trans-unit>
        <trans-unit id="69d9d1fff4b37940fbc6c5e8b43dc2bfa9e40934" translate="yes" xml:space="preserve">
          <source>The various RxJava implementations of Start are found in the optional &lt;code&gt;rxjava-async&lt;/code&gt; module.</source>
          <target state="translated">Las diversas implementaciones de RxJava de Start se encuentran en el &lt;code&gt;rxjava-async&lt;/code&gt; opcional rxjava-async .</target>
        </trans-unit>
        <trans-unit id="5d2372405de754e029a63b317c742a70f865da43" translate="yes" xml:space="preserve">
          <source>The various language-specific implementations of ReactiveX have a variety of operators that you can use to convert an Observable, or a sequence of items emitted by an Observable, into another variety of object or data structure. Some of these block until the Observable terminates and then produce an equivalent object or data structure; others return an Observable that emits such an object or data structure.</source>
          <target state="translated">Las diversas implementaciones de ReactiveX en idiomas específicos tienen una variedad de operadores que pueden utilizarse para convertir un observable,o una secuencia de elementos emitidos por un observable,en otra variedad de objeto o estructura de datos.Algunos de ellos se bloquean hasta que el Observable termina y luego producen un objeto o estructura de datos equivalente;otros devuelven un Observable que emite tal objeto o estructura de datos.</target>
        </trans-unit>
        <trans-unit id="8a3803202cc409cc722e7f519df7c21e3cad47af" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;manySelect&lt;/code&gt; passes each of these Observables into a function that you provide, and emits, as the emissions from the Observable that &lt;code&gt;manySelect&lt;/code&gt; returns, the return values from those function calls.</source>
          <target state="translated">Luego, &lt;code&gt;manySelect&lt;/code&gt; pasa cada uno de estos Observables a una funci&amp;oacute;n que usted proporciona y emite, como las emisiones del Observable que &lt;code&gt;manySelect&lt;/code&gt; devuelve, los valores de retorno de esas llamadas a funciones.</target>
        </trans-unit>
        <trans-unit id="33a18cef9dc87a7ca6a904f01a814fcba80c85d2" translate="yes" xml:space="preserve">
          <source>There are a number of ways that programming languages have for obtaining values as the result of calculations, with names like functions, futures, actions, callables, runnables, and so forth. The operators grouped here under the Start operator category make these things behave like Observables so that they can be chained with other Observables in an Observable cascade</source>
          <target state="translated">Los lenguajes de programación tienen varias formas de obtener valores como resultado de los cálculos,con nombres como funciones,futuros,acciones,llamables,ejecutables,etc.Los operadores agrupados aquí bajo la categoría de operador de inicio hacen que estas cosas se comporten como Observables para que puedan ser encadenados con otros Observables en una cascada de Observables</target>
        </trans-unit>
        <trans-unit id="73e88b632040f4debf71d15f62a7edac8dafa11d" translate="yes" xml:space="preserve">
          <source>There are a variety of strategies with which you can exercise flow control and backpressure in ReactiveX in order to alleviate the problems caused when a quickly-producing Observable meets a slow-consuming observer, which include, in some ReactiveX implementations, reactive pull backpressure and some backpressure-specific operators.</source>
          <target state="translated">Hay una variedad de estrategias con las que se puede ejercer el control del flujo y la contrapresión en ReactiveX a fin de aliviar los problemas causados cuando un observable de producción rápida se encuentra con un observador de consumo lento,que incluyen,en algunas implementaciones de ReactiveX,la contrapresión de retroceso reactiva y algunos operadores específicos de contrapresión.</target>
        </trans-unit>
        <trans-unit id="e49413915d5649a099917d12a2f59331c6b6ecb2" translate="yes" xml:space="preserve">
          <source>There are also several other operators that perform similar functions.</source>
          <target state="translated">También hay varios otros operadores que desempeñan funciones similares.</target>
        </trans-unit>
        <trans-unit id="61a06999b013c4f11472882f535a3c0cecf8baa5" translate="yes" xml:space="preserve">
          <source>There are also two operators that convert an ordinary Observable into at &lt;code&gt;PausableObservable&lt;/code&gt;.</source>
          <target state="translated">Tambi&amp;eacute;n hay dos operadores que convierten un Observable ordinario en en &lt;code&gt;PausableObservable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cd75322c8a8e345487e962bdedb9cc23338cdd4" translate="yes" xml:space="preserve">
          <source>There are also versions of &lt;code&gt;ReplaySubject&lt;/code&gt; that will throw away old items once the replay buffer threatens to grow beyond a certain size, or when a specified timespan has passed since the items were originally emitted.</source>
          <target state="translated">Tambi&amp;eacute;n hay versiones de &lt;code&gt;ReplaySubject&lt;/code&gt; que desechan los elementos antiguos una vez que el b&amp;uacute;fer de reproducci&amp;oacute;n amenaza con crecer m&amp;aacute;s all&amp;aacute; de un cierto tama&amp;ntilde;o, o cuando ha pasado un per&amp;iacute;odo de tiempo espec&amp;iacute;fico desde que los elementos se emitieron originalmente.</target>
        </trans-unit>
        <trans-unit id="f6c86c5d109c333c0cb181ff21e7e549c1d9978e" translate="yes" xml:space="preserve">
          <source>There are four varieties of &lt;code&gt;Subject&lt;/code&gt; that are designed for particular use cases. Not all of these are available in all implementations, and some implementations use other naming conventions (for example, in RxScala, what is called a &amp;ldquo;PublishSubject&amp;rdquo; here is known simply as a &amp;ldquo;Subject&amp;rdquo;):</source>
          <target state="translated">Hay cuatro variedades de &lt;code&gt;Subject&lt;/code&gt; que est&amp;aacute;n dise&amp;ntilde;adas para casos de uso particulares. No todos estos est&amp;aacute;n disponibles en todas las implementaciones, y algunas implementaciones usan otras convenciones de nomenclatura (por ejemplo, en RxScala, lo que se llama un &quot;PublishSubject&quot; aqu&amp;iacute; se conoce simplemente como un &quot;Subject&quot;):</target>
        </trans-unit>
        <trans-unit id="e3d50a06b7b01adde087a728ea4e55f5179a3c5f" translate="yes" xml:space="preserve">
          <source>There are many terms used to describe this model of asynchronous programming and design. This document will use the following terms: An</source>
          <target state="translated">Hay muchos términos utilizados para describir este modelo de programación y diseño asíncrono.En este documento se utilizarán los siguientes términos:Un</target>
        </trans-unit>
        <trans-unit id="c22e405785cca51fa4bed377c8c7a316e925a3fa" translate="yes" xml:space="preserve">
          <source>There are other patterns, like the Builder Pattern, in which a variety of methods of a particular class operate on an item of that same class by modifying that object through the operation of the method. These patterns also allow you to chain the methods in a similar way. But while in the Builder Pattern, the order in which the methods appear in the chain does not usually matter, with the Observable operators &lt;em&gt;order matters&lt;/em&gt;.</source>
          <target state="translated">Hay otros patrones, como Builder Pattern, en los que una variedad de m&amp;eacute;todos de una clase particular operan sobre un elemento de esa misma clase modificando ese objeto mediante la operaci&amp;oacute;n del m&amp;eacute;todo. Estos patrones tambi&amp;eacute;n le permiten encadenar los m&amp;eacute;todos de manera similar. Pero mientras que en el patr&amp;oacute;n de constructor, el orden en el que aparecen los m&amp;eacute;todos en la cadena no suele importar, con el &lt;em&gt;orden de los&lt;/em&gt; operadores observables s&amp;iacute; &lt;em&gt;importa&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ea34fdc274aea1e52da5c7d9e60582c49187d9f7" translate="yes" xml:space="preserve">
          <source>There are several variants of the Catch operator, and a variety of names used by different ReactiveX implementations to describe this operation, as you can see in the sections below.</source>
          <target state="translated">Hay varias variantes del operador Catch,y una variedad de nombres utilizados por diferentes implementaciones de ReactiveX para describir esta operación,como se puede ver en las secciones siguientes.</target>
        </trans-unit>
        <trans-unit id="6d11bb624ef1904bb9f2ab36c1280a55a7979979" translate="yes" xml:space="preserve">
          <source>There are several variants of the Window operator in Rx.NET.</source>
          <target state="translated">Hay varias variantes del operador Window en Rx.NET.</target>
        </trans-unit>
        <trans-unit id="07798f4e8bae1bc378e7ef680bdb140ecb41085a" translate="yes" xml:space="preserve">
          <source>There are several varieties of Window in RxGroovy.</source>
          <target state="translated">Hay varias variedades de Window en RxGroovy.</target>
        </trans-unit>
        <trans-unit id="fe6adaab352a0a35969e744faa35420dfb689712" translate="yes" xml:space="preserve">
          <source>There are several varieties of Window in RxJava.</source>
          <target state="translated">Hay varias variedades de Ventana en RxJava.</target>
        </trans-unit>
        <trans-unit id="f5e80cf04e90857ed90a075f8cf480a3a0d35901" translate="yes" xml:space="preserve">
          <source>There are several varieties of Window in RxKotlin.</source>
          <target state="translated">Hay varias variedades de Window en RxKotlin.</target>
        </trans-unit>
        <trans-unit id="18c6f13171d4c2450de4807dd5e71c2d51ac49cb" translate="yes" xml:space="preserve">
          <source>There are several, specialized From variants in RxJS:</source>
          <target state="translated">Hay varias variantes especializadas de RxJS:</target>
        </trans-unit>
        <trans-unit id="c2aafde972aa8a0b7ac30764bbba82ab7263e0b7" translate="yes" xml:space="preserve">
          <source>There ia also a variant of &lt;code&gt;debounce&lt;/code&gt; (that does not have a &lt;code&gt;throttleWithTimeout&lt;/code&gt; alias) that throttles the source Observable by applying a function to each item it emits, this function generating an Observable. If the source Observable emits another item before this newly-generated Observable terminates, &lt;code&gt;debounce&lt;/code&gt; will suppress the item.</source>
          <target state="translated">Tambi&amp;eacute;n hay una variante de &lt;code&gt;debounce&lt;/code&gt; (que no tiene un alias &lt;code&gt;throttleWithTimeout&lt;/code&gt; ) que acelera la fuente Observable aplicando una funci&amp;oacute;n a cada elemento que emite, esta funci&amp;oacute;n genera un Observable. Si el Observable de origen emite otro elemento antes de que este Observable reci&amp;eacute;n generado termine, el &lt;code&gt;debounce&lt;/code&gt; suprimir&amp;aacute; el elemento.</target>
        </trans-unit>
        <trans-unit id="27a314ac81cd792286fe509248ef7e647165cd74" translate="yes" xml:space="preserve">
          <source>There ia also a variant of &lt;code&gt;sample&lt;/code&gt; (that does not have a &lt;code&gt;throttleLast&lt;/code&gt; alias) that samples the source Observable each time a second Observable emits an item (or when it terminates). You pass in that second Observable as the parameter to &lt;code&gt;sample&lt;/code&gt;.</source>
          <target state="translated">Tambi&amp;eacute;n hay una variante de &lt;code&gt;sample&lt;/code&gt; (que no tiene un alias &lt;code&gt;throttleLast&lt;/code&gt; ) que muestrea la fuente Observable cada vez que un segundo Observable emite un elemento (o cuando termina). Pasas ese segundo Observable como par&amp;aacute;metro para &lt;code&gt;sample&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb4c828574f32cd2c4544bf3aa850a7f8f332980" translate="yes" xml:space="preserve">
          <source>There is a somewhat similar operator in the optional &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; package (it is not part of the standard RxGroovy set of operators). The &lt;code&gt;switchCase&lt;/code&gt; operator conditionally creates and returns one of a set of possible Observables.</source>
          <target state="translated">Hay un operador algo similar en el &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; opcional rxjava-computation-expression (no es parte del conjunto est&amp;aacute;ndar de operadores RxGroovy). El operador &lt;code&gt;switchCase&lt;/code&gt; crea y devuelve condicionalmente uno de un conjunto de posibles Observables.</target>
        </trans-unit>
        <trans-unit id="b0dccba89c1599405c711aa1cf5bd05e76ced379" translate="yes" xml:space="preserve">
          <source>There is a somewhat similar operator in the optional &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; package (it is not part of the standard RxJava set of operators). The &lt;code&gt;switchCase&lt;/code&gt; operator conditionally creates and returns one of a set of possible Observables.</source>
          <target state="translated">Hay un operador algo similar en el &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; opcional rxjava-computation-expression (no es parte del conjunto est&amp;aacute;ndar de operadores RxJava). El operador &lt;code&gt;switchCase&lt;/code&gt; crea y devuelve condicionalmente uno de un conjunto de posibles Observables.</target>
        </trans-unit>
        <trans-unit id="8b280f16d9def0775a32cceafee35e54eb2b99f3" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;BlockingObservable&lt;/code&gt; method called &lt;code&gt;forEach&lt;/code&gt; that is somewhat similar. In order to use it, you must first convert your source Observable into a &lt;code&gt;BlockingObservable&lt;/code&gt; by means of either the &lt;code&gt;BlockingObservable.from&lt;/code&gt; method or the &lt;code&gt;Observable.toBlocking&lt;/code&gt; operator.</source>
          <target state="translated">Tambi&amp;eacute;n hay un m&amp;eacute;todo &lt;code&gt;BlockingObservable&lt;/code&gt; llamado &lt;code&gt;forEach&lt;/code&gt; que es algo similar. Para usarlo, primero debe convertir su fuente Observable en &lt;code&gt;BlockingObservable&lt;/code&gt; mediante el m&amp;eacute;todo &lt;code&gt;BlockingObservable.from&lt;/code&gt; o el operador &lt;code&gt;Observable.toBlocking&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="756e49dd09eebbec81d8a98370d0d54627dacd33" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;concatMap&lt;/code&gt; operator, which is like the &lt;code&gt;flatMap&lt;/code&gt; operator, but it concatenates rather than merges the resulting Observables in order to generate its own sequence.</source>
          <target state="translated">Tambi&amp;eacute;n hay un operador &lt;code&gt;concatMap&lt;/code&gt; , que es como el operador &lt;code&gt;flatMap&lt;/code&gt; , pero concatena en lugar de fusionar los Observables resultantes para generar su propia secuencia.</target>
        </trans-unit>
        <trans-unit id="610870ff67a503579cdb5b83dc6b88cf5b2ca5bd" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;concatMap&lt;/code&gt; operator, which is like the simpler version of the &lt;code&gt;flatMap&lt;/code&gt; operator, but it concatenates rather than merges the resulting Observables in order to generate its own sequence.</source>
          <target state="translated">Tambi&amp;eacute;n hay un operador &lt;code&gt;concatMap&lt;/code&gt; , que es como la versi&amp;oacute;n m&amp;aacute;s simple del operador &lt;code&gt;flatMap&lt;/code&gt; , pero concatena en lugar de fusionar los Observables resultantes para generar su propia secuencia.</target>
        </trans-unit>
        <trans-unit id="09afc2ecb73970aa3e173379620bf2dbd67958e3" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;concatMapObserver&lt;/code&gt; operator, which is like the &lt;code&gt;flatMapObserver&lt;/code&gt; operator, in that it creates Observables to merge from both the emissions and terminal notifications of the source Observable, but it concatenates rather than merges these resulting Observables in order to generate its own sequence.</source>
          <target state="translated">Tambi&amp;eacute;n hay un operador &lt;code&gt;concatMapObserver&lt;/code&gt; , que es como el operador &lt;code&gt;flatMapObserver&lt;/code&gt; , en el sentido de que crea Observables para fusionar tanto las emisiones como las notificaciones terminales de la fuente Observable, pero concatena en lugar de fusionar estos Observables resultantes para generar su propia secuencia.</target>
        </trans-unit>
        <trans-unit id="f9e703f230d8766cf702a843852917ca049479cb" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;fromNodeCallback&lt;/code&gt; operator, which is specialized for the types of callback functions found in Node.js.</source>
          <target state="translated">Tambi&amp;eacute;n hay un operador &lt;code&gt;fromNodeCallback&lt;/code&gt; , que est&amp;aacute; especializado para los tipos de funciones de devoluci&amp;oacute;n de llamada que se encuentran en Node.js.</target>
        </trans-unit>
        <trans-unit id="0adc1cf4895a72eb26c43ab8483af0d51f693087" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;fromPromise&lt;/code&gt; operator that converts a Promise into an Observable, converting its &lt;code&gt;resolve&lt;/code&gt; calls into &lt;code&gt;onNext&lt;/code&gt; notifications, and its &lt;code&gt;reject&lt;/code&gt; calls into &lt;code&gt;onError&lt;/code&gt; notifications.</source>
          <target state="translated">Tambi&amp;eacute;n hay un operador &lt;code&gt;fromPromise&lt;/code&gt; que convierte una Promise en un Observable, convirtiendo sus llamadas de &lt;code&gt;resolve&lt;/code&gt; en notificaciones &lt;code&gt;onNext&lt;/code&gt; y sus llamadas de &lt;code&gt;reject&lt;/code&gt; en notificaciones &lt;code&gt;onError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9fa226a63caa5b60f8b21383025ba4a7f512229e" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;jortSort&lt;/code&gt; operator that performs a test on the entire sequence of items emitted by the source Observable. If those items are emitted in sorted order, upon the successful completion of the source Observable, the Observable returned from &lt;code&gt;jortSort&lt;/code&gt; will emit &lt;code&gt;true&lt;/code&gt; and then complete. If any of the items emitted by the source Observable is out of sort order, upon the successful completion of the source Observable, the Observable returned from &lt;code&gt;jortSort&lt;/code&gt; will emit &lt;code&gt;false&lt;/code&gt; and then complete.</source>
          <target state="translated">Tambi&amp;eacute;n hay un operador &lt;code&gt;jortSort&lt;/code&gt; que realiza una prueba en toda la secuencia de elementos emitidos por la fuente Observable. Si esos elementos se emiten en orden ordenado, despu&amp;eacute;s de completar con &amp;eacute;xito el Observable de origen, el Observable devuelto por &lt;code&gt;jortSort&lt;/code&gt; emitir&amp;aacute; &lt;code&gt;true&lt;/code&gt; y luego se completar&amp;aacute;. Si alguno de los elementos emitidos por el Observable fuente est&amp;aacute; fuera de orden, una vez que se complete con &amp;eacute;xito el Observable fuente, el Observable devuelto por &lt;code&gt;jortSort&lt;/code&gt; emitir&amp;aacute; &lt;code&gt;false&lt;/code&gt; y luego completo.</target>
        </trans-unit>
        <trans-unit id="f9b14ade97497781729ad307d8e9c95d0d12c215" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;jortSortUntil&lt;/code&gt; operator. It does not wait until the source Observable completes to evaluate its sequence for sortedness, as &lt;code&gt;jortSort&lt;/code&gt; does, but waits until a second Observable emits an item to do so.</source>
          <target state="translated">Tambi&amp;eacute;n hay un operador &lt;code&gt;jortSortUntil&lt;/code&gt; . No espera hasta que el Observable de origen se complete para evaluar su secuencia de clasificaci&amp;oacute;n, como &lt;code&gt;jortSort&lt;/code&gt; hace jortSort , sino que espera hasta que un segundo Observable emita un elemento para hacerlo.</target>
        </trans-unit>
        <trans-unit id="3b92b6af0c8024980674892ceec6ad6d8a9afe31" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;let&lt;/code&gt; operator (the alias &lt;code&gt;letBind&lt;/code&gt; is available for browsers such as Internet Explorer before IE9 where &amp;ldquo;&lt;code&gt;let&lt;/code&gt;&amp;rdquo; is forbidden). It is similar to &lt;code&gt;multicast&lt;/code&gt; but does not multicast the underlying Observable through a Subject:</source>
          <target state="translated">Tambi&amp;eacute;n hay un operador &lt;code&gt;let&lt;/code&gt; (el alias &lt;code&gt;letBind&lt;/code&gt; est&amp;aacute; disponible para navegadores como Internet Explorer antes de IE9, donde &quot; &lt;code&gt;let&lt;/code&gt; &quot; est&amp;aacute; prohibido). Es similar a la &lt;code&gt;multicast&lt;/code&gt; pero no multidifusi&amp;oacute;n del Observable subyacente a trav&amp;eacute;s de un sujeto:</target>
        </trans-unit>
        <trans-unit id="33bf4c5e7b8fe133a7bee1aa2fed01e21ee7ee8f" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;pairs&lt;/code&gt; operator. This operator accepts an Object, and returns an Observable that emits, as key/value pairs, the attributes of that object.</source>
          <target state="translated">Tambi&amp;eacute;n hay un operador de &lt;code&gt;pairs&lt;/code&gt; . Este operador acepta un Objeto y devuelve un Observable que emite, como pares clave / valor, los atributos de ese objeto.</target>
        </trans-unit>
        <trans-unit id="106ca88c78fe1594ed237ab370c3a39e226e56bd" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;share&lt;/code&gt; operator, which is the equivalent of applying both the &lt;code&gt;publish&lt;/code&gt; and &lt;code&gt;refCount&lt;/code&gt; operators to an Observable, in that order.</source>
          <target state="translated">Tambi&amp;eacute;n hay un operador de &lt;code&gt;share&lt;/code&gt; , que es el equivalente a aplicar los operadores &lt;code&gt;publish&lt;/code&gt; y &lt;code&gt;refCount&lt;/code&gt; a un Observable, en ese orden.</target>
        </trans-unit>
        <trans-unit id="a951647b57d362f06673c5f1bcc698b8bc2b55bc" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;share&lt;/code&gt; operator, which is the equivalent of applying both the &lt;code&gt;publish&lt;/code&gt; and &lt;code&gt;refCount&lt;/code&gt; operators to an Observable, in that order. A variant called &lt;code&gt;shareValue&lt;/code&gt; takes as a parameter a single item that it will emit to any subscribers before beginning to emit items from the source Observable.</source>
          <target state="translated">Tambi&amp;eacute;n hay un operador de &lt;code&gt;share&lt;/code&gt; , que es el equivalente a aplicar los operadores &lt;code&gt;publish&lt;/code&gt; y &lt;code&gt;refCount&lt;/code&gt; a un Observable, en ese orden. Una variante llamada &lt;code&gt;shareValue&lt;/code&gt; toma como par&amp;aacute;metro un solo elemento que emitir&amp;aacute; a cualquier suscriptor antes de comenzar a emitir elementos desde la fuente Observable.</target>
        </trans-unit>
        <trans-unit id="5dce3334b047123b8d59d3f575f95fd87a1a54bc" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;shareReplay&lt;/code&gt; operator, which keeps track of the number of observers, and disconnects from the source Observable when that number drops to zero. &lt;code&gt;shareReplay&lt;/code&gt; takes three optional parameters and returns an ordinary Observable:</source>
          <target state="translated">Tambi&amp;eacute;n hay un operador &lt;code&gt;shareReplay&lt;/code&gt; , que realiza un seguimiento del n&amp;uacute;mero de observadores y se desconecta de la fuente Observable cuando ese n&amp;uacute;mero cae a cero. &lt;code&gt;shareReplay&lt;/code&gt; toma tres par&amp;aacute;metros opcionales y devuelve un Observable ordinario:</target>
        </trans-unit>
        <trans-unit id="ebdcc8b43b2ed321ef1ee5bf75bf2c4c54ccb1c8" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;skipUntilWithTime&lt;/code&gt; operator to which you can pass an absolute time or an initial duration in place of an Observable, but this is described on the &lt;a href=&quot;skip&quot;&gt;Skip&lt;/a&gt; operator page.</source>
          <target state="translated">Tambi&amp;eacute;n hay un operador &lt;code&gt;skipUntilWithTime&lt;/code&gt; al que puede pasar un tiempo absoluto o una duraci&amp;oacute;n inicial en lugar de un Observable, pero esto se describe en la p&amp;aacute;gina del operador &lt;a href=&quot;skip&quot;&gt;Skip&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="13c54d80bc681ecd346bb753e654764813e1a20a" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;takeUntilWithTime&lt;/code&gt; operator to which you can pass an absolute time or an initial duration, but this is described on the &lt;a href=&quot;take&quot;&gt;Take&lt;/a&gt; operator page.</source>
          <target state="translated">Tambi&amp;eacute;n hay un operador &lt;code&gt;takeUntilWithTime&lt;/code&gt; al que puede pasar un tiempo absoluto o una duraci&amp;oacute;n inicial, pero esto se describe en la p&amp;aacute;gina del operador &lt;a href=&quot;take&quot;&gt;Take&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="187361ed609c2e791463629d8bb597c987424287" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;throttleFirst&lt;/code&gt; operator, which differs from &lt;code&gt;sample&lt;/code&gt; in that it emits the &lt;em&gt;first&lt;/em&gt; item emitted by the source Observable in each sampling period rather than the &lt;em&gt;most recently emitted&lt;/em&gt; item.</source>
          <target state="translated">Tambi&amp;eacute;n hay un operador &lt;code&gt;throttleFirst&lt;/code&gt; , que se diferencia de la &lt;code&gt;sample&lt;/code&gt; en que emite el &lt;em&gt;primer&lt;/em&gt; elemento emitido por la fuente Observable en cada per&amp;iacute;odo de muestreo en lugar del elemento &lt;em&gt;emitido m&amp;aacute;s recientemente&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6a39d834bd09c5835d19907919ecad6d0b1b92c4" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;throttleFirst&lt;/code&gt; operator, which differs from &lt;code&gt;throttleLast&lt;/code&gt;/&lt;code&gt;sample&lt;/code&gt; in that it emits the &lt;em&gt;first&lt;/em&gt; item emitted by the source Observable in each sampling period rather than the &lt;em&gt;most recently emitted&lt;/em&gt; item.</source>
          <target state="translated">Tambi&amp;eacute;n hay un operador &lt;code&gt;throttleFirst&lt;/code&gt; , que se diferencia de &lt;code&gt;throttleLast&lt;/code&gt; / &lt;code&gt;sample&lt;/code&gt; en que emite el &lt;em&gt;primer&lt;/em&gt; elemento emitido por la fuente Observable en cada per&amp;iacute;odo de muestreo en lugar del elemento &lt;em&gt;emitido m&amp;aacute;s recientemente&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1abf445457383a8d1a550a4666c34b283fc4d7f8" translate="yes" xml:space="preserve">
          <source>There is also a new operator in RxGroovy 1.1 called &lt;code&gt;switchIfEmpty&lt;/code&gt; that, rather than emitting a backup &lt;em&gt;value&lt;/em&gt; if the source Observable terminates without having emitted any items, it emits the emissions from a backup &lt;em&gt;Observable&lt;/em&gt;.</source>
          <target state="translated">Tambi&amp;eacute;n hay un nuevo operador en RxGroovy 1.1 llamado &lt;code&gt;switchIfEmpty&lt;/code&gt; que, en lugar de emitir un &lt;em&gt;valor de&lt;/em&gt; respaldo si la fuente Observable termina sin haber emitido ning&amp;uacute;n elemento, emite las emisiones desde un &lt;em&gt;Observable de&lt;/em&gt; respaldo .</target>
        </trans-unit>
        <trans-unit id="1d407e02d3cef84f4a97e1dea8d87f2761215549" translate="yes" xml:space="preserve">
          <source>There is also a new operator in RxJava 1.1 called &lt;code&gt;switchIfEmpty&lt;/code&gt; that, rather than emitting a backup &lt;em&gt;value&lt;/em&gt; if the source Observable terminates without having emitted any items, it emits the emissions from a backup &lt;em&gt;Observable&lt;/em&gt;.</source>
          <target state="translated">Tambi&amp;eacute;n hay un nuevo operador en RxJava 1.1 llamado &lt;code&gt;switchIfEmpty&lt;/code&gt; que, en lugar de emitir un &lt;em&gt;valor de&lt;/em&gt; respaldo si la fuente Observable termina sin haber emitido ning&amp;uacute;n elemento, emite las emisiones desde un &lt;em&gt;Observable de&lt;/em&gt; respaldo .</target>
        </trans-unit>
        <trans-unit id="88e452542892fa3f048cc208ee51de7ba7b6bfa7" translate="yes" xml:space="preserve">
          <source>There is also a specialized form of the Filter operator in RxGroovy that filters an Observable so that it only emits items of a particular class.</source>
          <target state="translated">También existe una forma especializada del operador del filtro en RxGroovy que filtra un Observable para que sólo emita artículos de una clase particular.</target>
        </trans-unit>
        <trans-unit id="cad5015a738f042fbcc8fcbefa23870ac6109eda" translate="yes" xml:space="preserve">
          <source>There is also a specialized form of the Filter operator in RxJava that filters an Observable so that it only emits items of a particular class.</source>
          <target state="translated">También existe una forma especializada del operador del filtro en RxJava que filtra un Observable para que sólo emita artículos de una clase particular.</target>
        </trans-unit>
        <trans-unit id="30fba8f0a70d3997f65d6c4711bb2800ae22ab62" translate="yes" xml:space="preserve">
          <source>There is also a variant of &lt;code&gt;scan&lt;/code&gt; to which you can pass a seed value to pass to the accumulator function the first time it is called (for the first emission from the source Observable) in place of the result from the missing prior call to the accumulator. Note that if you use this version, &lt;code&gt;scan&lt;/code&gt; will emit this seed value as its own initial emission. Note also that passing a seed of &lt;code&gt;null&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; the same as passing no seed at all. A &lt;code&gt;null&lt;/code&gt; seed is a valid variety of seed.</source>
          <target state="translated">Tambi&amp;eacute;n hay una variante de &lt;code&gt;scan&lt;/code&gt; a la que puede pasar un valor semilla para pasar a la funci&amp;oacute;n del acumulador la primera vez que se llama (para la primera emisi&amp;oacute;n de la fuente Observable) en lugar del resultado de la llamada anterior faltante al acumulador . Tenga en cuenta que si usa esta versi&amp;oacute;n, el &lt;code&gt;scan&lt;/code&gt; emitir&amp;aacute; este valor semilla como su propia emisi&amp;oacute;n inicial. Tenga en cuenta tambi&amp;eacute;n que pasar una semilla de &lt;code&gt;null&lt;/code&gt; &lt;em&gt;no&lt;/em&gt; es &lt;em&gt;lo&lt;/em&gt; mismo que no pasar ninguna semilla. Una semilla &lt;code&gt;null&lt;/code&gt; es una variedad v&amp;aacute;lida de semilla.</target>
        </trans-unit>
        <trans-unit id="c27cc229fc79800fa19cb934a76962c6dbbba751" translate="yes" xml:space="preserve">
          <source>There is also a variant of &lt;code&gt;skip&lt;/code&gt; that takes a temporal duration rather than a quantity of items. It drops those items that are emitted during that initial duration of the source Observable&amp;rsquo;s lifespan. You set this duration by passing in a length of time and the time units this length is denominated in as parameters to &lt;code&gt;skip&lt;/code&gt;.</source>
          <target state="translated">Tambi&amp;eacute;n hay una variante de &lt;code&gt;skip&lt;/code&gt; que tiene una duraci&amp;oacute;n temporal en lugar de una cantidad de elementos. Deja caer los elementos que se emiten durante la duraci&amp;oacute;n inicial de la vida &amp;uacute;til de la fuente Observable. Usted establece esta duraci&amp;oacute;n pasando un per&amp;iacute;odo de tiempo y las unidades de tiempo en las que se denomina este per&amp;iacute;odo como par&amp;aacute;metros para &lt;code&gt;skip&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9feb05589b0e81a02e0e7767bb09a69dfc4a56cf" translate="yes" xml:space="preserve">
          <source>There is also a variant of &lt;code&gt;skipLast&lt;/code&gt; that takes a temporal duration rather than a quantity of items. It drops those items that are emitted during that final duration of the source Observable&amp;rsquo;s lifespan. You set this duration by passing in a length of time and the time units this length is denominated in as parameters to &lt;code&gt;skipLast&lt;/code&gt;.</source>
          <target state="translated">Tambi&amp;eacute;n hay una variante de &lt;code&gt;skipLast&lt;/code&gt; que tiene una duraci&amp;oacute;n temporal en lugar de una cantidad de elementos. Deja caer los elementos que se emiten durante la duraci&amp;oacute;n final de la vida &amp;uacute;til de la fuente Observable. Usted establece esta duraci&amp;oacute;n pasando un per&amp;iacute;odo de tiempo y las unidades de tiempo en las que se denomina este per&amp;iacute;odo como par&amp;aacute;metros para &lt;code&gt;skipLast&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08051516481f1b3895ac9cf3adcd62adbae06014" translate="yes" xml:space="preserve">
          <source>There is also a variant of &lt;code&gt;take&lt;/code&gt; that takes a temporal duration rather than a quantity of items. It results in an Observable that emits only those items that are emitted during that initial duration of the source Observable&amp;rsquo;s lifespan. You set this duration by passing in a length of time and the time units this length is denominated in as parameters to &lt;code&gt;take&lt;/code&gt;.</source>
          <target state="translated">Tambi&amp;eacute;n hay una variante de &lt;code&gt;take&lt;/code&gt; que requiere una duraci&amp;oacute;n temporal en lugar de una cantidad de art&amp;iacute;culos. Da como resultado un Observable que emite solo aquellos elementos que se emiten durante esa duraci&amp;oacute;n inicial de la vida &amp;uacute;til del Observable fuente. Usted establece esta duraci&amp;oacute;n pasando un per&amp;iacute;odo de tiempo y las unidades de tiempo en las que se denomina como par&amp;aacute;metros a &lt;code&gt;take&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="449128271b54eccb75227b4a5514bce689da6853" translate="yes" xml:space="preserve">
          <source>There is also a variant of &lt;code&gt;takeLast&lt;/code&gt; that takes a temporal duration rather than a quantity of items. It emits only those items that are emitted during that final duration of the source Observable&amp;rsquo;s lifespan. You set this duration by passing in a length of time and the time units this length is denominated in as parameters to &lt;code&gt;takeLast&lt;/code&gt;.</source>
          <target state="translated">Tambi&amp;eacute;n hay una variante de &lt;code&gt;takeLast&lt;/code&gt; que tiene una duraci&amp;oacute;n temporal en lugar de una cantidad de elementos. Emite solo aquellos elementos que se emiten durante la duraci&amp;oacute;n final de la vida &amp;uacute;til de la fuente Observable. Usted establece esta duraci&amp;oacute;n pasando un per&amp;iacute;odo de tiempo y las unidades de tiempo en las que se denomina este per&amp;iacute;odo como par&amp;aacute;metros para &lt;code&gt;takeLast&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a59fb0727f4b59bbb076c9c5305d1643bae8cd28" translate="yes" xml:space="preserve">
          <source>There is also a variant of &lt;code&gt;timeout&lt;/code&gt; that both uses a per-item Observable to set the timeout duration and switches to a backup Observable in case of a timeout.</source>
          <target state="translated">Tambi&amp;eacute;n hay una variante de &lt;code&gt;timeout&lt;/code&gt; de espera que usa un Observable por elemento para establecer la duraci&amp;oacute;n del tiempo de espera y cambia a un Observable de respaldo en caso de un tiempo de espera.</target>
        </trans-unit>
        <trans-unit id="031e84f5098d34601fbcb52c5bc13125fa8050ff" translate="yes" xml:space="preserve">
          <source>There is also a variant of &lt;code&gt;timeoutWithSelector&lt;/code&gt; that both uses a per-item Observable to set the timeout duration and switches to a backup Observable in case of a timeout.</source>
          <target state="translated">Tambi&amp;eacute;n hay una variante de &lt;code&gt;timeoutWithSelector&lt;/code&gt; que usa un Observable por elemento para establecer la duraci&amp;oacute;n del tiempo de espera y cambia a un Observable de respaldo en caso de un tiempo de espera.</target>
        </trans-unit>
        <trans-unit id="36700f3cd710204d79349671ecb78d033b6e018a" translate="yes" xml:space="preserve">
          <source>There is also a variant of this operator that takes a function as a parameter. This function operates on items emitted by the source Observable to generate a &amp;ldquo;key.&amp;rdquo; It is these keys, then, and not the items themselves, that &lt;code&gt;distinct&lt;/code&gt; will compare to determine whether or not two items are distinct.</source>
          <target state="translated">Tambi&amp;eacute;n existe una variante de este operador que toma una funci&amp;oacute;n como par&amp;aacute;metro. Esta funci&amp;oacute;n opera sobre elementos emitidos por la fuente Observable para generar una &quot;clave&quot;. Son estas teclas, a continuaci&amp;oacute;n, y no los propios elementos, que &lt;code&gt;distinct&lt;/code&gt; comparar&amp;aacute; para determinar si dos objetos son distintos.</target>
        </trans-unit>
        <trans-unit id="f10041ebeaec7e7413aaa8734dfe5111f3042d93" translate="yes" xml:space="preserve">
          <source>There is also a variant that combines the two methods. It emits the minimum of the number of items emitted during a specified time window &lt;em&gt;or&lt;/em&gt; a particular count of items.</source>
          <target state="translated">Tambi&amp;eacute;n hay una variante que combina los dos m&amp;eacute;todos. Emite el n&amp;uacute;mero m&amp;iacute;nimo de elementos emitidos durante una ventana de tiempo especificada &lt;em&gt;o&lt;/em&gt; un recuento particular de elementos.</target>
        </trans-unit>
        <trans-unit id="0b8726cf18549a2cf1149657d39c80c83857f5b1" translate="yes" xml:space="preserve">
          <source>There is also a variant that takes a function as a parameter. This function takes an emitted item from the source Observable as a parameter and produces the item that will be emitted in its place by the resulting Observable.</source>
          <target state="translated">También hay una variante que toma una función como parámetro.Esta función toma un elemento emitido de la fuente Observable como parámetro y produce el elemento que será emitido en su lugar por el Observable resultante.</target>
        </trans-unit>
        <trans-unit id="dc97cb652e36868458024e656ee272ac5b84c26e" translate="yes" xml:space="preserve">
          <source>There is also a variant that takes a function as a parameter. This function takes as a parameter the &lt;code&gt;ConnectableObservable&lt;/code&gt; that shares a single subscription to the underlying Observable sequence. This function produces and returns a new Observable sequence.</source>
          <target state="translated">Tambi&amp;eacute;n existe una variante que toma una funci&amp;oacute;n como par&amp;aacute;metro. Esta funci&amp;oacute;n toma como par&amp;aacute;metro el &lt;code&gt;ConnectableObservable&lt;/code&gt; que comparte una &amp;uacute;nica suscripci&amp;oacute;n a la secuencia Observable subyacente. Esta funci&amp;oacute;n produce y devuelve una nueva secuencia observable.</target>
        </trans-unit>
        <trans-unit id="e5ae115f084cc2ab1aee05d0a43efa252b4c5426" translate="yes" xml:space="preserve">
          <source>There is also a variety of &lt;code&gt;replay&lt;/code&gt; that returns an ordinary Observable. These variants take as a parameter a transformative function; this function accepts an item emitted by the source Observable as its parameter, and returns an item to be emitted by the resulting Observable. So really, this operator does not replay the source Observable but instead replays the source Observable &lt;em&gt;as transformed&lt;/em&gt; by this function.</source>
          <target state="translated">Tambi&amp;eacute;n hay una variedad de &lt;code&gt;replay&lt;/code&gt; que devuelve un Observable ordinario. Estas variantes toman como par&amp;aacute;metro una funci&amp;oacute;n transformadora; esta funci&amp;oacute;n acepta un elemento emitido por el Observable de origen como par&amp;aacute;metro, y devuelve un elemento para ser emitido por el Observable resultante. Entonces, en realidad, este operador no reproduce la fuente Observable, sino que reproduce la fuente Observable &lt;em&gt;transformada&lt;/em&gt; por esta funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ff00967c6f2b2f7e162cb2796c317c702c4a18eb" translate="yes" xml:space="preserve">
          <source>There is also a variety that takes a &lt;a href=&quot;scheduler&quot;&gt;Scheduler&lt;/a&gt; as an argument:</source>
          <target state="translated">Tambi&amp;eacute;n hay una variedad que toma un &lt;a href=&quot;scheduler&quot;&gt;Programador&lt;/a&gt; como argumento:</target>
        </trans-unit>
        <trans-unit id="6900629b96a56ae8022ad8f2d925a1196485317c" translate="yes" xml:space="preserve">
          <source>There is also a version of &lt;code&gt;delayWithSelector&lt;/code&gt; that takes an additional (first) argument: an Observable that sets a delay before &lt;code&gt;delayWithSelector&lt;/code&gt; subscribes to the source Observable after it itself is subscribed to.</source>
          <target state="translated">Tambi&amp;eacute;n hay una versi&amp;oacute;n de &lt;code&gt;delayWithSelector&lt;/code&gt; que toma un (primer) argumento adicional: un Observable que establece un retraso antes de que &lt;code&gt;delayWithSelector&lt;/code&gt; se suscriba al Observable de origen despu&amp;eacute;s de que se suscriba.</target>
        </trans-unit>
        <trans-unit id="762fea989b34f515305f58f64134c4f4bcc94a1a" translate="yes" xml:space="preserve">
          <source>There is also a version of &lt;code&gt;interval&lt;/code&gt; that returns an Observable that emits a single zero after a specified delay, and then emits incrementally increasing numbers periodically thereafter on a specified periodicity. This version of &lt;code&gt;interval&lt;/code&gt; was called &lt;a href=&quot;timer&quot;&gt;&lt;code&gt;timer&lt;/code&gt;&lt;/a&gt; in RxGroovy 1.0.0, but that method has since been deprecated in favor of the one named &lt;code&gt;interval&lt;/code&gt; with the same behavior.</source>
          <target state="translated">Tambi&amp;eacute;n hay una versi&amp;oacute;n de &lt;code&gt;interval&lt;/code&gt; o que devuelve un Observable que emite un solo cero despu&amp;eacute;s de un retraso espec&amp;iacute;fico, y luego emite n&amp;uacute;meros incrementales de forma peri&amp;oacute;dica a partir de entonces en una periodicidad espec&amp;iacute;fica. Esta versi&amp;oacute;n de &lt;code&gt;interval&lt;/code&gt; o se llam&amp;oacute; &lt;a href=&quot;timer&quot;&gt; &lt;code&gt;timer&lt;/code&gt; &lt;/a&gt; en RxGroovy 1.0.0, pero ese m&amp;eacute;todo ha quedado obsoleto a favor del &lt;code&gt;interval&lt;/code&gt; o con el mismo comportamiento.</target>
        </trans-unit>
        <trans-unit id="522b1ee6207e40a9269cf62e4c01ec31cdfb8604" translate="yes" xml:space="preserve">
          <source>There is also a version of &lt;code&gt;interval&lt;/code&gt; that returns an Observable that emits a single zero after a specified delay, and then emits incrementally increasing numbers periodically thereafter on a specified periodicity. This version of &lt;code&gt;interval&lt;/code&gt; was called &lt;a href=&quot;timer&quot;&gt;&lt;code&gt;timer&lt;/code&gt;&lt;/a&gt; in RxJava 1.0.0, but that method has since been deprecated in favor of the one named &lt;code&gt;interval&lt;/code&gt; with the same behavior.</source>
          <target state="translated">Tambi&amp;eacute;n hay una versi&amp;oacute;n de &lt;code&gt;interval&lt;/code&gt; o que devuelve un Observable que emite un solo cero despu&amp;eacute;s de un retraso espec&amp;iacute;fico, y luego emite n&amp;uacute;meros incrementales de forma peri&amp;oacute;dica a partir de entonces en una periodicidad espec&amp;iacute;fica. Esta versi&amp;oacute;n de &lt;code&gt;interval&lt;/code&gt; o se llam&amp;oacute; &lt;a href=&quot;timer&quot;&gt; &lt;code&gt;timer&lt;/code&gt; &lt;/a&gt; en RxJava 1.0.0, pero ese m&amp;eacute;todo ha quedado obsoleto a favor del &lt;code&gt;interval&lt;/code&gt; o con el mismo comportamiento.</target>
        </trans-unit>
        <trans-unit id="fc631c74156b96e656eb92df791645c1d24072f1" translate="yes" xml:space="preserve">
          <source>There is also a version of &lt;code&gt;reduce&lt;/code&gt; to which you can pass a seed item in addition to an accumulator function. Note that passing a &lt;code&gt;null&lt;/code&gt; seed is not the same as not passing a seed. The behavior will be different. If you pass a seed of &lt;code&gt;null&lt;/code&gt;, you will be seeding your reduction with the item &lt;code&gt;null&lt;/code&gt;. Note also that if you do pass in a seed, and the source Observable emits no items, reduce will emit the seed and complete normally without error.</source>
          <target state="translated">Tambi&amp;eacute;n hay una versi&amp;oacute;n de &lt;code&gt;reduce&lt;/code&gt; a la que puede pasar un elemento semilla adem&amp;aacute;s de una funci&amp;oacute;n de acumulador. Tenga en cuenta que pasar una semilla &lt;code&gt;null&lt;/code&gt; no es lo mismo que no pasar una semilla. El comportamiento ser&amp;aacute; diferente. Si pasa una semilla de &lt;code&gt;null&lt;/code&gt; , sembrar&amp;aacute; su reducci&amp;oacute;n con el elemento &lt;code&gt;null&lt;/code&gt; . Tenga en cuenta tambi&amp;eacute;n que si pasa una semilla y la fuente Observable no emite elementos, reduce emitir&amp;aacute; la semilla y se completar&amp;aacute; normalmente sin errores.</target>
        </trans-unit>
        <trans-unit id="5202b7fb8ff33cff94a68a1b5e152acba79749b9" translate="yes" xml:space="preserve">
          <source>There is also a version of &lt;code&gt;timer&lt;/code&gt; that returns an Observable that emits a single item after a specified delay, and then emits items periodically thereafter on a specified periodicity. In this way it behaves a bit more like the &lt;a href=&quot;interval&quot;&gt;Interval&lt;/a&gt; operator.</source>
          <target state="translated">Tambi&amp;eacute;n hay una versi&amp;oacute;n de &lt;code&gt;timer&lt;/code&gt; que devuelve un Observable que emite un solo elemento despu&amp;eacute;s de un retraso espec&amp;iacute;fico, y luego emite elementos peri&amp;oacute;dicamente a partir de entonces en una periodicidad espec&amp;iacute;fica. De esta forma se comporta un poco m&amp;aacute;s como el operador de &lt;a href=&quot;interval&quot;&gt;intervalo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="539cbb5c3fad3008ba0960da437343ef5a498e5a" translate="yes" xml:space="preserve">
          <source>There is also a version of this operator that allows you to perform the delay on a particular &lt;a href=&quot;scheduler&quot;&gt;Scheduler&lt;/a&gt;:</source>
          <target state="translated">Tambi&amp;eacute;n existe una versi&amp;oacute;n de este operador que le permite realizar el retraso en un &lt;a href=&quot;scheduler&quot;&gt;Programador en&lt;/a&gt; particular :</target>
        </trans-unit>
        <trans-unit id="139c58d44cf810efd4f9f9031e89d1cd0ddb3c18" translate="yes" xml:space="preserve">
          <source>There is also an &lt;code&gt;ofArrayChanges&lt;/code&gt; operator that monitors an Array with the &lt;code&gt;Array.observe&lt;/code&gt; method, and returns an Observable that emits any changes that take place in the array. This operator is found only in the &lt;code&gt;rx.all.js&lt;/code&gt; distribution.</source>
          <target state="translated">Tambi&amp;eacute;n hay un operador &lt;code&gt;ofArrayChanges&lt;/code&gt; que monitorea un Array con el m&amp;eacute;todo &lt;code&gt;Array.observe&lt;/code&gt; y devuelve un Observable que emite cualquier cambio que tenga lugar en el arreglo. Este operador se encuentra solo en la distribuci&amp;oacute;n &lt;code&gt;rx.all.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8eddbc3c124fb70ba958a1ab03bc7c5cb95d456" translate="yes" xml:space="preserve">
          <source>There is also an instance method, &lt;code&gt;concatWith&lt;/code&gt;, such that &lt;code&gt;Observable.concat(a,b)&lt;/code&gt; is equivalent to &lt;code&gt;a.concatWith(b)&lt;/code&gt;.</source>
          <target state="translated">Tambi&amp;eacute;n hay un m&amp;eacute;todo de instancia, &lt;code&gt;concatWith&lt;/code&gt; , tal que &lt;code&gt;Observable.concat(a,b)&lt;/code&gt; es equivalente a &lt;code&gt;a.concatWith(b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38523a50cc8364b3f16b29daf3c937099c5ef9b5" translate="yes" xml:space="preserve">
          <source>There is also an instance version of this operator:</source>
          <target state="translated">También hay una versión de ejemplo de este operador:</target>
        </trans-unit>
        <trans-unit id="a6ab646dfb9f2df1243f7f0eecb8d5ca2c659762" translate="yes" xml:space="preserve">
          <source>There is also an operator called &lt;code&gt;pluck&lt;/code&gt; which is a simpler version of this operator. It transforms the elements emitted by the source Observable by extracting a single named property from those elements and emitting that property in their place.</source>
          <target state="translated">Tambi&amp;eacute;n hay un operador llamado &lt;code&gt;pluck&lt;/code&gt; , que es una versi&amp;oacute;n m&amp;aacute;s simple de este operador. Transforma los elementos emitidos por la fuente Observable extrayendo una sola propiedad nombrada de esos elementos y emitiendo esa propiedad en su lugar.</target>
        </trans-unit>
        <trans-unit id="8a6307e1784a009488a1fd7f31602a8bdede7cc4" translate="yes" xml:space="preserve">
          <source>There is also an operator called &lt;code&gt;repeatWhen&lt;/code&gt;. Rather than buffering and replaying the sequence from the source Observable, it &lt;em&gt;resubscribes&lt;/em&gt; to and mirrors the source Observable, but only conditionally.</source>
          <target state="translated">Tambi&amp;eacute;n hay un operador llamado &lt;code&gt;repeatWhen&lt;/code&gt; . En lugar de almacenar en b&amp;uacute;fer y reproducir la secuencia desde la fuente Observable, se &lt;em&gt;vuelve&lt;/em&gt; a &lt;em&gt;suscribir&lt;/em&gt; y refleja la fuente Observable, pero solo de forma condicional.</target>
        </trans-unit>
        <trans-unit id="92996dc580469547aa517e94605bc5bf1f133e10" translate="yes" xml:space="preserve">
          <source>There is also an operator called &lt;code&gt;takeLastBuffer&lt;/code&gt;. It differs in behavior from &lt;code&gt;takeLast&lt;/code&gt; by emitting its items not individually but collected into a single array of items that is emitted as a single item.</source>
          <target state="translated">Tambi&amp;eacute;n hay un operador llamado &lt;code&gt;takeLastBuffer&lt;/code&gt; . Se diferencia en comportamiento de &lt;code&gt;takeLast&lt;/code&gt; al emitir sus elementos no individualmente, sino recopilados en una &amp;uacute;nica matriz de elementos que se emite como un solo elemento.</target>
        </trans-unit>
        <trans-unit id="e106bef886f7af5b82506fb949433f1cdb132fb9" translate="yes" xml:space="preserve">
          <source>There is also an operator called &lt;code&gt;takeLastBuffer&lt;/code&gt;. It exists in the same set of variants as described above for &lt;code&gt;takeLast&lt;/code&gt;, and only differs in behavior by emitting its items not individually but collected into a single &lt;code&gt;List&lt;/code&gt; of items that is emitted as a single item.</source>
          <target state="translated">Tambi&amp;eacute;n hay un operador llamado &lt;code&gt;takeLastBuffer&lt;/code&gt; . Existe en el mismo conjunto de variantes descrito anteriormente para &lt;code&gt;takeLast&lt;/code&gt; , y solo difiere en el comportamiento al emitir sus elementos no individualmente, sino recopilados en una &amp;uacute;nica &lt;code&gt;List&lt;/code&gt; a de elementos que se emite como un solo elemento.</target>
        </trans-unit>
        <trans-unit id="d13d40451e716541ebf0c6d731751a04de4ef9d8" translate="yes" xml:space="preserve">
          <source>There is also an operator with which you can delay the subscription to the source Observable: &lt;code&gt;delaySubscription&lt;/code&gt;. It accepts parameters that define the amount of time to delay (a quantity of time, and a &lt;code&gt;TimeUnit&lt;/code&gt; that this quantity is denominated in).</source>
          <target state="translated">Tambi&amp;eacute;n hay un operador con el que puede retrasar la suscripci&amp;oacute;n a la fuente Observable: &lt;code&gt;delaySubscription&lt;/code&gt; . Acepta par&amp;aacute;metros que definen la cantidad de tiempo a demorar (una cantidad de tiempo y una &lt;code&gt;TimeUnit&lt;/code&gt; en la que se denomina esta cantidad).</target>
        </trans-unit>
        <trans-unit id="57b225db5c327853ba9175d45fd1a4710008118b" translate="yes" xml:space="preserve">
          <source>These Rx operators allow you to compose asynchronous sequences together in a declarative manner with all the efficiency benefits of callbacks but without the drawbacks of nesting callback handlers that are typically associated with asynchronous systems.</source>
          <target state="translated">Estos operadores Rx permiten componer secuencias asíncronas de manera declarativa con todas las ventajas de eficiencia de las llamadas de retorno pero sin los inconvenientes de anidar los manejadores de llamadas de retorno que se asocian típicamente con los sistemas asíncronos.</target>
        </trans-unit>
        <trans-unit id="b342145d78f94ba5bc005eea9d73e6207c97bba6" translate="yes" xml:space="preserve">
          <source>These are found in the following packages:</source>
          <target state="translated">Estos se encuentran en los siguientes paquetes:</target>
        </trans-unit>
        <trans-unit id="9c99563d62b8dafa8a56d975e28fbd373c39956c" translate="yes" xml:space="preserve">
          <source>These are not part of the core RxJava implementation, but are found as &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;then&lt;/code&gt;, and &lt;code&gt;when&lt;/code&gt; in the &lt;code&gt;rxjava-joins&lt;/code&gt; module.</source>
          <target state="translated">Estos no son parte de la implementaci&amp;oacute;n principal de RxJava, pero se encuentran como &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;then&lt;/code&gt; , y &lt;code&gt;when&lt;/code&gt; en el m&amp;oacute;dulo &lt;code&gt;rxjava-joins&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9a600662c2fc82f13668558f5d63c8a1fcdcd74" translate="yes" xml:space="preserve">
          <source>These operators do not operate by default on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but &lt;code&gt;empty&lt;/code&gt; and &lt;code&gt;error&lt;/code&gt; optionally take a Scheduler as a parameter, and if you pass them a Scheduler they will issue their termination notifications on that Scheduler.</source>
          <target state="translated">Estos operadores no operan por defecto en ning&amp;uacute;n &lt;a href=&quot;../scheduler&quot;&gt;Programador en&lt;/a&gt; particular , pero los &lt;code&gt;empty&lt;/code&gt; y los &lt;code&gt;error&lt;/code&gt; es toman opcionalmente un Programador como par&amp;aacute;metro, y si les pasa un Programador, emitir&amp;aacute;n sus notificaciones de terminaci&amp;oacute;n en ese Programador.</target>
        </trans-unit>
        <trans-unit id="a0c61cebbcf2a1d3434e4df6af333148712f0bf6" translate="yes" xml:space="preserve">
          <source>These operators do not operate by default on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">Estos operadores no operan por defecto en ning&amp;uacute;n &lt;a href=&quot;../scheduler&quot;&gt;Programador en&lt;/a&gt; particular .</target>
        </trans-unit>
        <trans-unit id="cdd5a1235b46cc038c2c8dfd4ff72d2c0352c88b" translate="yes" xml:space="preserve">
          <source>These pages include information about some operators that are not part of the core of ReactiveX but are implemented in one or more of language-specific implementations and/or optional modules.</source>
          <target state="translated">Estas páginas incluyen información sobre algunos operadores que no forman parte del núcleo de ReactiveX pero que se implementan en una o más de las implementaciones de idiomas específicos y/o módulos opcionales.</target>
        </trans-unit>
        <trans-unit id="5c0b03b39df18d437c443c915a55a790fd23c116" translate="yes" xml:space="preserve">
          <source>These two operators are both available in each of the following distributions:</source>
          <target state="translated">Estos dos operadores están disponibles en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="bcbafb20f7ea21b3026c1ebc35afb9f862e6a451" translate="yes" xml:space="preserve">
          <source>They each require one of the following distributions:</source>
          <target state="translated">Cada uno de ellos requiere una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="916223df0a0362f110f17d6ced5cde0a2f3c560d" translate="yes" xml:space="preserve">
          <source>They require one of the following distributions:</source>
          <target state="translated">Requieren una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="08773d29a7c65ab1b76fc7763b4fa5f4dfb28a6f" translate="yes" xml:space="preserve">
          <source>They require one of the following packages:</source>
          <target state="translated">Requieren uno de los siguientes paquetes:</target>
        </trans-unit>
        <trans-unit id="238cc3432981781641c15b8b2183f3d63f5d3335" translate="yes" xml:space="preserve">
          <source>They requires one of the following:</source>
          <target state="translated">Requiere uno de los siguientes requisitos:</target>
        </trans-unit>
        <trans-unit id="44f376b551befd476ffb7da70312237937318ec6" translate="yes" xml:space="preserve">
          <source>This documentation accompanies its explanations with &amp;ldquo;marble diagrams.&amp;rdquo; Here is how marble diagrams represent Observables and transformations of Observables:</source>
          <target state="translated">Esta documentaci&amp;oacute;n acompa&amp;ntilde;a sus explicaciones con &quot;diagramas de m&amp;aacute;rmol&quot;. As&amp;iacute; es como los diagramas de m&amp;aacute;rmol representan Observables y transformaciones de Observables:</target>
        </trans-unit>
        <trans-unit id="5281791692d83f6908a511d623cd74573af6ee17" translate="yes" xml:space="preserve">
          <source>This documentation groups information about &lt;a href=&quot;operators#alphabetical&quot;&gt;the various operators&lt;/a&gt; and examples of their usage into the following pages:</source>
          <target state="translated">Esta documentaci&amp;oacute;n agrupa informaci&amp;oacute;n sobre &lt;a href=&quot;operators#alphabetical&quot;&gt;los distintos operadores&lt;/a&gt; y ejemplos de su uso en las siguientes p&amp;aacute;ginas:</target>
        </trans-unit>
        <trans-unit id="d376cbe36ad100032f76fcc1541bba68f850b7f9" translate="yes" xml:space="preserve">
          <source>This first variant of &lt;code&gt;merge&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">Esta primera variante de &lt;code&gt;merge&lt;/code&gt; se encuentra en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="a5b5cc4b77c771ca16da88c602c7239a8d8f15cf" translate="yes" xml:space="preserve">
          <source>This implementation borrows the confusing nomenclature from Rx.NET, in which &lt;code&gt;onErrorResumeNext&lt;/code&gt; switches to a back-up Observable both on an error &lt;em&gt;and&lt;/em&gt; on a normal, error-free termination of the source Observable.</source>
          <target state="translated">Esta implementaci&amp;oacute;n toma prestada la confusa nomenclatura de Rx.NET, en la que &lt;code&gt;onErrorResumeNext&lt;/code&gt; cambia a un Observable de respaldo tanto en un error &lt;em&gt;como&lt;/em&gt; en una terminaci&amp;oacute;n normal libre de errores del Observable fuente.</target>
        </trans-unit>
        <trans-unit id="ed80ee8261095cde1024407fe495ab29a4c3c56e" translate="yes" xml:space="preserve">
          <source>This implementation introduces a confusing nomenclature, in which in spite of its name &lt;code&gt;OnErrorResumeNext&lt;/code&gt; switches to a back-up Observable both on an error &lt;em&gt;and&lt;/em&gt; on a normal, error-free termination of the source Observable. It is therefore more like a concatenation operator.</source>
          <target state="translated">Esta implementaci&amp;oacute;n introduce una nomenclatura confusa, en la que, a pesar de su nombre, &lt;code&gt;OnErrorResumeNext&lt;/code&gt; cambia a un Observable de respaldo tanto en un error &lt;em&gt;como&lt;/em&gt; en una terminaci&amp;oacute;n normal sin errores de la fuente Observable. Por tanto, se parece m&amp;aacute;s a un operador de concatenaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="0655f655c3305986ec20a3e6752fc22aaa4b2538" translate="yes" xml:space="preserve">
          <source>This method is useful, for example, when you have an Observable that emits a series of items that themselves have Observable members or are in other ways transformable into Observables, so that you can create a new Observable that emits the complete collection of items emitted by the sub-Observables of these items.</source>
          <target state="translated">Este método es útil,por ejemplo,cuando se dispone de un Observador que emite una serie de elementos que a su vez tienen miembros Observables o son de otro modo transformables en Observables,de modo que se puede crear un nuevo Observable que emita la colección completa de elementos emitidos por los sub-Observables de esos elementos.</target>
        </trans-unit>
        <trans-unit id="a30ad7717749cac98edadad7cd7de1d8efe78cb2" translate="yes" xml:space="preserve">
          <source>This operator also takes an optional third parameter: a function that accepts the arguments from the event handler as parameters and returns an item to be emitted by the resulting Observable in place of the event.</source>
          <target state="translated">Este operador también toma un tercer parámetro opcional:una función que acepta los argumentos del manejador de eventos como parámetros y devuelve un elemento para ser emitido por el Observable resultante en lugar del evento.</target>
        </trans-unit>
        <trans-unit id="f5e313c1df6d6f54ad302fc2dedb052cab252e38" translate="yes" xml:space="preserve">
          <source>This operator also takes three additional, optional parameters:</source>
          <target state="translated">Este operador también toma tres parámetros adicionales y opcionales:</target>
        </trans-unit>
        <trans-unit id="851f179b5f78b3880ad3289ce9b914d51abc4285" translate="yes" xml:space="preserve">
          <source>This operator also takes two additional, optional parameters:</source>
          <target state="translated">Este operador también toma dos parámetros adicionales y opcionales:</target>
        </trans-unit>
        <trans-unit id="fcac799407a98fcba63c160676594897d39befce" translate="yes" xml:space="preserve">
          <source>This operator converts an Observable into an &lt;code&gt;Future&lt;/code&gt; that will return the single item emitted by the source Observable. If the source Observable emits more than one item, the &lt;code&gt;Future&lt;/code&gt; will receive an &lt;code&gt;IllegalArgumentException&lt;/code&gt;; if it completes after emitting no items, the &lt;code&gt;Future&lt;/code&gt; will receive a &lt;code&gt;NoSuchElementException&lt;/code&gt;.</source>
          <target state="translated">Este operador convierte un Observable en un &lt;code&gt;Future&lt;/code&gt; que devolver&amp;aacute; el elemento &amp;uacute;nico emitido por la fuente Observable. Si la fuente Observable emite m&amp;aacute;s de un elemento, &lt;code&gt;Future&lt;/code&gt; recibir&amp;aacute; una &lt;code&gt;IllegalArgumentException&lt;/code&gt; ; si se completa despu&amp;eacute;s de no emitir elementos, &lt;code&gt;Future&lt;/code&gt; recibir&amp;aacute; una &lt;code&gt;NoSuchElementException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96728cf23a02c28de0a99116e4e6f37ac9437def" translate="yes" xml:space="preserve">
          <source>This operator converts an Observable into an &lt;code&gt;Iterable&lt;/code&gt; with which you can iterate over the set of items emitted by the source Observable.</source>
          <target state="translated">Este operador convierte un Observable en un &lt;code&gt;Iterable&lt;/code&gt; con el que puedes iterar sobre el conjunto de elementos emitidos por el Observable de origen.</target>
        </trans-unit>
        <trans-unit id="051af4f85d777e94bfacdab9a3b5169cc86dfb4d" translate="yes" xml:space="preserve">
          <source>This operator converts an Observable into an &lt;code&gt;Iterator&lt;/code&gt; with which you can iterate over the set of items emitted by the source Observable.</source>
          <target state="translated">Este operador convierte un Observable en un &lt;code&gt;Iterator&lt;/code&gt; con el que se puede iterar sobre el conjunto de elementos emitidos por el Observable de origen.</target>
        </trans-unit>
        <trans-unit id="7773f8dca511285fc6ff6888904509c3878d7c51" translate="yes" xml:space="preserve">
          <source>This operator does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">Este operador no opera por defecto en ning&amp;uacute;n &lt;a href=&quot;../scheduler&quot;&gt;Programador en&lt;/a&gt; particular .</target>
        </trans-unit>
        <trans-unit id="157b4dc6015159c8ffac986b079921217fd87e4b" translate="yes" xml:space="preserve">
          <source>This operator is not in the RxJava core, but is part of the distinct &lt;code&gt;rxjava-math&lt;/code&gt; module, where it is implemented with four type-specific operators: &lt;code&gt;averageDouble&lt;/code&gt;, &lt;code&gt;averageFloat&lt;/code&gt;, &lt;code&gt;averageInteger&lt;/code&gt;, and &lt;code&gt;averageLong&lt;/code&gt;.</source>
          <target state="translated">Este operador no est&amp;aacute; en el n&amp;uacute;cleo RxJava, pero es parte de la distinta &lt;code&gt;rxjava-math&lt;/code&gt; m&amp;oacute;dulo, donde se implementa con cuatro operadores espec&amp;iacute;ficos del tipo: &lt;code&gt;averageDouble&lt;/code&gt; , &lt;code&gt;averageFloat&lt;/code&gt; , &lt;code&gt;averageInteger&lt;/code&gt; , y &lt;code&gt;averageLong&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="abc6aa7fb60aaaf411d1cdedf546c6eadb42a5b8" translate="yes" xml:space="preserve">
          <source>This operator is not in the RxJava core, but is part of the distinct &lt;code&gt;rxjava-math&lt;/code&gt; module, where it is implemented with four type-specific operators: &lt;code&gt;sumDouble&lt;/code&gt;, &lt;code&gt;sumFloat&lt;/code&gt;, &lt;code&gt;sumInteger&lt;/code&gt;, and &lt;code&gt;sumLong&lt;/code&gt;.</source>
          <target state="translated">Este operador no est&amp;aacute; en el n&amp;uacute;cleo de RxJava, pero es parte del m&amp;oacute;dulo &lt;code&gt;rxjava-math&lt;/code&gt; distinto , donde se implementa con cuatro operadores espec&amp;iacute;ficos de tipo: &lt;code&gt;sumDouble&lt;/code&gt; , &lt;code&gt;sumFloat&lt;/code&gt; , &lt;code&gt;sumInteger&lt;/code&gt; y &lt;code&gt;sumLong&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6de110854ecb7b4ee552a7ef41d8c72018c80ab1" translate="yes" xml:space="preserve">
          <source>This operator operates by default on the &lt;code&gt;timeout&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you can override this by passing in another Scheduler as an optional second parameter.</source>
          <target state="translated">Este operador opera de forma predeterminada en el &lt;a href=&quot;../scheduler&quot;&gt;Programador de &lt;/a&gt; &lt;code&gt;timeout&lt;/code&gt; , pero puede anular esto pasando otro Programador como un segundo par&amp;aacute;metro opcional.</target>
        </trans-unit>
        <trans-unit id="02c50ddd466d3ebbb2748eac79e6fbfb4598c90f" translate="yes" xml:space="preserve">
          <source>This operator takes three additional, optional parameters:</source>
          <target state="translated">Este operador toma tres parámetros adicionales y opcionales:</target>
        </trans-unit>
        <trans-unit id="3dbabee9b79e9df2145ceeeb98aafe6caecdb79f" translate="yes" xml:space="preserve">
          <source>This operator will fail with an &lt;code&gt;IllegalArgumentException&lt;/code&gt; if the source Observable does not emit any items.</source>
          <target state="translated">Este operador fallar&amp;aacute; con una &lt;code&gt;IllegalArgumentException&lt;/code&gt; si la fuente Observable no emite ning&amp;uacute;n elemento.</target>
        </trans-unit>
        <trans-unit id="b104d679edb25132e93ff79622e9a5c691555507" translate="yes" xml:space="preserve">
          <source>This page explains what the reactive pattern is and what Observables and observers are (and how observers subscribe to Observables). Other pages show how you use &lt;a href=&quot;operators&quot;&gt;the variety of Observable operators&lt;/a&gt; to link Observables together and change their behaviors.</source>
          <target state="translated">Esta p&amp;aacute;gina explica qu&amp;eacute; es el patr&amp;oacute;n reactivo y qu&amp;eacute; son los Observables y los observadores (y c&amp;oacute;mo los observadores se suscriben a los Observables). Otras p&amp;aacute;ginas muestran c&amp;oacute;mo usa &lt;a href=&quot;operators&quot;&gt;la variedad de operadores observables&lt;/a&gt; para vincular observables y cambiar sus comportamientos.</target>
        </trans-unit>
        <trans-unit id="c116dd880801c77b8119160bb66b54963e21fff6" translate="yes" xml:space="preserve">
          <source>This page first lists what could be considered the &amp;ldquo;core&amp;rdquo; operators in ReactiveX, and links to pages that have more in-depth information on how these operators work and how particular language-specific ReactiveX versions have implemented these operators.</source>
          <target state="translated">Esta p&amp;aacute;gina primero enumera lo que podr&amp;iacute;an considerarse los operadores &quot;principales&quot; en ReactiveX, y enlaces a p&amp;aacute;ginas que tienen informaci&amp;oacute;n m&amp;aacute;s detallada sobre c&amp;oacute;mo funcionan estos operadores y c&amp;oacute;mo las versiones de ReactiveX espec&amp;iacute;ficas del lenguaje en particular han implementado estos operadores.</target>
        </trans-unit>
        <trans-unit id="77bb9ef85c54fbff31ff241c29acb1a8e1ec2d12" translate="yes" xml:space="preserve">
          <source>This page summarizes The Observable Contract.</source>
          <target state="translated">Esta página resume el Contrato Observable.</target>
        </trans-unit>
        <trans-unit id="8f1eb87eb26b05c1dd9b754759baaa987adf0fc3" translate="yes" xml:space="preserve">
          <source>This page uses Groovy-like pseudocode for its examples, but there are ReactiveX implementations in many languages.</source>
          <target state="translated">Esta página utiliza un pseudocódigo similar al de Groovy para sus ejemplos,pero hay implementaciones de ReactiveX en muchos idiomas.</target>
        </trans-unit>
        <trans-unit id="b8093fb2efdcee4333d8cd01bcaf5d4c8a8678af" translate="yes" xml:space="preserve">
          <source>This second variant of &lt;code&gt;merge&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">Esta segunda variante de &lt;code&gt;merge&lt;/code&gt; se encuentra en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="f5221f3b3887c251e11acd84d5b1946975ecec50" translate="yes" xml:space="preserve">
          <source>This sort of operation is sometimes called &amp;ldquo;accumulate,&amp;rdquo; &amp;ldquo;aggregate,&amp;rdquo; &amp;ldquo;compress,&amp;rdquo; &amp;ldquo;fold,&amp;rdquo; or &amp;ldquo;inject&amp;rdquo; in other contexts.</source>
          <target state="translated">Este tipo de operaci&amp;oacute;n a veces se denomina &quot;acumular&quot;, &quot;agregar&quot;, &quot;comprimir&quot;, &quot;plegar&quot; o &quot;inyectar&quot; en otros contextos.</target>
        </trans-unit>
        <trans-unit id="edafb359c827bcb10eb8a71786f17d2080d73b14" translate="yes" xml:space="preserve">
          <source>This sort of operator is sometimes called an &amp;ldquo;accumulator&amp;rdquo; in other contexts.</source>
          <target state="translated">Este tipo de operador a veces se denomina &quot;acumulador&quot; en otros contextos.</target>
        </trans-unit>
        <trans-unit id="c2561f854f2cc3c3e7da610a0e22ba37f41c88e2" translate="yes" xml:space="preserve">
          <source>This tree can help you find the ReactiveX Observable operator you&amp;rsquo;re looking for.</source>
          <target state="translated">Este &amp;aacute;rbol puede ayudarlo a encontrar el operador ReactiveX Observable que est&amp;aacute; buscando.</target>
        </trans-unit>
        <trans-unit id="705b10f8b5e84a3e1368d87690c43d30829c3378" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;Window&lt;/code&gt; opens a window whenever it observes the &lt;code&gt;windowOpenings&lt;/code&gt; Observable emit an &lt;code&gt;TWindowOpening&lt;/code&gt; object and at the same time calls the &lt;code&gt;windowClosingSelector&lt;/code&gt;, passing it that &lt;code&gt;TWindowOpening&lt;/code&gt; object, to generate a closing Observable associated with that window. When that closing Observable emits a &lt;code&gt;TWindowClosing&lt;/code&gt; object, &lt;code&gt;Window&lt;/code&gt; closes the associated window. Since the closing of currently open windows and the opening of new windows are activities that are regulated by independent Observables, this variant of &lt;code&gt;Window&lt;/code&gt; may create windows that overlap (duplicating items from the source Observable) or that leave gaps (discarding items from the source Observable).</source>
          <target state="translated">Esta variante de &lt;code&gt;Window&lt;/code&gt; abre una ventana cada vez que observa que &lt;code&gt;windowOpenings&lt;/code&gt; Observable emite un objeto &lt;code&gt;TWindowOpening&lt;/code&gt; y al mismo tiempo llama al &lt;code&gt;windowClosingSelector&lt;/code&gt; , pas&amp;aacute;ndole ese objeto &lt;code&gt;TWindowOpening&lt;/code&gt; , para generar un Observable de cierre asociado a esa ventana. Cuando ese Observable de cierre emite un objeto &lt;code&gt;TWindowClosing&lt;/code&gt; , &lt;code&gt;Window&lt;/code&gt; cierra la ventana asociada. Dado que el cierre de ventanas actualmente abiertas y la apertura de nuevas ventanas son actividades que est&amp;aacute;n reguladas por Observables independientes, esta variante de &lt;code&gt;Window&lt;/code&gt; puede crear ventanas que se superponen (duplicando elementos de la fuente Observable) o que dejan espacios (descartando elementos de la fuente Observable).</target>
        </trans-unit>
        <trans-unit id="97bf8eec0e5141569863b0c827f33e4e7d535d42" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;Window&lt;/code&gt; opens its first window immediately and calls the &lt;code&gt;windowClosingSelector&lt;/code&gt; function to obtain a second Observable. Whenever this second Observable emits a &lt;code&gt;TWindowClosing&lt;/code&gt; object, &lt;code&gt;Window&lt;/code&gt; closes the currently open window, and immediately opens a new one. It repeats this process until either Observable terminates. In this way, this variant of &lt;code&gt;Window&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable, until the closing selector observable terminates.</source>
          <target state="translated">Esta variante de &lt;code&gt;Window&lt;/code&gt; abre su primera ventana inmediatamente y llama a la funci&amp;oacute;n &lt;code&gt;windowClosingSelector&lt;/code&gt; para obtener un segundo Observable. Siempre que este segundo Observable emite un objeto &lt;code&gt;TWindowClosing&lt;/code&gt; , &lt;code&gt;Window&lt;/code&gt; cierra la ventana abierta actualmente e inmediatamente abre una nueva. Repite este proceso hasta que termina Observable. De esta forma, esta variante de &lt;code&gt;Window&lt;/code&gt; emite una serie de ventanas no superpuestas cuyas emisiones colectivas se corresponden uno a uno con las de la fuente Observable, hasta que termina el selector de cierre observable.</target>
        </trans-unit>
        <trans-unit id="98502a842a954982b7ce81f17a6a8c51360051d2" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;Window&lt;/code&gt; opens its first window immediately, and thereafter opens a new window every &lt;code&gt;timeShift&lt;/code&gt; period of time (in the form of a &lt;code&gt;TimeSpan&lt;/code&gt; object, and optionally on a particular &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;IScheduler&lt;/code&gt;&lt;/a&gt;). It closes a currently open window after &lt;code&gt;timeSpan&lt;/code&gt; period of time has passed since that window was opened. It will also close any currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. Depending on how you set &lt;code&gt;timeSpan&lt;/code&gt; and &lt;code&gt;timeShift&lt;/code&gt; the windows that result from this operation may overlap or may have gaps.</source>
          <target state="translated">Esta variante de &lt;code&gt;Window&lt;/code&gt; abre su primera ventana inmediatamente y, a partir de entonces, abre una nueva ventana cada per&amp;iacute;odo de tiempo &lt;code&gt;timeShift&lt;/code&gt; (en la forma de un objeto &lt;code&gt;TimeSpan&lt;/code&gt; y, opcionalmente, en un &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;IScheduler&lt;/code&gt; &lt;/a&gt; particular ). Cierra una ventana abierta actualmente despu&amp;eacute;s de que haya &lt;code&gt;timeSpan&lt;/code&gt; per&amp;iacute;odo de tiempo desde que se abri&amp;oacute; esa ventana. Tambi&amp;eacute;n cerrar&amp;aacute; cualquier ventana abierta actualmente si recibe una notificaci&amp;oacute;n de &lt;code&gt;onCompleted&lt;/code&gt; o &lt;code&gt;onError&lt;/code&gt; de la fuente Observable. Dependiendo de c&amp;oacute;mo establezca &lt;code&gt;timeSpan&lt;/code&gt; y &lt;code&gt;timeShift&lt;/code&gt; , las ventanas que resultan de esta operaci&amp;oacute;n pueden superponerse o tener espacios.</target>
        </trans-unit>
        <trans-unit id="4be1faa38714c36860cdde5e7e666e4a6e9464a1" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;Window&lt;/code&gt; opens its first window immediately. It closes the currently open window and immediately opens a new one whenever the current window has emitted &lt;code&gt;count&lt;/code&gt; items. It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. This variant of &lt;code&gt;Window&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">Esta variante de &lt;code&gt;Window&lt;/code&gt; abre su primera ventana inmediatamente. Cierra la ventana actualmente abierta e inmediatamente abre una nueva cada vez que la ventana actual ha emitido elementos de &lt;code&gt;count&lt;/code&gt; . Tambi&amp;eacute;n cerrar&amp;aacute; la ventana abierta actualmente si recibe una notificaci&amp;oacute;n &lt;code&gt;onCompleted&lt;/code&gt; o &lt;code&gt;onError&lt;/code&gt; de la fuente Observable. Esta variante de &lt;code&gt;Window&lt;/code&gt; emite una serie de ventanas no superpuestas cuyas emisiones colectivas se corresponden uno a uno con las de la fuente Observable.</target>
        </trans-unit>
        <trans-unit id="a187c3c7d20ee06b8c8d87d6e5adbb59e83be522" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;Window&lt;/code&gt; opens its first window immediately. It closes the currently open window and opens another one every &lt;code&gt;timeSpan&lt;/code&gt; period of time (in the form of a &lt;code&gt;TimeSpan&lt;/code&gt; object, and optionally on a particular &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;IScheduler&lt;/code&gt;&lt;/a&gt;) or whenever the currently open window has emitted &lt;code&gt;count&lt;/code&gt; items. It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. This variant of &lt;code&gt;window&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">Esta variante de &lt;code&gt;Window&lt;/code&gt; abre su primera ventana inmediatamente. Cierra la ventana abierta actualmente y abre otra cada per&amp;iacute;odo &lt;code&gt;timeSpan&lt;/code&gt; de tiempo (en forma de un objeto &lt;code&gt;TimeSpan&lt;/code&gt; , y opcionalmente en un &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;IScheduler&lt;/code&gt; &lt;/a&gt; particular ) o siempre que la ventana abierta actualmente ha emitido elementos de &lt;code&gt;count&lt;/code&gt; . Tambi&amp;eacute;n cerrar&amp;aacute; la ventana abierta actualmente si recibe una notificaci&amp;oacute;n &lt;code&gt;onCompleted&lt;/code&gt; o &lt;code&gt;onError&lt;/code&gt; de la fuente Observable. Esta variante de &lt;code&gt;window&lt;/code&gt; emite una serie de ventanas no superpuestas cuyas emisiones colectivas se corresponden uno a uno con las de la fuente Observable.</target>
        </trans-unit>
        <trans-unit id="55396b207982a5418912406d3afd4bff84fde485" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;Window&lt;/code&gt; opens its first window immediately. It closes the currently open window and opens another one every &lt;code&gt;timespan&lt;/code&gt; period of time (in the form of a &lt;code&gt;TimeSpan&lt;/code&gt; object, and optionally on a particular &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;IScheduler&lt;/code&gt;&lt;/a&gt;). It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. This variant of &lt;code&gt;Window&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">Esta variante de &lt;code&gt;Window&lt;/code&gt; abre su primera ventana inmediatamente. Se cierra la ventana actualmente abierta y otra se abre cada &lt;code&gt;timespan&lt;/code&gt; per&amp;iacute;odo de tiempo (en la forma de un &lt;code&gt;TimeSpan&lt;/code&gt; objeto, y, opcionalmente, en un determinado &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;IScheduler&lt;/code&gt; &lt;/a&gt; ). Tambi&amp;eacute;n cerrar&amp;aacute; la ventana abierta actualmente si recibe una notificaci&amp;oacute;n &lt;code&gt;onCompleted&lt;/code&gt; o &lt;code&gt;onError&lt;/code&gt; de la fuente Observable. Esta variante de &lt;code&gt;Window&lt;/code&gt; emite una serie de ventanas no superpuestas cuyas emisiones colectivas se corresponden uno a uno con las de la fuente Observable.</target>
        </trans-unit>
        <trans-unit id="e6921e1d3d31550d1a98f0a86ca02bb1cd8c8379" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;Window&lt;/code&gt; opens its first window immediately. It opens a new window beginning with every &lt;code&gt;skip&lt;/code&gt; item from the source Observable (so, for example, if &lt;code&gt;skip&lt;/code&gt; is 3, then it opens a new window starting with every third item). It closes each window when that window has emitted &lt;code&gt;count&lt;/code&gt; items or if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. If &lt;code&gt;skip&amp;nbsp;=&amp;nbsp;count&lt;/code&gt; then this behaves the same as &lt;code&gt;Window(source,&amp;nbsp;count)&lt;/code&gt;; if &lt;code&gt;skip&amp;nbsp;&amp;lt;&amp;nbsp;count&lt;/code&gt; this will emit windows that overlap by &lt;code&gt;count&amp;nbsp;&amp;minus;&amp;nbsp;skip&lt;/code&gt; items; if &lt;code&gt;skip&amp;nbsp;&amp;gt;&amp;nbsp;count&lt;/code&gt; this will emit windows that drop &lt;code&gt;skip&amp;nbsp;&amp;minus;&amp;nbsp;count&lt;/code&gt; items from the source Observable between every window.</source>
          <target state="translated">Esta variante de &lt;code&gt;Window&lt;/code&gt; abre su primera ventana inmediatamente. Abre una nueva ventana que comienza con cada elemento &lt;code&gt;skip&lt;/code&gt; de la fuente Observable (por ejemplo, si &lt;code&gt;skip&lt;/code&gt; es 3, entonces abre una nueva ventana comenzando con cada tercer elemento). Cierra cada ventana cuando esa ventana ha emitido elementos de &lt;code&gt;count&lt;/code&gt; o si recibe una notificaci&amp;oacute;n de &lt;code&gt;onCompleted&lt;/code&gt; o &lt;code&gt;onError&lt;/code&gt; de la fuente Observable. Si &lt;code&gt;skip&amp;nbsp;=&amp;nbsp;count&lt;/code&gt; entonces esto se comporta igual que &lt;code&gt;Window(source,&amp;nbsp;count)&lt;/code&gt; ; si &lt;code&gt;skip&amp;nbsp;&amp;lt;&amp;nbsp;count&lt;/code&gt; esto emitir&amp;aacute; ventanas que se superponen por &lt;code&gt;count&amp;nbsp;&amp;minus;&amp;nbsp;skip&lt;/code&gt; elementos; si &lt;code&gt;skip&amp;nbsp;&amp;gt;&amp;nbsp;count&lt;/code&gt; esto emitir&amp;aacute; ventanas que &lt;code&gt;skip&amp;nbsp;&amp;minus;&amp;nbsp;count&lt;/code&gt; elementos de la fuente Observable entre cada ventana.</target>
        </trans-unit>
        <trans-unit id="c860df6d9d7d7bbc4dffd959fc12e6ab3d15a2a4" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;debounce&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">Esta variante de &lt;code&gt;debounce&lt;/code&gt; no opera por defecto en ning&amp;uacute;n &lt;a href=&quot;../scheduler&quot;&gt;Programador en&lt;/a&gt; particular .</target>
        </trans-unit>
        <trans-unit id="bd2f07d1f74443fcca4dba475d554c45d9fefa68" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;delay&lt;/code&gt; by default runs on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you can choose a different Scheduler by passing it in as an optional third parameter to &lt;code&gt;delaySubscription&lt;/code&gt;.</source>
          <target state="translated">Esta variante de &lt;code&gt;delay&lt;/code&gt; ejecuta de forma predeterminada en el &lt;a href=&quot;../scheduler&quot;&gt;Programador de &lt;/a&gt; &lt;code&gt;computation&lt;/code&gt; , pero puede elegir un Programador diferente pas&amp;aacute;ndolo como un tercer par&amp;aacute;metro opcional para &lt;code&gt;delaySubscription&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89a735f7a290a0e3c83a8ff7f0b53d700ad552f6" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;delay&lt;/code&gt; does not by default run on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">Esta variante de &lt;code&gt;delay&lt;/code&gt; no se ejecuta de forma predeterminada en ning&amp;uacute;n &lt;a href=&quot;../scheduler&quot;&gt;Programador en&lt;/a&gt; particular .</target>
        </trans-unit>
        <trans-unit id="737ad7a4d0393add7f03cd203a8047bab096ef18" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;delaySubscription&lt;/code&gt; does not by default run on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">Esta variante de &lt;code&gt;delaySubscription&lt;/code&gt; no se ejecuta de forma predeterminada en ning&amp;uacute;n &lt;a href=&quot;../scheduler&quot;&gt;Programador en&lt;/a&gt; particular .</target>
        </trans-unit>
        <trans-unit id="e6803b366342fa051633884e5aa522cd6078903e" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;sample&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">Esta variante de &lt;code&gt;sample&lt;/code&gt; no opera por defecto en ning&amp;uacute;n &lt;a href=&quot;../scheduler&quot;&gt;Programador en&lt;/a&gt; particular .</target>
        </trans-unit>
        <trans-unit id="cf012d47d4bc079503c714e892ebcb4fd79c0201" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;sample&lt;/code&gt; operates by default on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you can optionally pass in a Scheduler of your choosing as a third parameter.</source>
          <target state="translated">Esta variante de &lt;code&gt;sample&lt;/code&gt; funciona de forma predeterminada en el &lt;a href=&quot;../scheduler&quot;&gt;programador de &lt;/a&gt; &lt;code&gt;computation&lt;/code&gt; , pero opcionalmente puede pasar un programador de su elecci&amp;oacute;n como tercer par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="409de3ece48bb2e6d1feb6d3bcfc772fcf41dff8" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;skip&lt;/code&gt; by default operates on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you may also pass in a Scheduler of your choosing as an optional third parameter.</source>
          <target state="translated">Esta variante de &lt;code&gt;skip&lt;/code&gt; por defecto opera en el &lt;a href=&quot;../scheduler&quot;&gt;Programador de &lt;/a&gt; &lt;code&gt;computation&lt;/code&gt; , pero tambi&amp;eacute;n puede pasar un Programador de su elecci&amp;oacute;n como un tercer par&amp;aacute;metro opcional.</target>
        </trans-unit>
        <trans-unit id="e994cf05c6f2a358611ec5ee6d239a28c7c8c490" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;skip&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">Esta variante de &lt;code&gt;skip&lt;/code&gt; no funciona por defecto en ning&amp;uacute;n &lt;a href=&quot;../scheduler&quot;&gt;Programador en&lt;/a&gt; particular .</target>
        </trans-unit>
        <trans-unit id="d44643f63e5b34f4e84daa5e287555095a653012" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;skipLast&lt;/code&gt; by default operates on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you may also pass in a Scheduler of your choosing as an optional third parameter.</source>
          <target state="translated">Esta variante de &lt;code&gt;skipLast&lt;/code&gt; por defecto opera en el &lt;a href=&quot;../scheduler&quot;&gt;Programador de &lt;/a&gt; &lt;code&gt;computation&lt;/code&gt; , pero tambi&amp;eacute;n puede pasar un Programador de su elecci&amp;oacute;n como un tercer par&amp;aacute;metro opcional.</target>
        </trans-unit>
        <trans-unit id="653a339a6c160863b57c50e0518e6c234f4a2fbd" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;skipLast&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">Esta variante de &lt;code&gt;skipLast&lt;/code&gt; no opera por defecto en ning&amp;uacute;n &lt;a href=&quot;../scheduler&quot;&gt;Programador en&lt;/a&gt; particular .</target>
        </trans-unit>
        <trans-unit id="a92f18fffbf6ac36d3ae397e2077eac1256c5a95" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;sliding&lt;/code&gt; opens a window whenever it observes the &lt;code&gt;openings&lt;/code&gt; Observable emit an &lt;code&gt;Opening&lt;/code&gt; object and at the same time calls &lt;code&gt;closings&lt;/code&gt; to generate a closing Observable associated with that window. When that closing Observable emits an item, &lt;code&gt;sliding&lt;/code&gt; closes that window.</source>
          <target state="translated">Esta variante de &lt;code&gt;sliding&lt;/code&gt; abre una ventana cada vez que observa las &lt;code&gt;openings&lt;/code&gt; Observable emiten un objeto &lt;code&gt;Opening&lt;/code&gt; y al mismo tiempo llama &lt;code&gt;closings&lt;/code&gt; para generar un Observable de cierre asociado a esa ventana. Cuando ese Observable de cierre emite un elemento, el &lt;code&gt;sliding&lt;/code&gt; cierra esa ventana.</target>
        </trans-unit>
        <trans-unit id="9d7114d84069bab442e1a2baecd16659f4731291" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;sliding&lt;/code&gt; opens its first window immediately, and thereafter opens a new window every &lt;code&gt;timeshift&lt;/code&gt; period of time (in the form of a &lt;code&gt;Duration&lt;/code&gt; object, and optionally on a particular &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt;). It closes a currently open window after &lt;code&gt;timespan&lt;/code&gt; period of time has passed since that window was opened or once &lt;code&gt;count&lt;/code&gt; items have been emitted on that window. It will also close any currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable.</source>
          <target state="translated">Esta variante de &lt;code&gt;sliding&lt;/code&gt; abre su primera ventana inmediatamente y, a partir de entonces, abre una nueva ventana cada per&amp;iacute;odo de tiempo de &lt;code&gt;timeshift&lt;/code&gt; de tiempo (en forma de un objeto &lt;code&gt;Duration&lt;/code&gt; y, opcionalmente, en un &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; particular ). Se cierra una ventana actualmente abierta despu&amp;eacute;s de &lt;code&gt;timespan&lt;/code&gt; de tiempo ha pasado desde esa ventana se abri&amp;oacute; o una vez &lt;code&gt;count&lt;/code&gt; art&amp;iacute;culos han sido emitida en esa ventana. Tambi&amp;eacute;n cerrar&amp;aacute; cualquier ventana abierta actualmente si recibe una notificaci&amp;oacute;n de &lt;code&gt;onCompleted&lt;/code&gt; o &lt;code&gt;onError&lt;/code&gt; de la fuente Observable.</target>
        </trans-unit>
        <trans-unit id="48c41e41d48a655cf8b2b53aa6dc1febc83b8551" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;sliding&lt;/code&gt; opens its first window immediately, and thereafter opens a new window every &lt;code&gt;timeshift&lt;/code&gt; period of time (in the form of a &lt;code&gt;Duration&lt;/code&gt; object, and optionally on a particular &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt;). It closes a currently open window after &lt;code&gt;timespan&lt;/code&gt; period of time has passed since that window was opened. It will also close any currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable.</source>
          <target state="translated">Esta variante de &lt;code&gt;sliding&lt;/code&gt; abre su primera ventana inmediatamente y, a partir de entonces, abre una nueva ventana cada per&amp;iacute;odo de tiempo de &lt;code&gt;timeshift&lt;/code&gt; de tiempo (en forma de un objeto &lt;code&gt;Duration&lt;/code&gt; y, opcionalmente, en un &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; particular ). Se cierra una ventana actualmente abierta despu&amp;eacute;s de &lt;code&gt;timespan&lt;/code&gt; periodo de tiempo ha pasado desde que se abri&amp;oacute; la ventana. Tambi&amp;eacute;n cerrar&amp;aacute; cualquier ventana abierta actualmente si recibe una notificaci&amp;oacute;n de &lt;code&gt;onCompleted&lt;/code&gt; o &lt;code&gt;onError&lt;/code&gt; de la fuente Observable.</target>
        </trans-unit>
        <trans-unit id="7c928da076f93edde2602acc469e63d58409880b" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;sliding&lt;/code&gt; opens its first window immediately. It opens a new window beginning with every &lt;code&gt;skip&lt;/code&gt; item from the source Observable (so, for example, if &lt;code&gt;skip&lt;/code&gt; is 3, then it opens a new window starting with every third item). It closes each window when that window has emitted &lt;code&gt;count&lt;/code&gt; items or if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. If &lt;code&gt;skip&amp;nbsp;=&amp;nbsp;count&lt;/code&gt; then this behaves the same as &lt;code&gt;tumbling(count)&lt;/code&gt;; if &lt;code&gt;skip&amp;nbsp;&amp;lt;&amp;nbsp;count&lt;/code&gt; this will emit windows that overlap by &lt;code&gt;count&amp;nbsp;&amp;minus;&amp;nbsp;skip&lt;/code&gt; items; if &lt;code&gt;skip&amp;nbsp;&amp;gt;&amp;nbsp;count&lt;/code&gt; this will emit windows that drop &lt;code&gt;skip&amp;nbsp;&amp;minus;&amp;nbsp;count&lt;/code&gt; items from the source Observable between every window.</source>
          <target state="translated">Esta variante de &lt;code&gt;sliding&lt;/code&gt; abre su primera ventana inmediatamente. Abre una nueva ventana que comienza con cada elemento &lt;code&gt;skip&lt;/code&gt; de la fuente Observable (por ejemplo, si &lt;code&gt;skip&lt;/code&gt; es 3, entonces abre una nueva ventana comenzando con cada tercer elemento). Cierra cada ventana cuando esa ventana ha emitido elementos de &lt;code&gt;count&lt;/code&gt; o si recibe una notificaci&amp;oacute;n de &lt;code&gt;onCompleted&lt;/code&gt; o &lt;code&gt;onError&lt;/code&gt; de la fuente Observable. Si &lt;code&gt;skip&amp;nbsp;=&amp;nbsp;count&lt;/code&gt; entonces esto se comporta de la misma manera que &lt;code&gt;tumbling(count)&lt;/code&gt; ; si &lt;code&gt;skip&amp;nbsp;&amp;lt;&amp;nbsp;count&lt;/code&gt; esto emitir&amp;aacute; ventanas que se superponen por &lt;code&gt;count&amp;nbsp;&amp;minus;&amp;nbsp;skip&lt;/code&gt; elementos; si &lt;code&gt;skip&amp;nbsp;&amp;gt;&amp;nbsp;count&lt;/code&gt; esto emitir&amp;aacute; ventanas que &lt;code&gt;skip&amp;nbsp;&amp;minus;&amp;nbsp;count&lt;/code&gt; elementos de la fuente Observable entre cada ventana.</target>
        </trans-unit>
        <trans-unit id="89dff3742ba07b7efcc661354ebd2e40382e8a0b" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;take&lt;/code&gt; by default operates on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you may also pass in a Scheduler of your choosing as an optional third parameter.</source>
          <target state="translated">Esta variante de &lt;code&gt;take&lt;/code&gt; por defecto en el &lt;a href=&quot;../scheduler&quot;&gt;programador de &lt;/a&gt; &lt;code&gt;computation&lt;/code&gt; , pero tambi&amp;eacute;n puede pasar un programador de su elecci&amp;oacute;n como tercer par&amp;aacute;metro opcional.</target>
        </trans-unit>
        <trans-unit id="c4faaa677832834fcac1002f1aa24a6e5a6b22a9" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;take&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">Esta variante de &lt;code&gt;take&lt;/code&gt; no opera por defecto en ning&amp;uacute;n &lt;a href=&quot;../scheduler&quot;&gt;Programador en&lt;/a&gt; particular .</target>
        </trans-unit>
        <trans-unit id="657acbff045486dbea7d27744af10d6c32942c62" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;takeLast&lt;/code&gt; by default operates on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you may also pass in a Scheduler of your choosing as an optional fourth parameter.</source>
          <target state="translated">Esta variante de &lt;code&gt;takeLast&lt;/code&gt; opera de forma predeterminada en el &lt;a href=&quot;../scheduler&quot;&gt;Programador de &lt;/a&gt; &lt;code&gt;computation&lt;/code&gt; , pero tambi&amp;eacute;n puede pasar un Programador de su elecci&amp;oacute;n como un cuarto par&amp;aacute;metro opcional.</target>
        </trans-unit>
        <trans-unit id="72f2d252be7ba01ae12dd933d1af12d7f39d6950" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;takeLast&lt;/code&gt; by default operates on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you may also pass in a Scheduler of your choosing as an optional third parameter.</source>
          <target state="translated">Esta variante de &lt;code&gt;takeLast&lt;/code&gt; funciona por defecto en el &lt;a href=&quot;../scheduler&quot;&gt;Programador de &lt;/a&gt; &lt;code&gt;computation&lt;/code&gt; , pero tambi&amp;eacute;n puede pasar un Programador de su elecci&amp;oacute;n como tercer par&amp;aacute;metro opcional.</target>
        </trans-unit>
        <trans-unit id="042c56433de6cca61a28e4c7ce8ff88898502335" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;takeLast&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">Esta variante de &lt;code&gt;takeLast&lt;/code&gt; no funciona por defecto en ning&amp;uacute;n &lt;a href=&quot;../scheduler&quot;&gt;Programador en&lt;/a&gt; particular .</target>
        </trans-unit>
        <trans-unit id="dcedede039a8ce96e34904dd498d9372ef230b55" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;timeout&lt;/code&gt; by default runs on the &lt;code&gt;immediate&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">Esta variante de &lt;code&gt;timeout&lt;/code&gt; de espera se ejecuta de forma predeterminada en el &lt;a href=&quot;../scheduler&quot;&gt;Programador &lt;/a&gt; &lt;code&gt;immediate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6e86fc9829ce8349d40eba57712fb2a0d949a58" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;tumbling&lt;/code&gt; opens its first window immediately. It closes the currently open window and immediately opens a new one whenever the current window has emitted &lt;code&gt;count&lt;/code&gt; items. It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable.</source>
          <target state="translated">Esta variante de &lt;code&gt;tumbling&lt;/code&gt; abre su primera ventana inmediatamente. Cierra la ventana actualmente abierta e inmediatamente abre una nueva cada vez que la ventana actual ha emitido elementos de &lt;code&gt;count&lt;/code&gt; . Tambi&amp;eacute;n cerrar&amp;aacute; la ventana abierta actualmente si recibe una notificaci&amp;oacute;n &lt;code&gt;onCompleted&lt;/code&gt; o &lt;code&gt;onError&lt;/code&gt; de la fuente Observable.</target>
        </trans-unit>
        <trans-unit id="6398043bbc04304d7192b07e90caf700ab6ec7c2" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;tumbling&lt;/code&gt; opens its first window immediately. It closes the currently open window and opens another one every &lt;code&gt;timespan&lt;/code&gt; period of time (a &lt;code&gt;Duration&lt;/code&gt;, optionally measured on a particular &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt;) or whenever the currently open window has emitted &lt;code&gt;count&lt;/code&gt; items. It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable.</source>
          <target state="translated">Esta variante de &lt;code&gt;tumbling&lt;/code&gt; abre su primera ventana inmediatamente. Se cierra la ventana actualmente abierta y otra se abre cada &lt;code&gt;timespan&lt;/code&gt; de tiempo (una &lt;code&gt;Duration&lt;/code&gt; , opcionalmente se mide en un determinado &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; ) o cuando la ventana abierta actualmente ha emitido &lt;code&gt;count&lt;/code&gt; art&amp;iacute;culos. Tambi&amp;eacute;n cerrar&amp;aacute; la ventana abierta actualmente si recibe una notificaci&amp;oacute;n &lt;code&gt;onCompleted&lt;/code&gt; o &lt;code&gt;onError&lt;/code&gt; de la fuente Observable.</target>
        </trans-unit>
        <trans-unit id="babbf35991f5d12016aa579a5bae94a4d892870e" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;tumbling&lt;/code&gt; opens its first window immediately. It closes the currently open window and opens another one every &lt;code&gt;timespan&lt;/code&gt; period of time (a &lt;code&gt;Duration&lt;/code&gt;, optionally measured on a particular &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;scheduler&lt;/code&gt;&lt;/a&gt;). It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable.</source>
          <target state="translated">Esta variante de &lt;code&gt;tumbling&lt;/code&gt; abre su primera ventana inmediatamente. Se cierra la ventana actualmente abierta y otra se abre cada &lt;code&gt;timespan&lt;/code&gt; de tiempo (una &lt;code&gt;Duration&lt;/code&gt; , opcionalmente se mide en un determinado &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;scheduler&lt;/code&gt; &lt;/a&gt; ). Tambi&amp;eacute;n cerrar&amp;aacute; la ventana abierta actualmente si recibe una notificaci&amp;oacute;n &lt;code&gt;onCompleted&lt;/code&gt; o &lt;code&gt;onError&lt;/code&gt; de la fuente Observable.</target>
        </trans-unit>
        <trans-unit id="4eb801fd5fc446e3c5fb9debba43462e7277a734" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;tumbling&lt;/code&gt; takes a second Observable as a parameter. Whenever this second Observable emits an item, &lt;code&gt;tumbling&lt;/code&gt; closes the current Observable window (if any) and opens a new one.</source>
          <target state="translated">Esta variante de &lt;code&gt;tumbling&lt;/code&gt; toma un segundo Observable como par&amp;aacute;metro. Siempre que este segundo Observable emite un elemento, la &lt;code&gt;tumbling&lt;/code&gt; cierra la ventana Observable actual (si existe) y abre una nueva.</target>
        </trans-unit>
        <trans-unit id="5f0586c409a4780239731e2c6e0bc0ef9a26ea29" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window&lt;/code&gt; opens a window whenever it observes the &lt;code&gt;windowOpenings&lt;/code&gt; Observable emit an &lt;code&gt;Opening&lt;/code&gt; object and at the same time calls &lt;code&gt;closingSelector&lt;/code&gt; to generate a closing Observable associated with that window. When that closing Observable emits an object, &lt;code&gt;window&lt;/code&gt; closes that window. Since the closing of currently open windows and the opening of new windows are activities that are regulated by independent Observables, this variant of &lt;code&gt;window&lt;/code&gt; may create windows that overlap (duplicating items from the source Observable) or that leave gaps (discarding items from the source Observable).</source>
          <target state="translated">Esta variante de &lt;code&gt;window&lt;/code&gt; abre una ventana cada vez que observa que &lt;code&gt;windowOpenings&lt;/code&gt; Observable emite un objeto de &lt;code&gt;Opening&lt;/code&gt; y al mismo tiempo llama a &lt;code&gt;closingSelector&lt;/code&gt; para generar un Observable de cierre asociado a esa ventana. Cuando ese Observable de cierre emite un objeto, la &lt;code&gt;window&lt;/code&gt; cierra esa ventana. Dado que el cierre de ventanas actualmente abiertas y la apertura de nuevas ventanas son actividades que est&amp;aacute;n reguladas por Observables independientes, esta variante de &lt;code&gt;window&lt;/code&gt; puede crear ventanas que se superponen (duplicando elementos de la fuente Observable) o que dejan espacios (descartando elementos de la fuente Observable ).</target>
        </trans-unit>
        <trans-unit id="91f89b25111f858aab5cff61e3d31bded1300441" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window&lt;/code&gt; opens a window whenever it observes the &lt;code&gt;window_openings&lt;/code&gt; Observable emit an item, and at the same time calls &lt;code&gt;closing_selector&lt;/code&gt; to generate a closing Observable associated with that window. When that closing Observable emits an object, &lt;code&gt;window&lt;/code&gt; closes that window. Since the closing of currently open windows and the opening of new windows are activities that are regulated by independent Observables, this variant of &lt;code&gt;window&lt;/code&gt; may create windows that overlap (duplicating items from the source Observable) or that leave gaps (discarding items from the source Observable).</source>
          <target state="translated">Esta variante de &lt;code&gt;window&lt;/code&gt; abre una ventana cada vez que observa que &lt;code&gt;window_openings&lt;/code&gt; Observable emiten un elemento, y al mismo tiempo llama a &lt;code&gt;closing_selector&lt;/code&gt; para generar un Observable de cierre asociado a esa ventana. Cuando ese Observable de cierre emite un objeto, la &lt;code&gt;window&lt;/code&gt; cierra esa ventana. Dado que el cierre de ventanas actualmente abiertas y la apertura de nuevas ventanas son actividades que est&amp;aacute;n reguladas por Observables independientes, esta variante de &lt;code&gt;window&lt;/code&gt; puede crear ventanas que se superponen (duplicando elementos de la fuente Observable) o que dejan espacios (descartando elementos de la fuente Observable ).</target>
        </trans-unit>
        <trans-unit id="5802a2f459856c9c009c204a82bf912f067a1d03" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window&lt;/code&gt; opens its first window immediately and calls the &lt;code&gt;closing_selector&lt;/code&gt; function to obtain a second Observable. When this second Observable emits an item, &lt;code&gt;window&lt;/code&gt; closes the currently open window, immediately opens a new one, and again calls the &lt;code&gt;closing_selector&lt;/code&gt; function to obtain a fresh Observable. It repeats this process until the source Observable terminates. In this way, this variant of &lt;code&gt;window&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">Esta variante de &lt;code&gt;window&lt;/code&gt; abre su primera ventana inmediatamente y llama a la funci&amp;oacute;n &lt;code&gt;closing_selector&lt;/code&gt; para obtener un segundo Observable. Cuando este segundo Observable emite un elemento, la &lt;code&gt;window&lt;/code&gt; cierra la ventana abierta actualmente, abre inmediatamente una nueva y vuelve a llamar a la funci&amp;oacute;n &lt;code&gt;closing_selector&lt;/code&gt; para obtener un Observable nuevo. Repite este proceso hasta que finaliza la fuente Observable. De esta forma, esta variante de &lt;code&gt;window&lt;/code&gt; emite una serie de ventanas no superpuestas cuyas emisiones colectivas se corresponden uno a uno con las de la fuente Observable.</target>
        </trans-unit>
        <trans-unit id="60b2240495a83527d8abfb8bc8f1f606ce11082c" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window&lt;/code&gt; opens its first window immediately, and thereafter opens a new window every &lt;code&gt;timeshift&lt;/code&gt; period of time (measured in &lt;code&gt;unit&lt;/code&gt;, and optionally on a particular &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt;). It closes a currently open window after &lt;code&gt;timespan&lt;/code&gt; period of time has passed since that window was opened. It will also close any currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. Depending on how you set &lt;code&gt;timespan&lt;/code&gt; and &lt;code&gt;timeshift&lt;/code&gt; the windows that result from this operation may overlap or may have gaps.</source>
          <target state="translated">Esta variante de &lt;code&gt;window&lt;/code&gt; abre su primera ventana inmediatamente y, a partir de entonces, abre una nueva ventana cada per&amp;iacute;odo de tiempo de &lt;code&gt;timeshift&lt;/code&gt; de tiempo (medido en &lt;code&gt;unit&lt;/code&gt; y, opcionalmente, en un &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; particular ). Se cierra una ventana actualmente abierta despu&amp;eacute;s de &lt;code&gt;timespan&lt;/code&gt; periodo de tiempo ha pasado desde que se abri&amp;oacute; la ventana. Tambi&amp;eacute;n cerrar&amp;aacute; cualquier ventana abierta actualmente si recibe una notificaci&amp;oacute;n de &lt;code&gt;onCompleted&lt;/code&gt; o &lt;code&gt;onError&lt;/code&gt; de la fuente Observable. Dependiendo de c&amp;oacute;mo establezca el &lt;code&gt;timespan&lt;/code&gt; y el &lt;code&gt;timeshift&lt;/code&gt; las ventanas que resultan de esta operaci&amp;oacute;n pueden superponerse o pueden tener espacios.</target>
        </trans-unit>
        <trans-unit id="98af2e59befb4b606ae4a25fd5855154e10487fc" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window&lt;/code&gt; opens its first window immediately. It closes the currently open window and immediately opens a new one each time it observes an object emitted by the Observable that is returned from &lt;code&gt;closingSelector&lt;/code&gt;. In this way, this variant of &lt;code&gt;window&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">Esta variante de &lt;code&gt;window&lt;/code&gt; abre su primera ventana inmediatamente. Cierra la ventana actualmente abierta e inmediatamente abre una nueva cada vez que observa un objeto emitido por el Observable que es devuelto por &lt;code&gt;closingSelector&lt;/code&gt; . De esta forma, esta variante de &lt;code&gt;window&lt;/code&gt; emite una serie de ventanas no superpuestas cuyas emisiones colectivas se corresponden uno a uno con las de la fuente Observable.</target>
        </trans-unit>
        <trans-unit id="4ef7ab0b963fc5b8b8684a5afae1268e9e03a08d" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window&lt;/code&gt; opens its first window immediately. It closes the currently open window and immediately opens a new one whenever the current window has emitted &lt;code&gt;count&lt;/code&gt; items. It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. This variant of &lt;code&gt;window&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">Esta variante de &lt;code&gt;window&lt;/code&gt; abre su primera ventana inmediatamente. Cierra la ventana actualmente abierta e inmediatamente abre una nueva cada vez que la ventana actual ha emitido elementos de &lt;code&gt;count&lt;/code&gt; . Tambi&amp;eacute;n cerrar&amp;aacute; la ventana abierta actualmente si recibe una notificaci&amp;oacute;n &lt;code&gt;onCompleted&lt;/code&gt; o &lt;code&gt;onError&lt;/code&gt; de la fuente Observable. Esta variante de &lt;code&gt;window&lt;/code&gt; emite una serie de ventanas no superpuestas cuyas emisiones colectivas se corresponden uno a uno con las de la fuente Observable.</target>
        </trans-unit>
        <trans-unit id="84222676d0cfade4ca7a8b88acdc55ea8a380067" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window&lt;/code&gt; opens its first window immediately. It closes the currently open window and opens another one every &lt;code&gt;timespan&lt;/code&gt; period of time (measured in &lt;code&gt;unit&lt;/code&gt;, and optionally on a particular &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt;) or whenever the currently open window has emitted &lt;code&gt;count&lt;/code&gt; items. It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. This variant of &lt;code&gt;window&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">Esta variante de &lt;code&gt;window&lt;/code&gt; abre su primera ventana inmediatamente. Se cierra la ventana actualmente abierta y otra se abre cada &lt;code&gt;timespan&lt;/code&gt; de tiempo (medido en &lt;code&gt;unit&lt;/code&gt; , y, opcionalmente, en un determinado &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; ) o cuando la ventana abierta actualmente ha emitido &lt;code&gt;count&lt;/code&gt; art&amp;iacute;culos. Tambi&amp;eacute;n cerrar&amp;aacute; la ventana abierta actualmente si recibe una notificaci&amp;oacute;n &lt;code&gt;onCompleted&lt;/code&gt; o &lt;code&gt;onError&lt;/code&gt; de la fuente Observable. Esta variante de &lt;code&gt;window&lt;/code&gt; emite una serie de ventanas no superpuestas cuyas emisiones colectivas se corresponden uno a uno con las de la fuente Observable.</target>
        </trans-unit>
        <trans-unit id="f715198c62a7d5a5035a9d81b75054eaeb4449c4" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window&lt;/code&gt; opens its first window immediately. It closes the currently open window and opens another one every &lt;code&gt;timespan&lt;/code&gt; period of time (measured in &lt;code&gt;unit&lt;/code&gt;, and optionally on a particular &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt;). It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. This variant of &lt;code&gt;window&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">Esta variante de &lt;code&gt;window&lt;/code&gt; abre su primera ventana inmediatamente. Se cierra la ventana actualmente abierta y otra se abre cada &lt;code&gt;timespan&lt;/code&gt; per&amp;iacute;odo de tiempo (medido en &lt;code&gt;unit&lt;/code&gt; , y, opcionalmente, en un determinado &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; ). Tambi&amp;eacute;n cerrar&amp;aacute; la ventana abierta actualmente si recibe una notificaci&amp;oacute;n &lt;code&gt;onCompleted&lt;/code&gt; o &lt;code&gt;onError&lt;/code&gt; de la fuente Observable. Esta variante de &lt;code&gt;window&lt;/code&gt; emite una serie de ventanas no superpuestas cuyas emisiones colectivas se corresponden uno a uno con las de la fuente Observable.</target>
        </trans-unit>
        <trans-unit id="fe556e801e961820cf9915aae7c855117324579e" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window&lt;/code&gt; opens its first window immediately. It opens a new window beginning with every &lt;code&gt;skip&lt;/code&gt; item from the source Observable (so, for example, if &lt;code&gt;skip&lt;/code&gt; is 3, then it opens a new window starting with every third item). It closes each window when that window has emitted &lt;code&gt;count&lt;/code&gt; items or if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. If &lt;code&gt;skip&amp;nbsp;=&amp;nbsp;count&lt;/code&gt; then this behaves the same as &lt;code&gt;window(source,&amp;nbsp;count)&lt;/code&gt;; if &lt;code&gt;skip&amp;nbsp;&amp;lt;&amp;nbsp;count&lt;/code&gt; this will emit windows that overlap by &lt;code&gt;count&amp;nbsp;&amp;minus;&amp;nbsp;skip&lt;/code&gt; items; if &lt;code&gt;skip&amp;nbsp;&amp;gt;&amp;nbsp;count&lt;/code&gt; this will emit windows that drop &lt;code&gt;skip&amp;nbsp;&amp;minus;&amp;nbsp;count&lt;/code&gt; items from the source Observable between every window.</source>
          <target state="translated">Esta variante de &lt;code&gt;window&lt;/code&gt; abre su primera ventana inmediatamente. Abre una nueva ventana que comienza con cada elemento &lt;code&gt;skip&lt;/code&gt; de la fuente Observable (por ejemplo, si &lt;code&gt;skip&lt;/code&gt; es 3, entonces abre una nueva ventana comenzando con cada tercer elemento). Cierra cada ventana cuando esa ventana ha emitido elementos de &lt;code&gt;count&lt;/code&gt; o si recibe una notificaci&amp;oacute;n de &lt;code&gt;onCompleted&lt;/code&gt; o &lt;code&gt;onError&lt;/code&gt; de la fuente Observable. Si &lt;code&gt;skip&amp;nbsp;=&amp;nbsp;count&lt;/code&gt; , esto se comporta igual que la &lt;code&gt;window(source,&amp;nbsp;count)&lt;/code&gt; ; si &lt;code&gt;skip&amp;nbsp;&amp;lt;&amp;nbsp;count&lt;/code&gt; esto emitir&amp;aacute; ventanas que se superponen por &lt;code&gt;count&amp;nbsp;&amp;minus;&amp;nbsp;skip&lt;/code&gt; elementos; si &lt;code&gt;skip&amp;nbsp;&amp;gt;&amp;nbsp;count&lt;/code&gt; esto emitir&amp;aacute; ventanas que &lt;code&gt;skip&amp;nbsp;&amp;minus;&amp;nbsp;count&lt;/code&gt; elementos de la fuente Observable entre cada ventana.</target>
        </trans-unit>
        <trans-unit id="4321575a1449c2aff82db3fafcef6ccd5f15b626" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window&lt;/code&gt; takes a second Observable as a parameter. Whenever this second Observable emits an item, &lt;code&gt;window&lt;/code&gt; closes the current Observable window (if any) and opens a new one.</source>
          <target state="translated">Esta variante de &lt;code&gt;window&lt;/code&gt; toma un segundo Observable como par&amp;aacute;metro. Siempre que este segundo Observable emite un elemento, la &lt;code&gt;window&lt;/code&gt; cierra la ventana Observable actual (si la hubiera) y abre una nueva.</target>
        </trans-unit>
        <trans-unit id="bae85c1387e45e3514474e9f22e4f754bb1fb7fa" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;windowWithCount&lt;/code&gt; opens its first window immediately. It closes the currently open window and immediately opens a new one whenever the current window has emitted &lt;code&gt;count&lt;/code&gt; items. It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. This variant of &lt;code&gt;windowWithCount&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">Esta variante de &lt;code&gt;windowWithCount&lt;/code&gt; abre su primera ventana inmediatamente. Cierra la ventana actualmente abierta e inmediatamente abre una nueva cada vez que la ventana actual ha emitido elementos de &lt;code&gt;count&lt;/code&gt; . Tambi&amp;eacute;n cerrar&amp;aacute; la ventana abierta actualmente si recibe una notificaci&amp;oacute;n &lt;code&gt;onCompleted&lt;/code&gt; o &lt;code&gt;onError&lt;/code&gt; de la fuente Observable. Esta variante de &lt;code&gt;windowWithCount&lt;/code&gt; emite una serie de ventanas no superpuestas cuyas emisiones colectivas se corresponden uno a uno con las de la fuente Observable.</target>
        </trans-unit>
        <trans-unit id="b0481e8b340ae9dd68d446d8a287e4351ba18f18" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;windowWithCount&lt;/code&gt; opens its first window immediately. It opens a new window beginning with every &lt;code&gt;skip&lt;/code&gt; item from the source Observable (so, for example, if &lt;code&gt;skip&lt;/code&gt; is 3, then it opens a new window starting with every third item). It closes each window when that window has emitted &lt;code&gt;count&lt;/code&gt; items or if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. If &lt;code&gt;skip&amp;nbsp;=&amp;nbsp;count&lt;/code&gt; then this behaves the same as &lt;code&gt;windowWithCount(count)&lt;/code&gt;; if &lt;code&gt;skip&amp;nbsp;&amp;lt;&amp;nbsp;count&lt;/code&gt; this will emit windows that overlap by &lt;code&gt;count&amp;nbsp;&amp;minus;&amp;nbsp;skip&lt;/code&gt; items; if &lt;code&gt;skip&amp;nbsp;&amp;gt;&amp;nbsp;count&lt;/code&gt; this will emit windows that drop &lt;code&gt;skip&amp;nbsp;&amp;minus;&amp;nbsp;count&lt;/code&gt; items from the source Observable between every window.</source>
          <target state="translated">Esta variante de &lt;code&gt;windowWithCount&lt;/code&gt; abre su primera ventana inmediatamente. Abre una nueva ventana que comienza con cada elemento &lt;code&gt;skip&lt;/code&gt; de la fuente Observable (por ejemplo, si &lt;code&gt;skip&lt;/code&gt; es 3, entonces abre una nueva ventana comenzando con cada tercer elemento). Cierra cada ventana cuando esa ventana ha emitido elementos de &lt;code&gt;count&lt;/code&gt; o si recibe una notificaci&amp;oacute;n de &lt;code&gt;onCompleted&lt;/code&gt; o &lt;code&gt;onError&lt;/code&gt; de la fuente Observable. Si &lt;code&gt;skip&amp;nbsp;=&amp;nbsp;count&lt;/code&gt; , esto se comporta igual que &lt;code&gt;windowWithCount(count)&lt;/code&gt; ; si &lt;code&gt;skip&amp;nbsp;&amp;lt;&amp;nbsp;count&lt;/code&gt; esto emitir&amp;aacute; ventanas que se superponen por &lt;code&gt;count&amp;nbsp;&amp;minus;&amp;nbsp;skip&lt;/code&gt; elementos; si &lt;code&gt;skip&amp;nbsp;&amp;gt;&amp;nbsp;count&lt;/code&gt; esto emitir&amp;aacute; ventanas que &lt;code&gt;skip&amp;nbsp;&amp;minus;&amp;nbsp;count&lt;/code&gt; elementos de la fuente Observable entre cada ventana.</target>
        </trans-unit>
        <trans-unit id="79476df52b04afcb45a97f5d9a45a69f194d05b3" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;windowWithTime&lt;/code&gt; opens its first window immediately, and thereafter opens a new window every &lt;code&gt;timeshift&lt;/code&gt; milliseconds (optionally measured on a particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;). It closes a currently open window after &lt;code&gt;timespan&lt;/code&gt; milliseconds have passed since that window was opened. It will also close any currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. Depending on how you set &lt;code&gt;timespan&lt;/code&gt; and &lt;code&gt;timeshift&lt;/code&gt; the windows that result from this operation may overlap or may have gaps.</source>
          <target state="translated">Esta variante de &lt;code&gt;windowWithTime&lt;/code&gt; abre su primera ventana inmediatamente, y luego abre una nueva ventana cada milisegundo de &lt;code&gt;timeshift&lt;/code&gt; (opcionalmente medido en un &lt;a href=&quot;../scheduler&quot;&gt;Programador en&lt;/a&gt; particular ). Se cierra una ventana actualmente abierta despu&amp;eacute;s de &lt;code&gt;timespan&lt;/code&gt; milisegundos han transcurrido desde que se abri&amp;oacute; la ventana. Tambi&amp;eacute;n cerrar&amp;aacute; cualquier ventana abierta actualmente si recibe una notificaci&amp;oacute;n de &lt;code&gt;onCompleted&lt;/code&gt; o &lt;code&gt;onError&lt;/code&gt; de la fuente Observable. Dependiendo de c&amp;oacute;mo establezca el &lt;code&gt;timespan&lt;/code&gt; y el &lt;code&gt;timeshift&lt;/code&gt; las ventanas que resultan de esta operaci&amp;oacute;n pueden superponerse o pueden tener espacios.</target>
        </trans-unit>
        <trans-unit id="7f022bb9e774776f440984488040ff5dc6603251" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;windowWithTime&lt;/code&gt; opens its first window immediately. It closes the currently open window and opens another one every &lt;code&gt;timespan&lt;/code&gt; period of time (in milliseconds, optionally measured on a particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;). It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. This variant of &lt;code&gt;windowWithTime&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">Esta variante de &lt;code&gt;windowWithTime&lt;/code&gt; abre su primera ventana inmediatamente. Se cierra la ventana actualmente abierta y otra se abre cada &lt;code&gt;timespan&lt;/code&gt; per&amp;iacute;odo de tiempo (en milisegundos, medida opcionalmente en un determinado &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; ). Tambi&amp;eacute;n cerrar&amp;aacute; la ventana abierta actualmente si recibe una notificaci&amp;oacute;n &lt;code&gt;onCompleted&lt;/code&gt; o &lt;code&gt;onError&lt;/code&gt; de la fuente Observable. Esta variante de &lt;code&gt;windowWithTime&lt;/code&gt; emite una serie de ventanas no superpuestas cuyas emisiones colectivas se corresponden uno a uno con las de la fuente Observable.</target>
        </trans-unit>
        <trans-unit id="e39142cb9f93a3df83e5acda2657507e2deb12aa" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window_with_count&lt;/code&gt; opens its first window immediately. It closes the currently open window and immediately opens a new one whenever the current window has emitted &lt;code&gt;count&lt;/code&gt; items. It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. This variant of &lt;code&gt;window_with_count&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">Esta variante de &lt;code&gt;window_with_count&lt;/code&gt; abre su primera ventana inmediatamente. Cierra la ventana actualmente abierta e inmediatamente abre una nueva cada vez que la ventana actual ha emitido elementos de &lt;code&gt;count&lt;/code&gt; . Tambi&amp;eacute;n cerrar&amp;aacute; la ventana abierta actualmente si recibe una notificaci&amp;oacute;n &lt;code&gt;onCompleted&lt;/code&gt; o &lt;code&gt;onError&lt;/code&gt; de la fuente Observable. Esta variante de &lt;code&gt;window_with_count&lt;/code&gt; emite una serie de ventanas no superpuestas cuyas emisiones colectivas se corresponden uno a uno con las de la fuente Observable.</target>
        </trans-unit>
        <trans-unit id="25854b53587cc3c28ca12fd6dd37ae3bdb7e4600" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window_with_count&lt;/code&gt; opens its first window immediately. It opens a new window beginning with every &lt;code&gt;skip&lt;/code&gt; item from the source Observable (so, for example, if &lt;code&gt;skip&lt;/code&gt; is 3, then it opens a new window starting with every third item). It closes each window when that window has emitted &lt;code&gt;count&lt;/code&gt; items or if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. If &lt;code&gt;skip&amp;nbsp;=&amp;nbsp;count&lt;/code&gt; then this behaves the same as &lt;code&gt;window_with_count(count)&lt;/code&gt;; if &lt;code&gt;skip&amp;nbsp;&amp;lt;&amp;nbsp;count&lt;/code&gt; this will emit windows that overlap by &lt;code&gt;count&amp;nbsp;&amp;minus;&amp;nbsp;skip&lt;/code&gt; items; if &lt;code&gt;skip&amp;nbsp;&amp;gt;&amp;nbsp;count&lt;/code&gt; this will emit windows that drop &lt;code&gt;skip&amp;nbsp;&amp;minus;&amp;nbsp;count&lt;/code&gt; items from the source Observable between every window.</source>
          <target state="translated">Esta variante de &lt;code&gt;window_with_count&lt;/code&gt; abre su primera ventana inmediatamente. Abre una nueva ventana que comienza con cada elemento &lt;code&gt;skip&lt;/code&gt; de la fuente Observable (por ejemplo, si &lt;code&gt;skip&lt;/code&gt; es 3, entonces abre una nueva ventana comenzando con cada tercer elemento). Cierra cada ventana cuando esa ventana ha emitido elementos de &lt;code&gt;count&lt;/code&gt; o si recibe una notificaci&amp;oacute;n de &lt;code&gt;onCompleted&lt;/code&gt; o &lt;code&gt;onError&lt;/code&gt; de la fuente Observable. Si &lt;code&gt;skip&amp;nbsp;=&amp;nbsp;count&lt;/code&gt; , esto se comporta igual que &lt;code&gt;window_with_count(count)&lt;/code&gt; ; si &lt;code&gt;skip&amp;nbsp;&amp;lt;&amp;nbsp;count&lt;/code&gt; esto emitir&amp;aacute; ventanas que se superponen por &lt;code&gt;count&amp;nbsp;&amp;minus;&amp;nbsp;skip&lt;/code&gt; elementos; si &lt;code&gt;skip&amp;nbsp;&amp;gt;&amp;nbsp;count&lt;/code&gt; esto emitir&amp;aacute; ventanas que &lt;code&gt;skip&amp;nbsp;&amp;minus;&amp;nbsp;count&lt;/code&gt; elementos de la fuente Observable entre cada ventana.</target>
        </trans-unit>
        <trans-unit id="cc84f2ccad24fdcfc2f3aff1217a66ac4eb92f9d" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window_with_time&lt;/code&gt; opens its first window immediately. It closes the currently open window after &lt;code&gt;period&lt;/code&gt; amount of time has passed since it was opened, and opens a new window after &lt;code&gt;skip&lt;/code&gt; amount of time has passed since the previous window was opened (both times are Durations, optionally computed by a given Coordination). It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. This variant of &lt;code&gt;window_with_time&lt;/code&gt; may emit windows that overlap or that have gaps, depending on whether &lt;code&gt;skip&lt;/code&gt; is less than or greater than &lt;code&gt;period&lt;/code&gt;.</source>
          <target state="translated">Esta variante de &lt;code&gt;window_with_time&lt;/code&gt; abre su primera ventana inmediatamente. Cierra la ventana abierta actualmente despu&amp;eacute;s de que haya pasado un &lt;code&gt;period&lt;/code&gt; de tiempo desde que se abri&amp;oacute;, y abre una nueva ventana despu&amp;eacute;s de que haya pasado el tiempo de &lt;code&gt;skip&lt;/code&gt; desde que se abri&amp;oacute; la ventana anterior (ambos tiempos son Duraciones, opcionalmente calculadas por una Coordinaci&amp;oacute;n dada). Tambi&amp;eacute;n cerrar&amp;aacute; la ventana abierta actualmente si recibe una notificaci&amp;oacute;n &lt;code&gt;onCompleted&lt;/code&gt; o &lt;code&gt;onError&lt;/code&gt; de la fuente Observable. Esta variante de &lt;code&gt;window_with_time&lt;/code&gt; puede emitir ventanas que se superponen o que tienen espacios, dependiendo de si el &lt;code&gt;skip&lt;/code&gt; es menor o mayor que el &lt;code&gt;period&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da96fc736c7bbd3922e8cf82442d11cbd4e9db04" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window_with_time&lt;/code&gt; opens its first window immediately. It closes the currently open window and opens another one every &lt;code&gt;period&lt;/code&gt; of time (a Duration, optionally computed by a given Coordination). It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. This variant of &lt;code&gt;window_with_time&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">Esta variante de &lt;code&gt;window_with_time&lt;/code&gt; abre su primera ventana inmediatamente. Cierra la ventana abierta actualmente y abre otra cada &lt;code&gt;period&lt;/code&gt; de tiempo (una Duraci&amp;oacute;n, opcionalmente calculada por una Coordinaci&amp;oacute;n dada). Tambi&amp;eacute;n cerrar&amp;aacute; la ventana abierta actualmente si recibe una notificaci&amp;oacute;n &lt;code&gt;onCompleted&lt;/code&gt; o &lt;code&gt;onError&lt;/code&gt; de la fuente Observable. Esta variante de &lt;code&gt;window_with_time&lt;/code&gt; emite una serie de ventanas no superpuestas cuyas emisiones colectivas se corresponden uno a uno con las de la fuente Observable.</target>
        </trans-unit>
        <trans-unit id="98a31bb4d7889c747d26c5c49a2c39000cc2314d" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window_with_time&lt;/code&gt; opens its first window immediately. It closes the currently open window and opens another one every &lt;code&gt;timespan&lt;/code&gt; milliseconds (optionally measured on a particular &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt;). It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. This variant of &lt;code&gt;window_with_time&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">Esta variante de &lt;code&gt;window_with_time&lt;/code&gt; abre su primera ventana inmediatamente. Cierra la ventana abierta actualmente y abre otra cada milisegundos de &lt;code&gt;timespan&lt;/code&gt; (opcionalmente medido en un &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; particular ). Tambi&amp;eacute;n cerrar&amp;aacute; la ventana abierta actualmente si recibe una notificaci&amp;oacute;n &lt;code&gt;onCompleted&lt;/code&gt; o &lt;code&gt;onError&lt;/code&gt; de la fuente Observable. Esta variante de &lt;code&gt;window_with_time&lt;/code&gt; emite una serie de ventanas no superpuestas cuyas emisiones colectivas se corresponden uno a uno con las de la fuente Observable.</target>
        </trans-unit>
        <trans-unit id="167c2d5b150d69824425b44c8ee4f720fa8f197f" translate="yes" xml:space="preserve">
          <source>This variant operates by default on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you can optionally pass in a Scheduler of your choosing as a third parameter.</source>
          <target state="translated">Esta variante opera por defecto en el &lt;a href=&quot;../scheduler&quot;&gt;Programador de &lt;/a&gt; &lt;code&gt;computation&lt;/code&gt; , pero opcionalmente puede pasar un Programador de su elecci&amp;oacute;n como tercer par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="913db6dde43b42bba235483e6967719c230885b6" translate="yes" xml:space="preserve">
          <source>This, too, has a &lt;a href=&quot;scheduler&quot;&gt;Scheduler&lt;/a&gt;-specific version:</source>
          <target state="translated">Esto tambi&amp;eacute;n tiene una versi&amp;oacute;n espec&amp;iacute;fica del &lt;a href=&quot;scheduler&quot;&gt;Programador&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="5319f3b89676bc765e966cae99f6cda9b3be1bc1" translate="yes" xml:space="preserve">
          <source>Throw</source>
          <target state="translated">Throw</target>
        </trans-unit>
        <trans-unit id="e0fdbfae633f2d57c9d587ae320cb30eefd7144d" translate="yes" xml:space="preserve">
          <source>Time shifts the observable sequence by dueTime. The relative time intervals between the values are preserved.</source>
          <target state="translated">El tiempo cambia la secuencia observable por el tiempo debido.Se conservan los intervalos de tiempo relativos entre los valores.</target>
        </trans-unit>
        <trans-unit id="98089835cc8515ca7a14ba6cd9c114f2b93470b4" translate="yes" xml:space="preserve">
          <source>TimeInterval</source>
          <target state="translated">TimeInterval</target>
        </trans-unit>
        <trans-unit id="d4c45de0fe64ac43c72a798c67faaadadfaa1b90" translate="yes" xml:space="preserve">
          <source>Timeout</source>
          <target state="translated">Timeout</target>
        </trans-unit>
        <trans-unit id="c3caddd6872bae63ffdabf37db746583d89bb38d" translate="yes" xml:space="preserve">
          <source>Timeout will cause a Single to abort with an error notification if it does not emit an item in a specified period of time after it is subscribed to. One version allows you to set this time out by means of a number of specified time units:</source>
          <target state="translated">El tiempo de espera hará que un Single aborte con una notificación de error si no emite un artículo en un período de tiempo determinado después de que se haya suscrito.Una versión le permite establecer este tiempo de espera por medio de un número de unidades de tiempo especificado:</target>
        </trans-unit>
        <trans-unit id="9d9cec22f36fd2bb99d5fe8c4723347bec202ca5" translate="yes" xml:space="preserve">
          <source>Timer</source>
          <target state="translated">Timer</target>
        </trans-unit>
        <trans-unit id="19eabc961735d78f12fc7be906ffcb033853cf85" translate="yes" xml:space="preserve">
          <source>Timestamp</source>
          <target state="translated">Timestamp</target>
        </trans-unit>
        <trans-unit id="ae79ea1e9c6391a9ed83a2e18a031b835feec0c9" translate="yes" xml:space="preserve">
          <source>To</source>
          <target state="translated">To</target>
        </trans-unit>
        <trans-unit id="e81ce27655e65ce085099be185ce85b2137f4e73" translate="yes" xml:space="preserve">
          <source>To filter an Observable so that only its first emission is emitted, use the &lt;code&gt;first&lt;/code&gt; operator with no parameters.</source>
          <target state="translated">Para filtrar un Observable de modo que solo se emita su primera emisi&amp;oacute;n, utilice el &lt;code&gt;first&lt;/code&gt; operador sin par&amp;aacute;metros.</target>
        </trans-unit>
        <trans-unit id="677b35ca927e319047d1628f637adc41423b0fc2" translate="yes" xml:space="preserve">
          <source>To filter an Observable so that only its last emission is emitted, use the &lt;code&gt;last&lt;/code&gt; operator with no parameters.</source>
          <target state="translated">Para filtrar un Observable de modo que solo se emita su &amp;uacute;ltima emisi&amp;oacute;n, utilice el &lt;code&gt;last&lt;/code&gt; operador sin par&amp;aacute;metros.</target>
        </trans-unit>
        <trans-unit id="9261d8ddfbd991cfda76aa23a0cd28a0cd4f32c7" translate="yes" xml:space="preserve">
          <source>To retrieve the first emission from a &lt;code&gt;BlockingObservable&lt;/code&gt;, use the &lt;code&gt;first&lt;/code&gt; method with no parameters.</source>
          <target state="translated">Para recuperar la primera emisi&amp;oacute;n de un &lt;code&gt;BlockingObservable&lt;/code&gt; , utilice el &lt;code&gt;first&lt;/code&gt; m&amp;eacute;todo sin par&amp;aacute;metros.</target>
        </trans-unit>
        <trans-unit id="df8a5a9c1edace12c77d1f92a0f265b88fc37580" translate="yes" xml:space="preserve">
          <source>To retrieve the last emission from a &lt;code&gt;BlockingObservable&lt;/code&gt;, use the &lt;code&gt;last&lt;/code&gt; method with no parameters.</source>
          <target state="translated">Para recuperar la &amp;uacute;ltima emisi&amp;oacute;n de un &lt;code&gt;BlockingObservable&lt;/code&gt; , utilice el &lt;code&gt;last&lt;/code&gt; m&amp;eacute;todo sin par&amp;aacute;metros.</target>
        </trans-unit>
        <trans-unit id="e965628b0ee331ec6b34dd39cc3f096b74728b00" translate="yes" xml:space="preserve">
          <source>To schedule recursive calls, you can use &lt;code&gt;schedule&lt;/code&gt; and then &lt;code&gt;schedule(this)&lt;/code&gt; on the Worker object:</source>
          <target state="translated">Para programar llamadas recursivas, puede usar &lt;code&gt;schedule&lt;/code&gt; y luego &lt;code&gt;schedule(this)&lt;/code&gt; en el objeto Trabajador:</target>
        </trans-unit>
        <trans-unit id="1cbffae95212baae30862313515c8962b10bea78" translate="yes" xml:space="preserve">
          <source>To specify on which Scheduler the Observable should invoke its observers&amp;rsquo; &lt;code&gt;onNext&lt;/code&gt;, &lt;code&gt;onCompleted&lt;/code&gt;, and &lt;code&gt;onError&lt;/code&gt; methods, use the &lt;code&gt;observeOn&lt;/code&gt; operator, passing it the appropriate &lt;code&gt;Scheduler&lt;/code&gt;.</source>
          <target state="translated">Para especificar en qu&amp;eacute; Programador el Observable debe invocar los &lt;code&gt;onNext&lt;/code&gt; , &lt;code&gt;onCompleted&lt;/code&gt; y &lt;code&gt;onError&lt;/code&gt; de sus observadores , use el operador &lt;code&gt;observeOn&lt;/code&gt; , pas&amp;aacute;ndole el &lt;code&gt;Scheduler&lt;/code&gt; apropiado .</target>
        </trans-unit>
        <trans-unit id="ecf22e1fc7f54c383e5bc0726b6592466baefc6f" translate="yes" xml:space="preserve">
          <source>To specify on which Scheduler the Observable should operate, use the &lt;code&gt;subscribeOn&lt;/code&gt; operator, passing it the appropriate &lt;code&gt;Scheduler&lt;/code&gt;.</source>
          <target state="translated">Para especificar en qu&amp;eacute; Programador debe operar el Observable, use el operador &lt;code&gt;subscribeOn&lt;/code&gt; , pas&amp;aacute;ndole el &lt;code&gt;Scheduler&lt;/code&gt; apropiado .</target>
        </trans-unit>
        <trans-unit id="f6f987265c853852ce9a93e90c296aeb2f943f0a" translate="yes" xml:space="preserve">
          <source>To specify which Scheduler observers will use to unsubscribe from an Observable, use the &lt;code&gt;unsubscribeOn&lt;/code&gt; operator, passing it the appropriate &lt;code&gt;Scheduler&lt;/code&gt;.</source>
          <target state="translated">Para especificar qu&amp;eacute; observadores del Programador usar&amp;aacute;n para cancelar la suscripci&amp;oacute;n de un Observable, use el operador &lt;code&gt;unsubscribeOn&lt;/code&gt; , pas&amp;aacute;ndole el &lt;code&gt;Scheduler&lt;/code&gt; apropiado .</target>
        </trans-unit>
        <trans-unit id="3adbd9b7c134b35abb9c049ce0a350bfd10d09c0" translate="yes" xml:space="preserve">
          <source>To turn an Observable into a &lt;code&gt;BlockingObservable&lt;/code&gt; so that you can use these methods, you can use either the &lt;code&gt;Observable.toBlocking&lt;/code&gt; or &lt;code&gt;BlockingObservable.from&lt;/code&gt; methods.</source>
          <target state="translated">Para convertir un Observable en un &lt;code&gt;BlockingObservable&lt;/code&gt; para que pueda usar estos m&amp;eacute;todos, puede usar los m&amp;eacute;todos &lt;code&gt;Observable.toBlocking&lt;/code&gt; o &lt;code&gt;BlockingObservable.from&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07edff8c6ab5d2b6ba73b34c78a1792f548b27e1" translate="yes" xml:space="preserve">
          <source>Transforming</source>
          <target state="translated">Transforming</target>
        </trans-unit>
        <trans-unit id="1dd516e9e95628b37e564d8feed261306c719fd5" translate="yes" xml:space="preserve">
          <source>Transforming Observable Items</source>
          <target state="translated">Transformación de los elementos observables</target>
        </trans-unit>
        <trans-unit id="8fb4f0478f90c2349e672d48265339bc5e89dd8a" translate="yes" xml:space="preserve">
          <source>Transforming Observables</source>
          <target state="translated">Transformación de los Observables</target>
        </trans-unit>
        <trans-unit id="cceb13cc487fca5dfa5ce538df3f2cb18dc1bd3f" translate="yes" xml:space="preserve">
          <source>Transforms an observable sequence of observable sequences into an observable sequence producing values only from the most recent observable sequence.</source>
          <target state="translated">Transforma una secuencia observable de secuencias observables en una secuencia observable que produce valores sólo de la secuencia observable más reciente.</target>
        </trans-unit>
        <trans-unit id="29c0474e6e05b94d2f3f5aceab38058a341249ef" translate="yes" xml:space="preserve">
          <source>Under development, but not part of the 1.0 release, is the &lt;code&gt;withLatestFrom&lt;/code&gt; operator. It is similar to &lt;code&gt;combineLatest&lt;/code&gt;, but only emits items when the single source Observable emits an item (not when &lt;em&gt;any&lt;/em&gt; of the Observables that are passed to the operator do, as &lt;code&gt;combineLatest&lt;/code&gt; does).</source>
          <target state="translated">En desarrollo, pero que no forma parte de la versi&amp;oacute;n 1.0, se encuentra el operador &lt;code&gt;withLatestFrom&lt;/code&gt; . Es similar a &lt;code&gt;combineLatest&lt;/code&gt; , pero solo emite elementos cuando el Observable de fuente &amp;uacute;nica emite un elemento (no cuando &lt;em&gt;cualquiera&lt;/em&gt; de los Observables que se pasan al operador lo hace, como &lt;code&gt;combineLatest&lt;/code&gt; hace combineLatest ).</target>
        </trans-unit>
        <trans-unit id="89deecaaba97e73598ad6fd0691e91f89a3e40ac" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;subscribe&lt;/code&gt;, &lt;code&gt;forEach&lt;/code&gt; does not return an object with which you can cancel the subscription. Nor do you have the option of passing a parameter that has this capability. So you should only use this operator if you definitely need to operate on all of the emissions and notifications from the Observable.</source>
          <target state="translated">A diferencia de &lt;code&gt;subscribe&lt;/code&gt; , &lt;code&gt;forEach&lt;/code&gt; no devuelve un objeto con el que pueda cancelar la suscripci&amp;oacute;n. Tampoco tiene la opci&amp;oacute;n de pasar un par&amp;aacute;metro que tenga esta capacidad. Por lo tanto, solo debe usar este operador si definitivamente necesita operar con todas las emisiones y notificaciones del Observable.</target>
        </trans-unit>
        <trans-unit id="834cc0ee6089e541b395509ba562516bcafa78e2" translate="yes" xml:space="preserve">
          <source>Unsubscribe</source>
          <target state="translated">Unsubscribe</target>
        </trans-unit>
        <trans-unit id="0925f1a577d120b3875b4a1d4b2873a36b77c455" translate="yes" xml:space="preserve">
          <source>Unsubscribing</source>
          <target state="translated">Unsubscribing</target>
        </trans-unit>
        <trans-unit id="2c0b5a028cb5b1c2860888c5875c3ebc0d28e8d6" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;length&lt;/code&gt; or &lt;code&gt;size&lt;/code&gt; instead if you want to count &lt;em&gt;all&lt;/em&gt; of the items emitted by the source Observable and emit this count as an Integer, or use &lt;code&gt;longCount&lt;/code&gt; to emit it as a Long.</source>
          <target state="translated">Use &lt;code&gt;length&lt;/code&gt; o &lt;code&gt;size&lt;/code&gt; en su lugar si desea contar &lt;em&gt;todos&lt;/em&gt; los elementos emitidos por la fuente Observable y emitir este conteo como un Integer, o use &lt;code&gt;longCount&lt;/code&gt; para emitirlo como Long.</target>
        </trans-unit>
        <trans-unit id="ab50a163272616dc7b8c326c9fbd42175ec215ad" translate="yes" xml:space="preserve">
          <source>Use that variable and its new value to do something useful.</source>
          <target state="translated">Usar esa variable y su nuevo valor para hacer algo útil.</target>
        </trans-unit>
        <trans-unit id="c25de2e83e9fceeee022a34e378748baf14ac201" translate="yes" xml:space="preserve">
          <source>Using</source>
          <target state="translated">Using</target>
        </trans-unit>
        <trans-unit id="09635283d6617f91ae3f074496d5e16cd86942ea" translate="yes" xml:space="preserve">
          <source>Using Schedulers</source>
          <target state="translated">Uso de los programadores</target>
        </trans-unit>
        <trans-unit id="89189507b2a074e98b2e877227343a6e1f27b3ab" translate="yes" xml:space="preserve">
          <source>Utility</source>
          <target state="translated">Utility</target>
        </trans-unit>
        <trans-unit id="fe106a343476b132e8645607f1656889a1e921e3" translate="yes" xml:space="preserve">
          <source>Utility Operators</source>
          <target state="translated">Operadores de servicios públicos</target>
        </trans-unit>
        <trans-unit id="fbd4e4db25253ae894d708535b43ea5afe51f6bc" translate="yes" xml:space="preserve">
          <source>Variant of distinct that takes a key selector</source>
          <target state="translated">Variante de distinto que toma un selector de claves</target>
        </trans-unit>
        <trans-unit id="7cfbea8206dca5542ac656ab9875b461b78d877f" translate="yes" xml:space="preserve">
          <source>Variant of distinctUntilChanged that takes a key selector and the comparer.</source>
          <target state="translated">Variante del distintivo &quot;Until-Changed&quot; que toma un selector de claves y el comparador.</target>
        </trans-unit>
        <trans-unit id="90783bfae1cb49ec27875b8d80bbd99d15acdda2" translate="yes" xml:space="preserve">
          <source>Variants of this variety of the &lt;code&gt;replay&lt;/code&gt; operator permit you to set a maximum buffer size to limit the number of items &lt;code&gt;replay&lt;/code&gt; will buffer and replay to subsequent observers, and/or to establish a moving time window that defines when emitted items become too old to buffer and replay.</source>
          <target state="translated">Las variantes de esta variedad del operador de &lt;code&gt;replay&lt;/code&gt; permiten establecer un tama&amp;ntilde;o m&amp;aacute;ximo de b&amp;uacute;fer para limitar el n&amp;uacute;mero de elementos que la &lt;code&gt;replay&lt;/code&gt; almacenar&amp;aacute; en b&amp;uacute;fer y la reproducci&amp;oacute;n para los observadores posteriores, y / o para establecer una ventana de tiempo m&amp;oacute;vil que defina cu&amp;aacute;ndo los elementos emitidos se vuelven demasiado antiguos para almacenar en b&amp;uacute;fer y reproducir.</target>
        </trans-unit>
        <trans-unit id="21a0bc424bfc99e307f7ea1edb0fa1c727459368" translate="yes" xml:space="preserve">
          <source>Varieties of Scheduler</source>
          <target state="translated">Variedades de Scheduler</target>
        </trans-unit>
        <trans-unit id="9b1873d552d24b69c5f119a53f0dc296aa04f44e" translate="yes" xml:space="preserve">
          <source>Varieties of Subject</source>
          <target state="translated">Variedades de sujeto</target>
        </trans-unit>
        <trans-unit id="71cd61da34b267e141ea188fbd6c4c966ad1f835" translate="yes" xml:space="preserve">
          <source>When a cold Observable is multicast (when it is converted into a connectable Observable and its &lt;a href=&quot;connect&quot;&gt;Connect&lt;/a&gt; method is called), it effectively becomes hot and for the purposes of backpressure and flow-control it should be treated as a hot Observable.</source>
          <target state="translated">Cuando un Observable fr&amp;iacute;o es multidifusi&amp;oacute;n (cuando se convierte en un Observable conectable y se llama a su m&amp;eacute;todo &lt;a href=&quot;connect&quot;&gt;Connect&lt;/a&gt; ), efectivamente se calienta y, a efectos de contrapresi&amp;oacute;n y control de flujo, debe tratarse como un Observable caliente.</target>
        </trans-unit>
        <trans-unit id="fb6cd998aa458f9efba7d561e3e8223e5f062816" translate="yes" xml:space="preserve">
          <source>When an Observable issues an OnError or OnComplete notification to its observers, this ends the subscription. Observers do not need to issue an Unsubscribe notification to end subscriptions that are ended by the Observable in this way.</source>
          <target state="translated">Cuando un Observador emite una notificación OnError o OnComplete a sus observadores,esto pone fin a la suscripción.Los observadores no necesitan emitir una notificación de Desuscripción para finalizar las suscripciones que el Observador termine de esta manera.</target>
        </trans-unit>
        <trans-unit id="940033d88560c950b008fe5ed51335ed9f76e48b" translate="yes" xml:space="preserve">
          <source>When an observer issues an Unsubscribe notification to an Observable, the Observable will attempt to stop issuing notifications to the observer. It is not guaranteed, however, that the Observable will issue &lt;em&gt;no&lt;/em&gt; notifications to the observer after an observer issues it an Unsubscribe notification.</source>
          <target state="translated">Cuando un observador emite una notificaci&amp;oacute;n de cancelaci&amp;oacute;n de suscripci&amp;oacute;n a un Observable, el Observable intentar&amp;aacute; dejar de enviar notificaciones al observador. No se garantiza, sin embargo, que la emitir&amp;aacute; observable &lt;em&gt;no hay&lt;/em&gt; notificaciones al observador despu&amp;eacute;s de un observador se lo emite una notificaci&amp;oacute;n Cancelar suscripci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7279bc1e33b61d9f42b615948eb053e0be2afe08" translate="yes" xml:space="preserve">
          <source>When an observer subscribes to a &lt;code&gt;BehaviorSubject&lt;/code&gt;, it begins by emitting the item most recently emitted by the source Observable (or a seed/default value if none has yet been emitted) and then continues to emit any other items emitted later by the source Observable(s).</source>
          <target state="translated">Cuando un observador se suscribe a un &lt;code&gt;BehaviorSubject&lt;/code&gt; , comienza emitiendo el elemento emitido m&amp;aacute;s recientemente por la fuente Observable (o una semilla / valor predeterminado si a&amp;uacute;n no se ha emitido ninguno) y luego contin&amp;uacute;a emitiendo cualquier otro elemento emitido m&amp;aacute;s tarde por la fuente Observable ( s).</target>
        </trans-unit>
        <trans-unit id="3e29ec19f330a8a47c44f3b9ef38cc21aace1333" translate="yes" xml:space="preserve">
          <source>When an observer subscribes to the Observable returned from &lt;code&gt;using&lt;/code&gt;, &lt;code&gt;using&lt;/code&gt; will use the Observable factory function to create the Observable the observer will observe, while at the same time using the resource factory function to create whichever resource you have designed it to make. To dispose of the resource, call the &lt;code&gt;dispose&lt;/code&gt; method of the subscription that was returned from the &lt;code&gt;subscribe&lt;/code&gt; call you used to subscribe an observer to the Observable that you modified with &lt;code&gt;using&lt;/code&gt;.</source>
          <target state="translated">Cuando un observador se suscribe al Observable devuelto por el &lt;code&gt;using&lt;/code&gt; , &lt;code&gt;using&lt;/code&gt; usar&amp;aacute; la funci&amp;oacute;n Observable factory para crear el Observable que el observador observar&amp;aacute;, mientras que al mismo tiempo usar&amp;aacute; la funci&amp;oacute;n Resource Factory para crear cualquier recurso para el que haya dise&amp;ntilde;ado. Para deshacerse del recurso, llame al m&amp;eacute;todo de &lt;code&gt;dispose&lt;/code&gt; de la suscripci&amp;oacute;n que se devolvi&amp;oacute; de la llamada de &lt;code&gt;subscribe&lt;/code&gt; que utiliz&amp;oacute; para suscribir un observador al Observable que modific&amp;oacute; con el &lt;code&gt;using&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ddf0d21d9cf8853a081099040075ed5d10c739ad" translate="yes" xml:space="preserve">
          <source>When an observer subscribes to the Observable returned from &lt;code&gt;using&lt;/code&gt;, &lt;code&gt;using&lt;/code&gt; will use the Observable factory function to create the Observable the observer will observe, while at the same time using the resource factory function to create whichever resource you have designed it to make. When the observer unsubscribes from the Observable, or when the Observable terminates (normally or with an error), &lt;code&gt;using&lt;/code&gt; will call the third function to dispose of the resource it created.</source>
          <target state="translated">Cuando un observador se suscribe al Observable devuelto por el &lt;code&gt;using&lt;/code&gt; , &lt;code&gt;using&lt;/code&gt; usar&amp;aacute; la funci&amp;oacute;n Observable factory para crear el Observable que el observador observar&amp;aacute;, mientras que al mismo tiempo usar&amp;aacute; la funci&amp;oacute;n Resource Factory para crear cualquier recurso para el que haya dise&amp;ntilde;ado. Cuando el observador se da de baja del Observable, o cuando el Observable termina (normalmente o con un error), el &lt;code&gt;using&lt;/code&gt; llamar&amp;aacute; a la tercera funci&amp;oacute;n para deshacerse del recurso que cre&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="ec187d7479d038f4317479a80baaa369b7917df2" translate="yes" xml:space="preserve">
          <source>When does an Observable begin emitting its sequence of items? It depends on the Observable. A &amp;ldquo;hot&amp;rdquo; Observable may begin emitting items as soon as it is created, and so any observer who later subscribes to that Observable may start observing the sequence somewhere in the middle. A &amp;ldquo;cold&amp;rdquo; Observable, on the other hand, waits until an observer subscribes to it before it begins to emit items, and so such an observer is guaranteed to see the whole sequence from the beginning.</source>
          <target state="translated">&amp;iquest;Cu&amp;aacute;ndo comienza un Observable a emitir su secuencia de elementos? Depende del Observable. Un Observable &quot;caliente&quot; puede comenzar a emitir elementos tan pronto como se crea, por lo que cualquier observador que luego se suscriba a ese Observable puede comenzar a observar la secuencia en alg&amp;uacute;n lugar intermedio. Un Observable &amp;ldquo;fr&amp;iacute;o&amp;rdquo;, por otro lado, espera hasta que un observador se suscribe antes de que comience a emitir elementos, por lo que se garantiza que ese observador ver&amp;aacute; la secuencia completa desde el principio.</target>
        </trans-unit>
        <trans-unit id="d1411f6748866de181ec109dedca11bfcb102f81" translate="yes" xml:space="preserve">
          <source>When it subscribes to the source Observable, &lt;code&gt;Buffer(bufferClosingSelector)&lt;/code&gt; begins to collect its emissions into an &lt;code&gt;IList&lt;/code&gt;, and it also calls &lt;code&gt;bufferClosingSelector&lt;/code&gt; to generate a second Observable. When this second Observable emits an &lt;code&gt;TBufferClosing&lt;/code&gt; object, &lt;code&gt;Buffer&lt;/code&gt; emits the current &lt;code&gt;IList&lt;/code&gt; and repeats this process: beginning a new &lt;code&gt;IList&lt;/code&gt; and calling &lt;code&gt;bufferClosingSelector&lt;/code&gt; to create a new Observable to monitor. It will do this until the source Observable terminates.</source>
          <target state="translated">Cuando se suscribe a la fuente Observable, &lt;code&gt;Buffer(bufferClosingSelector)&lt;/code&gt; comienza a recopilar sus emisiones en un &lt;code&gt;IList&lt;/code&gt; , y tambi&amp;eacute;n llama a &lt;code&gt;bufferClosingSelector&lt;/code&gt; para generar un segundo Observable. Cuando este segundo Observable emite un objeto &lt;code&gt;TBufferClosing&lt;/code&gt; , &lt;code&gt;Buffer&lt;/code&gt; emite el &lt;code&gt;IList&lt;/code&gt; actual y repite este proceso: comenzar un nuevo &lt;code&gt;IList&lt;/code&gt; y llamar a &lt;code&gt;bufferClosingSelector&lt;/code&gt; para crear un nuevo Observable para monitorear. Har&amp;aacute; esto hasta que la fuente Observable termine.</target>
        </trans-unit>
        <trans-unit id="f7a36d0dfbacea5b279df50792127d6faaec9446" translate="yes" xml:space="preserve">
          <source>When it subscribes to the source Observable, &lt;code&gt;buffer(bufferClosingSelector)&lt;/code&gt; begins to collect its emissions into a &lt;code&gt;List&lt;/code&gt;, and it also calls &lt;code&gt;bufferClosingSelector&lt;/code&gt; to generate a second Observable. When this second Observable emits an &lt;code&gt;TClosing&lt;/code&gt; object, &lt;code&gt;buffer&lt;/code&gt; emits the current &lt;code&gt;List&lt;/code&gt; and repeats this process: beginning a new &lt;code&gt;List&lt;/code&gt; and calling &lt;code&gt;bufferClosingSelector&lt;/code&gt; to create a new Observable to monitor. It will do this until the source Observable terminates.</source>
          <target state="translated">Cuando se suscribe a la fuente Observable, &lt;code&gt;buffer(bufferClosingSelector)&lt;/code&gt; comienza a recolectar sus emisiones en una &lt;code&gt;List&lt;/code&gt; , y tambi&amp;eacute;n llama a &lt;code&gt;bufferClosingSelector&lt;/code&gt; para generar un segundo Observable. Cuando este segundo Observable emite un objeto &lt;code&gt;TClosing&lt;/code&gt; , &lt;code&gt;buffer&lt;/code&gt; emite la &lt;code&gt;List&lt;/code&gt; a actual y repite este proceso: comenzando una nueva &lt;code&gt;List&lt;/code&gt; a y llamando a &lt;code&gt;bufferClosingSelector&lt;/code&gt; para crear un nuevo Observable para monitorear. Har&amp;aacute; esto hasta que la fuente Observable termine.</target>
        </trans-unit>
        <trans-unit id="cc62b05b2653ba0fcc8b376464d1a3e50f84f004" translate="yes" xml:space="preserve">
          <source>When it subscribes to the source Observable, &lt;code&gt;buffer(bufferClosingSelector)&lt;/code&gt; begins to collect its emissions into a collection, and it also calls &lt;code&gt;bufferClosingSelector&lt;/code&gt; to generate a second Observable. When this second Observable emits an item, &lt;code&gt;buffer&lt;/code&gt; emits the current collection and repeats this process: beginning a new collection and calling &lt;code&gt;bufferClosingSelector&lt;/code&gt; to create a new Observable to monitor. It will do this until the source Observable terminates.</source>
          <target state="translated">Cuando se suscribe a la fuente Observable, &lt;code&gt;buffer(bufferClosingSelector)&lt;/code&gt; comienza a recolectar sus emisiones en una colecci&amp;oacute;n, y tambi&amp;eacute;n llama a &lt;code&gt;bufferClosingSelector&lt;/code&gt; para generar un segundo Observable. Cuando este segundo Observable emite un elemento, &lt;code&gt;buffer&lt;/code&gt; emite la colecci&amp;oacute;n actual y repite este proceso: comenzar una nueva colecci&amp;oacute;n y llamar a &lt;code&gt;bufferClosingSelector&lt;/code&gt; para crear un nuevo Observable para monitorear. Har&amp;aacute; esto hasta que la fuente Observable termine.</target>
        </trans-unit>
        <trans-unit id="ffdd1094f76c4718e1dd27eb3b69f05cf8376978" translate="yes" xml:space="preserve">
          <source>When you pass a number of source Observables to Amb, it will pass through the emissions and notifications of exactly one of these Observables: the first one that sends a notification to Amb, either by emitting an item or sending an &lt;code&gt;onError&lt;/code&gt; or &lt;code&gt;onCompleted&lt;/code&gt; notification. Amb will ignore and discard the emissions and notifications of all of the other source Observables.</source>
          <target state="translated">Cuando pasa una cantidad de Observables de origen a Amb, pasar&amp;aacute; a trav&amp;eacute;s de las emisiones y notificaciones de exactamente uno de estos Observables: el primero que env&amp;iacute;a una notificaci&amp;oacute;n a Amb, ya sea emitiendo un elemento o enviando una notificaci&amp;oacute;n &lt;code&gt;onError&lt;/code&gt; o &lt;code&gt;onCompleted&lt;/code&gt; . Amb ignorar&amp;aacute; y descartar&amp;aacute; las emisiones y notificaciones de todas las dem&amp;aacute;s fuentes Observables.</target>
        </trans-unit>
        <trans-unit id="ed1d5342173ca839fdf8fe9c0ec24de1dc185152" translate="yes" xml:space="preserve">
          <source>When you work with Observables, it can be more convenient if all of the data you mean to work with can be represented as Observables, rather than as a mixture of Observables and other types. This allows you to use a single set of operators to govern the entire lifespan of the data stream.</source>
          <target state="translated">Cuando se trabaja con Observables,puede ser más conveniente que todos los datos con los que se quiere trabajar puedan representarse como Observables,en lugar de como una mezcla de Observables y otros tipos.Esto le permite utilizar un único conjunto de operadores para gobernar toda la vida útil del flujo de datos.</target>
        </trans-unit>
        <trans-unit id="d5d00501ca857ce32d5ad450528deb3276ed4573" translate="yes" xml:space="preserve">
          <source>Which looks something like this:</source>
          <target state="translated">Que se parece a algo como esto:</target>
        </trans-unit>
        <trans-unit id="7f4512b1c261ef620de45b9d8c88794c65d6da35" translate="yes" xml:space="preserve">
          <source>Why Use Observables?</source>
          <target state="translated">¿Por qué utilizar los observables?</target>
        </trans-unit>
        <trans-unit id="fd9d4ee647871a00407b827b39eb57cb188c8e9b" translate="yes" xml:space="preserve">
          <source>Will call a specified function when the source terminates on complete or error.</source>
          <target state="translated">Llamará a una función específica cuando la fuente termine por completo o por error.</target>
        </trans-unit>
        <trans-unit id="41dfc0a6c92707948578891c51d98c6443be63cc" translate="yes" xml:space="preserve">
          <source>Window</source>
          <target state="translated">Window</target>
        </trans-unit>
        <trans-unit id="9f072c045356efae34e3e1a1f0d76733efc29052" translate="yes" xml:space="preserve">
          <source>Window can reduce a sequence of many items to a sequence of fewer windows-of-items, making them more manageable. You could, for example, emit a window of items from a bursty Observable periodically, at a regular interval of time.</source>
          <target state="translated">La ventana puede reducir una secuencia de muchos artículos a una secuencia de menos ventanas de artículos,haciéndolas más manejables.Se podría,por ejemplo,emitir una ventana de artículos de una ráfaga observable periódicamente,en un intervalo regular de tiempo.</target>
        </trans-unit>
        <trans-unit id="aeb46abd228b75a53256f0b9bb6b7b8aa09463a1" translate="yes" xml:space="preserve">
          <source>Window is similar to &lt;a href=&quot;buffer&quot;&gt;Buffer&lt;/a&gt;, but rather than emitting packets of items from the source Observable, it emits Observables, each one of which emits a subset of items from the source Observable and then terminates with an &lt;code&gt;onCompleted&lt;/code&gt; notification.</source>
          <target state="translated">La ventana es similar a &lt;a href=&quot;buffer&quot;&gt;Buffer&lt;/a&gt; , pero en lugar de emitir paquetes de elementos de la fuente Observable, emite Observables, cada uno de los cuales emite un subconjunto de elementos de la fuente Observable y luego termina con una notificaci&amp;oacute;n &lt;code&gt;onCompleted&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3aa6c126ba6145f7e4e8238692031491a9fffcfd" translate="yes" xml:space="preserve">
          <source>With these additions, ReactiveX harmonizes the Iterable and Observable types. The only difference between them is the direction in which the data flows. This is very important because now any operation you can perform on an Iterable, you can also perform on an Observable.</source>
          <target state="translated">Con estas adiciones,ReactiveX armoniza los tipos Iterable y Observable.La única diferencia entre ellos es la dirección en la que fluyen los datos.Esto es muy importante porque ahora cualquier operación que se pueda realizar en un Iterable,también se puede realizar en un Observable.</target>
        </trans-unit>
        <trans-unit id="cffe58ca95400ce8524a59a6adb8339fe927b434" translate="yes" xml:space="preserve">
          <source>Write the predicate function so that it returns &lt;code&gt;true&lt;/code&gt; for those items you want to pass through the filter to the next observer, and &lt;code&gt;false&lt;/code&gt; for those items you want the filter to block and suppress.</source>
          <target state="translated">Escriba la funci&amp;oacute;n de predicado para que devuelva &lt;code&gt;true&lt;/code&gt; para los elementos que desea pasar a trav&amp;eacute;s del filtro al siguiente observador y &lt;code&gt;false&lt;/code&gt; para aquellos elementos que desea que el filtro bloquee y suprima.</target>
        </trans-unit>
        <trans-unit id="7832bd9cbceae7a6fa44c7235cfa89d50900f7e0" translate="yes" xml:space="preserve">
          <source>You can also average not the items themselves but the results of a function applied to each item, as in the illustration above, which emits the average number of sides on the figures emitted by the source Observable.</source>
          <target state="translated">También se puede promediar no los elementos en sí mismos sino los resultados de una función aplicada a cada elemento,como en la ilustración anterior,que emite el número medio de lados en las cifras emitidas por la fuente Observable.</target>
        </trans-unit>
        <trans-unit id="76e485df2d9c2ed235e91bb2f1f26240a5ef6a11" translate="yes" xml:space="preserve">
          <source>You can also pass &lt;code&gt;startWith&lt;/code&gt; an Observable, and it will prepend the emissions from that Observable to those of the source Observable to make its own set of emissions. This is a sort of inverted Concat operation.</source>
          <target state="translated">Tambi&amp;eacute;n puede pasar &lt;code&gt;startWith&lt;/code&gt; un Observable, y antepondr&amp;aacute; las emisiones de ese Observable a las de la fuente Observable para hacer su propio conjunto de emisiones. Esta es una especie de operaci&amp;oacute;n Concat invertida.</target>
        </trans-unit>
        <trans-unit id="76151784c054704dd1e5d91a90200d161d4d2c61" translate="yes" xml:space="preserve">
          <source>You can also pass a predicate function to &lt;code&gt;first&lt;/code&gt;, in which case it will produce an Observable that emits only the first item from the source Observable that the predicate evaluates as &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Tambi&amp;eacute;n puede pasar una funci&amp;oacute;n de predicado a &lt;code&gt;first&lt;/code&gt; , en cuyo caso producir&amp;aacute; un Observable que emite solo el primer elemento del Observable de origen que el predicado eval&amp;uacute;a como &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9032178a5997d03df3b49859b578df71837d196d" translate="yes" xml:space="preserve">
          <source>You can also pass a predicate function to &lt;code&gt;last&lt;/code&gt;, in which case it will produce an Observable that emits only the last item from the source Observable that the predicate evaluates as &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Tambi&amp;eacute;n puede pasar una funci&amp;oacute;n de predicado al &lt;code&gt;last&lt;/code&gt; , en cuyo caso producir&amp;aacute; un Observable que emite solo el &amp;uacute;ltimo elemento del Observable de origen que el predicado eval&amp;uacute;a como &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6227d5c7e14a1af665c31d2c7a7754c2eeacf80" translate="yes" xml:space="preserve">
          <source>You can also pass a predicate function to the &lt;code&gt;first&lt;/code&gt; method to retrieve the first emission from a &lt;code&gt;BlockingObservable&lt;/code&gt; that satisfies the predicate.</source>
          <target state="translated">Tambi&amp;eacute;n puede pasar una funci&amp;oacute;n de predicado al &lt;code&gt;first&lt;/code&gt; m&amp;eacute;todo para recuperar la primera emisi&amp;oacute;n de un &lt;code&gt;BlockingObservable&lt;/code&gt; que satisfaga el predicado.</target>
        </trans-unit>
        <trans-unit id="ff1fc46b917a6d39b2182685ef034a301d994df2" translate="yes" xml:space="preserve">
          <source>You can also pass a predicate function to the &lt;code&gt;last&lt;/code&gt; method to retrieve the last emission from a &lt;code&gt;BlockingObservable&lt;/code&gt; that satisfies the predicate.</source>
          <target state="translated">Tambi&amp;eacute;n puede pasar una funci&amp;oacute;n de predicado al &lt;code&gt;last&lt;/code&gt; m&amp;eacute;todo para recuperar la &amp;uacute;ltima emisi&amp;oacute;n de un &lt;code&gt;BlockingObservable&lt;/code&gt; que satisfaga el predicado.</target>
        </trans-unit>
        <trans-unit id="682f4fb340f16e8f1e5183cc92ab9b56a799d0eb" translate="yes" xml:space="preserve">
          <source>You can also pass an object to &lt;code&gt;findIndex&lt;/code&gt; as an optional second parameter, and that object will be available to the predicate function as &amp;ldquo;&lt;code&gt;this&lt;/code&gt;&amp;rdquo;.</source>
          <target state="translated">Tambi&amp;eacute;n puede pasar un objeto a &lt;code&gt;findIndex&lt;/code&gt; como un segundo par&amp;aacute;metro opcional, y ese objeto estar&amp;aacute; disponible para la funci&amp;oacute;n de predicado como &quot; &lt;code&gt;this&lt;/code&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="2f12ce04c127fae5f974652acbf7eb4637f72dc0" translate="yes" xml:space="preserve">
          <source>You can also pass in as an optional fifth parameter a &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; that &lt;code&gt;generate&lt;/code&gt; will use to create and emit its sequence (it uses &lt;code&gt;currentThread&lt;/code&gt; by default).</source>
          <target state="translated">Tambi&amp;eacute;n puede pasar como un quinto par&amp;aacute;metro opcional un &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; que &lt;code&gt;generate&lt;/code&gt; usar&amp;aacute; para crear y emitir su secuencia (usa &lt;code&gt;currentThread&lt;/code&gt; por defecto).</target>
        </trans-unit>
        <trans-unit id="44fdb21ced818c60966c04e7bd356097a2188b4d" translate="yes" xml:space="preserve">
          <source>You can also pass in as an optional fourth parameter a &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; that &lt;code&gt;generate&lt;/code&gt; will use to create and emit its sequence (it uses &lt;code&gt;CurrentThreadScheduler&lt;/code&gt; by default).</source>
          <target state="translated">Tambi&amp;eacute;n puede pasar como un cuarto par&amp;aacute;metro opcional un &lt;a href=&quot;../scheduler&quot;&gt;Programador&lt;/a&gt; que &lt;code&gt;generate&lt;/code&gt; usar&amp;aacute; para crear y emitir su secuencia (usa &lt;code&gt;CurrentThreadScheduler&lt;/code&gt; por defecto).</target>
        </trans-unit>
        <trans-unit id="b7cb5ca8203996c413ed3246420ce370e361571c" translate="yes" xml:space="preserve">
          <source>You can also pass in as an optional sixth parameter a &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; that &lt;code&gt;generate&lt;/code&gt; will use to create and emit its sequence (it uses &lt;code&gt;currentThread&lt;/code&gt; by default).</source>
          <target state="translated">Tambi&amp;eacute;n puede pasar como un sexto par&amp;aacute;metro opcional un &lt;a href=&quot;../scheduler&quot;&gt;Programador&lt;/a&gt; que &lt;code&gt;generate&lt;/code&gt; usar&amp;aacute; para crear y emitir su secuencia (usa &lt;code&gt;currentThread&lt;/code&gt; por defecto).</target>
        </trans-unit>
        <trans-unit id="ace5642a3047a0e0c9b280c2c4933542713f93b0" translate="yes" xml:space="preserve">
          <source>You can also pass it between one and three functions; these will be interpreted as follows:</source>
          <target state="translated">También se puede pasar entre una y tres funciones,que se interpretarán de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="8434b31a397379ba6a2fc9da703aa8991af9359f" translate="yes" xml:space="preserve">
          <source>You can also specify a particular &lt;a href=&quot;scheduler&quot;&gt;Scheduler&lt;/a&gt; for the timer to operate on:</source>
          <target state="translated">Tambi&amp;eacute;n puede especificar un &lt;a href=&quot;scheduler&quot;&gt;Programador en&lt;/a&gt; particular para que opere el temporizador:</target>
        </trans-unit>
        <trans-unit id="e502559fdf8b6103a0732d131d6e69a4a29eb47a" translate="yes" xml:space="preserve">
          <source>You can also sum not the items themselves but the results of a function applied to each item, as in the illustration above, which emits the sum number of sides on the figures emitted by the source Observable.</source>
          <target state="translated">También se pueden sumar no los elementos en sí mismos sino los resultados de una función aplicada a cada elemento,como en la ilustración anterior,que emite el número de lados de la suma de las cifras emitidas por la fuente Observable.</target>
        </trans-unit>
        <trans-unit id="7247fcf25ac20fbdb5f7aa37835067a9d4093a34" translate="yes" xml:space="preserve">
          <source>You can also sum not the items themselves but the results of a function applied to each item, as in the illustration above, which emits the sum of the number of sides on the figures emitted by the source Observable.</source>
          <target state="translated">También se pueden sumar no los elementos en sí mismos sino los resultados de una función aplicada a cada elemento,como en la ilustración anterior,que emite la suma del número de lados de las cifras emitidas por la fuente Observable.</target>
        </trans-unit>
        <trans-unit id="3b42768d804313cbd5e467001ecd6fd593441e45" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Scheduler.Worker.html#schedule(rx.functions.Action0,%20long,%20java.util.concurrent.TimeUnit)&quot;&gt;a version of &lt;code&gt;schedule&lt;/code&gt;&lt;/a&gt; that delays your action on the given Scheduler until a certain timespan has passed. The following example schedules &lt;code&gt;someAction&lt;/code&gt; to be performed on &lt;code&gt;someScheduler&lt;/code&gt; after 500ms have passed according to that Scheduler&amp;rsquo;s clock:</source>
          <target state="translated">Tambi&amp;eacute;n puede usar &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Scheduler.Worker.html#schedule(rx.functions.Action0,%20long,%20java.util.concurrent.TimeUnit)&quot;&gt;una versi&amp;oacute;n de &lt;code&gt;schedule&lt;/code&gt; &lt;/a&gt; que retrase su acci&amp;oacute;n en el Programador dado hasta que haya pasado un cierto per&amp;iacute;odo de tiempo. El siguiente ejemplo programa una &lt;code&gt;someAction&lt;/code&gt; para que se realice en &lt;code&gt;someScheduler&lt;/code&gt; despu&amp;eacute;s de que hayan pasado 500 ms de acuerdo con el reloj de ese programador:</target>
        </trans-unit>
        <trans-unit id="cb20d1dc2545e8aebb8070141dcdcdb2b4514b29" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;connect&lt;/code&gt; method to instruct an Observable to begin emitting items (or, to begin generating items that would be emitted) even before any Subscriber has subscribed to it. In this way you can turn a cold Observable into a hot one.</source>
          <target state="translated">Tambi&amp;eacute;n puede utilizar el m&amp;eacute;todo de &lt;code&gt;connect&lt;/code&gt; para indicar a un Observable que comience a emitir elementos (o que comience a generar elementos que se emitir&amp;iacute;an) incluso antes de que cualquier Suscriptor se haya suscrito a &amp;eacute;l. De esta forma puedes convertir un Observable fr&amp;iacute;o en uno caliente.</target>
        </trans-unit>
        <trans-unit id="b6ca8c83a0cdbbc6138ee98a1555b795c9b81a2f" translate="yes" xml:space="preserve">
          <source>You can combine the output of multiple Observables so that they act like a single Observable, by using the Merge operator.</source>
          <target state="translated">Puede combinar la salida de múltiples Observables para que actúen como un único Observable,utilizando el operador Merge.</target>
        </trans-unit>
        <trans-unit id="f29f94707670ef1f5bcad38186903f0c22c58ad6" translate="yes" xml:space="preserve">
          <source>You can convert a function into an asynchronous function with the &lt;code&gt;toAsync&lt;/code&gt; method. It takes a function, function parameter, and &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; as parameters, and returns an asynchronous function that will be invoked on the specified Scheduler. The last two parameters are optional; if you do not specify a Scheduler, the &lt;code&gt;timeout&lt;/code&gt; Scheduler will be used by default.</source>
          <target state="translated">Puede convertir una funci&amp;oacute;n en una funci&amp;oacute;n asincr&amp;oacute;nica con el m&amp;eacute;todo &lt;code&gt;toAsync&lt;/code&gt; . Toma una funci&amp;oacute;n, un par&amp;aacute;metro de funci&amp;oacute;n y un &lt;a href=&quot;../scheduler&quot;&gt;Programador&lt;/a&gt; como par&amp;aacute;metros y devuelve una funci&amp;oacute;n as&amp;iacute;ncrona que se invocar&amp;aacute; en el Programador especificado. Los dos &amp;uacute;ltimos par&amp;aacute;metros son opcionales; si no especifica un Programador, el Programador de &lt;code&gt;timeout&lt;/code&gt; se utilizar&amp;aacute; de forma predeterminada.</target>
        </trans-unit>
        <trans-unit id="d333d5f990bc05873a5bb431e9c19e5cfaa18ed6" translate="yes" xml:space="preserve">
          <source>You can create an Observable from scratch by using the Create operator. You pass this operator a function that accepts the observer as its parameter. Write this function so that it behaves as an Observable &amp;mdash; by calling the observer&amp;rsquo;s &lt;code&gt;onNext&lt;/code&gt;, &lt;code&gt;onError&lt;/code&gt;, and &lt;code&gt;onCompleted&lt;/code&gt; methods appropriately.</source>
          <target state="translated">Puede crear un Observable desde cero utilizando el operador Crear. Pasas a este operador una funci&amp;oacute;n que acepta al observador como su par&amp;aacute;metro. Escriba esta funci&amp;oacute;n para que se comporte como un Observable, llamando a los &lt;code&gt;onNext&lt;/code&gt; , &lt;code&gt;onError&lt;/code&gt; y &lt;code&gt;onCompleted&lt;/code&gt; del observador de manera apropiada.</target>
        </trans-unit>
        <trans-unit id="ed592ed573016152e1525943e01beed267c2837e" translate="yes" xml:space="preserve">
          <source>You can either pass &lt;code&gt;merge&lt;/code&gt; a set of Observables as individual parameters, or as a single parameter containing an array of those Observables.</source>
          <target state="translated">Puede &lt;code&gt;merge&lt;/code&gt; un conjunto de Observables como par&amp;aacute;metros individuales o como un solo par&amp;aacute;metro que contenga una matriz de esos Observables.</target>
        </trans-unit>
        <trans-unit id="0eb38cbaf446930a95ee352d060e3434e8e6cf5a" translate="yes" xml:space="preserve">
          <source>You can emit only the final</source>
          <target state="translated">Sólo puedes emitir el último</target>
        </trans-unit>
        <trans-unit id="92e0c405c5fc1dad5fbf0ff45e76df0f8d71a1b7" translate="yes" xml:space="preserve">
          <source>You can emit only the first</source>
          <target state="translated">Puedes emitir sólo la primera</target>
        </trans-unit>
        <trans-unit id="0d9ff619b7e4afa4d6d6cf1ea0bbdbec29b9e953" translate="yes" xml:space="preserve">
          <source>You can ignore the final</source>
          <target state="translated">Puedes ignorar el final</target>
        </trans-unit>
        <trans-unit id="cdf767f10b63dd6612725c17a1c1242d8039a0f1" translate="yes" xml:space="preserve">
          <source>You can ignore the first</source>
          <target state="translated">Puedes ignorar la primera</target>
        </trans-unit>
        <trans-unit id="34e3d5ad83cc701c11204debdb3a9bd100dc16ff" translate="yes" xml:space="preserve">
          <source>You can implement your own Observable operators. This page shows you how.</source>
          <target state="translated">Puede implementar sus propios operadores observables.Esta página te muestra cómo.</target>
        </trans-unit>
        <trans-unit id="a84dee30bbc65f9e86a29ef569240b6c41e82fe7" translate="yes" xml:space="preserve">
          <source>You can optionally pass &lt;code&gt;scan&lt;/code&gt; a seed value as an additional parameter. &lt;code&gt;scan&lt;/code&gt; will pass this seed value to the accumulator function the first time it is called (for the first emission from the source Observable) in place of the result from the missing prior call to the accumulator.</source>
          <target state="translated">Opcionalmente, puede pasar &lt;code&gt;scan&lt;/code&gt; un valor semilla como par&amp;aacute;metro adicional. &lt;code&gt;scan&lt;/code&gt; pasar&amp;aacute; este valor semilla a la funci&amp;oacute;n del acumulador la primera vez que se llame (para la primera emisi&amp;oacute;n de la fuente Observable) en lugar del resultado de la llamada anterior faltante al acumulador.</target>
        </trans-unit>
        <trans-unit id="c8b0aa91f55f3b994e6c69fe1cbb79f3b9e56c6b" translate="yes" xml:space="preserve">
          <source>You can pass &lt;code&gt;Merge&lt;/code&gt; an Array of Observables, an Enumerable of Observables, an Observable of Observables, or two individual Observables.</source>
          <target state="translated">Puede pasar &lt;code&gt;Merge&lt;/code&gt; una matriz de observables, un enumerable de observables, un observable de observables o dos observables individuales.</target>
        </trans-unit>
        <trans-unit id="cb8fd78267fbf9d33e89053521ba7ca1d2df2f4d" translate="yes" xml:space="preserve">
          <source>You can pass in a set of 1&amp;ndash;3 individual functions (&lt;code&gt;onNext&lt;/code&gt;, &lt;code&gt;onError&lt;/code&gt;, and &lt;code&gt;onCompleted&lt;/code&gt;) that &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;tap&lt;/code&gt; will call along with the similarly-named functions of any of its observers.</source>
          <target state="translated">Puede pasar un conjunto de 1 a 3 funciones individuales ( &lt;code&gt;onNext&lt;/code&gt; , &lt;code&gt;onError&lt;/code&gt; y &lt;code&gt;onCompleted&lt;/code&gt; ) que llamar&amp;aacute;n &lt;code&gt;do&lt;/code&gt; / &lt;code&gt;tap&lt;/code&gt; junto con las funciones con nombres similares de cualquiera de sus observadores.</target>
        </trans-unit>
        <trans-unit id="8e5177ba088da12c6ff9c7a019b4a2d5a68fbc0d" translate="yes" xml:space="preserve">
          <source>You can pass it an Observer, in which case &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;tap&lt;/code&gt; will call that Observer&amp;rsquo;s methods as though that Observer had subscribed to the resulting Observable.</source>
          <target state="translated">Puede pasarle un Observer, en cuyo caso &lt;code&gt;do&lt;/code&gt; / &lt;code&gt;tap&lt;/code&gt; llamar&amp;aacute; a los m&amp;eacute;todos de ese Observer como si ese Observador se hubiera suscrito al Observable resultante.</target>
        </trans-unit>
        <trans-unit id="c5c5fca5bde9cdb4b3c8839f8708898dbeeef111" translate="yes" xml:space="preserve">
          <source>You can pass the values you want to prepend to the Observable sequence to &lt;code&gt;startWith&lt;/code&gt; either in a single Iterable or as a series of one to nine function parameters.</source>
          <target state="translated">Puede pasar los valores que desea anteponer a la secuencia Observable para &lt;code&gt;startWith&lt;/code&gt; ya sea en un solo Iterable o como una serie de uno a nueve par&amp;aacute;metros de funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d39d86fe689387af19760dd31d8a62bc7e978897" translate="yes" xml:space="preserve">
          <source>You can register callbacks that ReactiveX will call when certain events take place on an Observable, where those callbacks will be called independently from the normal set of notifications associated with an Observable cascade. There are a variety of operators that various ReactiveX implementations have designed to allow for this.</source>
          <target state="translated">Se pueden registrar las llamadas de retorno que ReactiveX llamará cuando se produzcan determinados eventos en un observable,donde esas llamadas de retorno se llamarán independientemente del conjunto normal de notificaciones asociadas a una cascada de observables.Hay una variedad de operadores que varias implementaciones de ReactiveX han diseñado para permitir esto.</target>
        </trans-unit>
        <trans-unit id="fb2ee0c05762dad6511a1056f9e75b00a134937e" translate="yes" xml:space="preserve">
          <source>You can think of the Observable class as a &amp;ldquo;push&amp;rdquo; equivalent to &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/Iterable.html&quot;&gt;Iterable&lt;/a&gt;, which is a &amp;ldquo;pull.&amp;rdquo; With an Iterable, the consumer pulls values from the producer and the thread blocks until those values arrive. By contrast, with an Observable the producer pushes values to the consumer whenever values are available. This approach is more flexible, because values can arrive synchronously or asynchronously.</source>
          <target state="translated">Puede pensar en la clase Observable como un &quot;empuje&quot; equivalente a &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/Iterable.html&quot;&gt;Iterable&lt;/a&gt; , que es un &quot;tir&amp;oacute;n&quot;. Con un Iterable, el consumidor extrae valores del productor y los bloques de subprocesos hasta que llegan esos valores. Por el contrario, con un Observable, el productor empuja los valores al consumidor siempre que hay valores disponibles. Este enfoque es m&amp;aacute;s flexible, porque los valores pueden llegar de forma sincr&amp;oacute;nica o asincr&amp;oacute;nica.</target>
        </trans-unit>
        <trans-unit id="afe2c81139a11756e77093b65fd7ac0096d49a51" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;generate&lt;/code&gt; operator to create simple Observables that can generate their next emissions, and can determine when to terminate, based on the value of the previous emission. The basic form of &lt;code&gt;generate&lt;/code&gt; takes four parameters:</source>
          <target state="translated">Puede usar el operador de &lt;code&gt;generate&lt;/code&gt; para crear Observables simples que pueden generar sus pr&amp;oacute;ximas emisiones y pueden determinar cu&amp;aacute;ndo terminar, en funci&amp;oacute;n del valor de la emisi&amp;oacute;n anterior. La forma b&amp;aacute;sica de &lt;code&gt;generate&lt;/code&gt; toma cuatro par&amp;aacute;metros:</target>
        </trans-unit>
        <trans-unit id="e60fef6e6f2b9ffc1eea924da1b6d0b36ff75ea1" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;generate&lt;/code&gt; operator to create simple Observables that can generate their next emissions, and can determine when to terminate, based on the value of the previous emission. The basic form of &lt;code&gt;generate&lt;/code&gt; takes three parameters:</source>
          <target state="translated">Puede usar el operador de &lt;code&gt;generate&lt;/code&gt; para crear Observables simples que pueden generar sus pr&amp;oacute;ximas emisiones y pueden determinar cu&amp;aacute;ndo terminar, en funci&amp;oacute;n del valor de la emisi&amp;oacute;n anterior. La forma b&amp;aacute;sica de &lt;code&gt;generate&lt;/code&gt; toma tres par&amp;aacute;metros:</target>
        </trans-unit>
        <trans-unit id="4f52de916cbfb602ee5bae4de129d633704400d7" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;generateWithAbsoluteTime&lt;/code&gt; operator to create simple Observables that can generate their next emissions, and can determine when to terminate, based on the value of the previous emission. The basic form of &lt;code&gt;generateWithAbsoluteTime&lt;/code&gt; takes five parameters:</source>
          <target state="translated">Puede usar el operador &lt;code&gt;generateWithAbsoluteTime&lt;/code&gt; para crear Observables simples que puedan generar sus pr&amp;oacute;ximas emisiones y puedan determinar cu&amp;aacute;ndo terminar, en funci&amp;oacute;n del valor de la emisi&amp;oacute;n anterior. La forma b&amp;aacute;sica de &lt;code&gt;generateWithAbsoluteTime&lt;/code&gt; toma cinco par&amp;aacute;metros:</target>
        </trans-unit>
        <trans-unit id="530a4df6e9fe7ac23c4071905c1156e707670988" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;generateWithRelativeTime&lt;/code&gt; operator to create simple Observables that can generate their next emissions, and can determine when to terminate, based on the value of the previous emission. The basic form of &lt;code&gt;generateWithRelativeTime&lt;/code&gt; takes five parameters:</source>
          <target state="translated">Puede usar el operador &lt;code&gt;generateWithRelativeTime&lt;/code&gt; para crear Observables simples que pueden generar sus pr&amp;oacute;ximas emisiones y pueden determinar cu&amp;aacute;ndo terminar, en funci&amp;oacute;n del valor de la emisi&amp;oacute;n anterior. La forma b&amp;aacute;sica de &lt;code&gt;generateWithRelativeTime&lt;/code&gt; toma cinco par&amp;aacute;metros:</target>
        </trans-unit>
        <trans-unit id="3c8e590f92ae7e377643f3cb85ba8d13993cded0" translate="yes" xml:space="preserve">
          <source>You can use the Buffer operator to implement backpressure (that is, to cope with an Observable that may produce items too quickly for its observer to consume).</source>
          <target state="translated">Puede utilizar el operador de la memoria intermedia para aplicar la contrapresión (es decir,para hacer frente a un Observador que puede producir artículos con demasiada rapidez para que su observador los consuma).</target>
        </trans-unit>
        <trans-unit id="6a789db16cf992fb1a0e9a788b8fb01c96ea389d" translate="yes" xml:space="preserve">
          <source>You can use the Window operator to implement backpressure (that is, to cope with an Observable that may produce items too quickly for its observer to consume).</source>
          <target state="translated">Puede utilizar el operador de la Ventana para aplicar la contrapresión (es decir,para hacer frente a un Observador que puede producir artículos con demasiada rapidez para que su observador los consuma).</target>
        </trans-unit>
        <trans-unit id="140e328532101e1bca4082da61b61af7b7bddb4a" translate="yes" xml:space="preserve">
          <source>You can use this if you need a function that blocks until the completion of an Observable.</source>
          <target state="translated">Puede usar esto si necesita una función que bloquee hasta la finalización de un Observable.</target>
        </trans-unit>
        <trans-unit id="ec192e441ea90fa4d7c38e5cdb6a09a79315f557" translate="yes" xml:space="preserve">
          <source>You may also, optionally, pass in a &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; as a second parameter, and the timer will operate on that Scheduler (&lt;code&gt;skipUntilWithTime&lt;/code&gt; uses the &lt;code&gt;timeout&lt;/code&gt; Scheduler by default).</source>
          <target state="translated">Tambi&amp;eacute;n puede, opcionalmente, pasar un &lt;a href=&quot;../scheduler&quot;&gt;Programador&lt;/a&gt; como segundo par&amp;aacute;metro, y el temporizador operar&amp;aacute; en ese Programador ( &lt;code&gt;skipUntilWithTime&lt;/code&gt; usa el Programador de &lt;code&gt;timeout&lt;/code&gt; de forma predeterminada).</target>
        </trans-unit>
        <trans-unit id="a97be5d8b2c0e88945dca3a58187eeff3b450946" translate="yes" xml:space="preserve">
          <source>You may also, optionally, pass in a &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; as a second parameter, and the timer will operate on that Scheduler (&lt;code&gt;takeUntilWithTime&lt;/code&gt; uses the &lt;code&gt;timeout&lt;/code&gt; Scheduler by default).</source>
          <target state="translated">Tambi&amp;eacute;n puede, opcionalmente, pasar un &lt;a href=&quot;../scheduler&quot;&gt;Programador&lt;/a&gt; como segundo par&amp;aacute;metro, y el temporizador funcionar&amp;aacute; en ese Programador ( &lt;code&gt;takeUntilWithTime&lt;/code&gt; usa el Programador de &lt;code&gt;timeout&lt;/code&gt; de forma predeterminada).</target>
        </trans-unit>
        <trans-unit id="9ee11d62e29bb47499c0f66688f7c75ce6d51ea7" translate="yes" xml:space="preserve">
          <source>You may optionally pass a second parameter to &lt;code&gt;skipWhile&lt;/code&gt;. If so, that item will also be available to your predicate function as &amp;ldquo;&lt;code&gt;this&lt;/code&gt;&amp;rdquo;.</source>
          <target state="translated">Opcionalmente, puede pasar un segundo par&amp;aacute;metro a &lt;code&gt;skipWhile&lt;/code&gt; . Si es as&amp;iacute;, ese elemento tambi&amp;eacute;n estar&amp;aacute; disponible para su funci&amp;oacute;n de predicado como &quot; &lt;code&gt;this&lt;/code&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="023d26f660a72a31c63344590bfe54d9962554f4" translate="yes" xml:space="preserve">
          <source>You may optionally pass a second parameter to &lt;code&gt;takeWhile&lt;/code&gt;. If so, that item will also be available to your predicate function as &amp;ldquo;&lt;code&gt;this&lt;/code&gt;&amp;rdquo;.</source>
          <target state="translated">Opcionalmente, puede pasar un segundo par&amp;aacute;metro a &lt;code&gt;takeWhile&lt;/code&gt; . Si es as&amp;iacute;, ese elemento tambi&amp;eacute;n estar&amp;aacute; disponible para su funci&amp;oacute;n de predicado como &quot; &lt;code&gt;this&lt;/code&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="9d40c04f503ade2f5884377cd47e2bbce06c8245" translate="yes" xml:space="preserve">
          <source>You may optionally pass in a default value that &lt;code&gt;elementAt&lt;/code&gt; will emit if the source Observable emits no values:</source>
          <target state="translated">Opcionalmente, puede pasar un valor predeterminado que &lt;code&gt;elementAt&lt;/code&gt; emitir&amp;aacute; si la fuente Observable no emite valores:</target>
        </trans-unit>
        <trans-unit id="6924eecb0342a630593b97c28a087d0a232f2125" translate="yes" xml:space="preserve">
          <source>You may pass &lt;code&gt;catch_exception&lt;/code&gt; a set of back-up Observables either as individual function parameters or as a single array of Observables. If it encounters an &lt;code&gt;onError&lt;/code&gt; notification from the source Observable, it will subscribe to and begin mirroring the first of these back-up Observables. If this back-up Observable itself issues an &lt;code&gt;onError&lt;/code&gt; notification, &lt;code&gt;catch_exception&lt;/code&gt; will swallow it and switch over to the next back-up Observable. If any of these Observables issues an &lt;code&gt;onCompleted&lt;/code&gt; notification, &lt;code&gt;catch_exception&lt;/code&gt; will pass this along and will stop.</source>
          <target state="translated">Puede pasar &lt;code&gt;catch_exception&lt;/code&gt; un conjunto de Observables de respaldo ya sea como par&amp;aacute;metros de funci&amp;oacute;n individuales o como una &amp;uacute;nica matriz de Observables. Si encuentra una notificaci&amp;oacute;n de &lt;code&gt;onError&lt;/code&gt; del Observable de origen, se suscribir&amp;aacute; y comenzar&amp;aacute; a duplicar el primero de estos Observables de respaldo. Si este Observable de respaldo emite una notificaci&amp;oacute;n de &lt;code&gt;onError&lt;/code&gt; , &lt;code&gt;catch_exception&lt;/code&gt; lo tragar&amp;aacute; y cambiar&amp;aacute; al siguiente Observable de respaldo. Si cualquiera de estos observables emite una &lt;code&gt;onCompleted&lt;/code&gt; notificaci&amp;oacute;n, &lt;code&gt;catch_exception&lt;/code&gt; pasar&amp;aacute; a lo largo de este y se detendr&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="b4b837d7135fd3faba51276890ee36e1feca2008" translate="yes" xml:space="preserve">
          <source>You may pass &lt;code&gt;on_error_resume_next&lt;/code&gt; a set of back-up Observables either as individual function parameters, as a single array of Observables, or as a factory function that generates Observables. When the source Observable terminates, whether normally or with an error, &lt;code&gt;on_error_resume_next&lt;/code&gt; will subscribe to and begin mirroring the first of these back-up Observables, and then will recursively continue this concatenation process for each additional Observable until there are no more Observables to mirror, at which time it will pass on the &lt;code&gt;onError&lt;/code&gt; or &lt;code&gt;onCompleted&lt;/code&gt; notification from the last of these Observables.</source>
          <target state="translated">Puede pasar &lt;code&gt;on_error_resume_next&lt;/code&gt; un conjunto de Observables de respaldo, ya sea como par&amp;aacute;metros de funci&amp;oacute;n individuales, como una &amp;uacute;nica matriz de Observables o como una funci&amp;oacute;n de f&amp;aacute;brica que genera Observables. Cuando el Observable de origen termina, ya sea normalmente o con un error, &lt;code&gt;on_error_resume_next&lt;/code&gt; se suscribir&amp;aacute; y comenzar&amp;aacute; a duplicar el primero de estos Observables de respaldo, y luego continuar&amp;aacute; recursivamente este proceso de concatenaci&amp;oacute;n para cada Observable adicional hasta que no haya m&amp;aacute;s Observables para duplicar, en ese momento pasar&amp;aacute; la notificaci&amp;oacute;n &lt;code&gt;onError&lt;/code&gt; o &lt;code&gt;onCompleted&lt;/code&gt; del &amp;uacute;ltimo de estos Observables.</target>
        </trans-unit>
        <trans-unit id="4a8142ffd2e1b1f1cf04b936490d70f73561a031" translate="yes" xml:space="preserve">
          <source>You may pass &lt;code&gt;rescue_error&lt;/code&gt; either an Observable or a factory action that generates an Observable.</source>
          <target state="translated">Puede pasar &lt;code&gt;rescue_error&lt;/code&gt; ya sea un Observable o una acci&amp;oacute;n de f&amp;aacute;brica que genere un Observable.</target>
        </trans-unit>
        <trans-unit id="aa1f229e508d7ff97c8b29afa6b4e506ae8fad77" translate="yes" xml:space="preserve">
          <source>You may replace the first function parameter (the predicate that evaluates the exception) with a class object representing a variety of exception. If you do this, &lt;code&gt;catch*&lt;/code&gt; will treat it as equivalent to predicate that performs an &lt;code&gt;instance?&lt;/code&gt; check to see if the exception from the &lt;code&gt;onError&lt;/code&gt; notification is an instance of the class object. In other words:</source>
          <target state="translated">Puede reemplazar el primer par&amp;aacute;metro de funci&amp;oacute;n (el predicado que eval&amp;uacute;a la excepci&amp;oacute;n) con un objeto de clase que representa una variedad de excepciones. Si hace esto, &amp;iquest; &lt;code&gt;catch*&lt;/code&gt; lo tratar&amp;aacute; como equivalente al predicado que realiza una &lt;code&gt;instance?&lt;/code&gt; compruebe si la excepci&amp;oacute;n de la notificaci&amp;oacute;n &lt;code&gt;onError&lt;/code&gt; es una instancia del objeto de clase. En otras palabras:</target>
        </trans-unit>
        <trans-unit id="fc3c1c1381737d34e9f462554add7c36b53b82e9" translate="yes" xml:space="preserve">
          <source>You obtain a Scheduler from the factory methods described in &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/schedulers/Schedulers.html&quot;&gt;the &lt;code&gt;Schedulers&lt;/code&gt; class&lt;/a&gt;. The following table shows the varieties of Scheduler that are available to you by means of these methods in RxGroovy:</source>
          <target state="translated">Obtiene un Programador de los m&amp;eacute;todos de f&amp;aacute;brica descritos en &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/schedulers/Schedulers.html&quot;&gt;la clase &lt;code&gt;Schedulers&lt;/code&gt; &lt;/a&gt; . La siguiente tabla muestra las variedades de Programador que est&amp;aacute;n disponibles para usted mediante estos m&amp;eacute;todos en RxGroovy:</target>
        </trans-unit>
        <trans-unit id="bf2ca998afcfe4dc5973a75433cef6ddce12e4f3" translate="yes" xml:space="preserve">
          <source>You obtain a Scheduler from the factory methods described in &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/schedulers/Schedulers.html&quot;&gt;the &lt;code&gt;Schedulers&lt;/code&gt; class&lt;/a&gt;. The following table shows the varieties of Scheduler that are available to you by means of these methods in RxJava:</source>
          <target state="translated">Obtiene un Programador de los m&amp;eacute;todos de f&amp;aacute;brica descritos en &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/schedulers/Schedulers.html&quot;&gt;la clase &lt;code&gt;Schedulers&lt;/code&gt; &lt;/a&gt; . La siguiente tabla muestra las variedades de Scheduler que est&amp;aacute;n disponibles para usted mediante estos m&amp;eacute;todos en RxJava:</target>
        </trans-unit>
        <trans-unit id="bd39c643b0349c87b3a6306388851ca9feb51b59" translate="yes" xml:space="preserve">
          <source>You pass the &lt;code&gt;using&lt;/code&gt; operator three parameters:</source>
          <target state="translated">Pasas al operador &lt;code&gt;using&lt;/code&gt; tres par&amp;aacute;metros:</target>
        </trans-unit>
        <trans-unit id="945549399624f25bf835814f45b520f97baa16bc" translate="yes" xml:space="preserve">
          <source>You pass the &lt;code&gt;using&lt;/code&gt; operator two parameters:</source>
          <target state="translated">Pasas al operador &lt;code&gt;using&lt;/code&gt; dos par&amp;aacute;metros:</target>
        </trans-unit>
        <trans-unit id="1f339160e649a6f3d3ed789c3776e03cdd682087" translate="yes" xml:space="preserve">
          <source>Your operator should check &lt;a href=&quot;observable#unsubscribing&quot;&gt;its Subscriber's &lt;code&gt;isUnsubscribed( )&lt;/code&gt; status&lt;/a&gt; before it emits any item to (or sends any notification to) the Subscriber. Do not waste time generating items that no Subscriber is interested in seeing.</source>
          <target state="translated">Su operador debe comprobar &lt;a href=&quot;observable#unsubscribing&quot;&gt;su suscriptor de &lt;code&gt;isUnsubscribed( )&lt;/code&gt; estado&lt;/a&gt; antes de que se emite ning&amp;uacute;n elemento a (o env&amp;iacute;a ninguna notificaci&amp;oacute;n a) el suscriptor. No pierda tiempo generando elementos que ning&amp;uacute;n Suscriptor est&amp;aacute; interesado en ver.</target>
        </trans-unit>
        <trans-unit id="2de2635fc818fcac53a104f07189e4bb7e893948" translate="yes" xml:space="preserve">
          <source>Your operator should obey the core tenets of the Observable contract:</source>
          <target state="translated">Su operador debe obedecer los principios básicos del contrato Observable:</target>
        </trans-unit>
        <trans-unit id="aec742c8cd57ac5fee0ad76b17e91c6d76608cb3" translate="yes" xml:space="preserve">
          <source>Zip</source>
          <target state="translated">Zip</target>
        </trans-unit>
        <trans-unit id="4647f6838148e96f73bbd9c301485a593c564bca" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; on which this operator should operate</source>
          <target state="translated">un &lt;a href=&quot;../scheduler&quot;&gt;programador&lt;/a&gt; en el que este operador debe operar</target>
        </trans-unit>
        <trans-unit id="b493c478a21d579a93d747f7559defc353fe9a6b" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; on which you want to run the Node.js callback</source>
          <target state="translated">un &lt;a href=&quot;../scheduler&quot;&gt;Programador&lt;/a&gt; en el que desea ejecutar la devoluci&amp;oacute;n de llamada de Node.js</target>
        </trans-unit>
        <trans-unit id="509f3a9a1a12009f0c68350721b996a8bba83a2d" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;Date&lt;/code&gt;</source>
          <target state="translated">una &lt;code&gt;Date&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="094b3142a1b3282411e3d1922e3059844391c692" translate="yes" xml:space="preserve">
          <source>a Single passes this method the Throwable that caused the Single to be unable to emit an item</source>
          <target state="translated">un Single pasa este método el Throwable que causó que el Single no pudiera emitir un artículo</target>
        </trans-unit>
        <trans-unit id="f8c375880bc159b6da0439d622dda5c5e82f83b0" translate="yes" xml:space="preserve">
          <source>a Single passes this method the sole item that the Single emits</source>
          <target state="translated">un Soltero pasa por este método el único elemento que el Soltero emite</target>
        </trans-unit>
        <trans-unit id="6e746c23a5816efea8653e2074fbc7f27840c058" translate="yes" xml:space="preserve">
          <source>a factory function that creates a disposable resource</source>
          <target state="translated">una función de fábrica que crea un recurso desechable</target>
        </trans-unit>
        <trans-unit id="f9ef51f84c35f84a28720761526b6be0ec85aebe" translate="yes" xml:space="preserve">
          <source>a factory function that creates an Observable</source>
          <target state="translated">una función de fábrica que crea una función observable</target>
        </trans-unit>
        <trans-unit id="47dfc20e0f1b41b426e0e33d0cd2a5b9688c4e57" translate="yes" xml:space="preserve">
          <source>a function that accepts an item emitted by the source Observable and returns a</source>
          <target state="translated">una función que acepta un elemento emitido por la fuente Observable y devuelve un</target>
        </trans-unit>
        <trans-unit id="2ddd07bf05e2e9d39c05b862f2b8e252591ef85b" translate="yes" xml:space="preserve">
          <source>a function that accepts an item from the first Observable and an Observable that emits items from the second Observable and returns an item to be emitted by the Observable returned from &lt;code&gt;groupJoin&lt;/code&gt;</source>
          <target state="translated">una funci&amp;oacute;n que acepta un elemento del primer Observable y un Observable que emite elementos del segundo Observable y devuelve un elemento para ser emitido por el Observable devuelto por &lt;code&gt;groupJoin&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76f8801e6c5c9954ce73620d55acd7bf849c2a1a" translate="yes" xml:space="preserve">
          <source>a function that accepts an item from the first Observable and an item from the second Observable and returns an item to be emitted by the Observable returned from &lt;code&gt;join&lt;/code&gt;</source>
          <target state="translated">una funci&amp;oacute;n que acepta un elemento del primer Observable y un elemento del segundo Observable y devuelve un elemento para ser emitido por el Observable devuelto desde &lt;code&gt;join&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0aff1921b29e2531a19b409ba53bcaa299073931" translate="yes" xml:space="preserve">
          <source>a function that accepts an item from the second Observable and returns an Observable whose lifespan governs the duration during which that item will combine with items from the first Observable</source>
          <target state="translated">una función que acepta un artículo del segundo Observador y devuelve un Observador cuya vida útil rige la duración durante la cual ese artículo se combinará con los artículos del primer Observador</target>
        </trans-unit>
        <trans-unit id="2537afc91f615219e473b116dd8fce6e8c1a6ff9" translate="yes" xml:space="preserve">
          <source>a function that accepts an item from the source Observable and returns an Observable whose lifespan governs the duration during which that item will combine with items from the second Observable</source>
          <target state="translated">una función que acepta un artículo de la fuente Observable y devuelve un Observable cuya vida útil rige la duración durante la cual ese artículo se combinará con los artículos del segundo Observable</target>
        </trans-unit>
        <trans-unit id="0ea0e4f321f3690c79a053a22c1c77290a7e603e" translate="yes" xml:space="preserve">
          <source>a function that accepts an item from the source Observable and returns an item to be emitted in its place by one of the resulting Observables</source>
          <target state="translated">una función que acepta un artículo de la fuente Observable y devuelve un artículo para que sea emitido en su lugar por uno de los Observables resultantes</target>
        </trans-unit>
        <trans-unit id="2e39dfb6e89ec27b2799ac841058cbe1c8622ded" translate="yes" xml:space="preserve">
          <source>a function that accepts two items (or two keys) and compares them for distinctness, returning &lt;code&gt;false&lt;/code&gt; if they are distinct (an equality function is the default if you do not supply your own function here)</source>
          <target state="translated">una funci&amp;oacute;n que acepta dos elementos (o dos claves) y los compara para determinar su distinci&amp;oacute;n, devolviendo &lt;code&gt;false&lt;/code&gt; si son distintos (una funci&amp;oacute;n de igualdad es la predeterminada si no proporciona su propia funci&amp;oacute;n aqu&amp;iacute;)</target>
        </trans-unit>
        <trans-unit id="40c676b1b9cb886b7d849f24b8f8562dc0c7450f" translate="yes" xml:space="preserve">
          <source>a function that disposes of the resource</source>
          <target state="translated">una función que dispone del recurso</target>
        </trans-unit>
        <trans-unit id="f00fad8955c402d31ecc865bacbf29bf7f7b2e49" translate="yes" xml:space="preserve">
          <source>a function that returns the key that determines which Observable to emit</source>
          <target state="translated">una función que devuelve la clave que determina qué Observable emitir</target>
        </trans-unit>
        <trans-unit id="bf1f078c34ead7a76ff3206e489a656d7ecb0e61" translate="yes" xml:space="preserve">
          <source>a function that returns the mutable data structure</source>
          <target state="translated">una función que devuelve la estructura de datos mutable</target>
        </trans-unit>
        <trans-unit id="d3d2297cca8b40c3332e52315a233f4690aa3594" translate="yes" xml:space="preserve">
          <source>a function that, when given the data structure and an item emitted by the source Observable, modifies the data structure appropriately</source>
          <target state="translated">una función que,cuando se le da la estructura de datos y un elemento emitido por la fuente Observable,modifica la estructura de datos de manera apropiada</target>
        </trans-unit>
        <trans-unit id="fdcfa4810783cdbb46bc98763bc28d19271f7ac2" translate="yes" xml:space="preserve">
          <source>a function to generate the next item to test and emit based on the value of the previous item</source>
          <target state="translated">una función para generar el siguiente elemento a probar y emitir en base al valor del elemento anterior</target>
        </trans-unit>
        <trans-unit id="428d1cdfe3341cf4456bd0ff8a1f09d9b747a991" translate="yes" xml:space="preserve">
          <source>a function to indicate at what time (expressed as a &lt;code&gt;Date&lt;/code&gt;) the generator should emit the the new item</source>
          <target state="translated">una funci&amp;oacute;n para indicar a qu&amp;eacute; hora (expresada como una &lt;code&gt;Date&lt;/code&gt; ) el generador debe emitir el nuevo elemento</target>
        </trans-unit>
        <trans-unit id="b9b02313f83c7a5de6f60fa4dae062626ee99890" translate="yes" xml:space="preserve">
          <source>a function to indicate how long, in milliseconds, the generator should wait after the emission of the previous item before emitting this item</source>
          <target state="translated">una función para indicar cuánto tiempo,en milisegundos,debe esperar el generador después de la emisión del elemento anterior antes de emitir este elemento</target>
        </trans-unit>
        <trans-unit id="9c40d35aa81016b60c5e8f8e5f786a2e228ffcd8" translate="yes" xml:space="preserve">
          <source>a function to test an item to determine whether to emit it (&lt;code&gt;true&lt;/code&gt;) or terminate the Observable (&lt;code&gt;false&lt;/code&gt;)</source>
          <target state="translated">una funci&amp;oacute;n para probar un elemento para determinar si emitirlo ( &lt;code&gt;true&lt;/code&gt; ) o terminar el Observable ( &lt;code&gt;false&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="95323fca49a83a1abac26e79f91ed7eb8a5653bf" translate="yes" xml:space="preserve">
          <source>a function to transform items before emitting them</source>
          <target state="translated">una función para transformar los elementos antes de emitirlos</target>
        </trans-unit>
        <trans-unit id="0456183e34019ad3a80b7ade1f97bbdb2982c441" translate="yes" xml:space="preserve">
          <source>a function used to compare two keys for identity (that is, whether items with two keys should be emitted on the same Observable)</source>
          <target state="translated">una función utilizada para comparar dos claves para la identidad (es decir,si los artículos con dos claves deben ser emitidos en el mismo Observable)</target>
        </trans-unit>
        <trans-unit id="c37f5d4c24ebe19faceff2fa752f48ced17e4bc7" translate="yes" xml:space="preserve">
          <source>a number</source>
          <target state="translated">un número</target>
        </trans-unit>
        <trans-unit id="046c38b0c1d8b4e28f9b3036802beb70f5bc27ff" translate="yes" xml:space="preserve">
          <source>a parameter to give to the callback function</source>
          <target state="translated">un parámetro para dar a la función de devolución de llamada</target>
        </trans-unit>
        <trans-unit id="1cde721814013cf593ec03ffb7b7d2acbb857196" translate="yes" xml:space="preserve">
          <source>a parameter to pass to the callback function</source>
          <target state="translated">un parámetro para pasar a la función de devolución de llamada</target>
        </trans-unit>
        <trans-unit id="b8f7f3c1eda366392609e11b5761750c26f9eb1b" translate="yes" xml:space="preserve">
          <source>a second argument to pass into the transforming function as additional context information</source>
          <target state="translated">un segundo argumento para pasar a la función transformadora como información de contexto adicional</target>
        </trans-unit>
        <trans-unit id="64fcf1af137d36f34598932f6ace3ce897fda0d5" translate="yes" xml:space="preserve">
          <source>a tranforming function that takes the return value of the callback function as input and returns an item to be emitted by the resulting Observable</source>
          <target state="translated">una función de transformación que toma el valor de retorno de la función de retrollamada como entrada y devuelve un elemento para ser emitido por el Observable resultante</target>
        </trans-unit>
        <trans-unit id="d12ef7e3cdfedafdb8947dc6e3897484b12200cc" translate="yes" xml:space="preserve">
          <source>a transforming function that takes an item emitted by the source Observable as its parameter and returns an item to be emitted by the resulting Observable</source>
          <target state="translated">una función transformadora que toma como parámetro un elemento emitido por la fuente Observable y devuelve un elemento para ser emitido por el Observable resultante</target>
        </trans-unit>
        <trans-unit id="6e7e113e681e606f5e008dfe9116078cb537c060" translate="yes" xml:space="preserve">
          <source>a transforming function that takes an item from the array or iterable as input and produces an item to be emitted by the resulting Observable as output</source>
          <target state="translated">una función transformadora que toma un elemento del conjunto o iterable como entrada y produce un elemento que será emitido por el Observable resultante como salida</target>
        </trans-unit>
        <trans-unit id="ecbebad873608a573c6f88c7adfa7968ec975515" translate="yes" xml:space="preserve">
          <source>a variety of operators that enforce particular flow-control policies</source>
          <target state="translated">una variedad de operadores que aplican determinadas políticas de control de flujo</target>
        </trans-unit>
        <trans-unit id="75896d78bed7aa685002a0be20721209bce14725" translate="yes" xml:space="preserve">
          <source>additional items have been emitted by that Observable.</source>
          <target state="translated">se han emitido artículos adicionales por ese observable.</target>
        </trans-unit>
        <trans-unit id="f5d953a3114e36aab0e1e2506cada2331d1550b2" translate="yes" xml:space="preserve">
          <source>advances the Scheduler&amp;rsquo;s clock forward by a particular amount of time</source>
          <target state="translated">Avanza el reloj del Programador en una cantidad de tiempo particular</target>
        </trans-unit>
        <trans-unit id="8b089b72e7a4725ef2e2624e5e93a0590a197509" translate="yes" xml:space="preserve">
          <source>advances the Scheduler&amp;rsquo;s clock to a particular point in time</source>
          <target state="translated">avanza el reloj del programador a un punto en particular en el tiempo</target>
        </trans-unit>
        <trans-unit id="6f6ddadc45f67e2f1110937a7473b4d38d8782fb" translate="yes" xml:space="preserve">
          <source>after a specified delay</source>
          <target state="translated">después de una demora especificada</target>
        </trans-unit>
        <trans-unit id="25e01a2edb261f8e4f68662596bb4757a3c6699f" translate="yes" xml:space="preserve">
          <source>allows you create a custom operator</source>
          <target state="translated">le permite crear un operador personalizado</target>
        </trans-unit>
        <trans-unit id="eb1c47b9488976a153de840013f1e8555fdd7b89" translate="yes" xml:space="preserve">
          <source>an object that associates those keys with particular Observables</source>
          <target state="translated">un objeto que asocia esas claves con Observables particulares</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="3ab0c50ba1f5993a1e526134cd25d0da452d1ff0" translate="yes" xml:space="preserve">
          <source>and emit a number indicating how many items were in the sequence</source>
          <target state="translated">y emitir un número que indique cuántos artículos había en la secuencia</target>
        </trans-unit>
        <trans-unit id="4a96b1b08e9ed381d5574e8e1f21549df303d3ad" translate="yes" xml:space="preserve">
          <source>and emit a single boolean indicating if &lt;em&gt;all&lt;/em&gt; of the items pass some test</source>
          <target state="translated">y emite un solo booleano que indica si &lt;em&gt;todos&lt;/em&gt; los elementos pasan alguna prueba</target>
        </trans-unit>
        <trans-unit id="e69d22261ea99b45a17a8dc23bdd2a7509965bc6" translate="yes" xml:space="preserve">
          <source>and emit a single boolean indicating if the Observable emitted &lt;em&gt;any&lt;/em&gt; item (that passes some test)</source>
          <target state="translated">y emite un solo booleano que indica si el Observable emiti&amp;oacute; &lt;em&gt;alg&amp;uacute;n&lt;/em&gt; elemento (que pasa alguna prueba)</target>
        </trans-unit>
        <trans-unit id="7baf48599e88aaeeb73e266a7efd0e148448e0f5" translate="yes" xml:space="preserve">
          <source>and emit a single boolean indicating if the Observable emitted &lt;em&gt;no&lt;/em&gt; items</source>
          <target state="translated">y emite un solo booleano que indica si el Observable &lt;em&gt;no&lt;/em&gt; emiti&amp;oacute; elementos</target>
        </trans-unit>
        <trans-unit id="0c0325d25cb3794f2e6a745d0c90cae1126fc1cb" translate="yes" xml:space="preserve">
          <source>and emit a single boolean indicating if the sequence is identical to one emitted by a second Observable</source>
          <target state="translated">y emitir una sola booleana que indique si la secuencia es idéntica a la emitida por un segundo Observable</target>
        </trans-unit>
        <trans-unit id="0794b1050db960b48a9d04824c91e65f5e00ebf7" translate="yes" xml:space="preserve">
          <source>and emit the average of all of their values</source>
          <target state="translated">y emiten el promedio de todos sus valores</target>
        </trans-unit>
        <trans-unit id="97beebc6577539889da30f39e00f6502491523bf" translate="yes" xml:space="preserve">
          <source>and emit the item with the maximum value</source>
          <target state="translated">y emitir el artículo con el valor máximo</target>
        </trans-unit>
        <trans-unit id="00590436e185ea9db814cea817c3ef29f52817d6" translate="yes" xml:space="preserve">
          <source>and emit the item with the minimum value</source>
          <target state="translated">y emitir el artículo con el valor mínimo</target>
        </trans-unit>
        <trans-unit id="34f796b1a15e3b1cfec4260445200a01d2745463" translate="yes" xml:space="preserve">
          <source>and emit the sum of all of their values</source>
          <target state="translated">y emiten la suma de todos sus valores</target>
        </trans-unit>
        <trans-unit id="8607e552f2d0c2b275785ec61776399b991f6fd1" translate="yes" xml:space="preserve">
          <source>and emitting all of the items from all of the Observables in whatever order they are received</source>
          <target state="translated">y emitiendo todos los artículos de todos los Observatorios en cualquier orden en que se reciban</target>
        </trans-unit>
        <trans-unit id="7e5c7dcffd0e52405e8fd447dc388fee40056ad8" translate="yes" xml:space="preserve">
          <source>and emitting all of the items from all of the Observables, one Observable at a time</source>
          <target state="translated">y emitiendo todos los artículos de todos los Observables,un Observable a la vez</target>
        </trans-unit>
        <trans-unit id="9b0c7ceb92e8fe98a2db7b7ee8fcfb24c07771ee" translate="yes" xml:space="preserve">
          <source>and emitting the items from only the most-recently emitted of those Observables</source>
          <target state="translated">y emitiendo los artículos sólo de los más recientemente emitidos de esos Observables</target>
        </trans-unit>
        <trans-unit id="378c88957dfb0a305750c2b80287c13f20833b32" translate="yes" xml:space="preserve">
          <source>and then I want to ask it to start</source>
          <target state="translated">y luego quiero pedirle que empiece</target>
        </trans-unit>
        <trans-unit id="8be41e709b3249dd05643a847e4cab1c97aa1205" translate="yes" xml:space="preserve">
          <source>and then emits the complete sequence, even to those who subscribe after the sequence has begun</source>
          <target state="translated">y luego emite la secuencia completa,incluso a los que se suscriben después de que la secuencia haya comenzado</target>
        </trans-unit>
        <trans-unit id="7efd76778a88e660bb12fa24328e717c436d5b4b" translate="yes" xml:space="preserve">
          <source>and then only emits the last item in its sequence</source>
          <target state="translated">y luego sólo emite el último elemento en su secuencia</target>
        </trans-unit>
        <trans-unit id="80e361fe647eb090f7f3e23fe1e78f7661315c15" translate="yes" xml:space="preserve">
          <source>apply a function to each item emitted by an Observable, sequentially, and emit each successive value</source>
          <target state="translated">aplicar una función a cada elemento emitido por un Observable,de forma secuencial,y emitir cada valor sucesivo</target>
        </trans-unit>
        <trans-unit id="2aae0a97beec75e49732de3acf9a51a6e3f35b06" translate="yes" xml:space="preserve">
          <source>apply a function to each item emitted by an Observable, sequentially, and emit the final value</source>
          <target state="translated">aplicar una función a cada elemento emitido por un Observable,de forma secuencial,y emitir el valor final</target>
        </trans-unit>
        <trans-unit id="7d752f2c5e9504352a8b5051da82d8c592e4d092" translate="yes" xml:space="preserve">
          <source>asynchronous</source>
          <target state="translated">asynchronous</target>
        </trans-unit>
        <trans-unit id="82d5635631c9b07663bb7d672111045b85db490e" translate="yes" xml:space="preserve">
          <source>at particular intervals of time</source>
          <target state="translated">en determinados intervalos de tiempo</target>
        </trans-unit>
        <trans-unit id="36a05b8e8ae34dcb7426101165fea84e7c64e32e" translate="yes" xml:space="preserve">
          <source>attach a timestamp to each item emitted by an Observable indicating when it was emitted</source>
          <target state="translated">adjuntar una marca de tiempo a cada artículo emitido por un Observador indicando cuando fue emitido</target>
        </trans-unit>
        <trans-unit id="a2093fde1186db0585ea62a388b9cb2943526699" translate="yes" xml:space="preserve">
          <source>based on all of the items that preceded them</source>
          <target state="translated">basado en todos los elementos que los precedieron</target>
        </trans-unit>
        <trans-unit id="09fecbcf0276d272df9099e0daaaa3b7773fd804" translate="yes" xml:space="preserve">
          <source>begins generating items to emit immediately when it is created. Subscribers typically begin observing the sequence of items emitted by a hot Observable from somewhere in the middle of the sequence, beginning with the first item emitted by the Observable subsequent to the establishment of the subscription. Such an Observable emits items at its own pace, and it is up to its observers to keep up. Examples of items emitted by a hot Observable might include mouse &amp;amp; keyboard events, system events, or stock prices.</source>
          <target state="translated">comienza a generar elementos para emitir inmediatamente cuando se crea. Los suscriptores normalmente comienzan a observar la secuencia de elementos emitidos por un Observable caliente desde alg&amp;uacute;n lugar en el medio de la secuencia, comenzando con el primer elemento emitido por el Observable despu&amp;eacute;s del establecimiento de la suscripci&amp;oacute;n. Tal Observable emite elementos a su propio ritmo, y depende de sus observadores mantener el ritmo. Ejemplos de elementos emitidos por un Observable caliente pueden incluir eventos de mouse y teclado, eventos del sistema o precios de las acciones.</target>
        </trans-unit>
        <trans-unit id="91742200ee81bc6aadca216cd1711c81b8196c3e" translate="yes" xml:space="preserve">
          <source>below)</source>
          <target state="translated">below)</target>
        </trans-unit>
        <trans-unit id="f59062128d67887221611ec80b08fdc406bd1475" translate="yes" xml:space="preserve">
          <source>but I want it to go away once all of its subscribers unsubscribe</source>
          <target state="translated">pero quiero que desaparezca una vez que todos sus suscriptores se desabrochen</target>
        </trans-unit>
        <trans-unit id="7d79de2f1adf708e14a324d60741a611cc35ef65" translate="yes" xml:space="preserve">
          <source>by applying an aggregation function to each item in turn and emitting the result</source>
          <target state="translated">aplicando una función de agregación a cada elemento por turno y emitiendo el resultado</target>
        </trans-unit>
        <trans-unit id="2aece502258035de89ea708eb33596dfd03c34cb" translate="yes" xml:space="preserve">
          <source>by attaching a timestamp to them</source>
          <target state="translated">al adjuntarles una marca de tiempo</target>
        </trans-unit>
        <trans-unit id="3e27bc3f4d066d8b7c01b9fe0d22804704709389" translate="yes" xml:space="preserve">
          <source>by attempting to resubscribe to the upstream Observable</source>
          <target state="translated">al tratar de volver a suscribirse a la lista de Observables de arriba</target>
        </trans-unit>
        <trans-unit id="6adf44d0eb0023d4304115f3180e433f647a2efc" translate="yes" xml:space="preserve">
          <source>by combining the items from two or more Observables sequentially to come up with new items to emit</source>
          <target state="translated">combinando los elementos de dos o más Observables secuencialmente para obtener nuevos elementos a emitir</target>
        </trans-unit>
        <trans-unit id="bcd0218297b656000c1ac71599017790bc85c365" translate="yes" xml:space="preserve">
          <source>by delaying my subscription to it for some time after it begins emitting items</source>
          <target state="translated">retrasando mi suscripción a ella durante algún tiempo después de que empiece a emitir artículos</target>
        </trans-unit>
        <trans-unit id="f13876a8f487096fa7ed90f9de5112faf9f39485" translate="yes" xml:space="preserve">
          <source>by emitting all of the items emitted by corresponding Observables</source>
          <target state="translated">emitiendo todos los elementos emitidos por los Observadores correspondientes</target>
        </trans-unit>
        <trans-unit id="1dd53da47c6b8eff8a39ffadc7d377be35e20425" translate="yes" xml:space="preserve">
          <source>by filtering out those that do not match some predicate</source>
          <target state="translated">filtrando aquellos que no coinciden con algún predicado</target>
        </trans-unit>
        <trans-unit id="d47503a1e21d807bffb852a194a725c2958558e3" translate="yes" xml:space="preserve">
          <source>by means of &lt;code&gt;Pattern&lt;/code&gt; and &lt;code&gt;Plan&lt;/code&gt; intermediaries</source>
          <target state="translated">por medio del &lt;code&gt;Pattern&lt;/code&gt; y &lt;code&gt;Plan&lt;/code&gt; intermediarios</target>
        </trans-unit>
        <trans-unit id="63d6688bc3922632efdebc442218b0ecad0527ea" translate="yes" xml:space="preserve">
          <source>by only emitting items that are not followed by other items within some duration</source>
          <target state="translated">emitiendo solamente artículos que no son seguidos por otros artículos dentro de alguna duración</target>
        </trans-unit>
        <trans-unit id="988bc528771482a14d8f05b39fe9e424a0118901" translate="yes" xml:space="preserve">
          <source>by retrieving it from a Future</source>
          <target state="translated">recuperándolo de un Futuro</target>
        </trans-unit>
        <trans-unit id="869bf59133792be52e036bb3d7b589950917bf15" translate="yes" xml:space="preserve">
          <source>by sampling the Observable periodically</source>
          <target state="translated">mediante el muestreo del Observable periódicamente</target>
        </trans-unit>
        <trans-unit id="90a1749d56333543d881676b625ec860961f55ef" translate="yes" xml:space="preserve">
          <source>by suppressing items that are duplicates of already-emitted items</source>
          <target state="translated">suprimiendo los artículos que son duplicados de los ya emitidos</target>
        </trans-unit>
        <trans-unit id="7af15572c56ca7d62d1cfa5ddac5af0712b1c125" translate="yes" xml:space="preserve">
          <source>by the Observable to the observer</source>
          <target state="translated">por el Observador al observador</target>
        </trans-unit>
        <trans-unit id="dd78b511d8fcb0430492c6c02e9aa1973bb65655" translate="yes" xml:space="preserve">
          <source>by wrapping them in &lt;code&gt;Notification&lt;/code&gt; objects</source>
          <target state="translated">envolvi&amp;eacute;ndolos en objetos de &lt;code&gt;Notification&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="19068047789a81691f13158a43b02076c65041df" translate="yes" xml:space="preserve">
          <source>calculates the average of numbers emitted by an Observable and emits this average</source>
          <target state="translated">calcula el promedio de los números emitidos por un Observable y emite este promedio</target>
        </trans-unit>
        <trans-unit id="87e72635cfd6cb3993ed2975332903fc2b28069d" translate="yes" xml:space="preserve">
          <source>calculates the sum of numbers emitted by an Observable and emits this sum</source>
          <target state="translated">calcula la suma de los números emitidos por un Observable y emite esta suma</target>
        </trans-unit>
        <trans-unit id="ef83875cbdebb3066a5df980de002d8b7230c128" translate="yes" xml:space="preserve">
          <source>cold Observable</source>
          <target state="translated">frío Observable</target>
        </trans-unit>
        <trans-unit id="6710d8c63778707e72df57fc2aba9fa135efbe94" translate="yes" xml:space="preserve">
          <source>combine items emitted by two Observables whenever an item from one Observable is emitted during a time window defined according to an item emitted by the other Observable</source>
          <target state="translated">combinar los elementos emitidos por dos Observables siempre que un elemento de un Observable se emita durante una ventana de tiempo definida según un elemento emitido por el otro Observable</target>
        </trans-unit>
        <trans-unit id="d8a85be857c4b8d572be8a8cd2e6f9d20bae0516" translate="yes" xml:space="preserve">
          <source>combine multiple Observables into one by merging their emissions</source>
          <target state="translated">combinar varios Observables en uno solo fusionando sus emisiones</target>
        </trans-unit>
        <trans-unit id="d70c4db347b466165449fd0675674217d45894d7" translate="yes" xml:space="preserve">
          <source>combine sets of items emitted by two or more Observables by means of Pattern and Plan intermediaries</source>
          <target state="translated">combinar conjuntos de elementos emitidos por dos o más Observables por medio de intermediarios de Patrones y Planos</target>
        </trans-unit>
        <trans-unit id="aa40fbaa4ea0a034c51bceacc20bdceaa6365554" translate="yes" xml:space="preserve">
          <source>combine the emissions of multiple Observables together via a specified function and emit single items for each combination based on the results of this function</source>
          <target state="translated">combinar las emisiones de múltiples Observables juntas a través de una función especificada y emitir elementos individuales para cada combinación basada en los resultados de esta función</target>
        </trans-unit>
        <trans-unit id="0737c22d3bfae812339732d14d8c7dbd6dc4e09c" translate="yes" xml:space="preserve">
          <source>complete</source>
          <target state="translated">complete</target>
        </trans-unit>
        <trans-unit id="537bac49fb381519e179be6b0008c6ba0263e54a" translate="yes" xml:space="preserve">
          <source>compose</source>
          <target state="translated">compose</target>
        </trans-unit>
        <trans-unit id="49ba358c3272c2db40fc6ab2c103669678628b68" translate="yes" xml:space="preserve">
          <source>concat</source>
          <target state="translated">concat</target>
        </trans-unit>
        <trans-unit id="d90ad13cbc688a267267cf995a732fd5a221778e" translate="yes" xml:space="preserve">
          <source>concat and concatWith</source>
          <target state="translated">concat y concatWith</target>
        </trans-unit>
        <trans-unit id="5a528204c79768fa06e40aa1f390858060705983" translate="yes" xml:space="preserve">
          <source>concatWith</source>
          <target state="translated">concatWith</target>
        </trans-unit>
        <trans-unit id="4a87f56a7be04873edc5dab9dfcbea43167dcda6" translate="yes" xml:space="preserve">
          <source>concatenates the items emitted by multiple Singles as Observable emissions</source>
          <target state="translated">concatena los elementos emitidos por múltiples individuales como emisiones observables</target>
        </trans-unit>
        <trans-unit id="920b046593a982bd8c911c015fbe228693c49096" translate="yes" xml:space="preserve">
          <source>connectable Observable</source>
          <target state="translated">conectable Observable</target>
        </trans-unit>
        <trans-unit id="e07fc362e1775ed78d4cb3db16f025093e05f2f8" translate="yes" xml:space="preserve">
          <source>containing only the last items emitted</source>
          <target state="translated">que contiene sólo los últimos artículos emitidos</target>
        </trans-unit>
        <trans-unit id="855a0fc1d9acb3d7fad5d79757204568eb80f0d4" translate="yes" xml:space="preserve">
          <source>convert an Observable into another object or data structure</source>
          <target state="translated">convertir un Observable en otro objeto o estructura de datos</target>
        </trans-unit>
        <trans-unit id="d8272ed0eb1bc3fc9a572fe8071362ed69127653" translate="yes" xml:space="preserve">
          <source>convert an Observable that emits Observables into a single Observable that emits the items emitted by the most-recently-emitted of those Observables</source>
          <target state="translated">convertir un Observable que emite Observables en un único Observable que emite los elementos emitidos por el más reciente de esos Observables</target>
        </trans-unit>
        <trans-unit id="e912523a996828d3bf0fbb542911199b9dcd4945" translate="yes" xml:space="preserve">
          <source>convert an Observable that emits items into one that emits indications of the amount of time elapsed between those emissions</source>
          <target state="translated">convertir un Observable que emite artículos en uno que emite indicaciones de la cantidad de tiempo transcurrido entre esas emisiones</target>
        </trans-unit>
        <trans-unit id="b3b0d4dac76ddef2f79e3a08df1975b9c86b9d98" translate="yes" xml:space="preserve">
          <source>convert an ordinary Observable into a connectable Observable</source>
          <target state="translated">convertir un Observable ordinario en un Observable conectable</target>
        </trans-unit>
        <trans-unit id="36c287e5fcff20eaf16d26dfb5475062c8618c56" translate="yes" xml:space="preserve">
          <source>convert various other objects and data types into Observables</source>
          <target state="translated">convertir varios otros objetos y tipos de datos en Observables</target>
        </trans-unit>
        <trans-unit id="f4ca7b1d875550de063360cab8f9cf4978c92d84" translate="yes" xml:space="preserve">
          <source>converts a Future into a Single</source>
          <target state="translated">convierte un futuro en un simple</target>
        </trans-unit>
        <trans-unit id="cb8e1c3f3e599ff85786d96efc6bdfd9903b7f27" translate="yes" xml:space="preserve">
          <source>converts a Single into an Observable that emits the item emitted by the Single and then completes</source>
          <target state="translated">convierte un Único en un Observable que emite el elemento emitido por el Único y luego completa</target>
        </trans-unit>
        <trans-unit id="95bc015cb9a9c64e9443baea3c1aaa8ac7f29d16" translate="yes" xml:space="preserve">
          <source>converts a Single that emits a second Single into a Single that emits the item emitted by the second Single</source>
          <target state="translated">convierte un Single que emite un segundo Single en un Single que emite el artículo emitido por el segundo Single</target>
        </trans-unit>
        <trans-unit id="170368d03dc716d2f7e2d2bf74c31d9d92aa4f43" translate="yes" xml:space="preserve">
          <source>converts a Single that makes an error notification into a Single that emits a specified item</source>
          <target state="translated">convierte un Single que hace una notificación de error en un Single que emite un elemento específico</target>
        </trans-unit>
        <trans-unit id="21c864aec311796f6a8ee3738b2863e2059f40bf" translate="yes" xml:space="preserve">
          <source>converts an Observable that emits a single item into a Single that emits that item</source>
          <target state="translated">convierte un Observable que emite un único elemento en un Único que emite ese elemento</target>
        </trans-unit>
        <trans-unit id="1888c76c0a8234b805afa72fa84387df9c464cdd" translate="yes" xml:space="preserve">
          <source>conveys an</source>
          <target state="translated">transmite una</target>
        </trans-unit>
        <trans-unit id="cc33275c066e42225c7bd44275e209912fa780f0" translate="yes" xml:space="preserve">
          <source>count the number of items emitted by the source Observable and emit only this value</source>
          <target state="translated">contar el número de artículos emitidos por la fuente Observable y emitir sólo este valor</target>
        </trans-unit>
        <trans-unit id="9b7c68a918b17eb053809b198d7c9abfc142f30a" translate="yes" xml:space="preserve">
          <source>create</source>
          <target state="translated">create</target>
        </trans-unit>
        <trans-unit id="fdb38e7814f867156c67f7710cb229b4d10b3201" translate="yes" xml:space="preserve">
          <source>create a Single from scratch by calling subscriber methods explicitly</source>
          <target state="translated">crear un Single desde cero llamando a los métodos de suscripción explícitamente</target>
        </trans-unit>
        <trans-unit id="2ae303adc776faa5253a43fb06677635513e17d9" translate="yes" xml:space="preserve">
          <source>create a disposable resource that has the same lifespan as the Observable</source>
          <target state="translated">crear un recurso desechable que tenga la misma vida útil que el Observable</target>
        </trans-unit>
        <trans-unit id="c6a8aff547f069fdb80cd76a7872c7f620a75366" translate="yes" xml:space="preserve">
          <source>create an Observable from scratch by means of a function</source>
          <target state="translated">crear un Observable desde cero por medio de una función</target>
        </trans-unit>
        <trans-unit id="b33eccb560190edb81875010369904b2976a67f7" translate="yes" xml:space="preserve">
          <source>create an Observable that emits a particular item</source>
          <target state="translated">crear un observable que emita un elemento particular</target>
        </trans-unit>
        <trans-unit id="82295320e101fc0781587bba12bb5acf15af8c48" translate="yes" xml:space="preserve">
          <source>create an Observable that emits a particular item after a given delay</source>
          <target state="translated">crear un observable que emita un determinado elemento después de un determinado retraso</target>
        </trans-unit>
        <trans-unit id="1e3219e49f0c47c7c71d11d751ede2c8e6c514ac" translate="yes" xml:space="preserve">
          <source>create an Observable that emits a particular item multiple times</source>
          <target state="translated">crear un observable que emita un elemento particular varias veces</target>
        </trans-unit>
        <trans-unit id="ca0465f5eb874bf38df3fa2364bec78c08742f29" translate="yes" xml:space="preserve">
          <source>create an Observable that emits a particular range of sequential integers</source>
          <target state="translated">crear un observable que emita un rango particular de enteros secuenciales</target>
        </trans-unit>
        <trans-unit id="92ee38dc48832f578e61897964a8273e3909af09" translate="yes" xml:space="preserve">
          <source>create an Observable that emits a sequence of integers spaced by a given time interval</source>
          <target state="translated">crear un observable que emita una secuencia de números enteros espaciados por un intervalo de tiempo determinado</target>
        </trans-unit>
        <trans-unit id="8d4e5b41bfe8dba9a089b2fe7c6570c481c904ad" translate="yes" xml:space="preserve">
          <source>create an Observable that emits no items and does not terminate</source>
          <target state="translated">crear un observable que no emita ningún elemento y no termine</target>
        </trans-unit>
        <trans-unit id="03c73352ceb55a7c10db1ec5d57ebb0ef733141c" translate="yes" xml:space="preserve">
          <source>create an Observable that emits no items and terminates with an error</source>
          <target state="translated">crear un Observable que no emita ningún elemento y termine con un error</target>
        </trans-unit>
        <trans-unit id="32eb01d241a8343531a01127a803a32299028ff2" translate="yes" xml:space="preserve">
          <source>create an Observable that emits no items but terminates normally</source>
          <target state="translated">crear un observable que no emita elementos pero que termine normalmente</target>
        </trans-unit>
        <trans-unit id="b79d1c80846e9d369b49bcd22a30738b8cdee801" translate="yes" xml:space="preserve">
          <source>create an Observable that emits the return value of a function-like directive</source>
          <target state="translated">crear un observable que emita el valor de retorno de una directiva de tipo funcional</target>
        </trans-unit>
        <trans-unit id="a5561cb95df07e2d89b98437823d320627cdba07" translate="yes" xml:space="preserve">
          <source>creates a new thread for each unit of work</source>
          <target state="translated">crea un nuevo hilo para cada unidad de trabajo</target>
        </trans-unit>
        <trans-unit id="ab464f0252045aaf075411f0f1a6aed0797306c1" translate="yes" xml:space="preserve">
          <source>delay</source>
          <target state="translated">delay</target>
        </trans-unit>
        <trans-unit id="cb329146a0dd0d566b0628744d67936558741ffa" translate="yes" xml:space="preserve">
          <source>description</source>
          <target state="translated">description</target>
        </trans-unit>
        <trans-unit id="0130195fe419912b70a512541e4691345f6674cd" translate="yes" xml:space="preserve">
          <source>determine whether all items emitted by an Observable meet some criteria</source>
          <target state="translated">determinar si todos los artículos emitidos por un Observable cumplen algunos criterios</target>
        </trans-unit>
        <trans-unit id="ff3cae2ef561f628b8c891daa60ccb56db8aa32f" translate="yes" xml:space="preserve">
          <source>determine whether an Observable emits a particular item or not</source>
          <target state="translated">determinar si un Observable emite o no un determinado elemento</target>
        </trans-unit>
        <trans-unit id="7509d1ff7d8d151dbcd5969fef9f3f655099c57a" translate="yes" xml:space="preserve">
          <source>determine whether two Observables emit the same sequence of items</source>
          <target state="translated">determinar si dos Observables emiten la misma secuencia de elementos</target>
        </trans-unit>
        <trans-unit id="a3f45eefb0dd1450098d33b7dcd8b10e899ebd54" translate="yes" xml:space="preserve">
          <source>discard any items emitted by an Observable after a second Observable emits an item or terminates</source>
          <target state="translated">descartar cualquier artículo emitido por un Observador después de que un segundo Observador emita un artículo o termine</target>
        </trans-unit>
        <trans-unit id="7ef61ce8a5dffd0c260e15eb10d12d5974f6b1e1" translate="yes" xml:space="preserve">
          <source>discard items emitted by an Observable until a second Observable emits an item</source>
          <target state="translated">descartar los artículos emitidos por un Observador hasta que un segundo Observador emita un artículo</target>
        </trans-unit>
        <trans-unit id="3691b3deaeb85a3b9c3076808d8d13e2c9ca15c4" translate="yes" xml:space="preserve">
          <source>discard items emitted by an Observable until a specified condition becomes false</source>
          <target state="translated">descartar los elementos emitidos por un Observable hasta que una condición especificada se vuelva falsa</target>
        </trans-unit>
        <trans-unit id="a24279f0df1b28b11e1ed236842b46f562322a29" translate="yes" xml:space="preserve">
          <source>discover error</source>
          <target state="translated">descubrir el error</target>
        </trans-unit>
        <trans-unit id="946dc974300f80e10583bc68927d8820e58b6ce8" translate="yes" xml:space="preserve">
          <source>divide an Observable into a set of Observables that each emit a different subset of items from the original Observable</source>
          <target state="translated">dividen un Observable en un conjunto de Observables que cada uno de ellos emite un subconjunto diferente de artículos del Observable original</target>
        </trans-unit>
        <trans-unit id="11e6899e09d5b0e21dac51ae558f249603206247" translate="yes" xml:space="preserve">
          <source>do not create the Observable until the observer subscribes, and create a fresh Observable for each observer</source>
          <target state="translated">no crear el Observable hasta que el observador se suscriba,y crear un nuevo Observable para cada observador</target>
        </trans-unit>
        <trans-unit id="2332dd1e2b522343e16599f71fb2fde4233ff0ac" translate="yes" xml:space="preserve">
          <source>do not emit any items from an Observable but mirror its termination notification</source>
          <target state="translated">no emiten ningún elemento de un observable,sino que reflejan su notificación de terminación</target>
        </trans-unit>
        <trans-unit id="b0d186043ed808f44ab3b75ef20a1f576b6d7d31" translate="yes" xml:space="preserve">
          <source>doOnError</source>
          <target state="translated">doOnError</target>
        </trans-unit>
        <trans-unit id="7193c8c35518b2a87f4d4244048219ccdb80780b" translate="yes" xml:space="preserve">
          <source>doOnSuccess</source>
          <target state="translated">doOnSuccess</target>
        </trans-unit>
        <trans-unit id="a56b577350353096fb8dd622bb5aca0c9bec85e9" translate="yes" xml:space="preserve">
          <source>does it divide its work over multiple threads that may return data to the caller in any order?</source>
          <target state="translated">¿divide su trabajo en múltiples hilos que pueden devolver datos a la persona que llama en cualquier orden?</target>
        </trans-unit>
        <trans-unit id="e9a705a6cefc203dae4d8a9f3133b7eb64ecee9b" translate="yes" xml:space="preserve">
          <source>does it use NIO with an event-loop to do asynchronous network access?</source>
          <target state="translated">¿Utiliza la NIO con un bucle de eventos para hacer un acceso asíncrono a la red?</target>
        </trans-unit>
        <trans-unit id="c61eeb26d4303ae3094656f0c7c99d06a7fd47e5" translate="yes" xml:space="preserve">
          <source>does it use an Actor (or multiple Actors) instead of a thread pool?</source>
          <target state="translated">¿Utiliza un Actor (o varios Actores)en lugar de un conjunto de hilos?</target>
        </trans-unit>
        <trans-unit id="d45843eeab32a602d9af842b03276dd264c86fb3" translate="yes" xml:space="preserve">
          <source>does it use an event-loop to separate the work thread from the callback thread?</source>
          <target state="translated">¿Utiliza un bucle de eventos para separar el hilo de trabajo del hilo de retrollamada?</target>
        </trans-unit>
        <trans-unit id="5fa3c300a8b1aa79b5251cfec9489f85c1fe4ecc" translate="yes" xml:space="preserve">
          <source>does it work asynchronously on a distinct thread?</source>
          <target state="translated">¿funciona asincrónicamente en un hilo distinto?</target>
        </trans-unit>
        <trans-unit id="90c3f6d02b875e5084eb3ab9fe4d1f72abaab63b" translate="yes" xml:space="preserve">
          <source>does it work synchronously on the same thread as the caller?</source>
          <target state="translated">¿funciona de forma sincronizada en el mismo hilo de la llamada?</target>
        </trans-unit>
        <trans-unit id="710324ca59ab0fb7cedc97294ff18e57250aa3d3" translate="yes" xml:space="preserve">
          <source>element, or a NodeList, jQuery element, Zepto Element, Angular element, Ember.js element, or EventEmitter.</source>
          <target state="translated">o un elemento NodeList,elemento jQuery,elemento Zepto,elemento Angular,elemento Ember.js,o EventEmitter.</target>
        </trans-unit>
        <trans-unit id="543f8528a5a36e0fd63ca3d3b9efd3632fd5f9fe" translate="yes" xml:space="preserve">
          <source>emit a specified sequence of items before beginning to emit the items from the source Observable</source>
          <target state="translated">emitir una secuencia específica de elementos antes de comenzar a emitir los elementos de la fuente Observable</target>
        </trans-unit>
        <trans-unit id="769fc1172fe01d37dc2f7e2713413d7a65503510" translate="yes" xml:space="preserve">
          <source>emit items from the source Observable, or a default item if the source Observable emits nothing</source>
          <target state="translated">emiten elementos de la fuente Observable,o un elemento por defecto si la fuente Observable no emite nada</target>
        </trans-unit>
        <trans-unit id="a115af0876acd2b5e8fcdc6c52560200a454030f" translate="yes" xml:space="preserve">
          <source>emit only item</source>
          <target state="translated">emitir sólo un artículo</target>
        </trans-unit>
        <trans-unit id="02aaf586c2920f9cf2072e5c133fdd3df98c558a" translate="yes" xml:space="preserve">
          <source>emit only the final</source>
          <target state="translated">emitir sólo el final</target>
        </trans-unit>
        <trans-unit id="283d4e16f73e8edadb26e90e4c88dd395606afff" translate="yes" xml:space="preserve">
          <source>emit only the first</source>
          <target state="translated">emiten sólo la primera</target>
        </trans-unit>
        <trans-unit id="c1a6d921096c6a9cea1ec58a1d7915ffd2cb0a6c" translate="yes" xml:space="preserve">
          <source>emit only the first item (or the first item that meets some condition) emitted by an Observable</source>
          <target state="translated">emitir sólo el primer elemento (o el primer elemento que cumpla alguna condición)emitido por un Observador</target>
        </trans-unit>
        <trans-unit id="f7170ccdd023f5a086caa059f65476d0bdf1f23e" translate="yes" xml:space="preserve">
          <source>emit only the last item (or the last item that meets some condition) emitted by an Observable</source>
          <target state="translated">emitir sólo el último artículo (o el último artículo que cumpla alguna condición)emitido por un Observador</target>
        </trans-unit>
        <trans-unit id="c526ff4f61953d2c1ad9b75959a34d517116b608" translate="yes" xml:space="preserve">
          <source>emit only those items from an Observable that pass a predicate test</source>
          <target state="translated">emiten sólo aquellos artículos de un Observable que pasan una prueba predicada</target>
        </trans-unit>
        <trans-unit id="f2e3b63fe53b455567c0ba6e3aace08cba7b101c" translate="yes" xml:space="preserve">
          <source>emit the emissions from two or more Observables without interleaving them</source>
          <target state="translated">emiten las emisiones de dos o más Observables sin intercalarlas</target>
        </trans-unit>
        <trans-unit id="5b3c959fdd976b09cc3b28b3011f1ca1bcdb8853" translate="yes" xml:space="preserve">
          <source>emit the most recent items emitted by an Observable within periodic time intervals</source>
          <target state="translated">emiten los elementos más recientes emitidos por un Observador en intervalos de tiempo periódicos</target>
        </trans-unit>
        <trans-unit id="53f9ce69544263d25131c6704271a197bba315a5" translate="yes" xml:space="preserve">
          <source>emits</source>
          <target state="translated">emits</target>
        </trans-unit>
        <trans-unit id="a442b9237df23abb5cc5420387c221e8a2aeccc5" translate="yes" xml:space="preserve">
          <source>emits a particular sequence of items, but can begin emitting this sequence when its observer finds it to be convenient, and at whatever rate the observer desires, without disrupting the integrity of the sequence. For example if you convert a static iterable into an Observable, that Observable will emit the same sequence of items no matter when it is later subscribed to or how frequently those items are observed. Examples of items emitted by a cold Observable might include the results of a database query, file retrieval, or web request.</source>
          <target state="translated">emite una secuencia particular de elementos,pero puede comenzar a emitir esta secuencia cuando su observador lo considere conveniente,y a la velocidad que desee el observador,sin perturbar la integridad de la secuencia.Por ejemplo,si se convierte un iterable estático en un Observable,ese Observable emitirá la misma secuencia de elementos,independientemente de cuándo se suscriba más tarde o de la frecuencia con que se observen esos elementos.Entre los ejemplos de elementos emitidos por un Observable frío podrían figurar los resultados de una consulta de base de datos,la recuperación de un archivo o una solicitud en la web.</target>
        </trans-unit>
        <trans-unit id="9f22b2c00b19a035731d14ad74cd7c6d05921206" translate="yes" xml:space="preserve">
          <source>emits the item from the source Observable that had the maximum value</source>
          <target state="translated">emite el elemento de la fuente observable que tenía el valor máximo</target>
        </trans-unit>
        <trans-unit id="74d826ddf8287874d3ee8212bbe2a72b20190f91" translate="yes" xml:space="preserve">
          <source>emits the item from the source Observable that had the minimum value</source>
          <target state="translated">emite el artículo de la fuente observable que tenía el valor mínimo</target>
        </trans-unit>
        <trans-unit id="9665ac3929f268285506b88deec23cb12f0e63bd" translate="yes" xml:space="preserve">
          <source>emitted</source>
          <target state="translated">emitted</target>
        </trans-unit>
        <trans-unit id="88d6618f3561fa3cb57d650ace09305ee6f0d428" translate="yes" xml:space="preserve">
          <source>emitted by an Observable</source>
          <target state="translated">emitida por un Observador</target>
        </trans-unit>
        <trans-unit id="7e4f940b5782633c616f37bc35675c5163ed9a19" translate="yes" xml:space="preserve">
          <source>emitted by the Observable.</source>
          <target state="translated">emitidos por el Observable.</target>
        </trans-unit>
        <trans-unit id="71e9b710ca7e783890b77f938203768b335532b7" translate="yes" xml:space="preserve">
          <source>ensure that all observers see the same sequence of emitted items, even if they subscribe after the Observable has begun emitting items</source>
          <target state="translated">asegurarse de que todos los observadores vean la misma secuencia de artículos emitidos,incluso si se suscriben después de que el Observable haya comenzado a emitir artículos</target>
        </trans-unit>
        <trans-unit id="11f9578d05e6f7bb58a3cdd00107e9f4e3882671" translate="yes" xml:space="preserve">
          <source>error</source>
          <target state="translated">error</target>
        </trans-unit>
        <trans-unit id="5006ed0248a019713b762563076292379daf07b4" translate="yes" xml:space="preserve">
          <source>event</source>
          <target state="translated">event</target>
        </trans-unit>
        <trans-unit id="ccc9d4f948ad94c5bbe07a1feee18738df60b756" translate="yes" xml:space="preserve">
          <source>flatMap</source>
          <target state="translated">flatMap</target>
        </trans-unit>
        <trans-unit id="378ce4f507ad3e73799fb43d9c5ee511ddbf655c" translate="yes" xml:space="preserve">
          <source>flatMapObservable</source>
          <target state="translated">flatMapObservable</target>
        </trans-unit>
        <trans-unit id="4bd229d639cd13fb02a63b1261609ad0439b9c86" translate="yes" xml:space="preserve">
          <source>for each observer that subscribes</source>
          <target state="translated">para cada observador que se suscriba</target>
        </trans-unit>
        <trans-unit id="6074cf77c3da497067408b6c04f9a98a7d0a3bf9" translate="yes" xml:space="preserve">
          <source>for unit testing; this allows you to manually manipulate the movement of time</source>
          <target state="translated">para la prueba de la unidad;esto le permite manipular manualmente el movimiento del tiempo</target>
        </trans-unit>
        <trans-unit id="746e807e0dba440c42eb9deaeab2869069904a18" translate="yes" xml:space="preserve">
          <source>force an Observable to make serialized calls and to be well-behaved</source>
          <target state="translated">obligar a un Observador a hacer llamadas en serie y a comportarse bien</target>
        </trans-unit>
        <trans-unit id="0b1e95cfd9775191a7224d0a218ae79187e80c1d" translate="yes" xml:space="preserve">
          <source>from</source>
          <target state="translated">from</target>
        </trans-unit>
        <trans-unit id="f1d7632831475751406b7847814481cce36b28fc" translate="yes" xml:space="preserve">
          <source>from a timeout by switching to a backup Observable</source>
          <target state="translated">de un tiempo de espera al cambiar a una copia de seguridad Observable</target>
        </trans-unit>
        <trans-unit id="4ab8e53e57dab3b5525830c9e68479df42938a79" translate="yes" xml:space="preserve">
          <source>from an upstream error notification</source>
          <target state="translated">de una notificación de error ascendente</target>
        </trans-unit>
        <trans-unit id="7338bb521aa9cdd1bef4a257ca363c0096b6e672" translate="yes" xml:space="preserve">
          <source>from scratch, with custom logic</source>
          <target state="translated">desde cero,con una lógica personalizada</target>
        </trans-unit>
        <trans-unit id="5a492ec6db38b38bc93bc93c566d523b475eca95" translate="yes" xml:space="preserve">
          <source>given two or more source Observables, emit all of the items from only the first of these Observables to emit an item or notification</source>
          <target state="translated">dado que dos o más Observatorios fuente,emiten todos los artículos de sólo el primero de estos Observatorios para emitir un artículo o una notificación</target>
        </trans-unit>
        <trans-unit id="230d0d8c960eb6b08fb0602b808641addcc39716" translate="yes" xml:space="preserve">
          <source>happens-before</source>
          <target state="translated">happens-before</target>
        </trans-unit>
        <trans-unit id="51226a41675d8138b62f4eb13f05814105d80981" translate="yes" xml:space="preserve">
          <source>hot Observable</source>
          <target state="translated">caliente Observable</target>
        </trans-unit>
        <trans-unit id="762383040ebcbba981d0e6627015750c613068be" translate="yes" xml:space="preserve">
          <source>if a source Observable emits an error, resubscribe to it in the hopes that it will complete without error</source>
          <target state="translated">si una fuente observable emite un error,vuelva a suscribirse a ella con la esperanza de que se complete sin errores</target>
        </trans-unit>
        <trans-unit id="b7eef0381b59d94b8b2e60cf2c77d995768de18a" translate="yes" xml:space="preserve">
          <source>if a specified period of time elapses without it emitting an item</source>
          <target state="translated">si transcurre un período de tiempo determinado sin que emita un elemento</target>
        </trans-unit>
        <trans-unit id="c07264c1fd314b3c228343a6b7aa32c253cc1c83" translate="yes" xml:space="preserve">
          <source>if they immediately follow the item they are duplicates of</source>
          <target state="translated">si siguen inmediatamente al artículo son duplicados de</target>
        </trans-unit>
        <trans-unit id="847acd37db27d351d2cbeb11978036131dab6677" translate="yes" xml:space="preserve">
          <source>indicates that the Observable has completed successfully and that it will be emitting no further items</source>
          <target state="translated">indica que el Observable ha terminado con éxito y que no emitirá más artículos</target>
        </trans-unit>
        <trans-unit id="59bab5bf8560c12918e09739c3c2a53cf71eee79" translate="yes" xml:space="preserve">
          <source>indicates that the Observable has terminated with a specified error condition and that it will be emitting no further items</source>
          <target state="translated">indica que el Observatorio ha terminado con una condición de error especificada y que no emitirá más artículos</target>
        </trans-unit>
        <trans-unit id="57c80aa16dbb40cbb50b4685e19ae54bb36188e5" translate="yes" xml:space="preserve">
          <source>indicates that the Observable is ready to accept Request notifications from the observer (see</source>
          <target state="translated">indica que el Observador está dispuesto a aceptar las notificaciones de la Solicitud del observador (véase</target>
        </trans-unit>
        <trans-unit id="d80a3dc0bd493e47930194898002eecbd9780bcc" translate="yes" xml:space="preserve">
          <source>indicates that the observer is ready to receive notifications from the Observable</source>
          <target state="translated">indica que el observador está listo para recibir notificaciones del Observador</target>
        </trans-unit>
        <trans-unit id="03c2a4397d8fb4d3e801b370f28da5452181212d" translate="yes" xml:space="preserve">
          <source>indicates that the observer no longer wants to receive notifications from the Observable</source>
          <target state="translated">indica que el observador ya no desea recibir notificaciones del Observador</target>
        </trans-unit>
        <trans-unit id="7720d844d06776ca6a9a6e7116dc341d37719b6c" translate="yes" xml:space="preserve">
          <source>indicates that the observer wants no more than a particular number of additional OnNext notifications from the Observable (see</source>
          <target state="translated">indica que el observador no desea más que un número determinado de notificaciones OnNext adicionales del Observable (véase</target>
        </trans-unit>
        <trans-unit id="d772411175504239715809db32a049bd5f9a24eb" translate="yes" xml:space="preserve">
          <source>instruct a connectable Observable to begin emitting items to its subscribers</source>
          <target state="translated">instruye a un Observable conectable para que empiece a emitir artículos a sus suscriptores</target>
        </trans-unit>
        <trans-unit id="3e70b2ffd83c9f25ae3b87ef19a913ca3c280c74" translate="yes" xml:space="preserve">
          <source>instructs an Observable to begin emitting a second Observable sequence if it encounters an error</source>
          <target state="translated">instruye a un Observable para que empiece a emitir una segunda secuencia de Observable si encuentra un error</target>
        </trans-unit>
        <trans-unit id="d93ae2066632ae68fa3e9d24a83479d6a6125575" translate="yes" xml:space="preserve">
          <source>instructs an Observable to begin emitting a second Observable sequence if it encounters an error or if the source Observable terminates normally</source>
          <target state="translated">instruye a un Observable para que empiece a emitir una segunda secuencia de Observables si encuentra un error o si la fuente Observable termina normalmente</target>
        </trans-unit>
        <trans-unit id="c0cd3f6eebd1f6d2d2b9042e39803a1c070a6c65" translate="yes" xml:space="preserve">
          <source>instructs an Observable to begin emitting items from another Observable, or from an Observable returned from an action, if it encounters an error</source>
          <target state="translated">instruye a un Observador para que empiece a emitir elementos de otro Observador,o de un Observador devuelto de una acción,si encuentra un error</target>
        </trans-unit>
        <trans-unit id="22e38a48635b45db863e539f2c56ed48d008c816" translate="yes" xml:space="preserve">
          <source>instructs an Observable to concatenate items emitted by a set of other Observables, one Observable at a time, regardless of whether the source Observable or any subsequent Observable terminates with an error</source>
          <target state="translated">da instrucciones a un Observador para que concatene los elementos emitidos por un conjunto de otros Observadores,un Observador a la vez,independientemente de que la fuente Observable o cualquier Observador posterior termine con un error</target>
        </trans-unit>
        <trans-unit id="488263840997c93e29d532e89e384512092c9225" translate="yes" xml:space="preserve">
          <source>instructs an Observable to concatenate items emitted by another Observable to the sequence emitted by the source Observable, regardless of whether the source Observable terminates normally or with an error</source>
          <target state="translated">instruye a un Observable para que concatene los elementos emitidos por otro Observable con la secuencia emitida por el Observable fuente,independientemente de que el Observable fuente termine normalmente o con un error</target>
        </trans-unit>
        <trans-unit id="97c6213e9fd3b3b94003a1080aa20fcc201250e2" translate="yes" xml:space="preserve">
          <source>instructs an Observable to continue emitting items after it encounters an exception (but not another variety of throwable)</source>
          <target state="translated">instruye a un Observador para que continúe emitiendo artículos después de que se encuentre con una excepción (pero no otra variedad de artículos que se puedan tirar)</target>
        </trans-unit>
        <trans-unit id="ffd411015f886b118c92de6b6395db72b3070d73" translate="yes" xml:space="preserve">
          <source>instructs an Observable to emit a particular item when it encounters an error, and then terminate normally</source>
          <target state="translated">instruye a un Observable para que emita un elemento particular cuando encuentre un error,y luego termina normalmente</target>
        </trans-unit>
        <trans-unit id="4d7e5498f8a1b2653573be7dedf0e0305669acdd" translate="yes" xml:space="preserve">
          <source>instructs an Observable, if it encounters an error, to begin emitting items from a set of other Observables, one Observable at a time, until one of those Observables terminates successfully</source>
          <target state="translated">instruye a un Observador,si encuentra un error,para que empiece a emitir elementos de un conjunto de otros Observadores,un Observador a la vez,hasta que uno de esos Observadores termine con éxito</target>
        </trans-unit>
        <trans-unit id="4b601dbe8a076d8fccff82083667b82ac9cbcaf2" translate="yes" xml:space="preserve">
          <source>instructs the Single to call the subscriber methods on a particular &lt;a href=&quot;scheduler&quot;&gt;Scheduler&lt;/a&gt;</source>
          <target state="translated">le indica al Single que llame a los m&amp;eacute;todos de suscriptor en un &lt;a href=&quot;scheduler&quot;&gt;Programador en&lt;/a&gt; particular</target>
        </trans-unit>
        <trans-unit id="eca0b3496b0773e9004170e5ee17829fa81e2cfc" translate="yes" xml:space="preserve">
          <source>instructs the Single to operate on a particular &lt;a href=&quot;scheduler&quot;&gt;Scheduler&lt;/a&gt;</source>
          <target state="translated">le indica al Single que opere en un &lt;a href=&quot;scheduler&quot;&gt;Programador en&lt;/a&gt; particular</target>
        </trans-unit>
        <trans-unit id="c357df049720e803767baccb0a0919d8ae438720" translate="yes" xml:space="preserve">
          <source>integers starting with &lt;code&gt;1&lt;/code&gt; and converts it, via &lt;code&gt;scan&lt;/code&gt;, into an Observable that emits the first</source>
          <target state="translated">enteros que comienzan con &lt;code&gt;1&lt;/code&gt; y lo convierte, a trav&amp;eacute;s de &lt;code&gt;scan&lt;/code&gt; , en un Observable que emite el primer</target>
        </trans-unit>
        <trans-unit id="5c66328e63d2651a8680db012ecb04a1e0c9fb8d" translate="yes" xml:space="preserve">
          <source>into an indicator of the amount of time that lapsed before the emission of the item</source>
          <target state="translated">en un indicador de la cantidad de tiempo que transcurrió antes de la emisión del artículo</target>
        </trans-unit>
        <trans-unit id="6e92086dca618f4ee5c9fb6bfd63624bbdfcf042" translate="yes" xml:space="preserve">
          <source>into one that emits objects of type &lt;code&gt;Timestamped&amp;lt;&lt;i&gt;T&lt;/i&gt;&amp;gt;&lt;/code&gt;, where each such object is stamped with the time at which it was originally emitted.</source>
          <target state="translated">en uno que emite objetos de tipo &lt;code&gt;Timestamped&amp;lt;&lt;i&gt;T&lt;/i&gt;&amp;gt;&lt;/code&gt; , donde cada objeto se marca con la hora en que se emiti&amp;oacute; originalmente.</target>
        </trans-unit>
        <trans-unit id="18ab6ac7001b131bc4dc74bd619c612205dff372" translate="yes" xml:space="preserve">
          <source>is equivalent to:</source>
          <target state="translated">es equivalente a:</target>
        </trans-unit>
        <trans-unit id="f2ab6d76f77af5073047a5a0bc5e4892cf2ac71b" translate="yes" xml:space="preserve">
          <source>it (this also initiates the actions of the Observable).</source>
          <target state="translated">(esto también inicia las acciones del Observable).</target>
        </trans-unit>
        <trans-unit id="3a7d9767b1233601ebf8b67495c6dc2ce8b8c2af" translate="yes" xml:space="preserve">
          <source>item</source>
          <target state="translated">item</target>
        </trans-unit>
        <trans-unit id="7316c8b2e74870d9d7e9d30bbc28ecf4cdf945ee" translate="yes" xml:space="preserve">
          <source>items</source>
          <target state="translated">items</target>
        </trans-unit>
        <trans-unit id="54cecc63037672c9d565bd5b413cdb087c5f46ac" translate="yes" xml:space="preserve">
          <source>items before completing, the new, &lt;code&gt;take&lt;/code&gt;-modified Observable will not throw an exception or invoke &lt;code&gt;onError&lt;/code&gt;, but will merely emit this same fewer number of items before it completes.</source>
          <target state="translated">elementos antes de completarlos, el nuevo Observable modificado por &lt;code&gt;take&lt;/code&gt; no lanzar&amp;aacute; una excepci&amp;oacute;n ni invocar&amp;aacute; un &lt;code&gt;onError&lt;/code&gt; , sino que simplemente emitir&amp;aacute; este mismo n&amp;uacute;mero menor de elementos antes de que se complete.</target>
        </trans-unit>
        <trans-unit id="5cc703698419188f6748e57d5051172e7578d5ef" translate="yes" xml:space="preserve">
          <source>items emitted by an Observable</source>
          <target state="translated">los artículos emitidos por un Observador</target>
        </trans-unit>
        <trans-unit id="281b0dc3c88a6285d1fcc3248e4b72d6d13752fa" translate="yes" xml:space="preserve">
          <source>items emitted by an Observable and attend only to those items that come after, by modifying the Observable with the Skip operator.</source>
          <target state="translated">los artículos emitidos por un Observador y atender sólo a los que vienen después,modificando el Observador con el operador Skip.</target>
        </trans-unit>
        <trans-unit id="256cbf4eb14c5d64b17e59041c7002ce9915bf97" translate="yes" xml:space="preserve">
          <source>items emitted by an Observable and attend only to those items that come before them, by modifying the Observable with the SkipLast operator.</source>
          <target state="translated">los artículos emitidos por un Observador y atender sólo a los artículos que le preceden,modificando el Observador con el operador SkipLast.</target>
        </trans-unit>
        <trans-unit id="1bcdfca876104995c38c6ca1144b2b6e6f5fa505" translate="yes" xml:space="preserve">
          <source>items emitted by an Observable and attend only to those items that precede them, by modifying the Observable with the &lt;code&gt;skipLast(&lt;i&gt;n&lt;/i&gt;)&lt;/code&gt; operator. Note that the mechanism by which this is implemented will delay the emission of any item from the source Observable until</source>
          <target state="translated">elementos emitidos por un Observable y atienden solo a aquellos elementos que los preceden, modificando el Observable con el &lt;code&gt;skipLast(&lt;i&gt;n&lt;/i&gt;)&lt;/code&gt; . Tenga en cuenta que el mecanismo por el cual esto se implementa retrasar&amp;aacute; la emisi&amp;oacute;n de cualquier elemento de la fuente Observable hasta</target>
        </trans-unit>
        <trans-unit id="1ce3138e6873c0e9bb2af30c7b2c8ddfc633bf03" translate="yes" xml:space="preserve">
          <source>items emitted by an Observable and ignore those items that come before them, by modifying the Observable with the TakeLast operator.</source>
          <target state="translated">los elementos emitidos por un Observable e ignorar los elementos que le preceden,modificando el Observable con el operador TakeLast.</target>
        </trans-unit>
        <trans-unit id="627d3004856c8c25ed154bf10b211c198e92ed99" translate="yes" xml:space="preserve">
          <source>items emitted by an Observable and ignore those items that precede them, by modifying the Observable with the &lt;code&gt;takeLast(&lt;i&gt;n&lt;/i&gt;)&lt;/code&gt; operator. Note that this will delay the emission of any item from the source Observable until that Observable completes.</source>
          <target state="translated">elementos emitidos por un Observable e ignore los elementos que los preceden, modificando el Observable con el &lt;code&gt;takeLast(&lt;i&gt;n&lt;/i&gt;)&lt;/code&gt; . Tenga en cuenta que esto retrasar&amp;aacute; la emisi&amp;oacute;n de cualquier elemento de la fuente Observable hasta que se complete el Observable.</target>
        </trans-unit>
        <trans-unit id="e78d9230f84809bd8259c4cdacd12e1311cbf6b2" translate="yes" xml:space="preserve">
          <source>items emitted by an Observable and ignore those items that precede them, by modifying the Observable with the &lt;code&gt;takeLast(&lt;i&gt;n&lt;/i&gt;)&lt;/code&gt; operator. Note that this will delay the emission of any item from the source Observable until the source Observable completes.</source>
          <target state="translated">elementos emitidos por un Observable e ignore los elementos que los preceden, modificando el Observable con el &lt;code&gt;takeLast(&lt;i&gt;n&lt;/i&gt;)&lt;/code&gt; . Tenga en cuenta que esto retrasar&amp;aacute; la emisi&amp;oacute;n de cualquier elemento de la fuente Observable hasta que se complete la fuente Observable.</target>
        </trans-unit>
        <trans-unit id="3bbe910e0e0b20f8e7a00952441aa27949753b14" translate="yes" xml:space="preserve">
          <source>items emitted by an Observable and then complete while ignoring the remainder, by modifying the Observable with the Take operator.</source>
          <target state="translated">los elementos emitidos por un Observable y luego completarlos ignorando el resto,modificando el Observable con el operador Take.</target>
        </trans-unit>
        <trans-unit id="8638cd8395daa1b642320bfea0b50152c0b101a3" translate="yes" xml:space="preserve">
          <source>items emitted by the bursty Observable.</source>
          <target state="translated">elementos emitidos por el explosivo Observable.</target>
        </trans-unit>
        <trans-unit id="a7b968713a235f777cf138dc3695594bad65a2ed" translate="yes" xml:space="preserve">
          <source>items, which allows the &lt;code&gt;ControlledObservable&lt;/code&gt; to run somewhat ahead of the observer from time to time. &lt;code&gt;windowed(1)&lt;/code&gt; is equivalent to &lt;code&gt;stopAndWait&lt;/code&gt;.</source>
          <target state="translated">items, lo que permite que &lt;code&gt;ControlledObservable&lt;/code&gt; se ejecute un poco antes que el observador de vez en cuando. &lt;code&gt;windowed(1)&lt;/code&gt; es equivalente a &lt;code&gt;stopAndWait&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="252b793f4b97747e8725e6d8dc5ba3b8321dc7d6" translate="yes" xml:space="preserve">
          <source>jort.technology</source>
          <target state="translated">jort.technology</target>
        </trans-unit>
        <trans-unit id="d95b79cfc988b3b165ceb830a9c8932d1b52cf18" translate="yes" xml:space="preserve">
          <source>just</source>
          <target state="translated">just</target>
        </trans-unit>
        <trans-unit id="a62f2225bf70bfaccbc7f1ef2a397836717377de" translate="yes" xml:space="preserve">
          <source>key</source>
          <target state="translated">key</target>
        </trans-unit>
        <trans-unit id="0c1beb7946903d44f31f6b86cf15dfddb1b73736" translate="yes" xml:space="preserve">
          <source>make a Connectable Observable behave like an ordinary Observable</source>
          <target state="translated">hacen que un Observable Conectable se comporte como un Observable ordinario</target>
        </trans-unit>
        <trans-unit id="37745ed7a0f005fb14522c5cc7c1ba3d9e0df579" translate="yes" xml:space="preserve">
          <source>map</source>
          <target state="translated">map</target>
        </trans-unit>
        <trans-unit id="79d67b9fd09cde874d173f35b4df9504ff9198eb" translate="yes" xml:space="preserve">
          <source>meant for I/O-bound work such as asynchronous performance of blocking I/O, this scheduler is backed by a thread-pool that will grow as needed; for ordinary computational work, switch to &lt;code&gt;Schedulers.computation( )&lt;/code&gt;; &lt;code&gt;Schedulers.io( )&lt;/code&gt; by default is a &lt;code&gt;CachedThreadScheduler&lt;/code&gt;, which is something like a new thread scheduler with thread caching</source>
          <target state="translated">dise&amp;ntilde;ado para trabajos vinculados a E / S, como el rendimiento as&amp;iacute;ncrono de bloqueo de E / S, este planificador est&amp;aacute; respaldado por un grupo de subprocesos que crecer&amp;aacute; seg&amp;uacute;n sea necesario; para el trabajo computacional ordinario, cambie a &lt;code&gt;Schedulers.computation( )&lt;/code&gt; ; &lt;code&gt;Schedulers.io( )&lt;/code&gt; por defecto es un &lt;code&gt;CachedThreadScheduler&lt;/code&gt; , que es algo as&amp;iacute; como un nuevo programador de subprocesos con almacenamiento en cach&amp;eacute; de subprocesos</target>
        </trans-unit>
        <trans-unit id="a1b2d933157904f1909eba2778bc1b0bc5b32a0f" translate="yes" xml:space="preserve">
          <source>meant for computational work such as event-loops and callback processing; do not use this scheduler for I/O (use &lt;code&gt;Schedulers.io( )&lt;/code&gt; instead); the number of threads, by default, is equal to the number of processors</source>
          <target state="translated">destinado al trabajo computacional como bucles de eventos y procesamiento de devoluci&amp;oacute;n de llamada; no use este programador para E / S (use &lt;code&gt;Schedulers.io( )&lt;/code&gt; lugar); el n&amp;uacute;mero de subprocesos, por defecto, es igual al n&amp;uacute;mero de procesadores</target>
        </trans-unit>
        <trans-unit id="14091a9f2461267ee7e02525b4f1f2923f1c9849" translate="yes" xml:space="preserve">
          <source>merge</source>
          <target state="translated">merge</target>
        </trans-unit>
        <trans-unit id="b5a02016a0682c002da94900aa3dd08ee317e771" translate="yes" xml:space="preserve">
          <source>merge and mergeWith</source>
          <target state="translated">se fusionan y se fusionan con</target>
        </trans-unit>
        <trans-unit id="754ffff9989c69728e41fa3f602dea0149183089" translate="yes" xml:space="preserve">
          <source>mergeWith</source>
          <target state="translated">mergeWith</target>
        </trans-unit>
        <trans-unit id="6d5c675bf8edaff2c66ed7c992b706e5704acdc8" translate="yes" xml:space="preserve">
          <source>merges the items emitted by multiple Singles as Observable emissions</source>
          <target state="translated">fusiona los elementos emitidos por múltiples individuales como emisiones observables</target>
        </trans-unit>
        <trans-unit id="1373a31197b556329ac156e7ade9cb2ba85e793d" translate="yes" xml:space="preserve">
          <source>mirror items emitted by an Observable until a specified condition becomes false</source>
          <target state="translated">los artículos de espejo emitidos por un Observable hasta que una condición especificada se vuelve falsa</target>
        </trans-unit>
        <trans-unit id="69e7a4a6098f21dd74f0e5d1f1183014c08998d2" translate="yes" xml:space="preserve">
          <source>mirror the source Observable, but issue an error notification if a particular period of time elapses without any emitted items</source>
          <target state="translated">reflejan la fuente Observable,pero emiten una notificación de error si transcurre un período de tiempo determinado sin que se emita ningún elemento</target>
        </trans-unit>
        <trans-unit id="648302e50e59872ed27b6c579097c5a430271379" translate="yes" xml:space="preserve">
          <source>mirrors items from the source Observable until this absolute time</source>
          <target state="translated">refleja los artículos de la fuente Observable hasta este momento absoluto</target>
        </trans-unit>
        <trans-unit id="1c73d060d2a786fb5a45214e5514f3329b981c55" translate="yes" xml:space="preserve">
          <source>mirrors items from the source Observable until this many milliseconds have passed since the Observable was subscribed to</source>
          <target state="translated">refleja los artículos de la fuente Observable hasta que hayan pasado tantos milisegundos desde que el Observable se suscribió a</target>
        </trans-unit>
        <trans-unit id="da434d1b08108bb48efd1b874843206b9adea4d0" translate="yes" xml:space="preserve">
          <source>move the emission of an item from a Single forward in time</source>
          <target state="translated">mover la emisión de un artículo de un Único hacia adelante en el tiempo</target>
        </trans-unit>
        <trans-unit id="a94e19af4af9c51d17a33a85b88b9c524903d431" translate="yes" xml:space="preserve">
          <source>multiple items</source>
          <target state="translated">varios elementos</target>
        </trans-unit>
        <trans-unit id="d1854cae891ec7b29161ccaf79a24b00c274bdaa" translate="yes" xml:space="preserve">
          <source>n</source>
          <target state="translated">n</target>
        </trans-unit>
        <trans-unit id="1b60d2ed7158736cbc1353d72a6dc44a6772147f" translate="yes" xml:space="preserve">
          <source>notifications</source>
          <target state="translated">notifications</target>
        </trans-unit>
        <trans-unit id="d29d85b4e7d22abd97299321615272b226b96438" translate="yes" xml:space="preserve">
          <source>notifications and understands</source>
          <target state="translated">notificaciones y entiende</target>
        </trans-unit>
        <trans-unit id="133b33b5c57f2a5dc33401a8b5b7d96bac8376ad" translate="yes" xml:space="preserve">
          <source>notifications.</source>
          <target state="translated">notifications.</target>
        </trans-unit>
        <trans-unit id="560c4dbd7c1a66afc1b71b103a23f7c108007205" translate="yes" xml:space="preserve">
          <source>observeOn</source>
          <target state="translated">observeOn</target>
        </trans-unit>
        <trans-unit id="307527c227ac648bb119bcb457ebb8466e79827c" translate="yes" xml:space="preserve">
          <source>observer</source>
          <target state="translated">observer</target>
        </trans-unit>
        <trans-unit id="cabaf29399c77e9ce3c5ed70182997a660a42de0" translate="yes" xml:space="preserve">
          <source>onCompleted</source>
          <target state="translated">onCompleted</target>
        </trans-unit>
        <trans-unit id="34c18e24d1dfbbb529faba38b503601cb512f20e" translate="yes" xml:space="preserve">
          <source>onError</source>
          <target state="translated">onError</target>
        </trans-unit>
        <trans-unit id="1ec9553944d373e3c5ccee85191a76e3362aa2c2" translate="yes" xml:space="preserve">
          <source>onErrorReturn</source>
          <target state="translated">onErrorReturn</target>
        </trans-unit>
        <trans-unit id="8cffc1eb25befde35dc9a29caa8d3c1b3fdf164c" translate="yes" xml:space="preserve">
          <source>onNext</source>
          <target state="translated">onNext</target>
        </trans-unit>
        <trans-unit id="bc8d0ce7f27d4c43756b40ce541d77416645f7ef" translate="yes" xml:space="preserve">
          <source>onNext, onCompleted, and onError</source>
          <target state="translated">enNext,enCompletado,y enError</target>
        </trans-unit>
        <trans-unit id="df2505265f9a2c8f72075dad202d8fb79cdac569" translate="yes" xml:space="preserve">
          <source>onSuccess</source>
          <target state="translated">onSuccess</target>
        </trans-unit>
        <trans-unit id="b40cdaa970a1b4cc121d9b48173fcaff7e0f15d4" translate="yes" xml:space="preserve">
          <source>one Observable at a time, in the order they are emitted</source>
          <target state="translated">uno a uno,en el orden en que se emiten.</target>
        </trans-unit>
        <trans-unit id="9499006797e3e9becedebbe4f06adec371d9a167" translate="yes" xml:space="preserve">
          <source>one at a time with a function</source>
          <target state="translated">uno a uno con una función</target>
        </trans-unit>
        <trans-unit id="1b0bb14695267c72adf406bf3902f0603344f4e9" translate="yes" xml:space="preserve">
          <source>only emit an item from an Observable if a particular timespan has passed without it emitting another item</source>
          <target state="translated">sólo emiten un elemento de un Observable si ha transcurrido un período de tiempo determinado sin que emita otro elemento</target>
        </trans-unit>
        <trans-unit id="8f907d09e23699668d1792d557974f49ae533d7c" translate="yes" xml:space="preserve">
          <source>only if its sequence is empty</source>
          <target state="translated">sólo si su secuencia está vacía</target>
        </trans-unit>
        <trans-unit id="5395918d1a7cce46854ed435b45bff5e7397a9a0" translate="yes" xml:space="preserve">
          <source>operate upon the emissions and notifications from an Observable</source>
          <target state="translated">funcionan a partir de las emisiones y notificaciones de un Observador</target>
        </trans-unit>
        <trans-unit id="fe96dd39756ac41b74283a9292652d366d73931f" translate="yes" xml:space="preserve">
          <source>operator</source>
          <target state="translated">operator</target>
        </trans-unit>
        <trans-unit id="2a8c5cef636d11d3f64dcc36efc3ac4b5978eb60" translate="yes" xml:space="preserve">
          <source>operator converts a source Observable into an Observable that emits indications of the amount of time lapsed between consecutive emissions of the source Observable. The first emission from this new Observable indicates the amount of time lapsed between the time when the observer subscribed to the Observable and the time when the source Observable emitted its first item. There is no corresponding emission marking the amount of time lapsed between the last emission of the source Observable and the subsequent call to &lt;code&gt;onCompleted&lt;/code&gt;.</source>
          <target state="translated">El operador convierte una fuente Observable en Observable que emite indicaciones de la cantidad de tiempo transcurrido entre las emisiones consecutivas de la fuente Observable. La primera emisi&amp;oacute;n de este nuevo Observable indica la cantidad de tiempo transcurrido entre el momento en que el observador se suscribi&amp;oacute; al Observable y el momento en que la fuente Observable emiti&amp;oacute; su primer elemento. No hay una emisi&amp;oacute;n correspondiente que marque la cantidad de tiempo transcurrido entre la &amp;uacute;ltima emisi&amp;oacute;n de la fuente Observable y la siguiente llamada a &lt;code&gt;onCompleted&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66fc7ee958ea8e350bc6b87518bc06ff7e386c28" translate="yes" xml:space="preserve">
          <source>or sends</source>
          <target state="translated">o envía</target>
        </trans-unit>
        <trans-unit id="22e3ca60f9f989b91acea4f38bac56355b1ea1e5" translate="yes" xml:space="preserve">
          <source>otherwise: &lt;code&gt;rx.lite.js&lt;/code&gt; or &lt;code&gt;rx.lite.compat.js&lt;/code&gt;</source>
          <target state="translated">de lo contrario: &lt;code&gt;rx.lite.js&lt;/code&gt; o &lt;code&gt;rx.lite.compat.js&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aebaa77adbf6e1ab8dd65462495edf64837ccf37" translate="yes" xml:space="preserve">
          <source>periodically gather items emitted by an Observable into bundles and emit these bundles rather than emitting the items one at a time</source>
          <target state="translated">reunir periódicamente los artículos emitidos por un Observador en paquetes y emitir estos paquetes en lugar de emitir los artículos uno a uno</target>
        </trans-unit>
        <trans-unit id="66566ba8929f0e65118531a524420a0447fc130a" translate="yes" xml:space="preserve">
          <source>periodically subdivide items from an Observable into Observable windows and emit these windows rather than emitting the items one at a time</source>
          <target state="translated">subdividir periódicamente los artículos de un Observable en ventanas de Observable y emitir estas ventanas en lugar de emitir los artículos de uno en uno</target>
        </trans-unit>
        <trans-unit id="231e65684158501c2336cbfcb310e00fcb24c73a" translate="yes" xml:space="preserve">
          <source>purpose</source>
          <target state="translated">purpose</target>
        </trans-unit>
        <trans-unit id="4cc45ea2a949b9dd69fb4880e9ac06e94bde81b9" translate="yes" xml:space="preserve">
          <source>queues work to begin on the current thread after any already-queued work</source>
          <target state="translated">las colas de trabajo para comenzar en el hilo actual después de cualquier trabajo ya en cola</target>
        </trans-unit>
        <trans-unit id="9da83891bf1aa57c20a6c75cc2a6001679fd362b" translate="yes" xml:space="preserve">
          <source>recover from an onError notification by continuing the sequence without error</source>
          <target state="translated">recuperarse de una notificación de onError continuando la secuencia sin errores</target>
        </trans-unit>
        <trans-unit id="029c86507f454275f2dddfe843b1bf03334a3d19" translate="yes" xml:space="preserve">
          <source>register an action to take upon a variety of Observable lifecycle events</source>
          <target state="translated">registrar una acción para tomar una variedad de eventos observables del ciclo de vida</target>
        </trans-unit>
        <trans-unit id="16529dc63377ab5e64b0efbeca6d2e56779f6316" translate="yes" xml:space="preserve">
          <source>relationship between the notifications.</source>
          <target state="translated">relación entre las notificaciones.</target>
        </trans-unit>
        <trans-unit id="38bbe4da48e39e37646b87da88c2ef296e178ab7" translate="yes" xml:space="preserve">
          <source>replaces all &lt;code&gt;onError&lt;/code&gt; notifications from a misbehaving Observable into the emissions from a secondary Observable</source>
          <target state="translated">reemplaza todas &lt;code&gt;onError&lt;/code&gt; notificaciones de error de un Observable con mal comportamiento en las emisiones de un Observable secundario</target>
        </trans-unit>
        <trans-unit id="3f11990ccf2c77aba0c6c6712860414435d406c7" translate="yes" xml:space="preserve">
          <source>represent both the items emitted and the notifications sent as emitted items, or reverse this process</source>
          <target state="translated">representan tanto los artículos emitidos como las notificaciones enviadas como artículos emitidos,o invierten este proceso</target>
        </trans-unit>
        <trans-unit id="fc9aca251c84d76a6a0d931957efb486d507bcc2" translate="yes" xml:space="preserve">
          <source>resembles an ordinary Observable, except that it does not begin emitting items when it is subscribed to, but only when the Connect operator is applied to it. In this way you can prompt an Observable to begin emitting items at a time of your choosing.</source>
          <target state="translated">se asemeja a un Observable ordinario,salvo que no comienza a emitir elementos cuando se suscribe,sino sólo cuando se le aplica el operador Connect.De esta forma,puedes pedirle a un Observable que empiece a emitir elementos en el momento que tú elijas.</target>
        </trans-unit>
        <trans-unit id="fd09d85570e685cf25806e8c97a9cae9bc76d4c3" translate="yes" xml:space="preserve">
          <source>resembles an ordinary Observable, except that it does not begin emitting items when it is subscribed to, but only when the Connect operator is applied to it. In this way you can wait for all intended observers to subscribe to the Observable before the Observable begins emitting items.</source>
          <target state="translated">se asemeja a un Observable ordinario,salvo que no comienza a emitir elementos cuando se suscribe,sino sólo cuando se le aplica el operador Connect.De esta manera se puede esperar a que todos los observadores previstos se suscriban al Observable antes de que éste comience a emitir elementos.</target>
        </trans-unit>
        <trans-unit id="97a2a5e27c5d084c0dd5bee32de01ad786ad79e8" translate="yes" xml:space="preserve">
          <source>retrieve data</source>
          <target state="translated">recuperar los datos</target>
        </trans-unit>
        <trans-unit id="414e681ebabcd2f23de1f32468992b9c81c5f909" translate="yes" xml:space="preserve">
          <source>returns</source>
          <target state="translated">returns</target>
        </trans-unit>
        <trans-unit id="614fab05e39a4e771b71b18872fad9237db48830" translate="yes" xml:space="preserve">
          <source>returns a Single that also calls a method you specify when it calls onError</source>
          <target state="translated">devuelve un Single que también llama a un método que usted especifica cuando llama aError</target>
        </trans-unit>
        <trans-unit id="2cbcba5aecafd2534b89b0451d26040bd4880f33" translate="yes" xml:space="preserve">
          <source>returns a Single that also calls a method you specify when it calls onSuccess</source>
          <target state="translated">devuelve un Single que también llama a un método que usted especifica cuando llama a OnSuccess</target>
        </trans-unit>
        <trans-unit id="de9f4dcfa7411bbd303b05c9c4d627cf206844d3" translate="yes" xml:space="preserve">
          <source>returns a Single that emits a specified item</source>
          <target state="translated">devuelve un Single que emite un elemento específico</target>
        </trans-unit>
        <trans-unit id="789a106c2f647946e92573c3b1777edc55349f0a" translate="yes" xml:space="preserve">
          <source>returns a Single that emits an item that is the result of a function applied to items emitted by two or more other Singles</source>
          <target state="translated">devuelve un Soltero que emite un artículo que es el resultado de una función aplicada a artículos emitidos por otros dos o más Solteros</target>
        </trans-unit>
        <trans-unit id="19e291b4d133b23269dc04e8ef9d5fe9961d07e2" translate="yes" xml:space="preserve">
          <source>returns a Single that emits the result of a function applied to the item emitted by the source Single</source>
          <target state="translated">devuelve un Single que emite el resultado de una función aplicada al elemento emitido por la fuente Single</target>
        </trans-unit>
        <trans-unit id="ae8c346ab8cb11f2953656ad7208884e7770d344" translate="yes" xml:space="preserve">
          <source>returns a Single that immediately notifies subscribers of an error</source>
          <target state="translated">devuelve un Single que notifica inmediatamente a los suscriptores de un error</target>
        </trans-unit>
        <trans-unit id="644da51fb0f4c8e691099129ff2c304b9011980b" translate="yes" xml:space="preserve">
          <source>returns a Single that is the result of a function applied to an item emitted by a Single</source>
          <target state="translated">devuelve un Single que es el resultado de una función aplicada a un elemento emitido por un Single</target>
        </trans-unit>
        <trans-unit id="9d99fbe394a3cd2d6250690cb04bc2bae5e7789b" translate="yes" xml:space="preserve">
          <source>returns a Single that makes an error notification if the source Single does not emit a value in a specified time period</source>
          <target state="translated">devuelve un Single que hace una notificación de error si el Single de origen no emite un valor en un período de tiempo determinado</target>
        </trans-unit>
        <trans-unit id="ccc187c8d1099bc534bf656707e72f0b93487700" translate="yes" xml:space="preserve">
          <source>returns an Observable that is the result of a function applied to an item emitted by a Single</source>
          <target state="translated">devuelve un Observable que es el resultado de una función aplicada a un elemento emitido por una</target>
        </trans-unit>
        <trans-unit id="2d2ace357f46b9793f247eb0f1b39b5c06f1c284" translate="yes" xml:space="preserve">
          <source>schedules work as soon as possible on the current thread</source>
          <target state="translated">programa de trabajo tan pronto como sea posible en el hilo actual</target>
        </trans-unit>
        <trans-unit id="e2a05abe2afd449104bbe88995191b2546c2e36e" translate="yes" xml:space="preserve">
          <source>schedules work as though it were occurring at an arbitrary historical time</source>
          <target state="translated">los horarios funcionan como si ocurriera en un momento histórico arbitrario</target>
        </trans-unit>
        <trans-unit id="212804707d4553d4a9de98cd16a47586293da44e" translate="yes" xml:space="preserve">
          <source>schedules work by means of a timed callback</source>
          <target state="translated">programa el trabajo por medio de una llamada cronometrada</target>
        </trans-unit>
        <trans-unit id="0c6afaa2e04609f1ec3894129ba5ef333342b74b" translate="yes" xml:space="preserve">
          <source>schedules work immediately on the current thread</source>
          <target state="translated">los programas trabajan inmediatamente en el hilo actual</target>
        </trans-unit>
        <trans-unit id="6fd22fa59e4504bd3abe47116c75ba5d9520c2e4" translate="yes" xml:space="preserve">
          <source>schedules work to begin immediately in the current thread</source>
          <target state="translated">programa el trabajo para comenzar inmediatamente en el hilo actual</target>
        </trans-unit>
        <trans-unit id="ec5b10f224197c50b751cb29d575291de5a89193" translate="yes" xml:space="preserve">
          <source>shift the emissions from an Observable forward in time by a particular amount</source>
          <target state="translated">desplazan las emisiones de un observable hacia adelante en el tiempo en una cantidad determinada</target>
        </trans-unit>
        <trans-unit id="b6974d3c4c90f4bf308b7ceaad732a8411683831" translate="yes" xml:space="preserve">
          <source>single items</source>
          <target state="translated">elementos individuales</target>
        </trans-unit>
        <trans-unit id="4685ae520d469fe19757bc73a43fbb3e23d2eb64" translate="yes" xml:space="preserve">
          <source>skips items from the source Observable until this absolute time</source>
          <target state="translated">salta los artículos de la fuente Observable hasta este momento absoluto</target>
        </trans-unit>
        <trans-unit id="ec4661659182b1a32546f8ee26df269f5ff633bd" translate="yes" xml:space="preserve">
          <source>skips items from the source Observable until this many milliseconds have passed since the Observable was subscribed to</source>
          <target state="translated">se salta los artículos de la fuente del Observable hasta que hayan pasado tantos milisegundos desde que se suscribió el Observable</target>
        </trans-unit>
        <trans-unit id="d722e800457c1e3ff47b9919aacf412d58517e76" translate="yes" xml:space="preserve">
          <source>so that similar items end up on the same Observable</source>
          <target state="translated">de modo que artículos similares terminen en el mismo observable</target>
        </trans-unit>
        <trans-unit id="23f99c77497b013cb84fa93d00cd562cd60bc053" translate="yes" xml:space="preserve">
          <source>specify the Scheduler on which an Observable will operate</source>
          <target state="translated">especificar el Planificador en el que operará un Observador</target>
        </trans-unit>
        <trans-unit id="c1af98d719e46cb1c263d1f07f1d142225f032b5" translate="yes" xml:space="preserve">
          <source>specify the Scheduler on which an observer will observe this Observable</source>
          <target state="translated">especificar el Planificador en el que un observador observará este Observable</target>
        </trans-unit>
        <trans-unit id="8cc70babc917973e7be2341bdf842422d8559507" translate="yes" xml:space="preserve">
          <source>start any unstarted actions that have been scheduled for a time equal to or earlier than the present time according to the Scheduler&amp;rsquo;s clock</source>
          <target state="translated">iniciar cualquier acci&amp;oacute;n no iniciada que haya sido programada para una hora igual o anterior a la hora actual seg&amp;uacute;n el reloj del Programador</target>
        </trans-unit>
        <trans-unit id="d9b4f1177afce043722bb47561fbe3b4f6b4cb6b" translate="yes" xml:space="preserve">
          <source>strategies for coping with Observables that produce items more rapidly than their observers consume them</source>
          <target state="translated">estrategias para hacer frente a los Observables que producen artículos más rápidamente de lo que sus observadores los consumen</target>
        </trans-unit>
        <trans-unit id="22fd962474489207eb05adb7a8bcf49b937562b8" translate="yes" xml:space="preserve">
          <source>subscribe a single function to either the &lt;code&gt;onNext&lt;/code&gt;, the &lt;code&gt;onCompleted&lt;/code&gt;, or &lt;code&gt;onError&lt;/code&gt; notifications from an Observable, with &lt;code&gt;subscribeOnNext&lt;/code&gt;, &lt;code&gt;subscribeOnCompleted&lt;/code&gt;, or &lt;code&gt;subscribeOnError&lt;/code&gt; respectively</source>
          <target state="translated">suscribir una sola funci&amp;oacute;n a las &lt;code&gt;onNext&lt;/code&gt; , &lt;code&gt;onCompleted&lt;/code&gt; o &lt;code&gt;onError&lt;/code&gt; de un Observable, con &lt;code&gt;subscribeOnNext&lt;/code&gt; , &lt;code&gt;subscribeOnCompleted&lt;/code&gt; o &lt;code&gt;subscribeOnError&lt;/code&gt; respectivamente</target>
        </trans-unit>
        <trans-unit id="e9b287045b72e71494407f32ddc237ffeab5305a" translate="yes" xml:space="preserve">
          <source>subscribe by passing zero to three individual functions, or an object that implements those three functions, into either the &lt;code&gt;subscribe&lt;/code&gt; or &lt;code&gt;forEach&lt;/code&gt; operator (those operators behave identically).</source>
          <target state="translated">subscribe pasando de cero a tres funciones individuales, o un objeto que implemente esas tres funciones, en el operador &lt;code&gt;subscribe&lt;/code&gt; o &lt;code&gt;forEach&lt;/code&gt; (esos operadores se comportan de manera id&amp;eacute;ntica).</target>
        </trans-unit>
        <trans-unit id="ec9eb83261701c10244989eda4480cd0bc34282e" translate="yes" xml:space="preserve">
          <source>subscribeOn</source>
          <target state="translated">subscribeOn</target>
        </trans-unit>
        <trans-unit id="2f11a7869397c6279959fc770e96943449c6adc0" translate="yes" xml:space="preserve">
          <source>subscribes</source>
          <target state="translated">subscribes</target>
        </trans-unit>
        <trans-unit id="e45026cdc19b9b8ae7cd208d230ff92042c526de" translate="yes" xml:space="preserve">
          <source>subscribing</source>
          <target state="translated">subscribing</target>
        </trans-unit>
        <trans-unit id="a73cae38ca4e4c1f5ee35e5e1ab9e4023e603395" translate="yes" xml:space="preserve">
          <source>suppress duplicate items emitted by an Observable</source>
          <target state="translated">suprimir los artículos duplicados emitidos por un Observador</target>
        </trans-unit>
        <trans-unit id="e82088f5062344b73a3c19fab602396d690426d8" translate="yes" xml:space="preserve">
          <source>suppress the final</source>
          <target state="translated">suprimir el final</target>
        </trans-unit>
        <trans-unit id="c3865777c46bf1ae284de15cd7c85a4f6890eb77" translate="yes" xml:space="preserve">
          <source>suppress the first</source>
          <target state="translated">suprimir la primera</target>
        </trans-unit>
        <trans-unit id="771a09735788ce147033478f20360728d165bee2" translate="yes" xml:space="preserve">
          <source>synchronous</source>
          <target state="translated">synchronous</target>
        </trans-unit>
        <trans-unit id="2e573610264014eeec724ea567a1ed662b27b45c" translate="yes" xml:space="preserve">
          <source>that completes without emitting items</source>
          <target state="translated">que se completa sin emitir elementos</target>
        </trans-unit>
        <trans-unit id="6f08197d25304fd5b825dcbe7bf93275b3eb3552" translate="yes" xml:space="preserve">
          <source>that does nothing at all</source>
          <target state="translated">que no hace nada en absoluto</target>
        </trans-unit>
        <trans-unit id="137ab2573eaf4b29b027095f579031c127475086" translate="yes" xml:space="preserve">
          <source>that emits a particular item</source>
          <target state="translated">que emite un artículo en particular</target>
        </trans-unit>
        <trans-unit id="6bf394b782612eca525f4d43bc05228830887d33" translate="yes" xml:space="preserve">
          <source>that emits a sequence of integers</source>
          <target state="translated">que emite una secuencia de números enteros</target>
        </trans-unit>
        <trans-unit id="eaba046ca8704fac01dd6cf9c5c9f14a5b897381" translate="yes" xml:space="preserve">
          <source>that emits a sequence of items repeatedly</source>
          <target state="translated">que emite una secuencia de elementos repetidamente</target>
        </trans-unit>
        <trans-unit id="f1576e1882f41d1921a68f8fa5d3280da8029b02" translate="yes" xml:space="preserve">
          <source>that is</source>
          <target state="translated">que es</target>
        </trans-unit>
        <trans-unit id="d58317eedc0e0cc19a4dc5d96db7c79390bc0b2a" translate="yes" xml:space="preserve">
          <source>that is, after a second Observable emits an item</source>
          <target state="translated">es decir,después de que un segundo Observable emita un artículo</target>
        </trans-unit>
        <trans-unit id="b4ced51c288fff2a228b4b03d3034f929b53765c" translate="yes" xml:space="preserve">
          <source>that is, after an initial period of time</source>
          <target state="translated">es decir,después de un período inicial de tiempo</target>
        </trans-unit>
        <trans-unit id="d502ddf269ba3ba29f4b31ede202ce4f248f11c0" translate="yes" xml:space="preserve">
          <source>that is, after the first</source>
          <target state="translated">es decir,después de la primera</target>
        </trans-unit>
        <trans-unit id="01cc9507a2b962ed7290a559771e31f3dd47508e" translate="yes" xml:space="preserve">
          <source>that is, except items emitted after a second Observable emits an item</source>
          <target state="translated">es decir,excepto los artículos emitidos después de que un segundo Observable emita un artículo</target>
        </trans-unit>
        <trans-unit id="89722a4afc7485cc8282bfed94d1db2a8c8f45ed" translate="yes" xml:space="preserve">
          <source>that is, except items emitted during a period of time before the source completes</source>
          <target state="translated">es decir,excepto los artículos emitidos durante un período de tiempo antes de que la fuente complete</target>
        </trans-unit>
        <trans-unit id="86b3a5ff44246b1dc9bf253021af4f997751b277" translate="yes" xml:space="preserve">
          <source>that is, except the last</source>
          <target state="translated">es decir,excepto el último</target>
        </trans-unit>
        <trans-unit id="1c2fb5718217fbc77a780b296d5448ce0bb0e328" translate="yes" xml:space="preserve">
          <source>that is, only item</source>
          <target state="translated">es decir,el único artículo</target>
        </trans-unit>
        <trans-unit id="8807128feac25173baec8dcaa137f183e7a46065" translate="yes" xml:space="preserve">
          <source>that is, only the first item</source>
          <target state="translated">es decir,sólo el primer artículo</target>
        </trans-unit>
        <trans-unit id="1d01cf788cdb4ae54d6a0508037ae8d98e426919" translate="yes" xml:space="preserve">
          <source>that is, only the first item&lt;em&gt;s&lt;/em&gt;</source>
          <target state="translated">Es decir, solamente el art&amp;iacute;culo primeras &lt;em&gt;s&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cd465f2210bfb7e46979cf54ded4dff6ec1692e2" translate="yes" xml:space="preserve">
          <source>that is, only the last item</source>
          <target state="translated">es decir,sólo el último artículo</target>
        </trans-unit>
        <trans-unit id="46d9efc58a8899c1bd6830365dfe0851a789a47b" translate="yes" xml:space="preserve">
          <source>that is, only those items after the first items</source>
          <target state="translated">es decir,sólo aquellos artículos después de los primeros artículos</target>
        </trans-unit>
        <trans-unit id="3fd810f67e4b6418880cdf9e79b297644e46f98f" translate="yes" xml:space="preserve">
          <source>that is, those items except the last items</source>
          <target state="translated">es decir,esos artículos,excepto los últimos artículos</target>
        </trans-unit>
        <trans-unit id="7c8e5e79724ffb693a8f10afdcf74a756e2dfb2e" translate="yes" xml:space="preserve">
          <source>that is, until one of those items matches a predicate</source>
          <target state="translated">es decir,hasta que uno de esos artículos coincida con un predicado</target>
        </trans-unit>
        <trans-unit id="6c250c837d9328117e7d1fb1c5750a7f1aab95c0" translate="yes" xml:space="preserve">
          <source>that obtains its sequence from a Future</source>
          <target state="translated">que obtiene su secuencia de un Futuro</target>
        </trans-unit>
        <trans-unit id="e6b1daad8550bcc7c6c2ef78b7c5e5eeba2c7ec2" translate="yes" xml:space="preserve">
          <source>that pulls its emissions from a particular &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Iterable&lt;/code&gt;, or something like that</source>
          <target state="translated">que extrae sus emisiones de un &lt;code&gt;Array&lt;/code&gt; particular , &lt;code&gt;Iterable&lt;/code&gt; o algo as&amp;iacute;</target>
        </trans-unit>
        <trans-unit id="5446f7a00c20f00c1e1272456e1e623cd6777342" translate="yes" xml:space="preserve">
          <source>that was returned from a function called at subscribe-time</source>
          <target state="translated">que fue devuelto de una función llamada en tiempo de suscripción</target>
        </trans-unit>
        <trans-unit id="36ddf980b2667dd715828894e3fc3042cbedc25b" translate="yes" xml:space="preserve">
          <source>that was returned from an &lt;code&gt;Action&lt;/code&gt;, &lt;code&gt;Callable&lt;/code&gt;, &lt;code&gt;Runnable&lt;/code&gt;, or something of that sort, called at subscribe-time</source>
          <target state="translated">que fue devuelto desde una &lt;code&gt;Action&lt;/code&gt; , &lt;code&gt;Callable&lt;/code&gt; , &lt;code&gt;Runnable&lt;/code&gt; o algo por el estilo, llamado en el momento de la suscripci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="4d322a2a1ed8b229ce64a28e0f9a6b07bd805cb7" translate="yes" xml:space="preserve">
          <source>the &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; on which this operator will operate</source>
          <target state="translated">el &lt;a href=&quot;../scheduler&quot;&gt;Programador&lt;/a&gt; en el que operar&amp;aacute; este operador</target>
        </trans-unit>
        <trans-unit id="f54428f31bc9cd665202c66e3529743413a51ebf" translate="yes" xml:space="preserve">
          <source>the Observable from which that item was emitted</source>
          <target state="translated">el observable desde el que se emitió ese artículo</target>
        </trans-unit>
        <trans-unit id="45e5c3a5cdeb1e41ae2ba979a9fbbc2879407cb0" translate="yes" xml:space="preserve">
          <source>the Scheduler you want this operator to use</source>
          <target state="translated">el programador que quieres que este operador use</target>
        </trans-unit>
        <trans-unit id="619d6ec67e945d9c20afba296213710299061ec9" translate="yes" xml:space="preserve">
          <source>the ability for the producer to signal to the consumer that an error has occurred (an Iterable throws an exception if an error takes place during iteration; an Observable calls its observer&amp;rsquo;s &lt;code&gt;onError&lt;/code&gt; method)</source>
          <target state="translated">la capacidad del productor de se&amp;ntilde;alar al consumidor que ha ocurrido un error (un Iterable lanza una excepci&amp;oacute;n si se produce un error durante la iteraci&amp;oacute;n; un Observable llama al m&amp;eacute;todo &lt;code&gt;onError&lt;/code&gt; de su observador )</target>
        </trans-unit>
        <trans-unit id="ccf54bc28a9d5977bbe47958144f3f09e7562dd0" translate="yes" xml:space="preserve">
          <source>the ability for the producer to signal to the consumer that there is no more data available (a foreach loop on an Iterable completes and returns normally in such a case; an Observable calls its observer&amp;rsquo;s &lt;code&gt;onCompleted&lt;/code&gt; method)</source>
          <target state="translated">la capacidad del productor de indicarle al consumidor que no hay m&amp;aacute;s datos disponibles (un bucle foreach en un Iterable se completa y regresa normalmente en tal caso; un Observable llama al m&amp;eacute;todo &lt;code&gt;onCompleted&lt;/code&gt; de su observador )</target>
        </trans-unit>
        <trans-unit id="d36f5da1557da2000be76f162419f2842d8b6a66" translate="yes" xml:space="preserve">
          <source>the age, in milliseconds, at which items in this buffer may be discarded without being emitted to subsequent observers</source>
          <target state="translated">la edad,en milisegundos,a la que pueden desecharse los elementos de esta memoria intermedia sin que se emitan a los observadores posteriores</target>
        </trans-unit>
        <trans-unit id="a5c4d53c7c902b1b5cc8e185eede65fdb2de0277" translate="yes" xml:space="preserve">
          <source>the default Observable to emit if the key does not associate with any Observables</source>
          <target state="translated">el Observable por defecto a emitir si la clave no se asocia con ningún Observable</target>
        </trans-unit>
        <trans-unit id="1d113d4b461ba7203000f1bb511ee26f86e995a0" translate="yes" xml:space="preserve">
          <source>the emitted item</source>
          <target state="translated">el artículo emitido</target>
        </trans-unit>
        <trans-unit id="85e12c825e42525a7d38c934221156be2a4c8aad" translate="yes" xml:space="preserve">
          <source>the first item it emitted</source>
          <target state="translated">el primer artículo que emitió</target>
        </trans-unit>
        <trans-unit id="be4ce820ddeef4daec91cbf71555e93b8ca55a74" translate="yes" xml:space="preserve">
          <source>the first item to emit</source>
          <target state="translated">el primer elemento a emitir</target>
        </trans-unit>
        <trans-unit id="2fe008fb64922cd4f3a3244147ca04018865ec96" translate="yes" xml:space="preserve">
          <source>the index of that item in the sequence of emitted items</source>
          <target state="translated">el índice de ese artículo en la secuencia de artículos emitidos</target>
        </trans-unit>
        <trans-unit id="52694b753f3d0d4d183a51c70e89116a83fafd9c" translate="yes" xml:space="preserve">
          <source>the item emitted by the source Observable</source>
          <target state="translated">el elemento emitido por la fuente Observable</target>
        </trans-unit>
        <trans-unit id="f6eb842cfde4474cc55d27b11fda28c9d0974ca2" translate="yes" xml:space="preserve">
          <source>the item from the source Observable to be, or not be, filtered</source>
          <target state="translated">el artículo de la fuente Observable para ser,o no ser,filtrado</target>
        </trans-unit>
        <trans-unit id="f63828e115c31506deec5330c6cf7da6f1662e64" translate="yes" xml:space="preserve">
          <source>the last item emitted before it completed</source>
          <target state="translated">el último artículo emitido antes de que se completara</target>
        </trans-unit>
        <trans-unit id="4cd52010a84449eec942d8a7eb5de34cdaf5ca8d" translate="yes" xml:space="preserve">
          <source>the maximum number of items to buffer and replay to subsequent observers</source>
          <target state="translated">el número máximo de elementos que deben amortiguarse y reproducirse para los observadores posteriores</target>
        </trans-unit>
        <trans-unit id="f19cdb5df71b1ff17e9df3a1799991559db40ebf" translate="yes" xml:space="preserve">
          <source>the second Observable to combine with the source Observable</source>
          <target state="translated">el segundo Observable para combinar con la fuente Observable</target>
        </trans-unit>
        <trans-unit id="825f395e1e2ab0a50e58a2e578f9cda252845ec2" translate="yes" xml:space="preserve">
          <source>the sole item it emitted</source>
          <target state="translated">el único elemento que emitió</target>
        </trans-unit>
        <trans-unit id="c4b48660e367f953c340a09afe02029b181943ea" translate="yes" xml:space="preserve">
          <source>the source Observable</source>
          <target state="translated">la fuente Observable</target>
        </trans-unit>
        <trans-unit id="626662ed5d32414ca0a11f0bb9a64034f3068433" translate="yes" xml:space="preserve">
          <source>the source Observable itself</source>
          <target state="translated">la fuente Observable en sí misma</target>
        </trans-unit>
        <trans-unit id="f2213513da8d036c5bb0db7e96282e717db28520" translate="yes" xml:space="preserve">
          <source>the source Observable object</source>
          <target state="translated">la fuente Objeto observable</target>
        </trans-unit>
        <trans-unit id="02901a674fe43f7fbed3f5d4d20d10d2585b59f3" translate="yes" xml:space="preserve">
          <source>the zero-based index of that item</source>
          <target state="translated">el índice de base cero de ese artículo</target>
        </trans-unit>
        <trans-unit id="ff4fd068ef5334d397a2b9b95bad44dfbeb439ec" translate="yes" xml:space="preserve">
          <source>the zero-based index of that item in the sequence of emissions</source>
          <target state="translated">el índice de base cero de ese elemento en la secuencia de emisiones</target>
        </trans-unit>
        <trans-unit id="199a3fba451a63af3f467158fd6bc54160f86199" translate="yes" xml:space="preserve">
          <source>the zero-based index of this item in the source Observable&amp;rsquo;s sequence</source>
          <target state="translated">el &amp;iacute;ndice de base cero de este elemento en la secuencia de la fuente Observable</target>
        </trans-unit>
        <trans-unit id="c9f0ba0696d964a4bf6f877db29a8efb87a7b004" translate="yes" xml:space="preserve">
          <source>throws &lt;code&gt;Exception&lt;/code&gt;</source>
          <target state="translated">lanza &lt;code&gt;Exception&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5d8d37cb543750abf8a4e771b12e8265926a1ad7" translate="yes" xml:space="preserve">
          <source>timeInterval</source>
          <target state="translated">timeInterval</target>
        </trans-unit>
        <trans-unit id="56d3c9490be2608ac36f5a4805bfec2f21f7f982" translate="yes" xml:space="preserve">
          <source>timeout</source>
          <target state="translated">timeout</target>
        </trans-unit>
        <trans-unit id="11a572aecafbc0f74cba80722d6c2694c9293479" translate="yes" xml:space="preserve">
          <source>times.</source>
          <target state="translated">times.</target>
        </trans-unit>
        <trans-unit id="918300a03ee028633b64dfc10ce94f1efc51260f" translate="yes" xml:space="preserve">
          <source>to an</source>
          <target state="translated">a un</target>
        </trans-unit>
        <trans-unit id="3d803915a4dc5f4f1acc85a7a1052d8c8f251981" translate="yes" xml:space="preserve">
          <source>to its observers by calling the observers&amp;rsquo; methods.</source>
          <target state="translated">a sus observadores llamando a los m&amp;eacute;todos de los observadores.</target>
        </trans-unit>
        <trans-unit id="21b9896d15067b60a96aa46fce0956d921771516" translate="yes" xml:space="preserve">
          <source>toObservable</source>
          <target state="translated">toObservable</target>
        </trans-unit>
        <trans-unit id="d8603afc294b77cdaeff4436109d5ad84fb688d6" translate="yes" xml:space="preserve">
          <source>toSingle</source>
          <target state="translated">toSingle</target>
        </trans-unit>
        <trans-unit id="5886afa49f59f5bfc349ccddbbe20abdb26c5961" translate="yes" xml:space="preserve">
          <source>transform the items emitted by an Observable by applying a function to each item</source>
          <target state="translated">transformar los elementos emitidos por un Observable aplicando una función a cada elemento</target>
        </trans-unit>
        <trans-unit id="e7e43a876519041c58cbce9e04a1a2a77efd52b2" translate="yes" xml:space="preserve">
          <source>transform the items emitted by an Observable into Observables, then flatten the emissions from those into a single Observable</source>
          <target state="translated">transforman los elementos emitidos por un Observable en Observables,y luego aplanan las emisiones de estos en un único Observable</target>
        </trans-unit>
        <trans-unit id="7b55b668d2a03c54e10abf0fd560513c61800ce9" translate="yes" xml:space="preserve">
          <source>uses the specified &lt;code&gt;Executor&lt;/code&gt; as a Scheduler</source>
          <target state="translated">usa el &lt;code&gt;Executor&lt;/code&gt; especificado como un Programador</target>
        </trans-unit>
        <trans-unit id="963d96d958581e9e92f9acda78fb37f3bb8bfb40" translate="yes" xml:space="preserve">
          <source>when an item is emitted by either of two Observables, combine the latest item emitted by each Observable via a specified function and emit items based on the results of this function</source>
          <target state="translated">cuando un elemento es emitido por cualquiera de los dos Observatorios,combinar el último elemento emitido por cada Observador a través de una función especificada y emitir elementos basados en los resultados de esta función</target>
        </trans-unit>
        <trans-unit id="04387f9309cd75011a40ab7c3031310e01c65092" translate="yes" xml:space="preserve">
          <source>when it notifies observers</source>
          <target state="translated">cuando notifica a los observadores</target>
        </trans-unit>
        <trans-unit id="aae0fdc01ec4cc0d21d70383d00a3276d2b7b563" translate="yes" xml:space="preserve">
          <source>whenever &lt;em&gt;any&lt;/em&gt; of the Observables has emitted a new item</source>
          <target state="translated">siempre que &lt;em&gt;alguno&lt;/em&gt; de los Observables haya emitido un nuevo elemento</target>
        </trans-unit>
        <trans-unit id="6c2b43179a8c8aafdb4b0d4f3fa3fcebb34c76a6" translate="yes" xml:space="preserve">
          <source>whenever &lt;em&gt;each&lt;/em&gt; of the Observables has emitted a new item</source>
          <target state="translated">siempre que &lt;em&gt;cada uno&lt;/em&gt; de los Observables haya emitido un nuevo elemento</target>
        </trans-unit>
        <trans-unit id="f8e0b9e60ec000d6cd35e093097dfdd7a273c623" translate="yes" xml:space="preserve">
          <source>whenever an item is emitted by one Observable in a window defined by an item emitted by another</source>
          <target state="translated">cuando un elemento es emitido por un Observable en una ventana definida por un elemento emitido por otro</target>
        </trans-unit>
        <trans-unit id="dd83d0039aa92f3974d649a8a17ef435d5ade767" translate="yes" xml:space="preserve">
          <source>which I can then unwrap again with</source>
          <target state="translated">que luego puedo desenvolver de nuevo con</target>
        </trans-unit>
        <trans-unit id="b62562770a1246a8815b67b0d1d644b0e1c1d831" translate="yes" xml:space="preserve">
          <source>which will be used instead of the item itself when comparing two items for distinctness</source>
          <target state="translated">que se utilizará en lugar del artículo en sí cuando se comparen dos artículos por su distinción</target>
        </trans-unit>
        <trans-unit id="f13e27693c85aed522df8c3fcb0bb0110ca54e14" translate="yes" xml:space="preserve">
          <source>zip</source>
          <target state="translated">zip</target>
        </trans-unit>
        <trans-unit id="8a5c4039855db169827c66fcbbc8371e8cc25f57" translate="yes" xml:space="preserve">
          <source>zip and zipWith</source>
          <target state="translated">zip y zipCon</target>
        </trans-unit>
        <trans-unit id="cb92618013b7da045d179e02a557fe63872457d2" translate="yes" xml:space="preserve">
          <source>zipWith</source>
          <target state="translated">zipWith</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
