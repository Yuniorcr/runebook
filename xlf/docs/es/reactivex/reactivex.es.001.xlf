<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="reactivex">
    <body>
      <group id="reactivex">
        <trans-unit id="8bb1a4880b71bbf96c77904b471633be02e4f575" translate="yes" xml:space="preserve">
          <source>&amp;copy; ReactiveX contributors</source>
          <target state="translated">&amp;copy; Colaboradores de ReactiveX</target>
        </trans-unit>
        <trans-unit id="ada27a33bf9c68fb3cbac205322beb072f9bf4a3" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;&lt;code&gt;selectConcat&lt;/code&gt;&amp;rdquo; is an alias for &lt;code&gt;concatMap&lt;/code&gt;.</source>
          <target state="translated">&quot; &lt;code&gt;selectConcat&lt;/code&gt; &quot; es un alias de &lt;code&gt;concatMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f33193ba4ed9e4a70c0886da9f44ed6474f4347" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;&lt;code&gt;selectConcatObserver&lt;/code&gt;&amp;rdquo; is an alias for &lt;code&gt;concatMapObserver&lt;/code&gt;.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;selectConcatObserver&lt;/code&gt; &amp;rdquo; es un alias de &lt;code&gt;concatMapObserver&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="011bbafe1b211deabe6d4d163f504bc37bba4438" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;&lt;code&gt;selectMany&lt;/code&gt;&amp;rdquo; is an alias for &lt;code&gt;flatMap&lt;/code&gt;.</source>
          <target state="translated">&quot; &lt;code&gt;selectMany&lt;/code&gt; &quot; es un alias de &lt;code&gt;flatMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="652d537945ac6e2a2be380a114ed6b84ec433624" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;&lt;code&gt;selectManyObserver&lt;/code&gt;&amp;rdquo; is an alias for &lt;code&gt;flatMapObserver&lt;/code&gt;.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;selectManyObserver&lt;/code&gt; &amp;rdquo; es un alias de &lt;code&gt;flatMapObserver&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8858fe29d08b4ac07353302ff7337adc9c17e17e" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;&lt;code&gt;selectSwitch&lt;/code&gt;&amp;rdquo; is an alias for &lt;code&gt;flatMapLatest&lt;/code&gt;.</source>
          <target state="translated">&quot; &lt;code&gt;selectSwitch&lt;/code&gt; &quot; es un alias de &lt;code&gt;flatMapLatest&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a182db8bfa5293706ee292aab892f1c223187092" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Hot&amp;rdquo; and &amp;ldquo;Cold&amp;rdquo; Observables</source>
          <target state="translated">Observables &quot;calientes&quot; y &quot;fr&amp;iacute;os&quot;</target>
        </trans-unit>
        <trans-unit id="628e3c0ed13b486bb51f51ba494993cd92feca15" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;The Observable Contract,&amp;rdquo; which you may see referenced in various places in source documentation and in the pages on this site, is an attempt at a formal definition of an Observable, based originally on the 2010 document &lt;a href=&quot;https://go.microsoft.com/fwlink/?LinkID=205219&quot;&gt;&lt;cite&gt;Rx Design Guidelines&lt;/cite&gt;&lt;/a&gt; from Microsoft that described its Rx.NET implementation of ReactiveX.</source>
          <target state="translated">&quot;El Contrato Observable&quot;, que puede ver referenciado en varios lugares en la documentaci&amp;oacute;n de origen y en las p&amp;aacute;ginas de este sitio, es un intento de una definici&amp;oacute;n formal de un Observable, basado originalmente en el documento 2010 &lt;a href=&quot;https://go.microsoft.com/fwlink/?LinkID=205219&quot;&gt;&lt;cite&gt;Rx Design Guidelines&lt;/cite&gt;&lt;/a&gt; de Microsoft que describ&amp;iacute;a su Implementaci&amp;oacute;n Rx.NET de ReactiveX.</target>
        </trans-unit>
        <trans-unit id="3064f51b892e08b0c317bd603ed6b1c5496873e8" translate="yes" xml:space="preserve">
          <source>(If, on the other hand, you want to append a sequence of items to the end of those normally emitted by an Observable, you want the &lt;a href=&quot;concat&quot;&gt;Concat&lt;/a&gt; operator.)</source>
          <target state="translated">(Si, por otro lado, desea agregar una secuencia de elementos al final de los emitidos normalmente por un Observable, desea el operador &lt;a href=&quot;concat&quot;&gt;Concat&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="33d18aff50d4af9918043a17429ab9d8422faab7" translate="yes" xml:space="preserve">
          <source>(optional) a &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; or an Observable:</source>
          <target state="translated">(opcional) un &lt;a href=&quot;../scheduler&quot;&gt;Programador&lt;/a&gt; o un Observable:</target>
        </trans-unit>
        <trans-unit id="10a49259eb5c4104d411ab272baaefc70db9d42e" translate="yes" xml:space="preserve">
          <source>(required) a function that accepts an item from the source Observable and returns its key</source>
          <target state="translated">(obligatorio) una funci&amp;oacute;n que acepta un elemento de la fuente Observable y devuelve su clave</target>
        </trans-unit>
        <trans-unit id="472fde8dfbd26d60ec634739e7c5baef720d6a9e" translate="yes" xml:space="preserve">
          <source>(required) a function that returns an Observable, the emissions from which trigger the termination of any open Observables</source>
          <target state="translated">(obligatorio) una funci&amp;oacute;n que devuelve un Observable, cuyas emisiones desencadenan la terminaci&amp;oacute;n de cualquier Observable abierto</target>
        </trans-unit>
        <trans-unit id="8ec0db89f0508beecc88e44a4f261c96a84f7a76" translate="yes" xml:space="preserve">
          <source>), you only use two methods to subscribe:</source>
          <target state="translated">), solo usa dos m&amp;eacute;todos para suscribirse:</target>
        </trans-unit>
        <trans-unit id="5c10b5b2cd673a0616d529aa5234b12ee7153808" translate="yes" xml:space="preserve">
          <source>,</source>
          <target state="translated">,</target>
        </trans-unit>
        <trans-unit id="8278d2adba7612cf98a492d21a4ac4c78acb1202" translate="yes" xml:space="preserve">
          <source>, and</source>
          <target state="translated">y</target>
        </trans-unit>
        <trans-unit id="3a52ce780950d4d969792a2559cd519d7ee8c727" translate="yes" xml:space="preserve">
          <source>.</source>
          <target state="translated">.</target>
        </trans-unit>
        <trans-unit id="d2f39249308876151e8d9b31ac981ad614b505db" translate="yes" xml:space="preserve">
          <source>. An Observable</source>
          <target state="translated">. Un observable</target>
        </trans-unit>
        <trans-unit id="b1ac4cc21e92b26c247d2d196cac30ab387310d2" translate="yes" xml:space="preserve">
          <source>. Then that observer reacts to whatever item or sequence of items the Observable</source>
          <target state="translated">. Entonces ese observador reacciona a cualquier elemento o secuencia de elementos que el Observable</target>
        </trans-unit>
        <trans-unit id="51fe6dc75cfc49521ecb18667ffda03016ec73bf" translate="yes" xml:space="preserve">
          <source>. This pattern facilitates concurrent operations because it does not need to block while waiting for the Observable to emit objects, but instead it creates a sentry in the form of an observer that stands ready to react appropriately at whatever future time the Observable does so.</source>
          <target state="translated">. Este patr&amp;oacute;n facilita las operaciones concurrentes porque no necesita bloquearse mientras espera que el Observable emita objetos, sino que crea un centinela en forma de observador que est&amp;aacute; listo para reaccionar de manera apropiada en cualquier momento futuro que el Observable lo haga.</target>
        </trans-unit>
        <trans-unit id="05a79f06cf3f67f726dae68d18a2290f6c9a50c9" translate="yes" xml:space="preserve">
          <source>:</source>
          <target state="translated">:</target>
        </trans-unit>
        <trans-unit id="b3bae60012f7a78cc91257251e629489a51994ea" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;filtering-observables#wiki-first-and-takefirst&quot;&gt;&lt;code&gt;first( )&lt;/code&gt;&lt;/a&gt; is defined as &lt;a href=&quot;filtering-observables#wiki-take&quot;&gt;&lt;code&gt;take(1)&lt;/code&gt;&lt;/a&gt;&lt;code&gt;.&lt;/code&gt;&lt;a href=&quot;observable-utility-operators#wiki-single-and-singleordefault&quot;&gt;&lt;code&gt;single( )&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;filtering-observables#wiki-first-and-takefirst&quot;&gt; &lt;code&gt;first( )&lt;/code&gt; &lt;/a&gt; se define como&lt;a href=&quot;filtering-observables#wiki-take&quot;&gt; &lt;code&gt;take(1)&lt;/code&gt; &lt;/a&gt; &lt;code&gt;.&lt;/code&gt; &lt;a href=&quot;observable-utility-operators#wiki-single-and-singleordefault&quot;&gt; &lt;code&gt;single( )&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="59266734c85708062c27299be8478b239f26b4ac" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;filtering-observables#wiki-ignoreelements&quot;&gt;&lt;code&gt;ignoreElements( )&lt;/code&gt;&lt;/a&gt; is defined as &lt;a href=&quot;filtering-observables#wiki-filter&quot;&gt;&lt;code&gt;filter(alwaysFalse( ))&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;filtering-observables#wiki-ignoreelements&quot;&gt; &lt;code&gt;ignoreElements( )&lt;/code&gt; &lt;/a&gt; se define como&lt;a href=&quot;filtering-observables#wiki-filter&quot;&gt; &lt;code&gt;filter(alwaysFalse( ))&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4667e98d48cafefe965c6cfbbf931c271b1e90b2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://akarnokd.blogspot.hu/2015/05/pitfalls-of-operator-implementations.html&quot;&gt;Pitfalls of Operator Implementations (part 1)&lt;/a&gt; and &lt;a href=&quot;http://akarnokd.blogspot.hu/2015/05/pitfalls-of-operator-implementations_14.html&quot;&gt;(part 2)&lt;/a&gt; by D&amp;aacute;vid Karnok.</source>
          <target state="translated">&lt;a href=&quot;http://akarnokd.blogspot.hu/2015/05/pitfalls-of-operator-implementations.html&quot;&gt;Errores de las implementaciones del operador (parte 1)&lt;/a&gt; y &lt;a href=&quot;http://akarnokd.blogspot.hu/2015/05/pitfalls-of-operator-implementations_14.html&quot;&gt;(parte 2)&lt;/a&gt; por D&amp;aacute;vid Karnok.</target>
        </trans-unit>
        <trans-unit id="e206efd342d6f311e4eaf22aa1dad1f1c530786a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://akarnokd.blogspot.hu/2015/06/subjects-part-1.html&quot;&gt;Advanced RxJava: Subject&lt;/a&gt; by D&amp;aacute;vid Karnok</source>
          <target state="translated">&lt;a href=&quot;http://akarnokd.blogspot.hu/2015/06/subjects-part-1.html&quot;&gt;RxJava avanzado: Asunto&lt;/a&gt; por D&amp;aacute;vid Karnok</target>
        </trans-unit>
        <trans-unit id="47f33eda1a69dd738f1849ddb4b492a4b2e5509d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://akarnokd.blogspot.hu/2016/03/subscribeon-and-observeon.html&quot;&gt;Advanced Reactive Java: SubscribeOn and ObserveOn&lt;/a&gt; by D&amp;aacute;vid Karnok</source>
          <target state="translated">&lt;a href=&quot;http://akarnokd.blogspot.hu/2016/03/subscribeon-and-observeon.html&quot;&gt;Java reactivo avanzado: SubscribeOn y ObserveOn&lt;/a&gt; por D&amp;aacute;vid Karnok</target>
        </trans-unit>
        <trans-unit id="e230c3946af5006280175d640abe4d4a13419ba5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://blog.danlew.net/2014/09/22/grokking-rxjava-part-2/&quot;&gt;&lt;cite&gt;Grokking RxJava&lt;/cite&gt;: Operator, Operator&lt;/a&gt; by Dan Lew</source>
          <target state="translated">&lt;a href=&quot;http://blog.danlew.net/2014/09/22/grokking-rxjava-part-2/&quot;&gt;&lt;cite&gt;Grokking RxJava&lt;/cite&gt; : Operador, Operador&lt;/a&gt; de Dan Lew</target>
        </trans-unit>
        <trans-unit id="d3d0073935807280d0be6f71fbb272c064199c60" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://blog.danlew.net/2015/06/22/loading-data-from-multiple-sources-with-rxjava/&quot;&gt;Loading data from multiple sources with RxJava&lt;/a&gt; by Dan Lew (example using Concat and First)</source>
          <target state="translated">&lt;a href=&quot;http://blog.danlew.net/2015/06/22/loading-data-from-multiple-sources-with-rxjava/&quot;&gt;Carga de datos de m&amp;uacute;ltiples fuentes con RxJava&lt;/a&gt; por Dan Lew (ejemplo usando Concat y First)</target>
        </trans-unit>
        <trans-unit id="88b0f482a744066f1f064e5f01147915d1aa0700" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://blog.danlew.net/2015/07/23/deferring-observable-code-until-subscription-in-rxjava/&quot;&gt;Deferring Observable code until subscription in RxJava&lt;/a&gt; by Dan Lew</source>
          <target state="translated">&lt;a href=&quot;http://blog.danlew.net/2015/07/23/deferring-observable-code-until-subscription-in-rxjava/&quot;&gt;Aplazamiento del c&amp;oacute;digo observable hasta la suscripci&amp;oacute;n en RxJava&lt;/a&gt; por Dan Lew</target>
        </trans-unit>
        <trans-unit id="f1ca84472fb7904b99b27002018564cb5a4547cc" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://blog.joanzapata.com/experimentation-with-rx/&quot;&gt;Experimentation with RxJava&lt;/a&gt; by Joan Zapata</source>
          <target state="translated">&lt;a href=&quot;http://blog.joanzapata.com/experimentation-with-rx/&quot;&gt;Experimentaci&amp;oacute;n con RxJava&lt;/a&gt; por Joan Zapata</target>
        </trans-unit>
        <trans-unit id="c03861d52c0ac7e93ae1206503fa91b22d7f7e21" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://blog.kaush.co/2015/01/21/rxjava-tip-for-the-day-share-publish-refcount-and-all-that-jazz/&quot;&gt;&lt;cite&gt;Wedding Party&lt;/cite&gt;: Share, Publish, Refcount, and All That Jazz&lt;/a&gt; by Kaushik Gopal</source>
          <target state="translated">&lt;a href=&quot;http://blog.kaush.co/2015/01/21/rxjava-tip-for-the-day-share-publish-refcount-and-all-that-jazz/&quot;&gt;&lt;cite&gt;Fiesta de bodas&lt;/cite&gt; : compartir, publicar, volver a contar y todo ese jazz&lt;/a&gt; por Kaushik Gopal</target>
        </trans-unit>
        <trans-unit id="5ce980c6203942d6328150d8b1c308fa22c0eaa5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://blogs.microsoft.co.il/iblogger/2015/08/11/animations-of-rx-operators-groupby/&quot;&gt;Animations of Rx operators: GroupBy&lt;/a&gt; by Tamir Dresher</source>
          <target state="translated">&lt;a href=&quot;http://blogs.microsoft.co.il/iblogger/2015/08/11/animations-of-rx-operators-groupby/&quot;&gt;Animaciones de operadores Rx: GroupBy&lt;/a&gt; por Tamir Dresher</target>
        </trans-unit>
        <trans-unit id="fbfa59fd65771d372675362d61976b92c09f6c20" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://davesexton.com/blog/post/To-Use-Subject-Or-Not-To-Use-Subject.aspx&quot;&gt;To Use or Not to Use Subject&lt;/a&gt; from</source>
          <target state="translated">&lt;a href=&quot;http://davesexton.com/blog/post/To-Use-Subject-Or-Not-To-Use-Subject.aspx&quot;&gt;Usar o no usar el asunto&lt;/a&gt; de</target>
        </trans-unit>
        <trans-unit id="759d49d6a27ee607b3399f224c41924b74508d45" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.couchbase.com/developer/java-2.0/observables.html&quot;&gt;&lt;cite&gt;Mastering observables&lt;/cite&gt;&lt;/a&gt; (from the Couchbase Server documentation)</source>
          <target state="translated">&lt;a href=&quot;http://docs.couchbase.com/developer/java-2.0/observables.html&quot;&gt;&lt;cite&gt;Dominar los observables&lt;/cite&gt;&lt;/a&gt; (de la documentaci&amp;oacute;n del servidor Couchbase)</target>
        </trans-unit>
        <trans-unit id="896a64d54c6458d527ffcfd1ff702993ee89e715" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Triangular_number&quot;&gt;triangular numbers&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Triangular_number&quot;&gt;n&amp;uacute;meros triangulares&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="0cf025e741372bc56b5fa846f8b8c00cb06df70f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://fernandocejas.com/2015/01/11/rxjava-observable-tranformation-concatmap-vs-flatmap/&quot;&gt;RxJava Observable transformation: concatMap() vs. flatMap()&lt;/a&gt; by Fernando Cejas</source>
          <target state="translated">&lt;a href=&quot;http://fernandocejas.com/2015/01/11/rxjava-observable-tranformation-concatmap-vs-flatmap/&quot;&gt;Transformaci&amp;oacute;n observable RxJava: concatMap () vs flatMap ()&lt;/a&gt; por Fernando Cejas</target>
        </trans-unit>
        <trans-unit id="28d3f563e622ffc28d2ef40034bcd9d4f00ca617" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://java.dzone.com/articles/async-abstractios-using-rx&quot;&gt;Async Abstractions using rx-java&lt;/a&gt; by Biju Kunjummen,</source>
          <target state="translated">&lt;a href=&quot;http://java.dzone.com/articles/async-abstractios-using-rx&quot;&gt;Abstracciones as&amp;iacute;ncronas usando rx-java&lt;/a&gt; por Biju Kunjummen,</target>
        </trans-unit>
        <trans-unit id="8a54c1db4af03308f492e88a17125cdba0d0c092" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://jschneider.io/2014/11/26/Recursive-Observables-with-Rx-Java.html&quot;&gt;&lt;cite&gt;Recursive Observables with RxJava&lt;/cite&gt;&lt;/a&gt; by Jon Schneider</source>
          <target state="translated">&lt;a href=&quot;http://jschneider.io/2014/11/26/Recursive-Observables-with-Rx-Java.html&quot;&gt;&lt;cite&gt;Observables recursivos con RxJava&lt;/cite&gt;&lt;/a&gt; por Jon Schneider</target>
        </trans-unit>
        <trans-unit id="16022b407d5c10a64a78eb6bcb293d94191d92c2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Scheduler.Worker.html#schedulePeriodically(rx.functions.Action0,%20long,%20long,%20java.util.concurrent.TimeUnit)&quot;&gt;Another &lt;code&gt;Scheduler&lt;/code&gt; method&lt;/a&gt; allows you to schedule an action to take place at regular intervals. The following example schedules &lt;code&gt;someAction&lt;/code&gt; to be performed on &lt;code&gt;someScheduler&lt;/code&gt; after 500ms have passed, and then every 250ms thereafter:</source>
          <target state="translated">&lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Scheduler.Worker.html#schedulePeriodically(rx.functions.Action0,%20long,%20long,%20java.util.concurrent.TimeUnit)&quot;&gt;Otro m&amp;eacute;todo de &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; permite programar una acci&amp;oacute;n para que tenga lugar a intervalos regulares. El siguiente ejemplo programa &lt;code&gt;someAction&lt;/code&gt; para que se realice en &lt;code&gt;someScheduler&lt;/code&gt; despu&amp;eacute;s de que hayan pasado 500ms, y luego cada 250ms a partir de entonces:</target>
        </trans-unit>
        <trans-unit id="a37f7ccc01d776219ff3c86d486170b61368bb91" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/schedulers/TestScheduler.html&quot;&gt;The &lt;code&gt;TestScheduler&lt;/code&gt;&lt;/a&gt; allows you to exercise fine-tuned manual control over how the Scheduler&amp;rsquo;s clock behaves. This can be useful for testing interactions that depend on precise arrangements of actions in time. This Scheduler has three additional methods:</source>
          <target state="translated">&lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/schedulers/TestScheduler.html&quot;&gt;El &lt;code&gt;TestScheduler&lt;/code&gt; &lt;/a&gt; le permite ejercer un control manual afinado sobre c&amp;oacute;mo se comporta el reloj del Programador. Esto puede ser &amp;uacute;til para probar interacciones que dependen de arreglos precisos de acciones en el tiempo. Este programador tiene tres m&amp;eacute;todos adicionales:</target>
        </trans-unit>
        <trans-unit id="1b99f29bcb2b76c81e30b2a8987e758a20001805" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://tomstechnicalblog.blogspot.hu/2016/02/rxjava-understanding-observeon-and.html&quot;&gt;RxJava: Understanding observeOn() and subscribeOn()&lt;/a&gt; by Thomas Nield</source>
          <target state="translated">&lt;a href=&quot;http://tomstechnicalblog.blogspot.hu/2016/02/rxjava-understanding-observeon-and.html&quot;&gt;RxJava: Comprensi&amp;oacute;n de observeOn () y subscribeOn ()&lt;/a&gt; por Thomas Nield</target>
        </trans-unit>
        <trans-unit id="d5434e93f83f2e22d891275d0648442c8413f6ac" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.grahamlea.com/2014/07/rxjava-threading-examples/&quot;&gt;&lt;cite&gt;RxJava Threading Examples&lt;/cite&gt;&lt;/a&gt; by Graham Lea</source>
          <target state="translated">&lt;a href=&quot;http://www.grahamlea.com/2014/07/rxjava-threading-examples/&quot;&gt;&lt;cite&gt;Ejemplos de subprocesos RxJava&lt;/cite&gt;&lt;/a&gt; por Graham Lea</target>
        </trans-unit>
        <trans-unit id="1d280bc18cadf90c9c47536bb1dda083a732e6f3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.grahamlea.com/2014/07/rxjava-threading-examples/&quot;&gt;RxJava Threading Examlpes&lt;/a&gt; by Graham Lea</source>
          <target state="translated">&lt;a href=&quot;http://www.grahamlea.com/2014/07/rxjava-threading-examples/&quot;&gt;RxJava Threading Examlpes&lt;/a&gt; por Graham Lea</target>
        </trans-unit>
        <trans-unit id="74f17e88de08b7b705152e13a4c7159ebecfb889" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.nurkiewicz.com/2014/12/accessing-meetups-streaming-api-with.html&quot;&gt;Aligning packets with JSON documents&lt;/a&gt; with the &lt;code&gt;split&lt;/code&gt; operator</source>
          <target state="translated">&lt;a href=&quot;http://www.nurkiewicz.com/2014/12/accessing-meetups-streaming-api-with.html&quot;&gt;Alinear paquetes con documentos JSON&lt;/a&gt; con el operador &lt;code&gt;split&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8f646afbe00e0bfa7ba10a96b4ffa0e66bb17b8c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/getting_started_with_rxjs/implementing_your_own_operators.html&quot;&gt;Implementing Your Own Observable Operators&lt;/a&gt; (in RxJS) by Dennis Stoyanov</source>
          <target state="translated">&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/getting_started_with_rxjs/implementing_your_own_operators.html&quot;&gt;Implementaci&amp;oacute;n de sus propios operadores observables&lt;/a&gt; (en RxJS) por Dennis Stoyanov</target>
        </trans-unit>
        <trans-unit id="8de4cdb66506641a1d2be3db34ce3c18d520fb41" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/getting_started_with_rxjs/scheduling_and_concurrency.html&quot;&gt;Using Schedulers&lt;/a&gt; by Dennis Stoyanov</source>
          <target state="translated">&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/getting_started_with_rxjs/scheduling_and_concurrency.html&quot;&gt;Uso de programadores&lt;/a&gt; por Dennis Stoyanov</target>
        </trans-unit>
        <trans-unit id="704f937aee915cf54084238d4d732aaafe152536" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/getting_started_with_rxjs/subjects.html&quot;&gt;Using Subjects&lt;/a&gt; by Dennis Stoyanov</source>
          <target state="translated">&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/getting_started_with_rxjs/subjects.html&quot;&gt;Uso de sujetos&lt;/a&gt; por Dennis Stoyanov</target>
        </trans-unit>
        <trans-unit id="4848d0a67536767bfc3a46b25a389c6c12411971" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/helpers/pluck.html&quot;&gt;&lt;code&gt;Rx.helpers.pluck(property)&lt;/code&gt;&lt;/a&gt; from Dennis Stoyanov&amp;rsquo;s RxJS book</source>
          <target state="translated">&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/helpers/pluck.html&quot;&gt; &lt;code&gt;Rx.helpers.pluck(property)&lt;/code&gt; &lt;/a&gt; del libro RxJS de Dennis Stoyanov</target>
        </trans-unit>
        <trans-unit id="4d3ad2689ab54eb0e90eeaa55c13b2942af325ac" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/observable/index.html&quot;&gt;Observable object&lt;/a&gt; (RxJS) by Dennis Stoyanov</source>
          <target state="translated">&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/observable/index.html&quot;&gt;Objeto observable&lt;/a&gt; (RxJS) por Dennis Stoyanov</target>
        </trans-unit>
        <trans-unit id="05fc805666c7d298737b623ab15f7e3dc904dae7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/schedulers/index.html&quot;&gt;Schedulers&lt;/a&gt; by Dennis Stoyanov</source>
          <target state="translated">&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/schedulers/index.html&quot;&gt;Programadores&lt;/a&gt; de Dennis Stoyanov</target>
        </trans-unit>
        <trans-unit id="3189bb2a65685a675d2fc7b27dec30afc63ad7c4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/which_operator_do_i_use/index.html&quot;&gt;Which Operator do I use?&lt;/a&gt; by Dennis Stoyanov (a similar decision tree, specific to RxJS operators)</source>
          <target state="translated">&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/which_operator_do_i_use/index.html&quot;&gt;&amp;iquest;Qu&amp;eacute; operador utilizo? &lt;/a&gt;por Dennis Stoyanov (un &amp;aacute;rbol de decisiones similar, espec&amp;iacute;fico para los operadores RxJS)</target>
        </trans-unit>
        <trans-unit id="ce8e12a5cf50d130360fa140e3c6026b7357fde7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://afterecho.uk/blog/turning-a-callback-into-an-rx-observable.html&quot;&gt;Turning a callback into an Rx Observable&lt;/a&gt; by @afterecho</source>
          <target state="translated">&lt;a href=&quot;https://afterecho.uk/blog/turning-a-callback-into-an-rx-observable.html&quot;&gt;Convirtiendo una devoluci&amp;oacute;n de llamada en un Rx Observable&lt;/a&gt; por @afterecho</target>
        </trans-unit>
        <trans-unit id="d451c54e66d39cc9799f024ed509b3bc96bce3c7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://akarnokd.blogspot.hu/2015/05/pitfalls-of-operator-implementations.html&quot;&gt;Pitfalls of Operator Implementations (part 1)&lt;/a&gt; and &lt;a href=&quot;https://akarnokd.blogspot.hu/2015/05/pitfalls-of-operator-implementations_14.html&quot;&gt;(part 2)&lt;/a&gt; by D&amp;aacute;vid Karnok.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d90c5beaed2cc1c90c5fe7861f00e4aad4f4a6d1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://akarnokd.blogspot.hu/2015/06/subjects-part-1.html&quot;&gt;Advanced RxJava: Subject&lt;/a&gt; by D&amp;aacute;vid Karnok</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cf363991e89c8a0e87e6dfba9b6738ed9428569" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://akarnokd.blogspot.hu/2016/03/subscribeon-and-observeon.html&quot;&gt;Advanced Reactive Java: SubscribeOn and ObserveOn&lt;/a&gt; by D&amp;aacute;vid Karnok</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f93a2223081711dc6a16e0d515e0ae72c9ea57ff" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://egghead.io/lessons/javascript-introducing-the-observable&quot;&gt;Introducing the Observable&lt;/a&gt; by Jafar Husain (JavaScript Video Tutorial)</source>
          <target state="translated">&lt;a href=&quot;https://egghead.io/lessons/javascript-introducing-the-observable&quot;&gt;Presentaci&amp;oacute;n de lo observable&lt;/a&gt; de Jafar Husain (tutorial en v&amp;iacute;deo de JavaScript)</target>
        </trans-unit>
        <trans-unit id="334e700ad37dedaa75e68b424f31c8fa60b1fb0a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://egghead.io/lessons/javascript-using-the-map-method-with-observable&quot;&gt;Using the map method with Observable&lt;/a&gt; by Jafar Husain (JavaScript Video Tutorial)</source>
          <target state="translated">&lt;a href=&quot;https://egghead.io/lessons/javascript-using-the-map-method-with-observable&quot;&gt;Usando el m&amp;eacute;todo de mapa con Observable&lt;/a&gt; por Jafar Husain (Tutorial en video de JavaScript)</target>
        </trans-unit>
        <trans-unit id="cf0782f3a6b69844aa73c07760234981973bbc5f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Triangular_number&quot;&gt;triangular numbers&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b97a092a417ac6514a68c890f6e9a31313afc87" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://medium.com/@andrestaltz/2-minute-introduction-to-rx-24c8ca793877&quot;&gt;&lt;cite&gt;2 minute introduction to Rx&lt;/cite&gt;&lt;/a&gt; by Andre Staltz (&amp;ldquo;Think of an Observable as an asynchronous immutable array.&amp;rdquo;)</source>
          <target state="translated">&lt;a href=&quot;https://medium.com/@andrestaltz/2-minute-introduction-to-rx-24c8ca793877&quot;&gt;&lt;cite&gt;Introducci&amp;oacute;n de 2 minutos a Rx&lt;/cite&gt;&lt;/a&gt; por Andre Staltz (&quot;Piense en un Observable como una matriz inmutable asincr&amp;oacute;nica&quot;).</target>
        </trans-unit>
        <trans-unit id="f57e3b7ba34ac94a726bbf8003c34e5a0fd3f3d6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://speakerdeck.com/benjchristensen/applying-rxjava-to-existing-applications-at-philly-ete-2015&quot;&gt;Testing Reactive Applications&lt;/a&gt; by Ben Christensen</source>
          <target state="translated">&lt;a href=&quot;https://speakerdeck.com/benjchristensen/applying-rxjava-to-existing-applications-at-philly-ete-2015&quot;&gt;Prueba de aplicaciones reactivas&lt;/a&gt; por Ben Christensen</target>
        </trans-unit>
        <trans-unit id="c038a5a05f5d042c0ec78b36075a87e20bcb7315" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://tomstechnicalblog.blogspot.hu/2016/02/rxjava-understanding-observeon-and.html&quot;&gt;RxJava: Understanding observeOn() and subscribeOn()&lt;/a&gt; by Thomas Nield</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57b94d44ddd170ba627080334d6de635cf9dee2a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://xgrommx.github.io/rx-book/content/getting_started_with_rxjs/implementing_your_own_operators.html&quot;&gt;Implementing Your Own Observable Operators&lt;/a&gt; (in RxJS) by Dennis Stoyanov</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9fe549f38289b6afce34aa2e3fca82da4136bd8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://xgrommx.github.io/rx-book/content/getting_started_with_rxjs/scheduling_and_concurrency.html&quot;&gt;Using Schedulers&lt;/a&gt; by Dennis Stoyanov</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d6d766df35d7fb238b4d6047220476f351b1b95" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://xgrommx.github.io/rx-book/content/getting_started_with_rxjs/subjects.html&quot;&gt;Using Subjects&lt;/a&gt; by Dennis Stoyanov</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="640a5616bb195204bbe098f76af869fe354cb507" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://xgrommx.github.io/rx-book/content/helpers/pluck.html&quot;&gt;&lt;code&gt;Rx.helpers.pluck(property)&lt;/code&gt;&lt;/a&gt; from Dennis Stoyanov&amp;rsquo;s RxJS book</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d252ced924a06312f6659b0016eb34bf29753054" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://xgrommx.github.io/rx-book/content/observable/index.html&quot;&gt;Observable object&lt;/a&gt; (RxJS) by Dennis Stoyanov</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b89bc9845079206996bf7fc699562b453e2b49b9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://xgrommx.github.io/rx-book/content/schedulers/index.html&quot;&gt;Schedulers&lt;/a&gt; by Dennis Stoyanov</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87c215d1c35116530a5569ecbd77ec8011180980" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://xgrommx.github.io/rx-book/content/which_operator_do_i_use/index.html&quot;&gt;Which Operator do I use?&lt;/a&gt; by Dennis Stoyanov (a similar decision tree, specific to RxJS operators)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a64d773c526ed13fecf935007c5b8b42451946ce" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;mathematical-and-aggregate-operators#wiki-reduce&quot;&gt;&lt;code&gt;reduce(a)&lt;/code&gt;&lt;/a&gt; is defined as &lt;a href=&quot;transforming-observables#wiki-scan&quot;&gt;&lt;code&gt;scan(a)&lt;/code&gt;&lt;/a&gt;&lt;code&gt;.&lt;/code&gt;&lt;a href=&quot;filtering-observables#wiki-last&quot;&gt;&lt;code&gt;last( )&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;mathematical-and-aggregate-operators#wiki-reduce&quot;&gt; &lt;code&gt;reduce(a)&lt;/code&gt; &lt;/a&gt; se define como&lt;a href=&quot;transforming-observables#wiki-scan&quot;&gt; &lt;code&gt;scan(a)&lt;/code&gt; &lt;/a&gt; &lt;code&gt;.&lt;/code&gt; &lt;a href=&quot;filtering-observables#wiki-last&quot;&gt; &lt;code&gt;last( )&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aedba0e61fd807ab73f1bcd257861ff700c36541" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/all&quot;&gt;&lt;code&gt;All&lt;/code&gt;&lt;/a&gt; &amp;mdash; determine whether all items emitted by an Observable meet some criteria</source>
          <target state="translated">&lt;a href=&quot;operators/all&quot;&gt; &lt;code&gt;All&lt;/code&gt; &lt;/a&gt; : determine si todos los elementos emitidos por un Observable cumplen con algunos criterios</target>
        </trans-unit>
        <trans-unit id="cf4af39a8182c43692831b7f5254a2e5a28ab5e3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/amb&quot;&gt;&lt;code&gt;Amb&lt;/code&gt;&lt;/a&gt; &amp;mdash; given two or more source Observables, emit all of the items from only the first of these Observables to emit an item</source>
          <target state="translated">&lt;a href=&quot;operators/amb&quot;&gt; &lt;code&gt;Amb&lt;/code&gt; &lt;/a&gt; : dados dos o m&amp;aacute;s Observables de origen, emite todos los elementos de solo el primero de estos Observables para emitir un elemento</target>
        </trans-unit>
        <trans-unit id="6abf056e15446abb733a1356236897d0eb88fbc5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/and-then-when&quot;&gt;&lt;code&gt;And&lt;/code&gt;/&lt;code&gt;Then&lt;/code&gt;/&lt;code&gt;When&lt;/code&gt;&lt;/a&gt; &amp;mdash; combine sets of items emitted by two or more Observables by means of &lt;code&gt;Pattern&lt;/code&gt; and &lt;code&gt;Plan&lt;/code&gt; intermediaries</source>
          <target state="translated">&lt;a href=&quot;operators/and-then-when&quot;&gt; &lt;code&gt;And&lt;/code&gt; / &lt;code&gt;Then&lt;/code&gt; / &lt;code&gt;When&lt;/code&gt; &lt;/a&gt; - combinar conjuntos de elementos emitidos por dos o m&amp;aacute;s observables por medio del &lt;code&gt;Pattern&lt;/code&gt; y &lt;code&gt;Plan&lt;/code&gt; intermediarios</target>
        </trans-unit>
        <trans-unit id="5ebf0c5f54c5bec720782a934c3ac450d6d61240" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/average&quot;&gt;&lt;code&gt;Average&lt;/code&gt;&lt;/a&gt; &amp;mdash; calculates the average of numbers emitted by an Observable and emits this average</source>
          <target state="translated">&lt;a href=&quot;operators/average&quot;&gt; &lt;code&gt;Average&lt;/code&gt; &lt;/a&gt; : calcula el promedio de n&amp;uacute;meros emitidos por un Observable y emite este promedio</target>
        </trans-unit>
        <trans-unit id="e5b94b62bcc7c953efa686abfda740c404bb41fd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/backpressure&quot;&gt;&lt;strong&gt;backpressure operators&lt;/strong&gt;&lt;/a&gt; &amp;mdash; strategies for coping with Observables that produce items more rapidly than their observers consume them</source>
          <target state="translated">&lt;a href=&quot;operators/backpressure&quot;&gt;&lt;strong&gt;Operadores de contrapresi&amp;oacute;n&lt;/strong&gt;&lt;/a&gt; : estrategias para hacer frente a los Observables que producen elementos m&amp;aacute;s r&amp;aacute;pidamente de lo que sus observadores los consumen.</target>
        </trans-unit>
        <trans-unit id="f4188b6a7d79bcd68189ca1745286160ac1b4b8b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/buffer&quot;&gt;&lt;code&gt;Buffer&lt;/code&gt;&lt;/a&gt; &amp;mdash; periodically gather items from an Observable into bundles and emit these bundles rather than emitting the items one at a time</source>
          <target state="translated">&lt;a href=&quot;operators/buffer&quot;&gt; &lt;code&gt;Buffer&lt;/code&gt; &lt;/a&gt; : re&amp;uacute;na peri&amp;oacute;dicamente elementos de un Observable en paquetes y emita estos paquetes en lugar de emitir los elementos uno a la vez</target>
        </trans-unit>
        <trans-unit id="af1e7131303f464e9943733bedda780f33c1a666" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/catch&quot;&gt;&lt;code&gt;Catch&lt;/code&gt;&lt;/a&gt; &amp;mdash; recover from an &lt;code&gt;onError&lt;/code&gt; notification by continuing the sequence without error</source>
          <target state="translated">&lt;a href=&quot;operators/catch&quot;&gt; &lt;code&gt;Catch&lt;/code&gt; &lt;/a&gt; - recuperarse de una &lt;code&gt;onError&lt;/code&gt; notificaci&amp;oacute;n al continuar la secuencia sin error</target>
        </trans-unit>
        <trans-unit id="7da57d968e0e4216a34863a171db7ab41b9812ec" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/combinelatest&quot;&gt;&lt;code&gt;CombineLatest&lt;/code&gt;&lt;/a&gt; &amp;mdash; when an item is emitted by either of two Observables, combine the latest item emitted by each Observable via a specified function and emit items based on the results of this function</source>
          <target state="translated">&lt;a href=&quot;operators/combinelatest&quot;&gt; &lt;code&gt;CombineLatest&lt;/code&gt; &lt;/a&gt; : cuando un elemento es emitido por cualquiera de los dos Observables, combine el &amp;uacute;ltimo elemento emitido por cada Observable a trav&amp;eacute;s de una funci&amp;oacute;n espec&amp;iacute;fica y emita elementos seg&amp;uacute;n los resultados de esta funci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="b5080500198e0f8811c8452bb3beb14dec470f66" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/concat&quot;&gt;&lt;code&gt;Concat&lt;/code&gt;&lt;/a&gt; &amp;mdash; emit the emissions from two or more Observables without interleaving them</source>
          <target state="translated">&lt;a href=&quot;operators/concat&quot;&gt; &lt;code&gt;Concat&lt;/code&gt; &lt;/a&gt; : emite las emisiones de dos o m&amp;aacute;s Observables sin intercalarlos</target>
        </trans-unit>
        <trans-unit id="56ae6daf6671ffcf155c2fa5c4d803d4f7af8682" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/connect&quot;&gt;&lt;code&gt;Connect&lt;/code&gt;&lt;/a&gt; &amp;mdash; instruct a connectable Observable to begin emitting items to its subscribers</source>
          <target state="translated">&lt;a href=&quot;operators/connect&quot;&gt; &lt;code&gt;Connect&lt;/code&gt; &lt;/a&gt; : instruya a un Observable conectable para que comience a emitir elementos a sus suscriptores</target>
        </trans-unit>
        <trans-unit id="55e31fa5a564732c4705e3cfc70e314969dc504c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/contains&quot;&gt;&lt;code&gt;Contains&lt;/code&gt;&lt;/a&gt; &amp;mdash; determine whether an Observable emits a particular item or not</source>
          <target state="translated">&lt;a href=&quot;operators/contains&quot;&gt; &lt;code&gt;Contains&lt;/code&gt; &lt;/a&gt; : determina si un Observable emite un elemento en particular o no</target>
        </trans-unit>
        <trans-unit id="7bd2683bd64c47ab143020ad6a8b004e6473f895" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/count&quot;&gt;&lt;code&gt;Count&lt;/code&gt;&lt;/a&gt; &amp;mdash; count the number of items emitted by the source Observable and emit only this value</source>
          <target state="translated">&lt;a href=&quot;operators/count&quot;&gt; &lt;code&gt;Count&lt;/code&gt; &lt;/a&gt; : cuente el n&amp;uacute;mero de elementos emitidos por la fuente Observable y emita solo este valor</target>
        </trans-unit>
        <trans-unit id="b703b9011ffb0e21799b507e8d5b7991453ff2f5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/create&quot;&gt;&lt;code&gt;Create&lt;/code&gt;&lt;/a&gt; &amp;mdash; create an Observable from scratch by calling observer methods programmatically</source>
          <target state="translated">&lt;a href=&quot;operators/create&quot;&gt; &lt;code&gt;Create&lt;/code&gt; &lt;/a&gt; : cree un Observable desde cero llamando a los m&amp;eacute;todos del observador mediante programaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="d520a5275eeadd415b96286025e57173c2f421ef" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/debounce&quot;&gt;&lt;code&gt;Debounce&lt;/code&gt;&lt;/a&gt; &amp;mdash; only emit an item from an Observable if a particular timespan has passed without it emitting another item</source>
          <target state="translated">&lt;a href=&quot;operators/debounce&quot;&gt; &lt;code&gt;Debounce&lt;/code&gt; &lt;/a&gt; : solo emite un elemento de un Observable si ha pasado un per&amp;iacute;odo de tiempo en particular sin que emita otro elemento</target>
        </trans-unit>
        <trans-unit id="bcbedf41620fc26c55f3a79460e1936597cd6376" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/defaultifempty&quot;&gt;&lt;code&gt;DefaultIfEmpty&lt;/code&gt;&lt;/a&gt; &amp;mdash; emit items from the source Observable, or a default item if the source Observable emits nothing</source>
          <target state="translated">&lt;a href=&quot;operators/defaultifempty&quot;&gt; &lt;code&gt;DefaultIfEmpty&lt;/code&gt; &lt;/a&gt; : emite elementos de la fuente Observable, o un elemento predeterminado si la fuente Observable no emite nada</target>
        </trans-unit>
        <trans-unit id="1ead6b29bf678adce5dda8d26b2b84e8a029610e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/defer&quot;&gt;&lt;code&gt;Defer&lt;/code&gt;&lt;/a&gt; &amp;mdash; do not create the Observable until the observer subscribes, and create a fresh Observable for each observer</source>
          <target state="translated">&lt;a href=&quot;operators/defer&quot;&gt; &lt;code&gt;Defer&lt;/code&gt; &lt;/a&gt; : no cree el Observable hasta que el observador se suscriba y cree un Observable nuevo para cada observador</target>
        </trans-unit>
        <trans-unit id="c877468ebfffede1767292c312dce60b414b3e7e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/delay&quot;&gt;&lt;code&gt;Delay&lt;/code&gt;&lt;/a&gt; &amp;mdash; shift the emissions from an Observable forward in time by a particular amount</source>
          <target state="translated">&lt;a href=&quot;operators/delay&quot;&gt; &lt;code&gt;Delay&lt;/code&gt; &lt;/a&gt; : desplaza las emisiones de un Observable hacia adelante en el tiempo en una cantidad particular</target>
        </trans-unit>
        <trans-unit id="cfd3bc1c02474c98160f5c3daaaf519e81d28a2a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/distinct&quot;&gt;&lt;code&gt;Distinct&lt;/code&gt;&lt;/a&gt; &amp;mdash; suppress duplicate items emitted by an Observable</source>
          <target state="translated">&lt;a href=&quot;operators/distinct&quot;&gt; &lt;code&gt;Distinct&lt;/code&gt; &lt;/a&gt; : suprime los elementos duplicados emitidos por un Observable</target>
        </trans-unit>
        <trans-unit id="a0bcec9b0ef7199fdfb5d4143f346557af694831" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/do&quot;&gt;&lt;code&gt;Do&lt;/code&gt;&lt;/a&gt; &amp;mdash; register an action to take upon a variety of Observable lifecycle events</source>
          <target state="translated">&lt;a href=&quot;operators/do&quot;&gt; &lt;code&gt;Do&lt;/code&gt; &lt;/a&gt; : registrar una acci&amp;oacute;n para realizar una variedad de eventos del ciclo de vida observable</target>
        </trans-unit>
        <trans-unit id="d78138361fd31ace0165e9d2c41fa553949f98a1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/elementat&quot;&gt;&lt;code&gt;ElementAt&lt;/code&gt;&lt;/a&gt; &amp;mdash; emit only item</source>
          <target state="translated">&lt;a href=&quot;operators/elementat&quot;&gt; &lt;code&gt;ElementAt&lt;/code&gt; &lt;/a&gt; - emitir solo elemento</target>
        </trans-unit>
        <trans-unit id="b8ea48737e4cf7e24239f531b16f54742f291f19" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/empty-never-throw&quot;&gt;&lt;code&gt;Empty&lt;/code&gt;/&lt;code&gt;Never&lt;/code&gt;/&lt;code&gt;Throw&lt;/code&gt;&lt;/a&gt; &amp;mdash; create Observables that have very precise and limited behavior</source>
          <target state="translated">&lt;a href=&quot;operators/empty-never-throw&quot;&gt; &lt;code&gt;Empty&lt;/code&gt; / &lt;code&gt;Never&lt;/code&gt; / &lt;code&gt;Throw&lt;/code&gt; &lt;/a&gt; : crea Observables que tienen un comportamiento muy preciso y limitado</target>
        </trans-unit>
        <trans-unit id="39d35f0e202be5da8bca269f843088bbc301dc44" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/filter&quot;&gt;&lt;code&gt;Filter&lt;/code&gt;&lt;/a&gt; &amp;mdash; emit only those items from an Observable that pass a predicate test</source>
          <target state="translated">&lt;a href=&quot;operators/filter&quot;&gt; &lt;code&gt;Filter&lt;/code&gt; &lt;/a&gt; : emita solo aquellos elementos de un Observable que pasan una prueba de predicado</target>
        </trans-unit>
        <trans-unit id="6e10a2781542f87afbf33eb4a144578a352afb60" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/filter&quot;&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/a&gt; (RxScala version of &lt;strong&gt;&lt;code&gt;Filter&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">&lt;a href=&quot;operators/filter&quot;&gt; &lt;code&gt;collect&lt;/code&gt; &lt;/a&gt; (versi&amp;oacute;n RxScala de&lt;strong&gt; &lt;code&gt;Filter&lt;/code&gt; &lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="9af7efb0e5277caa8bcb4ca047ec46c742ccb1fd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/filter&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; (alternate name of &lt;strong&gt;&lt;code&gt;Filter&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">&lt;a href=&quot;operators/filter&quot;&gt; &lt;code&gt;select&lt;/code&gt; &lt;/a&gt; (nombre alternativo del&lt;strong&gt; &lt;code&gt;Filter&lt;/code&gt; &lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="59b1e5aa586c9c45e855a67c901087f73288790f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/first&quot;&gt;&lt;code&gt;First&lt;/code&gt;&lt;/a&gt; &amp;mdash; emit only the first item, or the first item that meets a condition, from an Observable</source>
          <target state="translated">&lt;a href=&quot;operators/first&quot;&gt; &lt;code&gt;First&lt;/code&gt; &lt;/a&gt; : emita solo el primer elemento, o el primer elemento que cumple una condici&amp;oacute;n, desde un Observable</target>
        </trans-unit>
        <trans-unit id="0333194f18a33a7a679904ac05075d80fb58292e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/first&quot;&gt;&lt;code&gt;Next&lt;/code&gt;&lt;/a&gt; (BlockingObservable version)</source>
          <target state="translated">&lt;a href=&quot;operators/first&quot;&gt; &lt;code&gt;Next&lt;/code&gt; &lt;/a&gt; (versi&amp;oacute;n de BlockingObservable)</target>
        </trans-unit>
        <trans-unit id="5e51f771a5f9140c8f1c5f545f5f8d7fa162868d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/flatmap&quot;&gt;&lt;code&gt;FlatMap&lt;/code&gt;&lt;/a&gt; &amp;mdash; transform the items emitted by an Observable into Observables, then flatten the emissions from those into a single Observable</source>
          <target state="translated">&lt;a href=&quot;operators/flatmap&quot;&gt; &lt;code&gt;FlatMap&lt;/code&gt; &lt;/a&gt; : transforme los elementos emitidos por un Observable en Observables, luego reduzca las emisiones de esos en un solo Observable</target>
        </trans-unit>
        <trans-unit id="71f2ef1fb92d5f7acf826243fcc2a2bbb36aecb1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; &amp;mdash; convert some other object or data structure into an Observable</source>
          <target state="translated">&lt;a href=&quot;operators/from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; : convierte alg&amp;uacute;n otro objeto o estructura de datos en un objeto Observable</target>
        </trans-unit>
        <trans-unit id="c784fcd85d0d9eee95eec8546747974634737771" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/groupby&quot;&gt;&lt;code&gt;GroupBy&lt;/code&gt;&lt;/a&gt; &amp;mdash; divide an Observable into a set of Observables that each emit a different group of items from the original Observable, organized by key</source>
          <target state="translated">&lt;a href=&quot;operators/groupby&quot;&gt; &lt;code&gt;GroupBy&lt;/code&gt; &lt;/a&gt; : divide un Observable en un conjunto de Observables, cada uno de los cuales emite un grupo diferente de elementos del Observable original, organizado por clave.</target>
        </trans-unit>
        <trans-unit id="961f7bdad0209a178b650ec75f14ba3dbab617cd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/ignoreelements&quot;&gt;&lt;code&gt;IgnoreElements&lt;/code&gt;&lt;/a&gt; &amp;mdash; do not emit any items from an Observable but mirror its termination notification</source>
          <target state="translated">&lt;a href=&quot;operators/ignoreelements&quot;&gt; &lt;code&gt;IgnoreElements&lt;/code&gt; &lt;/a&gt; : no emite ning&amp;uacute;n elemento de un Observable, pero refleja su notificaci&amp;oacute;n de terminaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="a7a0c12a44344d7075bd1bab89a82bb9105a316b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/interval&quot;&gt;&lt;code&gt;Interval&lt;/code&gt;&lt;/a&gt; &amp;mdash; create an Observable that emits a sequence of integers spaced by a particular time interval</source>
          <target state="translated">&lt;a href=&quot;operators/interval&quot;&gt; &lt;code&gt;Interval&lt;/code&gt; o&lt;/a&gt; : crea un Observable que emite una secuencia de n&amp;uacute;meros enteros espaciados por un intervalo de tiempo particular</target>
        </trans-unit>
        <trans-unit id="82c0927b758a710d223a235baa006d1ad82eacf1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/join&quot;&gt;&lt;code&gt;Join&lt;/code&gt;&lt;/a&gt; &amp;mdash; combine items emitted by two Observables whenever an item from one Observable is emitted during a time window defined according to an item emitted by the other Observable</source>
          <target state="translated">&lt;a href=&quot;operators/join&quot;&gt; &lt;code&gt;Join&lt;/code&gt; &lt;/a&gt; : combine elementos emitidos por dos Observables siempre que un elemento de un Observable se emita durante una ventana de tiempo definida de acuerdo con un elemento emitido por el otro Observable</target>
        </trans-unit>
        <trans-unit id="f789526a11cbf951f3017cad8bb11a7e4f2ae5f7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/just&quot;&gt;&lt;code&gt;Just&lt;/code&gt;&lt;/a&gt; &amp;mdash; convert an object or a set of objects into an Observable that emits that or those objects</source>
          <target state="translated">&lt;a href=&quot;operators/just&quot;&gt; &lt;code&gt;Just&lt;/code&gt; &lt;/a&gt; : convierte un objeto o un conjunto de objetos en un Observable que emite ese o esos objetos</target>
        </trans-unit>
        <trans-unit id="f24150c757b2d9fe51daa5b9af6362ed547f642d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/last&quot;&gt;&lt;code&gt;Last&lt;/code&gt;&lt;/a&gt; &amp;mdash; emit only the last item emitted by an Observable</source>
          <target state="translated">&lt;a href=&quot;operators/last&quot;&gt; &lt;code&gt;Last&lt;/code&gt; &lt;/a&gt; : emite solo el &amp;uacute;ltimo elemento emitido por un Observable</target>
        </trans-unit>
        <trans-unit id="3cfa4568e3237e07a49192561a240de86776b19c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/last&quot;&gt;&lt;code&gt;takeRight&lt;/code&gt;&lt;/a&gt; (see also: &lt;a href=&quot;operators/takelast&quot;&gt;&lt;code&gt;TakeLast&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;operators/last&quot;&gt; &lt;code&gt;takeRight&lt;/code&gt; &lt;/a&gt; (ver tambi&amp;eacute;n:&lt;a href=&quot;operators/takelast&quot;&gt; &lt;code&gt;TakeLast&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="6273a6a4cb7f838288a2e07ef52f0d3d06baaf4e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; &amp;mdash; transform the items emitted by an Observable by applying a function to each item</source>
          <target state="translated">&lt;a href=&quot;operators/map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; a&lt;/a&gt; : transforma los elementos emitidos por un Observable aplicando una funci&amp;oacute;n a cada elemento</target>
        </trans-unit>
        <trans-unit id="9b1ea99f33b2d42aa36a7fc325095d80ff73e6e3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/map&quot;&gt;&lt;code&gt;Select&lt;/code&gt;&lt;/a&gt; (alternate name of &lt;strong&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">&lt;a href=&quot;operators/map&quot;&gt; &lt;code&gt;Select&lt;/code&gt; &lt;/a&gt; (nombre alternativo del&lt;strong&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="cce6754f280c0d41eb1e96d9819d872ea7cbb479" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/materialize-dematerialize&quot;&gt;&lt;code&gt;Materialize&lt;/code&gt;/&lt;code&gt;Dematerialize&lt;/code&gt;&lt;/a&gt; &amp;mdash; represent both the items emitted and the notifications sent as emitted items, or reverse this process</source>
          <target state="translated">&lt;a href=&quot;operators/materialize-dematerialize&quot;&gt; &lt;code&gt;Materialize&lt;/code&gt; / &lt;code&gt;Dematerialize&lt;/code&gt; &lt;/a&gt; : representar tanto los elementos emitidos como las notificaciones enviadas como elementos emitidos, o invertir este proceso</target>
        </trans-unit>
        <trans-unit id="e43ea78d80899fb195485fd3038b95794736c693" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/max&quot;&gt;&lt;code&gt;Max&lt;/code&gt;&lt;/a&gt; &amp;mdash; determine, and emit, the maximum-valued item emitted by an Observable</source>
          <target state="translated">&lt;a href=&quot;operators/max&quot;&gt; &lt;code&gt;Max&lt;/code&gt; &lt;/a&gt; : determina y emite el elemento de valor m&amp;aacute;ximo emitido por un Observable</target>
        </trans-unit>
        <trans-unit id="896d525218ff0dfffdd195a9e6eee022104a5cda" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/merge&quot;&gt;&lt;code&gt;Merge&lt;/code&gt;&lt;/a&gt; &amp;mdash; combine multiple Observables into one by merging their emissions</source>
          <target state="translated">&lt;a href=&quot;operators/merge&quot;&gt; &lt;code&gt;Merge&lt;/code&gt; &lt;/a&gt; : combine varios Observables en uno fusionando sus emisiones</target>
        </trans-unit>
        <trans-unit id="0f540a11749020205078336f04e2c0c14a5a0beb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/min&quot;&gt;&lt;code&gt;Min&lt;/code&gt;&lt;/a&gt; &amp;mdash; determine, and emit, the minimum-valued item emitted by an Observable</source>
          <target state="translated">&lt;a href=&quot;operators/min&quot;&gt; &lt;code&gt;Min&lt;/code&gt; &lt;/a&gt; : determina y emite el elemento de valor m&amp;iacute;nimo emitido por un Observable</target>
        </trans-unit>
        <trans-unit id="78c97bac5d1832ec1abde2e15368384c4243e8cc" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/observeon&quot;&gt;&lt;code&gt;ObserveOn&lt;/code&gt;&lt;/a&gt; &amp;mdash; specify the scheduler on which an observer will observe this Observable</source>
          <target state="translated">&lt;a href=&quot;operators/observeon&quot;&gt; &lt;code&gt;ObserveOn&lt;/code&gt; &lt;/a&gt; : especifique el programador en el que un observador observar&amp;aacute; este Observable</target>
        </trans-unit>
        <trans-unit id="58e4de04374963ac6f0703deddf542b57beab534" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/publish&quot;&gt;&lt;code&gt;Publish&lt;/code&gt;&lt;/a&gt; &amp;mdash; convert an ordinary Observable into a connectable Observable</source>
          <target state="translated">&lt;a href=&quot;operators/publish&quot;&gt; &lt;code&gt;Publish&lt;/code&gt; &lt;/a&gt; : convierta un Observable ordinario en un Observable conectable</target>
        </trans-unit>
        <trans-unit id="6d19d53dfbba576a9be303d133898023ec0f1468" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; &amp;mdash; create an Observable that emits a range of sequential integers</source>
          <target state="translated">&lt;a href=&quot;operators/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; : crea un observable que emite un rango de n&amp;uacute;meros enteros secuenciales.</target>
        </trans-unit>
        <trans-unit id="220d9225db54aea0568c311fb54c1b1af2b03d83" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/reduce&quot;&gt;&lt;code&gt;Reduce&lt;/code&gt;&lt;/a&gt; &amp;mdash; apply a function to each item emitted by an Observable, sequentially, and emit the final value</source>
          <target state="translated">&lt;a href=&quot;operators/reduce&quot;&gt; &lt;code&gt;Reduce&lt;/code&gt; &lt;/a&gt; : aplique una funci&amp;oacute;n a cada elemento emitido por un Observable, secuencialmente, y emita el valor final</target>
        </trans-unit>
        <trans-unit id="f2ebff59c0c373b115b3a5c2d65e3f91e16e588e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/refcount&quot;&gt;&lt;code&gt;RefCount&lt;/code&gt;&lt;/a&gt; &amp;mdash; make a Connectable Observable behave like an ordinary Observable</source>
          <target state="translated">&lt;a href=&quot;operators/refcount&quot;&gt; &lt;code&gt;RefCount&lt;/code&gt; &lt;/a&gt; : haga que un Observable Conectable se comporte como un Observable ordinario</target>
        </trans-unit>
        <trans-unit id="e6ec521fdbc793707013621bfc8fb2ba153a0cd8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/repeat&quot;&gt;&lt;code&gt;Repeat&lt;/code&gt;&lt;/a&gt; &amp;mdash; create an Observable that emits a particular item or sequence of items repeatedly</source>
          <target state="translated">&lt;a href=&quot;operators/repeat&quot;&gt; &lt;code&gt;Repeat&lt;/code&gt; &lt;/a&gt; : crea un Observable que emita un elemento en particular o una secuencia de elementos repetidamente</target>
        </trans-unit>
        <trans-unit id="2804cd9e5f0367f7c9558927abf3a72ef9c06ac4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/replay&quot;&gt;&lt;code&gt;Replay&lt;/code&gt;&lt;/a&gt; &amp;mdash; ensure that all observers see the same sequence of emitted items, even if they subscribe after the Observable has begun emitting items</source>
          <target state="translated">&lt;a href=&quot;operators/replay&quot;&gt; &lt;code&gt;Replay&lt;/code&gt; &lt;/a&gt; : aseg&amp;uacute;rese de que todos los observadores vean la misma secuencia de elementos emitidos, incluso si se suscriben despu&amp;eacute;s de que el Observable haya comenzado a emitir elementos</target>
        </trans-unit>
        <trans-unit id="00ec748f863300265c910192f8f5af498feb4f55" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/retry&quot;&gt;&lt;code&gt;Retry&lt;/code&gt;&lt;/a&gt; &amp;mdash; if a source Observable sends an &lt;code&gt;onError&lt;/code&gt; notification, resubscribe to it in the hopes that it will complete without error</source>
          <target state="translated">&lt;a href=&quot;operators/retry&quot;&gt; &lt;code&gt;Retry&lt;/code&gt; &lt;/a&gt; : si una fuente Observable env&amp;iacute;a unanotificaci&amp;oacute;n de &lt;code&gt;onError&lt;/code&gt; , vuelva a suscribirse con la esperanza de que se complete sin errores.</target>
        </trans-unit>
        <trans-unit id="fe03930f3581f4dad5c8a3922092b89e1191d93d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/sample&quot;&gt;&lt;code&gt;Sample&lt;/code&gt;&lt;/a&gt; &amp;mdash; emit the most recent item emitted by an Observable within periodic time intervals</source>
          <target state="translated">&lt;a href=&quot;operators/sample&quot;&gt; &lt;code&gt;Sample&lt;/code&gt; &lt;/a&gt; : emite el elemento m&amp;aacute;s reciente emitido por un Observable dentro de intervalos de tiempo peri&amp;oacute;dicos</target>
        </trans-unit>
        <trans-unit id="d75c698d2f0fe31254942270f4f860c2edd619a3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/scan&quot;&gt;&lt;code&gt;Scan&lt;/code&gt;&lt;/a&gt; &amp;mdash; apply a function to each item emitted by an Observable, sequentially, and emit each successive value</source>
          <target state="translated">&lt;a href=&quot;operators/scan&quot;&gt; &lt;code&gt;Scan&lt;/code&gt; &lt;/a&gt; : aplique una funci&amp;oacute;n a cada elemento emitido por un Observable, secuencialmente, y emita cada valor sucesivo</target>
        </trans-unit>
        <trans-unit id="eb4dcaeae3f881353f0198da0ed07774810c96e4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/sequenceequal&quot;&gt;&lt;code&gt;SequenceEqual&lt;/code&gt;&lt;/a&gt; &amp;mdash; determine whether two Observables emit the same sequence of items</source>
          <target state="translated">&lt;a href=&quot;operators/sequenceequal&quot;&gt; &lt;code&gt;SequenceEqual&lt;/code&gt; &lt;/a&gt; : determina si dos Observables emiten la misma secuencia de elementos</target>
        </trans-unit>
        <trans-unit id="ca9082009ddd16283a5a15007359dd764bf941bf" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/serialize&quot;&gt;&lt;code&gt;Serialize&lt;/code&gt;&lt;/a&gt; &amp;mdash; force an Observable to make serialized calls and to be well-behaved</source>
          <target state="translated">&lt;a href=&quot;operators/serialize&quot;&gt; &lt;code&gt;Serialize&lt;/code&gt; &lt;/a&gt; : obligar a un Observable a realizar llamadas serializadas y comportarse bien</target>
        </trans-unit>
        <trans-unit id="3c5b3dde082c7f134651c5c0ee0f77c10d8849f7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/skip&quot;&gt;&lt;code&gt;Skip&lt;/code&gt;&lt;/a&gt; &amp;mdash; suppress the first</source>
          <target state="translated">&lt;a href=&quot;operators/skip&quot;&gt; &lt;code&gt;Skip&lt;/code&gt; &lt;/a&gt; : suprime el primero</target>
        </trans-unit>
        <trans-unit id="57c550f6342285873d1251001f507a49dd499b9a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/skiplast&quot;&gt;&lt;code&gt;SkipLast&lt;/code&gt;&lt;/a&gt; &amp;mdash; suppress the last</source>
          <target state="translated">&lt;a href=&quot;operators/skiplast&quot;&gt; &lt;code&gt;SkipLast&lt;/code&gt; &lt;/a&gt; - suprime el &amp;uacute;ltimo</target>
        </trans-unit>
        <trans-unit id="e4091fcbf30f6cac5a853be94132763f8026869c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/skipuntil&quot;&gt;&lt;code&gt;SkipUntil&lt;/code&gt;&lt;/a&gt; &amp;mdash; discard items emitted by an Observable until a second Observable emits an item</source>
          <target state="translated">&lt;a href=&quot;operators/skipuntil&quot;&gt; &lt;code&gt;SkipUntil&lt;/code&gt; &lt;/a&gt; : descarte los elementos emitidos por un Observable hasta que un segundo Observable emita un elemento</target>
        </trans-unit>
        <trans-unit id="7a2508b5d42729a80bcadabbd948ac432565126f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/skipwhile&quot;&gt;&lt;code&gt;SkipWhile&lt;/code&gt;&lt;/a&gt; &amp;mdash; discard items emitted by an Observable until a specified condition becomes false</source>
          <target state="translated">&lt;a href=&quot;operators/skipwhile&quot;&gt; &lt;code&gt;SkipWhile&lt;/code&gt; &lt;/a&gt; : descarte los elementos emitidos por un Observable hasta que una condici&amp;oacute;n especificada se vuelva falsa</target>
        </trans-unit>
        <trans-unit id="715557b9c7b5c8b25056c589cc3f188f11be2cc2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/start&quot;&gt;&lt;code&gt;Start&lt;/code&gt;&lt;/a&gt; &amp;mdash; create an Observable that emits the return value of a function</source>
          <target state="translated">&lt;a href=&quot;operators/start&quot;&gt; &lt;code&gt;Start&lt;/code&gt; &lt;/a&gt; : crea un Observable que emita el valor de retorno de una funci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="8a16879f166f96ec4f6c887a4b17c95425000b2d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/startwith&quot;&gt;&lt;code&gt;StartWith&lt;/code&gt;&lt;/a&gt; &amp;mdash; emit a specified sequence of items before beginning to emit the items from the source Observable</source>
          <target state="translated">&lt;a href=&quot;operators/startwith&quot;&gt; &lt;code&gt;StartWith&lt;/code&gt; &lt;/a&gt; : emite una secuencia espec&amp;iacute;fica de elementos antes de comenzar a emitir los elementos de la fuente Observable</target>
        </trans-unit>
        <trans-unit id="d0ff74e8a6826625e34447a02f61eea2babf5abb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/subscribe&quot;&gt;&lt;code&gt;Subscribe&lt;/code&gt;&lt;/a&gt; &amp;mdash; operate upon the emissions and notifications from an Observable</source>
          <target state="translated">&lt;a href=&quot;operators/subscribe&quot;&gt; &lt;code&gt;Subscribe&lt;/code&gt; &lt;/a&gt; : opere sobre las emisiones y notificaciones de un Observable</target>
        </trans-unit>
        <trans-unit id="1b8c65f3783b491e2da19c9577fc47f408f83f9f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/subscribe&quot;&gt;The &lt;code&gt;Subscribe&lt;/code&gt; method&lt;/a&gt; is how you connect an observer to an Observable. Your observer implements some subset of the following methods:</source>
          <target state="translated">&lt;a href=&quot;operators/subscribe&quot;&gt;El m&amp;eacute;todo &lt;code&gt;Subscribe&lt;/code&gt; &lt;/a&gt; es c&amp;oacute;mo conecta un observador a un Observable. Su observador implementa alg&amp;uacute;n subconjunto de los siguientes m&amp;eacute;todos:</target>
        </trans-unit>
        <trans-unit id="20bd35f3cd630e6729cd59d5f5871941dbba7336" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/subscribeon&quot;&gt;&lt;code&gt;SubscribeOn&lt;/code&gt;&lt;/a&gt; &amp;mdash; specify the scheduler an Observable should use when it is subscribed to</source>
          <target state="translated">&lt;a href=&quot;operators/subscribeon&quot;&gt; &lt;code&gt;SubscribeOn&lt;/code&gt; &lt;/a&gt; : especifique el programador que debe usar un Observable cuando est&amp;eacute; suscrito</target>
        </trans-unit>
        <trans-unit id="f2c9b8fa32c3e32960d4065945b8d21ee9ae586d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/sum&quot;&gt;&lt;code&gt;Sum&lt;/code&gt;&lt;/a&gt; &amp;mdash; calculate the sum of numbers emitted by an Observable and emit this sum</source>
          <target state="translated">&lt;a href=&quot;operators/sum&quot;&gt; &lt;code&gt;Sum&lt;/code&gt; a&lt;/a&gt; : calcula la suma de n&amp;uacute;meros emitidos por un observable y emite esta suma</target>
        </trans-unit>
        <trans-unit id="fff5479ffc0e2648d627b6a506e5a3ac0a369e95" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/sum&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; (string)</source>
          <target state="translated">&lt;a href=&quot;operators/sum&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt; (cadena)</target>
        </trans-unit>
        <trans-unit id="12270334cc52f8a9daf70d2dd8a4a15c526d5d82" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/switch&quot;&gt;&lt;code&gt;Switch&lt;/code&gt;&lt;/a&gt; &amp;mdash; convert an Observable that emits Observables into a single Observable that emits the items emitted by the most-recently-emitted of those Observables</source>
          <target state="translated">&lt;a href=&quot;operators/switch&quot;&gt; &lt;code&gt;Switch&lt;/code&gt; &lt;/a&gt; : convierte un Observable que emite Observables en un Observable &amp;uacute;nico que emite los elementos emitidos por el &amp;uacute;ltimo de esos Observables emitidos</target>
        </trans-unit>
        <trans-unit id="18cfa275521a80308ec35ddf6041423b53915ce9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/switch&quot;&gt;&lt;code&gt;latest&lt;/code&gt;&lt;/a&gt; (Rx.rb version of &lt;strong&gt;&lt;code&gt;Switch&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">&lt;a href=&quot;operators/switch&quot;&gt; &lt;code&gt;latest&lt;/code&gt; &lt;/a&gt; (versi&amp;oacute;n Rx.rb de&lt;strong&gt; &lt;code&gt;Switch&lt;/code&gt; &lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="c512d0a45fbef14a0ca00b1ba15611f0f470c5fd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/take&quot;&gt;&lt;code&gt;Take&lt;/code&gt;&lt;/a&gt; &amp;mdash; emit only the first</source>
          <target state="translated">&lt;a href=&quot;operators/take&quot;&gt; &lt;code&gt;Take&lt;/code&gt; &lt;/a&gt; - emita solo el primero</target>
        </trans-unit>
        <trans-unit id="2f2c659ea7a1fbd932f5dfd6f64cbda8bd8e8b88" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/takelast&quot;&gt;&lt;code&gt;TakeLast&lt;/code&gt;&lt;/a&gt; &amp;mdash; emit only the last</source>
          <target state="translated">&lt;a href=&quot;operators/takelast&quot;&gt; &lt;code&gt;TakeLast&lt;/code&gt; &lt;/a&gt; : emite solo el &amp;uacute;ltimo</target>
        </trans-unit>
        <trans-unit id="40a4532cb238dde4e68093af52658f5445b11adf" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/takeuntil&quot;&gt;&lt;code&gt;TakeUntil&lt;/code&gt;&lt;/a&gt; &amp;mdash; discard items emitted by an Observable after a second Observable emits an item or terminates</source>
          <target state="translated">&lt;a href=&quot;operators/takeuntil&quot;&gt; &lt;code&gt;TakeUntil&lt;/code&gt; &lt;/a&gt; : descarta elementos emitidos por un Observable despu&amp;eacute;s de que un segundo Observable emite un elemento o termina</target>
        </trans-unit>
        <trans-unit id="92a388db3da085f5150944c06f479a2f12efe907" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/takewhile&quot;&gt;&lt;code&gt;TakeWhile&lt;/code&gt;&lt;/a&gt; &amp;mdash; discard items emitted by an Observable after a specified condition becomes false</source>
          <target state="translated">&lt;a href=&quot;operators/takewhile&quot;&gt; &lt;code&gt;TakeWhile&lt;/code&gt; &lt;/a&gt; : descarte elementos emitidos por un Observable despu&amp;eacute;s de que una condici&amp;oacute;n especificada se vuelva falsa</target>
        </trans-unit>
        <trans-unit id="90712fbd60a57bf67f06b86afd680c3c52c8c0e8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/timeinterval&quot;&gt;&lt;code&gt;TimeInterval&lt;/code&gt;&lt;/a&gt; &amp;mdash; convert an Observable that emits items into one that emits indications of the amount of time elapsed between those emissions</source>
          <target state="translated">&lt;a href=&quot;operators/timeinterval&quot;&gt; &lt;code&gt;TimeInterval&lt;/code&gt; &lt;/a&gt; : convierte un Observable que emite elementos en uno que emite indicaciones de la cantidad de tiempo transcurrido entre esas emisiones</target>
        </trans-unit>
        <trans-unit id="56fae76408c63619174d789717205ca81e57c61d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/timeout&quot;&gt;&lt;code&gt;Timeout&lt;/code&gt;&lt;/a&gt; &amp;mdash; mirror the source Observable, but issue an error notification if a particular period of time elapses without any emitted items</source>
          <target state="translated">&lt;a href=&quot;operators/timeout&quot;&gt; &lt;code&gt;Timeout&lt;/code&gt; &lt;/a&gt; : refleje la fuente Observable, pero emita una notificaci&amp;oacute;n de error si transcurre un per&amp;iacute;odo de tiempo en particular sin ning&amp;uacute;n elemento emitido</target>
        </trans-unit>
        <trans-unit id="17b4d7785cee0739e289b4511c57a47b43fb0a69" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/timer&quot;&gt;&lt;code&gt;Timer&lt;/code&gt;&lt;/a&gt; &amp;mdash; create an Observable that emits a single item after a given delay</source>
          <target state="translated">&lt;a href=&quot;operators/timer&quot;&gt; &lt;code&gt;Timer&lt;/code&gt; &lt;/a&gt; : crea un Observable que emite un solo elemento despu&amp;eacute;s de un retraso determinado</target>
        </trans-unit>
        <trans-unit id="8153fd468994e7f23f93090e11c64478da3a861a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/timestamp&quot;&gt;&lt;code&gt;Timestamp&lt;/code&gt;&lt;/a&gt; &amp;mdash; attach a timestamp to each item emitted by an Observable</source>
          <target state="translated">&lt;a href=&quot;operators/timestamp&quot;&gt; &lt;code&gt;Timestamp&lt;/code&gt; &lt;/a&gt; : adjunte una marca de tiempo a cada elemento emitido por un Observable</target>
        </trans-unit>
        <trans-unit id="08036d386b50af7605f69d72032e90ec9b7ae3be" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/to&quot;&gt;&lt;code&gt;To&lt;/code&gt;&lt;/a&gt; &amp;mdash; convert an Observable into another object or data structure</source>
          <target state="translated">&lt;a href=&quot;operators/to&quot;&gt; &lt;code&gt;To&lt;/code&gt; &lt;/a&gt; : convertir un Observable en otro objeto o estructura de datos</target>
        </trans-unit>
        <trans-unit id="a27441bb348b701709f46ba2a9e1fd000edbe104" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/using&quot;&gt;&lt;code&gt;Using&lt;/code&gt;&lt;/a&gt; &amp;mdash; create a disposable resource that has the same lifespan as the Observable</source>
          <target state="translated">&lt;a href=&quot;operators/using&quot;&gt; &lt;code&gt;Using&lt;/code&gt; &lt;/a&gt; : cree un recurso desechable que tenga la misma vida &amp;uacute;til que el Observable</target>
        </trans-unit>
        <trans-unit id="4e7798a9984bb26f086d17dce14b65fb99ceeb7d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/window&quot;&gt;&lt;code&gt;Window&lt;/code&gt;&lt;/a&gt; &amp;mdash; periodically subdivide items from an Observable into Observable windows and emit these windows rather than emitting the items one at a time</source>
          <target state="translated">&lt;a href=&quot;operators/window&quot;&gt; &lt;code&gt;Window&lt;/code&gt; &lt;/a&gt; : subdivida peri&amp;oacute;dicamente elementos de un Observable en ventanas Observables y emita estas ventanas en lugar de emitir los elementos de uno en uno.</target>
        </trans-unit>
        <trans-unit id="c5cf183eb5d366413ed5d5c204d8b7fa6f3b0e5a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/zip&quot;&gt;&lt;code&gt;Zip&lt;/code&gt;&lt;/a&gt; &amp;mdash; combine the emissions of multiple Observables together via a specified function and emit single items for each combination based on the results of this function</source>
          <target state="translated">&lt;a href=&quot;operators/zip&quot;&gt; &lt;code&gt;Zip&lt;/code&gt; &lt;/a&gt; : combine las emisiones de varios Observables a trav&amp;eacute;s de una funci&amp;oacute;n espec&amp;iacute;fica y emita elementos individuales para cada combinaci&amp;oacute;n en funci&amp;oacute;n de los resultados de esta funci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="1d6d8e38830f49548b2c4afc11148786a0b1e918" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/zip&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; (RxClojure version of &lt;strong&gt;&lt;code&gt;Zip&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">&lt;a href=&quot;operators/zip&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; (versi&amp;oacute;n RxClojure de&lt;strong&gt; &lt;code&gt;Zip&lt;/code&gt; &lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="79293a7f079b9373f12db529fcf04630f0840459" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/zip&quot;&gt;&lt;code&gt;mapCat&lt;/code&gt;&lt;/a&gt; (RxClojure version of &lt;strong&gt;&lt;code&gt;Zip&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">&lt;a href=&quot;operators/zip&quot;&gt; &lt;code&gt;mapCat&lt;/code&gt; &lt;/a&gt; (versi&amp;oacute;n RxClojure de&lt;strong&gt; &lt;code&gt;Zip&lt;/code&gt; &lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="bc842fac1c68ceb5773485119db93147ac0c6b6e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;single&quot;&gt;&lt;tt&gt;Single&lt;/tt&gt;&lt;/a&gt; &amp;mdash; a specialized version of an Observable that emits only a single item</source>
          <target state="translated">&lt;a href=&quot;single&quot;&gt;&lt;tt&gt;&amp;Uacute;nico&lt;/tt&gt;&lt;/a&gt; : una versi&amp;oacute;n especializada de un Observable que emite solo un elemento</target>
        </trans-unit>
        <trans-unit id="84438b704c9fca4e5527512cd5c27340544d75ab" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Buffer &amp;mdash; Simple</source>
          <target state="translated">&lt;cite&gt;101 Rx Samples&lt;/cite&gt; : Buffer - Simple</target>
        </trans-unit>
        <trans-unit id="8e3999cc1a087194796f932be496866a6f0182c3" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: CombineLatest</source>
          <target state="translated">&lt;cite&gt;101 muestras Rx&lt;/cite&gt; : CombineLatest</target>
        </trans-unit>
        <trans-unit id="9dfeeecdc7b7288e5ea70c6c892c1d944664cf48" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: CombineLatest &amp;mdash; Parallel Execution</source>
          <target state="translated">&lt;cite&gt;101 Rx Samples&lt;/cite&gt; : CombineLatest - Ejecuci&amp;oacute;n en paralelo</target>
        </trans-unit>
        <trans-unit id="f6b4feb080d4814c3633843d31049b4ae614c799" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Concat &amp;mdash; cold observable</source>
          <target state="translated">&lt;cite&gt;101 muestras Rx&lt;/cite&gt; : Concat - observable en fr&amp;iacute;o</target>
        </trans-unit>
        <trans-unit id="c0e2ed6732260c865ef6eccba85b4ddc0466e81a" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Concat &amp;mdash; hot observable</source>
          <target state="translated">&lt;cite&gt;101 muestras Rx&lt;/cite&gt; : Concat - observable en caliente</target>
        </trans-unit>
        <trans-unit id="7f1e8f5e8387df20c1e2eec385011ae6468129f3" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Delay &amp;mdash; Simple</source>
          <target state="translated">&lt;cite&gt;101 muestras de Rx&lt;/cite&gt; : Delay - Simple</target>
        </trans-unit>
        <trans-unit id="e9cd41c26800564ad47aa6441382096c455b8e77" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Generate</source>
          <target state="translated">&lt;cite&gt;101 muestras de Rx&lt;/cite&gt; : generar</target>
        </trans-unit>
        <trans-unit id="b9ed1f3ab8250846a6b02df43301b10c649c335e" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: GroupJoin &amp;mdash; Joins two streams by matching by one of their attributes</source>
          <target state="translated">&lt;cite&gt;101 Rx Samples&lt;/cite&gt; : GroupJoin: une dos flujos al hacer coincidir uno de sus atributos</target>
        </trans-unit>
        <trans-unit id="f4a401a286d1a0539e3f17195639b2743803c2c5" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: ISubject&amp;lt;T&amp;gt; and ISubject&amp;lt;T1,T2&amp;gt;</source>
          <target state="translated">&lt;cite&gt;101 muestras de Rx&lt;/cite&gt; : ISubject &amp;lt;T&amp;gt; e ISubject &amp;lt;T1, T2&amp;gt;</target>
        </trans-unit>
        <trans-unit id="4497c7c8e023a9337eb5395666b4310b2d91e7e8" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Interval &amp;mdash; Simple</source>
          <target state="translated">&lt;cite&gt;101 Rx Samples&lt;/cite&gt; : Intervalo - Simple</target>
        </trans-unit>
        <trans-unit id="a953c40a21409172145703f425a7a60796dd5e88" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Interval &amp;mdash; With TimeInterval()</source>
          <target state="translated">&lt;cite&gt;101 muestras Rx&lt;/cite&gt; : Intervalo - Con TimeInterval ()</target>
        </trans-unit>
        <trans-unit id="65190ea0c6ca0b42f3664eb352fbfe370afd6443" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Merge</source>
          <target state="translated">&lt;cite&gt;101 muestras Rx&lt;/cite&gt; : Fusionar</target>
        </trans-unit>
        <trans-unit id="38e8128889f9b5776897d04d41bfbd2cef9c6fde" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Observation Operators</source>
          <target state="translated">&lt;cite&gt;101 Rx Samples&lt;/cite&gt; : Operadores de observaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="49730b290b423f322940dab1ff7061f932845d63" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Observing the Passing of Time</source>
          <target state="translated">&lt;cite&gt;101 Rx Samples&lt;/cite&gt; : Observando el paso del tiempo</target>
        </trans-unit>
        <trans-unit id="bdfc989ca6ffd7c7cbf77916f7081d7bbbcf3c03" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Publish &amp;mdash; Sharing a subscription with multiple Observers</source>
          <target state="translated">&lt;cite&gt;101 Rx Samples&lt;/cite&gt; : Publicar: compartir una suscripci&amp;oacute;n con varios observadores</target>
        </trans-unit>
        <trans-unit id="82e1b94cb3df3df1bc50246ed5e11b9d9a413f3e" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Range</source>
          <target state="translated">&lt;cite&gt;101 muestras Rx&lt;/cite&gt; : rango</target>
        </trans-unit>
        <trans-unit id="fd72099514d7ac2d1520ae4b1cd03541ecb3d75b" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Sample &amp;mdash; Simple</source>
          <target state="translated">&lt;cite&gt;101 Rx Samples&lt;/cite&gt; : Sample - Simple</target>
        </trans-unit>
        <trans-unit id="9d5982dbcf362e5fe59b0b1a74ae7c356eb14b62" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Select &amp;mdash; Indexed</source>
          <target state="translated">&lt;cite&gt;101 Rx Samples&lt;/cite&gt; : Select - Indexado</target>
        </trans-unit>
        <trans-unit id="758e63347c494706666595c451133580e55bb6b1" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Start &amp;mdash; Run Code Asynchronously</source>
          <target state="translated">&lt;cite&gt;101 Rx Samples&lt;/cite&gt; : Inicio - Ejecutar c&amp;oacute;digo de forma asincr&amp;oacute;nica</target>
        </trans-unit>
        <trans-unit id="c2323d4a4016773c83f1325ef75d2d80d33e98d7" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Throttle &amp;mdash; Simple</source>
          <target state="translated">&lt;cite&gt;101 muestras Rx&lt;/cite&gt; : acelerador - simple</target>
        </trans-unit>
        <trans-unit id="d228cb755846dd4e2bab50fb5eab415316bfec1c" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Timeout &amp;mdash; Simple</source>
          <target state="translated">&lt;cite&gt;101 Rx Samples&lt;/cite&gt; : Timeout - Simple</target>
        </trans-unit>
        <trans-unit id="002c8dac44d68094923f2810a86c6d928664e2f1" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Timer &amp;mdash; Simple</source>
          <target state="translated">&lt;cite&gt;101 muestras de Rx&lt;/cite&gt; : Temporizador - Simple</target>
        </trans-unit>
        <trans-unit id="8cb1c8d362fc1bea83ee3e202602ece035e7c32e" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Timestamp</source>
          <target state="translated">&lt;cite&gt;101 Rx Samples&lt;/cite&gt; : Marca de tiempo</target>
        </trans-unit>
        <trans-unit id="6ee1829693fce377b6ff46cbe5704191231dfef0" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Window</source>
          <target state="translated">&lt;cite&gt;101 Rx Samples&lt;/cite&gt; : Ventana</target>
        </trans-unit>
        <trans-unit id="7e1cda1b914a8d023f1dc4d23b17ff394f90c636" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Zip</source>
          <target state="translated">&lt;cite&gt;101 muestras Rx&lt;/cite&gt; : Zip</target>
        </trans-unit>
        <trans-unit id="a4bda5dfe90db399b7c4b0b87d01c88b07162ee5" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;DebounceBuffer: Use publish(), debounce() and buffer() together to capture bursts of events.&lt;/cite&gt; by Ben Christensen</source>
          <target state="translated">&lt;cite&gt;DebounceBuffer: use publish (), debounce () y buffer () juntos para capturar r&amp;aacute;fagas de eventos. &lt;/cite&gt;por Ben Christensen</target>
        </trans-unit>
        <trans-unit id="a2c0ae8f6836ea32e237cbdd5a36d5da68d09d69" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;DebouncedBuffer With RxJava&lt;/cite&gt; by Gopal Kaushik</source>
          <target state="translated">&lt;cite&gt;DebouncedBuffer con RxJava&lt;/cite&gt; de Gopal Kaushik</target>
        </trans-unit>
        <trans-unit id="eda16f284575e40f90ac1dc6981b546622a0c621" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Aggregate</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : agregado</target>
        </trans-unit>
        <trans-unit id="29247369a4b0d247d97753a93d41653acdcc1b2c" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: All</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : todos</target>
        </trans-unit>
        <trans-unit id="93019059f558486ba0ef91989fbb8dc88733b68e" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: And-Then-When</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : y luego cuando</target>
        </trans-unit>
        <trans-unit id="dc360128e41bbeba319356f06f179ae8502f246c" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: AsyncSubject</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : AsyncSubject</target>
        </trans-unit>
        <trans-unit id="035b87099a1834a0e066b29f62655685da21f8a6" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: BehaviorSubject</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : BehaviorSubject</target>
        </trans-unit>
        <trans-unit id="8bc61a26f41cc061366ee6101362cf6f70d41f1b" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Buffer</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : Buffer</target>
        </trans-unit>
        <trans-unit id="5b117e897e1a17fe032c5af3a2ce613ff6014d11" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Buffer revisited</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : Buffer revisado</target>
        </trans-unit>
        <trans-unit id="ab41ea4f239b99143925cd4be6c94ac1e3cfefa7" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Cast and OfType</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : Cast y OfType</target>
        </trans-unit>
        <trans-unit id="dd718e0e229c64fe1688ec231dd8353c9a412db9" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Catch</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : Catch</target>
        </trans-unit>
        <trans-unit id="b321cc1c9b76079278935ccb62bff36d39200bc5" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: CombineLatest</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : CombineLatest</target>
        </trans-unit>
        <trans-unit id="116fa0f10acbbeea88e8d3059138b6ffe66c5444" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Concat</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : Concat</target>
        </trans-unit>
        <trans-unit id="1528f7d4c47527e0e461233c282602ab6d7c644e" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Contains</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : contiene</target>
        </trans-unit>
        <trans-unit id="3cbe58edf946b3f8dfb0bb7c462598c80afc1e93" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Count</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : Count</target>
        </trans-unit>
        <trans-unit id="c35d04abcc5dd65704022c34cf83804415cc2818" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Create</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : Crear</target>
        </trans-unit>
        <trans-unit id="c1fd0c382a8358907465f71dddc50255a92ecd52" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: DefaultIfEmpty</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : DefaultIfEmpty</target>
        </trans-unit>
        <trans-unit id="b0b4c1fb3d3566c798e145f7923dc2a08228d7a6" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Delay</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : Delay</target>
        </trans-unit>
        <trans-unit id="b54a5e164dffee3139f0b8af5169e80489a8e13b" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Distinct and DistinctUntilChanged</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : Distinct y DistinctUntilChanged</target>
        </trans-unit>
        <trans-unit id="777d04576f3bc70403fbe3a7bb1a9372ec841588" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Do</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : Do</target>
        </trans-unit>
        <trans-unit id="8eb3452c0d7a0dadb569326b2e61144cf85c9fd3" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: ElementAt and ElementAtUntilChanged</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : ElementAt y ElementAtUntilChanged</target>
        </trans-unit>
        <trans-unit id="102fcee9f7ec081921ab59ef89ed1c5e6b30e5de" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Finally</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : finalmente</target>
        </trans-unit>
        <trans-unit id="23ea11e182295d6ed28a6220510e239e26b5282e" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: First</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : Primero</target>
        </trans-unit>
        <trans-unit id="c115a63e4865e74a4f8c5c291e91b00b3a150355" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Generate</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : Generar</target>
        </trans-unit>
        <trans-unit id="60542fbfdcd01dc53807bc0478ce040a8e2f6f10" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: GroupBy</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : GroupBy</target>
        </trans-unit>
        <trans-unit id="540568cfdc74e1f0a4c7b8678fd0356e93246f46" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: GroupJoin</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : GroupJoin</target>
        </trans-unit>
        <trans-unit id="6339c110750aea5eb774297c37884bfcde2b0f79" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: IObservable</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : IObservable</target>
        </trans-unit>
        <trans-unit id="c3d98673531f7a8b8b3f9e8256945795eeabd6f8" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: IObserver</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : IObserver</target>
        </trans-unit>
        <trans-unit id="fd627340831e496d98293a5f69462983384dde95" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: IgnoreElements</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : IgnoreElements</target>
        </trans-unit>
        <trans-unit id="62256229d5203f226886b8e64e6ea284cf6957eb" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Interval</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : intervalo</target>
        </trans-unit>
        <trans-unit id="0c4474d3483ee629a00095c34b8d299693d81065" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Join</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : unirse</target>
        </trans-unit>
        <trans-unit id="87545688a3ea5ebc6e25e2842e72c8dd9c5d1e62" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Last</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : &amp;Uacute;ltimo</target>
        </trans-unit>
        <trans-unit id="0de669709c1879b9f542aa4f94c433bcc8290782" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Leaving the monad</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : Saliendo de la m&amp;oacute;nada</target>
        </trans-unit>
        <trans-unit id="1ec1f4dfc1029c5aa7773b137724641aade3c9a3" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Materialize and Dematerialize</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : materializar y desmaterializar</target>
        </trans-unit>
        <trans-unit id="b04f7fc5eb7b8ba52c2a9a92360ca02e81cf40ad" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Merge</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : Merge</target>
        </trans-unit>
        <trans-unit id="fa7869d155329c64ed405fc5786876dad056073d" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Min, Max, Sum, and Average</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : Min, Max, Sum y Average</target>
        </trans-unit>
        <trans-unit id="d365b1eb7a9536f57568dab1fe5dd916f25bda8d" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Publish &amp;amp; Connect</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : publicar y conectar</target>
        </trans-unit>
        <trans-unit id="e878ce5258868ac3eb4fdf5d6843d2c8b3a76f7b" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Range</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : rango</target>
        </trans-unit>
        <trans-unit id="c1cf07af2c8eace50997f716a98f99e4c0971f00" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: RefCount</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : RefCount</target>
        </trans-unit>
        <trans-unit id="084764999a741c143088232da1c0321b35e44092" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Repeat</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : repetir</target>
        </trans-unit>
        <trans-unit id="26de299ed749b577f696b62b39924a8a9e30ef6b" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Replay</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : Replay</target>
        </trans-unit>
        <trans-unit id="c06a12ff37836439265ffeb4d10fc8154fcfaa4f" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: ReplaySubject</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : ReplaySubject</target>
        </trans-unit>
        <trans-unit id="b30bd9ac68d920b64f5efe285e03d588837291f5" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Retry</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : Reintentar</target>
        </trans-unit>
        <trans-unit id="54854f0097fa9244f288e39b24e48e27f8b83e4b" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Return</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : retorno</target>
        </trans-unit>
        <trans-unit id="79e2be634bb26a274d4fdf88c706025ebeaa2d11" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Sample</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : muestra</target>
        </trans-unit>
        <trans-unit id="1e1001379cadd511d49b86bafe6e12c95acd7607" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Scan</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : escaneo</target>
        </trans-unit>
        <trans-unit id="dc0d36e7e05dd4add274fb3feede439a3a19fa5b" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Scheduling and Threading</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : programaci&amp;oacute;n y subprocesos</target>
        </trans-unit>
        <trans-unit id="d7dab96b686167a434b97d22488b8cb79d6c5417" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Select</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : seleccione</target>
        </trans-unit>
        <trans-unit id="477286cb919491f0f63e72a8903656eb7a6282c1" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: SelectMany</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : SelectMany</target>
        </trans-unit>
        <trans-unit id="ee1800b1d9f701e32bfd1c70be2fcb64008e74f8" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: SequenceEqual</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : SequenceEqual</target>
        </trans-unit>
        <trans-unit id="ed818ec833039363080c9f8f4e89173be2b16966" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Simple Factory Methods</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : m&amp;eacute;todos simples de f&amp;aacute;brica</target>
        </trans-unit>
        <trans-unit id="fd00bb3e997d8645bdf8fe33420a70c94cda4c6e" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Single</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : Single</target>
        </trans-unit>
        <trans-unit id="b745a93a790b9dad2a52091e6386fcbbc51de6ee" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Skip and Take</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : Omitir y tomar</target>
        </trans-unit>
        <trans-unit id="1443306acabe169cf8f390ed1c3f8bbc6913bfee" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: SkipLast and TakeLast</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : SkipLast y TakeLast</target>
        </trans-unit>
        <trans-unit id="5cfe8d6a7fee34f4bb8d00922555c4a8c705669f" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: SkipUntil and TakeUntil</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : SkipUntil y TakeUntil</target>
        </trans-unit>
        <trans-unit id="b6650c255e70bfd3620e12c3cc72fedf90eadf2e" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: SkipWhile and TakeWhile</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : SkipWhile y TakeWhile</target>
        </trans-unit>
        <trans-unit id="8cc66b563aabc4fbedb00d8119ba74bacef0ab41" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: StartWith</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : StartWith</target>
        </trans-unit>
        <trans-unit id="9086b49d24c6b80e0f6a79b601213b2ce91d13b5" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Subject</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : Asunto</target>
        </trans-unit>
        <trans-unit id="9a983fed5c5e768256355b29f51e96fa5bbb549e" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: SubscribeOn and ObserveOn</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : SubscribeOn y ObserveOn</target>
        </trans-unit>
        <trans-unit id="83b0d127d96097cab2795ab626cee0a49915b626" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Switch</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : Switch</target>
        </trans-unit>
        <trans-unit id="598171f79ea0f898758ff883e3ad03569f596954" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Throttle</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : Throttle</target>
        </trans-unit>
        <trans-unit id="c2b85e9531a48451320c69fba5b56201a54cdb7f" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Timeout</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : Timeout</target>
        </trans-unit>
        <trans-unit id="e98b8b62bdf570f0a4177044a6de1ba2c46e8d5c" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Timer</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : temporizador</target>
        </trans-unit>
        <trans-unit id="7aaa2e22718c5ee322409e5e0fbbf4c9fbefbd6c" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Timestamp and TimeInterval</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : marca de tiempo e intervalo de tiempo</target>
        </trans-unit>
        <trans-unit id="8b1306a6995c5be8256f3ea632e95419c48355f6" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Using</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : uso</target>
        </trans-unit>
        <trans-unit id="82e2eaaf295a67907acba8525225401373b5b6e8" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Where</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : d&amp;oacute;nde</target>
        </trans-unit>
        <trans-unit id="88acce28317e2934f05b0089a12e44c31a31df21" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Window</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : Ventana</target>
        </trans-unit>
        <trans-unit id="311056bb87e8631686c9a13f7a9aa24b48a750b3" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Zip</source>
          <target state="translated">&lt;cite&gt;Introducci&amp;oacute;n a Rx&lt;/cite&gt; : Zip</target>
        </trans-unit>
        <trans-unit id="6c9f75058fd74c2e40d3fbad984b2426f71c5f1b" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Microsoft Developer Network&lt;/cite&gt;: &amp;ldquo;What does the new ManySelect operator do?&amp;rdquo;</source>
          <target state="translated">&lt;cite&gt;Microsoft Developer Network&lt;/cite&gt; : &quot;&amp;iquest;Qu&amp;eacute; hace el nuevo operador ManySelect?&quot;</target>
        </trans-unit>
        <trans-unit id="a2513d452931404692c534110e17b00bb086db47" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Rx Design Guidelines&lt;/cite&gt;</source>
          <target state="translated">&lt;cite&gt;Pautas de dise&amp;ntilde;o de Rx&lt;/cite&gt;</target>
        </trans-unit>
        <trans-unit id="f16b13d1d2d48a4ab59af38cc3f2786f48280ae9" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Rx Workshop: Schedulers&lt;/cite&gt;</source>
          <target state="translated">&lt;cite&gt;Taller de Rx: Programadores&lt;/cite&gt;</target>
        </trans-unit>
        <trans-unit id="69b16a529d6fb7f077c4e534c2ba8a41a8b5195c" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Rx Workshop&lt;/cite&gt;: Introduction</source>
          <target state="translated">&lt;cite&gt;Taller de Rx&lt;/cite&gt; : Introducci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="5e372f7712619b05579788c28d99a8619d24c02b" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Rx Workshop&lt;/cite&gt;: Schedulers</source>
          <target state="translated">&lt;cite&gt;Taller de Rx&lt;/cite&gt; : Programadores</target>
        </trans-unit>
        <trans-unit id="5060b2e8a80327e13489eab521802fc2c1470513" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;RxJS Design Guidelines&lt;/cite&gt;</source>
          <target state="translated">&lt;cite&gt;Directrices de dise&amp;ntilde;o de RxJS&lt;/cite&gt;</target>
        </trans-unit>
        <trans-unit id="84472df2bda697a25594c7286ae6152a2914a3d3" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;RxJava Threading Examples&lt;/cite&gt; by Graham Lea</source>
          <target state="translated">&lt;cite&gt;Ejemplos de subprocesos RxJava&lt;/cite&gt; por Graham Lea</target>
        </trans-unit>
        <trans-unit id="3c89a5198e1f457a5def50b38dd05269b98b494b" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;StackOverflow&lt;/cite&gt;: What is a &amp;ldquo;Scheduler&amp;rdquo; in RxJS</source>
          <target state="translated">&lt;cite&gt;StackOverflow&lt;/cite&gt; : &amp;iquest;Qu&amp;eacute; es un &quot;Programador&quot; en RxJS?</target>
        </trans-unit>
        <trans-unit id="99ad2748ced1a268c1da5ba38bef169ec3221a63" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;ad-hockery&lt;/cite&gt;: Simple Background Polling with RxJava</source>
          <target state="translated">&lt;cite&gt;ad-hockery&lt;/cite&gt; : sondeo en segundo plano simple con RxJava</target>
        </trans-unit>
        <trans-unit id="fdc895a0d19a290d9d7e1ce1ff10f8f31be62c51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;)&lt;/code&gt;. This behaves similarly to &lt;code&gt;stopAndWait&lt;/code&gt; but has an internal buffer of</source>
          <target state="translated">&lt;code&gt;)&lt;/code&gt; . Esto se comporta de manera similar a &lt;code&gt;stopAndWait&lt;/code&gt; pero tiene un b&amp;uacute;fer interno de</target>
        </trans-unit>
        <trans-unit id="ee8c7fe962e91ed4b8f8c0b825242e59e8443a3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;All&lt;/code&gt;, &lt;code&gt;Amb&lt;/code&gt;, &lt;code&gt;Contains&lt;/code&gt;, &lt;code&gt;DefaultIfEmpty&lt;/code&gt;, &lt;code&gt;SequenceEqual&lt;/code&gt;, &lt;code&gt;SkipUntil&lt;/code&gt;, &lt;code&gt;SkipWhile&lt;/code&gt;, &lt;code&gt;TakeUntil&lt;/code&gt;, and &lt;code&gt;TakeWhile&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;All&lt;/code&gt; , &lt;code&gt;Amb&lt;/code&gt; , &lt;code&gt;Contains&lt;/code&gt; , &lt;code&gt;DefaultIfEmpty&lt;/code&gt; , &lt;code&gt;SequenceEqual&lt;/code&gt; , &lt;code&gt;SkipUntil&lt;/code&gt; , &lt;code&gt;SkipWhile&lt;/code&gt; , &lt;code&gt;TakeUntil&lt;/code&gt; y &lt;code&gt;TakeWhile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f6d4b2413273db5421b89d5d4bf5bbc759de0ea7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;And&lt;/code&gt;/&lt;code&gt;Then&lt;/code&gt;/&lt;code&gt;When&lt;/code&gt;, &lt;code&gt;CombineLatest&lt;/code&gt;, &lt;code&gt;Join&lt;/code&gt;, &lt;code&gt;Merge&lt;/code&gt;, &lt;code&gt;StartWith&lt;/code&gt;, &lt;code&gt;Switch&lt;/code&gt;, and &lt;code&gt;Zip&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;And&lt;/code&gt; / &lt;code&gt;Then&lt;/code&gt; / &lt;code&gt;When&lt;/code&gt; , &lt;code&gt;CombineLatest&lt;/code&gt; , &lt;code&gt;Join&lt;/code&gt; , &lt;code&gt;Merge&lt;/code&gt; , &lt;code&gt;StartWith&lt;/code&gt; , &lt;code&gt;Switch&lt;/code&gt; y &lt;code&gt;Zip&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7126635798dce02399a0d9194f6641dfa46c0068" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Average&lt;/code&gt;, &lt;code&gt;Concat&lt;/code&gt;, &lt;code&gt;Count&lt;/code&gt;, &lt;code&gt;Max&lt;/code&gt;, &lt;code&gt;Min&lt;/code&gt;, &lt;code&gt;Reduce&lt;/code&gt;, and &lt;code&gt;Sum&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Average&lt;/code&gt; , &lt;code&gt;Concat&lt;/code&gt; , &lt;code&gt;Count&lt;/code&gt; , &lt;code&gt;Max&lt;/code&gt; , &lt;code&gt;Min&lt;/code&gt; , &lt;code&gt;Reduce&lt;/code&gt; y &lt;code&gt;Sum&lt;/code&gt; ar</target>
        </trans-unit>
        <trans-unit id="4c5c2eccca242affd9bbd13eb09e3476a9ed7742" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BlockingObservable.forEach&lt;/code&gt; takes a single function as its parameter, and this function behaves much like an &lt;code&gt;onNext&lt;/code&gt; function in the subscription to an ordinary Observable. The &lt;code&gt;forEach&lt;/code&gt; operator itself blocks until the &lt;code&gt;BlockingObservable&lt;/code&gt; completes, and it is by unblocking, rather than by calling a callback function, that it indicates that it is complete. If it encounters an error it will throw a &lt;code&gt;RuntimeException&lt;/code&gt; (rather than calling an analogue to the &lt;code&gt;onError&lt;/code&gt; callback).</source>
          <target state="translated">&lt;code&gt;BlockingObservable.forEach&lt;/code&gt; toma una sola funci&amp;oacute;n como par&amp;aacute;metro, y esta funci&amp;oacute;n se comporta de manera muy similar a una funci&amp;oacute;n &lt;code&gt;onNext&lt;/code&gt; en la suscripci&amp;oacute;n a un Observable ordinario. El &lt;code&gt;forEach&lt;/code&gt; operador forEach bloquea hasta que se completa &lt;code&gt;BlockingObservable&lt;/code&gt; , y es al desbloquear, en lugar de llamar a una funci&amp;oacute;n de devoluci&amp;oacute;n de llamada, que indica que est&amp;aacute; completo. Si encuentra un error, lanzar&amp;aacute; una &lt;code&gt;RuntimeException&lt;/code&gt; (en lugar de llamar a un an&amp;aacute;logo a la &lt;code&gt;onError&lt;/code&gt; llamada onError ).</target>
        </trans-unit>
        <trans-unit id="9fbef09e1b4ea0717efe751ffcefe7699946c25c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Buffer(bufferOpenings, bufferClosingSelector)&lt;/code&gt; monitors an Observable, &lt;code&gt;BufferOpenings&lt;/code&gt;, that emits &lt;code&gt;TBufferOpening&lt;/code&gt; objects. Each time it observes such an emitted item, it creates a new &lt;code&gt;IList&lt;/code&gt; to begin collecting items emitted by the source Observable and it passes the &lt;code&gt;TBufferOpening&lt;/code&gt; object into the &lt;code&gt;bufferClosingSelector&lt;/code&gt; function. That function returns an Observable. &lt;code&gt;Buffer&lt;/code&gt; monitors that Observable and when it detects an emitted item from it, it closes the &lt;code&gt;IList&lt;/code&gt; and emits it as its own emission.</source>
          <target state="translated">&lt;code&gt;Buffer(bufferOpenings, bufferClosingSelector)&lt;/code&gt; monitorea un Observable, &lt;code&gt;BufferOpenings&lt;/code&gt; , que emite objetos &lt;code&gt;TBufferOpening&lt;/code&gt; . Cada vez que observa un elemento emitido de este tipo, crea un nuevo &lt;code&gt;IList&lt;/code&gt; para comenzar a recopilar elementos emitidos por el Observable de origen y pasa el objeto &lt;code&gt;TBufferOpening&lt;/code&gt; a la funci&amp;oacute;n &lt;code&gt;bufferClosingSelector&lt;/code&gt; . Esa funci&amp;oacute;n devuelve un Observable. &lt;code&gt;Buffer&lt;/code&gt; monitorea ese Observable y cuando detecta un elemento emitido por &amp;eacute;l, cierra el &lt;code&gt;IList&lt;/code&gt; y lo emite como su propia emisi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="17d76f7cc4ba89864f1b43d8207b52f2436f06ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Buffer(count)&lt;/code&gt; emits non-overlapping buffers in the form of &lt;code&gt;IList&lt;/code&gt;s, each of which contains at most &lt;code&gt;count&lt;/code&gt; items from the source Observable (the final emitted &lt;code&gt;IList&lt;/code&gt; may have fewer than &lt;code&gt;count&lt;/code&gt; items).</source>
          <target state="translated">&lt;code&gt;Buffer(count)&lt;/code&gt; emite buffers no superpuestos en forma de &lt;code&gt;IList&lt;/code&gt; , cada uno de los cuales contiene como m&amp;aacute;ximo elementos de &lt;code&gt;count&lt;/code&gt; de la fuente Observable (el &lt;code&gt;IList&lt;/code&gt; emitido final puede tener menos de elementos de &lt;code&gt;count&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7081d72299cbb568724327709a714b40f340cd51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Buffer(count, skip)&lt;/code&gt; creates a new buffer starting with the first emitted item from the source Observable, and every &lt;code&gt;skip&lt;/code&gt; items thereafter, and fills each buffer with &lt;code&gt;count&lt;/code&gt; items: the initial item and &lt;code&gt;count-1&lt;/code&gt; subsequent ones. It emits these buffers as &lt;code&gt;IList&lt;/code&gt;s. Depending on the values of &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;skip&lt;/code&gt; these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).</source>
          <target state="translated">&lt;code&gt;Buffer(count, skip)&lt;/code&gt; crea un nuevo b&amp;uacute;fer comenzando con el primer elemento emitido desde el Observable de origen, y cada elemento &lt;code&gt;skip&lt;/code&gt; partir de entonces, y llena cada b&amp;uacute;fer con elementos de &lt;code&gt;count&lt;/code&gt; : el elemento inicial y los siguientes &lt;code&gt;count-1&lt;/code&gt; . Emite estos b&amp;uacute;feres como &lt;code&gt;IList&lt;/code&gt; . Dependiendo de los valores de &lt;code&gt;count&lt;/code&gt; y &lt;code&gt;skip&lt;/code&gt; , estos b&amp;uacute;feres pueden superponerse (varios b&amp;uacute;feres pueden contener el mismo elemento), o pueden tener espacios (donde los elementos emitidos por el Observable de origen no est&amp;aacute;n representados en ning&amp;uacute;n b&amp;uacute;fer).</target>
        </trans-unit>
        <trans-unit id="0da2abc6a4d49055692e67ed62d86fc2cb0e1e82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Buffer(timeSpan)&lt;/code&gt; emits a new &lt;code&gt;IList&lt;/code&gt; of items periodically, every &lt;code&gt;timeSpan&lt;/code&gt; amount of time, containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first list, since the subscription to the source Observable. There is also a version of this variant of the operator that takes an &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;IScheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan.</source>
          <target state="translated">&lt;code&gt;Buffer(timeSpan)&lt;/code&gt; emite una nueva &lt;code&gt;IList&lt;/code&gt; de elementos peri&amp;oacute;dicamente, cada &lt;code&gt;timeSpan&lt;/code&gt; cantidad de tiempo, que contiene todos los elementos emitidos por la fuente Observable desde la emisi&amp;oacute;n del paquete anterior o, en el caso de la primera lista, desde la suscripci&amp;oacute;n a la fuente Observable. Tambi&amp;eacute;n hay una versi&amp;oacute;n de esta variante del operador que toma un &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;IScheduler&lt;/code&gt; &lt;/a&gt; como par&amp;aacute;metro y lo usa para gobernar el intervalo de tiempo.</target>
        </trans-unit>
        <trans-unit id="fe0db02107ba69f00dfab9f9466aa0e853bf477c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Buffer(timeSpan, count)&lt;/code&gt; emits a new &lt;code&gt;IList&lt;/code&gt; of items for every &lt;code&gt;count&lt;/code&gt; items emitted by the source Observable, or, if &lt;code&gt;timeSpan&lt;/code&gt; has elapsed since its last list emission, it emits a list of however many items the source Observable has emitted in that span, even if this is fewer than &lt;code&gt;count&lt;/code&gt;. There is also a version of this variant of the operator that takes an &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;IScheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan.</source>
          <target state="translated">&lt;code&gt;Buffer(timeSpan, count)&lt;/code&gt; emite una nueva &lt;code&gt;IList&lt;/code&gt; de elementos para cada &lt;code&gt;count&lt;/code&gt; elementos emitidos por la fuente Observable o, si &lt;code&gt;timeSpan&lt;/code&gt; ha transcurrido desde la &amp;uacute;ltima emisi&amp;oacute;n de la lista, emite una lista de todos los elementos que la fuente Observable ha emitido en ese lapso , incluso si esto es menos de lo que &lt;code&gt;count&lt;/code&gt; . Tambi&amp;eacute;n hay una versi&amp;oacute;n de esta variante del operador que toma un &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;IScheduler&lt;/code&gt; &lt;/a&gt; como par&amp;aacute;metro y lo usa para gobernar el intervalo de tiempo.</target>
        </trans-unit>
        <trans-unit id="8b47fc6baedd7b73f21f5f4d7959f2aa975a8452" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Buffer(timeSpan, timeShift)&lt;/code&gt; creates a new &lt;code&gt;IList&lt;/code&gt; of items every &lt;code&gt;timeShift&lt;/code&gt; period of time, and fills this list with every item emitted by the source Observable from that time until &lt;code&gt;timeSpan&lt;/code&gt; time has passed since the list&amp;rsquo;s creation, before emitting this &lt;code&gt;IList&lt;/code&gt; as its own emission. If &lt;code&gt;timeSpan&lt;/code&gt; is longer than &lt;code&gt;timeShift&lt;/code&gt;, the emitted lists will represent time periods that overlap and so they may contain duplicate items. There is also a version of this variant of the operator that takes an &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;IScheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan.</source>
          <target state="translated">&lt;code&gt;Buffer(timeSpan, timeShift)&lt;/code&gt; crea una nueva &lt;code&gt;IList&lt;/code&gt; de elementos cada &lt;code&gt;timeShift&lt;/code&gt; per&amp;iacute;odo de tiempo, y llena esta lista con cada elemento emitido por la fuente Observable desde ese momento hasta que &lt;code&gt;timeSpan&lt;/code&gt; ha pasado el tiempo desde la creaci&amp;oacute;n de la lista, antes de emitir este &lt;code&gt;IList&lt;/code&gt; como propio emisi&amp;oacute;n. Si &lt;code&gt;timeSpan&lt;/code&gt; es m&amp;aacute;s largo que &lt;code&gt;timeShift&lt;/code&gt; , las listas emitidas representar&amp;aacute;n per&amp;iacute;odos de tiempo que se superponen y, por lo tanto, pueden contener elementos duplicados. Tambi&amp;eacute;n hay una versi&amp;oacute;n de esta variante del operador que toma un &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;IScheduler&lt;/code&gt; &lt;/a&gt; como par&amp;aacute;metro y lo usa para gobernar el intervalo de tiempo.</target>
        </trans-unit>
        <trans-unit id="dabc780819d59525df52a91f7676a389f3e0f2a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Buffer&lt;/code&gt;, &lt;code&gt;FlatMap&lt;/code&gt;, &lt;code&gt;GroupBy&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;Scan&lt;/code&gt;, and &lt;code&gt;Window&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Buffer&lt;/code&gt; , &lt;code&gt;FlatMap&lt;/code&gt; , &lt;code&gt;GroupBy&lt;/code&gt; , &lt;code&gt;Map&lt;/code&gt; , &lt;code&gt;Scan&lt;/code&gt; y &lt;code&gt;Window&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="36249d8634975dadb84d72123168f8247b877485" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Catch&lt;/code&gt; and &lt;code&gt;Retry&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Catch&lt;/code&gt; y &lt;code&gt;Retry&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1e1e26c0b89264fa68e936ea021b56c4aec1f096" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Connect&lt;/code&gt;, &lt;code&gt;Publish&lt;/code&gt;, &lt;code&gt;RefCount&lt;/code&gt;, and &lt;code&gt;Replay&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Connect&lt;/code&gt; , &lt;code&gt;Publish&lt;/code&gt; , &lt;code&gt;RefCount&lt;/code&gt; , y &lt;code&gt;Replay&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5a2352bf3b7789aa73de64405f99b50a6b876dcd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Create&lt;/code&gt;, &lt;code&gt;Defer&lt;/code&gt;, &lt;code&gt;Empty&lt;/code&gt;/&lt;code&gt;Never&lt;/code&gt;/&lt;code&gt;Throw&lt;/code&gt;, &lt;code&gt;From&lt;/code&gt;, &lt;code&gt;Interval&lt;/code&gt;, &lt;code&gt;Just&lt;/code&gt;, &lt;code&gt;Range&lt;/code&gt;, &lt;code&gt;Repeat&lt;/code&gt;, &lt;code&gt;Start&lt;/code&gt;, and &lt;code&gt;Timer&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Create&lt;/code&gt; , &lt;code&gt;Defer&lt;/code&gt; , &lt;code&gt;Empty&lt;/code&gt; / &lt;code&gt;Never&lt;/code&gt; / &lt;code&gt;Throw&lt;/code&gt; , &lt;code&gt;From&lt;/code&gt; , &lt;code&gt;Interval&lt;/code&gt; o , &lt;code&gt;Just&lt;/code&gt; , &lt;code&gt;Range&lt;/code&gt; , &lt;code&gt;Repeat&lt;/code&gt; , &lt;code&gt;Start&lt;/code&gt; y &lt;code&gt;Timer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="af0cc0f15199ef85fbb9ecd6605602fd48b0e87a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Debounce&lt;/code&gt;, &lt;code&gt;Distinct&lt;/code&gt;, &lt;code&gt;ElementAt&lt;/code&gt;, &lt;code&gt;Filter&lt;/code&gt;, &lt;code&gt;First&lt;/code&gt;, &lt;code&gt;IgnoreElements&lt;/code&gt;, &lt;code&gt;Last&lt;/code&gt;, &lt;code&gt;Sample&lt;/code&gt;, &lt;code&gt;Skip&lt;/code&gt;, &lt;code&gt;SkipLast&lt;/code&gt;, &lt;code&gt;Take&lt;/code&gt;, and &lt;code&gt;TakeLast&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Debounce&lt;/code&gt; , &lt;code&gt;Distinct&lt;/code&gt; , &lt;code&gt;ElementAt&lt;/code&gt; , &lt;code&gt;Filter&lt;/code&gt; , &lt;code&gt;First&lt;/code&gt; , &lt;code&gt;IgnoreElements&lt;/code&gt; , &lt;code&gt;Last&lt;/code&gt; , &lt;code&gt;Sample&lt;/code&gt; , &lt;code&gt;Skip&lt;/code&gt; , Omitir &lt;code&gt;SkipLast&lt;/code&gt; , &lt;code&gt;Take&lt;/code&gt; y &lt;code&gt;TakeLast&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a5f8d43efabcb2ababea7b078ba251a574b59be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Delay&lt;/code&gt;, &lt;code&gt;Do&lt;/code&gt;, &lt;code&gt;Materialize&lt;/code&gt;/&lt;code&gt;Dematerialize&lt;/code&gt;, &lt;code&gt;ObserveOn&lt;/code&gt;, &lt;code&gt;Serialize&lt;/code&gt;, &lt;code&gt;Subscribe&lt;/code&gt;, &lt;code&gt;SubscribeOn&lt;/code&gt;, &lt;code&gt;TimeInterval&lt;/code&gt;, &lt;code&gt;Timeout&lt;/code&gt;, &lt;code&gt;Timestamp&lt;/code&gt;, and &lt;code&gt;Using&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Delay&lt;/code&gt; , &lt;code&gt;Do&lt;/code&gt; , &lt;code&gt;Materialize&lt;/code&gt; / &lt;code&gt;Dematerialize&lt;/code&gt; , &lt;code&gt;ObserveOn&lt;/code&gt; , &lt;code&gt;Serialize&lt;/code&gt; , &lt;code&gt;Subscribe&lt;/code&gt; , &lt;code&gt;SubscribeOn&lt;/code&gt; , &lt;code&gt;TimeInterval&lt;/code&gt; , &lt;code&gt;Timeout&lt;/code&gt; , &lt;code&gt;Timestamp&lt;/code&gt; , y &lt;code&gt;Using&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e1b4675304049fa90cdf432a831ba6b5c8ac581b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PublishSubject&lt;/code&gt; emits to an observer only those items that are emitted by the source Observable(s) subsequent to the time of the subscription.</source>
          <target state="translated">&lt;code&gt;PublishSubject&lt;/code&gt; emite a un observador solo aquellos elementos que son emitidos por el Observable (s) de origen despu&amp;eacute;s del momento de la suscripci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="95c856f5db49856ca93f078770fa39860cfdd2e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ReplaySubject&lt;/code&gt; emits to any observer all of the items that were emitted by the source Observable(s), regardless of when the observer subscribes.</source>
          <target state="translated">&lt;code&gt;ReplaySubject&lt;/code&gt; emite a cualquier observador todos los elementos que fueron emitidos por el Observable (s) fuente, independientemente de cu&amp;aacute;ndo se suscriba el observador.</target>
        </trans-unit>
        <trans-unit id="3d6e191c77e6cb37262a32efe110a3b46253be77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Window(timeSpan,count&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Window(timeSpan,count&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e2656e1a12907334ba6ba9dbb22e19905e2e0d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Window(timeSpan,timeShift&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Window(timeSpan,timeShift&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5a145b69fbb341823a7e2b8ac1730617d11c3e2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Window(timeSpan&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Window(timeSpan&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="652dd811848564f467f4c6881792205b07b1ddcc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;average&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;average&lt;/code&gt; se encuentra en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="9a5d83aa14e9a24c0de81cecf086101bb52aa929" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(boundary)&lt;/code&gt; monitors an Observable, &lt;code&gt;boundary&lt;/code&gt;. Each time that Observable emits an item, it creates a new &lt;code&gt;List&lt;/code&gt; to begin collecting items emitted by the source Observable and emits the previous &lt;code&gt;List&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;buffer(boundary)&lt;/code&gt; monitorea un &lt;code&gt;boundary&lt;/code&gt; observable . Cada vez que Observable emite un elemento, crea una nueva &lt;code&gt;List&lt;/code&gt; a para comenzar a recopilar elementos emitidos por el Observable de origen y emite la &lt;code&gt;List&lt;/code&gt; a anterior .</target>
        </trans-unit>
        <trans-unit id="697675068739693864b5220ff9294b45d325c570" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(boundary&lt;/code&gt;[&lt;code&gt;, initialCapacity&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;buffer(boundary&lt;/code&gt; [ &lt;code&gt;, initialCapacity&lt;/code&gt; ] &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41bbfe617dacf8cd6bfdd7ec53d1681abb55514b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(bufferBoundaries)&lt;/code&gt; monitors an Observable, &lt;code&gt;bufferBoundaries&lt;/code&gt;. Each time that Observable emits an item, it creates a new collection to begin collecting items emitted by the source Observable and emits the previous collection.</source>
          <target state="translated">&lt;code&gt;buffer(bufferBoundaries)&lt;/code&gt; monitorea un Observable, &lt;code&gt;bufferBoundaries&lt;/code&gt; . Cada vez que Observable emite un elemento, crea una nueva colecci&amp;oacute;n para comenzar a recolectar elementos emitidos por la fuente Observable y emite la colecci&amp;oacute;n anterior.</target>
        </trans-unit>
        <trans-unit id="5308080ad587c5e4577043e64860d26d587755fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(bufferOpenings, bufferClosingSelector)&lt;/code&gt; monitors an Observable, &lt;code&gt;bufferOpenings&lt;/code&gt;, that emits &lt;code&gt;BufferOpening&lt;/code&gt; objects. Each time it observes such an emitted item, it creates a new &lt;code&gt;List&lt;/code&gt; to begin collecting items emitted by the source Observable and it passes the &lt;code&gt;bufferOpenings&lt;/code&gt; Observable into the &lt;code&gt;closingSelector&lt;/code&gt; function. That function returns an Observable. &lt;code&gt;buffer&lt;/code&gt; monitors that Observable and when it detects an emitted item from it, it closes the &lt;code&gt;List&lt;/code&gt; and emits it as its own emission.</source>
          <target state="translated">&lt;code&gt;buffer(bufferOpenings, bufferClosingSelector)&lt;/code&gt; monitorea un Observable, &lt;code&gt;bufferOpenings&lt;/code&gt; , que emite objetos &lt;code&gt;BufferOpening&lt;/code&gt; . Cada vez que observa un elemento emitido de este tipo, crea una nueva &lt;code&gt;List&lt;/code&gt; a para comenzar a recopilar elementos emitidos por la fuente Observable y pasa el &lt;code&gt;bufferOpenings&lt;/code&gt; Observable a la funci&amp;oacute;n &lt;code&gt;closingSelector&lt;/code&gt; . Esa funci&amp;oacute;n devuelve un Observable. &lt;code&gt;buffer&lt;/code&gt; monitorea ese Observable y cuando detecta un elemento emitido de &amp;eacute;l, cierra la &lt;code&gt;List&lt;/code&gt; a y lo emite como su propia emisi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="2570789cc0e868e96a6ac6bd1dc1fbc11fe2d472" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(bufferOpenings, bufferClosingSelector)&lt;/code&gt; monitors an Observable, &lt;code&gt;bufferOpenings&lt;/code&gt;, that emits &lt;code&gt;BufferOpening&lt;/code&gt; objects. Each time it observes such an emitted item, it creates a new collection to begin collecting items emitted by the source Observable and it passes the &lt;code&gt;bufferOpenings&lt;/code&gt; Observable into the &lt;code&gt;bufferClosingSelector&lt;/code&gt; function. That function returns an Observable. &lt;code&gt;buffer&lt;/code&gt; monitors that Observable and when it detects an emitted item from it, it emits the current collection and begins a new one.</source>
          <target state="translated">&lt;code&gt;buffer(bufferOpenings, bufferClosingSelector)&lt;/code&gt; monitorea un Observable, &lt;code&gt;bufferOpenings&lt;/code&gt; , que emite objetos &lt;code&gt;BufferOpening&lt;/code&gt; . Cada vez que observa un elemento emitido de este tipo, crea una nueva colecci&amp;oacute;n para comenzar a recopilar elementos emitidos por la fuente Observable y pasa el &lt;code&gt;bufferOpenings&lt;/code&gt; Observable a la funci&amp;oacute;n &lt;code&gt;bufferClosingSelector&lt;/code&gt; . Esa funci&amp;oacute;n devuelve un Observable. &lt;code&gt;buffer&lt;/code&gt; monitorea ese Observable y cuando detecta un elemento emitido por &amp;eacute;l, emite la colecci&amp;oacute;n actual y comienza una nueva.</target>
        </trans-unit>
        <trans-unit id="a6fe61d7081d96d83ff99876095e8a6fd192610b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(buffer_openings=boundaryObservable)&lt;/code&gt; monitors an Observable, &lt;code&gt;buffer_openings&lt;/code&gt;. Each time that Observable emits an item, it creates a new array to begin collecting items emitted by the source Observable and emits the previous array.</source>
          <target state="translated">&lt;code&gt;buffer(buffer_openings=boundaryObservable)&lt;/code&gt; monitorea un Observable, &lt;code&gt;buffer_openings&lt;/code&gt; . Cada vez que Observable emite un elemento, crea una nueva matriz para comenzar a recopilar elementos emitidos por la fuente Observable y emite la matriz anterior.</target>
        </trans-unit>
        <trans-unit id="863a8824c4e8d667b06cdd3b24a0e6ddd6012b66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(closing_selector=closingSelector)&lt;/code&gt; begins collecting items emitted by the source Observable immediately upon subscription, and also calls the &lt;code&gt;closing_selector&lt;/code&gt; function to generate a second Observable. It monitors this new Observable and, when it completes or emits an item, it emits the current array, begins a new array to collect items from the source Observable, and calls &lt;code&gt;closing_selector&lt;/code&gt; again to generate a new Observable to monitor in order to determine when to emit the new array. It repeats this process until the source Observable terminates, whereupon it emits the final array.</source>
          <target state="translated">&lt;code&gt;buffer(closing_selector=closingSelector)&lt;/code&gt; comienza a recolectar elementos emitidos por el Observable fuente inmediatamente despu&amp;eacute;s de la suscripci&amp;oacute;n, y tambi&amp;eacute;n llama a la funci&amp;oacute;n &lt;code&gt;closing_selector&lt;/code&gt; para generar un segundo Observable. Supervisa este nuevo Observable y, cuando completa o emite un elemento, emite la matriz actual, comienza una nueva matriz para recopilar elementos del Observable de origen y llama a &lt;code&gt;closing_selector&lt;/code&gt; nuevamente para generar un nuevo Observable para monitorear con el fin de determinar cu&amp;aacute;ndo emitir la nueva matriz. Repite este proceso hasta que la fuente Observable termina, despu&amp;eacute;s de lo cual emite la matriz final.</target>
        </trans-unit>
        <trans-unit id="bd4258a2e6df22ec7068de8e9b1e62f83c9e1a70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(closing_selector=openingSelector,&amp;nbsp;buffer_closing_selector=closingSelector)&lt;/code&gt; begins by calling &lt;code&gt;closing_selector&lt;/code&gt; to get an Observable. It monitors this Observable, and, whenever it emits an item, &lt;code&gt;buffer&lt;/code&gt; creates a new array, begins to collect items subsequently emitted by the source Observable into this array, and calls &lt;code&gt;buffer_closing_selector&lt;/code&gt; to get a new Observable to govern the closing of that array. When this new Observable emits an item or terminates, &lt;code&gt;buffer&lt;/code&gt; closes and emits the array that the Observable governs.</source>
          <target state="translated">&lt;code&gt;buffer(closing_selector=openingSelector,&amp;nbsp;buffer_closing_selector=closingSelector)&lt;/code&gt; comienza llamando a &lt;code&gt;closing_selector&lt;/code&gt; para obtener un Observable. Supervisa este Observable y, siempre que emite un elemento, el &lt;code&gt;buffer&lt;/code&gt; crea una nueva matriz, comienza a recopilar elementos posteriormente emitidos por el Observable de origen en esta matriz y llama a &lt;code&gt;buffer_closing_selector&lt;/code&gt; para obtener un nuevo Observable para gobernar el cierre de esa matriz. Cuando este nuevo Observable emite un elemento o termina, el &lt;code&gt;buffer&lt;/code&gt; cierra y emite la matriz que gobierna el Observable.</target>
        </trans-unit>
        <trans-unit id="46e14b0f10edb4752edcbe58757c5d212bbc1279" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(count)&lt;/code&gt; emits non-overlapping buffers in the form of &lt;code&gt;List&lt;/code&gt;s, each of which contains at most &lt;code&gt;count&lt;/code&gt; items from the source Observable (the final emitted &lt;code&gt;List&lt;/code&gt; may have fewer than &lt;code&gt;count&lt;/code&gt; items).</source>
          <target state="translated">&lt;code&gt;buffer(count)&lt;/code&gt; emite b&amp;uacute;feres no superpuestos en forma de &lt;code&gt;List&lt;/code&gt; s, cada uno de los cuales contiene como m&amp;aacute;ximo elementos de &lt;code&gt;count&lt;/code&gt; de la fuente Observable (la &lt;code&gt;List&lt;/code&gt; a emitida final puede tener menos de elementos de &lt;code&gt;count&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2056abba30f4856c7d26994b3b4bbf8b8a30285a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(count)&lt;/code&gt; emits non-overlapping buffers in the form of &lt;code&gt;vector&lt;/code&gt;s, each of which contains at most &lt;code&gt;count&lt;/code&gt; items from the source Observable (the final emitted &lt;code&gt;vector&lt;/code&gt; may have fewer than &lt;code&gt;count&lt;/code&gt; items).</source>
          <target state="translated">&lt;code&gt;buffer(count)&lt;/code&gt; emite b&amp;uacute;feres no superpuestos en forma de &lt;code&gt;vector&lt;/code&gt; es , cada uno de los cuales contiene como m&amp;aacute;ximo elementos de &lt;code&gt;count&lt;/code&gt; de la fuente Observable (el &lt;code&gt;vector&lt;/code&gt; emitido final puede tener menos de elementos de &lt;code&gt;count&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2ee3ca99f3c9242184fe103637a7205a45e39454" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(count, skip)&lt;/code&gt; creates a new buffer starting with the first emitted item from the source Observable, and every &lt;code&gt;skip&lt;/code&gt; items thereafter, and fills each buffer with &lt;code&gt;count&lt;/code&gt; items: the initial item and &lt;code&gt;count-1&lt;/code&gt; subsequent ones. It emits these buffers as &lt;code&gt;List&lt;/code&gt;s. Depending on the values of &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;skip&lt;/code&gt; these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).</source>
          <target state="translated">&lt;code&gt;buffer(count, skip)&lt;/code&gt; crea un nuevo b&amp;uacute;fer comenzando con el primer elemento emitido desde el origen Observable, y cada uno de los elementos &lt;code&gt;skip&lt;/code&gt; partir de entonces, y llena cada b&amp;uacute;fer con elementos de &lt;code&gt;count&lt;/code&gt; : el elemento inicial y &lt;code&gt;count-1&lt;/code&gt; subsiguientes. Emite estos b&amp;uacute;feres como &lt;code&gt;List&lt;/code&gt; s. Dependiendo de los valores de &lt;code&gt;count&lt;/code&gt; y &lt;code&gt;skip&lt;/code&gt; , estos b&amp;uacute;feres pueden superponerse (varios b&amp;uacute;feres pueden contener el mismo elemento), o pueden tener espacios (donde los elementos emitidos por el Observable de origen no est&amp;aacute;n representados en ning&amp;uacute;n b&amp;uacute;fer).</target>
        </trans-unit>
        <trans-unit id="c22dda51013aba339b4f5301fae6b2e4da5eccb1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(count, skip)&lt;/code&gt; creates a new buffer starting with the first emitted item from the source Observable, and every &lt;code&gt;skip&lt;/code&gt; items thereafter, and fills each buffer with &lt;code&gt;count&lt;/code&gt; items: the initial item and &lt;code&gt;count-1&lt;/code&gt; subsequent ones. It emits these buffers as &lt;code&gt;vector&lt;/code&gt;s. Depending on the values of &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;skip&lt;/code&gt; these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).</source>
          <target state="translated">&lt;code&gt;buffer(count, skip)&lt;/code&gt; crea un nuevo b&amp;uacute;fer comenzando con el primer elemento emitido desde el origen Observable, y todos los elementos &lt;code&gt;skip&lt;/code&gt; partir de entonces, y llena cada b&amp;uacute;fer con elementos de &lt;code&gt;count&lt;/code&gt; : el elemento inicial y &lt;code&gt;count-1&lt;/code&gt; subsiguientes. Emite estos b&amp;uacute;feres como &lt;code&gt;vector&lt;/code&gt; es . Dependiendo de los valores de &lt;code&gt;count&lt;/code&gt; y &lt;code&gt;skip&lt;/code&gt; , estos b&amp;uacute;feres pueden superponerse (varios b&amp;uacute;feres pueden contener el mismo elemento), o pueden tener espacios (donde los elementos emitidos por el Observable de origen no est&amp;aacute;n representados en ning&amp;uacute;n b&amp;uacute;fer).</target>
        </trans-unit>
        <trans-unit id="583f8a99c7e6fa0453a17cde605fa702f865a085" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(timespan, timeshift, unit&lt;/code&gt;[&lt;code&gt;, scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;buffer(timespan, timeshift, unit&lt;/code&gt; [ &lt;code&gt;, scheduler&lt;/code&gt; ] &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8fa2109d7bb913a1ea95726f4100c1cebac8aa2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(timespan, unit, count&lt;/code&gt;[&lt;code&gt;, scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;buffer(timespan, unit, count&lt;/code&gt; [ &lt;code&gt;, scheduler&lt;/code&gt; ] &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="491a83da4e4bb96760c09269a5758b2ad4a9dafe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(timespan, unit&lt;/code&gt;[&lt;code&gt;, scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;buffer(timespan, unit&lt;/code&gt; [ &lt;code&gt;, scheduler&lt;/code&gt; ] &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="64fa6aff05106cdc04eb3c628a3821de1a4df244" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(timespan, timeshift, unit)&lt;/code&gt; creates a new &lt;code&gt;List&lt;/code&gt; of items every &lt;code&gt;timeshift&lt;/code&gt; period of time, and fills this bundle with every item emitted by the source Observable from that time until &lt;code&gt;timespan&lt;/code&gt; time has passed since the bundle&amp;rsquo;s creation, before emitting this &lt;code&gt;List&lt;/code&gt; as its own emission. If &lt;code&gt;timespan&lt;/code&gt; is longer than &lt;code&gt;timeshift&lt;/code&gt;, the emitted bundles will represent time periods that overlap and so they may contain duplicate items. There is also a version of this variant of the operator that takes a &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan; by default this variant uses the &lt;code&gt;computation&lt;/code&gt; scheduler.</source>
          <target state="translated">&lt;code&gt;buffer(timespan, timeshift, unit)&lt;/code&gt; crea una nueva &lt;code&gt;List&lt;/code&gt; de elementos cada per&amp;iacute;odo de tiempo de &lt;code&gt;timeshift&lt;/code&gt; , y llena este paquete con cada elemento emitido por la fuente Observable desde ese momento hasta que el &lt;code&gt;timespan&lt;/code&gt; transcurre desde la creaci&amp;oacute;n del paquete, antes de emitir esta &lt;code&gt;List&lt;/code&gt; como su propia emisi&amp;oacute;n. Si el &lt;code&gt;timespan&lt;/code&gt; es m&amp;aacute;s largo que el &lt;code&gt;timeshift&lt;/code&gt; temporal, los paquetes emitidos representar&amp;aacute;n per&amp;iacute;odos de tiempo que se superponen y, por lo tanto, pueden contener elementos duplicados. Tambi&amp;eacute;n hay una versi&amp;oacute;n de esta variante del operador que toma un &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; como par&amp;aacute;metro y lo usa para gobernar el intervalo de tiempo; de forma predeterminada, esta variante utiliza el planificador de &lt;code&gt;computation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4b98a3f859f7bbc620366a633025b1515dde55a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(timespan, timeshift=timeshift)&lt;/code&gt; creates a new array of items every &lt;code&gt;timeshift&lt;/code&gt; milliseconds, and fills this array with every item emitted by the source Observable from that time until &lt;code&gt;timespan&lt;/code&gt; milliseconds have passed since the array&amp;rsquo;s creation, before emitting this array as its own emission. If &lt;code&gt;timespan&lt;/code&gt; is longer than &lt;code&gt;timeshift&lt;/code&gt;, the emitted arrays will represent time periods that overlap and so they may contain duplicate items. There is also a version of this variant of the operator that takes a &lt;code&gt;scheduler&lt;/code&gt; parameter and uses it to govern the timespan; by default this variant uses the &lt;code&gt;timeout&lt;/code&gt; scheduler.</source>
          <target state="translated">&lt;code&gt;buffer(timespan, timeshift=timeshift)&lt;/code&gt; crea una nueva gama de art&amp;iacute;culos cada &lt;code&gt;timeshift&lt;/code&gt; milisegundos, y llena esta matriz con cada art&amp;iacute;culo emitida por la fuente observable desde ese momento hasta &lt;code&gt;timespan&lt;/code&gt; milisegundos han transcurrido desde la creaci&amp;oacute;n de la matriz, antes de emitir esta matriz como su propio emisi&amp;oacute;n. Si el &lt;code&gt;timespan&lt;/code&gt; es m&amp;aacute;s largo que el &lt;code&gt;timeshift&lt;/code&gt; temporal, las matrices emitidas representar&amp;aacute;n per&amp;iacute;odos de tiempo que se superponen y, por lo tanto, pueden contener elementos duplicados. Tambi&amp;eacute;n hay una versi&amp;oacute;n de esta variante del operador que toma un par&amp;aacute;metro del &lt;code&gt;scheduler&lt;/code&gt; y lo usa para gobernar el intervalo de tiempo; de forma predeterminada, esta variante utiliza el programador de &lt;code&gt;timeout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0533305f953f0a309e5df453b9e133d20568e589" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(timespan, unit)&lt;/code&gt; emits a new &lt;code&gt;List&lt;/code&gt; of items periodically, every &lt;code&gt;timespan&lt;/code&gt; amount of time, containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first bundle, since the subscription to the source Observable. There is also a version of this variant of the operator that takes a &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan; by default this variant uses the &lt;code&gt;computation&lt;/code&gt; Scheduler.</source>
          <target state="translated">&lt;code&gt;buffer(timespan, unit)&lt;/code&gt; emite una nueva &lt;code&gt;List&lt;/code&gt; de elementos peri&amp;oacute;dicamente, cada &lt;code&gt;timespan&lt;/code&gt; de tiempo, que contiene todos los elementos emitidos por la fuente Observable desde la emisi&amp;oacute;n del paquete anterior o, en el caso del primer paquete, desde la suscripci&amp;oacute;n a la fuente Observable . Tambi&amp;eacute;n hay una versi&amp;oacute;n de esta variante del operador que toma un &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; como par&amp;aacute;metro y lo usa para gobernar el intervalo de tiempo; de forma predeterminada, esta variante utiliza el programador de &lt;code&gt;computation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e360891f0984ef4090aa7ada4740dcbb4f704617" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(timespan, unit)&lt;/code&gt; emits a new &lt;code&gt;List&lt;/code&gt; of items periodically, every &lt;code&gt;timespan&lt;/code&gt; amount of time, containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first bundle, since the subscription to the source Observable. There is also a version of this variant of the operator that takes a &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan; by default this variant uses the &lt;code&gt;computation&lt;/code&gt; scheduler.</source>
          <target state="translated">&lt;code&gt;buffer(timespan, unit)&lt;/code&gt; emite una nueva &lt;code&gt;List&lt;/code&gt; de elementos peri&amp;oacute;dicamente, cada &lt;code&gt;timespan&lt;/code&gt; de tiempo, que contiene todos los elementos emitidos por la fuente Observable desde la emisi&amp;oacute;n del paquete anterior o, en el caso del primer paquete, desde la suscripci&amp;oacute;n a la fuente Observable . Tambi&amp;eacute;n hay una versi&amp;oacute;n de esta variante del operador que toma un &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; como par&amp;aacute;metro y lo usa para gobernar el intervalo de tiempo; de forma predeterminada, esta variante utiliza el planificador de &lt;code&gt;computation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8371395551452bb18051c520c2f4b5a089268672" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(timespan, unit, count)&lt;/code&gt; emits a new &lt;code&gt;List&lt;/code&gt; of items for every &lt;code&gt;count&lt;/code&gt; items emitted by the source Observable, or, if &lt;code&gt;timespan&lt;/code&gt; has elapsed since its last bundle emission, it emits a bundle of however many items the source Observable has emitted in that span, even if this is fewer than &lt;code&gt;count&lt;/code&gt;. There is also a version of this variant of the operator that takes a &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan; by default this variant uses the &lt;code&gt;computation&lt;/code&gt; scheduler.</source>
          <target state="translated">&lt;code&gt;buffer(timespan, unit, count)&lt;/code&gt; emite una nueva &lt;code&gt;List&lt;/code&gt; de elementos para cada &lt;code&gt;count&lt;/code&gt; elementos emitidos por la fuente Observable o, si ha transcurrido el &lt;code&gt;timespan&lt;/code&gt; desde su &amp;uacute;ltima emisi&amp;oacute;n de paquete, emite un paquete de todos los elementos que la fuente Observable haya emitido en ese lapso, incluso si esto es menos de lo que &lt;code&gt;count&lt;/code&gt; . Tambi&amp;eacute;n hay una versi&amp;oacute;n de esta variante del operador que toma un &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; como par&amp;aacute;metro y lo usa para gobernar el intervalo de tiempo; de forma predeterminada, esta variante utiliza el planificador de &lt;code&gt;computation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="065b6459d070388eac1369f1d551fcb749fb19e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;buffer&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="19c3817e4bc1a4a104318a507d1f1df1dcce46ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer&lt;/code&gt; requires one of the following distributions:</source>
          <target state="translated">&lt;code&gt;buffer&lt;/code&gt; requiere una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="f240d669d61624f913fe346aa844fe8dd4cbf0fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bufferWithCount(count)&lt;/code&gt; emits non-overlapping buffers, each of which contains at most &lt;code&gt;count&lt;/code&gt; items from the source Observable (the final emitted buffer may contain fewer than &lt;code&gt;count&lt;/code&gt; items).</source>
          <target state="translated">&lt;code&gt;bufferWithCount(count)&lt;/code&gt; emite b&amp;uacute;feres no superpuestos, cada uno de los cuales contiene como m&amp;aacute;ximo elementos de &lt;code&gt;count&lt;/code&gt; de la fuente Observable (el b&amp;uacute;fer emitido final puede contener menos de elementos de &lt;code&gt;count&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="29a77fe8590e836748bec1afceb482424cc55b73" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bufferWithCount(count, skip)&lt;/code&gt; creates a new buffer starting with the first emitted item from the source Observable, and a new one for every &lt;code&gt;skip&lt;/code&gt; items thereafter, and fills each buffer with &lt;code&gt;count&lt;/code&gt; items: the initial item and &lt;code&gt;count-1&lt;/code&gt; subsequent ones, emitting each buffer when it is complete. Depending on the values of &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;skip&lt;/code&gt; these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).</source>
          <target state="translated">&lt;code&gt;bufferWithCount(count, skip)&lt;/code&gt; crea un nuevo b&amp;uacute;fer comenzando con el primer elemento emitido desde el origen Observable, y uno nuevo para cada elemento &lt;code&gt;skip&lt;/code&gt; partir de entonces, y llena cada b&amp;uacute;fer con elementos de &lt;code&gt;count&lt;/code&gt; : el elemento inicial y &lt;code&gt;count-1&lt;/code&gt; subsiguientes, emitiendo cada b&amp;uacute;fer cuando est&amp;eacute; completo. Dependiendo de los valores de &lt;code&gt;count&lt;/code&gt; y &lt;code&gt;skip&lt;/code&gt; , estos b&amp;uacute;feres pueden superponerse (varios b&amp;uacute;feres pueden contener el mismo elemento), o pueden tener espacios (donde los elementos emitidos por el Observable de origen no est&amp;aacute;n representados en ning&amp;uacute;n b&amp;uacute;fer).</target>
        </trans-unit>
        <trans-unit id="4d936831debc89a8b2338b3a3007dc091decf55f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bufferWithCount&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;bufferWithCount&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="725109d45ba1846de8a6b8392b6391092d1a98ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bufferWithTime(timeSpan)&lt;/code&gt; emits a new collection of items periodically, every &lt;code&gt;timeSpan&lt;/code&gt; milliseconds, containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first bundle, since the subscription to the source Observable. There is also a version of this variant of the operator that takes a &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan; by default this variant uses the &lt;code&gt;timeout&lt;/code&gt; scheduler.</source>
          <target state="translated">&lt;code&gt;bufferWithTime(timeSpan)&lt;/code&gt; emite una nueva colecci&amp;oacute;n de elementos peri&amp;oacute;dicamente, cada &lt;code&gt;timeSpan&lt;/code&gt; milisegundos, que contiene todos los elementos emitidos por la fuente Observable desde la emisi&amp;oacute;n del paquete anterior o, en el caso del primer paquete, desde la suscripci&amp;oacute;n a la fuente Observable. Tambi&amp;eacute;n hay una versi&amp;oacute;n de esta variante del operador que toma un &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; como par&amp;aacute;metro y lo usa para gobernar el intervalo de tiempo; de forma predeterminada, esta variante utiliza el programador de &lt;code&gt;timeout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6826b6f33554f8fb1de2ebf021c2cadcb4cd9c17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bufferWithTime(timeSpan, timeShift)&lt;/code&gt; creates a new collection of items every &lt;code&gt;timeShift&lt;/code&gt; milliseconds, and fills this bundle with every item emitted by the source Observable from that time until &lt;code&gt;timeSpan&lt;/code&gt; milliseconds has passed since the collection&amp;rsquo;s creation, before emitting this collection as its own emission. If &lt;code&gt;timeSpan&lt;/code&gt; is longer than &lt;code&gt;timeShift&lt;/code&gt;, the emitted bundles will represent time periods that overlap and so they may contain duplicate items. There is also a version of this variant of the operator that takes a &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan; by default this variant uses the &lt;code&gt;timeout&lt;/code&gt; scheduler.</source>
          <target state="translated">&lt;code&gt;bufferWithTime(timeSpan, timeShift)&lt;/code&gt; crea una nueva colecci&amp;oacute;n de elementos cada &lt;code&gt;timeShift&lt;/code&gt; milisegundos, y llena este paquete con cada elemento emitido por la fuente Observable desde ese momento hasta que &lt;code&gt;timeSpan&lt;/code&gt; milisegundos ha pasado desde la creaci&amp;oacute;n de la colecci&amp;oacute;n, antes de emitir esta colecci&amp;oacute;n como su propia emisi&amp;oacute;n. Si &lt;code&gt;timeSpan&lt;/code&gt; es m&amp;aacute;s largo que &lt;code&gt;timeShift&lt;/code&gt; , los paquetes emitidos representar&amp;aacute;n per&amp;iacute;odos de tiempo que se superponen y, por lo tanto, pueden contener elementos duplicados. Tambi&amp;eacute;n hay una versi&amp;oacute;n de esta variante del operador que toma un &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; como par&amp;aacute;metro y lo usa para gobernar el intervalo de tiempo; de forma predeterminada, esta variante utiliza el programador de &lt;code&gt;timeout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65d0e7bcf4ac65e74eca9ba20646e209c2c82ff0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bufferWithTime&lt;/code&gt; and &lt;code&gt;bufferWithTimeOrCount&lt;/code&gt; are found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;bufferWithTime&lt;/code&gt; y &lt;code&gt;bufferWithTimeOrCount&lt;/code&gt; se encuentran en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="5725f9a1a6a7c85dc4d290333be130a63966d6a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bufferWithTime&lt;/code&gt; and &lt;code&gt;bufferWithTimeOrCount&lt;/code&gt; require one of the following distributions:</source>
          <target state="translated">&lt;code&gt;bufferWithTime&lt;/code&gt; y &lt;code&gt;bufferWithTimeOrCount&lt;/code&gt; requieren una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="29da60953849f79c94578371fc21981b0e02a7a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bufferWithTimeOrCount(timeSpan, count)&lt;/code&gt; emits a new collection of items for every &lt;code&gt;count&lt;/code&gt; items emitted by the source Observable, or, if &lt;code&gt;timeSpan&lt;/code&gt; milliseconds have elapsed since its last collection emission, it emits a collection of however many items the source Observable has emitted in that span, even if this is fewer than &lt;code&gt;count&lt;/code&gt;. There is also a version of this variant of the operator that takes a &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan; by default this variant uses the &lt;code&gt;timeout&lt;/code&gt; scheduler.</source>
          <target state="translated">&lt;code&gt;bufferWithTimeOrCount(timeSpan, count)&lt;/code&gt; emite una nueva colecci&amp;oacute;n de elementos para cada &lt;code&gt;count&lt;/code&gt; elementos emitidos por la fuente Observable o, si &lt;code&gt;timeSpan&lt;/code&gt; milisegundos han transcurrido desde su &amp;uacute;ltima emisi&amp;oacute;n de colecci&amp;oacute;n, emite una colecci&amp;oacute;n de la cantidad de elementos que la fuente Observable haya emitido en ese span, incluso si es menor que el &lt;code&gt;count&lt;/code&gt; . Tambi&amp;eacute;n hay una versi&amp;oacute;n de esta variante del operador que toma un &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; como par&amp;aacute;metro y lo usa para gobernar el intervalo de tiempo; de forma predeterminada, esta variante utiliza el programador de &lt;code&gt;timeout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa343001bbb40cc3e8b3cc541b1d7a9764e511ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer_with_count(count)&lt;/code&gt; emits non-overlapping buffers in the form of arrays, each of which contains at most &lt;code&gt;count&lt;/code&gt; items from the source Observable (the final emitted array may have fewer than &lt;code&gt;count&lt;/code&gt; items).</source>
          <target state="translated">&lt;code&gt;buffer_with_count(count)&lt;/code&gt; emite b&amp;uacute;feres que no se superponen en forma de matrices, cada una de las cuales contiene como m&amp;aacute;ximo elementos de &lt;code&gt;count&lt;/code&gt; de la fuente Observable (la matriz emitida final puede tener menos de elementos de &lt;code&gt;count&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b64633ff8b9b99511e1f91464f9c7b8f23d5b394" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer_with_count(count, skip=skip)&lt;/code&gt; creates a new buffer starting with the first emitted item from the source Observable, and every &lt;code&gt;skip&lt;/code&gt; items thereafter, and fills each buffer with &lt;code&gt;count&lt;/code&gt; items: the initial item and &lt;code&gt;count-1&lt;/code&gt; subsequent ones. It emits these buffers as arrays. Depending on the values of &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;skip&lt;/code&gt; these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).</source>
          <target state="translated">&lt;code&gt;buffer_with_count(count, skip=skip)&lt;/code&gt; crea un nuevo b&amp;uacute;fer comenzando con el primer elemento emitido desde el origen Observable, y cada elemento &lt;code&gt;skip&lt;/code&gt; partir de entonces, y llena cada b&amp;uacute;fer con elementos de &lt;code&gt;count&lt;/code&gt; : el elemento inicial y &lt;code&gt;count-1&lt;/code&gt; subsiguientes. Emite estos b&amp;uacute;feres como matrices. Dependiendo de los valores de &lt;code&gt;count&lt;/code&gt; y &lt;code&gt;skip&lt;/code&gt; , estos b&amp;uacute;feres pueden superponerse (varios b&amp;uacute;feres pueden contener el mismo elemento), o pueden tener espacios (donde los elementos emitidos por el Observable de origen no est&amp;aacute;n representados en ning&amp;uacute;n b&amp;uacute;fer).</target>
        </trans-unit>
        <trans-unit id="da6265be2e09c0f88dba2c30d63bf9e68b96a9c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer_with_time(timespan)&lt;/code&gt; emits a new array of items periodically, every &lt;code&gt;timespan&lt;/code&gt; milliseconds, containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first bundle, since the subscription to the source Observable.</source>
          <target state="translated">&lt;code&gt;buffer_with_time(timespan)&lt;/code&gt; emite una nueva matriz de elementos peri&amp;oacute;dicamente, cada &lt;code&gt;timespan&lt;/code&gt; milisegundos, que contiene todos los elementos emitidos por la fuente Observable desde la emisi&amp;oacute;n del paquete anterior o, en el caso del primer paquete, desde la suscripci&amp;oacute;n a la fuente Observable.</target>
        </trans-unit>
        <trans-unit id="2c21c1882f580b27cb8db9eac720ea9eaf14d8e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer_with_time(timespan)&lt;/code&gt; emits a new array of items periodically, every &lt;code&gt;timespan&lt;/code&gt; milliseconds, containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first bundle, since the subscription to the source Observable. There is also a version of this variant of the operator that takes a &lt;code&gt;scheduler&lt;/code&gt; parameter and uses it to govern the timespan; by default this variant uses the &lt;code&gt;timeout&lt;/code&gt; scheduler.</source>
          <target state="translated">&lt;code&gt;buffer_with_time(timespan)&lt;/code&gt; emite una nueva matriz de elementos peri&amp;oacute;dicamente, cada &lt;code&gt;timespan&lt;/code&gt; milisegundos, que contiene todos los elementos emitidos por la fuente Observable desde la emisi&amp;oacute;n del paquete anterior o, en el caso del primer paquete, desde la suscripci&amp;oacute;n a la fuente Observable. Tambi&amp;eacute;n hay una versi&amp;oacute;n de esta variante del operador que toma un par&amp;aacute;metro del &lt;code&gt;scheduler&lt;/code&gt; y lo usa para gobernar el intervalo de tiempo; de forma predeterminada, esta variante utiliza el programador de &lt;code&gt;timeout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dedb9b5d750555c146f9ea815130104bd7cdac7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer_with_time_or_count(timespan, count)&lt;/code&gt; emits a new array of items for every &lt;code&gt;count&lt;/code&gt; items emitted by the source Observable, or, if &lt;code&gt;timespan&lt;/code&gt; milliseconds have elapsed since its last bundle emission, it emits an array of however many items the source Observable has emitted in that span, even if this is fewer than &lt;code&gt;count&lt;/code&gt;. There is also a version of this variant of the operator that takes a &lt;code&gt;scheduler&lt;/code&gt; parameter and uses it to govern the timespan; by default this variant uses the &lt;code&gt;timeout&lt;/code&gt; scheduler.</source>
          <target state="translated">&lt;code&gt;buffer_with_time_or_count(timespan, count)&lt;/code&gt; emite una nueva serie de art&amp;iacute;culos por cada &lt;code&gt;count&lt;/code&gt; elementos emitidos por la fuente observable, o, si &lt;code&gt;timespan&lt;/code&gt; milisegundos han transcurrido desde su &amp;uacute;ltima emisi&amp;oacute;n de haz, emite una serie de embargo muchos art&amp;iacute;culos de la fuente observable ha emitido en ese span, incluso si es menor que el &lt;code&gt;count&lt;/code&gt; . Tambi&amp;eacute;n hay una versi&amp;oacute;n de esta variante del operador que toma un par&amp;aacute;metro del &lt;code&gt;scheduler&lt;/code&gt; y lo usa para gobernar el intervalo de tiempo; de forma predeterminada, esta variante utiliza el programador de &lt;code&gt;timeout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8efbc0dfab77384e5695e0391a88f43d1c0aa03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;case&lt;/code&gt;/&lt;code&gt;switchCase&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;case&lt;/code&gt; / &lt;code&gt;switchCase&lt;/code&gt; se encuentra en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="21ab85f941795ebebc7621966c024835b3854ce9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;catch&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; se encuentra en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="6eada5ba41149936eb42223cb804a2da3d2fb07e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;collect&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;collect&lt;/code&gt; no opera por defecto en ning&amp;uacute;n &lt;a href=&quot;../scheduler&quot;&gt;Programador en&lt;/a&gt; particular .</target>
        </trans-unit>
        <trans-unit id="2e34bcdea7b0a4428fe34327e1ecd484b3e7fa08" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concat&lt;/code&gt; and &lt;code&gt;concatAll&lt;/code&gt; are found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;concat&lt;/code&gt; y &lt;code&gt;concatAll&lt;/code&gt; se encuentran en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="fc4f8fb42b68e7c7b7e5316591de9ce7532f3f71" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concat&lt;/code&gt; takes a variable number of Observables (or Promises) as parameters (or a single array of Observables or Promises), and concatenates them in the order they appear in the parameter list (or array). It exists as both an Observable prototype method and as an instance method.</source>
          <target state="translated">&lt;code&gt;concat&lt;/code&gt; toma un n&amp;uacute;mero variable de Observables (o Promesas) como par&amp;aacute;metros (o una &amp;uacute;nica matriz de Observables o Promesas) y los concatena en el orden en que aparecen en la lista de par&amp;aacute;metros (o matriz). Existe como m&amp;eacute;todo de prototipo observable y como m&amp;eacute;todo de instancia.</target>
        </trans-unit>
        <trans-unit id="8a05f7b7657968ed6c712decc49d7b955c8b6966" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concatAll&lt;/code&gt; is an instance method that operates on an Observable of Observables, concatinating each of these Observables in the order they are emitted.</source>
          <target state="translated">&lt;code&gt;concatAll&lt;/code&gt; es un m&amp;eacute;todo de instancia que opera en un Observable of Observables, concatenando cada uno de estos Observables en el orden en que se emiten.</target>
        </trans-unit>
        <trans-unit id="e66c4829b49a33917cc27c0640b2259d52e1e55f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concatAll&lt;/code&gt; operates on an Observable of Observables, concatinating each of these Observables in the order they are emitted.</source>
          <target state="translated">&lt;code&gt;concatAll&lt;/code&gt; opera en un Observable of Observables, concatenando cada uno de estos Observables en el orden en que se emiten.</target>
        </trans-unit>
        <trans-unit id="c0409c43e5cc9d6d379c8bea27199652abd6f255" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concatMap&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;concatMap&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="7d029702d3e9b15b15c6b4d30027e9cc6d70b4e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concatMapObserver&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;concatMapObserver&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="bfb35a6a3b4f9a20c3186e62ff7a21cb33bee0fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;connect&lt;/code&gt; is found in the following packages:</source>
          <target state="translated">&lt;code&gt;connect&lt;/code&gt; se encuentra en los siguientes paquetes:</target>
        </trans-unit>
        <trans-unit id="9640f1d7fa4ad35d3539ac1d849fef7fe71caa33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;connect&lt;/code&gt; requires one of the following packages:</source>
          <target state="translated">&lt;code&gt;connect&lt;/code&gt; requiere uno de los siguientes paquetes:</target>
        </trans-unit>
        <trans-unit id="c5e5e027558b94847fe199fe7233b289d43c3988" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;contains&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;contains&lt;/code&gt; se encuentra en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="f02a10531ba2d78eaba589a48c7af53fab6e76c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count&lt;/code&gt; is part of the following packages:</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; es parte de los siguientes paquetes:</target>
        </trans-unit>
        <trans-unit id="0fcbf042928888fd25281733fb74efa8027c00f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count&lt;/code&gt; requires one of any of the following packages:</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; requiere uno de los siguientes paquetes:</target>
        </trans-unit>
        <trans-unit id="8a6fbc195a31b898bd2620e8000a89499dcc9336" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;create&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;create&lt;/code&gt; no opera por defecto en ning&amp;uacute;n &lt;a href=&quot;../scheduler&quot;&gt;Programador en&lt;/a&gt; particular .</target>
        </trans-unit>
        <trans-unit id="9606d8bf5fdf3394981d341c49d099b55449f265" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;create&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;create&lt;/code&gt; se encuentra en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="4fb2205ee6a769cc0527dc0468e5653d34418731" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;debounce&lt;/code&gt; and &lt;code&gt;debounceWithSelector&lt;/code&gt; are found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;debounce&lt;/code&gt; y &lt;code&gt;debounceWithSelector&lt;/code&gt; se encuentran en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="f6ec38915190181a63aae2734403ec6811aa79ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defaultIfEmpty&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;defaultIfEmpty&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="0501ae0183e1bc12b30af5067f70d83fa221b7e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defer&lt;/code&gt; does not by default operate on a particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;defer&lt;/code&gt; no opera por defecto en un &lt;a href=&quot;../scheduler&quot;&gt;Programador en&lt;/a&gt; particular .</target>
        </trans-unit>
        <trans-unit id="1c4d06d8cc0b00cad69791240d6a9faa69aef0a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defer&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;defer&lt;/code&gt; se encuentra en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="0453f1952ccc6ca5fae76fdaa5a6430077591489" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;delay&lt;/code&gt;, &lt;code&gt;delaySubscription&lt;/code&gt;, and &lt;code&gt;delayWithSelector&lt;/code&gt; require &lt;code&gt;rx.lite.js&lt;/code&gt; or &lt;code&gt;rx.lite.compat.js&lt;/code&gt; and are found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;delay&lt;/code&gt; , &lt;code&gt;delaySubscription&lt;/code&gt; y &lt;code&gt;delayWithSelector&lt;/code&gt; requieren &lt;code&gt;rx.lite.js&lt;/code&gt; o &lt;code&gt;rx.lite.compat.js&lt;/code&gt; y se encuentran en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="a42e6eae40facebfc9412f8cd67d437d4ba55fa6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;delaySubscription&lt;/code&gt; is similar to &lt;code&gt;delay&lt;/code&gt; but rather than timeshifting the emissions from the source Observable, it timeshifts the moment of subscription to that Observable. You pass to this operator a time value (either a &lt;code&gt;Number&lt;/code&gt;, in which case this sets the number of milliseconds of delay, or a &lt;code&gt;Date&lt;/code&gt;, in which case this sets an absolute future time at which &lt;code&gt;delaySubscription&lt;/code&gt; will trigger the subscription). You may optionally pass a &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; as a second parameter, which &lt;code&gt;delaySubscription&lt;/code&gt; will use to govern the delay period or trigger time.</source>
          <target state="translated">&lt;code&gt;delaySubscription&lt;/code&gt; es similar a &lt;code&gt;delay&lt;/code&gt; pero en lugar de diferir las emisiones de la fuente Observable, cambia el momento de la suscripci&amp;oacute;n a ese Observable. Pasas a este operador un valor de tiempo (ya sea un &lt;code&gt;Number&lt;/code&gt; , en cuyo caso establece el n&amp;uacute;mero de milisegundos de retraso, o una &lt;code&gt;Date&lt;/code&gt; , en cuyo caso establece un tiempo futuro absoluto en el que &lt;code&gt;delaySubscription&lt;/code&gt; activar&amp;aacute; la suscripci&amp;oacute;n). Opcionalmente, puede pasar un &lt;a href=&quot;../scheduler&quot;&gt;Programador&lt;/a&gt; como segundo par&amp;aacute;metro, que &lt;code&gt;delaySubscription&lt;/code&gt; utilizar&amp;aacute; para controlar el per&amp;iacute;odo de retraso o el tiempo de activaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e7adbe72591784b4a714d2eb115365bb13e4cea8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;delayWithSelector&lt;/code&gt; is like &lt;code&gt;delay&lt;/code&gt; but does not use a constant delay duration (or absolute time), but sets its delay duration on a per-item basis by passing each item from the source Observable into a function that returns an Observable and then monitoring those Observables. When any such Observable completes, the Observable returned by &lt;code&gt;delay&lt;/code&gt; emits the associated item.</source>
          <target state="translated">&lt;code&gt;delayWithSelector&lt;/code&gt; es como &lt;code&gt;delay&lt;/code&gt; pero no usa una duraci&amp;oacute;n de retardo constante (o tiempo absoluto), pero establece su duraci&amp;oacute;n de retardo por elemento pasando cada elemento del Observable de origen a una funci&amp;oacute;n que devuelve un Observable y luego monitorea esos Observables. Cuando se completa cualquier Observable, el Observable devuelto por &lt;code&gt;delay&lt;/code&gt; emite el elemento asociado.</target>
        </trans-unit>
        <trans-unit id="85526d492d5d878f590368951b13d664cbf0ab56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dematerialize&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;dematerialize&lt;/code&gt; no opera por defecto en ning&amp;uacute;n &lt;a href=&quot;../scheduler&quot;&gt;Programador en&lt;/a&gt; particular .</target>
        </trans-unit>
        <trans-unit id="d70c73d8be9dbb0a7ddccccd361323bf2f38ab4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dematerialize&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;dematerialize&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="2ca4c8f4b2a43c908128d7d73fdfa0aeec78bd21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dematerialize&lt;/code&gt; reverses this process: converting the emitted &lt;code&gt;Notification&lt;/code&gt; objects from the source Observable into notifications from the resulting Observable.</source>
          <target state="translated">&lt;code&gt;dematerialize&lt;/code&gt; invierte este proceso: convertir los objetos de &lt;code&gt;Notification&lt;/code&gt; emitidos del Observable de origen en notificaciones del Observable resultante.</target>
        </trans-unit>
        <trans-unit id="df41a1151275a1c436292bf439c78eb32a392ec7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dematerialize&lt;/code&gt; reverses this process: converting the emitted &lt;code&gt;Notification&lt;/code&gt; objects from the source Observable into notifications from the resulting Observable. The following example dematerializes the materialized Observable from the previous section:</source>
          <target state="translated">&lt;code&gt;dematerialize&lt;/code&gt; invierte este proceso: convertir los objetos de &lt;code&gt;Notification&lt;/code&gt; emitidos del Observable de origen en notificaciones del Observable resultante. El siguiente ejemplo desmaterializa el Observable materializado del apartado anterior:</target>
        </trans-unit>
        <trans-unit id="575b0cbaa7c437c082382619ee3d2b599c5d8aa6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;distinct&lt;/code&gt; and &lt;code&gt;distinctUntilChanged&lt;/code&gt; are found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;distinct&lt;/code&gt; y &lt;code&gt;distinctUntilChanged&lt;/code&gt; se encuentran en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="f65514f172ddc744697e1b142c1194449befad2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;distinct&lt;/code&gt; and &lt;code&gt;distinctUntilChanged&lt;/code&gt; do not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;distinct&lt;/code&gt; y &lt;code&gt;distinctUntilChanged&lt;/code&gt; no operan por defecto en ning&amp;uacute;n &lt;a href=&quot;../scheduler&quot;&gt;Programador en&lt;/a&gt; particular .</target>
        </trans-unit>
        <trans-unit id="01a0882d7b2db85098410d045d7dff19792f7aa3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;do&lt;/code&gt;/&lt;code&gt;tap&lt;/code&gt;, &lt;code&gt;doOnNext&lt;/code&gt;/&lt;code&gt;tapOnNext&lt;/code&gt;, &lt;code&gt;doOnError&lt;/code&gt;/&lt;code&gt;tapOnError&lt;/code&gt;, &lt;code&gt;doOnCompleted&lt;/code&gt;/&lt;code&gt;tapOnCompleted&lt;/code&gt;, and &lt;code&gt;finally&lt;/code&gt; are found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;do&lt;/code&gt; / &lt;code&gt;tap&lt;/code&gt; , &lt;code&gt;doOnNext&lt;/code&gt; / &lt;code&gt;tapOnNext&lt;/code&gt; , &lt;code&gt;doOnError&lt;/code&gt; / &lt;code&gt;tapOnError&lt;/code&gt; , &lt;code&gt;doOnCompleted&lt;/code&gt; / &lt;code&gt;tapOnCompleted&lt;/code&gt; , y &lt;code&gt;finally&lt;/code&gt; se encuentran en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="ba28eb2a98755e124f1d52b5b9dcc8bd04262dc3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;doWhile&lt;/code&gt; is found in each of the following distributions.</source>
          <target state="translated">&lt;code&gt;doWhile&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones.</target>
        </trans-unit>
        <trans-unit id="8aee9c417fde4cd2d46ade859aa7f69f1f2a52e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;elementAt&lt;/code&gt; and &lt;code&gt;elementAtOrDefault&lt;/code&gt; do not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;elementAt&lt;/code&gt; y &lt;code&gt;elementAtOrDefault&lt;/code&gt; no operan por defecto en ning&amp;uacute;n &lt;a href=&quot;../scheduler&quot;&gt;Programador en&lt;/a&gt; particular .</target>
        </trans-unit>
        <trans-unit id="e0e41302836be86491f3b9837b34145fcc104fcf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;elementAt&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;elementAt&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="26d85c47be76d2b86ddbf1d36c82dae7e0563118" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;empty&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;empty&lt;/code&gt; se encuentra en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="1144ef5b59f5d111eb78cf1787143dd56d384a19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;every&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;every&lt;/code&gt; se encuentra en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="3575ee1fc6c15b236ec3868735424258902118a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expand&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;expand&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="b2c7c4225690df0f39e51c9f6112ab29eac89a70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expand&lt;/code&gt; requires one of the following distributions:</source>
          <target state="translated">&lt;code&gt;expand&lt;/code&gt; ir requiere una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="2cd400c1c5833ab09d2d1362e8821a842f57ba3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filter&lt;/code&gt; and &lt;code&gt;where&lt;/code&gt; are found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;filter&lt;/code&gt; y &lt;code&gt;where&lt;/code&gt; se encuentran en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="b4160a64d95ca2627e911591e307254638dca079" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filter&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;filter&lt;/code&gt; no opera por defecto en ning&amp;uacute;n &lt;a href=&quot;../scheduler&quot;&gt;Programador en&lt;/a&gt; particular .</target>
        </trans-unit>
        <trans-unit id="3b415955a2aa1c5cbed5857327ffa9aa9dba51fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;finallyDo&lt;/code&gt; is deprecated since RxJava 1.1.1, in favor of &lt;code&gt;doAfterTerminate&lt;/code&gt; with the same behavior.</source>
          <target state="translated">&lt;code&gt;finallyDo&lt;/code&gt; est&amp;aacute; en desuso desde RxJava 1.1.1, a favor de &lt;code&gt;doAfterTerminate&lt;/code&gt; con el mismo comportamiento.</target>
        </trans-unit>
        <trans-unit id="df5fe9a72c0b449743099df91b382964ece8478c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find&lt;/code&gt;, &lt;code&gt;findIndex&lt;/code&gt;, and &lt;code&gt;first&lt;/code&gt; are found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;find&lt;/code&gt; , &lt;code&gt;findIndex&lt;/code&gt; y &lt;code&gt;first&lt;/code&gt; se encuentran en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="9f9e2cc1497254c384bab408eec27fc4e6d63a6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findIndex&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;findIndex&lt;/code&gt; se encuentra en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="a2968359c689419c3b851f5749fe9db70e799191" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;first&lt;/code&gt;, &lt;code&gt;firstOrDefault&lt;/code&gt;, &lt;code&gt;single&lt;/code&gt;, &lt;code&gt;singleOrDefault&lt;/code&gt;, and &lt;code&gt;takeFirst&lt;/code&gt; do not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;first&lt;/code&gt; , &lt;code&gt;firstOrDefault&lt;/code&gt; , &lt;code&gt;single&lt;/code&gt; , &lt;code&gt;singleOrDefault&lt;/code&gt; y &lt;code&gt;takeFirst&lt;/code&gt; no funcionan de forma predeterminada en ning&amp;uacute;n &lt;a href=&quot;../scheduler&quot;&gt;programador en&lt;/a&gt; particular .</target>
        </trans-unit>
        <trans-unit id="dc69e12ef4eb80735da7a8ffa7381624d352d14e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;firstOrDefault&lt;/code&gt; also has a variant to which you can pass a predicate function, so that its Observable will emit the first item from the source Observable that the predicate evaluates as &lt;code&gt;true&lt;/code&gt;, or the default item if no items emitted by the source Observable pass the predicate.</source>
          <target state="translated">&lt;code&gt;firstOrDefault&lt;/code&gt; tambi&amp;eacute;n tiene una variante a la que puede pasar una funci&amp;oacute;n de predicado, de modo que su Observable emitir&amp;aacute; el primer elemento del Observable de origen que el predicado eval&amp;uacute;a como &lt;code&gt;true&lt;/code&gt; , o el elemento predeterminado si ning&amp;uacute;n elemento emitido por el Observable de origen pasa el predicado.</target>
        </trans-unit>
        <trans-unit id="06f0ceae9a2712cef444daa2be24a1a18e0220a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flatMap&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;flatMap&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="a73ed2b1d04a2afe67083d006a5767d38008225d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flatMap&lt;/code&gt; works just as well if the function you provide transforms items from the source Observables into Observables, into Promises, or into arrays.</source>
          <target state="translated">&lt;code&gt;flatMap&lt;/code&gt; funciona igual de bien si la funci&amp;oacute;n que proporciona transforma elementos de los Observables de origen en Observables, en Promesas o en matrices.</target>
        </trans-unit>
        <trans-unit id="e5e16d10a285700e7dab486c58a155a35a9ce31e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flatMapLatest&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;flatMapLatest&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="8c825a3961cc54c6c6ef805e3fd98b58b8f603ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flatMapObserver&lt;/code&gt; creates (and flattens) a new Observable for each item &lt;em&gt;and notification&lt;/em&gt; from the source Observable. It accepts a different transformation function to respond to &lt;code&gt;onNext&lt;/code&gt;, &lt;code&gt;onError&lt;/code&gt;, and &lt;code&gt;onCompleted&lt;/code&gt; notifications and to return an Observable for each.</source>
          <target state="translated">&lt;code&gt;flatMapObserver&lt;/code&gt; crea (y aplana) un nuevo Observable para cada elemento &lt;em&gt;y notificaci&amp;oacute;n&lt;/em&gt; de la fuente Observable. Acepta una funci&amp;oacute;n de transformaci&amp;oacute;n diferente para responder a las &lt;code&gt;onNext&lt;/code&gt; , &lt;code&gt;onError&lt;/code&gt; y &lt;code&gt;onCompleted&lt;/code&gt; y devolver un Observable para cada una.</target>
        </trans-unit>
        <trans-unit id="f51b699df8e1441a48690c6b1971732a8b76801f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flatMapObserver&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;flatMapObserver&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="ef78b641e6d3a740830c8f89647cba368bc89806" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flatten&lt;/code&gt; takes as its parameter an Observable that emits Observables. It merges the items emitted by each of these Observables to create its own single Observable sequence. A variant of this operator allows you to pass in an &lt;code&gt;Int&lt;/code&gt; indicating the maximum number of these emitted Observables you want &lt;code&gt;flatten&lt;/code&gt; to try to be subscribed to at any time. It it hits this maximum subscription count, it will refrain from subscribing to any other Observables emitted by the source Observable until such time as one of the already-subscribed-to Observables issues an &lt;code&gt;onCompleted&lt;/code&gt; notification.</source>
          <target state="translated">&lt;code&gt;flatten&lt;/code&gt; toma como par&amp;aacute;metro un Observable que emite Observables. Fusiona los elementos emitidos por cada uno de estos Observables para crear su propia secuencia &amp;uacute;nica de Observables. Una variante de este operador le permite pasar un &lt;code&gt;Int&lt;/code&gt; que indica el n&amp;uacute;mero m&amp;aacute;ximo de estos Observables emitidos que desea &lt;code&gt;flatten&lt;/code&gt; para intentar suscribirse en cualquier momento. Se golpea esta suscripci&amp;oacute;n m&amp;aacute;xima recuento, se abstendr&amp;aacute; de suscribirse a cualquier otro observables emitidos por la fuente observable hasta que una de las una ya suscrito a cuestiones observables &lt;code&gt;onCompleted&lt;/code&gt; notificaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f490d9df4739ffcbdfd79e77f05c1a12ad66261d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flattenDelayError&lt;/code&gt; is similar to &lt;code&gt;flatten&lt;/code&gt; except that it will always emit all items from all of the emitted Observables even if one or more of those Observables terminates with an &lt;code&gt;onError&lt;/code&gt; notification before the other Observables have finished emitting items.</source>
          <target state="translated">&lt;code&gt;flattenDelayError&lt;/code&gt; es similar a &lt;code&gt;flatten&lt;/code&gt; excepto que siempre emitir&amp;aacute; todos los elementos de todos los Observables emitidos, incluso si uno o m&amp;aacute;s de esos Observables terminan con una notificaci&amp;oacute;n &lt;code&gt;onError&lt;/code&gt; antes de que los otros Observables hayan terminado de emitir elementos.</target>
        </trans-unit>
        <trans-unit id="a0c2292ff2aabdc802f42755a7f15ac367b4fbc0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forkJoin&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;forkJoin&lt;/code&gt; se encuentra en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="11e1a4342d8e23599b8291e0535a43c3e1c8b990" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;from&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, however you can pass the variant that converts a Future a Scheduler as an optional second parameter, and it will use that Scheduler to govern the Future.</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; no opera por defecto en ning&amp;uacute;n &lt;a href=&quot;../scheduler&quot;&gt;Programador en&lt;/a&gt; particular , sin embargo, puede pasar la variante que convierte un Futuro en un Programador como un segundo par&amp;aacute;metro opcional, y usar&amp;aacute; ese Programador para gobernar el Futuro.</target>
        </trans-unit>
        <trans-unit id="5df439cbc86cf0b9ba3bedfa57ed66e6100a4072" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;from&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; se encuentra en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="a65f1e48b7bb0d9d9d719896dcd792a4cfc83fec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fromCallback&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;fromCallback&lt;/code&gt; se encuentra en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="2a72db4b80dc8bad54f16580c97b432c8b2daadb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fromEvent&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;fromEvent&lt;/code&gt; se encuentra en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="07265cef8fee5d99da56092ca85c52c79f93584a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fromNodeCallback&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;fromNodeCallback&lt;/code&gt; se encuentra en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="6a2ed748a3852498d48388eaf367201f153d93fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fromPromise&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;fromPromise&lt;/code&gt; se encuentra en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="2c3520858faf7a23e64e6c3d2f6e3307fbd26f8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;generate&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;generate&lt;/code&gt; se encuentra en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="0afae411108bbc561cc1122700b256b35c45fbaa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;generateWithAbsoluteTime&lt;/code&gt; is found in the following distribution:</source>
          <target state="translated">&lt;code&gt;generateWithAbsoluteTime&lt;/code&gt; se encuentra en la siguiente distribuci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="52da1d549ee7151f9db69e4a561c0990d7a46355" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;generateWithRelativeTime&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;generateWithRelativeTime&lt;/code&gt; se encuentra en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="4a23135807c49156cdc8b6752177c1f0c084e2c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;groupBy&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;groupBy&lt;/code&gt; no opera por defecto en ning&amp;uacute;n &lt;a href=&quot;../scheduler&quot;&gt;Programador en&lt;/a&gt; particular .</target>
        </trans-unit>
        <trans-unit id="91ad833301d1835f103f1baa096fee152ae86986" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;groupBy&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;groupBy&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="0e3a79fda5beb1254249bb177d0da34e38313a3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;groupByUntil&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;groupByUntil&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="0893202a0ecab0d0f8ea3b772158225e7098703c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;groupJoin&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;groupJoin&lt;/code&gt; no opera por defecto en ning&amp;uacute;n &lt;a href=&quot;../scheduler&quot;&gt;Programador en&lt;/a&gt; particular .</target>
        </trans-unit>
        <trans-unit id="d4f5d0735a424248247ad9aae5cc496d8ece526a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; se encuentra en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="477fd73d586b9fcbec825cd0ec0de785a84f39a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ignoreElements&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ignoreElements&lt;/code&gt; no opera por defecto en ning&amp;uacute;n &lt;a href=&quot;../scheduler&quot;&gt;Programador en&lt;/a&gt; particular .</target>
        </trans-unit>
        <trans-unit id="69048ec3ceda893dbaff054dda9cc09355fcca6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ignoreElements&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;ignoreElements&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="faf6f3923e8284b46d6b215d9e7373efbab268c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;indexOf&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;indexOf&lt;/code&gt; se encuentra en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="fccd0f02c09cee4ec7aa4d5fa8f66c339d4d6f8d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;interleave*&lt;/code&gt; is similar but operates on an Observable of Observables.</source>
          <target state="translated">&lt;code&gt;interleave*&lt;/code&gt; es similar pero opera en un Observable of Observables.</target>
        </trans-unit>
        <trans-unit id="7b50914802b5744bb9a29e53495e66d8ae29742e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;interleave&lt;/code&gt; is like &lt;code&gt;merge&lt;/code&gt;, but more deliberate about how it interleaves the items from the source Observables: the resulting Observable emits the first item emitted by the first source Observable, then the first item emitted by the second source Observable, and so forth, and having reached the last source Observable, then emits the second item emitted by the first source Observable, the second item emitted by the second source Observable, and so forth, until all of the source Observables terminate.</source>
          <target state="translated">&lt;code&gt;interleave&lt;/code&gt; es como &lt;code&gt;merge&lt;/code&gt; , pero m&amp;aacute;s deliberado acerca de c&amp;oacute;mo intercalar los elementos de la fuente Observables: el Observable resultante emite el primer elemento emitido por la primera fuente Observable, luego el primer elemento emitido por la segunda fuente Observable, y as&amp;iacute; sucesivamente, y teniendo alcanz&amp;oacute; la &amp;uacute;ltima fuente Observable, luego emite el segundo elemento emitido por la primera fuente Observable, el segundo elemento emitido por la segunda fuente Observable, y as&amp;iacute; sucesivamente, hasta que todos los Observables de fuente terminen.</target>
        </trans-unit>
        <trans-unit id="7264e5224d0efb5bbea1588870c9d1c16097664b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;interval&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;interval&lt;/code&gt; se encuentra en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="0f6fbc36a92a3bb6ea90875470f4264e24b6511f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;interval&lt;/code&gt; operates by default on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;. There are also variants that allow you to set the Scheduler by passing one in as a parameter.</source>
          <target state="translated">&lt;code&gt;interval&lt;/code&gt; funciona de forma predeterminada en el &lt;a href=&quot;../scheduler&quot;&gt;programador de &lt;/a&gt; &lt;code&gt;computation&lt;/code&gt; . Tambi&amp;eacute;n hay variantes que le permiten configurar el Programador pasando uno como par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="d4788908a9674cee42b2359c4082011fd9d64a96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;interval&lt;/code&gt; operates by default on the &lt;code&gt;timeout&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, or you can optionally pass in a different Scheduler as a second parameter, and &lt;code&gt;interval&lt;/code&gt; will operate on that Scheduler instead.</source>
          <target state="translated">&lt;code&gt;interval&lt;/code&gt; funciona de forma predeterminada en el &lt;a href=&quot;../scheduler&quot;&gt;Programador de &lt;/a&gt; &lt;code&gt;timeout&lt;/code&gt; , o puede pasar opcionalmente un Programador diferente como segundo par&amp;aacute;metro, y el &lt;code&gt;interval&lt;/code&gt; o funcionar&amp;aacute; en ese Programador en su lugar.</target>
        </trans-unit>
        <trans-unit id="45aed2147ce95798c6a80412108c06c33d406eaf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isEmpty&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;isEmpty&lt;/code&gt; se encuentra en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="396a69205a9eb0971c9c7f55db588708f79c4271" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;join&lt;/code&gt; and &lt;code&gt;groupJoin&lt;/code&gt; are found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;join&lt;/code&gt; y &lt;code&gt;groupJoin&lt;/code&gt; se encuentran en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="0266ff7e3c64a16c14367e7d9c449c8da592883a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;join&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;join&lt;/code&gt; no funciona de forma predeterminada en ning&amp;uacute;n &lt;a href=&quot;../scheduler&quot;&gt;programador en&lt;/a&gt; particular .</target>
        </trans-unit>
        <trans-unit id="1a69e5a2478476a9c491318f02a1ebcb2c00072d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jortSort&lt;/code&gt; and &lt;code&gt;jortSortUntil&lt;/code&gt; are found in the following distribution:</source>
          <target state="translated">&lt;code&gt;jortSort&lt;/code&gt; y &lt;code&gt;jortSortUntil&lt;/code&gt; se encuentran en la siguiente distribuci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="5a9b0c411484d69c52e4c13d11908433ad2a8d35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;just&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;just&lt;/code&gt; no opera por defecto en ning&amp;uacute;n &lt;a href=&quot;../scheduler&quot;&gt;Programador en&lt;/a&gt; particular .</target>
        </trans-unit>
        <trans-unit id="34d74f67c03c213281eab1d7970a0f0aa9fb5f47" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;last&lt;/code&gt; and &lt;code&gt;lastOrDefault&lt;/code&gt; do not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;last&lt;/code&gt; y &lt;code&gt;lastOrDefault&lt;/code&gt; no operan por defecto en ning&amp;uacute;n &lt;a href=&quot;../scheduler&quot;&gt;Programador en&lt;/a&gt; particular .</target>
        </trans-unit>
        <trans-unit id="4a533c3a569a685efc0f2ff08c697bf6945290e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;last&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;last&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="a7a36090f51769beb59adcc22b7e8c1ea2e87040" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lastOrDefault&lt;/code&gt; also has a variant to which you can pass a predicate function, so that its Observable will emit the last item from the source Observable that the predicate evaluates as &lt;code&gt;true&lt;/code&gt;, or the default item if no items emitted by the source Observable pass the predicate.</source>
          <target state="translated">&lt;code&gt;lastOrDefault&lt;/code&gt; tambi&amp;eacute;n tiene una variante a la que puede pasar una funci&amp;oacute;n de predicado, de modo que su Observable emitir&amp;aacute; el &amp;uacute;ltimo elemento de la fuente Observable que el predicado eval&amp;uacute;a como &lt;code&gt;true&lt;/code&gt; , o el elemento predeterminado si ning&amp;uacute;n elemento emitido por la fuente Observable pasa el predicado.</target>
        </trans-unit>
        <trans-unit id="7aacfc7731f6c17a90c6eb8a8408b8626b6b4c65" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;manySelect&lt;/code&gt; internally transforms each item emitted by the source Observable into an Observable that emits that item and all items subsequently emitted by the source Observable, in the same order. So, for example, it internally transforms an Observable that emits the numbers 1,2,3 into three Observables: one that emits 1,2,3, one that emits 2,3, and one that emits 3.</source>
          <target state="translated">&lt;code&gt;manySelect&lt;/code&gt; transforma internamente cada elemento emitido por la fuente Observable en un Observable que emite ese elemento y todos los elementos posteriormente emitidos por la fuente Observable, en el mismo orden. Entonces, por ejemplo, transforma internamente un Observable que emite los n&amp;uacute;meros 1,2,3 en tres Observables: uno que emite 1,2,3, uno que emite 2,3 y uno que emite 3.</target>
        </trans-unit>
        <trans-unit id="852bf5291fc644db30f6e600aef002fc5fd9aca1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;manySelect&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;manySelect&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="09057d142824186fbe022f1998c81ae84e72dcae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;manySelect&lt;/code&gt; requires one of the following distributions:</source>
          <target state="translated">&lt;code&gt;manySelect&lt;/code&gt; requiere una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="5e1e17116f83269cfcbfba129278c4ac51598937" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map&lt;/code&gt;/&lt;code&gt;select&lt;/code&gt; and &lt;code&gt;pluck&lt;/code&gt; are found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; / &lt;code&gt;select&lt;/code&gt; y &lt;code&gt;pluck&lt;/code&gt; se encuentran en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="c48520b92abdd1b6f13c2e1a944c18d0136643e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;materialize&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;materialize&lt;/code&gt; no opera por defecto en ning&amp;uacute;n &lt;a href=&quot;../scheduler&quot;&gt;Programador en&lt;/a&gt; particular .</target>
        </trans-unit>
        <trans-unit id="03109dd70ccd2d5f3ce0b4ab597c88f2b1775f8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max&lt;/code&gt; and &lt;code&gt;maxBy&lt;/code&gt; are found in the following distributions:</source>
          <target state="translated">&lt;code&gt;max&lt;/code&gt; y &lt;code&gt;maxBy&lt;/code&gt; se encuentran en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="177fec1f130af6e4eaca7a4228a28a204b1d0476" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maxBy&lt;/code&gt; emits a list. If more than one item has the maximum key value, each such item will be represented in the list.</source>
          <target state="translated">&lt;code&gt;maxBy&lt;/code&gt; emite una lista. Si m&amp;aacute;s de un elemento tiene el valor de clave m&amp;aacute;ximo, cada uno de esos elementos se representar&amp;aacute; en la lista.</target>
        </trans-unit>
        <trans-unit id="027592fb8ecb9365d5e058e59e73870c0dd9b14f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge*&lt;/code&gt; converts an Observable that emits Observables into a single Observable that emits all of the items emitted by all of the emitted Observables.</source>
          <target state="translated">&lt;code&gt;merge*&lt;/code&gt; convierte un Observable que emite Observables en un Observable &amp;uacute;nico que emite todos los elementos emitidos por todos los Observables emitidos.</target>
        </trans-unit>
        <trans-unit id="d15ed57f77ad2ac1e3613ef0567150f3e1436e28" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge-delay-error*&lt;/code&gt; is a similarly-modified version of &lt;code&gt;merge*&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;merge-delay-error*&lt;/code&gt; es una versi&amp;oacute;n modificada de manera similar de &lt;code&gt;merge*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e67f6049e6dc049459c7c289d724002ca5233350" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge-delay-error&lt;/code&gt; is like &lt;code&gt;merge&lt;/code&gt;, but will emit all items from all of the merged Observables even if one or more of those Observables terminates with an &lt;code&gt;onError&lt;/code&gt; notification while emissions are still pending.</source>
          <target state="translated">&lt;code&gt;merge-delay-error&lt;/code&gt; es como &lt;code&gt;merge&lt;/code&gt; , pero emitir&amp;aacute; todos los elementos de todos los Observables fusionados incluso si uno o m&amp;aacute;s de esos Observables terminan con una notificaci&amp;oacute;n de &lt;code&gt;onError&lt;/code&gt; mientras las emisiones a&amp;uacute;n est&amp;aacute;n pendientes.</target>
        </trans-unit>
        <trans-unit id="ee7977d5c910e7ed3bb342e6e05eb0de4027e714" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge&lt;/code&gt; converts two or more Observables into a single Observable that emits all of the items emitted by all of those Observables.</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; convierte dos o m&amp;aacute;s Observables en un solo Observable que emite todos los elementos emitidos por todos esos Observables.</target>
        </trans-unit>
        <trans-unit id="9b76e9c0a1d27549afef80505e42f88c49ea336f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge&lt;/code&gt; merges a second Observable into the one it is operating on to create a new merged Observable.</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; fusiona un segundo Observable en el que est&amp;aacute; operando para crear un nuevo Observable combinado.</target>
        </trans-unit>
        <trans-unit id="d6eb56447889e6eff2f5548660c3d51a27016c77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge&lt;/code&gt; takes a second Observable as a parameter and merges that Observable with the one the &lt;code&gt;merge&lt;/code&gt; operator is applied to in order to create a new output Observable.</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; toma un segundo Observable como par&amp;aacute;metro y fusiona ese Observable con el que se aplica el operador de &lt;code&gt;merge&lt;/code&gt; para crear una nueva salida Observable.</target>
        </trans-unit>
        <trans-unit id="614290ed812f3587868cc3180159ce55ec920f69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge&lt;/code&gt; takes as its parameter an Observable that emits Observables. It merges the items emitted by each of these Observables to create its own single Observable sequence.</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; toma como par&amp;aacute;metro un Observable que emite Observables. Fusiona los elementos emitidos por cada uno de estos Observables para crear su propia secuencia &amp;uacute;nica de Observables.</target>
        </trans-unit>
        <trans-unit id="bf87e244577c5c553ce2ac58ddee944690c8ba13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mergeAll&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;mergeAll&lt;/code&gt; se encuentra en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="0395844b120445f674db48bf21d82e4cc405b67e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mergeAll&lt;/code&gt; is like this second variant of &lt;code&gt;merge&lt;/code&gt; except that it does not allow you to set this maximum subscription count. It only takes the single parameter of an Observable of Observables.</source>
          <target state="translated">&lt;code&gt;mergeAll&lt;/code&gt; es como esta segunda variante de &lt;code&gt;merge&lt;/code&gt; excepto que no le permite establecer este recuento m&amp;aacute;ximo de suscripciones. Solo toma el par&amp;aacute;metro &amp;uacute;nico de un Observable of Observables.</target>
        </trans-unit>
        <trans-unit id="e97640809c79f9e4649a2564f86200103b701783" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mergeDelayError&lt;/code&gt; behaves much like &lt;code&gt;merge&lt;/code&gt;. The exception is when one of the Observables being merged terminates with an &lt;code&gt;onError&lt;/code&gt; notification. If this happens with &lt;code&gt;merge&lt;/code&gt;, the merged Observable will immediately issue an &lt;code&gt;onError&lt;/code&gt; notification and terminate. &lt;code&gt;mergeDelayError&lt;/code&gt;, on the other hand, will hold off on reporting the error until it has given any other non-error-producing Observables that it is merging a chance to finish emitting their items, and it will emit those itself, and will only terminate with an &lt;code&gt;onError&lt;/code&gt; notification when all of the other merged Observables have finished.</source>
          <target state="translated">&lt;code&gt;mergeDelayError&lt;/code&gt; se comporta de forma muy similar a &lt;code&gt;merge&lt;/code&gt; . La excepci&amp;oacute;n es cuando uno de los Observables que se fusionan termina con una notificaci&amp;oacute;n de &lt;code&gt;onError&lt;/code&gt; . Si esto sucede con la &lt;code&gt;merge&lt;/code&gt; , el Observable fusionado emitir&amp;aacute; inmediatamente una notificaci&amp;oacute;n de &lt;code&gt;onError&lt;/code&gt; y finalizar&amp;aacute;. &lt;code&gt;mergeDelayError&lt;/code&gt; , por otro lado, retrasar&amp;aacute; la notificaci&amp;oacute;n del error hasta que le haya dado a cualquier otro Observable que no produzca errores que est&amp;eacute; fusionando la oportunidad de terminar de emitir sus elementos, y los emitir&amp;aacute; &amp;eacute;l mismo, y solo terminar&amp;aacute; con una notificaci&amp;oacute;n &lt;code&gt;onError&lt;/code&gt; cuando todos los dem&amp;aacute;s Observables fusionados hayan terminado.</target>
        </trans-unit>
        <trans-unit id="a167493a245b87e171e08f6f02fdf1ad8bc9e2ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mergeDelayError&lt;/code&gt; has fewer variants. You cannot pass it an Iterable or Array of Observables, but you can pass it an Observable that emits Observables or between one and nine individual Observables as parameters. There is not an instance method version of &lt;code&gt;mergeDelayError&lt;/code&gt; as there is for &lt;code&gt;merge&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mergeDelayError&lt;/code&gt; tiene menos variantes. No puede pasarle un Iterable o Array of Observables, pero puede pasarle un Observable que emite Observables o entre uno y nueve Observables individuales como par&amp;aacute;metros. No hay una versi&amp;oacute;n de m&amp;eacute;todo de instancia de &lt;code&gt;mergeDelayError&lt;/code&gt; como existe para &lt;code&gt;merge&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0cfd0dcaa2b00079a42cbbc16dfd8134a7228f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mergeDelayError&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;mergeDelayError&lt;/code&gt; se encuentra en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="5df4328bd8b1f65ea0f113efcd6669bdfaa33239" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mergeDelayError&lt;/code&gt; is similar to &lt;code&gt;merge&lt;/code&gt; except that it will always emit all items from both Observables even if one of the Observables terminates with an &lt;code&gt;onError&lt;/code&gt; notification before the other Observable has finished emitting items.</source>
          <target state="translated">&lt;code&gt;mergeDelayError&lt;/code&gt; es similar a &lt;code&gt;merge&lt;/code&gt; excepto que siempre emitir&amp;aacute; todos los elementos de ambos Observables, incluso si uno de los Observables termina con una notificaci&amp;oacute;n &lt;code&gt;onError&lt;/code&gt; antes de que el otro Observable haya terminado de emitir elementos.</target>
        </trans-unit>
        <trans-unit id="b82f40498bf692a5a78433f62179f34c2ce3ab0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge_all&lt;/code&gt; and its alias &lt;code&gt;merge_observable&lt;/code&gt; take as their single parameter an Observable that emits Observables. They merge the emissions of all of these Observables to create their own Observable.</source>
          <target state="translated">&lt;code&gt;merge_all&lt;/code&gt; y su alias &lt;code&gt;merge_observable&lt;/code&gt; toman como su &amp;uacute;nico par&amp;aacute;metro un Observable que emite Observables. Fusionan las emisiones de todos estos Observables para crear su propio Observable.</target>
        </trans-unit>
        <trans-unit id="bf6c5d2e202b7b40759b72a1934f54b5e9a83c2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge_all&lt;/code&gt; is like &lt;code&gt;merge_concurrent(1)&lt;/code&gt;. It subscribes to each emitted Observable one at a time, mirroring its emissions as its own, and waiting to subscribe to the next Observable until the present one terminates with an &lt;code&gt;onCompleted&lt;/code&gt; notification. In this respect it is more like a Concat variant.</source>
          <target state="translated">&lt;code&gt;merge_all&lt;/code&gt; es como &lt;code&gt;merge_concurrent(1)&lt;/code&gt; . Se suscribe a cada Observable emitido de uno en uno, reflejando sus emisiones como propias y esperando suscribirse al siguiente Observable hasta que el actual termine con una notificaci&amp;oacute;n &lt;code&gt;onCompleted&lt;/code&gt; . En este sentido, se parece m&amp;aacute;s a una variante de Concat.</target>
        </trans-unit>
        <trans-unit id="b9b205f7b96cb7796621bb13f277b683df3a9c0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge_concurrent&lt;/code&gt; operates on an Observable that emits Observables, merging the emissions from each of these Observables into its own emissions. You can optionally pass it an integer parameter indicating how many of these emitted Observables &lt;code&gt;merge_concurrent&lt;/code&gt; should try to subscribe to concurrently. Once it reaches this maximum subscription count, it will refrain from subscribing to any other Observables emitted by the source Observable until such time as one of the already-subscribed-to Observables issues an &lt;code&gt;onCompleted&lt;/code&gt; notification. The default is 1, which makes it equivalent to &lt;code&gt;merge_all&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;merge_concurrent&lt;/code&gt; opera en un Observable que emite Observables, fusionando las emisiones de cada uno de estos Observables en sus propias emisiones. Opcionalmente, puede pasarle un par&amp;aacute;metro entero que indique a cu&amp;aacute;ntos de estos Observables emitidos &lt;code&gt;merge_concurrent&lt;/code&gt; deber&amp;iacute;a intentar suscribirse al mismo tiempo. Una vez que se alcanza este n&amp;uacute;mero m&amp;aacute;ximo de suscripci&amp;oacute;n, se abstendr&amp;aacute; de suscribirse a cualquier otro observables emitidos por la fuente observable hasta que una de las una ya suscrito a cuestiones observables &lt;code&gt;onCompleted&lt;/code&gt; notificaci&amp;oacute;n. El valor predeterminado es 1, lo que lo hace equivalente a &lt;code&gt;merge_all&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd6a4567c47afea1f9ff91a96e2a66d903320fb7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;min&lt;/code&gt; and &lt;code&gt;minBy&lt;/code&gt; are found in the following distributions:</source>
          <target state="translated">&lt;code&gt;min&lt;/code&gt; y &lt;code&gt;minBy&lt;/code&gt; se encuentran en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="fe33d78b21d502ce077f3e6214cf1f1e0a7a2b32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minBy&lt;/code&gt; emits a list. If more than one item has the minimum key value, each such item will be represented in the list.</source>
          <target state="translated">&lt;code&gt;minBy&lt;/code&gt; emite una lista. Si m&amp;aacute;s de un elemento tiene el valor de clave m&amp;iacute;nimo, cada uno de esos elementos se representar&amp;aacute; en la lista.</target>
        </trans-unit>
        <trans-unit id="7f478b05a123aaaa05e677793d3fd97a7fc5e6e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;never&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; se encuentra en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="1d1866924109e9670646683e6e6766eb97e7a636" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;observeOn&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;observeOn&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="14dc5b4b8485471c8c4af3ad8e073920b5b1958d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;of&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;of&lt;/code&gt; se encuentra en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="79a718b7958aac2f3f301ac09717b03f007e843a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ofType&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ofType&lt;/code&gt; no opera por defecto en ning&amp;uacute;n &lt;a href=&quot;../scheduler&quot;&gt;Programador en&lt;/a&gt; particular .</target>
        </trans-unit>
        <trans-unit id="897f67f71a1a6044cc793578bc84958ce3a7edc0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onBackpressureBuffer&lt;/code&gt; maintains a buffer of all unobserved emissions from the source Observable and emits them to downstream observers according to the requests they generate.</source>
          <target state="translated">&lt;code&gt;onBackpressureBuffer&lt;/code&gt; mantiene un b&amp;uacute;fer de todas las emisiones no observadas de la fuente Observable y las emite a los observadores posteriores de acuerdo con las solicitudes que generan.</target>
        </trans-unit>
        <trans-unit id="cae0fdf6c6ae888dae1f1dca903ede5835c8e193" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onBackpressureDrop&lt;/code&gt; drops emissions from the source Observable unless there is a pending request from a downstream observer, in which case it will emit enough items to fulfill the request.</source>
          <target state="translated">&lt;code&gt;onBackpressureDrop&lt;/code&gt; reduce las emisiones de la fuente Observable a menos que haya una solicitud pendiente de un observador aguas abajo, en cuyo caso emitir&amp;aacute; elementos suficientes para cumplir con la solicitud.</target>
        </trans-unit>
        <trans-unit id="8dad14f2756c6a7c1c084ae4a7d8630d2936a429" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onBackpressureLatest&lt;/code&gt; (new in RxJava 1.1) holds on to the most-recently emitted item from the source Observable and immediately emits that item to its observer upon request. It drops any other items that it observes between requests from its observer.</source>
          <target state="translated">&lt;code&gt;onBackpressureLatest&lt;/code&gt; (nuevo en RxJava 1.1) retiene el elemento emitido m&amp;aacute;s recientemente desde la fuente Observable e inmediatamente emite ese elemento a su observador cuando lo solicita. Descarta cualquier otro elemento que observe entre las solicitudes de su observador.</target>
        </trans-unit>
        <trans-unit id="dcb4b05219c46f2a0b6b1c9f6f952ca7e8293a54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onErrorFlatMap&lt;/code&gt; handles a special case: a source Observable that is noncompliant with &lt;a href=&quot;../contract&quot;&gt;the Observable contract&lt;/a&gt; in such a way that it may interleave &lt;code&gt;onError&lt;/code&gt; notifications with its emissions without terminating. This operator allows you to replace those &lt;code&gt;onError&lt;/code&gt; notifications with the emissions of an Observable of your choosing without unsubscribing from the source, so that any future items emitted from the source will be passed along to observers as though the sequence had not been interrupted with an &lt;code&gt;onError&lt;/code&gt; notification.</source>
          <target state="translated">&lt;code&gt;onErrorFlatMap&lt;/code&gt; maneja un caso especial: una fuente Observable que no cumple con &lt;a href=&quot;../contract&quot;&gt;el contrato Observable&lt;/a&gt; de tal manera que puede intercalar notificaciones &lt;code&gt;onError&lt;/code&gt; con sus emisiones sin terminar. Este operador le permite reemplazar esas notificaciones de &lt;code&gt;onError&lt;/code&gt; con las emisiones de un Observable de su elecci&amp;oacute;n sin darse de baja de la fuente, de modo que cualquier elemento futuro emitido desde la fuente se pasar&amp;aacute; a los observadores como si la secuencia no se hubiera interrumpido con un &lt;code&gt;onError&lt;/code&gt; notificaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="2b872759b6ef289a58cf969ce8164979b4a51e72" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onErrorResumeNext&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;onErrorResumeNext&lt;/code&gt; se encuentra en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="95ce8ec757b038f51c2a32661634197b973e09f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onNext&lt;/code&gt; and &lt;code&gt;onError&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;onNext&lt;/code&gt; y &lt;code&gt;onError&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd7ec9d67ac28a19f77f9e07b0ebd85713ac02e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onNext&lt;/code&gt;, &lt;code&gt;onError&lt;/code&gt;, and &lt;code&gt;onCompleted&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;onNext&lt;/code&gt; , &lt;code&gt;onError&lt;/code&gt; y &lt;code&gt;onCompleted&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9e4196398c53c4e2d07989c689f8952690797af5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pairs&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;pairs&lt;/code&gt; se encuentra en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="3c770e3f67c8bd25718da8165ccdb6ade967737f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;partition-all&lt;/code&gt; opens its first window immediately. It opens a new window beginning with every &lt;code&gt;step&lt;/code&gt; item from the source Observable (so, for example, if &lt;code&gt;step&lt;/code&gt; is 3, then it opens a new window starting with every third item). It closes each window when that window has emitted &lt;code&gt;n&lt;/code&gt; items or if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. If &lt;code&gt;step&amp;nbsp;=&amp;nbsp;n&lt;/code&gt; (which is the default if you omit the &lt;code&gt;step&lt;/code&gt; parameter) then the window size is the same as the step size and there will be a one-to-one correspondence between the items emitted by the source Observable and the items emitted by the collection of window Observables. If &lt;code&gt;step&amp;nbsp;&amp;lt;&amp;nbsp;n&lt;/code&gt; the windows will overlap by &lt;code&gt;n&amp;nbsp;&amp;minus;&amp;nbsp;step&lt;/code&gt; items; if &lt;code&gt;step&amp;nbsp;&amp;gt;&amp;nbsp;n&lt;/code&gt; the windows will drop &lt;code&gt;step&amp;nbsp;&amp;minus;&amp;nbsp;n&lt;/code&gt; items from the source Observable between every window.</source>
          <target state="translated">&lt;code&gt;partition-all&lt;/code&gt; abre su primera ventana inmediatamente. Abre una nueva ventana que comienza con cada elemento de &lt;code&gt;step&lt;/code&gt; de la fuente Observable (por ejemplo, si el &lt;code&gt;step&lt;/code&gt; es 3, entonces abre una nueva ventana comenzando con cada tercer elemento). Cierra cada ventana cuando esa ventana ha emitido &lt;code&gt;n&lt;/code&gt; elementos o si recibe una notificaci&amp;oacute;n &lt;code&gt;onCompleted&lt;/code&gt; o &lt;code&gt;onError&lt;/code&gt; de la fuente Observable. Si &lt;code&gt;step&amp;nbsp;=&amp;nbsp;n&lt;/code&gt; (que es el valor predeterminado si omite el par&amp;aacute;metro de &lt;code&gt;step&lt;/code&gt; ), entonces el tama&amp;ntilde;o de la ventana es el mismo que el tama&amp;ntilde;o del paso y habr&amp;aacute; una correspondencia uno a uno entre los elementos emitidos por la fuente Observable y los elementos emitidos por la colecci&amp;oacute;n de ventana Observables. Si &lt;code&gt;step&amp;nbsp;&amp;lt;&amp;nbsp;n&lt;/code&gt; las ventanas se superpondr&amp;aacute;n con elementos de &lt;code&gt;n&amp;nbsp;&amp;minus;&amp;nbsp;step&lt;/code&gt; ; si &lt;code&gt;step&amp;nbsp;&amp;gt;&amp;nbsp;n&lt;/code&gt; las ventanas soltar&amp;aacute;n &lt;code&gt;step&amp;nbsp;&amp;minus;&amp;nbsp;n&lt;/code&gt; elementos de la fuente Observable entre cada ventana.</target>
        </trans-unit>
        <trans-unit id="f84833cea1699df3f9c2492c38f87c6af17d1f1c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;range&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but there is a variant that allows you to set the Scheduler by passing one in as a parameter.</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; no opera por defecto en ning&amp;uacute;n &lt;a href=&quot;../scheduler&quot;&gt;Programador en&lt;/a&gt; particular , pero existe una variante que le permite configurar el Programador pasando uno como par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="eafc670c3b2d8e5043fd46a8907dcc34eb1f5b13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;range&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="517b7b00820d459d58d54fad2526893d4209d655" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;range&lt;/code&gt; operates by default on the &lt;code&gt;currentThread&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but there is a variant that allows you to set the Scheduler by passing one in as the optional third parameter.</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; opera por defecto en el &lt;code&gt;currentThread&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; , pero hay una variante que le permite configurar el Scheduler pasando uno como tercer par&amp;aacute;metro opcional.</target>
        </trans-unit>
        <trans-unit id="a05f7cc6a3cc8526b6a38205df25a5634604f34d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reduce&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;reduce&lt;/code&gt; no opera por defecto en ning&amp;uacute;n &lt;a href=&quot;../scheduler&quot;&gt;Programador en&lt;/a&gt; particular .</target>
        </trans-unit>
        <trans-unit id="6d54f7eb381b9a648070132276d93e7ee0df8d0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reduce&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;reduce&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="657f9e448cd627b5f491b7783525a31edf1ce8b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reduce&lt;/code&gt; requires one of the following distributions:</source>
          <target state="translated">&lt;code&gt;reduce&lt;/code&gt; requiere una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="0129da905d929db4ea918fd5191306e7b396dbfb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refCount&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;refCount&lt;/code&gt; se encuentra en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="4d8010dd75a4a1c1c6ac0ecdc7cdf94b599657a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repeat&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;repeat&lt;/code&gt; se encuentra en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="0999f08cc9f2ca4d3eeb983282250b4bcab5e4a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repeat&lt;/code&gt; operates by default on the &lt;code&gt;trampoline&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;. There is also a variant that allows you to set the Scheduler by passing one in as a parameter.</source>
          <target state="translated">&lt;code&gt;repeat&lt;/code&gt; funciona por defecto en el &lt;a href=&quot;../scheduler&quot;&gt;programador de &lt;/a&gt; &lt;code&gt;trampoline&lt;/code&gt; . Tambi&amp;eacute;n hay una variante que le permite configurar el Programador pasando uno como par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="161c846b7dafa9a83956414dd4c228d2f2b26cde" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repeatWhen&lt;/code&gt; operates by default on the &lt;code&gt;trampoline&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;. There is also a variant that allows you to set the Scheduler by passing one in as a parameter.</source>
          <target state="translated">&lt;code&gt;repeatWhen&lt;/code&gt; funciona de forma predeterminada en el &lt;a href=&quot;../scheduler&quot;&gt;programador de &lt;/a&gt; &lt;code&gt;trampoline&lt;/code&gt; . Tambi&amp;eacute;n hay una variante que le permite configurar el Programador pasando uno como par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="89b5f2f16447f11ba64e3a948984ca696d80d8a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;replay&lt;/code&gt; and &lt;code&gt;shareReplay&lt;/code&gt; are found in the following distributions:</source>
          <target state="translated">&lt;code&gt;replay&lt;/code&gt; y &lt;code&gt;shareReplay&lt;/code&gt; se encuentran en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="c00fe8d32c6838f3365164673884bc9df59b8c18" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;retry&lt;/code&gt; by default operates on the &lt;code&gt;trampoline&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;retry&lt;/code&gt; por defecto opera en el &lt;a href=&quot;../scheduler&quot;&gt;programador de &lt;/a&gt; &lt;code&gt;trampoline&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76be19f4fc07a54681d48e171bccef56c65fb404" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;retry&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;retry&lt;/code&gt; se encuentra en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="6cd834c8bce0a7dab20890b38a2731341bb7b199" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;retry&lt;/code&gt; takes a single argument, a count of the number of times it should try resubscribing to the source Observable when it encounters errors. If this count is exceeded, &lt;code&gt;retry&lt;/code&gt; will not attempt to resubscribe and will instead pass the &lt;code&gt;onError&lt;/code&gt; notification to its observers.</source>
          <target state="translated">&lt;code&gt;retry&lt;/code&gt; toma un solo argumento, un recuento de la cantidad de veces que deber&amp;iacute;a intentar volver a suscribirse a la fuente Observable cuando encuentra errores. Si se excede este recuento, el &lt;code&gt;retry&lt;/code&gt; no intentar&amp;aacute; volver a suscribirse y, en su lugar, pasar&amp;aacute; la notificaci&amp;oacute;n &lt;code&gt;onError&lt;/code&gt; a sus observadores.</target>
        </trans-unit>
        <trans-unit id="46ac3633b230eaa4da4ae659b81b5fd1fd01a960" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;retry&lt;/code&gt; takes a single optional parameter, a count of the number of times it should try resubscribing to and mirroring the source Observable when it encounters errors. If this count is exceeded, &lt;code&gt;retry&lt;/code&gt; will not attempt to resubscribe and will instead pass the &lt;code&gt;onError&lt;/code&gt; notification to its observers.</source>
          <target state="translated">&lt;code&gt;retry&lt;/code&gt; toma un solo par&amp;aacute;metro opcional, un recuento de la cantidad de veces que deber&amp;iacute;a intentar volver a suscribirse y reflejar la fuente Observable cuando encuentra errores. Si se excede este recuento, el &lt;code&gt;retry&lt;/code&gt; no intentar&amp;aacute; volver a suscribirse y, en su lugar, pasar&amp;aacute; la notificaci&amp;oacute;n &lt;code&gt;onError&lt;/code&gt; a sus observadores.</target>
        </trans-unit>
        <trans-unit id="78968626021de35abce2defdd55ea6bc88f55708" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;retry&lt;/code&gt; takes a single optional parameter, a count of the number of times it should try resubscribing to and mirroring the source Observable when it encounters errors. If this count is exceeded, &lt;code&gt;retry&lt;/code&gt; will not attempt to resubscribe and will instead pass the &lt;code&gt;onError&lt;/code&gt; notification to its observers. If you omit this parameter, &lt;code&gt;retry&lt;/code&gt; will attempt to resubscribe and mirror indefinitely, no matter how many &lt;code&gt;onError&lt;/code&gt; notifications it receives.</source>
          <target state="translated">&lt;code&gt;retry&lt;/code&gt; toma un solo par&amp;aacute;metro opcional, un recuento de la cantidad de veces que deber&amp;iacute;a intentar volver a suscribirse y reflejar la fuente Observable cuando encuentra errores. Si se excede este recuento, el &lt;code&gt;retry&lt;/code&gt; no intentar&amp;aacute; volver a suscribirse y, en su lugar, pasar&amp;aacute; la notificaci&amp;oacute;n &lt;code&gt;onError&lt;/code&gt; a sus observadores. Si omite este par&amp;aacute;metro, &lt;code&gt;retry&lt;/code&gt; intentar&amp;aacute; volver a suscribirse y reflejar indefinidamente, sin importar cu&amp;aacute;ntas notificaciones &lt;code&gt;onError&lt;/code&gt; reciba.</target>
        </trans-unit>
        <trans-unit id="7e3bb930ea61541d82eaef3c327715478723458b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;retryInfinitely&lt;/code&gt;, on the other hand, will attempt to resubscribe to and mirror the source Observable indefinitely, no matter how many &lt;code&gt;onError&lt;/code&gt; notifications it receives.</source>
          <target state="translated">&lt;code&gt;retryInfinitely&lt;/code&gt; , por otro lado, intentar&amp;aacute; volver a suscribirse y reflejar la fuente Observable indefinidamente, sin importar cu&amp;aacute;ntas notificaciones &lt;code&gt;onError&lt;/code&gt; reciba.</target>
        </trans-unit>
        <trans-unit id="eaab55adc8c8a728f1f75c3bb1edfb90ef94d65c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;retryWhen&lt;/code&gt; by default operates on the &lt;code&gt;trampoline&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, and there is also a version that accepts a Scheduler as a parameter.</source>
          <target state="translated">&lt;code&gt;retryWhen&lt;/code&gt; por defecto opera en el &lt;code&gt;trampoline&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; , y tambi&amp;eacute;n hay una versi&amp;oacute;n que acepta un Scheduler como par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="4120f82ca0762ba3c67980e47fd96b3d4ff4e869" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return&lt;/code&gt;/&lt;code&gt;just&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; / &lt;code&gt;just&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="6865b6419ccb621e514ec4fb6db7f12fbeb36594" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return&lt;/code&gt;/&lt;code&gt;just&lt;/code&gt; operates by default on the &lt;code&gt;immediate&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you can also pass in a Scheduler of your choosing as an optional second parameter, in which case it will operate on that Scheduler instead.</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; / &lt;code&gt;just&lt;/code&gt; opera de forma predeterminada en el &lt;a href=&quot;../scheduler&quot;&gt;Programador &lt;/a&gt; &lt;code&gt;immediate&lt;/code&gt; , pero tambi&amp;eacute;n puede pasar un Programador de su elecci&amp;oacute;n como un segundo par&amp;aacute;metro opcional, en cuyo caso operar&amp;aacute; en ese Programador.</target>
        </trans-unit>
        <trans-unit id="7b4047a0ea36585603f6ec748627509f0b4a9855" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.async.compat.js&lt;/code&gt; (requires &lt;code&gt;rx.binding.js&lt;/code&gt; and either &lt;code&gt;rx.js&lt;/code&gt; or &lt;code&gt;rx.compat.js&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;rx.async.compat.js&lt;/code&gt; (requiere &lt;code&gt;rx.binding.js&lt;/code&gt; y &lt;code&gt;rx.js&lt;/code&gt; o &lt;code&gt;rx.compat.js&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="99d0dd6df299ad0b8c56978d03652785c9ad339a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.async.js&lt;/code&gt; (requires &lt;code&gt;rx.binding.js&lt;/code&gt; and either &lt;code&gt;rx.js&lt;/code&gt; or &lt;code&gt;rx.compat.js&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;rx.async.js&lt;/code&gt; (requiere &lt;code&gt;rx.binding.js&lt;/code&gt; y &lt;code&gt;rx.js&lt;/code&gt; o &lt;code&gt;rx.compat.js&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="39644825f66c15f5ee185ab93766411f09e927f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.binding.js&lt;/code&gt; (requires &lt;code&gt;rx.js&lt;/code&gt; or &lt;code&gt;rx.compat.js&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;rx.binding.js&lt;/code&gt; (requiere &lt;code&gt;rx.js&lt;/code&gt; o &lt;code&gt;rx.compat.js&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a93ed12dffc1802ecae7f2aae2ec6a8f70ebd5be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.binding.js&lt;/code&gt; (requires &lt;code&gt;rx.js&lt;/code&gt;, &lt;code&gt;rx.compat.js&lt;/code&gt;, &lt;code&gt;rx.lite.js&lt;/code&gt;, or &lt;code&gt;rx.lite.compat.js&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;rx.binding.js&lt;/code&gt; (requiere &lt;code&gt;rx.js&lt;/code&gt; , &lt;code&gt;rx.compat.js&lt;/code&gt; , &lt;code&gt;rx.lite.js&lt;/code&gt; o &lt;code&gt;rx.lite.compat.js&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="8b53d4d110e21e5825ad980e2a5e7cb13d935856" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.binding.js&lt;/code&gt; (requires either &lt;code&gt;rx.js&lt;/code&gt; or &lt;code&gt;rx.compat.js&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;rx.binding.js&lt;/code&gt; (requiere &lt;code&gt;rx.js&lt;/code&gt; o &lt;code&gt;rx.compat.js&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="be2cc3de70d097deb29bf9d0c5b850ca4930bbc1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.binding.js&lt;/code&gt; (requires either &lt;code&gt;rx.lite.js&lt;/code&gt; or &lt;code&gt;rx.compat.js&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;rx.binding.js&lt;/code&gt; (requiere &lt;code&gt;rx.lite.js&lt;/code&gt; o &lt;code&gt;rx.compat.js&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="2357fcc02566cafce52d99070b5f15ba04fcac3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.experimental.js&lt;/code&gt; (requires &lt;code&gt;rx.js&lt;/code&gt;, &lt;code&gt;rx.compat.js&lt;/code&gt;, &lt;code&gt;rx.lite.js&lt;/code&gt;, or &lt;code&gt;rx.lite.compat.js&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;rx.experimental.js&lt;/code&gt; (requiere &lt;code&gt;rx.js&lt;/code&gt; , &lt;code&gt;rx.compat.js&lt;/code&gt; , &lt;code&gt;rx.lite.js&lt;/code&gt; o &lt;code&gt;rx.lite.compat.js&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b80c6ea09cb52e61d700bbdb778801b2438d5986" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.experimental.js&lt;/code&gt; (requires either &lt;code&gt;rx.js&lt;/code&gt;, &lt;code&gt;rx.compat.js&lt;/code&gt;, &lt;code&gt;rx.lite.js&lt;/code&gt;, or &lt;code&gt;rx.lite.compat.js&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;rx.experimental.js&lt;/code&gt; (requiere &lt;code&gt;rx.js&lt;/code&gt; , &lt;code&gt;rx.compat.js&lt;/code&gt; , &lt;code&gt;rx.lite.js&lt;/code&gt; o &lt;code&gt;rx.lite.compat.js&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="6cc8c4efacdb08ca9c78c34c4d28e124e3430c88" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.time.js&lt;/code&gt; (requires &lt;code&gt;rx.js&lt;/code&gt; or &lt;code&gt;rx.compat.js&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;rx.time.js&lt;/code&gt; (requiere &lt;code&gt;rx.js&lt;/code&gt; o &lt;code&gt;rx.compat.js&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="9e6345f31b107cb0269a8802101482908e912220" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.time.js&lt;/code&gt; (requires either &lt;code&gt;rx.js&lt;/code&gt; or &lt;code&gt;rx.compat.js&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;rx.time.js&lt;/code&gt; (requiere &lt;code&gt;rx.js&lt;/code&gt; o &lt;code&gt;rx.compat.js&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="0a2f74b508eb1599da60aa8c859b12c78401a19f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.time.js&lt;/code&gt; requires &lt;code&gt;rx.js&lt;/code&gt; or &lt;code&gt;rx.compat.js&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;rx.time.js&lt;/code&gt; requiere &lt;code&gt;rx.js&lt;/code&gt; o &lt;code&gt;rx.compat.js&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="55ebf3cb3c682607b13423bb830edbe481a23fde" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.timejs&lt;/code&gt; (requires &lt;code&gt;rx.js&lt;/code&gt; or &lt;code&gt;rx.compat.js&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;rx.timejs&lt;/code&gt; (requiere &lt;code&gt;rx.js&lt;/code&gt; o &lt;code&gt;rx.compat.js&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="fc4cf9e648d81d20eae0105dc67ee6d7971f1afe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sample&lt;/code&gt; and &lt;code&gt;throttleFirst&lt;/code&gt; operate by default on the &lt;code&gt;timeout&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;. They are found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;sample&lt;/code&gt; y &lt;code&gt;throttleFirst&lt;/code&gt; funcionan de forma predeterminada en el &lt;a href=&quot;../scheduler&quot;&gt;programador de &lt;/a&gt; &lt;code&gt;timeout&lt;/code&gt; . Se encuentran en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="9642d89ad52f3aff730c9fe3b50d35f97e92dedf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scan&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;scan&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="becbe9059426bc4fdaba799ee68f66c3ae0ff3d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sequenceEqual&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;sequenceEqual&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="5d1811fd6d4b8cc5e673ff4d9dd6085e1bd30090" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sequenceEqual&lt;/code&gt; requires one of the following distributions:</source>
          <target state="translated">&lt;code&gt;sequenceEqual&lt;/code&gt; requiere una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="b8c4ac4b83afedf5680116e88c507a16fc48b2f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;share&lt;/code&gt; and &lt;code&gt;shareValue&lt;/code&gt; are found in the following distributions:</source>
          <target state="translated">&lt;code&gt;share&lt;/code&gt; y &lt;code&gt;shareValue&lt;/code&gt; se encuentran en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="a461966af16fa4245c4bf73e1a8c7b411d6636cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;single&lt;/code&gt; also has a version that accepts a predicate, and emits the sole item emitted by the source Observable that matches that predicate, or notifies of an exception if exactly one such item does not match.</source>
          <target state="translated">&lt;code&gt;single&lt;/code&gt; tambi&amp;eacute;n tiene una versi&amp;oacute;n que acepta un predicado y emite el &amp;uacute;nico elemento emitido por la fuente Observable que coincide con ese predicado, o notifica una excepci&amp;oacute;n si exactamente uno de esos elementos no coincide.</target>
        </trans-unit>
        <trans-unit id="bb3c85771d4d9bde7a35c9a62319373f3d8d96cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;single&lt;/code&gt; also has a version that accepts a predicate, and returns the sole item emitted by the source Observable that matches that predicate, or throws an exception if exactly one such item does not match.</source>
          <target state="translated">&lt;code&gt;single&lt;/code&gt; tambi&amp;eacute;n tiene una versi&amp;oacute;n que acepta un predicado y devuelve el &amp;uacute;nico elemento emitido por el Observable de origen que coincide con ese predicado, o lanza una excepci&amp;oacute;n si exactamente uno de esos elementos no coincide.</target>
        </trans-unit>
        <trans-unit id="d6b89edd7f0936e1694c251ce2e83ac36b9534cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;skip&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;skip&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="7842b740b14a1bb4f092eb32d23be6838b6de48c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;skipLast&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;skipLast&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="fd24cf6d6309824f9efd2307264bd0c82d87abd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;skipLastWithTime&lt;/code&gt; by default operates on the &lt;code&gt;timeout&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you may also pass in a Scheduler of your choosing as an optional second parameter.</source>
          <target state="translated">&lt;code&gt;skipLastWithTime&lt;/code&gt; por defecto opera en el &lt;a href=&quot;../scheduler&quot;&gt;Programador de &lt;/a&gt; &lt;code&gt;timeout&lt;/code&gt; , pero tambi&amp;eacute;n puede pasar un Programador de su elecci&amp;oacute;n como un segundo par&amp;aacute;metro opcional.</target>
        </trans-unit>
        <trans-unit id="1b0ea964517cee199a2e9698d0f8b9b282d1a2d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;skipLastWithTime&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;skipLastWithTime&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="f855d9577dee628df260ad5b16cd6e2f479e252e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;skipUntil&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;skipUntil&lt;/code&gt; no opera por defecto en ning&amp;uacute;n &lt;a href=&quot;../scheduler&quot;&gt;Programador en&lt;/a&gt; particular .</target>
        </trans-unit>
        <trans-unit id="0efb342bef695a8ba90ab5c3a186c1d1e80d96db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;skipUntil&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;skipUntil&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="0054a1a7c41a519ebdff4961eb2a9c6387f209df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;skipUntilWithTime&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;skipUntilWithTime&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="aedae37e764a8cae3228eb19bf3866cfec747304" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;skipWhile&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;skipWhile&lt;/code&gt; no funciona de forma predeterminada en ning&amp;uacute;n &lt;a href=&quot;../scheduler&quot;&gt;programador en&lt;/a&gt; particular .</target>
        </trans-unit>
        <trans-unit id="3d271030a25e4748daf89de63d1f23c0bf647fd9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;skipWhile&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;skipWhile&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="59d8fb08b646ff0db07c057e6b35171eb8becd51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sliding(timespan,timeshift,count&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sliding(timespan,timeshift,count&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4d6b6f01fe681143dafffd2ce2f286570c01a2fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sliding(timespan,timeshift&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sliding(timespan,timeshift&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="340607a150f05545c373687c169c0693f97e838b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;slidingBuffer(count, skip)&lt;/code&gt; creates a new buffer starting with the first emitted item from the source Observable, and every &lt;code&gt;skip&lt;/code&gt; items thereafter, and fills each buffer with &lt;code&gt;count&lt;/code&gt; items: the initial item and &lt;code&gt;count-1&lt;/code&gt; subsequent ones. It emits these buffers as &lt;code&gt;Seq&lt;/code&gt;s. Depending on the values of &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;skip&lt;/code&gt; these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).</source>
          <target state="translated">&lt;code&gt;slidingBuffer(count, skip)&lt;/code&gt; crea un nuevo b&amp;uacute;fer comenzando con el primer elemento emitido desde el origen Observable, y todos los elementos &lt;code&gt;skip&lt;/code&gt; partir de entonces, y llena cada b&amp;uacute;fer con elementos de &lt;code&gt;count&lt;/code&gt; : el elemento inicial y los siguientes &lt;code&gt;count-1&lt;/code&gt; . Emite estos b&amp;uacute;feres como &lt;code&gt;Seq&lt;/code&gt; s. Dependiendo de los valores de &lt;code&gt;count&lt;/code&gt; y &lt;code&gt;skip&lt;/code&gt; , estos b&amp;uacute;feres pueden superponerse (varios b&amp;uacute;feres pueden contener el mismo elemento), o pueden tener espacios (donde los elementos emitidos por el Observable de origen no est&amp;aacute;n representados en ning&amp;uacute;n b&amp;uacute;fer).</target>
        </trans-unit>
        <trans-unit id="e800efd9702220c22509e95b689d97ed23b2e491" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;slidingBuffer(openings,closings)&lt;/code&gt; monitors the &lt;code&gt;openings&lt;/code&gt; Observable, and, whenever it emits an &lt;code&gt;Opening&lt;/code&gt; item, &lt;code&gt;slidingBuffer&lt;/code&gt; creates a new &lt;code&gt;Seq&lt;/code&gt;, begins to collect items subsequently emitted by the source Observable into this buffer, and calls &lt;code&gt;closings&lt;/code&gt; to get a new Observable to govern the closing of that buffer. When this new Observable emits an item or terminates, &lt;code&gt;slidingBuffer&lt;/code&gt; closes and emits the &lt;code&gt;Seq&lt;/code&gt;that the Observable governs.</source>
          <target state="translated">&lt;code&gt;slidingBuffer(openings,closings)&lt;/code&gt; monitorea las &lt;code&gt;openings&lt;/code&gt; Observable y, siempre que emite un elemento de &lt;code&gt;Opening&lt;/code&gt; , &lt;code&gt;slidingBuffer&lt;/code&gt; crea una nueva &lt;code&gt;Seq&lt;/code&gt; , comienza a recopilar elementos posteriormente emitidos por la fuente Observable en este b&amp;uacute;fer, y llama a los &lt;code&gt;closings&lt;/code&gt; para obtener un nuevo Observable para gobernar el cierre de ese b&amp;uacute;fer. Cuando este nuevo Observable emite un elemento o termina, &lt;code&gt;slidingBuffer&lt;/code&gt; cierra y emite la &lt;code&gt;Seq&lt;/code&gt; que gobierna el Observable.</target>
        </trans-unit>
        <trans-unit id="3a2d8b32d98cd2d85f509ed919d5b6fe0c839176" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;slidingBuffer(timespan, timeshift)&lt;/code&gt; creates a new &lt;code&gt;Seq&lt;/code&gt; of items every &lt;code&gt;timeshift&lt;/code&gt; (a &lt;code&gt;Duration&lt;/code&gt;), and fills this buffer with every item emitted by the source Observable from that time until &lt;code&gt;timespan&lt;/code&gt; (also a &lt;code&gt;Duration&lt;/code&gt;) has passed since the buffer&amp;rsquo;s creation, before emitting this &lt;code&gt;Seq&lt;/code&gt; as its own emission. If &lt;code&gt;timespan&lt;/code&gt; is longer than &lt;code&gt;timeshift&lt;/code&gt;, the emitted arrays will represent time periods that overlap and so they may contain duplicate items. There is also a version of this variant of the operator that takes a &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan.</source>
          <target state="translated">&lt;code&gt;slidingBuffer(timespan, timeshift)&lt;/code&gt; crea un nuevo &lt;code&gt;Seq&lt;/code&gt; de art&amp;iacute;culos cada &lt;code&gt;timeshift&lt;/code&gt; (una &lt;code&gt;Duration&lt;/code&gt; ), y llena este b&amp;uacute;fer con cada art&amp;iacute;culo emitida por la fuente observable desde ese momento hasta &lt;code&gt;timespan&lt;/code&gt; (tambi&amp;eacute;n un &lt;code&gt;Duration&lt;/code&gt; ) ha pasado desde la creaci&amp;oacute;n de la memoria intermedia, antes de emitir esta &lt;code&gt;Seq&lt;/code&gt; como su propia emisi&amp;oacute;n. Si el &lt;code&gt;timespan&lt;/code&gt; es m&amp;aacute;s largo que el &lt;code&gt;timeshift&lt;/code&gt; temporal, las matrices emitidas representar&amp;aacute;n per&amp;iacute;odos de tiempo que se superponen y, por lo tanto, pueden contener elementos duplicados. Tambi&amp;eacute;n hay una versi&amp;oacute;n de esta variante del operador que toma un &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; como par&amp;aacute;metro y lo usa para gobernar el intervalo de tiempo.</target>
        </trans-unit>
        <trans-unit id="24dd0a01354cced0a2acf0aa8063d70ee7f154a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; se encuentra en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="ed91665030b67875ffc98a470567ddb8eb0537e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;startAsync&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;startAsync&lt;/code&gt; se encuentra en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="7557812c5d12bce96afff2c6f2acef59e4f6bf67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;startWith&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;startWith&lt;/code&gt; se encuentra en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="21a9ba7e0e5a1992b4c0bbcf9fa451a208dde737" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subscribeOn&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;subscribeOn&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="e82eb96c199934418a5718cf08684f1241d7a926" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sum&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;sum&lt;/code&gt; se encuentra en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="d70375bcfc9c823861ed0e18d51cf92d8acf08eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;switch&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="7b1afa68f56894c76f703ac9f3769b28164434fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;take&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;take&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="7a4525d7b7fbc759ff9dd8eb06674f4280a9073b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeLast&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;takeLast&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="2941ac03f0842c43596c3b89634f04257ea7c68b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeLastBuffer&lt;/code&gt; also has its duration-based variant, &lt;code&gt;takeLastBufferWithTime&lt;/code&gt;, which is similar to &lt;code&gt;takeLastWithTime&lt;/code&gt; except that it emits its items not individually but collected into a single array of items that is emitted as a single item.</source>
          <target state="translated">&lt;code&gt;takeLastBuffer&lt;/code&gt; tambi&amp;eacute;n tiene su variante basada en duraci&amp;oacute;n, &lt;code&gt;takeLastBufferWithTime&lt;/code&gt; , que es similar a &lt;code&gt;takeLastWithTime&lt;/code&gt; , excepto que emite sus elementos no individualmente, sino que se recopilan en una &amp;uacute;nica matriz de elementos que se emite como un solo elemento.</target>
        </trans-unit>
        <trans-unit id="fc5a21060536e4921b09043d6957f61a67e85859" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeLastBuffer&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;takeLastBuffer&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="d02450ab9c999ca1cdd1497e8d7bf3269e1ad1a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeLastBufferWithTime&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;takeLastBufferWithTime&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="b665df985a737dfb05ba93333df8ea966170a9ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeLastWithTime&lt;/code&gt; by default operates the timer on the &lt;code&gt;timeout&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; and emits items on the &lt;code&gt;currentThread&lt;/code&gt; Scheduler, but you may also pass in Schedulers of your choosing to override these, as an optional second and third parameters, respectively.</source>
          <target state="translated">&lt;code&gt;takeLastWithTime&lt;/code&gt; por defecto funciona el temporizador del &lt;code&gt;timeout&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;del programador&lt;/a&gt; y emite elementos de la &lt;code&gt;currentThread&lt;/code&gt; programador, pero tambi&amp;eacute;n puede pasar en programadores de su elecci&amp;oacute;n para anular estos, como un par&amp;aacute;metro opcional segundo y tercero, respectivamente.</target>
        </trans-unit>
        <trans-unit id="14da141683decf3ce03f63343d83fd24c709bfb7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeLastWithTime&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;takeLastWithTime&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="c20c87a0557376049c73e16b9f4ff3c38215594a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeUntil&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;takeUntil&lt;/code&gt; no opera por defecto en ning&amp;uacute;n &lt;a href=&quot;../scheduler&quot;&gt;Programador en&lt;/a&gt; particular .</target>
        </trans-unit>
        <trans-unit id="37d6c84288e3575f42359e8018cdff6b7b45d977" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeUntil&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;takeUntil&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="9042095065b7d2b25a7d1e092da6338622f2d9fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeUntilWithTime&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;takeUntilWithTime&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="eb79aed0b0d7386fc7de8e365183d8e2e8e7ca97" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeWhile&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;takeWhile&lt;/code&gt; no opera por defecto en ning&amp;uacute;n &lt;a href=&quot;../scheduler&quot;&gt;Programador en&lt;/a&gt; particular .</target>
        </trans-unit>
        <trans-unit id="3df06abff8c84fc5b0f1f4a67410984a32d92db1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeWhile&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;takeWhile&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="8a8ebe39bb4a1d479f5ac26c962f779363985e11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;throttleFirst&lt;/code&gt; operates by default on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you can optionally pass in a Scheduler of your choosing as a third parameter.</source>
          <target state="translated">&lt;code&gt;throttleFirst&lt;/code&gt; funciona de forma predeterminada en el &lt;a href=&quot;../scheduler&quot;&gt;Programador de &lt;/a&gt; &lt;code&gt;computation&lt;/code&gt; , pero opcionalmente puede pasar un Programador de su elecci&amp;oacute;n como tercer par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="e58e7fab93ffb2601599bf75a4c5989ad7f8b9cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;throw&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;throw&lt;/code&gt; se encuentra en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="12fb397d3568ae4d036414110394066d39b1ed4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeInterval&lt;/code&gt; by default operates on the &lt;code&gt;immediate&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but also has a variant that allows you to specify the Scheduler by passing it in as a parameter.</source>
          <target state="translated">&lt;code&gt;timeInterval&lt;/code&gt; por defecto opera en el &lt;a href=&quot;../scheduler&quot;&gt;Programador &lt;/a&gt; &lt;code&gt;immediate&lt;/code&gt; , pero tambi&amp;eacute;n tiene una variante que le permite especificar el Programador pas&amp;aacute;ndolo como par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="757c130c5ec90e41b55716e7d8ceb364f6a8e288" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeInterval&lt;/code&gt; by default operates on the &lt;code&gt;timeout&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but also has a variant that allows you to specify the Scheduler by passing it in as a parameter.</source>
          <target state="translated">&lt;code&gt;timeInterval&lt;/code&gt; por defecto opera en el &lt;a href=&quot;../scheduler&quot;&gt;Programador de &lt;/a&gt; &lt;code&gt;timeout&lt;/code&gt; , pero tambi&amp;eacute;n tiene una variante que le permite especificar el Programador pas&amp;aacute;ndolo como par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="71b3b52092b0ce3ee3f4d96c9a24a943c2d938d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeInterval&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;timeInterval&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="7b213b55f226a478725826835dafe9681d5f8644" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; and &lt;code&gt;timeoutWithSelector&lt;/code&gt; are found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; y &lt;code&gt;timeoutWithSelector&lt;/code&gt; se encuentran en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="1ce975a53ac15047ca82f47b9d9d146a0d85da69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeoutWithSelector&lt;/code&gt; does not use a constant timeout duration, but sets its timeout duration on a per-item basis by passing each item from the source Observable into a function that returns an Observable and then monitoring those Observables. If any such Observable completes before the source Observable emits another item, this is considered a timeout condition, and triggers an &lt;code&gt;onError&lt;/code&gt; notification (&amp;ldquo;&lt;code&gt;Error: Timeout&lt;/code&gt;&amp;rdquo;) from the Observable &lt;code&gt;timeoutWithSelector&lt;/code&gt; returns.</source>
          <target state="translated">&lt;code&gt;timeoutWithSelector&lt;/code&gt; no usa una duraci&amp;oacute;n de tiempo de espera constante, sino que establece su duraci&amp;oacute;n de tiempo de espera por elemento al pasar cada elemento del Observable de origen a una funci&amp;oacute;n que devuelve un Observable y luego monitorea esos Observables. Si cualquiera de estos ultima observables antes de que los emite observables fuente otro elemento, esto se considera una condici&amp;oacute;n de tiempo de espera, y activa una &lt;code&gt;onError&lt;/code&gt; notificaci&amp;oacute;n ( &amp;ldquo; &lt;code&gt;Error: Timeout&lt;/code&gt; &amp;rdquo;) de los observables &lt;code&gt;timeoutWithSelector&lt;/code&gt; devoluciones.</target>
        </trans-unit>
        <trans-unit id="73773bfa5b563e9eba5535983817af426985e541" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timer&lt;/code&gt; by default operates on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, or you can override this by passing in a Scheduler as a final parameter.</source>
          <target state="translated">&lt;code&gt;timer&lt;/code&gt; funciona de forma predeterminada en el &lt;a href=&quot;../scheduler&quot;&gt;Programador de &lt;/a&gt; &lt;code&gt;computation&lt;/code&gt; , o puede anular esto pasando un Programador como par&amp;aacute;metro final.</target>
        </trans-unit>
        <trans-unit id="2cbc3a49fd6d590f7657eb64c4bf3aee582bf2ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timer&lt;/code&gt; by default operates on the &lt;code&gt;timeout&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, or you can override this by passing in a Scheduler as a final parameter.</source>
          <target state="translated">&lt;code&gt;timer&lt;/code&gt; funciona de forma predeterminada en el &lt;a href=&quot;../scheduler&quot;&gt;Programador de &lt;/a&gt; &lt;code&gt;timeout&lt;/code&gt; , o puede anular esto pasando un Programador como par&amp;aacute;metro final.</target>
        </trans-unit>
        <trans-unit id="166b0d0c1925597895a20348e99d636f269ba52f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timer&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;timer&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="a6994ab170fc57b3c6ae8b13a3eb78514353eada" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timer&lt;/code&gt; returns an Observable that emits a single number zero after a delay period you specify.</source>
          <target state="translated">&lt;code&gt;timer&lt;/code&gt; devuelve un Observable que emite un solo n&amp;uacute;mero cero despu&amp;eacute;s de un per&amp;iacute;odo de retraso que especifique.</target>
        </trans-unit>
        <trans-unit id="9d152bee231bbb8e03f92f397a5f47c8bc06dd80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timestamp&lt;/code&gt; by default operates on the &lt;code&gt;immediate&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; but also has a variant that allows you to choose the Scheduler by passing it in as a parameter.</source>
          <target state="translated">&lt;code&gt;timestamp&lt;/code&gt; de tiempo de forma predeterminada opera en el &lt;a href=&quot;../scheduler&quot;&gt;Programador &lt;/a&gt; &lt;code&gt;immediate&lt;/code&gt; pero tambi&amp;eacute;n tiene una variante que le permite elegir el Programador pas&amp;aacute;ndolo como par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="5c4b64c965f491d895a7583ac5fd6181c6b636c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timestamp&lt;/code&gt; by default operates on the &lt;code&gt;timeout&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but also has a variant that allows you to specify the Scheduler by passing it in as a parameter.</source>
          <target state="translated">&lt;code&gt;timestamp&lt;/code&gt; de tiempo por defecto opera en el &lt;a href=&quot;../scheduler&quot;&gt;Programador de &lt;/a&gt; &lt;code&gt;timeout&lt;/code&gt; , pero tambi&amp;eacute;n tiene una variante que le permite especificar el Programador pas&amp;aacute;ndolo como un par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="44cd8475782d97de9ca5e1e58e9b309ed7b54305" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timestamp&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;timestamp&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="51c19fb0c2dc91fdd7ff204e2e2b3dde5ed1cea6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toArray&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;toArray&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="f2436f143a44933d4ae386a7d36228fa95d3b9e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toAsync&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;toAsync&lt;/code&gt; se encuentra en las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="7bf929490433a6f89a9386a35013a74f1cafb6c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toList&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;toList&lt;/code&gt; no opera por defecto en ning&amp;uacute;n &lt;a href=&quot;../scheduler&quot;&gt;Programador en&lt;/a&gt; particular .</target>
        </trans-unit>
        <trans-unit id="480dfc94c15fb8040d8e100d3fa4d5194e955fdd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toMap&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;toMap&lt;/code&gt; no opera por defecto en ning&amp;uacute;n &lt;a href=&quot;../scheduler&quot;&gt;Programador en&lt;/a&gt; particular .</target>
        </trans-unit>
        <trans-unit id="f3c39b03d1c2b125af83fb8e2d096e30c15ec785" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toMap&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;toMap&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="ac9c9dc84a67060553324ea4b1a5883b58175151" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toMultiMap&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;toMultiMap&lt;/code&gt; no opera por defecto en ning&amp;uacute;n &lt;a href=&quot;../scheduler&quot;&gt;Programador en&lt;/a&gt; particular .</target>
        </trans-unit>
        <trans-unit id="4ea2ad74dcc9fb9b4b1703685d68edf066c0841f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toSet&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;toSet&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="ec7965f3d811250e08e8d9ceb0744100f593b518" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toSortedList&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;toSortedList&lt;/code&gt; no opera por defecto en ning&amp;uacute;n &lt;a href=&quot;../scheduler&quot;&gt;Programador en&lt;/a&gt; particular .</target>
        </trans-unit>
        <trans-unit id="46584cfb17a9dfd026e64a70ece0028c2345433e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tumbling(timespan,count&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tumbling(timespan,count&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="946b7fdda870bee85c6810d8f4b8baea15808387" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tumbling(timespan&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tumbling(timespan&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="114b0ca34209466be8813d092973923f1b9b4190" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tumblingBuffer(boundary)&lt;/code&gt; monitors an Observable, &lt;code&gt;boundary&lt;/code&gt;. Each time that Observable emits an item, it creates a new &lt;code&gt;Seq&lt;/code&gt; to begin collecting items emitted by the source Observable and emits the previous &lt;code&gt;Seq&lt;/code&gt;. This variant of the operator has an optional second parameter, &lt;code&gt;initialCapacity&lt;/code&gt; with which you can indicate the expected size of these buffers so as to make memory allocation more efficient.</source>
          <target state="translated">&lt;code&gt;tumblingBuffer(boundary)&lt;/code&gt; supervisa un &lt;code&gt;boundary&lt;/code&gt; observable . Cada vez que Observable emite un elemento, crea una nueva &lt;code&gt;Seq&lt;/code&gt; para comenzar a recopilar elementos emitidos por la fuente Observable y emite la &lt;code&gt;Seq&lt;/code&gt; anterior . Esta variante del operador tiene un segundo par&amp;aacute;metro opcional, &lt;code&gt;initialCapacity&lt;/code&gt; con el que puede indicar el tama&amp;ntilde;o esperado de estos b&amp;uacute;feres para hacer m&amp;aacute;s eficiente la asignaci&amp;oacute;n de memoria.</target>
        </trans-unit>
        <trans-unit id="d46125dcac2cbaa797114df6c032348ed56b10dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tumblingBuffer(count)&lt;/code&gt; emits non-overlapping buffers in the form of &lt;code&gt;Seq&lt;/code&gt;s, each of which contains at most &lt;code&gt;count&lt;/code&gt; items from the source Observable (the final emitted buffer may have fewer than &lt;code&gt;count&lt;/code&gt; items).</source>
          <target state="translated">&lt;code&gt;tumblingBuffer(count)&lt;/code&gt; emite b&amp;uacute;feres no superpuestos en forma de &lt;code&gt;Seq&lt;/code&gt; s, cada uno de los cuales contiene como m&amp;aacute;ximo elementos de &lt;code&gt;count&lt;/code&gt; de la fuente Observable (el b&amp;uacute;fer emitido final puede tener menos de elementos de &lt;code&gt;count&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="bfd1e55878e9963160e69e3e46fbcc3ba5b0c630" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tumblingBuffer(timespan)&lt;/code&gt; emits a new &lt;code&gt;Seq&lt;/code&gt; of items periodically, every &lt;code&gt;timespan&lt;/code&gt; (a &lt;code&gt;Duration&lt;/code&gt;), containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first bundle, since the subscription to the source Observable. This variant of the operator has an optional second parameter, &lt;code&gt;scheduler&lt;/code&gt;, with which you can set the &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; that you want to govern the timespan calculation.</source>
          <target state="translated">&lt;code&gt;tumblingBuffer(timespan)&lt;/code&gt; emite una nueva &lt;code&gt;Seq&lt;/code&gt; de elementos peri&amp;oacute;dicamente, cada &lt;code&gt;timespan&lt;/code&gt; (una &lt;code&gt;Duration&lt;/code&gt; ), que contiene todos los elementos emitidos por la fuente Observable desde la emisi&amp;oacute;n del paquete anterior o, en el caso del primer paquete, desde la suscripci&amp;oacute;n a la fuente Observable. Esta variante del operador tiene un segundo par&amp;aacute;metro opcional, el &lt;code&gt;scheduler&lt;/code&gt; , con el que puede configurar el &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; que desea que gobierne el c&amp;aacute;lculo del intervalo de tiempo.</target>
        </trans-unit>
        <trans-unit id="b21cd4f65fc506789ef4e59831405d1e22f95404" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tumblingBuffer(timespan, count)&lt;/code&gt; emits a new &lt;code&gt;Seq&lt;/code&gt; of items for every &lt;code&gt;count&lt;/code&gt; items emitted by the source Observable, or, if &lt;code&gt;timespan&lt;/code&gt; (a &lt;code&gt;Duration&lt;/code&gt;) has elapsed since its last bundle emission, it emits a &lt;code&gt;Seq&lt;/code&gt; containing however many items the source Observable emitted in that span, even if this is fewer than &lt;code&gt;count&lt;/code&gt;. This variant of the operator has an optional third parameter, &lt;code&gt;scheduler&lt;/code&gt;, with which you can set the &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; that you want to govern the timespan calculation.</source>
          <target state="translated">&lt;code&gt;tumblingBuffer(timespan, count)&lt;/code&gt; emite una nueva &lt;code&gt;Seq&lt;/code&gt; de elementos por cada elemento de &lt;code&gt;count&lt;/code&gt; emitido por la fuente Observable o, si ha transcurrido un &lt;code&gt;timespan&lt;/code&gt; (una &lt;code&gt;Duration&lt;/code&gt; ) desde su &amp;uacute;ltima emisi&amp;oacute;n de paquete, emite una &lt;code&gt;Seq&lt;/code&gt; contiene la cantidad de elementos que emiti&amp;oacute; la fuente Observable en ese lapso, incluso si esto es menos que &lt;code&gt;count&lt;/code&gt; . Esta variante del operador tiene un tercer par&amp;aacute;metro opcional, el &lt;code&gt;scheduler&lt;/code&gt; , con el que puede configurar el &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; que desea que gobierne el c&amp;aacute;lculo del intervalo de tiempo.</target>
        </trans-unit>
        <trans-unit id="3dbb96ec506e9ea7b859c90a031a511f04f5a25b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;using&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;using&lt;/code&gt; no opera por defecto en ning&amp;uacute;n &lt;a href=&quot;../scheduler&quot;&gt;Programador en&lt;/a&gt; particular .</target>
        </trans-unit>
        <trans-unit id="67fe99075e97e899a8a29e4d7d6bbf8bc6656d37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;using&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;using&lt;/code&gt; se encuentra en cada una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="9180af64681c5e6bbe87c5747504627d06e37279" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;while&lt;/code&gt; is found in the &lt;code&gt;rx.experimental.js&lt;/code&gt; distribution. It requires one of the following distributions:</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; se encuentra en la distribuci&amp;oacute;n &lt;code&gt;rx.experimental.js&lt;/code&gt; . Requiere una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="33cff6c004ac3784284d1aafacb977d88056d9a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window(timespan, timeshift, unit&lt;/code&gt;[&lt;code&gt;, scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;window(timespan, timeshift, unit&lt;/code&gt; [ &lt;code&gt;, scheduler&lt;/code&gt; ] &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aa5feef256593decbc4e3c0668b5c74c2b7542ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window(timespan, unit, count&lt;/code&gt;[&lt;code&gt;, scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;window(timespan, unit, count&lt;/code&gt; [ &lt;code&gt;, scheduler&lt;/code&gt; ] &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a88858274463fe4c29e450ff892be4ab3cdd04ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window(timespan, unit&lt;/code&gt;[&lt;code&gt;, scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;window(timespan, unit&lt;/code&gt; [ &lt;code&gt;, scheduler&lt;/code&gt; ] &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8df2411d37d8d9a19673d8cc2fca09e073fe8588" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;windowWithTime(timeSpan,timeShift&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;windowWithTime(timeSpan,timeShift&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0082a3e53e214cc5277d43c253721adf6ffebe46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;windowWithTime(timeSpan&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;windowWithTime(timeSpan&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="afd4e92b2e4ccb74b8e4469f1bd7c11303336a25" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;windowWithTimeOrCount(timeSpan,count&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;windowWithTimeOrCount(timeSpan,count&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5ba9f5753ce09bb018d7eea164bf09706e308337" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;windowWithTimeOrCount&lt;/code&gt; opens its first window immediately. It closes the currently open window and opens another one every &lt;code&gt;timespan&lt;/code&gt; milliseconds (optionally measured on a particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;) or whenever the currently open window has emitted &lt;code&gt;count&lt;/code&gt; items. It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. &lt;code&gt;windowWithTimeOrCount&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">&lt;code&gt;windowWithTimeOrCount&lt;/code&gt; abre su primera ventana inmediatamente. Cierra la ventana abierta actualmente y abre otra cada milisegundos de &lt;code&gt;timespan&lt;/code&gt; (opcionalmente medido en un &lt;a href=&quot;../scheduler&quot;&gt;Programador en&lt;/a&gt; particular ) o siempre que la ventana abierta actualmente haya emitido elementos de &lt;code&gt;count&lt;/code&gt; . Tambi&amp;eacute;n cerrar&amp;aacute; la ventana abierta actualmente si recibe una notificaci&amp;oacute;n &lt;code&gt;onCompleted&lt;/code&gt; o &lt;code&gt;onError&lt;/code&gt; de la fuente Observable. &lt;code&gt;windowWithTimeOrCount&lt;/code&gt; emite una serie de ventanas no superpuestas cuyas emisiones colectivas se corresponden uno a uno con las de la fuente Observable.</target>
        </trans-unit>
        <trans-unit id="fd00380205a686ee17604d17356c523c0e72c3a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window_with_time(period, skip&lt;/code&gt;[&lt;code&gt;, coordination&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;window_with_time(period, skip&lt;/code&gt; [ &lt;code&gt;, coordination&lt;/code&gt; ] &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5db0580b8d43ac68544b774f2554c7d3ba35e259" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window_with_time(period&lt;/code&gt;[&lt;code&gt;, coordination&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;window_with_time(period&lt;/code&gt; [ &lt;code&gt;, coordination&lt;/code&gt; ] &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="82e83f25479adacc961806d24bc915b042ddee0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window_with_time(timespan,timeshift&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;window_with_time(timespan,timeshift&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fee332926b0d48f2889ec46f5f950b3c4e76d18c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window_with_time(timespan&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;window_with_time(timespan&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="89d3d2c45562db6fe6c52b9d1508809b4531e5ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window_with_time_or_count(period, count&lt;/code&gt;[&lt;code&gt;, coordination&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;window_with_time_or_count(period, count&lt;/code&gt; [ &lt;code&gt;, coordination&lt;/code&gt; ] &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f76e50530b051a16903cb3a749bbf3d0ebcbc93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window_with_time_or_count(timespan,count&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;window_with_time_or_count(timespan,count&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="641566bee8a202a27ae03c144854e648d69bf89d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window_with_time_or_count&lt;/code&gt; opens its first window immediately. It closes the currently open window and opens another one every &lt;code&gt;period&lt;/code&gt; of time (optionally computed by a given Coordination) or whenever the currently open window has emitted &lt;code&gt;count&lt;/code&gt; items. It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. &lt;code&gt;window_with_time_or_count&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">&lt;code&gt;window_with_time_or_count&lt;/code&gt; abre su primera ventana inmediatamente. Cierra la ventana abierta actualmente y abre otra cada &lt;code&gt;period&lt;/code&gt; de tiempo (opcionalmente calculado por una Coordinaci&amp;oacute;n dada) o siempre que la ventana abierta actualmente ha emitido elementos de &lt;code&gt;count&lt;/code&gt; . Tambi&amp;eacute;n cerrar&amp;aacute; la ventana abierta actualmente si recibe una notificaci&amp;oacute;n &lt;code&gt;onCompleted&lt;/code&gt; o &lt;code&gt;onError&lt;/code&gt; de la fuente Observable. &lt;code&gt;window_with_time_or_count&lt;/code&gt; emite una serie de ventanas no superpuestas cuyas emisiones colectivas se corresponden uno a uno con las de la fuente Observable.</target>
        </trans-unit>
        <trans-unit id="58c4c18c7ec6364acc53cb5fe05e73f534b19a73" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window_with_time_or_count&lt;/code&gt; opens its first window immediately. It closes the currently open window and opens another one every &lt;code&gt;timespan&lt;/code&gt; milliseconds (optionally measured on a particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;) or whenever the currently open window has emitted &lt;code&gt;count&lt;/code&gt; items. It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. &lt;code&gt;window_with_time_or_count&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">&lt;code&gt;window_with_time_or_count&lt;/code&gt; abre su primera ventana inmediatamente. Cierra la ventana abierta actualmente y abre otra cada milisegundos de &lt;code&gt;timespan&lt;/code&gt; (opcionalmente medido en un &lt;a href=&quot;../scheduler&quot;&gt;Programador en&lt;/a&gt; particular ) o siempre que la ventana abierta actualmente haya emitido elementos de &lt;code&gt;count&lt;/code&gt; . Tambi&amp;eacute;n cerrar&amp;aacute; la ventana abierta actualmente si recibe una notificaci&amp;oacute;n &lt;code&gt;onCompleted&lt;/code&gt; o &lt;code&gt;onError&lt;/code&gt; de la fuente Observable. &lt;code&gt;window_with_time_or_count&lt;/code&gt; emite una serie de ventanas no superpuestas cuyas emisiones colectivas se corresponden uno a uno con las de la fuente Observable.</target>
        </trans-unit>
        <trans-unit id="dc83188733343337e00c5f1f317f3281f7cb8498" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;zip&lt;/code&gt; accepts a variable number of Observables or Promises as parameters, followed by a function that accepts one item emitted by each of those Observables or resolved by those Promises as input and produces a single item to be emitted by the resulting Observable.</source>
          <target state="translated">&lt;code&gt;zip&lt;/code&gt; acepta un n&amp;uacute;mero variable de Observables o Promesas como par&amp;aacute;metros, seguido de una funci&amp;oacute;n que acepta un elemento emitido por cada uno de esos Observables o resuelto por esas Promesas como entrada y produce un solo elemento para ser emitido por el Observable resultante.</target>
        </trans-unit>
        <trans-unit id="36e1debe572209b748af04eb0b1aaf0617354592" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;zip&lt;/code&gt; and &lt;code&gt;zipWith&lt;/code&gt; do not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;zip&lt;/code&gt; y &lt;code&gt;zipWith&lt;/code&gt; no operan por defecto en ning&amp;uacute;n &lt;a href=&quot;../scheduler&quot;&gt;Programador en&lt;/a&gt; particular .</target>
        </trans-unit>
        <trans-unit id="4541e5aef8fc275a2be0435a981bbc433ea604d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;zipArray&lt;/code&gt; accepts a variable number of Observables as parameters and returns an Observable that emits arrays, each one containing the</source>
          <target state="translated">&lt;code&gt;zipArray&lt;/code&gt; acepta un n&amp;uacute;mero variable de Observables como par&amp;aacute;metros y devuelve un Observable que emite matrices, cada una de las cuales contiene el</target>
        </trans-unit>
        <trans-unit id="73c6161ea024bd469cc2d9d1691023d9244d7b73" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; item from each source Observable.</source>
          <target state="translated">&lt;sup&gt;el&lt;/sup&gt; elemento de cada fuente Observable.</target>
        </trans-unit>
        <trans-unit id="2e3866d4dc2075c3f5d0d914e8fb5c6c5cf655d6" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; item that it expected.</source>
          <target state="translated">&lt;sup&gt;th&lt;/sup&gt; elemento que esperaba.</target>
        </trans-unit>
        <trans-unit id="6dcd4ce23d88e2ee9568ba546c007c63d9131c1b" translate="yes" xml:space="preserve">
          <source>A</source>
          <target state="translated">A</target>
        </trans-unit>
        <trans-unit id="5a9ea636768e98730048d960cb7b94ce27c67345" translate="yes" xml:space="preserve">
          <source>A Decision Tree of Observable Operators</source>
          <target state="translated">Un árbol de decisiones de los operadores observables</target>
        </trans-unit>
        <trans-unit id="2b08c72f6a37159d94745e3d486d34e86abda5ad" translate="yes" xml:space="preserve">
          <source>A Single is something like an Observable, but instead of emitting a series of values &amp;mdash; anywhere from none at all to an infinite number &amp;mdash; it always either emits one value or an error notification.</source>
          <target state="translated">Un Single es algo as&amp;iacute; como un Observable, pero en lugar de emitir una serie de valores, desde ninguno hasta un n&amp;uacute;mero infinito, siempre emite un valor o una notificaci&amp;oacute;n de error.</target>
        </trans-unit>
        <trans-unit id="ab0a565fcadf77db3f8a879c0832ebb221aa9780" translate="yes" xml:space="preserve">
          <source>A Single will call only one of these methods, and will only call it once. Upon calling either method, the Single terminates and the subscription to it ends.</source>
          <target state="translated">Un soltero llamará sólo uno de estos métodos,y sólo lo llamará una vez.Al llamar a cualquiera de los dos métodos,la soltera termina y la suscripción a ella termina.</target>
        </trans-unit>
        <trans-unit id="59605fccb31cb127c02c09296155efa5fe013b9c" translate="yes" xml:space="preserve">
          <source>A Subject is a sort of bridge or proxy that is available in some implementations of ReactiveX that acts both as an observer and as an Observable. Because it is an observer, it can subscribe to one or more Observables, and because it is an Observable, it can pass through the items it observes by reemitting them, and it can also emit new items.</source>
          <target state="translated">Un Sujeto es una especie de puente o proxy que está disponible en algunas implementaciones de ReactiveX que actúa tanto como observador como observable.Por ser un observador,puede suscribirse a uno o más Observables,y por ser un Observable,puede pasar a través de los elementos que observa reemitiéndolos,y también puede emitir nuevos elementos.</target>
        </trans-unit>
        <trans-unit id="e5115867d3f9ec7f7973522f38b1446136baf293" translate="yes" xml:space="preserve">
          <source>A chain of Observable operators do not operate independently on the original Observable that originates the chain, but they operate &lt;em&gt;in turn&lt;/em&gt;, each one operating on the Observable generated by the operator immediately previous in the chain.</source>
          <target state="translated">Una cadena de operadores Observables no opera de forma independiente sobre el Observable original que origina la cadena, sino que operan &lt;em&gt;a su vez&lt;/em&gt; , cada uno operando sobre el Observable generado por el operador inmediatamente anterior en la cadena.</target>
        </trans-unit>
        <trans-unit id="4aa1692172bf25b6129069ba0c0eaa218eb4bcab" translate="yes" xml:space="preserve">
          <source>A more complete &lt;code&gt;subscribe&lt;/code&gt; call example looks like this:</source>
          <target state="translated">Un ejemplo de llamada de &lt;code&gt;subscribe&lt;/code&gt; m&amp;aacute;s completo se ve as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="e0af329e9352bf7003c7730a1fbf549f05c11689" translate="yes" xml:space="preserve">
          <source>A related operator, IsEmpty returns an Observable that emits &lt;code&gt;true&lt;/code&gt; if and only if the source Observable completes without emitting any items. It emits &lt;code&gt;false&lt;/code&gt; if the source Observable emits an item.</source>
          <target state="translated">Un operador relacionado, IsEmpty devuelve un Observable que emite &lt;code&gt;true&lt;/code&gt; si y solo si el Observable de origen se completa sin emitir ning&amp;uacute;n elemento. Emite &lt;code&gt;false&lt;/code&gt; si la fuente Observable emite un elemento.</target>
        </trans-unit>
        <trans-unit id="3bd6fdbcf4ffd98efa9870facaa7222cee24194a" translate="yes" xml:space="preserve">
          <source>A second possibility is to use the &lt;code&gt;windowed(&lt;/code&gt;</source>
          <target state="translated">Una segunda posibilidad es utilizar la &lt;code&gt;windowed(&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="470bb39ca8f873b411a9bf2795442d8e2de5abb2" translate="yes" xml:space="preserve">
          <source>A second variant of &lt;code&gt;forkJoin&lt;/code&gt; exists as a prototype function, and you call it on an instance of one source Observable, passing it another source Observable as a parameter. As a second parameter, you pass it a function that combines the final item emitted by the two source Observables into the sole item to be emitted by the resulting Observable.</source>
          <target state="translated">Existe una segunda variante de &lt;code&gt;forkJoin&lt;/code&gt; como funci&amp;oacute;n prototipo, y la llamas en una instancia de una fuente Observable, pas&amp;aacute;ndole otra fuente Observable como par&amp;aacute;metro. Como segundo par&amp;aacute;metro, le pasa una funci&amp;oacute;n que combina el elemento final emitido por los dos Observables de origen en el &amp;uacute;nico elemento que emitir&amp;aacute; el Observable resultante.</target>
        </trans-unit>
        <trans-unit id="80636dd32da61a598e55857994e632bbd4be9e7d" translate="yes" xml:space="preserve">
          <source>A second variant of &lt;code&gt;timeout&lt;/code&gt; differs from the first in that instead of issuing an error notification in case of a timeout condition, it instead immediately switches to a backup Observable that you specify.</source>
          <target state="translated">Una segunda variante de &lt;code&gt;timeout&lt;/code&gt; de espera se diferencia de la primera en que en lugar de emitir una notificaci&amp;oacute;n de error en caso de una condici&amp;oacute;n de tiempo de espera, cambia inmediatamente a un Observable de respaldo que usted especifique.</target>
        </trans-unit>
        <trans-unit id="1014e078d9399bc4430b8c0f57f75f79b89ad343" translate="yes" xml:space="preserve">
          <source>A second version of this operator was released in RxGroovy 1.1. It uses a predicate function that evaluates the items emitted by the source Observable, rather than a second Observable, to terminate the resulting Observable sequence. In this way, it behaves in a similar way to &lt;a href=&quot;takewhile&quot;&gt;TakeWhile&lt;/a&gt;.</source>
          <target state="translated">Se lanz&amp;oacute; una segunda versi&amp;oacute;n de este operador en RxGroovy 1.1. Utiliza una funci&amp;oacute;n de predicado que eval&amp;uacute;a los elementos emitidos por el Observable fuente, en lugar de un segundo Observable, para terminar la secuencia Observable resultante. De esta forma, se comporta de forma similar a &lt;a href=&quot;takewhile&quot;&gt;TakeWhile&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a3a7d4a46c5c7bc15a9d7db1fc1edb5b764d3a73" translate="yes" xml:space="preserve">
          <source>A second version of this operator was released in RxJava 1.1. It uses a predicate function that evaluates the items emitted by the source Observable, rather than a second Observable, to terminate the resulting Observable sequence. In this way, it behaves in a similar way to &lt;a href=&quot;takewhile&quot;&gt;TakeWhile&lt;/a&gt;.</source>
          <target state="translated">Se lanz&amp;oacute; una segunda versi&amp;oacute;n de este operador en RxJava 1.1. Utiliza una funci&amp;oacute;n de predicado que eval&amp;uacute;a los elementos emitidos por el Observable fuente, en lugar de un segundo Observable, para terminar la secuencia Observable resultante. De esta forma, se comporta de forma similar a &lt;a href=&quot;takewhile&quot;&gt;TakeWhile&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bdc9c3e84a8e5b9e18d52bf83f76d74a848d15d8" translate="yes" xml:space="preserve">
          <source>A similar operator is &lt;code&gt;ofObjectChanges&lt;/code&gt;. It returns an Observable that emits any changes made to a particular object, as reported by its &lt;code&gt;Object.observe&lt;/code&gt; method. It is also found only in the &lt;code&gt;rx.all.js&lt;/code&gt; distribution.</source>
          <target state="translated">Un operador similar es &lt;code&gt;ofObjectChanges&lt;/code&gt; . Devuelve un Observable que emite cualquier cambio realizado en un objeto en particular, seg&amp;uacute;n lo informado por su m&amp;eacute;todo &lt;code&gt;Object.observe&lt;/code&gt; . Tambi&amp;eacute;n se encuentra solo en la distribuci&amp;oacute;n &lt;code&gt;rx.all.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d9b3babb124228b9672822ea408e026abe9f755" translate="yes" xml:space="preserve">
          <source>A third variant of &lt;code&gt;retry&lt;/code&gt; takes a predicate function as a parameter. You write this function to accept two arguments: an Int count of how many retries have taken place thusfar, and a Throwable indicating the error that caused the &lt;code&gt;onError&lt;/code&gt; notification. This function returns a Boolean to indicate whether or not &lt;code&gt;retry&lt;/code&gt; should resubscribe to and mirror the source Observable. If it does not, then &lt;code&gt;retry&lt;/code&gt; passes the latest &lt;code&gt;onError&lt;/code&gt; notification to its observers.</source>
          <target state="translated">Una tercera variante de &lt;code&gt;retry&lt;/code&gt; toma una funci&amp;oacute;n de predicado como par&amp;aacute;metro. Escribe esta funci&amp;oacute;n para aceptar dos argumentos: un recuento Int de cu&amp;aacute;ntos reintentos se han realizado hasta ahora y un Throwable que indica el error que provoc&amp;oacute; la notificaci&amp;oacute;n &lt;code&gt;onError&lt;/code&gt; . Esta funci&amp;oacute;n devuelve un valor booleano para indicar si el &lt;code&gt;retry&lt;/code&gt; debe volver a suscribirse y reflejar la fuente Observable. Si no es as&amp;iacute;, entonces &lt;code&gt;retry&lt;/code&gt; pasa la &amp;uacute;ltima notificaci&amp;oacute;n &lt;code&gt;onError&lt;/code&gt; a sus observadores.</target>
        </trans-unit>
        <trans-unit id="c9c9ea5b2183ed2e503c70773c2a45edce947b6d" translate="yes" xml:space="preserve">
          <source>A third variant of &lt;code&gt;retry&lt;/code&gt; takes a predicate function as a parameter. You write this function to accept two arguments: an Integer count of how many retries have taken place thusfar, and a Throwable indicating the error that caused the &lt;code&gt;onError&lt;/code&gt; notification. This function returns a Boolean to indicate whether or not &lt;code&gt;retry&lt;/code&gt; should resubscribe to and mirror the source Observable. If it does not, then &lt;code&gt;retry&lt;/code&gt; passes the latest &lt;code&gt;onError&lt;/code&gt; notification to its observers.</source>
          <target state="translated">Una tercera variante de &lt;code&gt;retry&lt;/code&gt; toma una funci&amp;oacute;n de predicado como par&amp;aacute;metro. Escribe esta funci&amp;oacute;n para aceptar dos argumentos: un recuento entero de cu&amp;aacute;ntos reintentos se han realizado hasta ahora y un Throwable que indica el error que provoc&amp;oacute; la notificaci&amp;oacute;n &lt;code&gt;onError&lt;/code&gt; . Esta funci&amp;oacute;n devuelve un valor booleano para indicar si el &lt;code&gt;retry&lt;/code&gt; debe volver a suscribirse y reflejar la fuente Observable. Si no es as&amp;iacute;, entonces &lt;code&gt;retry&lt;/code&gt; pasa la &amp;uacute;ltima notificaci&amp;oacute;n &lt;code&gt;onError&lt;/code&gt; a sus observadores.</target>
        </trans-unit>
        <trans-unit id="59dc0040b390fb0df014aee4d31dbc580181dd4c" translate="yes" xml:space="preserve">
          <source>A third variant of &lt;code&gt;timeout&lt;/code&gt; does not use a constant timeout duration, but sets its timeout duration on a per-item basis by passing each item from the source Observable into a function that returns an Observable and then monitoring those Observables. If any such Observable completes before the source Observable emits another item, this is considered a timeout condition, and triggers an &lt;code&gt;onError&lt;/code&gt; notification (&amp;ldquo;&lt;code&gt;TimeoutException&lt;/code&gt;&amp;rdquo;) from the Observable &lt;code&gt;timeout&lt;/code&gt; returns.</source>
          <target state="translated">Una tercera variante de &lt;code&gt;timeout&lt;/code&gt; de espera no usa una duraci&amp;oacute;n de tiempo de espera constante, sino que establece su duraci&amp;oacute;n de tiempo de espera por elemento al pasar cada elemento del Observable de origen a una funci&amp;oacute;n que devuelve un Observable y luego monitorea esos Observables. Si alguno de dichos Observable se completa antes de que el Observable de origen emita otro elemento, esto se considera una condici&amp;oacute;n de tiempo de espera y desencadena una notificaci&amp;oacute;n de &lt;code&gt;onError&lt;/code&gt; (&quot; &lt;code&gt;TimeoutException&lt;/code&gt; &quot;) de los retornos de &lt;code&gt;timeout&lt;/code&gt; Observable .</target>
        </trans-unit>
        <trans-unit id="e63b86ec2cc6e89e587945cf3c2a65042288e202" translate="yes" xml:space="preserve">
          <source>A toolbox of useful Operators for working with Observables</source>
          <target state="translated">Una caja de herramientas de Operadores útiles para trabajar con los Observables</target>
        </trans-unit>
        <trans-unit id="12bf70fec688d32e9df77570a93f7d9de2beb9f6" translate="yes" xml:space="preserve">
          <source>A typical implementation of the Subscribe operator may accept one to three methods (which then constitute the observer), or it may accept an object (sometimes called an &lt;code&gt;Observer&lt;/code&gt; or &lt;code&gt;Subscriber&lt;/code&gt;) that implements the interface which includes those three methods:</source>
          <target state="translated">Una implementaci&amp;oacute;n t&amp;iacute;pica del operador Suscribir puede aceptar de uno a tres m&amp;eacute;todos (que luego constituyen el observador), o puede aceptar un objeto (a veces llamado &lt;code&gt;Observer&lt;/code&gt; o &lt;code&gt;Subscriber&lt;/code&gt; ) que implementa la interfaz que incluye esos tres m&amp;eacute;todos:</target>
        </trans-unit>
        <trans-unit id="326f047b7addbda19eb8d949bed620511187ece5" translate="yes" xml:space="preserve">
          <source>A variant of distinct that only compares emitted items from the source Observable against their immediate predecessors in order to determine whether or not they are distinct.</source>
          <target state="translated">Una variante de los distintos que sólo compara los artículos emitidos de la fuente observable con sus predecesores inmediatos a fin de determinar si son distintos o no.</target>
        </trans-unit>
        <trans-unit id="628cd375e74040d3f1575481baed0a36bf589549" translate="yes" xml:space="preserve">
          <source>A variant of this operator &lt;code&gt;merge(maxConcurrent:)&lt;/code&gt; allows you to pass in an &lt;code&gt;Int&lt;/code&gt; indicating the maximum number of these emitted Observables you want &lt;code&gt;merge&lt;/code&gt; to try to be subscribed to at any time. If it hits this maximum subscription count, it will refrain from subscribing to any other Observables emitted by the source Observable until such time as one of the already-subscribed-to Observables issues an &lt;code&gt;onCompleted&lt;/code&gt; notification.</source>
          <target state="translated">Una variante de este operador &lt;code&gt;merge(maxConcurrent:)&lt;/code&gt; le permite pasar en un &lt;code&gt;Int&lt;/code&gt; indica el n&amp;uacute;mero m&amp;aacute;ximo de estos observables emitidos desee &lt;code&gt;merge&lt;/code&gt; para tratar de estar suscrito a en cualquier momento. Si impacta esta suscripci&amp;oacute;n m&amp;aacute;xima recuento, se abstendr&amp;aacute; de suscribirse a cualquier otro observables emitidos por la fuente observable hasta que una de las una ya suscrito a cuestiones observables &lt;code&gt;onCompleted&lt;/code&gt; notificaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d35ccc7301b7ce4feccd9c396c10c5d8cca3b515" translate="yes" xml:space="preserve">
          <source>A variant of this operator, called &lt;code&gt;ofWithScheduler&lt;/code&gt; takes a &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; as its first parameter, and operates the resulting Observable on this Scheduler.</source>
          <target state="translated">Una variante de este operador, llamada &lt;code&gt;ofWithScheduler&lt;/code&gt; , toma un &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; como su primer par&amp;aacute;metro y opera el Observable resultante en este Scheduler.</target>
        </trans-unit>
        <trans-unit id="c0925a0e0dd3f224e5197c574ea37e59cffa4f0d" translate="yes" xml:space="preserve">
          <source>A version of the timeout operator allows you to switch to a backup Single rather than sending an error notification if the timeout expires:</source>
          <target state="translated">Una versión del operador de tiempo de espera le permite cambiar a un Single de reserva en lugar de enviar una notificación de error si el tiempo de espera expira:</target>
        </trans-unit>
        <trans-unit id="95c20b67a1841fd8175f5bbf824b5bd0534f744a" translate="yes" xml:space="preserve">
          <source>A version of this operator that was introduced in RxGroovy 1.1 allows you to set the capacity of the buffer; applying this operator will cause the resulting Observable to terminate with an error if this buffer is overrun. A second version, introduced during the same release, allows you to set an &lt;code&gt;Action&lt;/code&gt; that &lt;code&gt;onBackpressureBuffer&lt;/code&gt; will call if the buffer is overrun.</source>
          <target state="translated">Una versi&amp;oacute;n de este operador que se introdujo en RxGroovy 1.1 le permite establecer la capacidad del b&amp;uacute;fer; la aplicaci&amp;oacute;n de este operador har&amp;aacute; que el Observable resultante termine con un error si este b&amp;uacute;fer se desborda. Una segunda versi&amp;oacute;n, introducida durante la misma versi&amp;oacute;n, le permite establecer una &lt;code&gt;Action&lt;/code&gt; que &lt;code&gt;onBackpressureBuffer&lt;/code&gt; llamar&amp;aacute; si el b&amp;uacute;fer est&amp;aacute; desbordado.</target>
        </trans-unit>
        <trans-unit id="f994ec3ff86b720b838d74d54795039e7a5aa034" translate="yes" xml:space="preserve">
          <source>A version of this operator that was introduced in RxJava 1.1 allows you to set the capacity of the buffer; applying this operator will cause the resulting Observable to terminate with an error if this buffer is overrun. A second version, introduced during the same release, allows you to set an &lt;code&gt;Action&lt;/code&gt; that &lt;code&gt;onBackpressureBuffer&lt;/code&gt; will call if the buffer is overrun.</source>
          <target state="translated">Una versi&amp;oacute;n de este operador que se introdujo en RxJava 1.1 le permite establecer la capacidad del b&amp;uacute;fer; la aplicaci&amp;oacute;n de este operador har&amp;aacute; que el Observable resultante termine con un error si este b&amp;uacute;fer se desborda. Una segunda versi&amp;oacute;n, introducida durante la misma versi&amp;oacute;n, le permite establecer una &lt;code&gt;Action&lt;/code&gt; que &lt;code&gt;onBackpressureBuffer&lt;/code&gt; llamar&amp;aacute; si el b&amp;uacute;fer est&amp;aacute; desbordado.</target>
        </trans-unit>
        <trans-unit id="17462ee811b15366ad770504e8600c231368974f" translate="yes" xml:space="preserve">
          <source>A version of this operator that was introduced in the 1.1 release notifies you, by means of an &lt;code&gt;Action&lt;/code&gt; you pass as a parameter, when an item has been dropped and which item was dropped.</source>
          <target state="translated">Una versi&amp;oacute;n de este operador que se introdujo en la versi&amp;oacute;n 1.1 le notifica, por medio de una &lt;code&gt;Action&lt;/code&gt; que pasa como par&amp;aacute;metro, cuando un elemento se ha eliminado y qu&amp;eacute; elemento se elimin&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="850d4acf22d3a4e1c03049abdf78b9a93ef3eccf" translate="yes" xml:space="preserve">
          <source>A version of this variant of the operator (still in Beta as of this writing) takes an additional &lt;code&gt;int&lt;/code&gt; parameter. This parameter sets the maximum number of concurrent subscriptions that &lt;code&gt;flatMap&lt;/code&gt; will attempt to have to the Observables that the items emitted by the source Observable map to. When it reaches this maximum number, it will wait for one of those Observables to terminate before subscribing to another.</source>
          <target state="translated">Una versi&amp;oacute;n de esta variante del operador (todav&amp;iacute;a en Beta al momento de escribir este art&amp;iacute;culo) toma un par&amp;aacute;metro &lt;code&gt;int&lt;/code&gt; adicional . Este par&amp;aacute;metro establece el n&amp;uacute;mero m&amp;aacute;ximo de suscripciones simult&amp;aacute;neas que &lt;code&gt;flatMap&lt;/code&gt; intentar&amp;aacute; tener a los Observables a los que los elementos emitidos por el mapa Observable de origen. Cuando alcance este n&amp;uacute;mero m&amp;aacute;ximo, esperar&amp;aacute; a que uno de esos Observables termine antes de suscribirse a otro.</target>
        </trans-unit>
        <trans-unit id="6cf0103a4b2b868a1a60d776479c80ac940f5052" translate="yes" xml:space="preserve">
          <source>A well-formed finite Observable must attempt to call either the observer&amp;rsquo;s &lt;code&gt;onCompleted&lt;/code&gt; method exactly once or its &lt;code&gt;onError&lt;/code&gt; method exactly once, and must not thereafter attempt to call any of the observer&amp;rsquo;s other methods.</source>
          <target state="translated">Un Observable finito bien formado debe intentar llamar al m&amp;eacute;todo &lt;code&gt;onCompleted&lt;/code&gt; del observador exactamente una vez o su m&amp;eacute;todo &lt;code&gt;onError&lt;/code&gt; exactamente una vez, y despu&amp;eacute;s no debe intentar llamar a ninguno de los otros m&amp;eacute;todos del observador.</target>
        </trans-unit>
        <trans-unit id="653657e1f29569ba5423fd7a08a85817bf13a50d" translate="yes" xml:space="preserve">
          <source>A well-formed, finite Observable will invoke its observer&amp;rsquo;s &lt;code&gt;onNext&lt;/code&gt; method zero or more times, and then will invoke either the &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; method exactly once. The Materialize operator converts this series of invocations &amp;mdash; both the original &lt;code&gt;onNext&lt;/code&gt; notifications and the terminal &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification &amp;mdash; into a series of &lt;em&gt;items&lt;/em&gt; emitted by an Observable.</source>
          <target state="translated">Un Observable finito y bien formado invocar&amp;aacute; el m&amp;eacute;todo &lt;code&gt;onNext&lt;/code&gt; de su observador cero o m&amp;aacute;s veces, y luego invocar&amp;aacute; el m&amp;eacute;todo &lt;code&gt;onCompleted&lt;/code&gt; u &lt;code&gt;onError&lt;/code&gt; exactamente una vez. El operador Materialise convierte esta serie de invocaciones, tanto las notificaciones &lt;code&gt;onNext&lt;/code&gt; originales como la notificaci&amp;oacute;n &lt;code&gt;onCompleted&lt;/code&gt; o &lt;code&gt;onError&lt;/code&gt; del terminal , en una serie de &lt;em&gt;elementos&lt;/em&gt; emitidos por un Observable.</target>
        </trans-unit>
        <trans-unit id="805825d0f7d22f43a512c60285f688fee71614c5" translate="yes" xml:space="preserve">
          <source>Advanced RxJava: Schedulers (&lt;a href=&quot;http://akarnokd.blogspot.hu/2015/05/schedulers-part-1.html&quot;&gt;part 1&lt;/a&gt;) (&lt;a href=&quot;http://akarnokd.blogspot.hu/2015/06/schedulers-part-2.html&quot;&gt;part 2&lt;/a&gt;) (&lt;a href=&quot;http://akarnokd.blogspot.hu/2015/06/schedulers-part-3.html&quot;&gt;part 3&lt;/a&gt;) (&lt;a href=&quot;http://akarnokd.blogspot.hu/2015/06/schedulers-part-4-final.html&quot;&gt;part 4&lt;/a&gt;) by D&amp;aacute;vid Karnok</source>
          <target state="translated">Advanced RxJava: Schedulers ( &lt;a href=&quot;http://akarnokd.blogspot.hu/2015/05/schedulers-part-1.html&quot;&gt;parte 1&lt;/a&gt; ) ( &lt;a href=&quot;http://akarnokd.blogspot.hu/2015/06/schedulers-part-2.html&quot;&gt;parte 2&lt;/a&gt; ) ( &lt;a href=&quot;http://akarnokd.blogspot.hu/2015/06/schedulers-part-3.html&quot;&gt;parte 3&lt;/a&gt; ) ( &lt;a href=&quot;http://akarnokd.blogspot.hu/2015/06/schedulers-part-4-final.html&quot;&gt;parte 4&lt;/a&gt; ) por D&amp;aacute;vid Karnok</target>
        </trans-unit>
        <trans-unit id="2da723bb85690e2a91f692590ad213ef381dda90" translate="yes" xml:space="preserve">
          <source>Advanced RxJava: Schedulers (&lt;a href=&quot;https://akarnokd.blogspot.hu/2015/05/schedulers-part-1.html&quot;&gt;part 1&lt;/a&gt;) (&lt;a href=&quot;https://akarnokd.blogspot.hu/2015/06/schedulers-part-2.html&quot;&gt;part 2&lt;/a&gt;) (&lt;a href=&quot;https://akarnokd.blogspot.hu/2015/06/schedulers-part-3.html&quot;&gt;part 3&lt;/a&gt;) (&lt;a href=&quot;https://akarnokd.blogspot.hu/2015/06/schedulers-part-4-final.html&quot;&gt;part 4&lt;/a&gt;) by D&amp;aacute;vid Karnok</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cf48d7677040c3e9d2bf95bb0839fd2703291b5" translate="yes" xml:space="preserve">
          <source>Alias for Map</source>
          <target state="translated">Alias para el mapa</target>
        </trans-unit>
        <trans-unit id="4ba6cd005270d28a5da0365e14fbe1da3cdff860" translate="yes" xml:space="preserve">
          <source>Alias for filter</source>
          <target state="translated">Alias para el filtro</target>
        </trans-unit>
        <trans-unit id="2c0fb5d23e5194856f864607d264c2dcc4f20d1e" translate="yes" xml:space="preserve">
          <source>Alias for flatMap</source>
          <target state="translated">Alias para flatMap</target>
        </trans-unit>
        <trans-unit id="6a72085653e4c5be8c7640c868ef787cbcf063d1" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">All</target>
        </trans-unit>
        <trans-unit id="c80ac46ff1f8aeeb94f7a8999a13b0a1e6062b2c" translate="yes" xml:space="preserve">
          <source>Also in the &lt;code&gt;StringObservable&lt;/code&gt; class that is not part of the RxGroovy core there is a specialty mapping operator called &lt;code&gt;byLine&lt;/code&gt;, that transforms an Observable that emits strings into an Observable that emits lines of text, by buffering the strings from the source Observable until a line-feed is found in one of them.</source>
          <target state="translated">Tambi&amp;eacute;n en la clase &lt;code&gt;StringObservable&lt;/code&gt; que no es parte del n&amp;uacute;cleo de RxGroovy hay un operador de mapeo especializado llamado &lt;code&gt;byLine&lt;/code&gt; , que transforma un Observable que emite cadenas en un Observable que emite l&amp;iacute;neas de texto, almacenando en b&amp;uacute;fer las cadenas desde el Observable fuente hasta una l&amp;iacute;nea- el pienso se encuentra en uno de ellos.</target>
        </trans-unit>
        <trans-unit id="9b4f6274689c272bebb2b489085539520b4a1e6a" translate="yes" xml:space="preserve">
          <source>Also in the &lt;code&gt;StringObservable&lt;/code&gt; class that is not part of the RxJava core there is a specialty mapping operator called &lt;code&gt;byLine&lt;/code&gt;, that transforms an Observable that emits strings into an Observable that emits lines of text, by buffering the strings from the source Observable until a line-feed is found in one of them.</source>
          <target state="translated">Tambi&amp;eacute;n en la clase &lt;code&gt;StringObservable&lt;/code&gt; que no es parte del n&amp;uacute;cleo de RxJava hay un operador de mapeo especializado llamado &lt;code&gt;byLine&lt;/code&gt; , que transforma un Observable que emite cadenas en un Observable que emite l&amp;iacute;neas de texto, almacenando en b&amp;uacute;fer las cadenas desde el Observable fuente hasta una l&amp;iacute;nea- el pienso se encuentra en uno de ellos.</target>
        </trans-unit>
        <trans-unit id="9dd5794be8096ff7869d94f283eedcf7b7672bb9" translate="yes" xml:space="preserve">
          <source>Amb</source>
          <target state="translated">Amb</target>
        </trans-unit>
        <trans-unit id="851ac2f8e49b2f26ad526a214ceca7b96c49f162" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;AsyncSubject&lt;/code&gt; emits the last value (and only the last value) emitted by the source Observable, and only after that source Observable completes. (If the source Observable does not emit any values, the &lt;code&gt;AsyncSubject&lt;/code&gt; also completes without emitting any values.)</source>
          <target state="translated">Un &lt;code&gt;AsyncSubject&lt;/code&gt; emite el &amp;uacute;ltimo valor (y solo el &amp;uacute;ltimo valor) emitido por la fuente Observable, y solo despu&amp;eacute;s de que se complete la fuente Observable. (Si la fuente Observable no emite ning&amp;uacute;n valor, &lt;code&gt;AsyncSubject&lt;/code&gt; tambi&amp;eacute;n se completa sin emitir ning&amp;uacute;n valor).</target>
        </trans-unit>
        <trans-unit id="7cd649dc1e5fe644141b9e448ab2c1ac4a152926" translate="yes" xml:space="preserve">
          <source>An Alphabetical List of Observable Operators</source>
          <target state="translated">Una lista alfabética de operadores observables</target>
        </trans-unit>
        <trans-unit id="2839cacd293e99aa08485d95a5eaad72408dc3f8" translate="yes" xml:space="preserve">
          <source>An Observable calls this method after it has called &lt;code&gt;onNext&lt;/code&gt; for the final time, if it has not encountered any errors.</source>
          <target state="translated">Un Observable llama a este m&amp;eacute;todo despu&amp;eacute;s de haber llamado a &lt;code&gt;onNext&lt;/code&gt; por &amp;uacute;ltima vez, si no ha encontrado ning&amp;uacute;n error.</target>
        </trans-unit>
        <trans-unit id="2ea9db047d5da0996289f4901a31c06634ef96eb" translate="yes" xml:space="preserve">
          <source>An Observable calls this method to indicate that it has failed to generate the expected data or has encountered some other error. It will not make further calls to &lt;code&gt;onNext&lt;/code&gt; or &lt;code&gt;onCompleted&lt;/code&gt;. The &lt;code&gt;onError&lt;/code&gt; method takes as its parameter an indication of what caused the error.</source>
          <target state="translated">Un Observable llama a este m&amp;eacute;todo para indicar que no ha podido generar los datos esperados o que ha encontrado alg&amp;uacute;n otro error. No realizar&amp;aacute; m&amp;aacute;s llamadas a &lt;code&gt;onNext&lt;/code&gt; o &lt;code&gt;onCompleted&lt;/code&gt; . El m&amp;eacute;todo &lt;code&gt;onError&lt;/code&gt; toma como par&amp;aacute;metro una indicaci&amp;oacute;n de la causa del error.</target>
        </trans-unit>
        <trans-unit id="42c53d34a4f49cf4f5df1fa4953366bbd8ebe91d" translate="yes" xml:space="preserve">
          <source>An Observable calls this method to indicate that it has failed to generate the expected data or has encountered some other error. This stops the Observable and it will not make further calls to &lt;code&gt;onNext&lt;/code&gt; or &lt;code&gt;onCompleted&lt;/code&gt;. The &lt;code&gt;onError&lt;/code&gt; method takes as its parameter an indication of what caused the error (sometimes an object like an Exception or Throwable, other times a simple string, depending on the implementation).</source>
          <target state="translated">Un Observable llama a este m&amp;eacute;todo para indicar que no ha podido generar los datos esperados o que ha encontrado alg&amp;uacute;n otro error. Esto detiene el Observable y no har&amp;aacute; m&amp;aacute;s llamadas a &lt;code&gt;onNext&lt;/code&gt; o &lt;code&gt;onCompleted&lt;/code&gt; . El m&amp;eacute;todo &lt;code&gt;onError&lt;/code&gt; toma como par&amp;aacute;metro una indicaci&amp;oacute;n de la causa del error (a veces un objeto como una Excepci&amp;oacute;n o Throwable, otras veces una cadena simple, dependiendo de la implementaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="74d2f09477c8a4f1394bf039fd16d24d7fa53421" translate="yes" xml:space="preserve">
          <source>An Observable calls this method whenever the Observable emits an item. This method takes as a parameter the item emitted by the Observable.</source>
          <target state="translated">Un Observador llama a este método siempre que el Observador emite un artículo.Este método toma como parámetro el elemento emitido por el Observable.</target>
        </trans-unit>
        <trans-unit id="16a9dcd358629f823cb0ef4d649474083b6c5bb3" translate="yes" xml:space="preserve">
          <source>An Observable communicates with its observers with the following</source>
          <target state="translated">Un Observador se comunica con sus observadores con lo siguiente</target>
        </trans-unit>
        <trans-unit id="6a76c3a98e43666ea0eb0740c08e3a7cbd79ab65" translate="yes" xml:space="preserve">
          <source>An Observable is called a &amp;ldquo;cold&amp;rdquo; Observable if it does not begin to emit items until an observer has subscribed to it; an Observable is called a &amp;ldquo;hot&amp;rdquo; Observable if it may begin emitting items at any time, and a subscriber may begin observing the sequence of emitted items at some point after its commencement, missing out on any items emitted previously to the time of the subscription.</source>
          <target state="translated">Un Observable se denomina Observable &amp;ldquo;fr&amp;iacute;o&amp;rdquo; si no comienza a emitir elementos hasta que un observador se haya suscrito a &amp;eacute;l; un Observable se denomina Observable &quot;caliente&quot; si puede comenzar a emitir elementos en cualquier momento, y un suscriptor puede comenzar a observar la secuencia de elementos emitidos en alg&amp;uacute;n momento despu&amp;eacute;s de su comienzo, perdiendo cualquier elemento emitido previamente al momento de la suscripci&amp;oacute;n .</target>
        </trans-unit>
        <trans-unit id="d7bf7c542baf1867dd7cef5a402b7db67b5190bd" translate="yes" xml:space="preserve">
          <source>An Observable is the asynchronous/push &lt;a href=&quot;http://en.wikipedia.org/wiki/Dual_(category_theory)&quot;&gt;&amp;ldquo;dual&amp;rdquo;&lt;/a&gt; to the synchronous/pull Iterable</source>
          <target state="translated">Un Observable es el asincr&amp;oacute;nico / push &lt;a href=&quot;http://en.wikipedia.org/wiki/Dual_(category_theory)&quot;&gt;&quot;dual&quot;&lt;/a&gt; al s&amp;iacute;ncrono / pull Iterable</target>
        </trans-unit>
        <trans-unit id="cb13486a1c65cc1a873f5114a61e7ce2d85fd09a" translate="yes" xml:space="preserve">
          <source>An Observable is the asynchronous/push &lt;a href=&quot;https://en.wikipedia.org/wiki/Dual_(category_theory)&quot;&gt;&amp;ldquo;dual&amp;rdquo;&lt;/a&gt; to the synchronous/pull Iterable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbafffea1979fbff2b9d19c9947eecf861d10073" translate="yes" xml:space="preserve">
          <source>An Observable may begin issuing notifications to an observer immediately after the Observable receives a Subscribe notification from the observer.</source>
          <target state="translated">Un Observador puede comenzar a emitir notificaciones a un observador inmediatamente después de recibir una notificación de suscripción del observador.</target>
        </trans-unit>
        <trans-unit id="a7c3d8f2d0e01af84eba974448d28b40c4172a8e" translate="yes" xml:space="preserve">
          <source>An Observable may emit no items at all. An Observable may also never terminate with either an OnCompleted or an OnError notification. That is to say that it is proper for an Observable to issue no notifications, to issue only an OnCompleted or an OnError notification, or to issue only OnNext notifications.</source>
          <target state="translated">Un observable puede no emitir ningún artículo.Un observable tampoco puede terminar nunca con una notificación de un error o de una terminación.Es decir,es apropiado que un Observador no emita ninguna notificación,que emita sólo una notificación de &quot;OnCompletado&quot; o &quot;OnError&quot;,o que sólo emita notificaciones &quot;OnNext&quot;.</target>
        </trans-unit>
        <trans-unit id="cf2b11572810d9a5ac8311dae558136ea173beb4" translate="yes" xml:space="preserve">
          <source>An Observable may make zero or more OnNext notifications, each representing a single emitted item, and it may then follow those emission notifications by either an OnCompleted or an OnError notification, but not both. Upon issuing an OnCompleted or OnError notification, it may not thereafter issue any further notifications.</source>
          <target state="translated">Un Observable puede hacer cero o más notificaciones de OnNext,cada una de las cuales representa un solo elemento emitido,y puede seguir esas notificaciones de emisión por una notificación de OnCompletado o de OnError,pero no ambas.Al emitir una notificación de &quot;OnCompleted&quot; o &quot;OnError&quot;,no podrá emitir posteriormente ninguna otra notificación.</target>
        </trans-unit>
        <trans-unit id="645e6d39de346178f5938830b549355de0e6e3e5" translate="yes" xml:space="preserve">
          <source>An Observable that does not implement backpressure should respond to a Request notification from an observer by issuing an OnError notification that indicates that backpressure is not supported.</source>
          <target state="translated">Un observador que no aplique la contrapresión debe responder a una notificación de solicitud de un observador emitiendo una notificación OnError que indique que no se apoya la contrapresión.</target>
        </trans-unit>
        <trans-unit id="689703d4ac79bcdd377cfb6c92ab325f0021d3b4" translate="yes" xml:space="preserve">
          <source>An OnError notification must contain the cause of the error (that is to say, it is invalid to call OnError with a &lt;code&gt;null&lt;/code&gt; value).</source>
          <target state="translated">Una notificaci&amp;oacute;n de OnError debe contener la causa del error (es decir, no es v&amp;aacute;lido llamar a OnError con un valor &lt;code&gt;null&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0ff87217adf75afaa1c6885b1ac6c1d5742a3cbd" translate="yes" xml:space="preserve">
          <source>An advantage of this approach is that when you have a bunch of tasks that are not dependent on each other, you can start them all at the same time rather than waiting for each one to finish before starting the next one &amp;mdash; that way, your entire bundle of tasks only takes as long to complete as the longest task in the bundle.</source>
          <target state="translated">Una ventaja de este enfoque es que cuando tienes un mont&amp;oacute;n de tareas que no dependen unas de otras, puedes comenzarlas todas al mismo tiempo en lugar de esperar a que cada una termine antes de comenzar la siguiente; de ​​esa manera, toda tu El paquete de tareas solo tarda tanto en completarse como la tarea m&amp;aacute;s larga del paquete.</target>
        </trans-unit>
        <trans-unit id="d85814a55f42e0261226556859d609d250a378ba" translate="yes" xml:space="preserve">
          <source>An even simpler operator in the optional &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; package (also not part of the standard RxGroovy set of operators) is &lt;code&gt;ifThen&lt;/code&gt;. This operator checks a condition and then either mirrors the source Observable or an empty Observable depending on the result.</source>
          <target state="translated">Un operador a&amp;uacute;n m&amp;aacute;s simple en el &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; opcional rxjava-computation-expression (que tampoco forma parte del conjunto est&amp;aacute;ndar de operadores &lt;code&gt;ifThen&lt;/code&gt; ) es ifThen . Este operador verifica una condici&amp;oacute;n y luego refleja la fuente Observable o un Observable vac&amp;iacute;o, seg&amp;uacute;n el resultado.</target>
        </trans-unit>
        <trans-unit id="0f829bc7f8186b73be4fd6d24d31abb651902daa" translate="yes" xml:space="preserve">
          <source>An observer communicates with its Observable by means of the following notifications:</source>
          <target state="translated">Un observador se comunica con su Observador mediante las siguientes notificaciones:</target>
        </trans-unit>
        <trans-unit id="6c74c14e78b3bf3709270805f239144c3e35aa94" translate="yes" xml:space="preserve">
          <source>An optional third parameter (named &lt;code&gt;defaultValue&lt;/code&gt;) allows you to choose an item that &lt;code&gt;first&lt;/code&gt; will emit if the source Observable does not emit any items (or if it does not emit the</source>
          <target state="translated">Un tercer par&amp;aacute;metro opcional (llamado &lt;code&gt;defaultValue&lt;/code&gt; ) le permite elegir un elemento que &lt;code&gt;first&lt;/code&gt; se emitir&amp;aacute; si la fuente Observable no emite ning&amp;uacute;n elemento (o si no emite el</target>
        </trans-unit>
        <trans-unit id="e16bafd99d71f935206c53ee2503366667c35c3c" translate="yes" xml:space="preserve">
          <source>And importantly: with ReactiveX you can later change your mind, and radically change the underlying nature of your Observable implementation, without breaking the consumers of your Observable.</source>
          <target state="translated">Y lo que es más importante:con ReactiveX puede cambiar de opinión más tarde,y cambiar radicalmente la naturaleza subyacente de su implementación de Observable,sin romper los consumidores de su Observable.</target>
        </trans-unit>
        <trans-unit id="214cbe57ae28db943c3ec9b46b47b3101daf0c7b" translate="yes" xml:space="preserve">
          <source>And that variant also has a cousin that will switch to a specified backup Observable rather than emitting an error upon hitting a timeout condition.</source>
          <target state="translated">Y esa variante también tiene un primo que cambiará a una copia de seguridad especificada Observable en lugar de emitir un error al alcanzar una condición de tiempo de espera.</target>
        </trans-unit>
        <trans-unit id="6fd733cd8e342ef935e8375aac0d129d8c255f6b" translate="yes" xml:space="preserve">
          <source>And there is a variant of &lt;code&gt;delaySubscription&lt;/code&gt; that uses an Observable (returned by a function you supply) rather than a fixed duration in order to set the subscription delay.</source>
          <target state="translated">Y hay una variante de &lt;code&gt;delaySubscription&lt;/code&gt; que utiliza un Observable (devuelto por una funci&amp;oacute;n que usted proporciona) en lugar de una duraci&amp;oacute;n fija para establecer el retraso de la suscripci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d8ee68728e1626f87277753fcdb831fc09c7b3d5" translate="yes" xml:space="preserve">
          <source>And there is also a verion of &lt;code&gt;singleOrDefault&lt;/code&gt; that takes a predicate function and emits the sole item from the source Observable that matches that predicate, if any; the default item if no such items match; and makes an error notification if multiple items match.</source>
          <target state="translated">Y tambi&amp;eacute;n hay una versi&amp;oacute;n de &lt;code&gt;singleOrDefault&lt;/code&gt; que toma una funci&amp;oacute;n de predicado y emite el &amp;uacute;nico elemento de la fuente Observable que coincide con ese predicado, si lo hay; el elemento predeterminado si ninguno de esos elementos coincide; y realiza una notificaci&amp;oacute;n de error si coinciden varios elementos.</target>
        </trans-unit>
        <trans-unit id="f667a90816681f20bf11089e389629e58978843f" translate="yes" xml:space="preserve">
          <source>And there is also a verion of &lt;code&gt;singleOrDefault&lt;/code&gt; that takes a predicate function and returns the sole item from the source Observable that matches that predicate, if any; the default item if no such items match; and throws an error if multiple items match.</source>
          <target state="translated">Y tambi&amp;eacute;n hay una versi&amp;oacute;n de &lt;code&gt;singleOrDefault&lt;/code&gt; que toma una funci&amp;oacute;n de predicado y devuelve el &amp;uacute;nico elemento de la fuente Observable que coincide con ese predicado, si lo hay; el elemento predeterminado si ninguno de esos elementos coincide; y arroja un error si coinciden varios elementos.</target>
        </trans-unit>
        <trans-unit id="10883d7bc99bd25d1b6cd9f78cf866a8856bbf98" translate="yes" xml:space="preserve">
          <source>And, as with &lt;code&gt;first&lt;/code&gt;, there is a &lt;code&gt;firstOrDefault&lt;/code&gt; variant that takes a predicate function as an argument and retrieves the first item from the source &lt;code&gt;BlockingObservable&lt;/code&gt; that satisfies that predicate, or a default item instead if no satisfying item was emitted.</source>
          <target state="translated">Y, al igual que con el &lt;code&gt;first&lt;/code&gt; , hay una variante &lt;code&gt;firstOrDefault&lt;/code&gt; que toma una funci&amp;oacute;n de predicado como argumento y recupera el primer elemento de la fuente &lt;code&gt;BlockingObservable&lt;/code&gt; que satisface ese predicado, o un elemento predeterminado en su lugar si no se emiti&amp;oacute; ning&amp;uacute;n elemento satisfactorio.</target>
        </trans-unit>
        <trans-unit id="b61cf36b9bbc9f1f59d3790764d487afdbb2624c" translate="yes" xml:space="preserve">
          <source>And, as with &lt;code&gt;first&lt;/code&gt;, there is a &lt;code&gt;firstOrDefault&lt;/code&gt; variant that takes a predicate function as an argument and returns the first item from the source &lt;code&gt;BlockingObservable&lt;/code&gt; that satisfies that predicate, or a default item instead if no satisfying item was emitted.</source>
          <target state="translated">Y, al igual que con el &lt;code&gt;first&lt;/code&gt; , hay una variante &lt;code&gt;firstOrDefault&lt;/code&gt; que toma una funci&amp;oacute;n de predicado como argumento y devuelve el primer elemento de la fuente &lt;code&gt;BlockingObservable&lt;/code&gt; que satisface ese predicado, o un elemento predeterminado en su lugar si no se emiti&amp;oacute; un elemento satisfactorio.</target>
        </trans-unit>
        <trans-unit id="5d569317120812ad4b1a0a46c5a1a37fce2c43e2" translate="yes" xml:space="preserve">
          <source>And, as with &lt;code&gt;last&lt;/code&gt;, there is a &lt;code&gt;lastOrDefault&lt;/code&gt; variant that takes a predicate function as an argument and retrieves the last item from the source &lt;code&gt;BlockingObservable&lt;/code&gt; that satisfies that predicate, or a default item instead if no satisfying item was emitted.</source>
          <target state="translated">Y, como con el &lt;code&gt;last&lt;/code&gt; , hay una variante &lt;code&gt;lastOrDefault&lt;/code&gt; que toma una funci&amp;oacute;n de predicado como argumento y recupera el &amp;uacute;ltimo elemento de la fuente &lt;code&gt;BlockingObservable&lt;/code&gt; que satisface ese predicado, o un elemento predeterminado en su lugar si no se emiti&amp;oacute; un elemento satisfactorio.</target>
        </trans-unit>
        <trans-unit id="8251dbbd4d407b2ba611d6bab161e9f49c31af8d" translate="yes" xml:space="preserve">
          <source>And/Then/When</source>
          <target state="translated">And/Then/When</target>
        </trans-unit>
        <trans-unit id="5e3f7fc4502eaa43261cf03af6ffe0dd602b81e7" translate="yes" xml:space="preserve">
          <source>Another variant allows you to instruct &lt;code&gt;timeout&lt;/code&gt; to switch to a backup Observable that you specify, rather than terminating with an error, if the timeout condition is triggered. To use this variant, pass the backup Observable (or &lt;code&gt;Promise&lt;/code&gt;) as the second parameter to &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">Otra variante le permite indicar el &lt;code&gt;timeout&lt;/code&gt; de espera para cambiar a una copia de seguridad Observable que especifique, en lugar de terminar con un error, si se activa la condici&amp;oacute;n de tiempo de espera. Para utilizar esta variante, pase la copia de seguridad Observable (o &lt;code&gt;Promise&lt;/code&gt; ) como segundo par&amp;aacute;metro para el &lt;code&gt;timeout&lt;/code&gt; de espera .</target>
        </trans-unit>
        <trans-unit id="e0a94542011650405c857cbde913a1b92445107e" translate="yes" xml:space="preserve">
          <source>Another variant of &lt;code&gt;Retry&lt;/code&gt; takes a single parameter: a count of the number of &lt;code&gt;onError&lt;/code&gt; notification it should be willing to accept before it too fails and passes the &lt;code&gt;onError&lt;/code&gt; to its observers. For example, &lt;code&gt;Retry(2)&lt;/code&gt; means that &lt;code&gt;Retry&lt;/code&gt; will resubscribe to and mirror the source Observable the first time it receives an &lt;code&gt;onError&lt;/code&gt; notification, but will terminate with an error the second time this happens.</source>
          <target state="translated">Otra variante de &lt;code&gt;Retry&lt;/code&gt; toma un solo par&amp;aacute;metro: un recuento del n&amp;uacute;mero de notificaciones &lt;code&gt;onError&lt;/code&gt; que deber&amp;iacute;a estar dispuesto a aceptar antes de que tambi&amp;eacute;n falle y pase el &lt;code&gt;onError&lt;/code&gt; a sus observadores. Por ejemplo, &lt;code&gt;Retry(2)&lt;/code&gt; significa que &lt;code&gt;Retry&lt;/code&gt; se volver&amp;aacute; a suscribir y reflejar&amp;aacute; la fuente Observable la primera vez que reciba una notificaci&amp;oacute;n &lt;code&gt;onError&lt;/code&gt; , pero terminar&amp;aacute; con un error la segunda vez que esto suceda.</target>
        </trans-unit>
        <trans-unit id="02efaeb4d2bdd19b23fcdfa7078d0965b0543f39" translate="yes" xml:space="preserve">
          <source>Another variant of &lt;code&gt;delay&lt;/code&gt; does not use a constant delay duration, but sets its delay duration on a per-item basis by passing each item from the source Observable into a function that returns an Observable and then monitoring those Observables. When any such Observable emits a item or completes, the Observable returned by &lt;code&gt;delay&lt;/code&gt; emits the associated item.</source>
          <target state="translated">Otra variante de &lt;code&gt;delay&lt;/code&gt; no usa una duraci&amp;oacute;n de retraso constante, sino que establece su duraci&amp;oacute;n de retraso por art&amp;iacute;culo pasando cada art&amp;iacute;culo del Observable de origen a una funci&amp;oacute;n que devuelve un Observable y luego monitorea esos Observables. Cuando cualquier Observable emite un elemento o se completa, el Observable devuelto por &lt;code&gt;delay&lt;/code&gt; emite el elemento asociado.</target>
        </trans-unit>
        <trans-unit id="f2cb02c7b8b0dc8585c179d8f7a980076f44300b" translate="yes" xml:space="preserve">
          <source>Another variant of &lt;code&gt;delay&lt;/code&gt; does not use a constant delay duration, but sets its delay duration on a per-item basis by passing each item from the source Observable into a function that returns an Observable and then monitoring those Observables. When any such Observable emits an item or completes, the Observable returned by &lt;code&gt;delay&lt;/code&gt; emits the associated item.</source>
          <target state="translated">Otra variante de &lt;code&gt;delay&lt;/code&gt; no usa una duraci&amp;oacute;n de retraso constante, sino que establece su duraci&amp;oacute;n de retraso por art&amp;iacute;culo pasando cada art&amp;iacute;culo del Observable de origen a una funci&amp;oacute;n que devuelve un Observable y luego monitorea esos Observables. Cuando cualquier Observable emite un elemento o se completa, el Observable devuelto por &lt;code&gt;delay&lt;/code&gt; emite el elemento asociado.</target>
        </trans-unit>
        <trans-unit id="18e4f38385f3555737f4cc37f65db6f2b2cb3f98" translate="yes" xml:space="preserve">
          <source>Another variant of &lt;code&gt;retry&lt;/code&gt; takes a single parameter: a count of the number of &lt;code&gt;onError&lt;/code&gt; notification it should be willing to accept before it too fails and passes the &lt;code&gt;onError&lt;/code&gt; to its observers. For example, &lt;code&gt;retry(2)&lt;/code&gt; means that &lt;code&gt;retry&lt;/code&gt; will resubscribe to and mirror the source Observable the first time it receives an &lt;code&gt;onError&lt;/code&gt; notification, but will terminate with an error the second time this happens.</source>
          <target state="translated">Otra variante de &lt;code&gt;retry&lt;/code&gt; toma un solo par&amp;aacute;metro: un recuento del n&amp;uacute;mero de notificaciones de &lt;code&gt;onError&lt;/code&gt; que deber&amp;iacute;a estar dispuesto a aceptar antes de que tambi&amp;eacute;n falle y pase el &lt;code&gt;onError&lt;/code&gt; a sus observadores. Por ejemplo, &lt;code&gt;retry(2)&lt;/code&gt; significa que &lt;code&gt;retry&lt;/code&gt; volver&amp;aacute; a suscribirse y reflejar&amp;aacute; la fuente Observable la primera vez que reciba una notificaci&amp;oacute;n &lt;code&gt;onError&lt;/code&gt; , pero terminar&amp;aacute; con un error la segunda vez que esto suceda.</target>
        </trans-unit>
        <trans-unit id="53a31e30b7b7961ac8ac1fd52bd1e592dd652cbb" translate="yes" xml:space="preserve">
          <source>Another variant of &lt;code&gt;retry&lt;/code&gt; takes a single parameter: a count of the number of times it should try to resubscribe to the source Observable when it encounters errors. If this count is exceeded, &lt;code&gt;retry&lt;/code&gt; will not attempt to resubscribe again and will instead pass the latest &lt;code&gt;onError&lt;/code&gt; notification to its observers.</source>
          <target state="translated">Otra variante de &lt;code&gt;retry&lt;/code&gt; toma un solo par&amp;aacute;metro: un recuento de la cantidad de veces que deber&amp;iacute;a intentar volver a suscribirse a la fuente Observable cuando encuentra errores. Si se supera este recuento, el &lt;code&gt;retry&lt;/code&gt; no intentar&amp;aacute; volver a suscribirse y, en su lugar, pasar&amp;aacute; la &amp;uacute;ltima notificaci&amp;oacute;n de &lt;code&gt;onError&lt;/code&gt; a sus observadores.</target>
        </trans-unit>
        <trans-unit id="180c4e210c4586ad6515a4efe0a7bfdaf14fb209" translate="yes" xml:space="preserve">
          <source>Another version combines items from the source Observable with the Observable triggered by those source items, and emits these combinations.</source>
          <target state="translated">Otra versión combina elementos de la fuente Observable con la Observable activada por esos elementos de la fuente,y emite esas combinaciones.</target>
        </trans-unit>
        <trans-unit id="9c3e74fdeb39fa8f79f8b41f914729603db3668b" translate="yes" xml:space="preserve">
          <source>Another version of &lt;code&gt;flatMap&lt;/code&gt; creates (and flattens) a new Observable for each item &lt;em&gt;and notification&lt;/em&gt; from the source Observable.</source>
          <target state="translated">Otra versi&amp;oacute;n de &lt;code&gt;flatMap&lt;/code&gt; crea (y aplana) un nuevo Observable para cada elemento &lt;em&gt;y notificaci&amp;oacute;n&lt;/em&gt; de la fuente Observable.</target>
        </trans-unit>
        <trans-unit id="416f48df8cc3910b8bb048511d0a6e4801002873" translate="yes" xml:space="preserve">
          <source>Another version of &lt;code&gt;groupBy&lt;/code&gt; allows you to pass in a transformative function that changes the elements before they are emitted by the resulting &lt;code&gt;GroupedObservable&lt;/code&gt;s.</source>
          <target state="translated">Otra versi&amp;oacute;n de &lt;code&gt;groupBy&lt;/code&gt; le permite pasar una funci&amp;oacute;n transformadora que cambia los elementos antes de que sean emitidos por los &lt;code&gt;GroupedObservable&lt;/code&gt; resultantes .</target>
        </trans-unit>
        <trans-unit id="6cbe5dee754659834a3070a07a4de32cd17c626d" translate="yes" xml:space="preserve">
          <source>Another version takes two or more Singles and merges them into an Observable that emits the items emitted by the source Singles (in an arbitrary order):</source>
          <target state="translated">Otra versión toma dos o más Singles y los fusiona en un Observable que emite los elementos emitidos por los Singles de origen (en un orden arbitrario):</target>
        </trans-unit>
        <trans-unit id="5fc07229ca716771de12a56cf5816c03a72ab3bb" translate="yes" xml:space="preserve">
          <source>Applies an accumulator function over an observable sequence and returns each intermediate result. The optional seed value is used as the initial accumulator value.</source>
          <target state="translated">Aplica una función de acumulador sobre una secuencia observable y devuelve cada resultado intermedio.El valor de semilla opcional se utiliza como valor inicial del acumulador.</target>
        </trans-unit>
        <trans-unit id="e968236df359a0c3a3b48d1101e20c7334bc87e3" translate="yes" xml:space="preserve">
          <source>Applies an accumulator function over an observable sequence, returning the result of the aggregation as a single element in the result sequence. The specified seed value is used as the initial accumulator value.</source>
          <target state="translated">Aplica una función de acumulador sobre una secuencia observable,devolviendo el resultado de la agregación como un solo elemento en la secuencia de resultados.El valor de semilla especificado se utiliza como valor inicial del acumulador.</target>
        </trans-unit>
        <trans-unit id="6482ebf54fcf3fef454ac6beb793ddcb408e9393" translate="yes" xml:space="preserve">
          <source>As an alternative to using &lt;code&gt;request&lt;/code&gt; to pull items from a &lt;code&gt;ControlledObservable&lt;/code&gt;, you may apply the &lt;code&gt;stopAndWait&lt;/code&gt; operator to it. This operator will request a new item from the Observable each time its observers&amp;rsquo; &lt;code&gt;onNext&lt;/code&gt; routine receives the latest item.</source>
          <target state="translated">Como alternativa al uso de &lt;code&gt;request&lt;/code&gt; para extraer elementos de un &lt;code&gt;ControlledObservable&lt;/code&gt; , puede aplicarle el operador &lt;code&gt;stopAndWait&lt;/code&gt; . Este operador solicitar&amp;aacute; un nuevo art&amp;iacute;culo al Observable cada vez que la rutina &lt;code&gt;onNext&lt;/code&gt; de sus observadores reciba el &amp;uacute;ltimo art&amp;iacute;culo.</target>
        </trans-unit>
        <trans-unit id="3e2402a383d153594ac341c580a389f352b429f3" translate="yes" xml:space="preserve">
          <source>As shown in the above diagram, an &lt;code&gt;onError&lt;/code&gt; notification from any of the source Observables will immediately be passed through to observers and will terminate the merged Observable.</source>
          <target state="translated">Como se muestra en el diagrama anterior, una notificaci&amp;oacute;n de &lt;code&gt;onError&lt;/code&gt; de cualquiera de los Observables de origen se pasar&amp;aacute; inmediatamente a los observadores y terminar&amp;aacute; el Observable fusionado.</target>
        </trans-unit>
        <trans-unit id="2944d9f0e54e8337eac2b3e9e3efb8980e22c066" translate="yes" xml:space="preserve">
          <source>As shown in this illustration, the SubscribeOn operator designates which thread the Observable will begin operating on, no matter at what point in the chain of operators that operator is called. ObserveOn, on the other hand, affects the thread that the Observable will use &lt;em&gt;below&lt;/em&gt; where that operator appears. For this reason, you may call ObserveOn multiple times at various points during the chain of Observable operators in order to change on which threads certain of those operators operate.</source>
          <target state="translated">Como se muestra en esta ilustraci&amp;oacute;n, el operador SubscribeOn designa en qu&amp;eacute; hilo comenzar&amp;aacute; a operar el Observable, sin importar en qu&amp;eacute; punto de la cadena de operadores se llame ese operador. ObserveOn, por otro lado, afecta el hilo que el Observable usar&amp;aacute; &lt;em&gt;debajo de&lt;/em&gt; donde aparece ese operador. Por esta raz&amp;oacute;n, puede llamar a ObserveOn varias veces en varios puntos durante la cadena de operadores observables para cambiar en qu&amp;eacute; hilos operan algunos de esos operadores.</target>
        </trans-unit>
        <trans-unit id="90336d424ebddac61136082a2c6d772454fe8231" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;distinct&lt;/code&gt;, there is also a version of &lt;code&gt;distinctUntilChanged&lt;/code&gt; that accepts a key selector function and that uses the resulting key to determine whether or not two adjacently-emitted items are distinct.</source>
          <target state="translated">Como con &lt;code&gt;distinct&lt;/code&gt; , tambi&amp;eacute;n hay una versi&amp;oacute;n de &lt;code&gt;distinctUntilChanged&lt;/code&gt; que acepta una funci&amp;oacute;n de selector de clave y que usa la clave resultante para determinar si dos elementos emitidos de forma adyacente son distintos o no.</target>
        </trans-unit>
        <trans-unit id="ea92b7b4b8b9fa35e6026e8b95b2e25ebb1fc5c4" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;firstOrDefault&lt;/code&gt; there is also a &lt;code&gt;singleOrDefault&lt;/code&gt; that emits a default item if the source Observable is empty, although it will still notify of an error if the source Observable emits more than one item.</source>
          <target state="translated">Al igual que con &lt;code&gt;firstOrDefault&lt;/code&gt; , tambi&amp;eacute;n hay un &lt;code&gt;singleOrDefault&lt;/code&gt; que emite un elemento predeterminado si el Observable de origen est&amp;aacute; vac&amp;iacute;o, aunque seguir&amp;aacute; notificando un error si el Observable de origen emite m&amp;aacute;s de un elemento.</target>
        </trans-unit>
        <trans-unit id="d92ac954f9b7869499152c6f9dac87389cc9d017" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;firstOrDefault&lt;/code&gt; there is also a &lt;code&gt;singleOrDefault&lt;/code&gt; that returns a default item if the source Observable is empty, although it will still throw an error if the source Observable emits more than one item.</source>
          <target state="translated">Al igual que con &lt;code&gt;firstOrDefault&lt;/code&gt; , tambi&amp;eacute;n hay un &lt;code&gt;singleOrDefault&lt;/code&gt; que devuelve un elemento predeterminado si el Observable de origen est&amp;aacute; vac&amp;iacute;o, aunque seguir&amp;aacute; arrojando un error si el Observable de origen emite m&amp;aacute;s de un elemento.</target>
        </trans-unit>
        <trans-unit id="9dca8bd3303f27dee6fa18df112035b5a22c5486" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;flatMap&lt;/code&gt;, &lt;code&gt;concatMap&lt;/code&gt; works just as well if the function you provide transforms items from the source Observables into Observables, into Promises, or into arrays.</source>
          <target state="translated">Al igual que con &lt;code&gt;flatMap&lt;/code&gt; , &lt;code&gt;concatMap&lt;/code&gt; funciona igual de bien si la funci&amp;oacute;n que proporciona transforma los elementos de los Observables de origen en Observables, en Promesas o en matrices.</target>
        </trans-unit>
        <trans-unit id="c6e9229a21e2a7672f82daa0c3b3a03f4a076628" translate="yes" xml:space="preserve">
          <source>As with the filtering operators, the &lt;code&gt;first&lt;/code&gt; method of &lt;code&gt;BlockingObservable&lt;/code&gt; will throw a &lt;code&gt;NoSuchElementException&lt;/code&gt; if there is no first element in the source &lt;code&gt;BlockingObservable&lt;/code&gt;. To return a default item instead in such cases, use the &lt;code&gt;firstOrDefault&lt;/code&gt; method.</source>
          <target state="translated">Al igual que con los operadores de filtrado, el &lt;code&gt;first&lt;/code&gt; m&amp;eacute;todo de &lt;code&gt;BlockingObservable&lt;/code&gt; lanzar&amp;aacute; una &lt;code&gt;NoSuchElementException&lt;/code&gt; si no hay un primer elemento en la fuente &lt;code&gt;BlockingObservable&lt;/code&gt; . Para devolver un art&amp;iacute;culo predeterminado en tales casos, utilice el m&amp;eacute;todo &lt;code&gt;firstOrDefault&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3967a0eb108ca47a2858158ed9dfb9574c5f8ca" translate="yes" xml:space="preserve">
          <source>As with the filtering operators, the &lt;code&gt;last&lt;/code&gt; method of &lt;code&gt;BlockingObservable&lt;/code&gt; will throw a &lt;code&gt;NoSuchElementException&lt;/code&gt; if there is no last element in the source &lt;code&gt;BlockingObservable&lt;/code&gt;. To return a default item instead in such cases, use the &lt;code&gt;lastOrDefault&lt;/code&gt; method.</source>
          <target state="translated">Al igual que con los operadores de filtrado, el &lt;code&gt;last&lt;/code&gt; m&amp;eacute;todo de &lt;code&gt;BlockingObservable&lt;/code&gt; lanzar&amp;aacute; una &lt;code&gt;NoSuchElementException&lt;/code&gt; si no hay un &amp;uacute;ltimo elemento en la fuente &lt;code&gt;BlockingObservable&lt;/code&gt; . Para devolver un art&amp;iacute;culo predeterminado en tales casos, utilice el m&amp;eacute;todo &lt;code&gt;lastOrDefault&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fcf5a04971327e7fdf42936464bd21e8b771ab5" translate="yes" xml:space="preserve">
          <source>Aside from passing these Schedulers in to RxJava Observable operators, you can also use them to schedule your own work on Subscriptions. The following example uses &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Scheduler.Worker.html#schedule(rx.functions.Action0)&quot;&gt;the &lt;code&gt;schedule&lt;/code&gt; method&lt;/a&gt; of &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Scheduler.Worker.html&quot;&gt;the &lt;code&gt;Scheduler.Worker&lt;/code&gt; class&lt;/a&gt; to schedule work on the &lt;code&gt;newThread&lt;/code&gt; Scheduler:</source>
          <target state="translated">Adem&amp;aacute;s de pasar estos programadores a los operadores observables de RxJava, tambi&amp;eacute;n puede usarlos para programar su propio trabajo en las suscripciones. El siguiente ejemplo utiliza &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Scheduler.Worker.html#schedule(rx.functions.Action0)&quot;&gt;el m&amp;eacute;todo &lt;code&gt;schedule&lt;/code&gt; &lt;/a&gt; de programaci&amp;oacute;n de &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Scheduler.Worker.html&quot;&gt;la clase &lt;code&gt;Scheduler.Worker&lt;/code&gt; &lt;/a&gt; para programar el trabajo en el programador &lt;code&gt;newThread&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="81a3a332582f8b7c97ecac0a351df1689bfb7637" translate="yes" xml:space="preserve">
          <source>AsyncSubject</source>
          <target state="translated">AsyncSubject</target>
        </trans-unit>
        <trans-unit id="4cd01c057417c6358415753c1e3270378ba8ff9e" translate="yes" xml:space="preserve">
          <source>At any time after it receives an OnSubscribe notification, an observer may issue a Request notification to the Observable it has subscribed to. This notification requests a particular number of items. The Observable responds to such a Request by emitting no more items to the observer than the number of items the observer requests. However the Observable may, in addition, issue an OnCompleted or OnError notification, and it may even issue such a notification before the observer requests any items at all.</source>
          <target state="translated">En cualquier momento después de recibir una notificación de suscripción,un observador puede emitir una notificación de solicitud al observable al que se ha suscrito.En esta notificación se solicita un número determinado de elementos.El Observador responde a dicha Solicitud emitiendo no más elementos al observador que el número de elementos que éste solicita.Sin embargo,el Observatorio puede,además,emitir una notificación de &quot;en curso&quot; o &quot;en error&quot;,e incluso puede emitir dicha notificación antes de que el observador solicite ningún elemento.</target>
        </trans-unit>
        <trans-unit id="8a7c2b7fecd45fc8d48965e405aa02103af88d8a" translate="yes" xml:space="preserve">
          <source>Attach the observer to that Observable by</source>
          <target state="translated">Atribuya el observador a ese Observable por</target>
        </trans-unit>
        <trans-unit id="15f86c051ecf0b64e5f8cdc8c689552f42595942" translate="yes" xml:space="preserve">
          <source>Average</source>
          <target state="translated">Average</target>
        </trans-unit>
        <trans-unit id="64dd60fe1a049fe6db3eb1369dec2e42bf428e21" translate="yes" xml:space="preserve">
          <source>Background</source>
          <target state="translated">Background</target>
        </trans-unit>
        <trans-unit id="bfded4a21da8efbb2fa839d4b2207399ba6ad7be" translate="yes" xml:space="preserve">
          <source>Backpressure</source>
          <target state="translated">Backpressure</target>
        </trans-unit>
        <trans-unit id="35262f52104832142bf6755bccc1f3e12433d190" translate="yes" xml:space="preserve">
          <source>Backpressure Operators</source>
          <target state="translated">Operadores de contrapresión</target>
        </trans-unit>
        <trans-unit id="d2eb3d3593072fa90c30c72ab2ea8bae6bdb0314" translate="yes" xml:space="preserve">
          <source>Backpressure is optional; not all ReactiveX implementations include backpressure, and in those that do, not all Observables or operators honor backpressure. An Observable &lt;em&gt;may&lt;/em&gt; implement backpressure if it detects that its observer implements</source>
          <target state="translated">La contrapresi&amp;oacute;n es opcional; no todas las implementaciones de ReactiveX incluyen contrapresi&amp;oacute;n, y en aquellas que lo hacen, no todos los Observables u operadores respetan la contrapresi&amp;oacute;n. Un Observable &lt;em&gt;puede&lt;/em&gt; implementar contrapresi&amp;oacute;n si detecta que su observador implementa</target>
        </trans-unit>
        <trans-unit id="c17bead9671f0fa78aeae30852ed269b9a2823ed" translate="yes" xml:space="preserve">
          <source>Backpressure-related Operators</source>
          <target state="translated">Operadores relacionados con la contrapresión</target>
        </trans-unit>
        <trans-unit id="430ace144fb8a573f293eacace0939475b0d212a" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;onErrorFlatMap&lt;/code&gt; is designed to work with pathological source Observables that do not terminate after issuing an error, it is mostly useful in debugging/testing scenarios.</source>
          <target state="translated">Debido a que &lt;code&gt;onErrorFlatMap&lt;/code&gt; est&amp;aacute; dise&amp;ntilde;ado para trabajar con Observables de origen patol&amp;oacute;gico que no terminan despu&amp;eacute;s de emitir un error, es principalmente &amp;uacute;til en escenarios de depuraci&amp;oacute;n / prueba.</target>
        </trans-unit>
        <trans-unit id="fd066d9d682432c2ab720b8c76cae63bcdae1811" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;runAsync&lt;/code&gt; immediately invokes the &lt;code&gt;Action&lt;/code&gt; and begins emitting the items (that is, it produces a &lt;em&gt;hot&lt;/em&gt; Observable), it is possible that some items may be lost in the interval between when you establish the &lt;code&gt;StoppableObservable&lt;/code&gt; with this operator and when your &lt;code&gt;Observer&lt;/code&gt; is ready to receive items. If this is a problem, you can use the variant of &lt;code&gt;runAsync&lt;/code&gt; that also accepts a &lt;code&gt;Subject&lt;/code&gt; and pass a &lt;code&gt;ReplaySubject&lt;/code&gt; with which you can retrieve the otherwise-missing items.</source>
          <target state="translated">Debido a que &lt;code&gt;runAsync&lt;/code&gt; invoca inmediatamente la &lt;code&gt;Action&lt;/code&gt; y comienza a emitir los elementos (es decir, produce un Observable &lt;em&gt;caliente&lt;/em&gt; ), es posible que algunos elementos se pierdan en el intervalo entre el momento en que establece el &lt;code&gt;StoppableObservable&lt;/code&gt; con este operador y cuando su &lt;code&gt;Observer&lt;/code&gt; est&amp;aacute; listo para recibir art&amp;iacute;culos. Si esto es un problema, puede usar la variante de &lt;code&gt;runAsync&lt;/code&gt; que tambi&amp;eacute;n acepta un &lt;code&gt;Subject&lt;/code&gt; y pasar un &lt;code&gt;ReplaySubject&lt;/code&gt; con el que puede recuperar los elementos que de otro modo faltar&amp;iacute;an.</target>
        </trans-unit>
        <trans-unit id="580926df80f2bb9b9ffac06756ddd1d4eed2fe8f" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;runAsync&lt;/code&gt; immediately invokes the &lt;code&gt;Action&lt;/code&gt; and begins emitting the items, it is possible that some items may be lost in the interval between when you establish the &lt;code&gt;StoppableObservable&lt;/code&gt; with this method and when your &lt;code&gt;Observer&lt;/code&gt; is ready to receive items. If this is a problem, you can use the variant of &lt;code&gt;runAsync&lt;/code&gt; that also accepts a &lt;a href=&quot;../subject&quot;&gt;&lt;code&gt;Subject&lt;/code&gt;&lt;/a&gt; and pass a &lt;code&gt;ReplaySubject&lt;/code&gt; with which you can retrieve the otherwise-missing items.</source>
          <target state="translated">Debido a que &lt;code&gt;runAsync&lt;/code&gt; invoca inmediatamente la &lt;code&gt;Action&lt;/code&gt; y comienza a emitir los elementos, es posible que algunos elementos se pierdan en el intervalo entre el momento en que establece el &lt;code&gt;StoppableObservable&lt;/code&gt; con este m&amp;eacute;todo y el momento en que su &lt;code&gt;Observer&lt;/code&gt; est&amp;aacute; listo para recibir elementos. Si esto es un problema, puede usar la variante de &lt;code&gt;runAsync&lt;/code&gt; que tambi&amp;eacute;n acepta un &lt;a href=&quot;../subject&quot;&gt; &lt;code&gt;Subject&lt;/code&gt; &lt;/a&gt; y pasar un &lt;code&gt;ReplaySubject&lt;/code&gt; con el que puede recuperar los elementos que de otro modo faltar&amp;iacute;an.</target>
        </trans-unit>
        <trans-unit id="45d4b461dae7aa4c7f69430372ef95db326bbe71" translate="yes" xml:space="preserve">
          <source>Because a Subject subscribes to an Observable, it will trigger that Observable to begin emitting items (if that Observable is &amp;ldquo;cold&amp;rdquo; &amp;mdash; that is, if it waits for a subscription before it begins to emit items). This can have the effect of making the resulting Subject a &amp;ldquo;hot&amp;rdquo; Observable variant of the original &amp;ldquo;cold&amp;rdquo; Observable.</source>
          <target state="translated">Debido a que un Sujeto se suscribe a un Observable, activar&amp;aacute; ese Observable para comenzar a emitir elementos (si ese Observable est&amp;aacute; &amp;ldquo;fr&amp;iacute;o&amp;rdquo;, es decir, si espera una suscripci&amp;oacute;n antes de comenzar a emitir elementos). Esto puede tener el efecto de hacer del Sujeto resultante una variante Observable &amp;ldquo;caliente&amp;rdquo; del Observable &amp;ldquo;fr&amp;iacute;o&amp;rdquo; original.</target>
        </trans-unit>
        <trans-unit id="eea3c830df555c58d5b9d3068d47dee7f418f5fe" translate="yes" xml:space="preserve">
          <source>Because it is possible that more than one of the merged Observables encountered an error, &lt;code&gt;mergeDelayError&lt;/code&gt; may pass information about &lt;em&gt;multiple&lt;/em&gt; errors in the &lt;code&gt;onError&lt;/code&gt; notification (it will never invoke the observer&amp;rsquo;s &lt;code&gt;onError&lt;/code&gt; method more than once). For this reason, if you want to know the nature of these errors, you should write your observers&amp;rsquo; &lt;code&gt;onError&lt;/code&gt; methods so that they accept a parameter of the class &lt;code&gt;CompositeException&lt;/code&gt;.</source>
          <target state="translated">Debido a que es posible que m&amp;aacute;s de uno de los Observables fusionados haya encontrado un error, &lt;code&gt;mergeDelayError&lt;/code&gt; puede pasar informaci&amp;oacute;n sobre &lt;em&gt;m&amp;uacute;ltiples&lt;/em&gt; errores en la notificaci&amp;oacute;n &lt;code&gt;onError&lt;/code&gt; (nunca invocar&amp;aacute; el m&amp;eacute;todo &lt;code&gt;onError&lt;/code&gt; del observador m&amp;aacute;s de una vez). Por esta raz&amp;oacute;n, si desea conocer la naturaleza de estos errores, debe escribir los m&amp;eacute;todos &lt;code&gt;onError&lt;/code&gt; de sus observadores para que acepten un par&amp;aacute;metro de la clase &lt;code&gt;CompositeException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40504d93089e459126b9f714fa64da0432bf9cb2" translate="yes" xml:space="preserve">
          <source>Before an Observable terminates it must first issue either an OnCompleted or OnError notification to all of the observers that are subscribed to it.</source>
          <target state="translated">Antes de que un observable termine,debe emitir primero una notificación de &quot;En curso&quot; o &quot;En error&quot; a todos los observadores que estén suscritos a él.</target>
        </trans-unit>
        <trans-unit id="368c978e94ba7ae5d0f5a362fef744af7dd7667e" translate="yes" xml:space="preserve">
          <source>BehaviorSubject</source>
          <target state="translated">BehaviorSubject</target>
        </trans-unit>
        <trans-unit id="2be5f64b36230104ef9c6e230215846a83d18df6" translate="yes" xml:space="preserve">
          <source>Buffer</source>
          <target state="translated">Buffer</target>
        </trans-unit>
        <trans-unit id="c7edc1ce6b23272555c0452f3036c8ab489ea4bc" translate="yes" xml:space="preserve">
          <source>Buffer can reduce a sequence of many items to a sequence of fewer buffers-of-items, making them more manageable. You could, for example, close and emit a buffer of items from a bursty Observable periodically, at a regular interval of time.</source>
          <target state="translated">El buffer puede reducir una secuencia de muchos artículos a una secuencia de menos buffers de artículos,haciéndolos más manejables.Podría,por ejemplo,cerrar y emitir un búfer de elementos de una ráfaga observable periódicamente,en un intervalo de tiempo regular.</target>
        </trans-unit>
        <trans-unit id="d726676ef856039a619e5c8fc3b22b65bd1d7d3f" translate="yes" xml:space="preserve">
          <source>But as with Futures, while callbacks are easy to use with a single level of asynchronous execution, &lt;a href=&quot;https://gist.github.com/4677544&quot;&gt;with nested composition they become unwieldy&lt;/a&gt;.</source>
          <target state="translated">Pero al igual que con Futures, aunque las devoluciones de llamada son f&amp;aacute;ciles de usar con un solo nivel de ejecuci&amp;oacute;n asincr&amp;oacute;nica, &lt;a href=&quot;https://gist.github.com/4677544&quot;&gt;con la composici&amp;oacute;n anidada se vuelven dif&amp;iacute;ciles de manejar&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3806ea89275a484caaeb8fb736ffc6a0c360406a" translate="yes" xml:space="preserve">
          <source>By default this variant of &lt;code&gt;delay&lt;/code&gt; operates on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you can choose a different Scheduler by passing it in as an optional third parameter to &lt;code&gt;delay&lt;/code&gt;</source>
          <target state="translated">De forma predeterminada, esta variante de &lt;code&gt;delay&lt;/code&gt; opera en el &lt;a href=&quot;../scheduler&quot;&gt;programador de &lt;/a&gt; &lt;code&gt;computation&lt;/code&gt; , pero puede elegir un programador diferente pas&amp;aacute;ndolo como un tercer par&amp;aacute;metro opcional para &lt;code&gt;delay&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="853cd838d6aa239dfebc6fe472f15b378a7e9fd0" translate="yes" xml:space="preserve">
          <source>By default this variant of &lt;code&gt;timeout&lt;/code&gt; operates on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you can choose a different Scheduler by passing it in as an optional third parameter to &lt;code&gt;timeout&lt;/code&gt;</source>
          <target state="translated">De forma predeterminada, esta variante de &lt;code&gt;timeout&lt;/code&gt; de espera opera en el &lt;a href=&quot;../scheduler&quot;&gt;programador de &lt;/a&gt; &lt;code&gt;computation&lt;/code&gt; , pero puede elegir un programador diferente pas&amp;aacute;ndolo como un tercer par&amp;aacute;metro opcional para el &lt;code&gt;timeout&lt;/code&gt; de espera</target>
        </trans-unit>
        <trans-unit id="27c7c6971a230126aa6e972a720f0bb289a01e7e" translate="yes" xml:space="preserve">
          <source>By default this variant of &lt;code&gt;timeout&lt;/code&gt; operates on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you can choose a different Scheduler by passing it in as an optional third parameter to &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">De forma predeterminada, esta variante de &lt;code&gt;timeout&lt;/code&gt; de espera funciona en el &lt;a href=&quot;../scheduler&quot;&gt;programador de &lt;/a&gt; &lt;code&gt;computation&lt;/code&gt; , pero puede elegir un programador diferente pas&amp;aacute;ndolo como un tercer par&amp;aacute;metro opcional para el &lt;code&gt;timeout&lt;/code&gt; de espera .</target>
        </trans-unit>
        <trans-unit id="1b5e38e8783b4ae293ff3a5deb6299790a6fded1" translate="yes" xml:space="preserve">
          <source>By default, an Observable and the chain of operators that you apply to it will do its work, and will notify its observers, on the same thread on which its &lt;code&gt;Subscribe&lt;/code&gt; method is called. The SubscribeOn operator changes this behavior by specifying a different Scheduler on which the Observable should operate. The ObserveOn operator specifies a different Scheduler that the Observable will use to send notifications to its observers.</source>
          <target state="translated">De forma predeterminada, un Observable y la cadena de operadores que le aplique har&amp;aacute;n su trabajo y notificar&amp;aacute;n a sus observadores en el mismo hilo en el que se llama a su m&amp;eacute;todo &lt;code&gt;Subscribe&lt;/code&gt; . El operador SubscribeOn cambia este comportamiento especificando un Programador diferente en el que deber&amp;iacute;a operar el Observable. El operador ObserveOn especifica un Programador diferente que el Observable utilizar&amp;aacute; para enviar notificaciones a sus observadores.</target>
        </trans-unit>
        <trans-unit id="349ec7cf4de33246924ed8834527eb97fcddde0c" translate="yes" xml:space="preserve">
          <source>By the terms of &lt;a href=&quot;contract&quot;&gt;the Observable contract&lt;/a&gt;, it may call &lt;code&gt;onNext&lt;/code&gt; zero or more times, and then may follow those calls with a call to either &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; but not both, which will be its last call. By convention, in this document, calls to &lt;code&gt;onNext&lt;/code&gt; are usually called &amp;ldquo;emissions&amp;rdquo; of items, whereas calls to &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; are called &amp;ldquo;notifications.&amp;rdquo;</source>
          <target state="translated">Seg&amp;uacute;n los t&amp;eacute;rminos del &lt;a href=&quot;contract&quot;&gt;contrato Observable&lt;/a&gt; , puede llamar a &lt;code&gt;onNext&lt;/code&gt; cero o m&amp;aacute;s veces, y luego puede seguir esas llamadas con una llamada a &lt;code&gt;onCompleted&lt;/code&gt; u &lt;code&gt;onError&lt;/code&gt; pero no a ambas, que ser&amp;aacute; su &amp;uacute;ltima llamada. Por convenci&amp;oacute;n, en este documento, las llamadas a &lt;code&gt;onNext&lt;/code&gt; generalmente se denominan &quot;emisiones&quot; de elementos, mientras que las llamadas a &lt;code&gt;onCompleted&lt;/code&gt; u &lt;code&gt;onError&lt;/code&gt; se denominan &quot;notificaciones&quot;.</target>
        </trans-unit>
        <trans-unit id="ad7f884b18f0e71ef27dcc9eb107c69b22184b8e" translate="yes" xml:space="preserve">
          <source>Bypasses a specified number of elements at the end of an observable sequence. This operator accumulates a queue with a length enough to store the first `count` elements. As more elements are received, elements are taken from the front of the queue and produced on the result sequence. This causes elements to be delayed.</source>
          <target state="translated">Pasa por alto un número determinado de elementos al final de una secuencia observable.Este operador acumula una cola con una longitud suficiente para almacenar los primeros elementos &quot;contados&quot;.A medida que se reciben más elementos,se toman elementos del frente de la cola y se producen en la secuencia de resultados.Esto hace que los elementos se retrasen.</target>
        </trans-unit>
        <trans-unit id="56a26a63bf2967d76012cc29baf8e343e4f53b12" translate="yes" xml:space="preserve">
          <source>Bypasses a specified number of elements in an observable sequence and then returns the remaining elements. Transform the items emitted by an Observable into Observables, and mirror those items emitted by the most-recently transformed Observable. The flatMapLatest operator is similar to the flatMap and concatMap methods described above, however, rather than emitting all of the items emitted by all of the Observables that the operator generates by transforming items from the source Observable, flatMapLatest instead emits items from each such transformed Observable only until the next such Observable is emitted, then it ignores the previous one and begins emitting items emitted by the new one.</source>
          <target state="translated">Pasa por alto un número determinado de elementos en una secuencia observable y luego devuelve los elementos restantes.Transforma los elementos emitidos por un Observable en Observables,y refleja los elementos emitidos por el Observable más recientemente transformado.El operador flatMapLatest es similar a los métodos flatMap y concatMap descritos anteriormente,sin embargo,en lugar de emitir todos los elementos emitidos por todos los Observables que el operador genera transformando elementos de la fuente Observable,flatMapLatest en cambio emite elementos de cada uno de esos Observables transformados sólo hasta que se emite el siguiente de esos Observables,entonces ignora el anterior y comienza a emitir elementos emitidos por el nuevo.</target>
        </trans-unit>
        <trans-unit id="49745efca49c630e89bcd950cbd9b790a40a26ec" translate="yes" xml:space="preserve">
          <source>Bypasses elements in an observable sequence as long as a specified condition is true and then returns the remaining elements.</source>
          <target state="translated">Pasa por alto elementos en una secuencia observable siempre que una condición especificada sea verdadera y luego devuelve los elementos restantes.</target>
        </trans-unit>
        <trans-unit id="5074688d8a8d1a7a2f2146111a01a2d5efa03be4" translate="yes" xml:space="preserve">
          <source>Bypasses elements in an observable sequence as long as a specified condition is true and then returns the remaining elements. The element's index is used in the logic of the predicate function.</source>
          <target state="translated">Pasa por alto elementos en una secuencia observable siempre que una condición especificada sea verdadera y luego devuelve los elementos restantes.El índice del elemento se utiliza en la lógica de la función predicada.</target>
        </trans-unit>
        <trans-unit id="78dc0e523eb5336a4517027ee20f8ce8c1283c64" translate="yes" xml:space="preserve">
          <source>Call a &lt;code&gt;ConnectableObservable&lt;/code&gt;&amp;rsquo;s &lt;code&gt;connect&lt;/code&gt; method to instruct it to begin emitting the items from its underlying Observable to its Subscribers.</source>
          <target state="translated">Llame a un &lt;code&gt;ConnectableObservable&lt;/code&gt; &amp;lsquo;s &lt;code&gt;connect&lt;/code&gt; m&amp;eacute;todo para indicarle que comenzar&amp;aacute; a emitir los art&amp;iacute;culos de su subyacente observable a sus suscriptores.</target>
        </trans-unit>
        <trans-unit id="c805453a51ab6e5402991a6b7905abbb82969b88" translate="yes" xml:space="preserve">
          <source>Call a method.</source>
          <target state="translated">Llama a un método.</target>
        </trans-unit>
        <trans-unit id="846a84e9501ad053efd6f0622ac43a7f2f1a41f9" translate="yes" xml:space="preserve">
          <source>Callbacks Have Their Own Problems</source>
          <target state="translated">Las devoluciones de llamada tienen sus propios problemas</target>
        </trans-unit>
        <trans-unit id="5d0513dc45b99b203cc47abe5101858366b0aaa9" translate="yes" xml:space="preserve">
          <source>Callbacks solve the problem of premature blocking on &lt;code&gt;Future.get()&lt;/code&gt; by not allowing anything to block. They are naturally efficient because they execute when the response is ready.</source>
          <target state="translated">Las devoluciones de llamada resuelven el problema del bloqueo prematuro en &lt;code&gt;Future.get()&lt;/code&gt; al no permitir que nada se bloquee. Son naturalmente eficientes porque se ejecutan cuando la respuesta est&amp;aacute; lista.</target>
        </trans-unit>
        <trans-unit id="fadfad0ea9282bb47746b81a6a4235042d5882c1" translate="yes" xml:space="preserve">
          <source>Canonical, core operator names are in &lt;strong&gt;boldface&lt;/strong&gt;. Other entries represent language-specific variants of these operators or specialty operators outside of the main ReactiveX core set of operators.</source>
          <target state="translated">Los nombres can&amp;oacute;nicos de los operadores principales est&amp;aacute;n en &lt;strong&gt;negrita&lt;/strong&gt; . Otras entradas representan variantes espec&amp;iacute;ficas del idioma de estos operadores u operadores especializados fuera del conjunto principal de operadores de ReactiveX.</target>
        </trans-unit>
        <trans-unit id="a7c51e67b60b0927212f25eb1aaefb172b8a7153" translate="yes" xml:space="preserve">
          <source>Catch</source>
          <target state="translated">Catch</target>
        </trans-unit>
        <trans-unit id="e6f5247c2c2f3a3279ed51693bfefd3a423b8bf0" translate="yes" xml:space="preserve">
          <source>Chaining Operators</source>
          <target state="translated">Encadenamiento de operadores</target>
        </trans-unit>
        <trans-unit id="902bd9921de41f5d7e6b42366eb8310a65a2c945" translate="yes" xml:space="preserve">
          <source>Chaining Your Custom Operators with Standard RxJava Operators</source>
          <target state="translated">Encadenando sus operadores personalizados con operadores estándar de RxJava</target>
        </trans-unit>
        <trans-unit id="d75951d379af65c103f979b689d8cd3675b822a8" translate="yes" xml:space="preserve">
          <source>Checking or Setting Unsubscribed Status</source>
          <target state="translated">Comprobación o establecimiento de la condición de no suscrito</target>
        </trans-unit>
        <trans-unit id="4fe96207c9c96f4636acc27e3c848d00d3a71f54" translate="yes" xml:space="preserve">
          <source>Cold Observables are ideal for the reactive pull model of backpressure implemented by some implementations of ReactiveX (which is described elsewhere). Hot Observables typically do not cope well with a reactive pull model, and are better candidates for other flow control strategies, such as the use of the operators described on this page, or operators like &lt;a href=&quot;buffer&quot;&gt;Buffer&lt;/a&gt;, &lt;a href=&quot;sample&quot;&gt;Sample&lt;/a&gt;, &lt;a href=&quot;debounce&quot;&gt;Debounce&lt;/a&gt;, or &lt;a href=&quot;window&quot;&gt;Window&lt;/a&gt;.</source>
          <target state="translated">Los Cold Observables son ideales para el modelo de contrapresi&amp;oacute;n de tracci&amp;oacute;n reactiva implementado por algunas implementaciones de ReactiveX (que se describe en otra parte). Los Hot Observables generalmente no se adaptan bien a un modelo de extracci&amp;oacute;n reactiva y son mejores candidatos para otras estrategias de control de flujo, como el uso de los operadores descritos en esta p&amp;aacute;gina u operadores como &lt;a href=&quot;buffer&quot;&gt;Buffer&lt;/a&gt; , &lt;a href=&quot;sample&quot;&gt;Sample&lt;/a&gt; , &lt;a href=&quot;debounce&quot;&gt;Debounce&lt;/a&gt; o &lt;a href=&quot;window&quot;&gt;Window&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8a4a4428705e4ab030e6ba205ec9858d5968be1b" translate="yes" xml:space="preserve">
          <source>Combine an Observable together with another Observable by merging their emissions into a single Observable.</source>
          <target state="translated">Combine un observable con otro observable fusionando sus emisiones en un único observable.</target>
        </trans-unit>
        <trans-unit id="6eaeb8e90e404219d2475ade2286223421965733" translate="yes" xml:space="preserve">
          <source>CombineLatest</source>
          <target state="translated">CombineLatest</target>
        </trans-unit>
        <trans-unit id="6c3a08025c1d0f1b566061e55f26255f61bfc3ba" translate="yes" xml:space="preserve">
          <source>Combining</source>
          <target state="translated">Combining</target>
        </trans-unit>
        <trans-unit id="88d3a1111da9d1eda1c639562973e23995473442" translate="yes" xml:space="preserve">
          <source>Combining Observables</source>
          <target state="translated">Combinación de observables</target>
        </trans-unit>
        <trans-unit id="5747c92bf0fa0eeb7e1e03446b2293ecf1be9ebd" translate="yes" xml:space="preserve">
          <source>Composition via Observable Operators</source>
          <target state="translated">Composición a través de operadores observables</target>
        </trans-unit>
        <trans-unit id="ae5c874513b4df302338425830ff176188a2f641" translate="yes" xml:space="preserve">
          <source>Composition via Single Operators</source>
          <target state="translated">Composición a través de operadores únicos</target>
        </trans-unit>
        <trans-unit id="3304bad3c3afa5d187ab48d870d028da8b016b08" translate="yes" xml:space="preserve">
          <source>Computes the average of an observable sequence of values.</source>
          <target state="translated">Calcula el promedio de una secuencia de valores observables.</target>
        </trans-unit>
        <trans-unit id="086146e076b0941ac82db3612259103a8c72834b" translate="yes" xml:space="preserve">
          <source>Computes the sum of a sequence of values</source>
          <target state="translated">Calcula la suma de una secuencia de valores</target>
        </trans-unit>
        <trans-unit id="6ad79ab6353b1eee8ebbc085e10d17c4fcfb024f" translate="yes" xml:space="preserve">
          <source>Concat</source>
          <target state="translated">Concat</target>
        </trans-unit>
        <trans-unit id="af22bc2cd4677bc8c0a76b729fa90aba7f0a85a8" translate="yes" xml:space="preserve">
          <source>Concat waits to subscribe to each additional Observable that you pass to it until the previous Observable completes. Note that because of this, if you try to concatenate a &amp;ldquo;hot&amp;rdquo; Observable, that is, one that begins emitting items immediately and before it is subscribed to, Concat will not see, and therefore will not emit, any items that Observable emits before all previous Observables complete and Concat subscribes to the &amp;ldquo;hot&amp;rdquo; Observable.</source>
          <target state="translated">Concat espera suscribirse a cada Observable adicional que le pase hasta que se complete el Observable anterior. Tenga en cuenta que debido a esto, si intenta concatenar un Observable &quot;caliente&quot;, es decir, uno que comienza a emitir elementos inmediatamente y antes de que se suscriba, Concat no ver&amp;aacute;, y por lo tanto no emitir&amp;aacute;, ning&amp;uacute;n elemento que el Observable emita antes. todos los Observables anteriores se completan y Concat se suscribe al Observable &amp;ldquo;caliente&amp;rdquo;.</target>
        </trans-unit>
        <trans-unit id="31a49591ac407c790c483a17d515d9fb2a8a38be" translate="yes" xml:space="preserve">
          <source>ConcatMap</source>
          <target state="translated">ConcatMap</target>
        </trans-unit>
        <trans-unit id="7d817faef75bfe91293d3714de7420c6573f23e2" translate="yes" xml:space="preserve">
          <source>Concatenate an observable sequence onto the end of the source observable.</source>
          <target state="translated">Concentrar una secuencia observable en el extremo de la fuente observable.</target>
        </trans-unit>
        <trans-unit id="105eca8e21d6f9c476cc3a553058b085eb5233eb" translate="yes" xml:space="preserve">
          <source>Concatenates a sequence of observable sequences into a single observable sequence.</source>
          <target state="translated">Concatena una secuencia de secuencias observables en una sola secuencia observable.</target>
        </trans-unit>
        <trans-unit id="769151df54c355c60c55756c44028ce4f3ae5d6a" translate="yes" xml:space="preserve">
          <source>Conditional and Boolean</source>
          <target state="translated">Condicional y Booleana</target>
        </trans-unit>
        <trans-unit id="9b047f76f02c3292f835923209499db8eb35fdb8" translate="yes" xml:space="preserve">
          <source>Conditional and Boolean Operators</source>
          <target state="translated">Operadores Condicionales y Booleanos</target>
        </trans-unit>
        <trans-unit id="b65463cb6a42a17de514acc4659f7fd331e0876a" translate="yes" xml:space="preserve">
          <source>Connect</source>
          <target state="translated">Connect</target>
        </trans-unit>
        <trans-unit id="1f7db7f19ce7165e91e31ee1d9b3ccf7f4d5ddb2" translate="yes" xml:space="preserve">
          <source>Connectable</source>
          <target state="translated">Connectable</target>
        </trans-unit>
        <trans-unit id="7b18cca5708f430e8e5e76af7d6ca811b7d401af" translate="yes" xml:space="preserve">
          <source>Connectable Observable Operators</source>
          <target state="translated">Operadores Observables Conectables</target>
        </trans-unit>
        <trans-unit id="33e15d008d511f3101566a2e25203ef2a3f605a0" translate="yes" xml:space="preserve">
          <source>Contains</source>
          <target state="translated">Contains</target>
        </trans-unit>
        <trans-unit id="f5cbdf6bfb51439be085b5c6b7460a7c91eabc3c" translate="yes" xml:space="preserve">
          <source>Contents</source>
          <target state="translated">Contents</target>
        </trans-unit>
        <trans-unit id="0815d31f649e51c84f54caac71abf843ed3f8bb3" translate="yes" xml:space="preserve">
          <source>Continues an observable sequence that is terminated by an exception with the next observable sequence.</source>
          <target state="translated">Continúa una secuencia observable que se termina por una excepción con la siguiente secuencia observable.</target>
        </trans-unit>
        <trans-unit id="6e687c89a4954fc6df4498ea2002f2818d836141" translate="yes" xml:space="preserve">
          <source>Converting Observables</source>
          <target state="translated">Convertir los observables</target>
        </trans-unit>
        <trans-unit id="a54800ec0ba74d95f4ae763fd411edb7cb335d1b" translate="yes" xml:space="preserve">
          <source>Converts a promise into an observable</source>
          <target state="translated">Convierte una promesa en una observable</target>
        </trans-unit>
        <trans-unit id="f6fd01b29250836779bf34c8cd915aff0e9c6ef1" translate="yes" xml:space="preserve">
          <source>Converts an Iterator into an observable sequence</source>
          <target state="translated">Convierte un Iterator en una secuencia observable</target>
        </trans-unit>
        <trans-unit id="ff785cfdb5ffb690f81079fc7680305d01077af0" translate="yes" xml:space="preserve">
          <source>Converts an array to an observable sequence</source>
          <target state="translated">Convierte una matriz en una secuencia observable</target>
        </trans-unit>
        <trans-unit id="66e12969c225cc6d65e18210488acb826eba907e" translate="yes" xml:space="preserve">
          <source>Count</source>
          <target state="translated">Count</target>
        </trans-unit>
        <trans-unit id="6e157c5da4410b7e9de85f5c93026b9176e69064" translate="yes" xml:space="preserve">
          <source>Create</source>
          <target state="translated">Create</target>
        </trans-unit>
        <trans-unit id="3017d922d76f674ffb9131a65a9d9805b40b649a" translate="yes" xml:space="preserve">
          <source>Creates an observable sequence containing a single element which is an array containing all the elements of the source sequence.</source>
          <target state="translated">Crea una secuencia observable que contiene un solo elemento que es una matriz que contiene todos los elementos de la secuencia fuente.</target>
        </trans-unit>
        <trans-unit id="ba20da44f8a1b3b058041022a942932e59185655" translate="yes" xml:space="preserve">
          <source>Creates an observable sequence from a specified subscribeAction callable implementation.</source>
          <target state="translated">Crea una secuencia observable a partir de una implementación llamable de SubscribeAction especificada.</target>
        </trans-unit>
        <trans-unit id="92bf119aef55197510b4be1bbec7191fb09b536e" translate="yes" xml:space="preserve">
          <source>Creating</source>
          <target state="translated">Creating</target>
        </trans-unit>
        <trans-unit id="6ad6131d04bc2f8da39dba3829954ab817589a3f" translate="yes" xml:space="preserve">
          <source>Creating Observables</source>
          <target state="translated">Creación de observables</target>
        </trans-unit>
        <trans-unit id="61f6f421ef32670498c220ee8ee339df076a5ad9" translate="yes" xml:space="preserve">
          <source>DOM</source>
          <target state="translated">DOM</target>
        </trans-unit>
        <trans-unit id="7cb67bc80f28063e0c70dca78f5ac1f7a7e27b33" translate="yes" xml:space="preserve">
          <source>DZone</source>
          <target state="translated">DZone</target>
        </trans-unit>
        <trans-unit id="9d15bbaea70fed040952f827d04bf23d37deee20" translate="yes" xml:space="preserve">
          <source>Dave Sexton&amp;rsquo;s blog</source>
          <target state="translated">Blog de Dave Sexton</target>
        </trans-unit>
        <trans-unit id="ba25d0847d81dc2070dc7517ad59c0bcd4bf477c" translate="yes" xml:space="preserve">
          <source>Debounce</source>
          <target state="translated">Debounce</target>
        </trans-unit>
        <trans-unit id="7ee8d644320fde72f64c3c02faecdd18b75c6696" translate="yes" xml:space="preserve">
          <source>Default Schedulers for RxGroovy Observable Operators</source>
          <target state="translated">Programadores por defecto para los operadores de RxGroovy Observable</target>
        </trans-unit>
        <trans-unit id="1b9dcde6cb5b0bfc6c5ca51b240a6adb12ef894c" translate="yes" xml:space="preserve">
          <source>Default Schedulers for RxJava 1.x Observable Operators</source>
          <target state="translated">Programadores por defecto para los operadores observables de RxJava 1.x</target>
        </trans-unit>
        <trans-unit id="123deaeef87eca8cb2b99f856d5107f914acdc3a" translate="yes" xml:space="preserve">
          <source>DefaultIfEmpty</source>
          <target state="translated">DefaultIfEmpty</target>
        </trans-unit>
        <trans-unit id="c4357816d34305505b749a4ff11d936352064da0" translate="yes" xml:space="preserve">
          <source>Defer</source>
          <target state="translated">Defer</target>
        </trans-unit>
        <trans-unit id="530d7bc391670a9d12abc2c95fba599d8d6a4fa3" translate="yes" xml:space="preserve">
          <source>Define a method that does something useful with the return value from the asynchronous call; this method is part of the</source>
          <target state="translated">Definir un método que haga algo útil con el valor de retorno de la llamada asíncrona;este método es parte de la</target>
        </trans-unit>
        <trans-unit id="c776a2467c885ed63c4827a40f24318ee838b755" translate="yes" xml:space="preserve">
          <source>Define the asynchronous call itself as an</source>
          <target state="translated">Define la llamada asíncrona en sí misma como una</target>
        </trans-unit>
        <trans-unit id="1d05798be1bf5aad240451b19cea28a1042183aa" translate="yes" xml:space="preserve">
          <source>Define your operator as a public class that implements the &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.Operator.html&quot;&gt;&lt;code&gt;Operator&lt;/code&gt;&lt;/a&gt; interface, like so:</source>
          <target state="translated">Defina su operador como una clase p&amp;uacute;blica que implementa la interfaz del &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.Operator.html&quot;&gt; &lt;code&gt;Operator&lt;/code&gt; &lt;/a&gt; , as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="b4c200bb0d1f7ba2b7c3e166470a4cb39be0daab" translate="yes" xml:space="preserve">
          <source>Delay</source>
          <target state="translated">Delay</target>
        </trans-unit>
        <trans-unit id="24eb06fa1daed4a5e60d45a988c3f8068a35cdf2" translate="yes" xml:space="preserve">
          <source>DelaySubscription</source>
          <target state="translated">DelaySubscription</target>
        </trans-unit>
        <trans-unit id="17582fe13ad63f1268f0a279d97ba7524dcb4b53" translate="yes" xml:space="preserve">
          <source>Delayed and Periodic Schedulers</source>
          <target state="translated">Programadores retrasados y periódicos</target>
        </trans-unit>
        <trans-unit id="b9573648319d57f22c34e294a58048517caa06a5" translate="yes" xml:space="preserve">
          <source>Dematerialize</source>
          <target state="translated">Dematerialize</target>
        </trans-unit>
        <trans-unit id="8a57a3d654adf9c3caf76455456be92d962c8113" translate="yes" xml:space="preserve">
          <source>Dematerializes the explicit notification values of an observable sequence as implicit notifications.</source>
          <target state="translated">Desmaterializa los valores de notificación explícitos de una secuencia observable como notificaciones implícitas.</target>
        </trans-unit>
        <trans-unit id="4faf2e90a3c1b400f4ee9d8c8176a362bc102d3a" translate="yes" xml:space="preserve">
          <source>Distinct</source>
          <target state="translated">Distinct</target>
        </trans-unit>
        <trans-unit id="1fa9ca2d50e91f64ba10b23625a789d1d514ba76" translate="yes" xml:space="preserve">
          <source>DistinctUntilChanged</source>
          <target state="translated">DistinctUntilChanged</target>
        </trans-unit>
        <trans-unit id="22bdf47be3fd0a53ecdf5d6edbde0a2c6b97f0e0" translate="yes" xml:space="preserve">
          <source>Do</source>
          <target state="translated">Do</target>
        </trans-unit>
        <trans-unit id="990799e2354088401f54e49252cb9cd2887b10be" translate="yes" xml:space="preserve">
          <source>Do not block within your operator.</source>
          <target state="translated">No bloquee dentro de su operador.</target>
        </trans-unit>
        <trans-unit id="bde4f7dc6a6a9b2fc7ddc5c5285b6941c477da41" translate="yes" xml:space="preserve">
          <source>Each element of the array is produced as an emission. The difference between this method and &lt;code&gt;Observable.just&lt;/code&gt; is that the latter emits the whole array as one emission.</source>
          <target state="translated">Cada elemento de la matriz se produce como una emisi&amp;oacute;n. La diferencia entre este m&amp;eacute;todo y &lt;code&gt;Observable.just&lt;/code&gt; Es que este &amp;uacute;ltimo emite la matriz completa como una emisi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7a91a226ecfae7f33d903980a454ab6aaa9b48e8" translate="yes" xml:space="preserve">
          <source>Each language-specific implementation of ReactiveX has its own naming quirks. There is no canonical naming standard, though there are many commonalities between implementations.</source>
          <target state="translated">Cada implementación de ReactiveX en un idioma específico tiene sus propias peculiaridades de denominación.No hay una norma canónica de denominación,aunque hay muchos puntos en común entre las implementaciones.</target>
        </trans-unit>
        <trans-unit id="cef6d442e8c8b1f7447957e1c9784e5f4cc239dc" translate="yes" xml:space="preserve">
          <source>Each language-specific implementation of ReactiveX implements a set of operators. Although there is much overlap between implementations, there are also some operators that are only implemented in certain implementations. Also, each implementation tends to name its operators to resemble those of similar methods that are already familiar from other contexts in that language.</source>
          <target state="translated">Cada implementación de ReactiveX en un idioma específico implementa un conjunto de operadores.Aunque hay mucho solapamiento entre las implementaciones,también hay algunos operadores que sólo se implementan en ciertas implementaciones.Además,cada implementación tiende a nombrar sus operadores para asemejarse a los de métodos similares que ya son familiares de otros contextos en ese idioma.</target>
        </trans-unit>
        <trans-unit id="b41b061bd9083507610ef2dcf5baaac02b4db60a" translate="yes" xml:space="preserve">
          <source>ElementAt</source>
          <target state="translated">ElementAt</target>
        </trans-unit>
        <trans-unit id="5c002992eecc90de6e3515445216429d901f6529" translate="yes" xml:space="preserve">
          <source>Emit only those items from an Observable that pass a predicate test.</source>
          <target state="translated">Emitir sólo aquellos artículos de un Observable que pasen una prueba de predicado.</target>
        </trans-unit>
        <trans-unit id="3159fe421b3221381b3c778dc1c3c26e4540be37" translate="yes" xml:space="preserve">
          <source>Empty</source>
          <target state="translated">Empty</target>
        </trans-unit>
        <trans-unit id="5fff1f56919b006049c274c6c76fbbe56470ee4c" translate="yes" xml:space="preserve">
          <source>Error Handling</source>
          <target state="translated">Manejo de errores</target>
        </trans-unit>
        <trans-unit id="b8a2a7f6e5c6d27ddebfed1897c207d4db559890" translate="yes" xml:space="preserve">
          <source>Error Handling Operators</source>
          <target state="translated">Operadores de manejo de errores</target>
        </trans-unit>
        <trans-unit id="9c83f123791849e254666f68cc88dae689457e0d" translate="yes" xml:space="preserve">
          <source>Errors the observable sequence if no item is emitted in the specified time. When a timeout occurs, this operator errors with an instance of Rx\Exception\TimeoutException</source>
          <target state="translated">Errores en la secuencia observable si no se emite ningún elemento en el tiempo especificado.Cuando se produce un timeout,este operador se equivoca con una instancia de RxException...</target>
        </trans-unit>
        <trans-unit id="8c51d8ac13956137d7379dd1c673b6057e36f8fc" translate="yes" xml:space="preserve">
          <source>Establishing Observers</source>
          <target state="translated">Establecimiento de observadores</target>
        </trans-unit>
        <trans-unit id="ec7a78ddd1e28dabdd3fb142de5c9c3d0907593c" translate="yes" xml:space="preserve">
          <source>Example code showing how similar high-order functions can be applied to an Iterable and an Observable</source>
          <target state="translated">Código de ejemplo que muestra cómo se pueden aplicar funciones de alto orden similares a un Iterable y a un Observable</target>
        </trans-unit>
        <trans-unit id="d7decf1aa22b02ae8abf9a96849ee423eee838e4" translate="yes" xml:space="preserve">
          <source>Filter</source>
          <target state="translated">Filter</target>
        </trans-unit>
        <trans-unit id="9075edca21736af901d2add18e4d9491f2452b4d" translate="yes" xml:space="preserve">
          <source>Filtering</source>
          <target state="translated">Filtering</target>
        </trans-unit>
        <trans-unit id="b3d1e836b8c9937992dbfac26e772ac39afe998a" translate="yes" xml:space="preserve">
          <source>Filtering Observables</source>
          <target state="translated">Filtro de los observables</target>
        </trans-unit>
        <trans-unit id="8978f6a09cf524ab9596b508a2479904c83591c3" translate="yes" xml:space="preserve">
          <source>Finally, there is an alphabetical list of most of the operators available in the many language-specific implementations of ReactiveX. These link to the page that documents the core operator that most closely resembles the language-specific operator (so, for instance, the Rx.NET &amp;ldquo;SelectMany&amp;rdquo; operator links to the documentation of the FlatMap ReactiveX operator, of which &amp;ldquo;SelectMany&amp;rdquo; is the Rx.NET implementation).</source>
          <target state="translated">Por &amp;uacute;ltimo, hay una lista alfab&amp;eacute;tica de la mayor&amp;iacute;a de los operadores disponibles en las muchas implementaciones espec&amp;iacute;ficas de lenguaje de ReactiveX. Estos enlazan a la p&amp;aacute;gina que documenta el operador principal que m&amp;aacute;s se parece al operador espec&amp;iacute;fico del idioma (as&amp;iacute;, por ejemplo, el operador Rx.NET &quot;SelectMany&quot; enlaza con la documentaci&amp;oacute;n del operador FlatMap ReactiveX, del cual &quot;SelectMany&quot; es el Implementaci&amp;oacute;n de Rx.NET).</target>
        </trans-unit>
        <trans-unit id="9f2160fad1531c502a9ce03c129b6f655416e93f" translate="yes" xml:space="preserve">
          <source>Finally, you can pass it an object that implements either of the &lt;code&gt;Observer&lt;/code&gt; or &lt;code&gt;Subscriber&lt;/code&gt; interfaces. The &lt;code&gt;Observer&lt;/code&gt; interface consists of the three previously-described &amp;ldquo;&lt;code&gt;on&lt;/code&gt;&amp;rdquo; methods. The &lt;code&gt;Subscriber&lt;/code&gt; interface implements these also, and adds a number of additional methods that facilitate reactive pull backpressure and that permit the Subscriber to unsubscribe to an Observable before it completes.</source>
          <target state="translated">Finalmente, puede pasarle un objeto que implemente cualquiera de las interfaces &lt;code&gt;Observer&lt;/code&gt; o &lt;code&gt;Subscriber&lt;/code&gt; . La interfaz de &lt;code&gt;Observer&lt;/code&gt; consta de los tres m&amp;eacute;todos &quot; &lt;code&gt;on&lt;/code&gt; &quot; descritos anteriormente . La interfaz del &lt;code&gt;Subscriber&lt;/code&gt; tambi&amp;eacute;n los implementa y agrega una serie de m&amp;eacute;todos adicionales que facilitan la contrapresi&amp;oacute;n reactiva y que permiten al suscriptor cancelar la suscripci&amp;oacute;n a un Observable antes de que se complete.</target>
        </trans-unit>
        <trans-unit id="916a78d701ded328cd66da58a97ef8cd28a99e84" translate="yes" xml:space="preserve">
          <source>First</source>
          <target state="translated">First</target>
        </trans-unit>
        <trans-unit id="c5bda5b47fc05cd947485d9dcbc97c118c87af17" translate="yes" xml:space="preserve">
          <source>FlatMap</source>
          <target state="translated">FlatMap</target>
        </trans-unit>
        <trans-unit id="273946dd5d2d1288f9b2aafed80ce36284371ce6" translate="yes" xml:space="preserve">
          <source>For example there is the &lt;code&gt;on&lt;i&gt;Event&lt;/i&gt;&lt;/code&gt; naming pattern (e.g. &lt;code&gt;onNext&lt;/code&gt;, &lt;code&gt;onCompleted&lt;/code&gt;, &lt;code&gt;onError&lt;/code&gt;). In some contexts such names would indicate methods by means of which event handlers are &lt;em&gt;registered&lt;/em&gt;. In ReactiveX, however, they name the event handlers themselves.</source>
          <target state="translated">Por ejemplo, existe la &lt;code&gt;on&lt;i&gt;Event&lt;/i&gt;&lt;/code&gt; patr&amp;oacute;n de nomenclatura (por ejemplo &lt;code&gt;onNext&lt;/code&gt; , &lt;code&gt;onCompleted&lt;/code&gt; , &lt;code&gt;onError&lt;/code&gt; ). En algunos contextos, estos nombres indicar&amp;iacute;an m&amp;eacute;todos mediante los cuales se &lt;em&gt;registran los&lt;/em&gt; controladores de eventos . En ReactiveX, sin embargo, ellos mismos nombran los controladores de eventos.</target>
        </trans-unit>
        <trans-unit id="217442e28d51221a4fdad0309844d07ab64be02a" translate="yes" xml:space="preserve">
          <source>For example, imagine using the &lt;a href=&quot;zip&quot;&gt;Zip&lt;/a&gt; operator to zip together two infinite Observables, one of which emits items twice as frequently as the other. A naive implementation of the operator would have to maintain an ever-expanding buffer of items emitted by the faster Observable to eventually combine with items emitted by the slower one. This could cause ReactiveX to seize an unwieldy amount of system resources.</source>
          <target state="translated">Por ejemplo, imagine usar el operador &lt;a href=&quot;zip&quot;&gt;Zip&lt;/a&gt; para unir dos Observables infinitos, uno de los cuales emite elementos con el doble de frecuencia que el otro. Una implementaci&amp;oacute;n ingenua del operador tendr&amp;iacute;a que mantener un b&amp;uacute;fer en constante expansi&amp;oacute;n de elementos emitidos por el Observable m&amp;aacute;s r&amp;aacute;pido para eventualmente combinarse con los elementos emitidos por el m&amp;aacute;s lento. Esto podr&amp;iacute;a hacer que ReactiveX se apodere de una cantidad inmanejable de recursos del sistema.</target>
        </trans-unit>
        <trans-unit id="2c04f7c1d2fb4ddd89c1509683905da7e098003b" translate="yes" xml:space="preserve">
          <source>For example, the following code merges the &lt;code&gt;odds&lt;/code&gt; and &lt;code&gt;evens&lt;/code&gt; into a single Observable. (The &lt;code&gt;subscribeOn&lt;/code&gt; operator makes &lt;code&gt;odds&lt;/code&gt; operate on a different thread from &lt;code&gt;evens&lt;/code&gt; so that the two Observables may both emit items at the same time, to demonstrate how Merge may interleave these items.)</source>
          <target state="translated">Por ejemplo, el siguiente c&amp;oacute;digo fusiona las &lt;code&gt;odds&lt;/code&gt; y los &lt;code&gt;evens&lt;/code&gt; en un solo Observable. (El operador &lt;code&gt;subscribeOn&lt;/code&gt; hace que las &lt;code&gt;odds&lt;/code&gt; operen en un hilo diferente de los &lt;code&gt;evens&lt;/code&gt; para que los dos Observables puedan emitir elementos al mismo tiempo, para demostrar c&amp;oacute;mo Merge puede intercalar estos elementos).</target>
        </trans-unit>
        <trans-unit id="dc05c0ee12f75173f33b61a359852128b084b9e1" translate="yes" xml:space="preserve">
          <source>For example, the following code takes a list of unsorted integers, converts it into an Observable, then converts that Observable into one that emits the original list in sorted form as a single item:</source>
          <target state="translated">Por ejemplo,el siguiente código toma una lista de números enteros sin clasificar,la convierte en un Observable,y luego convierte ese Observable en uno que emite la lista original en forma ordenada como un solo elemento:</target>
        </trans-unit>
        <trans-unit id="fbbdfcad6b5a5793860447cf0201a70bee8a2b57" translate="yes" xml:space="preserve">
          <source>For example, the following code uses &lt;code&gt;reduce&lt;/code&gt; to compute, and then emit as an Observable, the sum of the numbers emitted by the source Observable:</source>
          <target state="translated">Por ejemplo, el siguiente c&amp;oacute;digo usa &lt;code&gt;reduce&lt;/code&gt; para calcular, y luego emite como Observable, la suma de los n&amp;uacute;meros emitidos por el Observable fuente:</target>
        </trans-unit>
        <trans-unit id="875655c8a87dcab782ffad12361168b23205728f" translate="yes" xml:space="preserve">
          <source>For example, the following rather pointless code takes a list of integers, converts it into an Observable, then converts that Observable into one that emits the original list as a single item:</source>
          <target state="translated">Por ejemplo,el siguiente código bastante inútil toma una lista de números enteros,la convierte en un Observable,y luego convierte ese Observable en uno que emite la lista original como un solo elemento:</target>
        </trans-unit>
        <trans-unit id="b4afe05eb65cfed34c46b0c5cfa9d72af6ef87ec" translate="yes" xml:space="preserve">
          <source>For the special case of &lt;code&gt;take(0)&lt;/code&gt; you can also pass as a second parameter a &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; that &lt;code&gt;take&lt;/code&gt; will use to immediately schedule a call to &lt;code&gt;onCompleted&lt;/code&gt;.</source>
          <target state="translated">Para el caso especial de &lt;code&gt;take(0)&lt;/code&gt; , tambi&amp;eacute;n puede pasar como segundo par&amp;aacute;metro un &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; que &lt;code&gt;take&lt;/code&gt; usar&amp;aacute; para programar inmediatamente una llamada a &lt;code&gt;onCompleted&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e288d7fa19e1bf4757ab1d8f5269ca19ed723b7" translate="yes" xml:space="preserve">
          <source>For this reason, instead of subscribing to a Single with the three methods you use to respond to notifications from an Observable (</source>
          <target state="translated">Por esta razón,en lugar de suscribirse a un Single con los tres métodos que se utilizan para responder a las notificaciones de un Observable (</target>
        </trans-unit>
        <trans-unit id="2737986da43814cbc95d7c442ca5b8a689aa03a4" translate="yes" xml:space="preserve">
          <source>For this reason, most ReactiveX implementations have methods that allow you to convert certain language-specific objects and data structures into Observables.</source>
          <target state="translated">Por esta razón,la mayoría de las implementaciones de ReactiveX tienen métodos que permiten convertir ciertos objetos y estructuras de datos específicos del lenguaje en Observables.</target>
        </trans-unit>
        <trans-unit id="3f66052a107eaf9bae7cad0f61fb462f47ec2c47" translate="yes" xml:space="preserve">
          <source>From</source>
          <target state="translated">From</target>
        </trans-unit>
        <trans-unit id="392276019fcc1d5272942bce719b6342fcb81e7b" translate="yes" xml:space="preserve">
          <source>From the Observer&amp;rsquo;s point of view, it doesn&amp;rsquo;t matter!</source>
          <target state="translated">Desde el punto de vista del observador, &amp;iexcl;no importa!</target>
        </trans-unit>
        <trans-unit id="42428a2d2e461a43cab074a94ea7b862a5694eb9" translate="yes" xml:space="preserve">
          <source>Furthermore, some of these names have different implications in other contexts, or seem awkward in the idiom of a particular implementing language.</source>
          <target state="translated">Además,algunos de estos nombres tienen implicaciones diferentes en otros contextos,o parecen incómodos en el idioma de un determinado idioma de aplicación.</target>
        </trans-unit>
        <trans-unit id="1d3db6203d1cee531e933dc661377957741fd7c7" translate="yes" xml:space="preserve">
          <source>Generates an observable sequence of integral numbers within a specified range, using the specified scheduler to send out observer messages.</source>
          <target state="translated">Genera una secuencia observable de números integrales dentro de un rango especificado,utilizando el planificador especificado para enviar mensajes de observación.</target>
        </trans-unit>
        <trans-unit id="92d0f29396a5c34e31ebc967172deef307fe570f" translate="yes" xml:space="preserve">
          <source>Generates an observable sequence that repeats the given element the specified number of times.</source>
          <target state="translated">Genera una secuencia observable que repite el elemento dado el número de veces especificado.</target>
        </trans-unit>
        <trans-unit id="7b53270ad371697bc1e589de2e23706a1f6bcaa9" translate="yes" xml:space="preserve">
          <source>Go on with your business; whenever the call returns, the observer&amp;rsquo;s method will begin to operate on its return value or values &amp;mdash; the</source>
          <target state="translated">Contin&amp;uacute;e con su negocio; siempre que la llamada regrese, el m&amp;eacute;todo del observador comenzar&amp;aacute; a operar en su valor o valores de retorno: el</target>
        </trans-unit>
        <trans-unit id="63718ab0ad2dfd113729e407e5fdf344eb231fd5" translate="yes" xml:space="preserve">
          <source>GroupBy</source>
          <target state="translated">GroupBy</target>
        </trans-unit>
        <trans-unit id="5b580ccc31ee66edb3fbe2b6a9872b6baf3565df" translate="yes" xml:space="preserve">
          <source>Groups the elements of an observable sequence according to a specified key selector function and comparer and selects the resulting elements by using a specified function.</source>
          <target state="translated">Agrupa los elementos de una secuencia observable según una función selectora de teclas y un comparador especificados y selecciona los elementos resultantes utilizando una función especificada.</target>
        </trans-unit>
        <trans-unit id="ec80db1447579253ebd9672ba573bfff5db58f5b" translate="yes" xml:space="preserve">
          <source>Here is an example that provides its own sorting function: in this case, one that sorts numbers according to how close they are to the number 5.</source>
          <target state="translated">He aquí un ejemplo que proporciona su propia función de clasificación:en este caso,uno que clasifica los números de acuerdo a cuán cerca están del número 5.</target>
        </trans-unit>
        <trans-unit id="ed3a2bd6db43943919933044f161c73f3f3b3390" translate="yes" xml:space="preserve">
          <source>Hides the identity of an observable sequence.</source>
          <target state="translated">Oculta la identidad de una secuencia observable.</target>
        </trans-unit>
        <trans-unit id="1f4a28cce6229ef2c4b35941085f06d550791705" translate="yes" xml:space="preserve">
          <source>How is this Observable implemented?</source>
          <target state="translated">¿Cómo se aplica este observable?</target>
        </trans-unit>
        <trans-unit id="85f43fbd596793edf6bbe3749bc8742ef91cfde4" translate="yes" xml:space="preserve">
          <source>However, if the source Observable terminates with an error, the &lt;code&gt;BehaviorSubject&lt;/code&gt; will not emit any items to subsequent observers, but will simply pass along the error notification from the source Observable.</source>
          <target state="translated">Sin embargo, si el Observable de origen termina con un error, &lt;code&gt;BehaviorSubject&lt;/code&gt; no emitir&amp;aacute; ning&amp;uacute;n elemento a los observadores posteriores, sino que simplemente pasar&amp;aacute; la notificaci&amp;oacute;n de error del Observable de origen.</target>
        </trans-unit>
        <trans-unit id="77b8c0a40d90b726e62fff83e0e5d057ad8f6562" translate="yes" xml:space="preserve">
          <source>I want an Observable that does not start emitting items to subscribers until asked</source>
          <target state="translated">Quiero un observatorio que no empiece a emitir artículos a los suscriptores hasta que se le pida</target>
        </trans-unit>
        <trans-unit id="96e0c99e2ca6299088acf813f3684ac6db4f290d" translate="yes" xml:space="preserve">
          <source>I want an Observable that will notify observers of an error</source>
          <target state="translated">Quiero un Observador que notifique a los observadores de un error</target>
        </trans-unit>
        <trans-unit id="93ac8f52c641ecf8295c3126651b68566f69ca55" translate="yes" xml:space="preserve">
          <source>I want an Observable to invoke a particular action when certain events occur</source>
          <target state="translated">Quiero que un Observador invoque una acción particular cuando ocurran ciertos eventos</target>
        </trans-unit>
        <trans-unit id="71de0f2184ab945ae7071514e5714fa44c58f556" translate="yes" xml:space="preserve">
          <source>I want an Observable to recover gracefully</source>
          <target state="translated">Quiero que un Observador se recupere con gracia</target>
        </trans-unit>
        <trans-unit id="bf4218745ff4559c04307408b48fa3c0d95b2e3c" translate="yes" xml:space="preserve">
          <source>I want an operator to operate on a particular &lt;a href=&quot;http://reactivex.io/scheduler.html&quot;&gt;Scheduler&lt;/a&gt;</source>
          <target state="translated">Quiero que un operador opere en un &lt;a href=&quot;http://reactivex.io/scheduler.html&quot;&gt;programador en&lt;/a&gt; particular</target>
        </trans-unit>
        <trans-unit id="8bcee030a9b0fc7754e86e874779c1dd0d6fbcf4" translate="yes" xml:space="preserve">
          <source>I want to collect items from an Observable and reemit them as buffers of items</source>
          <target state="translated">Quiero recolectar artículos de un Observador y reemitirlos como buffers de artículos</target>
        </trans-unit>
        <trans-unit id="9da6c79bd44786fa9d805be97358190877889323" translate="yes" xml:space="preserve">
          <source>I want to convert the entire sequence of items emitted by an Observable into some other data structure</source>
          <target state="translated">Quiero convertir toda la secuencia de elementos emitidos por un Observable en alguna otra estructura de datos</target>
        </trans-unit>
        <trans-unit id="99621e91d6f81783ccbca5febefcff99798c51ba" translate="yes" xml:space="preserve">
          <source>I want to create a new Observable</source>
          <target state="translated">Quiero crear un nuevo observatorio</target>
        </trans-unit>
        <trans-unit id="e95392e6ebe4cd2b8d976a6b5dc15ebcc8652c19" translate="yes" xml:space="preserve">
          <source>I want to create a resource that has the same lifespan as the Observable</source>
          <target state="translated">Quiero crear un recurso que tenga la misma vida útil que el Observable</target>
        </trans-unit>
        <trans-unit id="e1e5a804f40a4ae53ad6d865409b7eb39972641d" translate="yes" xml:space="preserve">
          <source>I want to create an Observable by combining other Observables</source>
          <target state="translated">Quiero crear un observatorio combinando otros observatorios</target>
        </trans-unit>
        <trans-unit id="bba42083fc42c06c02ced02fc27975097eda340f" translate="yes" xml:space="preserve">
          <source>I want to emit the items from an Observable after transforming them</source>
          <target state="translated">Quiero emitir los artículos de un Observable después de transformarlos</target>
        </trans-unit>
        <trans-unit id="678a797d3d44a8e136336de41859f44d87ea12d0" translate="yes" xml:space="preserve">
          <source>I want to evaluate the entire sequence of items emitted by an Observable</source>
          <target state="translated">Quiero evaluar toda la secuencia de elementos emitidos por un Observable</target>
        </trans-unit>
        <trans-unit id="342d9df0dc00c6409e061ccbe8bd7a43ec0f1e2f" translate="yes" xml:space="preserve">
          <source>I want to ignore all items emitted by an Observable and only pass along its completed/error notification</source>
          <target state="translated">Quiero ignorar todos los artículos emitidos por un Observador y sólo pasar su notificación completa/errorizada</target>
        </trans-unit>
        <trans-unit id="ac1e59137d512a13724ce068546bdef43aa1b2cf" translate="yes" xml:space="preserve">
          <source>I want to mirror an Observable but prefix items to its sequence</source>
          <target state="translated">Quiero reflejar un Observable pero prefijo los elementos de su secuencia</target>
        </trans-unit>
        <trans-unit id="7bdd0d540cc5c4d1feeab4c1bf757d0bb5b1651e" translate="yes" xml:space="preserve">
          <source>I want to reemit items from an Observable only on condition that it was the first of a collection of Observables to emit an item</source>
          <target state="translated">Quiero volver a emitir artículos de un observatorio sólo a condición de que sea el primero de una colección de observatorios en emitir un artículo</target>
        </trans-unit>
        <trans-unit id="afea5ad42757cc0909b83ee4ce1bb6c62bd02f89" translate="yes" xml:space="preserve">
          <source>I want to reemit only certain items from an Observable</source>
          <target state="translated">Quiero sacar sólo ciertos artículos de un observable...</target>
        </trans-unit>
        <trans-unit id="55e5e42e408215716d6b5f291913c77f52df5dd6" translate="yes" xml:space="preserve">
          <source>I want to retrieve a particular item emitted by an Observable:</source>
          <target state="translated">Quiero recuperar un elemento particular emitido por un Observador:</target>
        </trans-unit>
        <trans-unit id="386e533e7f72fc5f43c8113497f862fc5eede916" translate="yes" xml:space="preserve">
          <source>I want to shift the items emitted by an Observable forward in time before reemitting them</source>
          <target state="translated">Quiero desplazar los objetos emitidos por un Observable hacia adelante en el tiempo antes de reemitirlos</target>
        </trans-unit>
        <trans-unit id="86a6925e0701483bb01af42b8def481ec4f9b265" translate="yes" xml:space="preserve">
          <source>I want to split one Observable into multiple Observables</source>
          <target state="translated">Quiero dividir un Observable en múltiples Observables</target>
        </trans-unit>
        <trans-unit id="51428b8b50c14765922c8b036cca4988742e7efd" translate="yes" xml:space="preserve">
          <source>I want to subscribe to an Observable and receive a &lt;code&gt;Future&lt;/code&gt; that blocks until the Observable completes</source>
          <target state="translated">Quiero suscribirme a un Observable y recibir un &lt;code&gt;Future&lt;/code&gt; que se bloquea hasta que el Observable se complete</target>
        </trans-unit>
        <trans-unit id="1e67d5551cb9e7fce5308aac618b27ccc290f104" translate="yes" xml:space="preserve">
          <source>I want to transform items &lt;em&gt;and&lt;/em&gt; notifications from an Observable into items and reemit them</source>
          <target state="translated">Quiero transformar elementos &lt;em&gt;y&lt;/em&gt; notificaciones de un Observable en elementos y volver a enviarlos</target>
        </trans-unit>
        <trans-unit id="caced85795e91d7af9dfe4ed9e1f46fd5fea7321" translate="yes" xml:space="preserve">
          <source>If a second observer subscribes to an Observable that is already emitting items to a first observer, it is up to the Observable whether it will thenceforth emit the same items to each observer, or whether it will replay the complete sequence of items from the beginning to the second observer, or whether it will emit a wholly different sequence of items to the second observer. There is no general guarantee that two observers of the same Observable will see the same sequence of items.</source>
          <target state="translated">Si un segundo observador se suscribe a un observatorio que ya está emitiendo elementos a un primer observador,depende del observatorio si en adelante emitirá los mismos elementos a cada observador,o si reproducirá la secuencia completa de elementos desde el principio hasta el segundo observador,o si emitirá una secuencia de elementos totalmente diferente al segundo observador.No hay ninguna garantía general de que dos observadores del mismo Observador vean la misma secuencia de elementos.</target>
        </trans-unit>
        <trans-unit id="a0ef7637d7666db7b1cac27130564f15f9858d6b" translate="yes" xml:space="preserve">
          <source>If an Observable has not issued an OnCompleted or OnError notification, an observer may consider it to be still active (even if it is not currently emitting items) and may issue it notifications (such as an Unsubscribe or Request notification). When an Observable does issue an OnCompleted or OnError notification, the Observable may release its resources and terminate, and its observers should not attempt to communicate with it any further.</source>
          <target state="translated">Si un observable no ha emitido una notificación de &quot;En curso&quot; o &quot;En error&quot;,un observador puede considerar que sigue activo (aunque no esté emitiendo artículos actualmente)y puede emitirle notificaciones (como una notificación de cancelación de suscripción o de solicitud).Cuando un observable emite una notificación de &quot;terminado&quot; o de &quot;error&quot;,el observable puede liberar sus recursos y darse de baja,y sus observadores no deben intentar comunicarse con él nunca más.</target>
        </trans-unit>
        <trans-unit id="ec7b046dde03b5ea699c95f5183b34be3f0cf4c2" translate="yes" xml:space="preserve">
          <source>If an Observable implements backpressure and its observer employs backpressure, the Observable will not begin to emit items to the observer immediately upon subscription. Instead, it will issue an OnSubscribe notification to the observer.</source>
          <target state="translated">Si un Observador aplica la contrapresión y su observador la emplea,el Observador no empezará a emitir artículos al observador inmediatamente después de la suscripción.En su lugar,emitirá una notificación de suscripción al observador.</target>
        </trans-unit>
        <trans-unit id="733ae6509dbabf4aba675cc3ed47501f58834086" translate="yes" xml:space="preserve">
          <source>If any of the individual Observables passed into &lt;code&gt;merge&lt;/code&gt; or &lt;code&gt;mergeAll&lt;/code&gt; terminates with an &lt;code&gt;onError&lt;/code&gt; notification, the resulting Observable will immediately terminate with an &lt;code&gt;onError&lt;/code&gt; notification. If you would prefer a merge that continues emitting the results of the remaining, error-free Observables before reporting the error, use &lt;code&gt;mergeDelayError&lt;/code&gt; instead.</source>
          <target state="translated">Si alguno de los Observables individuales pasa a &lt;code&gt;merge&lt;/code&gt; o &lt;code&gt;mergeAll&lt;/code&gt; termina con una notificaci&amp;oacute;n de &lt;code&gt;onError&lt;/code&gt; , el Observable resultante terminar&amp;aacute; inmediatamente con una notificaci&amp;oacute;n de &lt;code&gt;onError&lt;/code&gt; . Si prefiere una fusi&amp;oacute;n que contin&amp;uacute;e emitiendo los resultados de los Observables restantes sin errores antes de informar el error, use &lt;code&gt;mergeDelayError&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="dcd3e9e82373d3dfce17c1d4311251fdd13222d5" translate="yes" xml:space="preserve">
          <source>If any of the individual Observables passed into &lt;code&gt;merge&lt;/code&gt; terminates with an &lt;code&gt;onError&lt;/code&gt; notification, the Observable produced by &lt;code&gt;merge&lt;/code&gt; itself will immediately terminate with an &lt;code&gt;onError&lt;/code&gt; notification. If you would prefer a merge that continues emitting the results of the remaining, error-free Observables before reporting the error, use &lt;code&gt;mergeDelayError&lt;/code&gt; instead.</source>
          <target state="translated">Si alguno de los Observables individuales pasados ​​a la &lt;code&gt;merge&lt;/code&gt; termina con una notificaci&amp;oacute;n de &lt;code&gt;onError&lt;/code&gt; , el Observable producido por la &lt;code&gt;merge&lt;/code&gt; misma terminar&amp;aacute; inmediatamente con una notificaci&amp;oacute;n de &lt;code&gt;onError&lt;/code&gt; . Si prefiere una fusi&amp;oacute;n que contin&amp;uacute;e emitiendo los resultados de los Observables restantes sin errores antes de informar el error, use &lt;code&gt;mergeDelayError&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="6d250294c4e6c5532d682c6ee0dcbdc73daefb50" translate="yes" xml:space="preserve">
          <source>If instead you want the Observable to emit a default value in such a case, you can pass a second parameter (named &lt;code&gt;defaultValue&lt;/code&gt;) to &lt;code&gt;last&lt;/code&gt;:</source>
          <target state="translated">Si, en cambio, desea que el Observable emita un valor predeterminado en tal caso, puede pasar un segundo par&amp;aacute;metro (llamado &lt;code&gt;defaultValue&lt;/code&gt; ) al &lt;code&gt;last&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="72eba74aab57235e91614104d881cad347d5f3c6" translate="yes" xml:space="preserve">
          <source>If the Observable produces more items than the observer requests, it is up to the Observable whether it will discard the excess items, store them to emit at a later time, or use some other strategy to deal with the overflow.</source>
          <target state="translated">Si el Observatorio produce más artículos de los que pide,depende del Observatorio si descartará los artículos sobrantes,los almacenará para emitirlos más adelante o utilizará alguna otra estrategia para hacer frente al desbordamiento.</target>
        </trans-unit>
        <trans-unit id="574236c3473cbd9e1a8324c3c8b4368c27b83052" translate="yes" xml:space="preserve">
          <source>If the predicate function returns &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt; will increment the tally of items that it will report when the source Observable completes. If you want to count &lt;em&gt;all&lt;/em&gt; of the items emitted by the source Observable, simply pass &lt;code&gt;count&lt;/code&gt; a predicate that always returns &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="translated">Si la funci&amp;oacute;n de predicado devuelve &lt;code&gt;true&lt;/code&gt; , el &lt;code&gt;count&lt;/code&gt; incrementar&amp;aacute; el recuento de elementos que informar&amp;aacute; cuando se complete el Observable de origen. Si desea contar &lt;em&gt;todos&lt;/em&gt; los elementos emitidos por la fuente Observable, simplemente pase a &lt;code&gt;count&lt;/code&gt; un predicado que siempre devuelva &lt;code&gt;true&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8eef9a5d07bff0abbbfddd99e1e6d78b055ea35c" translate="yes" xml:space="preserve">
          <source>If the source Observable emits no items (or no items that match the predicate), &lt;code&gt;first&lt;/code&gt; will terminate with a &amp;ldquo;&lt;code&gt;Sequence contains no elements.&lt;/code&gt;&amp;rdquo; &lt;code&gt;onError&lt;/code&gt; notification.</source>
          <target state="translated">Si la fuente Observable no emite elementos (o ning&amp;uacute;n elemento que coincida con el predicado), &lt;code&gt;first&lt;/code&gt; terminar&amp;aacute; con un &amp;ldquo;La &lt;code&gt;Sequence contains no elements.&lt;/code&gt; &amp;rdquo; Notificaci&amp;oacute;n de &lt;code&gt;onError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9453ca79c20e7c3d4fd2ab97401f3e8fafa02aee" translate="yes" xml:space="preserve">
          <source>If the source Observable emits no items (or no items that match the predicate), &lt;code&gt;last&lt;/code&gt; will terminate with a &amp;ldquo;&lt;code&gt;Sequence contains no elements.&lt;/code&gt;&amp;rdquo; &lt;code&gt;onError&lt;/code&gt; notification.</source>
          <target state="translated">Si la fuente Observable no emite elementos (o ning&amp;uacute;n elemento que coincida con el predicado), el &lt;code&gt;last&lt;/code&gt; terminar&amp;aacute; con un &amp;ldquo;La &lt;code&gt;Sequence contains no elements.&lt;/code&gt; &amp;rdquo; Notificaci&amp;oacute;n de &lt;code&gt;onError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa8c354d5fd059c1f261a3b43af7ba6bf089e618" translate="yes" xml:space="preserve">
          <source>If the source Observable invokes &lt;code&gt;onCompleted&lt;/code&gt; before emitting any items, the Observable returned by &lt;code&gt;toList&lt;/code&gt; will emit an empty list before invoking &lt;code&gt;onCompleted&lt;/code&gt;. If the source Observable invokes &lt;code&gt;onError&lt;/code&gt;, the Observable returned by &lt;code&gt;toList&lt;/code&gt; will immediately invoke the &lt;code&gt;onError&lt;/code&gt; methods of its observers.</source>
          <target state="translated">Si el Observable de origen invoca a &lt;code&gt;onCompleted&lt;/code&gt; antes de emitir cualquier elemento, el Observable devuelto por &lt;code&gt;toList&lt;/code&gt; emitir&amp;aacute; una lista vac&amp;iacute;a antes de invocar a &lt;code&gt;onCompleted&lt;/code&gt; . Si el Observable fuente invoca &lt;code&gt;onError&lt;/code&gt; , el Observable devuelto por &lt;code&gt;toList&lt;/code&gt; invocar&amp;aacute; inmediatamente los m&amp;eacute;todos &lt;code&gt;onError&lt;/code&gt; de sus observadores.</target>
        </trans-unit>
        <trans-unit id="ecb1875188746c3fc8a2a22c90eacf4a3b187726" translate="yes" xml:space="preserve">
          <source>If the source Observable is empty it returns an Observable that emits true, otherwise it emits false.</source>
          <target state="translated">Si la fuente observable está vacía,devuelve un observable que emite verdadero,de lo contrario emite falso.</target>
        </trans-unit>
        <trans-unit id="2e65b113c5ab2efc19f456b3ae0c066cd172ca0d" translate="yes" xml:space="preserve">
          <source>If the source Observable terminates with an error, Count will pass this error notification along without emitting an item first. If the source Observable does not terminate at all, Count will neither emit an item nor terminate.</source>
          <target state="translated">Si la fuente observable termina con un error,Conde pasará esta notificación de error sin emitir un artículo primero.Si la fuente observable no termina en absoluto,Count no emitirá un artículo ni terminará.</target>
        </trans-unit>
        <trans-unit id="f688a0570f5d1b8ac889532c92767877018306e3" translate="yes" xml:space="preserve">
          <source>If the source Observable terminates with an error, the &lt;code&gt;PublishSubject&lt;/code&gt; will not emit any items to subsequent observers, but will simply pass along the error notification from the source Observable.</source>
          <target state="translated">Si el Observable de origen termina con un error, &lt;code&gt;PublishSubject&lt;/code&gt; no emitir&amp;aacute; ning&amp;uacute;n elemento a los observadores posteriores, sino que simplemente enviar&amp;aacute; la notificaci&amp;oacute;n de error del Observable de origen.</target>
        </trans-unit>
        <trans-unit id="9bb4470ea625098ffc957da0e83887d5445085ec" translate="yes" xml:space="preserve">
          <source>If there is no element in the source sequence with the index value you specify, &lt;code&gt;elementAt&lt;/code&gt; will issue an &lt;code&gt;onError&lt;/code&gt; notification: &amp;ldquo;&lt;code&gt;Argument out of range&lt;/code&gt;&amp;rdquo;</source>
          <target state="translated">Si no hay ning&amp;uacute;n elemento en la secuencia de origen con el valor de &amp;iacute;ndice que especifique, &lt;code&gt;elementAt&lt;/code&gt; emitir&amp;aacute; una notificaci&amp;oacute;n de &lt;code&gt;onError&lt;/code&gt; : &quot; &lt;code&gt;Argument out of range&lt;/code&gt; &quot;</target>
        </trans-unit>
        <trans-unit id="0e894ab20d3a46c26c42e98c6dfcddf872f60c1f" translate="yes" xml:space="preserve">
          <source>If you apply the Replay operator to an Observable before you convert it into a connectable Observable, the resulting connectable Observable will always emit the same complete sequence to any future observers, even those observers that subscribe after the connectable Observable has begun to emit items to other subscribed observers.</source>
          <target state="translated">Si se aplica el operador Replay a un Observable antes de convertirlo en un Observable conectable,el Observable conectable resultante emitirá siempre la misma secuencia completa a cualquier observador futuro,incluso a aquellos observadores que se suscriban después de que el Observable conectable haya comenzado a emitir elementos a otros observadores suscritos.</target>
        </trans-unit>
        <trans-unit id="3097ba365bdc02567dbcce3f4aa13b9f891570a9" translate="yes" xml:space="preserve">
          <source>If you are only interested in the first item emitted by an Observable, or the first item that meets some criteria, you can filter the Observable with the First operator.</source>
          <target state="translated">Si sólo le interesa el primer elemento emitido por un Observable,o el primer elemento que cumple algunos criterios,puede filtrar el Observable con el Primer operador.</target>
        </trans-unit>
        <trans-unit id="52c46bce5c8de030e8f87b590429e41a9b0aa7c5" translate="yes" xml:space="preserve">
          <source>If you are only interested in the last item emitted by an Observable, or the last item that meets some criteria, you can filter the Observable with the Last operator.</source>
          <target state="translated">Si sólo le interesa el último elemento emitido por un Observable,o el último elemento que cumple algunos criterios,puede filtrar el Observable con el Último operador.</target>
        </trans-unit>
        <trans-unit id="cde6dfb819e5be751bb6438b8bc1e8380bd27d52" translate="yes" xml:space="preserve">
          <source>If you are unable to guarantee that your operator conforms to the above two tenets, you can add the &lt;a href=&quot;observable-utility-operators#serialize&quot;&gt;&lt;code&gt;serialize( )&lt;/code&gt;&lt;/a&gt; operator to it to force the correct behavior.</source>
          <target state="translated">Si no puede garantizar que su operador cumpla con los dos principios anteriores, puede agregarle el operador &lt;a href=&quot;observable-utility-operators#serialize&quot;&gt; &lt;code&gt;serialize( )&lt;/code&gt; &lt;/a&gt; para forzar el comportamiento correcto.</target>
        </trans-unit>
        <trans-unit id="2cb580494f8e2917761a21353dfc55e61852dd40" translate="yes" xml:space="preserve">
          <source>If you call the &lt;code&gt;pause&lt;/code&gt; method of a &lt;code&gt;PausableObservable&lt;/code&gt; created with the &lt;code&gt;pausable&lt;/code&gt; operator, it will drop (ignore) any items emitted by the underlying source Observable until such time as you call its &lt;code&gt;resume&lt;/code&gt; method, whereupon it will continue to pass along emitted items to its observers.</source>
          <target state="translated">Si llama al m&amp;eacute;todo de &lt;code&gt;pause&lt;/code&gt; de un &lt;code&gt;PausableObservable&lt;/code&gt; creado con el operador &lt;code&gt;pausable&lt;/code&gt; , descartar&amp;aacute; (ignorar&amp;aacute;) cualquier elemento emitido por la fuente subyacente Observable hasta el momento en que llame a su m&amp;eacute;todo &lt;code&gt;resume&lt;/code&gt; , despu&amp;eacute;s de lo cual continuar&amp;aacute; pasando los elementos emitidos a su observadores.</target>
        </trans-unit>
        <trans-unit id="0ebf1e42c4df41cf02c078fef78bef390ab290dc" translate="yes" xml:space="preserve">
          <source>If you call the &lt;code&gt;pause&lt;/code&gt; method of a &lt;code&gt;PausableObservable&lt;/code&gt; created with the &lt;code&gt;pausableBuffered&lt;/code&gt; operator, it will buffer any items emitted by the underlying source Observable until such time as you call its &lt;code&gt;resume&lt;/code&gt; method, whereupon it will emit those buffered items and then continue to pass along any additional emitted items to its observers.</source>
          <target state="translated">Si llama al m&amp;eacute;todo &lt;code&gt;pause&lt;/code&gt; de un &lt;code&gt;PausableObservable&lt;/code&gt; creado con el operador &lt;code&gt;pausableBuffered&lt;/code&gt; , almacenar&amp;aacute; en b&amp;uacute;fer los elementos emitidos por la fuente subyacente Observable hasta el momento en que llame a su m&amp;eacute;todo de &lt;code&gt;resume&lt;/code&gt; , despu&amp;eacute;s de lo cual emitir&amp;aacute; esos elementos almacenados en b&amp;uacute;fer y luego continuar&amp;aacute; transmitiendo cualquier elemento elementos adicionales emitidos a sus observadores.</target>
        </trans-unit>
        <trans-unit id="0c2ab002bb963be41d5c16f8da5e55d6b8a3fce9" translate="yes" xml:space="preserve">
          <source>If you do not care about the items being emitted by an Observable, but you do want to be notified when it completes or when it terminates with an error, you can apply the &lt;code&gt;ignoreElements&lt;/code&gt; operator to the Observable, which will ensure that it will never call its observers&amp;rsquo; &lt;code&gt;onNext&lt;/code&gt; handlers.</source>
          <target state="translated">Si no le importa que los elementos sean emitidos por un Observable, pero desea que se le notifique cuando se complete o cuando termine con un error, puede aplicar el operador &lt;code&gt;ignoreElements&lt;/code&gt; al Observable, lo que garantizar&amp;aacute; que nunca llamar&amp;aacute; los controladores &lt;code&gt;onNext&lt;/code&gt; de sus observadores .</target>
        </trans-unit>
        <trans-unit id="1d22ca088df792825f2a6dd1d5192358b2d0b360" translate="yes" xml:space="preserve">
          <source>If you do not specify a Scheduler, this variant of &lt;code&gt;window&lt;/code&gt; uses the &lt;code&gt;computation&lt;/code&gt; Scheduler for its timer by default.</source>
          <target state="translated">Si no especifica un Programador, esta variante de &lt;code&gt;window&lt;/code&gt; usa el Programador de &lt;code&gt;computation&lt;/code&gt; para su temporizador por defecto.</target>
        </trans-unit>
        <trans-unit id="100e150c378c4889cd317549f1e83b99541904e3" translate="yes" xml:space="preserve">
          <source>If you do not specify a Scheduler, this variant of &lt;code&gt;windowWithTime&lt;/code&gt; uses the &lt;code&gt;timeout&lt;/code&gt; Scheduler for its timer by default.</source>
          <target state="translated">Si no especifica un Programador, esta variante de &lt;code&gt;windowWithTime&lt;/code&gt; usa el Programador de &lt;code&gt;timeout&lt;/code&gt; para su temporizador de forma predeterminada.</target>
        </trans-unit>
        <trans-unit id="888dd3de98d14ac68c9106daa319827d52cfb772" translate="yes" xml:space="preserve">
          <source>If you do not specify a Scheduler, this variant of &lt;code&gt;windowWithTimeOrCount&lt;/code&gt; uses the &lt;code&gt;timeout&lt;/code&gt; Scheduler for its timer by default.</source>
          <target state="translated">Si no especifica un Programador, esta variante de &lt;code&gt;windowWithTimeOrCount&lt;/code&gt; usa el Programador de &lt;code&gt;timeout&lt;/code&gt; para su temporizador de forma predeterminada.</target>
        </trans-unit>
        <trans-unit id="b2211604bc2e7c059844a1087c3b24f75a19cf04" translate="yes" xml:space="preserve">
          <source>If you do not specify a Scheduler, this variant of &lt;code&gt;window_with_time&lt;/code&gt; uses the &lt;code&gt;timeout&lt;/code&gt; Scheduler for its timer by default.</source>
          <target state="translated">Si no especifica un Programador, esta variante de &lt;code&gt;window_with_time&lt;/code&gt; usa el Programador de &lt;code&gt;timeout&lt;/code&gt; para su temporizador de forma predeterminada.</target>
        </trans-unit>
        <trans-unit id="c494ea4ea43f0b89b77c160f3bc5c87d3d7f3fd4" translate="yes" xml:space="preserve">
          <source>If you do not specify a Scheduler, this variant of &lt;code&gt;window_with_time_or_count&lt;/code&gt; uses the &lt;code&gt;timeout&lt;/code&gt; Scheduler for its timer by default.</source>
          <target state="translated">Si no especifica un Programador, esta variante de &lt;code&gt;window_with_time_or_count&lt;/code&gt; usa el Programador de &lt;code&gt;timeout&lt;/code&gt; para su temporizador de forma predeterminada.</target>
        </trans-unit>
        <trans-unit id="d565ade5214a4fb6f8454dd74c4548834ae2dc50" translate="yes" xml:space="preserve">
          <source>If you have a &lt;code&gt;Subject&lt;/code&gt; and you want to pass it along to some other agent without exposing its &lt;code&gt;Subscriber&lt;/code&gt; interface, you can mask it by calling its &lt;code&gt;asObservable&lt;/code&gt; method, which will return the Subject as a pure &lt;code&gt;Observable&lt;/code&gt;.</source>
          <target state="translated">Si tiene un &lt;code&gt;Subject&lt;/code&gt; y desea pasarlo a otro agente sin exponer su interfaz de &lt;code&gt;Subscriber&lt;/code&gt; , puede enmascararlo llamando a su m&amp;eacute;todo &lt;code&gt;asObservable&lt;/code&gt; , que devolver&amp;aacute; el Asunto como un &lt;code&gt;Observable&lt;/code&gt; puro .</target>
        </trans-unit>
        <trans-unit id="f599ae77d4264a95da87490e66763c1573b59a6f" translate="yes" xml:space="preserve">
          <source>If you pass an Enumerable or Observable of Observables, you have the option of also passing in an integer indicating the maximum number of those Observables it should attempt to be subscribed to simultaneously. Once it reaches this maximum subscription count, it will refrain from subscribing to any other Observables emitted by the source Observable until such time as one of the already-subscribed-to Observables issues an &lt;code&gt;onCompleted&lt;/code&gt; notification.</source>
          <target state="translated">Si pasa un Enumerable u Observable of Observables, tiene la opci&amp;oacute;n de pasar tambi&amp;eacute;n un n&amp;uacute;mero entero que indique el n&amp;uacute;mero m&amp;aacute;ximo de esos Observables a los que debe intentar suscribirse simult&amp;aacute;neamente. Una vez que se alcanza este n&amp;uacute;mero m&amp;aacute;ximo de suscripci&amp;oacute;n, se abstendr&amp;aacute; de suscribirse a cualquier otro observables emitidos por la fuente observable hasta que una de las una ya suscrito a cuestiones observables &lt;code&gt;onCompleted&lt;/code&gt; notificaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="57eb4e1625176691f9e6cc11d8fa0b29717c9f7b" translate="yes" xml:space="preserve">
          <source>If you pass in a negative index value, &lt;code&gt;elementAt&lt;/code&gt; will throw an &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt;.</source>
          <target state="translated">Si pasa un valor de &amp;iacute;ndice negativo, &lt;code&gt;elementAt&lt;/code&gt; arrojar&amp;aacute; una &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd08e0ec3efa5ea25eaca8fcf04453442b6d2375" translate="yes" xml:space="preserve">
          <source>If you pass in a negative index value, or if the source Observable emits fewer than &lt;code&gt;&lt;i&gt;index
       value&lt;/i&gt;&amp;nbsp;+&amp;nbsp;1&lt;/code&gt; items, &lt;code&gt;elementAt&lt;/code&gt; will throw an &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt;.</source>
          <target state="translated">Si pasa un valor de &amp;iacute;ndice negativo, o si el Observable de origen emite menos que el &lt;code&gt;&lt;i&gt;index value&lt;/i&gt;&amp;nbsp;+&amp;nbsp;1&lt;/code&gt; elementos, &lt;code&gt;elementAt&lt;/code&gt; arrojar&amp;aacute; una &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2bb67bd2fcbd71bad891a7d78a921dd997297707" translate="yes" xml:space="preserve">
          <source>If you pass in an Observable of Observables, you have the option of also passing in a value indicating to &lt;code&gt;merge&lt;/code&gt; the maximum number of those Observables it should attempt to be subscribed to simultaneously. Once it reaches this maximum subscription count, it will refrain from subscribing to any other Observables emitted by the source Observable until such time as one of the already-subscribed-to Observables issues an &lt;code&gt;onCompleted&lt;/code&gt; notification.</source>
          <target state="translated">Si pasa en un Observable of Observables, tiene la opci&amp;oacute;n de pasar tambi&amp;eacute;n un valor que indique &lt;code&gt;merge&lt;/code&gt; el n&amp;uacute;mero m&amp;aacute;ximo de esos Observables a los que deber&amp;iacute;a intentar suscribirse simult&amp;aacute;neamente. Una vez que se alcanza este n&amp;uacute;mero m&amp;aacute;ximo de suscripci&amp;oacute;n, se abstendr&amp;aacute; de suscribirse a cualquier otro observables emitidos por la fuente observable hasta que una de las una ya suscrito a cuestiones observables &lt;code&gt;onCompleted&lt;/code&gt; notificaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="eb5aeff66e4f4beed635dbbd159c10910227639f" translate="yes" xml:space="preserve">
          <source>If you pass it no parameters, it will trigger a subscription to the underlying Observable, but will ignore its emissions and notifications. This will activate a cold Observable.</source>
          <target state="translated">Si no le pasas ningún parámetro,activará una suscripción al Observable subyacente,pero ignorará sus emisiones y notificaciones.Esto activará un Observable frío.</target>
        </trans-unit>
        <trans-unit id="cc00be547db596f59e064ee2c08761c5578d5d79" translate="yes" xml:space="preserve">
          <source>If you unsubscribe from one of the &lt;code&gt;GroupedObservable&lt;/code&gt;s, or if an operator like &lt;code&gt;take&lt;/code&gt; that you apply to the &lt;code&gt;GroupedObservable&lt;/code&gt; unsubscribes from it, that &lt;code&gt;GroupedObservable&lt;/code&gt; will be terminated. If the source Observable later emits an item whose key matches the &lt;code&gt;GroupedObservable&lt;/code&gt; that was terminated in this way, &lt;code&gt;groupBy&lt;/code&gt; will create and emit a &lt;em&gt;new&lt;/em&gt;&lt;code&gt;GroupedObservable&lt;/code&gt; to match the key. In other words, unsubscribing from a &lt;code&gt;GroupedObservable&lt;/code&gt; will &lt;em&gt;not&lt;/em&gt; cause &lt;code&gt;groupBy&lt;/code&gt; to swallow items from its group. For example, see the following code:</source>
          <target state="translated">Si se da de baja de uno de los &lt;code&gt;GroupedObservable&lt;/code&gt; , o si un operador como &lt;code&gt;take&lt;/code&gt; que usted aplica a &lt;code&gt;GroupedObservable&lt;/code&gt; se da de baja, ese &lt;code&gt;GroupedObservable&lt;/code&gt; se cancelar&amp;aacute;. Si el Observable de origen emite posteriormente un elemento cuya clave coincide con &lt;code&gt;GroupedObservable&lt;/code&gt; que se termin&amp;oacute; de esta manera, &lt;code&gt;groupBy&lt;/code&gt; crear&amp;aacute; y emitir&amp;aacute; un &lt;em&gt;nuevo &lt;/em&gt; &lt;code&gt;GroupedObservable&lt;/code&gt; para que coincida con la clave. En otras palabras, darse de baja de un &lt;code&gt;GroupedObservable&lt;/code&gt; ser&amp;aacute; &lt;em&gt;no&lt;/em&gt; causa &lt;code&gt;groupBy&lt;/code&gt; de tragar art&amp;iacute;culos de su grupo. Por ejemplo, consulte el siguiente c&amp;oacute;digo:</target>
        </trans-unit>
        <trans-unit id="f27ee58c426e22c185bfcc111ee4433c42e68d05" translate="yes" xml:space="preserve">
          <source>If you unsubscribe from one of the &lt;code&gt;GroupedObservable&lt;/code&gt;s, that &lt;code&gt;GroupedObservable&lt;/code&gt; will be terminated. If the source Observable later emits an item whose key matches the &lt;code&gt;GroupedObservable&lt;/code&gt; that was terminated in this way, &lt;code&gt;groupBy&lt;/code&gt; will create and emit a new &lt;code&gt;GroupedObservable&lt;/code&gt; to match the key.</source>
          <target state="translated">Si &lt;code&gt;GroupedObservable&lt;/code&gt; su suscripci&amp;oacute;n a uno de los GroupedObservable , ese &lt;code&gt;GroupedObservable&lt;/code&gt; se cancelar&amp;aacute;. Si el Observable de origen emite posteriormente un elemento cuya clave coincide con el &lt;code&gt;GroupedObservable&lt;/code&gt; que se termin&amp;oacute; de esta manera, &lt;code&gt;groupBy&lt;/code&gt; crear&amp;aacute; y emitir&amp;aacute; un nuevo &lt;code&gt;GroupedObservable&lt;/code&gt; para que coincida con la clave.</target>
        </trans-unit>
        <trans-unit id="54bb9339c9f0a6407d30c5087cb9c774545f641e" translate="yes" xml:space="preserve">
          <source>If you use a &lt;code&gt;ReplaySubject&lt;/code&gt; as an observer, take care not to call its &lt;code&gt;onNext&lt;/code&gt; method (or its other &lt;code&gt;on&lt;/code&gt; methods) from multiple threads, as this could lead to coincident (non-sequential) calls, which violates &lt;a href=&quot;contract&quot;&gt;the Observable contract&lt;/a&gt; and creates an ambiguity in the resulting Subject as to which item or notification should be replayed first.</source>
          <target state="translated">Si usa un &lt;code&gt;ReplaySubject&lt;/code&gt; como observador, tenga cuidado de no llamar a su m&amp;eacute;todo &lt;code&gt;onNext&lt;/code&gt; (u otros m&amp;eacute;todos &lt;code&gt;on&lt;/code&gt; ) desde m&amp;uacute;ltiples subprocesos, ya que esto podr&amp;iacute;a conducir a llamadas coincidentes (no secuenciales), lo que viola &lt;a href=&quot;contract&quot;&gt;el contrato Observable&lt;/a&gt; y crea una ambig&amp;uuml;edad en el Asunto resultante en cuanto a qu&amp;eacute; elemento o notificaci&amp;oacute;n debe reproducirse primero.</target>
        </trans-unit>
        <trans-unit id="ee0d3520b5f3d10a48dc017e12fbce21ddb7dc02" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;take(&lt;i&gt;n&lt;/i&gt;)&lt;/code&gt; operator (or its synonym, &lt;code&gt;limit(&lt;i&gt;n&lt;/i&gt;)&lt;/code&gt;) on an Observable, and that Observable emits fewer than</source>
          <target state="translated">Si usa el operador &lt;code&gt;take(&lt;i&gt;n&lt;/i&gt;)&lt;/code&gt; (o su sin&amp;oacute;nimo, &lt;code&gt;limit(&lt;i&gt;n&lt;/i&gt;)&lt;/code&gt; ) en un Observable, y ese Observable emite menos de</target>
        </trans-unit>
        <trans-unit id="cb665f0140ca7cfd676978a94899df0df149f98a" translate="yes" xml:space="preserve">
          <source>If you want an Observable to emit a specific sequence of items before it begins emitting the items normally expected from it, apply the StartWith operator to it.</source>
          <target state="translated">Si quiere que un Observable emita una secuencia específica de elementos antes de que empiece a emitir los elementos que normalmente se esperan de él,aplíquele el operador StartWith.</target>
        </trans-unit>
        <trans-unit id="ed9b26cc4846dd7ff3a51b44674d518103045141" translate="yes" xml:space="preserve">
          <source>If you want to convert an Observable that may emit multiple items into a &lt;code&gt;Future&lt;/code&gt;, try something like this: &lt;code&gt;myObservable.toList().toBlocking().toFuture()&lt;/code&gt;.</source>
          <target state="translated">Si desea convertir un Observable que puede emitir varios elementos en un &lt;code&gt;Future&lt;/code&gt; , intente algo como esto: &lt;code&gt;myObservable.toList().toBlocking().toFuture()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="126fda7bd3aebaa0b8ff116732464d2b0b7d7b8b" translate="yes" xml:space="preserve">
          <source>If you want to implement your own operator, see &lt;a href=&quot;implement-operator&quot;&gt;Implementing Your Own Operators&lt;/a&gt;.</source>
          <target state="translated">Si desea implementar su propio operador, consulte &lt;a href=&quot;implement-operator&quot;&gt;Implementaci&amp;oacute;n de sus propios operadores&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f09f724f096a4aeef1d6681ca23a57c6938f183" translate="yes" xml:space="preserve">
          <source>If you want to introduce multithreading into your cascade of Observable operators, you can do so by instructing those operators (or particular Observables) to operate on particular</source>
          <target state="translated">Si desea introducir el multihilo en su cascada de operadores Observables,puede hacerlo instruyendo a esos operadores (o a determinados Observables)para que operen en determinados</target>
        </trans-unit>
        <trans-unit id="bf253b6526751dab305e3b5af636233ab2cfc540" translate="yes" xml:space="preserve">
          <source>If your operator is designed to &lt;em&gt;originate&lt;/em&gt; an Observable, rather than to transform or react to a source Observable, use the &lt;a href=&quot;operators/create&quot;&gt;&lt;code&gt;create( )&lt;/code&gt;&lt;/a&gt; method rather than trying to implement &lt;code&gt;Observable&lt;/code&gt; manually. Otherwise, follow the instructions below.</source>
          <target state="translated">Si su operador est&amp;aacute; dise&amp;ntilde;ado para &lt;em&gt;originar&lt;/em&gt; un Observable, en lugar de transformar o reaccionar a un Observable de origen, use el m&amp;eacute;todo &lt;a href=&quot;operators/create&quot;&gt; &lt;code&gt;create( )&lt;/code&gt; &lt;/a&gt; lugar de intentar implementar &lt;code&gt;Observable&lt;/code&gt; manualmente. De lo contrario, siga las instrucciones a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1a4b5013699939e2ed2c63f5435fe7f247de7353" translate="yes" xml:space="preserve">
          <source>If your operator uses functions or lambdas that are passed in as parameters (predicates, for instance), note that these may be sources of exceptions, and be prepared to catch these and notify subscribers via &lt;code&gt;onError( )&lt;/code&gt; calls.</source>
          <target state="translated">Si su operador usa funciones o lambdas que se pasan como par&amp;aacute;metros (predicados, por ejemplo), tenga en cuenta que estas pueden ser fuentes de excepciones y est&amp;eacute; preparado para detectarlas y notificar a los suscriptores a trav&amp;eacute;s de llamadas &lt;code&gt;onError( )&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d10a49a1c9f362ffcdd30bcc2d70e20ca8a33fb" translate="yes" xml:space="preserve">
          <source>IgnoreElements</source>
          <target state="translated">IgnoreElements</target>
        </trans-unit>
        <trans-unit id="6e3bf6a26e7b015407f7e23c30d9aad02237ac19" translate="yes" xml:space="preserve">
          <source>Implementing Your Operator</source>
          <target state="translated">Implementación de su operador</target>
        </trans-unit>
        <trans-unit id="080201a38e03e3f517b6f68adc6f2cdb032d6de9" translate="yes" xml:space="preserve">
          <source>Implementing Your Own Operators</source>
          <target state="translated">Implementar sus propios operadores</target>
        </trans-unit>
        <trans-unit id="d9746961ed48f27eba42c580dc7c910e85405477" translate="yes" xml:space="preserve">
          <source>In ReactiveX an</source>
          <target state="translated">En ReactiveX y</target>
        </trans-unit>
        <trans-unit id="e07101b5e398b22985de43fce99e80ccc71f4b18" translate="yes" xml:space="preserve">
          <source>In ReactiveX it is not difficult to get into a situation in which an Observable is emitting items more rapidly than an operator or observer can consume them. This presents the problem of what to do with such a growing backlog of unconsumed items.</source>
          <target state="translated">En ReactiveX no es difícil llegar a una situación en la que un Observador esté emitiendo artículos más rápidamente de lo que un operador u observador puede consumirlos.Esto plantea el problema de qué hacer con tal cantidad creciente de artículos no consumidos.</target>
        </trans-unit>
        <trans-unit id="4d88767b8ff979df7115dbd13cc1795448ccafca" translate="yes" xml:space="preserve">
          <source>In Rx.NET the Observable this operator creates emits an Integer value, but there is also a &lt;code&gt;LongCount&lt;/code&gt; whose Observable emits a Long value. With both variants, you can either pass the source Observable in to the operator as a parameter or you can call the operator as an instance method of the source Observable (in which case you omit the parameter).</source>
          <target state="translated">En Rx.NET, el Observable que este operador crea emite un valor Integer, pero tambi&amp;eacute;n hay un &lt;code&gt;LongCount&lt;/code&gt; cuyo Observable emite un valor Long. Con ambas variantes, puede pasar la fuente Observable al operador como par&amp;aacute;metro o puede llamar al operador como un m&amp;eacute;todo de instancia de la fuente Observable (en cuyo caso omite el par&amp;aacute;metro).</target>
        </trans-unit>
        <trans-unit id="082753d6aa99a3e49c22beaa10c53f7d50ccf53c" translate="yes" xml:space="preserve">
          <source>In Rx.NET there are several variants of Buffer. For each variety you can either pass in the source Observable as the first parameter, or you can call it as an instance method of the source Observable (in which case you can omit that parameter):</source>
          <target state="translated">En Rx.NET hay varias variantes de Buffer.Para cada variante se puede pasar la fuente Observable como primer parámetro,o se puede llamarla como un método de instancia de la fuente Observable (en cuyo caso se puede omitir ese parámetro):</target>
        </trans-unit>
        <trans-unit id="866459115059c570312783d7d933eb56a2044752" translate="yes" xml:space="preserve">
          <source>In Rx.rb you have the option to pass &lt;code&gt;count&lt;/code&gt; a predicate that takes an item emitted by the source Observable as a parameter. If you do so, &lt;code&gt;count&lt;/code&gt; will emit a count only of those items from the source Observable that the predicate evaluates as &lt;code&gt;true&lt;/code&gt;. Otherwise it will emit a count of all items emitted by the source Observable.</source>
          <target state="translated">En Rx.rb usted tiene la opci&amp;oacute;n de pasar a &lt;code&gt;count&lt;/code&gt; un predicado que tiene un elemento que emite la fuente observable como par&amp;aacute;metro. Si lo hace, &lt;code&gt;count&lt;/code&gt; emitir&amp;aacute; un recuento solo de aquellos elementos de la fuente Observable que el predicado eval&amp;uacute;a como &lt;code&gt;true&lt;/code&gt; . De lo contrario, emitir&amp;aacute; un recuento de todos los elementos emitidos por la fuente Observable.</target>
        </trans-unit>
        <trans-unit id="174c58d2e87272ea8e66142ea84c078a35283c3e" translate="yes" xml:space="preserve">
          <source>In Rx.rb, &lt;code&gt;on_error_resume_next&lt;/code&gt; inherits the misleading nomenclature from Rx.NET in that it concatenates the second Observable sequence to the source sequence whether that source sequence terminates normally or with an error.</source>
          <target state="translated">En Rx.rb, &lt;code&gt;on_error_resume_next&lt;/code&gt; hereda la nomenclatura enga&amp;ntilde;osa de Rx.NET en el sentido de que concatena la segunda secuencia observable con la secuencia fuente, ya sea que esa secuencia fuente termine normalmente o con un error.</target>
        </trans-unit>
        <trans-unit id="3dc1fcc902763003b44007791de3712de7a57a0c" translate="yes" xml:space="preserve">
          <source>In Rx.rb, the &lt;code&gt;concat&lt;/code&gt; operator operates on two Observables as an instance operator, or on an array of Observables as a class method.</source>
          <target state="translated">En Rx.rb, el operador &lt;code&gt;concat&lt;/code&gt; opera en dos Observables como operador de instancia, o en una matriz de Observables como m&amp;eacute;todo de clase.</target>
        </trans-unit>
        <trans-unit id="c3abf8fb4fa82e726050a8136a37f39dd9dbaf32" translate="yes" xml:space="preserve">
          <source>In RxClojure &lt;code&gt;concat&lt;/code&gt; concatenates some number of individual Observables together in the order in which they are given.</source>
          <target state="translated">En RxClojure, &lt;code&gt;concat&lt;/code&gt; concatena una cierta cantidad de Observables individuales en el orden en que se dan.</target>
        </trans-unit>
        <trans-unit id="bc54b08c66d20cbbb553766813dfa06d5c1e25ba" translate="yes" xml:space="preserve">
          <source>In RxClojure there are six operators of concern here:</source>
          <target state="translated">En RxClojure hay seis operadores de interés aquí:</target>
        </trans-unit>
        <trans-unit id="659fe011d5c89b01a2304a5c8e2bb81d2ad313c9" translate="yes" xml:space="preserve">
          <source>In RxGroovy the operator is called &lt;code&gt;count&lt;/code&gt; and the Observable it creates emits an Integer value. There is also a &lt;code&gt;countLong&lt;/code&gt; whose Observable emits a Long value.</source>
          <target state="translated">En RxGroovy, el operador se llama &lt;code&gt;count&lt;/code&gt; y el Observable que crea emite un valor entero. Tambi&amp;eacute;n hay un &lt;code&gt;countLong&lt;/code&gt; cuyo Observable emite un valor Long.</target>
        </trans-unit>
        <trans-unit id="d76cd52669eae9e069058fa6344e3c8d433d43c8" translate="yes" xml:space="preserve">
          <source>In RxGroovy there are several variants of Buffer:</source>
          <target state="translated">En RxGroovy hay varias variantes de Buffer:</target>
        </trans-unit>
        <trans-unit id="03bd02f7f4db8f2104aaf4dd90fc1dad471cf32a" translate="yes" xml:space="preserve">
          <source>In RxGroovy there is a variety of the &lt;code&gt;replay&lt;/code&gt; operator that returns a connectable Observable. You must &lt;a href=&quot;publish&quot;&gt;Publish&lt;/a&gt; this connectable Observable before observers can subscribe to it, and then &lt;a href=&quot;connect&quot;&gt;Connect&lt;/a&gt; to it in order to observe its emissions.</source>
          <target state="translated">En RxGroovy hay una variedad del operador de &lt;code&gt;replay&lt;/code&gt; que devuelve un Observable conectable. Debe &lt;a href=&quot;publish&quot;&gt;publicar&lt;/a&gt; este Observable conectable antes de que los observadores puedan suscribirse a &amp;eacute;l y luego &lt;a href=&quot;connect&quot;&gt;Conectarse&lt;/a&gt; a &amp;eacute;l para observar sus emisiones.</target>
        </trans-unit>
        <trans-unit id="4db754926010b838dcaf35e54ecc9e4308fc9f4d" translate="yes" xml:space="preserve">
          <source>In RxGroovy there is also a version of the &lt;a href=&quot;from&quot;&gt;From&lt;/a&gt; operator that converts a &lt;code&gt;Future&lt;/code&gt; into an Observable, and in this way resembles the Start operator.</source>
          <target state="translated">En RxGroovy tambi&amp;eacute;n existe una versi&amp;oacute;n del operador &lt;a href=&quot;from&quot;&gt;From&lt;/a&gt; que convierte un &lt;code&gt;Future&lt;/code&gt; en un Observable, y de esta manera se asemeja al operador Start.</target>
        </trans-unit>
        <trans-unit id="7572e0a31faefbf7ff70dca0814645c09d2770c6" translate="yes" xml:space="preserve">
          <source>In RxGroovy, &lt;code&gt;doWhile&lt;/code&gt; is not part of the standard set of operators, but is part of the optional &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; package. &lt;code&gt;doWhile&lt;/code&gt; checks a condition after each repetition of the source sequence, and only repeats it if that condition is true.</source>
          <target state="translated">En RxGroovy, &lt;code&gt;doWhile&lt;/code&gt; no es parte del conjunto est&amp;aacute;ndar de operadores, pero es parte del &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; opcional rxjava-computation-expression . &lt;code&gt;doWhile&lt;/code&gt; comprueba una condici&amp;oacute;n despu&amp;eacute;s de cada repetici&amp;oacute;n de la secuencia de origen y solo la repite si esa condici&amp;oacute;n es verdadera.</target>
        </trans-unit>
        <trans-unit id="3aa8ae88df582d489c98f809e108617b6f090787" translate="yes" xml:space="preserve">
          <source>In RxGroovy, &lt;code&gt;materialize&lt;/code&gt; transforms the notifications from the source Observable into &lt;code&gt;Notification&lt;/code&gt; objects and emits them as the emissions from the Observable it returns. For example:</source>
          <target state="translated">En RxGroovy, &lt;code&gt;materialize&lt;/code&gt; transforma las notificaciones de la fuente Observable en objetos de &lt;code&gt;Notification&lt;/code&gt; y las emite como las emisiones del Observable retorna. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="237f50a50a7216fd4056fb13f9fb3ed56266ba27" translate="yes" xml:space="preserve">
          <source>In RxGroovy, &lt;code&gt;whileDo&lt;/code&gt; is not part of the standard set of operators, but is part of the optional &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; package. &lt;code&gt;whileDo&lt;/code&gt; checks a condition before each repetition of the source sequence, and only repeats it if that condition is true.</source>
          <target state="translated">En RxGroovy, &lt;code&gt;whileDo&lt;/code&gt; no es parte del conjunto est&amp;aacute;ndar de operadores, pero es parte del &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; opcional rxjava-computation-expression . &lt;code&gt;whileDo&lt;/code&gt; comprueba una condici&amp;oacute;n antes de cada repetici&amp;oacute;n de la secuencia de origen y solo la repite si esa condici&amp;oacute;n es verdadera.</target>
        </trans-unit>
        <trans-unit id="dc4459eb5576a0985852d40aad97090be35fe7fe" translate="yes" xml:space="preserve">
          <source>In RxGroovy, the &lt;code&gt;connect&lt;/code&gt; operator is a method of the &lt;code&gt;ConnectableObservable&lt;/code&gt; interface. You can use the &lt;code&gt;publish&lt;/code&gt; operator to convert an ordinary Observable into a &lt;code&gt;ConnectableObservable&lt;/code&gt;.</source>
          <target state="translated">En RxGroovy, el operador de &lt;code&gt;connect&lt;/code&gt; es un m&amp;eacute;todo de la interfaz &lt;code&gt;ConnectableObservable&lt;/code&gt; . Puede utilizar el operador de &lt;code&gt;publish&lt;/code&gt; para convertir un Observable ordinario en un &lt;code&gt;ConnectableObservable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0218c1d751cc26a5e8cbb187a070d185be55fd96" translate="yes" xml:space="preserve">
          <source>In RxGroovy, the &lt;code&gt;from&lt;/code&gt; operator can convert a Future, an Iterable, or an Array. In the case of an Iterable or an Array, the resulting Observable will emit each item contained in the Iterable or Array.</source>
          <target state="translated">En RxGroovy, el operador &lt;code&gt;from&lt;/code&gt; puede convertir un Future, un Iterable o un Array. En el caso de un Iterable o un Array, el Observable resultante emitir&amp;aacute; cada elemento contenido en el Iterable o Array.</target>
        </trans-unit>
        <trans-unit id="077b76d936cc54a4fbdf52bb6a3d71bca4542ef9" translate="yes" xml:space="preserve">
          <source>In RxGroovy, these are not part of the core ReactiveX implementation, but are found as &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;then&lt;/code&gt;, and &lt;code&gt;when&lt;/code&gt; in the &lt;code&gt;rxjava-joins&lt;/code&gt; module.</source>
          <target state="translated">En RxGroovy, estos no son parte de la implementaci&amp;oacute;n principal de ReactiveX, pero se encuentran como &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;then&lt;/code&gt; , y &lt;code&gt;when&lt;/code&gt; en el m&amp;oacute;dulo &lt;code&gt;rxjava-joins&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98c6ab7a826f68ee896f9e7bbec6a50b13018591" translate="yes" xml:space="preserve">
          <source>In RxGroovy, this filtering operator is implemented as &lt;code&gt;first&lt;/code&gt;, &lt;code&gt;firstOrDefault&lt;/code&gt;, and &lt;code&gt;takeFirst&lt;/code&gt;.</source>
          <target state="translated">En RxGroovy, este operador de filtrado se implementa como &lt;code&gt;first&lt;/code&gt; , &lt;code&gt;firstOrDefault&lt;/code&gt; y &lt;code&gt;takeFirst&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29837dbff839813080383499d8c69a5c010c8559" translate="yes" xml:space="preserve">
          <source>In RxGroovy, this filtering operator is implemented as &lt;code&gt;last&lt;/code&gt; and &lt;code&gt;lastOrDefault&lt;/code&gt;.</source>
          <target state="translated">En RxGroovy, este operador de filtrado se implementa como &lt;code&gt;last&lt;/code&gt; y &lt;code&gt;lastOrDefault&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="524670218e1528528dc3e43a23a6e9ec903626f3" translate="yes" xml:space="preserve">
          <source>In RxGroovy, this operator is implemented as &lt;code&gt;skip&lt;/code&gt;.</source>
          <target state="translated">En RxGroovy, este operador se implementa como &lt;code&gt;skip&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8a0032a96a9e999b2568c2953d3e8ba98be07a8" translate="yes" xml:space="preserve">
          <source>In RxGroovy, this operator is implemented as &lt;code&gt;skipUntil&lt;/code&gt;.</source>
          <target state="translated">En RxGroovy, este operador se implementa como &lt;code&gt;skipUntil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ab9e4908bb4235f47b80c1c77b023791f672cb3" translate="yes" xml:space="preserve">
          <source>In RxGroovy, this operator is implemented as &lt;code&gt;take&lt;/code&gt;.</source>
          <target state="translated">En RxGroovy, este operador se implementa como &lt;code&gt;take&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5071f8b712a1a2faafa543e15f33108e9b05eb0e" translate="yes" xml:space="preserve">
          <source>In RxGroovy, this operator is implemented as &lt;code&gt;takeUntil&lt;/code&gt;. Note that the second Observable can cause &lt;code&gt;takeUntil&lt;/code&gt; to quit emitting items either by emitting an item or by issuing an &lt;code&gt;onError&lt;/code&gt; or &lt;code&gt;onCompleted&lt;/code&gt; notification.</source>
          <target state="translated">En RxGroovy, este operador se implementa como &lt;code&gt;takeUntil&lt;/code&gt; . Tenga en cuenta que el segundo Observable puede hacer que &lt;code&gt;takeUntil&lt;/code&gt; deje de emitir elementos, ya sea emitiendo un elemento o emitiendo una notificaci&amp;oacute;n &lt;code&gt;onError&lt;/code&gt; o &lt;code&gt;onCompleted&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da02f4576a4b5a5747703904db2371ebcf038e26" translate="yes" xml:space="preserve">
          <source>In RxGroovy, this operator is not in the ReactiveX core, but is part of the distinct &lt;code&gt;rxjava-math&lt;/code&gt; module, where it is implemented with four type-specific operators: &lt;code&gt;averageDouble&lt;/code&gt;, &lt;code&gt;averageFloat&lt;/code&gt;, &lt;code&gt;averageInteger&lt;/code&gt;, and &lt;code&gt;averageLong&lt;/code&gt;. The following example shows how these operators work:</source>
          <target state="translated">En RxGroovy, este operador no est&amp;aacute; en el n&amp;uacute;cleo ReactiveX, pero es parte de la distinta &lt;code&gt;rxjava-math&lt;/code&gt; m&amp;oacute;dulo, donde se implementa con cuatro operadores espec&amp;iacute;ficos del tipo: &lt;code&gt;averageDouble&lt;/code&gt; , &lt;code&gt;averageFloat&lt;/code&gt; , &lt;code&gt;averageInteger&lt;/code&gt; , y &lt;code&gt;averageLong&lt;/code&gt; . El siguiente ejemplo muestra c&amp;oacute;mo funcionan estos operadores:</target>
        </trans-unit>
        <trans-unit id="badd3303a8eb778bfc48d7a87db09f83d8fb14fa" translate="yes" xml:space="preserve">
          <source>In RxGroovy, this operator is not in the ReactiveX core, but is part of the distinct &lt;code&gt;rxjava-math&lt;/code&gt; module, where it is implemented with four type-specific operators: &lt;code&gt;sumDouble&lt;/code&gt;, &lt;code&gt;sumFloat&lt;/code&gt;, &lt;code&gt;sumInteger&lt;/code&gt;, and &lt;code&gt;sumLong&lt;/code&gt;. The following example shows how these operators work:</source>
          <target state="translated">En RxGroovy, este operador no est&amp;aacute; en el n&amp;uacute;cleo ReactiveX, pero es parte del m&amp;oacute;dulo &lt;code&gt;rxjava-math&lt;/code&gt; distinto , donde se implementa con cuatro operadores espec&amp;iacute;ficos de tipo: &lt;code&gt;sumDouble&lt;/code&gt; , &lt;code&gt;sumFloat&lt;/code&gt; , &lt;code&gt;sumInteger&lt;/code&gt; y &lt;code&gt;sumLong&lt;/code&gt; . El siguiente ejemplo muestra c&amp;oacute;mo funcionan estos operadores:</target>
        </trans-unit>
        <trans-unit id="c07cae2ff645e10f1475b173e92b2e4d1731fbd8" translate="yes" xml:space="preserve">
          <source>In RxGroovy, this operator is not in the ReactiveX core, but is part of the distinct &lt;code&gt;rxjava-math&lt;/code&gt; module.</source>
          <target state="translated">En RxGroovy, este operador no est&amp;aacute; en el n&amp;uacute;cleo de ReactiveX, pero es parte del m&amp;oacute;dulo &lt;code&gt;rxjava-math&lt;/code&gt; distintivo .</target>
        </trans-unit>
        <trans-unit id="39f81aa6294cb9c74bcf4eb9eeea361e7952d8bb" translate="yes" xml:space="preserve">
          <source>In RxJS the operator &lt;code&gt;count&lt;/code&gt; counts the number of items in the source Observable that satisfy a specified predicate. That predicate takes the form of a function that takes three parameters:</source>
          <target state="translated">En RxJS, el operador &lt;code&gt;count&lt;/code&gt; cuenta el n&amp;uacute;mero de elementos en la fuente Observable que satisfacen un predicado espec&amp;iacute;fico. Ese predicado toma la forma de una funci&amp;oacute;n que toma tres par&amp;aacute;metros:</target>
        </trans-unit>
        <trans-unit id="089ff40ee2d57ffddd76d98e11442fdb0f93e79e" translate="yes" xml:space="preserve">
          <source>In RxJS there are two versions of the &lt;code&gt;timer&lt;/code&gt; operator.</source>
          <target state="translated">En RxJS hay dos versiones del operador de &lt;code&gt;timer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="546ed95cf4899b2546736d0dc77f0000eca5cc15" translate="yes" xml:space="preserve">
          <source>In RxJS you can set the per-item delay in two ways: by passing a number of milliseconds into the &lt;code&gt;delay&lt;/code&gt; operator (which will delay each emission by that amount of time), or by passing in a &lt;code&gt;Date&lt;/code&gt; object (which will delay the beginning of the sequence of emissions until that absolute point in time).</source>
          <target state="translated">En RxJS puede establecer la demora por elemento de dos maneras: pasando una cantidad de milisegundos en el operador de &lt;code&gt;delay&lt;/code&gt; (que retrasar&amp;aacute; cada emisi&amp;oacute;n en esa cantidad de tiempo), o pasando un objeto &lt;code&gt;Date&lt;/code&gt; (que retrasar&amp;aacute; el comienzo de la secuencia de emisiones hasta ese momento absoluto).</target>
        </trans-unit>
        <trans-unit id="a91657e27431e8473a66e219d9cffa8076861683" translate="yes" xml:space="preserve">
          <source>In RxJS you obtain Schedulers from the &lt;code&gt;Rx.Scheduler&lt;/code&gt; object or as independently-implemented objects. The following table shows the varieties of Scheduler that are available to you in RxJS:.</source>
          <target state="translated">En RxJS, obtiene planificadores del objeto &lt;code&gt;Rx.Scheduler&lt;/code&gt; o como objetos implementados de forma independiente. La siguiente tabla muestra las variedades de Scheduler que est&amp;aacute;n disponibles en RxJS :.</target>
        </trans-unit>
        <trans-unit id="59380515fb1764dd57d6d356f045c860c3897dad" translate="yes" xml:space="preserve">
          <source>In RxJS, &lt;code&gt;sequenceEqual&lt;/code&gt; is a method of a particular Observable instance, so you pass it exactly one other Observable to compare the instance to. You can optionally pass a second parameter: a function that accepts two items and returns &lt;code&gt;true&lt;/code&gt; if they are equal according to a standard of your choosing. &lt;code&gt;sequenceEqual&lt;/code&gt; returns an Observable that will emit a &lt;code&gt;true&lt;/code&gt; if the two Observables emit the same set of items in the same order before completing, or a &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">En RxJS, &lt;code&gt;sequenceEqual&lt;/code&gt; es un m&amp;eacute;todo de una instancia de Observable particular, por lo que le pasa exactamente otro Observable para comparar la instancia. Opcionalmente, puede pasar un segundo par&amp;aacute;metro: una funci&amp;oacute;n que acepta dos elementos y devuelve &lt;code&gt;true&lt;/code&gt; si son iguales de acuerdo con un est&amp;aacute;ndar de su elecci&amp;oacute;n. &lt;code&gt;sequenceEqual&lt;/code&gt; devuelve un Observable que emitir&amp;aacute; un &lt;code&gt;true&lt;/code&gt; si los dos Observables emiten el mismo conjunto de elementos en el mismo orden antes de completar, o un &lt;code&gt;false&lt;/code&gt; caso contrario.</target>
        </trans-unit>
        <trans-unit id="e39fb67c9a541a9b33aa36d76685b7973746c9cf" translate="yes" xml:space="preserve">
          <source>In RxJS, the &lt;code&gt;connect&lt;/code&gt; operator is a method of the &lt;code&gt;ConnectableObservable&lt;/code&gt; prototype. You can use the &lt;code&gt;publish&lt;/code&gt; operator to convert an ordinary Observable into a &lt;code&gt;ConnectableObservable&lt;/code&gt;.</source>
          <target state="translated">En RxJS, el operador de &lt;code&gt;connect&lt;/code&gt; es un m&amp;eacute;todo del prototipo &lt;code&gt;ConnectableObservable&lt;/code&gt; . Puede utilizar el operador de &lt;code&gt;publish&lt;/code&gt; para convertir un Observable ordinario en un &lt;code&gt;ConnectableObservable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d1dad5015733748479ef787bfb5054f381799c6" translate="yes" xml:space="preserve">
          <source>In RxJS, the &lt;code&gt;distinct&lt;/code&gt; operator has two optional parameters:</source>
          <target state="translated">En RxJS, el operador &lt;code&gt;distinct&lt;/code&gt; tiene dos par&amp;aacute;metros opcionales:</target>
        </trans-unit>
        <trans-unit id="60aeaf00dfd42ac1f2aa979d31edd932b2e05c96" translate="yes" xml:space="preserve">
          <source>In RxJS, the &lt;code&gt;from&lt;/code&gt; operator converts an array-like or iterable object into an Observable that emits the items in that array or iterable. A String, in this context, is treated as an array of characters.</source>
          <target state="translated">En RxJS, el operador &lt;code&gt;from&lt;/code&gt; convierte un objeto iterable o similar a una matriz en un Observable que emite los elementos de esa matriz o iterable. Una cadena, en este contexto, se trata como una matriz de caracteres.</target>
        </trans-unit>
        <trans-unit id="32f572fa2a9a0912cc3687d3d2b76c82ee440842" translate="yes" xml:space="preserve">
          <source>In RxJS, the &lt;code&gt;publish&lt;/code&gt; operator takes a function as a parameter. This function takes an emitted item from the source Observable as a parameter and produces the item that will be emitted in its place by the returned &lt;code&gt;ConnectableObservable&lt;/code&gt;.</source>
          <target state="translated">En RxJS, el operador de &lt;code&gt;publish&lt;/code&gt; toma una funci&amp;oacute;n como par&amp;aacute;metro. Esta funci&amp;oacute;n toma un elemento emitido de la fuente Observable como par&amp;aacute;metro y produce el elemento que ser&amp;aacute; emitido en su lugar por el &lt;code&gt;ConnectableObservable&lt;/code&gt; devuelto .</target>
        </trans-unit>
        <trans-unit id="220a1ea76599fe696f6ff55d0b0240936d7391d9" translate="yes" xml:space="preserve">
          <source>In RxJS, you can subscribe to an Observable in two ways:</source>
          <target state="translated">En la RxJS,puedes suscribirte a un Observable de dos maneras:</target>
        </trans-unit>
        <trans-unit id="f0434c25ac778b06dc0f0e430a507026d4ffcd13" translate="yes" xml:space="preserve">
          <source>In RxJava the operator is called &lt;code&gt;count&lt;/code&gt; and the Observable it creates emits an Integer value. There is also a &lt;code&gt;countLong&lt;/code&gt; whose Observable emits a Long value.</source>
          <target state="translated">En RxJava, el operador se llama &lt;code&gt;count&lt;/code&gt; y el Observable que crea emite un valor Integer. Tambi&amp;eacute;n hay un &lt;code&gt;countLong&lt;/code&gt; cuyo Observable emite un valor Long.</target>
        </trans-unit>
        <trans-unit id="1b4d2614f2ccefc9538a2a5b53a4e9f2384b8a21" translate="yes" xml:space="preserve">
          <source>In RxJava there are several variants of Buffer:</source>
          <target state="translated">En RxJava hay varias variantes de Buffer:</target>
        </trans-unit>
        <trans-unit id="5324a1b154d0b35b0430e397999d44bbb2293830" translate="yes" xml:space="preserve">
          <source>In RxJava there is a variety of the &lt;code&gt;replay&lt;/code&gt; operator that returns a connectable Observable. You must &lt;a href=&quot;publish&quot;&gt;Publish&lt;/a&gt; this connectable Observable before observers can subscribe to it, and then &lt;a href=&quot;connect&quot;&gt;Connect&lt;/a&gt; to it in order to observe its emissions.</source>
          <target state="translated">En RxJava hay una variedad del operador de &lt;code&gt;replay&lt;/code&gt; que devuelve un Observable conectable. Debe &lt;a href=&quot;publish&quot;&gt;publicar&lt;/a&gt; este Observable conectable antes de que los observadores puedan suscribirse a &amp;eacute;l y luego &lt;a href=&quot;connect&quot;&gt;Conectarse&lt;/a&gt; a &amp;eacute;l para observar sus emisiones.</target>
        </trans-unit>
        <trans-unit id="fa9a02b1a23712e12eaf9bf38e6513173d05aad6" translate="yes" xml:space="preserve">
          <source>In RxJava there is also a version of the &lt;a href=&quot;from&quot;&gt;From&lt;/a&gt; operator that converts a &lt;code&gt;Future&lt;/code&gt; into an Observable, and in this way resembles the Start operator.</source>
          <target state="translated">En RxJava tambi&amp;eacute;n existe una versi&amp;oacute;n del operador &lt;a href=&quot;from&quot;&gt;From&lt;/a&gt; que convierte un &lt;code&gt;Future&lt;/code&gt; en un Observable, y de esta manera se asemeja al operador Start.</target>
        </trans-unit>
        <trans-unit id="d66e9a41859140e63d2a513b65a3eb33c3064950" translate="yes" xml:space="preserve">
          <source>In RxJava, &lt;code&gt;doWhile&lt;/code&gt; is not part of the standard set of operators, but is part of the optional &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; package. &lt;code&gt;doWhile&lt;/code&gt; checks a condition after each repetition of the source sequence, and only repeats it if that condition is true.</source>
          <target state="translated">En RxJava, &lt;code&gt;doWhile&lt;/code&gt; no es parte del conjunto est&amp;aacute;ndar de operadores, pero es parte del &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; opcional rxjava-computation-expression . &lt;code&gt;doWhile&lt;/code&gt; comprueba una condici&amp;oacute;n despu&amp;eacute;s de cada repetici&amp;oacute;n de la secuencia de origen y solo la repite si esa condici&amp;oacute;n es verdadera.</target>
        </trans-unit>
        <trans-unit id="278ec5920441fdbb971e38eb40408f25e66352a0" translate="yes" xml:space="preserve">
          <source>In RxJava, &lt;code&gt;materialize&lt;/code&gt; transforms the notifications from the source Observable into &lt;code&gt;Notification&lt;/code&gt; objects and emits them as the emissions from the Observable it returns.</source>
          <target state="translated">En RxJava, &lt;code&gt;materialize&lt;/code&gt; transforma las notificaciones de la fuente Observable en objetos de &lt;code&gt;Notification&lt;/code&gt; y las emite como las emisiones del Observable que devuelve.</target>
        </trans-unit>
        <trans-unit id="b9040120474fb9e9d6678ef11c5d331e3831055d" translate="yes" xml:space="preserve">
          <source>In RxJava, &lt;code&gt;whileDo&lt;/code&gt; is not part of the standard set of operators, but is part of the optional &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; package. &lt;code&gt;whileDo&lt;/code&gt; checks a condition before each repetition of the source sequence, and only repeats it if that condition is true.</source>
          <target state="translated">En RxJava, &lt;code&gt;whileDo&lt;/code&gt; no es parte del conjunto est&amp;aacute;ndar de operadores, pero es parte del &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; opcional rxjava-computation-expression . &lt;code&gt;whileDo&lt;/code&gt; comprueba una condici&amp;oacute;n antes de cada repetici&amp;oacute;n de la secuencia de origen y solo la repite si esa condici&amp;oacute;n es verdadera.</target>
        </trans-unit>
        <trans-unit id="7cda80172d796ec17e6de8b0b3fb7df8961f5322" translate="yes" xml:space="preserve">
          <source>In RxJava, the &lt;code&gt;connect&lt;/code&gt; operator is a method of the &lt;code&gt;ConnectableObservable&lt;/code&gt; interface. You can use the &lt;code&gt;publish&lt;/code&gt; operator to convert an ordinary Observable into a &lt;code&gt;ConnectableObservable&lt;/code&gt;.</source>
          <target state="translated">En RxJava, el operador de &lt;code&gt;connect&lt;/code&gt; es un m&amp;eacute;todo de la interfaz &lt;code&gt;ConnectableObservable&lt;/code&gt; . Puede utilizar el operador de &lt;code&gt;publish&lt;/code&gt; para convertir un Observable ordinario en un &lt;code&gt;ConnectableObservable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d915aa8a6371b24d546a898d5927650d68298d10" translate="yes" xml:space="preserve">
          <source>In RxJava, the &lt;code&gt;from&lt;/code&gt; operator can convert a Future, an Iterable, or an Array. In the case of an Iterable or an Array, the resulting Observable will emit each item contained in the Iterable or Array.</source>
          <target state="translated">En RxJava, el operador &lt;code&gt;from&lt;/code&gt; puede convertir un Future, un Iterable o un Array. En el caso de un Iterable o un Array, el Observable resultante emitir&amp;aacute; cada elemento contenido en el Iterable o Array.</target>
        </trans-unit>
        <trans-unit id="8aa6f776ef4b58ae93606199eab5d7aae9f12a1b" translate="yes" xml:space="preserve">
          <source>In RxJava, this filtering operator is implemented as &lt;code&gt;first&lt;/code&gt;, &lt;code&gt;firstOrDefault&lt;/code&gt;, and &lt;code&gt;takeFirst&lt;/code&gt;.</source>
          <target state="translated">En RxJava, este operador de filtrado se implementa como &lt;code&gt;first&lt;/code&gt; , &lt;code&gt;firstOrDefault&lt;/code&gt; y &lt;code&gt;takeFirst&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a4f120274458ea753c59c58263b7e7f5ac97cf7" translate="yes" xml:space="preserve">
          <source>In RxJava, this filtering operator is implemented as &lt;code&gt;last&lt;/code&gt; and &lt;code&gt;lastOrDefault&lt;/code&gt;.</source>
          <target state="translated">En RxJava, este operador de filtrado se implementa como &lt;code&gt;last&lt;/code&gt; y &lt;code&gt;lastOrDefault&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7aaf45cbe7681d9fc78492e0e1abae440e60cdd8" translate="yes" xml:space="preserve">
          <source>In RxJava, this operator is implemented as &lt;code&gt;skip&lt;/code&gt;.</source>
          <target state="translated">En RxJava, este operador se implementa como &lt;code&gt;skip&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad7d874d083f1f23b84c1a24058def9a12d847a5" translate="yes" xml:space="preserve">
          <source>In RxJava, this operator is implemented as &lt;code&gt;skipUntil&lt;/code&gt;.</source>
          <target state="translated">En RxJava, este operador se implementa como &lt;code&gt;skipUntil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0df78c0cd8e0c04b88996b41f57536868e395ae" translate="yes" xml:space="preserve">
          <source>In RxJava, this operator is implemented as &lt;code&gt;take&lt;/code&gt;.</source>
          <target state="translated">En RxJava, este operador se implementa como &lt;code&gt;take&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9c04fd97bf99939674e16f0e2e06fb85b1f5316" translate="yes" xml:space="preserve">
          <source>In RxJava, this operator is implemented as &lt;code&gt;takeUntil&lt;/code&gt;. Note that the second Observable can cause &lt;code&gt;takeUntil&lt;/code&gt; to quit emitting items either by emitting an item or by issuing an &lt;code&gt;onError&lt;/code&gt; or &lt;code&gt;onCompleted&lt;/code&gt; notification.</source>
          <target state="translated">En RxJava, este operador se implementa como &lt;code&gt;takeUntil&lt;/code&gt; . Tenga en cuenta que el segundo Observable puede hacer que &lt;code&gt;takeUntil&lt;/code&gt; deje de emitir elementos, ya sea emitiendo un elemento o emitiendo una notificaci&amp;oacute;n &lt;code&gt;onError&lt;/code&gt; o &lt;code&gt;onCompleted&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6cafebc8da2c395e45b748adaf4d16e424147df6" translate="yes" xml:space="preserve">
          <source>In RxJava, this operator is not in the ReactiveX core, but is part of the distinct &lt;code&gt;rxjava-math&lt;/code&gt; module.</source>
          <target state="translated">En RxJava, este operador no est&amp;aacute; en el n&amp;uacute;cleo de ReactiveX, pero es parte del m&amp;oacute;dulo &lt;code&gt;rxjava-math&lt;/code&gt; distinto .</target>
        </trans-unit>
        <trans-unit id="aa451d401756cfb43e0af09e28153a9dcf363ef1" translate="yes" xml:space="preserve">
          <source>In RxJs the &lt;code&gt;replay&lt;/code&gt; operator takes four optional parameters and returns an ordinary Observable:</source>
          <target state="translated">En RxJs, el operador de &lt;code&gt;replay&lt;/code&gt; toma cuatro par&amp;aacute;metros opcionales y devuelve un Observable ordinario:</target>
        </trans-unit>
        <trans-unit id="e5f6338e063dd1fe484cfc1e5f6bdc92e7874c61" translate="yes" xml:space="preserve">
          <source>In RxKotlin there are several variants of Buffer:</source>
          <target state="translated">En RxKotlin hay varias variantes de Buffer:</target>
        </trans-unit>
        <trans-unit id="09f9d22e6333dc41077c541c793d2b34999696d3" translate="yes" xml:space="preserve">
          <source>In RxPY &lt;code&gt;concat&lt;/code&gt; takes a variable number of Observables as parameters (or an array of Observables), and concatenates them in the order they appear in the parameter list (or array).</source>
          <target state="translated">En RxPY, &lt;code&gt;concat&lt;/code&gt; toma un n&amp;uacute;mero variable de Observables como par&amp;aacute;metros (o una matriz de Observables) y los concatena en el orden en que aparecen en la lista de par&amp;aacute;metros (o matriz).</target>
        </trans-unit>
        <trans-unit id="e73aa488412dc01ff1bb9df22470c5c2d99a3e49" translate="yes" xml:space="preserve">
          <source>In RxPY you have the option to pass &lt;code&gt;count&lt;/code&gt; a predicate that takes an item emitted by the source Observable as a parameter. If you do so, &lt;code&gt;count&lt;/code&gt; will emit a count only of those items from the source Observable that the predicate evaluates as &lt;code&gt;true&lt;/code&gt;. Otherwise, it will emit a count of all items emitted by the source Observable.</source>
          <target state="translated">En RxPY usted tiene la opci&amp;oacute;n de pasar a &lt;code&gt;count&lt;/code&gt; un predicado que tiene un elemento que emite la fuente observable como par&amp;aacute;metro. Si lo hace, &lt;code&gt;count&lt;/code&gt; emitir&amp;aacute; un recuento solo de aquellos elementos de la fuente Observable que el predicado eval&amp;uacute;a como &lt;code&gt;true&lt;/code&gt; . De lo contrario, emitir&amp;aacute; un recuento de todos los elementos emitidos por la fuente Observable.</target>
        </trans-unit>
        <trans-unit id="0b529c9a0dc4b531af4b60f80f6f0cf3876ca4b7" translate="yes" xml:space="preserve">
          <source>In RxScala the operator &lt;code&gt;count&lt;/code&gt; counts the number of items in the source Observable that satisfy a specified predicate. That predicate accepts an emitted item as a parameter and returns a Boolean. &lt;code&gt;count&lt;/code&gt; will emit a count of all items for which this predicate returned &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">En RxScala, el operador &lt;code&gt;count&lt;/code&gt; cuenta el n&amp;uacute;mero de elementos en la fuente Observable que satisfacen un predicado espec&amp;iacute;fico. Ese predicado acepta un elemento emitido como par&amp;aacute;metro y devuelve un booleano. &lt;code&gt;count&lt;/code&gt; emitir&amp;aacute; un recuento de todos los elementos para los que este predicado devolvi&amp;oacute; &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16ec499010df4b2455c2dfd317e76e966b3946e5" translate="yes" xml:space="preserve">
          <source>In Swift, this is implemented using the &lt;code&gt;Observable.from&lt;/code&gt; class method.</source>
          <target state="translated">En Swift, esto se implementa utilizando el m&amp;eacute;todo de clase &lt;code&gt;Observable.from&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="138a5f790b58f03a816d8788ec73857af8ed119a" translate="yes" xml:space="preserve">
          <source>In Swift, this is implemented using the &lt;code&gt;Observable.just&lt;/code&gt; class method.</source>
          <target state="translated">En Swift, esto se implementa utilizando el m&amp;eacute;todo de clase &lt;code&gt;Observable.just&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e45263cc87b0ac4023f88773e7a4a3cd1488684" translate="yes" xml:space="preserve">
          <source>In addition, in the &lt;code&gt;RxJavaAsyncUtil&lt;/code&gt; package, you have available to you the following operators that convert actions, callables, functions, and runnables into Observables that emit the results of those things:</source>
          <target state="translated">Adem&amp;aacute;s, en el paquete &lt;code&gt;RxJavaAsyncUtil&lt;/code&gt; , tiene disponibles los siguientes operadores que convierten acciones, invocables, funciones y ejecutables en Observables que emiten los resultados de esas cosas:</target>
        </trans-unit>
        <trans-unit id="c705eb2803752c9ee28584efe3fc60abb165fff0" translate="yes" xml:space="preserve">
          <source>In an ordinary method call &amp;mdash; that is, &lt;em&gt;not&lt;/em&gt; the sort of asynchronous, parallel calls typical in ReactiveX &amp;mdash; the flow is something like this:</source>
          <target state="translated">En una llamada de m&amp;eacute;todo ordinaria, es decir, &lt;em&gt;no&lt;/em&gt; el tipo de llamadas paralelas asincr&amp;oacute;nicas t&amp;iacute;picas en ReactiveX, el flujo es algo como esto:</target>
        </trans-unit>
        <trans-unit id="70afa1a17dffe1d75fa8ae4871f89baf7ba04903" translate="yes" xml:space="preserve">
          <source>In general, notify subscribers of error conditions immediately, rather than making an effort to emit more items first.</source>
          <target state="translated">En general,notifique a los suscriptores de las condiciones de error inmediatamente,en lugar de hacer un esfuerzo para emitir más artículos primero.</target>
        </trans-unit>
        <trans-unit id="b51d0ee6ef32193720cf5577081be13382e0461c" translate="yes" xml:space="preserve">
          <source>In many ReactiveX implementations there is a second operator, MergeDelayError, that changes this behavior &amp;mdash; reserving &lt;code&gt;onError&lt;/code&gt; notifications until all of the merged Observables complete and only then passing it along to the observers:</source>
          <target state="translated">En muchas implementaciones de ReactiveX hay un segundo operador, MergeDelayError, que cambia este comportamiento, reservando &lt;code&gt;onError&lt;/code&gt; notificaciones onError hasta que todos los Observables fusionados se completen y solo luego pas&amp;aacute;ndolo a los observadores:</target>
        </trans-unit>
        <trans-unit id="df1c152b88bf70837256cdf207124847c96b400f" translate="yes" xml:space="preserve">
          <source>In many software programming tasks, you more or less expect that the instructions you write will execute and complete incrementally, one-at-a-time, in order as you have written them. But in ReactiveX, many instructions may execute in parallel and their results are later captured, in arbitrary order, by &amp;ldquo;observers.&amp;rdquo; Rather than &lt;em&gt;calling&lt;/em&gt; a method, you define a mechanism for retrieving and transforming the data, in the form of an &amp;ldquo;Observable,&amp;rdquo; and then &lt;em&gt;subscribe&lt;/em&gt; an observer to it, at which point the previously-defined mechanism fires into action with the observer standing sentry to capture and respond to its emissions whenever they are ready.</source>
          <target state="translated">En muchas tareas de programaci&amp;oacute;n de software, m&amp;aacute;s o menos espera que las instrucciones que escribe se ejecuten y completen de forma incremental, una a la vez, en el orden en que las ha escrito. Pero en ReactiveX, muchas instrucciones pueden ejecutarse en paralelo y sus resultados luego son capturados, en orden arbitrario, por &quot;observadores&quot;. En lugar de &lt;em&gt;llamar a&lt;/em&gt; un m&amp;eacute;todo, usted define un mecanismo para recuperar y transformar los datos, en forma de &quot;Observable&quot;, y luego &lt;em&gt;suscribe a&lt;/em&gt; un observador, momento en el que el mecanismo definido previamente se activa con el observador de pie como centinela. para capturar y responder a sus emisiones cuando est&amp;eacute;n listas.</target>
        </trans-unit>
        <trans-unit id="af1cde5def7e314848c7b5ea89de136a83b3d54d" translate="yes" xml:space="preserve">
          <source>In other documents and other contexts, what we are calling an &amp;ldquo;observer&amp;rdquo; is sometimes called a &amp;ldquo;subscriber,&amp;rdquo; &amp;ldquo;watcher,&amp;rdquo; or &amp;ldquo;reactor.&amp;rdquo; This model in general is often referred to as the &lt;a href=&quot;http://en.wikipedia.org/wiki/Reactor_pattern&quot;&gt;&amp;ldquo;reactor pattern&amp;rdquo;&lt;/a&gt;.</source>
          <target state="translated">En otros documentos y otros contextos, lo que llamamos un &quot;observador&quot; a veces se denomina &quot;suscriptor&quot;, &quot;observador&quot; o &quot;reactor&quot;. Este modelo en general se denomina a menudo &lt;a href=&quot;http://en.wikipedia.org/wiki/Reactor_pattern&quot;&gt;&quot;patr&amp;oacute;n de reactor&quot;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0a661195d6805be9c148ca5aaa5480f83dbbbe3f" translate="yes" xml:space="preserve">
          <source>In other documents and other contexts, what we are calling an &amp;ldquo;observer&amp;rdquo; is sometimes called a &amp;ldquo;subscriber,&amp;rdquo; &amp;ldquo;watcher,&amp;rdquo; or &amp;ldquo;reactor.&amp;rdquo; This model in general is often referred to as the &lt;a href=&quot;https://en.wikipedia.org/wiki/Reactor_pattern&quot;&gt;&amp;ldquo;reactor pattern&amp;rdquo;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c110d63fdae361275771c2c4e8b7c4bd49374d1" translate="yes" xml:space="preserve">
          <source>In several of the language-specific implementations there is also an operator that does &lt;em&gt;not&lt;/em&gt; interleave the emissions from the transformed Observables, but instead emits these emissions in strict order, often called ConcatMap or something similar.</source>
          <target state="translated">En varias de las implementaciones espec&amp;iacute;ficas del lenguaje tambi&amp;eacute;n hay un operador que &lt;em&gt;no&lt;/em&gt; intercala las emisiones de los Observables transformados, sino que emite estas emisiones en un orden estricto, a menudo llamado ConcatMap o algo similar.</target>
        </trans-unit>
        <trans-unit id="93bfb63abe1513baa690460365bb2e32de9329bf" translate="yes" xml:space="preserve">
          <source>In some ReactiveX implementations there is also a ConcatMap operator (a.k.a. &lt;code&gt;concat_all&lt;/code&gt;, &lt;code&gt;concat_map&lt;/code&gt;, &lt;code&gt;concatMapObserver&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;forIn&lt;/code&gt;/&lt;code&gt;for_in&lt;/code&gt;, &lt;code&gt;mapcat&lt;/code&gt;, &lt;code&gt;selectConcat&lt;/code&gt;, or &lt;code&gt;selectConcatObserver&lt;/code&gt;) that transforms the items emitted by a source Observable into corresponding Observables and then concatenates the items emitted by each of these Observables in the order in which they are observed and transformed.</source>
          <target state="translated">En algunas implementaciones de ReactiveX tambi&amp;eacute;n hay un operador ConcatMap (tambi&amp;eacute;n &lt;code&gt;concat_all&lt;/code&gt; como concat_all , &lt;code&gt;concat_map&lt;/code&gt; , &lt;code&gt;concatMapObserver&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;forIn&lt;/code&gt; / &lt;code&gt;for_in&lt;/code&gt; , &lt;code&gt;mapcat&lt;/code&gt; , &lt;code&gt;selectConcat&lt;/code&gt; o &lt;code&gt;selectConcatObserver&lt;/code&gt; ) que transforma los elementos emitidos por un Observable de origen en Observables correspondientes y luego concatena los elementos emitidos por cada uno de estos Observables en el orden en que se observan y transforman.</target>
        </trans-unit>
        <trans-unit id="49d6b73f37ee57d71fdff6d16884e54ade3b0ef5" translate="yes" xml:space="preserve">
          <source>In some ReactiveX implementations, there is a specialized observer interface, &lt;code&gt;Subscriber&lt;/code&gt;, that implements an &lt;code&gt;unsubscribe&lt;/code&gt; method. You can call this method to indicate that the Subscriber is no longer interested in any of the Observables it is currently subscribed to. Those Observables can then (if they have no other interested observers) choose to stop generating new items to emit.</source>
          <target state="translated">En algunas implementaciones de ReactiveX, existe una interfaz de observador especializada, &lt;code&gt;Subscriber&lt;/code&gt; , que implementa un m&amp;eacute;todo de &lt;code&gt;unsubscribe&lt;/code&gt; . Puede llamar a este m&amp;eacute;todo para indicar que el suscriptor ya no est&amp;aacute; interesado en ninguno de los Observables a los que est&amp;aacute; suscrito actualmente. Esos Observables pueden entonces (si no tienen otros observadores interesados) optar por dejar de generar nuevos elementos para emitir.</target>
        </trans-unit>
        <trans-unit id="2949e25812bc031cf61fa47668bcad6970f74f74" translate="yes" xml:space="preserve">
          <source>In some ReactiveX implementations, there is an operator called something like &amp;ldquo;OnErrorResumeNext&amp;rdquo; that behaves like a Catch variant: specifically reacting to an &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. In others, there is an operator with that name that behaves more like a Concat variant: performing the concatenation operation regardless of whether the source Observable terminates normally or with an error. This is unfortunate and confusing, but something we have to live with.</source>
          <target state="translated">En algunas implementaciones de ReactiveX, hay un operador llamado algo as&amp;iacute; como &amp;ldquo;OnErrorResumeNext&amp;rdquo; que se comporta como una variante de Catch: reacciona espec&amp;iacute;ficamente a una notificaci&amp;oacute;n de &lt;code&gt;onError&lt;/code&gt; de la fuente Observable. En otros, hay un operador con ese nombre que se comporta m&amp;aacute;s como una variante de Concat: realizando la operaci&amp;oacute;n de concatenaci&amp;oacute;n sin importar si el Observable de origen termina normalmente o con un error. Esto es lamentable y confuso, pero algo con lo que tenemos que vivir.</target>
        </trans-unit>
        <trans-unit id="feb01da6c51b0285d3263e371d3483d2cae53174" translate="yes" xml:space="preserve">
          <source>In some ReactiveX implementations, your operator may need to be sensitive to that implementation&amp;rsquo;s &amp;ldquo;backpressure&amp;rdquo; strategies. (See, for example: &lt;a href=&quot;http://akarnokd.blogspot.hu/2015/05/pitfalls-of-operator-implementations_14.html&quot;&gt;Pitfalls of Operator Implementations (part 2)&lt;/a&gt; by D&amp;aacute;vid Karnok.)</source>
          <target state="translated">En algunas implementaciones de ReactiveX, su operador puede necesitar ser sensible a las estrategias de &quot;contrapresi&amp;oacute;n&quot; de esa implementaci&amp;oacute;n. (Ver, por ejemplo: &lt;a href=&quot;http://akarnokd.blogspot.hu/2015/05/pitfalls-of-operator-implementations_14.html&quot;&gt;Escollos de las implementaciones del operador (parte 2)&lt;/a&gt; por D&amp;aacute;vid Karnok.)</target>
        </trans-unit>
        <trans-unit id="d86788d80735e9747737d806466553a36e139407" translate="yes" xml:space="preserve">
          <source>In some ReactiveX implementations, your operator may need to be sensitive to that implementation&amp;rsquo;s &amp;ldquo;backpressure&amp;rdquo; strategies. (See, for example: &lt;a href=&quot;https://akarnokd.blogspot.hu/2015/05/pitfalls-of-operator-implementations_14.html&quot;&gt;Pitfalls of Operator Implementations (part 2)&lt;/a&gt; by D&amp;aacute;vid Karnok.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37d968bca48f34a1b9d629e8c8e5bc7f1f9e7409" translate="yes" xml:space="preserve">
          <source>In some circumstances, waiting until the last minute (that is, until subscription time) to generate the Observable can ensure that this Observable contains the freshest data.</source>
          <target state="translated">En algunas circunstancias,esperar hasta el último minuto (es decir,hasta el momento de la suscripción)para generar el Observatorio puede garantizar que éste contenga los datos más recientes.</target>
        </trans-unit>
        <trans-unit id="0d97597b94f7d0965b9edaef42c16ac57210f4bf" translate="yes" xml:space="preserve">
          <source>In some implementations of ReactiveX, there is also an operator that converts an Observable into a &amp;ldquo;Blocking&amp;rdquo; Observable. A Blocking Observable extends the ordinary Observable by providing a set of methods, operating on the items emitted by the Observable, that block. Some of the To operators are in this Blocking Observable set of extended operations.</source>
          <target state="translated">En algunas implementaciones de ReactiveX, tambi&amp;eacute;n hay un operador que convierte un Observable en un Observable de &quot;Bloqueo&quot;. Un Observable de Bloqueo extiende el Observable ordinario al proporcionar un conjunto de m&amp;eacute;todos que operan sobre los elementos emitidos por el Observable, ese bloque. Algunos de los operadores To est&amp;aacute;n en este conjunto de operaciones extendidas de Blocking Observable.</target>
        </trans-unit>
        <trans-unit id="f8063bc63842afdac26b9e318a09b125cd96bc99" translate="yes" xml:space="preserve">
          <source>In some implementations of ReactiveX, there is also something called a &amp;ldquo;Connectable&amp;rdquo; Observable. Such an Observable does not begin emitting items until its &lt;a href=&quot;operators/connect&quot;&gt;Connect&lt;/a&gt; method is called, whether or not any observers have subscribed to it.</source>
          <target state="translated">En algunas implementaciones de ReactiveX, tambi&amp;eacute;n hay algo llamado Observable &quot;Conectable&quot;. Tal Observable no comienza a emitir elementos hasta que se llama a su m&amp;eacute;todo &lt;a href=&quot;operators/connect&quot;&gt;Connect&lt;/a&gt; , ya sea que alg&amp;uacute;n observador se haya suscrito o no.</target>
        </trans-unit>
        <trans-unit id="037dec5a983c9517e8c8c6b9e8942bbe78e32581" translate="yes" xml:space="preserve">
          <source>In some implementations there are variants that allow you to adjust the criteria by which two items are considered &amp;ldquo;distinct.&amp;rdquo; In some, there is a variant of the operator that only compares an item against its immediate predecessor for distinctness, thereby filtering only &lt;em&gt;consecutive&lt;/em&gt; duplicate items from the sequence.</source>
          <target state="translated">En algunas implementaciones, existen variantes que le permiten ajustar los criterios por los cuales dos elementos se consideran &quot;distintos&quot;. En algunos, existe una variante del operador que solo compara un elemento con su predecesor inmediato en cuanto a distinci&amp;oacute;n, filtrando as&amp;iacute; solo elementos duplicados &lt;em&gt;consecutivos&lt;/em&gt; de la secuencia.</target>
        </trans-unit>
        <trans-unit id="1dd136608bd7e489e77433f289366dd451d69a68" translate="yes" xml:space="preserve">
          <source>In some implementations there is also a Single operator. It behaves similarly to First except that it waits until the source Observable terminates in order to guarantee that it only emits a single item (otherwise, rather than emitting that item, it terminates with an error). You can use this to not only take the first item from the source Observable but to also guarantee that there was only one item.</source>
          <target state="translated">En algunas implementaciones también hay un operador único.Se comporta de manera similar al Primero,salvo que espera a que termine el Observable de la fuente para garantizar que sólo emite un único elemento (de lo contrario,en lugar de emitir ese elemento,termina con un error).Puede utilizarlo no sólo para tomar el primer ítem de la fuente Observable sino también para garantizar que sólo había un ítem.</target>
        </trans-unit>
        <trans-unit id="6e0dc45fcc76d537e1792d8725c9220fda83cacf" translate="yes" xml:space="preserve">
          <source>In some implementations there is also an UnsubscribeOn operator.</source>
          <target state="translated">En algunas implementaciones también hay un operador UnsubscribeOn.</target>
        </trans-unit>
        <trans-unit id="12e47960cd978595f0079e3a0166c1245438c4c9" translate="yes" xml:space="preserve">
          <source>In some implementations, &lt;code&gt;First&lt;/code&gt; is not implemented as a filtering operator that returns an Observable, but as a blocking function that returns a particular item at such time as the source Observable emits that item. In those implementations, if you instead want a filtering operator, you may have better luck with &lt;a href=&quot;take&quot;&gt;&lt;code&gt;Take(1)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;elementat&quot;&gt;&lt;code&gt;ElementAt(0)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">En algunas implementaciones, &lt;code&gt;First&lt;/code&gt; no se implementa como un operador de filtrado que devuelve un Observable, sino como una funci&amp;oacute;n de bloqueo que devuelve un elemento en particular en el momento en que el Observable de origen emite ese elemento. En esas implementaciones, si en cambio desea un operador de filtrado, puede tener mejor suerte con &lt;a href=&quot;take&quot;&gt; &lt;code&gt;Take(1)&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;elementat&quot;&gt; &lt;code&gt;ElementAt(0)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4334a2a1ddeb5e11e72e20d2fc45eef1bd9c0c63" translate="yes" xml:space="preserve">
          <source>In some implementations, &lt;code&gt;Last&lt;/code&gt; is not implemented as a filtering operator that returns an Observable, but as a blocking function that returns a particular item when the source Observable terminates. In those implementations, if you instead want a filtering operator, you may have better luck with &lt;a href=&quot;take&quot;&gt;&lt;code&gt;TakeLast(1)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">En algunas implementaciones, &lt;code&gt;Last&lt;/code&gt; no se implementa como un operador de filtrado que devuelve un Observable, sino como una funci&amp;oacute;n de bloqueo que devuelve un elemento en particular cuando termina el Observable de origen. En esas implementaciones, si en cambio desea un operador de filtrado, puede tener m&amp;aacute;s suerte con &lt;a href=&quot;take&quot;&gt; &lt;code&gt;TakeLast(1)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a21a2695ee7461574576b39692f2c5743113615" translate="yes" xml:space="preserve">
          <source>In some implementations, there is also a ThrottleFirst operator that is similar, but emits not the most-recently emitted item in the sample period, but the &lt;em&gt;first&lt;/em&gt; item that was emitted during that period.</source>
          <target state="translated">En algunas implementaciones, tambi&amp;eacute;n hay un operador ThrottleFirst que es similar, pero no emite el elemento emitido m&amp;aacute;s recientemente en el per&amp;iacute;odo de muestra, sino el &lt;em&gt;primer&lt;/em&gt; elemento que se emiti&amp;oacute; durante ese per&amp;iacute;odo.</target>
        </trans-unit>
        <trans-unit id="a6343b30db7af9b5aa728419488dd86296f2eea2" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;StringObservable&lt;/code&gt; class that is not part of the RxGroovy core there is also a specialty mapping operator, &lt;code&gt;encode&lt;/code&gt;, that transforms an Observable that emits strings into an Observable that emits byte arrays that respect character boundaries of multibyte characters in the original strings.</source>
          <target state="translated">En la clase &lt;code&gt;StringObservable&lt;/code&gt; que no forma parte del n&amp;uacute;cleo de RxGroovy tambi&amp;eacute;n hay un operador de mapeo especializado, &lt;code&gt;encode&lt;/code&gt; , que transforma un Observable que emite cadenas en un Observable que emite matrices de bytes que respetan los l&amp;iacute;mites de caracteres de caracteres multibyte en las cadenas originales.</target>
        </trans-unit>
        <trans-unit id="978e2cb0f06af222730ceae268a71aa2cf8778d0" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;StringObservable&lt;/code&gt; class that is not part of the RxJava core there is also a specialty mapping operator, &lt;code&gt;encode&lt;/code&gt;, that transforms an Observable that emits strings into an Observable that emits byte arrays that respect character boundaries of multibyte characters in the original strings.</source>
          <target state="translated">En la clase &lt;code&gt;StringObservable&lt;/code&gt; que no forma parte del n&amp;uacute;cleo RxJava tambi&amp;eacute;n hay un operador de mapeo especializado, &lt;code&gt;encode&lt;/code&gt; , que transforma un Observable que emite cadenas en un Observable que emite matrices de bytes que respetan los l&amp;iacute;mites de caracteres de caracteres multibyte en las cadenas originales.</target>
        </trans-unit>
        <trans-unit id="2c205481240cf9f67657691f8018f19dd3c8c2fa" translate="yes" xml:space="preserve">
          <source>In the above code, the source Observable emits the sequence &lt;code&gt;{ 1 2 3 4 5 }&lt;/code&gt;. When it emits the first item in this sequence, the &lt;code&gt;groupBy&lt;/code&gt; operator creates and emits a &lt;code&gt;GroupedObservable&lt;/code&gt; with the key of &lt;code&gt;0&lt;/code&gt;. The &lt;code&gt;flatMap&lt;/code&gt; operator applies the &lt;code&gt;take(1)&lt;/code&gt; operator to that &lt;code&gt;GroupedObservable&lt;/code&gt;, which gives it the item (&lt;code&gt;1&lt;/code&gt;) that it emits and that also unsubscribes from the &lt;code&gt;GroupedObservable&lt;/code&gt;, which is terminated. When the source Observable emits the second item in its sequence, the &lt;code&gt;groupBy&lt;/code&gt; operator creates and emits a &lt;em&gt;second&lt;/em&gt;&lt;code&gt;GroupedObservable&lt;/code&gt; with the same key (&lt;code&gt;0&lt;/code&gt;) to replace the one that was terminated. &lt;code&gt;flatMap&lt;/code&gt; again applies &lt;code&gt;take(1)&lt;/code&gt; to this new &lt;code&gt;GroupedObservable&lt;/code&gt; to retrieve the new item to emit (&lt;code&gt;2&lt;/code&gt;) and to unsubscribe from and terminate the &lt;code&gt;GroupedObservable&lt;/code&gt;, and this process repeats for the remaining items in the source sequence.</source>
          <target state="translated">En el c&amp;oacute;digo anterior, la fuente Observable emite la secuencia &lt;code&gt;{ 1 2 3 4 5 }&lt;/code&gt; . Cuando emite el primer elemento de esta secuencia, el operador &lt;code&gt;groupBy&lt;/code&gt; crea y emite un &lt;code&gt;GroupedObservable&lt;/code&gt; con la clave &lt;code&gt;0&lt;/code&gt; . El operador &lt;code&gt;flatMap&lt;/code&gt; aplica el operador &lt;code&gt;take(1)&lt;/code&gt; a ese &lt;code&gt;GroupedObservable&lt;/code&gt; , que le da el elemento ( &lt;code&gt;1&lt;/code&gt; ) que emite y que tambi&amp;eacute;n &lt;code&gt;GroupedObservable&lt;/code&gt; la suscripci&amp;oacute;n del GroupedObservable , que finaliza. Cuando la fuente Observable emite el segundo elemento en su secuencia, el operador &lt;code&gt;groupBy&lt;/code&gt; crea y emite un &lt;em&gt;segundo &lt;/em&gt; &lt;code&gt;GroupedObservable&lt;/code&gt; con la misma clave ( &lt;code&gt;0&lt;/code&gt; ) para reemplazar el que fue cancelado. &lt;code&gt;flatMap&lt;/code&gt; aplica nuevamente &lt;code&gt;take(1)&lt;/code&gt; a este nuevo &lt;code&gt;GroupedObservable&lt;/code&gt; para recuperar el nuevo elemento para emitir ( &lt;code&gt;2&lt;/code&gt; ) y para cancelar la suscripci&amp;oacute;n y terminar el &lt;code&gt;GroupedObservable&lt;/code&gt; , y este proceso se repite para los elementos restantes en la secuencia de origen.</target>
        </trans-unit>
        <trans-unit id="3a01097bd263f962d72c9a363627040454cd407d" translate="yes" xml:space="preserve">
          <source>In the asynchronous model the flow goes more like this:</source>
          <target state="translated">En el modelo asíncrono el flujo es más parecido a esto:</target>
        </trans-unit>
        <trans-unit id="9b52ecbc0dd6f70ce33a2a266322bee10c5b7034" translate="yes" xml:space="preserve">
          <source>In the case of Action, the process is similar, but there is no return value. In this case, the Observable created by this operator will emit a &lt;code&gt;null&lt;/code&gt; before terminating.</source>
          <target state="translated">En el caso de Action, el proceso es similar, pero no hay valor de retorno. En este caso, el Observable creado por este operador emitir&amp;aacute; un &lt;code&gt;null&lt;/code&gt; antes de terminar.</target>
        </trans-unit>
        <trans-unit id="6fae0c623313d6102a6c3767b510998af08ec342" translate="yes" xml:space="preserve">
          <source>In the case of a Future, it will emit the single result of the &lt;code&gt;get&lt;/code&gt; call. You may optionally pass the version of &lt;code&gt;from&lt;/code&gt; that accepts a future two additional parameters indicating a timeout span and the units of time that span is denominated in. The resulting Observable will terminate with an error if that span of time passes before the Future responds with a value.</source>
          <target state="translated">En el caso de un Future, emitir&amp;aacute; el resultado &amp;uacute;nico de la llamada &lt;code&gt;get&lt;/code&gt; . Es posible pasar opcionalmente la versi&amp;oacute;n de &lt;code&gt;from&lt;/code&gt; que acepta un futuro dos par&amp;aacute;metros adicionales que indican un lapso de tiempo de espera y las unidades de tiempo ese lapso se denomina en. El observable resultante terminar con un error si ese lapso de tiempo pasa antes de que las responde futuro con una valor.</target>
        </trans-unit>
        <trans-unit id="f0dcc4a6d4282af18fc9e92a4494b472d3679b88" translate="yes" xml:space="preserve">
          <source>In the distinct &lt;code&gt;StringObservable&lt;/code&gt; class (not part of RxGroovy by default) there is also a &lt;code&gt;join&lt;/code&gt; operator that converts an Observable that emits a sequence of strings into an Observable that emits a single string that represents the concatenation of each of them, delimited by a string of your choosing.</source>
          <target state="translated">En la clase &lt;code&gt;StringObservable&lt;/code&gt; distinta (que no forma parte de RxGroovy por defecto) tambi&amp;eacute;n hay un operador de &lt;code&gt;join&lt;/code&gt; que convierte un Observable que emite una secuencia de cadenas en un Observable que emite una sola cadena que representa la concatenaci&amp;oacute;n de cada uno de ellos, delimitado por una cadena de su elecci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="0af1cd94fd507d9f3d910ef5d0527af5287336a9" translate="yes" xml:space="preserve">
          <source>In the distinct &lt;code&gt;StringObservable&lt;/code&gt; class (not part of RxGroovy by default) there is also a &lt;code&gt;split&lt;/code&gt; operator that converts an Observable of Strings into an Observable of Strings that treats the source sequence as a stream and splits it on a specified regex boundary, then merges the results of this split.</source>
          <target state="translated">En la clase &lt;code&gt;StringObservable&lt;/code&gt; distinta (que no forma parte de RxGroovy por defecto) tambi&amp;eacute;n hay un operador de &lt;code&gt;split&lt;/code&gt; que convierte un Observable of Strings en un Observable of Strings que trata la secuencia de origen como una secuencia y la divide en un l&amp;iacute;mite de expresi&amp;oacute;n regular especificado, luego fusiona el resultados de esta divisi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="eb5fda7ff19786c8da468ff346658e01540bcd69" translate="yes" xml:space="preserve">
          <source>In the distinct &lt;code&gt;StringObservable&lt;/code&gt; class (not part of RxGroovy by default) there is also a &lt;code&gt;stringConcat&lt;/code&gt; operator that converts an Observable that emits a sequence of strings into an Observable that emits a single string that represents the concatenation of them all.</source>
          <target state="translated">En la clase &lt;code&gt;StringObservable&lt;/code&gt; distinta (que no forma parte de RxGroovy por defecto) tambi&amp;eacute;n hay un operador &lt;code&gt;stringConcat&lt;/code&gt; que convierte un Observable que emite una secuencia de cadenas en un Observable que emite una sola cadena que representa la concatenaci&amp;oacute;n de todos ellos.</target>
        </trans-unit>
        <trans-unit id="a7212957ad6271a30e781217f05729777cde9078" translate="yes" xml:space="preserve">
          <source>In the distinct &lt;code&gt;StringObservable&lt;/code&gt; class (not part of RxJava by default) there is also a &lt;code&gt;join&lt;/code&gt; operator that converts an Observable that emits a sequence of strings into an Observable that emits a single string that represents the concatenation of each of them, delimited by a string of your choosing.</source>
          <target state="translated">En la clase &lt;code&gt;StringObservable&lt;/code&gt; distinta (que no forma parte de RxJava por defecto) tambi&amp;eacute;n hay un operador de &lt;code&gt;join&lt;/code&gt; que convierte un Observable que emite una secuencia de cadenas en un Observable que emite una sola cadena que representa la concatenaci&amp;oacute;n de cada uno de ellos, delimitado por una cadena de su elecci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="dbcfee3dbda596d98d950905c64f0d80750c8c34" translate="yes" xml:space="preserve">
          <source>In the distinct &lt;code&gt;StringObservable&lt;/code&gt; class (not part of RxJava by default) there is also a &lt;code&gt;split&lt;/code&gt; operator that converts an Observable of Strings into an Observable of Strings that treats the source sequence as a stream and splits it on a specified regex boundary, then merges the results of this split.</source>
          <target state="translated">En la clase &lt;code&gt;StringObservable&lt;/code&gt; distinta (que no forma parte de RxJava de forma predeterminada) tambi&amp;eacute;n hay un operador de &lt;code&gt;split&lt;/code&gt; que convierte un Observable of Strings en un Observable of Strings que trata la secuencia de origen como una secuencia y la divide en un l&amp;iacute;mite de expresi&amp;oacute;n regular especificado, luego fusiona el resultados de esta divisi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="80fab375b638934674bb3b50669b96064b97edfb" translate="yes" xml:space="preserve">
          <source>In the distinct &lt;code&gt;StringObservable&lt;/code&gt; class (not part of RxJava by default) there is also a &lt;code&gt;stringConcat&lt;/code&gt; operator that converts an Observable that emits a sequence of strings into an Observable that emits a single string that represents the concatenation of them all.</source>
          <target state="translated">En la clase &lt;code&gt;StringObservable&lt;/code&gt; distinta (que no forma parte de RxJava por defecto) tambi&amp;eacute;n hay un operador &lt;code&gt;stringConcat&lt;/code&gt; que convierte un Observable que emite una secuencia de cadenas en un Observable que emite una sola cadena que representa la concatenaci&amp;oacute;n de todos ellos.</target>
        </trans-unit>
        <trans-unit id="4360fc13798a2ced2520c5e5f6f7e632c555c696" translate="yes" xml:space="preserve">
          <source>In the separate &lt;code&gt;RxJavaAsyncUtil&lt;/code&gt; package, which is not included by default with RxGroovy, there is also a &lt;code&gt;runAsync&lt;/code&gt; function. Pass &lt;code&gt;runAsync&lt;/code&gt; an &lt;code&gt;Action&lt;/code&gt; and a &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt;, and it will return a &lt;code&gt;StoppableObservable&lt;/code&gt; that uses the specified &lt;code&gt;Action&lt;/code&gt; to generate items that it emits.</source>
          <target state="translated">En el paquete separado &lt;code&gt;RxJavaAsyncUtil&lt;/code&gt; , que no se incluye de forma predeterminada con RxGroovy, tambi&amp;eacute;n hay una funci&amp;oacute;n &lt;code&gt;runAsync&lt;/code&gt; . Pase &lt;code&gt;runAsync&lt;/code&gt; una &lt;code&gt;Action&lt;/code&gt; y un &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; , y devolver&amp;aacute; un &lt;code&gt;StoppableObservable&lt;/code&gt; que usa la &lt;code&gt;Action&lt;/code&gt; especificada para generar elementos que emite.</target>
        </trans-unit>
        <trans-unit id="85226d29791a941dfdc4a830caf1c1b4e7fa5b2f" translate="yes" xml:space="preserve">
          <source>In the separate &lt;code&gt;RxJavaAsyncUtil&lt;/code&gt; package, which is not included by default with RxJava, there is also a &lt;code&gt;runAsync&lt;/code&gt; function. Pass &lt;code&gt;runAsync&lt;/code&gt; an &lt;code&gt;Action&lt;/code&gt; and a &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt;, and it will return a &lt;code&gt;StoppableObservable&lt;/code&gt; that uses the specified &lt;code&gt;Action&lt;/code&gt; to generate items that it emits.</source>
          <target state="translated">En el paquete separado &lt;code&gt;RxJavaAsyncUtil&lt;/code&gt; , que no se incluye de forma predeterminada con RxJava, tambi&amp;eacute;n hay una funci&amp;oacute;n &lt;code&gt;runAsync&lt;/code&gt; . Pase &lt;code&gt;runAsync&lt;/code&gt; una &lt;code&gt;Action&lt;/code&gt; y un &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; , y devolver&amp;aacute; un &lt;code&gt;StoppableObservable&lt;/code&gt; que usa la &lt;code&gt;Action&lt;/code&gt; especificada para generar elementos que emite.</target>
        </trans-unit>
        <trans-unit id="9c13cd89c3c45da83ad846b47b1bedfc77c6fafa" translate="yes" xml:space="preserve">
          <source>In this way you can include a &lt;code&gt;Future&lt;/code&gt; that returns an Observable in a cascade of Observables as a peer to other Observables.</source>
          <target state="translated">De esta manera, puede incluir un &lt;code&gt;Future&lt;/code&gt; que devuelve un Observable en una cascada de Observables como un par de otros Observables.</target>
        </trans-unit>
        <trans-unit id="4249028943582ec355115c174d01896c5b993590" translate="yes" xml:space="preserve">
          <source>In this way, each item emitted by the resulting Observable is a function of the corresponding item in the source Observable and all of the items emitted by the source Observable after it.</source>
          <target state="translated">De esta manera,cada elemento emitido por el Observable resultante es una función del elemento correspondiente en el Observable de la fuente y todos los elementos emitidos por el Observable de la fuente después de él.</target>
        </trans-unit>
        <trans-unit id="72cba1d7a40bef7433b1f435b701d906c44bcbac" translate="yes" xml:space="preserve">
          <source>Instead of passing multiple Observables (up to nine) into &lt;code&gt;merge&lt;/code&gt;, you could also pass in a &lt;code&gt;List&amp;lt;&amp;gt;&lt;/code&gt; (or other Iterable) of Observables, an Array of Observables, or even an Observable that emits Observables, and &lt;code&gt;merge&lt;/code&gt; will merge their output into the output of a single Observable:</source>
          <target state="translated">En lugar de pasar varios Observables (hasta nueve) a la &lt;code&gt;merge&lt;/code&gt; , tambi&amp;eacute;n puede pasar una &lt;code&gt;List&amp;lt;&amp;gt;&lt;/code&gt; (u otro Iterable) de Observables, una Matriz de Observables, o incluso un Observable que emite Observables, y la &lt;code&gt;merge&lt;/code&gt; fusionar&amp;aacute; su salida en la salida de un solo Observable:</target>
        </trans-unit>
        <trans-unit id="011efcd591019b5969a332a24dff728a8107dbe2" translate="yes" xml:space="preserve">
          <source>Interval</source>
          <target state="translated">Interval</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="21bcc15c6b9dfe99deeeef31607f80ad9a914de1" translate="yes" xml:space="preserve">
          <source>Invokes an action for each element in the observable sequence and invokes an action upon graceful or exceptional termination of the observable sequence. This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline. When using do, it is important to note that the Observer may receive additional events after a stream has completed or errored (such as when using a repeat or resubscribing). If you are using an Observable that extends the AbstractObservable, you will not receive these events. For this special case, use the DoObserver. doOnNext, doOnError, and doOnCompleted uses the DoObserver internally and will receive these additional events.</source>
          <target state="translated">Invoca una acción para cada elemento de la secuencia observable e invoca una acción al término graciosa o excepcional de la secuencia observable.Este método puede utilizarse para la depuración,registro,etc.del comportamiento de la consulta interceptando el flujo de mensajes para ejecutar acciones arbitrarias para los mensajes en curso.Al utilizar do,es importante señalar que el Observador puede recibir eventos adicionales después de que una secuencia se haya completado o haya cometido un error (por ejemplo,cuando se utiliza una repetición o se vuelve a suscribir).Si está utilizando un Observable que amplía el AbstractObservable,no recibirá estos eventos.Para este caso especial,utilice el DoObserver.doOnNext,doOnError y doOnCompleted utiliza el DoObserver internamente y recibirá estos eventos adicionales.</target>
        </trans-unit>
        <trans-unit id="7d0b0f09c8bd2482d8e9bdd538591ca34488ba8f" translate="yes" xml:space="preserve">
          <source>Invokes the specified function asynchronously on the specified scheduler, surfacing the result through an observable sequence.</source>
          <target state="translated">Invoca la función especificada asincrónicamente en el planificador especificado,sacando a la superficie el resultado a través de una secuencia observable.</target>
        </trans-unit>
        <trans-unit id="002b9d3672a67b31dde384d5c82b77b20d5c5873" translate="yes" xml:space="preserve">
          <source>IsEmpty</source>
          <target state="translated">IsEmpty</target>
        </trans-unit>
        <trans-unit id="e9a2dbf8c765801c6abecc06d035b1c259eda973" translate="yes" xml:space="preserve">
          <source>It decides whether to resubscribe and remirror the source Observable by passing that Observable&amp;rsquo;s termination notifications (error or completed) to a notification handler as &lt;code&gt;void&lt;/code&gt; emissions. This notification handler acts as an Observable operator, taking an Observable that emits these &lt;code&gt;void&lt;/code&gt; notifications as input, and returning an Observable that emits &lt;code&gt;void&lt;/code&gt; items (meaning, resubscribe and mirror the source Observable) or terminates (meaning, terminate the sequence emitted by &lt;code&gt;repeatWhen&lt;/code&gt;).</source>
          <target state="translated">Decide si volver a suscribirse y volver a enviar el Observable de origen pasando las notificaciones de terminaci&amp;oacute;n de Observable (de error o completadas) a un administrador de notificaciones como emisiones &lt;code&gt;void&lt;/code&gt; . Este manejador de notificaciones act&amp;uacute;a como un operador Observable, tomando un Observable que emite estas notificaciones &lt;code&gt;void&lt;/code&gt; como entrada y devolviendo un Observable que emite elementos &lt;code&gt;void&lt;/code&gt; (es decir, resuscribirse y reflejar la fuente Observable) o termina (es decir, termina la secuencia emitida por &lt;code&gt;repeatWhen&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="b05b47ee27b95bf575e3effc01ae6ec08f9813b1" translate="yes" xml:space="preserve">
          <source>It does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">No funciona de forma predeterminada en ning&amp;uacute;n &lt;a href=&quot;../scheduler&quot;&gt;programador en&lt;/a&gt; particular .</target>
        </trans-unit>
        <trans-unit id="2649f51f97bc1799c96a9e6cbbf8c69285c15c00" translate="yes" xml:space="preserve">
          <source>It does not have the variant that uses the emissions from a second Observable to regulate the sampling periodicity.</source>
          <target state="translated">No tiene la variante que utiliza las emisiones de un segundo observable para regular la periodicidad del muestreo.</target>
        </trans-unit>
        <trans-unit id="db3a19396735f14c2206b8954fc9b9b7c96aadb3" translate="yes" xml:space="preserve">
          <source>It extends &lt;a href=&quot;http://en.wikipedia.org/wiki/Observer_pattern&quot;&gt;the observer pattern&lt;/a&gt; to support sequences of data and/or events and adds operators that allow you to compose sequences together declaratively while abstracting away concerns about things like low-level threading, synchronization, thread-safety, concurrent data structures, and non-blocking I/O.</source>
          <target state="translated">Extiende &lt;a href=&quot;http://en.wikipedia.org/wiki/Observer_pattern&quot;&gt;el patr&amp;oacute;n de observador&lt;/a&gt; para admitir secuencias de datos y / o eventos y agrega operadores que le permiten componer secuencias juntas de forma declarativa mientras se abstraen las preocupaciones sobre cosas como subprocesos de bajo nivel, sincronizaci&amp;oacute;n, seguridad de subprocesos, estructuras de datos concurrentes y no bloqueo de E / S.</target>
        </trans-unit>
        <trans-unit id="26cfd44aee2d1282f7da2850ed9a6868a5ea9b7a" translate="yes" xml:space="preserve">
          <source>It extends &lt;a href=&quot;https://en.wikipedia.org/wiki/Observer_pattern&quot;&gt;the observer pattern&lt;/a&gt; to support sequences of data and/or events and adds operators that allow you to compose sequences together declaratively while abstracting away concerns about things like low-level threading, synchronization, thread-safety, concurrent data structures, and non-blocking I/O.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39092222be5c5128f83455e200a511d51d81a068" translate="yes" xml:space="preserve">
          <source>It is &lt;a href=&quot;https://gist.github.com/4671081#file-futuresb-java-L163&quot;&gt;difficult to use Futures to optimally compose conditional asynchronous execution flows&lt;/a&gt; (or impossible, since latencies of each request vary at runtime). This &lt;a href=&quot;http://www.amazon.com/gp/product/0321349601?ie=UTF8&amp;amp;tag=none0b69&amp;amp;linkCode=as2&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=0321349601&quot;&gt;can be done&lt;/a&gt;, of course, but it quickly becomes complicated (and thus error-prone) or it prematurely blocks on &lt;code&gt;Future.get()&lt;/code&gt;, which eliminates the benefit of asynchronous execution.</source>
          <target state="translated">Es &lt;a href=&quot;https://gist.github.com/4671081#file-futuresb-java-L163&quot;&gt;dif&amp;iacute;cil usar Futures para componer de manera &amp;oacute;ptima flujos de ejecuci&amp;oacute;n as&amp;iacute;ncronos condicionales&lt;/a&gt; (o imposible, ya que las latencias de cada solicitud var&amp;iacute;an en tiempo de ejecuci&amp;oacute;n). Esto &lt;a href=&quot;http://www.amazon.com/gp/product/0321349601?ie=UTF8&amp;amp;tag=none0b69&amp;amp;linkCode=as2&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=0321349601&quot;&gt;se puede hacer&lt;/a&gt; , por supuesto, pero r&amp;aacute;pidamente se vuelve complicado (y por lo tanto propenso a errores) o se bloquea prematuramente en &lt;code&gt;Future.get()&lt;/code&gt; , lo que elimina el beneficio de la ejecuci&amp;oacute;n asincr&amp;oacute;nica.</target>
        </trans-unit>
        <trans-unit id="891f0aee785e089e9cb621d4692d8eb9f94a2f80" translate="yes" xml:space="preserve">
          <source>It is &lt;a href=&quot;https://gist.github.com/4671081#file-futuresb-java-L163&quot;&gt;difficult to use Futures to optimally compose conditional asynchronous execution flows&lt;/a&gt; (or impossible, since latencies of each request vary at runtime). This &lt;a href=&quot;https://www.amazon.com/gp/product/0321349601?ie=UTF8&amp;amp;tag=none0b69&amp;amp;linkCode=as2&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=0321349601&quot;&gt;can be done&lt;/a&gt;, of course, but it quickly becomes complicated (and thus error-prone) or it prematurely blocks on &lt;code&gt;Future.get()&lt;/code&gt;, which eliminates the benefit of asynchronous execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f071bee56464f0e79be82a201585f9d5ef9e78d" translate="yes" xml:space="preserve">
          <source>It is a bad idea to use &lt;code&gt;reduce&lt;/code&gt; to collect emitted items into a mutable data structure. Instead, use &lt;code&gt;collect&lt;/code&gt; for that purpose.</source>
          <target state="translated">Es una mala idea utilizar &lt;code&gt;reduce&lt;/code&gt; para recopilar elementos emitidos en una estructura de datos mutable. En su lugar, utilice &lt;code&gt;collect&lt;/code&gt; para ese prop&amp;oacute;sito.</target>
        </trans-unit>
        <trans-unit id="18385c80df1400f4f48ad03f26fe11b4b8b04677" translate="yes" xml:space="preserve">
          <source>It is good practice to check the observer&amp;rsquo;s &lt;code&gt;isUnsubscribed&lt;/code&gt; state from within the function you pass to &lt;code&gt;create&lt;/code&gt; so that your Observable can stop emitting items or doing expensive calculations when there is no longer an interested observer.</source>
          <target state="translated">Es una buena pr&amp;aacute;ctica verificar el estado &lt;code&gt;isUnsubscribed&lt;/code&gt; del observador desde dentro de la funci&amp;oacute;n que pasa a &lt;code&gt;create&lt;/code&gt; para que su Observable pueda dejar de emitir elementos o hacer c&amp;aacute;lculos costosos cuando ya no haya un observador interesado.</target>
        </trans-unit>
        <trans-unit id="f7151837303b01430de52221292363b8696a1db7" translate="yes" xml:space="preserve">
          <source>It is good practice to check the observer&amp;rsquo;s &lt;code&gt;isUnsubscribed&lt;/code&gt; state so that your Observable can stop emitting items or doing expensive calculations when there is no longer an interested observer.</source>
          <target state="translated">Es una buena pr&amp;aacute;ctica comprobar el estado del observador no &lt;code&gt;isUnsubscribed&lt;/code&gt; para que su Observable pueda dejar de emitir elementos o realizar c&amp;aacute;lculos costosos cuando ya no haya un observador interesado.</target>
        </trans-unit>
        <trans-unit id="9807d8fc75f41fdce45545c5c2eab52b2cde18ce" translate="yes" xml:space="preserve">
          <source>It is possible for an Observable to invoke its observers&amp;rsquo; methods asynchronously, perhaps from different threads. This could make such an Observable violate &lt;a href=&quot;../contract&quot;&gt;the Observable contract&lt;/a&gt;, in that it might try to send an &lt;code&gt;OnCompleted&lt;/code&gt; or &lt;code&gt;OnError&lt;/code&gt; notification before one of its &lt;code&gt;OnNext&lt;/code&gt; notifications, or it might make an &lt;code&gt;OnNext&lt;/code&gt; notification from two different threads concurrently. You can force such an Observable to be well-behaved and synchronous by applying the Serialize operator to it.</source>
          <target state="translated">Es posible que un Observable invoque los m&amp;eacute;todos de sus observadores de forma asincr&amp;oacute;nica, quiz&amp;aacute;s desde diferentes hilos. Esto podr&amp;iacute;a hacer que un Observable viole &lt;a href=&quot;../contract&quot;&gt;el contrato de Observable&lt;/a&gt; , ya que podr&amp;iacute;a intentar enviar una notificaci&amp;oacute;n &lt;code&gt;OnCompleted&lt;/code&gt; u &lt;code&gt;OnError&lt;/code&gt; antes de una de sus notificaciones &lt;code&gt;OnNext&lt;/code&gt; , o podr&amp;iacute;a hacer una notificaci&amp;oacute;n &lt;code&gt;OnNext&lt;/code&gt; desde dos subprocesos diferentes al mismo tiempo. Puede forzar que un Observable se comporte bien y sea s&amp;iacute;ncrono aplic&amp;aacute;ndole el operador Serialize.</target>
        </trans-unit>
        <trans-unit id="6eff2d2cefa3f5847f61455d90784355746d0b04" translate="yes" xml:space="preserve">
          <source>It is sometimes called &amp;ldquo;functional reactive programming&amp;rdquo; but this is a misnomer. ReactiveX may be functional, and it may be reactive, but &amp;ldquo;functional reactive programming&amp;rdquo; is a different animal. One main point of difference is that functional reactive programming operates on values that change &lt;em&gt;continuously&lt;/em&gt; over time, while ReactiveX operates on &lt;em&gt;discrete&lt;/em&gt; values that are emitted over time. (See &lt;a href=&quot;https://github.com/conal/essence-and-origins-of-frp&quot;&gt;Conal Elliott&amp;rsquo;s work for more-precise information on functional reactive programming&lt;/a&gt;.)</source>
          <target state="translated">A veces se le llama &quot;programaci&amp;oacute;n reactiva funcional&quot;, pero es un nombre inapropiado. ReactiveX puede ser funcional y puede ser reactivo, pero la &quot;programaci&amp;oacute;n funcional reactiva&quot; es un animal diferente. Un punto principal de diferencia es que la programaci&amp;oacute;n reactiva funcional opera con valores que cambian &lt;em&gt;continuamente&lt;/em&gt; con el tiempo, mientras que ReactiveX opera con valores &lt;em&gt;discretos&lt;/em&gt; que se emiten con el tiempo. (Consulte &lt;a href=&quot;https://github.com/conal/essence-and-origins-of-frp&quot;&gt;el trabajo de Conal Elliott para obtener informaci&amp;oacute;n m&amp;aacute;s precisa sobre la programaci&amp;oacute;n reactiva funcional&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="fdbf510bdf3d816e45ee8d48f0cc1228dc05a4a9" translate="yes" xml:space="preserve">
          <source>It is usually best that you compose new operators by combining existing ones, to the extent that this is possible, rather than reinventing the wheel. RxJava itself does this with some of its standard operators, for example:</source>
          <target state="translated">Normalmente es mejor que componga nuevos operadores combinando los existentes,en la medida en que esto sea posible,en lugar de reinventar la rueda.La propia RxJava hace esto con algunos de sus operadores estándar,por ejemplo:</target>
        </trans-unit>
        <trans-unit id="89174431a1a966b8fb514184bda6c8efce66dfd4" translate="yes" xml:space="preserve">
          <source>It may call a Subscriber's &lt;a href=&quot;observable#onnext-oncompleted-and-onerror&quot;&gt;&lt;code&gt;onNext( )&lt;/code&gt;&lt;/a&gt; method any number of times, but these calls must be non-overlapping.</source>
          <target state="translated">Puede llamar al m&amp;eacute;todo &lt;a href=&quot;observable#onnext-oncompleted-and-onerror&quot;&gt; &lt;code&gt;onNext( )&lt;/code&gt; &lt;/a&gt; un suscriptor cualquier n&amp;uacute;mero de veces, pero estas llamadas no deben superponerse.</target>
        </trans-unit>
        <trans-unit id="f1823f48cd27350e850e10e37c5ce6fe62ec4444" translate="yes" xml:space="preserve">
          <source>It may call either a Subscriber's &lt;a href=&quot;observable#onnext-oncompleted-and-onerror&quot;&gt;&lt;code&gt;onCompleted( )&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;observable#onnext-oncompleted-and-onerror&quot;&gt;&lt;code&gt;onError( )&lt;/code&gt;&lt;/a&gt; method, but not both, exactly once, and it may not subsequently call a Subscriber's &lt;a href=&quot;observable#onnext-oncompleted-and-onerror&quot;&gt;&lt;code&gt;onNext( )&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Puede llamar al &lt;a href=&quot;observable#onnext-oncompleted-and-onerror&quot;&gt; &lt;code&gt;onCompleted( )&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;observable#onnext-oncompleted-and-onerror&quot;&gt; &lt;code&gt;onError( )&lt;/code&gt; &lt;/a&gt; un suscriptor , pero no a ambos, exactamente una vez, y no puede llamar posteriormente al m&amp;eacute;todo &lt;a href=&quot;observable#onnext-oncompleted-and-onerror&quot;&gt; &lt;code&gt;onNext( )&lt;/code&gt; &lt;/a&gt; un suscriptor .</target>
        </trans-unit>
        <trans-unit id="2f070c7f11576ed486233e35474ddda41c4700b8" translate="yes" xml:space="preserve">
          <source>It requires one of the following distributions:</source>
          <target state="translated">Requiere una de las siguientes distribuciones:</target>
        </trans-unit>
        <trans-unit id="ca33803823f2ece4ecb5834672e63305ef95cfe5" translate="yes" xml:space="preserve">
          <source>It requires one of the following packages:</source>
          <target state="translated">Requiere uno de los siguientes paquetes:</target>
        </trans-unit>
        <trans-unit id="94d3d61d261c2ecef4925faed7443e2f2b6b049b" translate="yes" xml:space="preserve">
          <source>It requires one of the following:</source>
          <target state="translated">Se requiere uno de los siguientes:</target>
        </trans-unit>
        <trans-unit id="595e4e764020b5cf5ee3bcbb8f01313e97b8eb51" translate="yes" xml:space="preserve">
          <source>It will also emit this same final value to any subsequent observers. However, if the source Observable terminates with an error, the &lt;code&gt;AsyncSubject&lt;/code&gt; will not emit any items, but will simply pass along the error notification from the source Observable.</source>
          <target state="translated">Tambi&amp;eacute;n emitir&amp;aacute; este mismo valor final a cualquier observador posterior. Sin embargo, si el Observable de origen termina con un error, &lt;code&gt;AsyncSubject&lt;/code&gt; no emitir&amp;aacute; ning&amp;uacute;n elemento, sino que simplemente enviar&amp;aacute; la notificaci&amp;oacute;n de error del Observable de origen.</target>
        </trans-unit>
        <trans-unit id="34f02c71d6fa00b4deeade3bfbabd8b4f0199f33" translate="yes" xml:space="preserve">
          <source>Iterable (pull)</source>
          <target state="translated">Iterable (tirar)</target>
        </trans-unit>
        <trans-unit id="77c1c3007f7e0cc78d64781295922fced377fcae" translate="yes" xml:space="preserve">
          <source>Iterables, for example, can be thought of as a sort of synchronous Observable; Futures, as a sort of Observable that always emits only a single item. By explicitly converting such objects to Observables, you allow them to interact as peers with other Observables.</source>
          <target state="translated">Los Iterables,por ejemplo,pueden ser pensados como una especie de Observables sincrónicos;los Futuros,como una especie de Observables que siempre emiten un solo elemento.Al convertir explícitamente tales objetos en Observables,se les permite interactuar como pares con otros Observables.</target>
        </trans-unit>
        <trans-unit id="d4315de8eb96f9d5efab572bae1c956c26e04d48" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#all(io.reactivex.functions.Predicate)&quot;&gt;&lt;code&gt;all(Predicate)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#all(io.reactivex.functions.Predicate)&quot;&gt; &lt;code&gt;all(Predicate)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9c2d2bb807348c5a5bb2c5970e7049467cbc2bc0" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#amb(java.lang.Iterable)&quot;&gt;&lt;code&gt;amb(Iterable)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#amb(java.lang.Iterable)&quot;&gt; &lt;code&gt;amb(Iterable)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="46d652bb88043ecd2f247b688bb25aba237a1670" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#ambWith(io.reactivex.ObservableSource)&quot;&gt;&lt;code&gt;ambWith(Observable)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#ambWith(io.reactivex.ObservableSource)&quot;&gt; &lt;code&gt;ambWith(Observable)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="79801e93b31ea69def0891c5ca351103123a0395" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#empty()&quot;&gt;&lt;code&gt;empty()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#empty()&quot;&gt; &lt;code&gt;empty()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d612270b0b6dae224275e36de2f214e983b9162a" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#error(java.lang.Throwable)&quot;&gt;&lt;code&gt;error(Throwable)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#error(java.lang.Throwable)&quot;&gt; &lt;code&gt;error(Throwable)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="739b3189dd25d213d0efe5f2677878877c3bb018" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#error(java.util.concurrent.Callable)&quot;&gt;&lt;code&gt;error(Callable)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#error(java.util.concurrent.Callable)&quot;&gt; &lt;code&gt;error(Callable)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="00d7842c837d4d62344821564ad93d023e2720cb" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#never()&quot;&gt;&lt;code&gt;never()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#never()&quot;&gt; &lt;code&gt;never()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f8d8819c38a240885157cbd94598334402e3674d" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#all(rx.functions.Func1)&quot;&gt;&lt;code&gt;all(Func1)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#all(rx.functions.Func1)&quot;&gt; &lt;code&gt;all(Func1)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d6e16a78f86bba91a61a8a39b0bee1639141b4a0" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#amb(java.lang.Iterable)&quot;&gt;&lt;code&gt;amb(Iterable)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#amb(java.lang.Iterable)&quot;&gt; &lt;code&gt;amb(Iterable)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cb914eb34da607efe1851c51fece981b8a5d93ad" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#amb(rx.Observable,%20rx.Observable)&quot;&gt;&lt;code&gt;amb(Observable,Observable)&lt;/code&gt;&lt;/a&gt; (there are also versions that take up to nine Observable parameters)</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#amb(rx.Observable,%20rx.Observable)&quot;&gt; &lt;code&gt;amb(Observable,Observable)&lt;/code&gt; &lt;/a&gt; (tambi&amp;eacute;n hay versiones que toman hasta nueve par&amp;aacute;metros observables)</target>
        </trans-unit>
        <trans-unit id="6fa8dcea2523bcdb9be5374ff461051895601ef9" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#ambWith(rx.Observable)&quot;&gt;&lt;code&gt;ambWith(Observable)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#ambWith(rx.Observable)&quot;&gt; &lt;code&gt;ambWith(Observable)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9ac6f58e233b25dd5d275d2b6dbbeb82402fadfd" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(int)&quot;&gt;&lt;code&gt;buffer(int)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(int)&quot;&gt; &lt;code&gt;buffer(int)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3f4da8ad769c45ae36504e5e4b7db9678f04beed" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(int,%20int)&quot;&gt;&lt;code&gt;buffer(int,int)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(int,%20int)&quot;&gt; &lt;code&gt;buffer(int,int)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5c3114cc9509b09ba21be9976417c1d41b12b542" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit)&quot;&gt;&lt;code&gt;buffer(long,TimeUnit)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit)&quot;&gt; &lt;code&gt;buffer(long,TimeUnit)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f079df920af6fbe33cc7438b0af7d1b861068b58" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit,%20int)&quot;&gt;&lt;code&gt;buffer(long,TimeUnit,int)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit,%20int)&quot;&gt; &lt;code&gt;buffer(long,TimeUnit,int)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a7f01ab7dca8a888386fa5570d9f0b2e382b0f4a" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit,%20int,%20rx.Scheduler)&quot;&gt;&lt;code&gt;buffer(long,TimeUnit,int,Scheduler)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit,%20int,%20rx.Scheduler)&quot;&gt; &lt;code&gt;buffer(long,TimeUnit,int,Scheduler)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a169daeda654c4fee9bff30b2d8a9d0424179071" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)&quot;&gt;&lt;code&gt;buffer(long,TimeUnit,Scheduler)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)&quot;&gt; &lt;code&gt;buffer(long,TimeUnit,Scheduler)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3b62647dc23afa8babf67cfbc877e420f4ebb819" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20long,%20java.util.concurrent.TimeUnit)&quot;&gt;&lt;code&gt;buffer(long,long,TimeUnit)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20long,%20java.util.concurrent.TimeUnit)&quot;&gt; &lt;code&gt;buffer(long,long,TimeUnit)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a877f462a5deb198dfc0204b93c36359d93eae06" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)&quot;&gt;&lt;code&gt;buffer(long,long,TimeUnit,Scheduler)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)&quot;&gt; &lt;code&gt;buffer(long,long,TimeUnit,Scheduler)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="86d0c1c1c839634afc3f6c3c4a219ba201e6a4f2" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable)&quot;&gt;&lt;code&gt;buffer(Observable)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable)&quot;&gt; &lt;code&gt;buffer(Observable)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="507fd0d63c19e5259957c06f2c5e974b2361ac5e" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable,%20int)&quot;&gt;&lt;code&gt;buffer(Observable,int)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable,%20int)&quot;&gt; &lt;code&gt;buffer(Observable,int)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="19480f4a8a048d195247eca7c8ae389d06924f5d" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable,%20rx.functions.Func1)&quot;&gt;&lt;code&gt;buffer(Observable,Func1)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable,%20rx.functions.Func1)&quot;&gt; &lt;code&gt;buffer(Observable,Func1)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="24c5bc0bbf6f71e96eeb78bdbb7b8d2effc287b6" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.functions.Func0)&quot;&gt;&lt;code&gt;buffer(Func0)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.functions.Func0)&quot;&gt; &lt;code&gt;buffer(Func0)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4208c1d7ad4205ea40fa25a698af88ff2e762b45" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#cast(java.lang.Class)&quot;&gt;&lt;code&gt;cast(Class)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#cast(java.lang.Class)&quot;&gt; &lt;code&gt;cast(Class)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ef3db7ed2c0b62e5c36cbfc3fa2ca492c81d1a49" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#collect(rx.functions.Func0,%20rx.functions.Action2)&quot;&gt;&lt;code&gt;collect(Func0,Action2)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#collect(rx.functions.Func0,%20rx.functions.Action2)&quot;&gt; &lt;code&gt;collect(Func0,Action2)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fa67b873ecab3613f6b64ce78a0bdc32e5926fa9" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#combineLatest(java.util.List,%20rx.functions.FuncN)&quot;&gt;&lt;code&gt;combineLatest(List,FuncN)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#combineLatest(java.util.List,%20rx.functions.FuncN)&quot;&gt; &lt;code&gt;combineLatest(List,FuncN)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec7df6aac2f2e3c95a112f207b4dbda0f7a7d0c6" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#combineLatest(rx.Observable,%20rx.Observable,%20rx.functions.Func2)&quot;&gt;&lt;code&gt;combineLatest(Observable,Observable,Func2)&lt;/code&gt;&lt;/a&gt; (there are also versions that take up to nine Observables)</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#combineLatest(rx.Observable,%20rx.Observable,%20rx.functions.Func2)&quot;&gt; &lt;code&gt;combineLatest(Observable,Observable,Func2)&lt;/code&gt; &lt;/a&gt; (tambi&amp;eacute;n hay versiones que toman hasta nueve Observables)</target>
        </trans-unit>
        <trans-unit id="065654bfbdd9b9bee866590ec170ff626ea47e08" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#concat(rx.Observable)&quot;&gt;&lt;code&gt;concat(Observable&amp;lt;Observable&amp;gt;)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#concat(rx.Observable)&quot;&gt; &lt;code&gt;concat(Observable&amp;lt;Observable&amp;gt;)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b5260958a449491f7610db2dc9bb82bc9b45e109" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#concat(rx.Observable,%20rx.Observable)&quot;&gt;&lt;code&gt;concat(Observable,Observable)&lt;/code&gt;&lt;/a&gt; (there are also versions that take up to nine Observables)</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#concat(rx.Observable,%20rx.Observable)&quot;&gt; &lt;code&gt;concat(Observable,Observable)&lt;/code&gt; &lt;/a&gt; (tambi&amp;eacute;n hay versiones que toman hasta nueve Observables)</target>
        </trans-unit>
        <trans-unit id="50e62fe96dcbddd17b24ab4cd101fe1c35a3d6df" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#concatMap(rx.functions.Func1)&quot;&gt;&lt;code&gt;concatMap(Func1)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#concatMap(rx.functions.Func1)&quot;&gt; &lt;code&gt;concatMap(Func1)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d7f8062d4eceee18625891f695512adafea0ce1b" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#concatWith(rx.Observable)&quot;&gt;&lt;code&gt;concatWith(Observable)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#concatWith(rx.Observable)&quot;&gt; &lt;code&gt;concatWith(Observable)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="af422290d005f62aabe996a727d72476d3979818" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#contains(java.lang.Object)&quot;&gt;&lt;code&gt;contains(Object)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#contains(java.lang.Object)&quot;&gt; &lt;code&gt;contains(Object)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="70bacf76ad19d833c6f617bc4a72f0211c2df6b9" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#count()&quot;&gt;&lt;code&gt;count()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#count()&quot;&gt; &lt;code&gt;count()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c0135bdfd6a0be2f5741df4e612e42cc09264016" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#countLong()&quot;&gt;&lt;code&gt;countLong()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#countLong()&quot;&gt; &lt;code&gt;countLong()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c6913a045e4bd9b5ec923b8deed52b537c92fcf3" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#create(rx.Observable.OnSubscribe)&quot;&gt;&lt;code&gt;create(OnSubscribe)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#create(rx.Observable.OnSubscribe)&quot;&gt; &lt;code&gt;create(OnSubscribe)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dd4e32a121d2f3b9718d60b90e2a55ca637ed7d5" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#debounce(rx.functions.Func1)&quot;&gt;&lt;code&gt;debounce(Func1)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#debounce(rx.functions.Func1)&quot;&gt; &lt;code&gt;debounce(Func1)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="14e04e6e0b8a579ec0455332f25d673a969ebe63" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#defaultIfEmpty(T)&quot;&gt;&lt;code&gt;defaultIfEmpty(T)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#defaultIfEmpty(T)&quot;&gt; &lt;code&gt;defaultIfEmpty(T)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3665f849f7caae696ee21ed577b42416b67b5e53" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#defer(rx.functions.Func0)&quot;&gt;&lt;code&gt;defer()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#defer(rx.functions.Func0)&quot;&gt; &lt;code&gt;defer()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f24e91a0b092b6e002922bb2340a890ca0edec33" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#delay(long,%20java.util.concurrent.TimeUnit)&quot;&gt;&lt;code&gt;delay(long,TimeUnit)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#delay(long,%20java.util.concurrent.TimeUnit)&quot;&gt; &lt;code&gt;delay(long,TimeUnit)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ef2b29abfc91519e0f51d0c4dd0da82457c7399e" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#delay(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)&quot;&gt;&lt;code&gt;delay()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#delay(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)&quot;&gt; &lt;code&gt;delay()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
