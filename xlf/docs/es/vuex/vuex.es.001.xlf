<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="vuex">
    <body>
      <group id="vuex">
        <trans-unit id="74ae1a27792287a53f632864ec413cb560452e7e" translate="yes" xml:space="preserve">
          <source>&quot;createLogger&quot; function is exported from the core module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9b529393c3179a77a9306c183468564863d0ff0" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2015&amp;ndash;present Evan You</source>
          <target state="translated">&amp;copy; 2015 &amp;ndash; presente Evan You</target>
        </trans-unit>
        <trans-unit id="3dbca386b3bf4c0c03ea3c64d065f726c26a64b7" translate="yes" xml:space="preserve">
          <source>1. Installation</source>
          <target state="translated">1.Instalación</target>
        </trans-unit>
        <trans-unit id="7644d763c0c7ace9ff19d36e4552b445a389efe0" translate="yes" xml:space="preserve">
          <source>10. Strict Mode</source>
          <target state="translated">10.Modo estricto</target>
        </trans-unit>
        <trans-unit id="290258555d6677c0ac84626e214aa009f8a85e64" translate="yes" xml:space="preserve">
          <source>11. Form Handling</source>
          <target state="translated">11.manejo de la forma</target>
        </trans-unit>
        <trans-unit id="4129c08ad5f758bb8883f75f714cc03d6b8724d7" translate="yes" xml:space="preserve">
          <source>12. Testing</source>
          <target state="translated">12ª Prueba</target>
        </trans-unit>
        <trans-unit id="528a3b9b2d03ca80ea557ac5c60aa567789512ff" translate="yes" xml:space="preserve">
          <source>13. Hot Reloading</source>
          <target state="translated">13.Recarga en caliente</target>
        </trans-unit>
        <trans-unit id="dbc8b357691409e9c4daf2c6428dbe68446dc47c" translate="yes" xml:space="preserve">
          <source>2. Getting Started</source>
          <target state="translated">2.Empezando</target>
        </trans-unit>
        <trans-unit id="999bcc9c65f419d4177fbc85fb43d8d53350ea26" translate="yes" xml:space="preserve">
          <source>3. State</source>
          <target state="translated">3.Estado</target>
        </trans-unit>
        <trans-unit id="86901adbf99889e89f6fb5664ba644ee179d5895" translate="yes" xml:space="preserve">
          <source>4. Getters</source>
          <target state="translated">4.Getters</target>
        </trans-unit>
        <trans-unit id="f5dd21d6df4b83ebbdd0d793bd18c24ecafd3d6a" translate="yes" xml:space="preserve">
          <source>5. Mutations</source>
          <target state="translated">5.mutaciones</target>
        </trans-unit>
        <trans-unit id="d2db7e791345bd3756bb20faaf9a14d8b1ca6e1d" translate="yes" xml:space="preserve">
          <source>6. Actions</source>
          <target state="translated">6.Acciones</target>
        </trans-unit>
        <trans-unit id="311b202ab670d27bdcb3786803bee13f6ac0dd04" translate="yes" xml:space="preserve">
          <source>7. Modules</source>
          <target state="translated">7.Módulos</target>
        </trans-unit>
        <trans-unit id="5b2c110974e654cf654a583f99f4466b77ffad4a" translate="yes" xml:space="preserve">
          <source>8. Application Structure</source>
          <target state="translated">8.Estructura de la aplicación</target>
        </trans-unit>
        <trans-unit id="35fca60c7ce35ec44954758baa9845c6764c93f3" translate="yes" xml:space="preserve">
          <source>9. Plugins</source>
          <target state="translated">9.Plugins</target>
        </trans-unit>
        <trans-unit id="e491a21fa71516f2b26e081f14ece268b038b5c2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://unpkg.com&quot;&gt;Unpkg.com&lt;/a&gt; provides NPM-based CDN links. The above link will always point to the latest release on NPM. You can also use a specific version/tag via URLs like &lt;code&gt;https://unpkg.com/vuex@2.0.0&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://unpkg.com&quot;&gt;Unpkg.com&lt;/a&gt; proporciona enlaces CDN basados ​​en NPM. El enlace anterior siempre apuntar&amp;aacute; a la &amp;uacute;ltima versi&amp;oacute;n de NPM. Tambi&amp;eacute;n puede usar una versi&amp;oacute;n / etiqueta espec&amp;iacute;fica a trav&amp;eacute;s de URL como &lt;code&gt;https://unpkg.com/vuex@2.0.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0ab7dbdd7961ea625457c4f71c2a103e97577e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;createLogger&lt;/code&gt; function is exported from the core module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="140249cc0098c39ea9eee2f348b83aec84aeaea9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options&lt;/code&gt; can have &lt;code&gt;preserveState: true&lt;/code&gt; that allows to preserve the previous state. Useful with Server Side Rendering.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; pueden tener &lt;code&gt;preserveState: true&lt;/code&gt; que permite conservar el estado anterior. &amp;Uacute;til con la representaci&amp;oacute;n del lado del servidor.</target>
        </trans-unit>
        <trans-unit id="1d43392242421ea5926dd1b8219417091c58e5ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subscribeAction&lt;/code&gt; can also specify an &lt;code&gt;error&lt;/code&gt; handler to catch an error thrown when an action is dispatched. The function will receive an &lt;code&gt;error&lt;/code&gt; object as the third argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efda1a76b4931ed64f56c475099103b6b342e77a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subscribeAction&lt;/code&gt; can also specify whether the subscribe handler should be called &lt;em&gt;before&lt;/em&gt; or &lt;em&gt;after&lt;/em&gt; an action dispatch (the default behavior is &lt;em&gt;before&lt;/em&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93bc29b6324b7d1ed0dc681c2aa882c85b026c76" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Do not enable strict mode when deploying for production!&lt;/strong&gt; Strict mode runs a synchronous deep watcher on the state tree for detecting inappropriate mutations, and it can be quite expensive when you make large amount of mutations to the state. Make sure to turn it off in production to avoid the performance cost.</source>
          <target state="translated">&lt;strong&gt;&amp;iexcl;No habilite el modo estricto al implementar para producci&amp;oacute;n! &lt;/strong&gt;El modo estricto ejecuta un observador profundo sincr&amp;oacute;nico en el &amp;aacute;rbol de estado para detectar mutaciones inapropiadas, y puede ser bastante costoso cuando se realizan una gran cantidad de mutaciones en el estado. Aseg&amp;uacute;rese de apagarlo en producci&amp;oacute;n para evitar el costo de rendimiento.</target>
        </trans-unit>
        <trans-unit id="9f9016c15f9b85d16a456b0a8fed9e60d27f0c18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt; We will be using ES2015 syntax for code examples for the rest of the docs. If you haven't picked it up, &lt;a href=&quot;https://babeljs.io/docs/learn-es2015/&quot;&gt;you should&lt;/a&gt;!</source>
          <target state="translated">&lt;strong&gt;NOTA:&lt;/strong&gt; Usaremos la sintaxis ES2015 para ejemplos de c&amp;oacute;digo para el resto de los documentos. Si no lo ha recogido, &lt;a href=&quot;https://babeljs.io/docs/learn-es2015/&quot;&gt;&amp;iexcl;deber&amp;iacute;a hacerlo&lt;/a&gt; !</target>
        </trans-unit>
        <trans-unit id="543738af7550fb2b326fb4aec1d84822e5d85d47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Plugins that take state snapshots should be used only during development.&lt;/strong&gt; When using webpack or Browserify, we can let our build tools handle that for us:</source>
          <target state="translated">&lt;strong&gt;Los complementos que toman instant&amp;aacute;neas de estado deben usarse solo durante el desarrollo. &lt;/strong&gt;Cuando usamos webpack o Browserify, podemos dejar que nuestras herramientas de compilaci&amp;oacute;n lo manejen por nosotros:</target>
        </trans-unit>
        <trans-unit id="152494aaef0de9abdd755c1e397ccd919faab73b" translate="yes" xml:space="preserve">
          <source>A more practical example of real-world actions would be an action to checkout a shopping cart, which involves &lt;strong&gt;calling an async API&lt;/strong&gt; and &lt;strong&gt;committing multiple mutations&lt;/strong&gt;:</source>
          <target state="translated">Un ejemplo m&amp;aacute;s pr&amp;aacute;ctico de acciones del mundo real ser&amp;iacute;a una acci&amp;oacute;n para pagar un carrito de compras, que implica &lt;strong&gt;llamar a una API as&amp;iacute;ncrona&lt;/strong&gt; y &lt;strong&gt;cometer m&amp;uacute;ltiples mutaciones&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="b276f94cd8d0e74a21de6e5939b8c10ca9a975d6" translate="yes" xml:space="preserve">
          <source>API Reference</source>
          <target state="translated">Referencia API</target>
        </trans-unit>
        <trans-unit id="5f613656881e083dfef9e6ff61f4361ce0a8891f" translate="yes" xml:space="preserve">
          <source>Accessing Global Assets in Namespaced Modules</source>
          <target state="translated">Acceder a los activos globales en módulos con nombres</target>
        </trans-unit>
        <trans-unit id="a6ab98e7c5d9fe16cce79fc5b58d4c6a0bb97528" translate="yes" xml:space="preserve">
          <source>Accessing Mutations and Actions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18d2c21a5e764fa3068b12a662b48a445b54e874" translate="yes" xml:space="preserve">
          <source>Accessing State and Getters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d5c235f81dfbc7a38598e493ee1ecf48d2948cf" translate="yes" xml:space="preserve">
          <source>Action handlers receive a context object which exposes the same set of methods/properties on the store instance, so you can call &lt;code&gt;context.commit&lt;/code&gt; to commit a mutation, or access the state and getters via &lt;code&gt;context.state&lt;/code&gt; and &lt;code&gt;context.getters&lt;/code&gt;. We can even call other actions with &lt;code&gt;context.dispatch&lt;/code&gt;. We will see why this context object is not the store instance itself when we introduce &lt;a href=&quot;modules&quot;&gt;Modules&lt;/a&gt; later.</source>
          <target state="translated">Los controladores de acci&amp;oacute;n reciben un objeto de contexto que expone el mismo conjunto de m&amp;eacute;todos / propiedades en la instancia de la tienda, por lo que puede llamar a &lt;code&gt;context.commit&lt;/code&gt; para realizar una mutaci&amp;oacute;n, o acceder al estado y los captadores a trav&amp;eacute;s de &lt;code&gt;context.state&lt;/code&gt; y &lt;code&gt;context.getters&lt;/code&gt; . Incluso podemos llamar a otras acciones con &lt;code&gt;context.dispatch&lt;/code&gt; . Veremos por qu&amp;eacute; este objeto de contexto no es la instancia de la tienda en s&amp;iacute; cuando introduzcamos &lt;a href=&quot;modules&quot;&gt;M&amp;oacute;dulos&lt;/a&gt; m&amp;aacute;s adelante.</target>
        </trans-unit>
        <trans-unit id="c3cd636a585b20c40ac2df5ffb403e83cb2eef51" translate="yes" xml:space="preserve">
          <source>Actions</source>
          <target state="translated">Actions</target>
        </trans-unit>
        <trans-unit id="fd2b38844159f4c8bd1a540f724142f21bcb2783" translate="yes" xml:space="preserve">
          <source>Actions are often asynchronous, so how do we know when an action is done? And more importantly, how can we compose multiple actions together to handle more complex async flows?</source>
          <target state="translated">Las acciones son a menudo asincrónicas,así que ¿cómo sabemos cuándo se realiza una acción? Y lo más importante,¿cómo podemos componer múltiples acciones juntas para manejar flujos asíncronos más complejos?</target>
        </trans-unit>
        <trans-unit id="eebbe3f939d0e7eb5a702bddfd2a09d58662a331" translate="yes" xml:space="preserve">
          <source>Actions are similar to mutations, the differences being that:</source>
          <target state="translated">Las acciones son similares a las mutaciones,las diferencias son que:</target>
        </trans-unit>
        <trans-unit id="2fb7f3eefbb910c724298c1fe2f73e2dd2775642" translate="yes" xml:space="preserve">
          <source>Actions are triggered with the &lt;code&gt;store.dispatch&lt;/code&gt; method:</source>
          <target state="translated">Las acciones se activan con el m&amp;eacute;todo &lt;code&gt;store.dispatch&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e0710bf63012535b6c8d8716b3dcac5cf1237306" translate="yes" xml:space="preserve">
          <source>Actions can be a bit more tricky because they may call out to external APIs. When testing actions, we usually need to do some level of mocking - for example, we can abstract the API calls into a service and mock that service inside our tests. In order to easily mock dependencies, we can use webpack and &lt;a href=&quot;https://github.com/plasticine/inject-loader&quot;&gt;inject-loader&lt;/a&gt; to bundle our test files.</source>
          <target state="translated">Las acciones pueden ser un poco m&amp;aacute;s complicadas porque pueden llamar a API externas. Al probar acciones, generalmente necesitamos hacer alg&amp;uacute;n nivel de burla; por ejemplo, podemos abstraer las llamadas a la API en un servicio y simular ese servicio dentro de nuestras pruebas. Para simular dependencias f&amp;aacute;cilmente, podemos usar webpack e &lt;a href=&quot;https://github.com/plasticine/inject-loader&quot;&gt;inject-loader&lt;/a&gt; para empaquetar nuestros archivos de prueba.</target>
        </trans-unit>
        <trans-unit id="5b7eca18a813d34c8aa01e8ef07ee7519aaf8e37" translate="yes" xml:space="preserve">
          <source>Actions can contain arbitrary asynchronous operations.</source>
          <target state="translated">Las acciones pueden contener operaciones asincrónicas arbitrarias.</target>
        </trans-unit>
        <trans-unit id="20c41c87b2101245945eb4d510d08709af6ca47f" translate="yes" xml:space="preserve">
          <source>Actions from different views may need to mutate the same piece of state.</source>
          <target state="translated">Las acciones de diferentes puntos de vista pueden necesitar mutar el mismo pedazo de estado.</target>
        </trans-unit>
        <trans-unit id="cc658d581fafc63b17159bbd703e4b6ae9e6654d" translate="yes" xml:space="preserve">
          <source>Actions support the same payload format and object-style dispatch:</source>
          <target state="translated">Las acciones apoyan el mismo formato de carga útil y el envío de objetos:</target>
        </trans-unit>
        <trans-unit id="e6f1f5e24996a891b4012e435efadfe597fd76af" translate="yes" xml:space="preserve">
          <source>Admittedly, the above is quite a bit more verbose than &lt;code&gt;v-model&lt;/code&gt; + local state, and we lose some of the useful features from &lt;code&gt;v-model&lt;/code&gt; as well. An alternative approach is using a two-way computed property with a setter:</source>
          <target state="translated">Es cierto que lo anterior es un poco m&amp;aacute;s detallado que &lt;code&gt;v-model&lt;/code&gt; + local state, y tambi&amp;eacute;n perdemos algunas de las caracter&amp;iacute;sticas &amp;uacute;tiles del &lt;code&gt;v-model&lt;/code&gt; . Un enfoque alternativo es utilizar una propiedad calculada bidireccional con un establecedor:</target>
        </trans-unit>
        <trans-unit id="1202f0740ed7d8ae90a711fe902caaa8f08e09b3" translate="yes" xml:space="preserve">
          <source>After &lt;a href=&quot;../installation&quot;&gt;installing&lt;/a&gt; Vuex, let's create a store. It is pretty straightforward - just provide an initial state object, and some mutations:</source>
          <target state="translated">Despu&amp;eacute;s de &lt;a href=&quot;../installation&quot;&gt;instalar&lt;/a&gt; Vuex, creemos una tienda. Es bastante sencillo: solo proporcione un objeto de estado inicial y algunas mutaciones:</target>
        </trans-unit>
        <trans-unit id="a38a6afdb72dbde1dead2d25ed43a801e44eeba7" translate="yes" xml:space="preserve">
          <source>Again, the reason we are committing a mutation instead of changing &lt;code&gt;store.state.count&lt;/code&gt; directly, is because we want to explicitly track it. This simple convention makes your intention more explicit, so that you can reason about state changes in your app better when reading the code. In addition, this gives us the opportunity to implement tools that can log every mutation, take state snapshots, or even perform time travel debugging.</source>
          <target state="translated">Nuevamente, la raz&amp;oacute;n por la que estamos cometiendo una mutaci&amp;oacute;n en lugar de cambiar &lt;code&gt;store.state.count&lt;/code&gt; directamente, es porque queremos rastrearla expl&amp;iacute;citamente. Esta simple convenci&amp;oacute;n hace que su intenci&amp;oacute;n sea m&amp;aacute;s expl&amp;iacute;cita, para que pueda razonar mejor sobre los cambios de estado en su aplicaci&amp;oacute;n al leer el c&amp;oacute;digo. Adem&amp;aacute;s, esto nos brinda la oportunidad de implementar herramientas que pueden registrar cada mutaci&amp;oacute;n, tomar instant&amp;aacute;neas de estado o incluso realizar depuraci&amp;oacute;n de viajes en el tiempo.</target>
        </trans-unit>
        <trans-unit id="eab081c4e733f3e8e7fc4113e3a4c3e9822d6e7f" translate="yes" xml:space="preserve">
          <source>Almost all Vuex 4 APIs have remained unchanged from Vuex 3. However, there are still a few breaking changes that you must fix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="321cdc14e97d2ee50f5d65dc4d313dcb119e79c0" translate="yes" xml:space="preserve">
          <source>Also, inside module getters, the root state will be exposed as their 3rd argument:</source>
          <target state="translated">Además,dentro de los recibidores de módulos,el estado raíz será expuesto como su 3er argumento:</target>
        </trans-unit>
        <trans-unit id="2eee5b4fbbc1f54a27e6412f36e8fc0250ed0ca4" translate="yes" xml:space="preserve">
          <source>An alternative way to commit a mutation is by directly using an object that has a &lt;code&gt;type&lt;/code&gt; property:</source>
          <target state="translated">Una forma alternativa de cometer una mutaci&amp;oacute;n es usando directamente un objeto que tenga una propiedad de &lt;code&gt;type&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c5bfc0baa5cb6ec7b1c1c279caffbe5d5b8218a2" translate="yes" xml:space="preserve">
          <source>An array of plugin functions to be applied to the store. The plugin simply receives the store as the only argument and can either listen to mutations (for outbound data persistence, logging, or debugging) or dispatch mutations (for inbound data e.g. websockets or observables).</source>
          <target state="translated">Una serie de funciones de plugin para ser aplicadas a la tienda.El plugin simplemente recibe el almacén como único argumento y puede escuchar las mutaciones (para la persistencia,registro o depuración de datos salientes)o enviar mutaciones (para datos entrantes,por ejemplo,webckets u observables).</target>
        </trans-unit>
        <trans-unit id="6b626f3c447742f2fad682725d05b28250d88b5f" translate="yes" xml:space="preserve">
          <source>An object containing sub modules to be merged into the store, in the shape of:</source>
          <target state="translated">Un objeto que contiene submódulos para ser fusionados en la tienda,en forma de:</target>
        </trans-unit>
        <trans-unit id="dc46a43c367676022711c845ac16cc5387d782f6" translate="yes" xml:space="preserve">
          <source>And also in another action:</source>
          <target state="translated">Y también en otra acción:</target>
        </trans-unit>
        <trans-unit id="4db792123502a659fd37a4ca852f43e15ee1ef57" translate="yes" xml:space="preserve">
          <source>And also receives a second &lt;code&gt;payload&lt;/code&gt; argument if there is one.</source>
          <target state="translated">Y tambi&amp;eacute;n recibe un segundo argumento de &lt;code&gt;payload&lt;/code&gt; si lo hay.</target>
        </trans-unit>
        <trans-unit id="6eb1eaafd8f229821b275541a054f723a80d42bf" translate="yes" xml:space="preserve">
          <source>And can be used like this:</source>
          <target state="translated">Y puede ser usado así:</target>
        </trans-unit>
        <trans-unit id="fe2969186d8cff2f758236d5c540ae4e48a2d751" translate="yes" xml:space="preserve">
          <source>And here's the mutation handler:</source>
          <target state="translated">Y aquí está el controlador de la mutación:</target>
        </trans-unit>
        <trans-unit id="d71de8152541f4a1b7fda48b87f3fe315656e14c" translate="yes" xml:space="preserve">
          <source>Application Structure</source>
          <target state="translated">Estructura de la aplicación</target>
        </trans-unit>
        <trans-unit id="2ba5dece67f8efdf3c81bb9be56daf28e8655190" translate="yes" xml:space="preserve">
          <source>Application-level state is centralized in the store.</source>
          <target state="translated">El estado del nivel de aplicación está centralizado en la tienda.</target>
        </trans-unit>
        <trans-unit id="710522a05d77912ddae3e734e0a2d1d370529418" translate="yes" xml:space="preserve">
          <source>As a reference, check out the &lt;a href=&quot;https://github.com/vuejs/vuex/tree/4.0/examples/classic/shopping-cart&quot;&gt;Shopping Cart Example&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84a169df16a0c175be12b4d7b1cd59df717591a1" translate="yes" xml:space="preserve">
          <source>As a reference, check out the &lt;a href=&quot;https://github.com/vuejs/vuex/tree/dev/examples/shopping-cart&quot;&gt;Shopping Cart Example&lt;/a&gt;.</source>
          <target state="translated">Como referencia, consulte el &lt;a href=&quot;https://github.com/vuejs/vuex/tree/dev/examples/shopping-cart&quot;&gt;ejemplo de carrito de compras&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="90a44e426a7e60755b1c84d1d390da1cb4f500d2" translate="yes" xml:space="preserve">
          <source>As long as you follow these rules, it's up to you how to structure your project. If your store file gets too big, simply start splitting the actions, mutations and getters into separate files.</source>
          <target state="translated">Mientras sigas estas reglas,depende de ti cómo estructurar tu proyecto.Si tu archivo de almacenamiento se hace demasiado grande,simplemente empieza a dividir las acciones,mutaciones y getters en archivos separados.</target>
        </trans-unit>
        <trans-unit id="fc6ed90023b96fb6043edbdf30e42cf5dd8527fd" translate="yes" xml:space="preserve">
          <source>As of Vue 3.0, the getter's result is &lt;strong&gt;not cached&lt;/strong&gt; as the computed property does. This is a known issue that requires Vue 3.1 to be released. You can learn more at &lt;a href=&quot;https://github.com/vuejs/vuex/pull/1883&quot;&gt;PR #1878&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dfd062060191d75d85aa467d9473a70ac205ad2" translate="yes" xml:space="preserve">
          <source>Assuming &lt;code&gt;obj&lt;/code&gt; is a computed property that returns an Object from the store, the &lt;code&gt;v-model&lt;/code&gt; here will attempt to directly mutate &lt;code&gt;obj.message&lt;/code&gt; when the user types in the input. In strict mode, this will result in an error because the mutation is not performed inside an explicit Vuex mutation handler.</source>
          <target state="translated">Suponiendo que &lt;code&gt;obj&lt;/code&gt; es una propiedad calculada que devuelve un Objeto de la tienda, el &lt;code&gt;v-model&lt;/code&gt; aqu&amp;iacute; intentar&amp;aacute; mutar directamente &lt;code&gt;obj.message&lt;/code&gt; cuando el usuario ingrese la entrada. En modo estricto, esto resultar&amp;aacute; en un error porque la mutaci&amp;oacute;n no se realiza dentro de un manejador de mutaci&amp;oacute;n Vuex expl&amp;iacute;cito.</target>
        </trans-unit>
        <trans-unit id="6d84d9b230182d02f5132507784662fee81bd183" translate="yes" xml:space="preserve">
          <source>Asynchronicity combined with state mutation can make your program very hard to reason about. For example, when you call two methods both with async callbacks that mutate the state, how do you know when they are called and which callback was called first? This is exactly why we want to separate the two concepts. In Vuex, &lt;strong&gt;mutations are synchronous transactions&lt;/strong&gt;:</source>
          <target state="translated">La asincronicidad combinada con la mutaci&amp;oacute;n de estado puede hacer que sea muy dif&amp;iacute;cil razonar sobre su programa. Por ejemplo, cuando llama a dos m&amp;eacute;todos ambos con devoluciones de llamada as&amp;iacute;ncronas que mutan el estado, &amp;iquest;c&amp;oacute;mo sabe cu&amp;aacute;ndo se llaman y qu&amp;eacute; devoluci&amp;oacute;n de llamada se llam&amp;oacute; primero? Precisamente por eso queremos separar los dos conceptos. En Vuex, las &lt;strong&gt;mutaciones son transacciones sincr&amp;oacute;nicas&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="b626c6a5b4f21b273497b11b0696d3709db0b3b9" translate="yes" xml:space="preserve">
          <source>Asynchronous logic should be encapsulated in, and can be composed with &lt;strong&gt;actions&lt;/strong&gt;.</source>
          <target state="translated">La l&amp;oacute;gica asincr&amp;oacute;nica se debe encapsular y se puede componer con &lt;strong&gt;acciones&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b24ba5aae3b57ed131c31fce3d9e7c01ee0a8934" translate="yes" xml:space="preserve">
          <source>At the center of every Vuex application is the &lt;strong&gt;store&lt;/strong&gt;. A &quot;store&quot; is basically a container that holds your application &lt;strong&gt;state&lt;/strong&gt;. There are two things that make a Vuex store different from a plain global object:</source>
          <target state="translated">En el centro de cada aplicaci&amp;oacute;n de Vuex est&amp;aacute; la &lt;strong&gt;tienda&lt;/strong&gt; . Una &quot;tienda&quot; es b&amp;aacute;sicamente un contenedor que contiene el &lt;strong&gt;estado de&lt;/strong&gt; su aplicaci&amp;oacute;n . Hay dos cosas que hacen que una tienda Vuex sea diferente de un objeto global simple:</target>
        </trans-unit>
        <trans-unit id="c7d1a78232de1c9a47af6445001c58c1d1a7ff3f" translate="yes" xml:space="preserve">
          <source>Binding Helpers with Namespace</source>
          <target state="translated">Vinculando a los ayudantes con el espacio de nombres</target>
        </trans-unit>
        <trans-unit id="8f6f50fe6a684e36f2680d1b1f0d995148104f1b" translate="yes" xml:space="preserve">
          <source>Breaking Changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b82d0b3ff29a71b23bd07d252bf2496be796144" translate="yes" xml:space="preserve">
          <source>Built-in Logger Plugin</source>
          <target state="translated">Plugin de registro incorporado</target>
        </trans-unit>
        <trans-unit id="308a059e768af3165c20d5c89a88a895db34b5d3" translate="yes" xml:space="preserve">
          <source>Bundles are now aligned with Vue 3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b63c58271c9e6140433eb13c24cac57c216ef45" translate="yes" xml:space="preserve">
          <source>By committing mutations, a plugin can be used to sync a data source to the store. For example, to sync a websocket data source to the store (this is just a contrived example, in reality the &lt;code&gt;createWebSocketPlugin&lt;/code&gt; function can take some additional options for more complex tasks):</source>
          <target state="translated">Al cometer mutaciones, se puede utilizar un complemento para sincronizar una fuente de datos con la tienda. Por ejemplo, para sincronizar una fuente de datos de websocket con la tienda (esto es solo un ejemplo artificial, en realidad, la funci&amp;oacute;n &lt;code&gt;createWebSocketPlugin&lt;/code&gt; puede tomar algunas opciones adicionales para tareas m&amp;aacute;s complejas):</target>
        </trans-unit>
        <trans-unit id="54e6c17c9d96ae95deebc44ddbbdf708643bcdb6" translate="yes" xml:space="preserve">
          <source>By default, actions and mutations are still registered under the &lt;strong&gt;global namespace&lt;/strong&gt; - this allows multiple modules to react to the same action/mutation type. Getters are also registered in the global namespace by default. However, this currently has no functional purpose (it's as is to avoid breaking changes). You must be careful not to define two getters with the same name in different, non-namespaced modules, resulting in an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6129d443ac8169bdc5fb7a33f1a6e3a49e6acbc" translate="yes" xml:space="preserve">
          <source>By default, actions, mutations and getters inside modules are still registered under the &lt;strong&gt;global namespace&lt;/strong&gt; - this allows multiple modules to react to the same mutation/action type.</source>
          <target state="translated">De forma predeterminada, las acciones, mutaciones y captadores dentro de los m&amp;oacute;dulos a&amp;uacute;n se registran en el &lt;strong&gt;espacio de nombres global&lt;/strong&gt; , lo que permite que varios m&amp;oacute;dulos reaccionen al mismo tipo de mutaci&amp;oacute;n / acci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e5c047ce83c6997dc7276f84aba1f5edb7e54735" translate="yes" xml:space="preserve">
          <source>By default, new handler is added to the end of the chain, so it will be executed after other handlers that were added before. This can be overridden by adding &lt;code&gt;prepend: true&lt;/code&gt; to &lt;code&gt;options&lt;/code&gt;, which will add the handler to the beginning of the chain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51ce5306c9b50098f499e2c37705e5ca375897a5" translate="yes" xml:space="preserve">
          <source>By defining and separating the concepts involved in state management and enforcing rules that maintain independence between views and states, we give our code more structure and maintainability.</source>
          <target state="translated">Al definir y separar los conceptos involucrados en la administración del estado y hacer cumplir las reglas que mantienen la independencia entre los puntos de vista y los estados,le damos a nuestro código más estructura y mantenimiento.</target>
        </trans-unit>
        <trans-unit id="5f057ce6f76c7748c97610c88355154f282ad2c0" translate="yes" xml:space="preserve">
          <source>By providing the &lt;code&gt;store&lt;/code&gt; option to the root instance, the store will be injected into all child components of the root and will be available on them as &lt;code&gt;this.$store&lt;/code&gt;. Let's update our &lt;code&gt;Counter&lt;/code&gt; implementation:</source>
          <target state="translated">Al proporcionar la opci&amp;oacute;n de &lt;code&gt;store&lt;/code&gt; a la instancia ra&amp;iacute;z, la tienda se inyectar&amp;aacute; en todos los componentes secundarios de la ra&amp;iacute;z y estar&amp;aacute; disponible en ellos como &lt;code&gt;this.$store&lt;/code&gt; . Actualicemos nuestra implementaci&amp;oacute;n de &lt;code&gt;Counter&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="afbfca3e9562078c83014d5d713ed214293086dc" translate="yes" xml:space="preserve">
          <source>Caveat for Plugin Developers</source>
          <target state="translated">Advertencia para los desarrolladores de plugins</target>
        </trans-unit>
        <trans-unit id="b802f993bec634c517b9f6ea60df4c1f6d0862f1" translate="yes" xml:space="preserve">
          <source>Change the &lt;code&gt;entry&lt;/code&gt; from the webpack config above to &lt;code&gt;'mocha-loader!babel-loader!./test.js'&lt;/code&gt;.</source>
          <target state="translated">Cambie la &lt;code&gt;entry&lt;/code&gt; de la configuraci&amp;oacute;n del paquete web anterior a &lt;code&gt;'mocha-loader!babel-loader!./test.js'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad552703e8fdce0a6e99ce76eff171c7cb0b2e6e" translate="yes" xml:space="preserve">
          <source>Check if the module with the given name is already registered. &lt;a href=&quot;../guide/modules#dynamic-module-registration&quot;&gt;Details&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74a64ba9ebedb4fb168b3e805adfe8c5b4531bcc" translate="yes" xml:space="preserve">
          <source>Check out the &lt;a href=&quot;https://github.com/vuejs/vuex/tree/4.0/examples/composition&quot;&gt;Composition API example&lt;/a&gt; to see example applications utilising Vuex and Vue's Composition API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dce2cc7e2a5aca96dce40c7472c844313c6128f9" translate="yes" xml:space="preserve">
          <source>Checkout the &lt;a href=&quot;https://github.com/vuejs/vuex/tree/dev/examples/counter-hot&quot;&gt;counter-hot example&lt;/a&gt; to play with hot-reload.</source>
          <target state="translated">Mira el &lt;a href=&quot;https://github.com/vuejs/vuex/tree/dev/examples/counter-hot&quot;&gt;ejemplo de counter-hot&lt;/a&gt; para jugar con hot-reload.</target>
        </trans-unit>
        <trans-unit id="4fa10bacb249d780150d867ebb85a6f26364c8f3" translate="yes" xml:space="preserve">
          <source>Commit a mutation. &lt;code&gt;options&lt;/code&gt; can have &lt;code&gt;root: true&lt;/code&gt; that allows to commit root mutations in &lt;a href=&quot;../guide/modules#namespacing&quot;&gt;namespaced modules&lt;/a&gt;. &lt;a href=&quot;../guide/mutations&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">Comete una mutaci&amp;oacute;n. &lt;code&gt;options&lt;/code&gt; pueden tener &lt;code&gt;root: true&lt;/code&gt; que permite cometer mutaciones de ra&amp;iacute;z en &lt;a href=&quot;../guide/modules#namespacing&quot;&gt;m&amp;oacute;dulos con espacio&lt;/a&gt; de nombres . &lt;a href=&quot;../guide/mutations&quot;&gt;Detalles&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="abb9b61bf1bcc0d24bf3814462346ec637d49ab2" translate="yes" xml:space="preserve">
          <source>Commit with Payload</source>
          <target state="translated">Comprometerse con la carga útil</target>
        </trans-unit>
        <trans-unit id="ed6c4a7e621ba1c9ba60ff20a8e8dcf01877ef46" translate="yes" xml:space="preserve">
          <source>Committing Mutations Inside Plugins</source>
          <target state="translated">Cometer mutaciones dentro de los plugins</target>
        </trans-unit>
        <trans-unit id="ace0d08016e7028b4da846721e8e8ac868a1df57" translate="yes" xml:space="preserve">
          <source>Committing Mutations in Components</source>
          <target state="translated">Cometer mutaciones en los componentes</target>
        </trans-unit>
        <trans-unit id="1f6dc35fce777380808e0419957ee6d4ef776d2a" translate="yes" xml:space="preserve">
          <source>Component Binding Helpers</source>
          <target state="translated">Ayudantes de unión de componentes</target>
        </trans-unit>
        <trans-unit id="4d8cf2331522b00be9ba0f265b611e2039ac37bf" translate="yes" xml:space="preserve">
          <source>Components Can Still Have Local State</source>
          <target state="translated">Los componentes pueden tener todavía un estado local</target>
        </trans-unit>
        <trans-unit id="c21ad08c0baf7033efdd17f3b90986ad6f2a3b53" translate="yes" xml:space="preserve">
          <source>Composable Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b15cc8250e54a4e4e49adf02d259f1fa59279242" translate="yes" xml:space="preserve">
          <source>Composing Actions</source>
          <target state="translated">Composición de las acciones</target>
        </trans-unit>
        <trans-unit id="612f6427c9092a5834602047d990b4384c86915b" translate="yes" xml:space="preserve">
          <source>Composition API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ede404da36f4056ccf7af05d460f44cb9c43066f" translate="yes" xml:space="preserve">
          <source>Consult the setup in &lt;a href=&quot;https://vue-loader.vuejs.org/en/workflow/testing.html&quot;&gt;vue-loader documentation&lt;/a&gt;.</source>
          <target state="translated">Consulte la configuraci&amp;oacute;n en la &lt;a href=&quot;https://vue-loader.vuejs.org/en/workflow/testing.html&quot;&gt;documentaci&amp;oacute;n de vue-loader&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fdf30dd4ea6fdb8cb2d048ae6de2346d62859fba" translate="yes" xml:space="preserve">
          <source>Contains hard-coded prod/dev branches and the prod build is pre-minified. Use the &lt;code&gt;.prod.js&lt;/code&gt; files for production.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da10239b688b761162ce39505c1fb91b8a0f2cff" translate="yes" xml:space="preserve">
          <source>Create component computed options that return the evaluated value of a getter. &lt;a href=&quot;../guide/getters#the-mapgetters-helper&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">Cree opciones calculadas de componentes que devuelvan el valor evaluado de un captador. &lt;a href=&quot;../guide/getters#the-mapgetters-helper&quot;&gt;Detalles&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="31bb75db599ebdfdee4a1705ea2cde4fc02ae7e9" translate="yes" xml:space="preserve">
          <source>Create component computed options that return the sub tree of the Vuex store. &lt;a href=&quot;../guide/state#the-mapstate-helper&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">Cree opciones computadas de componentes que devuelvan el sub&amp;aacute;rbol de la tienda Vuex. &lt;a href=&quot;../guide/state#the-mapstate-helper&quot;&gt;Detalles&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3dbfc6c00c0be1ce1d1c67ae2ab7ad29e56233ee" translate="yes" xml:space="preserve">
          <source>Create component methods options that commit a mutation. &lt;a href=&quot;../guide/mutations#committing-mutations-in-components&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">Cree opciones de m&amp;eacute;todos de componentes que cometan una mutaci&amp;oacute;n. &lt;a href=&quot;../guide/mutations#committing-mutations-in-components&quot;&gt;Detalles&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="abafed37072bae96880b76a80729da6f20135f55" translate="yes" xml:space="preserve">
          <source>Create component methods options that dispatch an action. &lt;a href=&quot;../guide/actions#dispatching-actions-in-components&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">Cree opciones de m&amp;eacute;todos de componentes que env&amp;iacute;en una acci&amp;oacute;n. &lt;a href=&quot;../guide/actions#dispatching-actions-in-components&quot;&gt;Detalles&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9e2d6b72bf5a70877397f0095b2d65aff35b1892" translate="yes" xml:space="preserve">
          <source>Create namespaced component binding helpers. The returned object contains &lt;code&gt;mapState&lt;/code&gt;, &lt;code&gt;mapGetters&lt;/code&gt;, &lt;code&gt;mapActions&lt;/code&gt; and &lt;code&gt;mapMutations&lt;/code&gt; that are bound with the given namespace. &lt;a href=&quot;../guide/modules#binding-helpers-with-namespace&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">Cree ayudantes de enlace de componentes con espacio de nombres. El objeto devuelto contiene &lt;code&gt;mapState&lt;/code&gt; , &lt;code&gt;mapGetters&lt;/code&gt; , &lt;code&gt;mapActions&lt;/code&gt; y &lt;code&gt;mapMutations&lt;/code&gt; que est&amp;aacute;n vinculados con el espacio de nombres dado. &lt;a href=&quot;../guide/modules#binding-helpers-with-namespace&quot;&gt;Detalles&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e9ad68aa689b0ae8f0f0130cf5684aa9556b2ca9" translate="yes" xml:space="preserve">
          <source>Create the following webpack config (together with proper &lt;a href=&quot;https://babeljs.io/docs/usage/babelrc/&quot;&gt;&lt;code&gt;.babelrc&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">Cree la siguiente configuraci&amp;oacute;n de paquete web (junto con el &lt;a href=&quot;https://babeljs.io/docs/usage/babelrc/&quot;&gt; &lt;code&gt;.babelrc&lt;/code&gt; &lt;/a&gt; adecuado ):</target>
        </trans-unit>
        <trans-unit id="6d783b874c20d56d3f40a248f291e37048c0af28" translate="yes" xml:space="preserve">
          <source>Creates a new store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9105fc825a43c6d4845f7a03ee377cd299c7a10e" translate="yes" xml:space="preserve">
          <source>Creating multiple stores that use the same module (e.g. To &lt;a href=&quot;https://ssr.vuejs.org/en/structure.html#avoid-stateful-singletons&quot;&gt;avoid stateful singletons in the SSR&lt;/a&gt; when the &lt;code&gt;runInNewContext&lt;/code&gt; option is &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;'once'&lt;/code&gt;);</source>
          <target state="translated">Crear varias tiendas que utilizan el mismo m&amp;oacute;dulo (por ejemplo, para &lt;a href=&quot;https://ssr.vuejs.org/en/structure.html#avoid-stateful-singletons&quot;&gt;evitar singletons con estado en el SSR&lt;/a&gt; cuando la opci&amp;oacute;n &lt;code&gt;runInNewContext&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; o &lt;code&gt;'once'&lt;/code&gt; );</target>
        </trans-unit>
        <trans-unit id="21eac18e2c98912ec301de36518dcca3257d3520" translate="yes" xml:space="preserve">
          <source>Define the typed &lt;code&gt;InjectionKey&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc3decbb93847518f1a049dcf49d0d7c6560bcc6" translate="yes" xml:space="preserve">
          <source>Details</source>
          <target state="translated">Details</target>
        </trans-unit>
        <trans-unit id="40d9b9f619dbd27ad649a2fb2ed512704a8498dc" translate="yes" xml:space="preserve">
          <source>Dev Build</source>
          <target state="translated">Dev Build</target>
        </trans-unit>
        <trans-unit id="500633464b5e072d2c92585f64d2a894aa70607e" translate="yes" xml:space="preserve">
          <source>Development vs. Production</source>
          <target state="translated">Desarrollo vs.Producción</target>
        </trans-unit>
        <trans-unit id="3802d9202faed1ee478163e33ce9ddf939795ae9" translate="yes" xml:space="preserve">
          <source>Direct Download / CDN</source>
          <target state="translated">Descarga directa/CDN</target>
        </trans-unit>
        <trans-unit id="ea82e3864abf2011a82f27aa87646711a6dde792" translate="yes" xml:space="preserve">
          <source>Dispatch an action. &lt;code&gt;options&lt;/code&gt; can have &lt;code&gt;root: true&lt;/code&gt; that allows to dispatch root actions in &lt;a href=&quot;../guide/modules#namespacing&quot;&gt;namespaced modules&lt;/a&gt;. Returns a Promise that resolves all triggered action handlers. &lt;a href=&quot;../guide/actions&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">Env&amp;iacute;a una acci&amp;oacute;n. &lt;code&gt;options&lt;/code&gt; pueden tener &lt;code&gt;root: true&lt;/code&gt; que permite enviar acciones de root en &lt;a href=&quot;../guide/modules#namespacing&quot;&gt;m&amp;oacute;dulos con espacio&lt;/a&gt; de nombres . Devuelve una promesa que resuelve todos los controladores de acciones activados. &lt;a href=&quot;../guide/actions&quot;&gt;Detalles&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c5de1b3bf84cda5dd071c256e4397b905445d1ed" translate="yes" xml:space="preserve">
          <source>Dispatching Actions</source>
          <target state="translated">Acciones de despacho</target>
        </trans-unit>
        <trans-unit id="7bbf007bb6622957664e35e62427c33b4787bbb3" translate="yes" xml:space="preserve">
          <source>Dispatching Actions in Components</source>
          <target state="translated">Acciones de despacho en los componentes</target>
        </trans-unit>
        <trans-unit id="e84816ed7caab86d4177979788d92260896d7646" translate="yes" xml:space="preserve">
          <source>Does not ship minified builds (to be done together with the rest of the code after bundling).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18d9131cd512bae245202d7fdc5bab5cceca6887" translate="yes" xml:space="preserve">
          <source>Due to using a single state tree, all state of our application is contained inside one big object. However, as our application grows in scale, the store can get really bloated.</source>
          <target state="translated">Debido al uso de un único árbol de estados,todos los estados de nuestra aplicación están contenidos dentro de un gran objeto.Sin embargo,a medida que nuestra aplicación crece en escala,la tienda puede hincharse mucho.</target>
        </trans-unit>
        <trans-unit id="e37126c9ff488c45faa7f6c167a21e521222db0b" translate="yes" xml:space="preserve">
          <source>Due to using a single state tree, all states of our application are contained inside one big object. However, as our application grows in scale, the store can get really bloated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e38587c029f9616f99732e5fadca02a9d8f2a6d2" translate="yes" xml:space="preserve">
          <source>Dynamic Module Registration</source>
          <target state="translated">Registro del módulo dinámico</target>
        </trans-unit>
        <trans-unit id="cc0be31613baaad452c149bb9c4e8586cb8a8114" translate="yes" xml:space="preserve">
          <source>Dynamic module hot reloading</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2eff12ca8da9deedbd39f6bb9fd354742d118c9c" translate="yes" xml:space="preserve">
          <source>Dynamic module registration makes it possible for other Vue plugins to also leverage Vuex for state management by attaching a module to the application's store. For example, the &lt;a href=&quot;https://github.com/vuejs/vuex-router-sync&quot;&gt;&lt;code&gt;vuex-router-sync&lt;/code&gt;&lt;/a&gt; library integrates vue-router with vuex by managing the application's route state in a dynamically attached module.</source>
          <target state="translated">El registro din&amp;aacute;mico del m&amp;oacute;dulo hace posible que otros complementos de Vue tambi&amp;eacute;n aprovechen Vuex para la administraci&amp;oacute;n del estado al adjuntar un m&amp;oacute;dulo a la tienda de la aplicaci&amp;oacute;n. Por ejemplo, la &lt;a href=&quot;https://github.com/vuejs/vuex-router-sync&quot;&gt; &lt;code&gt;vuex-router-sync&lt;/code&gt; &lt;/a&gt; integra vue-router con vuex administrando el estado de la ruta de la aplicaci&amp;oacute;n en un m&amp;oacute;dulo conectado din&amp;aacute;micamente.</target>
        </trans-unit>
        <trans-unit id="9e3580cb8f8917bfac5059a2f1b0b379d39800d4" translate="yes" xml:space="preserve">
          <source>Each module can contain &lt;code&gt;state&lt;/code&gt; and &lt;code&gt;mutations&lt;/code&gt; similar to the root options. A module's state will be attached to the store's root state using the module's key. A module's mutations and getters will only receives the module's local state as the first argument instead of the root state, and module actions' &lt;code&gt;context.state&lt;/code&gt; will also point to the local state.</source>
          <target state="translated">Cada m&amp;oacute;dulo puede contener &lt;code&gt;state&lt;/code&gt; y &lt;code&gt;mutations&lt;/code&gt; similares a las opciones de ra&amp;iacute;z. El estado de un m&amp;oacute;dulo se adjuntar&amp;aacute; al estado ra&amp;iacute;z de la tienda mediante la clave del m&amp;oacute;dulo. Las mutaciones y captadores de un m&amp;oacute;dulo solo recibir&amp;aacute;n el estado local del m&amp;oacute;dulo como primer argumento en lugar del estado ra&amp;iacute;z, y el &lt;code&gt;context.state&lt;/code&gt; de las acciones del m&amp;oacute;dulo tambi&amp;eacute;n apuntar&amp;aacute; al estado local.</target>
        </trans-unit>
        <trans-unit id="f41155bdc10bb27f60f1da2c63993929e366cfa2" translate="yes" xml:space="preserve">
          <source>Edit this page on GitHub</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6af0b4fa90bb496d791139a634a4d2d65a25408" translate="yes" xml:space="preserve">
          <source>Example testing a getter:</source>
          <target state="translated">Ejemplo de prueba de un receptor:</target>
        </trans-unit>
        <trans-unit id="dd8e6bd0108987b857bb2a736cd9e6e1f11f7746" translate="yes" xml:space="preserve">
          <source>Example testing a mutation using Mocha + Chai (you can use any framework/assertion libraries you like):</source>
          <target state="translated">Ejemplo probando una mutación usando Mocha+Chai (puedes usar cualquier biblioteca de marcos/afirmaciones que quieras):</target>
        </trans-unit>
        <trans-unit id="4dadb731f14e104d4245f8a4e7627c9bb1d8c139" translate="yes" xml:space="preserve">
          <source>Example testing an async action:</source>
          <target state="translated">Ejemplo de prueba de una acción de sincronización:</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="cd172f61d02f40968010ccf686bd62765d497609" translate="yes" xml:space="preserve">
          <source>Exposes registered getters. Read only.</source>
          <target state="translated">Expone a los receptores registrados.Sólo lectura.</target>
        </trans-unit>
        <trans-unit id="6a0705ebf0c44ae72129e31b63faf83cc8385e86" translate="yes" xml:space="preserve">
          <source>Fetches the injected store when called inside the &lt;code&gt;setup&lt;/code&gt; hook. When using the Composition API, you can retrieve the store by calling this method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7e1190595d9109275e6d9d5c10a089a3981a13d" translate="yes" xml:space="preserve">
          <source>Finally, if we make use of &lt;a href=&quot;https://tc39.github.io/ecmascript-asyncawait/&quot;&gt;async / await&lt;/a&gt;, we can compose our actions like this:</source>
          <target state="translated">Finalmente, si hacemos uso de &lt;a href=&quot;https://tc39.github.io/ecmascript-asyncawait/&quot;&gt;async / await&lt;/a&gt; , podemos componer nuestras acciones as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="ecf5f38fd7c4dac49ef3d463f17a75ccd2d813ac" translate="yes" xml:space="preserve">
          <source>Finally, you can pass the key to the &lt;code&gt;useStore&lt;/code&gt; method to retrieve the typed store instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9fcf80576ac0f89837fff4eaee1452a5292cce8" translate="yes" xml:space="preserve">
          <source>Finally, you can pass the key to the &lt;code&gt;useStore&lt;/code&gt; method to retrieve the typed store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0760cb8d91e6272575ced160dd4e33845f64e540" translate="yes" xml:space="preserve">
          <source>First, declare the injection key using Vue's &lt;code&gt;InjectionKey&lt;/code&gt; interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="841c8a4f0fbdf7bd78d33837ca0ec3734ac74a01" translate="yes" xml:space="preserve">
          <source>Flux libraries are like glasses: you&amp;rsquo;ll know when you need them.</source>
          <target state="translated">Las bibliotecas Flux son como gafas: sabr&amp;aacute; cu&amp;aacute;ndo las necesita.</target>
        </trans-unit>
        <trans-unit id="38238c24d7f78b5d636a16e313302582a752f404" translate="yes" xml:space="preserve">
          <source>For any non-trivial app, we will likely need to leverage modules. Here's an example project structure:</source>
          <target state="translated">Para cualquier aplicación no trivial,es probable que necesitemos aprovechar los módulos.Aquí hay un ejemplo de estructura de proyecto:</target>
        </trans-unit>
        <trans-unit id="a300dd270b0c9c1a922b569511c43841912d4bc3" translate="yes" xml:space="preserve">
          <source>For direct use with &lt;code&gt;&amp;lt;script src=&quot;...&quot;&amp;gt;&lt;/code&gt; in the browser. Exposes the Vuex global.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="033826f9380de6f34a8b452670d3506eb71f91c9" translate="yes" xml:space="preserve">
          <source>For mutations and modules, you need to use the &lt;code&gt;store.hotUpdate()&lt;/code&gt; API method:</source>
          <target state="translated">Para mutaciones y m&amp;oacute;dulos, debe utilizar el m&amp;eacute;todo de API &lt;code&gt;store.hotUpdate()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="52511d0a336b3eb2bef841ae607141d7cff1fb7f" translate="yes" xml:space="preserve">
          <source>For problem one, passing props can be tedious for deeply nested components, and simply doesn't work for sibling components. For problem two, we often find ourselves resorting to solutions such as reaching for direct parent/child instance references or trying to mutate and synchronize multiple copies of the state via events. Both of these patterns are brittle and quickly lead to unmaintainable code.</source>
          <target state="translated">Para el primer problema,el paso de accesorios puede ser tedioso para los componentes profundamente anidados,y simplemente no funciona para los componentes de los hermanos.Para el problema dos,a menudo nos encontramos recurriendo a soluciones como buscar referencias directas de la instancia padre/hijo o tratar de mutar y sincronizar múltiples copias del estado a través de eventos.Ambos patrones son frágiles y conducen rápidamente a un código que no se puede mantener.</target>
        </trans-unit>
        <trans-unit id="2a82f8d5ce145c881352007d801685ce832abbc7" translate="yes" xml:space="preserve">
          <source>For use in Node.js server-side rendering with &lt;code&gt;require()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="424e49071bb58b22df700b0f0b42bc3fdfc8d652" translate="yes" xml:space="preserve">
          <source>For use with bundlers such as &lt;code&gt;webpack&lt;/code&gt;, &lt;code&gt;rollup&lt;/code&gt; and &lt;code&gt;parcel&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd780fa7ac6288608638eda9123dd968783ffa71" translate="yes" xml:space="preserve">
          <source>For use with native ES module imports (including module supporting browsers via &lt;code&gt;&amp;lt;script type=&quot;module&quot;&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bea63837c28f9e496db300536e9f97becac0fe11" translate="yes" xml:space="preserve">
          <source>Force the Vuex store into strict mode. In strict mode any mutations to Vuex state outside of mutation handlers will throw an Error.</source>
          <target state="translated">Forzar la tienda Vuex a un modo estricto.En modo estricto cualquier mutación al estado Vuex fuera de los manejadores de mutación arrojará un error.</target>
        </trans-unit>
        <trans-unit id="320e36f6db4da7afda899f2251cea1a84a74c2fd" translate="yes" xml:space="preserve">
          <source>Form Handling</source>
          <target state="translated">manejo del moho</target>
        </trans-unit>
        <trans-unit id="8f92675b7ffe5ac821405fab6ddb6dee755e7a33" translate="yes" xml:space="preserve">
          <source>Furthermore, add the below line into anywhere in your code before using Vuex:</source>
          <target state="translated">Además,agregue la siguiente línea en cualquier parte de su código antes de usar Vuex:</target>
        </trans-unit>
        <trans-unit id="e156a94f2c9e52e0ddb1f3009ed07dd2abf8f227" translate="yes" xml:space="preserve">
          <source>Furthermore, you can create namespaced helpers by using &lt;code&gt;createNamespacedHelpers&lt;/code&gt;. It returns an object having new component binding helpers that are bound with the given namespace value:</source>
          <target state="translated">Adem&amp;aacute;s, puede crear ayudantes con espacio de nombres utilizando &lt;code&gt;createNamespacedHelpers&lt;/code&gt; . Devuelve un objeto que tiene nuevos ayudantes de enlace de componentes que est&amp;aacute;n vinculados con el valor del espacio de nombres dado:</target>
        </trans-unit>
        <trans-unit id="3bbbe89e1bf4029f9a507d85d668e0d1d5478d40" translate="yes" xml:space="preserve">
          <source>Getters</source>
          <target state="translated">Getters</target>
        </trans-unit>
        <trans-unit id="a2c7b1aaac2b0cd5b5c8cf82e9116fb532a36719" translate="yes" xml:space="preserve">
          <source>Getters will also receive other getters as the 2nd argument:</source>
          <target state="translated">Los getters también recibirán otros getters como segundo argumento:</target>
        </trans-unit>
        <trans-unit id="d5976d58530e9ba51288bd1c3ba468cfba584344" translate="yes" xml:space="preserve">
          <source>Getters will receive the state as their 1st argument:</source>
          <target state="translated">Getters recibirá el estado como su primer argumento:</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">Empezando</target>
        </trans-unit>
        <trans-unit id="fca659dd312a705a6e05d1f829f26c05b73a3925" translate="yes" xml:space="preserve">
          <source>Getting Vuex State into Vue Components</source>
          <target state="translated">Llevar el estado de Vuex a los componentes del Vuex</target>
        </trans-unit>
        <trans-unit id="4277a56d46a56f9393fef01ea88a4610c015a3f2" translate="yes" xml:space="preserve">
          <source>Global build is built as IIFE, and not UMD, and is only meant for direct use with &lt;code&gt;&amp;lt;script src=&quot;...&quot;&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="722346bbd4db03c1c92c2a13e486f0e957996d98" translate="yes" xml:space="preserve">
          <source>Go to &lt;code&gt;localhost:8080/webpack-dev-server/test-bundle&lt;/code&gt;.</source>
          <target state="translated">Vaya a &lt;code&gt;localhost:8080/webpack-dev-server/test-bundle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf073fae640ded81eeb7a4cee70faff4a623c16c" translate="yes" xml:space="preserve">
          <source>Guide</source>
          <target state="translated">Guide</target>
        </trans-unit>
        <trans-unit id="f6642ec74afc236ede9f28e965753353dfeeed2c" translate="yes" xml:space="preserve">
          <source>Having to import &lt;code&gt;InjectionKey&lt;/code&gt; and passing it to &lt;code&gt;useStore&lt;/code&gt; everywhere it's used can quickly become a repetitive task. To simplify matters, you can define your own composable function to retrieve a typed store:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45a02043733710be9556d86b3bc87f17a5cbb0c2" translate="yes" xml:space="preserve">
          <source>Here's an example of the &lt;a href=&quot;https://jsfiddle.net/n9jmu5v7/1269/&quot;&gt;most basic Vuex counter app&lt;/a&gt;.</source>
          <target state="translated">Aqu&amp;iacute; &lt;a href=&quot;https://jsfiddle.net/n9jmu5v7/1269/&quot;&gt;tienes&lt;/a&gt; un ejemplo de la aplicaci&amp;oacute;n de contador Vuex m&amp;aacute;s b&amp;aacute;sica .</target>
        </trans-unit>
        <trans-unit id="7e74485fd2af89802a7ce36b6ae42c0bfcc32ed2" translate="yes" xml:space="preserve">
          <source>Hot Reloading</source>
          <target state="translated">Recarga en caliente</target>
        </trans-unit>
        <trans-unit id="c75202151698b65793216f709dd23fa91c67ca82" translate="yes" xml:space="preserve">
          <source>Hot swap new actions and mutations. &lt;a href=&quot;../guide/hot-reload&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">Intercambia en caliente nuevas acciones y mutaciones. &lt;a href=&quot;../guide/hot-reload&quot;&gt;Detalles&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="adbb8bac10b93929c10b60c23f56b5f8139a3463" translate="yes" xml:space="preserve">
          <source>However, if you're writing your Vue components in TypeScript, there're a few steps to follow that require for you to correctly provide typings for a store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a9fe831345a6e109e78580913b99472521a13a7" translate="yes" xml:space="preserve">
          <source>However, the simplicity quickly breaks down when we have &lt;strong&gt;multiple components that share a common state&lt;/strong&gt;:</source>
          <target state="translated">Sin embargo, la simplicidad se rompe r&amp;aacute;pidamente cuando tenemos &lt;strong&gt;varios componentes que comparten un estado com&amp;uacute;n&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="c5371d6ce87417e1b9eefdc865251be6386c405f" translate="yes" xml:space="preserve">
          <source>However, this pattern causes the component to rely on the global store singleton. When using a module system, it requires importing the store in every component that uses store state, and also requires mocking when testing the component.</source>
          <target state="translated">Sin embargo,este patrón hace que el componente dependa de la tienda global singleton.Cuando se utiliza un sistema de módulos,es necesario importar el almacén en cada componente que utiliza el estado de almacén,y también es necesario burlarse cuando se prueba el componente.</target>
        </trans-unit>
        <trans-unit id="b36b5bee1a64a661bc0d45de384b9124cbd72bfe" translate="yes" xml:space="preserve">
          <source>If more than one component needs to make use of this, we have to either duplicate the function, or extract it into a shared helper and import it in multiple places - both are less than ideal.</source>
          <target state="translated">Si más de un componente necesita hacer uso de esto,tenemos que o bien duplicar la función,o bien extraerla en un ayudante compartido e importarla en múltiples lugares-ambos son menos que ideales.</target>
        </trans-unit>
        <trans-unit id="bcd403966a8c64a6cc2f12e14145c0930fd23c8f" translate="yes" xml:space="preserve">
          <source>If we use a plain object to declare the state of the module, then that state object will be shared by reference and cause cross store/module state pollution when it's mutated.</source>
          <target state="translated">Si usamos un objeto simple para declarar el estado del módulo,entonces ese objeto de estado será compartido por referencia y causará una contaminación cruzada del estado del almacén/módulo cuando sea mutado.</target>
        </trans-unit>
        <trans-unit id="b7ec52a51a8cf587b9d439ecdf520d3332d63b46" translate="yes" xml:space="preserve">
          <source>If you are using &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools&lt;/a&gt; you probably don't need this.</source>
          <target state="translated">Si est&amp;aacute; utilizando &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools&lt;/a&gt; , probablemente no lo necesite.</target>
        </trans-unit>
        <trans-unit id="cee9eac37fcab09966f32a737634f82881a4edd4" translate="yes" xml:space="preserve">
          <source>If you have spies available in your testing environment (for example via &lt;a href=&quot;http://sinonjs.org/&quot;&gt;Sinon.JS&lt;/a&gt;), you can use them instead of the &lt;code&gt;testAction&lt;/code&gt; helper:</source>
          <target state="translated">Si tiene esp&amp;iacute;as disponibles en su entorno de prueba (por ejemplo, a trav&amp;eacute;s de &lt;a href=&quot;http://sinonjs.org/&quot;&gt;Sinon.JS&lt;/a&gt; ), puede usarlos en lugar del ayudante &lt;code&gt;testAction&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="99253187df56aff1e087c7f8349702f7e584c5c0" translate="yes" xml:space="preserve">
          <source>If you pass a function that returns an object, the returned object is used as the root state. This is useful when you want to reuse the state object especially for module reuse. &lt;a href=&quot;../guide/modules#module-reuse&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">Si pasa una funci&amp;oacute;n que devuelve un objeto, el objeto devuelto se utiliza como estado ra&amp;iacute;z. Esto es &amp;uacute;til cuando desea reutilizar el objeto de estado, especialmente para la reutilizaci&amp;oacute;n de m&amp;oacute;dulos. &lt;a href=&quot;../guide/modules#module-reuse&quot;&gt;Detalles&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="09433d887f39cc66b122d2113ece04bd4c9edb90" translate="yes" xml:space="preserve">
          <source>If you prefer using a package manager such as NPM or Yarn, install it with the following commands:</source>
          <target state="translated">Si prefieres usar un gestor de paquetes como NPM o Yarn,instálalo con los siguientes comandos:</target>
        </trans-unit>
        <trans-unit id="c818e621900aa5c6ea1f6dea69d53344a7ed6a02" translate="yes" xml:space="preserve">
          <source>If you use modules exclusively, you can use &lt;code&gt;require.context&lt;/code&gt; to load and hot reload all modules dynamically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3c23688fd4c0302fe8a3ccf68a85702b829cacd" translate="yes" xml:space="preserve">
          <source>If you want to learn Vuex in an interactive way you can check out this &lt;a href=&quot;https://scrimba.com/g/gvuex&quot;&gt;Vuex course on Scrimba&lt;/a&gt;, which gives you a mix of screencast and code playground that you can pause and play around with anytime.</source>
          <target state="translated">Si desea aprender Vuex de una manera interactiva, puede consultar este &lt;a href=&quot;https://scrimba.com/g/gvuex&quot;&gt;curso de Vuex en Scrimba&lt;/a&gt; , que le brinda una combinaci&amp;oacute;n de screencast y juegos de c&amp;oacute;digo que puede pausar y jugar en cualquier momento.</target>
        </trans-unit>
        <trans-unit id="f3eb7c190d4d6d7796c724c80957f823f5be66cc" translate="yes" xml:space="preserve">
          <source>If you want to map a getter to a different name, use an object:</source>
          <target state="translated">Si quieres mapear un getter a un nombre diferente,usa un objeto:</target>
        </trans-unit>
        <trans-unit id="20e00848ec8ade0a6824f9de7344231d1bfc9ba4" translate="yes" xml:space="preserve">
          <source>If you want to register global actions in namespaced modules, you can mark it with &lt;code&gt;root: true&lt;/code&gt; and place the action definition to function &lt;code&gt;handler&lt;/code&gt;. For example:</source>
          <target state="translated">Si desea registrar acciones globales en m&amp;oacute;dulos con espacio de nombres, puede marcarlo con &lt;code&gt;root: true&lt;/code&gt; y colocar la definici&amp;oacute;n de acci&amp;oacute;n en el &lt;code&gt;handler&lt;/code&gt; funciones . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="4f4b8e63a24cc27e082d0c2aea79d7dec7762531" translate="yes" xml:space="preserve">
          <source>If you want to use global state and getters, &lt;code&gt;rootState&lt;/code&gt; and &lt;code&gt;rootGetters&lt;/code&gt; are passed as the 3rd and 4th arguments to getter functions, and also exposed as properties on the &lt;code&gt;context&lt;/code&gt; object passed to action functions.</source>
          <target state="translated">Si desea utilizar el estado global y los &lt;code&gt;rootState&lt;/code&gt; , rootState y &lt;code&gt;rootGetters&lt;/code&gt; se pasan como los argumentos tercero y cuarto a las funciones captadoras, y tambi&amp;eacute;n se exponen como propiedades en el objeto de &lt;code&gt;context&lt;/code&gt; o que se pasa a las funciones de acci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6fcf9a3ab85ce67825ec590efb360c383d7dfca6" translate="yes" xml:space="preserve">
          <source>If you want your modules to be more self-contained or reusable, you can mark it as namespaced with &lt;code&gt;namespaced: true&lt;/code&gt;. When the module is registered, all of its getters, actions and mutations will be automatically namespaced based on the path the module is registered at. For example:</source>
          <target state="translated">Si desea que sus m&amp;oacute;dulos sean m&amp;aacute;s aut&amp;oacute;nomos o reutilizables, puede marcarlos con &lt;code&gt;namespaced: true&lt;/code&gt; nombres con espacio de nombres: verdadero . Cuando se registra el m&amp;oacute;dulo, todos sus captadores, acciones y mutaciones se asignar&amp;aacute;n autom&amp;aacute;ticamente al espacio de nombres seg&amp;uacute;n la ruta en la que est&amp;aacute; registrado el m&amp;oacute;dulo. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="09a871b493d3905657b3f74ae734baad18e2aaf1" translate="yes" xml:space="preserve">
          <source>If you've never built a large-scale SPA and jump right into Vuex, it may feel verbose and daunting. That's perfectly normal - if your app is simple, you will most likely be fine without Vuex. A simple &lt;a href=&quot;https://v3.vuejs.org/guide/state-management.html#simple-state-management-from-scratch&quot;&gt;store pattern&lt;/a&gt; may be all you need. But if you are building a medium-to-large-scale SPA, chances are you have run into situations that make you think about how to better handle state outside of your Vue components, and Vuex will be the natural next step for you. There's a good quote from Dan Abramov, the author of Redux:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5c0c63467aaecb0aa7b51168b383f900b5a513b" translate="yes" xml:space="preserve">
          <source>If you've never built a large-scale SPA and jump right into Vuex, it may feel verbose and daunting. That's perfectly normal - if your app is simple, you will most likely be fine without Vuex. A simple &lt;a href=&quot;https://vuejs.org/v2/guide/state-management.html#Simple-State-Management-from-Scratch&quot;&gt;store pattern&lt;/a&gt; may be all you need. But if you are building a medium-to-large-scale SPA, chances are you have run into situations that make you think about how to better handle state outside of your Vue components, and Vuex will be the natural next step for you. There's a good quote from Dan Abramov, the author of Redux:</source>
          <target state="translated">Si nunca ha construido un SPA a gran escala y se lanza directamente a Vuex, puede sentirse detallado y abrumador. Eso es perfectamente normal: si su aplicaci&amp;oacute;n es simple, lo m&amp;aacute;s probable es que est&amp;eacute; bien sin Vuex. Un &lt;a href=&quot;https://vuejs.org/v2/guide/state-management.html#Simple-State-Management-from-Scratch&quot;&gt;patr&amp;oacute;n de tienda&lt;/a&gt; simple puede ser todo lo que necesita. Pero si est&amp;aacute; construyendo un SPA de mediana a gran escala, es probable que se haya encontrado con situaciones que lo hagan pensar en c&amp;oacute;mo manejar mejor el estado fuera de sus componentes de Vue, y Vuex ser&amp;aacute; el siguiente paso natural para usted. Hay una buena cita de Dan Abramov, el autor de Redux:</target>
        </trans-unit>
        <trans-unit id="c6537ddc12952ad16232d8a921be6b7d5a76a6d6" translate="yes" xml:space="preserve">
          <source>If your getters have complicated computation, it is worth testing them. Getters are also very straightforward to test for the same reason as mutations.</source>
          <target state="translated">Si sus captadores tienen cálculos complicados,vale la pena probarlos.Los getters también son muy sencillos de probar por la misma razón que las mutaciones.</target>
        </trans-unit>
        <trans-unit id="4de758dad2a92aec248785ac4d6dbc0ff778d9aa" translate="yes" xml:space="preserve">
          <source>If your mutations and actions are written properly, the tests should have no direct dependency on Browser APIs after proper mocking. Thus you can simply bundle the tests with webpack and run it directly in Node. Alternatively, you can use &lt;code&gt;mocha-loader&lt;/code&gt; or Karma + &lt;code&gt;karma-webpack&lt;/code&gt; to run the tests in real browsers.</source>
          <target state="translated">Si sus mutaciones y acciones est&amp;aacute;n escritas correctamente, las pruebas no deber&amp;iacute;an tener una dependencia directa de las API del navegador despu&amp;eacute;s de una simulaci&amp;oacute;n adecuada. Por lo tanto, puede simplemente agrupar las pruebas con webpack y ejecutarlo directamente en Node. Alternativamente, puede usar &lt;code&gt;mocha-loader&lt;/code&gt; o Karma + &lt;code&gt;karma-webpack&lt;/code&gt; para ejecutar las pruebas en navegadores reales.</target>
        </trans-unit>
        <trans-unit id="6ee31c41647a54af22ae141a98d0fec5c96154f7" translate="yes" xml:space="preserve">
          <source>In Vuex 3, &lt;code&gt;createLogger&lt;/code&gt; function was exported from &lt;code&gt;vuex/dist/logger&lt;/code&gt; but it's now included in the core package. The function should be imported directly from the &lt;code&gt;vuex&lt;/code&gt; package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a410e66d911dd3ae0a50e7b80b34a4ce49f0e9c" translate="yes" xml:space="preserve">
          <source>In a Vue component, you can access the store as &lt;code&gt;this.$store&lt;/code&gt;. Now we can commit a mutation using a component method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b21dc6e7af159e44f13e61d052a381cc5930fcfa" translate="yes" xml:space="preserve">
          <source>In most cases, the payload should be an object so that it can contain multiple fields, and the recorded mutation will also be more descriptive:</source>
          <target state="translated">En la mayoría de los casos,la carga útil debe ser un objeto para que pueda contener múltiples campos,y la mutación registrada también será más descriptiva:</target>
        </trans-unit>
        <trans-unit id="c8e693418938cacbff5b768a895b5e05008f1bcd" translate="yes" xml:space="preserve">
          <source>In order to access state and getters, you will want to create &lt;code&gt;computed&lt;/code&gt; references to retain reactivity. This is the equivalent of creating computed properties using the Option API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b379a9de19b6c2947713c2e819c098b0d0414341" translate="yes" xml:space="preserve">
          <source>In practice, we often use ES2015 &lt;a href=&quot;https://github.com/lukehoban/es6features#destructuring&quot;&gt;argument destructuring&lt;/a&gt; to simplify the code a bit (especially when we need to call &lt;code&gt;commit&lt;/code&gt; multiple times):</source>
          <target state="translated">En la pr&amp;aacute;ctica, a menudo usamos la desestructuraci&amp;oacute;n de &lt;a href=&quot;https://github.com/lukehoban/es6features#destructuring&quot;&gt;argumentos de&lt;/a&gt; ES2015 para simplificar un poco el c&amp;oacute;digo (especialmente cuando necesitamos llamar a &lt;code&gt;commit&lt;/code&gt; varias veces):</target>
        </trans-unit>
        <trans-unit id="3857e213dc0f7b8c7391de2df6fe7f4ad9600a0c" translate="yes" xml:space="preserve">
          <source>In strict mode, whenever Vuex state is mutated outside of mutation handlers, an error will be thrown. This ensures that all state mutations can be explicitly tracked by debugging tools.</source>
          <target state="translated">En el modo estricto,cuando el estado Vuex es mutado fuera de los controladores de la mutación,se producirá un error.Esto asegura que todas las mutaciones de estado pueden ser explícitamente rastreadas por las herramientas de depuración.</target>
        </trans-unit>
        <trans-unit id="f605f46f5b670a253f694d77a6479a46bf60c051" translate="yes" xml:space="preserve">
          <source>In such cases, you can pass the module namespace string as the first argument to the helpers so that all bindings are done using that module as the context. The above can be simplified to:</source>
          <target state="translated">En tales casos,se puede pasar la cadena de nombres del módulo como primer argumento a los ayudantes para que todos los enlaces se hagan usando ese módulo como contexto.Lo anterior puede simplificarse a:</target>
        </trans-unit>
        <trans-unit id="fb4ca597574fefd3c18365a4df91a07d3925f51b" translate="yes" xml:space="preserve">
          <source>Include &lt;code&gt;vuex&lt;/code&gt; after Vue and it will install itself automatically:</source>
          <target state="translated">Incluya &lt;code&gt;vuex&lt;/code&gt; despu&amp;eacute;s de Vue y se instalar&amp;aacute; autom&amp;aacute;ticamente:</target>
        </trans-unit>
        <trans-unit id="4edd5883cfc0f50d6093450192a5526d804c388e" translate="yes" xml:space="preserve">
          <source>Inside a module's mutations and getters, the first argument received will be &lt;strong&gt;the module's local state&lt;/strong&gt;.</source>
          <target state="translated">Dentro de las mutaciones y captadores de un m&amp;oacute;dulo, el primer argumento recibido ser&amp;aacute; &lt;strong&gt;el estado local del m&amp;oacute;dulo&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="457ba19288441fafbf211b7b6c88681a0845bc6a" translate="yes" xml:space="preserve">
          <source>Install &lt;code&gt;mocha-loader&lt;/code&gt;.</source>
          <target state="translated">Instale &lt;code&gt;mocha-loader&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="cddc92ee3266aa27b7cb36a384142725c9edaa5f" translate="yes" xml:space="preserve">
          <source>Installation process</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d0fe35d22060e945e08d2b96b5abfd85eb87e88" translate="yes" xml:space="preserve">
          <source>Instead of mutating the state, actions commit mutations.</source>
          <target state="translated">En lugar de mutar el estado,las acciones cometen mutaciones.</target>
        </trans-unit>
        <trans-unit id="fb1e51da35f8b4fc5e80bad74fa44c9f09edf0fe" translate="yes" xml:space="preserve">
          <source>It is a commonly seen pattern to use constants for mutation types in various Flux implementations. This allows the code to take advantage of tooling like linters, and putting all constants in a single file allows your collaborators to get an at-a-glance view of what mutations are possible in the entire application:</source>
          <target state="translated">Es un patrón comúnmente visto el uso de constantes para los tipos de mutación en varias implementaciones de Flux.Esto permite que el código aproveche herramientas como linters,y poner todas las constantes en un solo archivo permite a sus colaboradores obtener una visión general de qué mutaciones son posibles en toda la aplicación:</target>
        </trans-unit>
        <trans-unit id="b3f113c6b42082f72c3757fb134ac642d34ef542" translate="yes" xml:space="preserve">
          <source>It is a self-contained app with the following parts:</source>
          <target state="translated">Es una aplicación autónoma con las siguientes partes:</target>
        </trans-unit>
        <trans-unit id="3ed4288f050eb852b800df4047f36461f3b17cbb" translate="yes" xml:space="preserve">
          <source>It may be likely that you want to preserve the previous state when registering a new module, such as preserving state from a Server Side Rendered app. You can achieve this with &lt;code&gt;preserveState&lt;/code&gt; option: &lt;code&gt;store.registerModule('a', module, { preserveState: true })&lt;/code&gt;</source>
          <target state="translated">Es probable que desee conservar el estado anterior al registrar un m&amp;oacute;dulo nuevo, como conservar el estado de una aplicaci&amp;oacute;n renderizada del lado del servidor. Puede lograr esto con la opci&amp;oacute;n &lt;code&gt;preserveState&lt;/code&gt; : &lt;code&gt;store.registerModule('a', module, { preserveState: true })&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="35dface9e340cb4e3bddcda3e4f2453cf5b8832e" translate="yes" xml:space="preserve">
          <source>It's possible for a &lt;code&gt;store.dispatch&lt;/code&gt; to trigger multiple action handlers in different modules. In such a case the returned value will be a Promise that resolves when all triggered handlers have been resolved.</source>
          <target state="translated">Es posible que un &lt;code&gt;store.dispatch&lt;/code&gt; active m&amp;uacute;ltiples controladores de acciones en diferentes m&amp;oacute;dulos. En tal caso, el valor devuelto ser&amp;aacute; una Promesa que se resuelve cuando se han resuelto todos los controladores activados.</target>
        </trans-unit>
        <trans-unit id="c26d954c51975d2534551b78c8a2337962fddd24" translate="yes" xml:space="preserve">
          <source>Last Updated:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dea187f850a75f522b6507857c44f2cc66982153" translate="yes" xml:space="preserve">
          <source>Leaves prod/dev branches with &lt;code&gt;process.&lt;wbr/&gt;env.NODE_ENV&lt;/code&gt; guards (must be replaced by bundler).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fad0c3d2dd4948e1dc7eca7ef59267b9baf27c8d" translate="yes" xml:space="preserve">
          <source>Leaves prod/dev branches with &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; guards (must be replaced by bundler).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9285043eca58d77420a4ea528c9c0140b7f99e5" translate="yes" xml:space="preserve">
          <source>Let's register a simple action:</source>
          <target state="translated">Registremos una acción simple:</target>
        </trans-unit>
        <trans-unit id="e58183fe873032e36b18fd13feeb2f3de6adac51" translate="yes" xml:space="preserve">
          <source>Let's start with a simple Vue counter app:</source>
          <target state="translated">Empecemos con una simple aplicación de contador de Vue:</target>
        </trans-unit>
        <trans-unit id="c7d28df54f0ee7bb49a6c375079257b9e2ce533e" translate="yes" xml:space="preserve">
          <source>Let's tackle this step by step. First, define the key using Vue's &lt;code&gt;InjectionKey&lt;/code&gt; interface along with your own store typing definition:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">Con licencia del MIT.</target>
        </trans-unit>
        <trans-unit id="3c4e2ff1708a0052c627ff0c7963ae29daba2c37" translate="yes" xml:space="preserve">
          <source>Method-Style Access</source>
          <target state="translated">Acceso al estilo del método</target>
        </trans-unit>
        <trans-unit id="c2e90d9f7d5710359410a2feb78df1c412eb56ec" translate="yes" xml:space="preserve">
          <source>Migrating to 4.0 from 3.x</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64f4a0ce2e411202b8f65d464a7de482b8f37081" translate="yes" xml:space="preserve">
          <source>Module Local State</source>
          <target state="translated">Módulo Estado Local</target>
        </trans-unit>
        <trans-unit id="da07abb5f2f59744fb9d34a53f63697e0f2d1603" translate="yes" xml:space="preserve">
          <source>Module Reuse</source>
          <target state="translated">Reutilización del módulo</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="f4e46025da22a7ac6c15f6c0d760b1ec96373a5b" translate="yes" xml:space="preserve">
          <source>Most commonly used in plugins. &lt;a href=&quot;../guide/plugins&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">M&amp;aacute;s com&amp;uacute;nmente utilizado en complementos. &lt;a href=&quot;../guide/plugins&quot;&gt;Detalles&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="415ace164c00364e28e4d1cc0b1dea319d4e4fe4" translate="yes" xml:space="preserve">
          <source>Multiple views may depend on the same piece of state.</source>
          <target state="translated">Múltiples vistas pueden depender de la misma parte del estado.</target>
        </trans-unit>
        <trans-unit id="00a7fb731451c41a484b7591ece27f55c474ec0e" translate="yes" xml:space="preserve">
          <source>Mutations</source>
          <target state="translated">Mutations</target>
        </trans-unit>
        <trans-unit id="104200b8a17f6d972a707d856a1247d4c7c79f01" translate="yes" xml:space="preserve">
          <source>Mutations Follow Vue's Reactivity Rules</source>
          <target state="translated">Las mutaciones siguen las reglas de reactividad de Vue</target>
        </trans-unit>
        <trans-unit id="1c4ca77f8cfecf119f2abce71ca721d4bcfe55b6" translate="yes" xml:space="preserve">
          <source>Mutations Must Be Synchronous</source>
          <target state="translated">Las mutaciones deben ser sincrónicas</target>
        </trans-unit>
        <trans-unit id="654ac141ada51cc2648d26957205d691ce5cdaec" translate="yes" xml:space="preserve">
          <source>Mutations are very straightforward to test, because they are just functions that completely rely on their arguments. One trick is that if you are using ES2015 modules and put your mutations inside your &lt;code&gt;store.js&lt;/code&gt; file, in addition to the default export, you should also export the mutations as a named export:</source>
          <target state="translated">Las mutaciones son muy sencillas de probar, porque son solo funciones que dependen completamente de sus argumentos. Un truco es que si est&amp;aacute; utilizando m&amp;oacute;dulos ES2015 y coloca sus mutaciones dentro de su archivo &lt;code&gt;store.js&lt;/code&gt; , adem&amp;aacute;s de la exportaci&amp;oacute;n predeterminada, tambi&amp;eacute;n debe exportar las mutaciones como una exportaci&amp;oacute;n con nombre:</target>
        </trans-unit>
        <trans-unit id="a8ad860c15810cce0e7beac1c91da3ab2cb22c47" translate="yes" xml:space="preserve">
          <source>NOTE</source>
          <target state="translated">NOTE</target>
        </trans-unit>
        <trans-unit id="7d94ebbf07f5417771d7c7fd06f208703494bf50" translate="yes" xml:space="preserve">
          <source>NPM</source>
          <target state="translated">NPM</target>
        </trans-unit>
        <trans-unit id="f0146eaf3d75ae19152beec5a891e0df9b9d3793" translate="yes" xml:space="preserve">
          <source>Namespaced getters and actions will receive localized &lt;code&gt;getters&lt;/code&gt;, &lt;code&gt;dispatch&lt;/code&gt; and &lt;code&gt;commit&lt;/code&gt;. In other words, you can use the module assets without writing prefix in the same module. Toggling between namespaced or not does not affect the code inside the module.</source>
          <target state="translated">Los captadores y las acciones con espacio de nombres recibir&amp;aacute;n &lt;code&gt;getters&lt;/code&gt; localizados , &lt;code&gt;dispatch&lt;/code&gt; y &lt;code&gt;commit&lt;/code&gt; . En otras palabras, puede usar los activos del m&amp;oacute;dulo sin escribir el prefijo en el mismo m&amp;oacute;dulo. Alternar entre espacios de nombres o no no afecta el c&amp;oacute;digo dentro del m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="362b423baafd1e7b201b94eb4694146a945d2f27" translate="yes" xml:space="preserve">
          <source>Namespacing</source>
          <target state="translated">Namespacing</target>
        </trans-unit>
        <trans-unit id="156e3db7d7ff24a58bfd4733460906ddcf9c82d6" translate="yes" xml:space="preserve">
          <source>New &quot;useStore&quot; composition function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a71d5762c0258836841ff5df622a89af0d09ccba" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;useStore&lt;/code&gt; composition function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="025519ea3f483eb11a3c8608b8a731eee0947b1b" translate="yes" xml:space="preserve">
          <source>New Features</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4820b6a8eaff4049273790823038a2d97641ee6b" translate="yes" xml:space="preserve">
          <source>New in 2.5.0</source>
          <target state="translated">Nuevo en 2.5.0</target>
        </trans-unit>
        <trans-unit id="ee5b92286bff361e6506cbde70ab9d79b67f9e22" translate="yes" xml:space="preserve">
          <source>New in 3.1.0</source>
          <target state="translated">Nuevo en 3.1.0</target>
        </trans-unit>
        <trans-unit id="f603edae1429a95385a9e96dce7eed555212b05b" translate="yes" xml:space="preserve">
          <source>Next, pass the defined injection key when installing the store to the Vue app:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94cbec932a3607b921845482469e8e3e43a2cef8" translate="yes" xml:space="preserve">
          <source>Next, we will discuss each core concept in much finer details, starting with &lt;a href=&quot;state&quot;&gt;State&lt;/a&gt;.</source>
          <target state="translated">A continuaci&amp;oacute;n, discutiremos cada concepto central en detalles mucho m&amp;aacute;s finos, comenzando con &lt;a href=&quot;state&quot;&gt;Estado&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8a19151987fbe02547ee0f70513d32dd282c4ac0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;mapState&lt;/code&gt; returns an object. How do we use it in combination with other local computed properties? Normally, we'd have to use a utility to merge multiple objects into one so that we can pass the final object to &lt;code&gt;computed&lt;/code&gt;. However with the &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;object spread operator&lt;/a&gt; (which is a stage-4 ECMAScript proposal), we can greatly simplify the syntax:</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;mapState&lt;/code&gt; devuelve un objeto. &amp;iquest;C&amp;oacute;mo lo usamos en combinaci&amp;oacute;n con otras propiedades calculadas localmente? Normalmente, tendr&amp;iacute;amos que usar una utilidad para fusionar varios objetos en uno para que podamos pasar el objeto final a &lt;code&gt;computed&lt;/code&gt; . Sin embargo, con el &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;operador de extensi&amp;oacute;n de objetos&lt;/a&gt; (que es una propuesta de ECMAScript de etapa 4), podemos simplificar enormemente la sintaxis:</target>
        </trans-unit>
        <trans-unit id="8fdd2db4fff8fb671f8b5b5304c69fa03718c6bb" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;mapState&lt;/code&gt; returns an object. How do we use it in combination with other local computed properties? Normally, we'd have to use a utility to merge multiple objects into one so that we can pass the final object to &lt;code&gt;computed&lt;/code&gt;. However with the &lt;a href=&quot;https://github.com/tc39/proposal-object-rest-spread&quot;&gt;object spread operator&lt;/a&gt;, we can greatly simplify the syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="383f040aea7fdc521540d519355364a1d7f735a8" translate="yes" xml:space="preserve">
          <source>Note that getters accessed as properties are cached as part of Vue's reactivity system.</source>
          <target state="translated">Note que los getters a los que se accede como propiedades se almacenan en caché como parte del sistema de reactividad de Vue.</target>
        </trans-unit>
        <trans-unit id="ee0bf46abe7c412da05c2c7e1afee2ada212118c" translate="yes" xml:space="preserve">
          <source>Note that getters accessed via methods will run each time you call them, and the result is not cached.</source>
          <target state="translated">Tenga en cuenta que los getters a los que se accede a través de los métodos se ejecutarán cada vez que los llame,y el resultado no se almacena en caché.</target>
        </trans-unit>
        <trans-unit id="d5717e27426eb7a2d5c1747c90156711ec9ef26a" translate="yes" xml:space="preserve">
          <source>Note that you may check if the module is already registered to the store or not via &lt;code&gt;store.hasModule(moduleName)&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93fca34876045ca8e7715e28c6d04cb4373157ba" translate="yes" xml:space="preserve">
          <source>Note the logger plugin takes state snapshots, so use it only during development.</source>
          <target state="translated">El plugin de registro toma instantáneas de estado,así que úsalo sólo durante el desarrollo.</target>
        </trans-unit>
        <trans-unit id="11f45dfd75b6d4fbcfd55b7ac788bd4b130224b1" translate="yes" xml:space="preserve">
          <source>Note we are performing a flow of asynchronous operations, and recording the side effects (state mutations) of the action by committing them.</source>
          <target state="translated">Obsérvese que estamos realizando un flujo de operaciones asíncronas,y registrando los efectos secundarios (mutaciones de estado)de la acción al cometerlas.</target>
        </trans-unit>
        <trans-unit id="ab293ff1751dac6b50aacc1c946da9ff9bd12a5a" translate="yes" xml:space="preserve">
          <source>Now imagine we are debugging the app and looking at the devtool's mutation logs. For every mutation logged, the devtool will need to capture a &quot;before&quot; and &quot;after&quot; snapshots of the state. However, the asynchronous callback inside the example mutation above makes that impossible: the callback is not called yet when the mutation is committed, and there's no way for the devtool to know when the callback will actually be called - any state mutation performed in the callback is essentially un-trackable!</source>
          <target state="translated">Ahora imagina que estamos depurando la aplicación y mirando los registros de mutaciones de la herramienta.Por cada mutación registrada,la herramienta necesitará capturar un &quot;antes&quot; y un &quot;después&quot; del estado.Sin embargo,la llamada asíncrona dentro de la mutación de ejemplo anterior hace que esto sea imposible:la llamada no se llama todavía cuando se comete la mutación,y no hay forma de que la herramienta sepa cuándo se llamará realmente la llamada:¡cualquier mutación de estado realizada en la llamada es esencialmente imposible de rastrear!</target>
        </trans-unit>
        <trans-unit id="93b9e7a0a6529c120d308e3a9afc60556aa4685a" translate="yes" xml:space="preserve">
          <source>Now you can do:</source>
          <target state="translated">Ahora puedes hacerlo:</target>
        </trans-unit>
        <trans-unit id="a5bc280bd65d97298b6a537bbd98ca0fca61ada2" translate="yes" xml:space="preserve">
          <source>Now, by importing your own composable function, you can retrieve the typed store &lt;strong&gt;without&lt;/strong&gt; having to provide the injection key and it's typing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cab930ccc32a830cf1b2daffb710e302771e1ccf" translate="yes" xml:space="preserve">
          <source>Now, you can access the state object as &lt;code&gt;store.state&lt;/code&gt;, and trigger a state change with the &lt;code&gt;store.commit&lt;/code&gt; method:</source>
          <target state="translated">Ahora, puede acceder al objeto de estado como &lt;code&gt;store.state&lt;/code&gt; y activar un cambio de estado con el m&amp;eacute;todo &lt;code&gt;store.commit&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ace4a2b4fe085d950494ad9721a19fbdb4b869ed" translate="yes" xml:space="preserve">
          <source>Object Spread Operator</source>
          <target state="translated">Operador de difusión de objetos</target>
        </trans-unit>
        <trans-unit id="4e55a0d58d5e1d3dd2c370978eeab3967aadea55" translate="yes" xml:space="preserve">
          <source>Object-Style Commit</source>
          <target state="translated">Compromiso de estilo de objeto</target>
        </trans-unit>
        <trans-unit id="af6888b6f45f7db98c78eb748575fc0a520bf758" translate="yes" xml:space="preserve">
          <source>On to Actions</source>
          <target state="translated">A las acciones</target>
        </trans-unit>
        <trans-unit id="be28144bfe8196f5de9245ef24f38b80c1795631" translate="yes" xml:space="preserve">
          <source>One important rule to remember is that &lt;strong&gt;mutation handler functions must be synchronous&lt;/strong&gt;. Why? Consider the following example:</source>
          <target state="translated">Una regla importante para recordar es que las &lt;strong&gt;funciones del manejador de mutaciones deben ser sincr&amp;oacute;nicas&lt;/strong&gt; . &amp;iquest;Por qu&amp;eacute;? Considere el siguiente ejemplo:</target>
        </trans-unit>
        <trans-unit id="0a517ce6f632f361387aae43f330fac6b9ff2fb5" translate="yes" xml:space="preserve">
          <source>Pass the typed &lt;code&gt;InjectionKey&lt;/code&gt; to the &lt;code&gt;useStore&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2228a15359ec1787af59c5da6ce5e371da06846" translate="yes" xml:space="preserve">
          <source>Place the following code in your project to allow &lt;code&gt;this.$store&lt;/code&gt; to be typed correctly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab2e26dd8b8868a3969cb3321e0c983c0d9d67d4" translate="yes" xml:space="preserve">
          <source>Plugins</source>
          <target state="translated">Plugins</target>
        </trans-unit>
        <trans-unit id="22f632f9f25219b387e3b3f91a16935bbf27d29a" translate="yes" xml:space="preserve">
          <source>Plugins are not allowed to directly mutate state - similar to your components, they can only trigger changes by committing mutations.</source>
          <target state="translated">A los plugins no se les permite mutar directamente el estado-similar a sus componentes,sólo pueden desencadenar cambios al cometer mutaciones.</target>
        </trans-unit>
        <trans-unit id="184f9c5d6a512ea46935550bc3405af620cc2aa9" translate="yes" xml:space="preserve">
          <source>Prefer initializing your store's initial state with all desired fields upfront.</source>
          <target state="translated">Prefiero inicializar el estado inicial de su tienda con todos los campos deseados por adelantado.</target>
        </trans-unit>
        <trans-unit id="e7e706a353f493baa85f48336645f1af9ce6a62b" translate="yes" xml:space="preserve">
          <source>Preserving state</source>
          <target state="translated">Estado de conservación</target>
        </trans-unit>
        <trans-unit id="fe5671922bc7f67cfabfa60ab97a9542ac21f39f" translate="yes" xml:space="preserve">
          <source>Promise</source>
          <target state="translated">Promise</target>
        </trans-unit>
        <trans-unit id="8dc7952272c26facc9a2c5604edbd77344108471" translate="yes" xml:space="preserve">
          <source>Property-Style Access</source>
          <target state="translated">Acceso al estilo de la propiedad</target>
        </trans-unit>
        <trans-unit id="f3080b3597ce40f7b3c7da14211527d0235807a1" translate="yes" xml:space="preserve">
          <source>Provide the typed &lt;code&gt;InjectionKey&lt;/code&gt; when installing a store to the Vue app.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fffd76e54cabe19ee1677cc2622cd23e6e275e9" translate="yes" xml:space="preserve">
          <source>Reactively watch &lt;code&gt;fn&lt;/code&gt;'s return value, and call the callback when the value changes. &lt;code&gt;fn&lt;/code&gt; receives the store's state as the first argument, and getters as the second argument. Accepts an optional options object that takes the same options as &lt;a href=&quot;https://vuejs.org/v2/api/#vm-watch&quot;&gt;Vue's &lt;code&gt;vm.$watch&lt;/code&gt; method&lt;/a&gt;.</source>
          <target state="translated">Observe de forma reactiva el valor de retorno de &lt;code&gt;fn&lt;/code&gt; y llame a la devoluci&amp;oacute;n de llamada cuando cambie el valor. &lt;code&gt;fn&lt;/code&gt; recibe el estado de la tienda como primer argumento y getters como segundo argumento. Acepta un objeto de opciones opcionales que toma las mismas opciones que &lt;a href=&quot;https://vuejs.org/v2/api/#vm-watch&quot;&gt;el m&amp;eacute;todo &lt;code&gt;vm.$watch&lt;/code&gt; de Vue&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="75e4ab33b7b5dc7455e9eadf2e7119121508fb6e" translate="yes" xml:space="preserve">
          <source>Register Global Action in Namespaced Modules</source>
          <target state="translated">Registrar la acción mundial en módulos con nombres</target>
        </trans-unit>
        <trans-unit id="de6210ec05f575ccd3825af5410dca87db3c1a7e" translate="yes" xml:space="preserve">
          <source>Register a dynamic module. &lt;a href=&quot;../guide/modules#dynamic-module-registration&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">Registra un m&amp;oacute;dulo din&amp;aacute;mico. &lt;a href=&quot;../guide/modules#dynamic-module-registration&quot;&gt;Detalles&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ad2bb0219d3b7cad70e9aeaf8b370461d8c5f459" translate="yes" xml:space="preserve">
          <source>Register actions on the store. The handler function receives a &lt;code&gt;context&lt;/code&gt; object that exposes the following properties:</source>
          <target state="translated">Registra acciones en la tienda. La funci&amp;oacute;n de controlador recibe un objeto de &lt;code&gt;context&lt;/code&gt; o que expone las siguientes propiedades:</target>
        </trans-unit>
        <trans-unit id="0c3c4cb0360b08ab239d9d6ce7ef5979c7bd75c9" translate="yes" xml:space="preserve">
          <source>Register getters on the store. The getter function receives the following arguments:</source>
          <target state="translated">Registra a los compradores en la tienda.La función de getter recibe los siguientes argumentos:</target>
        </trans-unit>
        <trans-unit id="b656445541eada906150dd7ca28e7277b3f8ac2d" translate="yes" xml:space="preserve">
          <source>Register mutations on the store. The handler function always receives &lt;code&gt;state&lt;/code&gt; as the first argument (will be module local state if defined in a module), and receives a second &lt;code&gt;payload&lt;/code&gt; argument if there is one.</source>
          <target state="translated">Registra mutaciones en la tienda. La funci&amp;oacute;n del controlador siempre recibe el &lt;code&gt;state&lt;/code&gt; como primer argumento (ser&amp;aacute; el estado local del m&amp;oacute;dulo si se define en un m&amp;oacute;dulo) y recibe un segundo argumento de &lt;code&gt;payload&lt;/code&gt; si lo hay.</target>
        </trans-unit>
        <trans-unit id="17a6292e850aa27ddd8a69f3670d7bf427ff4201" translate="yes" xml:space="preserve">
          <source>Register the same module multiple times in the same store.</source>
          <target state="translated">Registra el mismo módulo varias veces en la misma tienda.</target>
        </trans-unit>
        <trans-unit id="9adccc4f4e3ee229d76671c447375a4b4430cf1a" translate="yes" xml:space="preserve">
          <source>Registered getters are exposed on &lt;code&gt;store.getters&lt;/code&gt;.</source>
          <target state="translated">Los captadores registrados est&amp;aacute;n expuestos en &lt;code&gt;store.getters&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e74661ca249919f9eff75810910ad50f600b9f27" translate="yes" xml:space="preserve">
          <source>Replace that Object with a fresh one. For example, using the &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;object spread syntax&lt;/a&gt; we can write it like this:</source>
          <target state="translated">Reemplaza ese Objeto por uno nuevo. Por ejemplo, usando la &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;sintaxis de extensi&amp;oacute;n de objetos&lt;/a&gt; podemos escribirlo as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="cfc7d1d9a1abac11e07fd8298b3033a2dd367be4" translate="yes" xml:space="preserve">
          <source>Replace the store's root state. Use this only for state hydration / time-travel purposes.</source>
          <target state="translated">Reemplazar el estado de raíz de la tienda.Utilícelo sólo para la hidratación del estado/viaje en el tiempo.</target>
        </trans-unit>
        <trans-unit id="7ec9eede60ad8e8637510a86e616531533ada02f" translate="yes" xml:space="preserve">
          <source>Running Tests</source>
          <target state="translated">Pruebas de funcionamiento</target>
        </trans-unit>
        <trans-unit id="11b20f83f47c6fa0a2ecb66cf17c37a8bf3312ce" translate="yes" xml:space="preserve">
          <source>Running in Browser</source>
          <target state="translated">Corriendo en el navegador</target>
        </trans-unit>
        <trans-unit id="27b89784a5a88ae4dea9d0fe0a57d6ac83db22be" translate="yes" xml:space="preserve">
          <source>Running in Browser with Karma + karma-webpack</source>
          <target state="translated">Corriendo en el navegador con Karma+karma-webpack</target>
        </trans-unit>
        <trans-unit id="cbd1c1641d5f61fff635a6b95f6786707cdb60a6" translate="yes" xml:space="preserve">
          <source>Running in Node</source>
          <target state="translated">Corriendo en el nodo</target>
        </trans-unit>
        <trans-unit id="b7a73f532334578b3a16beb74895158fa37aca37" translate="yes" xml:space="preserve">
          <source>Similar to plugins, we can let the build tools handle that:</source>
          <target state="translated">Similar a los plugins,podemos dejar que las herramientas de construcción se encarguen de eso:</target>
        </trans-unit>
        <trans-unit id="6440404824fd3c3690de22244c1449cd72882e79" translate="yes" xml:space="preserve">
          <source>Similarly, inside module actions, &lt;code&gt;context.state&lt;/code&gt; will expose the local state, and root state will be exposed as &lt;code&gt;context.rootState&lt;/code&gt;:</source>
          <target state="translated">De manera similar, dentro de las acciones del m&amp;oacute;dulo, &lt;code&gt;context.state&lt;/code&gt; expondr&amp;aacute; el estado local y el estado ra&amp;iacute;z se expondr&amp;aacute; como &lt;code&gt;context.rootState&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ca9c5e520923e6214e6e652479441ba757527ff7" translate="yes" xml:space="preserve">
          <source>Simplifying &lt;code&gt;useStore&lt;/code&gt; usage</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="025e718449a36bec79871ddaaf94c1265848b2f1" translate="yes" xml:space="preserve">
          <source>Since 3.1.0, &lt;code&gt;subscribeAction&lt;/code&gt; can also specify whether the subscribe handler should be called &lt;em&gt;before&lt;/em&gt; or &lt;em&gt;after&lt;/em&gt; an action dispatch (the default behavior is &lt;em&gt;before&lt;/em&gt;):</source>
          <target state="translated">Desde 3.1.0, &lt;code&gt;subscribeAction&lt;/code&gt; tambi&amp;eacute;n puede especificar si se debe llamar al controlador de suscripci&amp;oacute;n &lt;em&gt;antes&lt;/em&gt; o &lt;em&gt;despu&amp;eacute;s del&lt;/em&gt; env&amp;iacute;o de una acci&amp;oacute;n (el comportamiento predeterminado es &lt;em&gt;antes&lt;/em&gt; ):</target>
        </trans-unit>
        <trans-unit id="f3fd68e0c5995c6798e0356b50e929c10917b3a4" translate="yes" xml:space="preserve">
          <source>Since a Vuex store's state is made reactive by Vue, when we mutate the state, Vue components observing the state will update automatically. This also means Vuex mutations are subject to the same reactivity caveats when working with plain Vue:</source>
          <target state="translated">Como el estado de un almacén Vuex se hace reactivo por el Vue,cuando mutamos el estado,los componentes del Vue que observan el estado se actualizan automáticamente.Esto también significa que las mutaciones del Vuex están sujetas a las mismas advertencias de reactividad cuando se trabaja con Vue simple:</target>
        </trans-unit>
        <trans-unit id="92041cc87d58be0a729eade29063235fe14b3c9c" translate="yes" xml:space="preserve">
          <source>Single State Tree</source>
          <target state="translated">Árbol de un solo estado</target>
        </trans-unit>
        <trans-unit id="5f6ffb7192daf8fe93bcac0572129c5101463336" translate="yes" xml:space="preserve">
          <source>So how do we display state inside the store in our Vue components? Since Vuex stores are reactive, the simplest way to &quot;retrieve&quot; state from it is simply returning some store state from within a &lt;a href=&quot;https://vuejs.org/guide/computed.html&quot;&gt;computed property&lt;/a&gt;:</source>
          <target state="translated">Entonces, &amp;iquest;c&amp;oacute;mo mostramos el estado dentro de la tienda en nuestros componentes de Vue? Dado que las tiendas Vuex son reactivas, la forma m&amp;aacute;s sencilla de &quot;recuperar&quot; el estado es simplemente devolver alg&amp;uacute;n estado de la tienda desde una &lt;a href=&quot;https://vuejs.org/guide/computed.html&quot;&gt;propiedad calculada&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="54d205729e342259f235761f9ebec2b225fe9abb" translate="yes" xml:space="preserve">
          <source>So why don't we extract the shared state out of the components, and manage it in a global singleton? With this, our component tree becomes a big &quot;view&quot;, and any component can access the state or trigger actions, no matter where they are in the tree!</source>
          <target state="translated">Entonces,¿por qué no extraemos el estado compartido de los componentes,y lo manejamos en un singleton global? Con esto,nuestro árbol de componentes se convierte en una gran &quot;vista&quot;,y cualquier componente puede acceder al estado o desencadenar acciones,¡sin importar en qué lugar del árbol se encuentren!</target>
        </trans-unit>
        <trans-unit id="f9f500529b87d6c41aa1c9ce2a53ab85b0f73f09" translate="yes" xml:space="preserve">
          <source>Sometimes a plugin may want to receive &quot;snapshots&quot; of the state, and also compare the post-mutation state with pre-mutation state. To achieve that, you will need to perform a deep-copy on the state object:</source>
          <target state="translated">A veces un plugin puede querer recibir &quot;instantáneas&quot; del estado,y también comparar el estado post-mutación con el estado pre-mutación.Para lograr eso,necesitará realizar una copia profunda del objeto del estado:</target>
        </trans-unit>
        <trans-unit id="ae8a5bdac2cd3270ab81602ae7fc6131bdbc35db" translate="yes" xml:space="preserve">
          <source>Sometimes we may need to compute derived state based on store state, for example filtering through a list of items and counting them:</source>
          <target state="translated">A veces es necesario calcular un estado derivado basado en el estado de la tienda,por ejemplo,filtrando a través de una lista de artículos y contándolos:</target>
        </trans-unit>
        <trans-unit id="35ae76006ac7e393b8d6ac1ac6f19a1ddefd3da2" translate="yes" xml:space="preserve">
          <source>Sometimes we may need to create multiple instances of a module, for example:</source>
          <target state="translated">A veces podemos necesitar crear múltiples instancias de un módulo,por ejemplo:</target>
        </trans-unit>
        <trans-unit id="13e4487543b6d8b06a46672cfa73442042e5fe18" translate="yes" xml:space="preserve">
          <source>Specific when defined in a module</source>
          <target state="translated">Específico cuando se define en un módulo</target>
        </trans-unit>
        <trans-unit id="aabf420288f022d987bce3f9558b9c31ba749e69" translate="yes" xml:space="preserve">
          <source>Start &lt;code&gt;webpack-dev-server&lt;/code&gt; using the config.</source>
          <target state="translated">Inicie &lt;code&gt;webpack-dev-server&lt;/code&gt; usando el archivo config.</target>
        </trans-unit>
        <trans-unit id="a72502067518684f9deeec70cf119fd26326cd33" translate="yes" xml:space="preserve">
          <source>State</source>
          <target state="translated">State</target>
        </trans-unit>
        <trans-unit id="0d8a7046c8d39d9cbd86abcdfb704b161a601f9e" translate="yes" xml:space="preserve">
          <source>Store</source>
          <target state="translated">Store</target>
        </trans-unit>
        <trans-unit id="cc646793e5a188b7dfed3c624e7ab770f511a330" translate="yes" xml:space="preserve">
          <source>Store Constructor Options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f3918202b47796e149a1504576be44f9c797b67" translate="yes" xml:space="preserve">
          <source>Store Instance Methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78960d483bd318512b15157254083d90ec1e70bb" translate="yes" xml:space="preserve">
          <source>Store Instance Properties</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e2f83ae922aab27ffe541f2875e43e6786c6d9f" translate="yes" xml:space="preserve">
          <source>StoreOptions.actions</source>
          <target state="translated">StoreOptions.actions</target>
        </trans-unit>
        <trans-unit id="7c2fb974fe6ac37076408fe6492caf0b5a840a6c" translate="yes" xml:space="preserve">
          <source>StoreOptions.devtools</source>
          <target state="translated">StoreOptions.devtools</target>
        </trans-unit>
        <trans-unit id="27bc45330a80e26b40635dc4a8b8fc17abc36877" translate="yes" xml:space="preserve">
          <source>StoreOptions.getters</source>
          <target state="translated">StoreOptions.getters</target>
        </trans-unit>
        <trans-unit id="13d89889e279cf3f4db38944cc0e1b9022ac7e5b" translate="yes" xml:space="preserve">
          <source>StoreOptions.modules</source>
          <target state="translated">StoreOptions.modules</target>
        </trans-unit>
        <trans-unit id="f35c2bfcf842e192031830ea98d80cec6e137cc2" translate="yes" xml:space="preserve">
          <source>StoreOptions.mutations</source>
          <target state="translated">StoreOptions.mutations</target>
        </trans-unit>
        <trans-unit id="9b08c590c8720def20c8cc4d49a23a43f356dabe" translate="yes" xml:space="preserve">
          <source>StoreOptions.plugins</source>
          <target state="translated">StoreOptions.plugins</target>
        </trans-unit>
        <trans-unit id="249ab110bf5289e564529ec006774bd6849ef3fa" translate="yes" xml:space="preserve">
          <source>StoreOptions.state</source>
          <target state="translated">StoreOptions.state</target>
        </trans-unit>
        <trans-unit id="057f939fdf0b4897b3dea09feff450cb50fdf3a3" translate="yes" xml:space="preserve">
          <source>StoreOptions.strict</source>
          <target state="translated">StoreOptions.strict</target>
        </trans-unit>
        <trans-unit id="7c183131363f4251f89993f5090afc10d8f0caad" translate="yes" xml:space="preserve">
          <source>Strict Mode</source>
          <target state="translated">Modo estricto</target>
        </trans-unit>
        <trans-unit id="cf363d0f2bd89c65219cc88d7452d61570ae39f4" translate="yes" xml:space="preserve">
          <source>Subscribe to store actions. The &lt;code&gt;handler&lt;/code&gt; is called for every dispatched action and receives the action descriptor and current store state as arguments. The &lt;code&gt;subscribe&lt;/code&gt; method will return an &lt;code&gt;unsubscribe&lt;/code&gt; function, which should be called when the subscription is no longer needed. For example, when unregistering a Vuex module or before destroying a Vue component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb4be8ac142fac6db9e88ed567eba8eb3225184f" translate="yes" xml:space="preserve">
          <source>Subscribe to store actions. The &lt;code&gt;handler&lt;/code&gt; is called for every dispatched action and receives the action descriptor and current store state as arguments:</source>
          <target state="translated">Suscr&amp;iacute;bete a las acciones de la tienda. Se llama al &lt;code&gt;handler&lt;/code&gt; para cada acci&amp;oacute;n enviada y recibe el descriptor de la acci&amp;oacute;n y el estado actual de la tienda como argumentos:</target>
        </trans-unit>
        <trans-unit id="120d63b068274dc6942d114c566d657d42c319d8" translate="yes" xml:space="preserve">
          <source>Subscribe to store mutations. The &lt;code&gt;handler&lt;/code&gt; is called after every mutation and receives the mutation descriptor and post-mutation state as arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf1e862a182cd71e72218de4a57d6428ba414773" translate="yes" xml:space="preserve">
          <source>Subscribe to store mutations. The &lt;code&gt;handler&lt;/code&gt; is called after every mutation and receives the mutation descriptor and post-mutation state as arguments:</source>
          <target state="translated">Suscr&amp;iacute;bete para almacenar mutaciones. El &lt;code&gt;handler&lt;/code&gt; se llama despu&amp;eacute;s de cada mutaci&amp;oacute;n y recibe el descriptor de la mutaci&amp;oacute;n y el estado posterior a la mutaci&amp;oacute;n como argumentos:</target>
        </trans-unit>
        <trans-unit id="4a190c880575f8d6d89a23b4172d04f0a311e4e6" translate="yes" xml:space="preserve">
          <source>Taking State Snapshots</source>
          <target state="translated">Tomando instantáneas del estado</target>
        </trans-unit>
        <trans-unit id="0820b32b206b7352858e8903a838ed14319acdfd" translate="yes" xml:space="preserve">
          <source>Testing</source>
          <target state="translated">Testing</target>
        </trans-unit>
        <trans-unit id="c59410bf3ca2f20fd8b0393728deccf2dc47f93a" translate="yes" xml:space="preserve">
          <source>Testing Actions</source>
          <target state="translated">Acciones de prueba</target>
        </trans-unit>
        <trans-unit id="34e8d11332da2e378672d0a243a1d14c5129d499" translate="yes" xml:space="preserve">
          <source>Testing Getters</source>
          <target state="translated">Probando los Getters</target>
        </trans-unit>
        <trans-unit id="97aad71ba2619e15a2576f93a06f963d9f14710f" translate="yes" xml:space="preserve">
          <source>Testing Mutations</source>
          <target state="translated">Pruebas de mutaciones</target>
        </trans-unit>
        <trans-unit id="9c06adb3a316efc06559622690345fb618cbaf08" translate="yes" xml:space="preserve">
          <source>The &quot;Vuex way&quot; to deal with it is binding the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;'s value and call a method on the &lt;code&gt;input&lt;/code&gt; or &lt;code&gt;change&lt;/code&gt; event:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75a5f0cdaf9e2b8de2bd8a7b0367c1b182465746" translate="yes" xml:space="preserve">
          <source>The &quot;Vuex way&quot; to deal with it is binding the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;'s value and call an action on the &lt;code&gt;input&lt;/code&gt; or &lt;code&gt;change&lt;/code&gt; event:</source>
          <target state="translated">La &quot;forma Vuex&quot; de tratarlo es vincular el valor de &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; y llamar a una acci&amp;oacute;n sobre la &lt;code&gt;input&lt;/code&gt; o el evento de &lt;code&gt;change&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7f04c49ca29bd705949d5268ee1592e8506b75b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;createLogger&lt;/code&gt; function takes a few options:</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;createLogger&lt;/code&gt; tiene algunas opciones:</target>
        </trans-unit>
        <trans-unit id="7f82a0b0f64bd49ff203795584f21da841843a62" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapGetters&lt;/code&gt; Helper</source>
          <target state="translated">El &lt;code&gt;mapGetters&lt;/code&gt; Helper</target>
        </trans-unit>
        <trans-unit id="98e2bb1175bd22373105493a5a1bff66a0f61906" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapGetters&lt;/code&gt; helper simply maps store getters to local computed properties:</source>
          <target state="translated">El ayudante &lt;code&gt;mapGetters&lt;/code&gt; simplemente asigna los captadores de la tienda a las propiedades calculadas locales:</target>
        </trans-unit>
        <trans-unit id="1c64da128ff2a5fa70401dea47d5ef1a1c1ebe06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapState&lt;/code&gt; Helper</source>
          <target state="translated">El &lt;code&gt;mapState&lt;/code&gt; Helper</target>
        </trans-unit>
        <trans-unit id="4ed23a0b581ae30af2dc1a6fb0ab9dd6e2a32e58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;subscribe&lt;/code&gt; method will return an &lt;code&gt;unsubscribe&lt;/code&gt; function, which should be called when the subscription is no longer needed. For example, you might subscribe to a Vuex Module and unsubscribe when you unregister the module. Or you might call &lt;code&gt;subscribe&lt;/code&gt; from inside a Vue Component and then destroy the component later. In these cases, you should remember to unsubscribe the subscription manually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d697d8557ee6fc852c1e6a6fc7993902dd98d06b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;subscribeAction&lt;/code&gt; method is most commonly used in plugins. &lt;a href=&quot;../guide/plugins&quot;&gt;Details&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b142924d441d0b8c053ee3a0c60776db52d2668" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;subscribeAction&lt;/code&gt; method will return an &lt;code&gt;unsubscribe&lt;/code&gt; function, which should be called when the subscription is no longer needed. For example, you might subscribe to a Vuex Module and unsubscribe when you unregister the module. Or you might call &lt;code&gt;subscribeAction&lt;/code&gt; from inside a Vue Component and then destroy the component later. In these cases, you should remember to unsubscribe the subscription manually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="536ee7b8ae92c527384d1572270e55ace22c2cdd" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;actions&lt;/strong&gt;, the possible ways the state could change in reaction to user inputs from the &lt;strong&gt;view&lt;/strong&gt;.</source>
          <target state="translated">Las &lt;strong&gt;acciones&lt;/strong&gt; , las posibles formas en que el estado podr&amp;iacute;a cambiar en reacci&amp;oacute;n a las entradas del usuario desde la &lt;strong&gt;vista&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="44d7e5a292944a9b8f0f212a5769200231c994ce" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;state&lt;/strong&gt;, the source of truth that drives our app;</source>
          <target state="translated">El &lt;strong&gt;estado&lt;/strong&gt; , la fuente de la verdad que impulsa nuestra aplicaci&amp;oacute;n;</target>
        </trans-unit>
        <trans-unit id="c7a29052af8d9c9885446ea356702c7246ba9728" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;view&lt;/strong&gt;, a declarative mapping of the &lt;strong&gt;state&lt;/strong&gt;;</source>
          <target state="translated">La &lt;strong&gt;vista&lt;/strong&gt; , un mapeo declarativo del &lt;strong&gt;estado&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="6efff60c6e384f46bfee8d934ae7afa0e3123d5a" translate="yes" xml:space="preserve">
          <source>The Simplest Store</source>
          <target state="translated">La tienda más simple</target>
        </trans-unit>
        <trans-unit id="65dc52e6fb3379afbda779041f713e48286fc0aa" translate="yes" xml:space="preserve">
          <source>The data you store in Vuex follows the same rules as the &lt;code&gt;data&lt;/code&gt; in a Vue instance, ie the state object must be plain. &lt;strong&gt;See also:&lt;/strong&gt;&lt;a href=&quot;https://v3.vuejs.org/api/options-data.html#data-2&quot;&gt;Vue#data&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bad57ff3f59fd1cdbd6a9c2eb4f3c380f8789e16" translate="yes" xml:space="preserve">
          <source>The data you store in Vuex follows the same rules as the &lt;code&gt;data&lt;/code&gt; in a Vue instance, ie the state object must be plain. &lt;strong&gt;See also:&lt;/strong&gt;&lt;a href=&quot;https://vuejs.org/v2/api/#data&quot;&gt;Vue#data&lt;/a&gt;.</source>
          <target state="translated">Los datos que almacena en Vuex siguen las mismas reglas que los &lt;code&gt;data&lt;/code&gt; en una instancia de Vue, es decir, el objeto de estado debe ser simple. &lt;strong&gt;Ver tambi&amp;eacute;n: &lt;/strong&gt;&lt;a href=&quot;https://vuejs.org/v2/api/#data&quot;&gt;Vue # data&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2b279e03c4074677e1ff56b9ff66e460fb14fa89" translate="yes" xml:space="preserve">
          <source>The first argument can optionally be a namespace string. &lt;a href=&quot;../guide/modules#binding-helpers-with-namespace&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">El primer argumento puede ser opcionalmente una cadena de espacio de nombres. &lt;a href=&quot;../guide/modules#binding-helpers-with-namespace&quot;&gt;Detalles&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3bcb1f41246213850c11b36c10d1fea79e5d77bc" translate="yes" xml:space="preserve">
          <source>The first thing to know is that &lt;code&gt;store.dispatch&lt;/code&gt; can handle Promise returned by the triggered action handler and it also returns Promise:</source>
          <target state="translated">Lo primero que debe saber es que &lt;code&gt;store.dispatch&lt;/code&gt; puede manejar Promise devuelto por el controlador de acci&amp;oacute;n desencadenado y tambi&amp;eacute;n devuelve Promise:</target>
        </trans-unit>
        <trans-unit id="dcebb29ecfe7deb0999fa8e584b599cd2758454e" translate="yes" xml:space="preserve">
          <source>The following bundles are generated to align with Vue 3 bundles:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33d9183239b6fa2ab9370efe48b42def65630f59" translate="yes" xml:space="preserve">
          <source>The getters will be exposed on the &lt;code&gt;store.getters&lt;/code&gt; object, and you access values as properties:</source>
          <target state="translated">Los captadores se expondr&amp;aacute;n en el objeto &lt;code&gt;store.getters&lt;/code&gt; y acceder&amp;aacute; a los valores como propiedades:</target>
        </trans-unit>
        <trans-unit id="188d06901f5c54b49ca05463c758d45fe516d6f3" translate="yes" xml:space="preserve">
          <source>The logger file can also be included directly via a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag, and will expose the &lt;code&gt;createVuexLogger&lt;/code&gt; function globally.</source>
          <target state="translated">El archivo del registrador tambi&amp;eacute;n se puede incluir directamente a trav&amp;eacute;s de una etiqueta &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; y expondr&amp;aacute; la funci&amp;oacute;n &lt;code&gt;createVuexLogger&lt;/code&gt; de forma global.</target>
        </trans-unit>
        <trans-unit id="7f53ab8729ac1f593a9e9d471a3a3f15e2c84ca7" translate="yes" xml:space="preserve">
          <source>The main parts we want to unit test in Vuex are mutations and actions.</source>
          <target state="translated">Las partes principales que queremos probar en Vuex son las mutaciones y las acciones.</target>
        </trans-unit>
        <trans-unit id="5f7f524307005481f2e4aca2c93d29527f99f1e2" translate="yes" xml:space="preserve">
          <source>The module's state will be exposed as &lt;code&gt;store.state.myModule&lt;/code&gt; and &lt;code&gt;store.state.nested.myModule&lt;/code&gt;.</source>
          <target state="translated">El estado del m&amp;oacute;dulo se expondr&amp;aacute; como &lt;code&gt;store.state.myModule&lt;/code&gt; y &lt;code&gt;store.state.nested.myModule&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fbed472d8720aba4f0e28e8c80ccedb98ce30b99" translate="yes" xml:space="preserve">
          <source>The only way to actually change state in a Vuex store is by committing a mutation. Vuex mutations are very similar to events: each mutation has a string &lt;strong&gt;type&lt;/strong&gt; and a &lt;strong&gt;handler&lt;/strong&gt;. The handler function is where we perform actual state modifications, and it will receive the state as the first argument:</source>
          <target state="translated">La &amp;uacute;nica forma de cambiar el estado en una tienda Vuex es realizando una mutaci&amp;oacute;n. Las mutaciones de Vuex son muy similares a los eventos: cada mutaci&amp;oacute;n tiene un &lt;strong&gt;tipo de&lt;/strong&gt; cadena y un &lt;strong&gt;controlador&lt;/strong&gt; . La funci&amp;oacute;n del controlador es donde realizamos modificaciones de estado reales, y recibir&amp;aacute; el estado como primer argumento:</target>
        </trans-unit>
        <trans-unit id="a6a0b4e8e1721ea8c21549fafae87877e2734097" translate="yes" xml:space="preserve">
          <source>The only way to mutate the state is by committing &lt;strong&gt;mutations&lt;/strong&gt;, which are synchronous transactions.</source>
          <target state="translated">La &amp;uacute;nica forma de mutar el estado es cometiendo &lt;strong&gt;mutaciones&lt;/strong&gt; , que son transacciones sincr&amp;oacute;nicas.</target>
        </trans-unit>
        <trans-unit id="dcbcf8b9a2e6b42000823c0ebf624eaedbb9d653" translate="yes" xml:space="preserve">
          <source>The plugin will be used by default. For production, you will need &lt;a href=&quot;https://webpack.js.org/plugins/define-plugin/&quot;&gt;DefinePlugin&lt;/a&gt; for webpack or &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt; for Browserify to convert the value of &lt;code&gt;process.&lt;wbr/&gt;env.NODE_ENV !== 'production'&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; for the final build.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46e235aa33469d6967a6809446c33b1593819a40" translate="yes" xml:space="preserve">
          <source>The plugin will be used by default. For production, you will need &lt;a href=&quot;https://webpack.js.org/plugins/define-plugin/&quot;&gt;DefinePlugin&lt;/a&gt; for webpack or &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt; for Browserify to convert the value of &lt;code&gt;process.env.NODE_ENV !== 'production'&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; for the final build.</source>
          <target state="translated">El complemento se utilizar&amp;aacute; de forma predeterminada. Para producci&amp;oacute;n, necesitar&amp;aacute; &lt;a href=&quot;https://webpack.js.org/plugins/define-plugin/&quot;&gt;DefinePlugin&lt;/a&gt; para webpack o &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt; para Browserify para convertir el valor de &lt;code&gt;process.env.NODE_ENV !== 'production'&lt;/code&gt; en &lt;code&gt;false&lt;/code&gt; para la compilaci&amp;oacute;n final.</target>
        </trans-unit>
        <trans-unit id="f01042e3fecd699c90149ef1ee5ae1c35a436639" translate="yes" xml:space="preserve">
          <source>The root state object for the Vuex store. &lt;a href=&quot;../guide/state&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">El objeto de estado ra&amp;iacute;z de la tienda Vuex. &lt;a href=&quot;../guide/state&quot;&gt;Detalles&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0280fc5ea89ec8da31027d69c613be9a3c9680dc" translate="yes" xml:space="preserve">
          <source>The root state. Read only.</source>
          <target state="translated">El estado de la raíz.Sólo lectura.</target>
        </trans-unit>
        <trans-unit id="2c3de3def96fcc05fedc5eb419a984266aa2428b" translate="yes" xml:space="preserve">
          <source>The second object argument's members can be a function. &lt;code&gt;function(commit: function, ...args: any[])&lt;/code&gt;</source>
          <target state="translated">Los miembros del segundo argumento de objeto pueden ser una funci&amp;oacute;n. &lt;code&gt;function(commit: function, ...args: any[])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26cd7f1bcabc21254ac5b9199d279b0ef8555a89" translate="yes" xml:space="preserve">
          <source>The second object argument's members can be a function. &lt;code&gt;function(dispatch: function, ...args: any[])&lt;/code&gt;</source>
          <target state="translated">Los miembros del segundo argumento de objeto pueden ser una funci&amp;oacute;n. &lt;code&gt;function(dispatch: function, ...args: any[])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7fdcb9da7768a075ddd1fe33f0287a0514029824" translate="yes" xml:space="preserve">
          <source>The second object argument's members can be a function. &lt;code&gt;function(state: any)&lt;/code&gt;</source>
          <target state="translated">Los miembros del segundo argumento de objeto pueden ser una funci&amp;oacute;n. &lt;code&gt;function(state: any)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="038cb5b264feb5642de1de9d5ce3def91138027b" translate="yes" xml:space="preserve">
          <source>The single state tree does not conflict with modularity - in later chapters we will discuss how to split your state and mutations into sub modules.</source>
          <target state="translated">El árbol de estado único no entra en conflicto con la modularidad-en capítulos posteriores discutiremos cómo dividir su estado y sus mutaciones en submódulos.</target>
        </trans-unit>
        <trans-unit id="b7e90dfde3eb455667e93149720981dac77b8e85" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;window.Promise&lt;/code&gt; will be available automatically.</source>
          <target state="translated">Entonces &lt;code&gt;window.Promise&lt;/code&gt; estar&amp;aacute; disponible autom&amp;aacute;ticamente.</target>
        </trans-unit>
        <trans-unit id="3b8439ab3ba17300e601fb8e0cd832d27c3875b1" translate="yes" xml:space="preserve">
          <source>Then, pass the defined key as the second argument for the &lt;code&gt;app.use&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="66d594b0f1f59f13c4f1fb32be8056b70d5a1027" translate="yes" xml:space="preserve">
          <source>This is a simple representation of the concept of &quot;one-way data flow&quot;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5b6185e9c9c13a311c71ea345f0a1bcffe543f2" translate="yes" xml:space="preserve">
          <source>This is actually the exact same problem with &lt;code&gt;data&lt;/code&gt; inside Vue components. So the solution is also the same - use a function for declaring module state (supported in 2.3.0+):</source>
          <target state="translated">Este es en realidad exactamente el mismo problema con los &lt;code&gt;data&lt;/code&gt; dentro de los componentes de Vue. Entonces, la soluci&amp;oacute;n tambi&amp;eacute;n es la misma: use una funci&amp;oacute;n para declarar el estado del m&amp;oacute;dulo (compatible con 2.3.0+):</target>
        </trans-unit>
        <trans-unit id="32e874b1aade463ecb43dfd8a24212e0197c777b" translate="yes" xml:space="preserve">
          <source>This is an simple representation of the concept of &quot;one-way data flow&quot;:</source>
          <target state="translated">Esta es una simple representación del concepto de &quot;flujo de datos unidireccional&quot;:</target>
        </trans-unit>
        <trans-unit id="4784799e1632043ab612568498af4698285efa24" translate="yes" xml:space="preserve">
          <source>This is the basic idea behind Vuex, inspired by &lt;a href=&quot;https://facebook.github.io/flux/docs/overview&quot;&gt;Flux&lt;/a&gt;, &lt;a href=&quot;http://redux.js.org/&quot;&gt;Redux&lt;/a&gt; and &lt;a href=&quot;https://guide.elm-lang.org/architecture/&quot;&gt;The Elm Architecture&lt;/a&gt;. Unlike the other patterns, Vuex is also a library implementation tailored specifically for Vue.js to take advantage of its granular reactivity system for efficient updates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4ae803eb94d79146b96a33ead3a2a7574ab90f7" translate="yes" xml:space="preserve">
          <source>This is the basic idea behind Vuex, inspired by &lt;a href=&quot;https://facebook.github.io/flux/docs/overview.html&quot;&gt;Flux&lt;/a&gt;, &lt;a href=&quot;http://redux.js.org/&quot;&gt;Redux&lt;/a&gt; and &lt;a href=&quot;https://guide.elm-lang.org/architecture/&quot;&gt;The Elm Architecture&lt;/a&gt;. Unlike the other patterns, Vuex is also a library implementation tailored specifically for Vue.js to take advantage of its granular reactivity system for efficient updates.</source>
          <target state="translated">Esta es la idea b&amp;aacute;sica detr&amp;aacute;s de Vuex, inspirada en &lt;a href=&quot;https://facebook.github.io/flux/docs/overview.html&quot;&gt;Flux&lt;/a&gt; , &lt;a href=&quot;http://redux.js.org/&quot;&gt;Redux&lt;/a&gt; y &lt;a href=&quot;https://guide.elm-lang.org/architecture/&quot;&gt;The Elm Architecture&lt;/a&gt; . A diferencia de los otros patrones, Vuex tambi&amp;eacute;n es una implementaci&amp;oacute;n de biblioteca dise&amp;ntilde;ada espec&amp;iacute;ficamente para Vue.js para aprovechar su sistema de reactividad granular para actualizaciones eficientes.</target>
        </trans-unit>
        <trans-unit id="01d82844153a1e06b9ed0ac7a7deee86d8194f29" translate="yes" xml:space="preserve">
          <source>This is the docs for Vuex 4, which works with Vue 3. If you're looking for docs for Vuex 3, which works with Vue 2, &lt;a href=&quot;https://vuex.vuejs.org/&quot;&gt;please check it out here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6765e94633afe8dfabe4c196fd106659f3711625" translate="yes" xml:space="preserve">
          <source>This may look silly at first sight: if we want to increment the count, why don't we just call &lt;code&gt;store.commit('increment')&lt;/code&gt; directly? Remember that &lt;strong&gt;mutations have to be synchronous&lt;/strong&gt;. Actions don't. We can perform &lt;strong&gt;asynchronous&lt;/strong&gt; operations inside an action:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ac43b405b6b649d36442b0894b012509c8256f1" translate="yes" xml:space="preserve">
          <source>This may look silly at first sight: if we want to increment the count, why don't we just call &lt;code&gt;store.commit('increment')&lt;/code&gt; directly? Remember that &lt;strong&gt;mutations have to be synchronous&lt;/strong&gt;? Actions don't. We can perform &lt;strong&gt;asynchronous&lt;/strong&gt; operations inside an action:</source>
          <target state="translated">Esto puede parecer tonto a primera vista: si queremos incrementar el recuento, &amp;iquest;por qu&amp;eacute; no llamamos a &lt;code&gt;store.commit('increment')&lt;/code&gt; directamente? &amp;iquest;Recuerda que las &lt;strong&gt;mutaciones tienen que ser sincr&amp;oacute;nicas&lt;/strong&gt; ? Las acciones no lo hacen. Podemos realizar operaciones &lt;strong&gt;asincr&amp;oacute;nicas&lt;/strong&gt; dentro de una acci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="0e6ac10721f7dad6b0d54424ccab8e328eca8722" translate="yes" xml:space="preserve">
          <source>To access the store within the &lt;code&gt;setup&lt;/code&gt; hook, you can call the &lt;code&gt;useStore&lt;/code&gt; function. This is the equivalent of retrieving &lt;code&gt;this.$store&lt;/code&gt; within a component using the Option API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cdbc54a1defb978e6cf0175dfb530c6313ce51a" translate="yes" xml:space="preserve">
          <source>To align with the new Vue 3 initialization process, the installation process of Vuex has changed. To create a new store, users are now encouraged to use the newly introduced createStore function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fad06b8194c84f29399e28d3869f1cd5156e9bf" translate="yes" xml:space="preserve">
          <source>To dispatch actions or commit mutations in the global namespace, pass &lt;code&gt;{ root: true }&lt;/code&gt; as the 3rd argument to &lt;code&gt;dispatch&lt;/code&gt; and &lt;code&gt;commit&lt;/code&gt;.</source>
          <target state="translated">Para enviar acciones o confirmar mutaciones en el espacio de nombres global, pase &lt;code&gt;{ root: true }&lt;/code&gt; como tercer argumento para &lt;code&gt;dispatch&lt;/code&gt; y &lt;code&gt;commit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c0e5afb99acb54f27fa2c4dc5de58b64ac70359" translate="yes" xml:space="preserve">
          <source>To do so, declare custom typings for Vue's &lt;code&gt;ComponentCustomProperties&lt;/code&gt; by adding a declaration file in your project folder:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9a17f7fd54b6a036cf2a11b136e992ee23b897e" translate="yes" xml:space="preserve">
          <source>To enable strict mode, simply pass in &lt;code&gt;strict: true&lt;/code&gt; when creating a Vuex store:</source>
          <target state="translated">Para habilitar el modo estricto, simplemente pase &lt;code&gt;strict: true&lt;/code&gt; al crear una tienda Vuex:</target>
        </trans-unit>
        <trans-unit id="b4555cdaed64feb01f23395f68a87fbe45b67dce" translate="yes" xml:space="preserve">
          <source>To handle asynchronous operations, let's introduce &lt;a href=&quot;actions&quot;&gt;Actions&lt;/a&gt;.</source>
          <target state="translated">Para manejar operaciones asincr&amp;oacute;nicas, introduzcamos &lt;a href=&quot;actions&quot;&gt;Acciones&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4195b1d72692d3750d2a410e7d9981a761f2d655" translate="yes" xml:space="preserve">
          <source>To help with that, Vuex allows us to divide our store into &lt;strong&gt;modules&lt;/strong&gt;. Each module can contain its own state, mutations, actions, getters, and even nested modules - it's fractal all the way down:</source>
          <target state="translated">Para ayudar con eso, Vuex nos permite dividir nuestra tienda en &lt;strong&gt;m&amp;oacute;dulos&lt;/strong&gt; . Cada m&amp;oacute;dulo puede contener su propio estado, mutaciones, acciones, captadores e incluso m&amp;oacute;dulos anidados; es fractal hasta el final:</target>
        </trans-unit>
        <trans-unit id="69ba8fbdd0f126138d738eba7ba3e25ab721058c" translate="yes" xml:space="preserve">
          <source>To install Vuex to a Vue instance, pass the &lt;code&gt;store&lt;/code&gt; instead of Vuex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47c12dedfc5d2ae19c1382030d2827746c9b159b" translate="yes" xml:space="preserve">
          <source>To stop subscribing, call the returned unsubscribe function.</source>
          <target state="translated">Para dejar de suscribirse,llame a la función de cancelación de suscripción devuelta.</target>
        </trans-unit>
        <trans-unit id="b38919feb133ed92197ba6b4d1ca2851ce856830" translate="yes" xml:space="preserve">
          <source>To stop watching, call the returned unwatch function.</source>
          <target state="translated">Para dejar de mirar,llama a la función de desmarque devuelto.</target>
        </trans-unit>
        <trans-unit id="d01a4f9ab1ff7fae7cb3dedf5ed58a422558aa71" translate="yes" xml:space="preserve">
          <source>Try this lesson on Scrimba</source>
          <target state="translated">Prueba esta lección en Scrimba</target>
        </trans-unit>
        <trans-unit id="812241cb367543e758bb2d6b8d6eb7df0bca334e" translate="yes" xml:space="preserve">
          <source>Turn the devtools on or off for a particular Vuex instance. For instance, passing &lt;code&gt;false&lt;/code&gt; tells the Vuex store to not subscribe to devtools plugin. Useful when you have multiple stores on a single page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb9df75c2e4aa99920a38d6895f257e82c103c0e" translate="yes" xml:space="preserve">
          <source>Turn the devtools on or off for a particular vuex instance. For instance passing false tells the Vuex store to not subscribe to devtools plugin. Useful for if you have multiple stores on a single page.</source>
          <target state="translated">Encienda o apague las devoluciones para un caso particular de vuex.Por ejemplo,si se pasa el falso indica a la tienda Vuex que no se suscriba al plugin de devtools.Es útil si tienes varios almacenes en una sola página.</target>
        </trans-unit>
        <trans-unit id="6d53cb5abedd0ebe3cd4c7395842755f71c30dbc" translate="yes" xml:space="preserve">
          <source>Two-way Computed Property</source>
          <target state="translated">Propiedad computarizada bidireccional</target>
        </trans-unit>
        <trans-unit id="aec373f2c6104f4e0717f76308cbda4cbd9ffa55" translate="yes" xml:space="preserve">
          <source>TypeScript Support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdea23efbec9c8bf6ee85ec63b78ab2e12f528cd" translate="yes" xml:space="preserve">
          <source>TypeScript support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50d095b72c23ae6ff8f64d6304776100771251da" translate="yes" xml:space="preserve">
          <source>TypeScript users can use an injection key to retrieve a typed store. In order for this to work, you must define the injection key and pass it along with the store when installing the store instance to the Vue app.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a035bd5d610b0e0f578980487f3e136c53e9a2df" translate="yes" xml:space="preserve">
          <source>Typing &lt;code&gt;$store&lt;/code&gt; Property in Vue Component</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f301538ed68fe96d60ca381f974527cc0892825" translate="yes" xml:space="preserve">
          <source>Typing &lt;code&gt;useStore&lt;/code&gt; Composition Function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88625f6fb2e47a984fc469839b246cc1bbd39a3d" translate="yes" xml:space="preserve">
          <source>Under the hood, Vuex installs the store to the Vue app using Vue's &lt;a href=&quot;https://v3.vuejs.org/api/composition-api.html#provide-inject&quot;&gt;Provide/Inject&lt;/a&gt; feature which is why the injection key is an important factor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58a34f2bdebff21a52c61f411732c8009ceffd74" translate="yes" xml:space="preserve">
          <source>Unregister a dynamic module. &lt;a href=&quot;../guide/modules#dynamic-module-registration&quot;&gt;Details&lt;/a&gt;</source>
          <target state="translated">Anular el registro de un m&amp;oacute;dulo din&amp;aacute;mico. &lt;a href=&quot;../guide/modules#dynamic-module-registration&quot;&gt;Detalles&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0e189823fb0c39c232d21cb4f56d5d5263ffa4a9" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Vue.set(obj, 'newProp', 123)&lt;/code&gt;, or</source>
          <target state="translated">Utilice &lt;code&gt;Vue.set(obj, 'newProp', 123)&lt;/code&gt; , o</target>
        </trans-unit>
        <trans-unit id="b49c80c66c6311a904333a467355c7e6bf1e59e1" translate="yes" xml:space="preserve">
          <source>Using Constants for Mutation Types</source>
          <target state="translated">Uso de constantes para los tipos de mutación</target>
        </trans-unit>
        <trans-unit id="2a3ef6422ba574dc83a7da5c0294678dde94d811" translate="yes" xml:space="preserve">
          <source>Using Vuex doesn't mean you should put &lt;strong&gt;all&lt;/strong&gt; the state in Vuex. Although putting more state into Vuex makes your state mutations more explicit and debuggable, sometimes it could also make the code more verbose and indirect. If a piece of state strictly belongs to a single component, it could be just fine leaving it as local state. You should weigh the trade-offs and make decisions that fit the development needs of your app.</source>
          <target state="translated">Usar Vuex no significa que deba poner &lt;strong&gt;todo&lt;/strong&gt; el estado en Vuex. Aunque poner m&amp;aacute;s estado en Vuex hace que las mutaciones de estado sean m&amp;aacute;s expl&amp;iacute;citas y depurables, a veces tambi&amp;eacute;n puede hacer que el c&amp;oacute;digo sea m&amp;aacute;s detallado e indirecto. Si una parte del estado pertenece estrictamente a un solo componente, podr&amp;iacute;a estar bien dejarlo como estado local. Debe sopesar las compensaciones y tomar decisiones que se ajusten a las necesidades de desarrollo de su aplicaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="0c1ee6f0263ee019fc5e3fcd7fa266eb225b6cc7" translate="yes" xml:space="preserve">
          <source>Using store state in a component simply involves returning the state within a computed property, because the store state is reactive. Triggering changes simply means committing mutations in component methods.</source>
          <target state="translated">Usar el estado de almacenamiento en un componente simplemente implica devolver el estado dentro de una propiedad calculada,porque el estado de almacenamiento es reactivo.Desencadenar los cambios simplemente significa cometer mutaciones en los métodos de los componentes.</target>
        </trans-unit>
        <trans-unit id="de0b33121be26507e3433bd94203e17aa9b5f222" translate="yes" xml:space="preserve">
          <source>Vuex</source>
          <target state="translated">Vuex</target>
        </trans-unit>
        <trans-unit id="03cbaaf12cf9de839a6ef24add75f70804c3bd36" translate="yes" xml:space="preserve">
          <source>Vuex &quot;injects&quot; the store into all child components from the root component through Vue's plugin system, and will be available on them as &lt;code&gt;this.$store&lt;/code&gt;. Let's update our &lt;code&gt;Counter&lt;/code&gt; implementation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b8cd4f61d900f72acb2af9c3655c9d0d3121feb" translate="yes" xml:space="preserve">
          <source>Vuex 4 introduces a new API to interact with the store in Composition API. You can use the &lt;code&gt;useStore&lt;/code&gt; composition function to retrieve the store within the component &lt;code&gt;setup&lt;/code&gt; hook.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa60c01f6f8d53bbb571c7cc4c0e43d605867024" translate="yes" xml:space="preserve">
          <source>Vuex 4 removes its global typings for &lt;code&gt;this.$store&lt;/code&gt; within a Vue component to solve &lt;a href=&quot;https://github.com/vuejs/vuex/issues/994&quot;&gt;issue #994&lt;/a&gt;. When used with TypeScript, you must declare your own module augmentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5043b9867f4c1f3c2a241e7e15f0309bf2b67e5" translate="yes" xml:space="preserve">
          <source>Vuex allows us to define &quot;getters&quot; in the store. You can think of them as computed properties for stores.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0d6f301a857638a6008e626f1c08e4b841279dd" translate="yes" xml:space="preserve">
          <source>Vuex allows us to define &quot;getters&quot; in the store. You can think of them as computed properties for stores. Like computed properties, a getter's result is cached based on its dependencies, and will only re-evaluate when some of its dependencies have changed.</source>
          <target state="translated">Vuex nos permite definir &quot;getters&quot; en la tienda.Puedes pensar en ellos como propiedades calculadas para las tiendas.Como las propiedades calculadas,el resultado de un getter se almacena en caché basado en sus dependencias,y sólo se reevaluará cuando algunas de sus dependencias hayan cambiado.</target>
        </trans-unit>
        <trans-unit id="0e2cd15820316b9d525f31489d6930bdf8394d91" translate="yes" xml:space="preserve">
          <source>Vuex comes with a logger plugin for common debugging usage:</source>
          <target state="translated">Vuex viene con un plugin de registro para el uso común de depuración:</target>
        </trans-unit>
        <trans-unit id="7a50b771f48dfa484820de4fbf6edb422dbc1306" translate="yes" xml:space="preserve">
          <source>Vuex doesn't provide typings for &lt;code&gt;this.$store&lt;/code&gt; property out of the box. When used with TypeScript, you must declare your own module augmentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97c7149a09097949a0cfcc2fbe94537dc69fb1ce" translate="yes" xml:space="preserve">
          <source>Vuex doesn't really restrict how you structure your code. Rather, it enforces a set of high-level principles:</source>
          <target state="translated">Vuex no restringe realmente la forma de estructurar su código.Más bien,hace cumplir un conjunto de principios de alto nivel:</target>
        </trans-unit>
        <trans-unit id="d17df34d062fc479eb107a94c88abf9ec059beae" translate="yes" xml:space="preserve">
          <source>Vuex helps us deal with shared state management with the cost of more concepts and boilerplate. It's a trade-off between short term and long term productivity.</source>
          <target state="translated">Vuex nos ayuda a lidiar con la administración compartida del estado con el costo de más conceptos y calderilla.Es una compensación entre la productividad a corto y largo plazo.</target>
        </trans-unit>
        <trans-unit id="685c1dd978a181fa797afacac4d6f9601b7d5fda" translate="yes" xml:space="preserve">
          <source>Vuex is a &lt;strong&gt;state management pattern + library&lt;/strong&gt; for Vue.js applications. It serves as a centralized store for all the components in an application, with rules ensuring that the state can only be mutated in a predictable fashion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4865c12b8c32edd994472010e09de64c7196db52" translate="yes" xml:space="preserve">
          <source>Vuex is a &lt;strong&gt;state management pattern + library&lt;/strong&gt; for Vue.js applications. It serves as a centralized store for all the components in an application, with rules ensuring that the state can only be mutated in a predictable fashion. It also integrates with Vue's official &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;devtools extension&lt;/a&gt; to provide advanced features such as zero-config time-travel debugging and state snapshot export / import.</source>
          <target state="translated">Vuex es un &lt;strong&gt;patr&amp;oacute;n de gesti&amp;oacute;n de estado + biblioteca&lt;/strong&gt; para aplicaciones Vue.js. Sirve como un almac&amp;eacute;n centralizado para todos los componentes de una aplicaci&amp;oacute;n, con reglas que garantizan que el estado solo se puede modificar de una manera predecible. Tambi&amp;eacute;n se integra con la &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;extensi&amp;oacute;n devtools&lt;/a&gt; oficial de Vue para proporcionar funciones avanzadas como depuraci&amp;oacute;n de viaje en el tiempo sin configuraci&amp;oacute;n y exportaci&amp;oacute;n / importaci&amp;oacute;n de instant&amp;aacute;neas de estado.</target>
        </trans-unit>
        <trans-unit id="0ab5b1ceae85cef3c7070700973eed24ddceb3f1" translate="yes" xml:space="preserve">
          <source>Vuex provides a mechanism to &quot;inject&quot; the store into all child components from the root component with the &lt;code&gt;store&lt;/code&gt; option (enabled by &lt;code&gt;Vue.use(Vuex)&lt;/code&gt;):</source>
          <target state="translated">Vuex proporciona un mecanismo para &quot;inyectar&quot; la tienda en todos los componentes secundarios desde el componente ra&amp;iacute;z con la opci&amp;oacute;n de &lt;code&gt;store&lt;/code&gt; (habilitada por &lt;code&gt;Vue.use(Vuex)&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="13c8b9558d25a74364d073902412ab0e29b9c7d8" translate="yes" xml:space="preserve">
          <source>Vuex provides its typings so you can use TypeScript to write a store definition. You don't need any special TypeScript configuration for Vuex. Please follow &lt;a href=&quot;https://v3.vuejs.org/guide/typescript-support.html&quot;&gt;Vue's basic TypeScript setup&lt;/a&gt; to configure your project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29e6083d0ea2da692697abc408390a78b3fbb6a1" translate="yes" xml:space="preserve">
          <source>Vuex requires &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises&quot;&gt;Promise&lt;/a&gt;. If your supporting browsers do not implement Promise (e.g. IE), you can use a polyfill library, such as &lt;a href=&quot;https://github.com/stefanpenner/es6-promise&quot;&gt;es6-promise&lt;/a&gt;.</source>
          <target state="translated">Vuex requiere &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises&quot;&gt;Promesa&lt;/a&gt; . Si sus navegadores compatibles no implementan Promise (por ejemplo, IE), puede usar una biblioteca polyfill, como &lt;a href=&quot;https://github.com/stefanpenner/es6-promise&quot;&gt;es6-promise&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a7c44a44a893f704da779f2a6753cb99fdabc86c" translate="yes" xml:space="preserve">
          <source>Vuex stores accept the &lt;code&gt;plugins&lt;/code&gt; option that exposes hooks for each mutation. A Vuex plugin is simply a function that receives the store as the only argument:</source>
          <target state="translated">Las tiendas Vuex aceptan la opci&amp;oacute;n de &lt;code&gt;plugins&lt;/code&gt; que expone ganchos para cada mutaci&amp;oacute;n. Un complemento de Vuex es simplemente una funci&amp;oacute;n que recibe la tienda como &amp;uacute;nico argumento:</target>
        </trans-unit>
        <trans-unit id="f9de6b1a8f9893aec2c24f2eb638d08f8c27963a" translate="yes" xml:space="preserve">
          <source>Vuex stores are reactive. When Vue components retrieve state from it, they will reactively and efficiently update if the store's state changes.</source>
          <target state="translated">Los almacenes de Vuex son reactivos.Cuando los componentes del Vuex recuperan su estado,se actualizan de forma reactiva y eficiente si el estado del almacén cambia.</target>
        </trans-unit>
        <trans-unit id="d1005b8dfed9f5da523d44fa0408fb96e863b48e" translate="yes" xml:space="preserve">
          <source>Vuex supports hot-reloading mutations, modules, actions and getters during development, using webpack's &lt;a href=&quot;https://webpack.js.org/guides/hot-module-replacement/&quot;&gt;Hot Module Replacement API&lt;/a&gt;. You can also use it in Browserify with the &lt;a href=&quot;https://github.com/AgentME/browserify-hmr/&quot;&gt;browserify-hmr&lt;/a&gt; plugin.</source>
          <target state="translated">Vuex admite mutaciones, m&amp;oacute;dulos, acciones y captadores de recarga en &lt;a href=&quot;https://webpack.js.org/guides/hot-module-replacement/&quot;&gt;caliente&lt;/a&gt; durante el desarrollo, utilizando la API de reemplazo de m&amp;oacute;dulo en caliente de webpack . Tambi&amp;eacute;n puede usarlo en Browserify con el &lt;a href=&quot;https://github.com/AgentME/browserify-hmr/&quot;&gt;complemento browserify-hmr&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1c91ec10df2bcecd2b18c0eb4c34783559fcaf6b" translate="yes" xml:space="preserve">
          <source>Vuex uses a &lt;strong&gt;single state tree&lt;/strong&gt; - that is, this single object contains all your application level state and serves as the &quot;single source of truth&quot;. This also means usually you will have only one store for each application. A single state tree makes it straightforward to locate a specific piece of state, and allows us to easily take snapshots of the current app state for debugging purposes.</source>
          <target state="translated">Vuex utiliza un &lt;strong&gt;&amp;aacute;rbol de estado &amp;uacute;nico&lt;/strong&gt; , es decir, este objeto &amp;uacute;nico contiene todo el estado de su aplicaci&amp;oacute;n y sirve como la &quot;fuente &amp;uacute;nica de la verdad&quot;. Esto tambi&amp;eacute;n significa que, por lo general, solo tendr&amp;aacute; una tienda para cada aplicaci&amp;oacute;n. Un &amp;aacute;rbol de estado &amp;uacute;nico facilita la localizaci&amp;oacute;n de una parte espec&amp;iacute;fica del estado y nos permite tomar instant&amp;aacute;neas del estado actual de la aplicaci&amp;oacute;n con facilidad para fines de depuraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="38d7ee9ea99de16acff8c72ca2947db3c8964cfb" translate="yes" xml:space="preserve">
          <source>Vuex uses a &lt;strong&gt;single state tree&lt;/strong&gt; - that is, this single object contains all your application level state and serves as the &quot;single source of truth.&quot; This also means usually you will have only one store for each application. A single state tree makes it straightforward to locate a specific piece of state, and allows us to easily take snapshots of the current app state for debugging purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daddb132dbb693223d1a8285c450a768b5e90526" translate="yes" xml:space="preserve">
          <source>Vuex.Store</source>
          <target state="translated">Vuex.Store</target>
        </trans-unit>
        <trans-unit id="e27d6d35e937e025eb96c09b1248e5c2676afd99" translate="yes" xml:space="preserve">
          <source>Vuex.Store Constructor Options</source>
          <target state="translated">Vuex.Store Opciones de construcción</target>
        </trans-unit>
        <trans-unit id="a12ddea81e37a47b9cf92721a2c3b3dce724518b" translate="yes" xml:space="preserve">
          <source>Vuex.Store Instance Methods</source>
          <target state="translated">Métodos de instancia Vuex.Store</target>
        </trans-unit>
        <trans-unit id="bf2e5bd997aabdf6407575808a7810ae806bc168" translate="yes" xml:space="preserve">
          <source>Vuex.Store Instance Properties</source>
          <target state="translated">Propiedades de la instancia Vuex.Store</target>
        </trans-unit>
        <trans-unit id="f9f831a5e0694e0c14522dd98fa88137c445d453" translate="yes" xml:space="preserve">
          <source>Vuex.Store.commit()</source>
          <target state="translated">Vuex.Store.commit()</target>
        </trans-unit>
        <trans-unit id="6525945e6ceed925f1b32505317c836dca657a7b" translate="yes" xml:space="preserve">
          <source>Vuex.Store.dispatch()</source>
          <target state="translated">Vuex.Store.dispatch()</target>
        </trans-unit>
        <trans-unit id="875eca0d2c435721934d6e21026feaf2c458121e" translate="yes" xml:space="preserve">
          <source>Vuex.Store.getters</source>
          <target state="translated">Vuex.Store.getters</target>
        </trans-unit>
        <trans-unit id="36f6be1d986b4f405099f5f30b602d52e9e30867" translate="yes" xml:space="preserve">
          <source>Vuex.Store.hotUpdate()</source>
          <target state="translated">Vuex.Store.hotUpdate()</target>
        </trans-unit>
        <trans-unit id="da4335e82262f6f8d6790534c7ad0926cc4745e2" translate="yes" xml:space="preserve">
          <source>Vuex.Store.registerModule()</source>
          <target state="translated">Vuex.Store.registerModule()</target>
        </trans-unit>
        <trans-unit id="94ac4b985f66595cf0a6092e1a82c5ad38bbb16b" translate="yes" xml:space="preserve">
          <source>Vuex.Store.replaceState()</source>
          <target state="translated">Vuex.Store.replaceState()</target>
        </trans-unit>
        <trans-unit id="4f304b4fdb3bf5548021e12438f19b8a3c837429" translate="yes" xml:space="preserve">
          <source>Vuex.Store.state</source>
          <target state="translated">Vuex.Store.state</target>
        </trans-unit>
        <trans-unit id="646d93a6768d3e6602cdefd17248482210916c01" translate="yes" xml:space="preserve">
          <source>Vuex.Store.subscribe()</source>
          <target state="translated">Vuex.Store.subscribe()</target>
        </trans-unit>
        <trans-unit id="f3e660b4b4bcbf28c208b2cb1849c08db1e4a864" translate="yes" xml:space="preserve">
          <source>Vuex.Store.subscribeAction()</source>
          <target state="translated">Vuex.Store.subscribeAction()</target>
        </trans-unit>
        <trans-unit id="ae9d201aeec49d5494691627724de63760974852" translate="yes" xml:space="preserve">
          <source>Vuex.Store.unregisterModule()</source>
          <target state="translated">Vuex.Store.unregisterModule()</target>
        </trans-unit>
        <trans-unit id="a78a21d356c3413617b93e60de03e3c4c85613bf" translate="yes" xml:space="preserve">
          <source>Vuex.Store.watch()</source>
          <target state="translated">Vuex.Store.watch()</target>
        </trans-unit>
        <trans-unit id="fd3edc641024a335a508fdacefb5f51ded5905cc" translate="yes" xml:space="preserve">
          <source>WARNING</source>
          <target state="translated">WARNING</target>
        </trans-unit>
        <trans-unit id="972f097fe8de7d9024e0cac7324df8bc2bd5d8a7" translate="yes" xml:space="preserve">
          <source>We can also pass a string array to &lt;code&gt;mapState&lt;/code&gt; when the name of a mapped computed property is the same as a state sub tree name.</source>
          <target state="translated">Tambi&amp;eacute;n podemos pasar una matriz de cadenas a &lt;code&gt;mapState&lt;/code&gt; cuando el nombre de una propiedad calculada asignada es el mismo que el nombre de un sub&amp;aacute;rbol de estado.</target>
        </trans-unit>
        <trans-unit id="62a0d6990ce81e2c8fb572ac1e1a0f61bc100c86" translate="yes" xml:space="preserve">
          <source>We can now easily make use of it inside any component:</source>
          <target state="translated">Ahora podemos utilizarlo fácilmente dentro de cualquier componente:</target>
        </trans-unit>
        <trans-unit id="8745c67924f31017daab7ed40bb8f21170388cd9" translate="yes" xml:space="preserve">
          <source>We will be using ES2015 syntax for code examples for the rest of the docs. If you haven't picked it up, &lt;a href=&quot;https://babeljs.io/docs/learn-es2015/&quot;&gt;you should&lt;/a&gt;!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e679c86924ed36ac40c73653131acb30c335823" translate="yes" xml:space="preserve">
          <source>What is Vuex?</source>
          <target state="translated">¿Qué es Vuex?</target>
        </trans-unit>
        <trans-unit id="4f7cb23fbc792a907900b6c227a08a9ce44bbb08" translate="yes" xml:space="preserve">
          <source>What is a &quot;State Management Pattern&quot;?</source>
          <target state="translated">¿Qué es un &quot;patrón de gestión estatal&quot;?</target>
        </trans-unit>
        <trans-unit id="bfb57f97eebc790fb0f996df58cf05c904d765fe" translate="yes" xml:space="preserve">
          <source>When Should I Use It?</source>
          <target state="translated">¿Cuándo debo usarla?</target>
        </trans-unit>
        <trans-unit id="7049f8d400f975057b510f35754e4b4a55b8a447" translate="yes" xml:space="preserve">
          <source>When a component needs to make use of multiple store state properties or getters, declaring all these computed properties can get repetitive and verbose. To deal with this we can make use of the &lt;code&gt;mapState&lt;/code&gt; helper which generates computed getter functions for us, saving us some keystrokes:</source>
          <target state="translated">Cuando un componente necesita hacer uso de varias propiedades de estado de tienda o captadores, declarar todas estas propiedades calculadas puede volverse repetitivo y detallado. Para lidiar con esto, podemos hacer uso del ayudante &lt;code&gt;mapState&lt;/code&gt; que genera funciones getter calculadas para nosotros, ahorr&amp;aacute;ndonos algunas pulsaciones de teclas:</target>
        </trans-unit>
        <trans-unit id="b0e91b1a6d070c61fac000b9d3b95342ccf2db46" translate="yes" xml:space="preserve">
          <source>When accessing mutations and actions, you can simply provide the &lt;code&gt;commit&lt;/code&gt; and &lt;code&gt;dispatch&lt;/code&gt; function inside the &lt;code&gt;setup&lt;/code&gt; hook.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c17e29a6e47a7d53eb7540fe5f43fd3c7ec25ef4" translate="yes" xml:space="preserve">
          <source>When adding new properties to an Object, you should either:</source>
          <target state="translated">Cuando se añaden nuevas propiedades a un objeto,se debe hacer lo siguiente:</target>
        </trans-unit>
        <trans-unit id="efff342070587a8120ff0a0f2a1a6c593581e9da" translate="yes" xml:space="preserve">
          <source>When binding a namespaced module to components with the &lt;code&gt;mapState&lt;/code&gt;, &lt;code&gt;mapGetters&lt;/code&gt;, &lt;code&gt;mapActions&lt;/code&gt; and &lt;code&gt;mapMutations&lt;/code&gt; helpers, it can get a bit verbose:</source>
          <target state="translated">Al vincular un m&amp;oacute;dulo con espacio de nombres a componentes con los &lt;code&gt;mapState&lt;/code&gt; , &lt;code&gt;mapGetters&lt;/code&gt; , &lt;code&gt;mapActions&lt;/code&gt; y &lt;code&gt;mapMutations&lt;/code&gt; , puede volverse un poco detallado:</target>
        </trans-unit>
        <trans-unit id="99195dc5710842be6bed30d96a1def16fb32d71c" translate="yes" xml:space="preserve">
          <source>When used with a module system, you must explicitly install Vuex via &lt;code&gt;Vue.use()&lt;/code&gt;:</source>
          <target state="translated">Cuando se usa con un sistema de m&amp;oacute;dulos, debe instalar Vuex expl&amp;iacute;citamente a trav&amp;eacute;s de &lt;code&gt;Vue.use()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="77c1ff3694c93e3a5898ebf5b137f7620c5e12dd" translate="yes" xml:space="preserve">
          <source>When using Vuex in strict mode, it could be a bit tricky to use &lt;code&gt;v-model&lt;/code&gt; on a piece of state that belongs to Vuex:</source>
          <target state="translated">Al usar Vuex en modo estricto, podr&amp;iacute;a ser un poco complicado usar &lt;code&gt;v-model&lt;/code&gt; en una parte del estado que pertenece a Vuex:</target>
        </trans-unit>
        <trans-unit id="fd5fb9660a82033a1f5e0bdd5e988d5fee11ea79" translate="yes" xml:space="preserve">
          <source>When using object-style commit, the entire object will be passed as the payload to mutation handlers, so the handler remains the same:</source>
          <target state="translated">Cuando se utiliza la confirmación de estilo de objeto,el objeto completo se pasa como carga útil a los manipuladores de la mutación,por lo que el manipulador sigue siendo el mismo:</target>
        </trans-unit>
        <trans-unit id="4c9c007e95ce7e90fdef65d514914f8a48ea50fc" translate="yes" xml:space="preserve">
          <source>When you set &lt;code&gt;preserveState: true&lt;/code&gt;, the module is registered, actions, mutations and getters are added to the store, but the state is not. It's assumed that your store state already contains state for that module and you don't want to overwrite it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64b97d35575f008d89a5abcf758506366a1df6c9" translate="yes" xml:space="preserve">
          <source>When you set &lt;code&gt;preserveState: true&lt;/code&gt;, the module is registered, actions, mutations and getters are added to the store, but the state not. It's assumed that your store state already contains state for that module and you don't want to overwrite it.</source>
          <target state="translated">Cuando establece &lt;code&gt;preserveState: true&lt;/code&gt; , el m&amp;oacute;dulo se registra, las acciones, mutaciones y captadores se agregan a la tienda, pero el estado no. Se supone que el estado de su tienda ya contiene el estado de ese m&amp;oacute;dulo y no desea sobrescribirlo.</target>
        </trans-unit>
        <trans-unit id="b67645573519bd6745c7692e115ca001bffedc35" translate="yes" xml:space="preserve">
          <source>When you're writing your Vue component in Composition API, you will most likely want &lt;code&gt;useStore&lt;/code&gt; to return the typed store. For &lt;code&gt;useStore&lt;/code&gt; to correctly return the typed store, you must:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0672c57fbbf8e8ecf0e7b63699f5a7c92edcd4d" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;store.state.count&lt;/code&gt; changes, it will cause the computed property to re-evaluate, and trigger associated DOM updates.</source>
          <target state="translated">Siempre que &lt;code&gt;store.state.count&lt;/code&gt; cambie, har&amp;aacute; que la propiedad calculada se vuelva a evaluar y active las actualizaciones DOM asociadas.</target>
        </trans-unit>
        <trans-unit id="a085ea0f1aa78bea832392da9c502369be0887a2" translate="yes" xml:space="preserve">
          <source>Whether to use constants is largely a preference - it can be helpful in large projects with many developers, but it's totally optional if you don't like them.</source>
          <target state="translated">El uso de constantes es en gran parte una preferencia-puede ser útil en proyectos grandes con muchos desarrolladores,pero es totalmente opcional si no te gustan.</target>
        </trans-unit>
        <trans-unit id="4c08b16ee1dc63cbfb31d2273bccaca063856191" translate="yes" xml:space="preserve">
          <source>Whilst this is not technically a breaking change, you may still use the &lt;code&gt;new Store(...)&lt;/code&gt; syntax, we recommend this approach to align with Vue 3 and Vue Router Next.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4de67a4d313139fb2f1d0ad9d2c13d0921ddb131" translate="yes" xml:space="preserve">
          <source>Yarn</source>
          <target state="translated">Yarn</target>
        </trans-unit>
        <trans-unit id="63134a6d55a8d86ebefa1d7e28dd4e4938a617f5" translate="yes" xml:space="preserve">
          <source>You can also pass arguments to getters by returning a function. This is particularly useful when you want to query an array in the store:</source>
          <target state="translated">También puedes pasar argumentos a los getters devolviendo una función.Esto es particularmente útil cuando quieres consultar una matriz en la tienda:</target>
        </trans-unit>
        <trans-unit id="23de97b968754adb5c8071394c94800b27c8ebc7" translate="yes" xml:space="preserve">
          <source>You can also remove a dynamically registered module with &lt;code&gt;store.unregisterModule(moduleName)&lt;/code&gt;. Note you cannot remove static modules (declared at store creation) with this method.</source>
          <target state="translated">Tambi&amp;eacute;n puede eliminar un m&amp;oacute;dulo registrado din&amp;aacute;micamente con &lt;code&gt;store.unregisterModule(moduleName)&lt;/code&gt; . Tenga en cuenta que no puede eliminar m&amp;oacute;dulos est&amp;aacute;ticos (declarados en la creaci&amp;oacute;n de la tienda) con este m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="d29c54157aed563d47280cf164e51dba16933038" translate="yes" xml:space="preserve">
          <source>You can commit mutations in components with &lt;code&gt;this.$store.commit('xxx')&lt;/code&gt;, or use the &lt;code&gt;mapMutations&lt;/code&gt; helper which maps component methods to &lt;code&gt;store.commit&lt;/code&gt; calls (requires root &lt;code&gt;store&lt;/code&gt; injection):</source>
          <target state="translated">Puede cometer mutaciones en componentes con &lt;code&gt;this.$store.commit('xxx')&lt;/code&gt; , o usar el asistente &lt;code&gt;mapMutations&lt;/code&gt; que mapea m&amp;eacute;todos de componentes para llamadas &lt;code&gt;store.commit&lt;/code&gt; (requiere inyecci&amp;oacute;n de &lt;code&gt;store&lt;/code&gt; ra&amp;iacute;z ):</target>
        </trans-unit>
        <trans-unit id="1215721038a305c2ecee17f52181bc37f1909ea8" translate="yes" xml:space="preserve">
          <source>You can dispatch actions in components with &lt;code&gt;this.$store.dispatch('xxx')&lt;/code&gt;, or use the &lt;code&gt;mapActions&lt;/code&gt; helper which maps component methods to &lt;code&gt;store.dispatch&lt;/code&gt; calls (requires root &lt;code&gt;store&lt;/code&gt; injection):</source>
          <target state="translated">Puede enviar acciones en componentes con &lt;code&gt;this.$store.dispatch('xxx')&lt;/code&gt; , o usar el asistente &lt;code&gt;mapActions&lt;/code&gt; que mapea m&amp;eacute;todos de componentes para &lt;code&gt;store.dispatch&lt;/code&gt; llamadas (requiere inyecci&amp;oacute;n de &lt;code&gt;store&lt;/code&gt; ra&amp;iacute;z ):</target>
        </trans-unit>
        <trans-unit id="8881848045fd86241cc9c9d7d92edbe765adb62d" translate="yes" xml:space="preserve">
          <source>You can include it via CDN:</source>
          <target state="translated">Puedes incluirlo a través de CDN:</target>
        </trans-unit>
        <trans-unit id="5ad1656a1ce03c34ec4d07184a92309aa7cbeafd" translate="yes" xml:space="preserve">
          <source>You can learn more in the &lt;a href=&quot;composition-api&quot;&gt;Composition API&lt;/a&gt; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fc0fa46dba60197b55bd958d17dd6ccb01559a1" translate="yes" xml:space="preserve">
          <source>You can learn more in the &lt;a href=&quot;typescript-support&quot;&gt;TypeScript Support&lt;/a&gt; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25c0fe7b987a059291687c75ef24f147484cb473" translate="yes" xml:space="preserve">
          <source>You can pass an additional argument to &lt;code&gt;store.commit&lt;/code&gt;, which is called the &lt;strong&gt;payload&lt;/strong&gt; for the mutation:</source>
          <target state="translated">Puede pasar un argumento adicional a &lt;code&gt;store.commit&lt;/code&gt; , que se denomina &lt;strong&gt;carga &amp;uacute;til&lt;/strong&gt; para la mutaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="3669fc0f4547fc417e6184797578f0ae3a315436" translate="yes" xml:space="preserve">
          <source>You can register a module &lt;strong&gt;after&lt;/strong&gt; the store has been created with the &lt;code&gt;store.registerModule&lt;/code&gt; method:</source>
          <target state="translated">Puede registrar un m&amp;oacute;dulo &lt;strong&gt;despu&amp;eacute;s de que&lt;/strong&gt; se haya creado la tienda con el m&amp;eacute;todo &lt;code&gt;store.registerModule&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="535a2512801117d140454c6e5cb378ba940f4b23" translate="yes" xml:space="preserve">
          <source>You cannot directly call a mutation handler. Think of it more like event registration: &quot;When a mutation with type &lt;code&gt;increment&lt;/code&gt; is triggered, call this handler.&quot; To invoke a mutation handler, you need to call &lt;code&gt;store.commit&lt;/code&gt; with its type:</source>
          <target state="translated">No puede llamar directamente a un controlador de mutaciones. Piense en ello m&amp;aacute;s como un registro de eventos: &quot;Cuando se activa una mutaci&amp;oacute;n con &lt;code&gt;increment&lt;/code&gt; o de tipo , llame a este controlador&quot;. Para invocar un controlador de mutaci&amp;oacute;n, debe llamar a &lt;code&gt;store.commit&lt;/code&gt; con su tipo:</target>
        </trans-unit>
        <trans-unit id="daa96a4f6ba2541961bc6b0ba61ad44c19c2cd8d" translate="yes" xml:space="preserve">
          <source>You cannot directly mutate the store's state. The only way to change a store's state is by explicitly &lt;strong&gt;committing mutations&lt;/strong&gt;. This ensures every state change leaves a track-able record, and enables tooling that helps us better understand our applications.</source>
          <target state="translated">No puede cambiar directamente el estado de la tienda. La &amp;uacute;nica forma de cambiar el estado de una tienda es &lt;strong&gt;cometiendo mutaciones&lt;/strong&gt; expl&amp;iacute;citamente . Esto asegura que cada cambio de estado deje un registro rastreable y habilita herramientas que nos ayudan a comprender mejor nuestras aplicaciones.</target>
        </trans-unit>
        <trans-unit id="360fc60f946b0e1fb46441c21ec094cefc382a47" translate="yes" xml:space="preserve">
          <source>You don't need to do this when using global script tags.</source>
          <target state="translated">No es necesario hacer esto cuando se usan etiquetas de escritura global.</target>
        </trans-unit>
        <trans-unit id="c70f3011e5bb2100175201538c23d3b8d06c1f46" translate="yes" xml:space="preserve">
          <source>You may care about unpredictable namespacing for your modules when you create a &lt;a href=&quot;plugins&quot;&gt;plugin&lt;/a&gt; that provides the modules and let users add them to a Vuex store. Your modules will be also namespaced if the plugin users add your modules under a namespaced module. To adapt this situation, you may need to receive a namespace value via your plugin option:</source>
          <target state="translated">Es posible que le importe el espacio de nombres impredecible para sus m&amp;oacute;dulos cuando crea un &lt;a href=&quot;plugins&quot;&gt;complemento&lt;/a&gt; que proporciona los m&amp;oacute;dulos y permite que los usuarios los agreguen a una tienda Vuex. Sus m&amp;oacute;dulos tambi&amp;eacute;n tendr&amp;aacute;n espacio de nombre si los usuarios del complemento agregan sus m&amp;oacute;dulos bajo un m&amp;oacute;dulo con espacio de nombre. Para adaptar esta situaci&amp;oacute;n, es posible que deba recibir un valor de espacio de nombres a trav&amp;eacute;s de su opci&amp;oacute;n de complemento:</target>
        </trans-unit>
        <trans-unit id="3f63bbd45ca0e396d20716f1a9faff811b1810cb" translate="yes" xml:space="preserve">
          <source>You will have to clone directly from GitHub and build &lt;code&gt;vuex&lt;/code&gt; yourself if you want to use the latest dev build.</source>
          <target state="translated">Tendr&amp;aacute; que clonar directamente desde GitHub y compilar &lt;code&gt;vuex&lt;/code&gt; usted mismo si desea utilizar la &amp;uacute;ltima compilaci&amp;oacute;n de desarrollo.</target>
        </trans-unit>
        <trans-unit id="326b426f9ac7a96ed6baf62f8838565416d27df8" translate="yes" xml:space="preserve">
          <source>actions</source>
          <target state="translated">actions</target>
        </trans-unit>
        <trans-unit id="4015b57a143aec5156fd1444a017a32137a3fd0f" translate="yes" xml:space="preserve">
          <source>commit</source>
          <target state="translated">commit</target>
        </trans-unit>
        <trans-unit id="c0b7cc8520ca125ff38dd308c300837ea02ab867" translate="yes" xml:space="preserve">
          <source>createNamespacedHelpers</source>
          <target state="translated">createNamespacedHelpers</target>
        </trans-unit>
        <trans-unit id="59211592ba313c330272b3b02e6654aaf2030698" translate="yes" xml:space="preserve">
          <source>createNamespacedHelpers()</source>
          <target state="translated">createNamespacedHelpers()</target>
        </trans-unit>
        <trans-unit id="d2d86ff5a0cd4d9837f7acff55b3a7cd9d364ab3" translate="yes" xml:space="preserve">
          <source>createStore</source>
          <target state="translated">createStore</target>
        </trans-unit>
        <trans-unit id="b853518a7253a67751993712323af2afe8d26a75" translate="yes" xml:space="preserve">
          <source>default: &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">predeterminado: &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="154cfec6bb116856227577921ae39f8885428eb2" translate="yes" xml:space="preserve">
          <source>devtools</source>
          <target state="translated">devtools</target>
        </trans-unit>
        <trans-unit id="05b145cfb6fbc24d08a8e01155c0aa2bf8460c87" translate="yes" xml:space="preserve">
          <source>dispatch</source>
          <target state="translated">dispatch</target>
        </trans-unit>
        <trans-unit id="6ec8d967f553282c8a0b78d6540dfc8d420a3ef0" translate="yes" xml:space="preserve">
          <source>getters</source>
          <target state="translated">getters</target>
        </trans-unit>
        <trans-unit id="7035b5cff18dc8c3847faa85107fdff08894d5e1" translate="yes" xml:space="preserve">
          <source>hasModule</source>
          <target state="translated">hasModule</target>
        </trans-unit>
        <trans-unit id="191d360d6e9259ceda69018c10b131806a257339" translate="yes" xml:space="preserve">
          <source>hotUpdate</source>
          <target state="translated">hotUpdate</target>
        </trans-unit>
        <trans-unit id="7f3c4da8402c9feb0a967e99e24a689f07ad9538" translate="yes" xml:space="preserve">
          <source>mapActions</source>
          <target state="translated">mapActions</target>
        </trans-unit>
        <trans-unit id="1c9faade8425f6bc337e39a55a39ae4126bc894c" translate="yes" xml:space="preserve">
          <source>mapActions()</source>
          <target state="translated">mapActions()</target>
        </trans-unit>
        <trans-unit id="c5092a452ac716aa7395be56d5a3e111411ab603" translate="yes" xml:space="preserve">
          <source>mapGetters</source>
          <target state="translated">mapGetters</target>
        </trans-unit>
        <trans-unit id="4bed8eb971d49de14d01396cd2061d4908c28770" translate="yes" xml:space="preserve">
          <source>mapGetters()</source>
          <target state="translated">mapGetters()</target>
        </trans-unit>
        <trans-unit id="a837f5acfc97cfd8166f5f0c59fcbb7dfc666465" translate="yes" xml:space="preserve">
          <source>mapMutations</source>
          <target state="translated">mapMutations</target>
        </trans-unit>
        <trans-unit id="80e0f1f5c3583f0fd0d207c7f3df5c3aba3bd7ec" translate="yes" xml:space="preserve">
          <source>mapMutations()</source>
          <target state="translated">mapMutations()</target>
        </trans-unit>
        <trans-unit id="e5461d7d29007a5a5aa44df5c418d146a0695054" translate="yes" xml:space="preserve">
          <source>mapState</source>
          <target state="translated">mapState</target>
        </trans-unit>
        <trans-unit id="2d1ce243674082e4c821c3525927a44e71d4d016" translate="yes" xml:space="preserve">
          <source>mapState()</source>
          <target state="translated">mapState()</target>
        </trans-unit>
        <trans-unit id="4580485d482a9037af94f68af98adf23819cbdf4" translate="yes" xml:space="preserve">
          <source>modules</source>
          <target state="translated">modules</target>
        </trans-unit>
        <trans-unit id="3db5c1d36e4a153d7b5cda1e2d65b175222ccf09" translate="yes" xml:space="preserve">
          <source>mutations</source>
          <target state="translated">mutations</target>
        </trans-unit>
        <trans-unit id="440c3339cb056522cd1edf391e616ceb636e1a08" translate="yes" xml:space="preserve">
          <source>plugins</source>
          <target state="translated">plugins</target>
        </trans-unit>
        <trans-unit id="3f170c2be21627360e728ba4b0f15e0c20cc0126" translate="yes" xml:space="preserve">
          <source>registerModule</source>
          <target state="translated">registerModule</target>
        </trans-unit>
        <trans-unit id="eb49199248380da5116beeb5a5bdf9606ac21f82" translate="yes" xml:space="preserve">
          <source>replaceState</source>
          <target state="translated">replaceState</target>
        </trans-unit>
        <trans-unit id="aa4a5f8125f234182e2dea92805afdfb747a86be" translate="yes" xml:space="preserve">
          <source>state</source>
          <target state="translated">state</target>
        </trans-unit>
        <trans-unit id="41eaab877ca3a0e3aa14f5a4b7981f590e3c2bd6" translate="yes" xml:space="preserve">
          <source>strict</source>
          <target state="translated">strict</target>
        </trans-unit>
        <trans-unit id="4c91330c57b1f26f16a92bbcb0653bc2a60a5b88" translate="yes" xml:space="preserve">
          <source>subscribe</source>
          <target state="translated">subscribe</target>
        </trans-unit>
        <trans-unit id="c8be9eb77e0a063aa55220d426f0169f12707d24" translate="yes" xml:space="preserve">
          <source>subscribeAction</source>
          <target state="translated">subscribeAction</target>
        </trans-unit>
        <trans-unit id="575fade49b23c513149d6cbd60de79f6715e014d" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;Array&amp;lt;Function&amp;gt;&lt;/code&gt;</source>
          <target state="translated">tipo: &lt;code&gt;Array&amp;lt;Function&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="501ad78bfb628eb307d521b862f9d31d47e25be6" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;Boolean&lt;/code&gt;</source>
          <target state="translated">tipo: &lt;code&gt;Boolean&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7f896effac2d60505acabced97b30bbb769a74db" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;Object | Function&lt;/code&gt;</source>
          <target state="translated">tipo: &lt;code&gt;Object | Function&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="459de9ab6bbb747b424aa86431b8923f3e3cebed" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;Object&lt;/code&gt;</source>
          <target state="translated">tipo: &lt;code&gt;Object&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e0800374f05dce7addc4f97d5a68d2e7b35b3ef4" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;boolean&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0adf6137f83fccfe39fef3d4143300d0f0d7953d" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;{ [key: string]: Function }&lt;/code&gt;</source>
          <target state="translated">tipo: &lt;code&gt;{ [key: string]: Function }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="116a5df420232cc247b1f0bf6bbbec8667db410b" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;{ [type: string]: Function }&lt;/code&gt;</source>
          <target state="translated">tipo: &lt;code&gt;{ [type: string]: Function }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a69e7241a5b047759b4617f9a2bc7130db75edc" translate="yes" xml:space="preserve">
          <source>unregisterModule</source>
          <target state="translated">unregisterModule</target>
        </trans-unit>
        <trans-unit id="53c05e9fd370dfe1efd890820e99c7a18b9c5414" translate="yes" xml:space="preserve">
          <source>useStore</source>
          <target state="translated">useStore</target>
        </trans-unit>
        <trans-unit id="292b0901993f7e9d9a0d9b80542f9e59505ba5be" translate="yes" xml:space="preserve">
          <source>watch</source>
          <target state="translated">watch</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
