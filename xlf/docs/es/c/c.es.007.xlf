<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="c">
    <body>
      <group id="c">
        <trans-unit id="c893ac9cadbf00f7e9ef1a77d5a304aa079fc5b5" translate="yes" xml:space="preserve">
          <source>The case where the argument is infinite is not specified to be a domain error in C, but it is defined as a &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/tan.html&quot;&gt;domain error in POSIX&lt;/a&gt;.</source>
          <target state="translated">El caso donde el argumento es infinito no se especifica como un error de dominio en C, pero se define como un &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/tan.html&quot;&gt;error de dominio en POSIX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b37eb2e5b0429777b4f0099246b03892d2c779ed" translate="yes" xml:space="preserve">
          <source>The case where the argument is infinite is not specified to be a domain error in C, but it is defined as a &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/cos.html&quot;&gt;domain error in POSIX&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85ce9f78e3a22b71278921e72f9f1d3621f8283f" translate="yes" xml:space="preserve">
          <source>The case where the argument is infinite is not specified to be a domain error in C, but it is defined as a &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/sin.html&quot;&gt;domain error in POSIX&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e55db8436986b99e3fbfd5f966d066276dfeccdd" translate="yes" xml:space="preserve">
          <source>The case where the argument is infinite is not specified to be a domain error in C, but it is defined as a &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/tan.html&quot;&gt;domain error in POSIX&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b194103418cca6cbbfda4929c3c1041036b43cf0" translate="yes" xml:space="preserve">
          <source>The cast to void is sometimes useful to silence compiler warnings about unused results.</source>
          <target state="translated">El lanzamiento al vacío es a veces útil para silenciar las advertencias del compilador sobre los resultados no utilizados.</target>
        </trans-unit>
        <trans-unit id="cb15aa2e205da76a53c99fdb5dd46d7ca6c8252c" translate="yes" xml:space="preserve">
          <source>The characters &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;!&lt;/code&gt; are invariant under ISO-646, but alternatives are provided for the operators that use these characters anyway to accommodate even more restrictive historical charsets.</source>
          <target state="translated">Los caracteres &lt;code&gt;&amp;amp;&lt;/code&gt; y &lt;code&gt;!&lt;/code&gt; son invariables bajo ISO-646, pero se proporcionan alternativas para los operadores que usan estos caracteres de todos modos para acomodar conjuntos hist&amp;oacute;ricos a&amp;uacute;n m&amp;aacute;s restrictivos.</target>
        </trans-unit>
        <trans-unit id="4035fa4f0afd21a7666c6150be01fe027d08712b" translate="yes" xml:space="preserve">
          <source>The characters of the C-strings pointed to by &lt;code&gt;grouping&lt;/code&gt; and &lt;code&gt;mon_grouping&lt;/code&gt; are interpreted according to their numeric values. When the terminating &lt;code&gt;'\0'&lt;/code&gt; is encountered, the last value seen is assumed to repeat for the remainder of digits. If &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;CHAR_MAX&lt;/a&gt;&lt;/code&gt; is encountered, no further digits are grouped. the typical grouping of three digits at a time is &lt;code&gt;&quot;\003&quot;&lt;/code&gt;.</source>
          <target state="translated">Los caracteres de las cadenas en C apuntados por &lt;code&gt;grouping&lt;/code&gt; y &lt;code&gt;mon_grouping&lt;/code&gt; se interpretan de acuerdo con sus valores num&amp;eacute;ricos. Cuando se encuentra la terminaci&amp;oacute;n &lt;code&gt;'\0'&lt;/code&gt; , se supone que el &amp;uacute;ltimo valor visto se repite para el resto de d&amp;iacute;gitos. Si se encuentra &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;CHAR_MAX&lt;/a&gt;&lt;/code&gt; , no se agrupan m&amp;aacute;s d&amp;iacute;gitos. La agrupaci&amp;oacute;n t&amp;iacute;pica de tres d&amp;iacute;gitos a la vez es &lt;code&gt;&quot;\003&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="389756ed6e9c288a5d7721af8a052706a08051ec" translate="yes" xml:space="preserve">
          <source>The choices made by each implementation about the sizes of the fundamental types are collectively known as</source>
          <target state="translated">Las decisiones tomadas por cada aplicación acerca de los tamaños de los tipos fundamentales se conocen colectivamente como</target>
        </trans-unit>
        <trans-unit id="639291a4f3c29237da353a25b118487f41eb6c93" translate="yes" xml:space="preserve">
          <source>The comma operator expression has the form.</source>
          <target state="translated">La expresión del operador de la coma tiene la forma.</target>
        </trans-unit>
        <trans-unit id="4d4d04275fd3986990614e795bf7dee50a7571a4" translate="yes" xml:space="preserve">
          <source>The comma operator may be lvalue in C++, but never in C.</source>
          <target state="translated">El operador de la coma puede ser lvalor en C++,pero nunca en C.</target>
        </trans-unit>
        <trans-unit id="d6fc3f2fb9c171bbd01b3b6dc85f4ee9561d08bf" translate="yes" xml:space="preserve">
          <source>The comma operator may return a struct (the only other expressions that return structs are compound literals, function calls, assignments, and the conditional operator).</source>
          <target state="translated">El operador de coma puede devolver una estructura (las únicas otras expresiones que devuelven estructuras son los literales compuestos,las llamadas a funciones,las asignaciones y el operador condicional).</target>
        </trans-unit>
        <trans-unit id="b7dee580f11aef5ebe6c5e769d0ef339e265bedd" translate="yes" xml:space="preserve">
          <source>The compiler is free to ignore any or all aliasing implications of uses of &lt;code&gt;restrict&lt;/code&gt;.</source>
          <target state="translated">El compilador es libre de ignorar cualquiera o todas las implicaciones de alias de los usos de &lt;code&gt;restrict&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5b3b0d4b525dd97c5a4869a198616c5154957d5" translate="yes" xml:space="preserve">
          <source>The compilers are required to issue diagnostic messages (either errors or warnings) for any programs that violates any C syntax rule or semantic constraint, even if its behavior is specified as undefined or implementation-defined or if the compiler provides a language extension that allows it to accept such program. Diagnostics for undefined behavior are not otherwise required.</source>
          <target state="translated">Los compiladores deben emitir mensajes de diagnóstico (ya sea errores o advertencias)para cualquier programa que viole cualquier regla de sintaxis C o restricción semántica,incluso si su comportamiento se especifica como indefinido o definido por la implementación o si el compilador proporciona una extensión de lenguaje que le permita aceptar dicho programa.Por lo demás,no se requiere el diagnóstico del comportamiento no definido.</target>
        </trans-unit>
        <trans-unit id="055be4235172d10af24ff6290ec130255293bd45" translate="yes" xml:space="preserve">
          <source>The completion of this function</source>
          <target state="translated">La realización de esta función</target>
        </trans-unit>
        <trans-unit id="a6dbfec61e3424ffae4ae18efa158e9aeaf2271e" translate="yes" xml:space="preserve">
          <source>The complex arc hyperbolic cosine of &lt;code&gt;z&lt;/code&gt; in the interval [0; &amp;infin;) along the real axis and in the interval [&amp;minus;i&amp;pi;; +i&amp;pi;] along the imaginary axis.</source>
          <target state="translated">El arco coseno hiperb&amp;oacute;lico complejo de &lt;code&gt;z&lt;/code&gt; en el intervalo [0; &amp;infin;) a lo largo del eje real y en el intervalo [&amp;minus;i&amp;pi;; + i&amp;pi;] a lo largo del eje imaginario.</target>
        </trans-unit>
        <trans-unit id="473d434a9b1e1fa3c3fa95983b0cf370022ebc41" translate="yes" xml:space="preserve">
          <source>The complex conjugate of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">El complejo conjugado de &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82c5651398368fa9194c75ad0cd42b27eaccd0a5" translate="yes" xml:space="preserve">
          <source>The complex exponential function ez</source>
          <target state="translated">La función exponencial compleja ez</target>
        </trans-unit>
        <trans-unit id="f4a8bb4e0bd6e80ede57c9b2a0ef2ec124631eca" translate="yes" xml:space="preserve">
          <source>The compound assignment operator expressions have the form.</source>
          <target state="translated">Las expresiones del operador de asignación de compuestos tienen la forma.</target>
        </trans-unit>
        <trans-unit id="7df263ae0e0ab175c4cedd3b99f705f4c1dd852a" translate="yes" xml:space="preserve">
          <source>The compound literal expression constructs an unnamed object of the type specified by type and initializes it as specified by initializer-list.</source>
          <target state="translated">La expresión literal compuesta construye un objeto sin nombre del tipo especificado por el tipo y lo inicializa como se especifica en la lista de inicializadores.</target>
        </trans-unit>
        <trans-unit id="4fbd0a48bc1fb7914fb073b18a7045d1a7fe29e4" translate="yes" xml:space="preserve">
          <source>The compound statement allows a set of declarations and statements to be grouped into one unit that can be used anywhere a single statement is expected (for example, in an &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; statement or an iteration statement):</source>
          <target state="translated">La declaraci&amp;oacute;n compuesta permite que un conjunto de declaraciones y declaraciones se agrupen en una unidad que se puede usar en cualquier lugar donde se espere una sola declaraci&amp;oacute;n (por ejemplo, en una declaraci&amp;oacute;n &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; o una declaraci&amp;oacute;n de iteraci&amp;oacute;n):</target>
        </trans-unit>
        <trans-unit id="8abc060166b36e799feb998e7f4939e28b8ecdbf" translate="yes" xml:space="preserve">
          <source>The conditional operator expression has the form.</source>
          <target state="translated">La expresión del operador condicional tiene la forma.</target>
        </trans-unit>
        <trans-unit id="35c8621167c53476a1a98fe938c3c174cc4134ee" translate="yes" xml:space="preserve">
          <source>The conditional operator is never an &lt;a href=&quot;value_category&quot;&gt;lvalue expression&lt;/a&gt;, although it may return objects of struct/union type. The only other expressions that may return stucts are &lt;a href=&quot;operator_assignment&quot;&gt;assignment&lt;/a&gt;, &lt;a href=&quot;operator_other#Comma_operator&quot;&gt;comma&lt;/a&gt;, &lt;a href=&quot;operator_other#Function_call&quot;&gt;function call&lt;/a&gt;, and &lt;a href=&quot;compound_literal&quot;&gt;compound literal&lt;/a&gt;.</source>
          <target state="translated">El operador condicional nunca es una &lt;a href=&quot;value_category&quot;&gt;expresi&amp;oacute;n lvalue&lt;/a&gt; , aunque puede devolver objetos de tipo struct / union. Las &amp;uacute;nicas otras expresiones que pueden devolver elementos son &lt;a href=&quot;operator_assignment&quot;&gt;asignaci&amp;oacute;n&lt;/a&gt; , &lt;a href=&quot;operator_other#Comma_operator&quot;&gt;coma&lt;/a&gt; , &lt;a href=&quot;operator_other#Function_call&quot;&gt;llamada a funci&amp;oacute;n&lt;/a&gt; y &lt;a href=&quot;compound_literal&quot;&gt;literal compuesto&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fadd419c227bb685e0a0582aff80f1b5ba7a551d" translate="yes" xml:space="preserve">
          <source>The conditional preprocessing block starts with &lt;code&gt;#if&lt;/code&gt;, &lt;code&gt;#ifdef&lt;/code&gt; or &lt;code&gt;#ifndef&lt;/code&gt; directive, then optionally includes any number of &lt;code&gt;#elif&lt;/code&gt; directives, then optionally includes at most one &lt;code&gt;#else&lt;/code&gt; directive and is terminated with the &lt;code&gt;#endif&lt;/code&gt; directive. Any inner conditional preprocessing blocks are processed separately.</source>
          <target state="translated">El bloque de preprocesamiento condicional comienza con las &lt;code&gt;#if&lt;/code&gt; , &lt;code&gt;#ifdef&lt;/code&gt; o &lt;code&gt;#ifndef&lt;/code&gt; , luego incluye opcionalmente cualquier n&amp;uacute;mero de directivas &lt;code&gt;#elif&lt;/code&gt; , luego opcionalmente incluye como m&amp;aacute;ximo una directiva &lt;code&gt;#else&lt;/code&gt; y termina con la directiva &lt;code&gt;#endif&lt;/code&gt; . Cualquier bloque de preprocesamiento condicional interno se procesa por separado.</target>
        </trans-unit>
        <trans-unit id="4ff37d62089a6b5f6e494aef62b9015866607221" translate="yes" xml:space="preserve">
          <source>The constant expression is evaluated at compile time and compared to zero. If it compares equal to zero, a compile-time error occurs and the compiler must display message (if provided) as part of the error message (except that characters not in &lt;a href=&quot;translation_phases&quot;&gt;basic source character set&lt;/a&gt; aren't required to be displayed).</source>
          <target state="translated">La expresi&amp;oacute;n constante se eval&amp;uacute;a en tiempo de compilaci&amp;oacute;n y se compara con cero. Si se compara igual a cero, se produce un error en tiempo de compilaci&amp;oacute;n y el compilador debe mostrar el mensaje (si se proporciona) como parte del mensaje de error (excepto que no se requiere que se muestren los caracteres que no est&amp;aacute;n en el &lt;a href=&quot;translation_phases&quot;&gt;conjunto de caracteres de origen b&amp;aacute;sico&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="7733c072d8eb0d24e0b88f6986f86f0fb8a35998" translate="yes" xml:space="preserve">
          <source>The controlling-expression and the expressions of the selections that are not chosen are never evaluated.</source>
          <target state="translated">La expresión controladora y las expresiones de las selecciones que no son elegidas nunca son evaluadas.</target>
        </trans-unit>
        <trans-unit id="0eba86b24f08a5313c7cce0d40bb40425a6f3985" translate="yes" xml:space="preserve">
          <source>The conversion specifiers &lt;code&gt;lc&lt;/code&gt;, &lt;code&gt;ls&lt;/code&gt;, and &lt;code&gt;l[&lt;/code&gt; perform multibyte-to-wide character conversion as if by calling &lt;a href=&quot;../string/multibyte/mbrtowc&quot;&gt;&lt;code&gt;mbrtowc()&lt;/code&gt;&lt;/a&gt; with an &lt;a href=&quot;../string/multibyte/mbstate_t&quot;&gt;&lt;code&gt;mbstate_t&lt;/code&gt;&lt;/a&gt; object initialized to zero before the first character is converted.</source>
          <target state="translated">Los especificadores de conversi&amp;oacute;n &lt;code&gt;lc&lt;/code&gt; , &lt;code&gt;ls&lt;/code&gt; y &lt;code&gt;l[&lt;/code&gt; realizan la conversi&amp;oacute;n de caracteres multibyte a ancho como si llamaran a &lt;a href=&quot;../string/multibyte/mbrtowc&quot;&gt; &lt;code&gt;mbrtowc()&lt;/code&gt; &lt;/a&gt; con un objeto &lt;a href=&quot;../string/multibyte/mbstate_t&quot;&gt; &lt;code&gt;mbstate_t&lt;/code&gt; &lt;/a&gt; inicializado a cero antes de convertir el primer car&amp;aacute;cter.</target>
        </trans-unit>
        <trans-unit id="10d720fad8838ce447569443ee37666195d1db03" translate="yes" xml:space="preserve">
          <source>The conversion specifiers &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;[&lt;/code&gt; always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width. The use of &lt;code&gt;%s&lt;/code&gt; or &lt;code&gt;%[&lt;/code&gt;, without specifying the destination array size, is as unsafe as &lt;code&gt;&lt;a href=&quot;gets&quot;&gt;gets&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Los especificadores de conversi&amp;oacute;n &lt;code&gt;s&lt;/code&gt; y &lt;code&gt;[&lt;/code&gt; siempre almacenan el terminador nulo adem&amp;aacute;s de los caracteres emparejados. El tama&amp;ntilde;o de la matriz de destino debe ser al menos uno mayor que el ancho del campo especificado. El uso de &lt;code&gt;%s&lt;/code&gt; o &lt;code&gt;%[&lt;/code&gt; , sin especificar el tama&amp;ntilde;o de la matriz de destino, es tan peligroso como &lt;code&gt;&lt;a href=&quot;gets&quot;&gt;gets&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac471b8f3e3680d0aea88efb3834381526f7e2d3" translate="yes" xml:space="preserve">
          <source>The conversions &lt;code&gt;F&lt;/code&gt;, &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;G&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; output &lt;code&gt;INF&lt;/code&gt;, &lt;code&gt;INFINITY&lt;/code&gt;, &lt;code&gt;NAN&lt;/code&gt; instead.</source>
          <target state="translated">Las conversiones &lt;code&gt;F&lt;/code&gt; , &lt;code&gt;E&lt;/code&gt; , &lt;code&gt;G&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; producen &lt;code&gt;INF&lt;/code&gt; , &lt;code&gt;INFINITY&lt;/code&gt; , &lt;code&gt;NAN&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="6d126e7074c1cecdf337f1c334c8340ee765b367" translate="yes" xml:space="preserve">
          <source>The conversions not listed here are not allowed. In particular,</source>
          <target state="translated">Las conversiones que no figuran en esta lista no están permitidas.En particular,</target>
        </trans-unit>
        <trans-unit id="fc8e08acb16e81fb66cf54c1031e76e0b8784b0f" translate="yes" xml:space="preserve">
          <source>The correct conversion specifications for the &lt;a href=&quot;../types/integer&quot;&gt;fixed-width integer types&lt;/a&gt; (&lt;code&gt;int8_t&lt;/code&gt;, etc) are defined in the header &lt;a href=&quot;../types/integer&quot;&gt;&amp;lt;inttypes.h&amp;gt;&lt;/a&gt; (although &lt;a href=&quot;../types/integer&quot;&gt;&lt;code&gt;SCNdMAX&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../types/integer&quot;&gt;&lt;code&gt;SCNuMAX&lt;/code&gt;&lt;/a&gt;, etc is synonymous with &lt;code&gt;%jd&lt;/code&gt;, &lt;code&gt;%ju&lt;/code&gt;, etc).</source>
          <target state="translated">Las especificaciones de conversi&amp;oacute;n correctas para los &lt;a href=&quot;../types/integer&quot;&gt;tipos enteros de ancho fijo&lt;/a&gt; ( &lt;code&gt;int8_t&lt;/code&gt; , etc.) se definen en el encabezado &lt;a href=&quot;../types/integer&quot;&gt;&amp;lt;inttypes.h&amp;gt;&lt;/a&gt; (aunque &lt;a href=&quot;../types/integer&quot;&gt; &lt;code&gt;SCNdMAX&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../types/integer&quot;&gt; &lt;code&gt;SCNuMAX&lt;/code&gt; &lt;/a&gt; , etc. es sin&amp;oacute;nimo de &lt;code&gt;%jd&lt;/code&gt; , &lt;code&gt;%ju&lt;/code&gt; , etc.).</target>
        </trans-unit>
        <trans-unit id="0a0aa617af0af8a4ff0e8b9f43a4c9fad55a2792" translate="yes" xml:space="preserve">
          <source>The correct conversion specifications for the fixed-width character types (&lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;int8_t&lt;/a&gt;&lt;/code&gt;, etc) are defined in the header &lt;a href=&quot;../types/integer&quot;&gt;&amp;lt;inttypes.h&amp;gt;&lt;/a&gt; (although &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;PRIdMAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;PRIuMAX&lt;/a&gt;&lt;/code&gt;, etc is synonymous with &lt;code&gt;%jd&lt;/code&gt;, &lt;code&gt;%ju&lt;/code&gt;, etc).</source>
          <target state="translated">Las especificaciones de conversi&amp;oacute;n correctas para los tipos de caracteres de ancho fijo ( &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;int8_t&lt;/a&gt;&lt;/code&gt; , etc.) se definen en el encabezado &lt;a href=&quot;../types/integer&quot;&gt;&amp;lt;inttypes.h&amp;gt;&lt;/a&gt; (aunque &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;PRIdMAX&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;PRIuMAX&lt;/a&gt;&lt;/code&gt; , etc. son sin&amp;oacute;nimos de &lt;code&gt;%jd&lt;/code&gt; , &lt;code&gt;%ju&lt;/code&gt; , etc.).</target>
        </trans-unit>
        <trans-unit id="7f9b4026c72463dbf7e53d38e204b4285cee0558" translate="yes" xml:space="preserve">
          <source>The correct length of the buffer that can receive the entire transformed string is &lt;code&gt;1+strxfrm(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, src, 0)&lt;/code&gt;.</source>
          <target state="translated">La longitud correcta del b&amp;uacute;fer que puede recibir toda la cadena transformada es &lt;code&gt;1+strxfrm(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, src, 0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a72dc1f2a9cfd3fbe819a915b266b2d90a2d9e5" translate="yes" xml:space="preserve">
          <source>The correct length of the buffer that can receive the entire transformed string is &lt;code&gt;1+wcsxfrm(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, src, 0)&lt;/code&gt;.</source>
          <target state="translated">La longitud correcta del b&amp;uacute;fer que puede recibir toda la cadena transformada es &lt;code&gt;1+wcsxfrm(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, src, 0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5a730e98fa4ae44b9e24fcf843d261fd0bdf207" translate="yes" xml:space="preserve">
          <source>The correct result can be represented as &lt;code&gt;int&lt;/code&gt; on all known implementations. For overflow to occur, &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; must be less than &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LDBL_MAX_EXP&lt;/a&gt;*log2(&lt;a href=&quot;../../types/limits&quot;&gt;FLT_RADIX&lt;/a&gt;)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt; must be greater than &lt;code&gt;LDBL_MIN_EXP-&lt;a href=&quot;../../types/limits&quot;&gt;LDBL_MANT_DIG&lt;/a&gt;)*log2(&lt;a href=&quot;../../types/limits&quot;&gt;FLT_RADIX&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">El resultado correcto se puede representar como &lt;code&gt;int&lt;/code&gt; en todas las implementaciones conocidas. Para que se produzca un desbordamiento, &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; debe ser menor que &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;LDBL_MAX_EXP&lt;/a&gt;*log2(&lt;a href=&quot;../../types/limits&quot;&gt;FLT_RADIX&lt;/a&gt;)&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../../types/limits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt; debe ser mayor que &lt;code&gt;LDBL_MIN_EXP-&lt;a href=&quot;../../types/limits&quot;&gt;LDBL_MANT_DIG&lt;/a&gt;)*log2(&lt;a href=&quot;../../types/limits&quot;&gt;FLT_RADIX&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="942cf9ae9a6d3badc39db24111513090bfb3dd85" translate="yes" xml:space="preserve">
          <source>The cosine is an entire function on the complex plane, and has no branch cuts.  Mathematical definition of the cosine is cos z =</source>
          <target state="translated">El coseno es una función completa en el plano complejo,y no tiene cortes en las ramas.La definición matemática del coseno es cos z =</target>
        </trans-unit>
        <trans-unit id="333d83e6dc8a3ed3cddeaf85bad80a985040ae63" translate="yes" xml:space="preserve">
          <source>The current &lt;a href=&quot;../fenv/fe_round&quot;&gt;rounding mode&lt;/a&gt; has no effect.</source>
          <target state="translated">El &lt;a href=&quot;../fenv/fe_round&quot;&gt;modo de redondeo&lt;/a&gt; actual no tiene efecto.</target>
        </trans-unit>
        <trans-unit id="df76dc533f4832695e4faabdf4a21cf982bfbb46" translate="yes" xml:space="preserve">
          <source>The current &lt;a href=&quot;http://en.cppreference.com/w/cpp/numeric/fenv/FE_round.html&quot;&gt;rounding mode&lt;/a&gt; has no effect.</source>
          <target state="translated">El &lt;a href=&quot;http://en.cppreference.com/w/cpp/numeric/fenv/FE_round.html&quot;&gt;modo de redondeo&lt;/a&gt; actual no tiene efecto.</target>
        </trans-unit>
        <trans-unit id="dcd990c0fc482fb45b1d3492d0748ec8b63e5c22" translate="yes" xml:space="preserve">
          <source>The current rounding mode affects the following:</source>
          <target state="translated">El modo de redondeo actual afecta a lo siguiente:</target>
        </trans-unit>
        <trans-unit id="430695fef50ce6b9934160789eacb1237ee74fd7" translate="yes" xml:space="preserve">
          <source>The current rounding mode does NOT affect the following:</source>
          <target state="translated">El modo de redondeo actual NO afecta a lo siguiente:</target>
        </trans-unit>
        <trans-unit id="d5f32fa1d98982e1738b953b2dd2b57c9e693298" translate="yes" xml:space="preserve">
          <source>The current rounding mode, reflecting the effects of the most recent &lt;code&gt;fesetround&lt;/code&gt;, can also be queried with &lt;code&gt;&lt;a href=&quot;../../types/limits/flt_rounds&quot;&gt;FLT_ROUNDS&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">El modo de redondeo actual, que refleja los efectos del &lt;code&gt;fesetround&lt;/code&gt; m&amp;aacute;s reciente , tambi&amp;eacute;n se puede consultar con &lt;code&gt;&lt;a href=&quot;../../types/limits/flt_rounds&quot;&gt;FLT_ROUNDS&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45ddc6fce10286bba6c1f8beb847e588ed427ba1" translate="yes" xml:space="preserve">
          <source>The current value of the atomic variable pointed to by &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">El valor actual de la variable at&amp;oacute;mica apuntada por &lt;code&gt;obj&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd998795c1cd4032dd66b9872287706842aa61a2" translate="yes" xml:space="preserve">
          <source>The data storage (memory) available to a C program is one or more contiguous sequences of</source>
          <target state="translated">El almacenamiento de datos (memoria)disponible para un programa C es una o más secuencias contiguas de</target>
        </trans-unit>
        <trans-unit id="c8994a846037bbc39e1e65a3a929f7e6a5d07984" translate="yes" xml:space="preserve">
          <source>The decimal point specified by &lt;code&gt;&lt;a href=&quot;../locale/setlocale&quot;&gt;setlocale&lt;/a&gt;&lt;/code&gt; has no effect on the syntax of floating constants: the decimal point character is always the period.</source>
          <target state="translated">El punto decimal especificado por &lt;code&gt;&lt;a href=&quot;../locale/setlocale&quot;&gt;setlocale&lt;/a&gt;&lt;/code&gt; no tiene efecto en la sintaxis de las constantes flotantes: el car&amp;aacute;cter del punto decimal es siempre el punto.</target>
        </trans-unit>
        <trans-unit id="b79072e7b56ba6659da6f87106f63e08064df5b7" translate="yes" xml:space="preserve">
          <source>The declaration of a variadic function uses an ellipsis as the last parameter, e.g. &lt;code&gt;int &lt;a href=&quot;io/fprintf&quot;&gt;printf&lt;/a&gt;(const char* format, ...);&lt;/code&gt;. See &lt;a href=&quot;language/variadic&quot;&gt;variadic arguments&lt;/a&gt; for additional detail on the syntax and automatic argument conversions.</source>
          <target state="translated">La declaraci&amp;oacute;n de una funci&amp;oacute;n variadic utiliza puntos suspensivos como &amp;uacute;ltimo par&amp;aacute;metro, por ejemplo, &lt;code&gt;int &lt;a href=&quot;io/fprintf&quot;&gt;printf&lt;/a&gt;(const char* format, ...);&lt;/code&gt; . Consulte los &lt;a href=&quot;language/variadic&quot;&gt;argumentos variadic&lt;/a&gt; para obtener detalles adicionales sobre la sintaxis y las conversiones autom&amp;aacute;ticas de argumentos.</target>
        </trans-unit>
        <trans-unit id="51b207b37e6bcac2f107504e9d723a780830b61a" translate="yes" xml:space="preserve">
          <source>The default behavior of all atomic operations in the &lt;a href=&quot;../language/atomic&quot;&gt;language&lt;/a&gt; and the library provides for</source>
          <target state="translated">El comportamiento predeterminado de todas las operaciones at&amp;oacute;micas en el &lt;a href=&quot;../language/atomic&quot;&gt;lenguaje&lt;/a&gt; y la biblioteca proporciona</target>
        </trans-unit>
        <trans-unit id="4587bcdbb1b6bc9e3b5e438494b4e72f8dd1c68a" translate="yes" xml:space="preserve">
          <source>The default buffer size &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;BUFSIZ&lt;/a&gt;&lt;/code&gt; is expected to be the most efficient buffer size for file I/O on the implementation, but POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fstat.html&quot;&gt;fstat&lt;/a&gt; often provides a better estimate.</source>
          <target state="translated">Se espera que el tama&amp;ntilde;o de b&amp;uacute;fer predeterminado &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;BUFSIZ&lt;/a&gt;&lt;/code&gt; sea ​​el tama&amp;ntilde;o de b&amp;uacute;fer m&amp;aacute;s eficiente para la E / S de archivos en la implementaci&amp;oacute;n, pero POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fstat.html&quot;&gt;fstat a&lt;/a&gt; menudo proporciona una mejor estimaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="704cfed41634169a037643744dd48b4ba86f41ca" translate="yes" xml:space="preserve">
          <source>The default buffer size &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;BUFSIZ&lt;/a&gt;&lt;/code&gt; is expected to be the most efficient buffer size for file I/O on the implementation, but POSIX &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/fstat.html&quot;&gt;fstat&lt;/a&gt; often provides a better estimate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="627832562bf8dd374b20ff048dfc37aaca313b99" translate="yes" xml:space="preserve">
          <source>The definition of the macro &lt;code&gt;assert&lt;/code&gt; depends on another macro, &lt;code&gt;NDEBUG&lt;/code&gt;, which is not defined by the standard library.</source>
          <target state="translated">La definici&amp;oacute;n de la macro &lt;code&gt;assert&lt;/code&gt; depende de otro macro, &lt;code&gt;NDEBUG&lt;/code&gt; , que no est&amp;aacute; definido por la biblioteca est&amp;aacute;ndar.</target>
        </trans-unit>
        <trans-unit id="aeb40399c9bd04128464837d331638d1fc355f39" translate="yes" xml:space="preserve">
          <source>The description is formed by concatenating the following components:</source>
          <target state="translated">La descripción se forma mediante la concatenación de los siguientes componentes:</target>
        </trans-unit>
        <trans-unit id="db81ed6a406de31b6ca65d95bdd037c70cc38728" translate="yes" xml:space="preserve">
          <source>The destructor, if available, is not invoked.</source>
          <target state="translated">El destructor,si está disponible,no se invoca.</target>
        </trans-unit>
        <trans-unit id="fb97a7284cd296528abb21877065aef28175aa34" translate="yes" xml:space="preserve">
          <source>The destructor, if one was registered by &lt;code&gt;&lt;a href=&quot;tss_create&quot;&gt;tss_create&lt;/a&gt;&lt;/code&gt;, is not called (they are only called at thread exit, either by &lt;code&gt;&lt;a href=&quot;thrd_exit&quot;&gt;thrd_exit&lt;/a&gt;&lt;/code&gt; or by returning from the thread function), it is the responsibility of the programmer to ensure that every thread that is aware of &lt;code&gt;tss_id&lt;/code&gt; performed all necessary cleanup, before the call to &lt;code&gt;tss_delete&lt;/code&gt; is made.</source>
          <target state="translated">El destructor, si uno fue registrado por &lt;code&gt;&lt;a href=&quot;tss_create&quot;&gt;tss_create&lt;/a&gt;&lt;/code&gt; , no se llama (solo se llama al salir del hilo, ya sea por &lt;code&gt;&lt;a href=&quot;thrd_exit&quot;&gt;thrd_exit&lt;/a&gt;&lt;/code&gt; o al regresar de la funci&amp;oacute;n de hilo), es responsabilidad del programador asegurarse de que cada hilo sea consciente de &lt;code&gt;tss_id&lt;/code&gt; realiz&amp;oacute; toda la limpieza necesaria, antes de realizar la llamada a &lt;code&gt;tss_delete&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2599aff3e1997c8bce0ea2079154bc10d116fd7" translate="yes" xml:space="preserve">
          <source>The double version of fmod behaves as if implemented as follows:</source>
          <target state="translated">La versión doble de fmod se comporta como si estuviera implementada de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="d33813bc0fb85e40f1c26903767c91afaf907f09" translate="yes" xml:space="preserve">
          <source>The effect of calling &lt;code&gt;&lt;a href=&quot;../types/offsetof&quot;&gt;offsetof&lt;/a&gt;&lt;/code&gt; on a bit field</source>
          <target state="translated">El efecto de llamar a &lt;code&gt;&lt;a href=&quot;../types/offsetof&quot;&gt;offsetof&lt;/a&gt;&lt;/code&gt; en un campo de bits</target>
        </trans-unit>
        <trans-unit id="529673770ff976d50ee9f358bf474740d57d7b6c" translate="yes" xml:space="preserve">
          <source>The element type of the composite type is the composite type of the two element types.</source>
          <target state="translated">El tipo de elemento del tipo compuesto es el tipo compuesto de los dos tipos de elementos.</target>
        </trans-unit>
        <trans-unit id="c50a1fc3f7b297bdcca890f9bac6d5dd553d12f8" translate="yes" xml:space="preserve">
          <source>The encoding of calendar time in &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; is unspecified, but most systems conform to &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/time.html&quot;&gt;POSIX specification&lt;/a&gt; and return a value of integral type holding the number of seconds since &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_15&quot;&gt;the Epoch&lt;/a&gt;. Implementations in which &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; is a 32-bit signed integer (many historical implementations) fail in the year &lt;a href=&quot;http://en.wikipedia.org/wiki/Year_2038_problem&quot;&gt;2038&lt;/a&gt;.</source>
          <target state="translated">La codificaci&amp;oacute;n del tiempo calendario en &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; no est&amp;aacute; especificada, pero la mayor&amp;iacute;a de los sistemas se ajustan a la &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/time.html&quot;&gt;especificaci&amp;oacute;n POSIX&lt;/a&gt; y devuelven un valor de tipo integral que contiene el n&amp;uacute;mero de segundos desde &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_15&quot;&gt;la &amp;Eacute;poca&lt;/a&gt; . Las implementaciones en las que &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; es un entero con signo de 32 bits (muchas implementaciones hist&amp;oacute;ricas) fallan en el a&amp;ntilde;o &lt;a href=&quot;http://en.wikipedia.org/wiki/Year_2038_problem&quot;&gt;2038&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="46c62e849f85f3a4ba03d516978379effedf794e" translate="yes" xml:space="preserve">
          <source>The encoding of calendar time in &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; is unspecified, but most systems conform to &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/time.html&quot;&gt;POSIX specification&lt;/a&gt; and return a value of integral type holding the number of seconds since &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_15&quot;&gt;the Epoch&lt;/a&gt;. Implementations in which &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; is a 32-bit signed integer (many historical implementations) fail in the year &lt;a href=&quot;https://en.wikipedia.org/wiki/Year_2038_problem&quot;&gt;2038&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="824493ebacf0d3370672a682b01bf74e21675169" translate="yes" xml:space="preserve">
          <source>The encoding of character string literals (1) and wide string literals (5) is implementation-defined. For example, gcc selects them with the &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/cpp/Invocation.html&quot;&gt;commandline options&lt;/a&gt;&lt;code&gt;-fexec-charset&lt;/code&gt; and &lt;code&gt;-fwide-exec-charset&lt;/code&gt;.</source>
          <target state="translated">La codificaci&amp;oacute;n de los literales de cadena de caracteres (1) y los literales de cadena ancha (5) est&amp;aacute; definida por la implementaci&amp;oacute;n. Por ejemplo, gcc los selecciona con las &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/cpp/Invocation.html&quot;&gt;opciones de l&amp;iacute;nea de comandos &lt;/a&gt; &lt;code&gt;-fexec-charset&lt;/code&gt; y &lt;code&gt;-fwide-exec-charset&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b539c63cb55edb7e1383ca8e128aa52c2118d3c" translate="yes" xml:space="preserve">
          <source>The end of every declarator that is not part of another declarator is a &lt;a href=&quot;eval_order&quot;&gt;sequence point&lt;/a&gt;.</source>
          <target state="translated">El final de cada declarador que no es parte de otro declarador es un &lt;a href=&quot;eval_order&quot;&gt;punto de secuencia&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2b400103ba5ae8e95fc269d363832185de644a92" translate="yes" xml:space="preserve">
          <source>The entire program may have zero or one external definition of every identifier (other than an &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt; function)(since C99) with &lt;a href=&quot;storage_duration&quot;&gt;external linkage&lt;/a&gt;.</source>
          <target state="translated">El programa completo puede tener cero o una definici&amp;oacute;n externa de cada identificador (que no sea una funci&amp;oacute;n en &lt;a href=&quot;inline&quot;&gt;l&amp;iacute;nea&lt;/a&gt; ) (desde C99) con &lt;a href=&quot;storage_duration&quot;&gt;enlace externo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f7a14859a09bf56dbf34fa38ebabd0a0cfc01622" translate="yes" xml:space="preserve">
          <source>The equality operator expressions have the form.</source>
          <target state="translated">Las expresiones del operador de igualdad tienen la forma.</target>
        </trans-unit>
        <trans-unit id="61830cacc4ca90b758c92dfcb68fdc8c2624ac72" translate="yes" xml:space="preserve">
          <source>The evaluation of expression takes place after each execution of statement (whether entered normally or by a goto). If the controlling expression needs to be evaluated before the loop body, the &lt;a href=&quot;while&quot;&gt;while loop&lt;/a&gt; or the &lt;a href=&quot;for&quot;&gt;for loop&lt;/a&gt; may be used.</source>
          <target state="translated">La evaluaci&amp;oacute;n de la expresi&amp;oacute;n se lleva a cabo despu&amp;eacute;s de cada ejecuci&amp;oacute;n de la declaraci&amp;oacute;n (ya sea ingresada normalmente o por un goto). Si la expresi&amp;oacute;n de control necesita ser evaluada antes del cuerpo del &lt;a href=&quot;for&quot;&gt;bucle,&lt;/a&gt; se puede usar el &lt;a href=&quot;while&quot;&gt;bucle while&lt;/a&gt; o el bucle for .</target>
        </trans-unit>
        <trans-unit id="6ac201da533f6480e174bf7db981da799dd3201b" translate="yes" xml:space="preserve">
          <source>The evaluation of expression takes place before each execution of statement (unless entered by a goto). If the controlling expression needs to be evaluated after the loop body, the &lt;a href=&quot;do&quot;&gt;do-while loop&lt;/a&gt; may be used.</source>
          <target state="translated">La evaluaci&amp;oacute;n de la expresi&amp;oacute;n tiene lugar antes de cada ejecuci&amp;oacute;n de la declaraci&amp;oacute;n (a menos que sea ingresada por un goto). Si la expresi&amp;oacute;n de control necesita ser evaluada despu&amp;eacute;s del cuerpo del &lt;a href=&quot;do&quot;&gt;bucle,&lt;/a&gt; se puede usar el bucle do-while .</target>
        </trans-unit>
        <trans-unit id="0e4a670e9ee4d8164f867b068f256b475e0334b4" translate="yes" xml:space="preserve">
          <source>The evaluations of expression that designates the function to be called and all arguments are &lt;a href=&quot;eval_order&quot;&gt;unsequenced&lt;/a&gt; with respect to each other (but there is a sequence point before the body of the function begins executing).</source>
          <target state="translated">Las evaluaciones de expresi&amp;oacute;n que designan la funci&amp;oacute;n a llamar y todos los argumentos no est&amp;aacute;n &lt;a href=&quot;eval_order&quot;&gt;secuenciados&lt;/a&gt; entre s&amp;iacute; (pero hay un punto de secuencia antes de que el cuerpo de la funci&amp;oacute;n comience a ejecutarse).</target>
        </trans-unit>
        <trans-unit id="88a06ff6d6b5a3ba4276cee42336251cadd1cd73" translate="yes" xml:space="preserve">
          <source>The exact behavior of this function depends on the implementation, in particular on the mechanics of the OS scheduler in use and the state of the system. For example, a first-in-first-out realtime scheduler (&lt;code&gt;SCHED_FIFO&lt;/code&gt; in Linux) would suspend the current thread and put it on the back of the queue of the same-priority threads that are ready to run (and if there are no other threads at the same priority, &lt;code&gt;yield&lt;/code&gt; has no effect).</source>
          <target state="translated">El comportamiento exacto de esta funci&amp;oacute;n depende de la implementaci&amp;oacute;n, en particular de la mec&amp;aacute;nica del planificador del sistema operativo en uso y del estado del sistema. Por ejemplo, un planificador en tiempo real &lt;code&gt;SCHED_FIFO&lt;/code&gt; en entrar, primero en salir ( SCHED_FIFO en Linux) suspender&amp;iacute;a el hilo actual y lo colocar&amp;iacute;a en la parte posterior de la cola de los hilos de la misma prioridad que est&amp;aacute;n listos para ejecutarse (y si no hay otro hilos con la misma prioridad, el &lt;code&gt;yield&lt;/code&gt; no tiene efecto).</target>
        </trans-unit>
        <trans-unit id="3afa03179e588e1c757bb671479e9343d010308a" translate="yes" xml:space="preserve">
          <source>The exponent contains at least two digits, more digits are used only if necessary. If the value is &lt;code&gt;​0​&lt;/code&gt;, the exponent is also &lt;code&gt;​0​&lt;/code&gt;.</source>
          <target state="translated">El exponente contiene al menos dos d&amp;iacute;gitos, solo se usan m&amp;aacute;s d&amp;iacute;gitos si es necesario. Si el valor es &lt;code&gt;​0​&lt;/code&gt; , el exponente es tambi&amp;eacute;n &lt;code&gt;​0​&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8bbac353ed3f45f6cc4a964a51c439a96d66dd22" translate="yes" xml:space="preserve">
          <source>The exponent has the form.</source>
          <target state="translated">El exponente tiene la forma.</target>
        </trans-unit>
        <trans-unit id="04028f66e9c71c2bd75f830dc82f30f80377d676" translate="yes" xml:space="preserve">
          <source>The exponential function is an</source>
          <target state="translated">La función exponencial es una</target>
        </trans-unit>
        <trans-unit id="3e9f12f2ca6ab5279914c37234b56437596c602d" translate="yes" xml:space="preserve">
          <source>The expression cannot be a &lt;a href=&quot;operator_other#Comma_operator&quot;&gt;comma operator&lt;/a&gt; (unless parenthesized) because the comma at the top level would be interpreted as the beginning of the next declarator.</source>
          <target state="translated">La expresi&amp;oacute;n no puede ser un &lt;a href=&quot;operator_other#Comma_operator&quot;&gt;operador de coma&lt;/a&gt; (a menos que est&amp;eacute; entre par&amp;eacute;ntesis) porque la coma en el nivel superior se interpretar&amp;iacute;a como el comienzo del siguiente declarante.</target>
        </trans-unit>
        <trans-unit id="25d8b1cc309b61a3a19bc6577131254cb18609f3" translate="yes" xml:space="preserve">
          <source>The expression following &lt;a href=&quot;../preprocessor/conditional&quot;&gt;#if or #elif&lt;/a&gt; must expand to.</source>
          <target state="translated">La expresi&amp;oacute;n que sigue a &lt;a href=&quot;../preprocessor/conditional&quot;&gt;#if o #elif&lt;/a&gt; debe expandirse a.</target>
        </trans-unit>
        <trans-unit id="fd397bb5ad1c715271d852321a59468dac4bf8e0" translate="yes" xml:space="preserve">
          <source>The expression in the middle of the conditional operator (between &lt;code&gt;?&lt;/code&gt; and &lt;code&gt;:&lt;/code&gt;) is parsed as if parenthesized: its precedence relative to &lt;code&gt;?:&lt;/code&gt; is ignored.</source>
          <target state="translated">La expresi&amp;oacute;n en el medio del operador condicional (entre &lt;code&gt;?&lt;/code&gt; Y &lt;code&gt;:&lt;/code&gt; ) se analiza como si entre par&amp;eacute;ntesis: su precedencia relativa a &lt;code&gt;?:&lt;/code&gt; Se ignora.</target>
        </trans-unit>
        <trans-unit id="6e6d20b10db31ec88b3330e05c431cfea6a343c7" translate="yes" xml:space="preserve">
          <source>The expression is a constant expression, using only &lt;a href=&quot;../language/expressions#Constants_and_literals&quot;&gt;constants&lt;/a&gt; and identifiers, defined using &lt;a href=&quot;replace&quot;&gt;&lt;code&gt; #define&lt;/code&gt;&lt;/a&gt; directive. Any identifier, which is not literal, non defined using &lt;a href=&quot;replace&quot;&gt;&lt;code&gt; #define&lt;/code&gt;&lt;/a&gt; directive, evaluates to</source>
          <target state="translated">La expresi&amp;oacute;n es una expresi&amp;oacute;n constante, que usa solo &lt;a href=&quot;../language/expressions#Constants_and_literals&quot;&gt;constantes&lt;/a&gt; e identificadores, definidos usando la directiva &lt;a href=&quot;replace&quot;&gt; &lt;code&gt; #define&lt;/code&gt; &lt;/a&gt; . Cualquier identificador, que no sea literal, no definido usando la directiva &lt;a href=&quot;replace&quot;&gt; &lt;code&gt; #define&lt;/code&gt; &lt;/a&gt; , se eval&amp;uacute;a como</target>
        </trans-unit>
        <trans-unit id="7442fe2fa76c716226a44ca97bfdfc72037a2ef9" translate="yes" xml:space="preserve">
          <source>The expression is evaluated, and its value, after &lt;a href=&quot;conversion&quot;&gt;conversion as if by assignment&lt;/a&gt; to the type of the object, becomes the initial value of the object being initialized.</source>
          <target state="translated">La expresi&amp;oacute;n se eval&amp;uacute;a y su valor, despu&amp;eacute;s de la &lt;a href=&quot;conversion&quot;&gt;conversi&amp;oacute;n, como por asignaci&amp;oacute;n&lt;/a&gt; al tipo de objeto, se convierte en el valor inicial del objeto que se est&amp;aacute; inicializando.</target>
        </trans-unit>
        <trans-unit id="324047fb5be1cb1232a316ce7dc9176cf6e8bad8" translate="yes" xml:space="preserve">
          <source>The expression lhs@=rhs is exactly the same as lhs&lt;code&gt;=&lt;/code&gt;lhs@&lt;code&gt;(&lt;/code&gt;rhs&lt;code&gt;)&lt;/code&gt;, except that lhs is evaluated only once.</source>
          <target state="translated">La expresi&amp;oacute;n lhs @ = rhs es exactamente la misma que lhs &lt;code&gt;=&lt;/code&gt; lhs @ &lt;code&gt;(&lt;/code&gt; rhs &lt;code&gt;)&lt;/code&gt; , excepto que lhs se eval&amp;uacute;a solo una vez.</target>
        </trans-unit>
        <trans-unit id="38f1c8c6b8733ef70e33511479b521ed6c4d5325" translate="yes" xml:space="preserve">
          <source>The expression may contain unary operators in form &lt;code&gt;defined&lt;/code&gt;identifier or &lt;code&gt;defined (&lt;/code&gt;identifier&lt;code&gt;)&lt;/code&gt; which return &lt;code&gt;1&lt;/code&gt; if the identifier was defined using &lt;a href=&quot;replace&quot;&gt;&lt;code&gt; #define&lt;/code&gt;&lt;/a&gt; directive and</source>
          <target state="translated">La expresi&amp;oacute;n puede contener operadores unarios en forma de identificador &lt;code&gt;defined&lt;/code&gt; o &lt;code&gt;defined (&lt;/code&gt; identificador &lt;code&gt;)&lt;/code&gt; que devuelve &lt;code&gt;1&lt;/code&gt; si el identificador se defini&amp;oacute; usando la directiva &lt;a href=&quot;replace&quot;&gt; &lt;code&gt; #define&lt;/code&gt; &lt;/a&gt; y</target>
        </trans-unit>
        <trans-unit id="609021b59f47fefb50869c57b0c8813d6a53f9c6" translate="yes" xml:space="preserve">
          <source>The expression statement used as loop_statement establishes its own block scope, distinct from the scope of init_clause, unlike in C++:</source>
          <target state="translated">La declaración de expresión utilizada como loop_statement establece su propio ámbito de bloque,distinto del ámbito de init_clause,a diferencia de lo que ocurre en C++:</target>
        </trans-unit>
        <trans-unit id="6e7851beccfe29b18d64f37c7c39bb8359a74916" translate="yes" xml:space="preserve">
          <source>The expressions are suitable for use as initializers for objects with static or thread storage duration, as long as the expressions &lt;code&gt;real&lt;/code&gt; and &lt;code&gt;imag&lt;/code&gt; are also suitable.</source>
          <target state="translated">Las expresiones son adecuadas para su uso como inicializadores para objetos con una duraci&amp;oacute;n de almacenamiento est&amp;aacute;tico o de subprocesos, siempre que las expresiones &lt;code&gt;real&lt;/code&gt; e &lt;code&gt;imag&lt;/code&gt; tambi&amp;eacute;n sean adecuadas.</target>
        </trans-unit>
        <trans-unit id="5e8e4ef756882f2ecb926b4da6aad7ade4184995" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;count&lt;/code&gt; characters of the transformed string are written to destination, including the terminating null character, and the length of the full transformed string is returned, excluding the terminating null character.</source>
          <target state="translated">Los primeros caracteres de &lt;code&gt;count&lt;/code&gt; de la cadena transformada se escriben en el destino, incluido el car&amp;aacute;cter nulo final, y se devuelve la longitud de la cadena transformada completa, excluyendo el car&amp;aacute;cter nulo final.</target>
        </trans-unit>
        <trans-unit id="097166e604623ecf948a99098da8c5eddd704203" translate="yes" xml:space="preserve">
          <source>The first argument of &lt;code&gt;_Static_assert&lt;/code&gt;</source>
          <target state="translated">El primer argumento de &lt;code&gt;_Static_assert&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="59d42cf5c59ef03d9f21e976e9211c12f3707cda" translate="yes" xml:space="preserve">
          <source>The first hexadecimal digit is not &lt;code&gt;0&lt;/code&gt; if the argument is a normalized floating point value. If the value is &lt;code&gt;​0​&lt;/code&gt;, the exponent is also &lt;code&gt;​0​&lt;/code&gt;.</source>
          <target state="translated">El primer d&amp;iacute;gito hexadecimal no es &lt;code&gt;0&lt;/code&gt; si el argumento es un valor de coma flotante normalizado. Si el valor es &lt;code&gt;​0​&lt;/code&gt; , el exponente es tambi&amp;eacute;n &lt;code&gt;​0​&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="85aefccf8c9b3c2cd0c976b63196e9f569cb09b9" translate="yes" xml:space="preserve">
          <source>The first of the following that applies:</source>
          <target state="translated">El primero de los siguientes que se aplica:</target>
        </trans-unit>
        <trans-unit id="1993f25515fdf5cf77175e2613e17a42e6c910c0" translate="yes" xml:space="preserve">
          <source>The first version orders memory accesses according to &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;, the second version orders memory accesses according to &lt;code&gt;order&lt;/code&gt;. &lt;code&gt;order&lt;/code&gt; must be one of &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_relaxed&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_consume&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_acquire&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;. Otherwise the behavior is undefined.</source>
          <target state="translated">La primera versi&amp;oacute;n ordena los accesos a la memoria seg&amp;uacute;n &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; , la segunda versi&amp;oacute;n ordena los accesos a la memoria seg&amp;uacute;n el &lt;code&gt;order&lt;/code&gt; . &lt;code&gt;order&lt;/code&gt; debe ser uno de &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_relaxed&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_consume&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_acquire&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; . De lo contrario, el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="3c052bc3e94706d81a135a07eebf60e086497cbe" translate="yes" xml:space="preserve">
          <source>The first version orders memory accesses according to &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;, the second version orders memory accesses according to &lt;code&gt;order&lt;/code&gt;. &lt;code&gt;order&lt;/code&gt; must be one of &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_relaxed&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_release&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;. Otherwise the behavior is undefined.</source>
          <target state="translated">La primera versi&amp;oacute;n ordena los accesos a la memoria seg&amp;uacute;n &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; , la segunda versi&amp;oacute;n ordena los accesos a la memoria seg&amp;uacute;n el &lt;code&gt;order&lt;/code&gt; . &lt;code&gt;order&lt;/code&gt; debe ser uno de &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_relaxed&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_release&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; . De lo contrario, el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="b7b4a6419bf1a2819ede3d443e7b61a16bea4d0c" translate="yes" xml:space="preserve">
          <source>The first write to that object through an lvalue that has a type other than character type, at which time the type of that lvalue becomes this object's</source>
          <target state="translated">El primero escribe a ese objeto a través de un valor que tiene un tipo diferente al tipo de carácter,en cuyo caso el tipo de ese valor se convierte en el de este objeto.</target>
        </trans-unit>
        <trans-unit id="ea51a875efb11ad49d51139f65a4fbab7c5f7404" translate="yes" xml:space="preserve">
          <source>The floating point conversion functions convert infinity to &lt;code&gt;inf&lt;/code&gt; or &lt;code&gt;infinity&lt;/code&gt;. Which one is used is implementation defined.</source>
          <target state="translated">Las funciones de conversi&amp;oacute;n de coma flotante convierten infinito en &lt;code&gt;inf&lt;/code&gt; o &lt;code&gt;infinity&lt;/code&gt; . El que se utiliza es la implementaci&amp;oacute;n definida.</target>
        </trans-unit>
        <trans-unit id="7a6247fea33eba71fac61a2b7cb4727c8281a459" translate="yes" xml:space="preserve">
          <source>The floating-point environment access and modification is only meaningful when &lt;a href=&quot;http://en.cppreference.com/w/cpp/preprocessor/impl.html&quot;&gt;&lt;code&gt; #pragma STDC FENV_ACCESS&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;ON&lt;/code&gt;. Otherwise the implementation is free to assume that floating-point control modes are always the default ones and that floating-point status flags are never tested or modified. In practice, few current compilers, such as HP aCC, Oracle Studio, and IBM XL, support the &lt;code&gt;#pragma&lt;/code&gt; explicitly, but most compilers allow meaningful access to the floating-point environment anyway.</source>
          <target state="translated">El acceso y modificaci&amp;oacute;n del entorno de punto flotante solo es significativo cuando &lt;a href=&quot;http://en.cppreference.com/w/cpp/preprocessor/impl.html&quot;&gt; &lt;code&gt; #pragma STDC FENV_ACCESS&lt;/code&gt; &lt;/a&gt; est&amp;aacute; configurado en &lt;code&gt;ON&lt;/code&gt; . De lo contrario, la implementaci&amp;oacute;n es libre de suponer que los modos de control de punto flotante son siempre los predeterminados y que los indicadores de estado de punto flotante nunca se prueban o modifican. En la pr&amp;aacute;ctica, pocos compiladores actuales, como HP aCC, Oracle Studio e IBM XL, admiten el &lt;code&gt;#pragma&lt;/code&gt; expl&amp;iacute;citamente, pero la mayor&amp;iacute;a de los compiladores permiten un acceso significativo al entorno de punto flotante de todos modos.</target>
        </trans-unit>
        <trans-unit id="d88a487f9a81a8c43facb1ab36c14a9792a2394f" translate="yes" xml:space="preserve">
          <source>The floating-point environment is the set of floating-point status flags and control modes supported by the implementation. It is thread-local, each thread inherits the initial state of its floating-point environment from the parent thread. Floating-point operations modify the floating-point status flags to indicate abnormal results or auxiliary information. The state of floating-point control modes affects the outcomes of some floating-point operations.</source>
          <target state="translated">El entorno de punto flotante es el conjunto de banderas de estado de punto flotante y modos de control que apoya la aplicación.Es un hilo local,cada hilo hereda el estado inicial de su entorno de punto flotante del hilo padre.Las operaciones en coma flotante modifican las banderas de estado de coma flotante para indicar resultados anormales o información auxiliar.El estado de los modos de control en punto flotante afecta a los resultados de algunas operaciones en punto flotante.</target>
        </trans-unit>
        <trans-unit id="1f30dcca8094f65496cbe7b9cb343a1867b9353f" translate="yes" xml:space="preserve">
          <source>The floating-point remainder of the division operation &lt;code&gt;x/y&lt;/code&gt; calculated by this function is exactly the value &lt;code&gt;x - n*y&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;x/y&lt;/code&gt; with its fractional part truncated.</source>
          <target state="translated">El resto de coma flotante de la operaci&amp;oacute;n de divisi&amp;oacute;n &lt;code&gt;x/y&lt;/code&gt; calculada por esta funci&amp;oacute;n es exactamente el valor &lt;code&gt;x - n*y&lt;/code&gt; , donde &lt;code&gt;n&lt;/code&gt; es &lt;code&gt;x/y&lt;/code&gt; con su parte fraccionaria truncada.</target>
        </trans-unit>
        <trans-unit id="9c564c91cc056f54f98f41b5fb84e49fa91ab18b" translate="yes" xml:space="preserve">
          <source>The following additional keywords are classified as extensions and conditionally-supported:</source>
          <target state="translated">Las siguientes palabras clave adicionales están clasificadas como extensiones y apoyadas condicionalmente:</target>
        </trans-unit>
        <trans-unit id="01d1b47f4e938983cec3203a558177551122e45b" translate="yes" xml:space="preserve">
          <source>The following additional macro names may be predefined by an implementation:</source>
          <target state="translated">Los siguientes nombres de macros adicionales pueden ser predefinidos por una aplicación:</target>
        </trans-unit>
        <trans-unit id="53267feddb0a903c8317f2f0976951442dab290e" translate="yes" xml:space="preserve">
          <source>The following alternative tokens are part of the core language, and, in all respects of the language, each alternative token behaves exactly the same as its primary token, except for its spelling (the &lt;a href=&quot;../preprocessor/replace&quot;&gt;stringification operator&lt;/a&gt; can make the spelling visible). The two-letter alternative tokens are sometimes called &quot;digraphs&quot;</source>
          <target state="translated">Los siguientes tokens alternativos son parte del lenguaje principal y, en todos los aspectos del lenguaje, cada token alternativo se comporta exactamente igual que su token primario, excepto por su ortograf&amp;iacute;a (el &lt;a href=&quot;../preprocessor/replace&quot;&gt;operador de stringificaci&amp;oacute;n&lt;/a&gt; puede hacer que la ortograf&amp;iacute;a sea visible). Las fichas alternativas de dos letras a veces se llaman &quot;d&amp;iacute;grafos&quot;</target>
        </trans-unit>
        <trans-unit id="2314e69040372621d3d5adf2b163840d6d43e0d3" translate="yes" xml:space="preserve">
          <source>The following aspects of the preprocessor can be controlled:</source>
          <target state="translated">Se pueden controlar los siguientes aspectos del preprocesador:</target>
        </trans-unit>
        <trans-unit id="bf5ea285c72c7d87a0b9f0ab566e300cf0d96f2e" translate="yes" xml:space="preserve">
          <source>The following chart contains all 128 ASCII decimal &lt;b&gt;(dec)&lt;/b&gt;, octal &lt;b&gt;(oct)&lt;/b&gt;, hexadecimal &lt;b&gt;(hex)&lt;/b&gt; and character &lt;b&gt;(ch)&lt;/b&gt; codes.</source>
          <target state="translated">La siguiente tabla contiene los 128 c&amp;oacute;digos ASCII decimales &lt;b&gt;(dec)&lt;/b&gt; , octales &lt;b&gt;(oct)&lt;/b&gt; , hexadecimales &lt;b&gt;(hexadecimales)&lt;/b&gt; y de caracteres &lt;b&gt;(ch)&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="96fdf8bcc92fd6fc1514e41f0d3d41b7c151059a" translate="yes" xml:space="preserve">
          <source>The following code redirects &lt;code&gt;stdout&lt;/code&gt; to a file.</source>
          <target state="translated">El siguiente c&amp;oacute;digo redirige &lt;code&gt;stdout&lt;/code&gt; a un archivo.</target>
        </trans-unit>
        <trans-unit id="ffbdf2342c1f96b0209b527d82df9863ea30a28c" translate="yes" xml:space="preserve">
          <source>The following code sets and resets the stream orientation.</source>
          <target state="translated">El siguiente código establece y restablece la orientación de la corriente.</target>
        </trans-unit>
        <trans-unit id="02b64fd2a82723acdd75ab79f9a274ca5cba5ba7" translate="yes" xml:space="preserve">
          <source>The following errors are detected at runtime and call the currently installed &lt;a href=&quot;../error/set_constraint_handler_s&quot;&gt;constraint handler&lt;/a&gt; function:</source>
          <target state="translated">Los siguientes errores se detectan en tiempo de ejecuci&amp;oacute;n y llaman a la funci&amp;oacute;n de &lt;a href=&quot;../error/set_constraint_handler_s&quot;&gt;controlador de restricciones&lt;/a&gt; actualmente instalada :</target>
        </trans-unit>
        <trans-unit id="3f0df48cae22b33977db026831f1533dc1eac83e" translate="yes" xml:space="preserve">
          <source>The following escape sequences are available. ISO C requires a diagnostic if the backslash is followed by any character not listed here:</source>
          <target state="translated">Las siguientes secuencias de escape están disponibles.La ISO C requiere un diagnóstico si la barra invertida va seguida de algún carácter no listado aquí:</target>
        </trans-unit>
        <trans-unit id="0463db8b7489f2f607fc0fb87c855f442b9abbeb" translate="yes" xml:space="preserve">
          <source>The following example demonstrates alternative operator spellings from the &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; header as well as use of digraphs and trigraphs. The space character in the first command-line argument, argv[1], requires the quotation marks: &quot;, World!&quot;.</source>
          <target state="translated">El siguiente ejemplo muestra la ortograf&amp;iacute;a de operadores alternativos del encabezado &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; , as&amp;iacute; como el uso de d&amp;iacute;grafos y trigrafos. El car&amp;aacute;cter de espacio en el primer argumento de l&amp;iacute;nea de comandos, argv [1], requiere las comillas: &quot;, &amp;iexcl;Mundo!&quot;.</target>
        </trans-unit>
        <trans-unit id="287a73bdcb331ffbabd28ac365a0f69ce0862305" translate="yes" xml:space="preserve">
          <source>The following expressions are lvalues:</source>
          <target state="translated">Las siguientes expresiones son valores:</target>
        </trans-unit>
        <trans-unit id="829cc0f70c42a8b870ad4b5e87e195960641456e" translate="yes" xml:space="preserve">
          <source>The following expressions are non-lvalue object expressions:</source>
          <target state="translated">Las siguientes expresiones son expresiones de objetos sin valor:</target>
        </trans-unit>
        <trans-unit id="2cfaf8e14e19bf31aee96ca79b4b825e2d169ca6" translate="yes" xml:space="preserve">
          <source>The following floating-point error conditions are recognized:</source>
          <target state="translated">Se reconocen las siguientes condiciones de error en punto flotante:</target>
        </trans-unit>
        <trans-unit id="bd4f90abfd9c4aaea62c390400d56b7eb617f8af" translate="yes" xml:space="preserve">
          <source>The following format specifiers are available:</source>
          <target state="translated">Se dispone de los siguientes especificadores de formato:</target>
        </trans-unit>
        <trans-unit id="1c8aa77024587faa413de9da508229e9cf4a51fc" translate="yes" xml:space="preserve">
          <source>The following function names are reserved for future addition to &lt;code&gt;complex.h&lt;/code&gt; and are not available for use in the programs that include that header: &lt;code&gt;cerf&lt;/code&gt;, &lt;code&gt;cerfc&lt;/code&gt;, &lt;code&gt;cexp2&lt;/code&gt;, &lt;code&gt;cexpm1&lt;/code&gt;, &lt;code&gt;clog10&lt;/code&gt;, &lt;code&gt;clog1p&lt;/code&gt;, &lt;code&gt;clog2&lt;/code&gt;, &lt;code&gt;clgamma&lt;/code&gt;, and &lt;code&gt;ctgamma&lt;/code&gt;, along with their -f and -l suffixed variants.</source>
          <target state="translated">Los siguientes nombres de funciones est&amp;aacute;n reservados para futuras adiciones a &lt;code&gt;complex.h&lt;/code&gt; y no est&amp;aacute;n disponibles para su uso en los programas que incluyen ese encabezado: &lt;code&gt;cerf&lt;/code&gt; , &lt;code&gt;cerfc&lt;/code&gt; , &lt;code&gt;cexp2&lt;/code&gt; , &lt;code&gt;cexpm1&lt;/code&gt; , &lt;code&gt;clog10&lt;/code&gt; , &lt;code&gt;clog1p&lt;/code&gt; , &lt;code&gt;clog2&lt;/code&gt; , &lt;code&gt;clgamma&lt;/code&gt; y &lt;code&gt;ctgamma&lt;/code&gt; , junto con su - f y -l variantes con sufijo.</target>
        </trans-unit>
        <trans-unit id="2f18389086be3ef835c51e9ad36c08bb8badaac5" translate="yes" xml:space="preserve">
          <source>The following functions are &lt;code&gt;noreturn&lt;/code&gt; in the standard library:</source>
          <target state="translated">Las siguientes funciones son &lt;code&gt;noreturn&lt;/code&gt; en la biblioteca est&amp;aacute;ndar:</target>
        </trans-unit>
        <trans-unit id="c5a591d9fa5638aac9fa2b83e82338a91618a78a" translate="yes" xml:space="preserve">
          <source>The following functions manage program termination and resource cleanup.</source>
          <target state="translated">Las siguientes funciones gestionan la terminación del programa y la limpieza de los recursos.</target>
        </trans-unit>
        <trans-unit id="7f554e67755443645ddea4d0c9f686b445b59a7f" translate="yes" xml:space="preserve">
          <source>The following functions should not be called from multiple threads without synchronization with the &lt;code&gt;mbstate_t*&lt;/code&gt; argument of &lt;code&gt;NULL&lt;/code&gt; due to possible data races: &lt;code&gt;&lt;a href=&quot;mbrlen&quot;&gt;mbrlen&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;mbrtowc&quot;&gt;mbrtowc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;mbsrtowcs&quot;&gt;mbsrtowcs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;mbtowc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;wcrtomb&quot;&gt;wcrtomb&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;wcsrtombs&quot;&gt;wcsrtombs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;wctomb&quot;&gt;wctomb&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Las siguientes funciones no deben ser llamados desde varios subprocesos sin sincronizaci&amp;oacute;n con el &lt;code&gt;mbstate_t*&lt;/code&gt; argumento de &lt;code&gt;NULL&lt;/code&gt; debido a posibles carreras de datos: &lt;code&gt;&lt;a href=&quot;mbrlen&quot;&gt;mbrlen&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;mbrtowc&quot;&gt;mbrtowc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;mbsrtowcs&quot;&gt;mbsrtowcs&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;mbtowc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;wcrtomb&quot;&gt;wcrtomb&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;wcsrtombs&quot;&gt;wcsrtombs&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;wctomb&quot;&gt;wctomb&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1674823b2b9c702abeb414373c5461775fcadedb" translate="yes" xml:space="preserve">
          <source>The following identifiers are</source>
          <target state="translated">Los siguientes identificadores son</target>
        </trans-unit>
        <trans-unit id="52747f8b268619d42bfc41249c2443bf02dfb375" translate="yes" xml:space="preserve">
          <source>The following limitations are imposed on the user-defined function that is installed as a signal handler.</source>
          <target state="translated">Las siguientes limitaciones se imponen a la función definida por el usuario que se instala como manejador de señales.</target>
        </trans-unit>
        <trans-unit id="60a246baccbe5a74a2372f3123a79e57ab1d8a6e" translate="yes" xml:space="preserve">
          <source>The following macro names are predefined in any translation unit:</source>
          <target state="translated">Los siguientes nombres de macros están predefinidos en cualquier unidad de traducción:</target>
        </trans-unit>
        <trans-unit id="760cdc8623d4deb346e101e369ccc8511374acd9" translate="yes" xml:space="preserve">
          <source>The following program computes the number of seconds that have passed since the beginning of the month.</source>
          <target state="translated">El siguiente programa calcula el número de segundos que han pasado desde el comienzo del mes.</target>
        </trans-unit>
        <trans-unit id="9ff275c825fa1a87d99185f365a34ebec03469ef" translate="yes" xml:space="preserve">
          <source>The following properties of bit fields are</source>
          <target state="translated">Las siguientes propiedades de los campos de bits son</target>
        </trans-unit>
        <trans-unit id="50ffe5d9875553429026debf7cff7fd09bf924b6" translate="yes" xml:space="preserve">
          <source>The following table lists the precedence and associativity of C operators. Operators are listed top to bottom, in descending precedence.</source>
          <target state="translated">En el siguiente cuadro se enumeran la precedencia y la asociatividad de los operadores C.Los operadores se enumeran de arriba a abajo,en precedencia descendente.</target>
        </trans-unit>
        <trans-unit id="8aa536e53d4635c03c483d42ad9b70a227480cbe" translate="yes" xml:space="preserve">
          <source>The following table provides a reference for the limits of common numeric representations. As the C Standard allows any signed integer representation, the table gives both the minimum guaranteed requirements (which correspond to the limits of &lt;a href=&quot;https://en.wikipedia.org/wiki/One%27s_complement&quot;&gt;one's complement&lt;/a&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Signed_number_representations#Sign-and-magnitude_method&quot;&gt;sign-and-magnitude&lt;/a&gt;) and the limits of the most commonly used implementation, &lt;a href=&quot;https://en.wikipedia.org/wiki/Two%27s_complement&quot;&gt;two's complement&lt;/a&gt;. All popular data models (including all of ILP32, LP32, LP64, LLP64) use two's complement representation, though.</source>
          <target state="translated">La siguiente tabla proporciona una referencia para los l&amp;iacute;mites de las representaciones num&amp;eacute;ricas comunes. Como el Est&amp;aacute;ndar C permite cualquier representaci&amp;oacute;n entera con signo, la tabla proporciona los requisitos m&amp;iacute;nimos garantizados (que corresponden a los l&amp;iacute;mites del &lt;a href=&quot;https://en.wikipedia.org/wiki/One%27s_complement&quot;&gt;complemento&lt;/a&gt; o &lt;a href=&quot;https://en.wikipedia.org/wiki/Signed_number_representations#Sign-and-magnitude_method&quot;&gt;signo y magnitud de uno&lt;/a&gt; ) y los l&amp;iacute;mites de la implementaci&amp;oacute;n m&amp;aacute;s com&amp;uacute;nmente utilizada, &lt;a href=&quot;https://en.wikipedia.org/wiki/Two%27s_complement&quot;&gt;el complemento a dos&lt;/a&gt; . Sin embargo, todos los modelos de datos populares (incluidos todos los ILP32, LP32, LP64, LLP64) usan la representaci&amp;oacute;n del complemento a dos.</target>
        </trans-unit>
        <trans-unit id="a901e9b7792340a20dc3a26c920d9911c931da64" translate="yes" xml:space="preserve">
          <source>The following table summarizes all available integer types and their properties:</source>
          <target state="translated">En el siguiente cuadro se resumen todos los tipos de números enteros disponibles y sus propiedades:</target>
        </trans-unit>
        <trans-unit id="3f6d452f86036275cf545aa6c2fd879d6ea70e67" translate="yes" xml:space="preserve">
          <source>The following three pragmas are defined by the language standard:</source>
          <target state="translated">Los siguientes tres pragmas están definidos por la norma de lenguaje:</target>
        </trans-unit>
        <trans-unit id="acc57bf9778baf29a073665323a0c5976c6a1f23" translate="yes" xml:space="preserve">
          <source>The following three-character groups (trigraphs) are &lt;a href=&quot;translation_phases&quot;&gt;parsed before comments and string literals are recognized&lt;/a&gt;, and each appearance of a trigraph is replaced by the corresponding primary character:</source>
          <target state="translated">Los siguientes grupos de tres caracteres (trigraphs) se &lt;a href=&quot;translation_phases&quot;&gt;analizan antes de que se reconozcan los comentarios y los literales de cadena&lt;/a&gt; , y cada aparici&amp;oacute;n de un trigraph se reemplaza por el car&amp;aacute;cter primario correspondiente:</target>
        </trans-unit>
        <trans-unit id="e2546fbb06c0a729787bc6cd7125e1b5361e4578" translate="yes" xml:space="preserve">
          <source>The following tokens are recognized by the &lt;a href=&quot;preprocessor&quot;&gt;preprocessor&lt;/a&gt; when they are used</source>
          <target state="translated">Los siguientes tokens son reconocidos por el &lt;a href=&quot;preprocessor&quot;&gt;preprocesador&lt;/a&gt; cuando se usan</target>
        </trans-unit>
        <trans-unit id="4f3e2b4ce9621498219d1ebd6d8fb04d675b973c" translate="yes" xml:space="preserve">
          <source>The following tokens are recognized by the preprocessor when they are used</source>
          <target state="translated">El preprocesador reconoce las siguientes fichas cuando se utilizan</target>
        </trans-unit>
        <trans-unit id="259ef24e493d7f7eee6e3b99062deb09c3faa2fa" translate="yes" xml:space="preserve">
          <source>The following two declarations declare the same function:</source>
          <target state="translated">Las dos declaraciones siguientes declaran la misma función:</target>
        </trans-unit>
        <trans-unit id="05238738a8d9e70dab6db4701b54bdcd606eef3b" translate="yes" xml:space="preserve">
          <source>The following types are incomplete:</source>
          <target state="translated">Los siguientes tipos están incompletos:</target>
        </trans-unit>
        <trans-unit id="05263cedaa87adae4404e0d5d0d5c6012425b488" translate="yes" xml:space="preserve">
          <source>The following values of &lt;code&gt;str&lt;/code&gt; are supported in all C locales:</source>
          <target state="translated">Los siguientes valores de &lt;code&gt;str&lt;/code&gt; son compatibles con todas las configuraciones regionales de C:</target>
        </trans-unit>
        <trans-unit id="5c29167a05bd707a804eef66e8a46280899a02a0" translate="yes" xml:space="preserve">
          <source>The following variables are initialized to the same value:</source>
          <target state="translated">Las siguientes variables se inicializan con el mismo valor:</target>
        </trans-unit>
        <trans-unit id="f68fcc28a98f3dfdaf45ebc2e1785811a6a9fe23" translate="yes" xml:space="preserve">
          <source>The format of &lt;code&gt;filename&lt;/code&gt; is implementation-defined, and does not necessarily refer to a file (e.g. it may be the console or another device accessible though filesystem API). On platforms that support them, &lt;code&gt;filename&lt;/code&gt; may include absolute or relative filesystem path.</source>
          <target state="translated">El formato del &lt;code&gt;filename&lt;/code&gt; de archivo est&amp;aacute; definido por la implementaci&amp;oacute;n y no necesariamente se refiere a un archivo (por ejemplo, puede ser la consola u otro dispositivo accesible a trav&amp;eacute;s de la API del sistema de archivos). En las plataformas que los admiten, el &lt;code&gt;filename&lt;/code&gt; puede incluir la ruta absoluta o relativa del sistema de archivos.</target>
        </trans-unit>
        <trans-unit id="93ac56cdaeeb6de79fc364f4fe683f408e59c3e6" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../string/byte/strtof&quot;&gt;&lt;code&gt;strtof()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El formato del n&amp;uacute;mero es el mismo que el esperado por &lt;a href=&quot;../string/byte/strtof&quot;&gt; &lt;code&gt;strtof()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8f0ad27913f478ab70d1cc2d0e0549d118103730" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../string/byte/strtol&quot;&gt;&lt;code&gt;strtol()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;10&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">El formato del n&amp;uacute;mero es el mismo que el esperado por &lt;a href=&quot;../string/byte/strtol&quot;&gt; &lt;code&gt;strtol()&lt;/code&gt; &lt;/a&gt; con el valor &lt;code&gt;10&lt;/code&gt; para el argumento &lt;code&gt;base&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="671556fcedcbcc40a3b072fd7bffc45f2fbccd26" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../string/byte/strtol&quot;&gt;&lt;code&gt;strtol()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;​0​&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument (base is determined by the first characters parsed).</source>
          <target state="translated">El formato del n&amp;uacute;mero es el mismo como se esperaba por &lt;a href=&quot;../string/byte/strtol&quot;&gt; &lt;code&gt;strtol()&lt;/code&gt; &lt;/a&gt; con el valor &lt;code&gt;​0​&lt;/code&gt; para la &lt;code&gt;base&lt;/code&gt; de argumento (base est&amp;aacute; determinada por los primeros caracteres analizados).</target>
        </trans-unit>
        <trans-unit id="b7b4201164d0bc303ec63a1d04f289d249202a0f" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../string/byte/strtoul&quot;&gt;&lt;code&gt;strtoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;10&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">El formato del n&amp;uacute;mero es el mismo que el esperado por &lt;a href=&quot;../string/byte/strtoul&quot;&gt; &lt;code&gt;strtoul()&lt;/code&gt; &lt;/a&gt; con el valor &lt;code&gt;10&lt;/code&gt; para el argumento &lt;code&gt;base&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b718549b02c9a87887915199e47e1a005bfae44" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../string/byte/strtoul&quot;&gt;&lt;code&gt;strtoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;16&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">El formato del n&amp;uacute;mero es el mismo que el esperado por &lt;a href=&quot;../string/byte/strtoul&quot;&gt; &lt;code&gt;strtoul()&lt;/code&gt; &lt;/a&gt; con el valor &lt;code&gt;16&lt;/code&gt; para el argumento &lt;code&gt;base&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2555a9003a37354d6399908418d0705063de50cf" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../string/byte/strtoul&quot;&gt;&lt;code&gt;strtoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;8&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">El formato del n&amp;uacute;mero es el mismo que el esperado por &lt;a href=&quot;../string/byte/strtoul&quot;&gt; &lt;code&gt;strtoul()&lt;/code&gt; &lt;/a&gt; con el valor &lt;code&gt;8&lt;/code&gt; para el argumento &lt;code&gt;base&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="92789305795f1eb56d034465a61e558a6506280d" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../string/wide/wcstof&quot;&gt;&lt;code&gt;wcstof()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El formato del n&amp;uacute;mero es el mismo que el esperado por &lt;a href=&quot;../string/wide/wcstof&quot;&gt; &lt;code&gt;wcstof()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="51860d6c8145c8370c4b642d4fc1c22a2186f998" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../string/wide/wcstol&quot;&gt;&lt;code&gt;wcstol()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;10&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">El formato del n&amp;uacute;mero es el mismo que el esperado por &lt;a href=&quot;../string/wide/wcstol&quot;&gt; &lt;code&gt;wcstol()&lt;/code&gt; &lt;/a&gt; con el valor &lt;code&gt;10&lt;/code&gt; para el argumento &lt;code&gt;base&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b523e0c8748ab9c5e972ec8245b3621fc4041002" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../string/wide/wcstol&quot;&gt;&lt;code&gt;wcstol()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;​0​&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument (base is determined by the first characters parsed).</source>
          <target state="translated">El formato del n&amp;uacute;mero es el mismo como se esperaba por &lt;a href=&quot;../string/wide/wcstol&quot;&gt; &lt;code&gt;wcstol()&lt;/code&gt; &lt;/a&gt; con el valor &lt;code&gt;​0​&lt;/code&gt; para la &lt;code&gt;base&lt;/code&gt; de argumento (base est&amp;aacute; determinada por los primeros caracteres analizados).</target>
        </trans-unit>
        <trans-unit id="f0aa77172a8536624fd5ee996fa4b09d9c154130" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../string/wide/wcstoul&quot;&gt;&lt;code&gt;wcstoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;10&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">El formato del n&amp;uacute;mero es el mismo que el esperado por &lt;a href=&quot;../string/wide/wcstoul&quot;&gt; &lt;code&gt;wcstoul()&lt;/code&gt; &lt;/a&gt; con el valor &lt;code&gt;10&lt;/code&gt; para el argumento &lt;code&gt;base&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76408fd6762baa6a334ed1b0697b3874e7fb1be4" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../string/wide/wcstoul&quot;&gt;&lt;code&gt;wcstoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;16&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">El formato del n&amp;uacute;mero es el mismo que el esperado por &lt;a href=&quot;../string/wide/wcstoul&quot;&gt; &lt;code&gt;wcstoul()&lt;/code&gt; &lt;/a&gt; con el valor &lt;code&gt;16&lt;/code&gt; para el argumento &lt;code&gt;base&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9b9db29e262a1c1455a0e82dbd508a761aa0601" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../string/wide/wcstoul&quot;&gt;&lt;code&gt;wcstoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;8&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">El formato del n&amp;uacute;mero es el mismo que el esperado por &lt;a href=&quot;../string/wide/wcstoul&quot;&gt; &lt;code&gt;wcstoul()&lt;/code&gt; &lt;/a&gt; con el valor &lt;code&gt;8&lt;/code&gt; para el argumento &lt;code&gt;base&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d9e18bdb76f0cfc72cfc7220ca845cba830ae2b" translate="yes" xml:space="preserve">
          <source>The format string consists of ordinary multibyte characters (except &lt;code&gt;%&lt;/code&gt;), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:</source>
          <target state="translated">La cadena de formato consta de caracteres multibyte normales (excepto &lt;code&gt;%&lt;/code&gt; ), que se copian sin cambios en la secuencia de salida y las especificaciones de conversi&amp;oacute;n. Cada especificaci&amp;oacute;n de conversi&amp;oacute;n tiene el siguiente formato:</target>
        </trans-unit>
        <trans-unit id="978f5198d804b9a4148d59f23d49bd19f235af7b" translate="yes" xml:space="preserve">
          <source>The format string consists of ordinary wide characters (except &lt;code&gt;%&lt;/code&gt;), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:</source>
          <target state="translated">La cadena de formato consta de caracteres anchos normales (excepto &lt;code&gt;%&lt;/code&gt; ), que se copian sin cambios en la secuencia de salida y las especificaciones de conversi&amp;oacute;n. Cada especificaci&amp;oacute;n de conversi&amp;oacute;n tiene el siguiente formato:</target>
        </trans-unit>
        <trans-unit id="77ae2a1ebbf9dfc51f6f5d5f89c9ab7a18fe650c" translate="yes" xml:space="preserve">
          <source>The format string consists of zero or more conversion specifiers and ordinary characters (except &lt;code&gt;%&lt;/code&gt;). All ordinary characters, including the terminating null character, are copied to the output string without modification. Each conversion specification begins with &lt;code&gt;%&lt;/code&gt; character, optionally followed by &lt;code&gt;E&lt;/code&gt; or &lt;code&gt;O&lt;/code&gt; modifier (ignored if unsupported by the locale), followed by the character that determines the behavior of the specifier. The following format specifiers are available:</source>
          <target state="translated">La cadena de formato consta de cero o m&amp;aacute;s especificadores de conversi&amp;oacute;n y caracteres ordinarios (excepto &lt;code&gt;%&lt;/code&gt; ). Todos los caracteres ordinarios, incluido el car&amp;aacute;cter nulo final, se copian a la cadena de salida sin modificaci&amp;oacute;n. Cada especificaci&amp;oacute;n de conversi&amp;oacute;n comienza con el car&amp;aacute;cter &lt;code&gt;%&lt;/code&gt; , seguido opcionalmente por el modificador &lt;code&gt;E&lt;/code&gt; u &lt;code&gt;O&lt;/code&gt; (ignorado si la configuraci&amp;oacute;n regional no lo admite), seguido del car&amp;aacute;cter que determina el comportamiento del especificador. Los siguientes especificadores de formato est&amp;aacute;n disponibles:</target>
        </trans-unit>
        <trans-unit id="5d35574333561b6d7197206a894209f7b4dca21b" translate="yes" xml:space="preserve">
          <source>The format string consists of.</source>
          <target state="translated">El formato de la cadena consiste en.</target>
        </trans-unit>
        <trans-unit id="ed94452fd5320f29fe790ddccc946a60d3be8519" translate="yes" xml:space="preserve">
          <source>The fractional part is discarded (truncated towards zero).</source>
          <target state="translated">La parte fraccionaria se descarta (truncada hacia cero).</target>
        </trans-unit>
        <trans-unit id="f1e777bed230647173e4ad51c340e8839794d4c2" translate="yes" xml:space="preserve">
          <source>The full contents of a floating-point exception flag is not necessarily a boolean value indicating whether the exception is raised or cleared. For example, it may be a struct which includes the boolean status and the address of the code that triggered the exception. These functions obtain all such content and obtain/store it in &lt;code&gt;flagp&lt;/code&gt; in implementation-defined format.</source>
          <target state="translated">El contenido completo de un indicador de excepci&amp;oacute;n de punto flotante no es necesariamente un valor booleano que indica si la excepci&amp;oacute;n se activa o desactiva. Por ejemplo, puede ser una estructura que incluye el estado booleano y la direcci&amp;oacute;n del c&amp;oacute;digo que activ&amp;oacute; la excepci&amp;oacute;n. Estas funciones obtienen todo ese contenido y lo obtienen / almacenan en &lt;code&gt;flagp&lt;/code&gt; en formato definido por la implementaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="96e76a18348bd7140463f4991aabb39103dce3cf" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;frexp&lt;/code&gt;, together with its dual, &lt;code&gt;&lt;a href=&quot;ldexp&quot;&gt;ldexp&lt;/a&gt;&lt;/code&gt;, can be used to manipulate the representation of a floating-point number without direct bit manipulations.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;frexp&lt;/code&gt; , junto con su dual, &lt;code&gt;&lt;a href=&quot;ldexp&quot;&gt;ldexp&lt;/a&gt;&lt;/code&gt; , se puede utilizar para manipular la representaci&amp;oacute;n de un n&amp;uacute;mero de punto flotante sin manipulaciones directas de bits.</target>
        </trans-unit>
        <trans-unit id="17196b905a44e0edee51205b99ccb0d4ea314cc3" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;ldexp&lt;/code&gt; (&quot;load exponent&quot;), together with its dual, &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;frexp&lt;/a&gt;&lt;/code&gt;, can be used to manipulate the representation of a floating-point number without direct bit manipulations.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;ldexp&lt;/code&gt; (&quot;exponente de carga&quot;), junto con su dual, &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;frexp&lt;/a&gt;&lt;/code&gt; , se puede utilizar para manipular la representaci&amp;oacute;n de un n&amp;uacute;mero de punto flotante sin manipulaciones directas de bits.</target>
        </trans-unit>
        <trans-unit id="4ffdf9ae1184af0302bbd32d7e4f00be8f426782" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;strcat_s&lt;/code&gt; is similar to the BSD function &lt;code&gt;strlcat&lt;/code&gt;, except that.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;strcat_s&lt;/code&gt; es similar a la funci&amp;oacute;n BSD &lt;code&gt;strlcat&lt;/code&gt; , excepto eso.</target>
        </trans-unit>
        <trans-unit id="0efd9ecc68a30f292c27629dda09e33a1b504eaf" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;strcpy_s&lt;/code&gt; is similar to the BSD function &lt;code&gt;strlcpy&lt;/code&gt;, except that.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;strcpy_s&lt;/code&gt; es similar a la funci&amp;oacute;n BSD &lt;code&gt;strlcpy&lt;/code&gt; , excepto que.</target>
        </trans-unit>
        <trans-unit id="720e67ae7cff5823d2274d70efa49b7c85aa1156" translate="yes" xml:space="preserve">
          <source>The function accepts (and does nothing with) the null pointer to reduce the amount of special-casing. Whether allocation succeeds or not, the pointer returned by an allocation function can be passed to &lt;code&gt;free()&lt;/code&gt;.</source>
          <target state="translated">La funci&amp;oacute;n acepta (y no hace nada con) el puntero nulo para reducir la cantidad de may&amp;uacute;sculas y min&amp;uacute;sculas. Si la asignaci&amp;oacute;n tiene &amp;eacute;xito o no, el puntero devuelto por una funci&amp;oacute;n de asignaci&amp;oacute;n se puede pasar a &lt;code&gt;free()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c8b1015abb293307d6cda96134dccb409db2cd8" translate="yes" xml:space="preserve">
          <source>The function call expression has the form.</source>
          <target state="translated">La expresión de la llamada de la función tiene la forma.</target>
        </trans-unit>
        <trans-unit id="126f425397cb45dc94e0836b07e8eefad9995278" translate="yes" xml:space="preserve">
          <source>The function does not support localization, and the newline character cannot be removed.</source>
          <target state="translated">La función no admite la localización y no se puede eliminar el carácter de nueva línea.</target>
        </trans-unit>
        <trans-unit id="072cec0bee6f6155df5b228611698b2538fe2d6d" translate="yes" xml:space="preserve">
          <source>The function does not support localization.</source>
          <target state="translated">La función no apoya la localización.</target>
        </trans-unit>
        <trans-unit id="d3171de1fa826c9d265134dad86a77ff176be6f3" translate="yes" xml:space="preserve">
          <source>The function drops any effects from previous calls to &lt;code&gt;&lt;a href=&quot;ungetc&quot;&gt;ungetc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">La funci&amp;oacute;n elimina cualquier efecto de llamadas anteriores a &lt;code&gt;&lt;a href=&quot;ungetc&quot;&gt;ungetc&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23ccd8cd43cb3d597e337e15d54fe5c87828b3ec" translate="yes" xml:space="preserve">
          <source>The function has mathematical poles at &amp;pi;(1/2 + n); however no common floating-point representation is able to represent &amp;pi;/2 exactly, thus there is no value of the argument for which a pole error occurs.</source>
          <target state="translated">La funci&amp;oacute;n tiene polos matem&amp;aacute;ticos en &amp;pi; (1/2 + n); sin embargo, ninguna representaci&amp;oacute;n com&amp;uacute;n de punto flotante puede representar &amp;pi; / 2 exactamente, por lo tanto, no hay ning&amp;uacute;n valor del argumento para el cual se produce un error de polo.</target>
        </trans-unit>
        <trans-unit id="af880fe541df16b2fd4a74d41e9903882d62887d" translate="yes" xml:space="preserve">
          <source>The function is continuous onto the branch cut taking into account the sign of imaginary part</source>
          <target state="translated">La función es continua en el corte de la rama teniendo en cuenta el signo de la parte imaginaria</target>
        </trans-unit>
        <trans-unit id="e2fe121470076dfe7dca9614b38a83d97b455692" translate="yes" xml:space="preserve">
          <source>The function is equivalent to &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;fseek&lt;/a&gt;(stream, 0, &lt;a href=&quot;../io&quot;&gt;SEEK_SET&lt;/a&gt;);&lt;/code&gt;, except that end-of-file and error indicators are cleared.</source>
          <target state="translated">La funci&amp;oacute;n es equivalente a &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;fseek&lt;/a&gt;(stream, 0, &lt;a href=&quot;../io&quot;&gt;SEEK_SET&lt;/a&gt;);&lt;/code&gt; , excepto que se borran los indicadores de fin de archivo y error.</target>
        </trans-unit>
        <trans-unit id="89f55932afa3e6e418ba772b0aaec318f66a0359" translate="yes" xml:space="preserve">
          <source>The function is implemented as a macro. &lt;code&gt;A&lt;/code&gt; is the type of &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">La funci&amp;oacute;n se implementa como una macro. &lt;code&gt;A&lt;/code&gt; es el tipo de &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15af0ce237ff3b3144c6a868b8ee125006a14e71" translate="yes" xml:space="preserve">
          <source>The function modifies static storage and is not thread-safe.</source>
          <target state="translated">La función modifica el almacenamiento estático y no es segura para los hilos.</target>
        </trans-unit>
        <trans-unit id="bc27df1dece75c7950d8306c4124d7ab25b1a17f" translate="yes" xml:space="preserve">
          <source>The function must not modify the objects passed to it and must return consistent results when called for the same objects, regardless of their positions in the array.</source>
          <target state="translated">La función no debe modificar los objetos que se le pasan y debe devolver resultados consistentes cuando se le piden los mismos objetos,independientemente de su posición en la matriz.</target>
        </trans-unit>
        <trans-unit id="08d9155e7bdfa1ab71dea3775710a903a49a673c" translate="yes" xml:space="preserve">
          <source>The function name stands for &quot;complementary span&quot; because the function searches for characters not found in &lt;code&gt;src&lt;/code&gt;, that is the complement of &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">El nombre de la funci&amp;oacute;n significa &quot;espacio complementario&quot; porque la funci&amp;oacute;n busca caracteres que no se encuentran en &lt;code&gt;src&lt;/code&gt; , que es el complemento de &lt;code&gt;src&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58af6034860fd87af855232a56a774834e007602" translate="yes" xml:space="preserve">
          <source>The function simply returns to the caller without performing any other action.</source>
          <target state="translated">La función simplemente vuelve a la persona que llama sin realizar ninguna otra acción.</target>
        </trans-unit>
        <trans-unit id="7c3559ff21a7ec0a87fd87249ee0c6ee1ced4a14" translate="yes" xml:space="preserve">
          <source>The function then returns the pointer to the beginning of the token</source>
          <target state="translated">La función entonces devuelve el puntero al principio de la ficha</target>
        </trans-unit>
        <trans-unit id="9c5eafec853997f8ec44f631d7a03573e4237d1e" translate="yes" xml:space="preserve">
          <source>The function to call is determined as follows:</source>
          <target state="translated">La función a llamar se determina de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="6257fd0e7140666f722f4b319f1c0f01eedf826a" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;&lt;a href=&quot;expm1&quot;&gt;expm1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;log1p&lt;/code&gt; are useful for financial calculations, for example, when calculating small daily interest rates: (1+x)n</source>
          <target state="translated">Las funciones &lt;code&gt;&lt;a href=&quot;expm1&quot;&gt;expm1&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;log1p&lt;/code&gt; son &amp;uacute;tiles para c&amp;aacute;lculos financieros, por ejemplo, al calcular peque&amp;ntilde;as tasas de inter&amp;eacute;s diarias: (1 + x) n</target>
        </trans-unit>
        <trans-unit id="0bac96adb11f232384a0a833a8c3ab44e75559c8" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;expm1&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;log1p&quot;&gt;log1p&lt;/a&gt;&lt;/code&gt; are useful for financial calculations, for example, when calculating small daily interest rates: (1+x)n</source>
          <target state="translated">Las funciones &lt;code&gt;expm1&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;log1p&quot;&gt;log1p&lt;/a&gt;&lt;/code&gt; son &amp;uacute;tiles para c&amp;aacute;lculos financieros, por ejemplo, al calcular peque&amp;ntilde;as tasas de inter&amp;eacute;s diarias: (1 + x) n</target>
        </trans-unit>
        <trans-unit id="ecc38b545ed39f36edc888e0a1aadedeb651989b" translate="yes" xml:space="preserve">
          <source>The functions registered with &lt;code&gt;&lt;a href=&quot;at_quick_exit&quot;&gt;at_quick_exit&lt;/a&gt;&lt;/code&gt; are not called.</source>
          <target state="translated">Las funciones registradas con &lt;code&gt;&lt;a href=&quot;at_quick_exit&quot;&gt;at_quick_exit&lt;/a&gt;&lt;/code&gt; no se llaman.</target>
        </trans-unit>
        <trans-unit id="3db16cc57db5dbc928e64b1b6ac3975c579a8b6a" translate="yes" xml:space="preserve">
          <source>The functions sets the pointer pointed to by &lt;code&gt;endptr&lt;/code&gt; to point to the character past the last character interpreted. If &lt;code&gt;endptr&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, it is ignored.</source>
          <target state="translated">Las funciones configuran el puntero al que apunta &lt;code&gt;endptr&lt;/code&gt; para se&amp;ntilde;alar el car&amp;aacute;cter pasado el &amp;uacute;ltimo car&amp;aacute;cter interpretado. Si &lt;code&gt;endptr&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; , se ignora.</target>
        </trans-unit>
        <trans-unit id="79e95f56658767e1e470d9215d4b6600bf8174e3" translate="yes" xml:space="preserve">
          <source>The functions sets the pointer pointed to by &lt;code&gt;endptr&lt;/code&gt; to point to the wide character past the last character interpreted. If &lt;code&gt;endptr&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, it is ignored.</source>
          <target state="translated">Las funciones configuran el puntero al que apunta &lt;code&gt;endptr&lt;/code&gt; para se&amp;ntilde;alar el car&amp;aacute;cter ancho m&amp;aacute;s all&amp;aacute; del &amp;uacute;ltimo car&amp;aacute;cter interpretado. Si &lt;code&gt;endptr&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; , se ignora.</target>
        </trans-unit>
        <trans-unit id="69ad6824d6f8c048fddeb1809adb4e0dadf9dc71" translate="yes" xml:space="preserve">
          <source>The functions sets the pointer pointed to by &lt;code&gt;str_end&lt;/code&gt; to point to the character past the last character interpreted. If &lt;code&gt;str_end&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, it is ignored.</source>
          <target state="translated">Las funciones establecen el puntero al que apunta &lt;code&gt;str_end&lt;/code&gt; para se&amp;ntilde;alar el car&amp;aacute;cter pasado el &amp;uacute;ltimo car&amp;aacute;cter interpretado. Si &lt;code&gt;str_end&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; , se ignora.</target>
        </trans-unit>
        <trans-unit id="9c7ec7a3aab98e1d97256af5eb3cd5dd8ac9ef4b" translate="yes" xml:space="preserve">
          <source>The functions sets the pointer pointed to by &lt;code&gt;str_end&lt;/code&gt; to point to the wide character past the last character interpreted. If &lt;code&gt;str_end&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, it is ignored.</source>
          <target state="translated">Las funciones establecen el puntero al que apunta &lt;code&gt;str_end&lt;/code&gt; para se&amp;ntilde;alar el car&amp;aacute;cter ancho m&amp;aacute;s all&amp;aacute; del &amp;uacute;ltimo car&amp;aacute;cter interpretado. Si &lt;code&gt;str_end&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; , se ignora.</target>
        </trans-unit>
        <trans-unit id="64603c7c7d2bc52bc986d70787386849f4ce71ed" translate="yes" xml:space="preserve">
          <source>The handler must be a pointer to function of type &lt;code&gt;constraint_handler_t&lt;/code&gt;, which is defined as.</source>
          <target state="translated">El controlador debe ser un puntero para funcionar de tipo &lt;code&gt;constraint_handler_t&lt;/code&gt; , que se define como.</target>
        </trans-unit>
        <trans-unit id="2b274cb694448d1bfa9bf6c931f75319a1e0a7aa" translate="yes" xml:space="preserve">
          <source>The header &lt;code&gt;&amp;lt;stdatomic.h&amp;gt;&lt;/code&gt; defines &lt;a href=&quot;../atomic&quot;&gt;37 convenience macros&lt;/a&gt;, from &lt;code&gt;&lt;a href=&quot;../atomic&quot;&gt;atomic_bool&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;../atomic&quot;&gt;atomic_uintmax_t&lt;/a&gt;&lt;/code&gt;, which simplify the use of this keyword with built-in and library types.</source>
          <target state="translated">El encabezado &lt;code&gt;&amp;lt;stdatomic.h&amp;gt;&lt;/code&gt; define &lt;a href=&quot;../atomic&quot;&gt;37 macros de conveniencia&lt;/a&gt; , desde &lt;code&gt;&lt;a href=&quot;../atomic&quot;&gt;atomic_bool&lt;/a&gt;&lt;/code&gt; a &lt;code&gt;&lt;a href=&quot;../atomic&quot;&gt;atomic_uintmax_t&lt;/a&gt;&lt;/code&gt; , que simplifican el uso de esta palabra clave con tipos incorporados y de biblioteca.</target>
        </trans-unit>
        <trans-unit id="74ddd8d38d4b8564e2c354808a42090ee373e9e1" translate="yes" xml:space="preserve">
          <source>The header &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; includes the headers &lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; and defines several type-generic macros that determine which real or, when applicable, complex function to call based on the types of the arguments.</source>
          <target state="translated">El encabezado &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; incluye los encabezados &lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt; y &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; y define varias macros de tipo gen&amp;eacute;rico que determinan qu&amp;eacute; funci&amp;oacute;n real o, cuando corresponde, compleja llamar seg&amp;uacute;n los tipos de argumentos.</target>
        </trans-unit>
        <trans-unit id="93ad7272aaadf98b5dfc20eafa318d853f619946" translate="yes" xml:space="preserve">
          <source>The header &lt;code&gt;complex.h&lt;/code&gt; provides types and functions about &lt;a href=&quot;numeric/complex&quot;&gt;complex numbers&lt;/a&gt;.</source>
          <target state="translated">El encabezado &lt;code&gt;complex.h&lt;/code&gt; proporciona tipos y funciones sobre &lt;a href=&quot;numeric/complex&quot;&gt;n&amp;uacute;meros complejos&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="388aaf76829951120a17be67c04fd86012fafcdd" translate="yes" xml:space="preserve">
          <source>The header &lt;code&gt;fenv.h&lt;/code&gt; defines &lt;a href=&quot;numeric/fenv&quot;&gt;flags and functions related to exceptional floating-point state&lt;/a&gt;, such as overflow and division by zero.</source>
          <target state="translated">El encabezado &lt;code&gt;fenv.h&lt;/code&gt; define &lt;a href=&quot;numeric/fenv&quot;&gt;indicadores y funciones relacionadas con un estado excepcional de coma flotante&lt;/a&gt; , como desbordamiento y divisi&amp;oacute;n por cero.</target>
        </trans-unit>
        <trans-unit id="07cc9e76a5e563d564e013252f3f732aeac63c6e" translate="yes" xml:space="preserve">
          <source>The header &lt;code&gt;math.h&lt;/code&gt; provides &lt;a href=&quot;numeric/math&quot;&gt;standard C library mathematical functions&lt;/a&gt; such as &lt;code&gt;&lt;a href=&quot;numeric/math/fabs&quot;&gt;fabs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;numeric/math/sqrt&quot;&gt;sqrt&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;numeric/math/sin&quot;&gt;sin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">El encabezado &lt;code&gt;math.h&lt;/code&gt; proporciona &lt;a href=&quot;numeric/math&quot;&gt;funciones matem&amp;aacute;ticas est&amp;aacute;ndar de la biblioteca C&lt;/a&gt; , como &lt;code&gt;&lt;a href=&quot;numeric/math/fabs&quot;&gt;fabs&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;numeric/math/sqrt&quot;&gt;sqrt&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;numeric/math/sin&quot;&gt;sin&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79610cd72ab9bda5e0cc9559f891b46b03619e71" translate="yes" xml:space="preserve">
          <source>The header &lt;code&gt;stdlib.h&lt;/code&gt; also includes C-style random number generation via &lt;code&gt;&lt;a href=&quot;numeric/random/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;numeric/random/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">El encabezado &lt;code&gt;stdlib.h&lt;/code&gt; tambi&amp;eacute;n incluye la generaci&amp;oacute;n de n&amp;uacute;meros aleatorios de estilo C a trav&amp;eacute;s de &lt;code&gt;&lt;a href=&quot;numeric/random/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;numeric/random/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9fc356d62136302dae71ff7d5b64387ba61e65f6" translate="yes" xml:space="preserve">
          <source>The header &lt;code&gt;tgmath.h&lt;/code&gt; provides some macros for a function which names XXX:</source>
          <target state="translated">El encabezado &lt;code&gt;tgmath.h&lt;/code&gt; proporciona algunas macros para una funci&amp;oacute;n que nombra XXX:</target>
        </trans-unit>
        <trans-unit id="024bdd2fc5e7f5dd7775a84e539446cdbb9cc19a" translate="yes" xml:space="preserve">
          <source>The identifier itself, if used, becomes the name of the enumerated type in the tags &lt;a href=&quot;name_space&quot;&gt;name space&lt;/a&gt; and requires the use of the keyword enum (unless typedef'd into the ordinary name space).</source>
          <target state="translated">El identificador en s&amp;iacute;, si se usa, se convierte en el nombre del tipo enumerado en el &lt;a href=&quot;name_space&quot;&gt;espacio de nombre de&lt;/a&gt; las etiquetas y requiere el uso de la palabra clave enum (a menos que typedef'd en el espacio de nombre ordinario).</target>
        </trans-unit>
        <trans-unit id="037a292514cf5762093c51f94e41b9f7f76bc8ff" translate="yes" xml:space="preserve">
          <source>The identifier of the calling thread.</source>
          <target state="translated">El identificador del hilo de llamada.</target>
        </trans-unit>
        <trans-unit id="9f2ec11eb7cd3993bbc0fbdd3a84fd4d32466d57" translate="yes" xml:space="preserve">
          <source>The imaginary constant</source>
          <target state="translated">La constante imaginaria</target>
        </trans-unit>
        <trans-unit id="9e1eb1c62e8a76621e675ea472f278a7a95b40c1" translate="yes" xml:space="preserve">
          <source>The imaginary numbers make it possible to express all complex numbers using the natural notation &lt;code&gt;x + I*y&lt;/code&gt; (where &lt;code&gt;I&lt;/code&gt; is defined as &lt;code&gt;&lt;a href=&quot;../numeric/complex/imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt;). Without imaginary types, certain special complex values cannot be created naturally. For example, if &lt;code&gt;I&lt;/code&gt; is defined as &lt;code&gt;&lt;a href=&quot;../numeric/complex/complex_i&quot;&gt;_Complex_I&lt;/a&gt;&lt;/code&gt;, then writing &lt;code&gt;0.0 + I*INFINITY&lt;/code&gt; gives NaN as the real part, and &lt;code&gt;&lt;a href=&quot;../numeric/complex/cmplx&quot;&gt;CMPLX&lt;/a&gt;(0.0, INFINITY)&lt;/code&gt; must be used instead. Same goes for the numbers with the negative zero imaginary component, which are meaningful when working with the library functions with branch cuts, such as &lt;code&gt;&lt;a href=&quot;../numeric/complex/csqrt&quot;&gt;csqrt&lt;/a&gt;&lt;/code&gt;: &lt;code&gt;1.0 - 0.0*I&lt;/code&gt; results in the positive zero imaginary component if &lt;code&gt;I&lt;/code&gt; is defined as &lt;code&gt;&lt;a href=&quot;../numeric/complex/complex_i&quot;&gt;_Complex_I&lt;/a&gt;&lt;/code&gt; and the negative zero imaginary part requires the use of &lt;code&gt;&lt;a href=&quot;../numeric/complex/cmplx&quot;&gt;CMPLX&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../numeric/complex/conj&quot;&gt;conj&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Los n&amp;uacute;meros imaginarios hacen posible expresar todos los n&amp;uacute;meros complejos utilizando la notaci&amp;oacute;n natural &lt;code&gt;x + I*y&lt;/code&gt; (donde &lt;code&gt;I&lt;/code&gt; se define como &lt;code&gt;&lt;a href=&quot;../numeric/complex/imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt; ). Sin tipos imaginarios, ciertos valores complejos especiales no pueden crearse naturalmente. Por ejemplo, si &lt;code&gt;I&lt;/code&gt; se define como &lt;code&gt;&lt;a href=&quot;../numeric/complex/complex_i&quot;&gt;_Complex_I&lt;/a&gt;&lt;/code&gt; , entonces escribir &lt;code&gt;0.0 + I*INFINITY&lt;/code&gt; da NaN como la parte real, y &lt;code&gt;&lt;a href=&quot;../numeric/complex/cmplx&quot;&gt;CMPLX&lt;/a&gt;(0.0, INFINITY)&lt;/code&gt; debe usarse en su lugar. Lo mismo ocurre con los n&amp;uacute;meros con el componente imaginario negativo cero, que son significativos cuando se trabaja con las funciones de la biblioteca con cortes de ramificaci&amp;oacute;n, como &lt;code&gt;&lt;a href=&quot;../numeric/complex/csqrt&quot;&gt;csqrt&lt;/a&gt;&lt;/code&gt; : &lt;code&gt;1.0 - 0.0*I&lt;/code&gt; da como resultado el componente imaginario cero positivo si &lt;code&gt;I&lt;/code&gt; se define como &lt;code&gt;&lt;a href=&quot;../numeric/complex/complex_i&quot;&gt;_Complex_I&lt;/a&gt;&lt;/code&gt; y la parte imaginaria negativa cero requiere el uso de &lt;code&gt;&lt;a href=&quot;../numeric/complex/cmplx&quot;&gt;CMPLX&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../numeric/complex/conj&quot;&gt;conj&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b55efabcd8849ef60ae8f5ea3a08febcffd5cd21" translate="yes" xml:space="preserve">
          <source>The imaginary part is discarded</source>
          <target state="translated">La parte imaginaria se descarta</target>
        </trans-unit>
        <trans-unit id="597104ddba845ce9bd24aa6877ef6907f2382360" translate="yes" xml:space="preserve">
          <source>The imaginary part of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">La parte imaginaria de &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20a99abb7396bbd40ee3b035ec1eb049a07d6192" translate="yes" xml:space="preserve">
          <source>The imaginary part of the result follows the conversion rules for the corresponding real types</source>
          <target state="translated">La parte imaginaria del resultado sigue las reglas de conversión para los tipos reales correspondientes</target>
        </trans-unit>
        <trans-unit id="09714acfb208e9f9b257f3045c35d573a30525df" translate="yes" xml:space="preserve">
          <source>The imaginary part of the result is positive zero (or unsigned zero on non-IEEE systems)</source>
          <target state="translated">La parte imaginaria del resultado es el cero positivo (o el cero sin signo en los sistemas no IEEE)</target>
        </trans-unit>
        <trans-unit id="dc1a01ff9f1f5abac042b758d317c3db71ae72ed" translate="yes" xml:space="preserve">
          <source>The implementation is guaranteed to support the registration of at least &lt;code&gt;32&lt;/code&gt; functions. The exact limit is implementation-defined.</source>
          <target state="translated">La implementaci&amp;oacute;n est&amp;aacute; garantizada para soportar el registro de al menos &lt;code&gt;32&lt;/code&gt; funciones. El l&amp;iacute;mite exacto est&amp;aacute; definido por la implementaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d883b4e1722e4a8d3caa8bc74366a237fa4929ec" translate="yes" xml:space="preserve">
          <source>The implementation may define additional macro constants in &lt;code&gt;&amp;lt;fenv.h&amp;gt;&lt;/code&gt; to identify additional floating-point exceptions. All such constants begin with &lt;code&gt;FE_&lt;/code&gt; followed by at least one uppercase letter.</source>
          <target state="translated">La implementaci&amp;oacute;n puede definir constantes macro adicionales en &lt;code&gt;&amp;lt;fenv.h&amp;gt;&lt;/code&gt; para identificar excepciones adicionales de punto flotante. Todas esas constantes comienzan con &lt;code&gt;FE_&lt;/code&gt; seguido de al menos una letra may&amp;uacute;scula.</target>
        </trans-unit>
        <trans-unit id="eee59aa77f4b166942e6841c23ab435c8ebfde79" translate="yes" xml:space="preserve">
          <source>The implicit conversion from floating-point to integral types also rounds towards zero, but is limited to the values that can be represented by the target type.</source>
          <target state="translated">La conversión implícita de los tipos de punto flotante a integral también se redondea hacia cero,pero se limita a los valores que pueden ser representados por el tipo de objetivo.</target>
        </trans-unit>
        <trans-unit id="d244055efbceb9cd116b307d0068bd03d7ccf1f4" translate="yes" xml:space="preserve">
          <source>The index in an &lt;a href=&quot;array_initialization&quot;&gt;array designator&lt;/a&gt;</source>
          <target state="translated">El &amp;iacute;ndice en un &lt;a href=&quot;array_initialization&quot;&gt;designador de matriz&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5e82d0a49cb26cac8606496f3b74019e4f5bd7ab" translate="yes" xml:space="preserve">
          <source>The initial value of atomic object of automatic storage duration that is not explicitly initialized using this macro(until C17) is indeterminate. The default (zero) initialization of static and thread-local variables produces a valid value however.</source>
          <target state="translated">El valor inicial del objeto atómico de duración de almacenamiento automático que no se inicializa explícitamente con esta macro (hasta el C17)es indeterminado.Sin embargo,la inicialización por defecto (cero)de las variables estáticas y de las variables locales del hilo produce un valor válido.</target>
        </trans-unit>
        <trans-unit id="c14bd019aca2383204e2ad83d047789a2c7ba54e" translate="yes" xml:space="preserve">
          <source>The initial values of function parameters are established as if by assignment from the arguments of a &lt;a href=&quot;operator_other#Function_call&quot;&gt;function call&lt;/a&gt;, rather than by initialization.</source>
          <target state="translated">Los valores iniciales de los par&amp;aacute;metros de funci&amp;oacute;n se establecen como por asignaci&amp;oacute;n a partir de los argumentos de una &lt;a href=&quot;operator_other#Function_call&quot;&gt;llamada a funci&amp;oacute;n&lt;/a&gt; , en lugar de por inicializaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f79095678450b261a7d4377d1d69bb99aef817af" translate="yes" xml:space="preserve">
          <source>The initializer for a scalar (an object of integer type including booleans and enumerated types, floating type including complex and imaginary, and pointer type including pointer to function) must be a single expression, optionally enclosed in braces:</source>
          <target state="translated">El inicializador de un escalar (un objeto de tipo entero que incluye booleanos y tipos enumerados,de tipo flotante que incluye complejos e imaginarios,y de tipo puntero que incluye puntero a la función)debe ser una expresión única,opcionalmente encerrada entre corchetes:</target>
        </trans-unit>
        <trans-unit id="051643a6443136c90c153854e9479f16f32a9c1c" translate="yes" xml:space="preserve">
          <source>The initializer list may have a trailing comma, which is ignored.</source>
          <target state="translated">La lista de inicialización puede tener una coma final,que se ignora.</target>
        </trans-unit>
        <trans-unit id="a21f21c29b1dd53223eceae658fd8c0f4adf0abb" translate="yes" xml:space="preserve">
          <source>The initializer specifies the initial value stored in an object.</source>
          <target state="translated">El inicializador especifica el valor inicial almacenado en un objeto.</target>
        </trans-unit>
        <trans-unit id="5dc8e20b4e5a968131b73c499de88baceffe7987" translate="yes" xml:space="preserve">
          <source>The initializers of the variables with automatic &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; declared inside a block and the VLA declarators are executed when flow of control passes over these declarations in order, as if they were statements:</source>
          <target state="translated">Los inicializadores de las variables con &lt;a href=&quot;storage_duration&quot;&gt;duraci&amp;oacute;n de almacenamiento&lt;/a&gt; autom&amp;aacute;tico declarados dentro de un bloque y los declaradores de VLA se ejecutan cuando el flujo de control pasa sobre estas declaraciones en orden, como si fueran declaraciones:</target>
        </trans-unit>
        <trans-unit id="3d0d426c073cbcb4ac70cff904892f38bd7c72ae" translate="yes" xml:space="preserve">
          <source>The integer argument of &lt;code&gt;_Alignas&lt;/code&gt;</source>
          <target state="translated">El argumento entero de &lt;code&gt;_Alignas&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c052ad8a76feca9c20921855c2130e125e23b1b8" translate="yes" xml:space="preserve">
          <source>The intended use of the restrict qualifier (like the register storage class) is to promote optimization, and deleting all instances of the qualifier from all preprocessing translation units composing a conforming program does not change its meaning (i.e., observable behavior).</source>
          <target state="translated">El uso previsto del calificador restringido (como la clase de almacenamiento de registros)es promover la optimización,y la eliminación de todas las instancias del calificador de todas las unidades de traducción de preprocesamiento que componen un programa de conformidad no cambia su significado (es decir,el comportamiento observable).</target>
        </trans-unit>
        <trans-unit id="3461dd13d361fb9e7a46ff0b4396f48813e4b6bc" translate="yes" xml:space="preserve">
          <source>The intent of the &lt;code&gt;inline&lt;/code&gt; specifier is to serve as a hint for the compiler to perform optimizations, such as function inlining, which require the definition of a function to be visible at the call site. The compilers can (and usually do) ignore presence or absence of the &lt;code&gt;inline&lt;/code&gt; specifier for the purpose of optimization.</source>
          <target state="translated">La intenci&amp;oacute;n del especificador en &lt;code&gt;inline&lt;/code&gt; es servir como una pista para que el compilador realice optimizaciones, como la funci&amp;oacute;n en l&amp;iacute;nea, que requieren que la definici&amp;oacute;n de una funci&amp;oacute;n sea visible en el sitio de la llamada. Los compiladores pueden (y generalmente lo hacen) ignorar la presencia o ausencia del especificador en &lt;code&gt;inline&lt;/code&gt; para fines de optimizaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c6924d561fcec2a25cafd9f30b6ce9d38cd1a4d2" translate="yes" xml:space="preserve">
          <source>The introduction of // comments in C99 was a breaking change in some rare circumstances:</source>
          <target state="translated">La introducción de los comentarios //en el C99 fue un cambio radical en algunas raras circunstancias:</target>
        </trans-unit>
        <trans-unit id="94b5c297f476b2d4707fabdba8af9c74ed678810" translate="yes" xml:space="preserve">
          <source>The invocation of &lt;code&gt;setjmp&lt;/code&gt; must appear only in one of the following contexts:</source>
          <target state="translated">La invocaci&amp;oacute;n de &lt;code&gt;setjmp&lt;/code&gt; debe aparecer solo en uno de los siguientes contextos:</target>
        </trans-unit>
        <trans-unit id="df73dd5056e900e6ab07fe7d785f7316167ce7e1" translate="yes" xml:space="preserve">
          <source>The iteration statements repeatedly execute a statement.</source>
          <target state="translated">Las declaraciones iterativas ejecutan repetidamente una declaración.</target>
        </trans-unit>
        <trans-unit id="5cbe65a328ae1a1725e46d04473058103fa2038a" translate="yes" xml:space="preserve">
          <source>The jump statements unconditionally transfer flow control.</source>
          <target state="translated">Las declaraciones de salto transfieren incondicionalmente el control del flujo.</target>
        </trans-unit>
        <trans-unit id="f512905bc0e7bcf8e0a06a3d543ae75331a9386b" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;_Thread_local&lt;/code&gt; is usually used through the convenience macro &lt;code&gt;&lt;a href=&quot;../thread/thread_local&quot;&gt;thread_local&lt;/a&gt;&lt;/code&gt;, defined in the header &lt;code&gt;threads.h&lt;/code&gt;.</source>
          <target state="translated">La palabra clave &lt;code&gt;_Thread_local&lt;/code&gt; generalmente se usa a trav&amp;eacute;s de la conveniente macro &lt;code&gt;&lt;a href=&quot;../thread/thread_local&quot;&gt;thread_local&lt;/a&gt;&lt;/code&gt; , definida en el encabezado &lt;code&gt;threads.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c10772b161d3dd40c9407a3fdf1ba40e6710ac1e" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;typedef&lt;/code&gt; is used in a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt;, in the grammatical position of a &lt;a href=&quot;storage_duration&quot;&gt;storage-class specifier&lt;/a&gt;, except that it does not affect storage or linkage:</source>
          <target state="translated">La palabra clave &lt;code&gt;typedef&lt;/code&gt; se usa en una &lt;a href=&quot;declarations&quot;&gt;declaraci&amp;oacute;n&lt;/a&gt; , en la posici&amp;oacute;n gramatical de un &lt;a href=&quot;storage_duration&quot;&gt;especificador de clase de almacenamiento&lt;/a&gt; , excepto que no afecta el almacenamiento o el enlace:</target>
        </trans-unit>
        <trans-unit id="38e6ce2423b10435fec95359cfc7871356cc7655" translate="yes" xml:space="preserve">
          <source>The largest representable floating-point values are exact integers in all standard floating-point formats, so &lt;code&gt;nearbyint&lt;/code&gt; never overflows on its own; however the result may overflow any integer type (including &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;intmax_t&lt;/a&gt;&lt;/code&gt;), when stored in an integer variable.</source>
          <target state="translated">Los valores de punto flotante representables m&amp;aacute;s grandes son n&amp;uacute;meros enteros exactos en todos los formatos est&amp;aacute;ndar de punto flotante, por lo que la &lt;code&gt;nearbyint&lt;/code&gt; nunca se desborda por s&amp;iacute; sola; sin embargo, el resultado puede desbordar cualquier tipo de entero (incluido &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;intmax_t&lt;/a&gt;&lt;/code&gt; ), cuando se almacena en una variable entera.</target>
        </trans-unit>
        <trans-unit id="b5db95457fd00b5137fae42ae0ad03c02ab7b1d9" translate="yes" xml:space="preserve">
          <source>The largest representable floating-point values are exact integers in all standard floating-point formats, so &lt;code&gt;rint&lt;/code&gt; never overflows on its own; however the result may overflow any integer type (including &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;intmax_t&lt;/a&gt;&lt;/code&gt;), when stored in an integer variable.</source>
          <target state="translated">Los valores de punto flotante representables m&amp;aacute;s grandes son enteros exactos en todos los formatos est&amp;aacute;ndar de punto flotante, por lo que el &lt;code&gt;rint&lt;/code&gt; nunca se desborda por s&amp;iacute; solo; sin embargo, el resultado puede desbordar cualquier tipo de entero (incluido &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;intmax_t&lt;/a&gt;&lt;/code&gt; ), cuando se almacena en una variable entera.</target>
        </trans-unit>
        <trans-unit id="32f6d5a8dd3178b9f5f93350efdb40176e9f37c4" translate="yes" xml:space="preserve">
          <source>The largest representable floating-point values are exact integers in all standard floating-point formats, so &lt;code&gt;round&lt;/code&gt; never overflows on its own; however the result may overflow any integer type (including &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;intmax_t&lt;/a&gt;&lt;/code&gt;), when stored in an integer variable.</source>
          <target state="translated">Los valores de punto flotante representables m&amp;aacute;s grandes son enteros exactos en todos los formatos est&amp;aacute;ndar de punto flotante, por lo que la &lt;code&gt;round&lt;/code&gt; nunca se desborda por s&amp;iacute; sola; sin embargo, el resultado puede desbordar cualquier tipo de entero (incluido &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;intmax_t&lt;/a&gt;&lt;/code&gt; ), cuando se almacena en una variable entera.</target>
        </trans-unit>
        <trans-unit id="2394bacc13a55aabca9c891a3369daa891fec410" translate="yes" xml:space="preserve">
          <source>The largest representable floating-point values are exact integers in all standard floating-point formats, so this function never overflows on its own; however the result may overflow any integer type (including &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;intmax_t&lt;/a&gt;&lt;/code&gt;), when stored in an integer variable.</source>
          <target state="translated">Los valores de punto flotante representables m&amp;aacute;s grandes son enteros exactos en todos los formatos est&amp;aacute;ndar de punto flotante, por lo que esta funci&amp;oacute;n nunca se desborda por s&amp;iacute; sola; sin embargo, el resultado puede desbordar cualquier tipo de entero (incluido &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;intmax_t&lt;/a&gt;&lt;/code&gt; ), cuando se almacena en una variable entera.</target>
        </trans-unit>
        <trans-unit id="c4390732ceb72a7d86e32c5b0b0e5852ccc329b7" translate="yes" xml:space="preserve">
          <source>The length of the maximum initial segment that contains only characters from the null-terminated byte string pointed to by &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">La longitud del segmento inicial m&amp;aacute;ximo que contiene solo caracteres de la cadena de bytes terminada en nulo a la que apunta &lt;code&gt;src&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63de454d6ebc822ff35b5de2988085c7a2c0e23c" translate="yes" xml:space="preserve">
          <source>The length of the maximum initial segment that contains only characters from wide string pointed to by &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">La longitud del segmento inicial m&amp;aacute;ximo que contiene solo caracteres de una cadena ancha a la que apunta &lt;code&gt;src&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f772a2bec6f10a883f7267bd67367b712ef3954" translate="yes" xml:space="preserve">
          <source>The length of the maximum initial segment that contains only characters not found in the character string pointed to by &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">La longitud del segmento inicial m&amp;aacute;ximo que contiene solo caracteres que no se encuentran en la cadena de caracteres se&amp;ntilde;alada por &lt;code&gt;src&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ba41a49e5fa46c983e71aed0b7bf8c8cf2bcd61" translate="yes" xml:space="preserve">
          <source>The length of the maximum initial segment that contains only characters not found in the null-terminated byte string pointed to by &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">La longitud del segmento inicial m&amp;aacute;ximo que contiene solo caracteres que no se encuentran en la cadena de bytes terminada en nulo a la que apunta &lt;code&gt;src&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="593d216bcb63cbce0afb160433d1ab015cf4835d" translate="yes" xml:space="preserve">
          <source>The length of the transformed string, not including the terminating null-character.</source>
          <target state="translated">La longitud de la cuerda transformada,sin incluir el carácter nulo de terminación.</target>
        </trans-unit>
        <trans-unit id="e3b3ec34feef4d29ba71c02ffc289279c3d65e7e" translate="yes" xml:space="preserve">
          <source>The length of the transformed wide string, not including the terminating null-character.</source>
          <target state="translated">La longitud de la cuerda ancha transformada,sin incluir el carácter nulo de terminación.</target>
        </trans-unit>
        <trans-unit id="049923770e49e0dc29c177e486ea5da1a8510445" translate="yes" xml:space="preserve">
          <source>The library type &lt;code&gt;&lt;a href=&quot;../program/sig_atomic_t&quot;&gt;sig_atomic_t&lt;/a&gt;&lt;/code&gt; does not provide inter-thread synchronization or memory ordering, only atomicity.</source>
          <target state="translated">El tipo de biblioteca &lt;code&gt;&lt;a href=&quot;../program/sig_atomic_t&quot;&gt;sig_atomic_t&lt;/a&gt;&lt;/code&gt; no proporciona sincronizaci&amp;oacute;n entre subprocesos u ordenamiento de memoria, solo atomicidad.</target>
        </trans-unit>
        <trans-unit id="6e7074b32735e8bf688f9281dcebfc831011f3a5" translate="yes" xml:space="preserve">
          <source>The line number following the directive &lt;code&gt;#line __LINE__&lt;/code&gt; is implementation-defined (there are two possible values that __LINE__ can expand to in this case: number of endlines seen so far, or number of endlines seen so far plus the endline that ends the #line directive).</source>
          <target state="translated">El n&amp;uacute;mero de l&amp;iacute;nea que sigue a la directiva &lt;code&gt;#line __LINE__&lt;/code&gt; est&amp;aacute; definido por la implementaci&amp;oacute;n (hay dos valores posibles a los que __LINE__ puede expandirse en este caso: n&amp;uacute;mero de l&amp;iacute;neas finales vistas hasta ahora, o n&amp;uacute;mero de l&amp;iacute;neas finales vistas hasta ahora m&amp;aacute;s la l&amp;iacute;nea final que termina la # l&amp;iacute;nea directiva).</target>
        </trans-unit>
        <trans-unit id="784e7ee73ce693765b5c5ba90815e9b87d11972a" translate="yes" xml:space="preserve">
          <source>The logical AND expression has the form.</source>
          <target state="translated">La expresión lógica Y tiene la forma.</target>
        </trans-unit>
        <trans-unit id="6d04b7b384fbd368de9e9b44a07a158efbdffa63" translate="yes" xml:space="preserve">
          <source>The logical NOT expression has the form.</source>
          <target state="translated">La expresión lógica NO tiene la forma.</target>
        </trans-unit>
        <trans-unit id="00f39c867b0308cf432ff2ac9d19a03a4ddb3431" translate="yes" xml:space="preserve">
          <source>The logical NOT operator has type &lt;code&gt;int&lt;/code&gt;. Its value is &lt;code&gt;​0​&lt;/code&gt; if expression evaluates to a value that compares unequal to zero. Its value is &lt;code&gt;1&lt;/code&gt; if expression evaluates to a value that compares equal to zero. (so &lt;code&gt;!E&lt;/code&gt; is the same as &lt;code&gt;(0==E)&lt;/code&gt;).</source>
          <target state="translated">El operador l&amp;oacute;gico NOT tiene el tipo &lt;code&gt;int&lt;/code&gt; . Su valor es &lt;code&gt;​0​&lt;/code&gt; si la expresi&amp;oacute;n se eval&amp;uacute;a a un valor que compara desigual a cero. Su valor es &lt;code&gt;1&lt;/code&gt; si la expresi&amp;oacute;n se eval&amp;uacute;a como un valor que se compara igual a cero. ( &lt;code&gt;!E&lt;/code&gt; es lo mismo que &lt;code&gt;(0==E)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fa0017b25e29a52a58370b61f25df5eb44b294a7" translate="yes" xml:space="preserve">
          <source>The logical OR expression has the form.</source>
          <target state="translated">La expresión OR lógica tiene la forma.</target>
        </trans-unit>
        <trans-unit id="8cfbb57750fb5f7112ff7e65f25d43235885b786" translate="yes" xml:space="preserve">
          <source>The logical-AND operator has type &lt;code&gt;int&lt;/code&gt; and the value &lt;code&gt;1&lt;/code&gt; if both lhs and rhs compare unequal to zero. It has the value &lt;code&gt;​0​&lt;/code&gt; otherwise (if either lhs or rhs or both compare equal to zero).</source>
          <target state="translated">El operador l&amp;oacute;gico AND tiene el tipo &lt;code&gt;int&lt;/code&gt; y el valor &lt;code&gt;1&lt;/code&gt; si tanto lhs como rhs se comparan desiguales con cero. Tiene el valor &lt;code&gt;​0​&lt;/code&gt; en caso contrario (si cualquiera LHS o rhs o ambos comparan igual a cero).</target>
        </trans-unit>
        <trans-unit id="5b1edfa9d60b658de6c633aadb9fa593c4e1a912" translate="yes" xml:space="preserve">
          <source>The logical-OR operator has type &lt;code&gt;int&lt;/code&gt; and the value &lt;code&gt;1&lt;/code&gt; if either lhs or rhs compare unequal to zero. It has value &lt;code&gt;​0​&lt;/code&gt; otherwise (if both lhs and rhs compare equal to zero).</source>
          <target state="translated">El operador l&amp;oacute;gico OR tiene el tipo &lt;code&gt;int&lt;/code&gt; y el valor &lt;code&gt;1&lt;/code&gt; si lhs o rhs se comparan desiguales con cero. Tiene un valor &lt;code&gt;​0​&lt;/code&gt; en caso contrario (si ambos izda y dcha comparan igual a cero).</target>
        </trans-unit>
        <trans-unit id="1a2eca04fbdbfa85ffa013854d23cfd7ee4c2242" translate="yes" xml:space="preserve">
          <source>The lvalue expressions that designate objects of const-qualified type and the lvalue expressions that designate objects of struct or union type with at least one member of const-qualified type (including members of recursively contained aggregates or unions), are not</source>
          <target state="translated">Las expresiones de valor que designan objetos de tipo const-cualificado y las expresiones de valor que designan objetos de tipo estructura o unión con al menos un miembro de tipo const-cualificado (incluyendo miembros de agregados o uniones recursivamente contenidos),no son</target>
        </trans-unit>
        <trans-unit id="44ca3a77c674e6760cefc2d99377e4d887b83ff7" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;I&lt;/code&gt; is often used to form complex numbers, with expressions such as &lt;code&gt;x + y*I&lt;/code&gt;. If &lt;code&gt;I&lt;/code&gt; is defined as &lt;code&gt;&lt;a href=&quot;complex_i&quot;&gt;_Complex_I&lt;/a&gt;&lt;/code&gt;, then such expression may create a value with imaginary component &lt;code&gt;+0.0&lt;/code&gt; even when &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;-0.0&lt;/code&gt;, which is significant for complex number functions with branch cuts. The macro &lt;code&gt;&lt;a href=&quot;cmplx&quot;&gt;CMPLX&lt;/a&gt;&lt;/code&gt; provides a way to construct a complex number precisely.</source>
          <target state="translated">La macro &lt;code&gt;I&lt;/code&gt; se utiliza a menudo para formar n&amp;uacute;meros complejos, con expresiones tales como &lt;code&gt;x + y*I&lt;/code&gt; . Si &lt;code&gt;I&lt;/code&gt; se define como &lt;code&gt;&lt;a href=&quot;complex_i&quot;&gt;_Complex_I&lt;/a&gt;&lt;/code&gt; , entonces dicha expresi&amp;oacute;n puede crear un valor con el componente imaginario &lt;code&gt;+0.0&lt;/code&gt; incluso cuando &lt;code&gt;y&lt;/code&gt; es &lt;code&gt;-0.0&lt;/code&gt; , que es significativo para funciones de n&amp;uacute;meros complejos con cortes de rama. La macro &lt;code&gt;&lt;a href=&quot;cmplx&quot;&gt;CMPLX&lt;/a&gt;&lt;/code&gt; proporciona una manera de construir un n&amp;uacute;mero complejo con precisi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a80e1699fb25e0be7eaf64d7cde6fed39109e343" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;NAN&lt;/code&gt; expands to constant expression of type &lt;code&gt;float&lt;/code&gt; which evaluates to a quiet not-a-number (QNaN) value. If the implementation does not support QNaNs, this macro constant is not defined.</source>
          <target state="translated">La macro &lt;code&gt;NAN&lt;/code&gt; se expande a una expresi&amp;oacute;n constante de tipo &lt;code&gt;float&lt;/code&gt; que se eval&amp;uacute;a como un valor silencioso de no n&amp;uacute;mero (QNaN). Si la implementaci&amp;oacute;n no admite QNaN, esta macro constante no est&amp;aacute; definida.</target>
        </trans-unit>
        <trans-unit id="511bc44ac64af1c05b670d54015e303e4e44b53b" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;NULL&lt;/code&gt; is an implementation-defined null pointer constant, which may be.</source>
          <target state="translated">La macro &lt;code&gt;NULL&lt;/code&gt; es una constante de puntero nulo definida por la implementaci&amp;oacute;n, que puede ser.</target>
        </trans-unit>
        <trans-unit id="3b57be3ca2436b3c7e80915f52102e2654815419" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;offsetof&lt;/code&gt; expands to an &lt;a href=&quot;../language/constant_expression#Integer_constant_expression&quot;&gt;integer constant expression&lt;/a&gt; of type &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;size_t&lt;/a&gt;&lt;/code&gt;, the value of which is the offset, in bytes, from the beginning of an object of specified type to its specified member, including padding if any.</source>
          <target state="translated">La macro &lt;code&gt;offsetof&lt;/code&gt; se expande a una &lt;a href=&quot;../language/constant_expression#Integer_constant_expression&quot;&gt;expresi&amp;oacute;n constante entera&lt;/a&gt; de tipo &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;size_t&lt;/a&gt;&lt;/code&gt; , cuyo valor es el desplazamiento, en bytes, desde el comienzo de un objeto de tipo especificado a su miembro especificado, incluido el relleno, si lo hay.</target>
        </trans-unit>
        <trans-unit id="a5a472a05b4e53b9216f7fc0c3e059710e59c4a4" translate="yes" xml:space="preserve">
          <source>The macro constant &lt;code&gt;FE_ALL_EXCEPT&lt;/code&gt;, which expands to the bitwise OR of all other &lt;code&gt;FE_*&lt;/code&gt;, is always defined and is zero if floating-point exceptions are not supported by the implementation.</source>
          <target state="translated">La constante de macro &lt;code&gt;FE_ALL_EXCEPT&lt;/code&gt; , que se expande al OR bit a bit de todos los dem&amp;aacute;s &lt;code&gt;FE_*&lt;/code&gt; , siempre est&amp;aacute; definida y es cero si la implementaci&amp;oacute;n no admite excepciones de punto flotante.</target>
        </trans-unit>
        <trans-unit id="8841799ce4f61109365c940ff69b8b7ec719c836" translate="yes" xml:space="preserve">
          <source>The macro constant &lt;code&gt;FE_DFL_ENV&lt;/code&gt; expands to an expression of type &lt;code&gt;const fenv_t*&lt;/code&gt;, which points to a full copy of the default floating-point environment, that is, the environment as loaded at program startup.</source>
          <target state="translated">La constante de macro &lt;code&gt;FE_DFL_ENV&lt;/code&gt; se expande a una expresi&amp;oacute;n de tipo &lt;code&gt;const fenv_t*&lt;/code&gt; , que apunta a una copia completa del entorno de punto flotante predeterminado, es decir, el entorno cargado al inicio del programa.</target>
        </trans-unit>
        <trans-unit id="4e6484c8cfd3a1b8d998f588b04075f3f3fb6a9f" translate="yes" xml:space="preserve">
          <source>The macro constant &lt;code&gt;math_errhandling&lt;/code&gt; expands to an expression of type &lt;code&gt;int&lt;/code&gt; that is either equal to &lt;code&gt;MATH_ERRNO&lt;/code&gt;, or equal to &lt;code&gt;MATH_ERREXCEPT&lt;/code&gt;, or equal to their bitwise OR (&lt;code&gt;MATH_ERRNO | MATH_ERREXCEPT&lt;/code&gt;).</source>
          <target state="translated">La macro constante &lt;code&gt;math_errhandling&lt;/code&gt; se expande a una expresi&amp;oacute;n de tipo &lt;code&gt;int&lt;/code&gt; que es igual a &lt;code&gt;MATH_ERRNO&lt;/code&gt; , o igual a &lt;code&gt;MATH_ERREXCEPT&lt;/code&gt; , o igual a su OR bit a bit ( &lt;code&gt;MATH_ERRNO | MATH_ERREXCEPT&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0e0067abc6a159712bb56dd3f2aea66ef110adc4" translate="yes" xml:space="preserve">
          <source>The macro is not named &lt;code&gt;i&lt;/code&gt;, which is the name of the imaginary unit in mathematics, because the name &lt;code&gt;i&lt;/code&gt; was already used in many C programs, e.g. as a loop counter variable.</source>
          <target state="translated">La macro no se llama &lt;code&gt;i&lt;/code&gt; , que es el nombre de la unidad imaginaria en matem&amp;aacute;ticas, porque el nombre &lt;code&gt;i&lt;/code&gt; ya se usaba en muchos programas en C, por ejemplo, como una variable de contador de bucle.</target>
        </trans-unit>
        <trans-unit id="c798130b9170a560fc1a663c486665854f217b8c" translate="yes" xml:space="preserve">
          <source>The mapped value of &lt;code&gt;wc&lt;/code&gt; using the mapping identified by &lt;code&gt;desc&lt;/code&gt; in LC_CTYPE facet of the current C locale.</source>
          <target state="translated">El valor mapeado de &lt;code&gt;wc&lt;/code&gt; usando el mapeo identificado por &lt;code&gt;desc&lt;/code&gt; en la faceta LC_CTYPE de la localizaci&amp;oacute;n C actual.</target>
        </trans-unit>
        <trans-unit id="030e1db264f4cf63958d4ac7eff5a182391b9628" translate="yes" xml:space="preserve">
          <source>The mathematical definition of the principal value of arc sine is asin z = -</source>
          <target state="translated">La definición matemática del valor principal del seno del arco es asin z=-</target>
        </trans-unit>
        <trans-unit id="97d3912b761a5766d76f8e019b7647d3c28a58a9" translate="yes" xml:space="preserve">
          <source>The mathematical definition of the principal value of the inverse hyperbolic cosine is acosh z = ln(z + &amp;radic;z+1&amp;radic;z-1)  For any z, acosh(z) =</source>
          <target state="translated">La definici&amp;oacute;n matem&amp;aacute;tica del valor principal del coseno hiperb&amp;oacute;lico inverso es acosh z = ln (z + &amp;radic;z + 1&amp;radic;z-1) Para cualquier z, acosh (z) =</target>
        </trans-unit>
        <trans-unit id="2ee0c302057514ba3aa0f5c20f8146065a6d4cf3" translate="yes" xml:space="preserve">
          <source>The mathematical definition of the principal value of the inverse hyperbolic sine is asinh z = ln(z + &amp;radic;1+z2</source>
          <target state="translated">La definici&amp;oacute;n matem&amp;aacute;tica del valor principal del seno hiperb&amp;oacute;lico inverso es asinh z = ln (z + &amp;radic;1 + z2</target>
        </trans-unit>
        <trans-unit id="329fc6fceaa5447c01dd9f62cafecf085e1ff466" translate="yes" xml:space="preserve">
          <source>The member access expression designates the named member of the &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; designated by its left operand. It has the same &lt;a href=&quot;value_category&quot;&gt;value category&lt;/a&gt; as its left operand.</source>
          <target state="translated">La expresi&amp;oacute;n de acceso de miembro designa al miembro nombrado de la &lt;a href=&quot;struct&quot;&gt;estructura&lt;/a&gt; o &lt;a href=&quot;union&quot;&gt;uni&amp;oacute;n&lt;/a&gt; designada por su operando izquierdo. Tiene la misma &lt;a href=&quot;value_category&quot;&gt;categor&amp;iacute;a de valor&lt;/a&gt; que su operando izquierdo.</target>
        </trans-unit>
        <trans-unit id="c5122e1449ef0335505c57e5253a964f45fcdf79" translate="yes" xml:space="preserve">
          <source>The member access expression has the form.</source>
          <target state="translated">La expresión de acceso de miembros tiene la forma.</target>
        </trans-unit>
        <trans-unit id="fa318493dd5c2f458fec0ccc1d6f9c59afaab4fd" translate="yes" xml:space="preserve">
          <source>The member access through pointer expression designates the named member of the &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; type pointed to by its left operand. Its value category is always &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt;.</source>
          <target state="translated">El acceso de miembro a trav&amp;eacute;s de la expresi&amp;oacute;n de puntero designa al miembro nombrado de la &lt;a href=&quot;struct&quot;&gt;estructura&lt;/a&gt; o tipo de &lt;a href=&quot;union&quot;&gt;uni&amp;oacute;n al que&lt;/a&gt; apunta su operando izquierdo. Su categor&amp;iacute;a de valor es siempre &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6d6e0885b44b0d2f2e93a7131b908d31fa827da7" translate="yes" xml:space="preserve">
          <source>The memory models for the read-modify-write and load operations are &lt;code&gt;succ&lt;/code&gt; and &lt;code&gt;fail&lt;/code&gt; respectively. The (1-2) versions use &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; by default.</source>
          <target state="translated">Los modelos de memoria para las operaciones de lectura-modificaci&amp;oacute;n-escritura y carga son &lt;code&gt;succ&lt;/code&gt; y &lt;code&gt;fail&lt;/code&gt; respectivamente. Las versiones (1-2) usan &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; por defecto.</target>
        </trans-unit>
        <trans-unit id="6f83b6ed70462af18ce1b14250e467f4f95844bf" translate="yes" xml:space="preserve">
          <source>The memory-writing conversion specifier &lt;code&gt;%n&lt;/code&gt; is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked &lt;code&gt;printf_s&lt;/code&gt; family of functions.</source>
          <target state="translated">El especificador de conversi&amp;oacute;n de escritura en memoria &lt;code&gt;%n&lt;/code&gt; es un objetivo com&amp;uacute;n de las vulnerabilidades de seguridad en las que las cadenas de formato dependen de la entrada del usuario y no son compatibles con la familia de funciones &lt;code&gt;printf_s&lt;/code&gt; con control de l&amp;iacute;mites .</target>
        </trans-unit>
        <trans-unit id="98877038e2ba0fac0c119a38c0522d0619de0c17" translate="yes" xml:space="preserve">
          <source>The most common keywords that begin with an underscore are generally used through their convenience macros:</source>
          <target state="translated">Las palabras clave más comunes que comienzan con un guión bajo se utilizan generalmente a través de sus macros de conveniencia:</target>
        </trans-unit>
        <trans-unit id="45bbb14be1144d08570d1c46bcac519c4ca04a16" translate="yes" xml:space="preserve">
          <source>The most popular use case for restrict-qualified pointers is the use as function parameters.</source>
          <target state="translated">El caso de uso más popular de los punteros restringidos es el uso como parámetros de función.</target>
        </trans-unit>
        <trans-unit id="b1f3d7cdd9264d99f9f78cc280cd57b23e748c7e" translate="yes" xml:space="preserve">
          <source>The name stands for &quot;string pointer break&quot;, because it returns a pointer to the first of the separator (&quot;break&quot;) characters.</source>
          <target state="translated">El nombre significa &quot;rotura de puntero de cadena&quot;,porque devuelve un puntero al primero de los caracteres separadores (&quot;break&quot;).</target>
        </trans-unit>
        <trans-unit id="1ee1404e6d3d16d932267176149d19223296bb12" translate="yes" xml:space="preserve">
          <source>The names &lt;code&gt;argc&lt;/code&gt; and &lt;code&gt;argv&lt;/code&gt; are arbitrary, as well as the representation of the types of the parameters: &lt;code&gt;int main(int ac, char** av)&lt;/code&gt; is equally valid.</source>
          <target state="translated">Los nombres &lt;code&gt;argc&lt;/code&gt; y &lt;code&gt;argv&lt;/code&gt; son arbitrarios, as&amp;iacute; como la representaci&amp;oacute;n de los tipos de par&amp;aacute;metros: &lt;code&gt;int main(int ac, char** av)&lt;/code&gt; es igualmente v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="1bb2ce61596e9a9e2acbc1daec6dd4f31667f9c0" translate="yes" xml:space="preserve">
          <source>The names of &lt;a href=&quot;../preprocessor/replace&quot;&gt;macros&lt;/a&gt; are not part of any name space because they are replaced by the preprocessor prior to semantic analysis.</source>
          <target state="translated">Los nombres de las &lt;a href=&quot;../preprocessor/replace&quot;&gt;macros&lt;/a&gt; no forman parte de ning&amp;uacute;n espacio de nombres porque son reemplazados por el preprocesador antes del an&amp;aacute;lisis sem&amp;aacute;ntico.</target>
        </trans-unit>
        <trans-unit id="da3734864c7a6f4ae8da4b63030befa1148f5321" translate="yes" xml:space="preserve">
          <source>The natural logarithm of a complex number z with polar coordinate components (r,&amp;theta;) equals ln r + i(&amp;theta;+2n&amp;pi;), with the principal value ln r + i&amp;theta;</source>
          <target state="translated">El logaritmo natural de un n&amp;uacute;mero complejo z con componentes de coordenadas polares (r, &amp;theta;) es igual a ln r + i (&amp;theta; + 2n&amp;pi;), con el valor principal ln r + i&amp;theta;</target>
        </trans-unit>
        <trans-unit id="3e1f12a369d7befe692c93f44687eb7110ca778a" translate="yes" xml:space="preserve">
          <source>The nearest integer value to &lt;code&gt;arg&lt;/code&gt;, according to the &lt;a href=&quot;../fenv/fe_round&quot;&gt;current rounding mode&lt;/a&gt;, is returned.</source>
          <target state="translated">Se devuelve el valor entero m&amp;aacute;s cercano a &lt;code&gt;arg&lt;/code&gt; , de acuerdo con el &lt;a href=&quot;../fenv/fe_round&quot;&gt;modo de redondeo actual&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f6eccb49cbb94feecde36ffadd4ba34340c519c4" translate="yes" xml:space="preserve">
          <source>The new-line character &lt;code&gt;\n&lt;/code&gt; has special meaning when used in &lt;a href=&quot;../io&quot;&gt;text mode I/O&lt;/a&gt;: it is converted to the OS-specific newline byte or byte sequence.</source>
          <target state="translated">El car&amp;aacute;cter de nueva l&amp;iacute;nea &lt;code&gt;\n&lt;/code&gt; tiene un significado especial cuando se usa en &lt;a href=&quot;../io&quot;&gt;modo de texto de E / S&lt;/a&gt; : se convierte en el byte de nueva l&amp;iacute;nea espec&amp;iacute;fico del sistema operativo o en la secuencia de bytes.</target>
        </trans-unit>
        <trans-unit id="61b9c57e3af3e967b10eb352639b13192c618556" translate="yes" xml:space="preserve">
          <source>The next wide character from the stream or &lt;code&gt;WEOF&lt;/code&gt; on failure.</source>
          <target state="translated">El siguiente car&amp;aacute;cter ancho de la secuencia o &lt;code&gt;WEOF&lt;/code&gt; en caso de error.</target>
        </trans-unit>
        <trans-unit id="c07d16928e24253bdda00754b26c48658241a00d" translate="yes" xml:space="preserve">
          <source>The null directive (&lt;code&gt;#&lt;/code&gt; followed by a line break) is allowed and has no effect.</source>
          <target state="translated">La directiva nula ( &lt;code&gt;#&lt;/code&gt; seguida de un salto de l&amp;iacute;nea) est&amp;aacute; permitida y no tiene ning&amp;uacute;n efecto.</target>
        </trans-unit>
        <trans-unit id="04d92f701b5c07543e4ab84377a0c9414fa7a320" translate="yes" xml:space="preserve">
          <source>The number of arguments must be the same as the number of arguments in the macro definition (parameters) or the program is ill-formed. If the identifier is not in functional-notation, i.e. does not have parentheses after itself, it is not replaced at all.</source>
          <target state="translated">El número de argumentos debe ser el mismo que el número de argumentos en la definición de la macro (parámetros)o el programa está mal formado.Si el identificador no está en anotación funcional,es decir,no tiene paréntesis después de sí mismo,no se reemplaza en absoluto.</target>
        </trans-unit>
        <trans-unit id="1b02eec6dc83ccdd83bcea1a56eb671b42ec3a69" translate="yes" xml:space="preserve">
          <source>The number of bytes written into the character array pointed to by &lt;code&gt;str&lt;/code&gt; not including the terminating &lt;code&gt;'\0'&lt;/code&gt; on success. If &lt;code&gt;count&lt;/code&gt; was reached before the entire string could be stored, &lt;code&gt;​0​&lt;/code&gt; is returned and the contents are undefined.</source>
          <target state="translated">El n&amp;uacute;mero de bytes escritos en la matriz de caracteres se&amp;ntilde;alados por &lt;code&gt;str&lt;/code&gt; sin incluir la terminaci&amp;oacute;n &lt;code&gt;'\0'&lt;/code&gt; en caso de &amp;eacute;xito. Si &lt;code&gt;count&lt;/code&gt; se alcanz&amp;oacute; antes de que se podr&amp;iacute;a almacenar toda la cadena, &lt;code&gt;​0​&lt;/code&gt; se devuelve y el contenido est&amp;aacute;n definidos.</target>
        </trans-unit>
        <trans-unit id="d9e0726f8dc98eb74868d9afc85bf0df3317f165" translate="yes" xml:space="preserve">
          <source>The number of objects written successfully, which may be less than &lt;code&gt;count&lt;/code&gt; if an error occurs.</source>
          <target state="translated">El n&amp;uacute;mero de objetos escritos con &amp;eacute;xito, que puede ser menor que &lt;code&gt;count&lt;/code&gt; si se produce un error.</target>
        </trans-unit>
        <trans-unit id="807035c9e6b0ffb0f3a70e237d402f9009cdef78" translate="yes" xml:space="preserve">
          <source>The obtained character on success or &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="translated">El personaje obtenido en el &amp;eacute;xito o &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; en el fracaso.</target>
        </trans-unit>
        <trans-unit id="b873fe3bdfab61293a8ea3488d6ce55e2f2befb5" translate="yes" xml:space="preserve">
          <source>The only difference between &lt;code&gt;nearbyint&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;rint&quot;&gt;rint&lt;/a&gt;&lt;/code&gt; is that &lt;code&gt;nearbyint&lt;/code&gt; never raises &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">La &amp;uacute;nica diferencia entre &lt;code&gt;nearbyint&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;rint&quot;&gt;rint&lt;/a&gt;&lt;/code&gt; es que &lt;code&gt;nearbyint&lt;/code&gt; nunca levanta &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12dd6a69e521621a23e516eeff24b5d905692137" translate="yes" xml:space="preserve">
          <source>The only difference between &lt;code&gt;rint&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;nearbyint&lt;/a&gt;&lt;/code&gt; is that &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;nearbyint&lt;/a&gt;&lt;/code&gt; never raises &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">La &amp;uacute;nica diferencia entre &lt;code&gt;rint&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;nearbyint&lt;/a&gt;&lt;/code&gt; es que &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;nearbyint&lt;/a&gt;&lt;/code&gt; nunca levanta &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ff53dd2216bc51a0d7bbb3c32825f9455bce0ac" translate="yes" xml:space="preserve">
          <source>The operand expr of both prefix and postfix increment or decrement must be a &lt;a href=&quot;value_category&quot;&gt;modifiable lvalue&lt;/a&gt; of &lt;a href=&quot;compatible_type&quot;&gt;integer type&lt;/a&gt; (including &lt;code&gt;_Bool&lt;/code&gt; and enums), real floating type, or a pointer type. It may be cvr-qualified, unqualified, or &lt;a href=&quot;atomic&quot;&gt;atomic&lt;/a&gt;.</source>
          <target state="translated">El operando expr de los incrementos o decrementos de prefijo y postfix debe ser un valor &lt;a href=&quot;value_category&quot;&gt;l modificable&lt;/a&gt; de &lt;a href=&quot;compatible_type&quot;&gt;tipo entero&lt;/a&gt; (incluyendo &lt;code&gt;_Bool&lt;/code&gt; y enumeraciones), tipo flotante real o tipo puntero. Puede ser calificado por CVR, no calificado o &lt;a href=&quot;atomic&quot;&gt;at&amp;oacute;mico&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="18275d066ab2586011d304d388724f3ba9519b5f" translate="yes" xml:space="preserve">
          <source>The operand is not evaluated (so external identifiers used in the operand do not have to be defined).</source>
          <target state="translated">El operando no se evalúa (por lo que no es necesario definir los identificadores externos utilizados en el operando).</target>
        </trans-unit>
        <trans-unit id="37137d3854c9080efa5ba737cb6b214274865b11" translate="yes" xml:space="preserve">
          <source>The operand of &lt;code&gt;sizeof&lt;/code&gt; can't be a type cast: the expression &lt;code&gt;sizeof (int) * p&lt;/code&gt; is unambiguously interpreted as &lt;code&gt;(sizeof(int)) * p&lt;/code&gt;, but not &lt;code&gt;sizeof((int)*p)&lt;/code&gt;.</source>
          <target state="translated">El operando de &lt;code&gt;sizeof&lt;/code&gt; no puede ser un tipo de conversi&amp;oacute;n: la expresi&amp;oacute;n &lt;code&gt;sizeof (int) * p&lt;/code&gt; se interpreta inequ&amp;iacute;vocamente como &lt;code&gt;(sizeof(int)) * p&lt;/code&gt; , pero no &lt;code&gt;sizeof((int)*p)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b4163fdf5ba90cadb97f17282331d38484360c2" translate="yes" xml:space="preserve">
          <source>The operand of prefix &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; can't be a type cast. This rule grammatically forbids some expressions that would be semantically invalid anyway. Some compilers ignore this rule and detect the invalidity semantically.</source>
          <target state="translated">El operando del prefijo &lt;code&gt;++&lt;/code&gt; y &lt;code&gt;--&lt;/code&gt; no puede ser un tipo de conversi&amp;oacute;n. Esta regla proh&amp;iacute;be gramaticalmente algunas expresiones que ser&amp;iacute;an sem&amp;aacute;nticamente inv&amp;aacute;lidas de todos modos. Algunos compiladores ignoran esta regla y detectan la invalidez sem&amp;aacute;nticamente.</target>
        </trans-unit>
        <trans-unit id="73662db4f86c916723ec8e38855bae82c65cb635" translate="yes" xml:space="preserve">
          <source>The operands of any operator may be other expressions or they may be</source>
          <target state="translated">Los operandos de cualquier operador pueden ser otras expresiones o pueden ser</target>
        </trans-unit>
        <trans-unit id="b31ff6e872519cb01b42793b5610377a28df7a92" translate="yes" xml:space="preserve">
          <source>The operands of the &lt;a href=&quot;sizeof&quot;&gt;sizeof operator&lt;/a&gt;, the &lt;a href=&quot;alignof&quot;&gt;_Alignof operator&lt;/a&gt;, and the controlling expression of a &lt;a href=&quot;generic&quot;&gt;generic selection&lt;/a&gt;,(since C11) are expressions that are not evaluated (unless they are VLAs)(since C99). Thus, &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;size_t&lt;/a&gt; n = sizeof(&lt;a href=&quot;../io/fprintf&quot;&gt;printf&lt;/a&gt;(&quot;%d&quot;, 4));&lt;/code&gt; does not perform console output.</source>
          <target state="translated">Los operandos del &lt;a href=&quot;sizeof&quot;&gt;operador sizeof&lt;/a&gt; , el &lt;a href=&quot;alignof&quot;&gt;operador _Alignof&lt;/a&gt; y la expresi&amp;oacute;n de control de una &lt;a href=&quot;generic&quot;&gt;selecci&amp;oacute;n gen&amp;eacute;rica&lt;/a&gt; (desde C11) son expresiones que no se eval&amp;uacute;an (a menos que sean VLA) (desde C99). Por lo tanto, &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;size_t&lt;/a&gt; n = sizeof(&lt;a href=&quot;../io/fprintf&quot;&gt;printf&lt;/a&gt;(&quot;%d&quot;, 4));&lt;/code&gt; no realiza la salida de la consola.</target>
        </trans-unit>
        <trans-unit id="d297e1f23cc8859be5bde831c7d9be6c7bf9a287" translate="yes" xml:space="preserve">
          <source>The order of bit fields within an allocation unit (on some platforms, bit fields are packed left-to-right, on others right-to-left)</source>
          <target state="translated">El orden de los campos binarios dentro de una unidad de asignación (en algunas plataformas,los campos binarios se empaquetan de izquierda a derecha,en otras de derecha a izquierda)</target>
        </trans-unit>
        <trans-unit id="0cc9aa93e9756b28627ee99925b99df10b1ad6c5" translate="yes" xml:space="preserve">
          <source>The order of evaluation of # and ## operators is unspecified.</source>
          <target state="translated">El orden de evaluación de los operadores#y ##no está especificado.</target>
        </trans-unit>
        <trans-unit id="e5a0f335326728b6cca410047346d8dea887e482" translate="yes" xml:space="preserve">
          <source>The other use of the keyword &lt;code&gt;static&lt;/code&gt; is &lt;a href=&quot;file_scope&quot;&gt;file scope&lt;/a&gt;.</source>
          <target state="translated">El otro uso de la palabra clave &lt;code&gt;static&lt;/code&gt; es &lt;a href=&quot;file_scope&quot;&gt;el alcance del archivo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="69f26538f800d4e9dfa396f5f3af68d5b600733f" translate="yes" xml:space="preserve">
          <source>The parameters in a declaration that is not part of a &lt;a href=&quot;function_definition&quot;&gt;function definition&lt;/a&gt; do not need to be named:</source>
          <target state="translated">Los par&amp;aacute;metros en una declaraci&amp;oacute;n que no es parte de una &lt;a href=&quot;function_definition&quot;&gt;definici&amp;oacute;n de funci&amp;oacute;n&lt;/a&gt; no necesitan ser nombrados:</target>
        </trans-unit>
        <trans-unit id="467dc40c372e73f0c2c12405d62c7e8ef32d3367" translate="yes" xml:space="preserve">
          <source>The parameters of the two-parameter form of the main function allow arbitrary multibyte character strings to be passed from the execution environment (these are typically known as</source>
          <target state="translated">Los parámetros de la forma de dos parámetros de la función principal permiten que se pasen cadenas de caracteres multibyte arbitrarias desde el entorno de ejecución (éstas se conocen típicamente como</target>
        </trans-unit>
        <trans-unit id="bcaa687493b6df88d7a017675ddb9c620e6ecde2" translate="yes" xml:space="preserve">
          <source>The pragma directive controls implementation-specific behavior of the compiler, such as disabling compiler warnings or changing alignment requirements. Any pragma that is not recognized is ignored.</source>
          <target state="translated">La directiva pragma controla el comportamiento específico de la implementación del compilador,como la desactivación de las advertencias del compilador o el cambio de los requisitos de alineación.Cualquier pragma que no sea reconocido es ignorado.</target>
        </trans-unit>
        <trans-unit id="5c545f4e65d9a240009138753e3771a06a41dbc9" translate="yes" xml:space="preserve">
          <source>The predefined variable &lt;code&gt;__func__&lt;/code&gt; (see &lt;a href=&quot;../language/function_definition#func&quot;&gt;function definition&lt;/a&gt; for details) is not a preprocessor macro, even though it is sometimes used together with &lt;code&gt;__FILE__&lt;/code&gt; and &lt;code&gt;__LINE__&lt;/code&gt;, e.g. by &lt;code&gt;&lt;a href=&quot;../error/assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">La variable predefinida &lt;code&gt;__func__&lt;/code&gt; (ver &lt;a href=&quot;../language/function_definition#func&quot;&gt;definici&amp;oacute;n de funci&amp;oacute;n&lt;/a&gt; para m&amp;aacute;s detalles) no es un macro preprocesador, a pesar de que a veces se utiliza junto con &lt;code&gt;__FILE__&lt;/code&gt; y &lt;code&gt;__LINE__&lt;/code&gt; , por ejemplo por &lt;code&gt;&lt;a href=&quot;../error/assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05a52076d2dc5c8b894927a5e244dc4ac56fe7ce" translate="yes" xml:space="preserve">
          <source>The preprocessing directives control the behavior of the preprocessor. Each directive occupies one line and has the following format:</source>
          <target state="translated">Las directivas de preprocesamiento controlan el comportamiento del preprocesador.Cada directiva ocupa una línea y tiene el siguiente formato:</target>
        </trans-unit>
        <trans-unit id="cb413a6249ff3f9ad8dd052d27dcc328f60aee81" translate="yes" xml:space="preserve">
          <source>The preprocessor has the source file translation capabilities:</source>
          <target state="translated">El preprocesador tiene la capacidad de traducción del archivo fuente:</target>
        </trans-unit>
        <trans-unit id="6aa350ea11bb9c5aa25e6e5ec9306cca0035172c" translate="yes" xml:space="preserve">
          <source>The preprocessor is executed at &lt;a href=&quot;language/translation_phases&quot;&gt;translation phase 4&lt;/a&gt;, before the compilation. The result of preprocessing is a single file which is then passed to the actual compiler.</source>
          <target state="translated">El preprocesador se ejecuta en la &lt;a href=&quot;language/translation_phases&quot;&gt;fase de traducci&amp;oacute;n 4&lt;/a&gt; , antes de la compilaci&amp;oacute;n. El resultado del preprocesamiento es un archivo &amp;uacute;nico que luego se pasa al compilador real.</target>
        </trans-unit>
        <trans-unit id="bc4687c98781e74fbe3189f89c48b78e9e171beb" translate="yes" xml:space="preserve">
          <source>The preprocessor supports conditional compilation of parts of a source file. This behavior is controlled by &lt;code&gt;#if&lt;/code&gt;, &lt;code&gt;#else&lt;/code&gt;, &lt;code&gt;#elif&lt;/code&gt;, &lt;code&gt;#ifdef&lt;/code&gt;, &lt;code&gt;#ifndef&lt;/code&gt; and &lt;code&gt;#endif&lt;/code&gt; directives.</source>
          <target state="translated">El preprocesador admite la compilaci&amp;oacute;n condicional de partes de un archivo fuente. Este comportamiento es controlado por &lt;code&gt;#if&lt;/code&gt; , &lt;code&gt;#else&lt;/code&gt; , &lt;code&gt;#elif&lt;/code&gt; , &lt;code&gt;#ifdef&lt;/code&gt; , &lt;code&gt;#ifndef&lt;/code&gt; y &lt;code&gt;#endif&lt;/code&gt; directivas.</target>
        </trans-unit>
        <trans-unit id="27574a8faae48a163d31765e56cbbeb67aa3ad8a" translate="yes" xml:space="preserve">
          <source>The preprocessor supports text macro replacement and function-like text macro replacement.</source>
          <target state="translated">El preprocesador soporta el reemplazo de macros de texto y el reemplazo de macros de texto con funciones similares.</target>
        </trans-unit>
        <trans-unit id="f3d1a0ebd42aa1b39b4a03a00bbf88d9f00ef744" translate="yes" xml:space="preserve">
          <source>The previous value held by the atomic flag pointed to by &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">El valor anterior mantenido por la bandera at&amp;oacute;mica se&amp;ntilde;alado por &lt;code&gt;obj&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b415c1df8056a8b60b1fe0e4eaabdb03213a23ff" translate="yes" xml:space="preserve">
          <source>The projection of &lt;code&gt;z&lt;/code&gt; on the Riemann sphere.</source>
          <target state="translated">La proyecci&amp;oacute;n de &lt;code&gt;z&lt;/code&gt; en la esfera de Riemann.</target>
        </trans-unit>
        <trans-unit id="39ca745a924bb9137959b139a9ffdc062119f806" translate="yes" xml:space="preserve">
          <source>The qualifiers that appear between &lt;code&gt;*&lt;/code&gt; and the identifier (or other nested declarator) qualify the type of the pointer that is being declared:</source>
          <target state="translated">Los calificadores que aparecen entre &lt;code&gt;*&lt;/code&gt; y el identificador (u otro declarador anidado) califican el tipo de puntero que se declara:</target>
        </trans-unit>
        <trans-unit id="e80a3e01ac05bea47ec62aef3af475352cd5d29f" translate="yes" xml:space="preserve">
          <source>The question mark escape sequence &lt;code&gt;\?&lt;/code&gt; is used to prevent &lt;a href=&quot;operator_alternative&quot;&gt;trigraphs&lt;/a&gt; from being interpreted inside string literals: a string such as &lt;code&gt;&quot;??/&quot;&lt;/code&gt; is compiled as &lt;code&gt;&quot;\&quot;&lt;/code&gt;, but if the second question mark is escaped, as in &lt;code&gt;&quot;?\?/&quot;&lt;/code&gt;, it becomes &lt;code&gt;&quot;??/&quot;&lt;/code&gt;</source>
          <target state="translated">La secuencia de escape de signo de interrogaci&amp;oacute;n &lt;code&gt;\?&lt;/code&gt; se usa para evitar que los &lt;a href=&quot;operator_alternative&quot;&gt;trigrafos&lt;/a&gt; se interpreten dentro de los literales de cadena: una cadena como &lt;code&gt;&quot;??/&quot;&lt;/code&gt; se compila como &lt;code&gt;&quot;\&quot;&lt;/code&gt; , pero si se escapa el segundo signo de interrogaci&amp;oacute;n, como en &lt;code&gt;&quot;?\?/&quot;&lt;/code&gt; , se convierte en &lt;code&gt;&quot;??/&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="20eb771689c7638596c471df8669135309db406f" translate="yes" xml:space="preserve">
          <source>The quiet NaN value that corresponds to the identifying string &lt;code&gt;arg&lt;/code&gt; or zero if the implementation does not support quiet NaNs.</source>
          <target state="translated">El valor de NaN silencioso que corresponde a la cadena de identificaci&amp;oacute;n &lt;code&gt;arg&lt;/code&gt; o cero si la implementaci&amp;oacute;n no admite NaN silenciosos.</target>
        </trans-unit>
        <trans-unit id="8a3d414a29f86b002434e0375d474e5453d360f9" translate="yes" xml:space="preserve">
          <source>The real part is converted following the rules for the real floating types</source>
          <target state="translated">La parte real se convierte siguiendo las reglas de los tipos flotantes reales</target>
        </trans-unit>
        <trans-unit id="3d332d998b707cad080166fabcdd3ca82e157e01" translate="yes" xml:space="preserve">
          <source>The real part is discarded</source>
          <target state="translated">La parte real se descarta</target>
        </trans-unit>
        <trans-unit id="d2fb212acc87955b594f7e2f071c1ac0ec5aa798" translate="yes" xml:space="preserve">
          <source>The real part of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">La parte real de &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4346c79f063102e016ae364fb68f3f8bb2758d57" translate="yes" xml:space="preserve">
          <source>The real part of the result is determined by the conversion rules for the real floating types</source>
          <target state="translated">La parte real del resultado está determinada por las reglas de conversión de los tipos flotantes reales</target>
        </trans-unit>
        <trans-unit id="3d3101c9f33fc2be7ee330e9f087611a76f132bd" translate="yes" xml:space="preserve">
          <source>The real part of the result is the positive zero</source>
          <target state="translated">La parte real del resultado es el cero positivo</target>
        </trans-unit>
        <trans-unit id="ad324bd2c8bc22b00758a73ea2fd6b6e48382778" translate="yes" xml:space="preserve">
          <source>The reallocation is done by either:</source>
          <target state="translated">La reasignación se hace por cualquiera de los dos:</target>
        </trans-unit>
        <trans-unit id="c91a538270dcd320d3a898adcd71a4e8cf52f99d" translate="yes" xml:space="preserve">
          <source>The reason &lt;code&gt;tss_delete&lt;/code&gt; never calls destructors is that the destructors (called at thread exit) are normally intended to be executed by the same thread that originally set the value (via &lt;code&gt;&lt;a href=&quot;tss_set&quot;&gt;tss_set&lt;/a&gt;&lt;/code&gt;) that the destructor will be dealing with, and may even rely on the values of that or other thread-specific data as seen by that thread. The thread executing &lt;code&gt;tss_delete&lt;/code&gt; has no access to other threads' TSS. Even if it were possible to call the destructor for each thread's own value associated with &lt;code&gt;tss_id&lt;/code&gt;, &lt;code&gt;tss_delete&lt;/code&gt; would have to synchronize with every thread if only to examine whether the value of this TSS in that thread is null (destructors are only called against non-null values).</source>
          <target state="translated">La raz&amp;oacute;n por la cual &lt;code&gt;tss_delete&lt;/code&gt; nunca llama a los destructores es porque los destructores (llamados a la salida del hilo) normalmente est&amp;aacute;n destinados a ser ejecutados por el mismo hilo que originalmente estableci&amp;oacute; el valor (a trav&amp;eacute;s de &lt;code&gt;&lt;a href=&quot;tss_set&quot;&gt;tss_set&lt;/a&gt;&lt;/code&gt; ) con el que el destructor estar&amp;aacute; tratando, e incluso puede confiar en los valores de ese u otros datos espec&amp;iacute;ficos de subproceso como se ve por ese subproceso. El hilo que ejecuta &lt;code&gt;tss_delete&lt;/code&gt; no tiene acceso a TSS de otros hilos. Incluso si fuera posible llamar al destructor para el propio valor de cada subproceso asociado con &lt;code&gt;tss_id&lt;/code&gt; , &lt;code&gt;tss_delete&lt;/code&gt; tendr&amp;iacute;a que sincronizarse con cada subproceso solo para examinar si el valor de este TSS en ese subproceso es nulo (los destructores solo se llaman contra los no nulos valores).</target>
        </trans-unit>
        <trans-unit id="c7248ba66e1897d995063b1acf5aa812b6ba0952" translate="yes" xml:space="preserve">
          <source>The reasoning behind this syntax is that when the identifier declared by the declarator appears in an expression of the same form as the declarator, it would have the type specified by the type specifier sequence.</source>
          <target state="translated">El razonamiento que subyace a esta sintaxis es que cuando el identificador declarado por el declarante aparece en una expresión de la misma forma que el declarante,tendría el tipo especificado por la secuencia del especificador de tipo.</target>
        </trans-unit>
        <trans-unit id="2e11489a7a30fc1b23c96dca40b2ff8e966f4c67" translate="yes" xml:space="preserve">
          <source>The related POSIX function &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/popen.html&quot;&gt;popen&lt;/a&gt; makes the output generated by &lt;code&gt;command&lt;/code&gt; available to the caller.</source>
          <target state="translated">La funci&amp;oacute;n relacionada &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/popen.html&quot;&gt;POSPO popen&lt;/a&gt; hace que la salida generada por el &lt;code&gt;command&lt;/code&gt; est&amp;eacute; disponible para la persona que llama.</target>
        </trans-unit>
        <trans-unit id="882b56e07684c56a82fb47ac99ca4f95e58df12c" translate="yes" xml:space="preserve">
          <source>The related POSIX function &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/popen.html&quot;&gt;popen&lt;/a&gt; makes the output generated by &lt;code&gt;command&lt;/code&gt; available to the caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="748eabde86f4be7c00894966086a057656832218" translate="yes" xml:space="preserve">
          <source>The related function &lt;code&gt;&lt;a href=&quot;puts&quot;&gt;puts&lt;/a&gt;&lt;/code&gt; appends a newline character to the output, while &lt;code&gt;fputs&lt;/code&gt; writes the string unmodified.</source>
          <target state="translated">La funci&amp;oacute;n relacionada &lt;code&gt;&lt;a href=&quot;puts&quot;&gt;puts&lt;/a&gt;&lt;/code&gt; agrega un car&amp;aacute;cter de nueva l&amp;iacute;nea a la salida, mientras que &lt;code&gt;fputs&lt;/code&gt; escribe la cadena sin modificar.</target>
        </trans-unit>
        <trans-unit id="b4fca208bdd61aeb00fb518a1b586c85e37c17e7" translate="yes" xml:space="preserve">
          <source>The relational operator expressions have the form.</source>
          <target state="translated">Las expresiones del operador relacional tienen la forma.</target>
        </trans-unit>
        <trans-unit id="7e9510a237cd6950e335a276b93cd34d804cbc1a" translate="yes" xml:space="preserve">
          <source>The result is</source>
          <target state="translated">El resultado es</target>
        </trans-unit>
        <trans-unit id="37ef1943a699e87ee70990285ed8c7f6d3a1bc80" translate="yes" xml:space="preserve">
          <source>The result is an integer constant of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;size_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">El resultado es una constante entera de tipo &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;size_t&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a957f8ea1f391e7935ddb74dad2e1448951ecef7" translate="yes" xml:space="preserve">
          <source>The result may have little or no significance if the magnitude of &lt;code&gt;arg&lt;/code&gt; is large.</source>
          <target state="translated">El resultado puede tener poca o ninguna importancia si la magnitud de &lt;code&gt;arg&lt;/code&gt; es grande.</target>
        </trans-unit>
        <trans-unit id="622a039faf91ba533c61ef9a103fa3595c187ec2" translate="yes" xml:space="preserve">
          <source>The result of evaluating a floating constant is either the nearest representable value or the larger or smaller representable value immediately adjacent to the nearest representable value, chosen in an implementation-defined manner (in other words, &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;default rounding direction&lt;/a&gt; during translation is implementation-defined).</source>
          <target state="translated">El resultado de evaluar una constante flotante es el valor representable m&amp;aacute;s cercano o el valor representable m&amp;aacute;s grande o m&amp;aacute;s peque&amp;ntilde;o inmediatamente adyacente al valor representable m&amp;aacute;s cercano, elegido de una manera definida por la implementaci&amp;oacute;n (en otras palabras, la &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;direcci&amp;oacute;n de redondeo predeterminada&lt;/a&gt; durante la traducci&amp;oacute;n est&amp;aacute; definida por la implementaci&amp;oacute;n) .</target>
        </trans-unit>
        <trans-unit id="95074b83d96838fbb0176f8d997b7f5d8c7e69fb" translate="yes" xml:space="preserve">
          <source>The result of evaluating a hexadecimal floating constant, if FLT_RADIX is 2, is the exact value represented by the floating constant, correctly rounded to the target type.</source>
          <target state="translated">El resultado de la evaluación de una constante flotante hexadecimal,si FLT_RADIX es 2,es el valor exacto representado por la constante flotante,redondeado correctamente al tipo de objetivo.</target>
        </trans-unit>
        <trans-unit id="b8eb097162eccdf968f91720477290428716a2d9" translate="yes" xml:space="preserve">
          <source>The result of the comparison: &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;*obj&lt;/code&gt; was equal to &lt;code&gt;*exp&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">El resultado de la comparaci&amp;oacute;n: &lt;code&gt;true&lt;/code&gt; si &lt;code&gt;*obj&lt;/code&gt; era igual a &lt;code&gt;*exp&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; caso contrario.</target>
        </trans-unit>
        <trans-unit id="cc90b9c6aca8e99ddaa9a7c76d3df7f7c89550ed" translate="yes" xml:space="preserve">
          <source>The result of the postfix increment and decrement operators is the value of expr.</source>
          <target state="translated">El resultado de los operadores de incremento y decremento de postfijo es el valor de expr.</target>
        </trans-unit>
        <trans-unit id="fe87173b6111d916a794c69de4b3db44d02ad43d" translate="yes" xml:space="preserve">
          <source>The result of the prefix increment operator is the result of adding the value &lt;code&gt;1&lt;/code&gt; to the value of expr: the expression &lt;code&gt;++e&lt;/code&gt; is equivalent to &lt;code&gt;e+=1&lt;/code&gt;. The result of the prefix decrement operator is the result of subtracting the value &lt;code&gt;1&lt;/code&gt; from the value of expr: the expression &lt;code&gt;--e&lt;/code&gt; is equivalent to &lt;code&gt;e-=1&lt;/code&gt;.</source>
          <target state="translated">El resultado del operador de incremento de prefijo es el resultado de agregar el valor &lt;code&gt;1&lt;/code&gt; al valor de expr: la expresi&amp;oacute;n &lt;code&gt;++e&lt;/code&gt; es equivalente a &lt;code&gt;e+=1&lt;/code&gt; . El resultado del operador de decremento de prefijo es el resultado de restar el valor &lt;code&gt;1&lt;/code&gt; del valor de expr: la expresi&amp;oacute;n &lt;code&gt;--e&lt;/code&gt; es equivalente a &lt;code&gt;e-=1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="051e09522f14a201c152465dc43e09f778fe0395" translate="yes" xml:space="preserve">
          <source>The result of this conversion may have greater range and precision than its target type indicates (see &lt;code&gt;&lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">El resultado de esta conversi&amp;oacute;n puede tener mayor alcance y precisi&amp;oacute;n de lo que indica su tipo de destino (consulte &lt;code&gt;&lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="370e8414fd327899a4b199af9a10f347fd8f9909" translate="yes" xml:space="preserve">
          <source>The result type is determined as follows:</source>
          <target state="translated">El tipo de resultado se determina de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="6d0defe1a2c0ecb1ad124d49279ffb47529db4f8" translate="yes" xml:space="preserve">
          <source>The resulting string has the following format:</source>
          <target state="translated">La cadena resultante tiene el siguiente formato:</target>
        </trans-unit>
        <trans-unit id="480df78ac4c637eafab6deaf07efb2edc33ecdf4" translate="yes" xml:space="preserve">
          <source>The return type of a function cannot be cvr-qualified: any qualified return type is adjusted to its unqualified version for the purpose of constructing the function type:</source>
          <target state="translated">El tipo de retorno de una función no puede ser cvr-cualificado:cualquier tipo de retorno calificado se ajusta a su versión no calificada con el propósito de construir el tipo de función:</target>
        </trans-unit>
        <trans-unit id="ab7dcf423f1c6746845ea395c4d29680d8249cb3" translate="yes" xml:space="preserve">
          <source>The return type of the function, determined by the type specifier in specifiers-and-qualifiers and possibly modified by the declarator as usual in &lt;a href=&quot;declarations&quot;&gt;declarations&lt;/a&gt;, must be a complete non-array object type or the type &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">El tipo de retorno de la funci&amp;oacute;n, determinado por el especificador de tipo en especificadores y calificadores y posiblemente modificado por el declarante como es habitual en las &lt;a href=&quot;declarations&quot;&gt;declaraciones&lt;/a&gt; , debe ser un tipo de objeto sin matriz completo o el tipo &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be7ba042cf486f9205da2c739695a1dd6890e1f2" translate="yes" xml:space="preserve">
          <source>The returned string must not be modified by the program, but may be overwritten by a subsequent call to the &lt;code&gt;strerror&lt;/code&gt; function. &lt;code&gt;strerror&lt;/code&gt; is not required to be thread-safe. Implementations may be returning different pointers to static read-only string literals or may be returning the same pointer over and over, pointing at a static buffer in which strerror places the string.</source>
          <target state="translated">La cadena devuelta no debe ser modificada por el programa, pero puede sobrescribirse mediante una llamada posterior a la funci&amp;oacute;n &lt;code&gt;strerror&lt;/code&gt; . &lt;code&gt;strerror&lt;/code&gt; se requiere que strerror sea seguro para subprocesos. Las implementaciones pueden devolver diferentes punteros a literales de cadena de solo lectura est&amp;aacute;tica o pueden devolver el mismo puntero una y otra vez, apuntando a un b&amp;uacute;fer est&amp;aacute;tico en el que strerror coloca la cadena.</target>
        </trans-unit>
        <trans-unit id="e6cfe8cddaf67890ed027e912f162eac09c9f502" translate="yes" xml:space="preserve">
          <source>The returned value has the same sign as &lt;code&gt;x&lt;/code&gt; and is less or equal to &lt;code&gt;y&lt;/code&gt; in magnitude.</source>
          <target state="translated">El valor devuelto tiene el mismo signo que &lt;code&gt;x&lt;/code&gt; y es menor o igual a &lt;code&gt;y&lt;/code&gt; en magnitud.</target>
        </trans-unit>
        <trans-unit id="d9cdb2a3429ed04aaceb9e604669e39a56f8c661" translate="yes" xml:space="preserve">
          <source>The returned value is exact (&lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; is never raised) and independent of the current &lt;a href=&quot;../fenv/fe_round&quot;&gt;rounding mode&lt;/a&gt;.</source>
          <target state="translated">El valor devuelto es exacto ( &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; nunca se eleva) e independiente del &lt;a href=&quot;../fenv/fe_round&quot;&gt;modo de redondeo&lt;/a&gt; actual .</target>
        </trans-unit>
        <trans-unit id="724b8307d3008dac328f6b273599dff3480427e3" translate="yes" xml:space="preserve">
          <source>The returned value is exact, &lt;a href=&quot;../fenv/fe_round&quot;&gt;the current rounding mode&lt;/a&gt; is ignored</source>
          <target state="translated">El valor devuelto es exacto, se ignora el &lt;a href=&quot;../fenv/fe_round&quot;&gt;modo de redondeo actual&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="26627005fd8f0f998000eb5ad42f45195facac69" translate="yes" xml:space="preserve">
          <source>The rounding mode can be changed with &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/feround&quot;&gt;fesetround&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;FLT_ROUNDS&lt;/code&gt; reflects that change.</source>
          <target state="translated">El modo de redondeo se puede cambiar con &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/feround&quot;&gt;fesetround&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;FLT_ROUNDS&lt;/code&gt; refleja ese cambio.</target>
        </trans-unit>
        <trans-unit id="1208e3c0bd83fd14a6cdf867c21125c8a325392a" translate="yes" xml:space="preserve">
          <source>The same function may be registered more than once.</source>
          <target state="translated">La misma función puede registrarse más de una vez.</target>
        </trans-unit>
        <trans-unit id="36cca19123f3e3aecba38855a6236bf8a3be39e0" translate="yes" xml:space="preserve">
          <source>The scope of a name introduced in the parameter list of a &lt;a href=&quot;function_declaration&quot;&gt;function declaration&lt;/a&gt; that is not a definition ends at the end of the function &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt;.</source>
          <target state="translated">El alcance de un nombre introducido en la lista de par&amp;aacute;metros de una &lt;a href=&quot;function_declaration&quot;&gt;declaraci&amp;oacute;n de funci&amp;oacute;n&lt;/a&gt; que no es una definici&amp;oacute;n termina al final del &lt;a href=&quot;declarations&quot;&gt;declarador de&lt;/a&gt; funci&amp;oacute;n .</target>
        </trans-unit>
        <trans-unit id="08f9e9e6e1ccdae243de6a8dd152c835a4814d19" translate="yes" xml:space="preserve">
          <source>The scope of any identifier declared inside a &lt;a href=&quot;statements#Compound_statements&quot;&gt;compound statement&lt;/a&gt;, including function bodies, or in any expression, declaration, or statement appearing in &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt;, &lt;a href=&quot;switch&quot;&gt;switch&lt;/a&gt;, &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt;, &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt;, or &lt;a href=&quot;do&quot;&gt;do-while&lt;/a&gt; statement(since C99), or within the parameter list of a &lt;a href=&quot;function_definition&quot;&gt;function definition&lt;/a&gt; begins at the point of declaration and ends at the end of the block or statement in which it was declared.</source>
          <target state="translated">El alcance de cualquier identificador declarado dentro de una &lt;a href=&quot;statements#Compound_statements&quot;&gt;declaraci&amp;oacute;n compuesta&lt;/a&gt; , incluidos los cuerpos de funci&amp;oacute;n, o en cualquier expresi&amp;oacute;n, declaraci&amp;oacute;n o declaraci&amp;oacute;n que aparezca en la instrucci&amp;oacute;n &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; , &lt;a href=&quot;switch&quot;&gt;switch&lt;/a&gt; , &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt; , &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; o &lt;a href=&quot;do&quot;&gt;do-while&lt;/a&gt; (desde C99), o dentro de la lista de par&amp;aacute;metros de una &lt;a href=&quot;function_definition&quot;&gt;definici&amp;oacute;n de funci&amp;oacute;n&lt;/a&gt; comienza en el punto de declaraci&amp;oacute;n y termina al final del bloque o declaraci&amp;oacute;n en la que se declar&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="0da26ef01f7800f45aa5282d2dba502de493ec7e" translate="yes" xml:space="preserve">
          <source>The scope of any identifier declared outside of any block or parameter list begins at the point of declaration and ends at the end of the translation unit.</source>
          <target state="translated">El alcance de cualquier identificador declarado fuera de cualquier lista de bloques o parámetros comienza en el punto de declaración y termina al final de la unidad de traducción.</target>
        </trans-unit>
        <trans-unit id="1a55802911a29a7c84471e338e2b3d8f2f2258f6" translate="yes" xml:space="preserve">
          <source>The scope of any other identifier begins just after the end of its declarator and before the initializer, if any:</source>
          <target state="translated">El alcance de cualquier otro identificador comienza justo después del final de su declarante y antes del inicializador,si lo hay:</target>
        </trans-unit>
        <trans-unit id="cc8bc4ca47ab86782b6ebc508ebe6dfdcefc5516" translate="yes" xml:space="preserve">
          <source>The scope of enumeration constant begins immediately after the appearance of its defining enumerator in an enumerator list.</source>
          <target state="translated">El alcance de la constante de enumeración comienza inmediatamente después de la aparición de su enumerador definitorio en una lista de enumeradores.</target>
        </trans-unit>
        <trans-unit id="57eacece4f9fbc810d3e12053a65d86114435d0a" translate="yes" xml:space="preserve">
          <source>The scope of structure, union, and enumeration tags begins immediately after the appearance of the tag in a type specifier that declares the tag.</source>
          <target state="translated">El alcance de las etiquetas de estructura,unión y enumeración comienza inmediatamente después de la aparición de la etiqueta en un especificador de tipo que declara la etiqueta.</target>
        </trans-unit>
        <trans-unit id="1e1af425a408607461b9f2fb850e37301a9a085a" translate="yes" xml:space="preserve">
          <source>The scope of the aliasing assertion made by a restrict-qualified pointer that is a member of a struct is the scope of the identifier used to access the struct.</source>
          <target state="translated">El alcance de la afirmación de alias hecha por un puntero restringido que es miembro de una estructura es el alcance del identificador utilizado para acceder a la estructura.</target>
        </trans-unit>
        <trans-unit id="7a691571a758bb7696344431b9bfb2790b337304" translate="yes" xml:space="preserve">
          <source>The selection statements choose between one of several statements depending on the value of an expression.</source>
          <target state="translated">Las declaraciones de selección eligen entre una de varias declaraciones dependiendo del valor de una expresión.</target>
        </trans-unit>
        <trans-unit id="6f77a16398df99646e30617c7408e24bfd96747a" translate="yes" xml:space="preserve">
          <source>The semantics of &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt;/&lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt;/&lt;a href=&quot;restrict&quot;&gt;restrict&lt;/a&gt;-qualifiers and &lt;a href=&quot;atomic&quot;&gt;atomic&lt;/a&gt; types apply to lvalues only (lvalue conversion strips the qualifiers and removes atomicity).</source>
          <target state="translated">La sem&amp;aacute;ntica de los calificadores &lt;a href=&quot;const&quot;&gt;constantes&lt;/a&gt; / &lt;a href=&quot;volatile&quot;&gt;vol&amp;aacute;tiles&lt;/a&gt; / &lt;a href=&quot;restrict&quot;&gt;restringidos&lt;/a&gt; y &lt;a href=&quot;atomic&quot;&gt;los&lt;/a&gt; tipos at&amp;oacute;micos se aplica solo a los valores (la conversi&amp;oacute;n del valor elimina los calificadores y elimina la atomicidad).</target>
        </trans-unit>
        <trans-unit id="e3b735a300b426d2245b4cf296a3150fc21a63b1" translate="yes" xml:space="preserve">
          <source>The set of valid values for base is {0,2,3,...,36}. The set of valid digits for base-2 integers is &lt;code&gt;{0,1&lt;/code&gt;}, for base-3 integers is &lt;code&gt;{0,1,2&lt;/code&gt;}, and so on. For bases larger than &lt;code&gt;10&lt;/code&gt;, valid digits include alphabetic characters, starting from &lt;code&gt;Aa&lt;/code&gt; for base-11 integer, to &lt;code&gt;Zz&lt;/code&gt; for base-36 integer. The case of the characters is ignored.</source>
          <target state="translated">El conjunto de valores v&amp;aacute;lidos para base es {0,2,3, ..., 36}. El conjunto de d&amp;iacute;gitos v&amp;aacute;lidos para los enteros de base 2 es &lt;code&gt;{0,1&lt;/code&gt; }, para los enteros de base 3 es &lt;code&gt;{0,1,2&lt;/code&gt; }, y as&amp;iacute; sucesivamente. Para bases mayores de &lt;code&gt;10&lt;/code&gt; , los d&amp;iacute;gitos v&amp;aacute;lidos incluyen caracteres alfab&amp;eacute;ticos, comenzando desde &lt;code&gt;Aa&lt;/code&gt; para entero de base 11, hasta &lt;code&gt;Zz&lt;/code&gt; para entero de base 36. Se ignora el caso de los personajes.</target>
        </trans-unit>
        <trans-unit id="017c5419328af904a55edc0a14ee95f01cd1e984" translate="yes" xml:space="preserve">
          <source>The side effect of updating lhs is &lt;a href=&quot;eval_order&quot;&gt;sequenced after&lt;/a&gt; the value computations, but not the side effects of lhs and rhs themselves and the evaluations of the operands are, as usual, unsequenced relative to each other (so the expressions such as &lt;code&gt;i=++i&lt;/code&gt;; are undefined).</source>
          <target state="translated">El efecto secundario de actualizar lhs se &lt;a href=&quot;eval_order&quot;&gt;secuencia despu&amp;eacute;s de&lt;/a&gt; los c&amp;aacute;lculos del valor, pero no los efectos secundarios de lhs y rhs en s&amp;iacute; y las evaluaciones de los operandos son, como de costumbre, sin secuencia entre s&amp;iacute; (por lo que las expresiones como &lt;code&gt;i=++i&lt;/code&gt; ; est&amp;aacute;n indefinidos).</target>
        </trans-unit>
        <trans-unit id="aa84b13f6c6f705a05056a0bda3d55f618faac49" translate="yes" xml:space="preserve">
          <source>The sign of the remainder is defined in such a way that if the quotient &lt;code&gt;a/b&lt;/code&gt; is representable in the result type, then &lt;code&gt;(a/b)*b + a%b == a&lt;/code&gt;.</source>
          <target state="translated">El signo del resto se define de tal manera que si el cociente &lt;code&gt;a/b&lt;/code&gt; es representable en el tipo de resultado, entonces &lt;code&gt;(a/b)*b + a%b == a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35d03624f1f46c34b182260c7be6e91d340366f1" translate="yes" xml:space="preserve">
          <source>The sign of the result is the sign of the difference between the values of the first pair of bytes (both interpreted as &lt;code&gt;unsigned char&lt;/code&gt;) that differ in the objects being compared.</source>
          <target state="translated">El signo del resultado es el signo de la diferencia entre los valores del primer par de bytes (ambos interpretados como caracteres &lt;code&gt;unsigned char&lt;/code&gt; ) que difieren en los objetos que se comparan.</target>
        </trans-unit>
        <trans-unit id="bdf14ae5b468472769becbdbf9c46a2eef5effb8" translate="yes" xml:space="preserve">
          <source>The sign of the result is the sign of the difference between the values of the first pair of characters (both interpreted as &lt;code&gt;unsigned char&lt;/code&gt;) that differ in the arrays being compared.</source>
          <target state="translated">El signo del resultado es el signo de la diferencia entre los valores del primer par de caracteres (ambos interpretados como caracteres &lt;code&gt;unsigned char&lt;/code&gt; ) que difieren en las matrices que se comparan.</target>
        </trans-unit>
        <trans-unit id="e97cc12d1f3f2487de1b90ed0cc2090797374f8e" translate="yes" xml:space="preserve">
          <source>The sign of the result is the sign of the difference between the values of the first pair of characters (both interpreted as &lt;code&gt;unsigned char&lt;/code&gt;) that differ in the strings being compared.</source>
          <target state="translated">El signo del resultado es el signo de la diferencia entre los valores del primer par de caracteres (ambos interpretados como caracteres &lt;code&gt;unsigned char&lt;/code&gt; ) que difieren en las cadenas que se comparan.</target>
        </trans-unit>
        <trans-unit id="cde6f3dc011075607068991f0904ec95fd72723b" translate="yes" xml:space="preserve">
          <source>The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the arrays being compared.</source>
          <target state="translated">El signo del resultado es el signo de la diferencia entre los valores del primer par de caracteres anchos que difieren en las matrices que se están comparando.</target>
        </trans-unit>
        <trans-unit id="f67aeb4832459c9bfc7aeb9f457a87aa921f1247" translate="yes" xml:space="preserve">
          <source>The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the strings being compared.</source>
          <target state="translated">El signo del resultado es el signo de la diferencia entre los valores del primer par de caracteres anchos que difieren en las cadenas que se comparan.</target>
        </trans-unit>
        <trans-unit id="4d5cf620ffd0c069fb09e6109069ba28e165d978" translate="yes" xml:space="preserve">
          <source>The signature of the comparison function should be equivalent to the following:</source>
          <target state="translated">La firma de la función de comparación debe ser equivalente a la siguiente:</target>
        </trans-unit>
        <trans-unit id="cc273ef773a3a7c0899e6fca6178c1d007bc2d9a" translate="yes" xml:space="preserve">
          <source>The simple assignment operator expressions have the form.</source>
          <target state="translated">Las expresiones del operador de asignación simple tienen la forma.</target>
        </trans-unit>
        <trans-unit id="d18977a380068b230c78baa2354437eff8114c95" translate="yes" xml:space="preserve">
          <source>The sine is an entire function on the complex plane, and has no branch cuts.  Mathematical definition of the sine is sin z =</source>
          <target state="translated">El seno es una función completa en el plano complejo,y no tiene cortes en las ramas.La definición matemática del seno es sin z =</target>
        </trans-unit>
        <trans-unit id="17ebf122a1a6ba9d02af71043c41ad40d0313167" translate="yes" xml:space="preserve">
          <source>The size of a  non-VLA(since C99) array</source>
          <target state="translated">El tamaño de un conjunto no VLA (desde el C99)</target>
        </trans-unit>
        <trans-unit id="f653bb8a005764d6896a4c10b9fa21fa24e60bf7" translate="yes" xml:space="preserve">
          <source>The size of a &lt;a href=&quot;bit_field&quot;&gt;bit field&lt;/a&gt;.</source>
          <target state="translated">El tama&amp;ntilde;o de un &lt;a href=&quot;bit_field&quot;&gt;campo de bits&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e75b385c7daf43a9926f6adaeac9cb65f13d6dfe" translate="yes" xml:space="preserve">
          <source>The size of the array pointed to by &lt;code&gt;argv&lt;/code&gt; is at least &lt;code&gt;argc+1&lt;/code&gt;, and the last element, &lt;code&gt;argv[argc]&lt;/code&gt;, is guaranteed to be a null pointer.</source>
          <target state="translated">El tama&amp;ntilde;o de la matriz a la que apunta &lt;code&gt;argv&lt;/code&gt; es al menos &lt;code&gt;argc+1&lt;/code&gt; , y se garantiza que el &amp;uacute;ltimo elemento, &lt;code&gt;argv[argc]&lt;/code&gt; , es un puntero nulo.</target>
        </trans-unit>
        <trans-unit id="3facb159d302e57398e2b32d50c748002ccee995" translate="yes" xml:space="preserve">
          <source>The size of the pushback buffer varies in practice from 4k (Linux, MacOS) to as little as 4 (Solaris) or the guaranteed minimum 1 (HPUX, AIX).</source>
          <target state="translated">El tamaño del buffer de retroceso varía en la práctica de 4k (Linux,MacOS)a tan sólo 4 (Solaris)o el mínimo garantizado 1 (HPUX,AIX).</target>
        </trans-unit>
        <trans-unit id="1f06f6c9c240dd4e69a113d08da04d2bb7994431" translate="yes" xml:space="preserve">
          <source>The sleep may resume earlier if a &lt;code&gt;&lt;a href=&quot;../program/signal&quot;&gt;signal&lt;/a&gt;&lt;/code&gt; that is not ignored is received. In such case, if &lt;code&gt;remaining&lt;/code&gt; is not &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the remaining time duration is stored into the object pointed to by &lt;code&gt;remaining&lt;/code&gt;.</source>
          <target state="translated">El sue&amp;ntilde;o puede reanudarse antes si se recibe una &lt;code&gt;&lt;a href=&quot;../program/signal&quot;&gt;signal&lt;/a&gt;&lt;/code&gt; que no se ignora. En tal caso, si el &lt;code&gt;remaining&lt;/code&gt; no es &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; , la duraci&amp;oacute;n del tiempo restante se almacena en el objeto se&amp;ntilde;alado por &lt;code&gt;remaining&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c68bd152d82f0003bda7516721387df0de4bf1c" translate="yes" xml:space="preserve">
          <source>The sole exception to the maximal munch rule is:</source>
          <target state="translated">La única excepción a la regla de la máxima cantidad de comida es..:</target>
        </trans-unit>
        <trans-unit id="2cb0a56eaaaa4fbc79add39c3ae2bbcedba7c991" translate="yes" xml:space="preserve">
          <source>The special</source>
          <target state="translated">El especial</target>
        </trans-unit>
        <trans-unit id="e98e17952a5eb1144c7a18093ec87f2dc42631df" translate="yes" xml:space="preserve">
          <source>The standard &lt;a href=&quot;../preprocessor/impl&quot;&gt;#pragmas&lt;/a&gt;&lt;code&gt;FENV_ACCESS&lt;/code&gt;, &lt;code&gt;FP_CONTRACT&lt;/code&gt;, and &lt;code&gt;CX_LIMITED_RANGE&lt;/code&gt; as well as the &lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;floating-point evaluation precision&lt;/a&gt; and &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;rounding direction&lt;/a&gt; control the way floating-point expressions are executed.</source>
          <target state="translated">Los est&amp;aacute;ndares &lt;a href=&quot;../preprocessor/impl&quot;&gt;#pragmas &lt;/a&gt; &lt;code&gt;FENV_ACCESS&lt;/code&gt; , &lt;code&gt;FP_CONTRACT&lt;/code&gt; y &lt;code&gt;CX_LIMITED_RANGE&lt;/code&gt; , as&amp;iacute; como la &lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;precisi&amp;oacute;n de la evaluaci&amp;oacute;n de punto flotante&lt;/a&gt; y &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;redondeo direcci&amp;oacute;n&lt;/a&gt; de control de la forma en que las expresiones de punto flotante se ejecutan.</target>
        </trans-unit>
        <trans-unit id="0875738ad89941cbe8ee8aded99ef6d23319611f" translate="yes" xml:space="preserve">
          <source>The standard does not define any minimum implementation limit on translation units. A hosted environment has an operating system; a freestanding environment does not. A program running in a hosted environment may use all features described in the library clause (clause 7); a program running in a freestanding environment may use a subset of library features required by clause 4.</source>
          <target state="translated">En la norma no se define ningún límite mínimo de aplicación para las unidades de traducción.Un entorno alojado tiene un sistema operativo;un entorno autónomo no.Un programa que se ejecuta en un entorno hospedado puede utilizar todas las características descritas en la cláusula de biblioteca (cláusula 7);un programa que se ejecuta en un entorno autónomo puede utilizar un subconjunto de las características de biblioteca exigidas por la cláusula 4.</target>
        </trans-unit>
        <trans-unit id="6ea76ab6562da741fc1f1f80fa940f195cc6f7f0" translate="yes" xml:space="preserve">
          <source>The standard itself doesn't specify precedence levels. They are derived from the grammar.</source>
          <target state="translated">La norma en sí no especifica los niveles de precedencia.Se derivan de la gramática.</target>
        </trans-unit>
        <trans-unit id="0bdb3b500d50c7ecf224dc0445855ec04f49c235" translate="yes" xml:space="preserve">
          <source>The standard library offers convenience typedefs for the &lt;a href=&quot;language/atomic&quot;&gt;core language atomic types&lt;/a&gt;.</source>
          <target state="translated">La biblioteca est&amp;aacute;ndar ofrece definiciones de tipos convenientes para los &lt;a href=&quot;language/atomic&quot;&gt;tipos at&amp;oacute;micos del lenguaje central&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="19d78e0ab7d39ff1a14d8db8179cd35f2c750911" translate="yes" xml:space="preserve">
          <source>The standard library provides bounds-checked versions of some existing functions (&lt;code&gt;&lt;a href=&quot;io/gets&quot;&gt;gets_s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;io/fopen&quot;&gt;fopen_s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;io/fprintf&quot;&gt;printf_s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;string/byte/strcpy&quot;&gt;strcpy_s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;string/wide/wcscpy&quot;&gt;wcscpy_s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;string/multibyte/mbstowcs&quot;&gt;mbstowcs_s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;algorithm/qsort&quot;&gt;qsort_s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;program/getenv&quot;&gt;getenv_s&lt;/a&gt;&lt;/code&gt;, etc). This functionality is</source>
          <target state="translated">La biblioteca est&amp;aacute;ndar proporciona versiones con comprobaci&amp;oacute;n de l&amp;iacute;mites de algunas funciones existentes ( &lt;code&gt;&lt;a href=&quot;io/gets&quot;&gt;gets_s&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;io/fopen&quot;&gt;fopen_s&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;io/fprintf&quot;&gt;printf_s&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;string/byte/strcpy&quot;&gt;strcpy_s&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;string/wide/wcscpy&quot;&gt;wcscpy_s&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;string/multibyte/mbstowcs&quot;&gt;mbstowcs_s&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;algorithm/qsort&quot;&gt;qsort_s&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;program/getenv&quot;&gt;getenv_s&lt;/a&gt;&lt;/code&gt; , etc.). Esta funcionalidad es</target>
        </trans-unit>
        <trans-unit id="2ac1ff28429f739a4cc4c3cff8e4e5165e074955" translate="yes" xml:space="preserve">
          <source>The standard uses the term</source>
          <target state="translated">La norma utiliza el término</target>
        </trans-unit>
        <trans-unit id="0a3c7c787747b239e731a6608e43e2c196135b2e" translate="yes" xml:space="preserve">
          <source>The strings are modifiable, and any modifications made persist until program termination, although these modifications do not propagate back to the host environment: they can be used, for example, with &lt;code&gt;&lt;a href=&quot;../string/byte/strtok&quot;&gt;strtok&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Las cadenas son modificables y cualquier modificaci&amp;oacute;n realizada persiste hasta la finalizaci&amp;oacute;n del programa, aunque estas modificaciones no se propagan al entorno del host: se pueden usar, por ejemplo, con &lt;code&gt;&lt;a href=&quot;../string/byte/strtok&quot;&gt;strtok&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9716a65dc5ff30cff1eae2da273ac1d3064db74" translate="yes" xml:space="preserve">
          <source>The struct &lt;code&gt;lconv&lt;/code&gt; contains numeric and monetary formatting rules as defined by a C locale. Objects of this struct may be obtained with &lt;code&gt;&lt;a href=&quot;localeconv&quot;&gt;localeconv&lt;/a&gt;&lt;/code&gt;. The members of &lt;code&gt;lconv&lt;/code&gt; are values of type &lt;code&gt;char&lt;/code&gt; and of type &lt;code&gt;char*&lt;/code&gt;. Each &lt;code&gt;char*&lt;/code&gt; member except &lt;code&gt;decimal_point&lt;/code&gt; may be pointing at a null character (that is, at an empty C-string). The members of type &lt;code&gt;char&lt;/code&gt; are all non-negative numbers, any of which may be &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;CHAR_MAX&lt;/a&gt;&lt;/code&gt; if the corresponding value is not available in the current C locale.</source>
          <target state="translated">La estructura &lt;code&gt;lconv&lt;/code&gt; contiene reglas de formato num&amp;eacute;rico y monetario definidas por una configuraci&amp;oacute;n regional C. Los objetos de esta estructura se pueden obtener con &lt;code&gt;&lt;a href=&quot;localeconv&quot;&gt;localeconv&lt;/a&gt;&lt;/code&gt; . Los miembros de &lt;code&gt;lconv&lt;/code&gt; son valores de tipo &lt;code&gt;char&lt;/code&gt; y de tipo &lt;code&gt;char*&lt;/code&gt; . Cada miembro &lt;code&gt;char*&lt;/code&gt; excepto &lt;code&gt;decimal_point&lt;/code&gt; puede estar apuntando a un car&amp;aacute;cter nulo (es decir, a una cadena en C vac&amp;iacute;a). Los miembros del tipo &lt;code&gt;char&lt;/code&gt; son todos n&amp;uacute;meros no negativos, cualquiera de los cuales puede ser &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;CHAR_MAX&lt;/a&gt;&lt;/code&gt; si el valor correspondiente no est&amp;aacute; disponible en la configuraci&amp;oacute;n regional actual de C.</target>
        </trans-unit>
        <trans-unit id="bb3a4a16886cf1ac48a851932de21f81c40cea6b" translate="yes" xml:space="preserve">
          <source>The style used to print a NaN is implementation defined.</source>
          <target state="translated">El estilo utilizado para imprimir un NaN es la implementación definida.</target>
        </trans-unit>
        <trans-unit id="21517d748a5bfd69cdd8f8ab9d477a543e017a3d" translate="yes" xml:space="preserve">
          <source>The style used to print an infinity is implementation defined.</source>
          <target state="translated">El estilo utilizado para imprimir un infinito es la implementación definida.</target>
        </trans-unit>
        <trans-unit id="ad5440ec13a92105f54304efe3535cd3756f2e59" translate="yes" xml:space="preserve">
          <source>The subscript operator expression is an &lt;a href=&quot;value_category&quot;&gt;lvalue expression&lt;/a&gt; whose type is the type of the object pointed to by pointer-expression.</source>
          <target state="translated">La expresi&amp;oacute;n del operador de sub&amp;iacute;ndice es una &lt;a href=&quot;value_category&quot;&gt;expresi&amp;oacute;n de valor de l&lt;/a&gt; cuyo tipo es el tipo del objeto al que apunta puntero-expresi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1a8e214981c3b158eea8b2d5e47dd47f41913a7c" translate="yes" xml:space="preserve">
          <source>The sum of the returned value and the value stored in &lt;code&gt;*iptr&lt;/code&gt; gives &lt;code&gt;arg&lt;/code&gt; (allowing for rounding).</source>
          <target state="translated">La suma del valor devuelto y el valor almacenado en &lt;code&gt;*iptr&lt;/code&gt; da &lt;code&gt;arg&lt;/code&gt; (permitiendo el redondeo).</target>
        </trans-unit>
        <trans-unit id="21c84344f10b85ba83941112b65c0b80df28cba9" translate="yes" xml:space="preserve">
          <source>The synchronization is established only between the threads</source>
          <target state="translated">La sincronización se establece sólo entre los hilos</target>
        </trans-unit>
        <trans-unit id="a1fafb7379abc511f3f59880d1048edc9085d42e" translate="yes" xml:space="preserve">
          <source>The syntax of a function-like macro invocation is similar to the syntax of a function call: each instance of the macro name followed by a ( as the next preprocessing token introduces the sequence of tokens that is replaced by the replacement-list. The sequence is terminated by the matching ) token, skipping intervening matched pairs of left and right parentheses.</source>
          <target state="translated">La sintaxis de una macroinvocación similar a una función es similar a la sintaxis de una llamada a una función:cada instancia del nombre de la macro seguido de un(como la siguiente ficha de preprocesamiento introduce la secuencia de fichas que se sustituye por la lista de sustitución.La secuencia es terminada por la ficha de emparejamiento ),omitiendo los pares de paréntesis izquierdo y derecho que intervienen en el emparejamiento.</target>
        </trans-unit>
        <trans-unit id="927fb804cb2eaeff9acfcfdf70d5c596b423f6da" translate="yes" xml:space="preserve">
          <source>The temporary file created by this function is closed and deleted when the program exits normally. Whether it's deleted on abnormal termination is implementation-defined.</source>
          <target state="translated">El archivo temporal creado por esta función se cierra y se borra cuando el programa sale normalmente.Si se borra al salir de forma anormal está definido en la implementación.</target>
        </trans-unit>
        <trans-unit id="d35cf85afe81dba05bfcd30078a13ec4b61a6248" translate="yes" xml:space="preserve">
          <source>The terminating null character from &lt;code&gt;str&lt;/code&gt; is not written.</source>
          <target state="translated">El car&amp;aacute;cter nulo de terminaci&amp;oacute;n de &lt;code&gt;str&lt;/code&gt; no est&amp;aacute; escrito.</target>
        </trans-unit>
        <trans-unit id="7e942509d6816ccf9d123b1cf1595fd4cb7dbdb4" translate="yes" xml:space="preserve">
          <source>The terminating null wide character from &lt;code&gt;str&lt;/code&gt; is not written.</source>
          <target state="translated">El car&amp;aacute;cter ancho nulo de terminaci&amp;oacute;n de &lt;code&gt;str&lt;/code&gt; no est&amp;aacute; escrito.</target>
        </trans-unit>
        <trans-unit id="241931c273ba7378188c003511f787a3f07e8c4b" translate="yes" xml:space="preserve">
          <source>The termination of the thread</source>
          <target state="translated">La terminación del hilo</target>
        </trans-unit>
        <trans-unit id="dd5115b93d33b078df682a05c54e3833b8a2ca89" translate="yes" xml:space="preserve">
          <source>The thread identifiers may be reused for new threads once the thread has finished and joined or detached.</source>
          <target state="translated">Los identificadores de los hilos pueden ser reutilizados para nuevos hilos una vez que el hilo haya terminado y se haya unido o desprendido.</target>
        </trans-unit>
        <trans-unit id="1296acc3dd7bffb8fff38e6c9ab05728e64b068e" translate="yes" xml:space="preserve">
          <source>The three complex types are.</source>
          <target state="translated">Los tres tipos complejos son.</target>
        </trans-unit>
        <trans-unit id="37b60758934aabf8d3da266bd1b4b57e82722056" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;../thread&quot;&gt;thrd_start_t&lt;/a&gt;&lt;/code&gt; is a typedef of &lt;code&gt;int(*)(void*)&lt;/code&gt;, which differs from the POSIX equivalent &lt;code&gt;void*(*)(void*)&lt;/code&gt;.</source>
          <target state="translated">El tipo &lt;code&gt;&lt;a href=&quot;../thread&quot;&gt;thrd_start_t&lt;/a&gt;&lt;/code&gt; es un typedef de &lt;code&gt;int(*)(void*)&lt;/code&gt; , que difiere del equivalente POSIX &lt;code&gt;void*(*)(void*)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5d45e719006a644d4efb5b5f7ec023e503421b2" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;char&lt;/code&gt; is not compatible with &lt;code&gt;signed char&lt;/code&gt; and not compatible with &lt;code&gt;unsigned char&lt;/code&gt;.</source>
          <target state="translated">El tipo &lt;code&gt;char&lt;/code&gt; no es compatible con el &lt;code&gt;signed char&lt;/code&gt; y no es compatible con el &lt;code&gt;unsigned char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18f576269346b3fd8946fd4e3da2eb80a4056c88" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;mbstate_t&lt;/code&gt; is a trivial non-array type that can represent any of the conversion states that can occur in an implementation-defined set of supported multibyte character encoding rules. Zero-initialized value of &lt;code&gt;mbstate_t&lt;/code&gt; represents the initial conversion state, although other values of &lt;code&gt;mbstate_t&lt;/code&gt; may exist that also represent the initial conversion state.</source>
          <target state="translated">El tipo &lt;code&gt;mbstate_t&lt;/code&gt; es un tipo trivial sin matriz que puede representar cualquiera de los estados de conversi&amp;oacute;n que pueden ocurrir en un conjunto definido por la implementaci&amp;oacute;n de reglas de codificaci&amp;oacute;n de caracteres multibyte compatibles. El valor de inicializaci&amp;oacute;n cero de &lt;code&gt;mbstate_t&lt;/code&gt; representa el estado de conversi&amp;oacute;n inicial, aunque pueden existir otros valores de &lt;code&gt;mbstate_t&lt;/code&gt; que tambi&amp;eacute;n representen el estado de conversi&amp;oacute;n inicial.</target>
        </trans-unit>
        <trans-unit id="bc4d74ec38eba7b867e7d4d689b5241938a4d1b3" translate="yes" xml:space="preserve">
          <source>The type after conversion is compared with type-names from the list of associations.</source>
          <target state="translated">El tipo después de la conversión se compara con los nombres de tipo de la lista de asociaciones.</target>
        </trans-unit>
        <trans-unit id="83ef2bff6850ff84da9eceaeb8081fce468a3423" translate="yes" xml:space="preserve">
          <source>The type of any equality operator expression is &lt;code&gt;int&lt;/code&gt;, and its value (which is not an lvalue) is &lt;code&gt;1&lt;/code&gt; when the specified relationship holds true and &lt;code&gt;​0​&lt;/code&gt; when the specified relationship does not hold.</source>
          <target state="translated">El tipo de cualquier expresi&amp;oacute;n operador de igualdad es &lt;code&gt;int&lt;/code&gt; , y su valor (que no es un lvalue) es &lt;code&gt;1&lt;/code&gt; cuando la relaci&amp;oacute;n especificada es v&amp;aacute;lido y &lt;code&gt;​0​&lt;/code&gt; cuando la relaci&amp;oacute;n especificada no se sostiene.</target>
        </trans-unit>
        <trans-unit id="d31a9fe37a49aeb320a1d46d51c8f069e7627c13" translate="yes" xml:space="preserve">
          <source>The type of any relational operator expression is &lt;code&gt;int&lt;/code&gt;, and its value (which is not an lvalue) is &lt;code&gt;1&lt;/code&gt; when the specified relationship holds true and &lt;code&gt;​0​&lt;/code&gt; when the specified relationship does not hold.</source>
          <target state="translated">El tipo de cualquier expresi&amp;oacute;n operador relacional es &lt;code&gt;int&lt;/code&gt; , y su valor (que no es un lvalue) es &lt;code&gt;1&lt;/code&gt; cuando la relaci&amp;oacute;n especificada es v&amp;aacute;lido y &lt;code&gt;​0​&lt;/code&gt; cuando la relaci&amp;oacute;n especificada no se sostiene.</target>
        </trans-unit>
        <trans-unit id="811237a08cfbebd18d4367ab827711b9115f6d3d" translate="yes" xml:space="preserve">
          <source>The type of each identifier introduced in a declaration is determined by a combination of the type specified by the type specifier and the type modifications applied by its declarator.</source>
          <target state="translated">El tipo de cada identificador introducido en una declaración se determina mediante una combinación del tipo especificado por el especificador de tipo y las modificaciones de tipo aplicadas por su declarante.</target>
        </trans-unit>
        <trans-unit id="d71eed56481373e458e0b94319f5f5bf3221d2ca" translate="yes" xml:space="preserve">
          <source>The type of the compound literal is type (except when type is an array of unknown size; its size is deduced from the initializer-list as in &lt;a href=&quot;array_initialization&quot;&gt;array initialization&lt;/a&gt;).</source>
          <target state="translated">El tipo del literal compuesto es tipo (excepto cuando el tipo es una matriz de tama&amp;ntilde;o desconocido; su tama&amp;ntilde;o se deduce de la lista de inicializadores como en la &lt;a href=&quot;array_initialization&quot;&gt;inicializaci&amp;oacute;n de la matriz&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="63e1afdcfba845cebcfec884ec5a8ac155768c26" translate="yes" xml:space="preserve">
          <source>The type of the expression is the type after promotion, and the &lt;a href=&quot;value_category&quot;&gt;value category&lt;/a&gt; is non-lvalue.</source>
          <target state="translated">El tipo de la expresi&amp;oacute;n es el tipo despu&amp;eacute;s de la promoci&amp;oacute;n, y la &lt;a href=&quot;value_category&quot;&gt;categor&amp;iacute;a de valor&lt;/a&gt; no es lvalue.</target>
        </trans-unit>
        <trans-unit id="e98e4102e24f34077fe9171371257f25c10edbfd" translate="yes" xml:space="preserve">
          <source>The type of the integer constant</source>
          <target state="translated">El tipo de la constante entera</target>
        </trans-unit>
        <trans-unit id="2680965a70e519d3207938fce242cd69e5be4916" translate="yes" xml:space="preserve">
          <source>The type of the integer constant is the first type in which the value can fit, from the list of types which depends on which numeric base and which integer-suffix was used.</source>
          <target state="translated">El tipo de la constante entera es el primer tipo en el que puede caber el valor,de la lista de tipos que depende de qué base numérica y qué sufijo entero se utilizó.</target>
        </trans-unit>
        <trans-unit id="829b1b1c6864595e1de1d8e5d9152081192a921a" translate="yes" xml:space="preserve">
          <source>The type of the lhs may be &lt;code&gt;void&lt;/code&gt; (that is, it may be a call to a function that returns &lt;code&gt;void&lt;/code&gt;, or it can be an expression &lt;a href=&quot;cast&quot;&gt;cast&lt;/a&gt; to &lt;code&gt;void&lt;/code&gt;).</source>
          <target state="translated">El tipo de lhs puede ser &lt;code&gt;void&lt;/code&gt; (es decir, puede ser una llamada a una funci&amp;oacute;n que devuelve &lt;code&gt;void&lt;/code&gt; , o puede ser una expresi&amp;oacute;n &lt;a href=&quot;cast&quot;&gt;convertida&lt;/a&gt; en &lt;code&gt;void&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="447849d54c1d67d6b61329201208de7c3155cd27" translate="yes" xml:space="preserve">
          <source>The type representing all floating-point status flags collectively</source>
          <target state="translated">El tipo que representa todas las banderas de estado de punto flotante colectivamente</target>
        </trans-unit>
        <trans-unit id="66cad8bd68a6349c324c8b818f25bd23910481f3" translate="yes" xml:space="preserve">
          <source>The type representing the entire floating-point environment</source>
          <target state="translated">El tipo que representa todo el entorno de punto flotante</target>
        </trans-unit>
        <trans-unit id="0cffaa40c40ebaf49e36b504549168d080b200aa" translate="yes" xml:space="preserve">
          <source>The type-generic macros are as follows:</source>
          <target state="translated">Los macros genéricos de tipo son los siguientes:</target>
        </trans-unit>
        <trans-unit id="3596eb5ea91c2633e1f6227c5debdbd1c9d68bf6" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; are compatible, if.</source>
          <target state="translated">Los tipos &lt;code&gt;T&lt;/code&gt; y &lt;code&gt;U&lt;/code&gt; son compatibles, si.</target>
        </trans-unit>
        <trans-unit id="ac4bdd032acdf24d44472ac4ff1c101e18823b80" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;float_t&lt;/code&gt; and &lt;code&gt;double_t&lt;/code&gt; are floating types at least as wide as &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt;, respectively, and such that &lt;code&gt;double_t&lt;/code&gt; is at least as wide as &lt;code&gt;float_t&lt;/code&gt;. The value of &lt;code&gt;&lt;a href=&quot;../../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt; determines the types of &lt;code&gt;float_t&lt;/code&gt; and &lt;code&gt;double_t&lt;/code&gt;.</source>
          <target state="translated">Los tipos &lt;code&gt;float_t&lt;/code&gt; y &lt;code&gt;double_t&lt;/code&gt; son tipos flotantes al menos tan anchos como &lt;code&gt;float&lt;/code&gt; y &lt;code&gt;double&lt;/code&gt; , respectivamente, y de modo que &lt;code&gt;double_t&lt;/code&gt; es al menos tan ancho como &lt;code&gt;float_t&lt;/code&gt; . El valor de &lt;code&gt;&lt;a href=&quot;../../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt; determina los tipos de &lt;code&gt;float_t&lt;/code&gt; y &lt;code&gt;double_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b6e26a516b34b7af57fc7012be60e25328df076" translate="yes" xml:space="preserve">
          <source>The unary arithmetic operator expressions have the form.</source>
          <target state="translated">Las expresiones del operador aritmético unario tienen la forma.</target>
        </trans-unit>
        <trans-unit id="1c3a2c1487d550c3fde0d68fbc12ecebb306ba75" translate="yes" xml:space="preserve">
          <source>The unary minus invokes undefined behavior due to signed integer overflow when applied to &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;LONG_MIN&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;LLONG_MIN&lt;/a&gt;&lt;/code&gt;, on typical (2's complement) platforms.</source>
          <target state="translated">El menos unario invoca un comportamiento indefinido debido al desbordamiento de enteros con signo cuando se aplica a &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;LONG_MIN&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;LLONG_MIN&lt;/a&gt;&lt;/code&gt; , en plataformas t&amp;iacute;picas (complemento de 2).</target>
        </trans-unit>
        <trans-unit id="f88c0e3c533664fbb73db04c0a5c2f3e03a61631" translate="yes" xml:space="preserve">
          <source>The union is only as big as necessary to hold its largest member (additional unnamed trailing padding may also be added). The other members are allocated in the same bytes as part of that largest member.</source>
          <target state="translated">La unión es sólo tan grande como sea necesario para sostener a su miembro más grande (también se puede agregar un acolchado adicional sin nombre).Los demás miembros se asignan en los mismos bytes como parte de ese miembro más grande.</target>
        </trans-unit>
        <trans-unit id="9dee7b9a492616febe6c3fc4efadefd3ada5e33b" translate="yes" xml:space="preserve">
          <source>The unnamed object to which the compound literal evaluates has static &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; if the compound literal occurs at file scope and automatic &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; if the compound literal occurs at block scope (in which case the object's &lt;a href=&quot;lifetime&quot;&gt;lifetime&lt;/a&gt; ends at the end of the enclosing block).</source>
          <target state="translated">El objeto sin nombre al que eval&amp;uacute;a el literal compuesto tiene &lt;a href=&quot;storage_duration&quot;&gt;una duraci&amp;oacute;n de almacenamiento&lt;/a&gt; est&amp;aacute;tico si el literal compuesto ocurre en el alcance del archivo y la &lt;a href=&quot;storage_duration&quot;&gt;duraci&amp;oacute;n de almacenamiento&lt;/a&gt; autom&amp;aacute;tico si el literal compuesto ocurre en el alcance del bloque (en cuyo caso la &lt;a href=&quot;lifetime&quot;&gt;vida &amp;uacute;til&lt;/a&gt; del objeto termina al final del bloque que lo encierra).</target>
        </trans-unit>
        <trans-unit id="0abb6094d96df27f0d637760f1d1f17013caac08" translate="yes" xml:space="preserve">
          <source>The use of alignof with expressions is allowed by some C compilers as a non-standard extension.</source>
          <target state="translated">Algunos compiladores de C permiten el uso de alignof con expresiones como una extensión no estándar.</target>
        </trans-unit>
        <trans-unit id="0b44666438f2ec28588f661880af1a91734f0eee" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; is associated with the newly created key in all existing threads, and upon thread creation, the values associated with all TSS keys is initialized to &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">El valor &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; est&amp;aacute; asociado con la clave reci&amp;eacute;n creada en todos los subprocesos existentes, y al crear el subproceso, los valores asociados con todas las claves TSS se inicializan en &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a983788a30d253bace1a068a44d1826dc47d6596" translate="yes" xml:space="preserve">
          <source>The value category of a compound literal is &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; (its address can be taken).</source>
          <target state="translated">La categor&amp;iacute;a de valor de un literal compuesto es &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; (se puede tomar su direcci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="ae6d7ff00e83423b304179c97fa6160b61c7d16c" translate="yes" xml:space="preserve">
          <source>The value computed by this function is the length of the hypotenuse of a right-angled triangle with sides of length &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, or the distance of the point &lt;code&gt;(x,y)&lt;/code&gt; from the origin &lt;code&gt;(0,0)&lt;/code&gt;, or the magnitude of a complex number &lt;code&gt;x+&lt;i&gt;i&lt;/i&gt;y&lt;/code&gt;.</source>
          <target state="translated">El valor calculado por esta funci&amp;oacute;n es la longitud de la hipotenusa de un tri&amp;aacute;ngulo rect&amp;aacute;ngulo con lados de longitud &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; , o la distancia del punto &lt;code&gt;(x,y)&lt;/code&gt; desde el origen &lt;code&gt;(0,0)&lt;/code&gt; , o la magnitud de un n&amp;uacute;mero complejo &lt;code&gt;x+&lt;i&gt;i&lt;/i&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8db27de9a2c14b5c36e77ac11db7b1e6b539ddf4" translate="yes" xml:space="preserve">
          <source>The value held previously be the atomic object pointed to by &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">El valor mantenido anteriormente ser&amp;aacute; el objeto at&amp;oacute;mico se&amp;ntilde;alado por &lt;code&gt;obj&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7044fe5027fd6004978c59ea869f2af588568b11" translate="yes" xml:space="preserve">
          <source>The value held previously by the atomic object pointed to by &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">El valor mantenido anteriormente por el objeto at&amp;oacute;mico al que apunta &lt;code&gt;obj&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74363b0d87e71eb3303d92bd255f435d2a3c664f" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;base&lt;/code&gt; if successful, zero otherwise.</source>
          <target state="translated">El valor de &lt;code&gt;base&lt;/code&gt; si tiene &amp;eacute;xito, cero de lo contrario.</target>
        </trans-unit>
        <trans-unit id="56ee130795a5dbf75897c6a6783296c3ad1b779f" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;errno&lt;/code&gt; is &lt;code&gt;​0​&lt;/code&gt; at program startup, and although library functions are allowed to write positive integers to &lt;code&gt;errno&lt;/code&gt; whether or not an error occurred, library functions never store &lt;code&gt;​0​&lt;/code&gt; in &lt;code&gt;errno&lt;/code&gt;.</source>
          <target state="translated">El valor de &lt;code&gt;errno&lt;/code&gt; es &lt;code&gt;​0​&lt;/code&gt; al inicio del programa, y aunque se permiten funciones de biblioteca para escribir n&amp;uacute;meros enteros positivos a &lt;code&gt;errno&lt;/code&gt; si se produjo o no un error, funciones de biblioteca Nunca almacene &lt;code&gt;​0​&lt;/code&gt; en &lt;code&gt;errno&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da2294d8108c3a6f801f89b03514268af0f31351" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;math_errhandling&lt;/code&gt; indicates the type of error handling that is performed by the floating-point operators and &lt;a href=&quot;../math&quot;&gt;functions&lt;/a&gt;:</source>
          <target state="translated">El valor de &lt;code&gt;math_errhandling&lt;/code&gt; indica el tipo de manejo de errores que realizan los operadores y &lt;a href=&quot;../math&quot;&gt;funciones de&lt;/a&gt; punto flotante :</target>
        </trans-unit>
        <trans-unit id="3ce421ed8122dc0c953b3daa7401767634d485f5" translate="yes" xml:space="preserve">
          <source>The value of a floating-point static initializer is never less accurate than the value of the same expression executed at run time, but it may be better.</source>
          <target state="translated">El valor de un inicializador estático en punto flotante nunca es menos exacto que el valor de la misma expresión ejecutada en tiempo de ejecución,pero puede ser mejor.</target>
        </trans-unit>
        <trans-unit id="adea83a39e96975099582b35000c5f6ef163b872" translate="yes" xml:space="preserve">
          <source>The value of an &lt;a href=&quot;enum&quot;&gt;enumeration constant&lt;/a&gt;</source>
          <target state="translated">El valor de una &lt;a href=&quot;enum&quot;&gt;constante de enumeraci&amp;oacute;n&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2319cb95fe6c4140766f25ba6aceff81797d3bc7" translate="yes" xml:space="preserve">
          <source>The value of the exponent returned by &lt;code&gt;ilogb&lt;/code&gt; is always 1 less than the exponent retuned by &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;frexp&lt;/a&gt;&lt;/code&gt; because of the different normalization requirements: for the exponent &lt;code&gt;e&lt;/code&gt; returned by &lt;code&gt;ilogb&lt;/code&gt;, |arg*r-e</source>
          <target state="translated">El valor del exponente devuelto por &lt;code&gt;ilogb&lt;/code&gt; siempre es 1 menor que el exponente reajustado por &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;frexp&lt;/a&gt;&lt;/code&gt; debido a los diferentes requisitos de normalizaci&amp;oacute;n: para el exponente &lt;code&gt;e&lt;/code&gt; devuelto por &lt;code&gt;ilogb&lt;/code&gt; , | arg * re</target>
        </trans-unit>
        <trans-unit id="9ae0f9145d3f54ff503856e7f95a6dee62b616ad" translate="yes" xml:space="preserve">
          <source>The value of the exponent returned by &lt;code&gt;logb&lt;/code&gt; is always 1 less than the exponent retuned by &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;frexp&lt;/a&gt;&lt;/code&gt; because of the different normalization requirements: for the exponent &lt;code&gt;e&lt;/code&gt; returned by &lt;code&gt;logb&lt;/code&gt;, |arg*r-e</source>
          <target state="translated">El valor del exponente devuelto por &lt;code&gt;logb&lt;/code&gt; es siempre 1 menor que el exponente reajustado por &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;frexp&lt;/a&gt;&lt;/code&gt; debido a los diferentes requisitos de normalizaci&amp;oacute;n: para el exponente &lt;code&gt;e&lt;/code&gt; devuelto por &lt;code&gt;logb&lt;/code&gt; , | arg * re</target>
        </trans-unit>
        <trans-unit id="1c338856b102032dd7454b82d3852e88916b004c" translate="yes" xml:space="preserve">
          <source>The value on success, &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="translated">El valor en caso de &amp;eacute;xito, &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; en caso de error.</target>
        </trans-unit>
        <trans-unit id="cc1839c6dd4f14d95b9fec518dce3cd0ccd9859a" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;clock()&lt;/code&gt; may wrap around on some implementations. For example, on a machine with 32-bit &lt;code&gt;&lt;a href=&quot;clock_t&quot;&gt;clock_t&lt;/a&gt;&lt;/code&gt;, it wraps after 2147 seconds or 36 minutes.</source>
          <target state="translated">El valor devuelto por &lt;code&gt;clock()&lt;/code&gt; puede ajustarse en algunas implementaciones. Por ejemplo, en una m&amp;aacute;quina con &lt;code&gt;&lt;a href=&quot;clock_t&quot;&gt;clock_t&lt;/a&gt;&lt;/code&gt; de 32 bits , se ajusta despu&amp;eacute;s de 2147 segundos o 36 minutos.</target>
        </trans-unit>
        <trans-unit id="7a76aed414f920671ac2d5636063f80c02930b91" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;p_sep_by_space&lt;/code&gt;, &lt;code&gt;n_sep_by_space&lt;/code&gt;, &lt;code&gt;int_p_sep_by_space&lt;/code&gt;, &lt;code&gt;int_n_sep_by_space&lt;/code&gt; are interpreted as follows:</source>
          <target state="translated">Los valores de &lt;code&gt;p_sep_by_space&lt;/code&gt; , &lt;code&gt;n_sep_by_space&lt;/code&gt; , &lt;code&gt;int_p_sep_by_space&lt;/code&gt; , &lt;code&gt;int_n_sep_by_space&lt;/code&gt; se interpretan de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="77672f917a9b339a086c2698e191450e19cf6727" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;p_sign_posn&lt;/code&gt;, &lt;code&gt;n_sign_posn&lt;/code&gt;, &lt;code&gt;int_p_sign_posn&lt;/code&gt;, &lt;code&gt;int_n_sign_posn&lt;/code&gt; are interpreted as follows:</source>
          <target state="translated">Los valores de &lt;code&gt;p_sign_posn&lt;/code&gt; , &lt;code&gt;n_sign_posn&lt;/code&gt; , &lt;code&gt;int_p_sign_posn&lt;/code&gt; , &lt;code&gt;int_n_sign_posn&lt;/code&gt; se interpretan de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="e9fe6d1f76a572b29a8d3484a98866cb41ec603b" translate="yes" xml:space="preserve">
          <source>The values of these macros (except for &lt;code&gt;__FILE__&lt;/code&gt; and &lt;code&gt;__LINE__&lt;/code&gt;) remain constant throughout the translation unit. Attempts to redefine or undefine these macros result in undefined behavior.</source>
          <target state="translated">Los valores de estas macros (excepto &lt;code&gt;__FILE__&lt;/code&gt; y &lt;code&gt;__LINE__&lt;/code&gt; ) permanecen constantes en toda la unidad de traducci&amp;oacute;n. Los intentos de redefinir o indefinir estas macros resultan en un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="8eb246d2ead310c8f059b8b86885fc138b2913d2" translate="yes" xml:space="preserve">
          <source>The weak forms ((2) and (4)) of the functions are allowed to fail spuriously, that is, act as if &lt;code&gt;*obj != *expected&lt;/code&gt; even if they are equal. When a compare-and-exchange is in a loop, the weak version will yield better performance on some platforms. When a weak compare-and-exchange would require a loop and a strong one would not, the strong one is preferable.</source>
          <target state="translated">Las formas d&amp;eacute;biles ((2) y (4)) de las funciones pueden fallar falsamente, es decir, actuar como si &lt;code&gt;*obj != *expected&lt;/code&gt; incluso si son iguales. Cuando una comparaci&amp;oacute;n e intercambio est&amp;aacute; en un bucle, la versi&amp;oacute;n d&amp;eacute;bil producir&amp;aacute; un mejor rendimiento en algunas plataformas. Cuando una comparaci&amp;oacute;n e intercambio d&amp;eacute;bil requerir&amp;iacute;a un bucle y uno fuerte no, el preferible es el fuerte.</target>
        </trans-unit>
        <trans-unit id="1afb1ba711265f6de0e35e414290ff85c3a2ad0f" translate="yes" xml:space="preserve">
          <source>Then, a &lt;a href=&quot;eval_order&quot;&gt;sequence point&lt;/a&gt; takes place, so that all side effects of lhs are complete.</source>
          <target state="translated">Luego, tiene lugar un &lt;a href=&quot;eval_order&quot;&gt;punto de secuencia&lt;/a&gt; , de modo que todos los efectos secundarios de lhs est&amp;aacute;n completos.</target>
        </trans-unit>
        <trans-unit id="cb90fa2576c7925b07f1e1ac9159668e2bf9b053" translate="yes" xml:space="preserve">
          <source>Then, the corresponding binary logic operators are applied bitwise; that is, each bit of the result is set or cleared according to the logic operation (NOT, AND, OR, or XOR), applied to the corresponding bits of the operands.</source>
          <target state="translated">A continuación,se aplican los operadores lógicos binarios correspondientes en función de los bits,es decir,cada bit del resultado se fija o se borra según la operación lógica (NOT,AND,OR,o XOR),aplicada a los bits correspondientes de los operandos.</target>
        </trans-unit>
        <trans-unit id="f7078c4d1c98d55c4bc04aaeacb070077101e980" translate="yes" xml:space="preserve">
          <source>Then, the right operand, rhs, is evaluated and its result is returned by the comma operator as a &lt;a href=&quot;value_category&quot;&gt;non-lvalue&lt;/a&gt;.</source>
          <target state="translated">Luego, se eval&amp;uacute;a el operando correcto, rhs, y el operador de coma devuelve su resultado como un valor &lt;a href=&quot;value_category&quot;&gt;no l&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7b3f137a362c8e821a1e6b9a4948bb2c26de27af" translate="yes" xml:space="preserve">
          <source>There are alternative spellings for the operators that use non-ISO646 characters, defined in &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; as macros:</source>
          <target state="translated">Hay ortograf&amp;iacute;as alternativas para los operadores que usan caracteres que no son ISO646, definidos en &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; como macros:</target>
        </trans-unit>
        <trans-unit id="eba25eb602283568b271842c052f8b74fae72c6c" translate="yes" xml:space="preserve">
          <source>There are five types of statements:</source>
          <target state="translated">Hay cinco tipos de declaraciones:</target>
        </trans-unit>
        <trans-unit id="6772e38914753165f4023b86ef3b645e638c1de8" translate="yes" xml:space="preserve">
          <source>There are four coherences that are guaranteed for all atomic operations:</source>
          <target state="translated">Hay cuatro coherencias que están garantizadas para todas las operaciones atómicas:</target>
        </trans-unit>
        <trans-unit id="beccd582c554354fe97bf6fe8f530cf6be9b9156" translate="yes" xml:space="preserve">
          <source>There are many different NaN values with different sign bits and payloads, see &lt;code&gt;&lt;a href=&quot;nan.2&quot;&gt;nan&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Hay muchos valores diferentes de NaN con diferentes bits de signo y cargas &amp;uacute;tiles, ver &lt;code&gt;&lt;a href=&quot;nan.2&quot;&gt;nan&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e03334de5cfa0b9f96707c08d7bef755bc11a3c" translate="yes" xml:space="preserve">
          <source>There are many different NaN values, differentiated by their payloads and their sign bits. The contents of the payload and the sign bit of the NaN generated by the macro &lt;code&gt;NAN&lt;/code&gt; are implementation-defined.</source>
          <target state="translated">Hay muchos valores diferentes de NaN, diferenciados por sus cargas &amp;uacute;tiles y sus bits de signo. El contenido de la carga &amp;uacute;til y el bit de signo del NaN generado por la macro &lt;code&gt;NAN&lt;/code&gt; est&amp;aacute;n definidos por la implementaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="59b96aea907cb0b6e15b2cdf641639fef1154954" translate="yes" xml:space="preserve">
          <source>There are no conversions (implicit or explicit) between pointers to functions and pointers to objects (including void*) or integers.</source>
          <target state="translated">No hay conversiones (implícitas o explícitas)entre los punteros a funciones y los punteros a objetos (incluido el vacío*)o números enteros.</target>
        </trans-unit>
        <trans-unit id="b92ddc58d5de1bff3b780dc60945b52fcda99d6e" translate="yes" xml:space="preserve">
          <source>There are no guarantees as to the quality of the random sequence produced. In the past, some implementations of &lt;code&gt;rand()&lt;/code&gt; have had serious shortcomings in the randomness, distribution and period of the sequence produced (in one well-known example, the low-order bit simply alternated between &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;0&lt;/code&gt; between calls). &lt;code&gt;rand()&lt;/code&gt; is not recommended for serious random-number generation needs, like cryptography.</source>
          <target state="translated">No hay garant&amp;iacute;as en cuanto a la calidad de la secuencia aleatoria producida. En el pasado, algunas implementaciones de &lt;code&gt;rand()&lt;/code&gt; han tenido serias deficiencias en la aleatoriedad, distribuci&amp;oacute;n y per&amp;iacute;odo de la secuencia producida (en un ejemplo bien conocido, el bit de bajo orden simplemente alternaba entre &lt;code&gt;1&lt;/code&gt; y &lt;code&gt;0&lt;/code&gt; entre llamadas). &lt;code&gt;rand()&lt;/code&gt; no se recomienda para necesidades serias de generaci&amp;oacute;n de n&amp;uacute;meros aleatorios, como la criptograf&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="588bd29754314126c33aee156a614a561e64c447" translate="yes" xml:space="preserve">
          <source>There are no negative floating constants; an expression such as &lt;code&gt;-1.2&lt;/code&gt; is the &lt;a href=&quot;operator_arithmetic&quot;&gt;arithmetic operator&lt;/a&gt; unary minus applied to the floating constant &lt;code&gt;1.2&lt;/code&gt;. Note that the special value negative zero may be constructed with &lt;code&gt;-0.0&lt;/code&gt;.</source>
          <target state="translated">No hay constantes flotantes negativas; Una expresi&amp;oacute;n como &lt;code&gt;-1.2&lt;/code&gt; es el &lt;a href=&quot;operator_arithmetic&quot;&gt;operador aritm&amp;eacute;tico&lt;/a&gt; unario menos aplicado a la constante flotante &lt;code&gt;1.2&lt;/code&gt; . Tenga en cuenta que el valor especial cero negativo puede construirse con &lt;code&gt;-0.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdca7722c2b3b18ea7c62a79f1fda46ad671b715" translate="yes" xml:space="preserve">
          <source>There are no negative integer constants. Expressions such as &lt;code&gt;-1&lt;/code&gt; apply the &lt;a href=&quot;operator_arithmetic&quot;&gt;unary minus operator&lt;/a&gt; to the value represented by the constant, which may involve implicit &lt;a href=&quot;conversion&quot;&gt;type conversions&lt;/a&gt;.</source>
          <target state="translated">No hay constantes enteras negativas. Expresiones como &lt;code&gt;-1&lt;/code&gt; aplican el &lt;a href=&quot;operator_arithmetic&quot;&gt;operador menos unario&lt;/a&gt; al valor representado por la constante, que puede implicar &lt;a href=&quot;conversion&quot;&gt;conversiones de tipo&lt;/a&gt; impl&amp;iacute;cito .</target>
        </trans-unit>
        <trans-unit id="9a3b42ee7caccbfb7868142d55eb631f71011dee" translate="yes" xml:space="preserve">
          <source>There are no nested functions (except where allowed through non-standard compiler extensions): each function definition must appear at file scope, and functions have no access to the local variables from the caller:</source>
          <target state="translated">No hay funciones anidadas (excepto cuando se permiten a través de extensiones de compilador no estándar):cada definición de función debe aparecer en el ámbito del archivo,y las funciones no tienen acceso a las variables locales del llamante:</target>
        </trans-unit>
        <trans-unit id="6c2d3c4f220b5494a67a0f9953dc898467eabcbd" translate="yes" xml:space="preserve">
          <source>There are several common usage patterns for restrict-qualified pointers:</source>
          <target state="translated">Hay varios patrones de uso común para los punteros restringidos:</target>
        </trans-unit>
        <trans-unit id="3adc61e5da640a9ba91547c50c8ab6dddb0048c4" translate="yes" xml:space="preserve">
          <source>There are several variations of array types: arrays of known constant size, variable-length arrays, and arrays of unknown size.</source>
          <target state="translated">Hay varias variaciones de tipos de arreglos:arreglos de tamaño constante conocido,arreglos de longitud variable y arreglos de tamaño desconocido.</target>
        </trans-unit>
        <trans-unit id="4997b02e62e6a0e4ec89133d02261fc0ce72b438" translate="yes" xml:space="preserve">
          <source>There are two kinds of evaluations performed by the compiler for each expression or subexpression (both of which are optional):</source>
          <target state="translated">Hay dos tipos de evaluaciones realizadas por el compilador para cada expresión o subexpresión (ambas son opcionales):</target>
        </trans-unit>
        <trans-unit id="d6fabe6d44b488b86750b5227d2a79c424b55dd2" translate="yes" xml:space="preserve">
          <source>There is a &lt;a href=&quot;../language/eval_order&quot;&gt;sequence point&lt;/a&gt; after the action of each conversion specifier; this permits storing multiple &lt;code&gt;%n&lt;/code&gt; results in the same variable or, as an edge case, printing a string modified by an earlier &lt;code&gt;%n&lt;/code&gt; within the same call.</source>
          <target state="translated">Hay un &lt;a href=&quot;../language/eval_order&quot;&gt;punto de secuencia&lt;/a&gt; despu&amp;eacute;s de la acci&amp;oacute;n de cada especificador de conversi&amp;oacute;n; esto permite almacenar m&amp;uacute;ltiples resultados &lt;code&gt;%n&lt;/code&gt; en la misma variable o, como caso l&amp;iacute;mite, imprimir una cadena modificada por un &lt;code&gt;%n&lt;/code&gt; anterior dentro de la misma llamada.</target>
        </trans-unit>
        <trans-unit id="52984a17b30b0d82af603d64b3c7eb96ca2c2d00" translate="yes" xml:space="preserve">
          <source>There is a &lt;a href=&quot;../language/eval_order&quot;&gt;sequence point&lt;/a&gt; after the action of each conversion specifier; this permits storing multiple fields in the same &quot;sink&quot; variable.</source>
          <target state="translated">Hay un &lt;a href=&quot;../language/eval_order&quot;&gt;punto de secuencia&lt;/a&gt; despu&amp;eacute;s de la acci&amp;oacute;n de cada especificador de conversi&amp;oacute;n; esto permite almacenar m&amp;uacute;ltiples campos en la misma variable &quot;sumidero&quot;.</target>
        </trans-unit>
        <trans-unit id="d70af8d031e1e84898b1b7b8ee0619e430a9744d" translate="yes" xml:space="preserve">
          <source>There is a &lt;a href=&quot;eval_order&quot;&gt;sequence point&lt;/a&gt; after the evaluation of lhs. If the result of lhs compares equal to zero, then rhs is not evaluated at all (so-called</source>
          <target state="translated">Hay un &lt;a href=&quot;eval_order&quot;&gt;punto de secuencia&lt;/a&gt; despu&amp;eacute;s de la evaluaci&amp;oacute;n de lhs. Si el resultado de lhs se compara igual a cero, entonces rhs no se eval&amp;uacute;a en absoluto (denominado</target>
        </trans-unit>
        <trans-unit id="14abb1fb6e2bfb562fbb9a6e6989215e9fd7c48f" translate="yes" xml:space="preserve">
          <source>There is a &lt;a href=&quot;eval_order&quot;&gt;sequence point&lt;/a&gt; after the evaluation of lhs. If the result of lhs compares unequal to zero, then rhs is not evaluated at all (so-called</source>
          <target state="translated">Hay un &lt;a href=&quot;eval_order&quot;&gt;punto de secuencia&lt;/a&gt; despu&amp;eacute;s de la evaluaci&amp;oacute;n de lhs. Si el resultado de lhs se compara desigual a cero, entonces rhs no se eval&amp;uacute;a en absoluto (denominado</target>
        </trans-unit>
        <trans-unit id="ab3c5acf0d5e4ba77cc962cd2ce83a7c967eb424" translate="yes" xml:space="preserve">
          <source>There is a non-standard function named &lt;code&gt;gamma&lt;/code&gt; in various implementations, but its definition is inconsistent. For example, glibc and 4.2BSD version of &lt;code&gt;gamma&lt;/code&gt; executes &lt;code&gt;lgamma&lt;/code&gt;, but 4.4BSD version of &lt;code&gt;gamma&lt;/code&gt; executes &lt;code&gt;tgamma&lt;/code&gt;.</source>
          <target state="translated">Hay una funci&amp;oacute;n no est&amp;aacute;ndar llamada &lt;code&gt;gamma&lt;/code&gt; en varias implementaciones, pero su definici&amp;oacute;n es inconsistente. Por ejemplo, la versi&amp;oacute;n glibc y 4.2BSD de &lt;code&gt;gamma&lt;/code&gt; ejecuta &lt;code&gt;lgamma&lt;/code&gt; , pero la versi&amp;oacute;n 4.4BSD de &lt;code&gt;gamma&lt;/code&gt; ejecuta &lt;code&gt;tgamma&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b717a5566f4d275ca27affef23f0b5a37db23c45" translate="yes" xml:space="preserve">
          <source>There is no alternative spelling (such as &lt;code&gt;eq&lt;/code&gt;) for the equality operator &lt;code&gt;==&lt;/code&gt; because the character &lt;code&gt;=&lt;/code&gt; was present in all supported charsets.</source>
          <target state="translated">No hay una ortograf&amp;iacute;a alternativa (como &lt;code&gt;eq&lt;/code&gt; ) para el operador de igualdad &lt;code&gt;==&lt;/code&gt; porque el car&amp;aacute;cter &lt;code&gt;=&lt;/code&gt; estaba presente en todos los conjuntos de caracteres admitidos.</target>
        </trans-unit>
        <trans-unit id="6eb84e3cfc1155e6d27b4d15b2eca66bb1cb86c9" translate="yes" xml:space="preserve">
          <source>There is no concept of left-to-right or right-to-left evaluation in C, which is not to be confused with left-to-right and right-to-left associativity of operators: the expression &lt;code&gt;f1() + f2() + f3()&lt;/code&gt; is parsed as &lt;code&gt;(f1() + f2()) + f3()&lt;/code&gt; due to left-to-right associativity of operator+, but the function call to &lt;code&gt;f3&lt;/code&gt; may be evaluated first, last, or between &lt;code&gt;f1()&lt;/code&gt; or &lt;code&gt;f2()&lt;/code&gt; at run time.</source>
          <target state="translated">No existe un concepto de evaluaci&amp;oacute;n de izquierda a derecha o de derecha a izquierda en C, que no debe confundirse con la asociatividad de operadores de izquierda a derecha y de derecha a izquierda: la expresi&amp;oacute;n &lt;code&gt;f1() + f2() + f3()&lt;/code&gt; se analiza como &lt;code&gt;(f1() + f2()) + f3()&lt;/code&gt; debido a la asociatividad de izquierda a derecha del operador +, pero la llamada de funci&amp;oacute;n a &lt;code&gt;f3&lt;/code&gt; puede evaluarse primero, &amp;uacute;ltimo o entre &lt;code&gt;f1()&lt;/code&gt; o &lt;code&gt;f2()&lt;/code&gt; en tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="4a78979596616d979924aa8f0a7856f4ca21bc39" translate="yes" xml:space="preserve">
          <source>There is no null character in the first &lt;code&gt;dstsz&lt;/code&gt; multibyte characters in the &lt;code&gt;*src&lt;/code&gt; array and &lt;code&gt;len&lt;/code&gt; is greater than &lt;code&gt;dstsz&lt;/code&gt; (unless &lt;code&gt;dst&lt;/code&gt; is null)</source>
          <target state="translated">No hay caracteres nulos en los primeros caracteres multibyte &lt;code&gt;dstsz&lt;/code&gt; en la matriz &lt;code&gt;*src&lt;/code&gt; y &lt;code&gt;len&lt;/code&gt; es mayor que &lt;code&gt;dstsz&lt;/code&gt; (a menos que &lt;code&gt;dst&lt;/code&gt; sea ​​nulo)</target>
        </trans-unit>
        <trans-unit id="9850a4c4e290745723f4fc213c3322632b4431ed" translate="yes" xml:space="preserve">
          <source>There is no null character in the first &lt;code&gt;dstsz&lt;/code&gt; multibyte characters in the &lt;code&gt;src&lt;/code&gt; array and &lt;code&gt;len&lt;/code&gt; is greater than &lt;code&gt;dstsz&lt;/code&gt; (unless &lt;code&gt;dst&lt;/code&gt; is null)</source>
          <target state="translated">No hay caracteres nulos en los primeros caracteres multibyte &lt;code&gt;dstsz&lt;/code&gt; en la matriz &lt;code&gt;src&lt;/code&gt; y &lt;code&gt;len&lt;/code&gt; es mayor que &lt;code&gt;dstsz&lt;/code&gt; (a menos que &lt;code&gt;dst&lt;/code&gt; sea ​​nulo)</target>
        </trans-unit>
        <trans-unit id="642998dca69feddbb7005ae57f38e02a160cbb21" translate="yes" xml:space="preserve">
          <source>These are the directives defined by the standard. The standard does not define behavior for other directives: they might be ignored, have some useful meaning, or make the program ill-formed. Even if otherwise ignored, they are removed from the source code when the preprocessor is done. A common non-standard extension is the directive &lt;code&gt;#warning&lt;/code&gt; which emits a user-defined message during compilation.</source>
          <target state="translated">Estas son las directivas definidas por la norma. El est&amp;aacute;ndar no define el comportamiento de otras directivas: pueden ignorarse, tener alg&amp;uacute;n significado &amp;uacute;til o hacer que el programa est&amp;eacute; mal formado. Incluso si se ignora de otro modo, se eliminan del c&amp;oacute;digo fuente cuando se termina el preprocesador. Una extensi&amp;oacute;n no est&amp;aacute;ndar com&amp;uacute;n es la directiva &lt;code&gt;#warning&lt;/code&gt; que emite un mensaje definido por el usuario durante la compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c34a994ae2744a9c70d2624d0339c7d60e48fac7" translate="yes" xml:space="preserve">
          <source>These macros are implemented as if the imaginary types are supported (even if they are otherwise not supported and &lt;code&gt;&lt;a href=&quot;imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt; is actually undefined) and as if defined as follows:</source>
          <target state="translated">Estas macros se implementan como si los tipos imaginarios fueran compatibles (incluso si de lo contrario no son compatibles y &lt;code&gt;&lt;a href=&quot;imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt; no est&amp;aacute; realmente definido) y como se define de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="a4070e09555e3c6b6233a56d9b2a60f748e63343" translate="yes" xml:space="preserve">
          <source>These rules apply recursively to the types from which the two types are derived.</source>
          <target state="translated">Estas reglas se aplican de manera recursiva a los tipos de los que se derivan los dos tipos.</target>
        </trans-unit>
        <trans-unit id="18430fdedd8d39e1faff6417927ee373baccbc33" translate="yes" xml:space="preserve">
          <source>These rules control whether a function that receives two pointers must re-read one after writing through another:</source>
          <target state="translated">Estas reglas controlan si una función que recibe dos punteros debe releer uno después de escribir a través de otro:</target>
        </trans-unit>
        <trans-unit id="9c584adee26a0f194a4221931b8f5c6cd4324020" translate="yes" xml:space="preserve">
          <source>These rules simplify the use of header files.</source>
          <target state="translated">Estas reglas simplifican el uso de los archivos de encabezamiento.</target>
        </trans-unit>
        <trans-unit id="6da00a198d25ed4a99c4e2cfacbe9f6df3d8c0b0" translate="yes" xml:space="preserve">
          <source>They can even avoid using the tag name space at all:</source>
          <target state="translated">Incluso pueden evitar usar el espacio de nombres de la etiqueta en absoluto:</target>
        </trans-unit>
        <trans-unit id="88450ca53b9705996636f46ab82f85909cd9ffd6" translate="yes" xml:space="preserve">
          <source>They can have postfix form:</source>
          <target state="translated">Pueden tener forma de postfijo:</target>
        </trans-unit>
        <trans-unit id="cfe69ffd880071fd0df6c53ec20b12147145bf12" translate="yes" xml:space="preserve">
          <source>This allows structs that refer to each other:</source>
          <target state="translated">Esto permite que las estructuras se refieran unas a otras:</target>
        </trans-unit>
        <trans-unit id="d2ed7fa74d34f8de0d1eaf468b8712c8f649e605" translate="yes" xml:space="preserve">
          <source>This constant is equivalent to the POSIX &lt;code&gt;PTHREAD_DESTRUCTOR_ITERATIONS&lt;/code&gt;.</source>
          <target state="translated">Esta constante es equivalente a POSIX &lt;code&gt;PTHREAD_DESTRUCTOR_ITERATIONS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b50860f0a9733ec87d616cbc629bfd04dd2d57a1" translate="yes" xml:space="preserve">
          <source>This convenience macro expands to the keyword &lt;a href=&quot;../keyword/_static_assert&quot;&gt;_Static_assert&lt;/a&gt;.</source>
          <target state="translated">Esta macro de conveniencia se expande a la palabra clave &lt;a href=&quot;../keyword/_static_assert&quot;&gt;_Static_assert&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b69559dc667ea9ee00a61f5b0fa74edf96266446" translate="yes" xml:space="preserve">
          <source>This conversion models the memory load of the value of the object from its location.</source>
          <target state="translated">Esta conversión modela la carga de memoria del valor del objeto desde su ubicación.</target>
        </trans-unit>
        <trans-unit id="7411fcb845dcaee0f13e9cd4e36b67d0ac9d7fab" translate="yes" xml:space="preserve">
          <source>This directive is used by some automatic code generation tools which produce C source files from a file written in another language. In that case, &lt;code&gt;#line&lt;/code&gt; directives may be inserted in the generated C file referencing line numbers and the file name of the original (human-editable) source file.</source>
          <target state="translated">Esta directiva es utilizada por algunas herramientas de generaci&amp;oacute;n autom&amp;aacute;tica de c&amp;oacute;digo que producen archivos fuente C a partir de un archivo escrito en otro idioma. En ese caso, se pueden insertar directivas &lt;code&gt;#line&lt;/code&gt; en el archivo C generado que hace referencia a los n&amp;uacute;meros de l&amp;iacute;nea y al nombre del archivo fuente original (editable por humanos).</target>
        </trans-unit>
        <trans-unit id="076b866beacb08cccde9a7cbeb026a03c41cdec2" translate="yes" xml:space="preserve">
          <source>This example demonstrates the difference between clock() time and real time.</source>
          <target state="translated">Este ejemplo demuestra la diferencia entre el tiempo del reloj()y el tiempo real.</target>
        </trans-unit>
        <trans-unit id="0244ac28d2447894c8661b2de1ddf4c14a2a9959" translate="yes" xml:space="preserve">
          <source>This example shows how to read a file twice.</source>
          <target state="translated">Este ejemplo muestra cómo leer un archivo dos veces.</target>
        </trans-unit>
        <trans-unit id="0c7a11a8d6d19389f0abbac4fa34ba46bd07ad35" translate="yes" xml:space="preserve">
          <source>This function</source>
          <target state="translated">Esta función</target>
        </trans-unit>
        <trans-unit id="0f912b3d69a2d64099faca61cd00f39d6e484909" translate="yes" xml:space="preserve">
          <source>This function (for double argument) behaves as if (except for the freedom to not raise &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;) implemented by.</source>
          <target state="translated">Esta funci&amp;oacute;n (para doble argumento) se comporta como si (excepto por la libertad de no aumentar &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; ) implementada por.</target>
        </trans-unit>
        <trans-unit id="fc3c34a0198ac33575e10015adc37a15fd3102be" translate="yes" xml:space="preserve">
          <source>This function &lt;code&gt;gmtime&lt;/code&gt; may not be thread-safe.</source>
          <target state="translated">Esta funci&amp;oacute;n &lt;code&gt;gmtime&lt;/code&gt; puede no ser segura para subprocesos.</target>
        </trans-unit>
        <trans-unit id="b50d9318428e6b56bb64ec1ee9a5392761dc1191" translate="yes" xml:space="preserve">
          <source>This function &lt;code&gt;localtime&lt;/code&gt; may not be thread-safe.</source>
          <target state="translated">Esta funci&amp;oacute;n &lt;code&gt;localtime&lt;/code&gt; puede no ser segura para subprocesos.</target>
        </trans-unit>
        <trans-unit id="56dabe59df1e13c9e7227a371ae542e03583d74a" translate="yes" xml:space="preserve">
          <source>This function behaves as if implemented as follows:</source>
          <target state="translated">Esta función se comporta como si estuviera implementada de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="e024c278b12913b9314d8bc74236e17366fbdd60" translate="yes" xml:space="preserve">
          <source>This function behaves as if it reads the characters sequentially and stops as soon as a matching character is found: if the array pointed to by &lt;code&gt;ptr&lt;/code&gt; is smaller than &lt;code&gt;count&lt;/code&gt;, but the match is found within the array, the behavior is well-defined.</source>
          <target state="translated">Esta funci&amp;oacute;n se comporta como si leyera los caracteres secuencialmente y se detiene tan pronto como se encuentre un car&amp;aacute;cter coincidente: si la matriz a la que apunta &lt;code&gt;ptr&lt;/code&gt; es menor que la &lt;code&gt;count&lt;/code&gt; , pero la coincidencia se encuentra dentro de la matriz, el comportamiento est&amp;aacute; bien definido.</target>
        </trans-unit>
        <trans-unit id="db0f3821e4deee5da8554e13cdcbbb92c017d0a9" translate="yes" xml:space="preserve">
          <source>This function is designed to be called multiples times to obtain successive tokens from the same string.</source>
          <target state="translated">Esta función está diseñada para ser llamada varias veces para obtener fichas sucesivas de la misma cadena.</target>
        </trans-unit>
        <trans-unit id="4e6efd938fea60e8a8ba4cf09b50c3ce4deac15d" translate="yes" xml:space="preserve">
          <source>This function is destructive: it writes the &lt;code&gt;'\0'&lt;/code&gt; characters in the elements of the string &lt;code&gt;str&lt;/code&gt;. In particular, a string literal cannot be used as the first argument of &lt;code&gt;strtok&lt;/code&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n es destructiva: escribe los caracteres &lt;code&gt;'\0'&lt;/code&gt; en los elementos de la cadena &lt;code&gt;str&lt;/code&gt; . En particular, un literal de cadena no se puede usar como primer argumento de &lt;code&gt;strtok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c153eac4de71030a581d492d74631860a8a74df0" translate="yes" xml:space="preserve">
          <source>This function is destructive: it writes the &lt;code&gt;L'\0'&lt;/code&gt; characters in the elements of the string &lt;code&gt;str&lt;/code&gt;. In particular, a wide string literal cannot be used as the first argument of &lt;code&gt;wcstok&lt;/code&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n es destructiva: escribe los caracteres &lt;code&gt;L'\0'&lt;/code&gt; en los elementos de la cadena &lt;code&gt;str&lt;/code&gt; . En particular, un literal de cadena ancha no se puede utilizar como primer argumento de &lt;code&gt;wcstok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4fced0fa7f525bd304cf4a0df7503105cd2c0150" translate="yes" xml:space="preserve">
          <source>This function is equivalent to the call &lt;code&gt;&lt;a href=&quot;mbrtowc&quot;&gt;mbrtowc&lt;/a&gt;(nullptr, s, n, ps?ps:&amp;amp;internal)&lt;/code&gt; for some hidden object &lt;code&gt;internal&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt;, except that the expression &lt;code&gt;ps&lt;/code&gt; is evaluated only once.</source>
          <target state="translated">Esta funci&amp;oacute;n es equivalente a la llamada &lt;code&gt;&lt;a href=&quot;mbrtowc&quot;&gt;mbrtowc&lt;/a&gt;(nullptr, s, n, ps?ps:&amp;amp;internal)&lt;/code&gt; para alg&amp;uacute;n objeto oculto &lt;code&gt;internal&lt;/code&gt; de tipo &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt; , excepto que la expresi&amp;oacute;n &lt;code&gt;ps&lt;/code&gt; se eval&amp;uacute;a solo una vez.</target>
        </trans-unit>
        <trans-unit id="231a0871c75740128f3a8e900a16eece62f9a755" translate="yes" xml:space="preserve">
          <source>This function is equivalent to the call &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;mbtowc&lt;/a&gt;((wchar_t*)0, s, n)&lt;/code&gt;, except that conversion state of &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;mbtowc&lt;/a&gt;&lt;/code&gt; is unaffected.</source>
          <target state="translated">Esta funci&amp;oacute;n es equivalente a la llamada &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;mbtowc&lt;/a&gt;((wchar_t*)0, s, n)&lt;/code&gt; , excepto que el estado de conversi&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;mbtowc&lt;/a&gt;&lt;/code&gt; no se ve afectado.</target>
        </trans-unit>
        <trans-unit id="289cf9d190604844c33bb4b2eed7d07fca8b2a3c" translate="yes" xml:space="preserve">
          <source>This function is fully specified for all possible inputs and is not subject to any errors described in &lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n est&amp;aacute; completamente especificada para todas las entradas posibles y no est&amp;aacute; sujeta a ning&amp;uacute;n error descrito en &lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bf2280640237c525c2d62eefb26aff9f2856c11f" translate="yes" xml:space="preserve">
          <source>This function is not locale-sensitive and pays no attention to the values of the &lt;code&gt;wchar_t&lt;/code&gt; objects it copies: nulls as well as invalid characters are copied too.</source>
          <target state="translated">Esta funci&amp;oacute;n no es sensible a la configuraci&amp;oacute;n regional y no presta atenci&amp;oacute;n a los valores de los objetos &lt;code&gt;wchar_t&lt;/code&gt; que copia: tambi&amp;eacute;n se copian los caracteres nulos y no v&amp;aacute;lidos.</target>
        </trans-unit>
        <trans-unit id="67fe14d7992c12e6d5c157b600ec2cde52ad0774" translate="yes" xml:space="preserve">
          <source>This function is not locale-sensitive and pays no attention to the values of the &lt;code&gt;wchar_t&lt;/code&gt; objects it examines: nulls as well as invalid wide characters are compared too.</source>
          <target state="translated">Esta funci&amp;oacute;n no es sensible a la configuraci&amp;oacute;n regional y no presta atenci&amp;oacute;n a los valores de los objetos &lt;code&gt;wchar_t&lt;/code&gt; que examina: los caracteres nulos y los caracteres anchos no v&amp;aacute;lidos tambi&amp;eacute;n se comparan.</target>
        </trans-unit>
        <trans-unit id="9c3cb718222d314cabd06a082b4892a3a4ab3e26" translate="yes" xml:space="preserve">
          <source>This function is not locale-sensitive and pays no attention to the values of the &lt;code&gt;wchar_t&lt;/code&gt; objects it writes: nulls as well as invalid wide characters are written too.</source>
          <target state="translated">Esta funci&amp;oacute;n no es sensible a la configuraci&amp;oacute;n regional y no presta atenci&amp;oacute;n a los valores de los objetos &lt;code&gt;wchar_t&lt;/code&gt; que escribe: tambi&amp;eacute;n se escriben los caracteres nulos y los caracteres anchos no v&amp;aacute;lidos.</target>
        </trans-unit>
        <trans-unit id="7fd9eb1ebb9f64fc35b5dd954c1ec8fde9ee2bc0" translate="yes" xml:space="preserve">
          <source>This function is not locale-sensitive, unlike &lt;code&gt;&lt;a href=&quot;strcoll&quot;&gt;strcoll&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;strxfrm&quot;&gt;strxfrm&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n no es sensible a la configuraci&amp;oacute;n regional, a diferencia de &lt;code&gt;&lt;a href=&quot;strcoll&quot;&gt;strcoll&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;strxfrm&quot;&gt;strxfrm&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62bdb6519f660463d2b94beeadb5dcc88cb10b36" translate="yes" xml:space="preserve">
          <source>This function is not locale-sensitive, unlike &lt;code&gt;&lt;a href=&quot;wcscoll&quot;&gt;wcscoll&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;wcsxfrm&quot;&gt;wcsxfrm&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n no es sensible a la configuraci&amp;oacute;n regional, a diferencia de &lt;code&gt;&lt;a href=&quot;wcscoll&quot;&gt;wcscoll&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;wcsxfrm&quot;&gt;wcsxfrm&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="927a55b81991e753e70085ac5fc65b5e5213d7eb" translate="yes" xml:space="preserve">
          <source>This function is not locale-sensitive, unlike &lt;code&gt;&lt;a href=&quot;wcscoll&quot;&gt;wcscoll&lt;/a&gt;&lt;/code&gt;, and the order may not be meaningful when characters from different Unicode blocks are used together or when the order of code units does not match any collation order.</source>
          <target state="translated">Esta funci&amp;oacute;n no es sensible a la configuraci&amp;oacute;n regional, a diferencia de &lt;code&gt;&lt;a href=&quot;wcscoll&quot;&gt;wcscoll&lt;/a&gt;&lt;/code&gt; , y el orden puede no ser significativo cuando los caracteres de diferentes bloques Unicode se usan juntos o cuando el orden de las unidades de c&amp;oacute;digo no coincide con ning&amp;uacute;n orden de clasificaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d3b72d4451a67b0f8e9ff04bab97998d9cac5a6e" translate="yes" xml:space="preserve">
          <source>This function is not required to be sensitive to the sign of zero, although some implementations additionally enforce that if one argument is +0 and the other is -0, then +0 is returned.</source>
          <target state="translated">No se requiere que esta función sea sensible al signo de cero,aunque algunas implementaciones refuerzan adicionalmente que si un argumento es +0 y el otro es -0,entonces se devuelve +0.</target>
        </trans-unit>
        <trans-unit id="1e7653f07d484a2f1a2819f2a881f15b3743184c" translate="yes" xml:space="preserve">
          <source>This function is not required to be sensitive to the sign of zero, although some implementations additionally enforce that if one argument is +0 and the other is -0, then -0 is returned.</source>
          <target state="translated">No se requiere que esta función sea sensible al signo de cero,aunque algunas implementaciones refuerzan adicionalmente que si un argumento es +0 y el otro es -0,entonces se devuelve -0.</target>
        </trans-unit>
        <trans-unit id="63ff1f7a80d3a2498f6c2c57080a31e1fe86d34e" translate="yes" xml:space="preserve">
          <source>This function is not required to be thread-safe. Another call to getenv, as well as a call to the POSIX functions &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/setenv.html&quot;&gt;setenv()&lt;/a&gt;, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/unsetenv.html&quot;&gt;unsetenv()&lt;/a&gt;, and &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/putenv.html&quot;&gt;putenv()&lt;/a&gt; may invalidate the pointer returned by a previous call or modify the string obtained from a previous call.</source>
          <target state="translated">No es necesario que esta funci&amp;oacute;n sea segura para subprocesos. Otra llamada a getenv, as&amp;iacute; como una llamada a las funciones POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/setenv.html&quot;&gt;setenv ()&lt;/a&gt; , &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/unsetenv.html&quot;&gt;unsetenv ()&lt;/a&gt; y &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/putenv.html&quot;&gt;putenv ()&lt;/a&gt; pueden invalidar el puntero devuelto por una llamada previa o modificar la cadena obtenida de una llamada previa.</target>
        </trans-unit>
        <trans-unit id="681d635b8b9b9b5848473256fcd251c20f009b9c" translate="yes" xml:space="preserve">
          <source>This function is not required to be thread-safe. Another call to getenv, as well as a call to the POSIX functions &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/setenv.html&quot;&gt;setenv()&lt;/a&gt;, &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/unsetenv.html&quot;&gt;unsetenv()&lt;/a&gt;, and &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/putenv.html&quot;&gt;putenv()&lt;/a&gt; may invalidate the pointer returned by a previous call or modify the string obtained from a previous call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c18c3327a1bb9aff722e27566d40c0f5a2e03ab6" translate="yes" xml:space="preserve">
          <source>This function is not subject to any errors specified in &lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n no est&amp;aacute; sujeta a ning&amp;uacute;n error especificado en &lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a6683742f8d4669b99ea5d2493ece7dd4bf9163f" translate="yes" xml:space="preserve">
          <source>This function is not subject to any of the error conditions specified in &lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n no est&amp;aacute; sujeta a ninguna de las condiciones de error especificadas en &lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a709e4cf707eedac9654ec2bb76727de164f9448" translate="yes" xml:space="preserve">
          <source>This function is not subject to any of the errors specified in &lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n no est&amp;aacute; sujeta a ninguno de los errores especificados en &lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ee72f094fe13a8766f016ade2b2b9b07bf2aa390" translate="yes" xml:space="preserve">
          <source>This function is used when making multiple locale-dependent comparisons using the same string or set of strings, because it is more efficient to use &lt;code&gt;strxfrm&lt;/code&gt; to transform all the strings just once, and subsequently compare the transformed strings with &lt;code&gt;&lt;a href=&quot;strcmp&quot;&gt;strcmp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n se usa cuando se realizan m&amp;uacute;ltiples comparaciones dependientes de la configuraci&amp;oacute;n regional utilizando la misma cadena o conjunto de cadenas, porque es m&amp;aacute;s eficiente usar &lt;code&gt;strxfrm&lt;/code&gt; para transformar todas las cadenas una sola vez y, posteriormente, comparar las cadenas transformadas con &lt;code&gt;&lt;a href=&quot;strcmp&quot;&gt;strcmp&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a65b542fcd908db7b072f90fe956dd83e5f184b9" translate="yes" xml:space="preserve">
          <source>This function is used when making multiple locale-dependent comparisons using the same wide string or set of wide strings, because it is more efficient to use &lt;code&gt;wcsxfrm&lt;/code&gt; to transform all the strings just once, and subsequently compare the transformed wide strings with &lt;code&gt;&lt;a href=&quot;wcscmp&quot;&gt;wcscmp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n se usa cuando se realizan m&amp;uacute;ltiples comparaciones dependientes de la configuraci&amp;oacute;n regional utilizando la misma cadena ancha o conjunto de cadenas anchas, porque es m&amp;aacute;s eficiente usar &lt;code&gt;wcsxfrm&lt;/code&gt; para transformar todas las cadenas una sola vez, y posteriormente comparar las cadenas anchas transformadas con &lt;code&gt;&lt;a href=&quot;wcscmp&quot;&gt;wcscmp&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e03d3793ab454e8128b5c58da21acb181e05d455" translate="yes" xml:space="preserve">
          <source>This function is useful when implementing periodic functions with the period exactly representable as a floating-point value: when calculating sin(&amp;pi;x) for a very large &lt;code&gt;x&lt;/code&gt;, calling &lt;code&gt;&lt;a href=&quot;sin&quot;&gt;sin&lt;/a&gt;&lt;/code&gt; directly may result in a large error, but if the function argument is first reduced with &lt;code&gt;remquo&lt;/code&gt;, he low-order bits of the quotient may be used to determine the sign and the octant of the result within the period, while the remainder may be used to calculate the value with high precision.</source>
          <target state="translated">Esta funci&amp;oacute;n es &amp;uacute;til cuando se implementan funciones peri&amp;oacute;dicas con el per&amp;iacute;odo exactamente representable como un valor de punto flotante: cuando se calcula sin (&amp;pi;x) para una &lt;code&gt;x&lt;/code&gt; muy grande , llamar directamente a &lt;code&gt;&lt;a href=&quot;sin&quot;&gt;sin&lt;/a&gt;&lt;/code&gt; puede resultar en un gran error, pero si el argumento de la funci&amp;oacute;n se reduce primero con &lt;code&gt;remquo&lt;/code&gt; , los bits de bajo orden del cociente se pueden usar para determinar el signo y el octante del resultado dentro del per&amp;iacute;odo, mientras que el resto se puede usar para calcular el valor con alta precisi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c35c12e20abb3630d4e436c000152934a2b3212d" translate="yes" xml:space="preserve">
          <source>This function may be used in the beginning of a subroutine that must hide the floating-point exceptions it may raise from the caller. If only some exceptions must be suppressed, while others must be reported, the non-stop mode is usually ended with a call to &lt;code&gt;&lt;a href=&quot;feupdateenv&quot;&gt;feupdateenv&lt;/a&gt;&lt;/code&gt; after clearing the unwanted exceptions.</source>
          <target state="translated">Esta funci&amp;oacute;n puede usarse al comienzo de una subrutina que debe ocultar las excepciones de punto flotante que puede generar la persona que llama. Si solo se deben suprimir algunas excepciones, mientras que se deben informar otras, el modo sin interrupci&amp;oacute;n generalmente finaliza con una llamada a &lt;code&gt;&lt;a href=&quot;feupdateenv&quot;&gt;feupdateenv&lt;/a&gt;&lt;/code&gt; despu&amp;eacute;s de borrar las excepciones no deseadas.</target>
        </trans-unit>
        <trans-unit id="c90c1d681d31741a20a83a505d3bfb6598bed15c" translate="yes" xml:space="preserve">
          <source>This function may be used to end the non-stop mode established by an earlier call to &lt;code&gt;&lt;a href=&quot;feholdexcept&quot;&gt;feholdexcept&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n puede usarse para finalizar el modo continuo establecido por una llamada anterior a &lt;code&gt;&lt;a href=&quot;feholdexcept&quot;&gt;feholdexcept&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eba5a1fa5d6bf34dbc8e4aa1de43f17b83ab0d16" translate="yes" xml:space="preserve">
          <source>This function may only be used after &lt;code&gt;stream&lt;/code&gt; has been associated with an open file, but before any other operation (other than a failed call to &lt;code&gt;&lt;a href=&quot;setbuf&quot;&gt;setbuf&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;setvbuf&lt;/code&gt;).</source>
          <target state="translated">Esta funci&amp;oacute;n solo se puede usar despu&amp;eacute;s de que la &lt;code&gt;stream&lt;/code&gt; se haya asociado con un archivo abierto, pero antes de cualquier otra operaci&amp;oacute;n (que no sea una llamada fallida a &lt;code&gt;&lt;a href=&quot;setbuf&quot;&gt;setbuf&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;setvbuf&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="96689986a9f996a280e4c757957f55a81eb0fb31" translate="yes" xml:space="preserve">
          <source>This function may only be used after &lt;code&gt;stream&lt;/code&gt; has been associated with an open file, but before any other operation (other than a failed call to &lt;code&gt;setbuf&lt;/code&gt;/&lt;code&gt;setvbuf&lt;/code&gt;).</source>
          <target state="translated">Esta funci&amp;oacute;n solo se puede usar despu&amp;eacute;s de que la &lt;code&gt;stream&lt;/code&gt; se haya asociado con un archivo abierto, pero antes de cualquier otra operaci&amp;oacute;n (que no sea una llamada fallida a &lt;code&gt;setbuf&lt;/code&gt; / &lt;code&gt;setvbuf&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c67c60121c3003570bb2cb1cae4c32a23903e49f" translate="yes" xml:space="preserve">
          <source>This function only reports the stream state as reported by the most recent I/O operation, it does not examine the associated data source. For example, if the most recent I/O was a &lt;code&gt;&lt;a href=&quot;fgetc&quot;&gt;fgetc&lt;/a&gt;&lt;/code&gt;, which returned the last byte of a file, &lt;code&gt;feof&lt;/code&gt; returns zero. The next &lt;code&gt;&lt;a href=&quot;fgetc&quot;&gt;fgetc&lt;/a&gt;&lt;/code&gt; fails and changes the stream state to</source>
          <target state="translated">Esta funci&amp;oacute;n solo informa el estado del flujo seg&amp;uacute;n lo informado por la operaci&amp;oacute;n de E / S m&amp;aacute;s reciente, no examina la fuente de datos asociada. Por ejemplo, si la E / S m&amp;aacute;s reciente fue un &lt;code&gt;&lt;a href=&quot;fgetc&quot;&gt;fgetc&lt;/a&gt;&lt;/code&gt; , que devolvi&amp;oacute; el &amp;uacute;ltimo byte de un archivo, &lt;code&gt;feof&lt;/code&gt; devuelve cero. El siguiente &lt;code&gt;&lt;a href=&quot;fgetc&quot;&gt;fgetc&lt;/a&gt;&lt;/code&gt; falla y cambia el estado del flujo a</target>
        </trans-unit>
        <trans-unit id="5497fdd666555fbd47980c9e891c896338ff075a" translate="yes" xml:space="preserve">
          <source>This function reads &lt;a href=&quot;../../language/object&quot;&gt;object representations&lt;/a&gt;, not the object values, and is typically meaningful for byte arrays only: structs may have padding bytes whose values are indeterminate, the values of any bytes beyond the last stored member in a union are indeterminate, and a type may have two or more representations for the same value (different encodings for +0 and -0 or for +0.0 and &amp;ndash;0.0, indeterminate padding bits within the type).</source>
          <target state="translated">Esta funci&amp;oacute;n lee &lt;a href=&quot;../../language/object&quot;&gt;representaciones de objetos&lt;/a&gt; , no los valores de los objetos, y generalmente es significativa solo para las matrices de bytes: las estructuras pueden tener bytes de relleno cuyos valores son indeterminados, los valores de los bytes m&amp;aacute;s all&amp;aacute; del &amp;uacute;ltimo miembro almacenado en una uni&amp;oacute;n son indeterminados, y un tipo puede tener dos o m&amp;aacute;s representaciones para el mismo valor (diferentes codificaciones para +0 y -0 o para +0.0 y &amp;ndash;0.0, bits de relleno indeterminados dentro del tipo).</target>
        </trans-unit>
        <trans-unit id="a9bf69b22ca337dadc2c824c35f9f63e828aff82" translate="yes" xml:space="preserve">
          <source>This function returns a pointer to static data and is not thread-safe. POSIX marks this function obsolete and recommends &lt;code&gt;&lt;a href=&quot;strftime&quot;&gt;strftime&lt;/a&gt;&lt;/code&gt; instead. The C standard also recommends &lt;code&gt;&lt;a href=&quot;strftime&quot;&gt;strftime&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;asctime&lt;/code&gt; and &lt;code&gt;asctime_s&lt;/code&gt; because &lt;code&gt;strftime&lt;/code&gt; is more flexible and locale-sensitive.</source>
          <target state="translated">Esta funci&amp;oacute;n devuelve un puntero a datos est&amp;aacute;ticos y no es seguro para subprocesos. POSIX marca esta funci&amp;oacute;n como obsoleta y en &lt;code&gt;&lt;a href=&quot;strftime&quot;&gt;strftime&lt;/a&gt;&lt;/code&gt; lugar recomienda strftime . El est&amp;aacute;ndar C tambi&amp;eacute;n recomienda &lt;code&gt;&lt;a href=&quot;strftime&quot;&gt;strftime&lt;/a&gt;&lt;/code&gt; en lugar de &lt;code&gt;asctime&lt;/code&gt; y &lt;code&gt;asctime_s&lt;/code&gt; porque &lt;code&gt;strftime&lt;/code&gt; es m&amp;aacute;s flexible y local.</target>
        </trans-unit>
        <trans-unit id="2f2be7af8e841f9575c6ea1a25f265a05a0d98bc" translate="yes" xml:space="preserve">
          <source>This function's analog for byte strings is &lt;code&gt;&lt;a href=&quot;../byte/strncpy&quot;&gt;strncpy&lt;/a&gt;&lt;/code&gt;, not &lt;code&gt;&lt;a href=&quot;../byte/strcpy&quot;&gt;strcpy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">El an&amp;aacute;logo de esta funci&amp;oacute;n para cadenas de bytes es &lt;code&gt;&lt;a href=&quot;../byte/strncpy&quot;&gt;strncpy&lt;/a&gt;&lt;/code&gt; , no &lt;code&gt;&lt;a href=&quot;../byte/strcpy&quot;&gt;strcpy&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7e4ea005b5c762b68b78e66cb478bbb9f15f5ca" translate="yes" xml:space="preserve">
          <source>This is a &lt;a href=&quot;../language/generic&quot;&gt;generic function&lt;/a&gt; defined for all &lt;a href=&quot;../language/atomic&quot;&gt;atomic object types&lt;/a&gt;&lt;code&gt;A&lt;/code&gt;. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and &lt;a href=&quot;../language/volatile&quot;&gt;volatile&lt;/a&gt; (e.g. memory-mapped I/O) atomic variables.</source>
          <target state="translated">Esta es una &lt;a href=&quot;../language/generic&quot;&gt;funci&amp;oacute;n gen&amp;eacute;rica&lt;/a&gt; definida para todos &lt;a href=&quot;../language/atomic&quot;&gt;los tipos de objetos at&amp;oacute;mica &lt;/a&gt; &lt;code&gt;A&lt;/code&gt; . El argumento apunta a un tipo at&amp;oacute;mico vol&amp;aacute;til para aceptar direcciones de variables at&amp;oacute;micas no vol&amp;aacute;tiles y &lt;a href=&quot;../language/volatile&quot;&gt;vol&amp;aacute;tiles&lt;/a&gt; (p. Ej., E / S mapeadas en memoria).</target>
        </trans-unit>
        <trans-unit id="e181a8038634b4136f7fdead9b63de0740a42ba9" translate="yes" xml:space="preserve">
          <source>This is a &lt;a href=&quot;../language/generic&quot;&gt;generic function&lt;/a&gt; defined for all &lt;a href=&quot;../language/atomic&quot;&gt;atomic object types&lt;/a&gt;&lt;code&gt;A&lt;/code&gt;. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and &lt;a href=&quot;../language/volatile&quot;&gt;volatile&lt;/a&gt; (e.g. memory-mapped I/O) atomic variables.&lt;code&gt;C&lt;/code&gt; is the non-atomic type corresponding to &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">Esta es una &lt;a href=&quot;../language/generic&quot;&gt;funci&amp;oacute;n gen&amp;eacute;rica&lt;/a&gt; definida para todos &lt;a href=&quot;../language/atomic&quot;&gt;los tipos de objetos at&amp;oacute;mica &lt;/a&gt; &lt;code&gt;A&lt;/code&gt; . El argumento apunta a un tipo at&amp;oacute;mico vol&amp;aacute;til para aceptar direcciones de variables at&amp;oacute;micas no vol&amp;aacute;tiles y &lt;a href=&quot;../language/volatile&quot;&gt;vol&amp;aacute;tiles&lt;/a&gt; (p. Ej., E / S mapeadas en memoria). &lt;code&gt;C&lt;/code&gt; es el tipo no at&amp;oacute;mica que corresponde a &lt;code&gt;A&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9ced58fc25709f23b54d5a8febf8951bc9cad14" translate="yes" xml:space="preserve">
          <source>This is a &lt;a href=&quot;../language/generic&quot;&gt;generic function&lt;/a&gt; defined for all &lt;a href=&quot;../language/atomic&quot;&gt;atomic object types&lt;/a&gt;&lt;code&gt;A&lt;/code&gt;. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and &lt;a href=&quot;../language/volatile&quot;&gt;volatile&lt;/a&gt; (e.g. memory-mapped I/O) atomic variables.&lt;code&gt;C&lt;/code&gt; is the non-atomic type corresponding to &lt;code&gt;A&lt;/code&gt;..</source>
          <target state="translated">Esta es una &lt;a href=&quot;../language/generic&quot;&gt;funci&amp;oacute;n gen&amp;eacute;rica&lt;/a&gt; definida para todos &lt;a href=&quot;../language/atomic&quot;&gt;los tipos de objetos at&amp;oacute;mica &lt;/a&gt; &lt;code&gt;A&lt;/code&gt; . El argumento apunta a un tipo at&amp;oacute;mico vol&amp;aacute;til para aceptar direcciones de variables at&amp;oacute;micas no vol&amp;aacute;tiles y &lt;a href=&quot;../language/volatile&quot;&gt;vol&amp;aacute;tiles&lt;/a&gt; (p. Ej., E / S mapeadas en memoria). &lt;code&gt;C&lt;/code&gt; es el tipo no at&amp;oacute;mico correspondiente a &lt;code&gt;A&lt;/code&gt; ..</target>
        </trans-unit>
        <trans-unit id="e969750390e2bd7552b0c9939a42fffba170be3a" translate="yes" xml:space="preserve">
          <source>This is a &lt;a href=&quot;../language/generic&quot;&gt;generic function&lt;/a&gt; defined for all &lt;a href=&quot;../language/atomic&quot;&gt;atomic object types&lt;/a&gt;&lt;code&gt;A&lt;/code&gt;. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and &lt;a href=&quot;../language/volatile&quot;&gt;volatile&lt;/a&gt; (e.g. memory-mapped I/O) atomic variables.&lt;code&gt;M&lt;/code&gt; is either the non-atomic type corresponding to &lt;code&gt;A&lt;/code&gt; if &lt;code&gt;A&lt;/code&gt; is atomic integer type, or &lt;code&gt;&lt;a href=&quot;../types/ptrdiff_t&quot;&gt;ptrdiff_t&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;A&lt;/code&gt; is atomic pointer type.</source>
          <target state="translated">Esta es una &lt;a href=&quot;../language/generic&quot;&gt;funci&amp;oacute;n gen&amp;eacute;rica&lt;/a&gt; definida para todos &lt;a href=&quot;../language/atomic&quot;&gt;los tipos de objetos at&amp;oacute;mica &lt;/a&gt; &lt;code&gt;A&lt;/code&gt; . El argumento apunta a un tipo at&amp;oacute;mico vol&amp;aacute;til para aceptar direcciones de variables at&amp;oacute;micas no vol&amp;aacute;tiles y &lt;a href=&quot;../language/volatile&quot;&gt;vol&amp;aacute;tiles&lt;/a&gt; (p. Ej., E / S mapeadas en memoria). &lt;code&gt;M&lt;/code&gt; es el tipo no at&amp;oacute;mico correspondiente a &lt;code&gt;A&lt;/code&gt; si &lt;code&gt;A&lt;/code&gt; es un tipo entero at&amp;oacute;mico, o &lt;code&gt;&lt;a href=&quot;../types/ptrdiff_t&quot;&gt;ptrdiff_t&lt;/a&gt;&lt;/code&gt; si &lt;code&gt;A&lt;/code&gt; es un tipo de puntero at&amp;oacute;mico.</target>
        </trans-unit>
        <trans-unit id="f2b809c781f1dd40ccaa7e9909384069fc16d953" translate="yes" xml:space="preserve">
          <source>This is a convenience macro that makes it possible to use &lt;code&gt;float imaginary&lt;/code&gt;, &lt;code&gt;double imaginary&lt;/code&gt;, and &lt;code&gt;long double imaginary&lt;/code&gt; as an alternative way to write the three pure imaginary C types &lt;code&gt;float _Imaginary&lt;/code&gt;, &lt;code&gt;double _Imaginary&lt;/code&gt;, and &lt;code&gt;long double _Imaginary&lt;/code&gt;.</source>
          <target state="translated">Esta es una macro conveniente que hace posible usar &lt;code&gt;float imaginary&lt;/code&gt; , &lt;code&gt;double imaginary&lt;/code&gt; y &lt;code&gt;long double imaginary&lt;/code&gt; como una forma alternativa de escribir los tres tipos de C imaginarios puros &lt;code&gt;float _Imaginary&lt;/code&gt; , &lt;code&gt;double _Imaginary&lt;/code&gt; y &lt;code&gt;long double _Imaginary&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e4229ef0621d5243c8579b95063d0e32f80e2588" translate="yes" xml:space="preserve">
          <source>This is a list of reserved keywords in C. Since they are used by the language, these keywords are not available for re-definition.</source>
          <target state="translated">Esta es una lista de palabras clave reservadas en C.Como son usadas por el lenguaje,estas palabras clave no están disponibles para su redefinición.</target>
        </trans-unit>
        <trans-unit id="db09d9c40cfbd787606a59adeb9a502f7781cbba" translate="yes" xml:space="preserve">
          <source>This is a reference of the core C language constructs.</source>
          <target state="translated">Esta es una referencia de las construcciones del núcleo del lenguaje C.</target>
        </trans-unit>
        <trans-unit id="86a43046ffec5125bc8767c2110f2dc6b326902d" translate="yes" xml:space="preserve">
          <source>This is commonly used with the &lt;a href=&quot;restrict&quot;&gt;restrict&lt;/a&gt; type qualifier:</source>
          <target state="translated">Esto se usa com&amp;uacute;nmente con el calificador de tipo de &lt;a href=&quot;restrict&quot;&gt;restricci&amp;oacute;n&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="0d36f9177dcf527b56588facf919e3ece4cf5e27" translate="yes" xml:space="preserve">
          <source>This is the most optimal integer type for the platform, and is guaranteed to be at least 16 bits. Most current systems use 32 bits (see Data models below).</source>
          <target state="translated">Este es el tipo de entero más óptimo para la plataforma,y se garantiza que es de al menos 16 bits.La mayoría de los sistemas actuales utilizan 32 bits (véase los modelos de datos más abajo).</target>
        </trans-unit>
        <trans-unit id="812af2a36c3f95774b9b7221df53591bbffef4a8" translate="yes" xml:space="preserve">
          <source>This is typically possible for the characters from the ASCII character set, since most multibyte encodings (such as UTF-8) use single bytes to encode those characters.</source>
          <target state="translated">Esto es típicamente posible para los caracteres del conjunto de caracteres ASCII,ya que la mayoría de las codificaciones multibyte (como UTF-8)utilizan bytes individuales para codificar esos caracteres.</target>
        </trans-unit>
        <trans-unit id="a8a90074bad3bc54e82f4f7ddf4763be591f8a47" translate="yes" xml:space="preserve">
          <source>This keyword is also available as convenience macro &lt;a href=&quot;../error/static_assert&quot;&gt;&lt;code&gt;static_assert&lt;/code&gt;&lt;/a&gt;, available in the header &lt;code&gt;&amp;lt;assert.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Esta palabra clave tambi&amp;eacute;n est&amp;aacute; disponible como macro de conveniencia &lt;a href=&quot;../error/static_assert&quot;&gt; &lt;code&gt;static_assert&lt;/code&gt; &lt;/a&gt; , disponible en el encabezado &lt;code&gt;&amp;lt;assert.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f3818c60dd5ef1e3857dbc5128a82d394bd645c" translate="yes" xml:space="preserve">
          <source>This keyword is also available as convenience macro &lt;a href=&quot;../types&quot;&gt;&lt;code&gt;alignas&lt;/code&gt;&lt;/a&gt;, available in the header &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Esta palabra clave tambi&amp;eacute;n est&amp;aacute; disponible como conveniencia macro &lt;a href=&quot;../types&quot;&gt; &lt;code&gt;alignas&lt;/code&gt; &lt;/a&gt; , disponible en el encabezado &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15e8ecfd0675839a3db53a82395e130694339dcc" translate="yes" xml:space="preserve">
          <source>This macro allows for the precise way to assemble a complex number from its real and imaginary components, e.g. with &lt;code&gt;(double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;)((double)x + _Imaginary_I * (double)y)&lt;/code&gt;. This pattern was standardized in C11 as the macro &lt;code&gt;&lt;a href=&quot;cmplx&quot;&gt;CMPLX&lt;/a&gt;&lt;/code&gt;. Note that if &lt;code&gt;&lt;a href=&quot;complex_i&quot;&gt;_Complex_I&lt;/a&gt;&lt;/code&gt; is used instead, this expression is allowed to convert negative zero to positive zero in the imaginary position.</source>
          <target state="translated">Esta macro permite la forma precisa de ensamblar un n&amp;uacute;mero complejo a partir de sus componentes reales e imaginarios, por ejemplo, con &lt;code&gt;(double &lt;a href=&quot;complex&quot;&gt;complex&lt;/a&gt;)((double)x + _Imaginary_I * (double)y)&lt;/code&gt; . Este patr&amp;oacute;n se estandariz&amp;oacute; en C11 como la macro &lt;code&gt;&lt;a href=&quot;cmplx&quot;&gt;CMPLX&lt;/a&gt;&lt;/code&gt; . Tenga en cuenta que si se usa &lt;code&gt;&lt;a href=&quot;complex_i&quot;&gt;_Complex_I&lt;/a&gt;&lt;/code&gt; en su lugar, esta expresi&amp;oacute;n puede convertir cero negativo a cero positivo en la posici&amp;oacute;n imaginaria.</target>
        </trans-unit>
        <trans-unit id="023f0d845cc1e4d3a0cf1393352c3051de4551a4" translate="yes" xml:space="preserve">
          <source>This macro detects the sign bit of zeroes, infinities, and NaNs. Along with &lt;code&gt;&lt;a href=&quot;copysign&quot;&gt;copysign&lt;/a&gt;&lt;/code&gt;, this macro is one of the only two portable ways to examine the sign of a NaN.</source>
          <target state="translated">Esta macro detecta el bit de signo de ceros, infinitos y NaN. Junto con &lt;code&gt;&lt;a href=&quot;copysign&quot;&gt;copysign&lt;/a&gt;&lt;/code&gt; , esta macro es una de las dos &amp;uacute;nicas formas port&amp;aacute;tiles de examinar el signo de un NaN.</target>
        </trans-unit>
        <trans-unit id="a3cb93fa29a939ad1bd07999da84e45d8cb15f21" translate="yes" xml:space="preserve">
          <source>This macro expands to a type specifier used to identify &lt;a href=&quot;../../language/arithmetic_types#Complex_floating_types&quot;&gt;complex types&lt;/a&gt;.</source>
          <target state="translated">Esta macro se expande a un especificador de tipo utilizado para identificar &lt;a href=&quot;../../language/arithmetic_types#Complex_floating_types&quot;&gt;tipos complejos&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6aae5edaddb18393f98f243eeeef3dce5c87a470" translate="yes" xml:space="preserve">
          <source>This macro expands to the keyword &lt;a href=&quot;../../keyword/_imaginary&quot;&gt;_Imaginary&lt;/a&gt;.</source>
          <target state="translated">Esta macro se expande a la palabra clave &lt;a href=&quot;../../keyword/_imaginary&quot;&gt;_Imaginary&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4eb4294230f13b4be30e04365483aa72ed1a0d15" translate="yes" xml:space="preserve">
          <source>This macro may be used when &lt;code&gt;I&lt;/code&gt; is not available, such as when it has been undefined by the application.</source>
          <target state="translated">Esta macro se puede usar cuando &lt;code&gt;I&lt;/code&gt; estoy disponible, como cuando la aplicaci&amp;oacute;n no lo ha definido.</target>
        </trans-unit>
        <trans-unit id="18ace75fad1f360f4336a3771cfb8db911e37fa5" translate="yes" xml:space="preserve">
          <source>This macro was a part of early draft design for C11 atomic types. It is not needed in C11, and is deprecated in C17 with plans to be removed in C2x.</source>
          <target state="translated">Esta macro fue parte del primer borrador de diseño para los tipos atómicos C11.No se necesita en el C11,y está desaprobada en el C17 con planes para ser eliminada en el C2x.</target>
        </trans-unit>
        <trans-unit id="a1e32004ae8fed464e4a25960c2972f60263328f" translate="yes" xml:space="preserve">
          <source>This operation is commonly implemented in hardware as &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiply%E2%80%93accumulate_operation&quot;&gt;fused multiply-add&lt;/a&gt; CPU instruction. If supported by hardware, the appropriate FP_FAST_FMA* macros are expected to be defined, but many implementations make use of the CPU instruction even when the macros are not defined.</source>
          <target state="translated">Esta operaci&amp;oacute;n se implementa com&amp;uacute;nmente en el hardware como instrucciones de CPU de &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiply%E2%80%93accumulate_operation&quot;&gt;m&amp;uacute;ltiples agregados fusionados&lt;/a&gt; . Si es compatible con el hardware, se espera que se definan las macros FP_FAST_FMA * apropiadas, pero muchas implementaciones utilizan la instrucci&amp;oacute;n de la CPU incluso cuando las macros no est&amp;aacute;n definidas.</target>
        </trans-unit>
        <trans-unit id="9e79fdb6054a98950180ec5dde4644fc50b541ce" translate="yes" xml:space="preserve">
          <source>This operator is typically used through the convenience macro &lt;a href=&quot;../types&quot;&gt;&lt;code&gt;alignof&lt;/code&gt;&lt;/a&gt;, which is provided in the header &lt;code&gt;stdalign.h&lt;/code&gt;.</source>
          <target state="translated">Este operador se usa generalmente a trav&amp;eacute;s de la conveniencia macro &lt;a href=&quot;../types&quot;&gt; &lt;code&gt;alignof&lt;/code&gt; &lt;/a&gt; , que se proporciona en el encabezado &lt;code&gt;stdalign.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce8f6e8c9fd40e6e31833711dbbb781eb59ce111" translate="yes" xml:space="preserve">
          <source>This optional extension to the C language limits the potential results of executing some forms of undefined behavior, which improves the effectiveness of static analysis of such programs. Analyzability is only guaranteed to be enabled if the &lt;a href=&quot;../preprocessor/replace&quot;&gt;predefined macro constant&lt;/a&gt;&lt;code&gt;__STDC_ANALYZABLE__&lt;/code&gt;(C11) is defined by the compiler.</source>
          <target state="translated">Esta extensi&amp;oacute;n opcional al lenguaje C limita los resultados potenciales de ejecutar algunas formas de comportamiento indefinido, lo que mejora la efectividad del an&amp;aacute;lisis est&amp;aacute;tico de dichos programas. La capacidad de an&amp;aacute;lisis solo se garantiza si la &lt;code&gt;__STDC_ANALYZABLE__&lt;/code&gt; &lt;a href=&quot;../preprocessor/replace&quot;&gt;constante de macro predefinida &lt;/a&gt;__STDC_ANALYZABLE__ (C11).</target>
        </trans-unit>
        <trans-unit id="74321edc083fa8a6c39f9d431ba4d565efc66119" translate="yes" xml:space="preserve">
          <source>This section provides definitions for the specific terminology and the concepts used when describing the C programming language.</source>
          <target state="translated">En esta sección se ofrecen definiciones de la terminología específica y de los conceptos utilizados al describir el lenguaje de programación C.</target>
        </trans-unit>
        <trans-unit id="94a2219ff6590395a027f7654f7033a84e305390" translate="yes" xml:space="preserve">
          <source>This special identifier is sometimes used in combination with the &lt;a href=&quot;../preprocessor/replace&quot;&gt;predefined macro constants&lt;/a&gt;&lt;code&gt;__FILE__&lt;/code&gt; and &lt;code&gt;__LINE__&lt;/code&gt;, for example, by &lt;code&gt;&lt;a href=&quot;../error/assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Este identificador especial a veces se usa en combinaci&amp;oacute;n con las &lt;a href=&quot;../preprocessor/replace&quot;&gt;constantes de macro predefinidas &lt;/a&gt; &lt;code&gt;__FILE__&lt;/code&gt; y &lt;code&gt;__LINE__&lt;/code&gt; , por ejemplo, por &lt;code&gt;&lt;a href=&quot;../error/assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a566611cbefba4805ca4f4043cbf2b2282bebff9" translate="yes" xml:space="preserve">
          <source>This specifier is typically used through the convenience macro &lt;a href=&quot;../types&quot;&gt;&lt;code&gt;noreturn&lt;/code&gt;&lt;/a&gt;, which is provided in the header &lt;code&gt;stdnoreturn.h&lt;/code&gt;.</source>
          <target state="translated">Este especificador se usa t&amp;iacute;picamente a trav&amp;eacute;s de la conveniencia macro &lt;a href=&quot;../types&quot;&gt; &lt;code&gt;noreturn&lt;/code&gt; &lt;/a&gt; , que se proporciona en el encabezado &lt;code&gt;stdnoreturn.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7c6ad17c59c0162dbceca8860dddec46556c891" translate="yes" xml:space="preserve">
          <source>Thread library</source>
          <target state="translated">Biblioteca de hilos</target>
        </trans-unit>
        <trans-unit id="859e6e5a070908c070449630fc5c93ccc9de646c" translate="yes" xml:space="preserve">
          <source>Thread storage duration</source>
          <target state="translated">Duración del almacenamiento del hilo</target>
        </trans-unit>
        <trans-unit id="604ac3e54d45a1053374b3b32afdb7b25fbf1ed4" translate="yes" xml:space="preserve">
          <source>Thread support</source>
          <target state="translated">Soporte del hilo</target>
        </trans-unit>
        <trans-unit id="e2d8ff11421f3eaf1af17a9be19957f5569bce89" translate="yes" xml:space="preserve">
          <source>Thread support library</source>
          <target state="translated">Biblioteca de apoyo a los hilos</target>
        </trans-unit>
        <trans-unit id="ccd9cecfbe050ef8f7199536919145c98a9ee01e" translate="yes" xml:space="preserve">
          <source>Thread-local storage</source>
          <target state="translated">Almacenamiento local de hilos</target>
        </trans-unit>
        <trans-unit id="bb12e8aaaecc434fd51e448fe7669bced1bdd107" translate="yes" xml:space="preserve">
          <source>Threads</source>
          <target state="translated">Threads</target>
        </trans-unit>
        <trans-unit id="e7a80c12335015336479b7097a8b8db3ed660872" translate="yes" xml:space="preserve">
          <source>Threads and data races</source>
          <target state="translated">Hilos y carreras de datos</target>
        </trans-unit>
        <trans-unit id="c43feecba43a30ac9fc0c134e6e8cb0382c660f2" translate="yes" xml:space="preserve">
          <source>Time manipulation</source>
          <target state="translated">Manipulación del tiempo</target>
        </trans-unit>
        <trans-unit id="4f5801c83faefb52d8b0b1d0165948b2acc652f4" translate="yes" xml:space="preserve">
          <source>Time/date utilities</source>
          <target state="translated">Utilidades de tiempo/fecha</target>
        </trans-unit>
        <trans-unit id="3638c034bf7f420ee37fdfda08e7287a4fde3110" translate="yes" xml:space="preserve">
          <source>To avoid undefined behavior, the programmer must ensure that the aliasing assertions made by the restrict-qualified pointers are not violated.</source>
          <target state="translated">Para evitar un comportamiento indefinido,el programador debe asegurarse de que no se violen las afirmaciones de alias hechas por los punteros restringidos.</target>
        </trans-unit>
        <trans-unit id="0308792871c141a4861984782de04d99ed007497" translate="yes" xml:space="preserve">
          <source>To initialize a pointer to null or to assign the null value to an existing pointer, a null pointer constant (&lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, or any other integer constant with the value zero) may be used. &lt;a href=&quot;initialization&quot;&gt;static initialization&lt;/a&gt; also initializes pointers to their null values.</source>
          <target state="translated">Para inicializar un puntero a nulo o para asignar el valor nulo a un puntero existente, se puede usar una constante de puntero nulo ( &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; o cualquier otra constante entera con el valor cero).&lt;a href=&quot;initialization&quot;&gt;La inicializaci&amp;oacute;n est&amp;aacute;tica&lt;/a&gt; tambi&amp;eacute;n inicializa los punteros a sus valores nulos.</target>
        </trans-unit>
        <trans-unit id="4a15bb607a0d9f65c2250157e2a839ed92b437f9" translate="yes" xml:space="preserve">
          <source>Top-level comma operator is also disallowed in array bounds.</source>
          <target state="translated">El operador de comas de alto nivel también está desautorizado en los límites de la matriz.</target>
        </trans-unit>
        <trans-unit id="00914541a4417609db5b497e533746eecb783cd5" translate="yes" xml:space="preserve">
          <source>Total sequential ordering requires a full memory fence CPU instruction on all multi-core systems. This may become a performance bottleneck since it forces the affected memory accesses to propagate to every core.</source>
          <target state="translated">El orden secuencial total requiere una instrucción completa de la CPU de la valla de memoria en todos los sistemas multi-núcleo.Esto puede convertirse en un cuello de botella en el rendimiento,ya que obliga a los accesos de memoria afectados a propagarse a cada núcleo.</target>
        </trans-unit>
        <trans-unit id="46e6b018bf6b11f9dba2a0941a7aa6b16ebcda66" translate="yes" xml:space="preserve">
          <source>Transfers control unconditionally to the desired location.</source>
          <target state="translated">Transfiere el control incondicionalmente al lugar deseado.</target>
        </trans-unit>
        <trans-unit id="b482437ed63f1df61cce8a2acd92481bf3131a5e" translate="yes" xml:space="preserve">
          <source>Transforms the null-terminated byte string pointed to by &lt;code&gt;src&lt;/code&gt; into the implementation-defined form such that comparing two transformed strings with &lt;code&gt;&lt;a href=&quot;strcmp&quot;&gt;strcmp&lt;/a&gt;&lt;/code&gt; gives the same result as comparing the original strings with &lt;code&gt;&lt;a href=&quot;strcoll&quot;&gt;strcoll&lt;/a&gt;&lt;/code&gt;, in the current C locale.</source>
          <target state="translated">Transforma la cadena de bytes terminada en nulo a la que apunta &lt;code&gt;src&lt;/code&gt; en la forma definida por la implementaci&amp;oacute;n, de modo que comparar dos cadenas transformadas con &lt;code&gt;&lt;a href=&quot;strcmp&quot;&gt;strcmp&lt;/a&gt;&lt;/code&gt; da el mismo resultado que comparar las cadenas originales con &lt;code&gt;&lt;a href=&quot;strcoll&quot;&gt;strcoll&lt;/a&gt;&lt;/code&gt; , en la configuraci&amp;oacute;n regional actual de C.</target>
        </trans-unit>
        <trans-unit id="13e434293d4a04a3d618635cca12fbe14a8e43a1" translate="yes" xml:space="preserve">
          <source>Transforms the null-terminated wide string pointed to by &lt;code&gt;src&lt;/code&gt; into the implementation-defined form such that comparing two transformed strings with &lt;code&gt;&lt;a href=&quot;wcscmp&quot;&gt;wcscmp&lt;/a&gt;&lt;/code&gt; gives the same result as comparing the original strings with &lt;code&gt;&lt;a href=&quot;wcscoll&quot;&gt;wcscoll&lt;/a&gt;&lt;/code&gt;, in the current C locale.</source>
          <target state="translated">Transforma la cadena ancha terminada en nulo a la que apunta &lt;code&gt;src&lt;/code&gt; en la forma definida por la implementaci&amp;oacute;n de modo que al comparar dos cadenas transformadas con &lt;code&gt;&lt;a href=&quot;wcscmp&quot;&gt;wcscmp&lt;/a&gt;&lt;/code&gt; se obtiene el mismo resultado que al comparar las cadenas originales con &lt;code&gt;&lt;a href=&quot;wcscoll&quot;&gt;wcscoll&lt;/a&gt;&lt;/code&gt; , en la configuraci&amp;oacute;n regional actual de C.</target>
        </trans-unit>
        <trans-unit id="4a101021db9dbdc21787f5f05cdb78df394c7c59" translate="yes" xml:space="preserve">
          <source>Translation limits</source>
          <target state="translated">Límites de traducción</target>
        </trans-unit>
        <trans-unit id="97ae6e6ddfa14e2bb949e4821dfd339e832124c2" translate="yes" xml:space="preserve">
          <source>Translation phases</source>
          <target state="translated">Fases de traducción</target>
        </trans-unit>
        <trans-unit id="9b1b19c48da84c8f1d5f977c8442d8b7f1fe8d0f" translate="yes" xml:space="preserve">
          <source>Tries to lock the mutex pointed to by &lt;code&gt;mutex&lt;/code&gt; without blocking. Returns immediately if the mutex is already locked.</source>
          <target state="translated">Intenta bloquear el mutex se&amp;ntilde;alado por &lt;code&gt;mutex&lt;/code&gt; sin bloquear. Regresa inmediatamente si el mutex ya est&amp;aacute; bloqueado.</target>
        </trans-unit>
        <trans-unit id="b9e4c026492c440bf32166e0789393487d03b254" translate="yes" xml:space="preserve">
          <source>Trigonometric functions</source>
          <target state="translated">Funciones trigonométricas</target>
        </trans-unit>
        <trans-unit id="e719a16c184c9946c83f511d812044089e2e21c9" translate="yes" xml:space="preserve">
          <source>Trigraph</source>
          <target state="translated">Trigraph</target>
        </trans-unit>
        <trans-unit id="f08a08292325f4a3e0a8098c439550809ff5abe5" translate="yes" xml:space="preserve">
          <source>Trigraphs</source>
          <target state="translated">Trigraphs</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="f530d91391a69a7f0a5ffca3ec89a0e5873ccb85" translate="yes" xml:space="preserve">
          <source>Type cast</source>
          <target state="translated">Tipo de moldeado.</target>
        </trans-unit>
        <trans-unit id="6c1aa9cebe6e183271d6415c7410657e8ccc6473" translate="yes" xml:space="preserve">
          <source>Type classification</source>
          <target state="translated">Clasificación de tipos</target>
        </trans-unit>
        <trans-unit id="3903d0a0100dacebf5dcf7dd9edaed2ca7445692" translate="yes" xml:space="preserve">
          <source>Type groups</source>
          <target state="translated">Grupos de tipos</target>
        </trans-unit>
        <trans-unit id="39b26b192c35ccdbf713808e6519a061718950de" translate="yes" xml:space="preserve">
          <source>Type names</source>
          <target state="translated">Nombres de tipos</target>
        </trans-unit>
        <trans-unit id="a612c634eb324c2736b08815ac8a0a1461bc8c70" translate="yes" xml:space="preserve">
          <source>Type names are used in the following situations:</source>
          <target state="translated">Los nombres de los tipos se utilizan en las siguientes situaciones:</target>
        </trans-unit>
        <trans-unit id="5c3dec20e8df5a43918b8faf39633e46723561db" translate="yes" xml:space="preserve">
          <source>Type specifier</source>
          <target state="translated">Especificador de tipo</target>
        </trans-unit>
        <trans-unit id="ebdbe0be2297808a43109ed1cd29e12d3786ec7d" translate="yes" xml:space="preserve">
          <source>Type support</source>
          <target state="translated">Soporte de tipo</target>
        </trans-unit>
        <trans-unit id="9877feb39d3467fd548f9afcf785d1120971dc32" translate="yes" xml:space="preserve">
          <source>Type-generic expression</source>
          <target state="translated">Expresión tipo-genérica</target>
        </trans-unit>
        <trans-unit id="b0b12fc7b6daa3215c051192f5645eb17e2ae21a" translate="yes" xml:space="preserve">
          <source>Type-generic macro</source>
          <target state="translated">Macro genérica de tipo</target>
        </trans-unit>
        <trans-unit id="dcd459fca026aec411accf6605fd9657b34f539e" translate="yes" xml:space="preserve">
          <source>Type-generic math</source>
          <target state="translated">Matemáticas de tipo genérico</target>
        </trans-unit>
        <trans-unit id="667570999a748e91a3ca2389e2391bc9f38d4223" translate="yes" xml:space="preserve">
          <source>Typedef declaration</source>
          <target state="translated">Declaración de tipedef</target>
        </trans-unit>
        <trans-unit id="2efbc0a48c2cf8824f893117ca1ec4d3510f7e9e" translate="yes" xml:space="preserve">
          <source>Typedef name</source>
          <target state="translated">Nombre escrito a máquina</target>
        </trans-unit>
        <trans-unit id="9de7d443ce78183570b348b13d6fa7a62f5e82c3" translate="yes" xml:space="preserve">
          <source>Typedef names are also commonly used to simplify the syntax of complex declarations:</source>
          <target state="translated">También se suelen utilizar nombres de tipografía para simplificar la sintaxis de las declaraciones complejas:</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="f2c7f86e6a072a5ffe548bdbdb59c9f7a208dd8a" translate="yes" xml:space="preserve">
          <source>Types allowed for integer constants</source>
          <target state="translated">Tipos permitidos para constantes enteras</target>
        </trans-unit>
        <trans-unit id="1b555741394ae9339e15f18c3b6d7121a3052b4c" translate="yes" xml:space="preserve">
          <source>Typical use cases for this ordering involve read access to rarely written concurrent data structures (routing tables, configuration, security policies, firewall rules, etc) and publisher-subscriber situations with pointer-mediated publication, that is, when the producer publishes a pointer through which the consumer can access information: there is no need to make everything else the producer wrote to memory visible to the consumer (which may be an expensive operation on weakly-ordered architectures). An example of such scenario is &lt;a href=&quot;https://en.wikipedia.org/wiki/Read-copy-update&quot;&gt;rcu_dereference&lt;/a&gt;.</source>
          <target state="translated">Los casos de uso t&amp;iacute;picos para este pedido implican acceso de lectura a estructuras de datos concurrentes raramente escritas (tablas de enrutamiento, configuraci&amp;oacute;n, pol&amp;iacute;ticas de seguridad, reglas de firewall, etc.) y situaciones de editor-suscriptor con publicaci&amp;oacute;n mediada por puntero, es decir, cuando el productor publica un puntero a trav&amp;eacute;s de que el consumidor puede acceder a la informaci&amp;oacute;n: no hay necesidad de hacer que todo lo dem&amp;aacute;s que el productor escribi&amp;oacute; en la memoria sea visible para el consumidor (lo que puede ser una operaci&amp;oacute;n costosa en arquitecturas poco ordenadas). Un ejemplo de tal escenario es &lt;a href=&quot;https://en.wikipedia.org/wiki/Read-copy-update&quot;&gt;rcu_dereference&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e9516dc93be7c971fcd17049638de54d997ca4a8" translate="yes" xml:space="preserve">
          <source>Typical use for relaxed memory ordering is incrementing counters, such as the reference counters , since this only requires atomicity, but not ordering or synchronization (note that decrementing the shared_ptr counters requires acquire-release synchronization with the destructor).</source>
          <target state="translated">El uso típico para el ordenamiento de la memoria relajada es incrementar los contadores,como los contadores de referencia,ya que esto sólo requiere atomicidad,pero no ordenamiento ni sincronización (obsérvese que para disminuir los contadores shared_ptr se requiere la sincronización de adquisición-liberación con el destructor).</target>
        </trans-unit>
        <trans-unit id="b8eea246e8bae9254ad685bd7b3a0d93181f6ef8" translate="yes" xml:space="preserve">
          <source>Typically TSS is used to store pointers to blocks of dynamically allocated memory that have been reserved for use by the calling thread.</source>
          <target state="translated">Típicamente la TSS se usa para almacenar punteros a bloques de memoria asignados dinámicamente que han sido reservados para ser usados por el hilo de llamada.</target>
        </trans-unit>
        <trans-unit id="57e2c95f58f57dd2510b427e263653b73348604c" translate="yes" xml:space="preserve">
          <source>U-prefixed wide string literals can be used to initialize arrays of any type compatible with (ignoring cv-qualifications &lt;code&gt;char32_t&lt;/code&gt;</source>
          <target state="translated">Los literales de cadena ancha con prefijo U se pueden usar para inicializar matrices de cualquier tipo compatible con (ignorando las calificaciones de cv &lt;code&gt;char32_t&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="02625f3ba5ef5ecc340624e8cdbc7bbea1792597" translate="yes" xml:space="preserve">
          <source>UB and optimization</source>
          <target state="translated">UB y optimización</target>
        </trans-unit>
        <trans-unit id="fc4cea3d19213a9f2ad0bf9e1d25fcd42a13416e" translate="yes" xml:space="preserve">
          <source>UCHAR_MAXUSHRT_MAXUINT_MAXULONG_MAXULLONG_MAX</source>
          <target state="translated">UCHAR_MAXUSHRT_MAXUINT_MAXULONG_MAXULLONG_MAX</target>
        </trans-unit>
        <trans-unit id="b326c17ee1a8eb3c225550246d3d3c78e82f8b2f" translate="yes" xml:space="preserve">
          <source>UINT8_CUINT16_CUINT32_CUINT64_C</source>
          <target state="translated">UINT8_CUINT16_CUINT32_CUINT64_C</target>
        </trans-unit>
        <trans-unit id="6fc76eff0c2b7cb02126a9c106ac3442a9727995" translate="yes" xml:space="preserve">
          <source>UINT8_MAXUINT16_MAXUINT32_MAXUINT64_MAX</source>
          <target state="translated">UINT8_MAXUINT16_MAXUINT32_MAXUINT64_MAX</target>
        </trans-unit>
        <trans-unit id="9ba6e74bce3dda604b2bb3467dd7e8066580c7b5" translate="yes" xml:space="preserve">
          <source>UINTMAX_C</source>
          <target state="translated">UINTMAX_C</target>
        </trans-unit>
        <trans-unit id="5b83709ee00794f8873850a1d8ed0fb42b4fb169" translate="yes" xml:space="preserve">
          <source>UINTMAX_MAX</source>
          <target state="translated">UINTMAX_MAX</target>
        </trans-unit>
        <trans-unit id="ce620a4e99af76df2964e767b6f8444400deb8ca" translate="yes" xml:space="preserve">
          <source>UINTPTR_MAX</source>
          <target state="translated">UINTPTR_MAX</target>
        </trans-unit>
        <trans-unit id="bfda17e335d33e8db92bdb55c45171d922a6859c" translate="yes" xml:space="preserve">
          <source>UINT_FAST8_MAXUINT_FAST16_MAXUINT_FAST32_MAXUINT_FAST64_MAX</source>
          <target state="translated">UINT_FAST8_MAXUINT_FAST16_MAXUINT_FAST32_MAXUINT_FAST64_MAX</target>
        </trans-unit>
        <trans-unit id="ad74c7ce12e14f74c8c414a0ec98ea6351f500a5" translate="yes" xml:space="preserve">
          <source>UINT_LEAST8_MAXUINT_LEAST16_MAXUINT_LEAST32_MAXUINT_LEAST64_MAX</source>
          <target state="translated">UINT_LEAST8_MAXUINT_LEAST16_MAXUINT_LEAST32_MAXUINT_LEAST64_MAX</target>
        </trans-unit>
        <trans-unit id="978310885d0047a2bbf93710be46a9692c211868" translate="yes" xml:space="preserve">
          <source>UTF-16 and UTF-32 character utilities</source>
          <target state="translated">Utilidades de caracteres UTF-16 y UTF-32</target>
        </trans-unit>
        <trans-unit id="e3121f2da5238f5445bc35f88607eb1340cef35d" translate="yes" xml:space="preserve">
          <source>UTF-8 string literal</source>
          <target state="translated">UTF-8 de cuerda literal</target>
        </trans-unit>
        <trans-unit id="5f3e0d667a999aa457338ffa317c4bbb126755c9" translate="yes" xml:space="preserve">
          <source>Unary arithmetic</source>
          <target state="translated">Aritmética unitaria</target>
        </trans-unit>
        <trans-unit id="262592c99ae87d664d104863b6a975a077ca3383" translate="yes" xml:space="preserve">
          <source>Unary plus and minus</source>
          <target state="translated">Unario más y menos</target>
        </trans-unit>
        <trans-unit id="de34c09eb59e18282b0464bd0bc5cfe7ba5ad888" translate="yes" xml:space="preserve">
          <source>Unblocks all thread that currently wait on condition variable pointed to by &lt;code&gt;cond&lt;/code&gt;. If no threads are blocked, does nothing and returns &lt;code&gt;thrd_success&lt;/code&gt;.</source>
          <target state="translated">Desbloquea todos los hilos que actualmente esperan en la variable de condici&amp;oacute;n se&amp;ntilde;alada por &lt;code&gt;cond&lt;/code&gt; . Si no hay hilos bloqueados, no hace nada y devuelve &lt;code&gt;thrd_success&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f7e568fb8b3fa778750d4687284053585644562" translate="yes" xml:space="preserve">
          <source>Unblocks one thread that currently waits on condition variable pointed to by &lt;code&gt;cond&lt;/code&gt;. If no threads are blocked, does nothing and returns &lt;code&gt;thrd_success&lt;/code&gt;.</source>
          <target state="translated">Desbloquea un hilo que actualmente espera en la variable de condici&amp;oacute;n se&amp;ntilde;alada por &lt;code&gt;cond&lt;/code&gt; . Si no hay hilos bloqueados, no hace nada y devuelve &lt;code&gt;thrd_success&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae22d7da41718d2107d501afa593d0dc097c049a" translate="yes" xml:space="preserve">
          <source>Undefined Behavior and Fermat&amp;rsquo;s Last Theorem</source>
          <target state="translated">Comportamiento indefinido y &amp;uacute;ltimo teorema de Fermat</target>
        </trans-unit>
        <trans-unit id="ebb35fed37a359f87ca6b9131bfd7b210eb81cd6" translate="yes" xml:space="preserve">
          <source>Undefined behavior</source>
          <target state="translated">Comportamiento indefinido</target>
        </trans-unit>
        <trans-unit id="675cd8702b8351b311d54416e35e1e88d24ddc83" translate="yes" xml:space="preserve">
          <source>Undefined behavior can result in time travel (among other things, but time travel is the funkiest)</source>
          <target state="translated">El comportamiento indefinido puede resultar en un viaje en el tiempo (entre otras cosas,pero el viaje en el tiempo es el más funky)</target>
        </trans-unit>
        <trans-unit id="629edcbcf75dfc7ce2bd6d903269c3ab902f3f25" translate="yes" xml:space="preserve">
          <source>Underflow is guaranteed if &lt;code&gt;|arg| &amp;lt; &lt;a href=&quot;../../types/limits&quot;&gt;DBL_MIN&lt;/a&gt;*(&lt;a href=&quot;sqrt&quot;&gt;sqrt&lt;/a&gt;(&amp;pi;)/2)&lt;/code&gt;.  erf(</source>
          <target state="translated">El desbordamiento est&amp;aacute; garantizado si &lt;code&gt;|arg| &amp;lt; &lt;a href=&quot;../../types/limits&quot;&gt;DBL_MIN&lt;/a&gt;*(&lt;a href=&quot;sqrt&quot;&gt;sqrt&lt;/a&gt;(&amp;pi;)/2)&lt;/code&gt; . erf (</target>
        </trans-unit>
        <trans-unit id="5b4fe0953f656d5c3e07304963135e1851f6e5c7" translate="yes" xml:space="preserve">
          <source>Understanding Integer Overflow in C/C++</source>
          <target state="translated">Comprensión del desbordamiento de enteros en C/C++</target>
        </trans-unit>
        <trans-unit id="5e6066d0264c25a17abb92da4543d5a1bb3137db" translate="yes" xml:space="preserve">
          <source>Unevaluated expressions</source>
          <target state="translated">Expresiones no evaluadas</target>
        </trans-unit>
        <trans-unit id="123f1fcb3edd17ce760e7f03ab6319443c344106" translate="yes" xml:space="preserve">
          <source>Unformatted input/output</source>
          <target state="translated">Entrada/salida sin formato</target>
        </trans-unit>
        <trans-unit id="a1a52383b2bc722ac899de02954f212432e3b35b" translate="yes" xml:space="preserve">
          <source>Uninitialized scalar</source>
          <target state="translated">Escalar no inicializado</target>
        </trans-unit>
        <trans-unit id="669a8f132f6da5ef9c5ce154e361c127d5e3b34d" translate="yes" xml:space="preserve">
          <source>Union declaration</source>
          <target state="translated">Declaración de la Unión</target>
        </trans-unit>
        <trans-unit id="43b3c1af3450df3cd0e1ac52c9b04b756ccd01b6" translate="yes" xml:space="preserve">
          <source>Unix and Unix-like systems (Linux, Mac OS X)</source>
          <target state="translated">Unix y sistemas similares a Unix (Linux,Mac OS X)</target>
        </trans-unit>
        <trans-unit id="fc9481ccc42310377001eaf4b65f0ba7f43291d9" translate="yes" xml:space="preserve">
          <source>Unless</source>
          <target state="translated">Unless</target>
        </trans-unit>
        <trans-unit id="b94d3063db2e039c2fe617cac39f892f9945b2d8" translate="yes" xml:space="preserve">
          <source>Unless &lt;a href=&quot;../preprocessor/impl&quot;&gt;&lt;code&gt; #pragma STDC FP_CONTRACT&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;OFF&lt;/code&gt;, all floating-point arithmetic may be performed as if the intermediate results have infinite range and precision, that is optimizations that omit rounding errors and floating-point exceptions that would be observed if the expression was evaluated exactly as written. For example, allows the implementation of &lt;code&gt;(x*y) + z&lt;/code&gt; with a single fused multiply-add CPU instruction or optimization of &lt;code&gt;a = x*x*x*x;&lt;/code&gt; as &lt;code&gt;tmp = x*x; a = tmp*tmp&lt;/code&gt;.</source>
          <target state="translated">A menos que &lt;a href=&quot;../preprocessor/impl&quot;&gt; &lt;code&gt; #pragma STDC FP_CONTRACT&lt;/code&gt; &lt;/a&gt; est&amp;eacute; establecido en &lt;code&gt;OFF&lt;/code&gt; , toda la aritm&amp;eacute;tica de punto flotante se puede realizar como si los resultados intermedios tuvieran un rango y precisi&amp;oacute;n infinitos, es decir, optimizaciones que omiten errores de redondeo y excepciones de punto flotante que se observar&amp;iacute;an si se evaluara la expresi&amp;oacute;n exactamente como est&amp;aacute; escrito Por ejemplo, permite la implementaci&amp;oacute;n de &lt;code&gt;(x*y) + z&lt;/code&gt; con una sola instrucci&amp;oacute;n de CPU de m&amp;uacute;ltiples agregados fusionados u optimizaci&amp;oacute;n de &lt;code&gt;a = x*x*x*x;&lt;/code&gt; como &lt;code&gt;tmp = x*x; a = tmp*tmp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b15a066b3b603647166b0b65f64183254893ada5" translate="yes" xml:space="preserve">
          <source>Unless a range error occurs, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; is never raised (the result is exact)</source>
          <target state="translated">A menos que ocurra un error de rango, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; nunca se eleva (el resultado es exacto)</target>
        </trans-unit>
        <trans-unit id="9cb361932c4949b97f983057f3dae3e641beb697" translate="yes" xml:space="preserve">
          <source>Unless a range error occurs, the &lt;a href=&quot;../fenv/fe_round&quot;&gt;current rounding mode&lt;/a&gt; is ignored</source>
          <target state="translated">A menos que ocurra un error de rango, el &lt;a href=&quot;../fenv/fe_round&quot;&gt;modo de redondeo actual&lt;/a&gt; se ignora el</target>
        </trans-unit>
        <trans-unit id="a58fabd46910e7bcf45330fb949c04b6b27dee2e" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;function_declaration&quot;&gt;function declarations&lt;/a&gt;, unnamed formal parameters are not allowed, they must be named even if they are not used within the function. The only exception is the special parameter list &lt;code&gt;(void)&lt;/code&gt;.</source>
          <target state="translated">A diferencia de &lt;a href=&quot;function_declaration&quot;&gt;las declaraciones de funci&amp;oacute;n&lt;/a&gt; , los par&amp;aacute;metros formales sin nombre no est&amp;aacute;n permitidos, deben nombrarse incluso si no se utilizan dentro de la funci&amp;oacute;n. La &amp;uacute;nica excepci&amp;oacute;n es la lista de par&amp;aacute;metros especiales &lt;code&gt;(void)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59590d273656ea53ab0c485190687185f59c87d4" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;integer_constant&quot;&gt;integer constants&lt;/a&gt;, a character constant may have a negative value if &lt;code&gt;char&lt;/code&gt; is signed: on such implementations &lt;code&gt;'\xFF'&lt;/code&gt; is an &lt;code&gt;int&lt;/code&gt; with the value &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">A diferencia de las &lt;a href=&quot;integer_constant&quot;&gt;constantes enteras&lt;/a&gt; , una constante de caracteres puede tener un valor negativo si &lt;code&gt;char&lt;/code&gt; est&amp;aacute; firmado: en tales implementaciones, &lt;code&gt;'\xFF'&lt;/code&gt; es un &lt;code&gt;int&lt;/code&gt; con el valor &lt;code&gt;-1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5893b9d3c3844337b6f481ce45fa24bcaf49949" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt;, there are no forward-declared enums in C:</source>
          <target state="translated">A diferencia de la &lt;a href=&quot;struct&quot;&gt;estructura&lt;/a&gt; o &lt;a href=&quot;union&quot;&gt;uni&amp;oacute;n&lt;/a&gt; , no hay enumeraciones con declaraci&amp;oacute;n directa en C:</target>
        </trans-unit>
        <trans-unit id="349921c60cca86b52b79297f58eff9fe42b04e26" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../byte/strtok&quot;&gt;strtok&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;wcstok&lt;/code&gt; does not update static storage: it stores the parser state in the user-provided location.</source>
          <target state="translated">A diferencia de &lt;code&gt;&lt;a href=&quot;../byte/strtok&quot;&gt;strtok&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;wcstok&lt;/code&gt; no actualiza almacenamiento est&amp;aacute;tico: se almacena el estado del analizador en la ubicaci&amp;oacute;n proporcionada por el usuario.</target>
        </trans-unit>
        <trans-unit id="4736d68a5eefa333a2087043cb0199117cb95803" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;cmplx&quot;&gt;CMPLX&lt;/a&gt;&lt;/code&gt;, use of this macro to construct a complex number may lose the sign of zero on the imaginary component.</source>
          <target state="translated">A diferencia de &lt;code&gt;&lt;a href=&quot;imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;cmplx&quot;&gt;CMPLX&lt;/a&gt;&lt;/code&gt; , el uso de esta macro para construir un n&amp;uacute;mero complejo puede perder el signo de cero en el componente imaginario.</target>
        </trans-unit>
        <trans-unit id="651147d7ee29a364b3441c1d65b4a589a7d4d5b1" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;strncpy&lt;/code&gt;, &lt;code&gt;strncpy_s&lt;/code&gt; does not pad the destination array with zeroes, This is a common source of errors when converting existing code to the bounds-checked version.</source>
          <target state="translated">A diferencia de &lt;code&gt;strncpy&lt;/code&gt; , &lt;code&gt;strncpy_s&lt;/code&gt; no rellena la matriz de destino con ceros. Esta es una fuente com&amp;uacute;n de errores al convertir el c&amp;oacute;digo existente a la versi&amp;oacute;n de verificaci&amp;oacute;n de l&amp;iacute;mites.</target>
        </trans-unit>
        <trans-unit id="1809f65a8ac2a536dcff46fc36c71372570caec2" translate="yes" xml:space="preserve">
          <source>Unlike C++ (and some implementations of C), the increment/decrement expressions are never themselves lvalues: &lt;code&gt;&amp;amp;++a&lt;/code&gt; is invalid.</source>
          <target state="translated">A diferencia de C ++ (y algunas implementaciones de C), las expresiones de incremento / decremento nunca son en s&amp;iacute; mismas valores: &lt;code&gt;&amp;amp;++a&lt;/code&gt; no es v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="12d3be48bbe8c1161c3b11cb7b674b4d820d5f30" translate="yes" xml:space="preserve">
          <source>Unlike C++, C has no struct scope: names declared within a struct/union/enum declaration are in the same scope as the struct declaration (except that data members are in their own &lt;a href=&quot;name_space&quot;&gt;member name space&lt;/a&gt;):</source>
          <target state="translated">A diferencia de C ++, C no tiene &amp;aacute;mbito de estructura: los nombres declarados dentro de una declaraci&amp;oacute;n de estructura / uni&amp;oacute;n / enumeraci&amp;oacute;n est&amp;aacute;n en el mismo &amp;aacute;mbito que la declaraci&amp;oacute;n de estructura (excepto que los miembros de datos est&amp;aacute;n en su propio &lt;a href=&quot;name_space&quot;&gt;espacio de nombre de miembro&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="356cd0e4f851521f00fbf0ecd9e4515ffc02b0ad" translate="yes" xml:space="preserve">
          <source>Unlike functions, pointers to functions are objects and thus can be stored in arrays, copied, assigned, passed to other functions as arguments, etc.</source>
          <target state="translated">A diferencia de las funciones,los punteros a las funciones son objetos y por lo tanto pueden ser almacenados en matrices,copiados,asignados,pasados a otras funciones como argumentos,etc.</target>
        </trans-unit>
        <trans-unit id="4fc1a9b3bf127389b70df7d40bbc2018c53338a0" translate="yes" xml:space="preserve">
          <source>Unlike header guards, this pragma makes it impossible to erroneously use the same macro name in more than one file. On the other hand, since with &lt;code&gt;#pragma once&lt;/code&gt; files are excluded based on their filesystem-level identity, this can't protect against including a header twice if it exists in more than one location in a project.</source>
          <target state="translated">A diferencia de los protectores de encabezado, este pragma hace que sea imposible usar err&amp;oacute;neamente el mismo nombre de macro en m&amp;aacute;s de un archivo. Por otro lado, ya que con &lt;code&gt;#pragma once&lt;/code&gt; archivos se excluyen en funci&amp;oacute;n de su identidad a nivel de sistema de archivos, esto no puede proteger contra la inclusi&amp;oacute;n de un encabezado dos veces si existe en m&amp;aacute;s de una ubicaci&amp;oacute;n en un proyecto.</target>
        </trans-unit>
        <trans-unit id="0ca9eab5e0c8d0f26634d969a4302dfd4432c351" translate="yes" xml:space="preserve">
          <source>Unlike in C++, enumeration constants are not struct members, and their name space is the name space of ordinary identifiers, and since there is no struct scope in C, their scope is the scope in which the struct declaration appears:</source>
          <target state="translated">A diferencia de C++,las constantes de enumeración no son miembros estructurales,y su espacio de nombres es el espacio de nombres de los identificadores ordinarios,y como no hay ámbito estructural en C,su ámbito es el ámbito en el que aparece la declaración estructural:</target>
        </trans-unit>
        <trans-unit id="7c5a2ac59cc1ae8f5f6a004185b87a1191bb07cb" translate="yes" xml:space="preserve">
          <source>Unlike in C++, the declarators &lt;code&gt;f()&lt;/code&gt; and &lt;code&gt;f(void)&lt;/code&gt; have different meaning: the declarator &lt;code&gt;f(void)&lt;/code&gt; is a new-style (prototype) declarator that declares a function that takes no parameters. The declarator &lt;code&gt;f()&lt;/code&gt; is an old-style (K&amp;amp;R) declarator that declares a function that takes</source>
          <target state="translated">A diferencia de C ++, los declaradores &lt;code&gt;f()&lt;/code&gt; y &lt;code&gt;f(void)&lt;/code&gt; tienen un significado diferente: el declarador &lt;code&gt;f(void)&lt;/code&gt; es un declarador de nuevo estilo (prototipo) que declara una funci&amp;oacute;n que no toma par&amp;aacute;metros. El declarador &lt;code&gt;f()&lt;/code&gt; es un declarador de estilo antiguo (K&amp;amp;R) que declara una funci&amp;oacute;n que toma</target>
        </trans-unit>
        <trans-unit id="33e51c28a36bb5692baf427b5a9efad5cb27763c" translate="yes" xml:space="preserve">
          <source>Unlike in a &lt;a href=&quot;function_definition&quot;&gt;function definition&lt;/a&gt;, the parameter list may be inherited from a typedef.</source>
          <target state="translated">A diferencia de una &lt;a href=&quot;function_definition&quot;&gt;definici&amp;oacute;n de funci&amp;oacute;n&lt;/a&gt; , la lista de par&amp;aacute;metros puede heredarse de un typedef.</target>
        </trans-unit>
        <trans-unit id="ad19b0dd608c2e4f48c9ccaf5ff2ce720f3cee01" translate="yes" xml:space="preserve">
          <source>Unlike integers, not every floating value can be represented directly by decimal or even hexadecimal constant syntax: macros &lt;a href=&quot;../numeric/math/nan&quot;&gt;NAN&lt;/a&gt; and &lt;a href=&quot;../numeric/math/infinity&quot;&gt;INFINITY&lt;/a&gt; as well as functions such as &lt;code&gt;&lt;a href=&quot;../numeric/math/nan.2&quot;&gt;nan&lt;/a&gt;&lt;/code&gt; offer ways to generate those special values. Note that &lt;code&gt;0x1.FFFFFEp128f&lt;/code&gt;, which might appear to be an IEEE float NaN, in fact overflows to an infinity in that format.</source>
          <target state="translated">A diferencia de los enteros, no todos los valores flotantes pueden representarse directamente por sintaxis decimal o incluso hexadecimal constante: las macros &lt;a href=&quot;../numeric/math/nan&quot;&gt;NAN&lt;/a&gt; e &lt;a href=&quot;../numeric/math/infinity&quot;&gt;INFINITY&lt;/a&gt; , as&amp;iacute; como las funciones como &lt;code&gt;&lt;a href=&quot;../numeric/math/nan.2&quot;&gt;nan&lt;/a&gt;&lt;/code&gt; ofrecen formas de generar esos valores especiales. Tenga en cuenta que &lt;code&gt;0x1.FFFFFEp128f&lt;/code&gt; , que podr&amp;iacute;a parecer un NaN flotante IEEE, de hecho se desborda hasta el infinito en ese formato.</target>
        </trans-unit>
        <trans-unit id="69ccd347acbb0fdbbb094496aea02f3e7e062a71" translate="yes" xml:space="preserve">
          <source>Unlike most bounds-checked functions, &lt;code&gt;wctomb_s&lt;/code&gt; does not null-terminate its output, because it is designed to be used in loops that process strings character-by-character.</source>
          <target state="translated">A diferencia de la mayor&amp;iacute;a de las funciones de verificaci&amp;oacute;n de l&amp;iacute;mites, &lt;code&gt;wctomb_s&lt;/code&gt; no termina nulo su salida, porque est&amp;aacute; dise&amp;ntilde;ado para usarse en bucles que procesan cadenas car&amp;aacute;cter por car&amp;aacute;cter.</target>
        </trans-unit>
        <trans-unit id="c348ec3650d4d97ed9bc09e83c2572c81d376d68" translate="yes" xml:space="preserve">
          <source>Unlike most other tokenizers, the delimiters in &lt;code&gt;strtok&lt;/code&gt; can be different for each subsequent token, and can even depend on the contents of the previous tokens.</source>
          <target state="translated">A diferencia de la mayor&amp;iacute;a de los otros tokenizadores, los delimitadores en &lt;code&gt;strtok&lt;/code&gt; pueden ser diferentes para cada token posterior e incluso pueden depender del contenido de los tokens anteriores.</target>
        </trans-unit>
        <trans-unit id="06aee15412aa0900def31255838a5e2cad48a89e" translate="yes" xml:space="preserve">
          <source>Unlike most other tokenizers, the delimiters in &lt;code&gt;wcstok&lt;/code&gt; can be different for each subsequent token, and can even depend on the contents of the previous tokens.</source>
          <target state="translated">A diferencia de la mayor&amp;iacute;a de los otros tokenizadores, los delimitadores en &lt;code&gt;wcstok&lt;/code&gt; pueden ser diferentes para cada token posterior e incluso pueden depender del contenido de los tokens anteriores.</target>
        </trans-unit>
        <trans-unit id="550d0e8f0b2b95fd2ac25cd6e94e1fb04406548e" translate="yes" xml:space="preserve">
          <source>Unlike other bounds-checked functions, &lt;code&gt;bsearch_s&lt;/code&gt; does not treat arrays of zero size as a runtime constraint violation and instead indicates element not found (the other function that accepts arrays of zero size is &lt;code&gt;qsort_s&lt;/code&gt;).</source>
          <target state="translated">A diferencia de otras funciones de verificaci&amp;oacute;n de l&amp;iacute;mites, &lt;code&gt;bsearch_s&lt;/code&gt; no trata las matrices de tama&amp;ntilde;o cero como una violaci&amp;oacute;n de restricci&amp;oacute;n de tiempo de ejecuci&amp;oacute;n y en su lugar indica el elemento no encontrado (la otra funci&amp;oacute;n que acepta matrices de tama&amp;ntilde;o cero es &lt;code&gt;qsort_s&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="32d3f5c043019688f561e38eab05f0332818d6f4" translate="yes" xml:space="preserve">
          <source>Unlike other bounds-checked functions, &lt;code&gt;qsort_s&lt;/code&gt; does not treat arrays of zero size as a runtime constraint violation and instead returns successfully without altering the array (the other function that accepts arrays of zero size is &lt;code&gt;bsearch_s&lt;/code&gt;).</source>
          <target state="translated">A diferencia de otras funciones de verificaci&amp;oacute;n de l&amp;iacute;mites, &lt;code&gt;qsort_s&lt;/code&gt; no trata las matrices de tama&amp;ntilde;o cero como una violaci&amp;oacute;n de restricci&amp;oacute;n de tiempo de ejecuci&amp;oacute;n y en su lugar regresa con &amp;eacute;xito sin alterar la matriz (la otra funci&amp;oacute;n que acepta matrices de tama&amp;ntilde;o cero es &lt;code&gt;bsearch_s&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="984a93ca0ecf9fa1964f4d81ad49bb3ad5b9d8cf" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;a href=&quot;storage_duration&quot;&gt;extern&lt;/a&gt; declarations, which don't change the linkage of an identifier if a previous declaration established it, tentative definitions may disagree in linkage with another declaration of the same identifier. If two declarations for the same identifier are in scope and have different linkage, the behavior is undefined:</source>
          <target state="translated">A diferencia del &lt;a href=&quot;storage_duration&quot;&gt;exterior&lt;/a&gt; declaraciones , que no cambian el enlace de un identificador si una declaraci&amp;oacute;n previa lo estableci&amp;oacute;, las definiciones provisionales pueden estar en desacuerdo en el enlace con otra declaraci&amp;oacute;n del mismo identificador. Si dos declaraciones para el mismo identificador est&amp;aacute;n dentro del alcance y tienen un enlace diferente, el comportamiento no est&amp;aacute; definido:</target>
        </trans-unit>
        <trans-unit id="7d1d42fef2cdf2c3dc389a3d7fa95ed1b3f519b3" translate="yes" xml:space="preserve">
          <source>Unlike with integer constant expressions, static initializer expressions are not required to be evaluated at compile time; the compiler is at liberty to turn such initializers into executable code which is invoked prior to program startup.</source>
          <target state="translated">A diferencia de las expresiones de constantes enteras,no es necesario evaluar las expresiones de inicialización estáticas en tiempo de compilación;el compilador tiene la libertad de convertir tales inicializaciones en código ejecutable que se invoca antes del inicio del programa.</target>
        </trans-unit>
        <trans-unit id="a515ca56a7b59ccaaa0047994f7aaf01c66be46c" translate="yes" xml:space="preserve">
          <source>Unlocks the mutex pointed to by &lt;code&gt;mutex&lt;/code&gt;.</source>
          <target state="translated">Desbloquea el mutex se&amp;ntilde;alado por &lt;code&gt;mutex&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6106cd24d3eb45fe60ce901f8033bf3f6920c45" translate="yes" xml:space="preserve">
          <source>Unrelated to contracting, intermediate results of floating-point arithmetic may have range and precision that is different from the one indicated by its type, see &lt;code&gt;&lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Sin relaci&amp;oacute;n con la contrataci&amp;oacute;n, los resultados intermedios de la aritm&amp;eacute;tica de coma flotante pueden tener un rango y una precisi&amp;oacute;n diferentes de los indicados por su tipo, ver &lt;code&gt;&lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e58bf16bb4075ebd2ecdad4cd86deb15d7942bb7" translate="yes" xml:space="preserve">
          <source>Unsigned integer arithmetic is always performed modulo 2n</source>
          <target state="translated">La aritmética de números enteros sin signo siempre se realiza en el módulo 2n</target>
        </trans-unit>
        <trans-unit id="1569ce9087643318f5b374c7177d610cac24614f" translate="yes" xml:space="preserve">
          <source>Unsigned integers : maximum value</source>
          <target state="translated">Enteros sin signo:valor máximo</target>
        </trans-unit>
        <trans-unit id="c72090771977fd06391926398abf4a074c68cada" translate="yes" xml:space="preserve">
          <source>Until &lt;code&gt;bsearch_s&lt;/code&gt;, users of &lt;code&gt;bsearch&lt;/code&gt; often used global variables to pass additional context to the comparison function.</source>
          <target state="translated">Hasta &lt;code&gt;bsearch_s&lt;/code&gt; , los usuarios de &lt;code&gt;bsearch&lt;/code&gt; a menudo usaban variables globales para pasar contexto adicional a la funci&amp;oacute;n de comparaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6714c3477fc3d9e9c5f8289c7130549e931d78ed" translate="yes" xml:space="preserve">
          <source>Until &lt;code&gt;qsort_s&lt;/code&gt;, users of &lt;code&gt;qsort&lt;/code&gt; often used global variables to pass additional context to the comparison function.</source>
          <target state="translated">Hasta &lt;code&gt;qsort_s&lt;/code&gt; , los usuarios de &lt;code&gt;qsort&lt;/code&gt; a menudo usaban variables globales para pasar contexto adicional a la funci&amp;oacute;n de comparaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="4775c7ec33060fa8ab3b09a08a0e950ff95cd91b" translate="yes" xml:space="preserve">
          <source>Until C99, selection and iteration statements did not establish their own block scopes (although if a compound statement was used in the statement, it had its usual block scope):</source>
          <target state="translated">Hasta el C99,las declaraciones de selección e iteración no establecían sus propios alcances de bloque (aunque si se utilizaba una declaración compuesta en la declaración,tenía su alcance de bloque habitual):</target>
        </trans-unit>
        <trans-unit id="9655f2afef6652d4bb5e5cdc7b77f082cd7603dd" translate="yes" xml:space="preserve">
          <source>Until C99, the rounding direction of the quotient and the sign of the remainder in the built-in division and remainder operators was implementation-defined if either of the operands was negative, but it was well-defined in &lt;code&gt;div&lt;/code&gt; and &lt;code&gt;ldiv&lt;/code&gt;.</source>
          <target state="translated">Hasta C99, la direcci&amp;oacute;n de redondeo del cociente y el signo del resto en la divisi&amp;oacute;n incorporada y los operadores restantes se definieron en la implementaci&amp;oacute;n si alguno de los operandos era negativo, pero estaba bien definido en &lt;code&gt;div&lt;/code&gt; y &lt;code&gt;ldiv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8694ee78b82e3c86eff19bc94b95dd11e5aef085" translate="yes" xml:space="preserve">
          <source>Until standardized as &lt;code&gt;CLOCKS_PER_SEC&lt;/code&gt; in C89, this macro was sometimes known by its IEEE std 1003.1-1988 name &lt;code&gt;CLK_TCK&lt;/code&gt;: that name was not included in C89 and was removed from POSIX itself in 1996 over ambiguity with &lt;code&gt;_SC_CLK_TCK&lt;/code&gt;, which gives number of clocks per second for the function &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/times.html&quot;&gt;times()&lt;/a&gt;).</source>
          <target state="translated">Hasta que se estandariz&amp;oacute; como &lt;code&gt;CLOCKS_PER_SEC&lt;/code&gt; en C89, esta macro a veces se conoc&amp;iacute;a por su nombre IEEE std 1003.1-1988 &lt;code&gt;CLK_TCK&lt;/code&gt; : ese nombre no estaba incluido en C89 y se elimin&amp;oacute; de POSIX en 1996 por ambig&amp;uuml;edad con &lt;code&gt;_SC_CLK_TCK&lt;/code&gt; , lo que da una cantidad de relojes por segundo para los &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/times.html&quot;&gt;tiempos de&lt;/a&gt; funci&amp;oacute;n () ).</target>
        </trans-unit>
        <trans-unit id="8226abfb543f59ee6038e13aaa63641c200612b9" translate="yes" xml:space="preserve">
          <source>Until standardized as &lt;code&gt;CLOCKS_PER_SEC&lt;/code&gt; in C89, this macro was sometimes known by its IEEE std 1003.1-1988 name &lt;code&gt;CLK_TCK&lt;/code&gt;: that name was not included in C89 and was removed from POSIX itself in 1996 over ambiguity with &lt;code&gt;_SC_CLK_TCK&lt;/code&gt;, which gives number of clocks per second for the function &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/times.html&quot;&gt;times()&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b89113dfc8c9140feeca3a6303fca59eb658148" translate="yes" xml:space="preserve">
          <source>Upon return to the scope of setjmp, all accessible objects, floating-point status flags, and other components of the abstract machine have the same values as they had when longjmp was executed, except for the non-&lt;a href=&quot;../language/volatile&quot;&gt;volatile&lt;/a&gt; local variables in setjmp's scope, whose values are indeterminate if they have been changed since the setjmp invocation.</source>
          <target state="translated">Al regresar al alcance de setjmp, todos los objetos accesibles, los indicadores de estado de coma flotante y otros componentes de la m&amp;aacute;quina abstracta tienen los mismos valores que ten&amp;iacute;an cuando se ejecut&amp;oacute; longjmp, excepto las variables locales no &lt;a href=&quot;../language/volatile&quot;&gt;vol&amp;aacute;tiles&lt;/a&gt; en el alcance de setjmp, cuyo los valores son indeterminados si se han cambiado desde la invocaci&amp;oacute;n setjmp.</target>
        </trans-unit>
        <trans-unit id="30e91e701960bb8a2f2ddc9e70cec3e0f356f152" translate="yes" xml:space="preserve">
          <source>Uppercase version of &lt;code&gt;ch&lt;/code&gt; or unmodified &lt;code&gt;ch&lt;/code&gt; if no uppercase version is listed in the current C locale.</source>
          <target state="translated">Versi&amp;oacute;n en may&amp;uacute;scula de &lt;code&gt;ch&lt;/code&gt; o &lt;code&gt;ch&lt;/code&gt; no modificada si no aparece una versi&amp;oacute;n en may&amp;uacute;scula en la configuraci&amp;oacute;n regional actual de C.</target>
        </trans-unit>
        <trans-unit id="59fdbe5f2786a81f9155555038f8f7073977bb9a" translate="yes" xml:space="preserve">
          <source>Uppercase version of &lt;code&gt;wc&lt;/code&gt; or unmodified &lt;code&gt;wc&lt;/code&gt; if no uppercase version is listed in the current C locale.</source>
          <target state="translated">Versi&amp;oacute;n en may&amp;uacute;sculas de &lt;code&gt;wc&lt;/code&gt; o &lt;code&gt;wc&lt;/code&gt; no modificada si no se incluye una versi&amp;oacute;n en may&amp;uacute;sculas en la configuraci&amp;oacute;n regional actual de C.</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="c7a274cde92cd914ce94247b07c6f39a38fa46a4" translate="yes" xml:space="preserve">
          <source>Usage patterns</source>
          <target state="translated">Patrones de uso</target>
        </trans-unit>
        <trans-unit id="7806efb19f32242dcbb9bc5ad35692f5e2036028" translate="yes" xml:space="preserve">
          <source>Used as a shorter equivalent of &lt;a href=&quot;while&quot;&gt;while loop&lt;/a&gt;.</source>
          <target state="translated">Se usa como un equivalente m&amp;aacute;s corto del &lt;a href=&quot;while&quot;&gt;ciclo while&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5a1c568d8c824c8779a7fbd4ddf0353bf241da96" translate="yes" xml:space="preserve">
          <source>Used fields</source>
          <target state="translated">Campos usados</target>
        </trans-unit>
        <trans-unit id="0411cff330fe1f926e098add76bac8d23f3a24cd" translate="yes" xml:space="preserve">
          <source>Used when actual size of the object must be known.</source>
          <target state="translated">Se utiliza cuando debe conocerse el tamaño real del objeto.</target>
        </trans-unit>
        <trans-unit id="cd3a7677f14605e188f81a1607ce0b998a59e8fc" translate="yes" xml:space="preserve">
          <source>Used when it is otherwise awkward to ignore the remaining portion of the loop using conditional statements.</source>
          <target state="translated">Se utiliza cuando resulta incómodo ignorar la parte restante del bucle mediante declaraciones condicionales.</target>
        </trans-unit>
        <trans-unit id="73641814b8ae560f3493eb824a0db1bde1f528d6" translate="yes" xml:space="preserve">
          <source>Used when it is otherwise awkward to terminate the loop using the condition expression and conditional statements.</source>
          <target state="translated">Se utiliza cuando de otro modo resulta incómodo terminar el bucle utilizando la expresión de la condición y las declaraciones condicionales.</target>
        </trans-unit>
        <trans-unit id="eb04de0c41b2213edcba796ec880d9c69993d1a3" translate="yes" xml:space="preserve">
          <source>Used when it is otherwise impossible to transfer control to the desired location using conventional constructs.</source>
          <target state="translated">Se utiliza cuando de otra manera es imposible transferir el control al lugar deseado utilizando construcciones convencionales.</target>
        </trans-unit>
        <trans-unit id="90fd08578221610e26a4e01b9e26db5ba6dd2586" translate="yes" xml:space="preserve">
          <source>Used where code needs to be executed only if some condition is true.</source>
          <target state="translated">Se utiliza cuando el código debe ser ejecutado sólo si alguna condición es verdadera.</target>
        </trans-unit>
        <trans-unit id="1036c46b05784fbc159479e3e12914f6c0a3dc61" translate="yes" xml:space="preserve">
          <source>Used where one or several out of many branches of code need to be executed according to an integral value.</source>
          <target state="translated">Se utiliza cuando una o varias de las muchas ramas del código deben ser ejecutadas de acuerdo a un valor integral.</target>
        </trans-unit>
        <trans-unit id="817c84df09ec7c700161033133b1b1abc3ba7ae7" translate="yes" xml:space="preserve">
          <source>Uses of volatile</source>
          <target state="translated">Los usos de los volátiles</target>
        </trans-unit>
        <trans-unit id="4466cb0f0bd2e7e6b18e73876fb3869a2080fc6d" translate="yes" xml:space="preserve">
          <source>Usual arithmetic conversions</source>
          <target state="translated">Conversiones aritméticas habituales</target>
        </trans-unit>
        <trans-unit id="268e0f35a1a78a980e701fb4508175cad117353e" translate="yes" xml:space="preserve">
          <source>VLA must have automatic storage duration. Pointers to VLA, but not VLA themselves may also have static storage duration. No VM type may have linkage.</source>
          <target state="translated">El VLA debe tener una duración de almacenamiento automático.Los punteros al VLA,pero no el VLA en sí mismo,también pueden tener una duración de almacenamiento estático.Ningún tipo de VM puede tener vinculación.</target>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="de0430a56abae1a9c8cca4fd7a8b8906769e0636" translate="yes" xml:space="preserve">
          <source>Value categories</source>
          <target state="translated">Categorías de valor</target>
        </trans-unit>
        <trans-unit id="44ee88d7a37283ed3f2e5c6bb77a69fd4b4ff443" translate="yes" xml:space="preserve">
          <source>Value of &lt;code&gt;str&lt;/code&gt;</source>
          <target state="translated">Valor de &lt;code&gt;str&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1c7cea36bd22384e74ce5693b3a96747824e4406" translate="yes" xml:space="preserve">
          <source>Value range</source>
          <target state="translated">Rango de valores</target>
        </trans-unit>
        <trans-unit id="af99e0d3d72b238f81c500119ae328f4acda13dc" translate="yes" xml:space="preserve">
          <source>Value transformations</source>
          <target state="translated">Transformaciones de valor</target>
        </trans-unit>
        <trans-unit id="6366acbba5e8e95bc0cae7ccba336b43ea8e9f5e" translate="yes" xml:space="preserve">
          <source>Variable arguments</source>
          <target state="translated">Argumentos variables</target>
        </trans-unit>
        <trans-unit id="1f5bf7a8e6972b2c8450b8b839e8d800d7313ad1" translate="yes" xml:space="preserve">
          <source>Variable-length arrays</source>
          <target state="translated">Matrices de longitud variable</target>
        </trans-unit>
        <trans-unit id="1967c897d235fbf77628efaec62c3448c89e2dfc" translate="yes" xml:space="preserve">
          <source>Variable-length arrays and the types derived from them (pointers to them, etc) are commonly known as &quot;variably-modified types&quot; (VM). Objects of any variably-modified type may only be declared at block scope or function prototype scope.</source>
          <target state="translated">Los conjuntos de longitud variable y los tipos derivados de ellos (punteros a ellos,etc.)se conocen comúnmente como &quot;tipos modificados de forma variable&quot; (VM).Los objetos de cualquier tipo variablemente modificado sólo pueden declararse en el ámbito del bloque o del prototipo de función.</target>
        </trans-unit>
        <trans-unit id="80cfadcd9fc8de8f2c49c35c4acd3c1d59f3d7ba" translate="yes" xml:space="preserve">
          <source>Variably-modified types cannot be members of structs or unions.</source>
          <target state="translated">Los tipos modificados de forma variable no pueden ser miembros de estructuras o uniones.</target>
        </trans-unit>
        <trans-unit id="a8548e5a783f6964c2b71215ac2f1cf031c3e8a0" translate="yes" xml:space="preserve">
          <source>Variadic arguments</source>
          <target state="translated">Argumentos variados</target>
        </trans-unit>
        <trans-unit id="8e36a4956d4555b32607f272180c87deea209898" translate="yes" xml:space="preserve">
          <source>Variadic functions</source>
          <target state="translated">Funciones variadas</target>
        </trans-unit>
        <trans-unit id="e3e170f0844bb573f925b5d4be5d7e11b8f4fb62" translate="yes" xml:space="preserve">
          <source>Variadic functions are functions (e.g. &lt;code&gt;&lt;a href=&quot;io/fprintf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;) which take a variable number of arguments.</source>
          <target state="translated">Las funciones variables son funciones (por ejemplo, &lt;code&gt;&lt;a href=&quot;io/fprintf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; ) que toman un n&amp;uacute;mero variable de argumentos.</target>
        </trans-unit>
        <trans-unit id="b4932fa91d3f1b70f0c1d88911a981d4f9befca2" translate="yes" xml:space="preserve">
          <source>Variadic functions are functions that may be called with different number of arguments.</source>
          <target state="translated">Las funciones variadas son funciones que pueden ser llamadas con diferente número de argumentos.</target>
        </trans-unit>
        <trans-unit id="5519001c19e39db626b1e56d5b3636ed5b38cb6f" translate="yes" xml:space="preserve">
          <source>Version (2) of the &lt;code&gt;#define&lt;/code&gt; directive defines a simple function-like macro.</source>
          <target state="translated">La versi&amp;oacute;n (2) de la directiva &lt;code&gt;#define&lt;/code&gt; define una macro simple similar a una funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6478ed6591675d0474d581d305bfaf13be93f411" translate="yes" xml:space="preserve">
          <source>Version (3) of the &lt;code&gt;#define&lt;/code&gt; directive defines a function-like macro with variable number of arguments. The additional arguments can be accessed using &lt;code&gt;__VA_ARGS__&lt;/code&gt; identifier, which is then replaced with arguments, supplied with the identifier to be replaced.</source>
          <target state="translated">La versi&amp;oacute;n (3) de la directiva &lt;code&gt;#define&lt;/code&gt; define una macro similar a una funci&amp;oacute;n con un n&amp;uacute;mero variable de argumentos. Se puede acceder a los argumentos adicionales utilizando el identificador &lt;code&gt;__VA_ARGS__&lt;/code&gt; , que luego se reemplaza por argumentos, suministrados con el identificador a reemplazar.</target>
        </trans-unit>
        <trans-unit id="60259716427bec2d4678682eccad9fa820f8bb67" translate="yes" xml:space="preserve">
          <source>Version (4) of the &lt;code&gt;#define&lt;/code&gt; directive defines a function-like macro with variable number of arguments, but no regular arguments. The arguments can be accessed only with &lt;code&gt;__VA_ARGS__&lt;/code&gt; identifier, which is then replaced with arguments, supplied with identifier to be replaced.</source>
          <target state="translated">La versi&amp;oacute;n (4) de la directiva &lt;code&gt;#define&lt;/code&gt; define una macro similar a una funci&amp;oacute;n con un n&amp;uacute;mero variable de argumentos, pero sin argumentos regulares. Solo se puede acceder a los argumentos con el identificador &lt;code&gt;__VA_ARGS__&lt;/code&gt; , que luego se reemplaza con argumentos, suministrados con el identificador que se reemplazar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="c0bc38123ad63ab545d3b75627acdac77e9b79a6" translate="yes" xml:space="preserve">
          <source>WCHAR_MAX</source>
          <target state="translated">WCHAR_MAX</target>
        </trans-unit>
        <trans-unit id="04ea5fdfa0eae316269a47c7f10e8316337146a4" translate="yes" xml:space="preserve">
          <source>WCHAR_MIN</source>
          <target state="translated">WCHAR_MIN</target>
        </trans-unit>
        <trans-unit id="c37a74a6f2d73286ec534a439a5c059b13230ec6" translate="yes" xml:space="preserve">
          <source>WEOF</source>
          <target state="translated">WEOF</target>
        </trans-unit>
        <trans-unit id="8d070188c9052ddde44bc280e3aced3c983ed8c7" translate="yes" xml:space="preserve">
          <source>WINT_MAX</source>
          <target state="translated">WINT_MAX</target>
        </trans-unit>
        <trans-unit id="cb08e31a881a0bd7697665afb678cdce175c2f59" translate="yes" xml:space="preserve">
          <source>WINT_MIN</source>
          <target state="translated">WINT_MIN</target>
        </trans-unit>
        <trans-unit id="f82be68a7fb4e7dec88f27463de94ad355242ee5" translate="yes" xml:space="preserve">
          <source>Week</source>
          <target state="translated">Week</target>
        </trans-unit>
        <trans-unit id="17a74d187c8a04abdcb5c0a680b6e9d660e85fba" translate="yes" xml:space="preserve">
          <source>What Every C Programmer Should Know About Undefined Behavior #1/3</source>
          <target state="translated">Lo que todo programador de C debería saber sobre el comportamiento indefinido #1/3</target>
        </trans-unit>
        <trans-unit id="8b7904dfab491b34141248cdfa81f76b99500ce8" translate="yes" xml:space="preserve">
          <source>What Every C Programmer Should Know About Undefined Behavior #2/3</source>
          <target state="translated">Lo que todo programador de C debería saber sobre el comportamiento indefinido #2/3</target>
        </trans-unit>
        <trans-unit id="faec1f8b604ae7cb007c3f28c6244f78ba75f633" translate="yes" xml:space="preserve">
          <source>What Every C Programmer Should Know About Undefined Behavior #3/3</source>
          <target state="translated">Lo que todo programador de C debería saber sobre el comportamiento indefinido #3/3</target>
        </trans-unit>
        <trans-unit id="459f3e0733d6888e3e209b8bb7e51c8223f8fd00" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;initialization&quot;&gt;initializing&lt;/a&gt; an object of &lt;a href=&quot;array&quot;&gt;array&lt;/a&gt; type, the initializer must be either a &lt;a href=&quot;string_literal&quot;&gt;string literal&lt;/a&gt; (optionally enclosed in braces) or be a brace-enclosed list of initialized for array members:</source>
          <target state="translated">Al &lt;a href=&quot;initialization&quot;&gt;inicializar&lt;/a&gt; un objeto de tipo &lt;a href=&quot;array&quot;&gt;matriz&lt;/a&gt; , el inicializador debe ser un &lt;a href=&quot;string_literal&quot;&gt;literal de cadena&lt;/a&gt; (opcionalmente encerrado entre llaves) o ser una lista de llaves inicializadas para los miembros de la matriz:</target>
        </trans-unit>
        <trans-unit id="fa50f94c71d27a1f5893686568c6c5949625b9d7" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;initialization&quot;&gt;initializing&lt;/a&gt; an object of &lt;a href=&quot;compatible_type#Type_groups&quot;&gt;scalar type&lt;/a&gt;, the initializer must be a single expression.</source>
          <target state="translated">Al &lt;a href=&quot;initialization&quot;&gt;inicializar&lt;/a&gt; un objeto de &lt;a href=&quot;compatible_type#Type_groups&quot;&gt;tipo escalar&lt;/a&gt; , el inicializador debe ser una sola expresi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a6cf5af2f39d3cc2baf225fdca0f325b4a6eeec7" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;initialization&quot;&gt;initializing&lt;/a&gt; an object of &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; type, the initializer must be a non-empty, brace-enclosed, comma-separated list of initializers for the members:</source>
          <target state="translated">Al &lt;a href=&quot;initialization&quot;&gt;inicializar&lt;/a&gt; un objeto de tipo &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; o &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; , el inicializador debe ser una lista de inicializadores no vac&amp;iacute;a, encerrada entre corchetes y separada por comas para los miembros:</target>
        </trans-unit>
        <trans-unit id="cc0170dca8716eb24882edf591a81dee83e562ee" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;#&lt;/code&gt; appears before &lt;code&gt;__VA_ARGS__&lt;/code&gt;, the entire expanded __VA_ARGS__ is enclosed in quotes:</source>
          <target state="translated">Cuando aparece &lt;code&gt;#&lt;/code&gt; antes de &lt;code&gt;__VA_ARGS__&lt;/code&gt; , todo el __VA_ARGS__ expandido se encierra entre comillas:</target>
        </trans-unit>
        <trans-unit id="af346b85b4a3c47e96376bfa441357b9915299c0" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; macro is used the types of the arguments passed to the generic parameters determine which function is selected by the macro as described below. If the types of the arguments are not &lt;a href=&quot;../language/compatible_type#Compatible_types&quot;&gt;compatible&lt;/a&gt; with the parameter types of the selected function, the behavior is undefined (e.g. if a complex argument is passed into a real-only tgmath macro: &lt;code&gt;float &lt;a href=&quot;complex/complex&quot;&gt;complex&lt;/a&gt; fc; &lt;a href=&quot;math/ceil&quot;&gt;ceil&lt;/a&gt;(fc)&lt;/code&gt; or &lt;code&gt;double &lt;a href=&quot;complex/complex&quot;&gt;complex&lt;/a&gt; dc; double d; &lt;a href=&quot;math/fmax&quot;&gt;fmax&lt;/a&gt;(dc, d)&lt;/code&gt; are examples of undefined behavior).</source>
          <target state="translated">Cuando se usa una macro &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; , los tipos de argumentos pasados ​​a los par&amp;aacute;metros gen&amp;eacute;ricos determinan qu&amp;eacute; funci&amp;oacute;n selecciona la macro como se describe a continuaci&amp;oacute;n. Si los tipos de los argumentos no son &lt;a href=&quot;../language/compatible_type#Compatible_types&quot;&gt;compatibles&lt;/a&gt; con los tipos de par&amp;aacute;metros de la funci&amp;oacute;n seleccionada, el comportamiento es indefinido (por ejemplo, si un argumento complejo se pasa a una macro tgmath solo real: &lt;code&gt;float &lt;a href=&quot;complex/complex&quot;&gt;complex&lt;/a&gt; fc; &lt;a href=&quot;math/ceil&quot;&gt;ceil&lt;/a&gt;(fc)&lt;/code&gt; flotante fc; &lt;a href=&quot;math/ceil&quot;&gt;ceil&lt;/a&gt; (fc) o &lt;code&gt;double &lt;a href=&quot;complex/complex&quot;&gt;complex&lt;/a&gt; dc; double d; &lt;a href=&quot;math/fmax&quot;&gt;fmax&lt;/a&gt;(dc, d)&lt;/code&gt; son ejemplos de comportamiento indefinido).</target>
        </trans-unit>
        <trans-unit id="4811bf90215855de12be0a426e5fdd66ceff8757" translate="yes" xml:space="preserve">
          <source>When a thread reads a value from a memory location, it may see the initial value, the value written in the same thread, or the value written in another thread. See &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;memory_order&lt;/a&gt;&lt;/code&gt; for details on the order in which writes made from threads become visible to other threads.</source>
          <target state="translated">Cuando un hilo lee un valor de una ubicaci&amp;oacute;n de memoria, puede ver el valor inicial, el valor escrito en el mismo hilo o el valor escrito en otro hilo. Consulte &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;memory_order&lt;/a&gt;&lt;/code&gt; para obtener detalles sobre el orden en que las escrituras hechas desde hilos se vuelven visibles para otros hilos.</target>
        </trans-unit>
        <trans-unit id="dbe54944a43bccf5cf205c899d78217a14037efa" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;eval_order&quot;&gt;evaluation&lt;/a&gt; of an expression writes to a memory location and another evaluation reads or modifies the same memory location, the expressions are said to</source>
          <target state="translated">Cuando una &lt;a href=&quot;eval_order&quot;&gt;evaluaci&amp;oacute;n&lt;/a&gt; de una expresi&amp;oacute;n escribe en una ubicaci&amp;oacute;n de memoria y otra evaluaci&amp;oacute;n lee o modifica la misma ubicaci&amp;oacute;n de memoria, se dice que las expresiones</target>
        </trans-unit>
        <trans-unit id="4d2d9b5843b2b14f889c96a5ed077d795aec2e22" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;identifier&quot;&gt;identifier&lt;/a&gt; is encountered in a C program, a lookup is performed to locate the &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; that introduced that identifier and that is currently &lt;a href=&quot;scope&quot;&gt;in scope&lt;/a&gt;. C allows more than one declaration for the same identifier to be in scope simultaneously if these identifiers belong to different categories, called</source>
          <target state="translated">Cuando se encuentra un &lt;a href=&quot;identifier&quot;&gt;identificador&lt;/a&gt; en un programa en C, se realiza una b&amp;uacute;squeda para localizar la &lt;a href=&quot;declarations&quot;&gt;declaraci&amp;oacute;n&lt;/a&gt; que introdujo ese identificador y que est&amp;aacute; actualmente&lt;a href=&quot;scope&quot;&gt; dentro del alcance&lt;/a&gt; . C permite que m&amp;aacute;s de una declaraci&amp;oacute;n para el mismo identificador est&amp;eacute; en alcance simult&amp;aacute;neamente si estos identificadores pertenecen a diferentes categor&amp;iacute;as, llamadas</target>
        </trans-unit>
        <trans-unit id="e89dee51109e2fa03d1d15f4098f1b184fdd3f34" translate="yes" xml:space="preserve">
          <source>When an array is initialized with a brace-enclosed list of initializers, the first initializer in the list initializes the array element at index zero (unless a designator is specified)(since C99), and each subsequent initializer without a designator (since C99)initializes the array element at index one greater than the one initialized by the previous initializer.</source>
          <target state="translated">Cuando un conjunto se inicializa con una lista de inicializadores encerrada entre corchetes,el primer inicializador de la lista inicializa el elemento del conjunto con un índice cero (a menos que se especifique una designación)(desde C99),y cada inicializador subsiguiente sin designación (desde C99)inicializa el elemento del conjunto con un índice uno mayor que el inicializado por el inicializador anterior.</target>
        </trans-unit>
        <trans-unit id="a3ca42c383f5f0e2bd3033657dc8530a9eba5d3b" translate="yes" xml:space="preserve">
          <source>When an array type is used in a function parameter list, it is transformed to the corresponding pointer type: &lt;code&gt;int f(int a[2])&lt;/code&gt; and &lt;code&gt;int f(int* a)&lt;/code&gt; declare the same function. Since the function's actual parameter type is pointer type, a function call with an array argument performs array-to-pointer conversion; the size of the argument array is not available to the called function and must be passed explicitly:</source>
          <target state="translated">Cuando se usa un tipo de matriz en una lista de par&amp;aacute;metros de funci&amp;oacute;n, se transforma en el tipo de puntero correspondiente: &lt;code&gt;int f(int a[2])&lt;/code&gt; e &lt;code&gt;int f(int* a)&lt;/code&gt; declaran la misma funci&amp;oacute;n. Como el tipo de par&amp;aacute;metro real de la funci&amp;oacute;n es de tipo puntero, una llamada de funci&amp;oacute;n con un argumento de matriz realiza la conversi&amp;oacute;n de matriz a puntero; el tama&amp;ntilde;o de la matriz de argumentos no est&amp;aacute; disponible para la funci&amp;oacute;n llamada y debe pasarse expl&amp;iacute;citamente:</target>
        </trans-unit>
        <trans-unit id="a8cc939c2091fa611fac1f51ee6f986940b00b89" translate="yes" xml:space="preserve">
          <source>When an expression is used in the context where a value of a different type is expected,</source>
          <target state="translated">Cuando una expresión se utiliza en un contexto en el que se espera un valor de tipo diferente,</target>
        </trans-unit>
        <trans-unit id="5c83a5d985c2238792f08da0fa782f6fc397cae6" translate="yes" xml:space="preserve">
          <source>When applied to an operand that has &lt;a href=&quot;struct&quot;&gt;structure&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; type, the result is the total number of bytes in such an object, including internal and trailing padding. The trailing padding is such that if the object were an element of an array, the alignment requirement of the next element of this array would be satisfied, in other words, sizeof(T) returns the size of an element of a T[] array.</source>
          <target state="translated">Cuando se aplica a un operando que tiene &lt;a href=&quot;struct&quot;&gt;estructura&lt;/a&gt; o &lt;a href=&quot;union&quot;&gt;uni&amp;oacute;n&lt;/a&gt; , el resultado es el n&amp;uacute;mero total de bytes en dicho objeto, incluidos los rellenos internos y finales. El relleno final es tal que si el objeto fuera un elemento de una matriz, se cumplir&amp;iacute;a el requisito de alineaci&amp;oacute;n del siguiente elemento de esta matriz, en otras palabras, sizeof (T) devuelve el tama&amp;ntilde;o de un elemento de una matriz T [] .</target>
        </trans-unit>
        <trans-unit id="cc704db980837263518025b9214e71556fed57f0" translate="yes" xml:space="preserve">
          <source>When casting between pointers (either object or function), if the original value is a null pointer value of its type, the result is the correct null pointer value for the target type.</source>
          <target state="translated">Al lanzar entre punteros (ya sea un objeto o una función),si el valor original es un valor de puntero nulo de su tipo,el resultado es el valor de puntero nulo correcto para el tipo de objetivo.</target>
        </trans-unit>
        <trans-unit id="ec13aa43d382edec81c71f93b1f833341dd32db6" translate="yes" xml:space="preserve">
          <source>When designators are nested, the designators for the members follow the designators for the enclosing structs/unions/arrays. Within any nested bracketed initializer list, the outermost designator refers to the</source>
          <target state="translated">Cuando los designadores están anidados,los designadores de los miembros siguen a los designadores de las estructuras/sindicatos/matrices de cierre.Dentro de cualquier lista de inicializadores anidados entre corchetes,el designador más externo se refiere al</target>
        </trans-unit>
        <trans-unit id="d3ec0511a34972ef6c3100af3407ac58d0149968" translate="yes" xml:space="preserve">
          <source>When initializing a &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt;, the first initializer in the list initializes the first declared member (unless a designator is specified)(since C99), and all subsequent initializers without designators (since C99)initialize the struct members declared after the one initialized by the previous expression.</source>
          <target state="translated">Al inicializar una &lt;a href=&quot;struct&quot;&gt;estructura&lt;/a&gt; , el primer inicializador de la lista inicializa el primer miembro declarado (a menos que se especifique un designador) (desde C99), y todos los inicializadores posteriores sin designadores (desde C99) inicializan los miembros de estructura declarados despu&amp;eacute;s del inicializado por el anterior expresi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="22e4620e60947af9c0a473fb0a8baeabfee382e6" translate="yes" xml:space="preserve">
          <source>When initializing a &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt;, the initializer list must have only one member, which initializes the first member of the union unless a designated initializer is used(since C99).</source>
          <target state="translated">Al inicializar una &lt;a href=&quot;union&quot;&gt;uni&amp;oacute;n&lt;/a&gt; , la lista de inicializadores debe tener solo un miembro, que inicializa el primer miembro de la uni&amp;oacute;n a menos que se use un inicializador designado (desde C99).</target>
        </trans-unit>
        <trans-unit id="2b3a780fd7c8398e52211c025dc25e8366b96122" translate="yes" xml:space="preserve">
          <source>When initializing an array of unknown size, the largest subscript for which an initializer is specified determines the size of the array being declared.</source>
          <target state="translated">Cuando se inicializa una matriz de tamaño desconocido,el mayor subíndice para el que se especifica un inicializador determina el tamaño de la matriz que se declara.</target>
        </trans-unit>
        <trans-unit id="6349ec69327a41a7f34afff23548abbfde4de09e" translate="yes" xml:space="preserve">
          <source>When initializing an atomic variable, any concurrent access, even through an atomic operation, is a data race (it may happen if the address is immediately passed to another thread with a &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_relaxed&lt;/a&gt;&lt;/code&gt; operation).</source>
          <target state="translated">Al inicializar una variable at&amp;oacute;mica, cualquier acceso concurrente, incluso a trav&amp;eacute;s de una operaci&amp;oacute;n at&amp;oacute;mica, es una carrera de datos (puede ocurrir si la direcci&amp;oacute;n se pasa inmediatamente a otro hilo con una operaci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_relaxed&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4db3e8dc56995aba80c1b48bd4c3d6ff9b4e8eb7" translate="yes" xml:space="preserve">
          <source>When initializing an object of static or thread-local &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt;, every expression in the initializer must be a &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt; or &lt;a href=&quot;string_literal&quot;&gt;string literal&lt;/a&gt;.</source>
          <target state="translated">Al inicializar un objeto de &lt;a href=&quot;storage_duration&quot;&gt;duraci&amp;oacute;n de almacenamiento&lt;/a&gt; local est&amp;aacute;tico o de subprocesos , cada expresi&amp;oacute;n en el inicializador debe ser una &lt;a href=&quot;constant_expression&quot;&gt;expresi&amp;oacute;n constante&lt;/a&gt; o &lt;a href=&quot;string_literal&quot;&gt;literal de cadena&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3fade3dd9c6dd385455b642a26cd93ce6d453eb8" translate="yes" xml:space="preserve">
          <source>When initializing objects of floating-point type, all computations for the objects with automatic &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; are done as-if at execution time and are affected by the &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;current rounding&lt;/a&gt;; floating-point errors are reported as specified in &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;. For objects of static and thread-local storage duration, computations are done as-if at compile time, and no exceptions are raised:</source>
          <target state="translated">Al inicializar objetos de tipo de punto flotante, todos los c&amp;aacute;lculos para los objetos con &lt;a href=&quot;storage_duration&quot;&gt;duraci&amp;oacute;n de almacenamiento&lt;/a&gt; autom&amp;aacute;tico se realizan como si en el momento de la ejecuci&amp;oacute;n y se ven afectados por el &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;redondeo actual&lt;/a&gt; ; los errores de punto flotante se informan como se especifica en &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt; . Para los objetos de duraci&amp;oacute;n de almacenamiento est&amp;aacute;tico y local de subprocesos, los c&amp;aacute;lculos se realizan como si estuvieran en tiempo de compilaci&amp;oacute;n, y no se generan excepciones:</target>
        </trans-unit>
        <trans-unit id="2fa8650712efe659cc0dd0339ead9630668b0570" translate="yes" xml:space="preserve">
          <source>When multiple alignas specifiers appear in the same declaration, the strictest one is used.</source>
          <target state="translated">Cuando aparecen varios especificadores de alineaciones en la misma declaración,se utiliza el más estricto.</target>
        </trans-unit>
        <trans-unit id="8c1fe3bbe944df7601e6e76ed048cf63122a0a2d" translate="yes" xml:space="preserve">
          <source>When objects of &lt;a href=&quot;arithmetic_types#Integer_types&quot;&gt;integer types&lt;/a&gt; (short, int, long, long long) occupy multiple bytes, the use of those bytes is implementation-defined, but the two dominant implementations are</source>
          <target state="translated">Cuando los objetos de &lt;a href=&quot;arithmetic_types#Integer_types&quot;&gt;tipos enteros&lt;/a&gt; (short, int, long, long long) ocupan varios bytes, el uso de esos bytes est&amp;aacute; definido por la implementaci&amp;oacute;n, pero las dos implementaciones dominantes son</target>
        </trans-unit>
        <trans-unit id="c0fcdf6257c6f5b63f77499931a12401e55fd130" translate="yes" xml:space="preserve">
          <source>When parsing an expression, an operator which is listed on some row will be bound tighter (as if by parentheses) to its arguments than any operator that is listed on a row further below it. For example, the expression &lt;code&gt;*p++&lt;/code&gt; is parsed as &lt;code&gt;*(p++)&lt;/code&gt;, and not as &lt;code&gt;(*p)++&lt;/code&gt;.</source>
          <target state="translated">Al analizar una expresi&amp;oacute;n, un operador que aparece en una fila estar&amp;aacute; m&amp;aacute;s ajustado (como por par&amp;eacute;ntesis) a sus argumentos que cualquier operador que est&amp;eacute; en una fila m&amp;aacute;s abajo. Por ejemplo, la expresi&amp;oacute;n &lt;code&gt;*p++&lt;/code&gt; se analiza como &lt;code&gt;*(p++)&lt;/code&gt; y no como &lt;code&gt;(*p)++&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8b48f697df0e524fccfbe77ccb0c6aefdae765c" translate="yes" xml:space="preserve">
          <source>When parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing &lt;code&gt;&quot;100er&quot;&lt;/code&gt; with the conversion specifier &lt;code&gt;%f&lt;/code&gt;, the sequence &lt;code&gt;&quot;100e&quot;&lt;/code&gt; (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with &lt;code&gt;&quot;r&quot;&lt;/code&gt; remaining. Some existing implementations do not follow this rule and roll back to consume only &lt;code&gt;&quot;100&quot;&lt;/code&gt;, leaving &lt;code&gt;&quot;er&quot;&lt;/code&gt;, e.g. &lt;a href=&quot;https://sourceware.org/bugzilla/show_bug.cgi?id=1765&quot;&gt;glibc bug 1765&lt;/a&gt;.</source>
          <target state="translated">Al analizar un valor de coma flotante incompleto que termina en el exponente sin d&amp;iacute;gitos, como analizar &lt;code&gt;&quot;100er&quot;&lt;/code&gt; con el especificador de conversi&amp;oacute;n &lt;code&gt;%f&lt;/code&gt; , se &lt;code&gt;&quot;100e&quot;&lt;/code&gt; la secuencia &quot;100e&quot; (el prefijo m&amp;aacute;s largo de un n&amp;uacute;mero de coma flotante posiblemente v&amp;aacute;lido) , lo que produce un error de coincidencia (la secuencia consumida no se puede convertir a un n&amp;uacute;mero de coma flotante), con &lt;code&gt;&quot;r&quot;&lt;/code&gt; restante. Algunas implementaciones existentes no siguen esta regla y retroceden para consumir solo &lt;code&gt;&quot;100&quot;&lt;/code&gt; , dejando &lt;code&gt;&quot;er&quot;&lt;/code&gt; , por ejemplo, &lt;a href=&quot;https://sourceware.org/bugzilla/show_bug.cgi?id=1765&quot;&gt;error glibc 1765&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7bd54443661e6fdf7c87f18bb32eddd2dd26a027" translate="yes" xml:space="preserve">
          <source>When passed to &lt;code&gt;&lt;a href=&quot;mtx_init&quot;&gt;mtx_init&lt;/a&gt;&lt;/code&gt;, identifies the type of a mutex to create.</source>
          <target state="translated">Cuando se pasa a &lt;code&gt;&lt;a href=&quot;mtx_init&quot;&gt;mtx_init&lt;/a&gt;&lt;/code&gt; , identifica el tipo de mutex para crear.</target>
        </trans-unit>
        <trans-unit id="e72802fb982f6c1ad80ec2312e0bb0f8ad1c000e" translate="yes" xml:space="preserve">
          <source>When signal handler is set to a function and a signal occurs, it is implementation defined whether &lt;code&gt;signal(sig, &lt;a href=&quot;sig_strategies&quot;&gt;SIG_DFL&lt;/a&gt;)&lt;/code&gt; will be executed immediately before the start of signal handler. Also, the implementation can prevent some implementation-defined set of signals from occurring while the signal handler runs.</source>
          <target state="translated">Cuando el controlador de se&amp;ntilde;al se establece en una funci&amp;oacute;n y se produce una se&amp;ntilde;al, su implementaci&amp;oacute;n define si la &lt;code&gt;signal(sig, &lt;a href=&quot;sig_strategies&quot;&gt;SIG_DFL&lt;/a&gt;)&lt;/code&gt; se ejecutar&amp;aacute; inmediatamente antes del inicio del controlador de se&amp;ntilde;al. Adem&amp;aacute;s, la implementaci&amp;oacute;n puede evitar que ocurra un conjunto de se&amp;ntilde;ales definidas por la implementaci&amp;oacute;n mientras se ejecuta el manejador de se&amp;ntilde;ales.</target>
        </trans-unit>
        <trans-unit id="a82c7324d6d1f526ac5299ac166aafff69e4a350" translate="yes" xml:space="preserve">
          <source>When signed integer arithmetic operation overflows (the result does not fit in the result type), the behavior is undefined: it may wrap around according to the rules of the representation (typically 2's complement), it may trap on some platforms or due to compiler options (e.g. &lt;code&gt;-ftrapv&lt;/code&gt; in GCC and Clang), or may be completely &lt;a href=&quot;http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html&quot;&gt;optimized out by the compiler&lt;/a&gt;.</source>
          <target state="translated">Cuando se desborda la operaci&amp;oacute;n aritm&amp;eacute;tica de enteros con signo (el resultado no cabe en el tipo de resultado), el comportamiento es indefinido: puede ajustarse de acuerdo con las reglas de la representaci&amp;oacute;n (generalmente el complemento de 2), puede quedar atrapado en algunas plataformas o debido al compilador opciones (por ejemplo, &lt;code&gt;-ftrapv&lt;/code&gt; en GCC y Clang), o puede ser completamente &lt;a href=&quot;http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html&quot;&gt;optimizado por el compilador&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5f0cf9abe0b614f53329302ad0d6b53be9c5214c" translate="yes" xml:space="preserve">
          <source>When the element type of an array is another array, it is said that the array is multidimensional:</source>
          <target state="translated">Cuando el tipo de elemento de una matriz es otra matriz,se dice que la matriz es multidimensional:</target>
        </trans-unit>
        <trans-unit id="682985610ed3813bc3f241e4a1e4f302bb45d4c6" translate="yes" xml:space="preserve">
          <source>When used in a controlling expression of &lt;a href=&quot;../preprocessor/conditional&quot;&gt;#if&lt;/a&gt; or &lt;a href=&quot;../preprocessor/conditional&quot;&gt;#elif&lt;/a&gt;, all signed integer constants act as if they have type &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;intmax_t&lt;/a&gt;&lt;/code&gt; and all unsigned integer constants act as if they have type &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;uintmax_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Cuando se usa en una expresi&amp;oacute;n de control de &lt;a href=&quot;../preprocessor/conditional&quot;&gt;#if&lt;/a&gt; o &lt;a href=&quot;../preprocessor/conditional&quot;&gt;#elif&lt;/a&gt; , todas las constantes enteras con signo act&amp;uacute;an como si tuvieran el tipo &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;intmax_t&lt;/a&gt;&lt;/code&gt; y todas las constantes enteras sin signo act&amp;uacute;an como si tuvieran el tipo &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;uintmax_t&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3fab87f570b0cb58044fb50de98b795acaec288" translate="yes" xml:space="preserve">
          <source>When used in a controlling expression of &lt;a href=&quot;../preprocessor/conditional&quot;&gt;#if&lt;/a&gt; or &lt;a href=&quot;../preprocessor/conditional&quot;&gt;#elif&lt;/a&gt;, character constants may be interpreted in terms of the source character set, the execution character set, or some other implementation-defined character set.</source>
          <target state="translated">Cuando se usa en una expresi&amp;oacute;n de control de &lt;a href=&quot;../preprocessor/conditional&quot;&gt;#if&lt;/a&gt; o &lt;a href=&quot;../preprocessor/conditional&quot;&gt;#elif&lt;/a&gt; , las constantes de caracteres se pueden interpretar en t&amp;eacute;rminos del conjunto de caracteres de origen, el conjunto de caracteres de ejecuci&amp;oacute;n o alg&amp;uacute;n otro conjunto de caracteres definido por la implementaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="dcf6e07c969001d8800b90077c7110e069a53418" translate="yes" xml:space="preserve">
          <source>When used in a declaration, the declared object will have its &lt;a href=&quot;object#Alignment&quot;&gt;alignment requirement&lt;/a&gt; set to.</source>
          <target state="translated">Cuando se usa en una declaraci&amp;oacute;n, el objeto declarado tendr&amp;aacute; su &lt;a href=&quot;object#Alignment&quot;&gt;requisito de alineaci&amp;oacute;n&lt;/a&gt; establecido en.</target>
        </trans-unit>
        <trans-unit id="bc35db4c35982640cd7a0636a9c639111c104e41" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;fopen_s&lt;/code&gt; or &lt;code&gt;freopen_s&lt;/code&gt;, file access permissions for any file created with &quot;w&quot; or &quot;a&quot; prevents other users from accessing it. File access mode flag &lt;code&gt;&quot;u&quot;&lt;/code&gt; can optionally be prepended to any specifier that begins with &quot;w&quot; or &quot;a&quot;, to enable the default &lt;code&gt;fopen&lt;/code&gt; permissions. (C11)</source>
          <target state="translated">Al usar &lt;code&gt;fopen_s&lt;/code&gt; o &lt;code&gt;freopen_s&lt;/code&gt; , los permisos de acceso a archivos para cualquier archivo creado con &quot;w&quot; o &quot;a&quot; impiden que otros usuarios accedan a &amp;eacute;l. El indicador de modo de acceso a archivos &lt;code&gt;&quot;u&quot;&lt;/code&gt; se puede anteponer opcionalmente a cualquier especificador que comience con &quot;w&quot; o &quot;a&quot;, para habilitar los permisos &lt;code&gt;fopen&lt;/code&gt; predeterminados . (C11)</target>
        </trans-unit>
        <trans-unit id="9e95324a6a7f1f1327a0ab19897537cb091cc4e8" translate="yes" xml:space="preserve">
          <source>Where &lt;a href=&quot;../../language/object#Strict_aliasing&quot;&gt;strict aliasing&lt;/a&gt; prohibits examining the same memory as values of two different types, &lt;code&gt;memcpy&lt;/code&gt; may be used to convert the values.</source>
          <target state="translated">Cuando el &lt;a href=&quot;../../language/object#Strict_aliasing&quot;&gt;alias estricto&lt;/a&gt; proh&amp;iacute;be examinar la misma memoria que los valores de dos tipos diferentes, se puede usar &lt;code&gt;memcpy&lt;/code&gt; para convertir los valores.</target>
        </trans-unit>
        <trans-unit id="452f408de6a7cd8281856de8e1f092cf8d55601a" translate="yes" xml:space="preserve">
          <source>Where &lt;a href=&quot;../../language/object#Strict_aliasing&quot;&gt;strict aliasing&lt;/a&gt; prohibits examining the same memory as values of two different types, &lt;code&gt;memmove&lt;/code&gt; may be used to convert the values.</source>
          <target state="translated">Cuando el &lt;a href=&quot;../../language/object#Strict_aliasing&quot;&gt;alias estricto&lt;/a&gt; proh&amp;iacute;be examinar la misma memoria que los valores de dos tipos diferentes, se puede usar &lt;code&gt;memmove&lt;/code&gt; para convertir los valores.</target>
        </trans-unit>
        <trans-unit id="21adf3b284d45513b5e5712dbeaf87c035585467" translate="yes" xml:space="preserve">
          <source>Where the significand has the form.</source>
          <target state="translated">Donde el significado tiene la forma.</target>
        </trans-unit>
        <trans-unit id="27f62a551f15ff9c032031f756f94d148b497948" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; is raised by the mathematical library functions is unspecified in general, but may be explicitly specified in the description of the function (e.g. &lt;code&gt;&lt;a href=&quot;rint&quot;&gt;rint&lt;/a&gt;&lt;/code&gt; vs &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;nearbyint&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Ya sea &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; se eleva por las funciones de biblioteca matem&amp;aacute;tica es no especificado en general, pero se puede especificar de forma expl&amp;iacute;cita en la descripci&amp;oacute;n de la funci&amp;oacute;n (por ejemplo &lt;code&gt;&lt;a href=&quot;rint&quot;&gt;rint&lt;/a&gt;&lt;/code&gt; vs &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;nearbyint&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="01eb3e966dcce36b733ea8791c56e49db1a6416a" translate="yes" xml:space="preserve">
          <source>Whether a bit field can straddle an allocation unit boundary</source>
          <target state="translated">Si un campo de bits puede atravesar el límite de una unidad de asignación</target>
        </trans-unit>
        <trans-unit id="ee54caa15a743254b67ada9f78d6f5a91a66fe21" translate="yes" xml:space="preserve">
          <source>Whether atomic types are permitted</source>
          <target state="translated">Si los tipos atómicos están permitidos</target>
        </trans-unit>
        <trans-unit id="edf5c52a70df7191bd2b181d0777b7c9622b6038" translate="yes" xml:space="preserve">
          <source>Whether bit fields of type &lt;code&gt;int&lt;/code&gt; are treated as signed or unsigned</source>
          <target state="translated">Si los campos de bits de tipo &lt;code&gt;int&lt;/code&gt; se tratan como con signo o sin signo</target>
        </trans-unit>
        <trans-unit id="feffb1ebd739adca8c1acd723648ceb50bfb3246" translate="yes" xml:space="preserve">
          <source>Whether or not the operation succeeds, the stream is no longer associated with a file, and the buffer allocated by &lt;code&gt;&lt;a href=&quot;setbuf&quot;&gt;setbuf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;setvbuf&lt;/a&gt;&lt;/code&gt;, if any, is also disassociated and deallocated if automatic allocation was used.</source>
          <target state="translated">Independientemente de si la operaci&amp;oacute;n tiene &amp;eacute;xito o no, la secuencia ya no est&amp;aacute; asociada con un archivo, y el b&amp;uacute;fer asignado por &lt;code&gt;&lt;a href=&quot;setbuf&quot;&gt;setbuf&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;setvbuf&lt;/a&gt;&lt;/code&gt; , si lo hay, tambi&amp;eacute;n se desasocia y desasigna si se utiliza la asignaci&amp;oacute;n autom&amp;aacute;tica.</target>
        </trans-unit>
        <trans-unit id="f4fd7a2e9a399af45240637c0eda092aecfbc9a0" translate="yes" xml:space="preserve">
          <source>Whether types other than int, signed int, unsigned int, and _Bool are permitted</source>
          <target state="translated">Si se permiten tipos distintos de int,int firmado,int sin firmar,y _Bool</target>
        </trans-unit>
        <trans-unit id="7259a07c162a5980a03092d887024ac563145697" translate="yes" xml:space="preserve">
          <source>While narrow strings provide &lt;code&gt;&lt;a href=&quot;fprintf&quot;&gt;snprintf&lt;/a&gt;&lt;/code&gt;, which makes it possible to determine the required output buffer size, there is no equivalent for wide strings (until C11's snwprintf_s), and in order to determine the buffer size, the program may need to call &lt;code&gt;swprintf&lt;/code&gt;, check the result value, and reallocate a larger buffer, trying again until successful.</source>
          <target state="translated">Si bien las cadenas estrechas proporcionan &lt;code&gt;&lt;a href=&quot;fprintf&quot;&gt;snprintf&lt;/a&gt;&lt;/code&gt; , lo que hace posible determinar el tama&amp;ntilde;o del b&amp;uacute;fer de salida requerido, no hay equivalente para cadenas anchas (hasta snwprintf_s de C11), y para determinar el tama&amp;ntilde;o del b&amp;uacute;fer, el programa puede necesitar llamar a &lt;code&gt;swprintf&lt;/code&gt; , verificar el valor de resultado y reasignar un b&amp;uacute;fer m&amp;aacute;s grande, intentando nuevamente hasta que tenga &amp;eacute;xito.</target>
        </trans-unit>
        <trans-unit id="a5c61c737d0b53e6e2f5ec4314c3a6438910987b" translate="yes" xml:space="preserve">
          <source>While narrow strings provide &lt;code&gt;&lt;a href=&quot;vfprintf&quot;&gt;vsnprintf&lt;/a&gt;&lt;/code&gt;, which makes it possible to determine the required output buffer size, there is no equivalent for wide strings (until C11's vsnwprintf_s), and in order to determine the buffer size, the program may need to call &lt;code&gt;vswprintf&lt;/code&gt;, check the result value, and reallocate a larger buffer, trying again until successful.</source>
          <target state="translated">Si bien las cadenas estrechas proporcionan &lt;code&gt;&lt;a href=&quot;vfprintf&quot;&gt;vsnprintf&lt;/a&gt;&lt;/code&gt; , lo que hace posible determinar el tama&amp;ntilde;o del b&amp;uacute;fer de salida requerido, no hay equivalente para las cadenas anchas (hasta vsnwprintf_s de C11), y para determinar el tama&amp;ntilde;o del b&amp;uacute;fer, el programa puede necesitar llamar a &lt;code&gt;vswprintf&lt;/code&gt; , verificar el valor de resultado y reasignar un b&amp;uacute;fer m&amp;aacute;s grande, intentando nuevamente hasta que tenga &amp;eacute;xito.</target>
        </trans-unit>
        <trans-unit id="b7402781ffeb31aaf9f29177f61c8ff4a0f44050" translate="yes" xml:space="preserve">
          <source>Wide character</source>
          <target state="translated">Carácter amplio</target>
        </trans-unit>
        <trans-unit id="1fb55327ce03b4f2af732e3d187f25baf551cf61" translate="yes" xml:space="preserve">
          <source>Wide character array manipulation</source>
          <target state="translated">Manipulación de la amplia gama de caracteres</target>
        </trans-unit>
        <trans-unit id="f8ed0c5da0ad503c6f172f824d7c17ff8675a795" translate="yes" xml:space="preserve">
          <source>Widens a single-byte character &lt;code&gt;c&lt;/code&gt; (reinterpreted as &lt;code&gt;unsigned char&lt;/code&gt;) to its wide character equivalent.</source>
          <target state="translated">Ampl&amp;iacute;a un car&amp;aacute;cter de byte &amp;uacute;nico &lt;code&gt;c&lt;/code&gt; (reinterpretado como &lt;code&gt;unsigned char&lt;/code&gt; ) a su equivalente de car&amp;aacute;cter ancho.</target>
        </trans-unit>
        <trans-unit id="3cf16972858ec6c71abfb6fa6d539bdbe451dbf6" translate="yes" xml:space="preserve">
          <source>Width in bits by data model</source>
          <target state="translated">Anchura en bits por modelo de datos</target>
        </trans-unit>
        <trans-unit id="0352671572d548b1b50beb4586216b4e3764d488" translate="yes" xml:space="preserve">
          <source>Win16 API</source>
          <target state="translated">API Win16</target>
        </trans-unit>
        <trans-unit id="ae7fc6d8171e0e405ed2e200f1d2b5056d479b80" translate="yes" xml:space="preserve">
          <source>Win32 API</source>
          <target state="translated">API de Win32</target>
        </trans-unit>
        <trans-unit id="50f72286ea0c96bccbea595ccc66e3982412d267" translate="yes" xml:space="preserve">
          <source>Win64 API</source>
          <target state="translated">API de Win64</target>
        </trans-unit>
        <trans-unit id="84a4a9dac26edeb0330a247c9af1446aecf202e8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;#pragma once&lt;/code&gt;, the same header appears as.</source>
          <target state="translated">Con &lt;code&gt;#pragma once&lt;/code&gt; , aparece el mismo encabezado que.</target>
        </trans-unit>
        <trans-unit id="859458ff8d7a2c1367626ec3e6f5fe580dc0d8be" translate="yes" xml:space="preserve">
          <source>Within a &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; definition, an array of unknown size may appear as the last member (as long as there is at least one other named member), in which case it is a special case known as</source>
          <target state="translated">Dentro de una definici&amp;oacute;n de &lt;a href=&quot;struct&quot;&gt;estructura&lt;/a&gt; , una matriz de tama&amp;ntilde;o desconocido puede aparecer como el &amp;uacute;ltimo miembro (siempre que haya al menos otro miembro nombrado), en cuyo caso es un caso especial conocido como</target>
        </trans-unit>
        <trans-unit id="28e069819f560fd884671902093491d5e9bb760b" translate="yes" xml:space="preserve">
          <source>Within a scope, an identifier may designate more than one entity only if the entities are in different &lt;a href=&quot;name_space&quot;&gt;name spaces&lt;/a&gt;.</source>
          <target state="translated">Dentro de un alcance, un identificador puede designar m&amp;aacute;s de una entidad solo si las entidades est&amp;aacute;n en &lt;a href=&quot;name_space&quot;&gt;espacios de nombre&lt;/a&gt; diferentes .</target>
        </trans-unit>
        <trans-unit id="4f799cd56e5a2e4e20f4f65e7ce12eb8f9226308" translate="yes" xml:space="preserve">
          <source>Within a struct object, addresses of its elements (and the addresses of the bit field allocation units) increase in order in which the members were defined. A pointer to a struct can be cast to a pointer to its first member (or, if the member is a bit field, to its allocation unit). Likewise, a pointer to the first member of a struct can be cast to a pointer to the enclosing struct. There may be unnamed padding between any two members of a struct or after the last member, but not before the first member. The size of a struct is at least as large as the sum of the sizes of its members.</source>
          <target state="translated">Dentro de un objeto estructural,las direcciones de sus elementos (y las direcciones de las unidades de asignación de campos de bits)aumentan en el orden en que se definieron los miembros.Un puntero a una estructura puede ser lanzado a un puntero a su primer miembro (o,si el miembro es un campo de bits,a su unidad de asignación).Del mismo modo,un puntero al primer miembro de una estructura puede ser lanzado a un puntero a la estructura que la encierra.Puede haber un relleno sin nombre entre dos miembros cualesquiera de una estructura o después del último miembro,pero no antes del primer miembro.El tamaño de una estructura es al menos tan grande como la suma de los tamaños de sus miembros.</target>
        </trans-unit>
        <trans-unit id="c312de86feff370bca491c752177547a6ed543f3" translate="yes" xml:space="preserve">
          <source>Within a thread of execution, accesses (reads and writes) through &lt;a href=&quot;../language/volatile&quot;&gt;volatile lvalues&lt;/a&gt; cannot be reordered past observable side-effects (including other volatile accesses) that are separated by a sequence point within the same thread, but this order is not guaranteed to be observed by another thread, since volatile access does not establish inter-thread synchronization.</source>
          <target state="translated">Dentro de un hilo de ejecuci&amp;oacute;n, los accesos (lecturas y escrituras) a trav&amp;eacute;s de &lt;a href=&quot;../language/volatile&quot;&gt;valores vol&amp;aacute;tiles&lt;/a&gt; no se pueden reordenar m&amp;aacute;s all&amp;aacute; de los efectos secundarios observables (incluidos otros accesos vol&amp;aacute;tiles) que est&amp;aacute;n separados por un punto de secuencia dentro del mismo hilo, pero no se garantiza que se observe este orden por otro hilo, ya que el acceso vol&amp;aacute;til no establece la sincronizaci&amp;oacute;n entre hilos.</target>
        </trans-unit>
        <trans-unit id="969826a89b84b4e4d551c53334e30be5ab3cd356" translate="yes" xml:space="preserve">
          <source>Within every function-body, the special predefined variable &lt;code&gt;__func__&lt;/code&gt; with block scope and static storage duration is available, as if defined immediately after the opening brace by.</source>
          <target state="translated">Dentro de cada cuerpo de funci&amp;oacute;n, la variable predefinida especial &lt;code&gt;__func__&lt;/code&gt; con alcance de bloque y duraci&amp;oacute;n de almacenamiento est&amp;aacute;tico est&amp;aacute; disponible, como si se definiera inmediatamente despu&amp;eacute;s de la llave de apertura.</target>
        </trans-unit>
        <trans-unit id="8023499cb58c4c109815a2d79ac5650829ddeda6" translate="yes" xml:space="preserve">
          <source>Within the body of a function that uses variadic arguments, the values of these arguments may be accessed using the &lt;a href=&quot;../variadic&quot;&gt;&amp;lt;stdarg.h&amp;gt; library facilities&lt;/a&gt;:</source>
          <target state="translated">Dentro del cuerpo de una funci&amp;oacute;n que usa argumentos variables, se puede acceder a los valores de estos argumentos usando las &lt;a href=&quot;../variadic&quot;&gt;funciones de biblioteca &amp;lt;stdarg.h&amp;gt;&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="703acf324f8116b8c498a56c14125e1a93f6ae46" translate="yes" xml:space="preserve">
          <source>Within the function body, every parameter is an &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; expression, they have automatic &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; and &lt;a href=&quot;scope&quot;&gt;block scope&lt;/a&gt;. The layout of the parameters in memory (or if they are stored in memory at all) is unspecified: it is a part of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Calling_convention&quot;&gt;calling convention&lt;/a&gt;.</source>
          <target state="translated">Dentro del cuerpo de la funci&amp;oacute;n, cada par&amp;aacute;metro es una expresi&amp;oacute;n &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; , tienen una &lt;a href=&quot;storage_duration&quot;&gt;duraci&amp;oacute;n de almacenamiento&lt;/a&gt; autom&amp;aacute;tica y &lt;a href=&quot;scope&quot;&gt;un alcance de bloque&lt;/a&gt; . El dise&amp;ntilde;o de los par&amp;aacute;metros en la memoria (o si est&amp;aacute;n almacenados en la memoria) no est&amp;aacute; especificado: es parte de la &lt;a href=&quot;https://en.wikipedia.org/wiki/Calling_convention&quot;&gt;convenci&amp;oacute;n de llamada&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="49fbad2db57b58d46114fa10a3190f7deba0831b" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;count&lt;/code&gt; of objects from the given array &lt;code&gt;buffer&lt;/code&gt; to the output stream &lt;code&gt;stream&lt;/code&gt;. The objects are written as if by reinterpreting each object as an array of &lt;code&gt;unsigned char&lt;/code&gt; and calling &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;fputc&lt;/a&gt;&lt;/code&gt;&lt;code&gt;size&lt;/code&gt; times for each object to write those &lt;code&gt;unsigned char&lt;/code&gt;s into &lt;code&gt;stream&lt;/code&gt;, in order. The file position indicator for the stream is advanced by the number of characters written.</source>
          <target state="translated">Escribe el &lt;code&gt;count&lt;/code&gt; de objetos del &lt;code&gt;buffer&lt;/code&gt; matriz dado en la secuencia de &lt;code&gt;stream&lt;/code&gt; salida . Los objetos se escriben como si reinterpretaran cada objeto como una matriz de caracteres &lt;code&gt;unsigned char&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;fputc&lt;/a&gt;&lt;/code&gt; tiempos de &lt;code&gt;size&lt;/code&gt; fputc para que cada objeto escriba esos caracteres &lt;code&gt;unsigned char&lt;/code&gt; en la &lt;code&gt;stream&lt;/code&gt; , en orden. El indicador de posici&amp;oacute;n del archivo para la transmisi&amp;oacute;n avanza por el n&amp;uacute;mero de caracteres escritos.</target>
        </trans-unit>
        <trans-unit id="e87fd10313099f92edd69106267a002d4e8466a1" translate="yes" xml:space="preserve">
          <source>Writes a character &lt;code&gt;ch&lt;/code&gt; to &lt;code&gt;stdout&lt;/code&gt;. Internally, the character is converted to &lt;code&gt;unsigned char&lt;/code&gt; just before being written.</source>
          <target state="translated">Escribe un car&amp;aacute;cter &lt;code&gt;ch&lt;/code&gt; para &lt;code&gt;stdout&lt;/code&gt; . Internamente, el car&amp;aacute;cter se convierte en &lt;code&gt;unsigned char&lt;/code&gt; justo antes de ser escrito.</target>
        </trans-unit>
        <trans-unit id="5869a84e9848e943c8c5fd069a261d745ada80d5" translate="yes" xml:space="preserve">
          <source>Writes a character &lt;code&gt;ch&lt;/code&gt; to the given output stream &lt;code&gt;stream&lt;/code&gt;. &lt;code&gt;putc()&lt;/code&gt; may be implemented as a macro and evaluate &lt;code&gt;stream&lt;/code&gt; more than once, so the corresponding argument should never be an expression with side effects.</source>
          <target state="translated">Escribe un car&amp;aacute;cter &lt;code&gt;ch&lt;/code&gt; en la secuencia de &lt;code&gt;stream&lt;/code&gt; salida dada . &lt;code&gt;putc()&lt;/code&gt; puede implementarse como una macro y evaluar la &lt;code&gt;stream&lt;/code&gt; m&amp;aacute;s de una vez, por lo que el argumento correspondiente nunca debe ser una expresi&amp;oacute;n con efectos secundarios.</target>
        </trans-unit>
        <trans-unit id="628a432848d3d2a0f439ca52671452d1eec4d9ff" translate="yes" xml:space="preserve">
          <source>Writes a wide character &lt;code&gt;ch&lt;/code&gt; to &lt;code&gt;stdout&lt;/code&gt;.</source>
          <target state="translated">Escribe un car&amp;aacute;cter amplio &lt;code&gt;ch&lt;/code&gt; para &lt;code&gt;stdout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a61cc5af43d9f51fcd06a3cacfeb3348c1595940" translate="yes" xml:space="preserve">
          <source>Writes a wide character &lt;code&gt;ch&lt;/code&gt; to the given output stream &lt;code&gt;stream&lt;/code&gt;. &lt;code&gt;putwc()&lt;/code&gt; may be implemented as a macro and may evaluate &lt;code&gt;stream&lt;/code&gt; more than once.</source>
          <target state="translated">Escribe un car&amp;aacute;cter ancho &lt;code&gt;ch&lt;/code&gt; en la secuencia de &lt;code&gt;stream&lt;/code&gt; salida dada . &lt;code&gt;putwc()&lt;/code&gt; puede implementarse como una macro y puede evaluar la &lt;code&gt;stream&lt;/code&gt; m&amp;aacute;s de una vez.</target>
        </trans-unit>
        <trans-unit id="c2f81c0bcaf9b63cee02a0581c7178cf0890849f" translate="yes" xml:space="preserve">
          <source>Writes an implementation-defined message to &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; which must include the string pointed to by &lt;code&gt;msg&lt;/code&gt; and calls &lt;code&gt;&lt;a href=&quot;../program/abort&quot;&gt;abort()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Escribe un mensaje definido por la implementaci&amp;oacute;n en &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; que debe incluir la cadena a la que apunta &lt;code&gt;msg&lt;/code&gt; y llama a &lt;code&gt;&lt;a href=&quot;../program/abort&quot;&gt;abort()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77fbd50411d6315927f25422863e722e33834996" translate="yes" xml:space="preserve">
          <source>Writes every character from the null-terminated string &lt;code&gt;str&lt;/code&gt; and one additional newline character &lt;code&gt;'\n'&lt;/code&gt; to the output stream &lt;code&gt;stdout&lt;/code&gt;, as if by repeatedly executing &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;fputc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Escribe todos los caracteres de la cadena &lt;code&gt;str&lt;/code&gt; terminada en nulo y un car&amp;aacute;cter de nueva l&amp;iacute;nea adicional &lt;code&gt;'\n'&lt;/code&gt; en la secuencia de salida &lt;code&gt;stdout&lt;/code&gt; , como si ejecutara repetidamente &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;fputc&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b38a38e83b8d315adcafdff09da46681f69740a" translate="yes" xml:space="preserve">
          <source>Writes every character from the null-terminated string &lt;code&gt;str&lt;/code&gt; to the output stream &lt;code&gt;stream&lt;/code&gt;, as if by repeatedly executing &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;fputc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Escribe todos los caracteres de la cadena &lt;code&gt;str&lt;/code&gt; terminada en nulo en la secuencia de &lt;code&gt;stream&lt;/code&gt; salida , como si ejecutara repetidamente &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;fputc&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b28d781181727277b71446dfb72cdeed8c73d3e4" translate="yes" xml:space="preserve">
          <source>Writes every character from the null-terminated wide string &lt;code&gt;str&lt;/code&gt; to the output stream &lt;code&gt;stream&lt;/code&gt;, as if by repeatedly executing &lt;code&gt;&lt;a href=&quot;fputwc&quot;&gt;fputwc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Escribe cada car&amp;aacute;cter desde la cadena de &lt;code&gt;str&lt;/code&gt; ancha terminada en nulo en la secuencia de &lt;code&gt;stream&lt;/code&gt; salida , como si ejecutara repetidamente &lt;code&gt;&lt;a href=&quot;fputwc&quot;&gt;fputwc&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d60cdb3a38da8a130cf91abef198ed0c8df65943" translate="yes" xml:space="preserve">
          <source>X and X appears before B in the Single Total Order</source>
          <target state="translated">X y X aparece antes de B en el orden total único</target>
        </trans-unit>
        <trans-unit id="2f3f27dde1e0deeab004667545a65bef35394ab9" translate="yes" xml:space="preserve">
          <source>X argument</source>
          <target state="translated">Argumento X</target>
        </trans-unit>
        <trans-unit id="6db6535836e6c904498ebb911985cfb1ab6cbadf" translate="yes" xml:space="preserve">
          <source>X, Y is</source>
          <target state="translated">X,Y es</target>
        </trans-unit>
        <trans-unit id="6ba655c53b7c6f7ad109ea6e30e446c19a1740b7" translate="yes" xml:space="preserve">
          <source>Y argument</source>
          <target state="translated">Argumento Y</target>
        </trans-unit>
        <trans-unit id="879e32326c5217968ac8e3a14e4a8a5214957264" translate="yes" xml:space="preserve">
          <source>Year</source>
          <target state="translated">Year</target>
        </trans-unit>
        <trans-unit id="8152a5497cccb550fed6c13df95ac1947ae757e7" translate="yes" xml:space="preserve">
          <source>Zero if &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; compare equal, or if count is zero.</source>
          <target state="translated">Cero si &lt;code&gt;lhs&lt;/code&gt; y &lt;code&gt;rhs&lt;/code&gt; se comparan igual, o si la cuenta es cero.</target>
        </trans-unit>
        <trans-unit id="51c939bb7f5f0758dd76abfc0b3c05c623bebff7" translate="yes" xml:space="preserve">
          <source>Zero if &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; compare equal.</source>
          <target state="translated">Cero si &lt;code&gt;lhs&lt;/code&gt; y &lt;code&gt;rhs&lt;/code&gt; se comparan igual.</target>
        </trans-unit>
        <trans-unit id="431ba1f7d46a244cebe6c0d684ca1e39d75e6ab0" translate="yes" xml:space="preserve">
          <source>Zero-length array declarations are not allowed, even though some compilers offer them as extensions (typically as a pre-C99 implementation of &lt;a href=&quot;struct&quot;&gt;flexible array members&lt;/a&gt;).</source>
          <target state="translated">Las declaraciones de matriz de longitud cero no est&amp;aacute;n permitidas, aunque algunos compiladores las ofrecen como extensiones (generalmente como una implementaci&amp;oacute;n anterior a C99 de &lt;a href=&quot;struct&quot;&gt;miembros de matriz flexible&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ca77598d8983f14f3898f59c121fdcf1e9e18087" translate="yes" xml:space="preserve">
          <source>[-]d.ddd</source>
          <target state="translated">[-]d.ddd</target>
        </trans-unit>
        <trans-unit id="913e7afee46c7a822906ed5749ddbb4805cee7d2" translate="yes" xml:space="preserve">
          <source>[-]ddd.ddd</source>
          <target state="translated">[-]ddd.ddd</target>
        </trans-unit>
        <trans-unit id="8c2b29412829eefb22455e55f53e2c249d24e11a" translate="yes" xml:space="preserve">
          <source>[-]dddd</source>
          <target state="translated">[-]dddd</target>
        </trans-unit>
        <trans-unit id="36886f5ee53771548cf5c86e4853a8dcf06d3e14" translate="yes" xml:space="preserve">
          <source>] radians, is returned.</source>
          <target state="translated">] radianes, se devuelve.</target>
        </trans-unit>
        <trans-unit id="12ec352745ee599586db13a925319fe87a988295" translate="yes" xml:space="preserve">
          <source>], is returned.</source>
          <target state="translated">], es regresado.</target>
        </trans-unit>
        <trans-unit id="3cb3417ca91352ca5e5ad839596b7b62a28b6c17" translate="yes" xml:space="preserve">
          <source>_Alignas</source>
          <target state="translated">_Alignas</target>
        </trans-unit>
        <trans-unit id="f7008bc87a6929c330fb4f709f0a2e6b754d59c3" translate="yes" xml:space="preserve">
          <source>_Alignas specifier</source>
          <target state="translated">_Especificador de Alignas</target>
        </trans-unit>
        <trans-unit id="bda6adb87ec6691221ed73213de332b2c9474ce6" translate="yes" xml:space="preserve">
          <source>_Alignof</source>
          <target state="translated">_Alignof</target>
        </trans-unit>
        <trans-unit id="e7ddc52003557bd694ed510e05d8ffa47bfc7849" translate="yes" xml:space="preserve">
          <source>_Alignof operator</source>
          <target state="translated">_Alinear operador</target>
        </trans-unit>
        <trans-unit id="048effd77189bf393076ca1fcf73e53aaeff6d6d" translate="yes" xml:space="preserve">
          <source>_Atomic</source>
          <target state="translated">_Atomic</target>
        </trans-unit>
        <trans-unit id="3bd5f76b0997fbede5e7b3a7dad72c9e8f31308b" translate="yes" xml:space="preserve">
          <source>_Bool</source>
          <target state="translated">_Bool</target>
        </trans-unit>
        <trans-unit id="c20ed3009ec2e03e51793cfd518f6e77ee0fc814" translate="yes" xml:space="preserve">
          <source>_Complex</source>
          <target state="translated">_Complex</target>
        </trans-unit>
        <trans-unit id="403449942a1d68cb22e3a2df541b687d5192f4f7" translate="yes" xml:space="preserve">
          <source>_Complex_I</source>
          <target state="translated">_Complex_I</target>
        </trans-unit>
        <trans-unit id="5903c0497b4b6110dd3051a9b31ef948bae78c64" translate="yes" xml:space="preserve">
          <source>_Exit</source>
          <target state="translated">_Exit</target>
        </trans-unit>
        <trans-unit id="0fa07fc2f45d73e6843828483db383cbb81e135c" translate="yes" xml:space="preserve">
          <source>_Generic</source>
          <target state="translated">_Generic</target>
        </trans-unit>
        <trans-unit id="a86d3649d1b2b72954d70aa40f94f98858c527ba" translate="yes" xml:space="preserve">
          <source>_IOFBF_IOLBF_IONBF</source>
          <target state="translated">_IOFBF_IOLBF_IONBF</target>
        </trans-unit>
        <trans-unit id="b81882d762d1caccc4812c0eaa31886b66e6d1d9" translate="yes" xml:space="preserve">
          <source>_Imaginary</source>
          <target state="translated">_Imaginary</target>
        </trans-unit>
        <trans-unit id="b28c3530ddb62124dba16492b0964cb3e6186e5a" translate="yes" xml:space="preserve">
          <source>_Imaginary_I</source>
          <target state="translated">_Imaginary_I</target>
        </trans-unit>
        <trans-unit id="deb8ccf25fe4c28454012c03785eb57ded7283e7" translate="yes" xml:space="preserve">
          <source>_Noreturn</source>
          <target state="translated">_Noreturn</target>
        </trans-unit>
        <trans-unit id="ef06032cc9ad497cbe9512a26000e41f2e236bf4" translate="yes" xml:space="preserve">
          <source>_Noreturn function specifier</source>
          <target state="translated">_Especificador de funci&amp;oacute;n de no retorno</target>
        </trans-unit>
        <trans-unit id="ccfa477ead56b2c88345b8173962b5f15db933a3" translate="yes" xml:space="preserve">
          <source>_Static_assert</source>
          <target state="translated">_Static_assert</target>
        </trans-unit>
        <trans-unit id="b796d6cb075e66b2fec2b6e79a80b0ede26d4cd1" translate="yes" xml:space="preserve">
          <source>_Thread_local</source>
          <target state="translated">_Thread_local</target>
        </trans-unit>
        <trans-unit id="1b22c1d687dc7c54339d14d0aa2284796291aec8" translate="yes" xml:space="preserve">
          <source>__DATE__</source>
          <target state="translated">__DATE__</target>
        </trans-unit>
        <trans-unit id="9d5d8995523b8b8951428baa81ea663ff0bd2c77" translate="yes" xml:space="preserve">
          <source>__FILE__</source>
          <target state="translated">__FILE__</target>
        </trans-unit>
        <trans-unit id="a51b95694c81c92580bff6f580f8e200ecf86661" translate="yes" xml:space="preserve">
          <source>__LINE__</source>
          <target state="translated">__LINE__</target>
        </trans-unit>
        <trans-unit id="a6d131d3c4073efb4f54ca94b64fdf5ebf0001ec" translate="yes" xml:space="preserve">
          <source>__STDC_ANALYZABLE__</source>
          <target state="translated">__STDC_ANALYZABLE__</target>
        </trans-unit>
        <trans-unit id="51f3c9479afc9737ac0812162dcb10cc18fbbd51" translate="yes" xml:space="preserve">
          <source>__STDC_HOSTED__</source>
          <target state="translated">__STDC_HOSTED__</target>
        </trans-unit>
        <trans-unit id="9b62494894b2be9bf94a226b2a93df702d06518d" translate="yes" xml:space="preserve">
          <source>__STDC_IEC_559_COMPLEX__</source>
          <target state="translated">__STDC_IEC_559_COMPLEX__</target>
        </trans-unit>
        <trans-unit id="1f0d02915700fe3497cf0ffb2cb5539415b60c57" translate="yes" xml:space="preserve">
          <source>__STDC_IEC_559__</source>
          <target state="translated">__STDC_IEC_559__</target>
        </trans-unit>
        <trans-unit id="aa16038a596c275e6fffc69644dbad7ec1a3ceb3" translate="yes" xml:space="preserve">
          <source>__STDC_ISO_10646__</source>
          <target state="translated">__STDC_ISO_10646__</target>
        </trans-unit>
        <trans-unit id="5ffa704ce725aadaecae2a04eb767b6de640c9ec" translate="yes" xml:space="preserve">
          <source>__STDC_LIB_EXT1__</source>
          <target state="translated">__STDC_LIB_EXT1__</target>
        </trans-unit>
        <trans-unit id="230648d096a182990dad2c93fa8e616a0bed8465" translate="yes" xml:space="preserve">
          <source>__STDC_MB_MIGHT_NEQ_WC__</source>
          <target state="translated">__STDC_MB_MIGHT_NEQ_WC__</target>
        </trans-unit>
        <trans-unit id="fc7e5fe991a21e7e3d1f456399d4028544f5c6da" translate="yes" xml:space="preserve">
          <source>__STDC_NO_ATOMICS__</source>
          <target state="translated">__STDC_NO_ATOMICS__</target>
        </trans-unit>
        <trans-unit id="ff500cb34558d344640792adb24dac70e376b23d" translate="yes" xml:space="preserve">
          <source>__STDC_NO_COMPLEX__</source>
          <target state="translated">__STDC_NO_COMPLEX__</target>
        </trans-unit>
        <trans-unit id="ae78398cf4324ce5250a638c6222cfae5fcbd1ec" translate="yes" xml:space="preserve">
          <source>__STDC_NO_THREADS__</source>
          <target state="translated">__STDC_NO_THREADS__</target>
        </trans-unit>
        <trans-unit id="8004a029922d7533c64a5198c26202855b45a447" translate="yes" xml:space="preserve">
          <source>__STDC_NO_VLA__</source>
          <target state="translated">__STDC_NO_VLA__</target>
        </trans-unit>
        <trans-unit id="aec164fb4da1e304eadad72b50ba5910b1144c03" translate="yes" xml:space="preserve">
          <source>__STDC_UTF_16__</source>
          <target state="translated">__STDC_UTF_16__</target>
        </trans-unit>
        <trans-unit id="92432151980d707704b3ddfa392fde3ab589eb6c" translate="yes" xml:space="preserve">
          <source>__STDC_UTF_32__</source>
          <target state="translated">__STDC_UTF_32__</target>
        </trans-unit>
        <trans-unit id="04202f9ce8c923e1e74ba2bfa78f2696041116d2" translate="yes" xml:space="preserve">
          <source>__STDC_VERSION__</source>
          <target state="translated">__STDC_VERSION__</target>
        </trans-unit>
        <trans-unit id="e7fe05e43de55659e13d860cf51adc28583a4875" translate="yes" xml:space="preserve">
          <source>__STDC__</source>
          <target state="translated">__STDC__</target>
        </trans-unit>
        <trans-unit id="cf716a68ef036dac529946b2640a330f562725fe" translate="yes" xml:space="preserve">
          <source>__TIME__</source>
          <target state="translated">__TIME__</target>
        </trans-unit>
        <trans-unit id="9c3e29639fd2bfaa4db627da53f4d56eac9f0ec0" translate="yes" xml:space="preserve">
          <source>__alignas_is_defined</source>
          <target state="translated">__alignas_is_defined</target>
        </trans-unit>
        <trans-unit id="9d36c35d5289d86c7318369c0ebda5c58db23714" translate="yes" xml:space="preserve">
          <source>__alignof_is_defined</source>
          <target state="translated">__alignof_is_defined</target>
        </trans-unit>
        <trans-unit id="d8db95cc58ad2925bc93429910aec8cf2d80ad01" translate="yes" xml:space="preserve">
          <source>__func__</source>
          <target state="translated">__func__</target>
        </trans-unit>
        <trans-unit id="ed05f3a1b388032bead330257ae7557f50fb23b8" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;compatible_type#Type_names&quot;&gt;type name&lt;/a&gt; specifying any complete object type or an array of unknown size, but not a VLA</source>
          <target state="translated">un &lt;a href=&quot;compatible_type#Type_names&quot;&gt;nombre de tipo que&lt;/a&gt; especifica cualquier tipo de objeto completo o una matriz de tama&amp;ntilde;o desconocido, pero no un VLA</target>
        </trans-unit>
        <trans-unit id="bf12ce76466b152fd371b60da373fcc004cd34e1" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;statements#Compound_statements&quot;&gt;compound statement&lt;/a&gt;, that is a brace-enclosed sequence of declarations and statements, that is executed whenever this function is called</source>
          <target state="translated">una &lt;a href=&quot;statements#Compound_statements&quot;&gt;declaraci&amp;oacute;n compuesta&lt;/a&gt; , que es una secuencia de declaraciones y declaraciones encerradas entre llaves, que se ejecuta cada vez que se llama a esta funci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="22334f752f416e871ad26a7973293f511dbb1117" translate="yes" xml:space="preserve">
          <source>a call to &lt;code&gt;aligned_alloc&lt;/code&gt; that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by &lt;code&gt;aligned_alloc&lt;/code&gt;. There is a single total order of all allocation and deallocation functions operating on each particular region of memory.</source>
          <target state="translated">una llamada a &lt;code&gt;aligned_alloc&lt;/code&gt; que asigna la misma o una parte de la misma regi&amp;oacute;n de memoria. Esta sincronizaci&amp;oacute;n ocurre despu&amp;eacute;s de cualquier acceso a la memoria por la funci&amp;oacute;n de desasignaci&amp;oacute;n y antes de cualquier acceso a la memoria por &lt;code&gt;aligned_alloc&lt;/code&gt; . Hay un &amp;uacute;nico orden total de todas las funciones de asignaci&amp;oacute;n y desasignaci&amp;oacute;n que operan en cada regi&amp;oacute;n particular de la memoria.</target>
        </trans-unit>
        <trans-unit id="3c0b56ef24d3ffabf7a12df45d7bbc0049a40b25" translate="yes" xml:space="preserve">
          <source>a call to &lt;code&gt;calloc&lt;/code&gt; that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by &lt;code&gt;calloc&lt;/code&gt;. There is a single total order of all allocation and deallocation functions operating on each particular region of memory.</source>
          <target state="translated">Una llamada a &lt;code&gt;calloc&lt;/code&gt; que asigna la misma o una parte de la misma regi&amp;oacute;n de memoria. Esta sincronizaci&amp;oacute;n ocurre despu&amp;eacute;s de cualquier acceso a la memoria por parte de la funci&amp;oacute;n de desasignaci&amp;oacute;n y antes de cualquier acceso a la memoria por parte de &lt;code&gt;calloc&lt;/code&gt; . Hay un &amp;uacute;nico orden total de todas las funciones de asignaci&amp;oacute;n y desasignaci&amp;oacute;n que operan en cada regi&amp;oacute;n particular de la memoria.</target>
        </trans-unit>
        <trans-unit id="9a1dfede2161933a15a2d59057794b27ad7f32c0" translate="yes" xml:space="preserve">
          <source>a call to &lt;code&gt;malloc&lt;/code&gt; that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by &lt;code&gt;malloc&lt;/code&gt;. There is a single total order of all allocation and deallocation functions operating on each particular region of memory.</source>
          <target state="translated">una llamada a &lt;code&gt;malloc&lt;/code&gt; que asigna la misma o una parte de la misma regi&amp;oacute;n de memoria. Esta sincronizaci&amp;oacute;n ocurre despu&amp;eacute;s de cualquier acceso a la memoria por parte de la funci&amp;oacute;n de desasignaci&amp;oacute;n y antes de cualquier acceso a la memoria por parte de &lt;code&gt;malloc&lt;/code&gt; . Hay un &amp;uacute;nico orden total de todas las funciones de asignaci&amp;oacute;n y desasignaci&amp;oacute;n que operan en cada regi&amp;oacute;n particular de la memoria.</target>
        </trans-unit>
        <trans-unit id="2c7964245d6375ae1a1b7aa7777bd609529d1b41" translate="yes" xml:space="preserve">
          <source>a call to any allocation function, including &lt;code&gt;realloc&lt;/code&gt; that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by &lt;code&gt;realloc&lt;/code&gt;. There is a single total order of all allocation and deallocation functions operating on each particular region of memory.</source>
          <target state="translated">una llamada a cualquier funci&amp;oacute;n de asignaci&amp;oacute;n, incluido &lt;code&gt;realloc&lt;/code&gt; que asigna la misma o una parte de la misma regi&amp;oacute;n de memoria. Esta sincronizaci&amp;oacute;n ocurre despu&amp;eacute;s de cualquier acceso a la memoria por la funci&amp;oacute;n de desasignaci&amp;oacute;n y antes de cualquier acceso a la memoria por &lt;code&gt;realloc&lt;/code&gt; . Hay un &amp;uacute;nico orden total de todas las funciones de asignaci&amp;oacute;n y desasignaci&amp;oacute;n que operan en cada regi&amp;oacute;n particular de la memoria.</target>
        </trans-unit>
        <trans-unit id="5c2b3caaac6f4495fa04fefe591d34d3404c9be0" translate="yes" xml:space="preserve">
          <source>a call to any subsequent allocation function that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by the allocation function. There is a single total order of all allocation and deallocation functions operating on each particular region of memory.</source>
          <target state="translated">una llamada a cualquier función de asignación posterior que asigne la misma o una parte de la misma región de memoria.Esta sincronización se produce después de cualquier acceso a la memoria por la función de reasignación y antes de cualquier acceso a la memoria por la función de asignación.Hay un solo orden total de todas las funciones de asignación y reasignación que operan en cada región particular de la memoria.</target>
        </trans-unit>
        <trans-unit id="37f124f55b3ba6f47f47e94dddf3560a78205e93" translate="yes" xml:space="preserve">
          <source>a character from the basic source character set minus single-quote (&lt;code&gt;'&lt;/code&gt;), backslash (&lt;code&gt;\&lt;/code&gt;), or the newline character.</source>
          <target state="translated">un car&amp;aacute;cter del conjunto de caracteres de origen b&amp;aacute;sico menos comillas simples ( &lt;code&gt;'&lt;/code&gt; ), barra diagonal inversa ( &lt;code&gt;\&lt;/code&gt; ) o el car&amp;aacute;cter de nueva l&amp;iacute;nea.</target>
        </trans-unit>
        <trans-unit id="b3e20e256d4371f9eda62db761cfe929f36364f0" translate="yes" xml:space="preserve">
          <source>a combination of</source>
          <target state="translated">una combinación de</target>
        </trans-unit>
        <trans-unit id="97556c5ee84f06d4c9e6e31d96e3be1f6a10cee5" translate="yes" xml:space="preserve">
          <source>a declarator for a function type which uses a &lt;a href=&quot;function_declaration&quot;&gt;identifier list&lt;/a&gt; to designate function parameters</source>
          <target state="translated">un declarador para un tipo de funci&amp;oacute;n que utiliza una &lt;a href=&quot;function_declaration&quot;&gt;lista de identificadores&lt;/a&gt; para designar par&amp;aacute;metros de funci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="aaad00c729007943609a1f99403a9854100c7ae7" translate="yes" xml:space="preserve">
          <source>a declarator for a function type which uses a &lt;a href=&quot;function_declaration&quot;&gt;parameter list&lt;/a&gt; to designate function parameters</source>
          <target state="translated">un declarador para un tipo de funci&amp;oacute;n que utiliza una &lt;a href=&quot;function_declaration&quot;&gt;lista de par&amp;aacute;metros&lt;/a&gt; para designar par&amp;aacute;metros de funci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="4d6273559dfdc3c5cc36c5e5eef22e8820ec4422" translate="yes" xml:space="preserve">
          <source>a list of C Standard Library header files</source>
          <target state="translated">una lista de archivos de encabezamiento de la Biblioteca Estándar C</target>
        </trans-unit>
        <trans-unit id="123d2f34da2c9eb6022f14f7a955c26bfe59be30" translate="yes" xml:space="preserve">
          <source>a name earlier introduced by a &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; declaration</source>
          <target state="translated">un nombre introducido anteriormente por una declaraci&amp;oacute;n &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0504278be6e31ecdf6a05b32909135da1f2b6e21" translate="yes" xml:space="preserve">
          <source>a non-character value of type wint_t used to indicate errors</source>
          <target state="translated">un valor no característico del tipo wint_t utilizado para indicar errores</target>
        </trans-unit>
        <trans-unit id="5dc9f3ea46b0a8a1ead292f1ee45735eb0a6f74f" translate="yes" xml:space="preserve">
          <source>a null pointer</source>
          <target state="translated">un puntero nulo</target>
        </trans-unit>
        <trans-unit id="2683ca29bdfef4cfd8048b11187a792b0ee2e2e2" translate="yes" xml:space="preserve">
          <source>a pointer to an object that is not an element of an array is treated as if it were pointing to an element of an array with one element</source>
          <target state="translated">un puntero a un objeto que no es un elemento de una matriz es tratado como si estuviera apuntando a un elemento de una matriz con un elemento</target>
        </trans-unit>
        <trans-unit id="642ef2320577c98feaf2f935169ad215e1202ed9" translate="yes" xml:space="preserve">
          <source>a positive integer value if the first argument is</source>
          <target state="translated">un valor entero positivo si el primer argumento es</target>
        </trans-unit>
        <trans-unit id="62ce867551f081be316dd4eace049a5f95b2fe17" translate="yes" xml:space="preserve">
          <source>a positive value of type errno_t</source>
          <target state="translated">un valor positivo de tipo errno_t</target>
        </trans-unit>
        <trans-unit id="492a0055d77ea0e7979cf99d3b9100bf9e6853bf" translate="yes" xml:space="preserve">
          <source>a sequence of digits</source>
          <target state="translated">una secuencia de dígitos</target>
        </trans-unit>
        <trans-unit id="092e5d5910cd24daae23118a07aa91b2b252f93d" translate="yes" xml:space="preserve">
          <source>a store in one thread becomes a</source>
          <target state="translated">una tienda en un hilo se convierte en un</target>
        </trans-unit>
        <trans-unit id="425bf9812e28d908720f162b8a9d1517a6cc2c8d" translate="yes" xml:space="preserve">
          <source>a string used to indicate negative monetary quantity</source>
          <target state="translated">una cadena utilizada para indicar la cantidad monetaria negativa</target>
        </trans-unit>
        <trans-unit id="757d7a97b6240cce0f9fe837451991e14db0783e" translate="yes" xml:space="preserve">
          <source>a string used to indicate non-negative monetary quantity</source>
          <target state="translated">una cadena utilizada para indicar la cantidad monetaria no negativa</target>
        </trans-unit>
        <trans-unit id="3b9575d67efdbcb362fb37d3399a2d1499fafcd8" translate="yes" xml:space="preserve">
          <source>a string whose elements indicate the sizes of digit groups</source>
          <target state="translated">una cadena cuyos elementos indican el tamaño de los grupos de dígitos</target>
        </trans-unit>
        <trans-unit id="f858a6b266d4e30454cc89ef983dd5a2590b03ee" translate="yes" xml:space="preserve">
          <source>a type with alignment requirement as great as any other scalar type</source>
          <target state="translated">un tipo con un requisito de alineación tan grande como cualquier otro tipo de escalar</target>
        </trans-unit>
        <trans-unit id="18069b9a8678c1f8291708c89d8b9c4d0252afe5" translate="yes" xml:space="preserve">
          <source>a typedef for the same type as &lt;code&gt;&lt;a href=&quot;types/size_t&quot;&gt;size_t&lt;/a&gt;&lt;/code&gt;, used to self-document functions that range-check their parameters at runtime</source>
          <target state="translated">un typedef para el mismo tipo que &lt;code&gt;&lt;a href=&quot;types/size_t&quot;&gt;size_t&lt;/a&gt;&lt;/code&gt; , utilizado para documentar funciones que comprueban sus par&amp;aacute;metros en tiempo de ejecuci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="09f017c999f517934019ede8a1bf4373b242d073" translate="yes" xml:space="preserve">
          <source>a typedef for the type &lt;code&gt;int&lt;/code&gt;, used to self-document functions that return &lt;code&gt;&lt;a href=&quot;error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; values</source>
          <target state="translated">un typedef para el tipo &lt;code&gt;int&lt;/code&gt; , usado para documentar funciones que devuelven valores &lt;code&gt;&lt;a href=&quot;error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="407f7616399e225a63ca52c79ae317571cf373f3" translate="yes" xml:space="preserve">
          <source>a typedef of the function pointer type &lt;code&gt;int(*)(void*)&lt;/code&gt;, used by &lt;code&gt;&lt;a href=&quot;thread/thrd_create&quot;&gt;thrd_create&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">un typedef del puntero de funci&amp;oacute;n tipo &lt;code&gt;int(*)(void*)&lt;/code&gt; , utilizado por &lt;code&gt;&lt;a href=&quot;thread/thrd_create&quot;&gt;thrd_create&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7533040d36d9a8ffca93129287587122b0c1b376" translate="yes" xml:space="preserve">
          <source>a value computation B of M, then the evaluation B takes its value from X or from a side effect Y that appears after X in the modification order of M.</source>
          <target state="translated">un cálculo del valor B de M,entonces la evaluación B toma su valor de X o de un efecto secundario Y que aparece después de X en el orden de modificación de M.</target>
        </trans-unit>
        <trans-unit id="b7f70cb2bc562eb0488f01aebc9ebd032140296e" translate="yes" xml:space="preserve">
          <source>a) 5 whitespace characters (space, horizontal tab, vertical tab, form feed, new-line)</source>
          <target state="translated">a)5 caracteres de espacio en blanco (espacio,tabulación horizontal,tabulación vertical,avance de forma,nueva línea)</target>
        </trans-unit>
        <trans-unit id="a57ad183139e2466db24858c2f6b437736f099b1" translate="yes" xml:space="preserve">
          <source>a) expanding or contracting the existing area pointed to by &lt;code&gt;ptr&lt;/code&gt;, if possible. The contents of the area remain unchanged up to the lesser of the new and old sizes. If the area is expanded, the contents of the new part of the array are undefined.</source>
          <target state="translated">a) expandir o contraer el &amp;aacute;rea existente se&amp;ntilde;alada por &lt;code&gt;ptr&lt;/code&gt; , si es posible. El contenido del &amp;aacute;rea permanece sin cambios hasta el menor de los tama&amp;ntilde;os nuevos y antiguos. Si el &amp;aacute;rea se expande, el contenido de la nueva parte de la matriz no est&amp;aacute; definido.</target>
        </trans-unit>
        <trans-unit id="848db1c7f35ec7d54618e653c42ac58dc864e10f" translate="yes" xml:space="preserve">
          <source>a) header names: &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt; or &lt;code&gt;&quot;myfile.h&quot;&lt;/code&gt;</source>
          <target state="translated">a) nombres de encabezado: &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt; o &lt;code&gt;&quot;myfile.h&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0f00aadd58815891ba18ffc68b4e53f080f7c07a" translate="yes" xml:space="preserve">
          <source>abnormal termination condition, as is e.g. initiated by &lt;code&gt;&lt;a href=&quot;abort&quot;&gt;abort()&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">condici&amp;oacute;n de terminaci&amp;oacute;n anormal, como p. ej. iniciada por &lt;code&gt;&lt;a href=&quot;abort&quot;&gt;abort()&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b61646f016483b318b49a910668a966b6ce09ede" translate="yes" xml:space="preserve">
          <source>abort</source>
          <target state="translated">abort</target>
        </trans-unit>
        <trans-unit id="97de44dce82a940a13b9f4994b57f07a99108566" translate="yes" xml:space="preserve">
          <source>abort callback for the bounds-checked functions</source>
          <target state="translated">abortar la llamada para las funciones de control de límites</target>
        </trans-unit>
        <trans-unit id="f904e02a1a8fcc03536537b036685a2c755fb46c" translate="yes" xml:space="preserve">
          <source>abort_handler_s</source>
          <target state="translated">abort_handler_s</target>
        </trans-unit>
        <trans-unit id="7923a997e5ef7f7635917efd7303a93b2c10c23a" translate="yes" xml:space="preserve">
          <source>aborts the program if the user-specified condition is not &lt;code&gt;true&lt;/code&gt;. May be disabled for release builds</source>
          <target state="translated">aborta el programa si la condici&amp;oacute;n especificada por el usuario no es &lt;code&gt;true&lt;/code&gt; . Puede deshabilitarse para las versiones de lanzamiento</target>
        </trans-unit>
        <trans-unit id="164bfc66d0623cf4e44cafa362512a824d7e8d82" translate="yes" xml:space="preserve">
          <source>above is a property of every &lt;a href=&quot;compatible_type&quot;&gt;integer type&lt;/a&gt; and is defined as follows:</source>
          <target state="translated">anterior es una propiedad de cada &lt;a href=&quot;compatible_type&quot;&gt;tipo entero&lt;/a&gt; y se define de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="5094c70ca393f26707dd39d316fccaaf5f18c594" translate="yes" xml:space="preserve">
          <source>abs, labs, llabs, imaxabs</source>
          <target state="translated">abdominales,laboratorios,laboratorios de laboratorio,imaxabs</target>
        </trans-unit>
        <trans-unit id="b198eb4b50fdd6b5832a36287b1acdc5b1c03d47" translate="yes" xml:space="preserve">
          <source>abslabsllabs</source>
          <target state="translated">abslabsllabs</target>
        </trans-unit>
        <trans-unit id="19a8e3d6209d1f620f09754c72b881fd910c1f0c" translate="yes" xml:space="preserve">
          <source>access member &lt;b&gt;b&lt;/b&gt; of &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; pointed to by &lt;b&gt;a&lt;/b&gt;</source>
          <target state="translated">miembro de acceso &lt;b&gt;b&lt;/b&gt; de &lt;a href=&quot;struct&quot;&gt;estructura&lt;/a&gt; o &lt;a href=&quot;union&quot;&gt;uni&amp;oacute;n&lt;/a&gt; se&amp;ntilde;alado por &lt;b&gt;un&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e77e10629f557a3bc65645a9ca4c3a8bf8fd7940" translate="yes" xml:space="preserve">
          <source>access member &lt;b&gt;b&lt;/b&gt; of &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt;&lt;b&gt;a&lt;/b&gt;</source>
          <target state="translated">miembro de acceso &lt;b&gt;b&lt;/b&gt; de &lt;a href=&quot;struct&quot;&gt;estructura&lt;/a&gt; o &lt;a href=&quot;union&quot;&gt;uni&amp;oacute;n &lt;/a&gt;&lt;b&gt;a&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8d2d225128f456bf497712bea851d5e0ab2b7e6c" translate="yes" xml:space="preserve">
          <source>access the &lt;b&gt;b&lt;/b&gt;th element of array &lt;b&gt;a&lt;/b&gt;</source>
          <target state="translated">acceder al elemento &lt;b&gt;b&lt;/b&gt; de la matriz &lt;b&gt;a&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fd6cc7542529dd7354ae281d8012983cdc5fce31" translate="yes" xml:space="preserve">
          <source>access to an object outside of its &lt;a href=&quot;lifetime&quot;&gt;lifetime&lt;/a&gt; (e.g. through a dangling pointer)</source>
          <target state="translated">acceso a un objeto fuera de su &lt;a href=&quot;lifetime&quot;&gt;vida &amp;uacute;til&lt;/a&gt; (por ejemplo, a trav&amp;eacute;s de un puntero colgante)</target>
        </trans-unit>
        <trans-unit id="fb4e35cb551b39ac5df3d0f5c072966de7e0bc5c" translate="yes" xml:space="preserve">
          <source>access to the list of environment variables</source>
          <target state="translated">acceso a la lista de variables de entorno</target>
        </trans-unit>
        <trans-unit id="7c24822cdeb7c5c6b787dbc0cfccf8c9b4d0844f" translate="yes" xml:space="preserve">
          <source>accesses the next variadic function argument</source>
          <target state="translated">accede al siguiente argumento de la función variádica</target>
        </trans-unit>
        <trans-unit id="328f0742cf74e8ffdb253376b1803615055e215b" translate="yes" xml:space="preserve">
          <source>acos</source>
          <target state="translated">acos</target>
        </trans-unit>
        <trans-unit id="147d0b37b30b50556b9e55d6a8ce932951fad569" translate="yes" xml:space="preserve">
          <source>acos(z), or simply i acos(z) in the upper half of the complex plane.</source>
          <target state="translated">acos(z),o simplemente i acos(z)en la mitad superior del plano complejo.</target>
        </trans-unit>
        <trans-unit id="4f6845fe659bed6637eedb661a4b4fda8a803d03" translate="yes" xml:space="preserve">
          <source>acos, acosf, acosl</source>
          <target state="translated">acos,acosf,acosl</target>
        </trans-unit>
        <trans-unit id="7065e6c51c4483cfded5cc061fbccd9a93bc104c" translate="yes" xml:space="preserve">
          <source>acosacosfacosl</source>
          <target state="translated">acosacosfacosl</target>
        </trans-unit>
        <trans-unit id="5df0277ec86f188e0c797c5782ceb42dc25bb36a" translate="yes" xml:space="preserve">
          <source>acosh</source>
          <target state="translated">acosh</target>
        </trans-unit>
        <trans-unit id="589a4621c7cf6dcff6a469151b23cd30ce08cce9" translate="yes" xml:space="preserve">
          <source>acosh, acoshf, acoshl</source>
          <target state="translated">acosh,acoshf,acoshl</target>
        </trans-unit>
        <trans-unit id="1824220df1c196fec7eafe8955123ab045039cc2" translate="yes" xml:space="preserve">
          <source>acoshacoshfacoshl</source>
          <target state="translated">acoshacoshfacoshl</target>
        </trans-unit>
        <trans-unit id="a90390361d9b0316110b5eee0023ea52e6598545" translate="yes" xml:space="preserve">
          <source>acoshl</source>
          <target state="translated">acoshl</target>
        </trans-unit>
        <trans-unit id="304e4d7ae71d38f68561c83b5cdefd5c197713fc" translate="yes" xml:space="preserve">
          <source>acosl</source>
          <target state="translated">acosl</target>
        </trans-unit>
        <trans-unit id="1c52002b743e4db150df31d4c92e7f8849bd4395" translate="yes" xml:space="preserve">
          <source>acquire operation</source>
          <target state="translated">adquirir la operación</target>
        </trans-unit>
        <trans-unit id="4ef76fa8e24cfa0361d135d67b2541d876650e36" translate="yes" xml:space="preserve">
          <source>acquiring</source>
          <target state="translated">acquiring</target>
        </trans-unit>
        <trans-unit id="c3805175370d19c334b59f45b87343b9f2b7f5e1" translate="yes" xml:space="preserve">
          <source>addition</source>
          <target state="translated">addition</target>
        </trans-unit>
        <trans-unit id="1ea3777754d6be1f3458ef90dda1cf54a1ddb440" translate="yes" xml:space="preserve">
          <source>addition assignment</source>
          <target state="translated">asignación de la adición</target>
        </trans-unit>
        <trans-unit id="feccbd79efdd23843e4995d7af810032b227dbbc" translate="yes" xml:space="preserve">
          <source>additional information (e.g., collating sequence), passed to &lt;code&gt;comp&lt;/code&gt; as the third argument</source>
          <target state="translated">informaci&amp;oacute;n adicional (p. ej., secuencia de clasificaci&amp;oacute;n), pasada a &lt;code&gt;comp&lt;/code&gt; como el tercer argumento</target>
        </trans-unit>
        <trans-unit id="9d50eddef9262e79d2047b13e4d6d3daf024d3ec" translate="yes" xml:space="preserve">
          <source>additionally, if they are enumerations, corresponding members must also have the same values.</source>
          <target state="translated">Además,si se trata de enumeraciones,los miembros correspondientes también deben tener los mismos valores.</target>
        </trans-unit>
        <trans-unit id="f3241e56e78b25a62f11b23b96ec570f0735ce1d" translate="yes" xml:space="preserve">
          <source>additionally, if they are structures or unions,</source>
          <target state="translated">además,si son estructuras o uniones,</target>
        </trans-unit>
        <trans-unit id="c662180230cad14787d4ab7e77aa08681ce783fa" translate="yes" xml:space="preserve">
          <source>address</source>
          <target state="translated">address</target>
        </trans-unit>
        <trans-unit id="556049da8cc10fac75ab14efc978eeeeb3ea2692" translate="yes" xml:space="preserve">
          <source>address constant expression</source>
          <target state="translated">expresión constante de la dirección</target>
        </trans-unit>
        <trans-unit id="0c17e45ca56ec6ed4a705f824c8aca1c8f4e8e77" translate="yes" xml:space="preserve">
          <source>address of</source>
          <target state="translated">dirección de</target>
        </trans-unit>
        <trans-unit id="4457c5c7ef8ebc7b3a1f299072c7fb0729c67a6a" translate="yes" xml:space="preserve">
          <source>aggregate types</source>
          <target state="translated">tipos agregados</target>
        </trans-unit>
        <trans-unit id="062f903e7a5b5fa5dd018873a2aa70adfb2020bd" translate="yes" xml:space="preserve">
          <source>alignas</source>
          <target state="translated">alignas</target>
        </trans-unit>
        <trans-unit id="0d80ec85b39f8b9faf623f44b5b53e8f41051306" translate="yes" xml:space="preserve">
          <source>aligned_alloc</source>
          <target state="translated">aligned_alloc</target>
        </trans-unit>
        <trans-unit id="05dfeae5db3ff37e5e9f1f43350a95604f04689b" translate="yes" xml:space="preserve">
          <source>alignment</source>
          <target state="translated">alignment</target>
        </trans-unit>
        <trans-unit id="7a5e5f751184b7bff89789dac0da42a54bbc4cb6" translate="yes" xml:space="preserve">
          <source>alignment requirement</source>
          <target state="translated">requisito de alineación</target>
        </trans-unit>
        <trans-unit id="2b0a9a63b400f56ea64f1dc5c76adcfc41fa151d" translate="yes" xml:space="preserve">
          <source>alignment requirement (can be determined by &lt;a href=&quot;alignof&quot;&gt;alignof&lt;/a&gt;)(since C11)</source>
          <target state="translated">requisito de alineaci&amp;oacute;n (puede determinarse mediante &lt;a href=&quot;alignof&quot;&gt;alignof&lt;/a&gt; ) (desde C11)</target>
        </trans-unit>
        <trans-unit id="867318e23a3e63655204aafd2975563685ee0462" translate="yes" xml:space="preserve">
          <source>alignof</source>
          <target state="translated">alignof</target>
        </trans-unit>
        <trans-unit id="d87c448044defb778f33158d8ccf94a20531d600" translate="yes" xml:space="preserve">
          <source>all</source>
          <target state="translated">all</target>
        </trans-unit>
        <trans-unit id="3e7c1609043c1941c605866ab35e26dad2ab85fc" translate="yes" xml:space="preserve">
          <source>all C streams are flushed and closed</source>
          <target state="translated">todos los arroyos C se enjuagan y se cierran</target>
        </trans-unit>
        <trans-unit id="df4172a5a7b30962538b9ec831d1b1de58d48654" translate="yes" xml:space="preserve">
          <source>all arithmetic, relational, logical, and bitwise operators</source>
          <target state="translated">todos los operadores aritméticos,relacionales,lógicos y de bits</target>
        </trans-unit>
        <trans-unit id="cdb708b79dfd7d3f13e68022e4110062dda87cf2" translate="yes" xml:space="preserve">
          <source>all operations and constants evaluate in the range and precision of &lt;code&gt;double&lt;/code&gt;. Additionally, both &lt;code&gt;float_t&lt;/code&gt; and &lt;code&gt;double_t&lt;/code&gt; are equivalent to &lt;code&gt;double&lt;/code&gt;</source>
          <target state="translated">Todas las operaciones y constantes se eval&amp;uacute;an en el rango y precisi&amp;oacute;n del &lt;code&gt;double&lt;/code&gt; . Adem&amp;aacute;s, &lt;code&gt;float_t&lt;/code&gt; y &lt;code&gt;double_t&lt;/code&gt; son equivalentes a &lt;code&gt;double&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a3353ab95ebb14131e875c614b1df72dfe1c566c" translate="yes" xml:space="preserve">
          <source>all operations and constants evaluate in the range and precision of &lt;code&gt;long double&lt;/code&gt;. Additionally, both &lt;code&gt;float_t&lt;/code&gt; and &lt;code&gt;double_t&lt;/code&gt; are equivalent to &lt;code&gt;long double&lt;/code&gt;</source>
          <target state="translated">Todas las operaciones y constantes se eval&amp;uacute;an en el rango y precisi&amp;oacute;n del &lt;code&gt;long double&lt;/code&gt; . Adem&amp;aacute;s, tanto &lt;code&gt;float_t&lt;/code&gt; como &lt;code&gt;double_t&lt;/code&gt; son equivalentes a &lt;code&gt;long double&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="977083d5e09600da9c4eccd257809269b4c94c59" translate="yes" xml:space="preserve">
          <source>all operations and constants evaluate in the range and precision of the type used. Additionally, &lt;code&gt;float_t&lt;/code&gt; and &lt;code&gt;double_t&lt;/code&gt; are equivalent to &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt; respectively</source>
          <target state="translated">Todas las operaciones y constantes se eval&amp;uacute;an en el rango y la precisi&amp;oacute;n del tipo utilizado. Adem&amp;aacute;s, &lt;code&gt;float_t&lt;/code&gt; y &lt;code&gt;double_t&lt;/code&gt; son equivalentes a &lt;code&gt;float&lt;/code&gt; y &lt;code&gt;double&lt;/code&gt; respectivamente</target>
        </trans-unit>
        <trans-unit id="7780d84b84c9142aa89e31966605e1441d783bee" translate="yes" xml:space="preserve">
          <source>all operators not specified to return lvalues, including</source>
          <target state="translated">todos los operadores no especificados para devolver los valores,incluyendo</target>
        </trans-unit>
        <trans-unit id="68630f1665f7e74a806f82115917b348ff54806d" translate="yes" xml:space="preserve">
          <source>all other pointer comparisons invoke undefined behavior</source>
          <target state="translated">todas las demás comparaciones de punteros invocan un comportamiento indefinido</target>
        </trans-unit>
        <trans-unit id="400375aeabf668f2340ea3b379d803b6b8b255fe" translate="yes" xml:space="preserve">
          <source>allocate a copy of a string</source>
          <target state="translated">asignar una copia de una cadena</target>
        </trans-unit>
        <trans-unit id="bb337ce8a028a4cee827132b68f54b4907c60e86" translate="yes" xml:space="preserve">
          <source>allocate a copy of a string up to specified size</source>
          <target state="translated">asignar una copia de una cadena hasta el tamaño especificado</target>
        </trans-unit>
        <trans-unit id="5f3e8f3c8913ee0556612ac56f1100bdc54d4b6b" translate="yes" xml:space="preserve">
          <source>allocates aligned memory</source>
          <target state="translated">asigna la memoria alineada</target>
        </trans-unit>
        <trans-unit id="8454d15e4c9c8e6f3a57a97cf499f9a12a5b9c45" translate="yes" xml:space="preserve">
          <source>allocates and zeroes memory</source>
          <target state="translated">asigna y pone a cero la memoria</target>
        </trans-unit>
        <trans-unit id="b8a8fad17819140ae5245db5e27c1653353c978b" translate="yes" xml:space="preserve">
          <source>allocates memory</source>
          <target state="translated">asigna la memoria</target>
        </trans-unit>
        <trans-unit id="91a0b05ea8f965ae4bee50cde10d4c446a1e3b17" translate="yes" xml:space="preserve">
          <source>allowed). The permitted implicit conversions remain implicit conversions as if by assignment since that's what &lt;a href=&quot;initialization&quot;&gt;initialization&lt;/a&gt; also uses.</source>
          <target state="translated">permitido). Las conversiones impl&amp;iacute;citas permitidas siguen siendo conversiones impl&amp;iacute;citas como por asignaci&amp;oacute;n, ya que eso es lo que tambi&amp;eacute;n usa la &lt;a href=&quot;initialization&quot;&gt;inicializaci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="57fc2642d89ce1e097c263a684eb5a024daeebb1" translate="yes" xml:space="preserve">
          <source>already exists</source>
          <target state="translated">ya existe</target>
        </trans-unit>
        <trans-unit id="a66468d63e91e596a97d876019fbaff6d95089c8" translate="yes" xml:space="preserve">
          <source>alternative form</source>
          <target state="translated">forma alternativa</target>
        </trans-unit>
        <trans-unit id="e8af47c361b758726325c4a5d8f6d520db8f84f6" translate="yes" xml:space="preserve">
          <source>alternative implementation</source>
          <target state="translated">implementación alternativa</target>
        </trans-unit>
        <trans-unit id="7a3889426121edfa53717bdb3ef97045d05ffc26" translate="yes" xml:space="preserve">
          <source>alternative representation</source>
          <target state="translated">representación alternativa</target>
        </trans-unit>
        <trans-unit id="1dd1a6dc80c5ec13ed0bab7c3efae29474bb9c3c" translate="yes" xml:space="preserve">
          <source>an &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; of any pointer type</source>
          <target state="translated">una &lt;a href=&quot;expressions&quot;&gt;expresi&amp;oacute;n&lt;/a&gt; de cualquier tipo de puntero</target>
        </trans-unit>
        <trans-unit id="6fcaeef60c578753f96c537b6021c9f8ba0f4005" translate="yes" xml:space="preserve">
          <source>an &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; of integer type</source>
          <target state="translated">una &lt;a href=&quot;expressions&quot;&gt;expresi&amp;oacute;n&lt;/a&gt; de tipo entero</target>
        </trans-unit>
        <trans-unit id="c3c63cd915fa58503257713ad4a99a2388d7cf0c" translate="yes" xml:space="preserve">
          <source>an &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; of type pointer to complete object</source>
          <target state="translated">una &lt;a href=&quot;expressions&quot;&gt;expresi&amp;oacute;n&lt;/a&gt; de tipo puntero para completar el objeto</target>
        </trans-unit>
        <trans-unit id="0ffd31cdd3fc478fb8aa298268d403b7671713aa" translate="yes" xml:space="preserve">
          <source>an &lt;a href=&quot;identifier&quot;&gt;identifier&lt;/a&gt; that names a member of the struct or union designated by expression</source>
          <target state="translated">un &lt;a href=&quot;identifier&quot;&gt;identificador&lt;/a&gt; que nombra a un miembro de la estructura o uni&amp;oacute;n designada por expresi&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="c770b10bd3283310dfe735741609cc3e6a12bf2a" translate="yes" xml:space="preserve">
          <source>an &lt;a href=&quot;identifier&quot;&gt;identifier&lt;/a&gt; that names a member of the struct or union pointed by expression</source>
          <target state="translated">un &lt;a href=&quot;identifier&quot;&gt;identificador&lt;/a&gt; que nombra a un miembro de la estructura o uni&amp;oacute;n se&amp;ntilde;alado por expresi&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="26834c673eb6eae28680be23c0c387a56f2be791" translate="yes" xml:space="preserve">
          <source>an &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; expression of any type that is not a &lt;a href=&quot;bit_field&quot;&gt;bit field&lt;/a&gt; and does not have &lt;a href=&quot;storage_duration&quot;&gt;register&lt;/a&gt; storage class</source>
          <target state="translated">Una expresi&amp;oacute;n &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; de cualquier tipo que no sea un &lt;a href=&quot;bit_field&quot;&gt;campo de bits&lt;/a&gt; y no tenga una clase de almacenamiento de &lt;a href=&quot;storage_duration&quot;&gt;registros&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8d25a5eab78f6eda49ce05aa4731693cd80db5ed" translate="yes" xml:space="preserve">
          <source>an expression of &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; type</source>
          <target state="translated">una expresi&amp;oacute;n de &lt;a href=&quot;struct&quot;&gt;estructura&lt;/a&gt; o tipo de &lt;a href=&quot;union&quot;&gt;uni&amp;oacute;n&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e9ca9f074bef452e68d74671c6b7e41ad6718dbe" translate="yes" xml:space="preserve">
          <source>an expression of any &lt;a href=&quot;compatible_type#Type_groups&quot;&gt;scalar type&lt;/a&gt;</source>
          <target state="translated">una expresi&amp;oacute;n de cualquier &lt;a href=&quot;compatible_type#Type_groups&quot;&gt;tipo escalar&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e482a6714eaafb0e24be84f63888929f38a20ed1" translate="yes" xml:space="preserve">
          <source>an expression of any scalar type</source>
          <target state="translated">una expresión de cualquier tipo de escalar</target>
        </trans-unit>
        <trans-unit id="c5091785e0504e641a8e3af5496c6028197b862f" translate="yes" xml:space="preserve">
          <source>an expression of any scalar type, which is only evaluated if lhs compares equal to &lt;code&gt;​0​&lt;/code&gt;</source>
          <target state="translated">una expresi&amp;oacute;n de cualquier tipo escalar, que solo se eval&amp;uacute;a si lhs se compara igual a &lt;code&gt;​0​&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9c30acc345d35d3998440b6088bf19963caa6a35" translate="yes" xml:space="preserve">
          <source>an expression of any scalar type, which is only evaluated if lhs does not compare equal to &lt;code&gt;​0​&lt;/code&gt;</source>
          <target state="translated">una expresi&amp;oacute;n de cualquier tipo escalar, que solo se eval&amp;uacute;a si lhs no se compara igual a &lt;code&gt;​0​&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b2daf35100d05a24b08066e28b51c0c00f1cce17" translate="yes" xml:space="preserve">
          <source>an expression of scalar type</source>
          <target state="translated">una expresión de tipo escalar</target>
        </trans-unit>
        <trans-unit id="1466d8b4e35f4f83ca75b50de808d2ca1cce841e" translate="yes" xml:space="preserve">
          <source>an expression of type &lt;a href=&quot;pointer&quot;&gt;pointer&lt;/a&gt; to &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt;</source>
          <target state="translated">una expresi&amp;oacute;n de tipo &lt;a href=&quot;pointer&quot;&gt;puntero&lt;/a&gt; a &lt;a href=&quot;struct&quot;&gt;estructura&lt;/a&gt; o &lt;a href=&quot;union&quot;&gt;uni&amp;oacute;n&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5a67874112f3e299e468f90df2277215d12f553a" translate="yes" xml:space="preserve">
          <source>an instance of the &lt;code&gt;va_list&lt;/code&gt; type</source>
          <target state="translated">una instancia del tipo &lt;code&gt;va_list&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="86abb14241dbb7db0bb13b74e8edde69e450c9e5" translate="yes" xml:space="preserve">
          <source>an instance of the &lt;code&gt;va_list&lt;/code&gt; type to clean up</source>
          <target state="translated">una instancia del tipo &lt;code&gt;va_list&lt;/code&gt; para limpiar</target>
        </trans-unit>
        <trans-unit id="30e295867a522c67c41499b0529da42173f1d4c0" translate="yes" xml:space="preserve">
          <source>an instance of the &lt;code&gt;va_list&lt;/code&gt; type to initialize</source>
          <target state="translated">una instancia del tipo &lt;code&gt;va_list&lt;/code&gt; para inicializar</target>
        </trans-unit>
        <trans-unit id="ce9512a3c405db5a107feba3b473178c36d74968" translate="yes" xml:space="preserve">
          <source>an integer &lt;a href=&quot;../language/constant_expression#Integer_constant_expression&quot;&gt;constant expression&lt;/a&gt; with the value &lt;code&gt;​0​&lt;/code&gt;</source>
          <target state="translated">una &lt;a href=&quot;../language/constant_expression#Integer_constant_expression&quot;&gt;expresi&amp;oacute;n constante&lt;/a&gt; entera con el valor &lt;code&gt;​0​&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d51b1b56486d192e084f8901036bb0c35812c943" translate="yes" xml:space="preserve">
          <source>an integer &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt; with a value greater or equal to zero and less or equal the number of bits in the underlying type. When greater than zero, this is the number of bits that this bit field will occupy. The value zero is only allowed for nameless bit fields and has special meaning: it specifies that the next bit field in the class definition will begin at an allocation unit's boundary.</source>
          <target state="translated">una &lt;a href=&quot;constant_expression&quot;&gt;expresi&amp;oacute;n constante&lt;/a&gt; entera con un valor mayor o igual a cero y menor o igual al n&amp;uacute;mero de bits en el tipo subyacente. Cuando es mayor que cero, este es el n&amp;uacute;mero de bits que ocupar&amp;aacute; este campo de bits. El valor cero solo est&amp;aacute; permitido para campos de bits sin nombre y tiene un significado especial: especifica que el siguiente campo de bits en la definici&amp;oacute;n de clase comenzar&amp;aacute; en el l&amp;iacute;mite de una unidad de asignaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b382c31b00d864a5cbeb230e9e1412baa05f78a4" translate="yes" xml:space="preserve">
          <source>an integer constant expression with the value 0 &lt;a href=&quot;../language/conversion#Pointer_conversions&quot;&gt;cast to the type&lt;/a&gt;&lt;code&gt;void*&lt;/code&gt;</source>
          <target state="translated">una expresi&amp;oacute;n constante entera con el valor 0 &lt;a href=&quot;../language/conversion#Pointer_conversions&quot;&gt;emitido al tipo &lt;/a&gt; &lt;code&gt;void*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0b08993b08f9159ab8acc22acd5919bddd34e9c0" translate="yes" xml:space="preserve">
          <source>an object of &lt;a href=&quot;compatible_type#Type_groups&quot;&gt;scalar type&lt;/a&gt; (arithmetic type, pointer type, enumeration type)</source>
          <target state="translated">Un objeto de &lt;a href=&quot;compatible_type#Type_groups&quot;&gt;tipo escalar&lt;/a&gt; ( tipo aritm&amp;eacute;tico, tipo puntero, tipo de enumeraci&amp;oacute;n)</target>
        </trans-unit>
        <trans-unit id="9fc8d05fff2d4a9fdbb558a1197ea598e431dfb8" translate="yes" xml:space="preserve">
          <source>an operation B on M, then A takes its value from a side effect X on M, where X appears before B in the modification order of M.</source>
          <target state="translated">una operación B en M,entonces A toma su valor de un efecto secundario X en M,donde X aparece antes de B en el orden de modificación de M.</target>
        </trans-unit>
        <trans-unit id="8dde5d5482f9f390a32371e3f89da7b3284eda61" translate="yes" xml:space="preserve">
          <source>an operation B that modifies M, then A appears earlier than B in the modification order of M.</source>
          <target state="translated">una operación B que modifica M,entonces A aparece antes que B en el orden de modificación de M.</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="04f3ea1263fe354b1a1abaea9c1143c043077794" translate="yes" xml:space="preserve">
          <source>and a</source>
          <target state="translated">y un</target>
        </trans-unit>
        <trans-unit id="96e2a753ba36c7df2d9c9572a980d973b1fb8650" translate="yes" xml:space="preserve">
          <source>and is only available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined. The following macros and functions support this functionality.</source>
          <target state="translated">y solo est&amp;aacute; disponible si &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; est&amp;aacute; definido. Las siguientes macros y funciones admiten esta funcionalidad.</target>
        </trans-unit>
        <trans-unit id="40fd560f32f29d04963d416d75047a6cfeb92dbe" translate="yes" xml:space="preserve">
          <source>and may not be declared in a program (doing so invokes undefined behavior):</source>
          <target state="translated">y no puede ser declarado en un programa (al hacerlo se invoca un comportamiento indefinido):</target>
        </trans-unit>
        <trans-unit id="6f5c1ef50816d102d59e8dddcc9ac547607b50fd" translate="yes" xml:space="preserve">
          <source>and selects the subobject to be initialized within the</source>
          <target state="translated">y selecciona el subobjeto a ser inicializado dentro de la</target>
        </trans-unit>
        <trans-unit id="a93345ebb64aeba932c32ab7d854638997d5ef19" translate="yes" xml:space="preserve">
          <source>and the standard library provides one definition of this constant as the macro &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; .</source>
          <target state="translated">y la biblioteca est&amp;aacute;ndar proporciona una definici&amp;oacute;n de esta constante como la macro &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9fd29300b85768a1234d6f664159b64c48c91452" translate="yes" xml:space="preserve">
          <source>and their</source>
          <target state="translated">y su</target>
        </trans-unit>
        <trans-unit id="fb0416aa14d74afde308590f0e07546abbf5c866" translate="yes" xml:space="preserve">
          <source>and.</source>
          <target state="translated">and.</target>
        </trans-unit>
        <trans-unit id="1fba2da8434660e3c85122283402e6dd020f0ee9" translate="yes" xml:space="preserve">
          <source>anonymous struct</source>
          <target state="translated">estructura anónima</target>
        </trans-unit>
        <trans-unit id="80a011b32fef63606811d73e091cc0b24ee0357f" translate="yes" xml:space="preserve">
          <source>anonymous union</source>
          <target state="translated">unión anónima</target>
        </trans-unit>
        <trans-unit id="0f6794e2c132cc20741c7a6f05c99a28077f81c0" translate="yes" xml:space="preserve">
          <source>another (see &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;memory_order&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">otro (ver &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;memory_order&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="809318b0f32018415dfddab521f3e13842ec38e4" translate="yes" xml:space="preserve">
          <source>any &lt;a href=&quot;../string/byte&quot;&gt;string&lt;/a&gt; or &lt;a href=&quot;../string/wide&quot;&gt;wide string&lt;/a&gt; library function accesses an array out of bounds</source>
          <target state="translated">cualquier &lt;a href=&quot;../string/byte&quot;&gt;cadena&lt;/a&gt; o funci&amp;oacute;n de biblioteca de &lt;a href=&quot;../string/wide&quot;&gt;cadenas anchas&lt;/a&gt; accede a una matriz fuera de los l&amp;iacute;mites</target>
        </trans-unit>
        <trans-unit id="548db24dda99e960bd75dbe694826c0574978efb" translate="yes" xml:space="preserve">
          <source>any &lt;a href=&quot;compatible_type#Type_names&quot;&gt;type name&lt;/a&gt;</source>
          <target state="translated">cualquier &lt;a href=&quot;compatible_type#Type_names&quot;&gt;tipo de nombre&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d0567d76c391930bf6159349a1feb7c3e0f6b493" translate="yes" xml:space="preserve">
          <source>any &lt;a href=&quot;constant_expression&quot;&gt;integer constant expression&lt;/a&gt;</source>
          <target state="translated">cualquier &lt;a href=&quot;constant_expression&quot;&gt;expresi&amp;oacute;n constante entera&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c86de59cb451b567943008ac77b5019b11450cd9" translate="yes" xml:space="preserve">
          <source>any &lt;a href=&quot;constant_expression&quot;&gt;integer constant expression&lt;/a&gt; whose value is a valid &lt;a href=&quot;object#Alignment&quot;&gt;alignment&lt;/a&gt; or zero</source>
          <target state="translated">cualquier &lt;a href=&quot;constant_expression&quot;&gt;expresi&amp;oacute;n constante entera&lt;/a&gt; cuyo valor sea una &lt;a href=&quot;object#Alignment&quot;&gt;alineaci&amp;oacute;n&lt;/a&gt; v&amp;aacute;lida o cero</target>
        </trans-unit>
        <trans-unit id="6240ff52b9d414b02e19da67fc0afce850b89a7c" translate="yes" xml:space="preserve">
          <source>any &lt;a href=&quot;declarations#Declarators&quot;&gt;declarator&lt;/a&gt; except unparenthesized pointer declarator. The identifier that is contained in this declarator is the identifier that becomes the function designator.</source>
          <target state="translated">cualquier &lt;a href=&quot;declarations#Declarators&quot;&gt;declarador&lt;/a&gt; excepto el declarador de puntero sin par&amp;eacute;ntesis. El identificador que est&amp;aacute; contenido en este declarador es el identificador que se convierte en el designador de la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c3b874c873f2146b6463b682d297176c153f579b" translate="yes" xml:space="preserve">
          <source>any &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; of &lt;a href=&quot;compatible_type#Type_groups&quot;&gt;integer type&lt;/a&gt; (char, signed or unsigned integer, or enumeration)</source>
          <target state="translated">cualquier &lt;a href=&quot;expressions&quot;&gt;expresi&amp;oacute;n&lt;/a&gt; de &lt;a href=&quot;compatible_type#Type_groups&quot;&gt;tipo entero&lt;/a&gt; (char, entero con signo o sin signo, o enumeraci&amp;oacute;n)</target>
        </trans-unit>
        <trans-unit id="be8381985b79c4f4f883852f84f08e64e5da8fc7" translate="yes" xml:space="preserve">
          <source>any &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; of &lt;a href=&quot;compatible_type#Type_groups&quot;&gt;scalar type&lt;/a&gt; (unless type-name is void, in which case it can be anything)</source>
          <target state="translated">cualquier &lt;a href=&quot;expressions&quot;&gt;expresi&amp;oacute;n&lt;/a&gt; de &lt;a href=&quot;compatible_type#Type_groups&quot;&gt;tipo escalar&lt;/a&gt; (a menos que el nombre de tipo sea nulo, en cuyo caso puede ser cualquier cosa)</target>
        </trans-unit>
        <trans-unit id="06f41d2a748f820ab4b0d60d234ee6447b5c7b2a" translate="yes" xml:space="preserve">
          <source>any &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; of &lt;a href=&quot;compatible_type#Type_groups&quot;&gt;scalar type&lt;/a&gt;. This expression is evaluated after each iteration, and if it compares equal to zero, the loop is exited.</source>
          <target state="translated">cualquier &lt;a href=&quot;expressions&quot;&gt;expresi&amp;oacute;n&lt;/a&gt; de &lt;a href=&quot;compatible_type#Type_groups&quot;&gt;tipo escalar&lt;/a&gt; . Esta expresi&amp;oacute;n se eval&amp;uacute;a despu&amp;eacute;s de cada iteraci&amp;oacute;n, y si se compara igual a cero, se sale del bucle.</target>
        </trans-unit>
        <trans-unit id="274e302869fbb27c30f2b86fea297b58e8fe8144" translate="yes" xml:space="preserve">
          <source>any &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; of &lt;a href=&quot;compatible_type#Type_groups&quot;&gt;scalar type&lt;/a&gt;. This expression is evaluated before each iteration, and if it compares equal to zero, the loop is exited.</source>
          <target state="translated">cualquier &lt;a href=&quot;expressions&quot;&gt;expresi&amp;oacute;n&lt;/a&gt; de &lt;a href=&quot;compatible_type#Type_groups&quot;&gt;tipo escalar&lt;/a&gt; . Esta expresi&amp;oacute;n se eval&amp;uacute;a antes de cada iteraci&amp;oacute;n, y si se compara igual a cero, se sale del bucle.</target>
        </trans-unit>
        <trans-unit id="289a2cbed49e869ef41824f6c67f9fe6d378b421" translate="yes" xml:space="preserve">
          <source>any &lt;a href=&quot;statements&quot;&gt;statement&lt;/a&gt; (typically a compound statement). &lt;code&gt;case:&lt;/code&gt; and &lt;code&gt;default:&lt;/code&gt; labels are permitted in statement, and &lt;code&gt;break;&lt;/code&gt; statement has special meaning.</source>
          <target state="translated">cualquier &lt;a href=&quot;statements&quot;&gt;declaraci&amp;oacute;n&lt;/a&gt; (t&amp;iacute;picamente una declaraci&amp;oacute;n compuesta). &lt;code&gt;case:&lt;/code&gt; y &lt;code&gt;default:&lt;/code&gt; las etiquetas est&amp;aacute;n permitidas en la declaraci&amp;oacute;n y &lt;code&gt;break;&lt;/code&gt; declaraci&amp;oacute;n tiene un significado especial.</target>
        </trans-unit>
        <trans-unit id="ff8f57a6fc50c3b928eca64028a6f3e218dfa5cd" translate="yes" xml:space="preserve">
          <source>any &lt;a href=&quot;statements&quot;&gt;statement&lt;/a&gt;, typically a compound statement, which is the body of the loop</source>
          <target state="translated">cualquier &lt;a href=&quot;statements&quot;&gt;declaraci&amp;oacute;n&lt;/a&gt; , t&amp;iacute;picamente una declaraci&amp;oacute;n compuesta, que es el cuerpo del bucle</target>
        </trans-unit>
        <trans-unit id="6160f2d70f309150cc39956b7333bdabe9e3c566" translate="yes" xml:space="preserve">
          <source>any &lt;a href=&quot;statements&quot;&gt;statement&lt;/a&gt;, typically a compound statement, which serves as the body of the loop</source>
          <target state="translated">cualquier &lt;a href=&quot;statements&quot;&gt;declaraci&amp;oacute;n&lt;/a&gt; , t&amp;iacute;picamente una declaraci&amp;oacute;n compuesta, que sirve como el cuerpo del bucle</target>
        </trans-unit>
        <trans-unit id="d5f530d35571677a796141f3d891df4b848b98e2" translate="yes" xml:space="preserve">
          <source>any &lt;a href=&quot;string_literal&quot;&gt;string literal&lt;/a&gt;</source>
          <target state="translated">cualquier &lt;a href=&quot;string_literal&quot;&gt;cadena literal&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c3a06491365351f3135fa57adca77cdbb5bb55da" translate="yes" xml:space="preserve">
          <source>any cast expression (note that compound literals, which look similar, are lvalues)</source>
          <target state="translated">cualquier expresión de reparto (nótese que los literales compuestos,que se ven similares,son valores l)</target>
        </trans-unit>
        <trans-unit id="edf8667431a1e779cde6bdce47ba00aaaafd8be3" translate="yes" xml:space="preserve">
          <source>any combination of &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt;, &lt;a href=&quot;restrict&quot;&gt;restrict&lt;/a&gt;, or &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt; qualifiers, only allowed in function parameter lists; this qualifies the pointer type to which this array parameter is transformed</source>
          <target state="translated">cualquier combinaci&amp;oacute;n de calificadores &lt;a href=&quot;const&quot;&gt;constantes&lt;/a&gt; , &lt;a href=&quot;restrict&quot;&gt;restringidos&lt;/a&gt; o &lt;a href=&quot;volatile&quot;&gt;vol&amp;aacute;tiles&lt;/a&gt; , solo permitidos en las listas de par&amp;aacute;metros de funciones; esto califica el tipo de puntero al que se transforma este par&amp;aacute;metro de matriz</target>
        </trans-unit>
        <trans-unit id="cbe45f6357925029ecee21a95f05d973c784b3fa" translate="yes" xml:space="preserve">
          <source>any complete &lt;a href=&quot;compatible_type&quot;&gt;object type&lt;/a&gt; that isn't variably-modified (that is, not VLA or pointer to VLA).</source>
          <target state="translated">cualquier &lt;a href=&quot;compatible_type&quot;&gt;tipo de objeto&lt;/a&gt; completo que no se modifique de forma variable (es decir, no VLA o puntero a VLA).</target>
        </trans-unit>
        <trans-unit id="d364f2a845a6f4b4da77a65cd5239650881109ee" translate="yes" xml:space="preserve">
          <source>any expression</source>
          <target state="translated">cualquier expresión</target>
        </trans-unit>
        <trans-unit id="efae355cfebbfc312e651b7bece35ca4f1afee8f" translate="yes" xml:space="preserve">
          <source>any expression (except for the &lt;a href=&quot;operator_other#Comma_operator&quot;&gt;comma operator&lt;/a&gt;) of any type and value category</source>
          <target state="translated">cualquier expresi&amp;oacute;n (excepto el &lt;a href=&quot;operator_other#Comma_operator&quot;&gt;operador de coma&lt;/a&gt; ) de cualquier tipo y categor&amp;iacute;a de valor</target>
        </trans-unit>
        <trans-unit id="e4266fde639a4ad2a2c6e4530bc1873de5bec3c9" translate="yes" xml:space="preserve">
          <source>any expression (except for the &lt;a href=&quot;operator_other#Comma_operator&quot;&gt;comma operator&lt;/a&gt;) whose type must be compatible with one of the type-names if the &lt;code&gt;default&lt;/code&gt; association is not used</source>
          <target state="translated">cualquier expresi&amp;oacute;n (excepto el &lt;a href=&quot;operator_other#Comma_operator&quot;&gt;operador de coma&lt;/a&gt; ) cuyo tipo debe ser compatible con uno de los nombres de tipo si no se utiliza la asociaci&amp;oacute;n &lt;code&gt;default&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ae479c7422b7687a645ec839ada30bfea7332b70" translate="yes" xml:space="preserve">
          <source>any expression of pointer-to-function type (after &lt;a href=&quot;conversion#Lvalue_conversions&quot;&gt;lvalue conversions&lt;/a&gt;)</source>
          <target state="translated">cualquier expresi&amp;oacute;n de tipo puntero a funci&amp;oacute;n (despu&amp;eacute;s de las &lt;a href=&quot;conversion#Lvalue_conversions&quot;&gt;conversiones de valor&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="baffd80eccda4b18e67a2afbc7b772a872267bab" translate="yes" xml:space="preserve">
          <source>any expression other than &lt;a href=&quot;operator_other#Comma_operator&quot;&gt;comma operator&lt;/a&gt;, designates the number of elements in the array</source>
          <target state="translated">cualquier expresi&amp;oacute;n que no sea &lt;a href=&quot;operator_other#Comma_operator&quot;&gt;operador de coma&lt;/a&gt; , designa el n&amp;uacute;mero de elementos en la matriz</target>
        </trans-unit>
        <trans-unit id="c84440a43394480ce95b6f58815357f35ade0d15" translate="yes" xml:space="preserve">
          <source>any expression other than another comma operator (in other words, comma operator's &lt;a href=&quot;operator_precedence&quot;&gt;associativity&lt;/a&gt; is left-to-right)</source>
          <target state="translated">cualquier expresi&amp;oacute;n que no sea otro operador de coma (en otras palabras, la &lt;a href=&quot;operator_precedence&quot;&gt;asociatividad&lt;/a&gt; del operador de coma es de izquierda a derecha)</target>
        </trans-unit>
        <trans-unit id="eed48d916d76a9379a8f2ebc1afbce301f417fd2" translate="yes" xml:space="preserve">
          <source>any function call expression</source>
          <target state="translated">cualquier expresión de llamada de función</target>
        </trans-unit>
        <trans-unit id="b0848b3f1b7b548a5a86bee48ad1b2613e0ed23f" translate="yes" xml:space="preserve">
          <source>any identifier that appears in a parameter list that could be treated as a typedef name or as a parameter name is treated as a typedef name: &lt;code&gt;int f(&lt;a href=&quot;../types/size_t&quot;&gt;size_t&lt;/a&gt;, &lt;a href=&quot;../types/integer&quot;&gt;uintptr_t&lt;/a&gt;)&lt;/code&gt; is parsed as a new-style declarator for a function taking two unnamed parameters of type size_t and uintptr_t, not an old-style declarator that begins the definition of a function taking two parameters named &quot;size_t&quot; and &quot;uintptr_t&quot;</source>
          <target state="translated">cualquier identificador que aparece en una lista de par&amp;aacute;metros que podr&amp;iacute;a tratarse como un nombre de typedef o como un nombre de par&amp;aacute;metro se trata como un nombre de typedef: &lt;code&gt;int f(&lt;a href=&quot;../types/size_t&quot;&gt;size_t&lt;/a&gt;, &lt;a href=&quot;../types/integer&quot;&gt;uintptr_t&lt;/a&gt;)&lt;/code&gt; se analiza como un nuevo declarador de estilo para una funci&amp;oacute;n que toma dos par&amp;aacute;metros sin nombre de tipo size_t y uintptr_t, no un declarador de estilo antiguo que comienza la definici&amp;oacute;n de una funci&amp;oacute;n que toma dos par&amp;aacute;metros llamados &quot;size_t&quot; y &quot;uintptr_t&quot;</target>
        </trans-unit>
        <trans-unit id="faab3a1343209dbb605e46853e2150f406236f5f" translate="yes" xml:space="preserve">
          <source>any integer &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt;</source>
          <target state="translated">cualquier &lt;a href=&quot;constant_expression&quot;&gt;expresi&amp;oacute;n constante&lt;/a&gt; entera</target>
        </trans-unit>
        <trans-unit id="0a42a9b8586a31a43c72b8b3bf40ccd35bf216d0" translate="yes" xml:space="preserve">
          <source>any number of variable declarations, &lt;a href=&quot;bit_field&quot;&gt;bit field&lt;/a&gt; declarations, and &lt;a href=&quot;static_assert&quot;&gt;static assert&lt;/a&gt; declarations. Members of incomplete type and members of function type are not allowed (except for the flexible array member described below)</source>
          <target state="translated">cualquier n&amp;uacute;mero de declaraciones de variables, declaraciones de &lt;a href=&quot;bit_field&quot;&gt;campo de bits&lt;/a&gt; y declaraciones de &lt;a href=&quot;static_assert&quot;&gt;aserci&amp;oacute;n est&amp;aacute;tica&lt;/a&gt; . Los miembros de tipo incompleto y los miembros de tipo de funci&amp;oacute;n no est&amp;aacute;n permitidos (excepto el miembro de matriz flexible que se describe a continuaci&amp;oacute;n)</target>
        </trans-unit>
        <trans-unit id="3c6a297d6eb7cf8a88b76ca1cdba0c369a078b9a" translate="yes" xml:space="preserve">
          <source>any number of variable declarations, bit field declarations, and static assert declarations. Members of incomplete type and members of function type are not allowed.</source>
          <target state="translated">cualquier número de declaraciones variables,declaraciones de campos de bits y declaraciones de afirmación estáticas.No se permiten los miembros de tipo incompleto y los miembros de tipo de función.</target>
        </trans-unit>
        <trans-unit id="991db7190ce90937e5272c02ff09f8c835ed6bb6" translate="yes" xml:space="preserve">
          <source>any of the arguments corresponding to &lt;code&gt;%s&lt;/code&gt; is a null pointer</source>
          <target state="translated">cualquiera de los argumentos correspondientes a &lt;code&gt;%s&lt;/code&gt; es un puntero nulo</target>
        </trans-unit>
        <trans-unit id="b9761fa8c99d6412896030019b9e1f7238a8ecc1" translate="yes" xml:space="preserve">
          <source>any of the arguments of pointer type is a null pointer</source>
          <target state="translated">cualquiera de los argumentos de tipo puntero es un puntero nulo</target>
        </trans-unit>
        <trans-unit id="c931b47c239c4cdb5b5676505bab2ff58278d90b" translate="yes" xml:space="preserve">
          <source>any other expression that may be accepted by the currently installed C &lt;code&gt;locale&lt;/code&gt;</source>
          <target state="translated">cualquier otra expresi&amp;oacute;n que pueda ser aceptada por la &lt;code&gt;locale&lt;/code&gt; C actualmente instalada</target>
        </trans-unit>
        <trans-unit id="ee46d10ed7aeb7823d65780e2d60186ac6dbd911" translate="yes" xml:space="preserve">
          <source>any parameter of array type is adjusted to the corresponding pointer type, which may be qualified if there are qualifiers between the square brackets of the array declarator(since C99)</source>
          <target state="translated">cualquier parámetro del tipo de matriz se ajusta al tipo de puntero correspondiente,que puede ser calificado si hay calificadores entre los corchetes del declarador de la matriz (desde C99)</target>
        </trans-unit>
        <trans-unit id="9616ae7c6d96ecd7803690f307d2d3795f91f219" translate="yes" xml:space="preserve">
          <source>any parameter of function type is adjusted to the corresponding pointer type</source>
          <target state="translated">cualquier parámetro del tipo de función se ajusta al tipo de puntero correspondiente</target>
        </trans-unit>
        <trans-unit id="da817154a673bbb68947705f741c46db2b6e0eb1" translate="yes" xml:space="preserve">
          <source>any type other than array or function. For (1), type-name also cannot be atomic or cvr-qualified</source>
          <target state="translated">cualquier otro tipo que no sea el de la matriz o la función.Para (1),el nombre del tipo tampoco puede ser atómico o cvr-cualificado</target>
        </trans-unit>
        <trans-unit id="831fce60a83f5aaa718757021717e0ba1f826a53" translate="yes" xml:space="preserve">
          <source>any use of the pointer that was deallocated by &lt;code&gt;&lt;a href=&quot;../memory/free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../memory/realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">cualquier uso del puntero que fue desasignado por &lt;code&gt;&lt;a href=&quot;../memory/free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../memory/realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac78b022715c5b8357b4dca8045e8463b4de2124" translate="yes" xml:space="preserve">
          <source>ap</source>
          <target state="translated">ap</target>
        </trans-unit>
        <trans-unit id="db43bff34c78044870bc6b1ae2aa16902bb1bb8a" translate="yes" xml:space="preserve">
          <source>append</source>
          <target state="translated">append</target>
        </trans-unit>
        <trans-unit id="4bfbd9f07437718b73115a6a0356598c7d27a84a" translate="yes" xml:space="preserve">
          <source>append extended</source>
          <target state="translated">apéndice ampliado</target>
        </trans-unit>
        <trans-unit id="cea4e18dac8b6b256584c24f08f1c66e6c79b375" translate="yes" xml:space="preserve">
          <source>appends a certain amount of wide characters from one wide string to another</source>
          <target state="translated">añade una cierta cantidad de caracteres anchos de una cadena ancha a otra</target>
        </trans-unit>
        <trans-unit id="1975c46fbfd68df17ca6344eed23e3a6512c750c" translate="yes" xml:space="preserve">
          <source>appends a copy of one wide string to another</source>
          <target state="translated">añade una copia de una cuerda ancha a otra</target>
        </trans-unit>
        <trans-unit id="df903074f885f1f15c3daa6ce45002105c249232" translate="yes" xml:space="preserve">
          <source>arbitrary hexadecimal value</source>
          <target state="translated">valor hexadecimal arbitrario</target>
        </trans-unit>
        <trans-unit id="4369a0f24ae39fbe536286ba71dd880472aa2770" translate="yes" xml:space="preserve">
          <source>arbitrary octal value</source>
          <target state="translated">valor octal arbitrario</target>
        </trans-unit>
        <trans-unit id="04d6e2b300911995efa37b6707fdc02975a3021c" translate="yes" xml:space="preserve">
          <source>arg</source>
          <target state="translated">arg</target>
        </trans-unit>
        <trans-unit id="8e52a50224511e55b3cb5a078473fdd0e08a5b1e" translate="yes" xml:space="preserve">
          <source>arg-1</source>
          <target state="translated">arg-1</target>
        </trans-unit>
        <trans-unit id="da7228e374c9c5c17ac8a45e24698a76423635ad" translate="yes" xml:space="preserve">
          <source>argc</source>
          <target state="translated">argc</target>
        </trans-unit>
        <trans-unit id="846a4bbd93bdd85706d5de7416afac88a45f8ae8" translate="yes" xml:space="preserve">
          <source>argument list in a function call</source>
          <target state="translated">lista de argumentos en una llamada de función</target>
        </trans-unit>
        <trans-unit id="9d12281d0d35ef85c73f95929507c005a2287e93" translate="yes" xml:space="preserve">
          <source>argument to fseek() indicating seeking from beginning of the file</source>
          <target state="translated">argumento para fseek()que indica la búsqueda desde el principio del expediente</target>
        </trans-unit>
        <trans-unit id="72786d66722ca4b98208afbe41b8eb11812480a7" translate="yes" xml:space="preserve">
          <source>argument to fseek() indicating seeking from end of the file</source>
          <target state="translated">argumento para fseek()que indica la búsqueda desde el final del archivo</target>
        </trans-unit>
        <trans-unit id="d32b6d5580bb50f023a54f00203dfa3201f6ec89" translate="yes" xml:space="preserve">
          <source>argument to fseek() indicating seeking from the current file position</source>
          <target state="translated">argumento para fseek()que indica la búsqueda desde la posición actual del archivo</target>
        </trans-unit>
        <trans-unit id="8d8716aaf8f6527ddb092f5a0c7a3b4f6d8fb6e3" translate="yes" xml:space="preserve">
          <source>argument to pass to the function</source>
          <target state="translated">argumento para pasar a la función</target>
        </trans-unit>
        <trans-unit id="d3bea05ca57a72f813079e31c799c8fa9aec7206" translate="yes" xml:space="preserve">
          <source>argument to setvbuf() indicating fully buffered I/O</source>
          <target state="translated">el argumento de setvbuf()que indica una E/S totalmente amortiguada</target>
        </trans-unit>
        <trans-unit id="9eb617945b0b4d913edf162e7b8270404a7289c2" translate="yes" xml:space="preserve">
          <source>argument to setvbuf() indicating line buffered I/O</source>
          <target state="translated">argumento para setvbuf()que indica la línea de E/S del buffer</target>
        </trans-unit>
        <trans-unit id="7602f5fc169b6cee652722ddadfdd64b78e9e442" translate="yes" xml:space="preserve">
          <source>argument to setvbuf() indicating unbuffered I/O</source>
          <target state="translated">argumento para setvbuf()que indica E/S sin amortiguador</target>
        </trans-unit>
        <trans-unit id="cfb1965acdbb56f90805167da69ff708224ab176" translate="yes" xml:space="preserve">
          <source>argument-list</source>
          <target state="translated">argument-list</target>
        </trans-unit>
        <trans-unit id="536f158f6dfd529865dcb865a97bb16804e34d70" translate="yes" xml:space="preserve">
          <source>arguments</source>
          <target state="translated">arguments</target>
        </trans-unit>
        <trans-unit id="6a0f14dd3cb378d1b2fb76510dc53f503afdcc59" translate="yes" xml:space="preserve">
          <source>arguments (depends on the instruction)</source>
          <target state="translated">argumentos (depende de la instrucción)</target>
        </trans-unit>
        <trans-unit id="e2dac687442a0397e2099f1e6330fa3064360636" translate="yes" xml:space="preserve">
          <source>arguments specifying data to print. If any argument after &lt;a href=&quot;../language/conversion#Default_argument_promotions&quot;&gt;default argument promotions&lt;/a&gt; is not the type expected by the corresponding conversion specifier, or if there are fewer arguments than required by &lt;code&gt;format&lt;/code&gt;, the behavior is undefined. If there are more arguments than required by &lt;code&gt;format&lt;/code&gt;, the extraneous arguments are evaluated and ignored</source>
          <target state="translated">argumentos que especifican datos para imprimir. Si alg&amp;uacute;n argumento despu&amp;eacute;s de las &lt;a href=&quot;../language/conversion#Default_argument_promotions&quot;&gt;promociones de argumento predeterminado&lt;/a&gt; no es el tipo esperado por el especificador de conversi&amp;oacute;n correspondiente, o si hay menos argumentos que los requeridos por el &lt;code&gt;format&lt;/code&gt; o , el comportamiento es indefinido. Si hay m&amp;aacute;s argumentos que los requeridos por el &lt;code&gt;format&lt;/code&gt; o , los argumentos extra&amp;ntilde;os se eval&amp;uacute;an e ignoran</target>
        </trans-unit>
        <trans-unit id="ded1eaca9edf12b71d324d9950a6c8f3e3d7ec9a" translate="yes" xml:space="preserve">
          <source>arguments specifying data to print. If any argument after &lt;a href=&quot;../language/conversion#Default_argument_promotions&quot;&gt;default argument promotions&lt;/a&gt; is not the type expected by the corresponding conversion specifier, or if there are fewer arguments than required by &lt;code&gt;format&lt;/code&gt;, the behavior is undefined. If there are more arguments than required by &lt;code&gt;format&lt;/code&gt;, the extraneous arguments are evaluated and ignored.</source>
          <target state="translated">argumentos que especifican datos para imprimir. Si alg&amp;uacute;n argumento despu&amp;eacute;s de las &lt;a href=&quot;../language/conversion#Default_argument_promotions&quot;&gt;promociones de argumento predeterminado&lt;/a&gt; no es el tipo esperado por el especificador de conversi&amp;oacute;n correspondiente, o si hay menos argumentos que los requeridos por el &lt;code&gt;format&lt;/code&gt; o , el comportamiento es indefinido. Si hay m&amp;aacute;s argumentos que los requeridos por el &lt;code&gt;format&lt;/code&gt; o , los argumentos extra&amp;ntilde;os se eval&amp;uacute;an e ignoran.</target>
        </trans-unit>
        <trans-unit id="44fa84e333f3362a12273e855dca2caf2666100b" translate="yes" xml:space="preserve">
          <source>argv</source>
          <target state="translated">argv</target>
        </trans-unit>
        <trans-unit id="18ca194aa0f608d645500c4f2354facbbde0a13e" translate="yes" xml:space="preserve">
          <source>arithmetic</source>
          <target state="translated">arithmetic</target>
        </trans-unit>
        <trans-unit id="54fbc403ddb9a8535eac7d7846e5a6e72e05c26e" translate="yes" xml:space="preserve">
          <source>arithmetic constant expression</source>
          <target state="translated">expresión aritmética constante</target>
        </trans-unit>
        <trans-unit id="d90b72b26be74b12d744b60937fa2f214a9d2d22" translate="yes" xml:space="preserve">
          <source>array subscript</source>
          <target state="translated">subíndice de la matriz</target>
        </trans-unit>
        <trans-unit id="7cd3365ec5cd3b7bc71721ba577abbedc1bb1832" translate="yes" xml:space="preserve">
          <source>array type of unknown size. It can be completed by a later declaration that specifies the size.</source>
          <target state="translated">tipo de matriz de tamaño desconocido.Se puede completar con una declaración posterior que especifique el tamaño.</target>
        </trans-unit>
        <trans-unit id="583b8fc652f8ec109f2a1271c77b0892a560a1c2" translate="yes" xml:space="preserve">
          <source>array types</source>
          <target state="translated">Tipos de matriz...</target>
        </trans-unit>
        <trans-unit id="9c5cf9e25955aafadeb0fc934da621efb22c50c4" translate="yes" xml:space="preserve">
          <source>as a single-byte subset, consisting of the following 96 characters:</source>
          <target state="translated">como un subconjunto de un solo byte,que consiste en los siguientes 96 caracteres:</target>
        </trans-unit>
        <trans-unit id="37066ddedc42722c4e146de881569c7f636156bc" translate="yes" xml:space="preserve">
          <source>as if</source>
          <target state="translated">como si</target>
        </trans-unit>
        <trans-unit id="e4e8f5522c763f7aac74293d814587b7b51ff770" translate="yes" xml:space="preserve">
          <source>as if by assignment</source>
          <target state="translated">como si fuera por asignación</target>
        </trans-unit>
        <trans-unit id="64ea9d4459e813837e6b2d6170a333da47079360" translate="yes" xml:space="preserve">
          <source>as part of</source>
          <target state="translated">como parte de</target>
        </trans-unit>
        <trans-unit id="4d520093947381fd24996c7c477fa5ad1a40de0f" translate="yes" xml:space="preserve">
          <source>as the left-hand operand of the &lt;a href=&quot;operator_assignment&quot;&gt;assignment and compound assignment&lt;/a&gt; operators.</source>
          <target state="translated">como el operando izquierdo de los operadores de &lt;a href=&quot;operator_assignment&quot;&gt;asignaci&amp;oacute;n y asignaci&amp;oacute;n compuesta&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4ec04b9d73f6eba21c4562d845ad4aa147fdd3a1" translate="yes" xml:space="preserve">
          <source>as the left-hand operand of the &lt;a href=&quot;operator_member_access&quot;&gt;member access&lt;/a&gt; (dot) operator.</source>
          <target state="translated">como el operando de la izquierda del operador de &lt;a href=&quot;operator_member_access&quot;&gt;acceso de miembros&lt;/a&gt; (punto).</target>
        </trans-unit>
        <trans-unit id="e32116980421df3eac0e9a887ff55708bc31c675" translate="yes" xml:space="preserve">
          <source>as the operand of &lt;a href=&quot;alignof&quot;&gt;_Alignof&lt;/a&gt;</source>
          <target state="translated">como el operando de &lt;a href=&quot;alignof&quot;&gt;_Alignof&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="01ab613c21670dea20248904a5545953ef13d684" translate="yes" xml:space="preserve">
          <source>as the operand of &lt;a href=&quot;sizeof&quot;&gt;sizeof&lt;/a&gt;</source>
          <target state="translated">como el operando de &lt;a href=&quot;sizeof&quot;&gt;sizeof&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ee0201522cbd2f212d3fe577bf15df3825cc8ff2" translate="yes" xml:space="preserve">
          <source>as the operand of the &lt;a href=&quot;operator_member_access&quot;&gt;address-of operator&lt;/a&gt;</source>
          <target state="translated">como el operando de la &lt;a href=&quot;operator_member_access&quot;&gt;direcci&amp;oacute;n del operador&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0ccde22a39f66d23bee179ee345a3f26a32ed97f" translate="yes" xml:space="preserve">
          <source>as the operand of the &lt;a href=&quot;operator_member_access&quot;&gt;address-of operator&lt;/a&gt; (except if the lvalue designates a &lt;a href=&quot;bit_field&quot;&gt;bit field&lt;/a&gt; or was declared &lt;a href=&quot;storage_duration&quot;&gt;register&lt;/a&gt;).</source>
          <target state="translated">como el operando de la &lt;a href=&quot;operator_member_access&quot;&gt;direcci&amp;oacute;n del operador&lt;/a&gt; (excepto si lvalue designa un &lt;a href=&quot;bit_field&quot;&gt;campo de bit&lt;/a&gt; o fue declarado &lt;a href=&quot;storage_duration&quot;&gt;registro&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="61981e5cabd311f63537d72c30f35aa168dcd3f1" translate="yes" xml:space="preserve">
          <source>as the operand of the &lt;a href=&quot;operator_member_access&quot;&gt;address-of operator&lt;/a&gt; (if allowed)</source>
          <target state="translated">como el operando de la &lt;a href=&quot;operator_member_access&quot;&gt;direcci&amp;oacute;n del operador&lt;/a&gt; (si est&amp;aacute; permitido)</target>
        </trans-unit>
        <trans-unit id="f8ff5014bfefda97f58711957a14dd50eb553afd" translate="yes" xml:space="preserve">
          <source>as the operand of the pre/post &lt;a href=&quot;operator_incdec&quot;&gt;increment and decrement operators&lt;/a&gt;.</source>
          <target state="translated">como el operando de los &lt;a href=&quot;operator_incdec&quot;&gt;operadores de incremento y decremento&lt;/a&gt; pre / post .</target>
        </trans-unit>
        <trans-unit id="edbd39f8302a9536a17e0200de5a48a17788a7f2" translate="yes" xml:space="preserve">
          <source>as the string literal used for &lt;a href=&quot;array_initialization&quot;&gt;array initialization&lt;/a&gt;</source>
          <target state="translated">como el literal de cadena utilizado para la &lt;a href=&quot;array_initialization&quot;&gt;inicializaci&amp;oacute;n de la matriz&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7fd4ec431b19760a17e098545249b59de85e86b2" translate="yes" xml:space="preserve">
          <source>as the type specifier in the &lt;a href=&quot;declarations&quot;&gt;declaration grammar&lt;/a&gt;:</source>
          <target state="translated">como el especificador de tipo en la &lt;a href=&quot;declarations&quot;&gt;gram&amp;aacute;tica de&lt;/a&gt; la declaraci&amp;oacute;n :</target>
        </trans-unit>
        <trans-unit id="10b28a347a252156b936f911d1cc72e64542d263" translate="yes" xml:space="preserve">
          <source>asctime, asctime_s</source>
          <target state="translated">asctime,asctime_s</target>
        </trans-unit>
        <trans-unit id="42142bd98fb9dd05c15c3597bae5919f33b72f04" translate="yes" xml:space="preserve">
          <source>asctime_s</source>
          <target state="translated">asctime_s</target>
        </trans-unit>
        <trans-unit id="2344ecbfe0be5e18554e8a8e920e86bed313503e" translate="yes" xml:space="preserve">
          <source>asctimeasctime_s</source>
          <target state="translated">asctimeasctime_s</target>
        </trans-unit>
        <trans-unit id="f6b3e9a1435d3f432e7a6b9003583871fcb26de3" translate="yes" xml:space="preserve">
          <source>asin</source>
          <target state="translated">asin</target>
        </trans-unit>
        <trans-unit id="87ef31809f8e6b00b30d4d5688627671939aeffb" translate="yes" xml:space="preserve">
          <source>asin(iz)</source>
          <target state="translated">asin(iz)</target>
        </trans-unit>
        <trans-unit id="c5ba758985d5a60f7caa44c3627a9bdad1ebbe2c" translate="yes" xml:space="preserve">
          <source>asin, asinf, asinl</source>
          <target state="translated">asin,asinf,asinl</target>
        </trans-unit>
        <trans-unit id="cc750b867f9dc58a4f03be277005b693adb6882e" translate="yes" xml:space="preserve">
          <source>asinasinfasinl</source>
          <target state="translated">asinasinfasinl</target>
        </trans-unit>
        <trans-unit id="d7d3dd685f3472024a78ef2982b478006acd6afc" translate="yes" xml:space="preserve">
          <source>asinh</source>
          <target state="translated">asinh</target>
        </trans-unit>
        <trans-unit id="98f5c9543105e3c4710f893fe6513249d1460b35" translate="yes" xml:space="preserve">
          <source>asinh, asinhf, asinhl</source>
          <target state="translated">asinh,asinhf,asinhl</target>
        </trans-unit>
        <trans-unit id="c992c5efc8f80141b44689f0e07c943fb9a30aa8" translate="yes" xml:space="preserve">
          <source>asinhasinhfasinhl</source>
          <target state="translated">asinhasinhfasinhl</target>
        </trans-unit>
        <trans-unit id="48cf2dd5233a6f36a4e6889905ffcff6691267da" translate="yes" xml:space="preserve">
          <source>asinhl</source>
          <target state="translated">asinhl</target>
        </trans-unit>
        <trans-unit id="e64a2f83388bdb9b16130ec9cd1a83a7f7338b24" translate="yes" xml:space="preserve">
          <source>asinl</source>
          <target state="translated">asinl</target>
        </trans-unit>
        <trans-unit id="64b5daad5073849378993ba34e058d7008293097" translate="yes" xml:space="preserve">
          <source>assert</source>
          <target state="translated">assert</target>
        </trans-unit>
        <trans-unit id="f26b63d628c9b5679c54e6f8f5ee244932da2d7d" translate="yes" xml:space="preserve">
          <source>assignment</source>
          <target state="translated">assignment</target>
        </trans-unit>
        <trans-unit id="f494b88f97fbaa7c60689f58dce7974ecb8e3e4c" translate="yes" xml:space="preserve">
          <source>assignment and compound assignment operators (note: they are lvalues in C++)</source>
          <target state="translated">operadores de asignación y de asignación compuesta (nota:son valores l en C++)</target>
        </trans-unit>
        <trans-unit id="7d752f2c5e9504352a8b5051da82d8c592e4d092" translate="yes" xml:space="preserve">
          <source>asynchronous</source>
          <target state="translated">asynchronous</target>
        </trans-unit>
        <trans-unit id="b4e380389a774a586c5fa16ad6f747ccd0f5dd49" translate="yes" xml:space="preserve">
          <source>at least</source>
          <target state="translated">al menos</target>
        </trans-unit>
        <trans-unit id="575f12d548b9fd6af3f0619c3c5f99b4dc5da351" translate="yes" xml:space="preserve">
          <source>at least 8, 16, 32 and 64 bits respectively</source>
          <target state="translated">al menos 8,16,32 y 64 bits respectivamente</target>
        </trans-unit>
        <trans-unit id="4b3167c14955e1f3fea9853d7148dcb75a62f7ab" translate="yes" xml:space="preserve">
          <source>at_quick_exit</source>
          <target state="translated">at_quick_exit</target>
        </trans-unit>
        <trans-unit id="f077504d04fa1bc96b042497b434fd33fabdf43d" translate="yes" xml:space="preserve">
          <source>atan</source>
          <target state="translated">atan</target>
        </trans-unit>
        <trans-unit id="fd281638c28da6a30c5b0c730c9b9ec0d88cba4c" translate="yes" xml:space="preserve">
          <source>atan(iz)</source>
          <target state="translated">atan(iz)</target>
        </trans-unit>
        <trans-unit id="df7e2494fec8f83d2e63521682db3853590fe40a" translate="yes" xml:space="preserve">
          <source>atan, atanf, atanl</source>
          <target state="translated">atan,atanf,atanl</target>
        </trans-unit>
        <trans-unit id="b1a7357ef61ecd1781b4633dc3e33a383686041c" translate="yes" xml:space="preserve">
          <source>atan2</source>
          <target state="translated">atan2</target>
        </trans-unit>
        <trans-unit id="208f110d2774b4f5fad38662ea6cc831171dabd6" translate="yes" xml:space="preserve">
          <source>atan2, atan2f, atan2l</source>
          <target state="translated">atan2,atan2f,atan2l</target>
        </trans-unit>
        <trans-unit id="b957cefd959bb1c4b5fdb50a314397923487008a" translate="yes" xml:space="preserve">
          <source>atan2atan2fatan2l</source>
          <target state="translated">atan2atan2fatan2l</target>
        </trans-unit>
        <trans-unit id="a02e2f7a37d63971c98216ff7f3b3373699aed5f" translate="yes" xml:space="preserve">
          <source>atan2l</source>
          <target state="translated">atan2l</target>
        </trans-unit>
        <trans-unit id="1cbecfd27a902ae767327ccf26fc508a471b1941" translate="yes" xml:space="preserve">
          <source>atanatanfatanl</source>
          <target state="translated">atanatanfatanl</target>
        </trans-unit>
        <trans-unit id="7684baa497f7669edce3de05984655b59aa5aa40" translate="yes" xml:space="preserve">
          <source>atanh</source>
          <target state="translated">atanh</target>
        </trans-unit>
        <trans-unit id="b065796585ecb12f9248b5ff7df8c24a8b656516" translate="yes" xml:space="preserve">
          <source>atanh, atanhf, atanhl</source>
          <target state="translated">atanh,atanhf,atanhl</target>
        </trans-unit>
        <trans-unit id="0b67f8cc63e7d4d66ac6071e6d9132e68a8b95f5" translate="yes" xml:space="preserve">
          <source>atanhatanhfatanhl</source>
          <target state="translated">atanhatanhfatanhl</target>
        </trans-unit>
        <trans-unit id="61a1ff3103217455c2b8717c437b50d092665e93" translate="yes" xml:space="preserve">
          <source>atanhl</source>
          <target state="translated">atanhl</target>
        </trans-unit>
        <trans-unit id="7beedb8b23716296e0856ec53d68f95fd1f612b5" translate="yes" xml:space="preserve">
          <source>atanl</source>
          <target state="translated">atanl</target>
        </trans-unit>
        <trans-unit id="3853b2fd4c89603fc8835e3e1228e431622c9270" translate="yes" xml:space="preserve">
          <source>atexit</source>
          <target state="translated">atexit</target>
        </trans-unit>
        <trans-unit id="6017383f8fbd1471aeeef3234b4ca0a2acb5156d" translate="yes" xml:space="preserve">
          <source>atof</source>
          <target state="translated">atof</target>
        </trans-unit>
        <trans-unit id="a8abc8e1d18caf883d0fd33d6b1b317350c0f37c" translate="yes" xml:space="preserve">
          <source>atoi, atol, atoll</source>
          <target state="translated">atoi,atolón,atolón</target>
        </trans-unit>
        <trans-unit id="c6ad2fc918927ced018e6fe7d948a7ec0fc7ebff" translate="yes" xml:space="preserve">
          <source>atoiatolatoll</source>
          <target state="translated">atoiatolatoll</target>
        </trans-unit>
        <trans-unit id="e154f040d1ad0ab5670d0c3b9dbdf20b2124451d" translate="yes" xml:space="preserve">
          <source>atoll</source>
          <target state="translated">atoll</target>
        </trans-unit>
        <trans-unit id="d20a53d0c79d0d5837445d462c94138fc6bdcc80" translate="yes" xml:space="preserve">
          <source>atomic addition</source>
          <target state="translated">la adición atómica</target>
        </trans-unit>
        <trans-unit id="88e6625eb34f1cb363273fcd051629eb11f3189c" translate="yes" xml:space="preserve">
          <source>atomic bitwise AND</source>
          <target state="translated">atómico bituminoso Y</target>
        </trans-unit>
        <trans-unit id="5abaebd8a55922cfeed40c417f35cf1942167bdc" translate="yes" xml:space="preserve">
          <source>atomic bitwise OR</source>
          <target state="translated">atómico bituminoso O</target>
        </trans-unit>
        <trans-unit id="56f9564609953b60799326151b1ff80328fe5b5f" translate="yes" xml:space="preserve">
          <source>atomic bitwise exclusive OR</source>
          <target state="translated">atómico bituminoso exclusivo O</target>
        </trans-unit>
        <trans-unit id="922ee459c2e6d7d2fbf1dfd8439b5ffa40fe41b9" translate="yes" xml:space="preserve">
          <source>atomic functions from &lt;a href=&quot;../atomic&quot;&gt;stdatomic.h&lt;/a&gt; if the atomic arguments are lock-free</source>
          <target state="translated">funciones at&amp;oacute;micas de &lt;a href=&quot;../atomic&quot;&gt;stdatomic.h&lt;/a&gt; si los argumentos at&amp;oacute;micos no tienen bloqueo</target>
        </trans-unit>
        <trans-unit id="a7a9594db0c1ccde731b4b620cec456ded6b35b4" translate="yes" xml:space="preserve">
          <source>atomic subtraction</source>
          <target state="translated">sustracción atómica</target>
        </trans-unit>
        <trans-unit id="054e1dc1b63cbf780ada25cf4b64c89fc6cada8b" translate="yes" xml:space="preserve">
          <source>atomic type specifier and qualifier</source>
          <target state="translated">especificador y calificador de tipo atómico</target>
        </trans-unit>
        <trans-unit id="b5e5e6ab0f5460b564fd920ffd02d7dda388fdc6" translate="yes" xml:space="preserve">
          <source>atomic types</source>
          <target state="translated">los tipos atómicos</target>
        </trans-unit>
        <trans-unit id="5aa17b861e9de9a72a9231f8e499e91b8c772f38" translate="yes" xml:space="preserve">
          <source>atomic_compare_exchange_strongatomic_compare_exchange_strong_explicitatomic_compare_exchange_weakatomic_compare_exchange_weak_explicit</source>
          <target state="translated">atomic_compare_exchange_strongatomic_compare_exchange_strong_explicitatomic_compare_exchange_weakatomic_compare_exchange_weak_explicit</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
