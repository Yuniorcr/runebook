<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="tensorflow">
    <body>
      <group id="tensorflow">
        <trans-unit id="af423eb943d44142b4ba2df380bb45f9370ab357" translate="yes" xml:space="preserve">
          <source>This is useful to eliminate per-test boilerplate when context managers are used. For example, instead of decorating every test with &lt;code&gt;@mock.patch&lt;/code&gt;, simply do &lt;code&gt;self.foo = self.enter_context(mock.patch(...))' in&lt;/code&gt;setUp()`.</source>
          <target state="translated">Esto es &amp;uacute;til para eliminar el texto est&amp;aacute;ndar por prueba cuando se utilizan administradores de contexto. Por ejemplo, en lugar de decorar cada prueba con &lt;code&gt;@mock.patch&lt;/code&gt; , simplemente haz &lt;code&gt;self.foo = self.enter_context(mock.patch(...))' in&lt;/code&gt; setUp () `.</target>
        </trans-unit>
        <trans-unit id="2f67d0f15d4bd847d95e4812f46c68a7b2ce669c" translate="yes" xml:space="preserve">
          <source>This is useful to mitigate overfitting (you could see it as a form of random data augmentation). Gaussian Noise (GS) is a natural choice as corruption process for real valued inputs.</source>
          <target state="translated">Esto es útil para mitigar la sobrecarga (se podría considerar como una forma de aumento de datos aleatorios).El Ruido Gaussiano (GS)es una elección natural como proceso de corrupción para las entradas de valor real.</target>
        </trans-unit>
        <trans-unit id="0a10808c724fd5007563891cae49997723f67e26" translate="yes" xml:space="preserve">
          <source>This is useful when starting a dedicated dispatch process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16e0781bd49ec3a98f90bdf48daf84789ac4527c" translate="yes" xml:space="preserve">
          <source>This is useful when starting a dedicated worker process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d38a2f7346a2a0766d59c6174961d13ece4817fb" translate="yes" xml:space="preserve">
          <source>This is useful when validating the result of a broadcasting operation when the tensors do not have statically known shapes.</source>
          <target state="translated">Esto es útil para validar el resultado de una operación de radiodifusión cuando los tensores no tienen formas estáticamente conocidas.</target>
        </trans-unit>
        <trans-unit id="50937613d6e3934b243fbeba16769c301a7b4618" translate="yes" xml:space="preserve">
          <source>This is useful when validating the result of a broadcasting operation when the tensors have statically known shapes.</source>
          <target state="translated">Esto es útil para validar el resultado de una operación de radiodifusión cuando los tensores tienen formas estáticamente conocidas.</target>
        </trans-unit>
        <trans-unit id="d56f48520fc92b32fe411b251279af631392c0d0" translate="yes" xml:space="preserve">
          <source>This is useful when you need to extract a subset of slices in an &lt;code&gt;IndexedSlices&lt;/code&gt; object.</source>
          <target state="translated">Esto es &amp;uacute;til cuando necesita extraer un subconjunto de cortes en un objeto &lt;code&gt;IndexedSlices&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7324163610c415fe69e9edf14d1514614e0096c2" translate="yes" xml:space="preserve">
          <source>This is where the layer's logic lives.</source>
          <target state="translated">Aquí es donde vive la lógica de la capa.</target>
        </trans-unit>
        <trans-unit id="51b266b637bd972731e9b8ded931808387760c03" translate="yes" xml:space="preserve">
          <source>This iterator-constructing method can be used to create an iterator that is reusable with many different datasets.</source>
          <target state="translated">Este método de construcción de iteradores puede utilizarse para crear un iterador que sea reutilizable con muchos conjuntos de datos diferentes.</target>
        </trans-unit>
        <trans-unit id="e4b84ee23970a9ba1fae231b7f3281c7ddfd3c7d" translate="yes" xml:space="preserve">
          <source>This kernel op implements the following mathematical equations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6651501cdbb63552c7881c732a891c9b596e4cd4" translate="yes" xml:space="preserve">
          <source>This layer can add rows and columns of zeros at the top, bottom, left and right side of an image tensor.</source>
          <target state="translated">Esta capa puede añadir filas y columnas de ceros en la parte superior,inferior,izquierda y derecha de un tensor de imagen.</target>
        </trans-unit>
        <trans-unit id="c8f7de7a90e40a1acb832cfeb3e997b1fdd42909" translate="yes" xml:space="preserve">
          <source>This layer can be called multiple times with different features.</source>
          <target state="translated">Esta capa puede ser llamada varias veces con diferentes características.</target>
        </trans-unit>
        <trans-unit id="b23ebdf3426b29c2bb4017b933209c527b0b2eaf" translate="yes" xml:space="preserve">
          <source>This layer can only be used as the first layer in a model.</source>
          <target state="translated">Esta capa sólo puede ser usada como la primera capa en un modelo.</target>
        </trans-unit>
        <trans-unit id="8d2bf436fb7b0b2292ba74c82ed9e0b6359c6446" translate="yes" xml:space="preserve">
          <source>This layer can perform einsum calculations of arbitrary dimensionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28df12740051102a73475796ca5f477471a88b56" translate="yes" xml:space="preserve">
          <source>This layer concatenates multiple categorical inputs into a single categorical output (similar to Cartesian product). The output dtype is string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbd759fae81bda98338ee6eb24eac5b449a08594" translate="yes" xml:space="preserve">
          <source>This layer creates a convolution kernel that is convolved (actually cross-correlated) with the layer input to produce a tensor of outputs. If &lt;code&gt;use_bias&lt;/code&gt; is True (and a &lt;code&gt;bias_initializer&lt;/code&gt; is provided), a bias vector is created and added to the outputs. Finally, if &lt;code&gt;activation&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt;, it is applied to the outputs as well.</source>
          <target state="translated">Esta capa crea un n&amp;uacute;cleo de convoluci&amp;oacute;n que est&amp;aacute; convolucionado (en realidad, con correlaci&amp;oacute;n cruzada) con la entrada de la capa para producir un tensor de salidas. Si &lt;code&gt;use_bias&lt;/code&gt; es True (y se proporciona un &lt;code&gt;bias_initializer&lt;/code&gt; ), se crea un vector de sesgo y se agrega a las salidas. Finalmente, si la &lt;code&gt;activation&lt;/code&gt; no es &lt;code&gt;None&lt;/code&gt; , tambi&amp;eacute;n se aplica a las salidas.</target>
        </trans-unit>
        <trans-unit id="a9977284bd794456f41f5d8f8d36aed1d3801d36" translate="yes" xml:space="preserve">
          <source>This layer creates a convolution kernel that is convolved with the layer input over a single spatial (or temporal) dimension to produce a tensor of outputs. If &lt;code&gt;use_bias&lt;/code&gt; is True, a bias vector is created and added to the outputs. Finally, if &lt;code&gt;activation&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt;, it is applied to the outputs as well.</source>
          <target state="translated">Esta capa crea un n&amp;uacute;cleo de convoluci&amp;oacute;n que se convoluciona con la entrada de la capa sobre una &amp;uacute;nica dimensi&amp;oacute;n espacial (o temporal) para producir un tensor de salidas. Si &lt;code&gt;use_bias&lt;/code&gt; es True, se crea un vector de sesgo y se agrega a las salidas. Finalmente, si la &lt;code&gt;activation&lt;/code&gt; no es &lt;code&gt;None&lt;/code&gt; , tambi&amp;eacute;n se aplica a las salidas.</target>
        </trans-unit>
        <trans-unit id="d01bf01ba17a42cbf8ad8412a4cd7bfe52f00c78" translate="yes" xml:space="preserve">
          <source>This layer creates a convolution kernel that is convolved with the layer input to produce a tensor of outputs. If &lt;code&gt;use_bias&lt;/code&gt; is True, a bias vector is created and added to the outputs. Finally, if &lt;code&gt;activation&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt;, it is applied to the outputs as well.</source>
          <target state="translated">Esta capa crea un n&amp;uacute;cleo de convoluci&amp;oacute;n que se convoluciona con la entrada de la capa para producir un tensor de salidas. Si &lt;code&gt;use_bias&lt;/code&gt; es True, se crea un vector de sesgo y se agrega a las salidas. Finalmente, si la &lt;code&gt;activation&lt;/code&gt; no es &lt;code&gt;None&lt;/code&gt; , tambi&amp;eacute;n se aplica a las salidas.</target>
        </trans-unit>
        <trans-unit id="884d29443e655c08f257cc412193f76628fd846b" translate="yes" xml:space="preserve">
          <source>This layer has basic options for managing text in a Keras model. It transforms a batch of strings (one sample = one string) into either a list of token indices (one sample = 1D tensor of integer token indices) or a dense representation (one sample = 1D tensor of float values representing data about the sample's tokens).</source>
          <target state="translated">Esta capa tiene opciones básicas para manejar el texto en un modelo de Keras.Transforma un lote de cadenas (una muestra=una cadena)en una lista de índices de fichas (una muestra=tensor 1D de índices de fichas enteras)o en una representación densa (una muestra=tensor 1D de valores flotantes que representan datos sobre las fichas de la muestra).</target>
        </trans-unit>
        <trans-unit id="0b7b099051eae116bfa4a2ca036f64c30b769c6d" translate="yes" xml:space="preserve">
          <source>This layer implements a mapping from input space to a space with &lt;code&gt;output_dim&lt;/code&gt; dimensions, which approximates shift-invariant kernels. A kernel function &lt;code&gt;K(x, y)&lt;/code&gt; is shift-invariant if &lt;code&gt;K(x, y) == k(x - y)&lt;/code&gt; for some function &lt;code&gt;k&lt;/code&gt;. Many popular Radial Basis Functions (RBF), including Gaussian and Laplacian kernels, are shift-invariant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bca79ddc4abf3d361de2fa2d5bdf3c1e02faac7e" translate="yes" xml:space="preserve">
          <source>This layer implements the operation: &lt;code&gt;outputs = activation(inputs * kernel + bias)&lt;/code&gt; Where &lt;code&gt;activation&lt;/code&gt; is the activation function passed as the &lt;code&gt;activation&lt;/code&gt; argument (if not &lt;code&gt;None&lt;/code&gt;), &lt;code&gt;kernel&lt;/code&gt; is a weights matrix created by the layer, and &lt;code&gt;bias&lt;/code&gt; is a bias vector created by the layer (only if &lt;code&gt;use_bias&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;).</source>
          <target state="translated">Esta capa implementa la operaci&amp;oacute;n: &lt;code&gt;outputs = activation(inputs * kernel + bias)&lt;/code&gt; Donde &lt;code&gt;activation&lt;/code&gt; es la funci&amp;oacute;n de activaci&amp;oacute;n que se pasa como argumento de &lt;code&gt;activation&lt;/code&gt; (si no es &lt;code&gt;None&lt;/code&gt; ), el &lt;code&gt;kernel&lt;/code&gt; es una matriz de pesos creada por la capa y el &lt;code&gt;bias&lt;/code&gt; es un vector de sesgo creado por la capa (solo si &lt;code&gt;use_bias&lt;/code&gt; es &lt;code&gt;True&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="35e71e883bb0be18fa94fd4d0a457376805923f0" translate="yes" xml:space="preserve">
          <source>This layer performs a depthwise convolution that acts separately on channels, followed by a pointwise convolution that mixes channels. If &lt;code&gt;use_bias&lt;/code&gt; is True and a bias initializer is provided, it adds a bias vector to the output. It then optionally applies an activation function to produce the final output.</source>
          <target state="translated">Esta capa realiza una convoluci&amp;oacute;n en profundidad que act&amp;uacute;a por separado en los canales, seguida de una convoluci&amp;oacute;n puntual que mezcla los canales. Si &lt;code&gt;use_bias&lt;/code&gt; es True y se proporciona un inicializador de sesgo, agrega un vector de sesgo a la salida. A continuaci&amp;oacute;n, aplica opcionalmente una funci&amp;oacute;n de activaci&amp;oacute;n para producir el resultado final.</target>
        </trans-unit>
        <trans-unit id="886b50c9aa90bb61796488bc8efaa41bf9f78825" translate="yes" xml:space="preserve">
          <source>This layer provides options for condensing data into a categorical encoding. It accepts integer values as inputs and outputs a dense representation (one sample = 1-index tensor of float values representing data about the sample's tokens) of those inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47be8fc04afe99661c4ed5ab6b6d7ef9885d2eff" translate="yes" xml:space="preserve">
          <source>This layer provides options for condensing input data into denser representations. It accepts either integer values or strings as inputs, allows users to map those inputs into a contiguous integer space, and outputs either those integer values (one sample = 1D tensor of integer token indices) or a dense representation (one sample = 1D tensor of float values representing data about the sample's tokens).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="344f6b570b33a446c2eb6dc9ce40efd08ad87ee8" translate="yes" xml:space="preserve">
          <source>This layer supports masking for input data with a variable number of timesteps. To introduce masks to your data, use an [tf.keras.layers.Embedding] layer with the &lt;code&gt;mask_zero&lt;/code&gt; parameter set to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">Esta capa admite el enmascaramiento de datos de entrada con un n&amp;uacute;mero variable de pasos de tiempo. Para introducir m&amp;aacute;scaras a sus datos, utilice una capa [tf.keras.layers.Embedding] con el par&amp;aacute;metro &lt;code&gt;mask_zero&lt;/code&gt; establecido en &lt;code&gt;True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1e7b36e17487480357995623584b1cdfb115de4" translate="yes" xml:space="preserve">
          <source>This layer transforms single or multiple categorical inputs to hashed output. It converts a sequence of int or string to a sequence of int. The stable hash function uses tensorflow::ops::Fingerprint to produce universal output that is consistent across platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1b7379fe2dc54f750afe7d401d80af36bad9408" translate="yes" xml:space="preserve">
          <source>This layer translates a set of arbitrary integers into an integer output via a table-based lookup, with optional out-of-vocabulary handling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbcf3f69a06cbdc5f32560a16983b32541e31aaf" translate="yes" xml:space="preserve">
          <source>This layer translates a set of arbitrary strings into an integer output via a table-based lookup, with optional out-of-vocabulary handling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f87526b4a527a8b2c085b4914d68a929b0016554" translate="yes" xml:space="preserve">
          <source>This layer uses &lt;a href=&quot;https://github.com/google/farmhash&quot;&gt;FarmHash64&lt;/a&gt; by default, which provides a consistent hashed output across different platforms and is stable across invocations, regardless of device and context, by mixing the input bits thoroughly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="951c6b01ab8359114ccb88b8a93d70dd8a953954" translate="yes" xml:space="preserve">
          <source>This layer will coerce its inputs into a distribution centered around 0 with standard deviation 1. It accomplishes this by precomputing the mean and variance of the data, and calling (input-mean)/sqrt(var) at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe1b0f3431a8ec7d138b525163f2ad9cf543ffa7" translate="yes" xml:space="preserve">
          <source>This layer will coerce its inputs into a normal distribution centered around 0 with standard deviation 1. It accomplishes this by precomputing the mean and variance of the data, and calling (input-mean)/sqrt(var) at runtime.</source>
          <target state="translated">Esta capa forzará sus entradas en una distribución normal centrada en torno a 0 con una desviación estándar 1.Esto se logra mediante el precalculo de la media y la varianza de los datos,y llamando (input-mean)/sqrt(var)en tiempo de ejecución.</target>
        </trans-unit>
        <trans-unit id="bf78e85c045cf32b4df68b19ac70fe5f256ed641" translate="yes" xml:space="preserve">
          <source>This layer will crop all the images in the same batch to the same cropping location. By default, random cropping is only applied during training. At inference time, the images will be first rescaled to preserve the shorter side, and center cropped. If you need to apply random cropping at inference time, set &lt;code&gt;training&lt;/code&gt; to True when calling the layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc9e9462205fcd047a049604a7917fbea53a1a7d" translate="yes" xml:space="preserve">
          <source>This layer will flip the images based on the &lt;code&gt;mode&lt;/code&gt; attribute. During inference time, the output will be identical to input. Call the layer with &lt;code&gt;training=True&lt;/code&gt; to flip the input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3d352f01824e505c14a980e99a24ac05a3a55ba" translate="yes" xml:space="preserve">
          <source>This layer will place each element of its input data into one of several contiguous ranges and output an integer index indicating which range each element was placed in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbf50d844249a2e7240d57251d949994666050a2" translate="yes" xml:space="preserve">
          <source>This library contains all implementations of ClusterResolvers. ClusterResolvers are a way of specifying cluster information for distributed execution. Built on top of existing &lt;code&gt;ClusterSpec&lt;/code&gt; framework, ClusterResolvers are a way for TensorFlow to communicate with various cluster management systems (e.g. GCE, AWS, etc...).</source>
          <target state="translated">Esta biblioteca contiene todas las implementaciones de ClusterResolvers. Los ClusterResolvers son una forma de especificar la informaci&amp;oacute;n del cl&amp;uacute;ster para la ejecuci&amp;oacute;n distribuida. Construidos sobre el marco &lt;code&gt;ClusterSpec&lt;/code&gt; existente , ClusterResolvers son una forma de que TensorFlow se comunique con varios sistemas de administraci&amp;oacute;n de cl&amp;uacute;steres (por ejemplo, GCE, AWS, etc.).</target>
        </trans-unit>
        <trans-unit id="b6b2d72a41e6a38bd121d03e086a0c141b5bab2a" translate="yes" xml:space="preserve">
          <source>This makes the TensorFlow Lite interpreter accessible in Python. It is possible to use this interpreter in a multithreaded Python environment, but you must be sure to call functions of a particular instance from only one thread at a time. So if you want to have 4 threads running different inferences simultaneously, create an interpreter for each one as thread-local data. Similarly, if you are calling invoke() in one thread on a single interpreter but you want to use tensor() on another thread once it is done, you must use a synchronization primitive between the threads to ensure invoke has returned before calling tensor().</source>
          <target state="translated">Esto hace que el intérprete de TensorFlow Lite sea accesible en Python.Es posible utilizar este intérprete en un entorno Python multihilo,pero hay que asegurarse de llamar a las funciones de una instancia particular desde un solo hilo a la vez.Así que si quieres tener 4 hilos ejecutando diferentes inferencias simultáneamente,crea un intérprete para cada uno de ellos como datos locales del hilo.De forma similar,si estás llamando a invoke()en un hilo en un único intérprete pero quieres usar tensor()en otro hilo una vez que esté hecho,debes usar una primitiva de sincronización entre los hilos para asegurarte de que la invocación ha vuelto antes de llamar a tensor().</target>
        </trans-unit>
        <trans-unit id="6846fc96931fb6bb57a7f6152c9caf47e33ab2da" translate="yes" xml:space="preserve">
          <source>This makes the summary tag more predictable and consistent for the user.</source>
          <target state="translated">Esto hace que la etiqueta de resumen sea más predecible y consistente para el usuario.</target>
        </trans-unit>
        <trans-unit id="ac535677c50e98c6e0ce0364a9b0ce341c3f0a28" translate="yes" xml:space="preserve">
          <source>This matches the behavior of If and While for determining if a tensor counts as true/false for a branch condition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99fc0b3a4e959624cfdd7190647db3380c4e327c" translate="yes" xml:space="preserve">
          <source>This may be useful for checking HTML output.</source>
          <target state="translated">Esto puede ser útil para comprobar la salida del HTML.</target>
        </trans-unit>
        <trans-unit id="381d4e4134c335f7e7e4d713df90044462182059" translate="yes" xml:space="preserve">
          <source>This may occur, for example, if an operation receives an input tensor that has an invalid value or shape. For example, the &lt;a href=&quot;../linalg/matmul&quot;&gt;&lt;code&gt;tf.matmul&lt;/code&gt;&lt;/a&gt; op will raise this error if it receives an input that is not a matrix, and the &lt;a href=&quot;../reshape&quot;&gt;&lt;code&gt;tf.reshape&lt;/code&gt;&lt;/a&gt; op will raise this error if the new shape does not match the number of elements in the input tensor.</source>
          <target state="translated">Esto puede ocurrir, por ejemplo, si una operaci&amp;oacute;n recibe un tensor de entrada que tiene un valor o forma no v&amp;aacute;lidos. Por ejemplo, la &lt;a href=&quot;../linalg/matmul&quot;&gt; &lt;code&gt;tf.matmul&lt;/code&gt; &lt;/a&gt; generar&amp;aacute; este error si recibe una entrada que no es una matriz, y la &lt;a href=&quot;../reshape&quot;&gt; &lt;code&gt;tf.reshape&lt;/code&gt; &lt;/a&gt; generar&amp;aacute; este error si la nueva forma no coincide con el n&amp;uacute;mero de elementos en el tensor de entrada.</target>
        </trans-unit>
        <trans-unit id="5c451c9f3d5af265bc5daacf860461f46903194b" translate="yes" xml:space="preserve">
          <source>This may only be used inside &lt;code&gt;self.scope()&lt;/code&gt;.</source>
          <target state="translated">Esto solo se puede usar dentro de &lt;code&gt;self.scope()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8407349f1434fe18f1d4f684e5cf94ad12755be8" translate="yes" xml:space="preserve">
          <source>This means that the result of matrix multiplication &lt;code&gt;v = Au&lt;/code&gt; has &lt;code&gt;Lth&lt;/code&gt; column given circular convolution between &lt;code&gt;h&lt;/code&gt; with the &lt;code&gt;Lth&lt;/code&gt; column of &lt;code&gt;u&lt;/code&gt;.</source>
          <target state="translated">Esto significa que el resultado de la multiplicaci&amp;oacute;n de matrices &lt;code&gt;v = Au&lt;/code&gt; tiene una &lt;code&gt;Lth&lt;/code&gt; columna dada una convoluci&amp;oacute;n circular entre &lt;code&gt;h&lt;/code&gt; con la &lt;code&gt;Lth&lt;/code&gt; columna de &lt;code&gt;u&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54a591701bef9e5baac7a364b34d92ce1a314391" translate="yes" xml:space="preserve">
          <source>This means the layout when converted and saved as an image is rotated 90 degrees clockwise from a typical spectrogram. Time is descending down the Y axis, and the frequency decreases from left to right.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bac1b11600b86163afb8ed50f9d2fd7c08c803e" translate="yes" xml:space="preserve">
          <source>This method allows you to define a &quot;feedable&quot; iterator where you can choose between concrete iterators by feeding a value in a &lt;code&gt;tf.Session.run&lt;/code&gt; call. In that case, &lt;code&gt;string_handle&lt;/code&gt; would be a &lt;a href=&quot;../placeholder&quot;&gt;&lt;code&gt;tf.compat.v1.placeholder&lt;/code&gt;&lt;/a&gt;, and you would feed it with the value of &lt;code&gt;tf.data.Iterator.string_handle&lt;/code&gt; in each step.</source>
          <target state="translated">Este m&amp;eacute;todo le permite definir un iterador &quot;alimentable&quot; donde puede elegir entre iteradores concretos &lt;code&gt;tf.Session.run&lt;/code&gt; un valor en una llamada tf.Session.run . En ese caso, &lt;code&gt;string_handle&lt;/code&gt; ser&amp;iacute;a un &lt;a href=&quot;../placeholder&quot;&gt; &lt;code&gt;tf.compat.v1.placeholder&lt;/code&gt; &lt;/a&gt; , y lo alimentar&amp;iacute;as con el valor de &lt;code&gt;tf.data.Iterator.string_handle&lt;/code&gt; en cada paso.</target>
        </trans-unit>
        <trans-unit id="3ed29b40d37b37daebb7172d60a5cb7452fb1937" translate="yes" xml:space="preserve">
          <source>This method also allows multi-arity &lt;code&gt;elems&lt;/code&gt; and accumulator. If &lt;code&gt;elems&lt;/code&gt; is a (possibly nested) list or tuple of tensors, then each of these tensors must have a matching first (unpack) dimension. The second argument of &lt;code&gt;fn&lt;/code&gt; must match the structure of &lt;code&gt;elems&lt;/code&gt;.</source>
          <target state="translated">Este m&amp;eacute;todo tambi&amp;eacute;n permite &lt;code&gt;elems&lt;/code&gt; y acumuladores multi- arity . Si &lt;code&gt;elems&lt;/code&gt; es una lista (posiblemente anidada) o una tupla de tensores, entonces cada uno de estos tensores debe tener una primera dimensi&amp;oacute;n (desempaquetar) coincidente. El segundo argumento de &lt;code&gt;fn&lt;/code&gt; debe coincidir con la estructura de &lt;code&gt;elems&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11d1041ad958b2d24d55eb0ab2e6d83f39085f6b" translate="yes" xml:space="preserve">
          <source>This method also allows multi-arity &lt;code&gt;elems&lt;/code&gt; and output of &lt;code&gt;fn&lt;/code&gt;. If &lt;code&gt;elems&lt;/code&gt; is a (possibly nested) list or tuple of tensors, then each of these tensors must have a matching first (unpack) dimension. The signature of &lt;code&gt;fn&lt;/code&gt; may match the structure of &lt;code&gt;elems&lt;/code&gt;. That is, if &lt;code&gt;elems&lt;/code&gt; is &lt;code&gt;(t1, [t2, t3, [t4, t5]])&lt;/code&gt;, then an appropriate signature for &lt;code&gt;fn&lt;/code&gt; is: &lt;code&gt;fn = lambda (t1, [t2, t3, [t4, t5]]):&lt;/code&gt;.</source>
          <target state="translated">Este m&amp;eacute;todo tambi&amp;eacute;n permite &lt;code&gt;elems&lt;/code&gt; multi- arity y salida de &lt;code&gt;fn&lt;/code&gt; . Si &lt;code&gt;elems&lt;/code&gt; es una lista (posiblemente anidada) o una tupla de tensores, entonces cada uno de estos tensores debe tener una primera dimensi&amp;oacute;n (desempaquetar) coincidente. La firma de &lt;code&gt;fn&lt;/code&gt; puede coincidir con la estructura de &lt;code&gt;elems&lt;/code&gt; . Es decir, si &lt;code&gt;elems&lt;/code&gt; es &lt;code&gt;(t1, [t2, t3, [t4, t5]])&lt;/code&gt; , a continuaci&amp;oacute;n, una firma apropiada para &lt;code&gt;fn&lt;/code&gt; es: &lt;code&gt;fn = lambda (t1, [t2, t3, [t4, t5]]):&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="766a4862e3d658751f25e8ca0813b9af0856b88d" translate="yes" xml:space="preserve">
          <source>This method behaves differently than self.session(): for performance reasons &lt;code&gt;cached_session&lt;/code&gt; will by default reuse the same session within the same test. The session returned by this function will only be closed at the end of the test (in the TearDown function).</source>
          <target state="translated">Este m&amp;eacute;todo se comporta de manera diferente a self.session (): por razones de rendimiento, &lt;code&gt;cached_session&lt;/code&gt; reutilizar&amp;aacute; de forma predeterminada la misma sesi&amp;oacute;n dentro de la misma prueba. La sesi&amp;oacute;n devuelta por esta funci&amp;oacute;n solo se cerrar&amp;aacute; al final de la prueba (en la funci&amp;oacute;n TearDown).</target>
        </trans-unit>
        <trans-unit id="c7294d73f60860f63726337f7edc669a47fd434f" translate="yes" xml:space="preserve">
          <source>This method builds a new graph by first calling the &lt;code&gt;serving_input_receiver_fn&lt;/code&gt; to obtain feature &lt;code&gt;Tensor&lt;/code&gt;s, and then calling this &lt;code&gt;Estimator&lt;/code&gt;'s &lt;code&gt;model_fn&lt;/code&gt; to generate the model graph based on those features. It restores the given checkpoint (or, lacking that, the most recent checkpoint) into this graph in a fresh session. Finally it creates a timestamped export directory below the given &lt;code&gt;export_dir_base&lt;/code&gt;, and writes a &lt;code&gt;SavedModel&lt;/code&gt; into it containing a single &lt;code&gt;tf.MetaGraphDef&lt;/code&gt; saved from this session.</source>
          <target state="translated">Este m&amp;eacute;todo construye un nuevo gr&amp;aacute;fico llamando primero la &lt;code&gt;serving_input_receiver_fn&lt;/code&gt; obtener caracter&amp;iacute;stica &lt;code&gt;Tensor&lt;/code&gt; s, y despu&amp;eacute;s de llamar a este &lt;code&gt;Estimator&lt;/code&gt; 's &lt;code&gt;model_fn&lt;/code&gt; para generar el gr&amp;aacute;fico modelo basado en esas caracter&amp;iacute;sticas. Restaura el punto de control dado (o, en su defecto, el punto de control m&amp;aacute;s reciente) en este gr&amp;aacute;fico en una nueva sesi&amp;oacute;n. Finalmente, crea un directorio de exportaci&amp;oacute;n con marca de tiempo debajo de la &lt;code&gt;export_dir_base&lt;/code&gt; dada , y escribe un &lt;code&gt;SavedModel&lt;/code&gt; en &amp;eacute;l que contiene un &amp;uacute;nico &lt;code&gt;tf.MetaGraphDef&lt;/code&gt; guardado de esta sesi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c6ee7778196b7d2b41326a073f8b56a7c8a9a62d" translate="yes" xml:space="preserve">
          <source>This method can also be called directly on a Functional Model during construction. In this case, any loss Tensors passed to this Model must be symbolic and be able to be traced back to the model's &lt;code&gt;Input&lt;/code&gt;s. These losses become part of the model's topology and are tracked in &lt;code&gt;get_config&lt;/code&gt;.</source>
          <target state="translated">Este m&amp;eacute;todo tambi&amp;eacute;n se puede llamar directamente en un modelo funcional durante la construcci&amp;oacute;n. En este caso, cualquier Tensor de p&amp;eacute;rdida que se transfiera a este modelo debe ser simb&amp;oacute;lico y debe poder rastrearse hasta las &lt;code&gt;Input&lt;/code&gt; del modelo . Estas p&amp;eacute;rdidas pasan a formar parte de la topolog&amp;iacute;a del modelo y se &lt;code&gt;get_config&lt;/code&gt; en get_config .</target>
        </trans-unit>
        <trans-unit id="3e9d9d9b289f8d837ef3c68f7420c8739fcddb82" translate="yes" xml:space="preserve">
          <source>This method can also be called directly on a Functional Model during construction. In this case, any tensor passed to this Model must be symbolic and be able to be traced back to the model's &lt;code&gt;Input&lt;/code&gt;s. These metrics become part of the model's topology and are tracked when you save the model via &lt;code&gt;save()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72b1f5316c49fd45d1ca1593424ee77777a4e789" translate="yes" xml:space="preserve">
          <source>This method can be called multiple times, and will merge the given &lt;code&gt;shape&lt;/code&gt; with the current shape of this tensor. It can be used to provide additional information about the shape of this tensor that cannot be inferred from the graph alone. For example, this can be used to provide additional information about the shapes of images:</source>
          <target state="translated">Este m&amp;eacute;todo se puede llamar varias veces y fusionar&amp;aacute; la &lt;code&gt;shape&lt;/code&gt; dada con la forma actual de este tensor. Se puede utilizar para proporcionar informaci&amp;oacute;n adicional sobre la forma de este tensor que no se puede inferir solo del gr&amp;aacute;fico. Por ejemplo, esto se puede utilizar para proporcionar informaci&amp;oacute;n adicional sobre las formas de las im&amp;aacute;genes:</target>
        </trans-unit>
        <trans-unit id="312e4a6b05fc4ebb6ca2b98fbc58b54373467b4c" translate="yes" xml:space="preserve">
          <source>This method can be overridden to support custom evaluation logic. This method is called by &lt;a href=&quot;../model#evaluate&quot;&gt;&lt;code&gt;Model.evaluate&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../model#test_on_batch&quot;&gt;&lt;code&gt;Model.test_on_batch&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec15a46dc0420f052e7d9fc2485824bcb8d59546" translate="yes" xml:space="preserve">
          <source>This method can be overridden to support custom evaluation logic. This method is called by &lt;a href=&quot;../model#make_test_function&quot;&gt;&lt;code&gt;Model.make_test_function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24b263a87142b52faa1e21dbe53ee04255d04a75" translate="yes" xml:space="preserve">
          <source>This method can be overridden to support custom evaluation logic. This method is called by &lt;a href=&quot;model#evaluate&quot;&gt;&lt;code&gt;Model.evaluate&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;model#test_on_batch&quot;&gt;&lt;code&gt;Model.test_on_batch&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00b8ab943979a68d8e7d563dec5f7eda81840f4f" translate="yes" xml:space="preserve">
          <source>This method can be overridden to support custom evaluation logic. This method is called by &lt;a href=&quot;model#make_test_function&quot;&gt;&lt;code&gt;Model.make_test_function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4740c061fca2f7ba4333f6609ad3d2119d60a6e9" translate="yes" xml:space="preserve">
          <source>This method can be overridden to support custom inference logic. This method is called by &lt;a href=&quot;../model#make_predict_function&quot;&gt;&lt;code&gt;Model.make_predict_function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9231f9e258188fbf7d82d2b745ff3bd729ba7207" translate="yes" xml:space="preserve">
          <source>This method can be overridden to support custom inference logic. This method is called by &lt;a href=&quot;../model#predict&quot;&gt;&lt;code&gt;Model.predict&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../model#predict_on_batch&quot;&gt;&lt;code&gt;Model.predict_on_batch&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d12957750990229d94e78212f50e83f538705ddf" translate="yes" xml:space="preserve">
          <source>This method can be overridden to support custom inference logic. This method is called by &lt;a href=&quot;model#make_predict_function&quot;&gt;&lt;code&gt;Model.make_predict_function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ecd8d8943012dca870b082ac2069dbad2ddff8d" translate="yes" xml:space="preserve">
          <source>This method can be overridden to support custom inference logic. This method is called by &lt;a href=&quot;model#predict&quot;&gt;&lt;code&gt;Model.predict&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;model#predict_on_batch&quot;&gt;&lt;code&gt;Model.predict_on_batch&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52dfa555331eece2b509081a1f3acc2117560cba" translate="yes" xml:space="preserve">
          <source>This method can be overridden to support custom training logic. This method is called by &lt;a href=&quot;../model#fit&quot;&gt;&lt;code&gt;Model.fit&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../model#train_on_batch&quot;&gt;&lt;code&gt;Model.train_on_batch&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="655f9f9c1b7ccd7db3e5c665ed02881a9dad1b2f" translate="yes" xml:space="preserve">
          <source>This method can be overridden to support custom training logic. This method is called by &lt;a href=&quot;../model#make_train_function&quot;&gt;&lt;code&gt;Model.make_train_function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="678799c210cac42289c8d3efd485d53c6086509d" translate="yes" xml:space="preserve">
          <source>This method can be overridden to support custom training logic. This method is called by &lt;a href=&quot;model#fit&quot;&gt;&lt;code&gt;Model.fit&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;model#train_on_batch&quot;&gt;&lt;code&gt;Model.train_on_batch&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab33fe36b3e6b63aa5f9d2cddc383b1eeb7bd2db" translate="yes" xml:space="preserve">
          <source>This method can be overridden to support custom training logic. This method is called by &lt;a href=&quot;model#make_train_function&quot;&gt;&lt;code&gt;Model.make_train_function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7f74b2952869b5420047da9ad72bf8f755d938b" translate="yes" xml:space="preserve">
          <source>This method can be used after a call to &lt;a href=&quot;enable_check_numerics&quot;&gt;&lt;code&gt;tf.debugging.enable_check_numerics()&lt;/code&gt;&lt;/a&gt; to disable the numerics-checking mechanism that catches infinity and NaN values output by ops executed eagerly or in tf.function-compiled graphs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7667fea48f6e7bf7add0c54e02f390885694a1d8" translate="yes" xml:space="preserve">
          <source>This method can be used after a call to &lt;a href=&quot;enable_check_numerics&quot;&gt;&lt;code&gt;tf.debugging.enable_check_numerics()&lt;/code&gt;&lt;/a&gt; to disable the numerics-checking mechanism that catches inifnity and NaN values output by ops executed eagerly or in tf.function-compiled graphs.</source>
          <target state="translated">Este m&amp;eacute;todo se puede usar despu&amp;eacute;s de una llamada a &lt;a href=&quot;enable_check_numerics&quot;&gt; &lt;code&gt;tf.debugging.enable_check_numerics()&lt;/code&gt; &lt;/a&gt; para deshabilitar el mecanismo de verificaci&amp;oacute;n num&amp;eacute;rica que detecta los valores inifnity y NaN generados por operaciones ejecutadas con entusiasmo o en gr&amp;aacute;ficos compilados por funciones.</target>
        </trans-unit>
        <trans-unit id="ab134bc99ff08cb5e34c3578ec66ab8ee325437d" translate="yes" xml:space="preserve">
          <source>This method can be used for several purposes. For example, where &lt;code&gt;experimental_distribute_dataset&lt;/code&gt; is unable to shard the input files, this method might be used to manually shard the dataset (avoiding the slow fallback behavior in &lt;code&gt;experimental_distribute_dataset&lt;/code&gt;). In cases where the dataset is infinite, this sharding can be done by creating dataset replicas that differ only in their random seed. &lt;code&gt;experimental_distribute_dataset&lt;/code&gt; may also sometimes fail to split the batch across replicas on a worker. In that case, this method can be used where that limitation does not exist.</source>
          <target state="translated">Este m&amp;eacute;todo se puede utilizar para varios prop&amp;oacute;sitos. Por ejemplo, cuando &lt;code&gt;experimental_distribute_dataset&lt;/code&gt; no puede fragmentar los archivos de entrada, este m&amp;eacute;todo podr&amp;iacute;a usarse para fragmentar manualmente el conjunto de datos (evitando el comportamiento de retroceso lento en &lt;code&gt;experimental_distribute_dataset&lt;/code&gt; ). En los casos en los que el conjunto de datos es infinito, esta fragmentaci&amp;oacute;n se puede realizar creando r&amp;eacute;plicas del conjunto de datos que solo difieren en su semilla aleatoria. &lt;code&gt;experimental_distribute_dataset&lt;/code&gt; a veces tambi&amp;eacute;n puede fallar al dividir el lote entre las r&amp;eacute;plicas de un trabajador. En ese caso, este m&amp;eacute;todo se puede utilizar cuando esa limitaci&amp;oacute;n no exista.</target>
        </trans-unit>
        <trans-unit id="4d445a1a8ccfc13d2cbb47a0cd8852bd14137cba" translate="yes" xml:space="preserve">
          <source>This method can be used inside a subclassed layer or model's &lt;code&gt;call&lt;/code&gt; function, in which case &lt;code&gt;losses&lt;/code&gt; should be a Tensor or list of Tensors.</source>
          <target state="translated">Este m&amp;eacute;todo se puede usar dentro de una capa subclasificada o una funci&amp;oacute;n de &lt;code&gt;call&lt;/code&gt; del modelo , en cuyo caso las &lt;code&gt;losses&lt;/code&gt; deben ser un Tensor o una lista de Tensores.</target>
        </trans-unit>
        <trans-unit id="1d54c9015867d4032542a340799e853563723710" translate="yes" xml:space="preserve">
          <source>This method can be used inside the &lt;code&gt;call()&lt;/code&gt; method of a subclassed layer or model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a08143c632d6d9a6c3bb58abdfe351796aa7d61" translate="yes" xml:space="preserve">
          <source>This method can be used to assert that there exists a shape that both &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; represent.</source>
          <target state="translated">Este m&amp;eacute;todo puede usarse para afirmar que existe una forma que tanto &lt;code&gt;self&lt;/code&gt; como los &lt;code&gt;other&lt;/code&gt; representan.</target>
        </trans-unit>
        <trans-unit id="311f5dd67cb7916aeab132002e12e94284e8fdb8" translate="yes" xml:space="preserve">
          <source>This method can be used to create &lt;code&gt;RaggedTensor&lt;/code&gt;s with multiple uniform outer dimensions. For example, a &lt;code&gt;RaggedTensor&lt;/code&gt; with shape &lt;code&gt;[2, 2, None]&lt;/code&gt; can be constructed with this method from a &lt;code&gt;RaggedTensor&lt;/code&gt; values with shape &lt;code&gt;[4, None]&lt;/code&gt;:</source>
          <target state="translated">Este m&amp;eacute;todo se puede utilizar para crear &lt;code&gt;RaggedTensor&lt;/code&gt; s con m&amp;uacute;ltiples dimensiones exteriores uniformes. Por ejemplo, un &lt;code&gt;RaggedTensor&lt;/code&gt; con forma &lt;code&gt;[2, 2, None]&lt;/code&gt; se puede construir con este m&amp;eacute;todo a partir de valores de &lt;code&gt;RaggedTensor&lt;/code&gt; con forma &lt;code&gt;[4, None]&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="53a52d98446448532e361c5ab0b1a6a4bc35f1f2" translate="yes" xml:space="preserve">
          <source>This method can be used to merge partitions created by &lt;code&gt;dynamic_partition&lt;/code&gt; as illustrated on the following example:</source>
          <target state="translated">Este m&amp;eacute;todo se puede utilizar para fusionar particiones creadas por &lt;code&gt;dynamic_partition&lt;/code&gt; como se ilustra en el siguiente ejemplo:</target>
        </trans-unit>
        <trans-unit id="d34cdddad9212e7710a82e27967cd30b8fc5e14d" translate="yes" xml:space="preserve">
          <source>This method can be used to run a step function for training a number of times using input from a dataset.</source>
          <target state="translated">Este método puede utilizarse para ejecutar una función de paso para entrenar varias veces utilizando la entrada de un conjunto de datos.</target>
        </trans-unit>
        <trans-unit id="9c709bdcba30505f75d83241dd8ba3817ec876a1" translate="yes" xml:space="preserve">
          <source>This method currently blocks forever.</source>
          <target state="translated">Este método actualmente se bloquea para siempre.</target>
        </trans-unit>
        <trans-unit id="0f39f81e0d455fd570ceb61e61e1722fce44270e" translate="yes" xml:space="preserve">
          <source>This method enables setting metadata in a trace event after it is created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc0fd4004c973da3102a123f7521a19f6c88fb03" translate="yes" xml:space="preserve">
          <source>This method generalizes to higher-dimensions by simply providing a list for both the sp_ids as well as the vocab_size. In this case the resulting &lt;code&gt;SparseTensor&lt;/code&gt; has the following properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a08e7549042177e7c94f4230a7e19c5cac25a2de" translate="yes" xml:space="preserve">
          <source>This method generalizes to higher-dimensions by simply providing a list for both the sp_ids as well as the vocab_size. In this case the resulting &lt;code&gt;SparseTensor&lt;/code&gt; has the following properties: - &lt;code&gt;indices&lt;/code&gt; is equivalent to &lt;code&gt;sp_ids[0].indices&lt;/code&gt; with the last dimension discarded and concatenated with &lt;code&gt;sp_ids[0].values, sp_ids[1].values, ...&lt;/code&gt;. - &lt;code&gt;values&lt;/code&gt; is simply &lt;code&gt;sp_values.values&lt;/code&gt;. - If &lt;code&gt;sp_ids.dense_shape = [D0, D1, ..., Dn, K]&lt;/code&gt;, then &lt;code&gt;output.shape = [D0, D1, ..., Dn] + vocab_size&lt;/code&gt;.</source>
          <target state="translated">Este m&amp;eacute;todo se generaliza a dimensiones superiores simplemente proporcionando una lista tanto para sp_ids como para vocab_size. En este caso la resultante &lt;code&gt;SparseTensor&lt;/code&gt; tiene las siguientes propiedades: - &lt;code&gt;indices&lt;/code&gt; es equivalente a &lt;code&gt;sp_ids[0].indices&lt;/code&gt; con la &amp;uacute;ltima dimensi&amp;oacute;n descartado y concatenado con &lt;code&gt;sp_ids[0].values, sp_ids[1].values, ...&lt;/code&gt; . - &lt;code&gt;values&lt;/code&gt; es simplemente &lt;code&gt;sp_values.values&lt;/code&gt; . - Si &lt;code&gt;sp_ids.dense_shape = [D0, D1, ..., Dn, K]&lt;/code&gt; , entonces &lt;code&gt;output.shape = [D0, D1, ..., Dn] + vocab_size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7e44aa7677b60789a9ebef54c74a9714ec4de2a" translate="yes" xml:space="preserve">
          <source>This method has similar semantics to the built-in &lt;code&gt;zip()&lt;/code&gt; function in Python, with the main difference being that the &lt;code&gt;datasets&lt;/code&gt; argument can be an arbitrary nested structure of &lt;code&gt;Dataset&lt;/code&gt; objects.</source>
          <target state="translated">Este m&amp;eacute;todo tiene una sem&amp;aacute;ntica similar a la funci&amp;oacute;n &lt;code&gt;zip()&lt;/code&gt; incorporada en Python, con la principal diferencia de que el argumento del &lt;code&gt;datasets&lt;/code&gt; puede ser una estructura anidada arbitraria de objetos del &lt;code&gt;Dataset&lt;/code&gt; de datos .</target>
        </trans-unit>
        <trans-unit id="1925370323ce05b6dc0cdc8787e9c0d6ebf8403a" translate="yes" xml:space="preserve">
          <source>This method is a convenience wrapper for creating a &lt;a href=&quot;server&quot;&gt;&lt;code&gt;tf.distribute.Server&lt;/code&gt;&lt;/a&gt; with a &lt;a href=&quot;../train/serverdef&quot;&gt;&lt;code&gt;tf.train.ServerDef&lt;/code&gt;&lt;/a&gt; that specifies a single-process cluster containing a single task in a job called &lt;code&gt;&quot;local&quot;&lt;/code&gt;.</source>
          <target state="translated">Este m&amp;eacute;todo es un contenedor conveniente para crear un &lt;a href=&quot;server&quot;&gt; &lt;code&gt;tf.distribute.Server&lt;/code&gt; &lt;/a&gt; con un &lt;a href=&quot;../train/serverdef&quot;&gt; &lt;code&gt;tf.train.ServerDef&lt;/code&gt; &lt;/a&gt; que especifica un cl&amp;uacute;ster de un solo proceso que contiene una sola tarea en un trabajo llamado &lt;code&gt;&quot;local&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05c81c4b69f5f8cdea4eba6f7d8bb00b2d7cd37f" translate="yes" xml:space="preserve">
          <source>This method is automatically called when the StubOutForTesting() object is deleted; there is no need to call it explicitly.</source>
          <target state="translated">Este método se llama automáticamente cuando se borra el objeto StubOutForTesting();no hay necesidad de llamarlo explícitamente.</target>
        </trans-unit>
        <trans-unit id="992fe7b39731079182b90eaf498e1ed5e5a20148" translate="yes" xml:space="preserve">
          <source>This method is completely compatible with the &lt;code&gt;tf.Session.run()&lt;/code&gt; method.</source>
          <target state="translated">Este m&amp;eacute;todo es completamente compatible con el m&amp;eacute;todo &lt;code&gt;tf.Session.run()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9074766f6510dcf3975a88d8985dc7d0e99f0a13" translate="yes" xml:space="preserve">
          <source>This method is deprecated, use is_alive() instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a744f7951fcb63381ecb2ea91dcc061d08e7d4a0" translate="yes" xml:space="preserve">
          <source>This method is exposed in TensorFlow's API so that library developers can register dispatching for &lt;a href=&quot;tensor#__eq__&quot;&gt;&lt;code&gt;Tensor.&lt;strong&gt;eq&lt;/strong&gt;&lt;/code&gt;&lt;/a&gt; to allow it to handle custom composite tensors &amp;amp; other custom objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a699437e1c2aa279788c76128e6e5f624c7c0a7" translate="yes" xml:space="preserve">
          <source>This method is exposed in TensorFlow's API so that library developers can register dispatching for &lt;a href=&quot;tensor#__getitem__&quot;&gt;&lt;code&gt;Tensor.&lt;strong&gt;getitem&lt;/strong&gt;&lt;/code&gt;&lt;/a&gt; to allow it to handle custom composite tensors &amp;amp; other custom objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca897118350393caa56db53d55d7ff23f3ea66bf" translate="yes" xml:space="preserve">
          <source>This method is exposed in TensorFlow's API so that library developers can register dispatching for &lt;a href=&quot;tensor#__ne__&quot;&gt;&lt;code&gt;Tensor.&lt;strong&gt;ne&lt;/strong&gt;&lt;/code&gt;&lt;/a&gt; to allow it to handle custom composite tensors &amp;amp; other custom objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7dd7ea7386a00c65842a1da48fad6c58e2f712f" translate="yes" xml:space="preserve">
          <source>This method is for use by TestCase subclasses that need to register their own type equality functions to provide nicer error messages.</source>
          <target state="translated">Este método es para ser usado por subclases de TestCase que necesitan registrar sus propias funciones de igualdad de tipos para proporcionar mensajes de error más agradables.</target>
        </trans-unit>
        <trans-unit id="66283121e6883c956c7613fffa84d220528690f4" translate="yes" xml:space="preserve">
          <source>This method is idempotent. Calling it multiple times has the same effect as calling it once.</source>
          <target state="translated">Este método es idempotente.Llamarlo varias veces tiene el mismo efecto que llamarlo una vez.</target>
        </trans-unit>
        <trans-unit id="26e25dbe646e6bb109fc819d323736b4d761ed81" translate="yes" xml:space="preserve">
          <source>This method is intended to be used to load checkpoints created by &lt;code&gt;save()&lt;/code&gt;. For checkpoints created by &lt;code&gt;write()&lt;/code&gt; use the &lt;code&gt;read()&lt;/code&gt; method which does not expect the &lt;code&gt;save_counter&lt;/code&gt; variable added by &lt;code&gt;save()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="887c8b37e88faa620b24a828f5dc104598906d79" translate="yes" xml:space="preserve">
          <source>This method is just like &lt;code&gt;restore()&lt;/code&gt; but does not expect the &lt;code&gt;save_counter&lt;/code&gt; variable in the checkpoint. It only restores the objects that the checkpoint already depends on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1d2fc5aba91c121cb755ded927621c464c711dd" translate="yes" xml:space="preserve">
          <source>This method is only needed if you compute gradients manually, e.g. with &lt;a href=&quot;../../../gradienttape&quot;&gt;&lt;code&gt;tf.GradientTape&lt;/code&gt;&lt;/a&gt;. In that case, call this method to scale the loss before passing the loss to &lt;a href=&quot;../../../gradienttape&quot;&gt;&lt;code&gt;tf.GradientTape&lt;/code&gt;&lt;/a&gt;. If you use &lt;a href=&quot;../../optimizers/optimizer#minimize&quot;&gt;&lt;code&gt;LossScaleOptimizer.minimize&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;lossscaleoptimizer#get_gradients&quot;&gt;&lt;code&gt;LossScaleOptimizer.get_gradients&lt;/code&gt;&lt;/a&gt;, loss scaling is automatically applied and this method is unneeded.</source>
          <target state="translated">Este m&amp;eacute;todo solo es necesario si calcula gradientes manualmente, por ejemplo, con &lt;a href=&quot;../../../gradienttape&quot;&gt; &lt;code&gt;tf.GradientTape&lt;/code&gt; &lt;/a&gt; . En ese caso, llame a este m&amp;eacute;todo para escalar la p&amp;eacute;rdida antes de pasarla a &lt;a href=&quot;../../../gradienttape&quot;&gt; &lt;code&gt;tf.GradientTape&lt;/code&gt; &lt;/a&gt; . Si usa &lt;a href=&quot;../../optimizers/optimizer#minimize&quot;&gt; &lt;code&gt;LossScaleOptimizer.minimize&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;lossscaleoptimizer#get_gradients&quot;&gt; &lt;code&gt;LossScaleOptimizer.get_gradients&lt;/code&gt; &lt;/a&gt; , la escala de p&amp;eacute;rdida se aplica autom&amp;aacute;ticamente y este m&amp;eacute;todo no es necesario.</target>
        </trans-unit>
        <trans-unit id="2ffe062127379160c3973cd4f84270b4f4f8ccf9" translate="yes" xml:space="preserve">
          <source>This method is only needed if you compute gradients manually, e.g. with &lt;a href=&quot;../../../gradienttape&quot;&gt;&lt;code&gt;tf.GradientTape&lt;/code&gt;&lt;/a&gt;. In that case, call this method to unscale the gradients after computing them with &lt;a href=&quot;../../../gradienttape&quot;&gt;&lt;code&gt;tf.GradientTape&lt;/code&gt;&lt;/a&gt;. If you use &lt;a href=&quot;../../optimizers/optimizer#minimize&quot;&gt;&lt;code&gt;LossScaleOptimizer.minimize&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;lossscaleoptimizer#get_gradients&quot;&gt;&lt;code&gt;LossScaleOptimizer.get_gradients&lt;/code&gt;&lt;/a&gt;, loss scaling is automatically applied and this method is unneeded.</source>
          <target state="translated">Este m&amp;eacute;todo solo es necesario si calcula gradientes manualmente, por ejemplo, con &lt;a href=&quot;../../../gradienttape&quot;&gt; &lt;code&gt;tf.GradientTape&lt;/code&gt; &lt;/a&gt; . En ese caso, llame a este m&amp;eacute;todo para cambiar la escala de los gradientes despu&amp;eacute;s de calcularlos con &lt;a href=&quot;../../../gradienttape&quot;&gt; &lt;code&gt;tf.GradientTape&lt;/code&gt; &lt;/a&gt; . Si usa &lt;a href=&quot;../../optimizers/optimizer#minimize&quot;&gt; &lt;code&gt;LossScaleOptimizer.minimize&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;lossscaleoptimizer#get_gradients&quot;&gt; &lt;code&gt;LossScaleOptimizer.get_gradients&lt;/code&gt; &lt;/a&gt; , la escala de p&amp;eacute;rdida se aplica autom&amp;aacute;ticamente y este m&amp;eacute;todo no es necesario.</target>
        </trans-unit>
        <trans-unit id="2d15ade5009ad723801c2c48bded790a3845587f" translate="yes" xml:space="preserve">
          <source>This method is optional if you are just training and executing models, exporting to and from SavedModels, or using weight checkpoints.</source>
          <target state="translated">Este método es opcional si sólo está entrenando y ejecutando modelos,exportando a y desde SavedModels,o usando puntos de control de peso.</target>
        </trans-unit>
        <trans-unit id="2ed4e772dabffd01cfde2b74159ef69c9f3e04f5" translate="yes" xml:space="preserve">
          <source>This method is required for Keras &lt;code&gt;model_to_estimator&lt;/code&gt;, saving and loading models to HDF5 formats, Keras model cloning, some visualization utilities, and exporting models to and from JSON.</source>
          <target state="translated">Este m&amp;eacute;todo es necesario para Keras &lt;code&gt;model_to_estimator&lt;/code&gt; , guardar y cargar modelos en formatos HDF5, clonar modelos Keras, algunas utilidades de visualizaci&amp;oacute;n y exportar modelos hacia y desde JSON.</target>
        </trans-unit>
        <trans-unit id="6fdad9c5ed22f16c319e244d8261ea4ee3d279dd" translate="yes" xml:space="preserve">
          <source>This method is smart and works at the module, class, and instance level while preserving proper inheritance. It will not stub out C types however unless that has been explicitly allowed by the type.</source>
          <target state="translated">Este método es inteligente y funciona a nivel de módulo,clase e instancia mientras preserva la herencia apropiada.Sin embargo,no eliminará los tipos C a menos que el tipo lo permita explícitamente.</target>
        </trans-unit>
        <trans-unit id="feecb6a599cedcf2305768be36a750d8591e9329" translate="yes" xml:space="preserve">
          <source>This method is the reverse of &lt;code&gt;get_config&lt;/code&gt;, capable of instantiating the same layer from the config dictionary. It does not handle layer connectivity (handled by Network), nor weights (handled by &lt;code&gt;set_weights&lt;/code&gt;).</source>
          <target state="translated">Este m&amp;eacute;todo es el inverso de &lt;code&gt;get_config&lt;/code&gt; , capaz de instanciar la misma capa desde el diccionario de configuraci&amp;oacute;n. No maneja conectividad de capa (manejada por Network), ni pesos (manejada por &lt;code&gt;set_weights&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="422559cd09a8b37855dfa1becf9159996c55a88c" translate="yes" xml:space="preserve">
          <source>This method is the reverse of &lt;code&gt;get_config&lt;/code&gt;, capable of instantiating the same optimizer from the config dictionary.</source>
          <target state="translated">Este m&amp;eacute;todo es el inverso de &lt;code&gt;get_config&lt;/code&gt; , capaz de instanciar el mismo optimizador del diccionario de configuraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c7d6ed78b790787a16f4abeccc0ecd949df6cc2b" translate="yes" xml:space="preserve">
          <source>This method is the reverse of &lt;code&gt;get_config&lt;/code&gt;, capable of instantiating the same regularizer from the config dictionary.</source>
          <target state="translated">Este m&amp;eacute;todo es el inverso de &lt;code&gt;get_config&lt;/code&gt; , capaz de instanciar el mismo regularizador del diccionario de configuraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="64a729de3228c199e6f42ec9b13a781c1672f7d1" translate="yes" xml:space="preserve">
          <source>This method is the same as setting &lt;code&gt;minval&lt;/code&gt; and &lt;code&gt;maxval&lt;/code&gt; to &lt;code&gt;None&lt;/code&gt; in the &lt;code&gt;uniform&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="188de6cc0c368ed4ab40eeabc0c2f0a4587200cc" translate="yes" xml:space="preserve">
          <source>This method is thread-safe.</source>
          <target state="translated">Este método es seguro.</target>
        </trans-unit>
        <trans-unit id="430e31afd2b8ce36dbd30c0726de058dc4716f34" translate="yes" xml:space="preserve">
          <source>This method is used by Keras &lt;code&gt;model_to_estimator&lt;/code&gt;, saving and loading models to HDF5 formats, Keras model cloning, some visualization utilities, and exporting models to and from JSON.</source>
          <target state="translated">Keras &lt;code&gt;model_to_estimator&lt;/code&gt; usa este m&amp;eacute;todo , guardando y cargando modelos en formatos HDF5, clonaci&amp;oacute;n de modelos Keras, algunas utilidades de visualizaci&amp;oacute;n y exportando modelos hacia y desde JSON.</target>
        </trans-unit>
        <trans-unit id="457bbe494ff8a7cc3168e5b2acb3fc1d7df09a01" translate="yes" xml:space="preserve">
          <source>This method is used to convert a dictionary into a sequence of parameters for a binary that parses arguments using this module.</source>
          <target state="translated">Este método se utiliza para convertir un diccionario en una secuencia de parámetros para un binario que analiza los argumentos utilizando este módulo.</target>
        </trans-unit>
        <trans-unit id="5f40fabbeaa1bcaea8e9654a487713070e7848ee" translate="yes" xml:space="preserve">
          <source>This method is useful for recovering the &quot;self._last_checkpoints&quot; state.</source>
          <target state="translated">Este método es útil para recuperar el estado &quot;self._last_checkpoints&quot;.</target>
        </trans-unit>
        <trans-unit id="5eb2940a1b8924b3a2b4c6c370fcb87bd404d70c" translate="yes" xml:space="preserve">
          <source>This method may be called concurrently from multiple threads.</source>
          <target state="translated">Este método puede ser llamado simultáneamente desde múltiples hilos.</target>
        </trans-unit>
        <trans-unit id="879b4ac0bfff915fe8733219e840864c530b0386" translate="yes" xml:space="preserve">
          <source>This method must be used as a context manager, and will yield a recording object with two attributes: &lt;code&gt;output&lt;/code&gt; and &lt;code&gt;records&lt;/code&gt;. At the end of the context manager, the &lt;code&gt;output&lt;/code&gt; attribute will be a list of the matching formatted log messages and the &lt;code&gt;records&lt;/code&gt; attribute will be a list of the corresponding LogRecord objects.</source>
          <target state="translated">Este m&amp;eacute;todo debe utilizarse como administrador de contexto y producir&amp;aacute; un objeto de grabaci&amp;oacute;n con dos atributos: &lt;code&gt;output&lt;/code&gt; y &lt;code&gt;records&lt;/code&gt; . Al final del administrador de contexto, el atributo de &lt;code&gt;output&lt;/code&gt; ser&amp;aacute; una lista de los mensajes de registro formateados coincidentes y el atributo de &lt;code&gt;records&lt;/code&gt; ser&amp;aacute; una lista de los objetos LogRecord correspondientes.</target>
        </trans-unit>
        <trans-unit id="45b78faa33c30a4ca2de4d4a2a7e0ea54433a6aa" translate="yes" xml:space="preserve">
          <source>This method overrides unittest.TestCase.shortDescription(), which only returns the first line of the docstring, obscuring the name of the test upon failure.</source>
          <target state="translated">Este método anula el método unittest.TestCase.shortDescription(),que sólo devuelve la primera línea de la cadena de documentación,oscureciendo el nombre de la prueba al fallar.</target>
        </trans-unit>
        <trans-unit id="ee5a67ef5f4ab3abd49e8e0aa6ab37b4c495718e" translate="yes" xml:space="preserve">
          <source>This method promotes a completely unknown shape to one with a known rank.</source>
          <target state="translated">Este método promueve una forma completamente desconocida a uno con un rango conocido.</target>
        </trans-unit>
        <trans-unit id="f08536c5c4bd5b0bf81a621ac1af31ff012f949c" translate="yes" xml:space="preserve">
          <source>This method requires a session in which the graph was launched. It creates a list of threads, optionally starting them. There is one thread for each op passed in &lt;code&gt;enqueue_ops&lt;/code&gt;.</source>
          <target state="translated">Este m&amp;eacute;todo requiere una sesi&amp;oacute;n en la que se lanz&amp;oacute; el gr&amp;aacute;fico. Crea una lista de subprocesos, opcionalmente inici&amp;aacute;ndolos. Hay un hilo para cada &lt;code&gt;enqueue_ops&lt;/code&gt; pasada en enqueue_ops .</target>
        </trans-unit>
        <trans-unit id="ed37572237615338abb9afe9f97f9e51444c9050" translate="yes" xml:space="preserve">
          <source>This method requires that you are running in eager mode and the dataset's element_spec contains only &lt;code&gt;TensorSpec&lt;/code&gt; components.</source>
          <target state="translated">Este m&amp;eacute;todo requiere que est&amp;eacute; ejecutando en modo ansioso y que element_spec del conjunto de datos contenga solo componentes de &lt;code&gt;TensorSpec&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba66428fee92af2921958313c4abbe6a414d3356" translate="yes" xml:space="preserve">
          <source>This method requires that you are running in eager mode, and that the length of the dataset is known and non-infinite. When the length may be unknown or infinite, or if you are running in graph mode, use &lt;a href=&quot;../../../../data/dataset#cardinality&quot;&gt;&lt;code&gt;tf.data.Dataset.cardinality&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c229102fa2fa8b3a631fa2db6ca01f20dd5c2adc" translate="yes" xml:space="preserve">
          <source>This method requires that you are running in eager mode, and that the length of the dataset is known and non-infinite. When the length may be unknown or infinite, or if you are running in graph mode, use &lt;a href=&quot;../../../data/dataset#cardinality&quot;&gt;&lt;code&gt;tf.data.Dataset.cardinality&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bff5648ed0712c0feea6c45e6290da036f8f217" translate="yes" xml:space="preserve">
          <source>This method requires that you are running in eager mode, and that the length of the dataset is known and non-infinite. When the length may be unknown or infinite, or if you are running in graph mode, use &lt;a href=&quot;../dataset#cardinality&quot;&gt;&lt;code&gt;tf.data.Dataset.cardinality&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d8d6fb6d8be4a1c2d9cfd5ec8103395810dc8de" translate="yes" xml:space="preserve">
          <source>This method requires that you are running in eager mode, and that the length of the dataset is known and non-infinite. When the length may be unknown or infinite, or if you are running in graph mode, use &lt;a href=&quot;dataset#cardinality&quot;&gt;&lt;code&gt;tf.data.Dataset.cardinality&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df938127180a900a9c0ee2c326f70990ca05bad0" translate="yes" xml:space="preserve">
          <source>This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads.</source>
          <target state="translated">Este método devuelve True justo antes de que el método run()comience hasta justo después de que el método run()termine.La función modular enumerate()devuelve una lista de todos los hilos vivos.</target>
        </trans-unit>
        <trans-unit id="843186b661a979f57d76fd131bdb6daf25004a63" translate="yes" xml:space="preserve">
          <source>This method returns a context manager, and is used as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67c5a6af4d2a477a788bf93645d98e3fc1667925" translate="yes" xml:space="preserve">
          <source>This method runs one &quot;step&quot; of TensorFlow computation, by running the necessary graph fragment to execute every &lt;code&gt;Operation&lt;/code&gt; and evaluate every &lt;code&gt;Tensor&lt;/code&gt; in &lt;code&gt;fetches&lt;/code&gt;, substituting the values in &lt;code&gt;feed_dict&lt;/code&gt; for the corresponding input values.</source>
          <target state="translated">Este m&amp;eacute;todo ejecuta un &quot;paso&quot; de c&amp;aacute;lculo de TensorFlow, ejecutando el fragmento de gr&amp;aacute;fico necesario para ejecutar cada &lt;code&gt;Operation&lt;/code&gt; y evaluar cada &lt;code&gt;Tensor&lt;/code&gt; en las &lt;code&gt;fetches&lt;/code&gt; , sustituyendo los valores en &lt;code&gt;feed_dict&lt;/code&gt; por los valores de entrada correspondientes.</target>
        </trans-unit>
        <trans-unit id="7ef4f95365ffd49356edce6309d3da564feb3d3b" translate="yes" xml:space="preserve">
          <source>This method runs the ops added by the constructor for restoring variables. It requires a session in which the graph was launched. The variables to restore do not have to have been initialized, as restoring is itself a way to initialize variables.</source>
          <target state="translated">Este método ejecuta las operaciones añadidas por el constructor para restaurar las variables.Requiere una sesión en la que se lanzó el gráfico.Las variables a restaurar no tienen que haber sido inicializadas,ya que la restauración es en sí misma una forma de inicializar las variables.</target>
        </trans-unit>
        <trans-unit id="6a0628c028c0b695f5ff3c6935b2aad50149fac6" translate="yes" xml:space="preserve">
          <source>This method runs the ops added by the constructor for saving variables. It requires a session in which the graph was launched. The variables to save must also have been initialized.</source>
          <target state="translated">Este método ejecuta las operaciones añadidas por el constructor para guardar las variables.Requiere una sesión en la que se haya lanzado el gráfico.Las variables a guardar también deben haber sido inicializadas.</target>
        </trans-unit>
        <trans-unit id="9df50570004b7fc9f261d6b98cab329e6a66afe0" translate="yes" xml:space="preserve">
          <source>This method sets the vocabulary and DF data for this layer directly, instead of analyzing a dataset through 'adapt'. It should be used whenever the vocab (and optionally document frequency) information is already known. If vocabulary data is already present in the layer, this method will either replace it, if 'append' is set to False, or append to it (if 'append' is set to True).</source>
          <target state="translated">Este método establece el vocabulario y los datos DF para esta capa directamente,en lugar de analizar un conjunto de datos a través de &quot;adaptar&quot;.Debería utilizarse siempre que la información del vocabulario (y opcionalmente la frecuencia de los documentos)ya se conozca.Si los datos del vocabulario ya están presentes en la capa,este método los reemplazará,si 'append' está establecido en Falso,o los añadirá (si 'append' está establecido en Verdadero).</target>
        </trans-unit>
        <trans-unit id="98a596750a8e57f7c4dd92233c96d160228e7339" translate="yes" xml:space="preserve">
          <source>This method sets the vocabulary and DF data for this layer directly, instead of analyzing a dataset through 'adapt'. It should be used whenever the vocab (and optionally document frequency) information is already known. If vocabulary data is already present in the layer, this method will replace it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f39e288c36cc30e58aa384f98451d54174eefdc7" translate="yes" xml:space="preserve">
          <source>This method sets the vocabulary for this layer directly, instead of analyzing a dataset through 'adapt'. It should be used whenever the vocab information is already known. If vocabulary data is already present in the layer, this method will either replace it</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="381d5d74ef1ba876c849eaf0c748814799df311b" translate="yes" xml:space="preserve">
          <source>This method should be used if you want to create multiple graphs in the same process. For convenience, a global default graph is provided, and all ops will be added to this graph if you do not create a new graph explicitly.</source>
          <target state="translated">Este método debería utilizarse si se desea crear múltiples gráficos en el mismo proceso.Para mayor comodidad,se proporciona un gráfico global predeterminado,y todas las operaciones se añadirán a este gráfico si no se crea un nuevo gráfico explícitamente.</target>
        </trans-unit>
        <trans-unit id="801d04a3f8f77fe9f713a4af6184910c6103cec6" translate="yes" xml:space="preserve">
          <source>This method should be used to create all threads in test cases, as otherwise there is a risk that a thread will silently fail, and/or assertions made in the thread will not be respected.</source>
          <target state="translated">Este método debería utilizarse para crear todos los hilos en los casos de prueba,ya que de lo contrario existe el riesgo de que un hilo falle silenciosamente,y/o no se respeten las afirmaciones hechas en el hilo.</target>
        </trans-unit>
        <trans-unit id="0840a5953e72a61137caa721b5cce35c70dbd3d8" translate="yes" xml:space="preserve">
          <source>This method should contain the mathemetical logic for one step of inference. This typically includes the forward pass.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eebfd3cd848c16a7d254cfeece5ae46941b7f986" translate="yes" xml:space="preserve">
          <source>This method should contain the mathemetical logic for one step of training. This typically includes the forward pass, loss calculation, backpropagation, and metric updates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84ddde0d41fb950f979365b1dd4b04e51a4464b1" translate="yes" xml:space="preserve">
          <source>This method simply combines calls &lt;code&gt;compute_gradients()&lt;/code&gt; and &lt;code&gt;apply_gradients()&lt;/code&gt;. If you want to process the gradient before applying them call &lt;code&gt;compute_gradients()&lt;/code&gt; and &lt;code&gt;apply_gradients()&lt;/code&gt; explicitly instead of using this function.</source>
          <target state="translated">Este m&amp;eacute;todo simplemente combina las llamadas &lt;code&gt;compute_gradients()&lt;/code&gt; y &lt;code&gt;apply_gradients()&lt;/code&gt; . Si desea procesar el degradado antes de aplicarlos, llame a &lt;code&gt;compute_gradients()&lt;/code&gt; y &lt;code&gt;apply_gradients()&lt;/code&gt; expl&amp;iacute;citamente en lugar de usar esta funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="5f6d383158cc853c41c5bc430e4c2e31944ed6aa" translate="yes" xml:space="preserve">
          <source>This method simply computes gradient using &lt;a href=&quot;../../../gradienttape&quot;&gt;&lt;code&gt;tf.GradientTape&lt;/code&gt;&lt;/a&gt; and calls &lt;code&gt;apply_gradients()&lt;/code&gt;. If you want to process the gradient before applying then call &lt;a href=&quot;../../../gradienttape&quot;&gt;&lt;code&gt;tf.GradientTape&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;apply_gradients()&lt;/code&gt; explicitly instead of using this function.</source>
          <target state="translated">Este m&amp;eacute;todo simplemente calcula el gradiente usando &lt;a href=&quot;../../../gradienttape&quot;&gt; &lt;code&gt;tf.GradientTape&lt;/code&gt; &lt;/a&gt; y llama a &lt;code&gt;apply_gradients()&lt;/code&gt; . Si desea procesar el degradado antes de aplicarlo, llame a &lt;a href=&quot;../../../gradienttape&quot;&gt; &lt;code&gt;tf.GradientTape&lt;/code&gt; &lt;/a&gt; y &lt;code&gt;apply_gradients()&lt;/code&gt; expl&amp;iacute;citamente en lugar de usar esta funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7c45540d5f88e8d63143978a302ef3be7b4897a3" translate="yes" xml:space="preserve">
          <source>This method simply computes gradient using &lt;a href=&quot;../../gradienttape&quot;&gt;&lt;code&gt;tf.GradientTape&lt;/code&gt;&lt;/a&gt; and calls &lt;code&gt;apply_gradients()&lt;/code&gt;. If you want to process the gradient before applying then call &lt;a href=&quot;../../gradienttape&quot;&gt;&lt;code&gt;tf.GradientTape&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;apply_gradients()&lt;/code&gt; explicitly instead of using this function.</source>
          <target state="translated">Este m&amp;eacute;todo simplemente calcula el gradiente usando &lt;a href=&quot;../../gradienttape&quot;&gt; &lt;code&gt;tf.GradientTape&lt;/code&gt; &lt;/a&gt; y llama a &lt;code&gt;apply_gradients()&lt;/code&gt; . Si desea procesar el degradado antes de aplicarlo, llame a &lt;a href=&quot;../../gradienttape&quot;&gt; &lt;code&gt;tf.GradientTape&lt;/code&gt; &lt;/a&gt; y &lt;code&gt;apply_gradients()&lt;/code&gt; expl&amp;iacute;citamente en lugar de usar esta funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9fbf54940adbbc3b34153fb181199a19b56bd888" translate="yes" xml:space="preserve">
          <source>This method supports the case where attr_name is a staticmethod or a classmethod of obj.</source>
          <target state="translated">Este método apoya el caso en el que attr_name es un método estadístico o un método de clase de objeto.</target>
        </trans-unit>
        <trans-unit id="b1e95fe0c7a12cd011cb442b54315c64dbbef85c" translate="yes" xml:space="preserve">
          <source>This method supports the case where child_name is a staticmethod or a classmethod of parent.</source>
          <target state="translated">Este método apoya el caso en el que el nombre del hijo es un método estadístico o un método de clase de los padres.</target>
        </trans-unit>
        <trans-unit id="3c5357e5e49a58f1873923787332f7877e186b5d" translate="yes" xml:space="preserve">
          <source>This method takes effect only on the thread in which it is called.</source>
          <target state="translated">Este método sólo tiene efecto en el hilo en el que se llama.</target>
        </trans-unit>
        <trans-unit id="dc69067a62ba3479c811e1ffb95925d4cb95f817" translate="yes" xml:space="preserve">
          <source>This method takes the same args as the DeviceSpec constructor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cd6047c37611c4ef1b1add7ec4d3db22681db24" translate="yes" xml:space="preserve">
          <source>This method will also be called as a result of recovering a wrapped session, not only at the beginning of the overall session.</source>
          <target state="translated">Este método también se llamará como resultado de la recuperación de una sesión envuelta,no sólo al principio de la sesión general.</target>
        </trans-unit>
        <trans-unit id="b524a4798bc6e14abf1530810ef4205d0b748932" translate="yes" xml:space="preserve">
          <source>This method will block caller thread until it receives tracing result. This method supports CPU, GPU, and Cloud TPU. This method supports profiling a single host for CPU, GPU, TPU, as well as multiple TPU workers. The profiled results will be saved to your specified TensorBoard log directory (e.g. the directory you save your model checkpoints). Use the TensorBoard profile plugin to view the visualization and analysis results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80c9b1eb0c3b33d3a7e2274259517a077b4c895e" translate="yes" xml:space="preserve">
          <source>This method will first try to restore from the most recent checkpoint in &lt;code&gt;directory&lt;/code&gt;. If no checkpoints exist in &lt;code&gt;directory&lt;/code&gt;, and &lt;code&gt;init_fn&lt;/code&gt; is specified, this method will call &lt;code&gt;init_fn&lt;/code&gt; to do customized initialization. This can be used to support initialization from pretrained models.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72f0ec32b5d6b0d5f31ec5a44977c2b73ae22a24" translate="yes" xml:space="preserve">
          <source>This method will raise a RuntimeError if called more than once on the same thread object.</source>
          <target state="translated">Este método levantará un RuntimeError si se llama más de una vez en el mismo objeto de hilo.</target>
        </trans-unit>
        <trans-unit id="5450168f56def10b3805f1b87bf923f81daadea9" translate="yes" xml:space="preserve">
          <source>This method works similar to tf.map_fn but is optimized to run much faster, possibly with a much larger memory footprint. The speedups are obtained by vectorization (see &lt;a href=&quot;https://arxiv.org/pdf/1903.04243.pdf&quot;&gt;https://arxiv.org/pdf/1903.04243.pdf&lt;/a&gt;). The idea behind vectorization is to semantically launch all the invocations of &lt;code&gt;fn&lt;/code&gt; in parallel and fuse corresponding operations across all these invocations. This fusion is done statically at graph generation time and the generated code is often similar in performance to a manually fused version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="218a6eaea58d633bb4c07cebec2cce2a54164fc8" translate="yes" xml:space="preserve">
          <source>This method works similar to tf.map_fn but is optimized to run much faster, possibly with a much larger memory footprint. The speedups are obtained by vectorization (see https://arxiv.org/pdf/1903.04243.pdf). The idea behind vectorization is to semantically launch all the invocations of &lt;code&gt;fn&lt;/code&gt; in parallel and fuse corresponding operations across all these invocations. This fusion is done statically at graph generation time and the generated code is often similar in performance to a manually fused version.</source>
          <target state="translated">Este m&amp;eacute;todo funciona de manera similar a tf.map_fn pero est&amp;aacute; optimizado para ejecutarse mucho m&amp;aacute;s r&amp;aacute;pido, posiblemente con una huella de memoria mucho mayor. Las aceleraciones se obtienen por vectorizaci&amp;oacute;n (ver https://arxiv.org/pdf/1903.04243.pdf). La idea detr&amp;aacute;s de la vectorizaci&amp;oacute;n es lanzar sem&amp;aacute;nticamente todas las invocaciones de &lt;code&gt;fn&lt;/code&gt; en paralelo y fusionar las operaciones correspondientes en todas estas invocaciones. Esta fusi&amp;oacute;n se realiza de forma est&amp;aacute;tica en el momento de la generaci&amp;oacute;n del gr&amp;aacute;fico y el c&amp;oacute;digo generado suele tener un rendimiento similar al de una versi&amp;oacute;n fusionada manualmente.</target>
        </trans-unit>
        <trans-unit id="fe5b3fca46a696592f5d3933d9a6c2e14a59d105" translate="yes" xml:space="preserve">
          <source>This method wraps the provided session in an &lt;code&gt;Event&lt;/code&gt; protocol buffer and adds it to the event file.</source>
          <target state="translated">Este m&amp;eacute;todo envuelve la sesi&amp;oacute;n proporcionada en un b&amp;uacute;fer de protocolo de &lt;code&gt;Event&lt;/code&gt; y la agrega al archivo de eventos.</target>
        </trans-unit>
        <trans-unit id="0b654fd9b9bcfd951b8584e5c172fdf88b6f87e9" translate="yes" xml:space="preserve">
          <source>This method wraps the provided summary in an &lt;code&gt;Event&lt;/code&gt; protocol buffer and adds it to the event file.</source>
          <target state="translated">Este m&amp;eacute;todo envuelve el resumen proporcionado en un b&amp;uacute;fer de protocolo de &lt;code&gt;Event&lt;/code&gt; y lo agrega al archivo de eventos.</target>
        </trans-unit>
        <trans-unit id="e573192331e3d216aaf00fffe24f089e83e9c9ad" translate="yes" xml:space="preserve">
          <source>This method, unlike assertCountEqual, doesn't care about any duplicates in the expected and actual sequences.</source>
          <target state="translated">Este método,a diferencia de assertCountEqual,no se preocupa por ningún duplicado en las secuencias esperadas y reales.</target>
        </trans-unit>
        <trans-unit id="0b693febd3a0c9fc69fb14a0f914449cb9729097" translate="yes" xml:space="preserve">
          <source>This metric creates four local variables, &lt;code&gt;true_positives&lt;/code&gt;, &lt;code&gt;true_negatives&lt;/code&gt;, &lt;code&gt;false_positives&lt;/code&gt; and &lt;code&gt;false_negatives&lt;/code&gt; that are used to compute the AUC. To discretize the AUC curve, a linearly spaced set of thresholds is used to compute pairs of recall and precision values. The area under the ROC-curve is therefore computed using the height of the recall values by the false positive rate, while the area under the PR-curve is the computed using the height of the precision values by the recall.</source>
          <target state="translated">Esta m&amp;eacute;trica crea cuatro variables locales, &lt;code&gt;true_positives&lt;/code&gt; , &lt;code&gt;true_negatives&lt;/code&gt; , &lt;code&gt;false_positives&lt;/code&gt; y &lt;code&gt;false_negatives&lt;/code&gt; que se utilizan para calcular el AUC. Para discretizar la curva AUC, se utiliza un conjunto de umbrales espaciados linealmente para calcular pares de valores de recuperaci&amp;oacute;n y precisi&amp;oacute;n. Por lo tanto, el &amp;aacute;rea bajo la curva ROC se calcula utilizando la altura de los valores de recuperaci&amp;oacute;n por la tasa de falsos positivos, mientras que el &amp;aacute;rea bajo la curva PR se calcula utilizando la altura de los valores de precisi&amp;oacute;n mediante la recuperaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8310e01ff09f3ad784585cc77cdb8fe7f1ac0213" translate="yes" xml:space="preserve">
          <source>This metric creates four local variables, &lt;code&gt;true_positives&lt;/code&gt;, &lt;code&gt;true_negatives&lt;/code&gt;, &lt;code&gt;false_positives&lt;/code&gt; and &lt;code&gt;false_negatives&lt;/code&gt; that are used to compute the precision at the given recall. The threshold for the given recall value is computed and used to evaluate the corresponding precision.</source>
          <target state="translated">Esta m&amp;eacute;trica crea cuatro variables locales, &lt;code&gt;true_positives&lt;/code&gt; , &lt;code&gt;true_negatives&lt;/code&gt; , &lt;code&gt;false_positives&lt;/code&gt; y &lt;code&gt;false_negatives&lt;/code&gt; que se utilizan para calcular la precisi&amp;oacute;n en la recuperaci&amp;oacute;n dada. El umbral para el valor de recuperaci&amp;oacute;n dado se calcula y se utiliza para evaluar la precisi&amp;oacute;n correspondiente.</target>
        </trans-unit>
        <trans-unit id="cd97f6783f485e9e31fe2474cb3ca5414d0a738b" translate="yes" xml:space="preserve">
          <source>This metric creates four local variables, &lt;code&gt;true_positives&lt;/code&gt;, &lt;code&gt;true_negatives&lt;/code&gt;, &lt;code&gt;false_positives&lt;/code&gt; and &lt;code&gt;false_negatives&lt;/code&gt; that are used to compute the recall at the given precision. The threshold for the given precision value is computed and used to evaluate the corresponding recall.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a469d6ce618a21614949a4828cde8383fb0456e0" translate="yes" xml:space="preserve">
          <source>This metric creates four local variables, &lt;code&gt;true_positives&lt;/code&gt;, &lt;code&gt;true_negatives&lt;/code&gt;, &lt;code&gt;false_positives&lt;/code&gt; and &lt;code&gt;false_negatives&lt;/code&gt; that are used to compute the sensitivity at the given specificity. The threshold for the given specificity value is computed and used to evaluate the corresponding sensitivity.</source>
          <target state="translated">Esta m&amp;eacute;trica crea cuatro variables locales, &lt;code&gt;true_positives&lt;/code&gt; , &lt;code&gt;true_negatives&lt;/code&gt; , &lt;code&gt;false_positives&lt;/code&gt; y &lt;code&gt;false_negatives&lt;/code&gt; que se utilizan para calcular la sensibilidad en la especificidad dada. El umbral para el valor de especificidad dado se calcula y se utiliza para evaluar la sensibilidad correspondiente.</target>
        </trans-unit>
        <trans-unit id="ff9252130946c80b57ae4c5ee9b47938ca02b839" translate="yes" xml:space="preserve">
          <source>This metric creates four local variables, &lt;code&gt;true_positives&lt;/code&gt;, &lt;code&gt;true_negatives&lt;/code&gt;, &lt;code&gt;false_positives&lt;/code&gt; and &lt;code&gt;false_negatives&lt;/code&gt; that are used to compute the specificity at the given sensitivity. The threshold for the given sensitivity value is computed and used to evaluate the corresponding specificity.</source>
          <target state="translated">Esta m&amp;eacute;trica crea cuatro variables locales, &lt;code&gt;true_positives&lt;/code&gt; , &lt;code&gt;true_negatives&lt;/code&gt; , &lt;code&gt;false_positives&lt;/code&gt; y &lt;code&gt;false_negatives&lt;/code&gt; que se utilizan para calcular la especificidad a la sensibilidad dada. El umbral para el valor de sensibilidad dado se calcula y se usa para evaluar la especificidad correspondiente.</target>
        </trans-unit>
        <trans-unit id="fb652b4471c79604ae7dfb8ff87ca222abc482c6" translate="yes" xml:space="preserve">
          <source>This metric creates one variable, &lt;code&gt;total&lt;/code&gt;, that is used to compute the sum of &lt;code&gt;values&lt;/code&gt;. This is ultimately returned as &lt;code&gt;sum&lt;/code&gt;.</source>
          <target state="translated">Esta m&amp;eacute;trica crea una variable, &lt;code&gt;total&lt;/code&gt; , que se usa para calcular la suma de &lt;code&gt;values&lt;/code&gt; . Esto finalmente se devuelve como &lt;code&gt;sum&lt;/code&gt; a .</target>
        </trans-unit>
        <trans-unit id="77a69992763ecf548ab84fef5482d353d7a9cba3" translate="yes" xml:space="preserve">
          <source>This metric creates two local variables, &lt;code&gt;total&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt; that are used to compute the frequency with which &lt;code&gt;y_pred&lt;/code&gt; matches &lt;code&gt;y_true&lt;/code&gt;. This frequency is ultimately returned as &lt;code&gt;binary accuracy&lt;/code&gt;: an idempotent operation that simply divides &lt;code&gt;total&lt;/code&gt; by &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">Esta m&amp;eacute;trica crea dos variables locales, &lt;code&gt;total&lt;/code&gt; y &lt;code&gt;count&lt;/code&gt; , que se utilizan para calcular la frecuencia con la que &lt;code&gt;y_pred&lt;/code&gt; coincide con &lt;code&gt;y_true&lt;/code&gt; . Esta frecuencia se devuelve finalmente como &lt;code&gt;binary accuracy&lt;/code&gt; : una operaci&amp;oacute;n idempotente que simplemente divide el &lt;code&gt;total&lt;/code&gt; por el &lt;code&gt;count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10a549b6038018b3cebc025343c39cb24e67e040" translate="yes" xml:space="preserve">
          <source>This metric creates two local variables, &lt;code&gt;total&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt; that are used to compute the frequency with which &lt;code&gt;y_pred&lt;/code&gt; matches &lt;code&gt;y_true&lt;/code&gt;. This frequency is ultimately returned as &lt;code&gt;categorical accuracy&lt;/code&gt;: an idempotent operation that simply divides &lt;code&gt;total&lt;/code&gt; by &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">Esta m&amp;eacute;trica crea dos variables locales, &lt;code&gt;total&lt;/code&gt; y &lt;code&gt;count&lt;/code&gt; , que se utilizan para calcular la frecuencia con la que &lt;code&gt;y_pred&lt;/code&gt; coincide con &lt;code&gt;y_true&lt;/code&gt; . Esta frecuencia se devuelve finalmente como &lt;code&gt;categorical accuracy&lt;/code&gt; : una operaci&amp;oacute;n idempotente que simplemente divide el &lt;code&gt;total&lt;/code&gt; por el &lt;code&gt;count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d4e9dd5712eaf45fc10b998b8c6d4caf2e34bae" translate="yes" xml:space="preserve">
          <source>This metric creates two local variables, &lt;code&gt;total&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt; that are used to compute the frequency with which &lt;code&gt;y_pred&lt;/code&gt; matches &lt;code&gt;y_true&lt;/code&gt;. This frequency is ultimately returned as &lt;code&gt;sparse categorical accuracy&lt;/code&gt;: an idempotent operation that simply divides &lt;code&gt;total&lt;/code&gt; by &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">Esta m&amp;eacute;trica crea dos variables locales, &lt;code&gt;total&lt;/code&gt; y &lt;code&gt;count&lt;/code&gt; , que se utilizan para calcular la frecuencia con la que &lt;code&gt;y_pred&lt;/code&gt; coincide con &lt;code&gt;y_true&lt;/code&gt; . Esta frecuencia se devuelve en &amp;uacute;ltima instancia como una &lt;code&gt;sparse categorical accuracy&lt;/code&gt; : una operaci&amp;oacute;n idempotente que simplemente divide el &lt;code&gt;total&lt;/code&gt; por el &lt;code&gt;count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="300536328f19b08910251bd6b961009b9a37a3b7" translate="yes" xml:space="preserve">
          <source>This metric creates two local variables, &lt;code&gt;total&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt; that are used to compute the mean relative absolute error. This average is weighted by &lt;code&gt;sample_weight&lt;/code&gt;, and it is ultimately returned as &lt;code&gt;mean_relative_error&lt;/code&gt;: an idempotent operation that simply divides &lt;code&gt;total&lt;/code&gt; by &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">Esta m&amp;eacute;trica crea dos variables locales, &lt;code&gt;total&lt;/code&gt; y &lt;code&gt;count&lt;/code&gt; que se utilizan para calcular el error absoluto relativo medio. Este promedio se pondera por &lt;code&gt;sample_weight&lt;/code&gt; , y finalmente se devuelve como &lt;code&gt;mean_relative_error&lt;/code&gt; : una operaci&amp;oacute;n idempotente que simplemente divide el &lt;code&gt;total&lt;/code&gt; por el &lt;code&gt;count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aea998ffd50f56931370c8f2e5952f5d92b92150" translate="yes" xml:space="preserve">
          <source>This metric creates two local variables, &lt;code&gt;total&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt; that are used to compute the mean relative error. This is weighted by &lt;code&gt;sample_weight&lt;/code&gt;, and it is ultimately returned as &lt;code&gt;mean_relative_error&lt;/code&gt;: an idempotent operation that simply divides &lt;code&gt;total&lt;/code&gt; by &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bf885c318184cc4d7f8536f5a3a6cfc0be45917" translate="yes" xml:space="preserve">
          <source>This metric creates two local variables, &lt;code&gt;true_positives&lt;/code&gt; and &lt;code&gt;false_negatives&lt;/code&gt;, that are used to compute the recall. This value is ultimately returned as &lt;code&gt;recall&lt;/code&gt;, an idempotent operation that simply divides &lt;code&gt;true_positives&lt;/code&gt; by the sum of &lt;code&gt;true_positives&lt;/code&gt; and &lt;code&gt;false_negatives&lt;/code&gt;.</source>
          <target state="translated">Esta m&amp;eacute;trica crea dos variables locales, &lt;code&gt;true_positives&lt;/code&gt; y &lt;code&gt;false_negatives&lt;/code&gt; , que se utilizan para calcular la recuperaci&amp;oacute;n. Este valor se devuelve finalmente como &lt;code&gt;recall&lt;/code&gt; , una operaci&amp;oacute;n idempotente que simplemente divide &lt;code&gt;true_positives&lt;/code&gt; por la suma de &lt;code&gt;true_positives&lt;/code&gt; y &lt;code&gt;false_negatives&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="093560f8538560280d9ed1cd9a3cab29a6cbb355" translate="yes" xml:space="preserve">
          <source>This metric creates two variables, &lt;code&gt;total&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt; that are used to compute the average of &lt;code&gt;values&lt;/code&gt;. This average is ultimately returned as &lt;code&gt;mean&lt;/code&gt; which is an idempotent operation that simply divides &lt;code&gt;total&lt;/code&gt; by &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">Esta m&amp;eacute;trica crea dos variables, &lt;code&gt;total&lt;/code&gt; y &lt;code&gt;count&lt;/code&gt; que se utilizan para calcular el promedio de &lt;code&gt;values&lt;/code&gt; . Este promedio finalmente se devuelve como &lt;code&gt;mean&lt;/code&gt; que es una operaci&amp;oacute;n idempotente que simplemente divide el &lt;code&gt;total&lt;/code&gt; por el &lt;code&gt;count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0c9b94b35f1d2e4eb96d2ecbbedfd0249ca4dde6" translate="yes" xml:space="preserve">
          <source>This metric keeps the average cosine similarity between &lt;code&gt;predictions&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt; over a stream of data.</source>
          <target state="translated">Esta m&amp;eacute;trica mantiene la similitud de coseno promedio entre &lt;code&gt;predictions&lt;/code&gt; y &lt;code&gt;labels&lt;/code&gt; en un flujo de datos.</target>
        </trans-unit>
        <trans-unit id="418d70f20044dbd3397385f2c468b1eaa3216144" translate="yes" xml:space="preserve">
          <source>This model accepts sparse float inputs as well:</source>
          <target state="translated">Este modelo acepta también entradas de flotadores dispersos:</target>
        </trans-unit>
        <trans-unit id="3a4737a2c04c7eb94694e1e82664a0b0d934f20d" translate="yes" xml:space="preserve">
          <source>This model approximates the following function:</source>
          <target state="translated">Este modelo se aproxima a la siguiente función:</target>
        </trans-unit>
        <trans-unit id="82e7fe60bedc5bc6c52d1131a24d660c1d1e5baf" translate="yes" xml:space="preserve">
          <source>This model jointly train a linear and a dnn model.</source>
          <target state="translated">Este modelo entrena conjuntamente un modelo lineal y un modelo dnn.</target>
        </trans-unit>
        <trans-unit id="e8ea575479c33e1d3b54efb7336850606e620ed3" translate="yes" xml:space="preserve">
          <source>This module contains experimental &lt;code&gt;Dataset&lt;/code&gt; sources and transformations that can be used in conjunction with the &lt;a href=&quot;../../../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; API. Note that the &lt;a href=&quot;../../../data/experimental&quot;&gt;&lt;code&gt;tf.data.experimental&lt;/code&gt;&lt;/a&gt; API is not subject to the same backwards compatibility guarantees as &lt;a href=&quot;../../../data&quot;&gt;&lt;code&gt;tf.data&lt;/code&gt;&lt;/a&gt;, but we will provide deprecation advice in advance of removing existing functionality.</source>
          <target state="translated">Este m&amp;oacute;dulo contiene transformaciones y fuentes experimentales de &lt;code&gt;Dataset&lt;/code&gt; que se pueden usar junto con la API &lt;a href=&quot;../../../data/dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; &lt;/a&gt; . Tenga en cuenta que la API &lt;a href=&quot;../../../data/experimental&quot;&gt; &lt;code&gt;tf.data.experimental&lt;/code&gt; &lt;/a&gt; no est&amp;aacute; sujeta a las mismas garant&amp;iacute;as de compatibilidad con versiones anteriores que &lt;a href=&quot;../../../data&quot;&gt; &lt;code&gt;tf.data&lt;/code&gt; &lt;/a&gt; , pero proporcionaremos un consejo de desaprobaci&amp;oacute;n antes de eliminar la funcionalidad existente.</target>
        </trans-unit>
        <trans-unit id="048da49888cbf092642d30c4a165ddde49bb4a0b" translate="yes" xml:space="preserve">
          <source>This module contains experimental &lt;code&gt;Dataset&lt;/code&gt; sources and transformations that can be used in conjunction with the &lt;a href=&quot;dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; API. Note that the &lt;a href=&quot;experimental&quot;&gt;&lt;code&gt;tf.data.experimental&lt;/code&gt;&lt;/a&gt; API is not subject to the same backwards compatibility guarantees as &lt;a href=&quot;../data&quot;&gt;&lt;code&gt;tf.data&lt;/code&gt;&lt;/a&gt;, but we will provide deprecation advice in advance of removing existing functionality.</source>
          <target state="translated">Este m&amp;oacute;dulo contiene transformaciones y fuentes experimentales de &lt;code&gt;Dataset&lt;/code&gt; que se pueden usar junto con la API &lt;a href=&quot;dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; &lt;/a&gt; . Tenga en cuenta que la API &lt;a href=&quot;experimental&quot;&gt; &lt;code&gt;tf.data.experimental&lt;/code&gt; &lt;/a&gt; no est&amp;aacute; sujeta a las mismas garant&amp;iacute;as de compatibilidad con versiones anteriores que &lt;a href=&quot;../data&quot;&gt; &lt;code&gt;tf.data&lt;/code&gt; &lt;/a&gt; , pero proporcionaremos un consejo de desaprobaci&amp;oacute;n antes de eliminar la funcionalidad existente.</target>
        </trans-unit>
        <trans-unit id="458fef549ca5bb1cdd37d04e9f0b5b8e3b96d46e" translate="yes" xml:space="preserve">
          <source>This must be called by the constructors of subclasses.</source>
          <target state="translated">Esto debe ser llamado por los constructores de subclases.</target>
        </trans-unit>
        <trans-unit id="b854be37a7975d22746ea61f4632ebd3ee101333" translate="yes" xml:space="preserve">
          <source>This must be called by the constructors of subclasses. Note that Optimizer instances should not bind to a single graph, and so shouldn't keep Tensors as member variables. Generally you should be able to use the _set_hyper()/state.get_hyper() facility instead.</source>
          <target state="translated">Esto debe ser llamado por los constructores de subclases.Tenga en cuenta que las instancias del Optimizador no deben unirse a un solo gráfico,y por lo tanto no deben mantener los Tensores como variables de miembros.En general,debería poder usar la función _set_hyper()/state.get_hyper()en su lugar.</target>
        </trans-unit>
        <trans-unit id="10ca194e65aab7cdbd21fa158a845dc67377d2ce" translate="yes" xml:space="preserve">
          <source>This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False.</source>
          <target state="translated">Esto debe ser configurado antes de que se llame a start(),de lo contrario RuntimeError se eleva.Su valor inicial se hereda del hilo de creación;el hilo principal no es un hilo de demonio y,por lo tanto,todos los hilos creados en el hilo principal tienen como valor predeterminado demonio=Falso.</target>
        </trans-unit>
        <trans-unit id="0329801ef1692f0ddc2ae7e5af20ed6a131c6c7c" translate="yes" xml:space="preserve">
          <source>This only ensures that the data has made its way out of the process without any guarantees on whether it's written to disk. This means that the data would survive an application crash but not necessarily an OS crash.</source>
          <target state="translated">Esto sólo asegura que los datos han salido del proceso sin ninguna garantía de que estén escritos en un disco.Esto significa que los datos sobrevivirían a una caída de la aplicación pero no necesariamente a una caída del sistema operativo.</target>
        </trans-unit>
        <trans-unit id="739d09cc347d37887487c132a76071a68cf15e0c" translate="yes" xml:space="preserve">
          <source>This op accepts a ragged tensor with 1 ragged dimension containing only strings and outputs a ragged tensor with 1 ragged dimension containing ngrams of that string, joined along the innermost axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93e1dc6b2d1103564814280c522ceb3f62da8aaa" translate="yes" xml:space="preserve">
          <source>This op adds entries with the specified &lt;code&gt;default_value&lt;/code&gt; at index &lt;code&gt;[row, 0]&lt;/code&gt; for any row in the input that does not already have a value.</source>
          <target state="translated">Esta operaci&amp;oacute;n agrega entradas con el &lt;code&gt;default_value&lt;/code&gt; especificado en el &amp;iacute;ndice &lt;code&gt;[row, 0]&lt;/code&gt; para cualquier fila de la entrada que a&amp;uacute;n no tenga un valor.</target>
        </trans-unit>
        <trans-unit id="5fa1114f375b9880e62fbc5a662e7acc5ce57fbe" translate="yes" xml:space="preserve">
          <source>This op also returns an indicator vector shaped &lt;code&gt;[dense_shape[0]]&lt;/code&gt; such that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c96c116d1d672bbaf2e116ec518227e07309624" translate="yes" xml:space="preserve">
          <source>This op also returns an indicator vector such that</source>
          <target state="translated">Esta operación también devuelve un vector indicador tal que</target>
        </trans-unit>
        <trans-unit id="63eba777b467e98e8d9a395e0dc5bdd68e038be1" translate="yes" xml:space="preserve">
          <source>This op also supports decoding JPEGs and PNGs, though it is cleaner to use &lt;a href=&quot;../io/decode_image&quot;&gt;&lt;code&gt;tf.io.decode_image&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0a295b7a7559c4062aef820bad409706b47254e" translate="yes" xml:space="preserve">
          <source>This op also supports decoding JPEGs and PNGs, though it is cleaner to use &lt;a href=&quot;decode_image&quot;&gt;&lt;code&gt;tf.image.decode_image&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esta operaci&amp;oacute;n tambi&amp;eacute;n admite la decodificaci&amp;oacute;n de archivos JPEG y PNG, aunque es m&amp;aacute;s limpio usar &lt;a href=&quot;decode_image&quot;&gt; &lt;code&gt;tf.image.decode_image&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="483bb07454239e8342211e5a15919059fc6155be" translate="yes" xml:space="preserve">
          <source>This op also supports decoding JPEGs and PNGs, though it is cleaner to use &lt;a href=&quot;decode_image&quot;&gt;&lt;code&gt;tf.io.decode_image&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18fa4a39fc572b40f8f4dacf2470cf5be8ddff15" translate="yes" xml:space="preserve">
          <source>This op also supports decoding JPEGs and non-animated GIFs since the interface is the same, though it is cleaner to use &lt;a href=&quot;../io/decode_image&quot;&gt;&lt;code&gt;tf.io.decode_image&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b09a5c52da344b1eb6cdb8c06bc391b1939c62f" translate="yes" xml:space="preserve">
          <source>This op also supports decoding JPEGs and non-animated GIFs since the interface is the same, though it is cleaner to use &lt;a href=&quot;decode_image&quot;&gt;&lt;code&gt;tf.image.decode_image&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esta operaci&amp;oacute;n tambi&amp;eacute;n admite la decodificaci&amp;oacute;n de archivos JPEG y GIF no animados, ya que la interfaz es la misma, aunque es m&amp;aacute;s limpio usar &lt;a href=&quot;decode_image&quot;&gt; &lt;code&gt;tf.image.decode_image&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c9a007b21ccb02db71e5f851437184affd13ed0e" translate="yes" xml:space="preserve">
          <source>This op also supports decoding JPEGs and non-animated GIFs since the interface is the same, though it is cleaner to use &lt;a href=&quot;decode_image&quot;&gt;&lt;code&gt;tf.io.decode_image&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5122fab2d6910f76eb99cdafcfcf3c05b7df8003" translate="yes" xml:space="preserve">
          <source>This op also supports decoding PNGs and non-animated GIFs since the interface is the same, though it is cleaner to use &lt;a href=&quot;../io/decode_image&quot;&gt;&lt;code&gt;tf.io.decode_image&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42b9c8de7bcd9a44756c5acb1ef87661725abb7d" translate="yes" xml:space="preserve">
          <source>This op also supports decoding PNGs and non-animated GIFs since the interface is the same, though it is cleaner to use &lt;a href=&quot;decode_image&quot;&gt;&lt;code&gt;tf.image.decode_image&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esta operaci&amp;oacute;n tambi&amp;eacute;n admite la decodificaci&amp;oacute;n de PNG y GIF no animados, ya que la interfaz es la misma, aunque es m&amp;aacute;s limpio usar &lt;a href=&quot;decode_image&quot;&gt; &lt;code&gt;tf.image.decode_image&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4126fd2328e7484c2f21d905e8ae694800311e37" translate="yes" xml:space="preserve">
          <source>This op also supports decoding PNGs and non-animated GIFs since the interface is the same, though it is cleaner to use &lt;a href=&quot;decode_image&quot;&gt;&lt;code&gt;tf.io.decode_image&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd4491d1a6601d1e84570bcd363e85b0e7d5c12e" translate="yes" xml:space="preserve">
          <source>This op assumes that there is at least one id for each row in the dense tensor represented by sp_ids (i.e. there are no rows with empty features), and that all the indices of sp_ids are in canonical row-major order.</source>
          <target state="translated">Esta operación asume que hay al menos un id por cada fila en el tensor denso representado por sp_ids (es decir,no hay filas con rasgos vacíos),y que todos los índices de sp_ids están en el orden canónico de fila mayor.</target>
        </trans-unit>
        <trans-unit id="ff99bdd028bae5711c127316ae24a743c30a9349" translate="yes" xml:space="preserve">
          <source>This op can be substantially more efficient than &lt;a href=&quot;case&quot;&gt;&lt;code&gt;tf.case&lt;/code&gt;&lt;/a&gt; when exactly one branch will be selected. &lt;a href=&quot;switch_case&quot;&gt;&lt;code&gt;tf.switch_case&lt;/code&gt;&lt;/a&gt; is more like a C++ switch/case statement than &lt;a href=&quot;case&quot;&gt;&lt;code&gt;tf.case&lt;/code&gt;&lt;/a&gt;, which is more like an if/elif/elif/else chain.</source>
          <target state="translated">Esta &lt;a href=&quot;case&quot;&gt; &lt;code&gt;tf.case&lt;/code&gt; &lt;/a&gt; puede ser sustancialmente m&amp;aacute;s eficiente que tf.case cuando se seleccionar&amp;aacute; exactamente una rama. &lt;a href=&quot;switch_case&quot;&gt; &lt;code&gt;tf.switch_case&lt;/code&gt; &lt;/a&gt; se parece m&amp;aacute;s a una instrucci&amp;oacute;n switch / case de C ++ que a &lt;a href=&quot;case&quot;&gt; &lt;code&gt;tf.case&lt;/code&gt; &lt;/a&gt; , que se parece m&amp;aacute;s a una cadena if / elif / elif / else.</target>
        </trans-unit>
        <trans-unit id="88d4e65ada667e4924bd61aa913d0b719a3489bc" translate="yes" xml:space="preserve">
          <source>This op can be used to override the gradient for complicated functions. For example, suppose y = f(x) and we wish to apply a custom function g for backprop such that dx = g(dy). In Python,</source>
          <target state="translated">Esta operación puede utilizarse para anular el gradiente para funciones complicadas.Por ejemplo,supongamos que y=f(x)y deseamos aplicar una función personalizada g para la retropropulsión tal que dx=g(dy).En Python,</target>
        </trans-unit>
        <trans-unit id="a70d4bf94e1aa31fec2daa089308a302909ea19e" translate="yes" xml:space="preserve">
          <source>This op collects patches from the input image, as if applying a convolution. All extracted patches are stacked in the depth (last) dimension of the output.</source>
          <target state="translated">Esta operación recoge parches de la imagen de entrada,como si se aplicara una convolución.Todos los parches extraídos se apilan en la dimensión de profundidad (última)de la salida.</target>
        </trans-unit>
        <trans-unit id="b607b039f446accd9cc9d66850f0e1a0f18bc805" translate="yes" xml:space="preserve">
          <source>This op consumes a lock created by &lt;code&gt;MutexLock&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c18dad5d5d6899466a10670d53475ca56625c85" translate="yes" xml:space="preserve">
          <source>This op converts between data types, scaling the values appropriately before casting.</source>
          <target state="translated">Esta opción convierte entre los tipos de datos,escalando los valores apropiadamente antes de lanzarlos.</target>
        </trans-unit>
        <trans-unit id="cc622534ae3fa62514818ea7bebb60dccd64c26d" translate="yes" xml:space="preserve">
          <source>This op creates a &lt;a href=&quot;https://www.tensorflow.org/code/tensorflow/core/framework/summary.proto&quot;&gt;&lt;code&gt;Summary&lt;/code&gt;&lt;/a&gt; protocol buffer that contains the union of all the values in the input summaries.</source>
          <target state="translated">Esta operaci&amp;oacute;n crea un b&amp;uacute;fer de protocolo de &lt;a href=&quot;https://www.tensorflow.org/code/tensorflow/core/framework/summary.proto&quot;&gt; &lt;code&gt;Summary&lt;/code&gt; &lt;/a&gt; que contiene la uni&amp;oacute;n de todos los valores en los res&amp;uacute;menes de entrada.</target>
        </trans-unit>
        <trans-unit id="9d0ac8a3b320dffdcce993580747b2ce812c1930" translate="yes" xml:space="preserve">
          <source>This op creates a hash table, specifying the type of its keys and values. Before using the table you will have to initialize it. After initialization the table will be immutable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="656267a02d31eb1fe3e2f93fe32ae0ecba89ac70" translate="yes" xml:space="preserve">
          <source>This op creates a mutable hash table, specifying the type of its keys and values. Each value must be a scalar. Data can be inserted into the table using the insert operations. It does not support the initialization operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="889ef924ddf97837ebe886303d19b68a45247ddd" translate="yes" xml:space="preserve">
          <source>This op creates a mutable hash table, specifying the type of its keys and values. Each value must be a vector. Data can be inserted into the table using the insert operations. It does not support the initialization operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26981876c06a781e2a944a631697cc4482c0e90e" translate="yes" xml:space="preserve">
          <source>This op cuts a rectangular part out of &lt;code&gt;image&lt;/code&gt;. The top-left corner of the returned image is at &lt;code&gt;offset_height, offset_width&lt;/code&gt; in &lt;code&gt;image&lt;/code&gt;, and its lower-right corner is at &lt;code&gt;offset_height + target_height, offset_width + target_width&lt;/code&gt;.</source>
          <target state="translated">Esta operaci&amp;oacute;n corta una parte rectangular de la &lt;code&gt;image&lt;/code&gt; n . La esquina superior izquierda de la imagen devuelta est&amp;aacute; en &lt;code&gt;offset_height, offset_width&lt;/code&gt; en la &lt;code&gt;image&lt;/code&gt; n , y su esquina inferior derecha est&amp;aacute; en &lt;code&gt;offset_height + target_height, offset_width + target_width&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6b4a71613ffb1856f3dff1fb3fb7c9c68b7515a" translate="yes" xml:space="preserve">
          <source>This op decompresses each element of the &lt;code&gt;bytes&lt;/code&gt; input &lt;code&gt;Tensor&lt;/code&gt;, which is assumed to be compressed using the given &lt;code&gt;compression_type&lt;/code&gt;.</source>
          <target state="translated">Esta operaci&amp;oacute;n descomprime cada elemento del &lt;code&gt;Tensor&lt;/code&gt; entrada de &lt;code&gt;bytes&lt;/code&gt; , que se supone que est&amp;aacute; comprimido usando el tipo de &lt;code&gt;compression_type&lt;/code&gt; dado .</target>
        </trans-unit>
        <trans-unit id="3ca6b920060424a35214647a956bfc883925dbdc" translate="yes" xml:space="preserve">
          <source>This op determines the maximum scale_factor that would map the initial [input_min, input_max] range to a range that lies within the representable quantized range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e56e06059315b7dda1620664824a84ff8d7bc3c" translate="yes" xml:space="preserve">
          <source>This op does not &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.13.0/user/basics.broadcasting.html&quot;&gt;broadcast&lt;/a&gt; its inputs. If you need broadcasting, use &lt;a href=&quot;add&quot;&gt;&lt;code&gt;tf.math.add&lt;/code&gt;&lt;/a&gt; (or the &lt;code&gt;+&lt;/code&gt; operator) instead.</source>
          <target state="translated">Esta operaci&amp;oacute;n no &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.13.0/user/basics.broadcasting.html&quot;&gt;transmite&lt;/a&gt; sus entradas. Si necesita transmitir, use &lt;a href=&quot;add&quot;&gt; &lt;code&gt;tf.math.add&lt;/code&gt; &lt;/a&gt; (o el operador &lt;code&gt;+&lt;/code&gt; ) en su lugar.</target>
        </trans-unit>
        <trans-unit id="32ac8411f8421961cf71053e4e574031251a142f" translate="yes" xml:space="preserve">
          <source>This op does nothing if &lt;code&gt;offset_*&lt;/code&gt; is zero and the image already has size &lt;code&gt;target_height&lt;/code&gt; by &lt;code&gt;target_width&lt;/code&gt;.</source>
          <target state="translated">Esta &lt;code&gt;offset_*&lt;/code&gt; no hace nada si offset_ * es cero y la imagen ya tiene el tama&amp;ntilde;o &lt;code&gt;target_height&lt;/code&gt; por &lt;code&gt;target_width&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59b86b1f9adf8ca0901c6f9e9aeaabfe44733a8c" translate="yes" xml:space="preserve">
          <source>This op exists to consume a tensor created by &lt;code&gt;MutexLock&lt;/code&gt; (other than direct control dependencies). It should be the only that consumes the tensor, and will raise an error if it is not. Its only purpose is to keep the mutex lock tensor alive until it is consumed by this op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd2475b0227c59a4b9b579ebadb0eb003bb5c048" translate="yes" xml:space="preserve">
          <source>This op expects to receive audio data as an input, stored as floats in the range -1 to 1, together with a window width in samples, and a stride specifying how far to move the window between slices. From this it generates a three dimensional output. The first dimension is for the channels in the input, so a stereo audio input would have two here for example. The second dimension is time, with successive frequency slices. The third dimension has an amplitude value for each frequency during that time slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25438ddc9615e500386687f63662f19536c3cd65" translate="yes" xml:space="preserve">
          <source>This op first slices &lt;code&gt;input&lt;/code&gt; along the dimension &lt;code&gt;batch_axis&lt;/code&gt;, and for each slice &lt;code&gt;i&lt;/code&gt;, reverses the first &lt;code&gt;seq_lengths[i]&lt;/code&gt; elements along the dimension &lt;code&gt;seq_axis&lt;/code&gt;.</source>
          <target state="translated">Esta &lt;code&gt;seq_lengths[i]&lt;/code&gt; primero divide la &lt;code&gt;input&lt;/code&gt; largo de la dimensi&amp;oacute;n &lt;code&gt;batch_axis&lt;/code&gt; , y para cada segmento &lt;code&gt;i&lt;/code&gt; , invierte los primeros elementos seq_lengths [i] a lo largo de la dimensi&amp;oacute;n &lt;code&gt;seq_axis&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c2da47231c9225efc906681c480ffa9fdcb8257" translate="yes" xml:space="preserve">
          <source>This op first slices &lt;code&gt;input&lt;/code&gt; along the dimension &lt;code&gt;batch_dim&lt;/code&gt;, and for each slice &lt;code&gt;i&lt;/code&gt;, reverses the first &lt;code&gt;seq_lengths[i]&lt;/code&gt; elements along the dimension &lt;code&gt;seq_dim&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fb605b6d0eb10d714ac2254180881c3166d465a" translate="yes" xml:space="preserve">
          <source>This op implements the CTC loss as presented in (Graves et al., 2006).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d8869736a8a0caa172690fd78df7a0c80acf40c" translate="yes" xml:space="preserve">
          <source>This op implements the CTC loss as presented in (Graves et al., 2016).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7225b3ea22ec4deb1adfd4a695bd1a7623e154b" translate="yes" xml:space="preserve">
          <source>This op implements the CTC loss as presented in the article:</source>
          <target state="translated">Esta operación implementa la pérdida del CTC como se presenta en el artículo:</target>
        </trans-unit>
        <trans-unit id="6fcde341bc16f91f21275b0c9eb0d836f06faca1" translate="yes" xml:space="preserve">
          <source>This op inserts a single entry for every row that doesn't have any values. The index is created as &lt;code&gt;[row, 0, ..., 0]&lt;/code&gt; and the inserted value is &lt;code&gt;default_value&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2221b86f1776b0a82d12fa22eaebb9f19fcdaeda" translate="yes" xml:space="preserve">
          <source>This op is a convenience wrapper around &lt;code&gt;sparse_to_dense&lt;/code&gt; for &lt;code&gt;SparseTensor&lt;/code&gt;s.</source>
          <target state="translated">Esta &lt;code&gt;sparse_to_dense&lt;/code&gt; es una envoltura de conveniencia alrededor de sparse_to_dense para &lt;code&gt;SparseTensor&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="9bcf7c2af4594b54e144cbf824cb1c395a0dff7e" translate="yes" xml:space="preserve">
          <source>This op is being phased out in favor of TensorSummaryV2, which lets callers pass a tag as well as a serialized SummaryMetadata proto string that contains plugin-specific data. We will keep this op to maintain backwards compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="498581ecde1f847b44ae5faacdf090686c5a82aa" translate="yes" xml:space="preserve">
          <source>This op is conceptually identical to,</source>
          <target state="translated">Esta operación es conceptualmente idéntica a,</target>
        </trans-unit>
        <trans-unit id="e11c482ba528e17a7aaf9d69ed66f29f71a93708" translate="yes" xml:space="preserve">
          <source>This op is deprecated and will be removed in the future. Prefer &lt;a href=&quot;../nn/batch_normalization&quot;&gt;&lt;code&gt;tf.nn.batch_normalization&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="939958da045f886ccce510657fd3f21292de978d" translate="yes" xml:space="preserve">
          <source>This op is deprecated. Prefer &lt;a href=&quot;../nn/batch_normalization&quot;&gt;&lt;code&gt;tf.nn.batch_normalization&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1fddd748b0417b58ea1729816edada8cf15be10" translate="yes" xml:space="preserve">
          <source>This op is deprecated. See &lt;a href=&quot;../../../nn/batch_normalization&quot;&gt;&lt;code&gt;tf.nn.batch_normalization&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esta operaci&amp;oacute;n est&amp;aacute; en desuso. Consulte &lt;a href=&quot;../../../nn/batch_normalization&quot;&gt; &lt;code&gt;tf.nn.batch_normalization&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="faec970c7a84c7f84287e5993964bd296d88974e" translate="yes" xml:space="preserve">
          <source>This op is deprecated. See &lt;a href=&quot;../nn/batch_normalization&quot;&gt;&lt;code&gt;tf.nn.batch_normalization&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="350e179bf73709c36862e34c13946cb30d6be41a" translate="yes" xml:space="preserve">
          <source>This op is deprecated. See &lt;a href=&quot;batch_normalization&quot;&gt;&lt;code&gt;tf.nn.batch_normalization&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esta operaci&amp;oacute;n est&amp;aacute; en desuso. Consulte &lt;a href=&quot;batch_normalization&quot;&gt; &lt;code&gt;tf.nn.batch_normalization&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f5f21db00ede271aa47c92ca1afb2548ebae0215" translate="yes" xml:space="preserve">
          <source>This op is equivalent to applying the normal &lt;a href=&quot;../nn/softmax&quot;&gt;&lt;code&gt;tf.nn.softmax()&lt;/code&gt;&lt;/a&gt; to each innermost logical submatrix with shape &lt;code&gt;[B, C]&lt;/code&gt;, but with the catch that &lt;em&gt;the implicitly zero elements do not participate&lt;/em&gt;. Specifically, the algorithm is equivalent to the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfe73bfb3165baeb1cd799227e5df39e5edc40e8" translate="yes" xml:space="preserve">
          <source>This op is equivalent to applying the normal &lt;a href=&quot;../nn/softmax&quot;&gt;&lt;code&gt;tf.nn.softmax()&lt;/code&gt;&lt;/a&gt; to each innermost logical submatrix with shape &lt;code&gt;[B, C]&lt;/code&gt;, but with the catch that &lt;em&gt;the implicitly zero elements do not participate&lt;/em&gt;. Specifically, the algorithm is equivalent to:</source>
          <target state="translated">Esta &lt;a href=&quot;../nn/softmax&quot;&gt; &lt;code&gt;tf.nn.softmax()&lt;/code&gt; &lt;/a&gt; es equivalente a aplicar el tf.nn.softmax () normal a cada submatriz l&amp;oacute;gica m&amp;aacute;s interna con forma &lt;code&gt;[B, C]&lt;/code&gt; , pero con la trampa de que &lt;em&gt;los elementos impl&amp;iacute;citamente cero no participan&lt;/em&gt; . Espec&amp;iacute;ficamente, el algoritmo es equivalente a:</target>
        </trans-unit>
        <trans-unit id="9f3c57195c3a48d6087d2de6a616b3e7ac7825fb" translate="yes" xml:space="preserve">
          <source>This op is hidden from public in Python. It is used by TensorFlow Debugger to register gradient tensors for gradient debugging. This op operates on non-reference-type tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5208058dc424b56d5683c09cc9ca79f806771d57" translate="yes" xml:space="preserve">
          <source>This op is hidden from public in Python. It is used by TensorFlow Debugger to register gradient tensors for gradient debugging. This op operates on reference-type tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42f43d3073e8761b09396618e2f19e046d1dc61b" translate="yes" xml:space="preserve">
          <source>This op is meant only for debugging / testing, and its interface is not expected to be stable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf3e5eda158a5f12c2f2da1b9b93833d5ff71185" translate="yes" xml:space="preserve">
          <source>This op is only defined for complex matrices. If A is positive-definite and real, then casting to a complex matrix, taking the logarithm and casting back to a real matrix will give the correct result.</source>
          <target state="translated">Esta operación sólo está definida para matrices complejas.Si A es positivo-definido y real,entonces echar a una matriz compleja,tomando el logaritmo y echando de nuevo a una matriz real dará el resultado correcto.</target>
        </trans-unit>
        <trans-unit id="b4088dd89f372d9134efcda4f21dccb2a4e43e51" translate="yes" xml:space="preserve">
          <source>This op is similar to &lt;code&gt;tf.strings.decode(...)&lt;/code&gt;, but it also returns the start offset for each character in its respective string. This information can be used to align the characters with the original byte sequence.</source>
          <target state="translated">Esta &lt;code&gt;tf.strings.decode(...)&lt;/code&gt; es similar a tf.strings.decode (...) , pero tambi&amp;eacute;n devuelve el desplazamiento de inicio para cada car&amp;aacute;cter en su cadena respectiva. Esta informaci&amp;oacute;n se puede utilizar para alinear los caracteres con la secuencia de bytes original.</target>
        </trans-unit>
        <trans-unit id="231193f912eb9ecede37b6d2bd24ac7965dab82e" translate="yes" xml:space="preserve">
          <source>This op is used as a placeholder in If branch functions. It doesn't provide a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30dc65726d5913cc5cf094798e27be8207b68832" translate="yes" xml:space="preserve">
          <source>This op is used during session initialization when a Scaffold is initialized without specifying the local_init_op arg. It includes &lt;a href=&quot;../local_variables_initializer&quot;&gt;&lt;code&gt;tf.compat.v1.local_variables_initializer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../tables_initializer&quot;&gt;&lt;code&gt;tf.compat.v1.tables_initializer&lt;/code&gt;&lt;/a&gt;, and also initializes local session resources.</source>
          <target state="translated">Esta operaci&amp;oacute;n se utiliza durante la inicializaci&amp;oacute;n de la sesi&amp;oacute;n cuando se inicializa un Scaffold sin especificar el argumento local_init_op. Incluye &lt;a href=&quot;../local_variables_initializer&quot;&gt; &lt;code&gt;tf.compat.v1.local_variables_initializer&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../tables_initializer&quot;&gt; &lt;code&gt;tf.compat.v1.tables_initializer&lt;/code&gt; &lt;/a&gt; y tambi&amp;eacute;n inicializa los recursos de la sesi&amp;oacute;n local.</target>
        </trans-unit>
        <trans-unit id="27d759b10e3031b72c69cecb21d0a5f2a1e56b50" translate="yes" xml:space="preserve">
          <source>This op is used together with &lt;code&gt;Exit&lt;/code&gt; to create loops in the graph. The unique &lt;code&gt;frame_name&lt;/code&gt; is used by the &lt;code&gt;Executor&lt;/code&gt; to identify frames. If &lt;code&gt;is_constant&lt;/code&gt; is true, &lt;code&gt;output&lt;/code&gt; is a constant in the child frame; otherwise it may be changed in the child frame. At most &lt;code&gt;parallel_iterations&lt;/code&gt; iterations are run in parallel in the child frame.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d539ed4cc2d3820ae7fed70f08ee95780da8755" translate="yes" xml:space="preserve">
          <source>This op may use some OS-provided source of non-determinism (e.g. an RNG), so each execution will give different results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7494eb2e4d00b6f1a2a80a896b2a97c11ea84bbb" translate="yes" xml:space="preserve">
          <source>This op only parses the image header, so it is much faster than DecodeJpeg.</source>
          <target state="translated">Esta operación sólo analiza el encabezado de la imagen,por lo que es mucho más rápido que DecodeJpeg.</target>
        </trans-unit>
        <trans-unit id="256678fd9ba7a89e98c94dad29bebb27865a6123" translate="yes" xml:space="preserve">
          <source>This op parses a serialized sequence example into a tuple of dictionaries, each mapping keys to &lt;code&gt;Tensor&lt;/code&gt; and &lt;code&gt;SparseTensor&lt;/code&gt; objects. The first dictionary contains mappings for keys appearing in &lt;code&gt;context_features&lt;/code&gt;, and the second dictionary contains mappings for keys appearing in &lt;code&gt;sequence_features&lt;/code&gt;.</source>
          <target state="translated">Esta operaci&amp;oacute;n analiza un ejemplo de secuencia serializada en una tupla de diccionarios, cada una de las cuales &lt;code&gt;SparseTensor&lt;/code&gt; claves a los objetos &lt;code&gt;Tensor&lt;/code&gt; y SparseTensor . El primer diccionario contiene asignaciones para claves que aparecen en &lt;code&gt;context_features&lt;/code&gt; , y el segundo diccionario contiene asignaciones para claves que aparecen en &lt;code&gt;sequence_features&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b74d19b6cde7e379b7fc76473e78e58968efe064" translate="yes" xml:space="preserve">
          <source>This op parses serialized examples into a dictionary mapping keys to &lt;code&gt;Tensor&lt;/code&gt;, &lt;code&gt;SparseTensor&lt;/code&gt;, and &lt;code&gt;RaggedTensor&lt;/code&gt; objects. &lt;code&gt;features&lt;/code&gt; is a dict from keys to &lt;code&gt;VarLenFeature&lt;/code&gt;, &lt;code&gt;RaggedFeature&lt;/code&gt;, &lt;code&gt;SparseFeature&lt;/code&gt;, and &lt;code&gt;FixedLenFeature&lt;/code&gt; objects. Each &lt;code&gt;VarLenFeature&lt;/code&gt; and &lt;code&gt;SparseFeature&lt;/code&gt; is mapped to a &lt;code&gt;SparseTensor&lt;/code&gt;; each &lt;code&gt;RaggedFeature&lt;/code&gt; is mapped to a &lt;code&gt;RaggedTensor&lt;/code&gt;; and each &lt;code&gt;FixedLenFeature&lt;/code&gt; is mapped to a &lt;code&gt;Tensor&lt;/code&gt;. See &lt;a href=&quot;../../io/parse_example&quot;&gt;&lt;code&gt;tf.io.parse_example&lt;/code&gt;&lt;/a&gt; for more details about feature dictionaries.</source>
          <target state="translated">Esta operaci&amp;oacute;n analiza ejemplos serializados en un diccionario que &lt;code&gt;SparseTensor&lt;/code&gt; &lt;code&gt;RaggedTensor&lt;/code&gt; objetos &lt;code&gt;Tensor&lt;/code&gt; , SparseTensor y RaggedTensor . &lt;code&gt;features&lt;/code&gt; es un diccionario de claves a los &lt;code&gt;VarLenFeature&lt;/code&gt; , &lt;code&gt;RaggedFeature&lt;/code&gt; , &lt;code&gt;SparseFeature&lt;/code&gt; y &lt;code&gt;FixedLenFeature&lt;/code&gt; . Cada &lt;code&gt;VarLenFeature&lt;/code&gt; y &lt;code&gt;SparseFeature&lt;/code&gt; se asigna a un &lt;code&gt;SparseTensor&lt;/code&gt; ; cada &lt;code&gt;RaggedFeature&lt;/code&gt; se asigna a un &lt;code&gt;RaggedTensor&lt;/code&gt; ; y cada &lt;code&gt;FixedLenFeature&lt;/code&gt; se asigna a un &lt;code&gt;Tensor&lt;/code&gt; . Ver &lt;a href=&quot;../../io/parse_example&quot;&gt; &lt;code&gt;tf.io.parse_example&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s detalles sobre los diccionarios de funciones.</target>
        </trans-unit>
        <trans-unit id="845b399d2e9c5818b169dacff650d84da1b8a72a" translate="yes" xml:space="preserve">
          <source>This op parses serialized examples into a dictionary mapping keys to &lt;code&gt;Tensor&lt;/code&gt;&lt;code&gt;SparseTensor&lt;/code&gt;, and &lt;code&gt;RaggedTensor&lt;/code&gt; objects. &lt;code&gt;features&lt;/code&gt; is a dict from keys to &lt;code&gt;VarLenFeature&lt;/code&gt;, &lt;code&gt;SparseFeature&lt;/code&gt;, &lt;code&gt;RaggedFeature&lt;/code&gt;, and &lt;code&gt;FixedLenFeature&lt;/code&gt; objects. Each &lt;code&gt;VarLenFeature&lt;/code&gt; and &lt;code&gt;SparseFeature&lt;/code&gt; is mapped to a &lt;code&gt;SparseTensor&lt;/code&gt;; each &lt;code&gt;FixedLenFeature&lt;/code&gt; is mapped to a &lt;code&gt;Tensor&lt;/code&gt;; and each &lt;code&gt;RaggedFeature&lt;/code&gt; is mapped to a &lt;code&gt;RaggedTensor&lt;/code&gt;.</source>
          <target state="translated">Esta operaci&amp;oacute;n analiza ejemplos serializados en un diccionario que &lt;code&gt;SparseTensor&lt;/code&gt; claves a los objetos &lt;code&gt;Tensor&lt;/code&gt; SparseTensor y &lt;code&gt;RaggedTensor&lt;/code&gt; . &lt;code&gt;features&lt;/code&gt; es un diccionario de claves a los &lt;code&gt;VarLenFeature&lt;/code&gt; , &lt;code&gt;SparseFeature&lt;/code&gt; , &lt;code&gt;RaggedFeature&lt;/code&gt; y &lt;code&gt;FixedLenFeature&lt;/code&gt; . Cada &lt;code&gt;VarLenFeature&lt;/code&gt; y &lt;code&gt;SparseFeature&lt;/code&gt; se asigna a un &lt;code&gt;SparseTensor&lt;/code&gt; ; cada &lt;code&gt;FixedLenFeature&lt;/code&gt; se asigna a un &lt;code&gt;Tensor&lt;/code&gt; ; y cada &lt;code&gt;RaggedFeature&lt;/code&gt; se asigna a un &lt;code&gt;RaggedTensor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="787b46fef668ea2442d8cf59e886173e8f1beeb1" translate="yes" xml:space="preserve">
          <source>This op parses serialized sequence examples into a tuple of dictionaries, each mapping keys to &lt;code&gt;Tensor&lt;/code&gt; and &lt;code&gt;SparseTensor&lt;/code&gt; objects. The first dictionary contains mappings for keys appearing in &lt;code&gt;context_features&lt;/code&gt;, and the second dictionary contains mappings for keys appearing in &lt;code&gt;sequence_features&lt;/code&gt;.</source>
          <target state="translated">Esta operaci&amp;oacute;n analiza ejemplos de secuencias serializadas en una tupla de diccionarios, cada una de las cuales &lt;code&gt;SparseTensor&lt;/code&gt; claves a objetos &lt;code&gt;Tensor&lt;/code&gt; y SparseTensor . El primer diccionario contiene asignaciones para claves que aparecen en &lt;code&gt;context_features&lt;/code&gt; , y el segundo diccionario contiene asignaciones para claves que aparecen en &lt;code&gt;sequence_features&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4fe7f65a801aad08671f34a64293fcb18c9780f3" translate="yes" xml:space="preserve">
          <source>This op produces Region of Interests from given bounding boxes(bbox_deltas) encoded wrt anchors according to eq.2 in arXiv:1506.01497</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ca1b1701aa5c064253c44ce1aad741cb653df7b" translate="yes" xml:space="preserve">
          <source>This op reports an &lt;code&gt;InvalidArgument&lt;/code&gt; error if any value is not finite.</source>
          <target state="translated">Esta &lt;code&gt;InvalidArgument&lt;/code&gt; informa un error de InvalidArgument si alg&amp;uacute;n valor no es finito.</target>
        </trans-unit>
        <trans-unit id="a524bdef26722689a646035ff3a30a89b59c896f" translate="yes" xml:space="preserve">
          <source>This op runs in &lt;code&gt;O(M log M)&lt;/code&gt; time, where &lt;code&gt;M&lt;/code&gt; is the total number of non-empty values across all inputs. This is due to the need for an internal sort in order to concatenate efficiently across an arbitrary dimension.</source>
          <target state="translated">Esta operaci&amp;oacute;n se ejecuta en tiempo &lt;code&gt;O(M log M)&lt;/code&gt; , donde &lt;code&gt;M&lt;/code&gt; es el n&amp;uacute;mero total de valores no vac&amp;iacute;os en todas las entradas. Esto se debe a la necesidad de un ordenamiento interno para concatenar de manera eficiente en una dimensi&amp;oacute;n arbitraria.</target>
        </trans-unit>
        <trans-unit id="7aad9bcdb175c316d0cd0c518023c08cbf3d7ccf" translate="yes" xml:space="preserve">
          <source>This op simply returns its first input, which is assumed to have been sliced from the Tensors returned by TPUEmbeddingDequeueActivations. The presence of this op, and its first argument being a trainable Variable, enables automatic differentiation of graphs containing embeddings via the TPU Embedding Python libraries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d483631861e7a19423d30b1c89ca7bd9af9deb77" translate="yes" xml:space="preserve">
          <source>This op simulates the precision loss from the quantized forward pass by:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82f92515415e66dd8fe55e82e86a429d52767b5f" translate="yes" xml:space="preserve">
          <source>This op takes an N-dimensional &lt;code&gt;Tensor&lt;/code&gt;, &lt;code&gt;RaggedTensor&lt;/code&gt;, or &lt;code&gt;SparseTensor&lt;/code&gt;, and returns an N-dimensional int64 SparseTensor where element &lt;code&gt;[i0...i[axis], j]&lt;/code&gt; contains the number of times the value &lt;code&gt;j&lt;/code&gt; appears in slice &lt;code&gt;[i0...i[axis], :]&lt;/code&gt; of the input tensor. Currently, only N=0 and N=-1 are supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad5fa7632826618c2d76f2d4a4592c97b627433a" translate="yes" xml:space="preserve">
          <source>This op takes in the upstream gradient w.r.t. non-empty values of the sliced &lt;code&gt;SparseTensor&lt;/code&gt;, and outputs the gradients w.r.t. the non-empty values of input &lt;code&gt;SparseTensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edecba4e86376242d273ba622ca63b2965a5a438" translate="yes" xml:space="preserve">
          <source>This op translates a tensor containing Example records, encoded using the &lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/proto3#json&quot;&gt;standard JSON mapping&lt;/a&gt;, into a tensor containing the same records encoded as binary protocol buffers. The resulting tensor can then be fed to any of the other Example-parsing ops.</source>
          <target state="translated">Esta operaci&amp;oacute;n traduce un tensor que contiene registros de ejemplo, codificados con el &lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/proto3#json&quot;&gt;mapeo JSON est&amp;aacute;ndar&lt;/a&gt; , en un tensor que contiene los mismos registros codificados como b&amp;uacute;fer de protocolo binario. El tensor resultante se puede alimentar a cualquiera de las otras operaciones de an&amp;aacute;lisis sint&amp;aacute;ctico de ejemplos.</target>
        </trans-unit>
        <trans-unit id="aed6dcb7e60458715d6ef5c3c8eddc95029d6141" translate="yes" xml:space="preserve">
          <source>This op uses the algorithm by Marsaglia et al. to acquire samples via transformation-rejection from pairs of uniform and normal random variables. See &lt;a href=&quot;http://dl.acm.org/citation.cfm?id=358414&quot;&gt;http://dl.acm.org/citation.cfm?id=358414&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c381caf80ba3167793d4166edbbb6bfbc8d1b9b9" translate="yes" xml:space="preserve">
          <source>This op uses two algorithms, depending on rate. If rate &amp;gt;= 10, then the algorithm by Hormann is used to acquire samples via transformation-rejection. See &lt;a href=&quot;http://www.sciencedirect.com/science/article/pii/0167668793909974&quot;&gt;http://www.sciencedirect.com/science/article/pii/0167668793909974&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49b534f6ddaaf2bd4e7772b31b4be9cf92fcfbd7" translate="yes" xml:space="preserve">
          <source>This operation blocks until that finishes.</source>
          <target state="translated">Esta operación se bloquea hasta que termine.</target>
        </trans-unit>
        <trans-unit id="14d876872d62a220ab5753fd3b852a5a6bcb76ef" translate="yes" xml:space="preserve">
          <source>This operation can be used with &lt;code&gt;output_encoding = input_encoding&lt;/code&gt; to enforce correct formatting for inputs even if they are already in the desired encoding.</source>
          <target state="translated">Esta operaci&amp;oacute;n se puede utilizar con &lt;code&gt;output_encoding = input_encoding&lt;/code&gt; para imponer el formato correcto para las entradas, incluso si ya est&amp;aacute;n en la codificaci&amp;oacute;n deseada.</target>
        </trans-unit>
        <trans-unit id="bf8af72c7ec5c03a0a302901ae0b02f8840934f4" translate="yes" xml:space="preserve">
          <source>This operation computes</source>
          <target state="translated">Esta operación calcula</target>
        </trans-unit>
        <trans-unit id="df2c8f127a35805203dd552ccd88657669212f89" translate="yes" xml:space="preserve">
          <source>This operation computes the inverse of an index permutation. It takes a 1-D integer tensor &lt;code&gt;x&lt;/code&gt;, which represents the indices of a zero-based array, and swaps each value with its index position. In other words, for an output tensor &lt;code&gt;y&lt;/code&gt; and an input tensor &lt;code&gt;x&lt;/code&gt;, this operation computes the following:</source>
          <target state="translated">Esta operaci&amp;oacute;n calcula el inverso de una permutaci&amp;oacute;n de &amp;iacute;ndice. Toma un tensor entero 1-D &lt;code&gt;x&lt;/code&gt; , que representa los &amp;iacute;ndices de una matriz de base cero, y cambia cada valor con su posici&amp;oacute;n de &amp;iacute;ndice. En otras palabras, para un tensor de salida &lt;code&gt;y&lt;/code&gt; y un tensor de entrada &lt;code&gt;x&lt;/code&gt; , esta operaci&amp;oacute;n calcula lo siguiente:</target>
        </trans-unit>
        <trans-unit id="9ce96baa1d2aec98a8f7f3b28803c0d5bf74ec4e" translate="yes" xml:space="preserve">
          <source>This operation concatenates completed-element component tensors along the 0th dimension to make a single component tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8b4d24b16bc4a84c7216a06caa8665f602e4b2d" translate="yes" xml:space="preserve">
          <source>This operation concatenates queue-element component tensors along the 0th dimension to make a single component tensor. All of the components in the dequeued tuple will have size &lt;code&gt;n&lt;/code&gt; in the 0th dimension.</source>
          <target state="translated">Esta operaci&amp;oacute;n concatena los tensores de los componentes de los elementos de la cola a lo largo de la dimensi&amp;oacute;n 0 para crear un tensor de un solo componente. Todos los componentes de la tupla quitada de la cola tendr&amp;aacute;n un tama&amp;ntilde;o &lt;code&gt;n&lt;/code&gt; en la dimensi&amp;oacute;n 0.</target>
        </trans-unit>
        <trans-unit id="45d38aafbd1acaa44920f79c8c0c3ecc6bbcdeda" translate="yes" xml:space="preserve">
          <source>This operation concatenates queue-element component tensors along the 0th dimension to make a single component tensor. All of the components in the dequeued tuple will have size n in the 0th dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50e9d3be55bb6834daac8ca12d0b390851428378" translate="yes" xml:space="preserve">
          <source>This operation concatenates queue-element component tensors along the 0th dimension to make a single component tensor. If the queue has not been closed, all of the components in the dequeued tuple will have size &lt;code&gt;n&lt;/code&gt; in the 0th dimension.</source>
          <target state="translated">Esta operaci&amp;oacute;n concatena los tensores de los componentes de los elementos de la cola a lo largo de la dimensi&amp;oacute;n 0 para crear un tensor de un solo componente. Si la cola no se ha cerrado, todos los componentes de la tupla quitada de la cola tendr&amp;aacute;n un tama&amp;ntilde;o &lt;code&gt;n&lt;/code&gt; en la dimensi&amp;oacute;n 0.</target>
        </trans-unit>
        <trans-unit id="15bf39234c37f046f148fb34f3d92a5f21991cd5" translate="yes" xml:space="preserve">
          <source>This operation converts Unicode code points to script codes corresponding to each code point. Script codes correspond to International Components for Unicode (ICU) UScriptCode values. See &lt;a href=&quot;http://icu-project.org/apiref/icu4c/uscript_8h.html&quot;&gt;http://icu-project.org/apiref/icu4c/uscript_8h.html&lt;/a&gt; Returns -1 (USCRIPT_INVALID_CODE) for invalid codepoints. Output shape will match input shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45295c6769989505efcf8c49b52125eb620acebf" translate="yes" xml:space="preserve">
          <source>This operation converts Unicode code points to script codes corresponding to each code point. Script codes correspond to International Components for Unicode (ICU) UScriptCode values. See http://icu-project.org/apiref/icu4c/uscript_8h.html. Returns -1 (USCRIPT_INVALID_CODE) for invalid codepoints. Output shape will match input shape.</source>
          <target state="translated">Esta operación convierte los puntos de código Unicode en códigos de escritura correspondientes a cada punto de código.Los códigos de escritura corresponden a los componentes internacionales para los valores de Unicode (ICU)UScriptCode.Véase http://icu-project.org/apiref/icu4c/uscript_8h.html.Devuelve -1 (USCRIPT_INVALID_CODE)para los puntos de código no válidos.La forma de salida coincidirá con la de entrada.</target>
        </trans-unit>
        <trans-unit id="46e590d89bb172f52098449de9dab107e8dbb7d2" translate="yes" xml:space="preserve">
          <source>This operation corresponds to &lt;code&gt;numpy.tensordot(a, b, axes)&lt;/code&gt;.</source>
          <target state="translated">Esta operaci&amp;oacute;n corresponde a &lt;code&gt;numpy.tensordot(a, b, axes)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11cc84360970a3caa94b4965487c085edd1841b7" translate="yes" xml:space="preserve">
          <source>This operation creates a new tensor by adding sparse &lt;code&gt;updates&lt;/code&gt; to the passed in &lt;code&gt;tensor&lt;/code&gt;. This operation is very similar to &lt;code&gt;tf.scatter_nd_add&lt;/code&gt;, except that the updates are added onto an existing tensor (as opposed to a variable). If the memory for the existing tensor cannot be re-used, a copy is made and updated.</source>
          <target state="translated">Esta operaci&amp;oacute;n crea un nuevo tensor agregando &lt;code&gt;updates&lt;/code&gt; escasas al &lt;code&gt;tensor&lt;/code&gt; pasado . Esta operaci&amp;oacute;n es muy similar a &lt;code&gt;tf.scatter_nd_add&lt;/code&gt; , excepto que las actualizaciones se agregan a un tensor existente (a diferencia de una variable). Si la memoria del tensor existente no se puede reutilizar, se realiza una copia y se actualiza.</target>
        </trans-unit>
        <trans-unit id="ffa4c89af08b8794e18efa910261002f2ad8a60e" translate="yes" xml:space="preserve">
          <source>This operation creates a new tensor by applying sparse &lt;code&gt;updates&lt;/code&gt; to the passed in &lt;code&gt;tensor&lt;/code&gt;. This operation is very similar to &lt;a href=&quot;../scatter_nd&quot;&gt;&lt;code&gt;tf.scatter_nd&lt;/code&gt;&lt;/a&gt;, except that the updates are scattered onto an existing tensor (as opposed to a zero-tensor). If the memory for the existing tensor cannot be re-used, a copy is made and updated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c390e65b4cc57f97f7e73aea3a4e81f629906485" translate="yes" xml:space="preserve">
          <source>This operation creates a new tensor by applying sparse &lt;code&gt;updates&lt;/code&gt; to the passed in &lt;code&gt;tensor&lt;/code&gt;. This operation is very similar to &lt;a href=&quot;scatter_nd&quot;&gt;&lt;code&gt;tf.scatter_nd&lt;/code&gt;&lt;/a&gt;, except that the updates are scattered onto an existing tensor (as opposed to a zero-tensor). If the memory for the existing tensor cannot be re-used, a copy is made and updated.</source>
          <target state="translated">Esta operaci&amp;oacute;n crea un nuevo tensor aplicando &lt;code&gt;updates&lt;/code&gt; dispersas al &lt;code&gt;tensor&lt;/code&gt; pasado . Esta operaci&amp;oacute;n es muy similar a &lt;a href=&quot;scatter_nd&quot;&gt; &lt;code&gt;tf.scatter_nd&lt;/code&gt; &lt;/a&gt; , excepto que las actualizaciones se dispersan en un tensor existente (a diferencia de un tensor cero). Si la memoria del tensor existente no se puede reutilizar, se realiza una copia y se actualiza.</target>
        </trans-unit>
        <trans-unit id="35ada26abd351b9c5bf627e9862c2252c700b1b5" translate="yes" xml:space="preserve">
          <source>This operation creates a new tensor by replicating &lt;code&gt;input&lt;/code&gt;&lt;code&gt;multiples&lt;/code&gt; times. The output tensor's i'th dimension has &lt;code&gt;input.dims(i) * multiples[i]&lt;/code&gt; elements, and the values of &lt;code&gt;input&lt;/code&gt; are replicated &lt;code&gt;multiples[i]&lt;/code&gt; times along the 'i'th dimension. For example, tiling &lt;code&gt;[a b c d]&lt;/code&gt; by &lt;code&gt;[2]&lt;/code&gt; produces &lt;code&gt;[a b c d a b c d]&lt;/code&gt;.</source>
          <target state="translated">Esta operaci&amp;oacute;n crea un nuevo tensor al replicar la &lt;code&gt;input&lt;/code&gt; &lt;code&gt;multiples&lt;/code&gt; veces. La &lt;code&gt;input.dims(i) * multiples[i]&lt;/code&gt; &amp;eacute;sima dimensi&amp;oacute;n del tensor de salida tiene input.dims (i) * m&amp;uacute;ltiplos [i] elementos, y los valores de &lt;code&gt;input&lt;/code&gt; se replican &lt;code&gt;multiples[i]&lt;/code&gt; veces a lo largo de la 'i' dimensi&amp;oacute;n. Por ejemplo, &lt;code&gt;[a b c d a b c d]&lt;/code&gt; mosaico &lt;code&gt;[a b c d]&lt;/code&gt; por &lt;code&gt;[2]&lt;/code&gt; produce [abcdabcd] .</target>
        </trans-unit>
        <trans-unit id="5c90c8c96fbb8b355bef6addc97e2ca668679eab" translate="yes" xml:space="preserve">
          <source>This operation creates a new tensor by subtracting sparse &lt;code&gt;updates&lt;/code&gt; from the passed in &lt;code&gt;tensor&lt;/code&gt;. This operation is very similar to &lt;code&gt;tf.scatter_nd_sub&lt;/code&gt;, except that the updates are subtracted from an existing tensor (as opposed to a variable). If the memory for the existing tensor cannot be re-used, a copy is made and updated.</source>
          <target state="translated">Esta operaci&amp;oacute;n crea un nuevo tensor restando &lt;code&gt;updates&lt;/code&gt; escasas del &lt;code&gt;tensor&lt;/code&gt; pasado . Esta operaci&amp;oacute;n es muy similar a &lt;code&gt;tf.scatter_nd_sub&lt;/code&gt; , excepto que las actualizaciones se restan de un tensor existente (a diferencia de una variable). Si la memoria del tensor existente no se puede reutilizar, se realiza una copia y se actualiza.</target>
        </trans-unit>
        <trans-unit id="52687eaf04e092c6367552afd7b0ecbe304d63d1" translate="yes" xml:space="preserve">
          <source>This operation creates a sequence of numbers that begins at &lt;code&gt;start&lt;/code&gt; and extends by increments of &lt;code&gt;delta&lt;/code&gt; up to but not including &lt;code&gt;limit&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92df0de1d5e9953fcab8fedab1e1918021371c50" translate="yes" xml:space="preserve">
          <source>This operation creates a tensor of &lt;code&gt;shape&lt;/code&gt; and &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aaf5e994752ce058c39711d4638a06e40443f56" translate="yes" xml:space="preserve">
          <source>This operation creates a tensor of shape &lt;code&gt;dims&lt;/code&gt; and fills it with &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">Esta operaci&amp;oacute;n crea un tensor de forma que se &lt;code&gt;dims&lt;/code&gt; y lo llena de &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2acd7b755c2b5e055f5081527ae8768ab15af691" translate="yes" xml:space="preserve">
          <source>This operation divides &quot;spatial&quot; dimensions &lt;code&gt;[1, ..., M]&lt;/code&gt; of the input into a grid of blocks of shape &lt;code&gt;block_shape&lt;/code&gt;, and interleaves these blocks with the &quot;batch&quot; dimension (0) such that in the output, the spatial dimensions &lt;code&gt;[1, ..., M]&lt;/code&gt; correspond to the position within the grid, and the batch dimension combines both the position within a spatial block and the original batch position. Prior to division into blocks, the spatial dimensions of the input are optionally zero padded according to &lt;code&gt;paddings&lt;/code&gt;. See below for a precise description.</source>
          <target state="translated">Esta operaci&amp;oacute;n divide las dimensiones &quot;espaciales&quot; &lt;code&gt;[1, ..., M]&lt;/code&gt; de la entrada en una cuadr&amp;iacute;cula de bloques de forma &lt;code&gt;block_shape&lt;/code&gt; , e intercala estos bloques con la dimensi&amp;oacute;n &quot;lote&quot; (0) de modo que en la salida, las dimensiones espaciales &lt;code&gt;[1, ..., M]&lt;/code&gt; corresponden a la posici&amp;oacute;n dentro de la cuadr&amp;iacute;cula, y la dimensi&amp;oacute;n del lote combina la posici&amp;oacute;n dentro de un bloque espacial y la posici&amp;oacute;n del lote original. Antes de la divisi&amp;oacute;n en bloques, las dimensiones espaciales de la entrada se rellenan opcionalmente con ceros de acuerdo con los &lt;code&gt;paddings&lt;/code&gt; . Consulte a continuaci&amp;oacute;n para obtener una descripci&amp;oacute;n precisa.</target>
        </trans-unit>
        <trans-unit id="41e0f15b392354d26d2756845f1cfcd72200eb6d" translate="yes" xml:space="preserve">
          <source>This operation either returns a tensor &lt;code&gt;y&lt;/code&gt; containing unique elements along the &lt;code&gt;axis&lt;/code&gt; of a tensor. The returned unique elements is sorted in the same order as they occur along &lt;code&gt;axis&lt;/code&gt; in &lt;code&gt;x&lt;/code&gt;. This operation also returns a tensor &lt;code&gt;idx&lt;/code&gt; and a tensor &lt;code&gt;count&lt;/code&gt; that are the same size as the number of the elements in &lt;code&gt;x&lt;/code&gt; along the &lt;code&gt;axis&lt;/code&gt; dimension. The &lt;code&gt;idx&lt;/code&gt; contains the index in the unique output &lt;code&gt;y&lt;/code&gt; and the &lt;code&gt;count&lt;/code&gt; contains the count in the unique output &lt;code&gt;y&lt;/code&gt;. In other words, for an &lt;code&gt;1-D&lt;/code&gt; tensor &lt;code&gt;x&lt;/code&gt; with `axis = None:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fb9300ba4c7f909238dc4fbd9e13292c10f4740" translate="yes" xml:space="preserve">
          <source>This operation either returns a tensor &lt;code&gt;y&lt;/code&gt; containing unique elements along the &lt;code&gt;axis&lt;/code&gt; of a tensor. The returned unique elements is sorted in the same order as they occur along &lt;code&gt;axis&lt;/code&gt; in &lt;code&gt;x&lt;/code&gt;. This operation also returns a tensor &lt;code&gt;idx&lt;/code&gt; that is the same size as the number of the elements in &lt;code&gt;x&lt;/code&gt; along the &lt;code&gt;axis&lt;/code&gt; dimension. It contains the index in the unique output &lt;code&gt;y&lt;/code&gt;. In other words, for an &lt;code&gt;1-D&lt;/code&gt; tensor &lt;code&gt;x&lt;/code&gt; with `axis = None:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a631f52c0283f6c97e9168ae9c2c1920fc673e57" translate="yes" xml:space="preserve">
          <source>This operation ensures the underlying data memory is ready when returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d3e7305e25146c306e9ca9dac7912d7b2d4ded2" translate="yes" xml:space="preserve">
          <source>This operation extracts a slice of size &lt;code&gt;size&lt;/code&gt; from a tensor &lt;code&gt;input_&lt;/code&gt; starting at the location specified by &lt;code&gt;begin&lt;/code&gt;. The slice &lt;code&gt;size&lt;/code&gt; is represented as a tensor shape, where &lt;code&gt;size[i]&lt;/code&gt; is the number of elements of the 'i'th dimension of &lt;code&gt;input_&lt;/code&gt; that you want to slice. The starting location (&lt;code&gt;begin&lt;/code&gt;) for the slice is represented as an offset in each dimension of &lt;code&gt;input_&lt;/code&gt;. In other words, &lt;code&gt;begin[i]&lt;/code&gt; is the offset into the i'th dimension of &lt;code&gt;input_&lt;/code&gt; that you want to slice from.</source>
          <target state="translated">Esta operaci&amp;oacute;n extrae una porci&amp;oacute;n de tama&amp;ntilde;o de &lt;code&gt;size&lt;/code&gt; de un tensor &lt;code&gt;input_&lt;/code&gt; comenzando en la ubicaci&amp;oacute;n especificada por &lt;code&gt;begin&lt;/code&gt; . El &lt;code&gt;size&lt;/code&gt; porci&amp;oacute;n se representa como una forma tensorial, donde &lt;code&gt;size[i]&lt;/code&gt; es el n&amp;uacute;mero de elementos de la 'i'&amp;eacute;sima dimensi&amp;oacute;n de &lt;code&gt;input_&lt;/code&gt; que desea dividir . La ubicaci&amp;oacute;n inicial ( &lt;code&gt;begin&lt;/code&gt; ) del sector se representa como un desplazamiento en cada dimensi&amp;oacute;n de &lt;code&gt;input_&lt;/code&gt; . En otras palabras, &lt;code&gt;begin[i]&lt;/code&gt; es el desplazamiento en la i-&amp;eacute;sima dimensi&amp;oacute;n de &lt;code&gt;input_&lt;/code&gt; desde el que desea cortar.</target>
        </trans-unit>
        <trans-unit id="29ab911f3d597d49d14cf454f1533a4b19e5e15b" translate="yes" xml:space="preserve">
          <source>This operation extracts the specified region from the tensor. The notation is similar to NumPy with the restriction that currently only support basic indexing. That means that using a non-scalar tensor as input is not currently allowed.</source>
          <target state="translated">Esta operación extrae la región especificada del tensor.La notación es similar a la de NumPy con la restricción de que actualmente sólo soporta la indexación básica.Eso significa que usar un tensor no escalar como entrada no está actualmente permitido.</target>
        </trans-unit>
        <trans-unit id="c488d4bcca92a0ac54244fdbb1f9925da2e5d927" translate="yes" xml:space="preserve">
          <source>This operation folds the padded areas of &lt;code&gt;input&lt;/code&gt; by &lt;code&gt;MirrorPad&lt;/code&gt; according to the &lt;code&gt;paddings&lt;/code&gt; you specify. &lt;code&gt;paddings&lt;/code&gt; must be the same as &lt;code&gt;paddings&lt;/code&gt; argument given to the corresponding &lt;code&gt;MirrorPad&lt;/code&gt; op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f4879a7545e74fa85acacd4cf01d74137ecf234" translate="yes" xml:space="preserve">
          <source>This operation has &lt;code&gt;k&lt;/code&gt; outputs, where &lt;code&gt;k&lt;/code&gt; is the number of components in the tuples stored in the given queue, and output &lt;code&gt;i&lt;/code&gt; is the ith component of the dequeued tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d3ec2c39ae0a5c24c1de4e22eea70e184fc371a" translate="yes" xml:space="preserve">
          <source>This operation has a gradient and thus allows for training &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; values.</source>
          <target state="translated">Esta operaci&amp;oacute;n tiene un gradiente y por lo tanto permite el entrenamiento &lt;code&gt;min&lt;/code&gt; y &lt;code&gt;max&lt;/code&gt; valores.</target>
        </trans-unit>
        <trans-unit id="ac2e08c9a87871e0d33d02bc30d3bfc7e328d76d" translate="yes" xml:space="preserve">
          <source>This operation has k outputs, where &lt;code&gt;k&lt;/code&gt; is the number of components in the tuples stored in the given queue, and output &lt;code&gt;i&lt;/code&gt; is the ith component of the dequeued tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="701111c6d7bceddee66d3b31a146ad5d2ba5dd35" translate="yes" xml:space="preserve">
          <source>This operation has k outputs, where k is the number of components in the tuples stored in the given queue, and output i is the ith component of the dequeued tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b78d17d35c34babe04bca7ab5360f7b9d4aad4d2" translate="yes" xml:space="preserve">
          <source>This operation has the same semantics as &lt;code&gt;reshape&lt;/code&gt; on the represented dense tensor. The indices of non-empty values in &lt;code&gt;sp_input&lt;/code&gt; are recomputed based on the new dense shape, and a new &lt;code&gt;SparseTensor&lt;/code&gt; is returned containing the new indices and new shape. The order of non-empty values in &lt;code&gt;sp_input&lt;/code&gt; is unchanged.</source>
          <target state="translated">Esta operaci&amp;oacute;n tiene la misma sem&amp;aacute;ntica que la &lt;code&gt;reshape&lt;/code&gt; del tensor denso representado. Los &amp;iacute;ndices de valores no vac&amp;iacute;os en &lt;code&gt;sp_input&lt;/code&gt; se vuelven a calcular en funci&amp;oacute;n de la nueva forma densa, y se devuelve un nuevo &lt;code&gt;SparseTensor&lt;/code&gt; que contiene los nuevos &amp;iacute;ndices y la nueva forma. El orden de los valores no vac&amp;iacute;os en &lt;code&gt;sp_input&lt;/code&gt; no se modifica.</target>
        </trans-unit>
        <trans-unit id="920eea1003570a2934a5442842f0411a9537123b" translate="yes" xml:space="preserve">
          <source>This operation has the same semantics as reshape on the represented dense tensor. The &lt;code&gt;input_indices&lt;/code&gt; are recomputed based on the requested &lt;code&gt;new_shape&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f987eeda9053c7636415898332c77d1e39acd9d4" translate="yes" xml:space="preserve">
          <source>This operation holds a replicated input to a &lt;code&gt;tpu.replicate()&lt;/code&gt; computation subgraph. Each replicated input has the same shape and type alongside the output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d663f608fa1c649097379c4a16273931656d413" translate="yes" xml:space="preserve">
          <source>This operation holds a replicated output from a &lt;code&gt;tpu.replicate()&lt;/code&gt; computation subgraph. Each replicated output has the same shape and type alongside the input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddc1067cff13fb19a5da325542d16f1e694e62d1" translate="yes" xml:space="preserve">
          <source>This operation holds the metadata common to operations of a &lt;code&gt;tpu.replicate()&lt;/code&gt; computation subgraph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bd3f36c5bf6b7e281276b8f3d298543774510a1" translate="yes" xml:space="preserve">
          <source>This operation is a no-op when executing eagerly.</source>
          <target state="translated">Esta operación es un no-operación cuando se ejecuta con entusiasmo.</target>
        </trans-unit>
        <trans-unit id="7c3a2eaa25ce85f5bc726adb4e2f6e321fc3ad96" translate="yes" xml:space="preserve">
          <source>This operation is a synchronous version IteratorGetNext. It should only be used in situations where the iterator does not block the calling thread, or where the calling thread is not a member of the thread pool used to execute parallel operations (e.g. in eager mode).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="834adca0b6e8190426dd82e3dc679bdfc3901af6" translate="yes" xml:space="preserve">
          <source>This operation is considered stateful. For a stateless version, see PyFuncStateless.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c77c133cb2aa87b66c50cea9b24338cf94df91e2" translate="yes" xml:space="preserve">
          <source>This operation is equivalent to the following steps:</source>
          <target state="translated">Esta operación equivale a los siguientes pasos:</target>
        </trans-unit>
        <trans-unit id="a85336f9b64b0941e75fed8873dd343470ffb664" translate="yes" xml:space="preserve">
          <source>This operation is for training only. It is generally an underestimate of the full softmax loss.</source>
          <target state="translated">Esta operación es sólo para entrenamiento.Generalmente es una subestimación de la pérdida total de softmax.</target>
        </trans-unit>
        <trans-unit id="197a06d7811b56e8d6bce80b3c815e4a4c56a4a7" translate="yes" xml:space="preserve">
          <source>This operation is not supported by all queues. If a queue does not support DequeueUpTo, then an Unimplemented error is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6db0a8622252241b3dd8e4da9fc3d6ba84977a9c" translate="yes" xml:space="preserve">
          <source>This operation is related to &lt;code&gt;squeeze()&lt;/code&gt;, which removes dimensions of size 1.</source>
          <target state="translated">Esta operaci&amp;oacute;n est&amp;aacute; relacionada con &lt;code&gt;squeeze()&lt;/code&gt; , que elimina las dimensiones de tama&amp;ntilde;o 1.</target>
        </trans-unit>
        <trans-unit id="49c94ac01402b2bd4ac870cdfc937202b7e69050" translate="yes" xml:space="preserve">
          <source>This operation is related to:</source>
          <target state="translated">Esta operación está relacionada con:</target>
        </trans-unit>
        <trans-unit id="f8a4568939439baca88acb2c04e8494963c44c55" translate="yes" xml:space="preserve">
          <source>This operation is significantly more numerically stable than the equivalent tensorflow operation &lt;code&gt;tf.math.log(tf.math.cumsum(tf.math.exp(x)))&lt;/code&gt;, although computes the same result given infinite numerical precision. However, note that in some cases, it may be less stable than &lt;a href=&quot;reduce_logsumexp&quot;&gt;&lt;code&gt;tf.math.reduce_logsumexp&lt;/code&gt;&lt;/a&gt; for a given element, as it applies the &quot;log-sum-exp trick&quot; in a different way.</source>
          <target state="translated">Esta operaci&amp;oacute;n es significativamente m&amp;aacute;s estable num&amp;eacute;ricamente que la operaci&amp;oacute;n de &lt;code&gt;tf.math.log(tf.math.cumsum(tf.math.exp(x)))&lt;/code&gt; tensorial equivalente tf.math.log (tf.math.cumsum (tf.math.exp (x))) , aunque calcula el mismo resultado dada una precisi&amp;oacute;n num&amp;eacute;rica infinita. Sin embargo, tenga en cuenta que en algunos casos, puede ser menos estable que &lt;a href=&quot;reduce_logsumexp&quot;&gt; &lt;code&gt;tf.math.reduce_logsumexp&lt;/code&gt; &lt;/a&gt; para un elemento dado, ya que aplica el &quot;truco log-sum-exp&quot; de una manera diferente.</target>
        </trans-unit>
        <trans-unit id="c9fb91f09ebc4c3acce5ac821344d6140f7e24da" translate="yes" xml:space="preserve">
          <source>This operation is similar to tensor_scatter_add, except that the tensor is zero-initialized. Calling &lt;a href=&quot;../scatter_nd&quot;&gt;&lt;code&gt;tf.scatter_nd(indices, values, shape)&lt;/code&gt;&lt;/a&gt; is identical to &lt;code&gt;tensor_scatter_add(tf.zeros(shape, values.dtype), indices, values)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cce4836efcc5d3f1c90cad3d4974cf4b16512f4" translate="yes" xml:space="preserve">
          <source>This operation is similar to tensor_scatter_add, except that the tensor is zero-initialized. Calling &lt;a href=&quot;scatter_nd&quot;&gt;&lt;code&gt;tf.scatter_nd(indices, values, shape)&lt;/code&gt;&lt;/a&gt; is identical to &lt;code&gt;tensor_scatter_add(tf.zeros(shape, values.dtype), indices, values)&lt;/code&gt;</source>
          <target state="translated">Esta operaci&amp;oacute;n es similar a tensor_scatter_add, excepto que el tensor se inicializa en cero. Llamar a &lt;a href=&quot;scatter_nd&quot;&gt; &lt;code&gt;tf.scatter_nd(indices, values, shape)&lt;/code&gt; &lt;/a&gt; es id&amp;eacute;ntico a &lt;code&gt;tensor_scatter_add(tf.zeros(shape, values.dtype), indices, values)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ef068c49d35ae40fdbd6e0290914a410da40aff" translate="yes" xml:space="preserve">
          <source>This operation is sometimes called &quot;deconvolution&quot; after (Zeiler et al., 2010), but is actually the transpose (gradient) of &lt;code&gt;conv1d&lt;/code&gt; rather than an actual deconvolution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5e02776737c55d9c6ad653f1cc95f3511e5d57b" translate="yes" xml:space="preserve">
          <source>This operation is sometimes called &quot;deconvolution&quot; after (Zeiler et al., 2010), but is really the transpose (gradient) of &lt;code&gt;atrous_conv2d&lt;/code&gt; rather than an actual deconvolution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00a748a99cc55d86cf7d8d7f88c1133466c7c32f" translate="yes" xml:space="preserve">
          <source>This operation is sometimes called &quot;deconvolution&quot; after (Zeiler et al., 2010), but is really the transpose (gradient) of &lt;code&gt;conv2d&lt;/code&gt; rather than an actual deconvolution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c47ed45caa79111f8c5fa46b428a6d5a1fe8d370" translate="yes" xml:space="preserve">
          <source>This operation is sometimes called &quot;deconvolution&quot; after (Zeiler et al., 2010), but is really the transpose (gradient) of &lt;code&gt;conv3d&lt;/code&gt; rather than an actual deconvolution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50f836730593fffe361ee867e1bf79d15e8af917" translate="yes" xml:space="preserve">
          <source>This operation is sometimes called &quot;deconvolution&quot; after &lt;a href=&quot;http://www.matthewzeiler.com/pubs/cvpr2010/cvpr2010.pdf&quot;&gt;Deconvolutional Networks&lt;/a&gt;, but is actually the transpose (gradient) of &lt;code&gt;conv2d&lt;/code&gt; rather than an actual deconvolution.</source>
          <target state="translated">Esta operaci&amp;oacute;n a veces se denomina &quot;deconvoluci&amp;oacute;n&quot; despu&amp;eacute;s de &lt;a href=&quot;http://www.matthewzeiler.com/pubs/cvpr2010/cvpr2010.pdf&quot;&gt;Deconvolutional Networks&lt;/a&gt; , pero en realidad es la transposici&amp;oacute;n (gradiente) de &lt;code&gt;conv2d&lt;/code&gt; en lugar de una deconvoluci&amp;oacute;n real.</target>
        </trans-unit>
        <trans-unit id="cdd40bbfb18d0876cdd3d1bf655721101051d082" translate="yes" xml:space="preserve">
          <source>This operation is sometimes called &quot;deconvolution&quot; after &lt;a href=&quot;http://www.matthewzeiler.com/pubs/cvpr2010/cvpr2010.pdf&quot;&gt;Deconvolutional Networks&lt;/a&gt;, but is actually the transpose (gradient) of &lt;code&gt;convolution&lt;/code&gt; rather than an actual deconvolution.</source>
          <target state="translated">Esta operaci&amp;oacute;n a veces se llama &quot;deconvoluci&amp;oacute;n&quot; despu&amp;eacute;s de &lt;a href=&quot;http://www.matthewzeiler.com/pubs/cvpr2010/cvpr2010.pdf&quot;&gt;Deconvolutional Networks&lt;/a&gt; , pero en realidad es la transposici&amp;oacute;n (gradiente) de &lt;code&gt;convolution&lt;/code&gt; lugar de una deconvoluci&amp;oacute;n real.</target>
        </trans-unit>
        <trans-unit id="a80e63d8e3617ef22a7c11bc4ac5ce2aac92b83c" translate="yes" xml:space="preserve">
          <source>This operation is sometimes called &quot;deconvolution&quot; after &lt;a href=&quot;https://www.matthewzeiler.com/mattzeiler/deconvolutionalnetworks.pdf&quot;&gt;Deconvolutional Networks&lt;/a&gt;, but is really the transpose (gradient) of &lt;code&gt;atrous_conv2d&lt;/code&gt; rather than an actual deconvolution.</source>
          <target state="translated">Esta operaci&amp;oacute;n a veces se denomina &quot;deconvoluci&amp;oacute;n&quot; despu&amp;eacute;s de &lt;a href=&quot;https://www.matthewzeiler.com/mattzeiler/deconvolutionalnetworks.pdf&quot;&gt;Deconvolutional Networks&lt;/a&gt; , pero en realidad es la transposici&amp;oacute;n (gradiente) de &lt;code&gt;atrous_conv2d&lt;/code&gt; en lugar de una deconvoluci&amp;oacute;n real.</target>
        </trans-unit>
        <trans-unit id="3e16e89f92d27118cbc90336d321edbdccabf257" translate="yes" xml:space="preserve">
          <source>This operation is sometimes called &quot;deconvolution&quot; after &lt;a href=&quot;https://www.matthewzeiler.com/mattzeiler/deconvolutionalnetworks.pdf&quot;&gt;Deconvolutional Networks&lt;/a&gt;, but is really the transpose (gradient) of &lt;code&gt;conv1d&lt;/code&gt; rather than an actual deconvolution.</source>
          <target state="translated">Esta operaci&amp;oacute;n a veces se denomina &quot;deconvoluci&amp;oacute;n&quot; despu&amp;eacute;s de &lt;a href=&quot;https://www.matthewzeiler.com/mattzeiler/deconvolutionalnetworks.pdf&quot;&gt;Deconvolutional Networks&lt;/a&gt; , pero en realidad es la transposici&amp;oacute;n (gradiente) de &lt;code&gt;conv1d&lt;/code&gt; en lugar de una deconvoluci&amp;oacute;n real.</target>
        </trans-unit>
        <trans-unit id="74c54a1240dd3ebac671477622bdae5730c68b14" translate="yes" xml:space="preserve">
          <source>This operation is sometimes called &quot;deconvolution&quot; after &lt;a href=&quot;https://www.matthewzeiler.com/mattzeiler/deconvolutionalnetworks.pdf&quot;&gt;Deconvolutional Networks&lt;/a&gt;, but is really the transpose (gradient) of &lt;code&gt;conv2d&lt;/code&gt; rather than an actual deconvolution.</source>
          <target state="translated">Esta operaci&amp;oacute;n a veces se denomina &quot;deconvoluci&amp;oacute;n&quot; despu&amp;eacute;s de &lt;a href=&quot;https://www.matthewzeiler.com/mattzeiler/deconvolutionalnetworks.pdf&quot;&gt;Deconvolutional Networks&lt;/a&gt; , pero en realidad es la transposici&amp;oacute;n (gradiente) de &lt;code&gt;conv2d&lt;/code&gt; en lugar de una deconvoluci&amp;oacute;n real.</target>
        </trans-unit>
        <trans-unit id="78632da26e5444bf46256b6e1c192a603e6c3c00" translate="yes" xml:space="preserve">
          <source>This operation is sometimes called &quot;deconvolution&quot; after &lt;a href=&quot;https://www.matthewzeiler.com/mattzeiler/deconvolutionalnetworks.pdf&quot;&gt;Deconvolutional Networks&lt;/a&gt;, but is really the transpose (gradient) of &lt;code&gt;conv3d&lt;/code&gt; rather than an actual deconvolution.</source>
          <target state="translated">Esta operaci&amp;oacute;n a veces se denomina &quot;deconvoluci&amp;oacute;n&quot; despu&amp;eacute;s de &lt;a href=&quot;https://www.matthewzeiler.com/mattzeiler/deconvolutionalnetworks.pdf&quot;&gt;Deconvolutional Networks&lt;/a&gt; , pero en realidad es la transposici&amp;oacute;n (gradiente) de &lt;code&gt;conv3d&lt;/code&gt; en lugar de una deconvoluci&amp;oacute;n real.</target>
        </trans-unit>
        <trans-unit id="20f728b5bb5e16f6250024eb3cf614e43cfbbe07" translate="yes" xml:space="preserve">
          <source>This operation is typically used to clip gradients before applying them with an optimizer.</source>
          <target state="translated">Esta operación suele utilizarse para recortar los gradientes antes de aplicarlos con un optimizador.</target>
        </trans-unit>
        <trans-unit id="7b06c412ab3afb65378a71bcff3a6e6664ba2503" translate="yes" xml:space="preserve">
          <source>This operation is typically used to clip gradients before applying them with an optimizer. Most gradient data is a collection of different shaped tensors for different parts of the model. Thus, this is a common usage:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a39ff6aff1d832bca041bbe0ecd1ce428c1522da" translate="yes" xml:space="preserve">
          <source>This operation is useful for Locality-Sensitive-Hashing (LSH) and other algorithms that use hashing approximations of cosine and &lt;code&gt;L2&lt;/code&gt; distances; codes can be generated from an input via:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5397809ea0e6b96d049101c13960159515304d67" translate="yes" xml:space="preserve">
          <source>This operation is useful for resizing the activations between convolutions (but keeping all data), e.g. instead of pooling. It is also useful for training purely convolutional models.</source>
          <target state="translated">Esta operación es útil para redimensionar las activaciones entre las convoluciones (pero manteniendo todos los datos),por ejemplo,en lugar de agruparlas.También es útil para entrenar modelos puramente convolucionales.</target>
        </trans-unit>
        <trans-unit id="e6cbba91c74639c8cb40de16428e2bef0563e905" translate="yes" xml:space="preserve">
          <source>This operation is useful if you want to add a batch dimension to a single element. For example, if you have a single image of shape &lt;code&gt;[height, width, channels]&lt;/code&gt;, you can make it a batch of 1 image with &lt;code&gt;expand_dims(image, 0)&lt;/code&gt;, which will make the shape &lt;code&gt;[1, height, width, channels]&lt;/code&gt;.</source>
          <target state="translated">Esta operaci&amp;oacute;n es &amp;uacute;til si desea agregar una dimensi&amp;oacute;n de lote a un solo elemento. Por ejemplo, si tiene una sola imagen de forma &lt;code&gt;[height, width, channels]&lt;/code&gt; , puede convertirla en un lote de 1 imagen con &lt;code&gt;expand_dims(image, 0)&lt;/code&gt; , lo que har&amp;aacute; que la forma &lt;code&gt;[1, height, width, channels]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6316e455129ed9fa859e28aacc9886a66315035c" translate="yes" xml:space="preserve">
          <source>This operation is useful if you want to add a batch dimension to a single element. For example, if you have a single image of shape &lt;code&gt;[height, width, channels]&lt;/code&gt;, you can make it a batch of one image with &lt;code&gt;expand_dims(image, 0)&lt;/code&gt;, which will make the shape &lt;code&gt;[1, height, width, channels]&lt;/code&gt;.</source>
          <target state="translated">Esta operaci&amp;oacute;n es &amp;uacute;til si desea agregar una dimensi&amp;oacute;n de lote a un solo elemento. Por ejemplo, si tiene una sola imagen de forma &lt;code&gt;[height, width, channels]&lt;/code&gt; , puede convertirla en un lote de una imagen con &lt;code&gt;expand_dims(image, 0)&lt;/code&gt; , lo que har&amp;aacute; que la forma &lt;code&gt;[1, height, width, channels]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e351d2492bb6908fd7d460e61be31a9eca71f43d" translate="yes" xml:space="preserve">
          <source>This operation is useful to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="183fa485124f0558dfb1f2c40c10151a91905ce9" translate="yes" xml:space="preserve">
          <source>This operation may be executed multiple times. Each execution will reset the iterator in &lt;code&gt;iterator&lt;/code&gt; to the first element of &lt;code&gt;dataset&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="082051a9c25e40abb9ca51ba30204e50cec28855" translate="yes" xml:space="preserve">
          <source>This operation outputs &quot;ref&quot; after the assignment is done. This makes it easier to chain operations that need to use the reset value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45e5d0f78a3a33704d46216d94caf563cfac246a" translate="yes" xml:space="preserve">
          <source>This operation outputs &quot;ref&quot; after the update is done. This makes it easier to chain operations that need to use the reset value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d1d3aca1842cf510032065cfce3509b5c793096" translate="yes" xml:space="preserve">
          <source>This operation outputs &quot;ref&quot; after the update is done. This makes it easier to chain operations that need to use the reset value. Unlike &lt;a href=&quot;../../math/add&quot;&gt;&lt;code&gt;tf.math.add&lt;/code&gt;&lt;/a&gt;, this op does not broadcast. &lt;code&gt;ref&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; must have the same shape.</source>
          <target state="translated">Esta operaci&amp;oacute;n genera &quot;ref&quot; despu&amp;eacute;s de que se realiza la actualizaci&amp;oacute;n. Esto facilita la cadena de operaciones que necesitan utilizar el valor de reinicio. A diferencia de &lt;a href=&quot;../../math/add&quot;&gt; &lt;code&gt;tf.math.add&lt;/code&gt; &lt;/a&gt; , esta operaci&amp;oacute;n no se transmite. &lt;code&gt;ref&lt;/code&gt; y &lt;code&gt;value&lt;/code&gt; deben tener la misma forma.</target>
        </trans-unit>
        <trans-unit id="7e16eef80cf37c2d9c02fad5e714a6e559684854" translate="yes" xml:space="preserve">
          <source>This operation outputs &lt;code&gt;ref&lt;/code&gt; after the update is done. This makes it easier to chain operations that need to use the reset value.</source>
          <target state="translated">Esta operaci&amp;oacute;n genera &lt;code&gt;ref&lt;/code&gt; despu&amp;eacute;s de que se realiza la actualizaci&amp;oacute;n. Esto facilita la cadena de operaciones que necesitan utilizar el valor de reinicio.</target>
        </trans-unit>
        <trans-unit id="80080e1227c1f588b580293eb11f01d8754cc2fa" translate="yes" xml:space="preserve">
          <source>This operation outputs &lt;code&gt;ref&lt;/code&gt; after the update is done. This makes it easier to chain operations that need to use the reset value. Unlike &lt;a href=&quot;../../math/subtract&quot;&gt;&lt;code&gt;tf.math.subtract&lt;/code&gt;&lt;/a&gt;, this op does not broadcast. &lt;code&gt;ref&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; must have the same shape.</source>
          <target state="translated">Esta operaci&amp;oacute;n genera &lt;code&gt;ref&lt;/code&gt; despu&amp;eacute;s de que se realiza la actualizaci&amp;oacute;n. Esto facilita la cadena de operaciones que necesitan utilizar el valor de reinicio. A diferencia de &lt;a href=&quot;../../math/subtract&quot;&gt; &lt;code&gt;tf.math.subtract&lt;/code&gt; &lt;/a&gt; , esta operaci&amp;oacute;n no se transmite. &lt;code&gt;ref&lt;/code&gt; y &lt;code&gt;value&lt;/code&gt; deben tener la misma forma.</target>
        </trans-unit>
        <trans-unit id="211cf88f878719f0fdbc3eba7700cfd25f62b94c" translate="yes" xml:space="preserve">
          <source>This operation outputs &lt;code&gt;ref&lt;/code&gt; after the update is done. This makes it easier to chain operations that need to use the updated value. Duplicate entries are handled correctly: if multiple &lt;code&gt;indices&lt;/code&gt; reference the same location, their contributions add.</source>
          <target state="translated">Esta operaci&amp;oacute;n genera &lt;code&gt;ref&lt;/code&gt; despu&amp;eacute;s de que se realiza la actualizaci&amp;oacute;n. Esto hace que sea m&amp;aacute;s f&amp;aacute;cil encadenar operaciones que necesitan utilizar el valor actualizado. Las entradas duplicadas se manejan correctamente: si varios &lt;code&gt;indices&lt;/code&gt; referencia a la misma ubicaci&amp;oacute;n, sus contribuciones se suman.</target>
        </trans-unit>
        <trans-unit id="f7141134307e0a174b2d64cd3ba50899cf746d15" translate="yes" xml:space="preserve">
          <source>This operation outputs a Tensor that holds the new value of &lt;code&gt;ref&lt;/code&gt; after the value has been assigned. This makes it easier to chain operations that need to use the reset value.</source>
          <target state="translated">Esta operaci&amp;oacute;n genera un tensor que contiene el nuevo valor de &lt;code&gt;ref&lt;/code&gt; despu&amp;eacute;s de que se ha asignado el valor. Esto facilita la cadena de operaciones que necesitan utilizar el valor de reinicio.</target>
        </trans-unit>
        <trans-unit id="ff9194e8e7be6d4ad4f022b42bf00a1d9dcc3aad" translate="yes" xml:space="preserve">
          <source>This operation pads &lt;code&gt;input&lt;/code&gt; according to the &lt;code&gt;paddings&lt;/code&gt; and &lt;code&gt;constant_values&lt;/code&gt; you specify. &lt;code&gt;paddings&lt;/code&gt; is an integer tensor with shape &lt;code&gt;[Dn, 2]&lt;/code&gt;, where n is the rank of &lt;code&gt;input&lt;/code&gt;. For each dimension D of &lt;code&gt;input&lt;/code&gt;, &lt;code&gt;paddings[D, 0]&lt;/code&gt; indicates how many padding values to add before the contents of &lt;code&gt;input&lt;/code&gt; in that dimension, and &lt;code&gt;paddings[D, 1]&lt;/code&gt; indicates how many padding values to add after the contents of &lt;code&gt;input&lt;/code&gt; in that dimension. &lt;code&gt;constant_values&lt;/code&gt; is a scalar tensor of the same type as &lt;code&gt;input&lt;/code&gt; that indicates the value to use for padding &lt;code&gt;input&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7dac094042ba8225a6a7449892b847dafe951a8" translate="yes" xml:space="preserve">
          <source>This operation pads a &lt;code&gt;input&lt;/code&gt; with mirrored values according to the &lt;code&gt;paddings&lt;/code&gt; you specify. &lt;code&gt;paddings&lt;/code&gt; is an integer tensor with shape &lt;code&gt;[n, 2]&lt;/code&gt;, where n is the rank of &lt;code&gt;input&lt;/code&gt;. For each dimension D of &lt;code&gt;input&lt;/code&gt;, &lt;code&gt;paddings[D, 0]&lt;/code&gt; indicates how many values to add before the contents of &lt;code&gt;input&lt;/code&gt; in that dimension, and &lt;code&gt;paddings[D, 1]&lt;/code&gt; indicates how many values to add after the contents of &lt;code&gt;input&lt;/code&gt; in that dimension. Both &lt;code&gt;paddings[D, 0]&lt;/code&gt; and &lt;code&gt;paddings[D, 1]&lt;/code&gt; must be no greater than &lt;code&gt;input.dim_size(D)&lt;/code&gt; (or &lt;code&gt;input.dim_size(D) - 1&lt;/code&gt;) if &lt;code&gt;copy_border&lt;/code&gt; is true (if false, respectively).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98dc6d3604c67365b92527ae5f26da565365534d" translate="yes" xml:space="preserve">
          <source>This operation pads a &lt;code&gt;input&lt;/code&gt; with zeros according to the &lt;code&gt;paddings&lt;/code&gt; you specify. &lt;code&gt;paddings&lt;/code&gt; is an integer tensor with shape &lt;code&gt;[Dn, 2]&lt;/code&gt;, where n is the rank of &lt;code&gt;input&lt;/code&gt;. For each dimension D of &lt;code&gt;input&lt;/code&gt;, &lt;code&gt;paddings[D, 0]&lt;/code&gt; indicates how many zeros to add before the contents of &lt;code&gt;input&lt;/code&gt; in that dimension, and &lt;code&gt;paddings[D, 1]&lt;/code&gt; indicates how many zeros to add after the contents of &lt;code&gt;input&lt;/code&gt; in that dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8dcb952f1fd946dc8a99ab12f18c6c9f3bad230" translate="yes" xml:space="preserve">
          <source>This operation pads a &lt;code&gt;tensor&lt;/code&gt; according to the &lt;code&gt;paddings&lt;/code&gt; you specify. &lt;code&gt;paddings&lt;/code&gt; is an integer tensor with shape &lt;code&gt;[n, 2]&lt;/code&gt;, where n is the rank of &lt;code&gt;tensor&lt;/code&gt;. For each dimension D of &lt;code&gt;input&lt;/code&gt;, &lt;code&gt;paddings[D, 0]&lt;/code&gt; indicates how many values to add before the contents of &lt;code&gt;tensor&lt;/code&gt; in that dimension, and &lt;code&gt;paddings[D, 1]&lt;/code&gt; indicates how many values to add after the contents of &lt;code&gt;tensor&lt;/code&gt; in that dimension. If &lt;code&gt;mode&lt;/code&gt; is &quot;REFLECT&quot; then both &lt;code&gt;paddings[D, 0]&lt;/code&gt; and &lt;code&gt;paddings[D, 1]&lt;/code&gt; must be no greater than &lt;code&gt;tensor.dim_size(D) - 1&lt;/code&gt;. If &lt;code&gt;mode&lt;/code&gt; is &quot;SYMMETRIC&quot; then both &lt;code&gt;paddings[D, 0]&lt;/code&gt; and &lt;code&gt;paddings[D, 1]&lt;/code&gt; must be no greater than &lt;code&gt;tensor.dim_size(D)&lt;/code&gt;.</source>
          <target state="translated">Esta operaci&amp;oacute;n rellena un &lt;code&gt;tensor&lt;/code&gt; de acuerdo con los &lt;code&gt;paddings&lt;/code&gt; que especifique. &lt;code&gt;paddings&lt;/code&gt; es un tensor entero con forma &lt;code&gt;[n, 2]&lt;/code&gt; , donde n es el rango del &lt;code&gt;tensor&lt;/code&gt; . Para cada dimensi&amp;oacute;n D de &lt;code&gt;input&lt;/code&gt; , los &lt;code&gt;paddings[D, 0]&lt;/code&gt; indican cu&amp;aacute;ntos valores agregar antes del contenido del &lt;code&gt;tensor&lt;/code&gt; en esa dimensi&amp;oacute;n, y los &lt;code&gt;paddings[D, 1]&lt;/code&gt; indican cu&amp;aacute;ntos valores agregar despu&amp;eacute;s del contenido del &lt;code&gt;tensor&lt;/code&gt; en esa dimensi&amp;oacute;n. Si el &lt;code&gt;mode&lt;/code&gt; es &quot;REFLECT&quot;, tanto los &lt;code&gt;paddings[D, 0]&lt;/code&gt; como los &lt;code&gt;paddings[D, 1]&lt;/code&gt; deben ser mayores que &lt;code&gt;tensor.dim_size(D) - 1&lt;/code&gt; . Si el &lt;code&gt;mode&lt;/code&gt; es &quot;SYMMETRIC&quot;, tanto los &lt;code&gt;paddings[D, 0]&lt;/code&gt; como los &lt;code&gt;paddings[D, 1]&lt;/code&gt; deben ser mayores que &lt;code&gt;tensor.dim_size(D)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ece6bb1bca3b5a4f71fcb2a4c7bb7def98bb6471" translate="yes" xml:space="preserve">
          <source>This operation performs non_max_suppression on the inputs per batch, across all classes. Prunes away boxes that have high intersection-over-union (IOU) overlap with previously selected boxes. Bounding boxes are supplied as [y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the coordinates of any diagonal pair of box corners and the coordinates can be provided as normalized (i.e., lying in the interval [0, 1]) or absolute. Note that this algorithm is agnostic to where the origin is in the coordinate system. Also note that this algorithm is invariant to orthogonal transformations and translations of the coordinate system; thus translating or reflections of the coordinate system result in the same boxes being selected by the algorithm. The output of this operation is the final boxes, scores and classes tensor returned after performing non_max_suppression.</source>
          <target state="translated">Esta operación realiza una no_supresión_máxima en las entradas por lote,en todas las clases.Elimina las cajas que tienen una alta intersección-sobre-unión (IOU)que se superponen con las cajas previamente seleccionadas.Las cajas delimitadoras se suministran como [y1,x1,y2,x2],donde (y1,x1)y (y2,x2)son las coordenadas de cualquier par diagonal de esquinas de caja y las coordenadas pueden suministrarse como normalizadas (es decir,situadas en el intervalo [0,1])o absolutas.Obsérvese que este algoritmo es agnóstico en cuanto al lugar de origen en el sistema de coordenadas.Obsérvese también que este algoritmo es invariable a las transformaciones ortogonales y a las traslaciones del sistema de coordenadas;por lo tanto,las traslaciones o reflexiones del sistema de coordenadas dan lugar a que las mismas casillas sean seleccionadas por el algoritmo.El resultado de esta operación es el tensor final de cajas,puntuaciones y clases que se devuelve después de realizar la no_supresión_máxima.</target>
        </trans-unit>
        <trans-unit id="92bf8506361b0c3190382a71e7f126a1495f07cd" translate="yes" xml:space="preserve">
          <source>This operation randomly samples a tensor of sampled classes (&lt;code&gt;sampled_candidates&lt;/code&gt;) from the range of integers &lt;code&gt;[0, range_max)&lt;/code&gt;.</source>
          <target state="translated">Esta operaci&amp;oacute;n muestrea aleatoriamente un tensor de clases muestreadas ( &lt;code&gt;sampled_candidates&lt;/code&gt; ) del rango de enteros &lt;code&gt;[0, range_max)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef1ed12213e6ff487e80edd0040d70890d84414e" translate="yes" xml:space="preserve">
          <source>This operation requires that &lt;code&gt;axis&lt;/code&gt; is a valid index for &lt;code&gt;input.shape&lt;/code&gt;, following Python indexing rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5bc7ae5c1b93f8f5a6a390a4d228223c7c191dd" translate="yes" xml:space="preserve">
          <source>This operation requires that &lt;code&gt;axis&lt;/code&gt; is a valid index for &lt;code&gt;input.shape&lt;/code&gt;, following python indexing rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2656ea13a552cbb0836e0031c2afa8bfe371a2e1" translate="yes" xml:space="preserve">
          <source>This operation requires that:</source>
          <target state="translated">Esta operación requiere eso:</target>
        </trans-unit>
        <trans-unit id="b27b171e2cb8132634ecffed1d0dfa123640e238" translate="yes" xml:space="preserve">
          <source>This operation reshapes the &quot;batch&quot; dimension 0 into &lt;code&gt;M + 1&lt;/code&gt; dimensions of shape &lt;code&gt;block_shape + [batch]&lt;/code&gt;, interleaves these blocks back into the grid defined by the spatial dimensions &lt;code&gt;[1, ..., M]&lt;/code&gt;, to obtain a result with the same rank as the input. The spatial dimensions of this intermediate result are then optionally cropped according to &lt;code&gt;crops&lt;/code&gt; to produce the output. This is the reverse of SpaceToBatch (see &lt;a href=&quot;space_to_batch&quot;&gt;&lt;code&gt;tf.space_to_batch&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85455e262fab5e8f9fc55d0016d69887ed46e6fb" translate="yes" xml:space="preserve">
          <source>This operation reshapes the &quot;batch&quot; dimension 0 into &lt;code&gt;M + 1&lt;/code&gt; dimensions of shape &lt;code&gt;block_shape + [batch]&lt;/code&gt;, interleaves these blocks back into the grid defined by the spatial dimensions &lt;code&gt;[1, ..., M]&lt;/code&gt;, to obtain a result with the same rank as the input. The spatial dimensions of this intermediate result are then optionally cropped according to &lt;code&gt;crops&lt;/code&gt; to produce the output. This is the reverse of SpaceToBatch. See below for a precise description.</source>
          <target state="translated">Esta operaci&amp;oacute;n &lt;code&gt;block_shape + [batch]&lt;/code&gt; forma de la dimensi&amp;oacute;n de &quot;lote&quot; 0 en &lt;code&gt;M + 1&lt;/code&gt; dimensiones de forma block_shape + [batch] , intercala estos bloques de nuevo en la cuadr&amp;iacute;cula definida por las dimensiones espaciales &lt;code&gt;[1, ..., M]&lt;/code&gt; , para obtener un resultado con el mismo rango que la entrada. Las dimensiones espaciales de este resultado intermedio se recortan opcionalmente seg&amp;uacute;n los &lt;code&gt;crops&lt;/code&gt; para producir el resultado. Este es el reverso de SpaceToBatch. Consulte a continuaci&amp;oacute;n para obtener una descripci&amp;oacute;n precisa.</target>
        </trans-unit>
        <trans-unit id="9858054bc42ba5d711abfe7b471684870f12eb28" translate="yes" xml:space="preserve">
          <source>This operation returns N 1-D integer tensors representing shape of &lt;code&gt;input[i]s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe8665b789d92e174b87e3b8d8b3131e0c5a95d4" translate="yes" xml:space="preserve">
          <source>This operation returns a 1-D integer tensor representing the shape of &lt;code&gt;input&lt;/code&gt;.</source>
          <target state="translated">Esta operaci&amp;oacute;n devuelve un tensor entero 1-D que representa la forma de la &lt;code&gt;input&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a59463d2fe92b4018e2beec28525b7ad3bbf202" translate="yes" xml:space="preserve">
          <source>This operation returns a tensor &lt;code&gt;y&lt;/code&gt; containing all of the unique elements of &lt;code&gt;x&lt;/code&gt; sorted in the same order that they occur in &lt;code&gt;x&lt;/code&gt;. This operation also returns a tensor &lt;code&gt;idx&lt;/code&gt; the same size as &lt;code&gt;x&lt;/code&gt; that contains the index of each value of &lt;code&gt;x&lt;/code&gt; in the unique output &lt;code&gt;y&lt;/code&gt;. Finally, it returns a third tensor &lt;code&gt;count&lt;/code&gt; that contains the count of each element of &lt;code&gt;y&lt;/code&gt; in &lt;code&gt;x&lt;/code&gt;. In other words:</source>
          <target state="translated">Esta operaci&amp;oacute;n devuelve un tensor &lt;code&gt;y&lt;/code&gt; que contiene todos los elementos &amp;uacute;nicos de &lt;code&gt;x&lt;/code&gt; ordenados en el mismo orden en que ocurren en &lt;code&gt;x&lt;/code&gt; . Esta operaci&amp;oacute;n tambi&amp;eacute;n devuelve un tensor &lt;code&gt;idx&lt;/code&gt; del mismo tama&amp;ntilde;o que &lt;code&gt;x&lt;/code&gt; que contiene el &amp;iacute;ndice de cada valor de &lt;code&gt;x&lt;/code&gt; en la salida &amp;uacute;nica &lt;code&gt;y&lt;/code&gt; . Finalmente, devuelve un tercer &lt;code&gt;count&lt;/code&gt; tensorial que contiene el recuento de cada elemento de &lt;code&gt;y&lt;/code&gt; en &lt;code&gt;x&lt;/code&gt; . En otras palabras:</target>
        </trans-unit>
        <trans-unit id="536871e049e74061332eb50e7568b95429f16ba6" translate="yes" xml:space="preserve">
          <source>This operation returns a tensor &lt;code&gt;y&lt;/code&gt; containing all of the unique elements of &lt;code&gt;x&lt;/code&gt; sorted in the same order that they occur in &lt;code&gt;x&lt;/code&gt;; &lt;code&gt;x&lt;/code&gt; does not need to be sorted. This operation also returns a tensor &lt;code&gt;idx&lt;/code&gt; the same size as &lt;code&gt;x&lt;/code&gt; that contains the index of each value of &lt;code&gt;x&lt;/code&gt; in the unique output &lt;code&gt;y&lt;/code&gt;. In other words:</source>
          <target state="translated">Esta operaci&amp;oacute;n devuelve un tensor &lt;code&gt;y&lt;/code&gt; que contiene todos los elementos &amp;uacute;nicos de &lt;code&gt;x&lt;/code&gt; ordenados en el mismo orden en que aparecen en &lt;code&gt;x&lt;/code&gt; ; &lt;code&gt;x&lt;/code&gt; no necesita ordenarse. Esta operaci&amp;oacute;n tambi&amp;eacute;n devuelve un tensor &lt;code&gt;idx&lt;/code&gt; del mismo tama&amp;ntilde;o que &lt;code&gt;x&lt;/code&gt; que contiene el &amp;iacute;ndice de cada valor de &lt;code&gt;x&lt;/code&gt; en la salida &amp;uacute;nica &lt;code&gt;y&lt;/code&gt; . En otras palabras:</target>
        </trans-unit>
        <trans-unit id="08bfd9d4b0608003900efe52523c1412fe2e10f1" translate="yes" xml:space="preserve">
          <source>This operation returns a tensor of type &lt;code&gt;dtype&lt;/code&gt; with shape &lt;code&gt;shape&lt;/code&gt; and all elements set to one.</source>
          <target state="translated">Esta operaci&amp;oacute;n devuelve un tensor de tipo &lt;code&gt;dtype&lt;/code&gt; con shape &lt;code&gt;shape&lt;/code&gt; y todos los elementos establecidos en uno.</target>
        </trans-unit>
        <trans-unit id="46403ed383d4150a23258a456b0faa0e79d56dbe" translate="yes" xml:space="preserve">
          <source>This operation returns a tensor of type &lt;code&gt;dtype&lt;/code&gt; with shape &lt;code&gt;shape&lt;/code&gt; and all elements set to zero.</source>
          <target state="translated">Esta operaci&amp;oacute;n devuelve un tensor de tipo &lt;code&gt;dtype&lt;/code&gt; con shape &lt;code&gt;shape&lt;/code&gt; y todos los elementos establecidos en cero.</target>
        </trans-unit>
        <trans-unit id="476cbc978c015f266a3353221077ac3bad3036de" translate="yes" xml:space="preserve">
          <source>This operation returns a tensor with the &lt;code&gt;diagonal&lt;/code&gt; part of the &lt;code&gt;input&lt;/code&gt;. The &lt;code&gt;diagonal&lt;/code&gt; part is computed as follows:</source>
          <target state="translated">Esta operaci&amp;oacute;n devuelve un tensor con la parte &lt;code&gt;diagonal&lt;/code&gt; de la &lt;code&gt;input&lt;/code&gt; . La parte &lt;code&gt;diagonal&lt;/code&gt; se calcula de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="4aefd218f88fe56a44f84be48601325a8bfff9a5" translate="yes" xml:space="preserve">
          <source>This operation returns a tensor with the &lt;code&gt;diagonal&lt;/code&gt; part of the batched &lt;code&gt;input&lt;/code&gt;. The &lt;code&gt;diagonal&lt;/code&gt; part is computed as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19c9a08587b8ac6d36c602ec8cf419295278168f" translate="yes" xml:space="preserve">
          <source>This operation returns an integer representing the number of elements in &lt;code&gt;input&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="283ea59f55046522de219f0f2dc075ad8e2f3a65" translate="yes" xml:space="preserve">
          <source>This operation returns an integer representing the rank of &lt;code&gt;input&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7e2028f3f49e171315c3ed603528d9f2314c768" translate="yes" xml:space="preserve">
          <source>This operation returns the coordinates of true elements in &lt;code&gt;condition&lt;/code&gt;. The coordinates are returned in a 2-D tensor where the first dimension (rows) represents the number of true elements, and the second dimension (columns) represents the coordinates of the true elements. Keep in mind, the shape of the output tensor can vary depending on how many true values there are in &lt;code&gt;condition&lt;/code&gt;. Indices are output in row-major order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9768f017e85a1cd0efa99d0dd71cd4a51ae98fd1" translate="yes" xml:space="preserve">
          <source>This operation returns the result of a TPU compilation as a serialized CompilationResultProto, which holds a status and an error message if an error occurred during compilation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2b8bbf455ec7dda7bf033c368dcb34b158ee06e" translate="yes" xml:space="preserve">
          <source>This operation returns the same result as the C++ std::nextafter function.</source>
          <target state="translated">Esta operación devuelve el mismo resultado que la función C++std::nextafter.</target>
        </trans-unit>
        <trans-unit id="cba2fef602700f559d54f64ca39679c7fe5a39cf" translate="yes" xml:space="preserve">
          <source>This operation returns true if the queue is closed and false if the queue is open.</source>
          <target state="translated">Esta operación vuelve verdadera si la cola está cerrada y falsa si la cola está abierta.</target>
        </trans-unit>
        <trans-unit id="dc131f95b04b052706f9dc5a2e0863ccce212278" translate="yes" xml:space="preserve">
          <source>This operation signals that no more elements will be enqueued in the given queue. Subsequent &lt;code&gt;enqueue&lt;/code&gt; and &lt;code&gt;enqueue_many&lt;/code&gt; operations will fail. Subsequent &lt;code&gt;dequeue&lt;/code&gt; and &lt;code&gt;dequeue_many&lt;/code&gt; operations will continue to succeed if sufficient elements remain in the queue. Subsequently dequeue and dequeue_many operations that would otherwise block waiting for more elements (if close hadn't been called) will now fail immediately.</source>
          <target state="translated">Esta operaci&amp;oacute;n indica que no se colocar&amp;aacute;n m&amp;aacute;s elementos en la cola dada. Subsiguientes &lt;code&gt;enqueue&lt;/code&gt; y &lt;code&gt;enqueue_many&lt;/code&gt; operaciones fallar&amp;aacute;n. Las &lt;code&gt;dequeue&lt;/code&gt; posteriores dequeue y &lt;code&gt;dequeue_many&lt;/code&gt; seguir&amp;aacute;n teniendo &amp;eacute;xito si quedan suficientes elementos en la cola. Posteriormente, las operaciones dequeue y dequeue_many que de otro modo bloquear&amp;iacute;an la espera de m&amp;aacute;s elementos (si no se hubiera llamado a close) ahora fallar&amp;aacute;n inmediatamente.</target>
        </trans-unit>
        <trans-unit id="03d601007c00ecaaf281c99e7ccdb7f989fc3f40" translate="yes" xml:space="preserve">
          <source>This operation signals that no more elements will be enqueued in the given queue. Subsequent Enqueue(Many) operations will fail. Subsequent Dequeue(Many) operations will continue to succeed if sufficient elements remain in the queue. Subsequent Dequeue(Many) operations that would block will fail immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ec52846420c7cbfc81445413d50c93e2addb827" translate="yes" xml:space="preserve">
          <source>This operation signals that no more new elements will be inserted in the given barrier. Subsequent InsertMany that try to introduce a new key will fail. Subsequent InsertMany operations that just add missing components to already existing elements will continue to succeed. Subsequent TakeMany operations will continue to succeed if sufficient completed elements remain in the barrier. Subsequent TakeMany operations that would block will fail immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed8ef290710f5b794405ab349bc8048a526b3051" translate="yes" xml:space="preserve">
          <source>This operation slices each component tensor along the 0th dimension to make multiple queue elements. All of the tensors in &lt;code&gt;vals&lt;/code&gt; must have the same size in the 0th dimension.</source>
          <target state="translated">Esta operaci&amp;oacute;n divide cada tensor de componente a lo largo de la dimensi&amp;oacute;n 0 para crear varios elementos de cola. Todos los tensores en &lt;code&gt;vals&lt;/code&gt; deben tener el mismo tama&amp;ntilde;o en la dimensi&amp;oacute;n 0.</target>
        </trans-unit>
        <trans-unit id="b7a9602cce6855f9551ec64964df2f6660343d5e" translate="yes" xml:space="preserve">
          <source>This operation slices each component tensor along the 0th dimension to make multiple queue elements. All of the tuple components must have the same size in the 0th dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b06acef6473406f9a6972f0bdd65c856a80109e7" translate="yes" xml:space="preserve">
          <source>This operation takes variable-length sequences (&lt;code&gt;hypothesis&lt;/code&gt; and &lt;code&gt;truth&lt;/code&gt;), each provided as a &lt;code&gt;SparseTensor&lt;/code&gt;, and computes the Levenshtein distance. You can normalize the edit distance by length of &lt;code&gt;truth&lt;/code&gt; by setting &lt;code&gt;normalize&lt;/code&gt; to true.</source>
          <target state="translated">Esta operaci&amp;oacute;n toma secuencias de longitud variable ( &lt;code&gt;hypothesis&lt;/code&gt; y &lt;code&gt;truth&lt;/code&gt; ), cada una proporcionada como un &lt;code&gt;SparseTensor&lt;/code&gt; , y calcula la distancia de Levenshtein. Puede normalizar la distancia de edici&amp;oacute;n por longitud de &lt;code&gt;truth&lt;/code&gt; estableciendo &lt;code&gt;normalize&lt;/code&gt; en verdadero.</target>
        </trans-unit>
        <trans-unit id="4b844fb17a610af4c2dfbda43ce1ac8c2ea894a7" translate="yes" xml:space="preserve">
          <source>This operation tends to perform well when &lt;code&gt;A&lt;/code&gt; is more sparse, if the column size of the product is small (e.g. matrix-vector multiplication), if &lt;code&gt;sp_a.dense_shape&lt;/code&gt; takes on large values.</source>
          <target state="translated">Esta operaci&amp;oacute;n tiende a funcionar bien cuando &lt;code&gt;A&lt;/code&gt; es m&amp;aacute;s escasa, si el tama&amp;ntilde;o de la columna del producto es peque&amp;ntilde;o (por ejemplo, multiplicaci&amp;oacute;n matriz-vector), si &lt;code&gt;sp_a.dense_shape&lt;/code&gt; toma valores grandes.</target>
        </trans-unit>
        <trans-unit id="656ae1e1362cbc36310acc8deee39f6903aad8f9" translate="yes" xml:space="preserve">
          <source>This operation will block indefinitely until data is available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca0db1beb7905bc51f7f1596562bcd98102255d3" translate="yes" xml:space="preserve">
          <source>This operation will block indefinitely until data is available. Output &lt;code&gt;i&lt;/code&gt; corresponds to XLA tuple element &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1051e1cb11d005837380c93974db8cb36d834ab5" translate="yes" xml:space="preserve">
          <source>This operation will generate a string suitable to be saved out to create a .wav audio file. It will be encoded in the 16-bit PCM format. It takes in float values in the range -1.0f to 1.0f, and any outside that value will be clamped to that range.</source>
          <target state="translated">Esta operación generará una cadena adecuada para ser guardada para crear un archivo de audio .wav.Se codificará en el formato PCM de 16 bits.Toma valores de flotación en el rango de -1.0f a 1.0f,y cualquier valor fuera de ese rango será sujetado a ese rango.</target>
        </trans-unit>
        <trans-unit id="bf6b9f0d6051cd83422b6ad2cb1617b5b6c44a65" translate="yes" xml:space="preserve">
          <source>This operation will output a tensor of shape &lt;code&gt;[1, 1, 1, 4]&lt;/code&gt;:</source>
          <target state="translated">Esta operaci&amp;oacute;n generar&amp;aacute; un tensor de forma &lt;code&gt;[1, 1, 1, 4]&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="01c0abdcd1d63eef5d525eb4d621b9072cafca4f" translate="yes" xml:space="preserve">
          <source>This operation will output a tensor of shape &lt;code&gt;[1, 2, 2, 1]&lt;/code&gt;:</source>
          <target state="translated">Esta operaci&amp;oacute;n generar&amp;aacute; un tensor de forma &lt;code&gt;[1, 2, 2, 1]&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f9c1bb170834121c155816075bc30535b34c3026" translate="yes" xml:space="preserve">
          <source>This operation would return the following:</source>
          <target state="translated">Esta operación devolvería lo siguiente:</target>
        </trans-unit>
        <trans-unit id="c09d355015c640623e774187c625203da78fb3a6" translate="yes" xml:space="preserve">
          <source>This operation would return:</source>
          <target state="translated">Esta operación volvería:</target>
        </trans-unit>
        <trans-unit id="6585b279d1753d7936601f5ce821925656bfd5b2" translate="yes" xml:space="preserve">
          <source>This operation, for block size of 2, will return the following tensor of shape &lt;code&gt;[1, 2, 2, 3]&lt;/code&gt;</source>
          <target state="translated">Esta operaci&amp;oacute;n, para un tama&amp;ntilde;o de bloque de 2, devolver&amp;aacute; el siguiente tensor de forma &lt;code&gt;[1, 2, 2, 3]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="123e5c864ddc20e423825601cb576b64af53b67e" translate="yes" xml:space="preserve">
          <source>This operation, for block_size of 2, will return the following tensor of shape &lt;code&gt;[1, 1, 1, 12]&lt;/code&gt;</source>
          <target state="translated">Esta operaci&amp;oacute;n, para block_size de 2, devolver&amp;aacute; el siguiente tensor de forma &lt;code&gt;[1, 1, 1, 12]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a0a130eb7e8314a609a2db135e21936c4a0de8b" translate="yes" xml:space="preserve">
          <source>This operator acts like a (batch) matrix &lt;code&gt;A&lt;/code&gt; with shape &lt;code&gt;[B1,...,Bb, M, N]&lt;/code&gt; for some &lt;code&gt;b &amp;gt;= 0&lt;/code&gt;. The first &lt;code&gt;b&lt;/code&gt; indices index a batch member. For every batch index &lt;code&gt;(i1,...,ib)&lt;/code&gt;, &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; is an &lt;code&gt;m x n&lt;/code&gt; matrix. Again, this matrix &lt;code&gt;A&lt;/code&gt; may not be materialized, but for purposes of identifying and working with compatible arguments the shape is relevant.</source>
          <target state="translated">Este operador act&amp;uacute;a como una matriz &lt;code&gt;A&lt;/code&gt; (por lotes) con forma &lt;code&gt;[B1,...,Bb, M, N]&lt;/code&gt; para algunos &lt;code&gt;b &amp;gt;= 0&lt;/code&gt; . Los primeros &amp;iacute;ndices &lt;code&gt;b&lt;/code&gt; indexan un miembro del lote. Para cada &amp;iacute;ndice de lote &lt;code&gt;(i1,...,ib)&lt;/code&gt; , &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; es una matriz &lt;code&gt;m x n&lt;/code&gt; . Una vez m&amp;aacute;s, es posible que esta matriz &lt;code&gt;A&lt;/code&gt; no se materialice, pero a los efectos de identificar y trabajar con argumentos compatibles, la forma es relevante.</target>
        </trans-unit>
        <trans-unit id="9624d2140d2af8604c19c56292430ec7141d96ff" translate="yes" xml:space="preserve">
          <source>This operator acts like a [batch] Toeplitz matrix &lt;code&gt;A&lt;/code&gt; with shape &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; for some &lt;code&gt;b &amp;gt;= 0&lt;/code&gt;. The first &lt;code&gt;b&lt;/code&gt; indices index a batch member. For every batch index &lt;code&gt;(i1,...,ib)&lt;/code&gt;, &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; is an &lt;code&gt;N x N&lt;/code&gt; matrix. This matrix &lt;code&gt;A&lt;/code&gt; is not materialized, but for purposes of broadcasting this shape will be relevant.</source>
          <target state="translated">Este operador act&amp;uacute;a como una matriz &lt;code&gt;A&lt;/code&gt; de Toeplitz [lote] con forma &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; para algunos &lt;code&gt;b &amp;gt;= 0&lt;/code&gt; . Los primeros &amp;iacute;ndices &lt;code&gt;b&lt;/code&gt; indexan un miembro del lote. Para cada &amp;iacute;ndice de lote &lt;code&gt;(i1,...,ib)&lt;/code&gt; , &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; es una matriz &lt;code&gt;N x N&lt;/code&gt; . Esta matriz &lt;code&gt;A&lt;/code&gt; no est&amp;aacute; materializada, pero para efectos de difusi&amp;oacute;n esta forma ser&amp;aacute; relevante.</target>
        </trans-unit>
        <trans-unit id="ae991b61103c038a5ab6e26593ecbc7152e117f2" translate="yes" xml:space="preserve">
          <source>This operator acts like a [batch] diagonal matrix &lt;code&gt;A&lt;/code&gt; with shape &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; for some &lt;code&gt;b &amp;gt;= 0&lt;/code&gt;. The first &lt;code&gt;b&lt;/code&gt; indices index a batch member. For every batch index &lt;code&gt;(i1,...,ib)&lt;/code&gt;, &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; is an &lt;code&gt;N x N&lt;/code&gt; matrix. This matrix &lt;code&gt;A&lt;/code&gt; is not materialized, but for purposes of broadcasting this shape will be relevant.</source>
          <target state="translated">Este operador act&amp;uacute;a como una matriz diagonal &lt;code&gt;A&lt;/code&gt; [por lotes] con forma &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; para algunos &lt;code&gt;b &amp;gt;= 0&lt;/code&gt; . Los primeros &amp;iacute;ndices &lt;code&gt;b&lt;/code&gt; indexan un miembro del lote. Para cada &amp;iacute;ndice de lote &lt;code&gt;(i1,...,ib)&lt;/code&gt; , &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; es una matriz &lt;code&gt;N x N&lt;/code&gt; . Esta matriz &lt;code&gt;A&lt;/code&gt; no est&amp;aacute; materializada, pero para efectos de difusi&amp;oacute;n esta forma ser&amp;aacute; relevante.</target>
        </trans-unit>
        <trans-unit id="5eea0437af7326077ca375b7627f553585750e30" translate="yes" xml:space="preserve">
          <source>This operator acts like a [batch] identity matrix &lt;code&gt;A&lt;/code&gt; with shape &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; for some &lt;code&gt;b &amp;gt;= 0&lt;/code&gt;. The first &lt;code&gt;b&lt;/code&gt; indices index a batch member. For every batch index &lt;code&gt;(i1,...,ib)&lt;/code&gt;, &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; is an &lt;code&gt;N x N&lt;/code&gt; matrix. This matrix &lt;code&gt;A&lt;/code&gt; is not materialized, but for purposes of broadcasting this shape will be relevant.</source>
          <target state="translated">Este operador act&amp;uacute;a como una matriz de identidad [lote] &lt;code&gt;A&lt;/code&gt; con forma &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; para algunos &lt;code&gt;b &amp;gt;= 0&lt;/code&gt; . Los primeros &amp;iacute;ndices &lt;code&gt;b&lt;/code&gt; indexan un miembro del lote. Para cada &amp;iacute;ndice de lote &lt;code&gt;(i1,...,ib)&lt;/code&gt; , &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; es una matriz &lt;code&gt;N x N&lt;/code&gt; . Esta matriz &lt;code&gt;A&lt;/code&gt; no est&amp;aacute; materializada, pero para efectos de difusi&amp;oacute;n esta forma ser&amp;aacute; relevante.</target>
        </trans-unit>
        <trans-unit id="7036bf9c433fed406d0eb267aee69b2fb875c75f" translate="yes" xml:space="preserve">
          <source>This operator acts like a [batch] lower triangular matrix &lt;code&gt;A&lt;/code&gt; with shape &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; for some &lt;code&gt;b &amp;gt;= 0&lt;/code&gt;. The first &lt;code&gt;b&lt;/code&gt; indices index a batch member. For every batch index &lt;code&gt;(i1,...,ib)&lt;/code&gt;, &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; is an &lt;code&gt;N x N&lt;/code&gt; matrix.</source>
          <target state="translated">Este operador act&amp;uacute;a como una matriz triangular inferior &lt;code&gt;A&lt;/code&gt; [lote] con forma &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; para algunos &lt;code&gt;b &amp;gt;= 0&lt;/code&gt; . Los primeros &amp;iacute;ndices &lt;code&gt;b&lt;/code&gt; indexan un miembro del lote. Para cada &amp;iacute;ndice de lote &lt;code&gt;(i1,...,ib)&lt;/code&gt; , &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; es una matriz &lt;code&gt;N x N&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d5825859d807d72eb10161ef6b5b940c6fe0b9b" translate="yes" xml:space="preserve">
          <source>This operator acts like a [batch] matrix &lt;code&gt;A&lt;/code&gt; with shape &lt;code&gt;[B1,...,Bb, M, N]&lt;/code&gt; for some &lt;code&gt;b &amp;gt;= 0&lt;/code&gt;. The first &lt;code&gt;b&lt;/code&gt; indices index a batch member. For every batch index &lt;code&gt;(i1,...,ib)&lt;/code&gt;, &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; is an &lt;code&gt;M x N&lt;/code&gt; matrix.</source>
          <target state="translated">Este operador act&amp;uacute;a como una matriz &lt;code&gt;A&lt;/code&gt; [lote] con forma &lt;code&gt;[B1,...,Bb, M, N]&lt;/code&gt; para algunos &lt;code&gt;b &amp;gt;= 0&lt;/code&gt; . Los primeros &amp;iacute;ndices &lt;code&gt;b&lt;/code&gt; indexan un miembro del lote. Para cada &amp;iacute;ndice de lote &lt;code&gt;(i1,...,ib)&lt;/code&gt; , &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; es una matriz &lt;code&gt;M x N&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f99131310964b3eb6cd5147dace10a254e9fff2" translate="yes" xml:space="preserve">
          <source>This operator acts like a [batch] of householder reflections with shape &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; for some &lt;code&gt;b &amp;gt;= 0&lt;/code&gt;. The first &lt;code&gt;b&lt;/code&gt; indices index a batch member. For every batch index &lt;code&gt;(i1,...,ib)&lt;/code&gt;, &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; is an &lt;code&gt;N x N&lt;/code&gt; matrix. This matrix &lt;code&gt;A&lt;/code&gt; is not materialized, but for purposes of broadcasting this shape will be relevant.</source>
          <target state="translated">Este operador act&amp;uacute;a como un [lote] de reflejos dom&amp;eacute;sticos con forma &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; para algunos &lt;code&gt;b &amp;gt;= 0&lt;/code&gt; . Los primeros &amp;iacute;ndices &lt;code&gt;b&lt;/code&gt; indexan un miembro del lote. Para cada &amp;iacute;ndice de lote &lt;code&gt;(i1,...,ib)&lt;/code&gt; , &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; es una matriz &lt;code&gt;N x N&lt;/code&gt; . Esta matriz &lt;code&gt;A&lt;/code&gt; no est&amp;aacute; materializada, pero para efectos de difusi&amp;oacute;n esta forma ser&amp;aacute; relevante.</target>
        </trans-unit>
        <trans-unit id="2c9497726784db48f14f606b75baa3af89ad92c3" translate="yes" xml:space="preserve">
          <source>This operator acts like a [batch] of permutations with shape &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; for some &lt;code&gt;b &amp;gt;= 0&lt;/code&gt;. The first &lt;code&gt;b&lt;/code&gt; indices index a batch member. For every batch index &lt;code&gt;(i1,...,ib)&lt;/code&gt;, &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; is an &lt;code&gt;N x N&lt;/code&gt; matrix. This matrix &lt;code&gt;A&lt;/code&gt; is not materialized, but for purposes of broadcasting this shape will be relevant.</source>
          <target state="translated">Este operador act&amp;uacute;a como un [lote] de permutaciones con forma &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; para algunos &lt;code&gt;b &amp;gt;= 0&lt;/code&gt; . Los primeros &amp;iacute;ndices &lt;code&gt;b&lt;/code&gt; indexan un miembro del lote. Para cada &amp;iacute;ndice de lote &lt;code&gt;(i1,...,ib)&lt;/code&gt; , &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; es una matriz &lt;code&gt;N x N&lt;/code&gt; . Esta matriz &lt;code&gt;A&lt;/code&gt; no est&amp;aacute; materializada, pero para efectos de difusi&amp;oacute;n esta forma ser&amp;aacute; relevante.</target>
        </trans-unit>
        <trans-unit id="583ba682dbf34a68e239431a7d0b3d3bb383323a" translate="yes" xml:space="preserve">
          <source>This operator acts like a [batch] square tridiagonal matrix &lt;code&gt;A&lt;/code&gt; with shape &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; for some &lt;code&gt;b &amp;gt;= 0&lt;/code&gt;. The first &lt;code&gt;b&lt;/code&gt; indices index a batch member. For every batch index &lt;code&gt;(i1,...,ib)&lt;/code&gt;, &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; is an &lt;code&gt;N x M&lt;/code&gt; matrix. This matrix &lt;code&gt;A&lt;/code&gt; is not materialized, but for purposes of broadcasting this shape will be relevant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="400eb5597c413c726e34a9f1e1bb7b69ea62bb78" translate="yes" xml:space="preserve">
          <source>This operator acts like a [batch] zero matrix &lt;code&gt;A&lt;/code&gt; with shape &lt;code&gt;[B1,...,Bb, N, M]&lt;/code&gt; for some &lt;code&gt;b &amp;gt;= 0&lt;/code&gt;. The first &lt;code&gt;b&lt;/code&gt; indices index a batch member. For every batch index &lt;code&gt;(i1,...,ib)&lt;/code&gt;, &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; is an &lt;code&gt;N x M&lt;/code&gt; matrix. This matrix &lt;code&gt;A&lt;/code&gt; is not materialized, but for purposes of broadcasting this shape will be relevant.</source>
          <target state="translated">Este operador act&amp;uacute;a como una matriz &lt;code&gt;A&lt;/code&gt; cero [lote] con forma &lt;code&gt;[B1,...,Bb, N, M]&lt;/code&gt; para algunos &lt;code&gt;b &amp;gt;= 0&lt;/code&gt; . Los primeros &amp;iacute;ndices &lt;code&gt;b&lt;/code&gt; indexan un miembro del lote. Para cada &amp;iacute;ndice de lote &lt;code&gt;(i1,...,ib)&lt;/code&gt; , &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; es una matriz &lt;code&gt;N x M&lt;/code&gt; . Esta matriz &lt;code&gt;A&lt;/code&gt; no est&amp;aacute; materializada, pero para efectos de difusi&amp;oacute;n esta forma ser&amp;aacute; relevante.</target>
        </trans-unit>
        <trans-unit id="b7102c53ecb6c13af874ea168315014a6e7dc84b" translate="yes" xml:space="preserve">
          <source>This operator acts like a block circulant matrix &lt;code&gt;A&lt;/code&gt; with shape &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; for some &lt;code&gt;b &amp;gt;= 0&lt;/code&gt;. The first &lt;code&gt;b&lt;/code&gt; indices index a batch member. For every batch index &lt;code&gt;(i1,...,ib)&lt;/code&gt;, &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; is an &lt;code&gt;N x N&lt;/code&gt; matrix. This matrix &lt;code&gt;A&lt;/code&gt; is not materialized, but for purposes of broadcasting this shape will be relevant.</source>
          <target state="translated">Este operador act&amp;uacute;a como un bloque de matriz circulante &lt;code&gt;A&lt;/code&gt; con forma &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; para algunos &lt;code&gt;b &amp;gt;= 0&lt;/code&gt; . Los primeros &amp;iacute;ndices &lt;code&gt;b&lt;/code&gt; indexan un miembro del lote. Para cada &amp;iacute;ndice de lote &lt;code&gt;(i1,...,ib)&lt;/code&gt; , &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; es una matriz &lt;code&gt;N x N&lt;/code&gt; . Esta matriz &lt;code&gt;A&lt;/code&gt; no est&amp;aacute; materializada, pero para efectos de difusi&amp;oacute;n esta forma ser&amp;aacute; relevante.</target>
        </trans-unit>
        <trans-unit id="4c216274d20b8ffa480f3dfffdabad95ff0cda74" translate="yes" xml:space="preserve">
          <source>This operator acts like a circulant matrix &lt;code&gt;A&lt;/code&gt; with shape &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; for some &lt;code&gt;b &amp;gt;= 0&lt;/code&gt;. The first &lt;code&gt;b&lt;/code&gt; indices index a batch member. For every batch index &lt;code&gt;(i1,...,ib)&lt;/code&gt;, &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; is an &lt;code&gt;N x N&lt;/code&gt; matrix. This matrix &lt;code&gt;A&lt;/code&gt; is not materialized, but for purposes of broadcasting this shape will be relevant.</source>
          <target state="translated">Este operador act&amp;uacute;a como una matriz circulante &lt;code&gt;A&lt;/code&gt; con forma &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; para algunos &lt;code&gt;b &amp;gt;= 0&lt;/code&gt; . Los primeros &amp;iacute;ndices &lt;code&gt;b&lt;/code&gt; indexan un miembro del lote. Para cada &amp;iacute;ndice de lote &lt;code&gt;(i1,...,ib)&lt;/code&gt; , &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; es una matriz &lt;code&gt;N x N&lt;/code&gt; . Esta matriz &lt;code&gt;A&lt;/code&gt; no est&amp;aacute; materializada, pero para efectos de difusi&amp;oacute;n esta forma ser&amp;aacute; relevante.</target>
        </trans-unit>
        <trans-unit id="0f0a750eb3c4adb095723453eef766bb4bcd89f8" translate="yes" xml:space="preserve">
          <source>This operator acts like a scaled [batch] identity matrix &lt;code&gt;A&lt;/code&gt; with shape &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; for some &lt;code&gt;b &amp;gt;= 0&lt;/code&gt;. The first &lt;code&gt;b&lt;/code&gt; indices index a batch member. For every batch index &lt;code&gt;(i1,...,ib)&lt;/code&gt;, &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; is a scaled version of the &lt;code&gt;N x N&lt;/code&gt; identity matrix.</source>
          <target state="translated">Este operador act&amp;uacute;a como una matriz de identidad &lt;code&gt;A&lt;/code&gt; escalada [lote] con forma &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; para algunos &lt;code&gt;b &amp;gt;= 0&lt;/code&gt; . Los primeros &amp;iacute;ndices &lt;code&gt;b&lt;/code&gt; indexan un miembro del lote. Para cada &amp;iacute;ndice de lote &lt;code&gt;(i1,...,ib)&lt;/code&gt; , &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; es una versi&amp;oacute;n escalada de la matriz de identidad &lt;code&gt;N x N&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b1442fc44774d80a4540791883d0146d00de836" translate="yes" xml:space="preserve">
          <source>This operator acts on [batch] matrix with compatible shape. &lt;code&gt;x&lt;/code&gt; is a batch matrix with compatible shape for &lt;code&gt;matmul&lt;/code&gt; and &lt;code&gt;solve&lt;/code&gt; if</source>
          <target state="translated">Este operador act&amp;uacute;a sobre una matriz [lote] con forma compatible. &lt;code&gt;x&lt;/code&gt; es una matriz de lotes con forma compatible para &lt;code&gt;matmul&lt;/code&gt; y &lt;code&gt;solve&lt;/code&gt; si</target>
        </trans-unit>
        <trans-unit id="a4840abea8050987eeb44a958dc938a96dc5772f" translate="yes" xml:space="preserve">
          <source>This operator acts on batch matrices with compatible shape. FILL IN WHAT IS MEANT BY COMPATIBLE SHAPE</source>
          <target state="translated">Este operador actúa sobre matrices de lotes de forma compatible.RELLENA LO QUE SE ENTIENDE POR FORMA COMPATIBLE</target>
        </trans-unit>
        <trans-unit id="5cfb7dc84da5837b6c81afa0e3c1dd415d37bda4" translate="yes" xml:space="preserve">
          <source>This operator broadcasts the batch dimensions of &lt;code&gt;bands&lt;/code&gt; and the batch dimensions of &lt;code&gt;rhs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53228a3fac3cf2f50966b1ada24ef3b0466deb1e" translate="yes" xml:space="preserve">
          <source>This operator combines one or more linear operators &lt;code&gt;[op1,...,opJ]&lt;/code&gt;, building a new &lt;code&gt;LinearOperator&lt;/code&gt;, whose underlying matrix representation is square and has each operator &lt;code&gt;opi&lt;/code&gt; on the main diagonal, and zero's elsewhere.</source>
          <target state="translated">Este operador combina uno o m&amp;aacute;s operadores lineales &lt;code&gt;[op1,...,opJ]&lt;/code&gt; , construyendo un nuevo &lt;code&gt;LinearOperator&lt;/code&gt; , cuya representaci&amp;oacute;n de matriz subyacente es cuadrada y tiene cada operador &lt;code&gt;opi&lt;/code&gt; en la diagonal principal y ceros en otra parte.</target>
        </trans-unit>
        <trans-unit id="564367f646774e8a861547adb060150a45779d5f" translate="yes" xml:space="preserve">
          <source>This operator composes one or more linear operators &lt;code&gt;[op1,...,opJ]&lt;/code&gt;, building a new &lt;code&gt;LinearOperator&lt;/code&gt; representing the Kronecker product: &lt;code&gt;op1 x op2 x .. opJ&lt;/code&gt; (we omit parentheses as the Kronecker product is associative).</source>
          <target state="translated">Este operador compone uno o m&amp;aacute;s operadores lineales &lt;code&gt;[op1,...,opJ]&lt;/code&gt; , construyendo un nuevo &lt;code&gt;LinearOperator&lt;/code&gt; que representa el producto Kronecker: &lt;code&gt;op1 x op2 x .. opJ&lt;/code&gt; (omitimos los par&amp;eacute;ntesis porque el producto Kronecker es asociativo).</target>
        </trans-unit>
        <trans-unit id="0c0d85ebac206e74618bf7317ca7c96fff15c835" translate="yes" xml:space="preserve">
          <source>This operator composes one or more linear operators &lt;code&gt;[op1,...,opJ]&lt;/code&gt;, building a new &lt;code&gt;LinearOperator&lt;/code&gt; with action defined by:</source>
          <target state="translated">Este operador compone uno o m&amp;aacute;s operadores lineales &lt;code&gt;[op1,...,opJ]&lt;/code&gt; , construyendo un nuevo &lt;code&gt;LinearOperator&lt;/code&gt; con acci&amp;oacute;n definida por:</target>
        </trans-unit>
        <trans-unit id="8e7241eaa8846c5c4338cb18a140b07ab3b606ae" translate="yes" xml:space="preserve">
          <source>This operator corresponds to a real matrix if and only if &lt;code&gt;H&lt;/code&gt; is Hermitian.</source>
          <target state="translated">Este operador corresponde a una matriz real si y solo si &lt;code&gt;H&lt;/code&gt; es hermitiano.</target>
        </trans-unit>
        <trans-unit id="6f9242e838252063460c0276fd01dfac0ef01ff4" translate="yes" xml:space="preserve">
          <source>This operator corresponds to a real-valued matrix if and only if its spectrum is Hermitian.</source>
          <target state="translated">Este operador corresponde a una matriz de valor real si y sólo si su espectro es hermitiano.</target>
        </trans-unit>
        <trans-unit id="3bcff2453a32e7e855e1bf28e92cc09521b4d919" translate="yes" xml:space="preserve">
          <source>This operator has two modes: in one mode both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are provided, in another mode neither are provided. &lt;code&gt;condition&lt;/code&gt; is always expected to be a &lt;a href=&quot;tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; of type &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c618e51b272c823eef5139b9cc3a948f981f98e8" translate="yes" xml:space="preserve">
          <source>This operator is able to broadcast the leading (batch) dimensions, which sometimes requires copying data. If &lt;code&gt;batch_shape&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, the operator can take arguments of any batch shape without copying. See examples.</source>
          <target state="translated">Este operador puede difundir las dimensiones iniciales (por lotes), lo que a veces requiere copiar datos. Si &lt;code&gt;batch_shape&lt;/code&gt; es &lt;code&gt;None&lt;/code&gt; , el operador puede tomar argumentos de cualquier forma de lote sin copiar. Ver ejemplos.</target>
        </trans-unit>
        <trans-unit id="66cb218ad1e2e8f68e038b90d3bfb45bd6e74e63" translate="yes" xml:space="preserve">
          <source>This operator is able to broadcast the leading (batch) dimensions.</source>
          <target state="translated">Este operador es capaz de transmitir las dimensiones principales (lote).</target>
        </trans-unit>
        <trans-unit id="348a23cb6559c85829c515ac4244685e0efb46f2" translate="yes" xml:space="preserve">
          <source>This operator is considered non-singular if</source>
          <target state="translated">Este operador se considera no-singular si</target>
        </trans-unit>
        <trans-unit id="b5e0ce71bd6146dbac079f3d21ad0a2a2a8c2054" translate="yes" xml:space="preserve">
          <source>This operator is initialized with a nested list of linear operators, which are combined into a new &lt;code&gt;LinearOperator&lt;/code&gt; whose underlying matrix representation is square and has each operator on or below the main diagonal, and zero's elsewhere. Each element of the outer list is a list of &lt;code&gt;LinearOperators&lt;/code&gt; corresponding to a row-partition of the blockwise structure. The number of &lt;code&gt;LinearOperator&lt;/code&gt;s in row-partion &lt;code&gt;i&lt;/code&gt; must be equal to &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d06a5054c0e8f5a488a0e50140ca1317d8ee8b76" translate="yes" xml:space="preserve">
          <source>This operator is positive definite if and only if &lt;code&gt;Real{H} &amp;gt; 0&lt;/code&gt;.</source>
          <target state="translated">Este operador es positivo definido si y solo si &lt;code&gt;Real{H} &amp;gt; 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa787331edbdbf77b6543a837e62e8acfa555fdd" translate="yes" xml:space="preserve">
          <source>This operator is self-adjoint if and only if &lt;code&gt;H&lt;/code&gt; is real.</source>
          <target state="translated">Este operador es autoadjunto si y solo si &lt;code&gt;H&lt;/code&gt; es real.</target>
        </trans-unit>
        <trans-unit id="0434efb4cb6fe37aceabe23ccb563dea7d82d49a" translate="yes" xml:space="preserve">
          <source>This operator is similar to the unsorted segment sum operator found &lt;a href=&quot;https://www.tensorflow.org/api_docs/api_docs/python/math_ops#UnsortedSegmentSum&quot;&gt;(here)&lt;/a&gt;. Instead of computing the sum over segments, it computes the maximum such that:</source>
          <target state="translated">Este operador es similar al operador de suma de segmentos sin clasificar encontrado &lt;a href=&quot;https://www.tensorflow.org/api_docs/api_docs/python/math_ops#UnsortedSegmentSum&quot;&gt;(aqu&amp;iacute;)&lt;/a&gt; . En lugar de calcular la suma de los segmentos, calcula el m&amp;aacute;ximo de modo que:</target>
        </trans-unit>
        <trans-unit id="f0203b5b1fedf802a969aad64e740ba2ad439f1c" translate="yes" xml:space="preserve">
          <source>This operator is similar to the unsorted segment sum operator found &lt;a href=&quot;https://www.tensorflow.org/api_docs/api_docs/python/math_ops#UnsortedSegmentSum&quot;&gt;(here)&lt;/a&gt;. Instead of computing the sum over segments, it computes the minimum such that:</source>
          <target state="translated">Este operador es similar al operador de suma de segmentos sin clasificar encontrado &lt;a href=&quot;https://www.tensorflow.org/api_docs/api_docs/python/math_ops#UnsortedSegmentSum&quot;&gt;(aqu&amp;iacute;)&lt;/a&gt; . En lugar de calcular la suma de los segmentos, calcula el m&amp;iacute;nimo tal que:</target>
        </trans-unit>
        <trans-unit id="9b525fce235ebc8f800bcb2ded78049fa74f120a" translate="yes" xml:space="preserve">
          <source>This operator is similar to the unsorted segment sum operator found &lt;a href=&quot;https://www.tensorflow.org/api_docs/api_docs/python/math_ops#UnsortedSegmentSum&quot;&gt;(here)&lt;/a&gt;. Instead of computing the sum over segments, it computes the product of all entries belonging to a segment such that:</source>
          <target state="translated">Este operador es similar al operador de suma de segmentos sin clasificar encontrado &lt;a href=&quot;https://www.tensorflow.org/api_docs/api_docs/python/math_ops#UnsortedSegmentSum&quot;&gt;(aqu&amp;iacute;)&lt;/a&gt; . En lugar de calcular la suma de los segmentos, calcula el producto de todas las entradas que pertenecen a un segmento de manera que:</target>
        </trans-unit>
        <trans-unit id="59fd9e153dcbd12bffedb241b5f88000e9237c11" translate="yes" xml:space="preserve">
          <source>This operator is similar to the unsorted segment sum operator found &lt;a href=&quot;https://www.tensorflow.org/api_docs/api_docs/python/math_ops#UnsortedSegmentSum&quot;&gt;here&lt;/a&gt;. Additionally to computing the sum over segments, it divides the results by sqrt(N).</source>
          <target state="translated">Este operador es similar al operador de suma de segmentos sin clasificar que se encuentra &lt;a href=&quot;https://www.tensorflow.org/api_docs/api_docs/python/math_ops#UnsortedSegmentSum&quot;&gt;aqu&amp;iacute;&lt;/a&gt; . Adem&amp;aacute;s de calcular la suma de los segmentos, divide los resultados por sqrt (N).</target>
        </trans-unit>
        <trans-unit id="a4a7cb1afea6269197bd76bbd4732c1dbecdf7fc" translate="yes" xml:space="preserve">
          <source>This operator is similar to the unsorted segment sum operator found &lt;a href=&quot;https://www.tensorflow.org/api_docs/api_docs/python/math_ops#UnsortedSegmentSum&quot;&gt;here&lt;/a&gt;. Instead of computing the sum over segments, it computes the mean of all entries belonging to a segment such that:</source>
          <target state="translated">Este operador es similar al operador de suma de segmentos sin clasificar que se encuentra &lt;a href=&quot;https://www.tensorflow.org/api_docs/api_docs/python/math_ops#UnsortedSegmentSum&quot;&gt;aqu&amp;iacute;&lt;/a&gt; . En lugar de calcular la suma de los segmentos, calcula la media de todas las entradas que pertenecen a un segmento de manera que:</target>
        </trans-unit>
        <trans-unit id="52ed4dad04ede72e0a76f0501a2814cdc539eef1" translate="yes" xml:space="preserve">
          <source>This operator is similar to the unsorted segment sum operator found &lt;a href=&quot;https://www.tensorflow.org/versions/r2.3/api_docs/api_docs/python/math_ops#UnsortedSegmentSum&quot;&gt;(here)&lt;/a&gt;. Instead of computing the sum over segments, it computes the maximum such that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5555cd5610bd14e5cd5be64e806dbe517b909cf" translate="yes" xml:space="preserve">
          <source>This operator is similar to the unsorted segment sum operator found &lt;a href=&quot;https://www.tensorflow.org/versions/r2.3/api_docs/api_docs/python/math_ops#UnsortedSegmentSum&quot;&gt;(here)&lt;/a&gt;. Instead of computing the sum over segments, it computes the minimum such that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5626f77bd1ee157ca8ad5f5950e88d3290b6e7a5" translate="yes" xml:space="preserve">
          <source>This operator is similar to the unsorted segment sum operator found &lt;a href=&quot;https://www.tensorflow.org/versions/r2.3/api_docs/api_docs/python/math_ops#UnsortedSegmentSum&quot;&gt;(here)&lt;/a&gt;. Instead of computing the sum over segments, it computes the product of all entries belonging to a segment such that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4490e7220bb7e840d8af406c98df4879f8c31ca" translate="yes" xml:space="preserve">
          <source>This operator is similar to the unsorted segment sum operator found &lt;a href=&quot;https://www.tensorflow.org/versions/r2.3/api_docs/api_docs/python/math_ops#UnsortedSegmentSum&quot;&gt;here&lt;/a&gt;. Additionally to computing the sum over segments, it divides the results by sqrt(N).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fcc2d9bddedbecbae737fa85ec20cea5d89c2f2" translate="yes" xml:space="preserve">
          <source>This operator is similar to the unsorted segment sum operator found &lt;a href=&quot;https://www.tensorflow.org/versions/r2.3/api_docs/api_docs/python/math_ops#UnsortedSegmentSum&quot;&gt;here&lt;/a&gt;. Instead of computing the sum over segments, it computes the mean of all entries belonging to a segment such that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83929e057e5aae77fa1c5e82493e5f81ffd7c7d5" translate="yes" xml:space="preserve">
          <source>This operator represents the adjoint of another operator.</source>
          <target state="translated">Este operador representa el complemento de otro operador.</target>
        </trans-unit>
        <trans-unit id="011faa1fcbdac7f7db43d7798ee8f420d25df1c3" translate="yes" xml:space="preserve">
          <source>This operator represents the inverse of another operator.</source>
          <target state="translated">Este operador representa el inverso de otro operador.</target>
        </trans-unit>
        <trans-unit id="d243b49a16809ba508894c3eb53aaf2744d8ff3a" translate="yes" xml:space="preserve">
          <source>This operator represents the loop termination condition used by the &quot;pivot&quot; switches of a loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efbc958735ecb1b79fddfae66e71db4081b1ceb7" translate="yes" xml:space="preserve">
          <source>This operator takes the given &lt;code&gt;SparseTensor&lt;/code&gt; and adds it to a container object (a &lt;code&gt;SparseTensorsMap&lt;/code&gt;). A unique key within this container is generated in the form of an &lt;code&gt;int64&lt;/code&gt;, and this is the value that is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8beab818ce538eb5919197a98807ea337b127bd0" translate="yes" xml:space="preserve">
          <source>This operator tries to squeeze as much precision as possible into an output with a lower bit depth by calculating the actual min and max values found in the data. For example, maybe that quint16 input has no values lower than 16,384 and none higher than 49,152. That means only half the range is actually needed, all the float interpretations are between -0.5f and 0.5f, so if we want to compress the data into a quint8 output, we can use that range rather than the theoretical -1.0f to 1.0f that is suggested by the input min and max.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caac5d3bbf4d0945a7bd985970cd4106cce90915" translate="yes" xml:space="preserve">
          <source>This operator wraps a [batch] matrix &lt;code&gt;A&lt;/code&gt; (which is a &lt;code&gt;Tensor&lt;/code&gt;) with shape &lt;code&gt;[B1,...,Bb, M, N]&lt;/code&gt; for some &lt;code&gt;b &amp;gt;= 0&lt;/code&gt;. The first &lt;code&gt;b&lt;/code&gt; indices index a batch member. For every batch index &lt;code&gt;(i1,...,ib)&lt;/code&gt;, &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; is an &lt;code&gt;M x N&lt;/code&gt; matrix.</source>
          <target state="translated">Este operador envuelve una matriz &lt;code&gt;A&lt;/code&gt; [lote] (que es un &lt;code&gt;Tensor&lt;/code&gt; ) con forma &lt;code&gt;[B1,...,Bb, M, N]&lt;/code&gt; para algunos &lt;code&gt;b &amp;gt;= 0&lt;/code&gt; . Los primeros &amp;iacute;ndices &lt;code&gt;b&lt;/code&gt; indexan un miembro del lote. Para cada &amp;iacute;ndice de lote &lt;code&gt;(i1,...,ib)&lt;/code&gt; , &lt;code&gt;A[i1,...,ib, : :]&lt;/code&gt; es una matriz &lt;code&gt;M x N&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7a64029550dddacbaa84a5c9b1e8fcd91b9538b" translate="yes" xml:space="preserve">
          <source>This optimizer class is &lt;a href=&quot;../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; aware, which means it automatically sums gradients across all replicas. To average gradients, you divide your loss by the global batch size, which is done automatically if you use &lt;a href=&quot;../../keras&quot;&gt;&lt;code&gt;tf.keras&lt;/code&gt;&lt;/a&gt; built-in training or evaluation loops. See the &lt;code&gt;reduction&lt;/code&gt; argument of your loss which should be set to &lt;a href=&quot;../losses/reduction#SUM_OVER_BATCH_SIZE&quot;&gt;&lt;code&gt;tf.keras.losses.Reduction.SUM_OVER_BATCH_SIZE&lt;/code&gt;&lt;/a&gt; for averaging or &lt;a href=&quot;../losses/reduction#SUM&quot;&gt;&lt;code&gt;tf.keras.losses.Reduction.SUM&lt;/code&gt;&lt;/a&gt; for not.</source>
          <target state="translated">Esta clase de optimizador es &lt;a href=&quot;../../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt; , lo que significa que suma autom&amp;aacute;ticamente los gradientes en todas las r&amp;eacute;plicas. Para promediar gradientes, divida su p&amp;eacute;rdida por el tama&amp;ntilde;o global del lote, lo que se hace autom&amp;aacute;ticamente si usa los &lt;a href=&quot;../../keras&quot;&gt; &lt;code&gt;tf.keras&lt;/code&gt; &lt;/a&gt; de capacitaci&amp;oacute;n o evaluaci&amp;oacute;n integrados de tf.keras . Vea el argumento de &lt;code&gt;reduction&lt;/code&gt; de su p&amp;eacute;rdida, que deber&amp;iacute;a establecerse en &lt;a href=&quot;../losses/reduction#SUM_OVER_BATCH_SIZE&quot;&gt; &lt;code&gt;tf.keras.losses.Reduction.SUM_OVER_BATCH_SIZE&lt;/code&gt; &lt;/a&gt; para promediar o &lt;a href=&quot;../losses/reduction#SUM&quot;&gt; &lt;code&gt;tf.keras.losses.Reduction.SUM&lt;/code&gt; &lt;/a&gt; para no.</target>
        </trans-unit>
        <trans-unit id="f9ca3ab79a1177cb06784d426253ffabbbc2a6a4" translate="yes" xml:space="preserve">
          <source>This optimizer takes care of regularization of unseen features in a mini batch by updating them when they are seen with a closed form update rule that is equivalent to having updated them on every mini-batch.</source>
          <target state="translated">Este optimizador se encarga de la regularización de las características no vistas en un mini lote,actualizándolas cuando se ven con una regla de actualización de forma cerrada que equivale a haberlas actualizado en cada mini lote.</target>
        </trans-unit>
        <trans-unit id="9a8b5c268bde39d241894c5b95721103ebdbc425" translate="yes" xml:space="preserve">
          <source>This optimizer wraps another optimizer and applies loss scaling to it via a &lt;code&gt;LossScale&lt;/code&gt;. Loss scaling is applied whenever gradients are computed, either through &lt;code&gt;minimize()&lt;/code&gt; or &lt;code&gt;get_gradients()&lt;/code&gt;. The loss scale is updated via &lt;a href=&quot;../../../mixed_precision/experimental/lossscale#update&quot;&gt;&lt;code&gt;LossScale.update()&lt;/code&gt;&lt;/a&gt; whenever gradients are applied, either through &lt;code&gt;minimize()&lt;/code&gt; or &lt;code&gt;apply_gradients()&lt;/code&gt;. For example:</source>
          <target state="translated">Este optimizador envuelve otro optimizador y le aplica una escala de p&amp;eacute;rdida a trav&amp;eacute;s de &lt;code&gt;LossScale&lt;/code&gt; . La escala de p&amp;eacute;rdida se aplica siempre que se calculan los gradientes, ya sea a trav&amp;eacute;s de &lt;code&gt;minimize()&lt;/code&gt; o &lt;code&gt;get_gradients()&lt;/code&gt; . La escala de p&amp;eacute;rdida se actualiza a trav&amp;eacute;s de &lt;a href=&quot;../../../mixed_precision/experimental/lossscale#update&quot;&gt; &lt;code&gt;LossScale.update()&lt;/code&gt; &lt;/a&gt; cada vez que se aplican gradientes, ya sea a trav&amp;eacute;s de &lt;code&gt;minimize()&lt;/code&gt; o &lt;code&gt;apply_gradients()&lt;/code&gt; . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="a13f36128710145f1603618c3c0bcd6462911f2d" translate="yes" xml:space="preserve">
          <source>This optimizer wraps another optimizer and applies loss scaling to it via a &lt;code&gt;LossScale&lt;/code&gt;. Loss scaling is applied whenever gradients are computed, such as through &lt;code&gt;minimize()&lt;/code&gt;.</source>
          <target state="translated">Este optimizador envuelve otro optimizador y le aplica una escala de p&amp;eacute;rdida a trav&amp;eacute;s de &lt;code&gt;LossScale&lt;/code&gt; . La escala de p&amp;eacute;rdida se aplica siempre que se calculan los gradientes, como a trav&amp;eacute;s de &lt;code&gt;minimize()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64e321c394397e96aca6614583438da557ccee0e" translate="yes" xml:space="preserve">
          <source>This option can be used to override the default policy for how to handle external state when serializing a dataset or checkpointing its iterator. There are three settings available - IGNORE: in which we completely ignore any state; WARN: We warn the user that some state might be thrown away; FAIL: We fail if any state is being captured.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa77eb4223231696da9576378f71e5fd1b4c5fa1" translate="yes" xml:space="preserve">
          <source>This outputs a &lt;code&gt;batch_size&lt;/code&gt; bool array, an entry &lt;code&gt;out[i]&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; if the prediction for the target class is among the top &lt;code&gt;k&lt;/code&gt; predictions among all predictions for example &lt;code&gt;i&lt;/code&gt;. Note that the behavior of &lt;code&gt;InTopK&lt;/code&gt; differs from the &lt;code&gt;TopK&lt;/code&gt; op in its handling of ties; if multiple classes have the same prediction value and straddle the top-&lt;code&gt;k&lt;/code&gt; boundary, all of those classes are considered to be in the top &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43b5cb445e044712f2e69a5344f02f5be0ddda93" translate="yes" xml:space="preserve">
          <source>This outputs a &lt;code&gt;batch_size&lt;/code&gt; bool array, an entry &lt;code&gt;out[i]&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; if the prediction for the target class is finite (not inf, -inf, or nan) and among the top &lt;code&gt;k&lt;/code&gt; predictions among all predictions for example &lt;code&gt;i&lt;/code&gt;. Note that the behavior of &lt;code&gt;InTopK&lt;/code&gt; differs from the &lt;code&gt;TopK&lt;/code&gt; op in its handling of ties; if multiple classes have the same prediction value and straddle the top-&lt;code&gt;k&lt;/code&gt; boundary, all of those classes are considered to be in the top &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="translated">Esto genera una &lt;code&gt;batch_size&lt;/code&gt; bool batch_size , una entrada &lt;code&gt;out[i]&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; si la predicci&amp;oacute;n para la clase objetivo es finita (no inf, -inf o nan) y entre las &lt;code&gt;k&lt;/code&gt; predicciones principales entre todas las predicciones, por ejemplo, &lt;code&gt;i&lt;/code&gt; . Tenga en cuenta que el comportamiento de &lt;code&gt;InTopK&lt;/code&gt; difiere del de la &lt;code&gt;TopK&lt;/code&gt; en su manejo de los empates; si varias clases tienen el mismo valor de predicci&amp;oacute;n y se encuentran en el l&amp;iacute;mite superior de &lt;code&gt;k&lt;/code&gt; , se considera que todas esas clases est&amp;aacute;n en la parte superior &lt;code&gt;k&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="345380820e023cc35c074a4e6039205226041719" translate="yes" xml:space="preserve">
          <source>This overload raises a &lt;code&gt;TypeError&lt;/code&gt; when the user inadvertently treats a &lt;code&gt;Tensor&lt;/code&gt; as a boolean (most commonly in an &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;while&lt;/code&gt; statement), in code that was not converted by AutoGraph. For example:</source>
          <target state="translated">Esta sobrecarga genera un &lt;code&gt;TypeError&lt;/code&gt; cuando el usuario trata inadvertidamente un &lt;code&gt;Tensor&lt;/code&gt; como un booleano (m&amp;aacute;s com&amp;uacute;nmente en una declaraci&amp;oacute;n &lt;code&gt;if&lt;/code&gt; o &lt;code&gt;while&lt;/code&gt; ), en un c&amp;oacute;digo que no fue convertido por AutoGraph. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="5f63c68c6b6d06032eeae666e8d05a28d8b6e750" translate="yes" xml:space="preserve">
          <source>This package defines ops for manipulating ragged tensors (&lt;a href=&quot;../../raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt;), which are tensors with non-uniform shapes. In particular, each &lt;code&gt;RaggedTensor&lt;/code&gt; has one or more &lt;em&gt;ragged dimensions&lt;/em&gt;, which are dimensions whose slices may have different lengths. For example, the inner (column) dimension of &lt;code&gt;rt=[[3, 1, 4, 1], [], [5, 9, 2], [6], []]&lt;/code&gt; is ragged, since the column slices (&lt;code&gt;rt[0, :]&lt;/code&gt;, ..., &lt;code&gt;rt[4, :]&lt;/code&gt;) have different lengths. For a more detailed description of ragged tensors, see the &lt;a href=&quot;../../raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt; class documentation and the &lt;a href=&quot;https://www.tensorflow.org/guide/ragged_tensors&quot;&gt;Ragged Tensor Guide&lt;/a&gt;.</source>
          <target state="translated">Este paquete define operaciones para manipular tensores irregulares ( &lt;a href=&quot;../../raggedtensor&quot;&gt; &lt;code&gt;tf.RaggedTensor&lt;/code&gt; &lt;/a&gt; ), que son tensores con formas no uniformes. En particular, cada &lt;code&gt;RaggedTensor&lt;/code&gt; tiene una o m&amp;aacute;s &lt;em&gt;dimensiones irregulares&lt;/em&gt; , que son dimensiones cuyas rebanadas pueden tener diferentes longitudes. Por ejemplo, la dimensi&amp;oacute;n interna (columna) de &lt;code&gt;rt=[[3, 1, 4, 1], [], [5, 9, 2], [6], []]&lt;/code&gt; es desigual, ya que las secciones de columna ( &lt;code&gt;rt[0, :]&lt;/code&gt; , ..., &lt;code&gt;rt[4, :]&lt;/code&gt; ) tienen diferentes longitudes. Para obtener una descripci&amp;oacute;n m&amp;aacute;s detallada de los tensores irregulares, consulte la documentaci&amp;oacute;n de la clase &lt;a href=&quot;../../raggedtensor&quot;&gt; &lt;code&gt;tf.RaggedTensor&lt;/code&gt; &lt;/a&gt; y la &lt;a href=&quot;https://www.tensorflow.org/guide/ragged_tensors&quot;&gt;Gu&amp;iacute;a de tensores irregulares&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3e4f0989d73eb8b679bcdf7fff408eece47a531f" translate="yes" xml:space="preserve">
          <source>This package defines ops for manipulating ragged tensors (&lt;a href=&quot;raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt;), which are tensors with non-uniform shapes. In particular, each &lt;code&gt;RaggedTensor&lt;/code&gt; has one or more &lt;em&gt;ragged dimensions&lt;/em&gt;, which are dimensions whose slices may have different lengths. For example, the inner (column) dimension of &lt;code&gt;rt=[[3, 1, 4, 1], [], [5, 9, 2], [6], []]&lt;/code&gt; is ragged, since the column slices (&lt;code&gt;rt[0, :]&lt;/code&gt;, ..., &lt;code&gt;rt[4, :]&lt;/code&gt;) have different lengths. For a more detailed description of ragged tensors, see the &lt;a href=&quot;raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt; class documentation and the &lt;a href=&quot;https://www.tensorflow.org/guide/ragged_tensors&quot;&gt;Ragged Tensor Guide&lt;/a&gt;.</source>
          <target state="translated">Este paquete define operaciones para manipular tensores irregulares ( &lt;a href=&quot;raggedtensor&quot;&gt; &lt;code&gt;tf.RaggedTensor&lt;/code&gt; &lt;/a&gt; ), que son tensores con formas no uniformes. En particular, cada &lt;code&gt;RaggedTensor&lt;/code&gt; tiene una o m&amp;aacute;s &lt;em&gt;dimensiones irregulares&lt;/em&gt; , que son dimensiones cuyas rebanadas pueden tener diferentes longitudes. Por ejemplo, la dimensi&amp;oacute;n interna (columna) de &lt;code&gt;rt=[[3, 1, 4, 1], [], [5, 9, 2], [6], []]&lt;/code&gt; es desigual, ya que las secciones de columna ( &lt;code&gt;rt[0, :]&lt;/code&gt; , ..., &lt;code&gt;rt[4, :]&lt;/code&gt; ) tienen diferentes longitudes. Para obtener una descripci&amp;oacute;n m&amp;aacute;s detallada de los tensores irregulares, consulte la documentaci&amp;oacute;n de la clase &lt;a href=&quot;raggedtensor&quot;&gt; &lt;code&gt;tf.RaggedTensor&lt;/code&gt; &lt;/a&gt; y la &lt;a href=&quot;https://www.tensorflow.org/guide/ragged_tensors&quot;&gt;Gu&amp;iacute;a de tensores irregulares&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ca381bc7587c1d86ccea71cf77a3f51f18c01785" translate="yes" xml:space="preserve">
          <source>This partitioner will shard a Variable along one axis, attempting to keep the maximum shard size below &lt;code&gt;max_shard_bytes&lt;/code&gt;. In practice, this is not always possible when sharding along only one axis. When this happens, this axis is sharded as much as possible (i.e., every dimension becomes a separate shard).</source>
          <target state="translated">Este particionador fragmentar&amp;aacute; una Variable a lo largo de un eje, intentando mantener el tama&amp;ntilde;o m&amp;aacute;ximo de fragmento por debajo de &lt;code&gt;max_shard_bytes&lt;/code&gt; . En la pr&amp;aacute;ctica, esto no siempre es posible cuando se fragmenta a lo largo de un solo eje. Cuando esto sucede, este eje se fragmenta tanto como sea posible (es decir, cada dimensi&amp;oacute;n se convierte en un fragmento separado).</target>
        </trans-unit>
        <trans-unit id="fd457ac6c886ad4d6a9b1c2c9ed70e07ea8ad467" translate="yes" xml:space="preserve">
          <source>This produces files called &quot;timeline-</source>
          <target state="translated">Esto produce archivos llamados &quot;línea de tiempo&quot;...</target>
        </trans-unit>
        <trans-unit id="9f7b45ed5e5688563844dafc256f1f022fd16e33" translate="yes" xml:space="preserve">
          <source>This property only works when the &lt;code&gt;TPUEmbedding&lt;/code&gt; object is created under a non-TPU strategy. This is intended to be used to for CPU based lookup when creating a serving checkpoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="650852868a3688b5e43945d526af2b7a7abb7659" translate="yes" xml:space="preserve">
          <source>This regressor ignores feature values and will learn to predict the average value of each label.</source>
          <target state="translated">Este regresor ignora los valores de las características y aprenderá a predecir el valor promedio de cada etiqueta.</target>
        </trans-unit>
        <trans-unit id="6b4e11e2fc93d180cb8cb79e60f96113138df290" translate="yes" xml:space="preserve">
          <source>This returns a ClusterSpec object for use based on information from the specified initialization parameters and Slurm environment variables. The cluster specification is resolved each time this function is called. The resolver extract hostnames of nodes by scontrol and pack tasks in that order until a node a has number of tasks that is equal to specification. GPUs on nodes are allocated to tasks by specification through setting CUDA_VISIBLE_DEVICES environment variable.</source>
          <target state="translated">Esto devuelve un objeto ClusterSpec para su uso basado en la información de los parámetros de inicialización especificados y las variables de entorno Slurm.La especificación del cluster se resuelve cada vez que se llama a esta función.El resolvedor extrae los nombres de host de los nodos por scontrol y empaqueta las tareas en ese orden hasta que un nodo a tiene un número de tareas que es igual a la especificación.Las GPUs de los nodos se asignan a las tareas por especificación a través de la variable de entorno CUDA_VISIBLE_DEVICES.</target>
        </trans-unit>
        <trans-unit id="ce42bdd47f55adee51dc4ae146a85efc32785746" translate="yes" xml:space="preserve">
          <source>This returns a ClusterSpec object for use based on information from the specified instance group. We will retrieve the information from the GCE APIs every time this method is called.</source>
          <target state="translated">Esto devuelve un objeto ClusterSpec para su uso basado en la información del grupo de instancia especificado.Recuperaremos la información de las API de la CME cada vez que se llame a este método.</target>
        </trans-unit>
        <trans-unit id="d4e36425f3d932370ce3f31b5b37e6bd2c5dbb8b" translate="yes" xml:space="preserve">
          <source>This returns a function outputting &lt;code&gt;features&lt;/code&gt; and &lt;code&gt;targets&lt;/code&gt; based on the dict of numpy arrays. The dict &lt;code&gt;features&lt;/code&gt; has the same keys as the &lt;code&gt;x&lt;/code&gt;. The dict &lt;code&gt;targets&lt;/code&gt; has the same keys as the &lt;code&gt;y&lt;/code&gt; if &lt;code&gt;y&lt;/code&gt; is a dict.</source>
          <target state="translated">Esto devuelve una funci&amp;oacute;n que genera &lt;code&gt;features&lt;/code&gt; y &lt;code&gt;targets&lt;/code&gt; basados ​​en el dictado de matrices numpy. Las &lt;code&gt;features&lt;/code&gt; dict tienen las mismas claves que la &lt;code&gt;x&lt;/code&gt; . Los &lt;code&gt;targets&lt;/code&gt; dict tienen las mismas claves que &lt;code&gt;y&lt;/code&gt; si &lt;code&gt;y&lt;/code&gt; es un dict.</target>
        </trans-unit>
        <trans-unit id="091f487524e5d0cdc7f2f7122f0e27fecc0512d2" translate="yes" xml:space="preserve">
          <source>This returns the job name and task index for the process which calls this function according to its rank and cluster specification. The job name and task index are set after a cluster is constructed by cluster_spec otherwise defaults to None.</source>
          <target state="translated">Esto devuelve el nombre del trabajo y el índice de la tarea para el proceso que llama a esta función de acuerdo con su rango y especificación del grupo.El nombre de la tarea y el índice de la tarea se establecen después de que se construye un cluster mediante cluster_spec,de lo contrario,el valor predeterminado es Ninguno.</target>
        </trans-unit>
        <trans-unit id="9e86e167f9dfaedec2287e6304deddcf9a677504" translate="yes" xml:space="preserve">
          <source>This returns the number of accelerator cores (such as GPUs and TPUs) available per worker.</source>
          <target state="translated">Esto devuelve el número de núcleos de acelerador (como GPU y TPU)disponibles por trabajador.</target>
        </trans-unit>
        <trans-unit id="43f97f599a6e5c9f5b6d870e441e77232b9c4ee2" translate="yes" xml:space="preserve">
          <source>This sampler is useful when the target classes approximately follow such a distribution - for example, if the classes represent words in a lexicon sorted in decreasing order of frequency. If your classes are not ordered by decreasing frequency, do not use this op.</source>
          <target state="translated">Este muestreador es útil cuando las clases objetivo siguen aproximadamente esa distribución,por ejemplo,si las clases representan palabras en un léxico clasificado en orden decreciente de frecuencia.Si las clases no están ordenadas por frecuencia decreciente,no utilice este op.</target>
        </trans-unit>
        <trans-unit id="f4116f5a13b723775fce909b3d142c6ace24a3f4" translate="yes" xml:space="preserve">
          <source>This set may grow over time, so it's important the signature of creators is as mentioned above.</source>
          <target state="translated">Este conjunto puede crecer con el tiempo,por lo que es importante que la firma de los creadores sea la mencionada anteriormente.</target>
        </trans-unit>
        <trans-unit id="642d4b5b813040e42f63e66f6c2fcb5de77a52c5" translate="yes" xml:space="preserve">
          <source>This should only be used when the if then/else body functions do not have stateful ops.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fc235c555c96c210745b72880b680aa6b17dbdb" translate="yes" xml:space="preserve">
          <source>This should only be used when the while condition and body functions do not have stateful ops.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fe6f784df295b3702cbf845894c09377130127e" translate="yes" xml:space="preserve">
          <source>This simply wraps &lt;code&gt;compute_gradients()&lt;/code&gt; from the real optimizer. The gradients will be aggregated in &lt;code&gt;apply_gradients()&lt;/code&gt; so that user can modify the gradients like clipping with per replica global norm if needed. The global norm with aggregated gradients can be bad as one replica's huge gradients can hurt the gradients from other replicas.</source>
          <target state="translated">Esto simplemente envuelve &lt;code&gt;compute_gradients()&lt;/code&gt; del optimizador real. Los degradados se &lt;code&gt;apply_gradients()&lt;/code&gt; en apply_gradients () para que el usuario pueda modificar los degradados como recortar con la norma global por r&amp;eacute;plica si es necesario. La norma global con degradados agregados puede ser mala, ya que los enormes degradados de una r&amp;eacute;plica pueden da&amp;ntilde;ar los degradados de otras r&amp;eacute;plicas.</target>
        </trans-unit>
        <trans-unit id="8231e710a02b190ee62057d8ce9e6843f584733f" translate="yes" xml:space="preserve">
          <source>This simply wraps the compute_gradients() from the real optimizer. The gradients will be aggregated in the apply_gradients() so that user can modify the gradients like clipping with per replica global norm if needed. The global norm with aggregated gradients can be bad as one replica's huge gradients can hurt the gradients from other replicas.</source>
          <target state="translated">Esto simplemente envuelve los gradientes de cálculo del optimizador real.Los gradientes serán agregados en el apply_gradients()para que el usuario pueda modificar los gradientes como recorte con la norma global por réplica si es necesario.La norma global con gradientes agregados puede ser mala ya que los enormes gradientes de una réplica pueden dañar los gradientes de otras réplicas.</target>
        </trans-unit>
        <trans-unit id="9535c2c156931877173be6ce0ef4fcc7c39ade4d" translate="yes" xml:space="preserve">
          <source>This simply wraps the get_slot() from the actual optimizer.</source>
          <target state="translated">Esto simplemente envuelve el get_slot()del optimizador real.</target>
        </trans-unit>
        <trans-unit id="627b6a914c45360f47c7270bf7239e5630834ac1" translate="yes" xml:space="preserve">
          <source>This simply wraps the get_slot_names() from the actual optimizer.</source>
          <target state="translated">Esto simplemente envuelve el get_slot_names()del optimizador actual.</target>
        </trans-unit>
        <trans-unit id="481aba790f7180557002a29e34e41b2834d82d24" translate="yes" xml:space="preserve">
          <source>This starts services in the background. The services started depend on the parameters to the constructor and may include:</source>
          <target state="translated">Esto inicia los servicios en el fondo.Los servicios iniciados dependen de los parámetros al constructor y pueden incluir:</target>
        </trans-unit>
        <trans-unit id="61ba97b856d34fcc84e3cd4a4201db78d7018540" translate="yes" xml:space="preserve">
          <source>This strategy implements synchronous distributed training across multiple workers, each with potentially multiple GPUs. Similar to &lt;a href=&quot;../../../../distribute/mirroredstrategy&quot;&gt;&lt;code&gt;tf.distribute.MirroredStrategy&lt;/code&gt;&lt;/a&gt;, it creates copies of all variables in the model on each device across all workers.</source>
          <target state="translated">Esta estrategia implementa entrenamiento distribuido sincr&amp;oacute;nico entre m&amp;uacute;ltiples trabajadores, cada uno con potencialmente m&amp;uacute;ltiples GPU. Similar a &lt;a href=&quot;../../../../distribute/mirroredstrategy&quot;&gt; &lt;code&gt;tf.distribute.MirroredStrategy&lt;/code&gt; &lt;/a&gt; , crea copias de todas las variables en el modelo en cada dispositivo en todos los trabajadores.</target>
        </trans-unit>
        <trans-unit id="f19046d3b0cb6c64ecb2b4f8764cc9d33c4854f1" translate="yes" xml:space="preserve">
          <source>This strategy implements synchronous distributed training across multiple workers, each with potentially multiple GPUs. Similar to &lt;a href=&quot;../mirroredstrategy&quot;&gt;&lt;code&gt;tf.distribute.MirroredStrategy&lt;/code&gt;&lt;/a&gt;, it creates copies of all variables in the model on each device across all workers.</source>
          <target state="translated">Esta estrategia implementa entrenamiento distribuido sincr&amp;oacute;nico entre m&amp;uacute;ltiples trabajadores, cada uno con potencialmente m&amp;uacute;ltiples GPU. Similar a &lt;a href=&quot;../mirroredstrategy&quot;&gt; &lt;code&gt;tf.distribute.MirroredStrategy&lt;/code&gt; &lt;/a&gt; , crea copias de todas las variables en el modelo en cada dispositivo en todos los trabajadores.</target>
        </trans-unit>
        <trans-unit id="04f8a8d0444c29ec6e24f3fc468a55853c986597" translate="yes" xml:space="preserve">
          <source>This strategy is typically used for training on one machine with multiple GPUs. For TPUs, use &lt;a href=&quot;../../../distribute/tpustrategy&quot;&gt;&lt;code&gt;tf.distribute.TPUStrategy&lt;/code&gt;&lt;/a&gt;. To use &lt;code&gt;MirroredStrategy&lt;/code&gt; with multiple workers, please refer to &lt;a href=&quot;../../../distribute/experimental/multiworkermirroredstrategy&quot;&gt;&lt;code&gt;tf.distribute.experimental.MultiWorkerMirroredStrategy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c008960642435f7f796dcc4d6d07c58ad8a9370" translate="yes" xml:space="preserve">
          <source>This strategy is typically used for training on one machine with multiple GPUs. For TPUs, use &lt;a href=&quot;tpustrategy&quot;&gt;&lt;code&gt;tf.distribute.TPUStrategy&lt;/code&gt;&lt;/a&gt;. To use &lt;code&gt;MirroredStrategy&lt;/code&gt; with multiple workers, please refer to &lt;a href=&quot;experimental/multiworkermirroredstrategy&quot;&gt;&lt;code&gt;tf.distribute.experimental.MultiWorkerMirroredStrategy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="648f5d6b8ceebd17f689c7c0ab8ef16660a7747c" translate="yes" xml:space="preserve">
          <source>This strategy requires two jobs: workers and parameter servers. Variables and updates to those variables will be assigned to parameter servers and other operations are assigned to workers.</source>
          <target state="translated">Esta estrategia requiere dos trabajos:trabajadores y servidores de parámetros.Las variables y las actualizaciones de esas variables se asignarán a los servidores de parámetros y las demás operaciones se asignarán a los trabajadores.</target>
        </trans-unit>
        <trans-unit id="e44a68c24a5012e2f287321dc3d6da6b35bca174" translate="yes" xml:space="preserve">
          <source>This strategy requires two roles: workers and parameter servers. Variables and updates to those variables will be assigned to parameter servers and other operations are assigned to workers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="609b539c1ba8e5fb73c25fa137b65336a8f05b90" translate="yes" xml:space="preserve">
          <source>This strategy uses one replica per device and sync replication for its multi-GPU version.</source>
          <target state="translated">Esta estrategia utiliza una réplica por dispositivo y una réplica de sincronización para su versión multi-GPU.</target>
        </trans-unit>
        <trans-unit id="a028b1379398bc12b06afc7b36060473f028c25d" translate="yes" xml:space="preserve">
          <source>This symbol is also exported to v2 in tf.estimator namespace. See &lt;a href=&quot;https://github.com/tensorflow/estimator/blob/master/tensorflow_estimator/python/estimator/hooks/basic_session_run_hooks.py&quot;&gt;https://github.com/tensorflow/estimator/blob/master/tensorflow_estimator/python/estimator/hooks/basic_session_run_hooks.py&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f77a1c7f27ca177eb5967fdc02f021a08479ef96" translate="yes" xml:space="preserve">
          <source>This symbol is also exported to v2 in tf.estimator namespace. See https://github.com/tensorflow/estimator/blob/master/tensorflow_estimator/python/estimator/hooks/basic_session_run_hooks.py</source>
          <target state="translated">Este símbolo también se exporta a v2 en el espacio de nombres tf.estimator.Véase https://github.com/tensorflow/estimator/blob/master/tensorflow_estimator/python/estimator/hooks/basic_session_run_hooks.py</target>
        </trans-unit>
        <trans-unit id="ee30a785484036470f77ee9c09ff132832518ed4" translate="yes" xml:space="preserve">
          <source>This takes an ordinary &lt;code&gt;dataset&lt;/code&gt; and &lt;code&gt;replica_fn&lt;/code&gt; and runs it distributed using a particular &lt;a href=&quot;strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; named &lt;code&gt;my_strategy&lt;/code&gt; above. Any variables created in &lt;code&gt;replica_fn&lt;/code&gt; are created using &lt;code&gt;my_strategy&lt;/code&gt;'s policy, and library functions called by &lt;code&gt;replica_fn&lt;/code&gt; can use the &lt;code&gt;get_replica_context()&lt;/code&gt; API to implement distributed-specific behavior.</source>
          <target state="translated">Esto toma un &lt;code&gt;dataset&lt;/code&gt; ordinario y &lt;code&gt;replica_fn&lt;/code&gt; y lo ejecuta distribuido usando un &lt;a href=&quot;strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt; particular llamado &lt;code&gt;my_strategy&lt;/code&gt; arriba. Cualquier variable creada en &lt;code&gt;replica_fn&lt;/code&gt; se crea usando la pol&amp;iacute;tica de &lt;code&gt;my_strategy&lt;/code&gt; , y las funciones de biblioteca llamadas por &lt;code&gt;replica_fn&lt;/code&gt; pueden usar la API &lt;code&gt;get_replica_context()&lt;/code&gt; para implementar un comportamiento espec&amp;iacute;fico distribuido.</target>
        </trans-unit>
        <trans-unit id="f43e50d6d041bdda53ec0ccc184fa3940b822601" translate="yes" xml:space="preserve">
          <source>This takes in a few parameters and creates a GCEClusterResolver project. It will then use these parameters to query the GCE API for the IP addresses of each instance in the instance group.</source>
          <target state="translated">Esto toma unos pocos parámetros y crea un proyecto GCEClusterResolver.Luego usará estos parámetros para consultar la API del GCE para las direcciones IP de cada instancia en el grupo de instancias.</target>
        </trans-unit>
        <trans-unit id="dcbb15c135f93b202dd4afc6d928c452a899b686" translate="yes" xml:space="preserve">
          <source>This takes in parameters and creates a SlurmClusterResolver object. It uses those parameters to check which nodes will processes reside on and resolves their hostnames. With the number of the GPUs on each node and number of GPUs for each task it offsets the port number for each process and allocates GPUs to tasks by setting environment variables. The resolver currently supports homogeneous tasks and default Slurm process allocation.</source>
          <target state="translated">Esto toma los parámetros y crea un objeto SlurmClusterResolver.Utiliza esos parámetros para comprobar en qué nodos residirán los procesos y resuelve sus nombres de host.Con el número de las GPU de cada nodo y el número de GPU de cada tarea,compensa el número de puerto de cada proceso y asigna GPU a las tareas estableciendo variables de entorno.El resolvedor actualmente soporta tareas homogéneas y asignación de procesos Slurm por defecto.</target>
        </trans-unit>
        <trans-unit id="c32e52f6772f69af41778414a120795e360f2147" translate="yes" xml:space="preserve">
          <source>This thread class is intended to be used with a &lt;code&gt;Coordinator&lt;/code&gt;. It repeatedly runs code specified either as &lt;code&gt;target&lt;/code&gt; and &lt;code&gt;args&lt;/code&gt; or by the &lt;code&gt;run_loop()&lt;/code&gt; method.</source>
          <target state="translated">Esta clase de hilo est&amp;aacute; pensada para ser utilizada con un &lt;code&gt;Coordinator&lt;/code&gt; . Ejecuta repetidamente c&amp;oacute;digo especificado como &lt;code&gt;target&lt;/code&gt; y &lt;code&gt;args&lt;/code&gt; o por el m&amp;eacute;todo &lt;code&gt;run_loop()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbe44aae232eb7beccd1bb717d150f53dfed09d2" translate="yes" xml:space="preserve">
          <source>This tracking then allows saving variable values to &lt;a href=&quot;https://www.tensorflow.org/guide/checkpoint&quot;&gt;training checkpoints&lt;/a&gt;, or to &lt;a href=&quot;https://www.tensorflow.org/guide/saved_model&quot;&gt;SavedModels&lt;/a&gt; which include serialized TensorFlow graphs.</source>
          <target state="translated">Luego, este seguimiento permite guardar los valores de las variables en &lt;a href=&quot;https://www.tensorflow.org/guide/checkpoint&quot;&gt;los puntos de control de entrenamiento&lt;/a&gt; o en los &lt;a href=&quot;https://www.tensorflow.org/guide/saved_model&quot;&gt;modelos guardados,&lt;/a&gt; que incluyen gr&amp;aacute;ficos de TensorFlow serializados.</target>
        </trans-unit>
        <trans-unit id="84d3d178d35882538e5cb6113338132ed1567a47" translate="yes" xml:space="preserve">
          <source>This transformation applies &lt;code&gt;map_func&lt;/code&gt; to each element of this dataset, and returns a new dataset containing the transformed elements, in the same order as they appeared in the input. &lt;code&gt;map_func&lt;/code&gt; can be used to change both the values and the structure of a dataset's elements. For example, adding 1 to each element, or projecting a subset of element components.</source>
          <target state="translated">Esta transformaci&amp;oacute;n aplica &lt;code&gt;map_func&lt;/code&gt; a cada elemento de este conjunto de datos y devuelve un nuevo conjunto de datos que contiene los elementos transformados, en el mismo orden en que aparecieron en la entrada. &lt;code&gt;map_func&lt;/code&gt; se puede utilizar para cambiar tanto los valores como la estructura de los elementos de un conjunto de datos. Por ejemplo, agregar 1 a cada elemento o proyectar un subconjunto de componentes del elemento.</target>
        </trans-unit>
        <trans-unit id="ba79b19e287af6ccbf373678af86969066d66587" translate="yes" xml:space="preserve">
          <source>This transformation checks whether the camel-case names (i.e. &quot;FlatMap&quot;, not &quot;flat_map&quot;) of the transformations following this transformation match the list of names in the &lt;code&gt;transformations&lt;/code&gt; argument. If there is a mismatch, the transformation raises an exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b91ea223c9ec8adff0faaecc5c9b88a252c4af69" translate="yes" xml:space="preserve">
          <source>This transformation combines multiple consecutive elements of the input dataset into a single element.</source>
          <target state="translated">Esta transformación combina múltiples elementos consecutivos del conjunto de datos de entrada en un solo elemento.</target>
        </trans-unit>
        <trans-unit id="35f6c3c6efa792b9215faf94c8c00f35d19886a0" translate="yes" xml:space="preserve">
          <source>This transformation is a stateful relative of &lt;a href=&quot;../dataset#map&quot;&gt;&lt;code&gt;tf.data.Dataset.map&lt;/code&gt;&lt;/a&gt;. In addition to mapping &lt;code&gt;scan_func&lt;/code&gt; across the elements of the input dataset, &lt;code&gt;scan()&lt;/code&gt; accumulates one or more state tensors, whose initial values are &lt;code&gt;initial_state&lt;/code&gt;.</source>
          <target state="translated">Esta transformaci&amp;oacute;n es un pariente con estado de &lt;a href=&quot;../dataset#map&quot;&gt; &lt;code&gt;tf.data.Dataset.map&lt;/code&gt; &lt;/a&gt; . Adem&amp;aacute;s de mapear &lt;code&gt;scan_func&lt;/code&gt; entre los elementos del conjunto de datos de entrada, &lt;code&gt;scan()&lt;/code&gt; acumula uno o m&amp;aacute;s tensores de estado, cuyos valores iniciales son &lt;code&gt;initial_state&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e7258027c5f693626ed2b2e68a04576c8a8c285" translate="yes" xml:space="preserve">
          <source>This transformation maps each consecutive element in a dataset to a key using &lt;code&gt;key_func&lt;/code&gt; and groups the elements by key. It then applies &lt;code&gt;reduce_func&lt;/code&gt; to at most &lt;code&gt;window_size_func(key)&lt;/code&gt; elements matching the same key. All except the final window for each key will contain &lt;code&gt;window_size_func(key)&lt;/code&gt; elements; the final window may be smaller.</source>
          <target state="translated">Esta transformaci&amp;oacute;n mapea cada elemento consecutivo en un conjunto de datos a una clave usando &lt;code&gt;key_func&lt;/code&gt; y agrupa los elementos por clave. Luego aplica &lt;code&gt;reduce_func&lt;/code&gt; a la mayor&amp;iacute;a de los elementos &lt;code&gt;window_size_func(key)&lt;/code&gt; que coinciden con la misma clave. Todos excepto la ventana final para cada clave contendr&amp;aacute;n elementos &lt;code&gt;window_size_func(key)&lt;/code&gt; ; la ventana final puede ser m&amp;aacute;s peque&amp;ntilde;a.</target>
        </trans-unit>
        <trans-unit id="a21aaa6c0a7b4d11f0bde650d661805100a01ad7" translate="yes" xml:space="preserve">
          <source>This transformation maps element of a dataset to a key using &lt;code&gt;key_func&lt;/code&gt; and groups the elements by key. The &lt;code&gt;reducer&lt;/code&gt; is used to process each group; its &lt;code&gt;init_func&lt;/code&gt; is used to initialize state for each group when it is created, the &lt;code&gt;reduce_func&lt;/code&gt; is used to update the state every time an element is mapped to the matching group, and the &lt;code&gt;finalize_func&lt;/code&gt; is used to map the final state to an output value.</source>
          <target state="translated">Esta transformaci&amp;oacute;n asigna un elemento de un conjunto de datos a una clave usando &lt;code&gt;key_func&lt;/code&gt; y agrupa los elementos por clave. El &lt;code&gt;reducer&lt;/code&gt; se utiliza para procesar cada grupo; su &lt;code&gt;init_func&lt;/code&gt; se usa para inicializar el estado de cada grupo cuando se crea, &lt;code&gt;reduce_func&lt;/code&gt; se usa para actualizar el estado cada vez que un elemento se asigna al grupo coincidente, y &lt;code&gt;finalize_func&lt;/code&gt; se usa para asignar el estado final a un valor de salida.</target>
        </trans-unit>
        <trans-unit id="24ab6194aaa04fc157672b906f20ba2e1b1ec8cc" translate="yes" xml:space="preserve">
          <source>This updates the checkpoint file containing a CheckpointState proto.</source>
          <target state="translated">Esto actualiza el archivo del puesto de control que contiene un prototipo de CheckpointState.</target>
        </trans-unit>
        <trans-unit id="5bb7cb617dbb67bdd4c7f55f6d436fa2f1b33e3c" translate="yes" xml:space="preserve">
          <source>This uses &lt;a href=&quot;../norm&quot;&gt;&lt;code&gt;tf.linalg.norm&lt;/code&gt;&lt;/a&gt; to compute the norm along &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">Esto usa &lt;a href=&quot;../norm&quot;&gt; &lt;code&gt;tf.linalg.norm&lt;/code&gt; &lt;/a&gt; para calcular la norma a lo largo del &lt;code&gt;axis&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7945ebd1b4ae121cdd796a53759129e7e59a0846" translate="yes" xml:space="preserve">
          <source>This usually returns the master from the first ClusterResolver passed in, but you can override this by specifying the task_type and task_id.</source>
          <target state="translated">Por lo general,esto devuelve el maestro del primer ClusterResolver pasado,pero se puede anular especificando el tipo_de_tarea y el identificador_de_tarea.</target>
        </trans-unit>
        <trans-unit id="4285af5e3616d9c051e0b5382ab0649693cc39b6" translate="yes" xml:space="preserve">
          <source>This utility function provides consistent behavior for both local (non-distributed) and distributed configurations. The default distribution configuration is parameter server-based between-graph replication. For other types of distribution configurations such as all-reduce training, please use &lt;a href=&quot;https://github.com/tensorflow/tensorflow/tree/master/tensorflow/contrib/distribute&quot;&gt;DistributionStrategies&lt;/a&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n de utilidad proporciona un comportamiento coherente tanto para configuraciones locales (no distribuidas) como distribuidas. La configuraci&amp;oacute;n de distribuci&amp;oacute;n predeterminada es la replicaci&amp;oacute;n entre gr&amp;aacute;ficos basada en el servidor de par&amp;aacute;metros. Para otros tipos de configuraciones de distribuci&amp;oacute;n, como el entrenamiento de reducci&amp;oacute;n total, utilice &lt;a href=&quot;https://github.com/tensorflow/tensorflow/tree/master/tensorflow/contrib/distribute&quot;&gt;DistributionStrategies&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="50e5c41b60a6dacb228de3d2a27ac083ca26570e" translate="yes" xml:space="preserve">
          <source>This utility function trains, evaluates, and (optionally) exports the model by using the given &lt;code&gt;estimator&lt;/code&gt;. All training related specification is held in &lt;code&gt;train_spec&lt;/code&gt;, including training &lt;code&gt;input_fn&lt;/code&gt; and training max steps, etc. All evaluation and export related specification is held in &lt;code&gt;eval_spec&lt;/code&gt;, including evaluation &lt;code&gt;input_fn&lt;/code&gt;, steps, etc.</source>
          <target state="translated">Esta funci&amp;oacute;n de utilidad entrena, eval&amp;uacute;a y (opcionalmente) exporta el modelo usando el &lt;code&gt;estimator&lt;/code&gt; dado . Toda la especificaci&amp;oacute;n relacionada con la capacitaci&amp;oacute;n se mantiene en &lt;code&gt;train_spec&lt;/code&gt; , incluida la capacitaci&amp;oacute;n &lt;code&gt;input_fn&lt;/code&gt; y la capacitaci&amp;oacute;n max steps, etc. Todas las especificaciones relacionadas con la evaluaci&amp;oacute;n y la exportaci&amp;oacute;n se mantienen en &lt;code&gt;eval_spec&lt;/code&gt; , incluida la evaluaci&amp;oacute;n &lt;code&gt;input_fn&lt;/code&gt; , steps, etc.</target>
        </trans-unit>
        <trans-unit id="370bf5deaf68ca405b51cda0b005ed741251919f" translate="yes" xml:space="preserve">
          <source>This utility method replaces the deprecated-in-V2 &lt;code&gt;tf.compat.v1.Dataset.output_classes&lt;/code&gt; property.</source>
          <target state="translated">Este m&amp;eacute;todo de utilidad reemplaza la propiedad &lt;code&gt;tf.compat.v1.Dataset.output_classes&lt;/code&gt; obsoleta-en-V2 .</target>
        </trans-unit>
        <trans-unit id="46213afe2d7d2a75cd43b97252d79901207a3be4" translate="yes" xml:space="preserve">
          <source>This utility method replaces the deprecated-in-V2 &lt;code&gt;tf.compat.v1.Dataset.output_shapes&lt;/code&gt; property.</source>
          <target state="translated">Este m&amp;eacute;todo de utilidad reemplaza la propiedad &lt;code&gt;tf.compat.v1.Dataset.output_shapes&lt;/code&gt; obsoleta en V2 .</target>
        </trans-unit>
        <trans-unit id="917e4af53cd9619ae0480dec3aee8643df47493a" translate="yes" xml:space="preserve">
          <source>This utility method replaces the deprecated-in-V2 &lt;code&gt;tf.compat.v1.Dataset.output_types&lt;/code&gt; property.</source>
          <target state="translated">Este m&amp;eacute;todo de utilidad reemplaza la propiedad &lt;code&gt;tf.compat.v1.Dataset.output_types&lt;/code&gt; obsoleta en V2 .</target>
        </trans-unit>
        <trans-unit id="e1997fea43a5c765a33c5bb8c3d18f8bd998811c" translate="yes" xml:space="preserve">
          <source>This value is ultimately returned as &lt;code&gt;auc&lt;/code&gt;, an idempotent operation that computes the area under a discretized curve of precision versus recall values (computed using the aforementioned variables). The &lt;code&gt;num_thresholds&lt;/code&gt; variable controls the degree of discretization with larger numbers of thresholds more closely approximating the true AUC. The quality of the approximation may vary dramatically depending on &lt;code&gt;num_thresholds&lt;/code&gt;.</source>
          <target state="translated">Este valor se devuelve finalmente como &lt;code&gt;auc&lt;/code&gt; , una operaci&amp;oacute;n idempotente que calcula el &amp;aacute;rea bajo una curva discretizada de precisi&amp;oacute;n versus valores de recuperaci&amp;oacute;n (calculados utilizando las variables antes mencionadas). La variable &lt;code&gt;num_thresholds&lt;/code&gt; controla el grado de discretizaci&amp;oacute;n con un mayor n&amp;uacute;mero de umbrales que se aproximan m&amp;aacute;s al AUC real. La calidad de la aproximaci&amp;oacute;n puede variar dr&amp;aacute;sticamente seg&amp;uacute;n &lt;code&gt;num_thresholds&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65677d697851bf6819d55d4ff4251a12696e0771" translate="yes" xml:space="preserve">
          <source>This value is ultimately returned as &lt;code&gt;auc&lt;/code&gt;, an idempotent operation that computes the area under a discretized curve of precision versus recall values (computed using the aforementioned variables). The &lt;code&gt;num_thresholds&lt;/code&gt; variable controls the degree of discretization with larger numbers of thresholds more closely approximating the true AUC. The quality of the approximation may vary dramatically depending on &lt;code&gt;num_thresholds&lt;/code&gt;. The &lt;code&gt;thresholds&lt;/code&gt; parameter can be used to manually specify thresholds which split the predictions more evenly.</source>
          <target state="translated">Este valor se devuelve finalmente como &lt;code&gt;auc&lt;/code&gt; , una operaci&amp;oacute;n idempotente que calcula el &amp;aacute;rea bajo una curva discretizada de precisi&amp;oacute;n versus valores de recuperaci&amp;oacute;n (calculados utilizando las variables antes mencionadas). La variable &lt;code&gt;num_thresholds&lt;/code&gt; controla el grado de discretizaci&amp;oacute;n con un mayor n&amp;uacute;mero de umbrales que se aproximan m&amp;aacute;s al AUC real. La calidad de la aproximaci&amp;oacute;n puede variar dr&amp;aacute;sticamente seg&amp;uacute;n &lt;code&gt;num_thresholds&lt;/code&gt; . El par&amp;aacute;metro de &lt;code&gt;thresholds&lt;/code&gt; se puede utilizar para especificar manualmente los umbrales que dividen las predicciones de manera m&amp;aacute;s uniforme.</target>
        </trans-unit>
        <trans-unit id="ca17fcf3f560f3e845deeb7ae0f38bd32e476e10" translate="yes" xml:space="preserve">
          <source>This version enqueues a different list of tensors in different threads. It adds the following to the current &lt;code&gt;Graph&lt;/code&gt;:</source>
          <target state="translated">Esta versi&amp;oacute;n pone en cola una lista diferente de tensores en diferentes hilos. Agrega lo siguiente al &lt;code&gt;Graph&lt;/code&gt; actual :</target>
        </trans-unit>
        <trans-unit id="3dd9104e524c4af8048275ef1cca44df52153ae4" translate="yes" xml:space="preserve">
          <source>This version has support for both online L2 (McMahan et al., 2013) and shrinkage-type L2, which is the addition of an L2 penalty to the loss function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56d946ffec0b3da9d0ec8b7171e5c9d7eac7532e" translate="yes" xml:space="preserve">
          <source>This version performs the same function as Dropout, however it drops entire 1D feature maps instead of individual elements. If adjacent frames within feature maps are strongly correlated (as is normally the case in early convolution layers) then regular dropout will not regularize the activations and will otherwise just result in an effective learning rate decrease. In this case, SpatialDropout1D will help promote independence between feature maps and should be used instead.</source>
          <target state="translated">Esta versión realiza la misma función que Dropout,sin embargo deja caer mapas completos de características 1D en lugar de elementos individuales.Si los marcos adyacentes dentro de los mapas de características están fuertemente correlacionados (como suele ocurrir en las capas de convolución temprana),entonces la deserción regular no regularizará las activaciones y,de lo contrario,sólo resultará en una disminución efectiva de la tasa de aprendizaje.En este caso,SpatialDropout1D ayudará a promover la independencia entre los mapas de características y debería utilizarse en su lugar.</target>
        </trans-unit>
        <trans-unit id="a36f7273ef31d9cbeb00b22a3f221c68cd1e40a0" translate="yes" xml:space="preserve">
          <source>This version performs the same function as Dropout, however it drops entire 2D feature maps instead of individual elements. If adjacent pixels within feature maps are strongly correlated (as is normally the case in early convolution layers) then regular dropout will not regularize the activations and will otherwise just result in an effective learning rate decrease. In this case, SpatialDropout2D will help promote independence between feature maps and should be used instead.</source>
          <target state="translated">Esta versión realiza la misma función que Dropout,sin embargo deja caer mapas completos de características 2D en lugar de elementos individuales.Si los píxeles adyacentes dentro de los mapas de características están fuertemente correlacionados (como es normalmente el caso en las capas de convolución temprana)entonces la deserción regular no regularizará las activaciones y de otra manera sólo resultará en una disminución efectiva de la tasa de aprendizaje.En este caso,SpatialDropout2D ayudará a promover la independencia entre los mapas de características y debería utilizarse en su lugar.</target>
        </trans-unit>
        <trans-unit id="d0ef991814863883d725a0aaf896bf4a46fb3d16" translate="yes" xml:space="preserve">
          <source>This version performs the same function as Dropout, however it drops entire 3D feature maps instead of individual elements. If adjacent voxels within feature maps are strongly correlated (as is normally the case in early convolution layers) then regular dropout will not regularize the activations and will otherwise just result in an effective learning rate decrease. In this case, SpatialDropout3D will help promote independence between feature maps and should be used instead.</source>
          <target state="translated">Esta versión realiza la misma función que Dropout,sin embargo deja caer mapas completos de características 3D en lugar de elementos individuales.Si los vóxeles adyacentes dentro de los mapas de características están fuertemente correlacionados (como sucede normalmente en las capas de convolución temprana),entonces la deserción regular no regularizará las activaciones y,de lo contrario,sólo resultará en una disminución efectiva de la tasa de aprendizaje.En este caso,SpatialDropout3D ayudará a promover la independencia entre los mapas de características y debería utilizarse en su lugar.</target>
        </trans-unit>
        <trans-unit id="3b754cc618ce29bdbcce941232103d369933ab97" translate="yes" xml:space="preserve">
          <source>This version performs the same function as Dropout, however, it drops entire 1D feature maps instead of individual elements. If adjacent frames within feature maps are strongly correlated (as is normally the case in early convolution layers) then regular dropout will not regularize the activations and will otherwise just result in an effective learning rate decrease. In this case, SpatialDropout1D will help promote independence between feature maps and should be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="669d1fce226733b310b6c063bbb1478bd8960685" translate="yes" xml:space="preserve">
          <source>This version performs the same function as Dropout, however, it drops entire 2D feature maps instead of individual elements. If adjacent pixels within feature maps are strongly correlated (as is normally the case in early convolution layers) then regular dropout will not regularize the activations and will otherwise just result in an effective learning rate decrease. In this case, SpatialDropout2D will help promote independence between feature maps and should be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef292e83a5c48c6c48f427ef4821dec22b8cd18d" translate="yes" xml:space="preserve">
          <source>This version performs the same function as Dropout, however, it drops entire 3D feature maps instead of individual elements. If adjacent voxels within feature maps are strongly correlated (as is normally the case in early convolution layers) then regular dropout will not regularize the activations and will otherwise just result in an effective learning rate decrease. In this case, SpatialDropout3D will help promote independence between feature maps and should be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28fed8917e83f005a3a2493f518294b2e184da80" translate="yes" xml:space="preserve">
          <source>This was originally generated by parsing and preprocessing the classic Reuters-21578 dataset, but the preprocessing code is no longer packaged with Keras. See this &lt;a href=&quot;https://github.com/keras-team/keras/issues/12072&quot;&gt;github discussion&lt;/a&gt; for more info.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d54f43064a89a76630348aa955f910392f5b82d" translate="yes" xml:space="preserve">
          <source>This will clear all caches, even those that are maintained through sequential calls to tf.tpu.experimental.initialize_tpu_system, such as the compilation cache.</source>
          <target state="translated">Esto eliminará todos los cachés,incluso aquellos que se mantienen a través de llamadas secuenciales al sistema tf.tpu.experimental.initialize_tpu_system,como el caché de compilación.</target>
        </trans-unit>
        <trans-unit id="d806ab1c15562f7cef5ecfb73dfc54f37420bf0f" translate="yes" xml:space="preserve">
          <source>This will match and replace multiple sig defs iff tags is None (i.e when multiple &lt;code&gt;MetaGraph&lt;/code&gt;s have a signature_def with the same key). If tags is not None, this will only replace a single signature_def in the &lt;code&gt;MetaGraph&lt;/code&gt; with matching tags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c497916c950017d377f8b22ce65b7642e7fe656" translate="yes" xml:space="preserve">
          <source>This works for both single worker and multi-worker mode, only MirroredStrategy and MultiWorkerMirroredStrategy are supported for now.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1d5a90de0626fc107829e4415b87374a7e5143d" translate="yes" xml:space="preserve">
          <source>This wrapper allows to apply a layer to every temporal slice of an input.</source>
          <target state="translated">Esta envoltura permite aplicar una capa a cada porción temporal de una entrada.</target>
        </trans-unit>
        <trans-unit id="e4911cf935e00a37c587b392c63c4d1259cd5359" translate="yes" xml:space="preserve">
          <source>This wraps &lt;code&gt;func_&lt;/code&gt; in a Template and partially evaluates it. Templates are functions that create variables the first time they are called and reuse them thereafter. In order for &lt;code&gt;func_&lt;/code&gt; to be compatible with a &lt;code&gt;Template&lt;/code&gt; it must have the following properties:</source>
          <target state="translated">Esto envuelve &lt;code&gt;func_&lt;/code&gt; en una plantilla y la eval&amp;uacute;a parcialmente. Las plantillas son funciones que crean variables la primera vez que se llaman y las reutilizan a partir de entonces. Para que &lt;code&gt;func_&lt;/code&gt; sea ​​compatible con una &lt;code&gt;Template&lt;/code&gt; , debe tener las siguientes propiedades:</target>
        </trans-unit>
        <trans-unit id="9934a34210519520663a7f89fe0d027dd3ebea0c" translate="yes" xml:space="preserve">
          <source>This wraps &lt;code&gt;variables()&lt;/code&gt; from the actual optimizer. It does not include the &lt;code&gt;SyncReplicasOptimizer&lt;/code&gt;'s local step.</source>
          <target state="translated">Esto envuelve las &lt;code&gt;variables()&lt;/code&gt; del optimizador real. No incluye el paso local de &lt;code&gt;SyncReplicasOptimizer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cea56f6fda7d999d314aba39c0fdf92a26a4a3d0" translate="yes" xml:space="preserve">
          <source>Thread Compatibility</source>
          <target state="translated">Compatibilidad de los hilos</target>
        </trans-unit>
        <trans-unit id="c707a1c58a3c28cb78f0eb8786b82d358ba76091" translate="yes" xml:space="preserve">
          <source>Thread code:</source>
          <target state="translated">Código de hilo:</target>
        </trans-unit>
        <trans-unit id="a1bfe9290c9416a7b4254caec7ab391081602a4c" translate="yes" xml:space="preserve">
          <source>Thread identifier of this thread or None if it has not been started.</source>
          <target state="translated">Identificador de este hilo o ninguno si no se ha iniciado.</target>
        </trans-unit>
        <trans-unit id="51781b51dab5c68c5071966ab81a91a116a5c345" translate="yes" xml:space="preserve">
          <source>ThreadPoolDataset</source>
          <target state="translated">ThreadPoolDataset</target>
        </trans-unit>
        <trans-unit id="c1e81f3f498c6f28feb25121d03bcd7897368f6a" translate="yes" xml:space="preserve">
          <source>ThreadPoolHandle</source>
          <target state="translated">ThreadPoolHandle</target>
        </trans-unit>
        <trans-unit id="b296a2588708c5eab00cc272e74d54b936f28305" translate="yes" xml:space="preserve">
          <source>ThreadUnsafeUnigramCandidateSampler</source>
          <target state="translated">ThreadUnsafeUnigramCandidateSampler</target>
        </trans-unit>
        <trans-unit id="673246c2e28b595a5660cad8b7dc6e0bcb64f903" translate="yes" xml:space="preserve">
          <source>Threshold below which the singular value is counted as 'zero'. Default value: &lt;code&gt;None&lt;/code&gt; (i.e., &lt;code&gt;eps * max(rows, cols) * max(singular_val)&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf8ab928262e89058d10a418722762edfa599e46" translate="yes" xml:space="preserve">
          <source>Thresholded Rectified Linear Unit.</source>
          <target state="translated">Unidad lineal rectificada de umbral.</target>
        </trans-unit>
        <trans-unit id="9c1b3e348c5e658c9f04296e21ad3e2315006119" translate="yes" xml:space="preserve">
          <source>Throws:</source>
          <target state="translated">Throws:</target>
        </trans-unit>
        <trans-unit id="19453fe8b327db6c16c490630fc6fcb997c1883b" translate="yes" xml:space="preserve">
          <source>Thus the saved model can be reinstantiated in the exact same state, without any of the code used for model definition or training.</source>
          <target state="translated">Así,el modelo guardado puede ser reinstalado en el mismo estado exacto,sin ninguno de los códigos utilizados para la definición o el entrenamiento del modelo.</target>
        </trans-unit>
        <trans-unit id="2dd2c660983753cf7cd7ed0bfc6dd2c1219c9bc2" translate="yes" xml:space="preserve">
          <source>Tile</source>
          <target state="translated">Tile</target>
        </trans-unit>
        <trans-unit id="04d349170a16840309d778c9a6bc280d1695cf69" translate="yes" xml:space="preserve">
          <source>TileGrad</source>
          <target state="translated">TileGrad</target>
        </trans-unit>
        <trans-unit id="ec15d67c587aeda01fdee12aac8f67ec1f6fc946" translate="yes" xml:space="preserve">
          <source>Time (in seconds) to wait for process cleanup to propagate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5071117f474d7a0d851f7b8b532519d4fe0b2f5" translate="yes" xml:space="preserve">
          <source>Time boundaries at which to call Run(), or None if it should be called back to back.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea13a52ff3b11f3a3cff17d94eddba0db805c4f1" translate="yes" xml:space="preserve">
          <source>Time series forecasting</source>
          <target state="translated">Previsión de series temporales</target>
        </trans-unit>
        <trans-unit id="3e5a5aa6d16549aefb0642b61016bd76ed1a572d" translate="yes" xml:space="preserve">
          <source>Time step at which the gradient was computed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d96b16498245359e1fc62fcf077cd9c20e575ff4" translate="yes" xml:space="preserve">
          <source>Timer that triggers at most once every N seconds or once every N steps.</source>
          <target state="translated">Temporizador que se activa como mucho una vez cada N segundos o una vez cada N pasos.</target>
        </trans-unit>
        <trans-unit id="19eabc961735d78f12fc7be906ffcb033853cf85" translate="yes" xml:space="preserve">
          <source>Timestamp</source>
          <target state="translated">Timestamp</target>
        </trans-unit>
        <trans-unit id="b0bee40a202555900d8a3e86b930a56b855407cd" translate="yes" xml:space="preserve">
          <source>To &lt;code&gt;run&lt;/code&gt; without hooks.</source>
          <target state="translated">Para &lt;code&gt;run&lt;/code&gt; sin ganchos.</target>
        </trans-unit>
        <trans-unit id="40336213cb93ad585f6a3a6e3ff018601cc59a2a" translate="yes" xml:space="preserve">
          <source>To achieve a performance improvement, you can also wrap the &lt;code&gt;strategy.run&lt;/code&gt; call with a &lt;a href=&quot;../range&quot;&gt;&lt;code&gt;tf.range&lt;/code&gt;&lt;/a&gt; inside a &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;. This runs multiple steps in a &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;. Autograph will convert it to a &lt;a href=&quot;../while_loop&quot;&gt;&lt;code&gt;tf.while_loop&lt;/code&gt;&lt;/a&gt; on the worker. However, it is less flexible comparing with running a single step inside &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;. For example, you cannot run things eagerly or arbitrary python code within the steps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f375d91c07ec3d845eaa0b13fb5e2121d93801bc" translate="yes" xml:space="preserve">
          <source>To add an inner vector length axis to a tensor of scalars.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd6eda6c08067795995f955381394f94ccb8826e" translate="yes" xml:space="preserve">
          <source>To aggregate gradients yourself, call &lt;code&gt;apply_gradients&lt;/code&gt; with &lt;code&gt;experimental_aggregate_gradients&lt;/code&gt; set to False. This is useful if you need to process aggregated gradients.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010eecd6ae7f583a0121a3a0180c941339655bd9" translate="yes" xml:space="preserve">
          <source>To apply a functional operation to the nonzero elements of a SparseTensor one of the following methods is recommended. First, if the function is expressible as TensorFlow ops, use</source>
          <target state="translated">Para aplicar una operación funcional a los elementos no nulos de un SparseTensor se recomienda uno de los siguientes métodos.En primer lugar,si la función es expresable como TensorFlow ops,usar</target>
        </trans-unit>
        <trans-unit id="3eb084feee66304e2da16fe914a839b30b34c9ff" translate="yes" xml:space="preserve">
          <source>To associate a &lt;code&gt;StatsAggregator&lt;/code&gt; with a &lt;a href=&quot;../../../../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; object, use the following pattern:</source>
          <target state="translated">Para asociar un &lt;code&gt;StatsAggregator&lt;/code&gt; con un objeto &lt;a href=&quot;../../../../data/dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; &lt;/a&gt; , use el siguiente patr&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="c154cd080332e723a840721f93b48724110f7c06" translate="yes" xml:space="preserve">
          <source>To associate a &lt;code&gt;StatsAggregator&lt;/code&gt; with a &lt;a href=&quot;../dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; object, use the following pattern:</source>
          <target state="translated">Para asociar un &lt;code&gt;StatsAggregator&lt;/code&gt; con un objeto &lt;a href=&quot;../dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; &lt;/a&gt; , use el siguiente patr&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="936085b5545471dc42df6c7c7d391847c9751475" translate="yes" xml:space="preserve">
          <source>To avoid copies, if the consumer of the returned value is on the same device as the variable, this actually returns the live value of the variable, not a copy. Updates to the variable are seen by the consumer. If the consumer is on a different device it will get a copy of the variable.</source>
          <target state="translated">Para evitar copias,si el consumidor del valor devuelto está en el mismo dispositivo que la variable,esto devuelve realmente el valor vivo de la variable,no una copia.Las actualizaciones de la variable son vistas por el consumidor.Si el consumidor está en un dispositivo diferente,obtendrá una copia de la variable.</target>
        </trans-unit>
        <trans-unit id="7c1421196dd351f3e8d18229f5901c13e59818be" translate="yes" xml:space="preserve">
          <source>To avoid this operation one can looping over the first &lt;code&gt;ndims&lt;/code&gt; of the variable and using &lt;code&gt;scatter_update&lt;/code&gt; on the subtensors that result of slicing the first dimension. This is a valid option for &lt;code&gt;ndims = 1&lt;/code&gt;, but less efficient than this implementation.</source>
          <target state="translated">Para evitar esta operaci&amp;oacute;n, uno puede &lt;code&gt;ndims&lt;/code&gt; los primeros ndims de la variable y usar &lt;code&gt;scatter_update&lt;/code&gt; en los subtensores que resultan de cortar la primera dimensi&amp;oacute;n. Esta es una opci&amp;oacute;n v&amp;aacute;lida para &lt;code&gt;ndims = 1&lt;/code&gt; , pero menos eficiente que esta implementaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="cfcb9f867b92956487a659195717febb57a22acc" translate="yes" xml:space="preserve">
          <source>To avoid this operation there would be 2 alternatives:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d93bb75610f7b39567f5b306f3397077993ff8e1" translate="yes" xml:space="preserve">
          <source>To avoid this operation there would be 2 alternatives: 1) Reshaping the variable by merging the first &lt;code&gt;ndims&lt;/code&gt; dimensions. However, this is not possible because &lt;a href=&quot;../../reshape&quot;&gt;&lt;code&gt;tf.reshape&lt;/code&gt;&lt;/a&gt; returns a Tensor, which we cannot use &lt;a href=&quot;scatter_update&quot;&gt;&lt;code&gt;tf.compat.v1.scatter_update&lt;/code&gt;&lt;/a&gt; on. 2) Looping over the first &lt;code&gt;ndims&lt;/code&gt; of the variable and using &lt;a href=&quot;scatter_update&quot;&gt;&lt;code&gt;tf.compat.v1.scatter_update&lt;/code&gt;&lt;/a&gt; on the subtensors that result of slicing the first dimension. This is a valid option for &lt;code&gt;ndims = 1&lt;/code&gt;, but less efficient than this implementation.</source>
          <target state="translated">Para evitar esta operaci&amp;oacute;n habr&amp;iacute;a 2 alternativas: 1) Remodelar la variable fusionando las primeras dimensiones &lt;code&gt;ndims&lt;/code&gt; . Sin embargo, esto no es posible porque &lt;a href=&quot;../../reshape&quot;&gt; &lt;code&gt;tf.reshape&lt;/code&gt; &lt;/a&gt; devuelve un tensor, en el que no podemos usar &lt;a href=&quot;scatter_update&quot;&gt; &lt;code&gt;tf.compat.v1.scatter_update&lt;/code&gt; &lt;/a&gt; . 2) &lt;code&gt;ndims&lt;/code&gt; bucle sobre los primeros ndims de la variable y usar &lt;a href=&quot;scatter_update&quot;&gt; &lt;code&gt;tf.compat.v1.scatter_update&lt;/code&gt; &lt;/a&gt; en los subtensores que resultan de cortar la primera dimensi&amp;oacute;n. Esta es una opci&amp;oacute;n v&amp;aacute;lida para &lt;code&gt;ndims = 1&lt;/code&gt; , pero menos eficiente que esta implementaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c9183a300f45fff79988522f16235dc4e2de646c" translate="yes" xml:space="preserve">
          <source>To be implemented by subclasses:</source>
          <target state="translated">Se aplicará por subclases:</target>
        </trans-unit>
        <trans-unit id="52f2d1556ade9e7f9e4af5a180af2690b66cec6f" translate="yes" xml:space="preserve">
          <source>To be used together with &lt;code&gt;initializer = tf.variance_scaling_initializer(factor=1.0, mode='FAN_IN')&lt;/code&gt;. For correct dropout, use &lt;code&gt;tf.contrib.nn.alpha_dropout&lt;/code&gt;.</source>
          <target state="translated">Para ser utilizado junto con &lt;code&gt;initializer = tf.variance_scaling_initializer(factor=1.0, mode='FAN_IN')&lt;/code&gt; . Para un abandono correcto, use &lt;code&gt;tf.contrib.nn.alpha_dropout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea58afe1c10fb928517e860a0db2a381e664fd3c" translate="yes" xml:space="preserve">
          <source>To be used together with the &lt;a href=&quot;../initializers/lecunnormal&quot;&gt;&lt;code&gt;tf.keras.initializers.LecunNormal&lt;/code&gt;&lt;/a&gt; initializer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="067aa09e87c256fc4280bb7886d1747104dcfb5d" translate="yes" xml:space="preserve">
          <source>To be used together with the dropout variant &lt;a href=&quot;../layers/alphadropout&quot;&gt;&lt;code&gt;tf.keras.layers.AlphaDropout&lt;/code&gt;&lt;/a&gt; (not regular dropout).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53dd8873954bfa79dfd0bea43d6ef54fe742261a" translate="yes" xml:space="preserve">
          <source>To build a SavedModel, the first meta graph must be saved with variables. Subsequent meta graphs will simply be saved with their graph definitions. If assets need to be saved and written or copied to disk, they can be provided when the meta graph def is added. If multiple meta graph defs are associated an asset of the same name, only the first version is retained.</source>
          <target state="translated">Para construir un SavedModel,el primer meta gráfico debe ser guardado con variables.Los meta gráficos subsiguientes simplemente se guardarán con sus definiciones de gráficos.Si es necesario guardar y escribir o copiar los activos en el disco,se pueden proporcionar cuando se añada el meta gráfico por defecto.Si a varios metagráficos defs se les asocia un activo del mismo nombre,sólo se conserva la primera versión.</target>
        </trans-unit>
        <trans-unit id="44fe360fd9bf0e087ab467407a9221a32654e234" translate="yes" xml:space="preserve">
          <source>To construct a TPUStrategy object, you need to run the initialization code as below:</source>
          <target state="translated">Para construir un objeto de TPUStrategy,hay que ejecutar el código de inicialización como se indica a continuación:</target>
        </trans-unit>
        <trans-unit id="83c7623c3022948b14096264ce7d526cb9408c74" translate="yes" xml:space="preserve">
          <source>To consume the statistics, associate a &lt;code&gt;StatsAggregator&lt;/code&gt; with the output dataset.</source>
          <target state="translated">Para consumir las estad&amp;iacute;sticas, asocie un &lt;code&gt;StatsAggregator&lt;/code&gt; con el conjunto de datos de salida.</target>
        </trans-unit>
        <trans-unit id="d2287264f43a3ef6c22b5d232bbf5118319287d4" translate="yes" xml:space="preserve">
          <source>To create a &lt;a href=&quot;../compat/v1/session&quot;&gt;&lt;code&gt;tf.compat.v1.Session&lt;/code&gt;&lt;/a&gt; that connects to this server, use the following snippet:</source>
          <target state="translated">Para crear una &lt;a href=&quot;../compat/v1/session&quot;&gt; &lt;code&gt;tf.compat.v1.Session&lt;/code&gt; &lt;/a&gt; que se conecte a este servidor, utilice el siguiente fragmento:</target>
        </trans-unit>
        <trans-unit id="d6382ce12824513eb2d0429e1935eb788cf98fff" translate="yes" xml:space="preserve">
          <source>To create a cluster with two jobs and five tasks, you specify the mapping from job names to lists of network addresses (typically hostname-port pairs).</source>
          <target state="translated">Para crear un clúster con dos trabajos y cinco tareas,se especifica el mapeo desde los nombres de los trabajos hasta las listas de direcciones de red (típicamente pares de nombre de host y puerto).</target>
        </trans-unit>
        <trans-unit id="162a52ef0e892f8de2d469fbf8a8ede583aeb2c2" translate="yes" xml:space="preserve">
          <source>To create a dataset of all files matching a pattern, use &lt;a href=&quot;dataset#list_files&quot;&gt;&lt;code&gt;tf.data.Dataset.list_files&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Para crear un conjunto de datos de todos los archivos que coinciden con un patr&amp;oacute;n, use &lt;a href=&quot;dataset#list_files&quot;&gt; &lt;code&gt;tf.data.Dataset.list_files&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="d3f4ab00aa69fb40cd693922a5c483368cf34082" translate="yes" xml:space="preserve">
          <source>To customize the estimator &lt;code&gt;eval_metric_ops&lt;/code&gt; names, you can pass in the &lt;code&gt;metric_names_map&lt;/code&gt; dictionary mapping the keras model output metric names to the custom names as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baed8fb95bde1dbbdafd79f549daf02185ceb494" translate="yes" xml:space="preserve">
          <source>To enable a public method, subclasses should implement the leading-underscore version of the method. The argument signature should be identical except for the omission of &lt;code&gt;name=&quot;...&quot;&lt;/code&gt;. For example, to enable &lt;code&gt;matmul(x, adjoint=False, name=&quot;matmul&quot;)&lt;/code&gt; a subclass should implement &lt;code&gt;_matmul(x, adjoint=False)&lt;/code&gt;.</source>
          <target state="translated">Para habilitar un m&amp;eacute;todo p&amp;uacute;blico, las subclases deben implementar la versi&amp;oacute;n de subrayado inicial del m&amp;eacute;todo. La firma del argumento debe ser id&amp;eacute;ntica excepto por la omisi&amp;oacute;n de &lt;code&gt;name=&quot;...&quot;&lt;/code&gt; . Por ejemplo, para habilitar &lt;code&gt;matmul(x, adjoint=False, name=&quot;matmul&quot;)&lt;/code&gt; una subclase debe implementar &lt;code&gt;_matmul(x, adjoint=False)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a64f441e5dd84fd06f79adb0f1f3a053a7155dea" translate="yes" xml:space="preserve">
          <source>To enable and control broadcasting, use an ellipsis. For example, to perform batch matrix multiplication with NumPy-style broadcasting across the batch dimensions, use:</source>
          <target state="translated">Para habilitar y controlar la emisión,utilice una elipse.Por ejemplo,para realizar la multiplicación de la matriz de lotes con la difusión de estilo NumPy a través de las dimensiones del lote,utilice:</target>
        </trans-unit>
        <trans-unit id="afa60615bea13e940acd80b65497cda8c8de7ef9" translate="yes" xml:space="preserve">
          <source>To enable statefulness:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b6fd9e2269c63a7f1c5eddbf780087a139a252" translate="yes" xml:space="preserve">
          <source>To enable statefulness: - Specify &lt;code&gt;stateful=True&lt;/code&gt; in the layer constructor. - Specify a fixed batch size for your model, by passing If sequential model: &lt;code&gt;batch_input_shape=(...)&lt;/code&gt; to the first layer in your model. Else for functional model with 1 or more Input layers: &lt;code&gt;batch_shape=(...)&lt;/code&gt; to all the first layers in your model. This is the expected shape of your inputs &lt;em&gt;including the batch size&lt;/em&gt;. It should be a tuple of integers, e.g. &lt;code&gt;(32, 10, 100)&lt;/code&gt;. - Specify &lt;code&gt;shuffle=False&lt;/code&gt; when calling fit().</source>
          <target state="translated">Para habilitar statefulness: - Especifique &lt;code&gt;stateful=True&lt;/code&gt; en el constructor de capas. - Especifique un tama&amp;ntilde;o de lote fijo para su modelo, pasando If modelo secuencial: &lt;code&gt;batch_input_shape=(...)&lt;/code&gt; a la primera capa de su modelo. De lo contrario, para el modelo funcional con 1 o m&amp;aacute;s capas de entrada: &lt;code&gt;batch_shape=(...)&lt;/code&gt; a todas las primeras capas de su modelo. Esta es la forma esperada de sus entradas, &lt;em&gt;incluido el tama&amp;ntilde;o del lote&lt;/em&gt; . Debe ser una tupla de n&amp;uacute;meros enteros, por ejemplo &lt;code&gt;(32, 10, 100)&lt;/code&gt; . - Especifique &lt;code&gt;shuffle=False&lt;/code&gt; al llamar a fit ().</target>
        </trans-unit>
        <trans-unit id="d5e380bc52096caf61cf4a0e2ca23ca08f41f03b" translate="yes" xml:space="preserve">
          <source>To enable this Soft-NMS mode, set the &lt;code&gt;soft_nms_sigma&lt;/code&gt; parameter to be larger than 0. When &lt;code&gt;soft_nms_sigma&lt;/code&gt; equals 0, the behavior of &lt;a href=&quot;non_max_suppression_padded&quot;&gt;&lt;code&gt;tf.image.non_max_suppression_padded&lt;/code&gt;&lt;/a&gt; is identical to that of &lt;a href=&quot;non_max_suppression&quot;&gt;&lt;code&gt;tf.image.non_max_suppression&lt;/code&gt;&lt;/a&gt; (except for the extra output) both in function and in running time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63aaf92714daf46639926647a3d0a69e133b8f2a" translate="yes" xml:space="preserve">
          <source>To enable this Soft-NMS mode, set the &lt;code&gt;soft_nms_sigma&lt;/code&gt; parameter to be larger than 0. When &lt;code&gt;soft_nms_sigma&lt;/code&gt; equals 0, the behavior of &lt;code&gt;tf.image.non_max_suppression_v2&lt;/code&gt; is identical to that of &lt;a href=&quot;non_max_suppression&quot;&gt;&lt;code&gt;tf.image.non_max_suppression&lt;/code&gt;&lt;/a&gt; (except for the extra output) both in function and in running time.</source>
          <target state="translated">Para habilitar este modo Soft-NMS, configure el par&amp;aacute;metro &lt;code&gt;soft_nms_sigma&lt;/code&gt; para que sea mayor que 0. Cuando &lt;code&gt;soft_nms_sigma&lt;/code&gt; es igual a 0, el comportamiento de &lt;code&gt;tf.image.non_max_suppression_v2&lt;/code&gt; es id&amp;eacute;ntico al de &lt;a href=&quot;non_max_suppression&quot;&gt; &lt;code&gt;tf.image.non_max_suppression&lt;/code&gt; &lt;/a&gt; (excepto por la salida adicional) tanto en funci&amp;oacute;n y en tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="30dc95cd6fb2fe82cb6bde586b190076a23204d3" translate="yes" xml:space="preserve">
          <source>To ensure forward compatibility of generated graphs (see &lt;code&gt;forward_compatible&lt;/code&gt;) with older binaries, new features can be gated with:</source>
          <target state="translated">Para garantizar la compatibilidad con &lt;code&gt;forward_compatible&lt;/code&gt; gr&amp;aacute;ficos generados (consulte forward_compatible ) con archivos binarios m&amp;aacute;s antiguos, se pueden obtener nuevas funciones con:</target>
        </trans-unit>
        <trans-unit id="2a6dfd40e1c087316d123358f0bfd9c6696a8b43" translate="yes" xml:space="preserve">
          <source>To ensure that loading is complete and no more assignments will take place, use the &lt;code&gt;assert_consumed()&lt;/code&gt; method of the status object returned by &lt;code&gt;restore()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fdc8715d19df576a528e05d54600b3b8b7e951d" translate="yes" xml:space="preserve">
          <source>To ensure that loading is complete and no more assignments will take place, use the &lt;code&gt;assert_consumed()&lt;/code&gt; method of the status object returned by &lt;code&gt;restore&lt;/code&gt;:</source>
          <target state="translated">Para asegurarse de que la carga est&amp;eacute; completa y no se realizar&amp;aacute;n m&amp;aacute;s asignaciones, use el m&amp;eacute;todo &lt;code&gt;assert_consumed()&lt;/code&gt; del objeto de estado devuelto por &lt;code&gt;restore&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7f9135f3ba27360a5d60098a844664f0e165caf9" translate="yes" xml:space="preserve">
          <source>To extend, inherit from this class; from the subclass &lt;strong&gt;init&lt;/strong&gt;, call</source>
          <target state="translated">Para ampliar, heredar de esta clase; desde la subclase &lt;strong&gt;init&lt;/strong&gt; , llame</target>
        </trans-unit>
        <trans-unit id="a5d8cbeafaa3eeb0c6165bfa56b4aafe15d6a9db" translate="yes" xml:space="preserve">
          <source>To generate different sequences across sessions, set neither graph-level nor op-level seeds:</source>
          <target state="translated">Para generar diferentes secuencias a lo largo de las sesiones,no establezca ni semillas de nivel gráfico ni de nivel operativo:</target>
        </trans-unit>
        <trans-unit id="8b8fda9f12ffa5af323a889062c3aa890309e2cb" translate="yes" xml:space="preserve">
          <source>To generate the same repeatable sequence for an op across sessions, set the seed for the op:</source>
          <target state="translated">Para generar la misma secuencia repetible para una operación a través de las sesiones,establezca la semilla de la operación:</target>
        </trans-unit>
        <trans-unit id="ff3af5efb2174b5bcd82487648e50b8ae5b6afb0" translate="yes" xml:space="preserve">
          <source>To get a more intuitive and visual look at what this operation does, you can run tensorflow/examples/wav_to_spectrogram to read in an audio file and save out the resulting spectrogram as a PNG image.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec9fe6e91399876e841634556ab27d6bee162948" translate="yes" xml:space="preserve">
          <source>To get a protocol buffer summary of the currently aggregated statistics, use the &lt;code&gt;StatsAggregator.get_summary()&lt;/code&gt; tensor. The easiest way to do this is to add the returned tensor to the &lt;code&gt;tf.GraphKeys.SUMMARIES&lt;/code&gt; collection, so that the summaries will be included with any existing summaries.</source>
          <target state="translated">Para obtener un resumen del b&amp;uacute;fer de protocolo de las estad&amp;iacute;sticas agregadas actualmente, use el tensor &lt;code&gt;StatsAggregator.get_summary()&lt;/code&gt; . La forma m&amp;aacute;s sencilla de hacer esto es agregar el tensor devuelto a la colecci&amp;oacute;n &lt;code&gt;tf.GraphKeys.SUMMARIES&lt;/code&gt; , de modo que los res&amp;uacute;menes se incluyan con los res&amp;uacute;menes existentes.</target>
        </trans-unit>
        <trans-unit id="eecdfb3013e20388a17f33fbb93597b30d4ef349" translate="yes" xml:space="preserve">
          <source>To get the current default session, use &lt;a href=&quot;get_default_session&quot;&gt;&lt;code&gt;tf.compat.v1.get_default_session&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para obtener la sesi&amp;oacute;n predeterminada actual, use &lt;a href=&quot;get_default_session&quot;&gt; &lt;code&gt;tf.compat.v1.get_default_session&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="273ca78fffe894af5651288f4a1f4c051d209749" translate="yes" xml:space="preserve">
          <source>To illustrate the user-visible effects, consider these examples:</source>
          <target state="translated">Para ilustrar los efectos visibles para el usuario,considere estos ejemplos:</target>
        </trans-unit>
        <trans-unit id="ce5890e8d9ded5f833a93abef51a8a4c147da863" translate="yes" xml:space="preserve">
          <source>To instead reorder the data to rearrange the dimensions of a tensor, see &lt;a href=&quot;transpose&quot;&gt;&lt;code&gt;tf.transpose&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">En su lugar, para reordenar los datos para reorganizar las dimensiones de un tensor, consulte &lt;a href=&quot;transpose&quot;&gt; &lt;code&gt;tf.transpose&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="58521b85b5941fed07e375b8c580b661cb67962d" translate="yes" xml:space="preserve">
          <source>To load a network from a JSON save file, use &lt;a href=&quot;../models/model_from_json&quot;&gt;&lt;code&gt;keras.models.model_from_json(json_string, custom_objects={})&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para cargar una red desde un archivo guardado JSON, use &lt;a href=&quot;../models/model_from_json&quot;&gt; &lt;code&gt;keras.models.model_from_json(json_string, custom_objects={})&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fc1f35de200c65966b97907804a085417fa2674d" translate="yes" xml:space="preserve">
          <source>To load a network from a JSON save file, use &lt;a href=&quot;models/model_from_json&quot;&gt;&lt;code&gt;keras.models.model_from_json(json_string, custom_objects={})&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para cargar una red desde un archivo guardado JSON, use &lt;a href=&quot;models/model_from_json&quot;&gt; &lt;code&gt;keras.models.model_from_json(json_string, custom_objects={})&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="171ed2725b41e726794d8676fc06308b4d649fcf" translate="yes" xml:space="preserve">
          <source>To load a network from a yaml save file, use &lt;a href=&quot;../models/model_from_yaml&quot;&gt;&lt;code&gt;keras.models.model_from_yaml(yaml_string, custom_objects={})&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para cargar una red desde un archivo guardado de yaml, use &lt;a href=&quot;../models/model_from_yaml&quot;&gt; &lt;code&gt;keras.models.model_from_yaml(yaml_string, custom_objects={})&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="32acfa401b4c952f2dcfef233deb7f737a491a64" translate="yes" xml:space="preserve">
          <source>To load a network from a yaml save file, use &lt;a href=&quot;models/model_from_yaml&quot;&gt;&lt;code&gt;keras.models.model_from_yaml(yaml_string, custom_objects={})&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para cargar una red desde un archivo guardado de yaml, use &lt;a href=&quot;models/model_from_yaml&quot;&gt; &lt;code&gt;keras.models.model_from_yaml(yaml_string, custom_objects={})&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="84dbf2d04bfcc507efa1aac8fcfb0ed50455e091" translate="yes" xml:space="preserve">
          <source>To make the random sequences generated by all ops be repeatable across sessions, set a graph-level seed:</source>
          <target state="translated">Para que las secuencias aleatorias generadas por todas las operaciones se repitan a lo largo de las sesiones,establezca una semilla a nivel de gráfico:</target>
        </trans-unit>
        <trans-unit id="8bca5a7e3515ab70d1734fcf9290f94f57a539f3" translate="yes" xml:space="preserve">
          <source>To mimic the behavior of &lt;code&gt;np.flatten&lt;/code&gt; (which flattens all dimensions), use &lt;code&gt;rt.merge_dims(0, -1). To mimic the behavior of&lt;/code&gt;tf.layers.Flatten&lt;code&gt;(which flattens all dimensions except the outermost batch dimension), use&lt;/code&gt;rt.merge_dims(1, -1)`.</source>
          <target state="translated">Para imitar el comportamiento de &lt;code&gt;np.flatten&lt;/code&gt; (que aplana todas las dimensiones), use &lt;code&gt;rt.merge_dims(0, -1). To mimic the behavior of&lt;/code&gt; tf.layers.Flatten &lt;code&gt;(which flattens all dimensions except the outermost batch dimension), use&lt;/code&gt; rt.merge_dims (1, -1) `.</target>
        </trans-unit>
        <trans-unit id="f9a3e8831e7d974549f1a0383e7928bbabcfacd7" translate="yes" xml:space="preserve">
          <source>To obtain an individual graph, use the &lt;code&gt;get_concrete_function&lt;/code&gt; method of the callable created by &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;. It can be called with the same arguments as &lt;code&gt;func&lt;/code&gt; and returns a special &lt;a href=&quot;graph&quot;&gt;&lt;code&gt;tf.Graph&lt;/code&gt;&lt;/a&gt; object:</source>
          <target state="translated">Para obtener un gr&amp;aacute;fico individual, use el m&amp;eacute;todo &lt;code&gt;get_concrete_function&lt;/code&gt; del invocable creado por &lt;a href=&quot;function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; . Se puede llamar con los mismos argumentos que &lt;code&gt;func&lt;/code&gt; y devuelve un objeto &lt;a href=&quot;graph&quot;&gt; &lt;code&gt;tf.Graph&lt;/code&gt; &lt;/a&gt; especial :</target>
        </trans-unit>
        <trans-unit id="9e83f95895428f42e71becadca9982d2894dba04" translate="yes" xml:space="preserve">
          <source>To pass sample weights when training or evaluating the Estimator, the first item returned by the input function should be a dictionary with keys &lt;code&gt;features&lt;/code&gt; and &lt;code&gt;sample_weights&lt;/code&gt;. Example below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0110a07b243d67a47edf557bd54d79fd2de9674" translate="yes" xml:space="preserve">
          <source>To perform the clipping, the values &lt;code&gt;t_list[i]&lt;/code&gt; are set to:</source>
          <target state="translated">Para realizar el recorte, los valores &lt;code&gt;t_list[i]&lt;/code&gt; se establecen en:</target>
        </trans-unit>
        <trans-unit id="5e552f3cce7d0e03051d89f4e0255d1c49f37d1b" translate="yes" xml:space="preserve">
          <source>To prevent accidental sharing of variables, we raise an exception when getting an existing variable in a non-reusing scope.</source>
          <target state="translated">Para evitar que se compartan accidentalmente las variables,planteamos una excepción cuando se obtiene una variable existente en un ámbito no reutilizable.</target>
        </trans-unit>
        <trans-unit id="b90b39244fd5711de404a1ed79326b6635b08950" translate="yes" xml:space="preserve">
          <source>To process lines from files, use &lt;a href=&quot;textlinedataset&quot;&gt;&lt;code&gt;tf.data.TextLineDataset&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Para procesar l&amp;iacute;neas de archivos, use &lt;a href=&quot;textlinedataset&quot;&gt; &lt;code&gt;tf.data.TextLineDataset&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="aa139b98ea790b72d4805462346af0f7c690db65" translate="yes" xml:space="preserve">
          <source>To process records written in the &lt;code&gt;TFRecord&lt;/code&gt; format, use &lt;code&gt;TFRecordDataset&lt;/code&gt;:</source>
          <target state="translated">Para procesar registros escritos en formato &lt;code&gt;TFRecord&lt;/code&gt; , use &lt;code&gt;TFRecordDataset&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="862cc9660449fcff05a0a9d8dd83a651e63fd705" translate="yes" xml:space="preserve">
          <source>To provide an API that is close to Python's file I/O objects, and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e93ce7e6602bc5d8a646cce42b0e2f27a7ee545d" translate="yes" xml:space="preserve">
          <source>To provide an implementation based on TensorFlow's C++ FileSystem API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b683767243ad0f37ed1467c8125bf95f601a1fc4" translate="yes" xml:space="preserve">
          <source>To read back the elements, use &lt;code&gt;TFRecordDataset&lt;/code&gt;.</source>
          <target state="translated">Para volver a leer los elementos, use &lt;code&gt;TFRecordDataset&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff235c20472c16fd213bae4a4af01054d920d420" translate="yes" xml:space="preserve">
          <source>To reconstruct an original waveform, a complementary window function should be used with &lt;code&gt;inverse_stft&lt;/code&gt;. Such a window function can be constructed with &lt;a href=&quot;inverse_stft_window_fn&quot;&gt;&lt;code&gt;tf.signal.inverse_stft_window_fn&lt;/code&gt;&lt;/a&gt;. Example:</source>
          <target state="translated">Para reconstruir una forma de onda original, se debe usar una funci&amp;oacute;n de ventana complementaria con &lt;code&gt;inverse_stft&lt;/code&gt; . Esta funci&amp;oacute;n de ventana se puede construir con &lt;a href=&quot;inverse_stft_window_fn&quot;&gt; &lt;code&gt;tf.signal.inverse_stft_window_fn&lt;/code&gt; &lt;/a&gt; . Ejemplo:</target>
        </trans-unit>
        <trans-unit id="a1cda1853dc2b4c5ea41c6c734bd8df45e09a74c" translate="yes" xml:space="preserve">
          <source>To reconstruct an original waveform, the same window function should be used with &lt;code&gt;mdct&lt;/code&gt; and &lt;code&gt;inverse_mdct&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca5c9dd44204672cbbbbaf3d7ffdd096d2e60573" translate="yes" xml:space="preserve">
          <source>To record statistics, use one of the custom transformation functions defined in this module when defining your &lt;a href=&quot;../../../../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt;. All statistics will be aggregated by the &lt;code&gt;StatsAggregator&lt;/code&gt; that is associated with a particular iterator (see below). For example, to record the latency of producing each element by iterating over a dataset:</source>
          <target state="translated">Para registrar estad&amp;iacute;sticas, use una de las funciones de transformaci&amp;oacute;n personalizadas definidas en este m&amp;oacute;dulo al definir su &lt;a href=&quot;../../../../data/dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; &lt;/a&gt; . Todas las estad&amp;iacute;sticas ser&amp;aacute;n agregadas por el &lt;code&gt;StatsAggregator&lt;/code&gt; que est&amp;aacute; asociado con un iterador en particular (ver m&amp;aacute;s abajo). Por ejemplo, para registrar la latencia de producir cada elemento iterando sobre un conjunto de datos:</target>
        </trans-unit>
        <trans-unit id="84004f640543424d2c71289d24eec0f0b8df9f20" translate="yes" xml:space="preserve">
          <source>To record statistics, use one of the custom transformation functions defined in this module when defining your &lt;a href=&quot;../dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt;. All statistics will be aggregated by the &lt;code&gt;StatsAggregator&lt;/code&gt; that is associated with a particular iterator (see below). For example, to record the latency of producing each element by iterating over a dataset:</source>
          <target state="translated">Para registrar estad&amp;iacute;sticas, use una de las funciones de transformaci&amp;oacute;n personalizadas definidas en este m&amp;oacute;dulo al definir su &lt;a href=&quot;../dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; &lt;/a&gt; . Todas las estad&amp;iacute;sticas ser&amp;aacute;n agregadas por el &lt;code&gt;StatsAggregator&lt;/code&gt; que est&amp;aacute; asociado con un iterador en particular (ver m&amp;aacute;s abajo). Por ejemplo, para registrar la latencia de producir cada elemento iterando sobre un conjunto de datos:</target>
        </trans-unit>
        <trans-unit id="6601eea42af302d30ea25dfb68ead4d332e25000" translate="yes" xml:space="preserve">
          <source>To rescale an input in the &lt;code&gt;[0, 255]&lt;/code&gt; range to be in the &lt;code&gt;[-1, 1]&lt;/code&gt; range, you would pass &lt;code&gt;scale=1./127.5, offset=-1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="878d90bc13f047ae3b3be5ee736a5ab7a5fd6624" translate="yes" xml:space="preserve">
          <source>To rescale an input in the &lt;code&gt;[0, 255]&lt;/code&gt; range to be in the &lt;code&gt;[0, 1]&lt;/code&gt; range, you would pass &lt;code&gt;scale=1./255&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bf5571681c9436431c1ed224b52ea46ea226e1b" translate="yes" xml:space="preserve">
          <source>To reset the states of your model, call &lt;code&gt;.reset_states()&lt;/code&gt; on either a specific layer, or on your entire model.</source>
          <target state="translated">Para restablecer los estados de su modelo, llame a &lt;code&gt;.reset_states()&lt;/code&gt; en una capa espec&amp;iacute;fica o en todo su modelo.</target>
        </trans-unit>
        <trans-unit id="5f2fb526cb8dbaa2bd872bcdf1bffcdc847f4f4f" translate="yes" xml:space="preserve">
          <source>To restore variables, you have to know the name of the shadow variables. That name and the original variable can then be passed to a &lt;code&gt;Saver()&lt;/code&gt; object to restore the variable from the moving average value with: &lt;code&gt;saver = tf.compat.v1.train.Saver({ema.average_name(var): var})&lt;/code&gt;</source>
          <target state="translated">Para restaurar variables, debe conocer el nombre de las variables de sombra. Ese nombre y la variable original se pueden pasar a un objeto &lt;code&gt;Saver()&lt;/code&gt; para restaurar la variable desde el valor promedio m&amp;oacute;vil con: &lt;code&gt;saver = tf.compat.v1.train.Saver({ema.average_name(var): var})&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="61b9174bc024e647c5c9bf1631b4141790c76fd9" translate="yes" xml:space="preserve">
          <source>To run TF2 programs on TPUs, you can either use &lt;code&gt;.compile&lt;/code&gt; and &lt;code&gt;.fit&lt;/code&gt; APIs in &lt;a href=&quot;../../keras&quot;&gt;&lt;code&gt;tf.keras&lt;/code&gt;&lt;/a&gt; with TPUStrategy, or write your own customized training loop by calling &lt;code&gt;strategy.experimental_run_v2&lt;/code&gt; directly. Note that TPUStrategy doesn't support pure eager execution, so please make sure the function passed into &lt;code&gt;strategy.experimental_run_v2&lt;/code&gt; is a &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;strategy.experimental_run_v2&lt;/code&gt; us called inside a &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; if running in eager mode.</source>
          <target state="translated">Para ejecutar programas TF2 en TPU, puede usar las API &lt;code&gt;.compile&lt;/code&gt; y &lt;code&gt;.fit&lt;/code&gt; en &lt;a href=&quot;../../keras&quot;&gt; &lt;code&gt;tf.keras&lt;/code&gt; &lt;/a&gt; con TPUStrategy, o escribir su propio ciclo de entrenamiento personalizado llamando a &lt;code&gt;strategy.experimental_run_v2&lt;/code&gt; directamente. Tenga en cuenta que TPUStrategy no admite la ejecuci&amp;oacute;n ansiosos puro, as&amp;iacute; que por favor aseg&amp;uacute;rese de que la funci&amp;oacute;n pasada en &lt;code&gt;strategy.experimental_run_v2&lt;/code&gt; es un &lt;a href=&quot;../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; o &lt;code&gt;strategy.experimental_run_v2&lt;/code&gt; nosotros llamamos el interior de un &lt;a href=&quot;../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; si se ejecuta en modo ansiosos.</target>
        </trans-unit>
        <trans-unit id="75d6af2437dac9afdbd259194ca306ea0df7ba35" translate="yes" xml:space="preserve">
          <source>To run TF2 programs on TPUs, you can either use &lt;code&gt;.compile&lt;/code&gt; and &lt;code&gt;.fit&lt;/code&gt; APIs in &lt;a href=&quot;../../keras&quot;&gt;&lt;code&gt;tf.keras&lt;/code&gt;&lt;/a&gt; with TPUStrategy, or write your own customized training loop by calling &lt;code&gt;strategy.run&lt;/code&gt; directly. Note that TPUStrategy doesn't support pure eager execution, so please make sure the function passed into &lt;code&gt;strategy.run&lt;/code&gt; is a &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;strategy.run&lt;/code&gt; is called inside a &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; if eager behavior is enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d76e97ea1150910b642e3424cedffc8e064a46d" translate="yes" xml:space="preserve">
          <source>To run TF2 programs on TPUs, you can either use &lt;code&gt;.compile&lt;/code&gt; and &lt;code&gt;.fit&lt;/code&gt; APIs in &lt;a href=&quot;../keras&quot;&gt;&lt;code&gt;tf.keras&lt;/code&gt;&lt;/a&gt; with TPUStrategy, or write your own customized training loop by calling &lt;code&gt;strategy.run&lt;/code&gt; directly. Note that TPUStrategy doesn't support pure eager execution, so please make sure the function passed into &lt;code&gt;strategy.run&lt;/code&gt; is a &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;strategy.run&lt;/code&gt; is called inside a &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; if eager behavior is enabled. See more details in https://www.tensorflow.org/guide/tpu.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e990fa899ccbe4b80cb8729867536ff2b0542458" translate="yes" xml:space="preserve">
          <source>To save and restore.</source>
          <target state="translated">Para salvar y restaurar.</target>
        </trans-unit>
        <trans-unit id="b35673692b203b1580cc459164c684b7c71fe1e4" translate="yes" xml:space="preserve">
          <source>To shard a &lt;code&gt;dataset&lt;/code&gt; across multiple TFRecord files:</source>
          <target state="translated">Para fragmentar un &lt;code&gt;dataset&lt;/code&gt; en varios archivos TFRecord:</target>
        </trans-unit>
        <trans-unit id="fc6bb2051a5897d4a8d4dac929c8a069356b9e0c" translate="yes" xml:space="preserve">
          <source>To simplify the thread implementation, the Coordinator provides a context handler &lt;code&gt;stop_on_exception()&lt;/code&gt; that automatically requests a stop if an exception is raised. Using the context handler the thread code above can be written as:</source>
          <target state="translated">Para simplificar la implementaci&amp;oacute;n del hilo, el Coordinador proporciona un controlador de contexto &lt;code&gt;stop_on_exception()&lt;/code&gt; que solicita autom&amp;aacute;ticamente una parada si se genera una excepci&amp;oacute;n. Usando el controlador de contexto, el c&amp;oacute;digo del hilo anterior se puede escribir como:</target>
        </trans-unit>
        <trans-unit id="a72b5fda5da9fdf55b3bf54113912820e04f4679" translate="yes" xml:space="preserve">
          <source>To stop the trace and export the collected information, use &lt;a href=&quot;trace_export&quot;&gt;&lt;code&gt;tf.summary.trace_export&lt;/code&gt;&lt;/a&gt;. To stop the trace without exporting, use &lt;a href=&quot;trace_off&quot;&gt;&lt;code&gt;tf.summary.trace_off&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para detener el rastreo y exportar la informaci&amp;oacute;n recopilada, use &lt;a href=&quot;trace_export&quot;&gt; &lt;code&gt;tf.summary.trace_export&lt;/code&gt; &lt;/a&gt; . Para detener el seguimiento sin exportar, use &lt;a href=&quot;trace_off&quot;&gt; &lt;code&gt;tf.summary.trace_off&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="25b078e238adc2f2bf2f225cb3a76dafd2b5b18d" translate="yes" xml:space="preserve">
          <source>To take the transpose of the matrices in dimension-0 (such as when you are transposing matrices where 0 is the batch dimesnion), you would set &lt;code&gt;perm=[0,2,1]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78edbe912a6ec7dfbde2fa6ca3dbd293be354b5e" translate="yes" xml:space="preserve">
          <source>To train with replicas you deploy the same program in a &lt;code&gt;Cluster&lt;/code&gt;. One of the tasks must be identified as the &lt;em&gt;chief&lt;/em&gt;: the task that handles initialization, checkpoints, summaries, and recovery. The other tasks depend on the &lt;em&gt;chief&lt;/em&gt; for these services.</source>
          <target state="translated">Para entrenar con r&amp;eacute;plicas, implementa el mismo programa en un &lt;code&gt;Cluster&lt;/code&gt; . Una de las tareas debe identificarse como el &lt;em&gt;jefe&lt;/em&gt; : la tarea que maneja la inicializaci&amp;oacute;n, los puntos de control, los res&amp;uacute;menes y la recuperaci&amp;oacute;n. Las otras tareas dependen del &lt;em&gt;jefe&lt;/em&gt; de estos servicios.</target>
        </trans-unit>
        <trans-unit id="0a01c3edc32585755d57328d40fa48f8fdb3ab82" translate="yes" xml:space="preserve">
          <source>To treat a sparse input as dense, provide &lt;code&gt;allow_missing=True&lt;/code&gt;; otherwise, the parse functions will fail on any examples missing this feature.</source>
          <target state="translated">Para tratar una entrada escasa como densa, proporcione &lt;code&gt;allow_missing=True&lt;/code&gt; ; de lo contrario, las funciones de an&amp;aacute;lisis fallar&amp;aacute;n en cualquier ejemplo que no tenga esta caracter&amp;iacute;stica.</target>
        </trans-unit>
        <trans-unit id="f70a87293b647de36d39cf376105ebfad1b65755" translate="yes" xml:space="preserve">
          <source>To treat sparse input as dense, provide a &lt;code&gt;default_value&lt;/code&gt;; otherwise, the parse functions will fail on any examples missing this feature.</source>
          <target state="translated">Para tratar la entrada escasa como densa, proporcione un &lt;code&gt;default_value&lt;/code&gt; ; de lo contrario, las funciones de an&amp;aacute;lisis fallar&amp;aacute;n en cualquier ejemplo que no tenga esta caracter&amp;iacute;stica.</target>
        </trans-unit>
        <trans-unit id="2cf2713de328f732331e0697fff7bd058371175a" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;MirroredStrategy&lt;/code&gt; with multiple workers, please refer to &lt;code&gt;tf.distribute.MultiWorkerMirroredStrategy&lt;/code&gt;.</source>
          <target state="translated">Para utilizar &lt;code&gt;MirroredStrategy&lt;/code&gt; con varios trabajadores, consulte &lt;code&gt;tf.distribute.MultiWorkerMirroredStrategy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12770f5e5f15720c161e4a87129f9d9bb0774bc6" translate="yes" xml:space="preserve">
          <source>To use SyncReplicasOptimizer with an &lt;code&gt;Estimator&lt;/code&gt;, you need to send sync_replicas_hook while calling the fit.</source>
          <target state="translated">Para usar SyncReplicasOptimizer con un &lt;code&gt;Estimator&lt;/code&gt; , debe enviar sync_replicas_hook mientras llama al ajuste.</target>
        </trans-unit>
        <trans-unit id="783180a85bf045e00f72afe9cf4aeba0310e67f8" translate="yes" xml:space="preserve">
          <source>To use a listener, implement a class and pass the listener to a &lt;code&gt;CheckpointSaverHook&lt;/code&gt;, as in this example:</source>
          <target state="translated">Para usar un oyente, implemente una clase y pase el oyente a un &lt;code&gt;CheckpointSaverHook&lt;/code&gt; , como en este ejemplo:</target>
        </trans-unit>
        <trans-unit id="dc7556a3e1ddbbfb55342d1204bfb7cd99d3d15a" translate="yes" xml:space="preserve">
          <source>To use another kernel, just replace the layer creation line with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82a8f0d7938dca39dd9baa444dbabf12a6beff73" translate="yes" xml:space="preserve">
          <source>To use crossed column in DNN model, you need to add it in an embedding column as in this example:</source>
          <target state="translated">Para usar la columna cruzada en el modelo DNN,hay que añadirla en una columna de incrustación como en este ejemplo:</target>
        </trans-unit>
        <trans-unit id="df232f0149a3304cb55f19e9533d29d033c88a07" translate="yes" xml:space="preserve">
          <source>To use it with Keras &lt;code&gt;compile&lt;/code&gt;/&lt;code&gt;fit&lt;/code&gt;, &lt;a href=&quot;https://www.tensorflow.org/guide/distributed_training#using_tfdistributestrategy_with_keras&quot;&gt;please read&lt;/a&gt;.</source>
          <target state="translated">Para usarlo con Keras &lt;code&gt;compile&lt;/code&gt; / &lt;code&gt;fit&lt;/code&gt; , &lt;a href=&quot;https://www.tensorflow.org/guide/distributed_training#using_tfdistributestrategy_with_keras&quot;&gt;lea&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="52761ad57b4e88f15825661793f52089d3153688" translate="yes" xml:space="preserve">
          <source>To use mixed precision in a Keras model, the &lt;code&gt;'mixed_float16'&lt;/code&gt; or &lt;code&gt;'mixed_bfloat16'&lt;/code&gt; policy can be used. &lt;a href=&quot;set_policy&quot;&gt;&lt;code&gt;tf.keras.mixed_precision.experimental.set_policy&lt;/code&gt;&lt;/a&gt; can be used to set the default policy for layers if no policy is passed to them. For example:</source>
          <target state="translated">Para usar precisi&amp;oacute;n mixta en un modelo de Keras, se puede usar la pol&amp;iacute;tica &lt;code&gt;'mixed_float16'&lt;/code&gt; o &lt;code&gt;'mixed_bfloat16'&lt;/code&gt; . &lt;a href=&quot;set_policy&quot;&gt; &lt;code&gt;tf.keras.mixed_precision.experimental.set_policy&lt;/code&gt; &lt;/a&gt; se puede utilizar para establecer la pol&amp;iacute;tica predeterminada para las capas si no se les pasa ninguna pol&amp;iacute;tica. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="e3bc90b596c6a06641f646fd21855a01a15f891a" translate="yes" xml:space="preserve">
          <source>To use partial execution, a user first calls &lt;code&gt;partial_run_setup()&lt;/code&gt; and then a sequence of &lt;code&gt;partial_run()&lt;/code&gt;. &lt;code&gt;partial_run_setup&lt;/code&gt; specifies the list of feeds and fetches that will be used in the subsequent &lt;code&gt;partial_run&lt;/code&gt; calls.</source>
          <target state="translated">Para usar la ejecuci&amp;oacute;n parcial, un usuario primero llama a la ejecuci&amp;oacute;n parcial &lt;code&gt;partial_run_setup()&lt;/code&gt; y luego a una secuencia de ejecuci&amp;oacute;n parcial &lt;code&gt;partial_run()&lt;/code&gt; . &lt;code&gt;partial_run_setup&lt;/code&gt; especifica la lista de feeds y recuperaciones que se utilizar&amp;aacute;n en las siguientes llamadas de &lt;code&gt;partial_run&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0486110c8c71e38a21a240cd6d1c94b9eb3a8e49" translate="yes" xml:space="preserve">
          <source>To use the pprof file:</source>
          <target state="translated">Para usar el archivo pprof:</target>
        </trans-unit>
        <trans-unit id="77972f247631f66b18016dae59b6ae8450d1266a" translate="yes" xml:space="preserve">
          <source>To use the replacement for variables which does not have these issues:</source>
          <target state="translated">Usar el reemplazo de las variables que no tienen estos problemas:</target>
        </trans-unit>
        <trans-unit id="49e82f46abbf85f6d932a9d996d53b01fa3132b2" translate="yes" xml:space="preserve">
          <source>To use this API on TPU you should use a custom training loop. Below is an example of a training and evaluation step:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9fed22a474957718b6e8cceaa345a94b692ff2f" translate="yes" xml:space="preserve">
          <source>To use, enqueue filenames in a Queue. The output of Read will be a filename (key) and the contents of that file (value).</source>
          <target state="translated">Para usar,poner en cola los nombres de los archivos en una cola.La salida de Read será un nombre de archivo (clave)y el contenido de ese archivo (valor).</target>
        </trans-unit>
        <trans-unit id="22500ae27d7e8f143eaf335c0b5e17ab00f9b916" translate="yes" xml:space="preserve">
          <source>To use, enqueue filenames in a Queue. The output of ReaderRead will be a filename (key) and the contents of that file (value).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="936bb6e71e849ce05ab2a85d8c98f04120f3012d" translate="yes" xml:space="preserve">
          <source>To use, enqueue strings in a Queue. Read will take the front work string and output (work, work).</source>
          <target state="translated">Para usar,coloque las cuerdas en una cola.Leer tomará la cadena de trabajo frontal y la salida (trabajo,trabajo).</target>
        </trans-unit>
        <trans-unit id="c154b7f61f883ef570a45770d3ff51fd323c7da3" translate="yes" xml:space="preserve">
          <source>To use, enqueue strings in a Queue. ReaderRead will take the front work string and output (work, work).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b5c6be676ffa47f64b992a379fa3a687addb427" translate="yes" xml:space="preserve">
          <source>To warm-start an &lt;code&gt;Estimator&lt;/code&gt;:</source>
          <target state="translated">Para iniciar un &lt;code&gt;Estimator&lt;/code&gt; caliente :</target>
        </trans-unit>
        <trans-unit id="4e303367b1554b64249c563b8cdde01d47543e39" translate="yes" xml:space="preserve">
          <source>ToBool</source>
          <target state="translated">ToBool</target>
        </trans-unit>
        <trans-unit id="487247adcb71f2786b8b26a837b3a8f982eb5eb2" translate="yes" xml:space="preserve">
          <source>Toeplitz and Circulant Matrices - A Review: &lt;a href=&quot;https://www.nowpublishers.com/article/Details/CIT-006&quot;&gt;Gray, 2006&lt;/a&gt; (&lt;a href=&quot;https://ee.stanford.edu/%7Egray/toeplitz.pdf&quot;&gt;pdf&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33d27663923e948257deb0ac3f48e158f539a021" translate="yes" xml:space="preserve">
          <source>Toeplitz means that &lt;code&gt;A&lt;/code&gt; has constant diagonals. Hence, &lt;code&gt;A&lt;/code&gt; can be generated with two vectors. One represents the first column of the matrix, and the other represents the first row.</source>
          <target state="translated">Toeplitz significa que &lt;code&gt;A&lt;/code&gt; tiene diagonales constantes. Por tanto, &lt;code&gt;A&lt;/code&gt; se puede generar con dos vectores. Uno representa la primera columna de la matriz y el otro representa la primera fila.</target>
        </trans-unit>
        <trans-unit id="0b92ef92f904efdaf4c897b9d82c8d8bc711a6dd" translate="yes" xml:space="preserve">
          <source>Top K categorical accuracy value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00a0204649835b513c94e7dcd17a04a18748c48f" translate="yes" xml:space="preserve">
          <source>TopK</source>
          <target state="translated">TopK</target>
        </trans-unit>
        <trans-unit id="9be91f59904e4556becc788662db35f00e8e37f9" translate="yes" xml:space="preserve">
          <source>TopKV2</source>
          <target state="translated">TopKV2</target>
        </trans-unit>
        <trans-unit id="ecc5f00336dd7a221505890680888796ae7ad79b" translate="yes" xml:space="preserve">
          <source>Total length of printed lines (e.g. set this to adapt the display to different terminal window sizes).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18b8da40b59609823f34b2eae31c92eb13b8a1df" translate="yes" xml:space="preserve">
          <source>Total number of steps (batches of samples) before declaring the prediction round finished. Ignored with the default value of &lt;code&gt;None&lt;/code&gt;. If x is a &lt;a href=&quot;../../data&quot;&gt;&lt;code&gt;tf.data&lt;/code&gt;&lt;/a&gt; dataset and &lt;code&gt;steps&lt;/code&gt; is None, &lt;code&gt;predict&lt;/code&gt; will run until the input dataset is exhausted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d64736c6b92cc8a7d61eecd538f81edd562b347c" translate="yes" xml:space="preserve">
          <source>Total number of steps (batches of samples) before declaring the prediction round finished. Ignored with the default value of &lt;code&gt;None&lt;/code&gt;. If x is a &lt;a href=&quot;../data&quot;&gt;&lt;code&gt;tf.data&lt;/code&gt;&lt;/a&gt; dataset and &lt;code&gt;steps&lt;/code&gt; is None, &lt;code&gt;predict&lt;/code&gt; will run until the input dataset is exhausted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9b71747c87f2120b712f35eff6cd2daf9f890ef" translate="yes" xml:space="preserve">
          <source>Total number of steps expected, None if unknown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b273e7fcad30a2510d0545ec0ed37f53fcc2226" translate="yes" xml:space="preserve">
          <source>Total number of tasks/workers/replicas, could be different from replicas_to_aggregate. If total_num_replicas &amp;gt; replicas_to_aggregate: it is backup_replicas + replicas_to_aggregate. If total_num_replicas &amp;lt; replicas_to_aggregate: Replicas compute multiple batches per update to variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c766217ff2603fec7b0d19fd0e734ed0a36b0a6" translate="yes" xml:space="preserve">
          <source>Trace events are created only when the profiler is enabled. More information on how to use the profiler can be found at &lt;a href=&quot;https://tensorflow.org/guide/profiler&quot;&gt;https://tensorflow.org/guide/profiler&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="121fe412af2d5e916662ca3ec0794ef40b1e2f67" translate="yes" xml:space="preserve">
          <source>Trace of the linear operator, equal to sum of &lt;code&gt;self.diag_part()&lt;/code&gt;.</source>
          <target state="translated">Traza del operador lineal, igual a la suma de &lt;code&gt;self.diag_part()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="865739f4547ef1507e787549027075c5e994644c" translate="yes" xml:space="preserve">
          <source>Trace the function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36823bd4f0f4f117aef52940f9d3cfb4969f8d54" translate="yes" xml:space="preserve">
          <source>Trace the function, see the &lt;a href=&quot;https://www.tensorflow.org/guide/concrete_function&quot;&gt;Concrete Functions Guide&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3cd08d7e53167c39ff4df8ac6fd7573ac51ea11" translate="yes" xml:space="preserve">
          <source>Traces argument information at compilation time.</source>
          <target state="translated">Rastrea la información del argumento en el momento de la compilación.</target>
        </trans-unit>
        <trans-unit id="0eed61bd40a0f60d630ca02fa135c76ba2b343a8" translate="yes" xml:space="preserve">
          <source>Tracing may fail if a shape missmatch can be detected:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="235a91222dd28e8e16c0e133dc2cba6c6d12742f" translate="yes" xml:space="preserve">
          <source>Train a linear model to classify instances into one of multiple possible classes. When number of possible classes is 2, this is binary classification.</source>
          <target state="translated">Entrenar un modelo lineal para clasificar las instancias en una de las múltiples clases posibles.Cuando el número de clases posibles es 2,esta es una clasificación binaria.</target>
        </trans-unit>
        <trans-unit id="ee3c9790cb66e90ecfd717511a371fde17bac07c" translate="yes" xml:space="preserve">
          <source>Train a linear regression model to predict label value given observation of feature values.</source>
          <target state="translated">Entrenar un modelo de regresión lineal para predecir el valor de la etiqueta dada la observación de los valores de las características.</target>
        </trans-unit>
        <trans-unit id="3efa73c7139b833a96e690294f1f5dee0c8dafcf" translate="yes" xml:space="preserve">
          <source>Train and evaluate the &lt;code&gt;estimator&lt;/code&gt;.</source>
          <target state="translated">Entrene y eval&amp;uacute;e al &lt;code&gt;estimator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="beb3053fd8366acd014d9b2f3ece6098b4b72e55" translate="yes" xml:space="preserve">
          <source>Train and evaluate with Keras</source>
          <target state="translated">Entrena y evalúa con Keras</target>
        </trans-unit>
        <trans-unit id="cc6f15e9d8d0df93c841a4bfbdce1ebcc8b8e338" translate="yes" xml:space="preserve">
          <source>Trainable variables (created by &lt;a href=&quot;variable&quot;&gt;&lt;code&gt;tf.Variable&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;compat/v1/get_variable&quot;&gt;&lt;code&gt;tf.compat.v1.get_variable&lt;/code&gt;&lt;/a&gt;, where &lt;code&gt;trainable=True&lt;/code&gt; is default in both cases) are automatically watched. Tensors can be manually watched by invoking the &lt;code&gt;watch&lt;/code&gt; method on this context manager.</source>
          <target state="translated">Las variables entrenables (creadas por &lt;a href=&quot;variable&quot;&gt; &lt;code&gt;tf.Variable&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;compat/v1/get_variable&quot;&gt; &lt;code&gt;tf.compat.v1.get_variable&lt;/code&gt; &lt;/a&gt; , donde &lt;code&gt;trainable=True&lt;/code&gt; es el valor predeterminado en ambos casos) se miran autom&amp;aacute;ticamente. Los tensores se pueden observar manualmente invocando el m&amp;eacute;todo de &lt;code&gt;watch&lt;/code&gt; en este administrador de contexto.</target>
        </trans-unit>
        <trans-unit id="d85aa0db75043b2fc7e6d076a658d6108e846757" translate="yes" xml:space="preserve">
          <source>Training checkpoints</source>
          <target state="translated">Los puntos de control de entrenamiento</target>
        </trans-unit>
        <trans-unit id="10de55a426007543588aad0c26e9034f2ddc3a47" translate="yes" xml:space="preserve">
          <source>Training graph visualization</source>
          <target state="translated">Visualización del gráfico de entrenamiento</target>
        </trans-unit>
        <trans-unit id="7db0d855207cb66583c78145b39525c5633639da" translate="yes" xml:space="preserve">
          <source>Training helper that restores from checkpoint and creates session.</source>
          <target state="translated">Ayudante de entrenamiento que restaura desde el punto de control y crea sesión.</target>
        </trans-unit>
        <trans-unit id="fb6f2aff4ed7bb3a59f319dbd5466e071cc53fba" translate="yes" xml:space="preserve">
          <source>Training loss &lt;code&gt;Tensor&lt;/code&gt;. Must be either scalar, or with shape &lt;code&gt;[1]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7079a2991739ec717b2df9e546127d4ec5f23f66" translate="yes" xml:space="preserve">
          <source>Training step to trigger on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf6759c44ad41b3091516c81e1bc49fed1c443ea" translate="yes" xml:space="preserve">
          <source>Trains a model given training data &lt;code&gt;input_fn&lt;/code&gt;.</source>
          <target state="translated">Entrena un modelo dados los datos de entrenamiento &lt;code&gt;input_fn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b7a7a43991418e3ac5adb5f5a2111146e234e48" translate="yes" xml:space="preserve">
          <source>Trains a recurrent neural network model to classify instances into one of multiple classes.</source>
          <target state="translated">Entrena un modelo de red neural recurrente para clasificar las instancias en una de varias clases.</target>
        </trans-unit>
        <trans-unit id="03d8eb1e5694e7e09ad702ee89cbe5988334450c" translate="yes" xml:space="preserve">
          <source>Trains the model for a fixed number of epochs (iterations on a dataset).</source>
          <target state="translated">Entrena el modelo para un número fijo de épocas (iteraciones en un conjunto de datos).</target>
        </trans-unit>
        <trans-unit id="e5238d35744e76f113cfe81d17fbfa29f295ac05" translate="yes" xml:space="preserve">
          <source>Transcode the input text from a source encoding to a destination encoding.</source>
          <target state="translated">Transcodificar el texto de entrada de una codificación de origen a una codificación de destino.</target>
        </trans-unit>
        <trans-unit id="983dff86700d17b79a819dfaab7edfc9d23e3e22" translate="yes" xml:space="preserve">
          <source>Transfer learning with TensorFlow Hub</source>
          <target state="translated">Transferir el aprendizaje con TensorFlow Hub</target>
        </trans-unit>
        <trans-unit id="db752c46f6cefcfd15e6ab5a7acbda3b3ec8bdb7" translate="yes" xml:space="preserve">
          <source>Transfer learning with a pretrained ConvNet</source>
          <target state="translated">Transfiera el aprendizaje con un ConvNet preformado</target>
        </trans-unit>
        <trans-unit id="d3f4cdda163a694c3d7aafb554148d5d45b68f92" translate="yes" xml:space="preserve">
          <source>Transform [batch] matrix &lt;code&gt;x&lt;/code&gt; with left multiplication: &lt;code&gt;x --&amp;gt; Ax&lt;/code&gt;.</source>
          <target state="translated">Transforme la matriz de [lote] &lt;code&gt;x&lt;/code&gt; con la multiplicaci&amp;oacute;n por la izquierda: &lt;code&gt;x --&amp;gt; Ax&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="42db4158efb02ff54237870e3243b8f49a10cb88" translate="yes" xml:space="preserve">
          <source>Transform [batch] vector &lt;code&gt;x&lt;/code&gt; with left multiplication: &lt;code&gt;x --&amp;gt; Ax&lt;/code&gt;.</source>
          <target state="translated">Transforme el vector &lt;code&gt;x&lt;/code&gt; [lote] con la multiplicaci&amp;oacute;n por la izquierda: &lt;code&gt;x --&amp;gt; Ax&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d685ad7c59aeb1945ef867b52857539b62c1b81c" translate="yes" xml:space="preserve">
          <source>Transformations</source>
          <target state="translated">Transformations</target>
        </trans-unit>
        <trans-unit id="74bb10df9a38f2595c0a343bb271e614fdcbbc79" translate="yes" xml:space="preserve">
          <source>Transformations:</source>
          <target state="translated">Transformations:</target>
        </trans-unit>
        <trans-unit id="a65cfd47338728767e1d8fe389f325154f22e3d2" translate="yes" xml:space="preserve">
          <source>Transformer model for language understanding</source>
          <target state="translated">Modelo transformador para la comprensión del lenguaje</target>
        </trans-unit>
        <trans-unit id="c6c688b7b4f9c9a55098909d8e4bbea04f915bb0" translate="yes" xml:space="preserve">
          <source>Transforms &lt;code&gt;elems&lt;/code&gt; by applying &lt;code&gt;fn&lt;/code&gt; to each element unstacked on axis 0. (deprecated arguments)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33d02a85618ebba62b643cdb3a4e3f69d88e4866" translate="yes" xml:space="preserve">
          <source>Transforms &lt;code&gt;input_dataset&lt;/code&gt; containing &lt;code&gt;Example&lt;/code&gt; protos as vectors of DT_STRING into a dataset of &lt;code&gt;Tensor&lt;/code&gt; or &lt;code&gt;SparseTensor&lt;/code&gt; objects representing the parsed features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae192d97c8bb43adae60e73f077c7a262798214c" translate="yes" xml:space="preserve">
          <source>Transforms a Tensor into a serialized TensorProto proto.</source>
          <target state="translated">Transforma un Tensor en un prototipo TensorProto serializado.</target>
        </trans-unit>
        <trans-unit id="4999b7a71f3c11d96be3e3808c9e8fc9eb261a51" translate="yes" xml:space="preserve">
          <source>Transforms a scalar brain.SequenceExample proto (as strings) into typed tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fe37f8377ecffffde4f3405645d41e0b3b001bd" translate="yes" xml:space="preserve">
          <source>Transforms a serialized tensorflow.TensorProto proto into a Tensor.</source>
          <target state="translated">Transforma un prototipo de TensorProto en un Tensor.</target>
        </trans-unit>
        <trans-unit id="f6ffa885d4348734b93da08e4df5eb979eae50df" translate="yes" xml:space="preserve">
          <source>Transforms a spectrogram into a form that's useful for speech recognition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd2f17793a2563570a330d4671f70e89b2937951" translate="yes" xml:space="preserve">
          <source>Transforms a tf.Example proto (as a string) into typed tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b8677520a5e74e9b4b4788602fe7bc1e6fe1360" translate="yes" xml:space="preserve">
          <source>Transforms a vector of brain.Example protos (as strings) into typed tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be5a4de021d7eadbe941c3409ada3c7b1dabaea1" translate="yes" xml:space="preserve">
          <source>Transforms a vector of brain.SequenceExample protos (as strings) into typed tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb363dfb8e50cc87a12a26568447baf08e0619fb" translate="yes" xml:space="preserve">
          <source>Transforms a vector of tf.Example protos (as strings) into typed tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db88575dec31c88470bf932dd1fed9370a7d6c45" translate="yes" xml:space="preserve">
          <source>Transforms a vector of tf.io.SequenceExample protos (as strings) into</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="655ffb734eb7a488c9c872982dd743f0f56654c3" translate="yes" xml:space="preserve">
          <source>Transforms each input point to its distances to all cluster centers.</source>
          <target state="translated">Transforma cada punto de entrada a sus distancias a todos los centros de los cúmulos.</target>
        </trans-unit>
        <trans-unit id="fcd8235ad6fe846d496fe3b5ab9ef987b5075ab1" translate="yes" xml:space="preserve">
          <source>Transforms each sequence in &lt;code&gt;sequences&lt;/code&gt; to a list of texts(strings).</source>
          <target state="translated">Transforma cada secuencia en &lt;code&gt;sequences&lt;/code&gt; en una lista de textos (cadenas).</target>
        </trans-unit>
        <trans-unit id="e5d4ddf915c1a321118b7e1927e1abe917834a51" translate="yes" xml:space="preserve">
          <source>Transforms each sequence into a list of text.</source>
          <target state="translated">Transforma cada secuencia en una lista de texto.</target>
        </trans-unit>
        <trans-unit id="15870f729495d9cc692bfd46436e8e2286a88257" translate="yes" xml:space="preserve">
          <source>Transforms each text in &lt;code&gt;texts&lt;/code&gt; to a sequence of integers.</source>
          <target state="translated">Transforma cada texto en &lt;code&gt;texts&lt;/code&gt; en una secuencia de n&amp;uacute;meros enteros.</target>
        </trans-unit>
        <trans-unit id="86add4b4e27d9c231884be5bf0ca73d7ca67d517" translate="yes" xml:space="preserve">
          <source>Transforms each text in texts to a sequence of integers.</source>
          <target state="translated">Transforma cada texto en textos en una secuencia de números enteros.</target>
        </trans-unit>
        <trans-unit id="71016bf2a8086e5adaa42aba0ed39ec30d8c82a3" translate="yes" xml:space="preserve">
          <source>Transparently swap the tensors produced in forward inference but needed for back prop from GPU to CPU. This allows training RNNs which would typically not fit on a single GPU, with very minimal (or no) performance penalty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa257429d8539a08df2ef78919507d4169cac2c8" translate="yes" xml:space="preserve">
          <source>Transpose</source>
          <target state="translated">Transpose</target>
        </trans-unit>
        <trans-unit id="c6f3940520a66558ccbf4deb29b8ad759ce2893f" translate="yes" xml:space="preserve">
          <source>Transpose image(s) by swapping the height and width dimension.</source>
          <target state="translated">Transponer la(s)imagen(es)intercambiando la dimensión de altura y anchura.</target>
        </trans-unit>
        <trans-unit id="aaef5878a51828ef045b24256f979251b2fa2f09" translate="yes" xml:space="preserve">
          <source>Transposed 2D convolution layer (sometimes called 2D Deconvolution).</source>
          <target state="translated">Capa de convolución 2D transpuesta (a veces llamada Deconvolución 2D).</target>
        </trans-unit>
        <trans-unit id="20b55b4579cc2c500b14b1401912fc234412af61" translate="yes" xml:space="preserve">
          <source>Transposed 3D convolution layer (sometimes called 3D Deconvolution).</source>
          <target state="translated">Capa de convolución 3D transpuesta (a veces llamada Deconvolución 3D).</target>
        </trans-unit>
        <trans-unit id="8af454b225f62d0dcbcdc7d510f5d2a829dab734" translate="yes" xml:space="preserve">
          <source>Transposed convolution layer (sometimes called Deconvolution).</source>
          <target state="translated">Capa de convolución transpuesta (a veces llamada Deconvolución).</target>
        </trans-unit>
        <trans-unit id="c1808bb1215e7e8c12e0e53a29ab899fd06887f1" translate="yes" xml:space="preserve">
          <source>Transposes &lt;code&gt;a&lt;/code&gt;, where &lt;code&gt;a&lt;/code&gt; is a Tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4559d9f372084e43321f8c8b67aa21b4b3be2db7" translate="yes" xml:space="preserve">
          <source>Transposes &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Transpone &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f6a95a7cfa0d75e4317493ed12e7c428f7e9164" translate="yes" xml:space="preserve">
          <source>Transposes a &lt;code&gt;SparseTensor&lt;/code&gt;</source>
          <target state="translated">Transpone un &lt;code&gt;SparseTensor&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2262bf9a92872de90cc8f31b3040779445c53825" translate="yes" xml:space="preserve">
          <source>Transposes a tensor and returns it.</source>
          <target state="translated">Transpone un tensor y lo devuelve.</target>
        </trans-unit>
        <trans-unit id="52d7d3690c76e45b3f4ac6d7704301666eae2d1f" translate="yes" xml:space="preserve">
          <source>Transposes last two dimensions of tensor &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Transpone las dos &amp;uacute;ltimas dimensiones del tensor &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9979dd1e79bbad4d151836984b737dcb27347af2" translate="yes" xml:space="preserve">
          <source>Transposes the inner (matrix) dimensions of a CSRSparseMatrix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3011a7a9922254d6bc94cbf852ba13e1faec6347" translate="yes" xml:space="preserve">
          <source>Transposes the inner (matrix) dimensions of a SparseMatrix and optionally conjugates its values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad508b5e8ca6e24e73ed31c06d7f5a032986b9fa" translate="yes" xml:space="preserve">
          <source>Transposes the last two dimensions of and conjugates tensor &lt;code&gt;matrix&lt;/code&gt;.</source>
          <target state="translated">Transpone las dos &amp;uacute;ltimas dimensiones de y conjuga la &lt;code&gt;matrix&lt;/code&gt; tensorial .</target>
        </trans-unit>
        <trans-unit id="50adcae727c1540c5f8c2710b6a31d5f9d861f46" translate="yes" xml:space="preserve">
          <source>TridiagonalMatMul</source>
          <target state="translated">TridiagonalMatMul</target>
        </trans-unit>
        <trans-unit id="90d5236e355acbf1f60d52716bcd6f0402f00405" translate="yes" xml:space="preserve">
          <source>TridiagonalSolve</source>
          <target state="translated">TridiagonalSolve</target>
        </trans-unit>
        <trans-unit id="06d45be632bf282d211af84cbad96e7a33a03b23" translate="yes" xml:space="preserve">
          <source>Trouser</source>
          <target state="translated">Trouser</target>
        </trans-unit>
        <trans-unit id="afd4d25dce087075230a2ce40818eed7a8b7c821" translate="yes" xml:space="preserve">
          <source>True and exponential_avg_factor != 1.0: Mean must be a &lt;code&gt;Tensor&lt;/code&gt; of the same shape as scale containing the exponential running mean.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0904ca48cae02b60d23262abfe2ce903cfefb1e" translate="yes" xml:space="preserve">
          <source>True and exponential_avg_factor == 1.0: Mean must be None. is_training</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c2872020c8add34a2cf2fcba50775a603f0d0e2" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;v&lt;/code&gt; was created inside the scope, False if not.</source>
          <target state="translated">Verdadero si &lt;code&gt;v&lt;/code&gt; se cre&amp;oacute; dentro del alcance, falso si no.</target>
        </trans-unit>
        <trans-unit id="ea6d3038da7212df43580d700019b440b6df39f7" translate="yes" xml:space="preserve">
          <source>True if a GPU device of the requested kind is available.</source>
          <target state="translated">Cierto si un dispositivo de GPU del tipo solicitado está disponible.</target>
        </trans-unit>
        <trans-unit id="0182552244a71267208d89b4ec5f7f593b52459d" translate="yes" xml:space="preserve">
          <source>True if a Tensor of the &lt;code&gt;other&lt;/code&gt;&lt;code&gt;DType&lt;/code&gt; will be implicitly converted to this &lt;code&gt;DType&lt;/code&gt;.</source>
          <target state="translated">Verdadero si un tensor del &lt;code&gt;other&lt;/code&gt; &lt;code&gt;DType&lt;/code&gt; se convertir&amp;aacute; impl&amp;iacute;citamente a este &lt;code&gt;DType&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d65dfa1082053356f76fa7e32f60ffc009e106a5" translate="yes" xml:space="preserve">
          <source>True if a stop was requested.</source>
          <target state="translated">Cierto si se solicitó una parada.</target>
        </trans-unit>
        <trans-unit id="fba54694bed7e972eba04ddb43445b6835518a56" translate="yes" xml:space="preserve">
          <source>True if inside a &lt;code&gt;with strategy.scope():&lt;/code&gt;.</source>
          <target state="translated">Es cierto que si un interior &lt;code&gt;with strategy.scope():&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d356c240016a0c32cb15a7f51543e8af63f4aad" translate="yes" xml:space="preserve">
          <source>True if spec_or_tensor is compatible with self.</source>
          <target state="translated">Cierto si el espec_o_tensor es compatible con el yo.</target>
        </trans-unit>
        <trans-unit id="f031713f493f44a87f541097d9a6c4633a7c4174" translate="yes" xml:space="preserve">
          <source>True if the Coordinator is told stop, False if the timeout expired.</source>
          <target state="translated">Cierto si se le dice al Coordinador que se detenga,Falso si el tiempo de espera expiró.</target>
        </trans-unit>
        <trans-unit id="40e3b3363df1be71fab94fcf563145f01a88073c" translate="yes" xml:space="preserve">
          <source>True if the caller can expect that serialized TensorFlow graphs produced can be consumed by programs that are compiled with the TensorFlow library source code after (year, month, day).</source>
          <target state="translated">Cierto si el llamante puede esperar que los gráficos serializados de TensorFlow producidos pueden ser consumidos por programas que son compilados con el código fuente de la biblioteca de TensorFlow después (año,mes,día).</target>
        </trans-unit>
        <trans-unit id="5bee156ad7270160152bb6dbabfb7781157fb705" translate="yes" xml:space="preserve">
          <source>True if the constructor is being called by one of the factory methods. If false, an exception will be raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4faef914883a1a10aa15778c49f35fb98be8732e" translate="yes" xml:space="preserve">
          <source>True if the coordinator was told to stop, False otherwise.</source>
          <target state="translated">Cierto si se le dijo al coordinador que se detuviera,falso si no.</target>
        </trans-unit>
        <trans-unit id="41bb9eed11faf580e5cf2243f1284401f224c42a" translate="yes" xml:space="preserve">
          <source>True if the difference between the current time and the time of the last trigger exceeds &lt;code&gt;every_secs&lt;/code&gt;, or if the difference between the current step and the last triggered step exceeds &lt;code&gt;every_steps&lt;/code&gt;. False otherwise.</source>
          <target state="translated">Verdadero si la diferencia entre la hora actual y la hora del &amp;uacute;ltimo disparo excede &lt;code&gt;every_secs&lt;/code&gt; , o si la diferencia entre el paso actual y el &amp;uacute;ltimo paso disparado excede &lt;code&gt;every_steps&lt;/code&gt; . Falso de lo contrario.</target>
        </trans-unit>
        <trans-unit id="bfc13f68b704941e80142d04a3ed7c6629e6c664" translate="yes" xml:space="preserve">
          <source>True if the export directory contains SavedModel files, False otherwise.</source>
          <target state="translated">Cierto si el directorio de exportación contiene archivos de SavedModel,falso si no.</target>
        </trans-unit>
        <trans-unit id="6a900b62e1edba1c0e27907e12139238da6afb94" translate="yes" xml:space="preserve">
          <source>True if the given node must run on CPU, otherwise False.</source>
          <target state="translated">Cierto si el nodo dado debe funcionar en la CPU,de lo contrario Falso.</target>
        </trans-unit>
        <trans-unit id="e5ad15e25e43eb5bd9cd393c44c117efba29c6f6" translate="yes" xml:space="preserve">
          <source>True if the path exists, whether it's a file or a directory. False if the path does not exist and there are no filesystem errors.</source>
          <target state="translated">Cierto si la ruta existe,ya sea un archivo o un directorio.Falso si la ruta no existe y no hay errores en el sistema de archivos.</target>
        </trans-unit>
        <trans-unit id="2817ab94bf3761a7902a64b969f4ce8bf858694f" translate="yes" xml:space="preserve">
          <source>True if the quantization is signed or unsigned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12521f184e32516a21dbe08fda414904f64f4716" translate="yes" xml:space="preserve">
          <source>True if the queue is closed and false if the queue is open.</source>
          <target state="translated">Verdadero si la cola está cerrada y falso si la cola está abierta.</target>
        </trans-unit>
        <trans-unit id="8a6738c31462b3c1cdd66322c6255be278594bf2" translate="yes" xml:space="preserve">
          <source>True if the reader implementation can serialize its state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3d692e2a1a03f9a580cbe6af7887c076366f28a" translate="yes" xml:space="preserve">
          <source>True if the sequence is a not a string and is a collections.abc.Sequence or a dict.</source>
          <target state="translated">Cierto si la secuencia no es una cadena y es una colección.abc.Sequencia o un dictado.</target>
        </trans-unit>
        <trans-unit id="e846d2ffe93240497692f8c335b561f9a3b5ca4b" translate="yes" xml:space="preserve">
          <source>True if this Dimension and &lt;code&gt;other&lt;/code&gt; are compatible.</source>
          <target state="translated">Cierto si esta dimensi&amp;oacute;n y &lt;code&gt;other&lt;/code&gt; son compatibles.</target>
        </trans-unit>
        <trans-unit id="1af9f77f297353d13cc2052ce5add84a77143e29" translate="yes" xml:space="preserve">
          <source>True if this graph has been finalized.</source>
          <target state="translated">Cierto si este gráfico ha sido finalizado.</target>
        </trans-unit>
        <trans-unit id="13ac567ddd78dbff91bfa15ccdc8c27002125b9d" translate="yes" xml:space="preserve">
          <source>True iff &lt;code&gt;self&lt;/code&gt; is compatible with &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">Verdadero si el &lt;code&gt;self&lt;/code&gt; es compatible con los &lt;code&gt;other&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ea2041726102a7cb24768511dc474dfc2d2086e" translate="yes" xml:space="preserve">
          <source>True iff at most one predicate is allowed to evaluate to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84ec63366604b21f0a1cd748c6c806b8cc035002" translate="yes" xml:space="preserve">
          <source>True on success, or false if no summary was emitted because no default summary writer was available.</source>
          <target state="translated">Verdadero en el éxito,o falso si no se emitió un resumen porque no se disponía de un escritor de resúmenes por defecto.</target>
        </trans-unit>
        <trans-unit id="fc591d62fe392ab5c3a30eaf5e21967f39695530" translate="yes" xml:space="preserve">
          <source>True on success, or false if no summary was written because no default summary writer was available.</source>
          <target state="translated">Verdadero en el éxito,o falso si no se escribió un resumen porque no había un escritor de resumen predeterminado disponible.</target>
        </trans-unit>
        <trans-unit id="c5ce5b285e7cceb24195ca6aafbc51395c9eec5d" translate="yes" xml:space="preserve">
          <source>True tries extracting the file as an Archive, like tar or zip.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64eb5b8ece15c07598a0a8b6e044d88bd144975f" translate="yes" xml:space="preserve">
          <source>True, False or None. None restores the default behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f16aacc072df96e8b74050ff74d241c633ad1f94" translate="yes" xml:space="preserve">
          <source>True, if the path is a directory; False otherwise</source>
          <target state="translated">Cierto,si la ruta es un directorio;falso en caso contrario</target>
        </trans-unit>
        <trans-unit id="b14f591e5a76ce927e3d51f5d369ecadec7b9175" translate="yes" xml:space="preserve">
          <source>True, if variables should be casted.</source>
          <target state="translated">Cierto,si las variables deben ser proyectadas.</target>
        </trans-unit>
        <trans-unit id="0398d49e6ea66afbb212b36d04e2616800d64ac3" translate="yes" xml:space="preserve">
          <source>True: executes each operation synchronously.</source>
          <target state="translated">Cierto:ejecuta cada operación de forma sincronizada.</target>
        </trans-unit>
        <trans-unit id="4a2f0a78e05a23faa43333403bbc8e7bb4a127d9" translate="yes" xml:space="preserve">
          <source>TruncateDiv</source>
          <target state="translated">TruncateDiv</target>
        </trans-unit>
        <trans-unit id="88d5fe1e339e14bfa5e83a1a1041f877f78fa654" translate="yes" xml:space="preserve">
          <source>TruncateMod</source>
          <target state="translated">TruncateMod</target>
        </trans-unit>
        <trans-unit id="5b6f413272cd888b5af448b50b30ef69c71b431f" translate="yes" xml:space="preserve">
          <source>TruncatedNormal</source>
          <target state="translated">TruncatedNormal</target>
        </trans-unit>
        <trans-unit id="4d9fd66a7778c40e3dba2083356a599b52f25d88" translate="yes" xml:space="preserve">
          <source>Truncation designates that negative numbers will round fractional quantities toward zero. I.e. -7 / 5 = -1. This matches C semantics but it is different than Python semantics. See &lt;code&gt;FloorDiv&lt;/code&gt; for a division function that matches Python Semantics.</source>
          <target state="translated">El truncamiento designa que los n&amp;uacute;meros negativos redondear&amp;aacute;n cantidades fraccionarias hacia cero. Es decir, -7 / 5 = -1. Esto coincide con la sem&amp;aacute;ntica de C pero es diferente a la sem&amp;aacute;ntica de Python. Consulte &lt;code&gt;FloorDiv&lt;/code&gt; para ver una funci&amp;oacute;n de divisi&amp;oacute;n que coincide con Python Semantics.</target>
        </trans-unit>
        <trans-unit id="aa758b468b210aad3c052427b42a0c7ac48798f6" translate="yes" xml:space="preserve">
          <source>Tuple in the format used in &lt;a href=&quot;../model#fit&quot;&gt;&lt;code&gt;Model.fit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c85382570b1156fafff522dc38424cdd757186e" translate="yes" xml:space="preserve">
          <source>Tuple of 2 integers, how many zeros to add at the start and end of dim 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d878205ddde8c656cd0c2ec819ef9a66c6db3326" translate="yes" xml:space="preserve">
          <source>Tuple of 2 integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e902bb2fc5cab147bc391e40439b73d1a642c42" translate="yes" xml:space="preserve">
          <source>Tuple of 2 tuples, padding pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e0b6b48776191185766960be076280c767a6bcd" translate="yes" xml:space="preserve">
          <source>Tuple of 3 integers, factors by which to downscale (dim1, dim2, dim3). &lt;code&gt;(2, 2, 2)&lt;/code&gt; will halve the size of the 3D input in each dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2a3aa7cb19c709e2aeca6ab2c5fbdce9372f47c" translate="yes" xml:space="preserve">
          <source>Tuple of 3 tuples, padding pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b36302f1d8a1cd0c40fa6d16b6fe2aaaa964f68" translate="yes" xml:space="preserve">
          <source>Tuple of Numpy arrays: &lt;code&gt;(x_train, y_train), (x_test, y_test)&lt;/code&gt;.</source>
          <target state="translated">Tupla de matrices Numpy: &lt;code&gt;(x_train, y_train), (x_test, y_test)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5fcb3189bbbad2089b9134f58fe7fca941f8a70" translate="yes" xml:space="preserve">
          <source>Tuple of integers &lt;code&gt;(height, width)&lt;/code&gt;, defaults to &lt;code&gt;(256, 256)&lt;/code&gt;. The dimensions to which all images found will be resized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80e3a7c1e14386c2b20631926430b4d65ddfff1f" translate="yes" xml:space="preserve">
          <source>Tuple of integers representing (min, max) range values for all arrays without a specified range. Intended for experimenting with quantization via &quot;dummy quantization&quot;. (default None)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e26526855fdb022129c7cbbd982fef1427fddb1" translate="yes" xml:space="preserve">
          <source>Tuple of integers, shape of returned Keras variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8ec74a912c043af498fdebd5ada0cb4d060e6f5" translate="yes" xml:space="preserve">
          <source>Tuple of integers. Permutation pattern does not include the samples dimension. Indexing starts at 1. For instance, &lt;code&gt;(2, 1)&lt;/code&gt; permutes the first and second dimensions of the input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d1f41be26f53eaa6f970fca60630a6f21855e44" translate="yes" xml:space="preserve">
          <source>Tuple of strings representing input tensor names and list of integers representing input shapes (e.g., [(&quot;foo&quot; : [1, 16, 16, 3])]). Use only when graph cannot be loaded into TensorFlow and when &lt;code&gt;input_tensors&lt;/code&gt; and &lt;code&gt;output_tensors&lt;/code&gt; are None. (default None)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cbc0064b79f9aa3d7ea238c4e18ad22b86f3acb" translate="yes" xml:space="preserve">
          <source>Tuple or list of integers with target dimensions, or single integer. The sizes of &lt;code&gt;x.shape[axes[0]]&lt;/code&gt; and &lt;code&gt;y.shape[axes[1]]&lt;/code&gt; should be equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="082793c3bba9dd17881797f57bdfd7fbb926fad6" translate="yes" xml:space="preserve">
          <source>Tuple or list of integers, shape of returned Keras variable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4531a58c8012cfb70552795a6d42bd391095a246" translate="yes" xml:space="preserve">
          <source>Tuple or list of two floats. Range for picking a brightness shift value from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcd91650680c7044999f313873fe057ab50db675" translate="yes" xml:space="preserve">
          <source>Tuple or list with positional arguments for &lt;code&gt;fn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b33b3b3fb1f8b255b7161c80b27363774e8f88ed" translate="yes" xml:space="preserve">
          <source>Tuple or list. Additional positional arguments to pass to &lt;code&gt;fn()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2613ea839d069df0d5c8d9c5f47854631d09fc20" translate="yes" xml:space="preserve">
          <source>Tuple used by LSTM Cells for &lt;code&gt;state_size&lt;/code&gt;, &lt;code&gt;zero_state&lt;/code&gt;, and output state.</source>
          <target state="translated">Tupla utilizada por LSTM Cells para &lt;code&gt;state_size&lt;/code&gt; , &lt;code&gt;zero_state&lt;/code&gt; y estado de salida.</target>
        </trans-unit>
        <trans-unit id="5b48f912499203c94d01ac7a5a26aea7a05b21fa" translate="yes" xml:space="preserve">
          <source>Turn a nD tensor into a 2D tensor with same 0th dimension.</source>
          <target state="translated">Convierte un tensor nD en un tensor 2D con la misma dimensión 0.</target>
        </trans-unit>
        <trans-unit id="84c0c370c16aa336bb6f7381c737e4c2aba96f9e" translate="yes" xml:space="preserve">
          <source>Turns positive integers (indexes) into dense vectors of fixed size.</source>
          <target state="translated">Convierte los números enteros positivos (índices)en vectores densos de tamaño fijo.</target>
        </trans-unit>
        <trans-unit id="2c47d5c1924debfd2ddf97975d083f8b91fc55b1" translate="yes" xml:space="preserve">
          <source>Turns the serialized form of a Keras object back into an actual object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0312b13c624e55c7e9bb5fdcfe0c38b37f8b9c61" translate="yes" xml:space="preserve">
          <source>Tutorials and examples can be found in: &lt;a href=&quot;https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/profiler/g3doc/python_api.md&quot;&gt;https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/profiler/g3doc/python_api.md&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1970692bb6c07bd87f9682c04edd6a7dc8b64ed" translate="yes" xml:space="preserve">
          <source>Tutorials and examples can be found in: https://github.com/tensorflow/tensorflow/tree/master/tensorflow/core/profiler/README.md</source>
          <target state="translated">Se pueden encontrar tutoriales y ejemplos en:https://github.com/tensorflow/tensorflow/tree/master/tensorflow/core/profiler/README.md</target>
        </trans-unit>
        <trans-unit id="5392c950bdde4be7e5f5b8fdc6a1ca5f21e905cf" translate="yes" xml:space="preserve">
          <source>Twitter</source>
          <target state="translated">Twitter</target>
        </trans-unit>
        <trans-unit id="698a7f116a9d0145fa7461b0cd8612ceab6c65c3" translate="yes" xml:space="preserve">
          <source>Two 2-d numpy arrays representing the theoretical and numerical Jacobian for dy/dx. Each has &quot;x_size&quot; rows and &quot;y_size&quot; columns where &quot;x_size&quot; is the number of elements in x and &quot;y_size&quot; is the number of elements in y. If x is a list, returns a list of two numpy arrays.</source>
          <target state="translated">Dos matrices numéricas 2-d representando el teórico y numérico jacobino para dy/dx.Cada una tiene filas de &quot;x_size&quot; y columnas de &quot;y_size&quot; donde &quot;x_size&quot; es el número de elementos en x y &quot;y_size&quot; es el número de elementos en y.Si x es una lista,devuelve una lista de dos matrices numéricas.</target>
        </trans-unit>
        <trans-unit id="ba15ec3492dd4bf582b4e766b61d26647d5ffcdc" translate="yes" xml:space="preserve">
          <source>Two &lt;a href=&quot;../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; objects of type &lt;code&gt;bool&lt;/code&gt; of the same shape. In this case, the result will be the element-wise logical AND of the two input tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2f8646d6f565d2ad7fc58a15043d6c2087ee7b6" translate="yes" xml:space="preserve">
          <source>Two &lt;a href=&quot;../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; objects of type &lt;code&gt;bool&lt;/code&gt; of the same shape. In this case, the result will be the element-wise logical XOR of the two input tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e476c2f4924caa7e379cac892bc43188804bebb" translate="yes" xml:space="preserve">
          <source>Two &lt;a href=&quot;../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; objects of type &lt;code&gt;bool&lt;/code&gt; of the same shape. In this case, the result will be the element-wise logical AND of the two input tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34ab6873a8334c48d1673369412e608cd7417e10" translate="yes" xml:space="preserve">
          <source>Two &lt;a href=&quot;../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; objects of type &lt;code&gt;bool&lt;/code&gt; of the same shape. In this case, the result will be the element-wise logical XOR of the two input tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31988105748d2b29509a18eb03ac4bcf2e98951c" translate="yes" xml:space="preserve">
          <source>Two &lt;a href=&quot;tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; objects of type &lt;code&gt;bool&lt;/code&gt; of the same shape. In this case, the result will be the element-wise logical AND of the two input tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="322bef22d5ff10923c851f4887f9752d9171cff1" translate="yes" xml:space="preserve">
          <source>Two &lt;a href=&quot;tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; objects of type &lt;code&gt;bool&lt;/code&gt; of the same shape. In this case, the result will be the element-wise logical XOR of the two input tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e61ae5fa9a8a338e450ea4521d3c90e37b3fce55" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;Tensor&lt;/code&gt; objects: &lt;code&gt;mean&lt;/code&gt; and &lt;code&gt;variance&lt;/code&gt;.</source>
          <target state="translated">Dos objetos &lt;code&gt;Tensor&lt;/code&gt; : &lt;code&gt;mean&lt;/code&gt; y &lt;code&gt;variance&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18f9e0ca8006912df25de0a98edea35700ad81f2" translate="yes" xml:space="preserve">
          <source>Two accumulation steps are required: 1) the accumulation of gradients squared, 2) the accumulation of updates squared.</source>
          <target state="translated">Se requieren dos pasos de acumulación:1)la acumulación de gradientes al cuadrado,2)la acumulación de actualizaciones al cuadrado.</target>
        </trans-unit>
        <trans-unit id="a1d8ed408945a366f45477724e8c9686614ca2d7" translate="yes" xml:space="preserve">
          <source>Two different templates are guaranteed to be unique, unless you reenter the same variable scope as the initial definition of a template and redefine it. An examples of this exception:</source>
          <target state="translated">Se garantiza que dos plantillas diferentes son únicas,a menos que se vuelva a introducir el mismo alcance variable de la definición inicial de una plantilla y se redefina.Un ejemplo de esta excepción:</target>
        </trans-unit>
        <trans-unit id="641506872a34040c078fdb14eeef6b25c62c6fc9" translate="yes" xml:space="preserve">
          <source>Two generators are independent of each other in the sense that the random-number streams they generate don't have statistically detectable correlations. The new generators are also independent of the old one. The old generator's state will be changed (like other random-number generating methods), so two calls of &lt;code&gt;split&lt;/code&gt; will return different new generators.</source>
          <target state="translated">Dos generadores son independientes entre s&amp;iacute; en el sentido de que los flujos de n&amp;uacute;meros aleatorios que generan no tienen correlaciones detectables estad&amp;iacute;sticamente. Los nuevos generadores tambi&amp;eacute;n son independientes del anterior. El estado del generador anterior se cambiar&amp;aacute; (como otros m&amp;eacute;todos de generaci&amp;oacute;n de n&amp;uacute;meros aleatorios), por lo que dos llamadas de &lt;code&gt;split&lt;/code&gt; devolver&amp;aacute;n diferentes generadores nuevos.</target>
        </trans-unit>
        <trans-unit id="609ab801a6e4c68686c97569df58fbb61201051d" translate="yes" xml:space="preserve">
          <source>Two known Dimensions are compatible if they have the same value. An unknown Dimension is compatible with all other Dimensions.</source>
          <target state="translated">Dos dimensiones conocidas son compatibles si tienen el mismo valor.Una Dimensión desconocida es compatible con todas las demás Dimensiones.</target>
        </trans-unit>
        <trans-unit id="6133911db30a0e3197c09499734a8919b0cbd3bf" translate="yes" xml:space="preserve">
          <source>Two or more words may be assigned to the same index, due to possible collisions by the hashing function. The &lt;a href=&quot;https://en.wikipedia.org/wiki/Birthday_problem#Probability_table&quot;&gt;probability&lt;/a&gt; of a collision is in relation to the dimension of the hashing space and the number of distinct objects.</source>
          <target state="translated">Se pueden asignar dos o m&amp;aacute;s palabras al mismo &amp;iacute;ndice, debido a posibles colisiones de la funci&amp;oacute;n hash. La &lt;a href=&quot;https://en.wikipedia.org/wiki/Birthday_problem#Probability_table&quot;&gt;probabilidad&lt;/a&gt; de una colisi&amp;oacute;n est&amp;aacute; en relaci&amp;oacute;n con la dimensi&amp;oacute;n del espacio hash y el n&amp;uacute;mero de objetos distintos.</target>
        </trans-unit>
        <trans-unit id="aa46f48d3d26a8be473e57169e56d3f2b7f57692" translate="yes" xml:space="preserve">
          <source>Two possibly-partially-defined shapes are compatible if there exists a fully-defined shape that both shapes can represent. Thus, compatibility allows the shape inference code to reason about partially-defined shapes. For example:</source>
          <target state="translated">Dos formas posiblemente parcialmente definidas son compatibles si existe una forma totalmente definida que ambas formas puedan representar.Por lo tanto,la compatibilidad permite al código de inferencia de la forma razonar sobre formas parcialmente definidas.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="b556440bce1c841c1d10f79b38663d9dfe8ce6f6" translate="yes" xml:space="preserve">
          <source>Two single elements of type &lt;code&gt;bool&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b0a6ae6ca7d62abe9867da93517fe68a65fffe7" translate="yes" xml:space="preserve">
          <source>Two static instances exist in the distributions library, signifying one of two possible properties for samples from a distribution:</source>
          <target state="translated">Existen dos instancias estáticas en la biblioteca de distribuciones,lo que significa una de las dos posibles propiedades de las muestras de una distribución:</target>
        </trans-unit>
        <trans-unit id="304880baecfd0af0b3d1da16c178a413930af3d7" translate="yes" xml:space="preserve">
          <source>Two tensors are considered compatible if they have the same dtype and their shapes are compatible (see &lt;a href=&quot;tensorshape#is_compatible_with&quot;&gt;&lt;code&gt;tf.TensorShape.is_compatible_with&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Dos tensores se consideran compatibles si tienen el mismo tipo d y sus formas son compatibles (ver &lt;a href=&quot;tensorshape#is_compatible_with&quot;&gt; &lt;code&gt;tf.TensorShape.is_compatible_with&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6c808e735cf1d9acc205c12bc34a1db874936c96" translate="yes" xml:space="preserve">
          <source>Two tensors: &lt;code&gt;weighted_mean&lt;/code&gt; and &lt;code&gt;weighted_variance&lt;/code&gt;.</source>
          <target state="translated">Dos tensores: &lt;code&gt;weighted_mean&lt;/code&gt; y &lt;code&gt;weighted_variance&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="197f1a152813e8754c3ab4ada0aee8e8eb0ab0e1" translate="yes" xml:space="preserve">
          <source>Type collections</source>
          <target state="translated">Colecciones de tipos</target>
        </trans-unit>
        <trans-unit id="70190875a976d04b6dbbdb76a76b8abab15ed20d" translate="yes" xml:space="preserve">
          <source>Type of reduction to apply to loss.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="580ea2f11b5081d9834cac3a14574bfc02323a10" translate="yes" xml:space="preserve">
          <source>Type of the new or existing variable (defaults to &lt;code&gt;DT_FLOAT&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eda6e626972cf9e8cb577094d8e71478f4d87dc1" translate="yes" xml:space="preserve">
          <source>Type of the variables. Ignored if &lt;code&gt;initializer&lt;/code&gt; is a &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cb8d838a08c5043e95b8affed6f234ffe7a8fca" translate="yes" xml:space="preserve">
          <source>Type of weights, such as &lt;a href=&quot;../../tf#float32&quot;&gt;&lt;code&gt;tf.float32&lt;/code&gt;&lt;/a&gt;. Only float and integer weights are supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89bccb1027fad55abb521d6f7f2c0ac6a074c8f5" translate="yes" xml:space="preserve">
          <source>Type specification for &lt;a href=&quot;dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Especificaci&amp;oacute;n de tipo para &lt;a href=&quot;dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="712d9ffcd0e88abdb9eab9798af5f280ec9181bd" translate="yes" xml:space="preserve">
          <source>Type specification for &lt;a href=&quot;experimental/optional&quot;&gt;&lt;code&gt;tf.experimental.Optional&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="546c3b422414d2acfe0b7b6df33ddda2e98f189c" translate="yes" xml:space="preserve">
          <source>Type specification for &lt;a href=&quot;iterator&quot;&gt;&lt;code&gt;tf.data.Iterator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ffc6a6652502645af83819deceaf071d1bee7ae" translate="yes" xml:space="preserve">
          <source>Type specification for a &lt;a href=&quot;indexedslices&quot;&gt;&lt;code&gt;tf.IndexedSlices&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Especificaci&amp;oacute;n de tipo para &lt;a href=&quot;indexedslices&quot;&gt; &lt;code&gt;tf.IndexedSlices&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="db38e64c6790f1fa6a4046e1608589e1baafdb4f" translate="yes" xml:space="preserve">
          <source>Type specification for a &lt;a href=&quot;raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Especificaci&amp;oacute;n de tipo para un &lt;a href=&quot;raggedtensor&quot;&gt; &lt;code&gt;tf.RaggedTensor&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="506637460ca723fc98125655b0c45f16d689f183" translate="yes" xml:space="preserve">
          <source>Type specification for a &lt;a href=&quot;sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.SparseTensor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Especificaci&amp;oacute;n de tipo para un &lt;a href=&quot;sparse/sparsetensor&quot;&gt; &lt;code&gt;tf.SparseTensor&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f8dc08024793f24e03dca43c23eba2de392c0936" translate="yes" xml:space="preserve">
          <source>Type specification for a &lt;a href=&quot;sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="097420656a3bb835a98ade8d3c1d8d6e161e4abc" translate="yes" xml:space="preserve">
          <source>Type specification for a &lt;a href=&quot;tensorarray&quot;&gt;&lt;code&gt;tf.TensorArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Especificaci&amp;oacute;n de tipo para un &lt;a href=&quot;tensorarray&quot;&gt; &lt;code&gt;tf.TensorArray&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0fa80254c7cf732908a6ef92e8bcb16a8cbc3031" translate="yes" xml:space="preserve">
          <source>TypeError if &lt;code&gt;cluster&lt;/code&gt; is not a dictionary or &lt;code&gt;ClusterDef&lt;/code&gt; protocol buffer, or if &lt;code&gt;ps_strategy&lt;/code&gt; is provided but not a callable.</source>
          <target state="translated">TypeError si el &lt;code&gt;cluster&lt;/code&gt; no es un diccionario o &lt;code&gt;ClusterDef&lt;/code&gt; b&amp;uacute;fer de protocolo ClusterDef , o si se proporciona &lt;code&gt;ps_strategy&lt;/code&gt; pero no es un invocable.</target>
        </trans-unit>
        <trans-unit id="7a7a3cb39cba799635ae97a5b59c3c35fb2a8e05" translate="yes" xml:space="preserve">
          <source>TypeError.</source>
          <target state="translated">TypeError.</target>
        </trans-unit>
        <trans-unit id="5bdcc3d1ee1c7b80e26206fa1de63397c5a2add9" translate="yes" xml:space="preserve">
          <source>TypeError: If the slice indices aren't int, slice, ellipsis, tf.newaxis or int32/int64 tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d6c4c2eeadfc7d013e2b2fb8940e520aa96954c" translate="yes" xml:space="preserve">
          <source>Types I, II, III and IV are supported. Type I is implemented using a length &lt;code&gt;2N&lt;/code&gt; padded &lt;a href=&quot;rfft&quot;&gt;&lt;code&gt;tf.signal.rfft&lt;/code&gt;&lt;/a&gt;. Type II is implemented using a length &lt;code&gt;2N&lt;/code&gt; padded &lt;a href=&quot;rfft&quot;&gt;&lt;code&gt;tf.signal.rfft&lt;/code&gt;&lt;/a&gt;, as described here: &lt;a href=&quot;https://dsp.stackexchange.com/a/10606&quot;&gt;Type 2 DCT using 2N FFT padded (Makhoul)&lt;/a&gt;. Type III is a fairly straightforward inverse of Type II (i.e. using a length &lt;code&gt;2N&lt;/code&gt; padded &lt;a href=&quot;irfft&quot;&gt;&lt;code&gt;tf.signal.irfft&lt;/code&gt;&lt;/a&gt;). Type IV is calculated through 2N length DCT2 of padded signal and picking the odd indices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9e719623f3a5418b899a4ace2cf4d169670e417" translate="yes" xml:space="preserve">
          <source>Types of loss reduction.</source>
          <target state="translated">Tipos de reducción de pérdidas.</target>
        </trans-unit>
        <trans-unit id="aa3c047f418cf4b489027ae070f266970331772f" translate="yes" xml:space="preserve">
          <source>Typical usage example:</source>
          <target state="translated">Ejemplo típico de uso:</target>
        </trans-unit>
        <trans-unit id="f86aad613fa5c3ee99a3b5451654d3e3136022f7" translate="yes" xml:space="preserve">
          <source>Typical usage for the &lt;code&gt;SavedModelBuilder&lt;/code&gt;:</source>
          <target state="translated">Uso t&amp;iacute;pico para &lt;code&gt;SavedModelBuilder&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1dc96cc06e4c88360c7be195760a73e5c44fb2f7" translate="yes" xml:space="preserve">
          <source>Typical usage of this strategy could be testing your code with the tf.distribute.Strategy API before switching to other strategies which actually distribute to multiple devices/machines.</source>
          <target state="translated">El uso típico de esta estrategia podría ser probar su código con la API de la estrategia tf.distribute.antes de cambiar a otras estrategias que realmente se distribuyen a múltiples dispositivos/máquinas.</target>
        </trans-unit>
        <trans-unit id="9f433de3a09f2cf5cd13a827c57725457d725e39" translate="yes" xml:space="preserve">
          <source>Typical usage:</source>
          <target state="translated">Uso típico:</target>
        </trans-unit>
        <trans-unit id="86f2b70049641c1127233f5a7f23b12cf7d72298" translate="yes" xml:space="preserve">
          <source>Typical usages of the &lt;code&gt;MethodNameUpdater&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0271771c7069a116c3373c269a63be4c6aca6198" translate="yes" xml:space="preserve">
          <source>Typical users will use one of the more specialized DEFINE_xxx functions, such as DEFINE_string or DEFINE_integer. But developers who need to create Flag objects themselves should use this function to register their flags.</source>
          <target state="translated">Los usuarios típicos utilizarán una de las funciones más especializadas DEFINE_xxx,como DEFINE_string o DEFINE_integer.Pero los desarrolladores que necesiten crear ellos mismos objetos de bandera deben usar esta función para registrar sus banderas.</target>
        </trans-unit>
        <trans-unit id="2637b9cc80067f35b6391fac2edcbf9be59d7ab4" translate="yes" xml:space="preserve">
          <source>Typically only used in a cross-replica context:</source>
          <target state="translated">Normalmente sólo se utiliza en un contexto de réplica cruzada:</target>
        </trans-unit>
        <trans-unit id="770e50ed1c5b312d1ae6d0b8292c12f6aec34dd4" translate="yes" xml:space="preserve">
          <source>Typically this function is used to convert from TensorFlow GraphDef to TFLite. Conversion can be customized by providing arguments that are forwarded to &lt;code&gt;build_toco_convert_protos&lt;/code&gt; (see documentation for details). This function has been deprecated. Please use &lt;a href=&quot;../../../lite/tfliteconverter&quot;&gt;&lt;code&gt;lite.TFLiteConverter&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Normalmente, esta funci&amp;oacute;n se utiliza para convertir de TensorFlow GraphDef a TFLite. La conversi&amp;oacute;n se puede personalizar proporcionando argumentos que se env&amp;iacute;an a &lt;code&gt;build_toco_convert_protos&lt;/code&gt; (consulte la documentaci&amp;oacute;n para obtener m&amp;aacute;s detalles). Esta funci&amp;oacute;n ha quedado obsoleta. &lt;a href=&quot;../../../lite/tfliteconverter&quot;&gt; &lt;code&gt;lite.TFLiteConverter&lt;/code&gt; &lt;/a&gt; lugar, utilice lite.TFLiteConverter .</target>
        </trans-unit>
        <trans-unit id="3fe4dd1700ccac29f3d0ae3fa02b865b65b1c45f" translate="yes" xml:space="preserve">
          <source>Typically this function is used to convert from TensorFlow GraphDef to TFLite. Conversion can be customized by providing arguments that are forwarded to &lt;code&gt;build_toco_convert_protos&lt;/code&gt; (see documentation for details). This function has been deprecated. Please use &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/lite/TFLiteConverter&quot;&gt;&lt;code&gt;lite.TFLiteConverter&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f937cb551b8e8625cac21b8a54df64070d57507" translate="yes" xml:space="preserve">
          <source>Typically, constructing a file writer creates a new event file in &lt;code&gt;logdir&lt;/code&gt;. This event file will contain &lt;code&gt;Event&lt;/code&gt; protocol buffers constructed when you call one of the following functions: &lt;code&gt;add_summary()&lt;/code&gt;, &lt;code&gt;add_session_log()&lt;/code&gt;, &lt;code&gt;add_event()&lt;/code&gt;, or &lt;code&gt;add_graph()&lt;/code&gt;.</source>
          <target state="translated">Normalmente, la construcci&amp;oacute;n de un escritor de archivos crea un nuevo archivo de eventos en &lt;code&gt;logdir&lt;/code&gt; . Este archivo de &lt;code&gt;Event&lt;/code&gt; contendr&amp;aacute; b&amp;uacute;feres de protocolo de eventos construidos cuando llame a una de las siguientes funciones: &lt;code&gt;add_summary()&lt;/code&gt; , &lt;code&gt;add_session_log()&lt;/code&gt; , &lt;code&gt;add_event()&lt;/code&gt; o &lt;code&gt;add_graph()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aff7b1a518fb0d16f85d64959ece4d247dd8cf1c" translate="yes" xml:space="preserve">
          <source>Typically, different numerical approximations can be used for the log survival function, which are more accurate than &lt;code&gt;1 - cdf(x)&lt;/code&gt; when &lt;code&gt;x &amp;gt;&amp;gt; 1&lt;/code&gt;.</source>
          <target state="translated">Normalmente, se pueden utilizar diferentes aproximaciones num&amp;eacute;ricas para la funci&amp;oacute;n de supervivencia logar&amp;iacute;tmica, que son m&amp;aacute;s precisas que &lt;code&gt;1 - cdf(x)&lt;/code&gt; cuando &lt;code&gt;x &amp;gt;&amp;gt; 1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc11d475cf6eeccc4ccad2799b660daf47f6e97d" translate="yes" xml:space="preserve">
          <source>Typically, this is used for contiguous ranges of integer indexes, but it doesn't have to be. This might be inefficient, however, if many of IDs are unused. Consider &lt;code&gt;categorical_column_with_hash_bucket&lt;/code&gt; in that case.</source>
          <target state="translated">Normalmente, esto se usa para rangos contiguos de &amp;iacute;ndices enteros, pero no tiene por qu&amp;eacute; ser as&amp;iacute;. Sin embargo, esto podr&amp;iacute;a resultar ineficaz si muchos de los ID no se utilizan. Considere &lt;code&gt;categorical_column_with_hash_bucket&lt;/code&gt; en ese caso.</target>
        </trans-unit>
        <trans-unit id="642d93bf7af9445a97651535e05ec594d4e074d2" translate="yes" xml:space="preserve">
          <source>Typically, this method directly controls &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; settings, and delegates the actual evaluation logic to &lt;a href=&quot;../model#predict_step&quot;&gt;&lt;code&gt;Model.predict_step&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e09b882e09baa741494589bf82363a386761e573" translate="yes" xml:space="preserve">
          <source>Typically, this method directly controls &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; settings, and delegates the actual evaluation logic to &lt;a href=&quot;../model#test_step&quot;&gt;&lt;code&gt;Model.test_step&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b89bd069f03bea0bc8a7420d63726498425c37ea" translate="yes" xml:space="preserve">
          <source>Typically, this method directly controls &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; settings, and delegates the actual training logic to &lt;a href=&quot;../model#train_step&quot;&gt;&lt;code&gt;Model.train_step&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a9ed424e025572fe99563e115ac58ef9f0eecef" translate="yes" xml:space="preserve">
          <source>Typically, this method directly controls &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; settings, and delegates the actual evaluation logic to &lt;a href=&quot;model#predict_step&quot;&gt;&lt;code&gt;Model.predict_step&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88e682fbb9f04bb6f808d62f5cfd3cba250f9355" translate="yes" xml:space="preserve">
          <source>Typically, this method directly controls &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; settings, and delegates the actual evaluation logic to &lt;a href=&quot;model#test_step&quot;&gt;&lt;code&gt;Model.test_step&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39425f208b695839de1ae797673c90196ac3923f" translate="yes" xml:space="preserve">
          <source>Typically, this method directly controls &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; settings, and delegates the actual training logic to &lt;a href=&quot;model#train_step&quot;&gt;&lt;code&gt;Model.train_step&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4872edff50fbbe6a9f917cabaf4b95b3b51cfbf5" translate="yes" xml:space="preserve">
          <source>UUID of function that this tracks arguments for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="028563b1e54555afd3216dd205c2179bff62edca" translate="yes" xml:space="preserve">
          <source>Unbatch</source>
          <target state="translated">Unbatch</target>
        </trans-unit>
        <trans-unit id="18de537cd188f9aa6703c0bcca0bdd3aa030d834" translate="yes" xml:space="preserve">
          <source>UnbatchDataset</source>
          <target state="translated">UnbatchDataset</target>
        </trans-unit>
        <trans-unit id="282c6a33f97fdaf72f77ce51ca56ef49ffc77747" translate="yes" xml:space="preserve">
          <source>UnbatchGrad</source>
          <target state="translated">UnbatchGrad</target>
        </trans-unit>
        <trans-unit id="0ed10c799418646f55b928fd78fe57ac0388bf1c" translate="yes" xml:space="preserve">
          <source>UncompressElement</source>
          <target state="translated">UncompressElement</target>
        </trans-unit>
        <trans-unit id="4b7dbe0386bf95cabb32b5ed231c8f56aae99b96" translate="yes" xml:space="preserve">
          <source>Uncompresses a compressed dataset element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="315f69cd0de49a2c6013b3acdede0a3586eb743f" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;TPUStrategy&lt;/code&gt;, we allow access to the method &lt;code&gt;enqueue&lt;/code&gt;, &lt;code&gt;dequeue&lt;/code&gt; and &lt;code&gt;apply_gradients&lt;/code&gt;. We will show examples below of how to use these to train and evaluate your model. Under CPU, we only access to the &lt;code&gt;embedding_tables&lt;/code&gt; property which allow access to the embedding tables so that you can use them to run model evaluation/prediction on CPU.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3e018efacc4788ac4991e79f9e0eac32efd113e" translate="yes" xml:space="preserve">
          <source>Under a scope &lt;code&gt;with custom_object_scope(objects_dict)&lt;/code&gt;, Keras methods such as &lt;a href=&quot;../models/load_model&quot;&gt;&lt;code&gt;tf.keras.models.load_model&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../models/model_from_config&quot;&gt;&lt;code&gt;tf.keras.models.model_from_config&lt;/code&gt;&lt;/a&gt; will be able to deserialize any custom object referenced by a saved config (e.g. a custom layer or metric).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="505df01a0bd35a5e05151b2e08abe84fb66596dc" translate="yes" xml:space="preserve">
          <source>Understanding and Improving Convolutional Neural Networks via Concatenated Rectified Linear Units: &lt;a href=&quot;http://proceedings.mlr.press/v48/shang16&quot;&gt;Shang et al., 2016&lt;/a&gt; (&lt;a href=&quot;http://proceedings.mlr.press/v48/shang16.pdf&quot;&gt;pdf&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f2505b6c39bb7db973660c096d38f1739c74197" translate="yes" xml:space="preserve">
          <source>Undoes all SmartSet() &amp;amp; Set() calls, restoring original definitions.</source>
          <target state="translated">Deshace todas las llamadas SmartSet () y Set (), restaurando las definiciones originales.</target>
        </trans-unit>
        <trans-unit id="1956e966c40ea031fb68e7fe6e402465c17b477c" translate="yes" xml:space="preserve">
          <source>Unicode encoding that should be used to encode each codepoint sequence. Can be &lt;code&gt;&quot;UTF-8&quot;&lt;/code&gt;, &lt;code&gt;&quot;UTF-16-BE&quot;&lt;/code&gt;, or &lt;code&gt;&quot;UTF-32-BE&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90ac7bb3b01b32e952ee295aa92163d24d25615d" translate="yes" xml:space="preserve">
          <source>Unicode strings</source>
          <target state="translated">Cuerdas de Unicode</target>
        </trans-unit>
        <trans-unit id="5e0684d6d7d272631c8bbe44f41cfa3f5076b1d4" translate="yes" xml:space="preserve">
          <source>UnicodeDecode</source>
          <target state="translated">UnicodeDecode</target>
        </trans-unit>
        <trans-unit id="d7d59980b4ae5cf39a350faf2c470f5fc69d74d8" translate="yes" xml:space="preserve">
          <source>UnicodeDecodeWithOffsets</source>
          <target state="translated">UnicodeDecodeWithOffsets</target>
        </trans-unit>
        <trans-unit id="05ae41cc8fec2efee56c1fd3fc455b9ee887c661" translate="yes" xml:space="preserve">
          <source>UnicodeEncode</source>
          <target state="translated">UnicodeEncode</target>
        </trans-unit>
        <trans-unit id="d48a266454de5c99b64f1535df01a2aa732eb493" translate="yes" xml:space="preserve">
          <source>UnicodeScript</source>
          <target state="translated">UnicodeScript</target>
        </trans-unit>
        <trans-unit id="c03f6044710be2f868218b1b8ef3d1a0cb70d8e9" translate="yes" xml:space="preserve">
          <source>UnicodeTranscode</source>
          <target state="translated">UnicodeTranscode</target>
        </trans-unit>
        <trans-unit id="976c215ff49db1df66b6e17319495979c35769ef" translate="yes" xml:space="preserve">
          <source>Uniform Inner Dimensions</source>
          <target state="translated">Dimensiones interiores uniformes</target>
        </trans-unit>
        <trans-unit id="8560175804cd279f78f66d9a95299a6ca618dbfc" translate="yes" xml:space="preserve">
          <source>Uniform Outer Dimensions</source>
          <target state="translated">Dimensiones exteriores uniformes</target>
        </trans-unit>
        <trans-unit id="877e52ac4e7248f2800c12c1d91696ac0ce4e843" translate="yes" xml:space="preserve">
          <source>Uniform and ragged outer dimensions may be interleaved, meaning that a tensor with any combination of ragged and uniform dimensions may be created. For example, a RaggedTensor &lt;code&gt;t4&lt;/code&gt; with shape &lt;code&gt;[3, None, 4, 8, None, 2]&lt;/code&gt; could be constructed as follows:</source>
          <target state="translated">Las dimensiones exteriores uniformes y desiguales se pueden intercalar, lo que significa que se puede crear un tensor con cualquier combinaci&amp;oacute;n de dimensiones irregulares y uniformes. Por ejemplo, un RaggedTensor &lt;code&gt;t4&lt;/code&gt; con forma &lt;code&gt;[3, None, 4, 8, None, 2]&lt;/code&gt; podr&amp;iacute;a construirse de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="9c91421a9e87411dcbfdcaf48e2c1f3430455339" translate="yes" xml:space="preserve">
          <source>Uniform dimensions are encoded using multidimensional numpy &lt;code&gt;array&lt;/code&gt;s. In the following example, the value returned by &lt;a href=&quot;raggedtensor#numpy&quot;&gt;&lt;code&gt;RaggedTensor.numpy()&lt;/code&gt;&lt;/a&gt; contains a single numpy &lt;code&gt;array&lt;/code&gt; object, with &lt;code&gt;rank=2&lt;/code&gt; and &lt;code&gt;dtype=int64&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f358f22f84035b210a806ebde2b7ba64470c6103" translate="yes" xml:space="preserve">
          <source>Uniform distribution on an integer type's entire range.</source>
          <target state="translated">Distribución uniforme en todo el rango de un tipo entero.</target>
        </trans-unit>
        <trans-unit id="5a636a3f76b9605e2629209f45efcb9cace24843" translate="yes" xml:space="preserve">
          <source>Uniform distribution with &lt;code&gt;low&lt;/code&gt; and &lt;code&gt;high&lt;/code&gt; parameters.</source>
          <target state="translated">Distribuci&amp;oacute;n uniforme con par&amp;aacute;metros &lt;code&gt;high&lt;/code&gt; y &lt;code&gt;low&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2408554486ca40a7df4bc74cb3619a293981c6a8" translate="yes" xml:space="preserve">
          <source>UniformCandidateSampler</source>
          <target state="translated">UniformCandidateSampler</target>
        </trans-unit>
        <trans-unit id="82b9b64659267074d1c1ba85abf6981423a4e4d2" translate="yes" xml:space="preserve">
          <source>UniformRowLength(length,)</source>
          <target state="translated">UniformRowLength(length,)</target>
        </trans-unit>
        <trans-unit id="338a58853d5b589d79285d729f26c7d598bf74eb" translate="yes" xml:space="preserve">
          <source>Union[Iterable[Enum], Iterable[Text], Enum, Text, None], the default value of the flag; see &lt;code&gt;DEFINE_multi&lt;/code&gt;; only differences are documented here. If the value is a single Enum, it is treated as a single-item list of that Enum value. If it is an iterable, text values within the iterable will be converted to the equivalent Enum objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04886f2c2934fa1074408cc7cc12b5f99af25706" translate="yes" xml:space="preserve">
          <source>Union[Iterable[T], Text, None], the default value of the flag. If the value is text, it will be parsed as if it was provided from the command line. If the value is a non-string iterable, it will be iterated over to create a shallow copy of the values. If it is None, it is left as-is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="737c59cf13411337a19af29f48783402b8ed06de" translate="yes" xml:space="preserve">
          <source>Union[Iterable[Text], Text, None], the default value of the flag; see &lt;code&gt;DEFINE_multi&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6428fc2f5260465f511164c37261c5570e275cd5" translate="yes" xml:space="preserve">
          <source>Union[Iterable[float], Text, None], the default value of the flag; see &lt;code&gt;DEFINE_multi&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c19e99ab715ea5a714cc70c9ca1419999c89628b" translate="yes" xml:space="preserve">
          <source>Union[Iterable[int], Text, None], the default value of the flag; see &lt;code&gt;DEFINE_multi&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87c6f410754d2f5d42cbccc33576be0d5edc865c" translate="yes" xml:space="preserve">
          <source>Unique</source>
          <target state="translated">Unique</target>
        </trans-unit>
        <trans-unit id="0dd84a267eb06050e1d51577f84d2e5f9d140c27" translate="yes" xml:space="preserve">
          <source>Unique integer ID.</source>
          <target state="translated">Una identificación entera única.</target>
        </trans-unit>
        <trans-unit id="b898bebda42c40e1bfed797240e3b6330402424d" translate="yes" xml:space="preserve">
          <source>UniqueDataset</source>
          <target state="translated">UniqueDataset</target>
        </trans-unit>
        <trans-unit id="936d3125f6165a80c34df14b2afdc4601cd8b763" translate="yes" xml:space="preserve">
          <source>UniqueV2</source>
          <target state="translated">UniqueV2</target>
        </trans-unit>
        <trans-unit id="6d7fb951e6346ddabc82f570397d0fd46ed74844" translate="yes" xml:space="preserve">
          <source>UniqueWithCounts</source>
          <target state="translated">UniqueWithCounts</target>
        </trans-unit>
        <trans-unit id="1c7a5d24b663759b635f7eb14541a1e553019f23" translate="yes" xml:space="preserve">
          <source>UniqueWithCountsV2</source>
          <target state="translated">UniqueWithCountsV2</target>
        </trans-unit>
        <trans-unit id="3716d64264f900396f1af7fc16d7b86fdf992a50" translate="yes" xml:space="preserve">
          <source>Unknown error.</source>
          <target state="translated">Error desconocido.</target>
        </trans-unit>
        <trans-unit id="36714cf4410eee18e8f50df2ffea0a7fa2ac86eb" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../../../../data/dataset#batch&quot;&gt;&lt;code&gt;tf.data.Dataset.batch&lt;/code&gt;&lt;/a&gt;, the input elements to be batched may have different shapes, and this transformation will pad each component to the respective shape in &lt;code&gt;padded_shapes&lt;/code&gt;. The &lt;code&gt;padded_shapes&lt;/code&gt; argument determines the resulting shape for each dimension of each component in an output element:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ecf9df1b9c446def763a4926348afbeccb07217" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../../../../data/dataset#batch&quot;&gt;&lt;code&gt;tf.data.Dataset.batch&lt;/code&gt;&lt;/a&gt;, the input elements to be batched may have different shapes, and this transformation will pad each component to the respective shape in &lt;code&gt;padding_shapes&lt;/code&gt;. The &lt;code&gt;padding_shapes&lt;/code&gt; argument determines the resulting shape for each dimension of each component in an output element:</source>
          <target state="translated">A diferencia de &lt;a href=&quot;../../../../data/dataset#batch&quot;&gt; &lt;code&gt;tf.data.Dataset.batch&lt;/code&gt; &lt;/a&gt; , los elementos de entrada que se van a agrupar pueden tener diferentes formas, y esta transformaci&amp;oacute;n rellenar&amp;aacute; cada componente con la forma respectiva en &lt;code&gt;padding_shapes&lt;/code&gt; . El argumento &lt;code&gt;padding_shapes&lt;/code&gt; determina la forma resultante para cada dimensi&amp;oacute;n de cada componente en un elemento de salida:</target>
        </trans-unit>
        <trans-unit id="576d359833afce4c0260f4d74f22330fd90213de" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../../../data/dataset#batch&quot;&gt;&lt;code&gt;tf.data.Dataset.batch&lt;/code&gt;&lt;/a&gt;, the input elements to be batched may have different shapes, and this transformation will pad each component to the respective shape in &lt;code&gt;padded_shapes&lt;/code&gt;. The &lt;code&gt;padded_shapes&lt;/code&gt; argument determines the resulting shape for each dimension of each component in an output element:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb9a4a5a4e9492ece2558573a0acc8a789ddc313" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../../../data/dataset#batch&quot;&gt;&lt;code&gt;tf.data.Dataset.batch&lt;/code&gt;&lt;/a&gt;, the input elements to be batched may have different shapes, and this transformation will pad each component to the respective shape in &lt;code&gt;padding_shapes&lt;/code&gt;. The &lt;code&gt;padding_shapes&lt;/code&gt; argument determines the resulting shape for each dimension of each component in an output element:</source>
          <target state="translated">A diferencia de &lt;a href=&quot;../../../data/dataset#batch&quot;&gt; &lt;code&gt;tf.data.Dataset.batch&lt;/code&gt; &lt;/a&gt; , los elementos de entrada que se van a agrupar pueden tener diferentes formas, y esta transformaci&amp;oacute;n rellenar&amp;aacute; cada componente con la forma respectiva en &lt;code&gt;padding_shapes&lt;/code&gt; . El argumento &lt;code&gt;padding_shapes&lt;/code&gt; determina la forma resultante para cada dimensi&amp;oacute;n de cada componente en un elemento de salida:</target>
        </trans-unit>
        <trans-unit id="e4abe35be36c6363497bfcbdede20ee0472e70d3" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;to_graph&lt;/code&gt; is a low-level transpiler that converts Python code to TensorFlow graph code. It does not implement any caching, variable management or create any actual ops, and is best used where greater control over the generated TensorFlow graph is desired. Another difference from &lt;a href=&quot;../../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; is that &lt;code&gt;to_graph&lt;/code&gt; will not wrap the graph into a TensorFlow function or a Python callable. Internally, &lt;a href=&quot;../../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; uses &lt;code&gt;to_graph&lt;/code&gt;.</source>
          <target state="translated">A diferencia de &lt;a href=&quot;../../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;to_graph&lt;/code&gt; es un transpilador de bajo nivel que convierte el c&amp;oacute;digo de Python en c&amp;oacute;digo de gr&amp;aacute;fico de TensorFlow. No implementa ning&amp;uacute;n almacenamiento en cach&amp;eacute;, administraci&amp;oacute;n de variables ni crea operaciones reales, y se usa mejor cuando se desea un mayor control sobre el gr&amp;aacute;fico de TensorFlow generado. Otra diferencia con &lt;a href=&quot;../../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; es que &lt;code&gt;to_graph&lt;/code&gt; no ajustar&amp;aacute; el gr&amp;aacute;fico a una funci&amp;oacute;n de TensorFlow o una funci&amp;oacute;n de Python invocable. Internamente, &lt;a href=&quot;../../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; usa &lt;code&gt;to_graph&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c289f8aae64df7cd4ff7fdb8457061e6c012cdc6" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;wrap_function&lt;/code&gt; will only trace the Python function once. As with placeholders in TF 1.x, shapes and dtypes must be provided to &lt;code&gt;wrap_function&lt;/code&gt;'s &lt;code&gt;signature&lt;/code&gt; argument.</source>
          <target state="translated">A diferencia de &lt;a href=&quot;../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;wrap_function&lt;/code&gt; solo rastrear&amp;aacute; la funci&amp;oacute;n de Python una vez. Al igual que con los marcadores de posici&amp;oacute;n en TF 1.x, se deben proporcionar formas y dtypes para el argumento de &lt;code&gt;signature&lt;/code&gt; &lt;code&gt;wrap_function&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="704bf993fd1f302cbdbbea9b08e8e2b996cf4dcb" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../dataset#batch&quot;&gt;&lt;code&gt;tf.data.Dataset.batch&lt;/code&gt;&lt;/a&gt;, the input elements to be batched may have different shapes, and each batch will be encoded as a &lt;a href=&quot;../../raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt;. Example:</source>
          <target state="translated">A diferencia de &lt;a href=&quot;../dataset#batch&quot;&gt; &lt;code&gt;tf.data.Dataset.batch&lt;/code&gt; &lt;/a&gt; , los elementos de entrada que se van a agrupar pueden tener diferentes formas, y cada lote se codificar&amp;aacute; como &lt;a href=&quot;../../raggedtensor&quot;&gt; &lt;code&gt;tf.RaggedTensor&lt;/code&gt; &lt;/a&gt; . Ejemplo:</target>
        </trans-unit>
        <trans-unit id="ab3fab341c82646fe8f085450f444bec807918c5" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../dataset#batch&quot;&gt;&lt;code&gt;tf.data.Dataset.batch&lt;/code&gt;&lt;/a&gt;, the input elements to be batched may have different shapes, and this transformation will pad each component to the respective shape in &lt;code&gt;padded_shapes&lt;/code&gt;. The &lt;code&gt;padded_shapes&lt;/code&gt; argument determines the resulting shape for each dimension of each component in an output element:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ebb4bc2458197f2fb3172235869b74c91d350b2" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../dataset#batch&quot;&gt;&lt;code&gt;tf.data.Dataset.batch&lt;/code&gt;&lt;/a&gt;, the input elements to be batched may have different shapes, and this transformation will pad each component to the respective shape in &lt;code&gt;padding_shapes&lt;/code&gt;. The &lt;code&gt;padding_shapes&lt;/code&gt; argument determines the resulting shape for each dimension of each component in an output element:</source>
          <target state="translated">A diferencia de &lt;a href=&quot;../dataset#batch&quot;&gt; &lt;code&gt;tf.data.Dataset.batch&lt;/code&gt; &lt;/a&gt; , los elementos de entrada que se van a agrupar pueden tener diferentes formas, y esta transformaci&amp;oacute;n rellenar&amp;aacute; cada componente con la forma respectiva en &lt;code&gt;padding_shapes&lt;/code&gt; . El argumento &lt;code&gt;padding_shapes&lt;/code&gt; determina la forma resultante para cada dimensi&amp;oacute;n de cada componente en un elemento de salida:</target>
        </trans-unit>
        <trans-unit id="0d34e57a1aa18be3c8484d7069cc1c8ad2db64a5" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../dataset#batch&quot;&gt;&lt;code&gt;tf.data.Dataset.batch&lt;/code&gt;&lt;/a&gt;, the input elements to be batched may have different shapes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69eb42951cde2b887407e0d83e6a95dc1668220b" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;to_graph&lt;/code&gt; is a low-level transpiler that converts Python code to TensorFlow graph code. It does not implement any caching, variable management or create any actual ops, and is best used where greater control over the generated TensorFlow graph is desired. Another difference from &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; is that &lt;code&gt;to_graph&lt;/code&gt; will not wrap the graph into a TensorFlow function or a Python callable. Internally, &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; uses &lt;code&gt;to_graph&lt;/code&gt;.</source>
          <target state="translated">A diferencia de &lt;a href=&quot;../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;to_graph&lt;/code&gt; es un transpilador de bajo nivel que convierte el c&amp;oacute;digo de Python en c&amp;oacute;digo de gr&amp;aacute;fico de TensorFlow. No implementa ning&amp;uacute;n almacenamiento en cach&amp;eacute;, administraci&amp;oacute;n de variables ni crea operaciones reales, y se usa mejor cuando se desea un mayor control sobre el gr&amp;aacute;fico de TensorFlow generado. Otra diferencia con &lt;a href=&quot;../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; es que &lt;code&gt;to_graph&lt;/code&gt; no ajustar&amp;aacute; el gr&amp;aacute;fico a una funci&amp;oacute;n de TensorFlow o una funci&amp;oacute;n de Python invocable. Internamente, &lt;a href=&quot;../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; usa &lt;code&gt;to_graph&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de7b7f502adc89ee96e98e3c06014fa1c272dc91" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;dataset#batch&quot;&gt;&lt;code&gt;tf.data.Dataset.batch&lt;/code&gt;&lt;/a&gt;, the input elements to be batched may have different shapes, and this transformation will pad each component to the respective shape in &lt;code&gt;padded_shapes&lt;/code&gt;. The &lt;code&gt;padded_shapes&lt;/code&gt; argument determines the resulting shape for each dimension of each component in an output element:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcde43ba32f97c1ff2549287396cb94e24747c3e" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;dataset#batch&quot;&gt;&lt;code&gt;tf.data.Dataset.batch&lt;/code&gt;&lt;/a&gt;, the input elements to be batched may have different shapes, and this transformation will pad each component to the respective shape in &lt;code&gt;padding_shapes&lt;/code&gt;. The &lt;code&gt;padding_shapes&lt;/code&gt; argument determines the resulting shape for each dimension of each component in an output element:</source>
          <target state="translated">A diferencia de &lt;a href=&quot;dataset#batch&quot;&gt; &lt;code&gt;tf.data.Dataset.batch&lt;/code&gt; &lt;/a&gt; , los elementos de entrada que se van a agrupar pueden tener diferentes formas, y esta transformaci&amp;oacute;n rellenar&amp;aacute; cada componente con la forma respectiva en &lt;code&gt;padding_shapes&lt;/code&gt; . El argumento &lt;code&gt;padding_shapes&lt;/code&gt; determina la forma resultante para cada dimensi&amp;oacute;n de cada componente en un elemento de salida:</target>
        </trans-unit>
        <trans-unit id="e86a43f4e75dabc2059ed1937b3c30cb8a924b23" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;SoftmaxCrossEntropyWithLogits&lt;/code&gt;, this operation does not accept a matrix of label probabilities, but rather a single label per row of features. This label is considered to have probability 1.0 for the given row.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c42cd1138a7b09e8aab4b48a275bce9fecd055c5" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;mean_squared_error&lt;/code&gt;, which is a measure of the differences between corresponding elements of &lt;code&gt;predictions&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt;, &lt;code&gt;mean_pairwise_squared_error&lt;/code&gt; is a measure of the differences between pairs of corresponding elements of &lt;code&gt;predictions&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt;.</source>
          <target state="translated">A diferencia de &lt;code&gt;mean_squared_error&lt;/code&gt; , que es una medida de las diferencias entre los elementos correspondientes de &lt;code&gt;predictions&lt;/code&gt; y &lt;code&gt;labels&lt;/code&gt; , &lt;code&gt;mean_pairwise_squared_error&lt;/code&gt; es una medida de las diferencias entre pares de elementos correspondientes de &lt;code&gt;predictions&lt;/code&gt; y &lt;code&gt;labels&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54b3e19f1658856fdd01905f7b1d827a5e2c7da2" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;stack&lt;/code&gt;, &lt;code&gt;parallel_stack&lt;/code&gt; does NOT support backpropagation.</source>
          <target state="translated">A diferencia de la &lt;code&gt;stack&lt;/code&gt; , &lt;code&gt;parallel_stack&lt;/code&gt; NO admite la propagaci&amp;oacute;n hacia atr&amp;aacute;s.</target>
        </trans-unit>
        <trans-unit id="3d3e8c9f8d19935be11b8a97738c865b48f3a40a" translate="yes" xml:space="preserve">
          <source>Unlike FractionalMaxPoolGrad, we don't need to find arg_max for FractionalAvgPoolGrad, we just need to evenly back-propagate each element of out_backprop to those indices that form the same pooling cell. Therefore, we just need to know the shape of original input tensor, instead of the whole tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="591f5490b4f3510f244c0007610068c1ceac25d0" translate="yes" xml:space="preserve">
          <source>Unlike MapDataset, the &lt;code&gt;f&lt;/code&gt; in FlatMapDataset is expected to return a Dataset variant, and FlatMapDataset will flatten successive results into a single Dataset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c453e83691ce84ff295e7a2c1ef516446c3ab8d7" translate="yes" xml:space="preserve">
          <source>Unlike MapDataset, the &lt;code&gt;f&lt;/code&gt; in InterleaveDataset is expected to return a Dataset variant, and InterleaveDataset will flatten successive results into a single Dataset. Unlike FlatMapDataset, InterleaveDataset will interleave sequences of up to &lt;code&gt;block_length&lt;/code&gt; consecutive elements from &lt;code&gt;cycle_length&lt;/code&gt; input elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c4c90486ba0091b8ea290c9a282ca7b97ffe78f" translate="yes" xml:space="preserve">
          <source>Unlike a &quot;MapDataset&quot;, which applies &lt;code&gt;f&lt;/code&gt; sequentially, this dataset invokes up to &lt;code&gt;batch_size * num_parallel_batches&lt;/code&gt; copies of &lt;code&gt;f&lt;/code&gt; in parallel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88b9771a4d40bd229bd2768494cd1206b15de019" translate="yes" xml:space="preserve">
          <source>Unlike a &quot;MapDataset&quot;, which applies &lt;code&gt;f&lt;/code&gt; sequentially, this dataset invokes up to &lt;code&gt;num_parallel_calls&lt;/code&gt; copies of &lt;code&gt;f&lt;/code&gt; in parallel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13fc8fd7e6240efedf349e3dbe4446fea97e3c13" translate="yes" xml:space="preserve">
          <source>Unlike a TensorShape object, a TensorSpec object contains both shape and dtype information for a tensor. This method allows layers to provide output dtype information if it is different from the input dtype. For any layer that doesn't implement this function, the framework will fall back to use &lt;code&gt;compute_output_shape&lt;/code&gt;, and will assume that the output dtype matches the input dtype.</source>
          <target state="translated">A diferencia de un objeto TensorShape, un objeto TensorSpec contiene informaci&amp;oacute;n de forma y tipo d para un tensor. Este m&amp;eacute;todo permite que las capas proporcionen informaci&amp;oacute;n de tipo d de salida si es diferente del tipo d de entrada. Para cualquier capa que no implemente esta funci&amp;oacute;n, el marco recurrir&amp;aacute; a &lt;code&gt;compute_output_shape&lt;/code&gt; y asumir&amp;aacute; que el dtype de salida coincide con el dtype de entrada.</target>
        </trans-unit>
        <trans-unit id="43b00e58be5bd1f34d6a3d43cebfb8995414356d" translate="yes" xml:space="preserve">
          <source>Unlike assertRaisesRegex, this method takes a literal string, not a regular expression.</source>
          <target state="translated">A diferencia de assertRaisesRegex,este método toma una cadena literal,no una expresión regular.</target>
        </trans-unit>
        <trans-unit id="b677c0df05da91282dc6309d244c4aedc109a5da" translate="yes" xml:space="preserve">
          <source>Unlike the Copy Op, this op has HostMemory constraint on its input or output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5f7d3fe36850e7fa5811bed8af5b2d92d808d37" translate="yes" xml:space="preserve">
          <source>Unlike the CopyHost Op, this op does not have HostMemory constraint on its input or output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="780bb9592c9dfb9fae30e2efc18623daa3e2cff4" translate="yes" xml:space="preserve">
          <source>Unlike the older op &lt;a href=&quot;compat/v1/squeeze&quot;&gt;&lt;code&gt;tf.compat.v1.squeeze&lt;/code&gt;&lt;/a&gt;, this op does not accept a deprecated &lt;code&gt;squeeze_dims&lt;/code&gt; argument.</source>
          <target state="translated">A diferencia de la &lt;a href=&quot;compat/v1/squeeze&quot;&gt; &lt;code&gt;tf.compat.v1.squeeze&lt;/code&gt; &lt;/a&gt; anterior tf.compat.v1.squeeze , esta operaci&amp;oacute;n no acepta un argumento &lt;code&gt;squeeze_dims&lt;/code&gt; obsoleto .</target>
        </trans-unit>
        <trans-unit id="33c0f5ca96c96a12269cd4ff95c4f773357fb44e" translate="yes" xml:space="preserve">
          <source>Unlike the original &lt;code&gt;accumulate_n&lt;/code&gt;, &lt;code&gt;accumulate_n_v2&lt;/code&gt; is differentiable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9828410fab6a8798616092f30a5aa2ae3611617b" translate="yes" xml:space="preserve">
          <source>Unordered dictionaries are not supported in eager mode when &lt;code&gt;exclusive=False&lt;/code&gt;. Use a list of tuples instead.</source>
          <target state="translated">Los diccionarios desordenados no se admiten en el modo ansioso cuando &lt;code&gt;exclusive=False&lt;/code&gt; . En su lugar, utilice una lista de tuplas.</target>
        </trans-unit>
        <trans-unit id="e2231a91d542441b9a855a9095ab4fe46e316699" translate="yes" xml:space="preserve">
          <source>Unpack</source>
          <target state="translated">Unpack</target>
        </trans-unit>
        <trans-unit id="0657883ef20cc657b888740e46664440ff735ff1" translate="yes" xml:space="preserve">
          <source>Unpacking behavior for iterator-like inputs: A common pattern is to pass a tf.data.Dataset, generator, or tf.keras.utils.Sequence to the &lt;code&gt;x&lt;/code&gt; argument of fit, which will in fact yield not only features (x) but optionally targets (y) and sample weights. Keras requires that the output of such iterator-likes be unambiguous. The iterator should return a tuple of length 1, 2, or 3, where the optional second and third elements will be used for y and sample_weight respectively. Any other type provided will be wrapped in a length one tuple, effectively treating everything as 'x'. When yielding dicts, they should still adhere to the top-level tuple structure. e.g. &lt;code&gt;({&quot;x0&quot;: x0, &quot;x1&quot;: x1}, y)&lt;/code&gt;. Keras will not attempt to separate features, targets, and weights from the keys of a single dict. A notable unsupported data type is the namedtuple. The reason is that it behaves like both an ordered datatype (tuple) and a mapping datatype (dict). So given a namedtuple of the form: &lt;code&gt;namedtuple(&quot;example_tuple&quot;, [&quot;y&quot;, &quot;x&quot;])&lt;/code&gt; it is ambiguous whether to reverse the order of the elements when interpreting the value. Even worse is a tuple of the form: &lt;code&gt;namedtuple(&quot;other_tuple&quot;, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])&lt;/code&gt; where it is unclear if the tuple was intended to be unpacked into x, y, and sample_weight or passed through as a single element to &lt;code&gt;x&lt;/code&gt;. As a result the data processing code will simply raise a ValueError if it encounters a namedtuple. (Along with instructions to remedy the issue.)</source>
          <target state="translated">Comportamiento de desempaquetado para entradas tipo iterador: un patr&amp;oacute;n com&amp;uacute;n es pasar una secuencia tf.data.Dataset, generator o tf.keras.utils.Sequence al argumento &lt;code&gt;x&lt;/code&gt; de ajuste, que de hecho producir&amp;aacute; no solo caracter&amp;iacute;sticas (x) sino opcionalmente, objetivos (y) y pesos de muestra. Keras requiere que la salida de este tipo de iteradores no sea ambigua. El iterador debe devolver una tupla de longitud 1, 2 o 3, donde el segundo y tercer elementos opcionales se usar&amp;aacute;n para y y sample_weight respectivamente. Cualquier otro tipo que se proporcione se incluir&amp;aacute; en una tupla de una longitud, lo que tratar&amp;aacute; todo como 'x'. Al emitir dictados, a&amp;uacute;n deben adherirse a la estructura de tuplas de nivel superior. p &lt;code&gt;({&quot;x0&quot;: x0, &quot;x1&quot;: x1}, y)&lt;/code&gt; ej. ({&quot;x0&quot;: x0, &quot;x1&quot;: x1}, y). Keras no intentar&amp;aacute; separar caracter&amp;iacute;sticas, objetivos y pesos de las claves de un solo dictado. Un tipo de datos no admitido notable es el namedtuple. La raz&amp;oacute;n es que se comporta como un tipo de datos ordenado (tupla) y un tipo de datos de mapeo (dict). Entonces, dada una tupla con nombre de la forma: &lt;code&gt;namedtuple(&quot;example_tuple&quot;, [&quot;y&quot;, &quot;x&quot;])&lt;/code&gt; es ambiguo si se debe invertir el orden de los elementos al interpretar el valor. Peor a&amp;uacute;n es una tupla de la forma: &lt;code&gt;namedtuple(&quot;other_tuple&quot;, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])&lt;/code&gt; donde no est&amp;aacute; claro si la tupla estaba destinada a descomprimirse en x, y y sample_weight o pasar a trav&amp;eacute;s como un solo elemento &lt;code&gt;x&lt;/code&gt; . Como resultado, el c&amp;oacute;digo de procesamiento de datos simplemente generar&amp;aacute; un ValueError si encuentra una tupla con nombre. (Junto con instrucciones para solucionar el problema).</target>
        </trans-unit>
        <trans-unit id="a70d7a46a185b9dd6d1158e08b8b8c0950e01eaa" translate="yes" xml:space="preserve">
          <source>Unpacks &lt;code&gt;num&lt;/code&gt; tensors from &lt;code&gt;value&lt;/code&gt; by chipping it along the &lt;code&gt;axis&lt;/code&gt; dimension. For example, given a tensor of shape &lt;code&gt;(A, B, C, D)&lt;/code&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="243ed91dcd10a0424df6d36deb350e6391df8548" translate="yes" xml:space="preserve">
          <source>Unpacks &lt;code&gt;num&lt;/code&gt; tensors from &lt;code&gt;value&lt;/code&gt; by chipping it along the &lt;code&gt;axis&lt;/code&gt; dimension. If &lt;code&gt;num&lt;/code&gt; is not specified (the default), it is inferred from &lt;code&gt;value&lt;/code&gt;'s shape. If &lt;code&gt;value.shape[axis]&lt;/code&gt; is not known, &lt;code&gt;ValueError&lt;/code&gt; is raised.</source>
          <target state="translated">Desempaqueta el &lt;code&gt;num&lt;/code&gt; tensores del &lt;code&gt;value&lt;/code&gt; cort&amp;aacute;ndolo a lo largo de la dimensi&amp;oacute;n del &lt;code&gt;axis&lt;/code&gt; . Si &lt;code&gt;num&lt;/code&gt; no se especifica (el valor predeterminado), se infiere de la forma del &lt;code&gt;value&lt;/code&gt; . Si no se conoce &lt;code&gt;value.shape[axis]&lt;/code&gt; , &lt;code&gt;ValueError&lt;/code&gt; se genera .</target>
        </trans-unit>
        <trans-unit id="eb445a131ff25a35a36ff7e142e017c24f785cd1" translate="yes" xml:space="preserve">
          <source>Unpacks a given dimension of a rank-&lt;code&gt;R&lt;/code&gt; tensor into &lt;code&gt;num&lt;/code&gt; rank-&lt;code&gt;(R-1)&lt;/code&gt; tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48918b5563a8ceafb76129f6bc60ab73e49603cf" translate="yes" xml:space="preserve">
          <source>Unpacks the given dimension of a rank-&lt;code&gt;R&lt;/code&gt; tensor into rank-&lt;code&gt;(R-1)&lt;/code&gt; tensors.</source>
          <target state="translated">Descompone la dimensi&amp;oacute;n dada de un tensor de rango &lt;code&gt;R&lt;/code&gt; en tensores de rango &lt;code&gt;(R-1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d65a83d865bb52fdcfa278aa190e57e05dce3f63" translate="yes" xml:space="preserve">
          <source>Unpacks user-provided data tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05dc9402d9793ff470926b16aca6821cb0999026" translate="yes" xml:space="preserve">
          <source>Unparses all flags to the point before any FLAGS(argv) was called.</source>
          <target state="translated">Despliega todas las banderas al punto antes de que se llamara a cualquier FLAGS(argv).</target>
        </trans-unit>
        <trans-unit id="2c8018d2ec1edd743fc94f4ac501f4979aa67070" translate="yes" xml:space="preserve">
          <source>UnravelIndex</source>
          <target state="translated">UnravelIndex</target>
        </trans-unit>
        <trans-unit id="5abd8671c3b3e7c85742a7fbdf4fc8baadcb9032" translate="yes" xml:space="preserve">
          <source>UnrecognizedFlagError: if the referenced flag doesn't exist. DuplicateFlagError: if the alias name has been used by some existing flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d01190ad612aa7505976a06d2cc1e8836b163992" translate="yes" xml:space="preserve">
          <source>Unscaled log probabilities of shape &lt;code&gt;[d_0, d_1, ..., d_{r-1}, num_classes]&lt;/code&gt; and dtype &lt;code&gt;float16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt; or &lt;code&gt;float64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b9238f8e545d4a2d2b6a4160c436067e5463ca7" translate="yes" xml:space="preserve">
          <source>Unscaled log probabilities of shape &lt;code&gt;[d_0, d_1, ..., d_{r-1}, num_classes]&lt;/code&gt; and dtype &lt;code&gt;float16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, or &lt;code&gt;float64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fd64ffd66a09162278b73ad3a2e108855905b4f" translate="yes" xml:space="preserve">
          <source>Unscaled log probabilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e5da72ba27bb718f2dac7fc946f26f49a76ad43" translate="yes" xml:space="preserve">
          <source>Unscales the gradients by the loss scale.</source>
          <target state="translated">Desescalan los gradientes por la escala de pérdidas.</target>
        </trans-unit>
        <trans-unit id="9329b6002fc399b1c6e7eb106d68b0ce50955b52" translate="yes" xml:space="preserve">
          <source>UnsortedSegmentJoin</source>
          <target state="translated">UnsortedSegmentJoin</target>
        </trans-unit>
        <trans-unit id="0982334ce0fca73c3a5e3ea913a7e0313a459f82" translate="yes" xml:space="preserve">
          <source>UnsortedSegmentMax</source>
          <target state="translated">UnsortedSegmentMax</target>
        </trans-unit>
        <trans-unit id="366fa15ecb43d76a152b506219741a7b3f5f0bcd" translate="yes" xml:space="preserve">
          <source>UnsortedSegmentMin</source>
          <target state="translated">UnsortedSegmentMin</target>
        </trans-unit>
        <trans-unit id="6ef6286b2679e6c430cc36837f66e9730b079a8c" translate="yes" xml:space="preserve">
          <source>UnsortedSegmentProd</source>
          <target state="translated">UnsortedSegmentProd</target>
        </trans-unit>
        <trans-unit id="88334ca532d2e8466fab68a79d76f33ec76acf9a" translate="yes" xml:space="preserve">
          <source>UnsortedSegmentSum</source>
          <target state="translated">UnsortedSegmentSum</target>
        </trans-unit>
        <trans-unit id="c32922004f1cab6d2b368005f373dc639dc0003a" translate="yes" xml:space="preserve">
          <source>Unspecified run-time error.</source>
          <target state="translated">Error de tiempo de ejecución no especificado.</target>
        </trans-unit>
        <trans-unit id="b986cea6fdf9453b34548d5133226ff149db996f" translate="yes" xml:space="preserve">
          <source>Unstack the values of a &lt;code&gt;Tensor&lt;/code&gt; in the TensorArray.</source>
          <target state="translated">Desapila los valores de un &lt;code&gt;Tensor&lt;/code&gt; en TensorArray.</target>
        </trans-unit>
        <trans-unit id="7298d7ed988425fb6199864e49341c509f32d027" translate="yes" xml:space="preserve">
          <source>Unstage</source>
          <target state="translated">Unstage</target>
        </trans-unit>
        <trans-unit id="c5093a3d1578793a3f4e74f50d7ce016ac60ef3d" translate="yes" xml:space="preserve">
          <source>Untested. Very likely will not learn to output repeated classes.</source>
          <target state="translated">Sin probar.Es muy probable que no aprenda a dar clases repetidas.</target>
        </trans-unit>
        <trans-unit id="5a0115166e5bef4246c231811f6b2ed301118eb7" translate="yes" xml:space="preserve">
          <source>Until the release of TF 2.0, we need the legacy behavior of &lt;code&gt;TensorShape&lt;/code&gt; to coexist with the new behavior. This utility is a bridge between the two.</source>
          <target state="translated">Hasta el lanzamiento de TF 2.0, necesitamos que el comportamiento heredado de &lt;code&gt;TensorShape&lt;/code&gt; coexista con el nuevo comportamiento. Esta utilidad es un puente entre los dos.</target>
        </trans-unit>
        <trans-unit id="f13be7738e1389f72c0f88aa84d17719f746bf4a" translate="yes" xml:space="preserve">
          <source>Unused.</source>
          <target state="translated">Unused.</target>
        </trans-unit>
        <trans-unit id="673367f4f1a26218e41caccf074dc2728214600f" translate="yes" xml:space="preserve">
          <source>UnwrapDatasetVariant</source>
          <target state="translated">UnwrapDatasetVariant</target>
        </trans-unit>
        <trans-unit id="45306172633156360fe411da89aad86bcba27d77" translate="yes" xml:space="preserve">
          <source>Unwrapping and merging: Consider calling a function &lt;code&gt;fn&lt;/code&gt; on multiple replicas, like &lt;code&gt;experimental_run_v2(fn, args=[w])&lt;/code&gt; with an argument &lt;code&gt;w&lt;/code&gt; that is a wrapped value. This means &lt;code&gt;w&lt;/code&gt; will have a map taking replica id &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;w0&lt;/code&gt;, replica id &lt;code&gt;11&lt;/code&gt; to &lt;code&gt;w1&lt;/code&gt;, etc. &lt;code&gt;experimental_run_v2()&lt;/code&gt; unwraps &lt;code&gt;w&lt;/code&gt; before calling &lt;code&gt;fn&lt;/code&gt;, so it calls &lt;code&gt;fn(w0)&lt;/code&gt; on &lt;code&gt;d0&lt;/code&gt;, &lt;code&gt;fn(w1)&lt;/code&gt; on &lt;code&gt;d1&lt;/code&gt;, etc. It then merges the return values from &lt;code&gt;fn()&lt;/code&gt;, which can possibly result in wrapped values. For example, let's say &lt;code&gt;fn()&lt;/code&gt; returns a tuple with three components: &lt;code&gt;(x, a, v0)&lt;/code&gt; from replica 0, &lt;code&gt;(x, b, v1)&lt;/code&gt; on replica 1, etc. If the first component is the same object &lt;code&gt;x&lt;/code&gt; from every replica, then the first component of the merged result will also be &lt;code&gt;x&lt;/code&gt;. If the second component is different (&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, ...) from each replica, then the merged value will have a wrapped map from replica device to the different values. If the third component is the members of a mirrored variable (&lt;code&gt;v&lt;/code&gt; maps &lt;code&gt;d0&lt;/code&gt; to &lt;code&gt;v0&lt;/code&gt;, &lt;code&gt;d1&lt;/code&gt; to &lt;a href=&quot;../../v1&quot;&gt;&lt;code&gt;v1&lt;/code&gt;&lt;/a&gt;, etc.), then the merged result will be that mirrored variable (&lt;code&gt;v&lt;/code&gt;).</source>
          <target state="translated">Desenvolver y fusionar: considere la posibilidad de llamar a una funci&amp;oacute;n &lt;code&gt;fn&lt;/code&gt; en varias r&amp;eacute;plicas, como &lt;code&gt;experimental_run_v2(fn, args=[w])&lt;/code&gt; con un argumento &lt;code&gt;w&lt;/code&gt; que sea un valor envuelto. Esto significa que &lt;code&gt;w&lt;/code&gt; tendr&amp;aacute; un mapa que tomar&amp;aacute; la identificaci&amp;oacute;n de r&amp;eacute;plica &lt;code&gt;0&lt;/code&gt; a &lt;code&gt;w0&lt;/code&gt; , la identificaci&amp;oacute;n de r&amp;eacute;plica &lt;code&gt;11&lt;/code&gt; a &lt;code&gt;w1&lt;/code&gt; , etc. &lt;code&gt;experimental_run_v2()&lt;/code&gt; desenvuelve &lt;code&gt;w&lt;/code&gt; antes de llamar a &lt;code&gt;fn&lt;/code&gt; , por lo que llama a &lt;code&gt;fn(w0)&lt;/code&gt; en &lt;code&gt;d0&lt;/code&gt; , &lt;code&gt;fn(w1)&lt;/code&gt; en &lt;code&gt;d1&lt;/code&gt; , etc. Luego fusiona los valores de retorno de &lt;code&gt;fn()&lt;/code&gt; , que posiblemente puede resultar en valores ajustados. Por ejemplo, digamos que &lt;code&gt;fn()&lt;/code&gt; devuelve una tupla con tres componentes: &lt;code&gt;(x, a, v0)&lt;/code&gt; de la r&amp;eacute;plica 0, &lt;code&gt;(x, b, v1)&lt;/code&gt; en la r&amp;eacute;plica 1, etc. Si el primer componente es el mismo objeto &lt;code&gt;x&lt;/code&gt; de cada r&amp;eacute;plica, entonces el primer componente del resultado combinado tambi&amp;eacute;n ser&amp;aacute; &lt;code&gt;x&lt;/code&gt; . Si el segundo componente es diferente ( &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , ...) de cada r&amp;eacute;plica, entonces el valor combinado tendr&amp;aacute; un mapa empaquetado del dispositivo de r&amp;eacute;plica a los diferentes valores. Si el tercer componente son los miembros de una variable reflejada ( &lt;code&gt;v&lt;/code&gt; mapea &lt;code&gt;d0&lt;/code&gt; a &lt;code&gt;v0&lt;/code&gt; , &lt;code&gt;d1&lt;/code&gt; a &lt;a href=&quot;../../v1&quot;&gt; &lt;code&gt;v1&lt;/code&gt; &lt;/a&gt;, etc.), el resultado combinado ser&amp;aacute; la variable reflejada ( &lt;code&gt;v&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="452d19a44e1939a79c6b1e46110b7518ec2e32f4" translate="yes" xml:space="preserve">
          <source>Unwrapping and merging: Consider calling a function &lt;code&gt;fn&lt;/code&gt; on multiple replicas, like &lt;code&gt;experimental_run_v2(fn, args=[w])&lt;/code&gt; with an argument &lt;code&gt;w&lt;/code&gt; that is a wrapped value. This means &lt;code&gt;w&lt;/code&gt; will have a map taking replica id &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;w0&lt;/code&gt;, replica id &lt;code&gt;11&lt;/code&gt; to &lt;code&gt;w1&lt;/code&gt;, etc. &lt;code&gt;experimental_run_v2()&lt;/code&gt; unwraps &lt;code&gt;w&lt;/code&gt; before calling &lt;code&gt;fn&lt;/code&gt;, so it calls &lt;code&gt;fn(w0)&lt;/code&gt; on &lt;code&gt;d0&lt;/code&gt;, &lt;code&gt;fn(w1)&lt;/code&gt; on &lt;code&gt;d1&lt;/code&gt;, etc. It then merges the return values from &lt;code&gt;fn()&lt;/code&gt;, which can possibly result in wrapped values. For example, let's say &lt;code&gt;fn()&lt;/code&gt; returns a tuple with three components: &lt;code&gt;(x, a, v0)&lt;/code&gt; from replica 0, &lt;code&gt;(x, b, v1)&lt;/code&gt; on replica 1, etc. If the first component is the same object &lt;code&gt;x&lt;/code&gt; from every replica, then the first component of the merged result will also be &lt;code&gt;x&lt;/code&gt;. If the second component is different (&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, ...) from each replica, then the merged value will have a wrapped map from replica device to the different values. If the third component is the members of a mirrored variable (&lt;code&gt;v&lt;/code&gt; maps &lt;code&gt;d0&lt;/code&gt; to &lt;code&gt;v0&lt;/code&gt;, &lt;code&gt;d1&lt;/code&gt; to &lt;a href=&quot;../compat/v1&quot;&gt;&lt;code&gt;v1&lt;/code&gt;&lt;/a&gt;, etc.), then the merged result will be that mirrored variable (&lt;code&gt;v&lt;/code&gt;).</source>
          <target state="translated">Desenvolver y fusionar: considere la posibilidad de llamar a una funci&amp;oacute;n &lt;code&gt;fn&lt;/code&gt; en varias r&amp;eacute;plicas, como &lt;code&gt;experimental_run_v2(fn, args=[w])&lt;/code&gt; con un argumento &lt;code&gt;w&lt;/code&gt; que sea un valor envuelto. Esto significa que &lt;code&gt;w&lt;/code&gt; tendr&amp;aacute; un mapa que tomar&amp;aacute; la identificaci&amp;oacute;n de r&amp;eacute;plica &lt;code&gt;0&lt;/code&gt; a &lt;code&gt;w0&lt;/code&gt; , la identificaci&amp;oacute;n de r&amp;eacute;plica &lt;code&gt;11&lt;/code&gt; a &lt;code&gt;w1&lt;/code&gt; , etc. &lt;code&gt;experimental_run_v2()&lt;/code&gt; desenvuelve &lt;code&gt;w&lt;/code&gt; antes de llamar a &lt;code&gt;fn&lt;/code&gt; , por lo que llama a &lt;code&gt;fn(w0)&lt;/code&gt; en &lt;code&gt;d0&lt;/code&gt; , &lt;code&gt;fn(w1)&lt;/code&gt; en &lt;code&gt;d1&lt;/code&gt; , etc. Luego fusiona los valores de retorno de &lt;code&gt;fn()&lt;/code&gt; , que posiblemente puede resultar en valores ajustados. Por ejemplo, digamos que &lt;code&gt;fn()&lt;/code&gt; devuelve una tupla con tres componentes: &lt;code&gt;(x, a, v0)&lt;/code&gt; de la r&amp;eacute;plica 0, &lt;code&gt;(x, b, v1)&lt;/code&gt; en la r&amp;eacute;plica 1, etc. Si el primer componente es el mismo objeto &lt;code&gt;x&lt;/code&gt; de cada r&amp;eacute;plica, entonces el primer componente del resultado combinado tambi&amp;eacute;n ser&amp;aacute; &lt;code&gt;x&lt;/code&gt; . Si el segundo componente es diferente ( &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , ...) de cada r&amp;eacute;plica, entonces el valor combinado tendr&amp;aacute; un mapa empaquetado del dispositivo de r&amp;eacute;plica a los diferentes valores. Si el tercer componente son los miembros de una variable reflejada ( &lt;code&gt;v&lt;/code&gt; mapea &lt;code&gt;d0&lt;/code&gt; a &lt;code&gt;v0&lt;/code&gt; , &lt;code&gt;d1&lt;/code&gt; a &lt;a href=&quot;../compat/v1&quot;&gt; &lt;code&gt;v1&lt;/code&gt; &lt;/a&gt;, etc.), el resultado combinado ser&amp;aacute; la variable reflejada ( &lt;code&gt;v&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="447e8380a0660bcbaf0b5a0132d4263bb7475a27" translate="yes" xml:space="preserve">
          <source>Unwraps an object into a list of TFDecorators and a final target.</source>
          <target state="translated">Desenvuelve un objeto en una lista de TFDecoradores y un objetivo final.</target>
        </trans-unit>
        <trans-unit id="f84ad806586080c9477df4b9148217324f31d72e" translate="yes" xml:space="preserve">
          <source>Up-to-date gradients (i.e., time step at which gradient was computed is equal to the accumulator's time step) are added to the accumulator.</source>
          <target state="translated">Los gradientes actualizados (es decir,el paso de tiempo en el que se calculó el gradiente es igual al paso de tiempo del acumulador)se añaden al acumulador.</target>
        </trans-unit>
        <trans-unit id="82d0fcae0670e010a42fb65be9daf931bbfd317f" translate="yes" xml:space="preserve">
          <source>Update '*var' according to the AdaMax algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e38d308cee1cac8d9c2edb27c5ab629ef7fac7d9" translate="yes" xml:space="preserve">
          <source>Update '*var' according to the Adam algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b43e05874006f2166053362d39efb24c1da40cb" translate="yes" xml:space="preserve">
          <source>Update '*var' according to the AddSign update.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52d1d116ee95e78e3bbfd1ce841dc358b8929317" translate="yes" xml:space="preserve">
          <source>Update '*var' according to the Ftrl-proximal scheme.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="471071d3477d079bfcbcf7383ae1d699f1fecd50" translate="yes" xml:space="preserve">
          <source>Update '*var' according to the RMSProp algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff81ee48686edeb07f152d5d3567bb2505faedfb" translate="yes" xml:space="preserve">
          <source>Update '*var' according to the adadelta scheme.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d5ebbbd0b1837c20103e258d32dcbcdda20ba7d" translate="yes" xml:space="preserve">
          <source>Update '*var' according to the adagrad scheme.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="868d113999a0543f3fad5d44d43245c1668a6d37" translate="yes" xml:space="preserve">
          <source>Update '*var' according to the centered RMSProp algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e800b9c7484bc8710e98c151f2fff6a2fd5d03ac" translate="yes" xml:space="preserve">
          <source>Update '*var' according to the momentum scheme.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d77d08a52fed9d23da57628bfa85afe8cc236bc" translate="yes" xml:space="preserve">
          <source>Update '*var' according to the proximal adagrad scheme.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="787674ac15a7f58c7a9bd7dc691b153215067ce5" translate="yes" xml:space="preserve">
          <source>Update '*var' as FOBOS algorithm with fixed learning rate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abf5d76205f9777481707bb7900ee4d7f09321a8" translate="yes" xml:space="preserve">
          <source>Update '*var' by subtracting 'alpha' * 'delta' from it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9efdd46b9ea48522d76a8280bde64699fbd0f6a5" translate="yes" xml:space="preserve">
          <source>Update '&lt;em&gt;var' and '&lt;/em&gt;accum' according to FOBOS with Adagrad learning rate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe20dc33f34485fdead6adf9d07e849e8a936d69" translate="yes" xml:space="preserve">
          <source>Update 'ref' by adding 'value' to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9257701af71d4f765da34dcd01e8df105b8aa44" translate="yes" xml:space="preserve">
          <source>Update 'ref' by assigning 'value' to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29365e08f06cd2686f25f0d377b66ff5415b759c" translate="yes" xml:space="preserve">
          <source>Update 'ref' by subtracting 'value' from it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fe8e246cbfb66ec49e8326c839db8c07c5c7366" translate="yes" xml:space="preserve">
          <source>Update (</source>
          <target state="translated">Actualización (</target>
        </trans-unit>
        <trans-unit id="6509bc67c069e61a7a1a3a68aa4391deff81b6d2" translate="yes" xml:space="preserve">
          <source>Update &lt;code&gt;ref&lt;/code&gt; by adding &lt;code&gt;value&lt;/code&gt; to it.</source>
          <target state="translated">Actualice la &lt;code&gt;ref&lt;/code&gt; erencia agregando &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05a75e8ad72ec7a17916b0418183b2ae49757686" translate="yes" xml:space="preserve">
          <source>Update &lt;code&gt;ref&lt;/code&gt; by assigning &lt;code&gt;value&lt;/code&gt; to it.</source>
          <target state="translated">Actualice la &lt;code&gt;ref&lt;/code&gt; erencia asign&amp;aacute;ndole un &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0da9a4ecf7a09eb5b3d6a68070c44c71f746dcb9" translate="yes" xml:space="preserve">
          <source>Update &lt;code&gt;ref&lt;/code&gt; by subtracting &lt;code&gt;value&lt;/code&gt; from it.</source>
          <target state="translated">Actualice la &lt;code&gt;ref&lt;/code&gt; erencia restando un &lt;code&gt;value&lt;/code&gt; de ella.</target>
        </trans-unit>
        <trans-unit id="04cf114f82db9c03d560972fce4e303ff3f2a1fd" translate="yes" xml:space="preserve">
          <source>Update entries in '&lt;em&gt;var' and '&lt;/em&gt;accum' according to the proximal adagrad scheme.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d6d9dee5acd7031de9e9744560f0e2f29a28a2c" translate="yes" xml:space="preserve">
          <source>Update op.</source>
          <target state="translated">Actualización de la operación.</target>
        </trans-unit>
        <trans-unit id="447e87cca9a900913e2b362703c44b530d8ad36e" translate="yes" xml:space="preserve">
          <source>Update relevant entries in '*var' according to the Ftrl-proximal scheme.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97803936ee3881b955dd554c9048e1fb8c7cee65" translate="yes" xml:space="preserve">
          <source>Update relevant entries in '&lt;em&gt;var' and '&lt;/em&gt;accum' according to the adagrad scheme.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6438974b08aca642d6bcdb677ce1d3cc168f6c3" translate="yes" xml:space="preserve">
          <source>Update relevant entries in '&lt;em&gt;var' and '&lt;/em&gt;accum' according to the momentum scheme.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f3b6f8527ee9f9f2b48e9baa56537bfbb1fe75d" translate="yes" xml:space="preserve">
          <source>Update rule for parameter &lt;code&gt;w&lt;/code&gt; with gradient &lt;code&gt;g&lt;/code&gt; when &lt;code&gt;momentum&lt;/code&gt; is 0:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63b0c5665a5cecb00d89f2c99aeee6da821e96bf" translate="yes" xml:space="preserve">
          <source>Update rule when &lt;code&gt;momentum&lt;/code&gt; is larger than 0:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3f52bac13b63cbb6e97bf073a84b716bbe078b6" translate="yes" xml:space="preserve">
          <source>Update step:</source>
          <target state="translated">Paso de actualización:</target>
        </trans-unit>
        <trans-unit id="a77038db17ca8f9cacdb34920018f09eddc93c47" translate="yes" xml:space="preserve">
          <source>Update the last triggered time and step number.</source>
          <target state="translated">Actualiza el último tiempo de activación y el número de paso.</target>
        </trans-unit>
        <trans-unit id="d386d7ccaa88b6dedf1b5040c55b451c526442d6" translate="yes" xml:space="preserve">
          <source>Update the value of &lt;code&gt;x&lt;/code&gt; by adding &lt;code&gt;increment&lt;/code&gt;.</source>
          <target state="translated">Actualice el valor de &lt;code&gt;x&lt;/code&gt; agregando &lt;code&gt;increment&lt;/code&gt; o .</target>
        </trans-unit>
        <trans-unit id="bbd7754fb14c25638e64d5d064bb72937445b6c4" translate="yes" xml:space="preserve">
          <source>Update the value of &lt;code&gt;x&lt;/code&gt; by subtracting &lt;code&gt;decrement&lt;/code&gt;.</source>
          <target state="translated">Actualice el valor de &lt;code&gt;x&lt;/code&gt; restando &lt;code&gt;decrement&lt;/code&gt; o .</target>
        </trans-unit>
        <trans-unit id="bdd024c3635252f3a95af60168a7a02c85468f31" translate="yes" xml:space="preserve">
          <source>Updated base class for optimizers.</source>
          <target state="translated">Clase base actualizada para los optimizadores.</target>
        </trans-unit>
        <trans-unit id="f63d62e4ed45a361aebb6397e1fccc02f07b3ec2" translate="yes" xml:space="preserve">
          <source>Updates eval metrics. See &lt;code&gt;base_head.Head&lt;/code&gt; for details.</source>
          <target state="translated">Actualiza las m&amp;eacute;tricas de evaluaci&amp;oacute;n. Consulte &lt;code&gt;base_head.Head&lt;/code&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="25882cbb9d1b53825b652d00bf42872915dbaa9e" translate="yes" xml:space="preserve">
          <source>Updates internal vocabulary based on a list of sequences.</source>
          <target state="translated">Actualiza el vocabulario interno basado en una lista de secuencias.</target>
        </trans-unit>
        <trans-unit id="852460ee15870b6e90ad0684cbc07e2e2a1a46d1" translate="yes" xml:space="preserve">
          <source>Updates internal vocabulary based on a list of texts.</source>
          <target state="translated">Actualiza el vocabulario interno basado en una lista de textos.</target>
        </trans-unit>
        <trans-unit id="bf38595a5f74f710192dab7d4c5a5b9f35f64f69" translate="yes" xml:space="preserve">
          <source>Updates loss scale based on if gradients are finite in current step.</source>
          <target state="translated">Actualiza la escala de pérdidas en base a si los gradientes son finitos en el paso actual.</target>
        </trans-unit>
        <trans-unit id="3ff6b49a83b568897a31a71591847bcb981cfe8c" translate="yes" xml:space="preserve">
          <source>Updates metric objects and returns a &lt;code&gt;dict&lt;/code&gt; of the updated metrics.</source>
          <target state="translated">Actualiza los objetos m&amp;eacute;tricos y devuelve un &lt;code&gt;dict&lt;/code&gt; ado de las m&amp;eacute;tricas actualizadas.</target>
        </trans-unit>
        <trans-unit id="c1444a8720b007d3bc3efc14cd0416a718bdfe20" translate="yes" xml:space="preserve">
          <source>Updates specified rows 'i' with values 'v'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da9e8385ef1cee6fd5a3ef89050fbd2471b13c5e" translate="yes" xml:space="preserve">
          <source>Updates the accumulator with a new value for global_step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04014643289292114c04f072ec1d42a7ffcf535f" translate="yes" xml:space="preserve">
          <source>Updates the content of the 'checkpoint' file. (deprecated)</source>
          <target state="translated">Actualiza el contenido del archivo del &quot;punto de control&quot;.(desaprobado)</target>
        </trans-unit>
        <trans-unit id="e27ee7c5bc27400dd7ff516cc28fe06e87e352bf" translate="yes" xml:space="preserve">
          <source>Updates the method name(s) of the SavedModel stored in the given path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="114215d83f25c29dd880192b62cf9c4d735d8aca" translate="yes" xml:space="preserve">
          <source>Updates the progress bar.</source>
          <target state="translated">Actualiza la barra de progreso.</target>
        </trans-unit>
        <trans-unit id="f3aa5183ae2c5fffe19c95fc5154e5548921fe2d" translate="yes" xml:space="preserve">
          <source>Updates the shape of a tensor and checks at runtime that the shape holds.</source>
          <target state="translated">Actualiza la forma de un tensor y comprueba en tiempo de ejecución que la forma se mantiene.</target>
        </trans-unit>
        <trans-unit id="d45fc3ae1d9fcc9b117583faaa29b9c68525b6d1" translate="yes" xml:space="preserve">
          <source>Updates the shape of this tensor.</source>
          <target state="translated">Actualiza la forma de este tensor.</target>
        </trans-unit>
        <trans-unit id="f590327e9570d8c3a01e570e103d03bfc643e1c5" translate="yes" xml:space="preserve">
          <source>Updates the table to associates keys with values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfb5af8bff1bdbad2b00e834b01497c1e3817b80" translate="yes" xml:space="preserve">
          <source>Updates the tree ensemble by adding a layer to the last tree being grown</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6834941215f45b3c876acacc8e8c580f1e32c40" translate="yes" xml:space="preserve">
          <source>Updates the tree ensemble by either adding a layer to the last tree being grown</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd283fb80513334be997d84fc1ce654a3740f2f1" translate="yes" xml:space="preserve">
          <source>Updates the value of the loss scale.</source>
          <target state="translated">Actualiza el valor de la escala de pérdidas.</target>
        </trans-unit>
        <trans-unit id="56d5a06c3dd0023752b72f3ca770e1ae3effe80d" translate="yes" xml:space="preserve">
          <source>Updates this variable with the max of &lt;a href=&quot;../../indexedslices&quot;&gt;&lt;code&gt;tf.IndexedSlices&lt;/code&gt;&lt;/a&gt; and itself.</source>
          <target state="translated">Actualiza esta variable con el m&amp;aacute;ximo de &lt;a href=&quot;../../indexedslices&quot;&gt; &lt;code&gt;tf.IndexedSlices&lt;/code&gt; &lt;/a&gt; y ella misma.</target>
        </trans-unit>
        <trans-unit id="0b0e1aa88bedb98a31d52dc0db2aabdbdc628dd2" translate="yes" xml:space="preserve">
          <source>Updates this variable with the max of &lt;a href=&quot;indexedslices&quot;&gt;&lt;code&gt;tf.IndexedSlices&lt;/code&gt;&lt;/a&gt; and itself.</source>
          <target state="translated">Actualiza esta variable con el m&amp;aacute;ximo de &lt;a href=&quot;indexedslices&quot;&gt; &lt;code&gt;tf.IndexedSlices&lt;/code&gt; &lt;/a&gt; y ella misma.</target>
        </trans-unit>
        <trans-unit id="729d65b580f1272ed91207fc8a10aa3312f5c72c" translate="yes" xml:space="preserve">
          <source>Updates this variable with the min of &lt;a href=&quot;../../indexedslices&quot;&gt;&lt;code&gt;tf.IndexedSlices&lt;/code&gt;&lt;/a&gt; and itself.</source>
          <target state="translated">Actualiza esta variable con el m&amp;iacute;nimo de &lt;a href=&quot;../../indexedslices&quot;&gt; &lt;code&gt;tf.IndexedSlices&lt;/code&gt; &lt;/a&gt; y ella misma.</target>
        </trans-unit>
        <trans-unit id="ee9c6cf89fa6d5d3bc7214b300a7628504d2e372" translate="yes" xml:space="preserve">
          <source>Updates this variable with the min of &lt;a href=&quot;indexedslices&quot;&gt;&lt;code&gt;tf.IndexedSlices&lt;/code&gt;&lt;/a&gt; and itself.</source>
          <target state="translated">Actualiza esta variable con el m&amp;iacute;nimo de &lt;a href=&quot;indexedslices&quot;&gt; &lt;code&gt;tf.IndexedSlices&lt;/code&gt; &lt;/a&gt; y ella misma.</target>
        </trans-unit>
        <trans-unit id="b62b62db1c38cdd8d87bd06d704758f1b3977490" translate="yes" xml:space="preserve">
          <source>Updating and clearing custom objects using &lt;code&gt;custom_object_scope&lt;/code&gt; is preferred, but &lt;code&gt;get_custom_objects&lt;/code&gt; can be used to directly access &lt;code&gt;_GLOBAL_CUSTOM_OBJECTS&lt;/code&gt;.</source>
          <target state="translated">Se prefiere actualizar y borrar objetos personalizados mediante &lt;code&gt;custom_object_scope&lt;/code&gt; , pero &lt;code&gt;get_custom_objects&lt;/code&gt; se puede utilizar para acceder directamente a &lt;code&gt;_GLOBAL_CUSTOM_OBJECTS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd72d1503f9d3fb82ce4c9572b6d9a18a62eb0ba" translate="yes" xml:space="preserve">
          <source>Updating and clearing custom objects using &lt;code&gt;custom_object_scope&lt;/code&gt; is preferred, but &lt;code&gt;get_custom_objects&lt;/code&gt; can be used to directly access the current collection of custom objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="281cba0fb3149b6c3774ed01f37649638874e882" translate="yes" xml:space="preserve">
          <source>Upon a load, the subset of variables and assets supplied as part of the specific meta graph def, will be restored into the supplied session. The values of the variables though will correspond to the saved values from the first meta graph added to the SavedModel using &lt;code&gt;add_meta_graph_and_variables(...)&lt;/code&gt; in &lt;code&gt;builder.py&lt;/code&gt;.</source>
          <target state="translated">Tras una carga, el subconjunto de variables y activos proporcionados como parte de la definici&amp;oacute;n espec&amp;iacute;fica del meta gr&amp;aacute;fico se restaurar&amp;aacute; en la sesi&amp;oacute;n proporcionada. Sin embargo, los valores de las variables corresponder&amp;aacute;n a los valores guardados del primer meta gr&amp;aacute;fico agregado al modelo guardado usando &lt;code&gt;add_meta_graph_and_variables(...)&lt;/code&gt; en &lt;code&gt;builder.py&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="363a67d86f68374ba8c4a4cfbabbae29d79775ae" translate="yes" xml:space="preserve">
          <source>Upon removal from the active set, a checkpoint will be preserved if it has been at least &lt;code&gt;keep_checkpoint_every_n_hours&lt;/code&gt; since the last preserved checkpoint. The default setting of &lt;code&gt;None&lt;/code&gt; does not preserve any checkpoints in this way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ceee3a3a486ed4178c6d9fbac07e5800c6e5b47" translate="yes" xml:space="preserve">
          <source>Upper bound on the number of partitions. Defaults to 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e44dc51c175ff5c0db1e82d8dfe21d3d95479e8" translate="yes" xml:space="preserve">
          <source>Upper boundary of the output interval.</source>
          <target state="translated">Límite superior del intervalo de salida.</target>
        </trans-unit>
        <trans-unit id="19aecdfa7cdf02c6ca74a44e34017ebb74fcec55" translate="yes" xml:space="preserve">
          <source>UpperBound</source>
          <target state="translated">UpperBound</target>
        </trans-unit>
        <trans-unit id="c31d78903813b3bcaeecbae756ddce1af8f35bae" translate="yes" xml:space="preserve">
          <source>Upsampling layer for 1D inputs.</source>
          <target state="translated">Capa de muestreo para entradas 1D.</target>
        </trans-unit>
        <trans-unit id="7b0d1a97658971e96b3f9be123da52362174eefa" translate="yes" xml:space="preserve">
          <source>Upsampling layer for 2D inputs.</source>
          <target state="translated">Capa de muestreo para entradas 2D.</target>
        </trans-unit>
        <trans-unit id="d8e99e181057faa2a85bca621f7cd639c1901c16" translate="yes" xml:space="preserve">
          <source>Upsampling layer for 3D inputs.</source>
          <target state="translated">Capa de muestreo para entradas 3D.</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="9629fc5be7eebf84f66a1a4fe14d7eee29fbc498" translate="yes" xml:space="preserve">
          <source>Usage Example:</source>
          <target state="translated">Ejemplo de uso:</target>
        </trans-unit>
        <trans-unit id="c697e1f98f6b38e0ebf986cdde5209243dc5a1fb" translate="yes" xml:space="preserve">
          <source>Usage example with &lt;a href=&quot;../mobilenet&quot;&gt;&lt;code&gt;applications.MobileNet&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7878482cb2d732b2ccb44cbc91378bf291581491" translate="yes" xml:space="preserve">
          <source>Usage example with &lt;a href=&quot;../strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b925d1a88d8e7cc54989fe4e8d7270088645c5c3" translate="yes" xml:space="preserve">
          <source>Usage example with tf.distribute.Strategy:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fec43ce445f974147bd0eb223a50147e7fb7202d" translate="yes" xml:space="preserve">
          <source>Usage example:</source>
          <target state="translated">Ejemplo de uso:</target>
        </trans-unit>
        <trans-unit id="77817d0a0c43f5e8811381e684f28870ad0caaef" translate="yes" xml:space="preserve">
          <source>Usage in a &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Uso en una funci&amp;oacute;n &lt;a href=&quot;function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="801e743874a5f137b8515158c4ad1c682d3d5c9a" translate="yes" xml:space="preserve">
          <source>Usage in a functional model:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f55d9b06976fb1e7cdaee8fa9d5e54cd7e87ed03" translate="yes" xml:space="preserve">
          <source>Usage in custom training loops</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7229b161af4f523b13ed9ebb0ca67db64df129d" translate="yes" xml:space="preserve">
          <source>Usage with &lt;code&gt;compile()&lt;/code&gt; API:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e990e47405f0ff9e5047d2be7faad8352983c3d7" translate="yes" xml:space="preserve">
          <source>Usage with a canned estimator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7f68eccfb39ab6d5044b1fe94d8202e173daf81" translate="yes" xml:space="preserve">
          <source>Usage with distribution strategy and custom training loop:</source>
          <target state="translated">Uso con estrategia de distribución y bucle de entrenamiento personalizado:</target>
        </trans-unit>
        <trans-unit id="e394973fc15ca8e6a0ab7b5e15b6537c110fcd61" translate="yes" xml:space="preserve">
          <source>Usage with tf.keras API:</source>
          <target state="translated">Uso con el API de tf.keras:</target>
        </trans-unit>
        <trans-unit id="b672bfd407587ac4347c7d14f539f0167c943965" translate="yes" xml:space="preserve">
          <source>Usage with the &lt;a href=&quot;../../keras&quot;&gt;&lt;code&gt;tf.keras&lt;/code&gt;&lt;/a&gt; API:</source>
          <target state="translated">Uso con la API &lt;a href=&quot;../../keras&quot;&gt; &lt;code&gt;tf.keras&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="96ba7c58b31b72cda1421876078e636d93a95906" translate="yes" xml:space="preserve">
          <source>Usage with the &lt;code&gt;compile()&lt;/code&gt; API:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3a64fc9df2f2b5aa9b2b0f2f696a9fa962d415a" translate="yes" xml:space="preserve">
          <source>Usage with the &lt;code&gt;compile&lt;/code&gt; API:</source>
          <target state="translated">Uso con la API de &lt;code&gt;compile&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="030e432f7e4bb780778d21710d19d27e9dde09e7" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../keras/models/load_model&quot;&gt;&lt;code&gt;tf.keras.models.load_model&lt;/code&gt;&lt;/a&gt; to restore the Keras model.</source>
          <target state="translated">Utilice &lt;a href=&quot;../keras/models/load_model&quot;&gt; &lt;code&gt;tf.keras.models.load_model&lt;/code&gt; &lt;/a&gt; para restaurar el modelo de Keras.</target>
        </trans-unit>
        <trans-unit id="d4c2fa90899bd40eef81dcc968f1e443a9a43ef7" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;global_variables&quot;&gt;&lt;code&gt;tf.compat.v1.global_variables&lt;/code&gt;&lt;/a&gt; instead. (deprecated)</source>
          <target state="translated">&lt;a href=&quot;global_variables&quot;&gt; &lt;code&gt;tf.compat.v1.global_variables&lt;/code&gt; &lt;/a&gt; lugar, use tf.compat.v1.global_variables . (obsoleto)</target>
        </trans-unit>
        <trans-unit id="3209823decab9f9b116ef0a97be20eccaaae6362" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;strategy#experimental_distribute_dataset&quot;&gt;&lt;code&gt;tf.distribute.Strategy.experimental_distribute_dataset&lt;/code&gt;&lt;/a&gt; to convert a &lt;a href=&quot;../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; to something that produces &quot;per-replica&quot; values. If you want to manually specify how the dataset should be partitioned across replicas, use &lt;a href=&quot;strategy#experimental_distribute_datasets_from_function&quot;&gt;&lt;code&gt;tf.distribute.Strategy.experimental_distribute_datasets_from_function&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Utilice &lt;a href=&quot;strategy#experimental_distribute_dataset&quot;&gt; &lt;code&gt;tf.distribute.Strategy.experimental_distribute_dataset&lt;/code&gt; &lt;/a&gt; para convertir un &lt;a href=&quot;../data/dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; &lt;/a&gt; en algo que produzca valores &quot;por r&amp;eacute;plica&quot;. Si desea especificar manualmente c&amp;oacute;mo se debe dividir el conjunto de datos en las r&amp;eacute;plicas, use &lt;a href=&quot;strategy#experimental_distribute_datasets_from_function&quot;&gt; &lt;code&gt;tf.distribute.Strategy.experimental_distribute_datasets_from_function&lt;/code&gt; &lt;/a&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="8ee5b2fdcd82632d020da9ff566a06840585c6ea" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;strategy#experimental_run_v2&quot;&gt;&lt;code&gt;tf.distribute.Strategy.experimental_run_v2&lt;/code&gt;&lt;/a&gt; to run a function once per replica, taking values that may be &quot;per-replica&quot; (e.g. from a distributed dataset) and returning &quot;per-replica&quot; values. This function is executed in &quot;replica context&quot;, which means each operation is performed separately on each replica.</source>
          <target state="translated">Utilice &lt;a href=&quot;strategy#experimental_run_v2&quot;&gt; &lt;code&gt;tf.distribute.Strategy.experimental_run_v2&lt;/code&gt; &lt;/a&gt; para ejecutar una funci&amp;oacute;n una vez por r&amp;eacute;plica, tomando valores que pueden ser &quot;por r&amp;eacute;plica&quot; (por ejemplo, de un conjunto de datos distribuido) y devolviendo valores &quot;por r&amp;eacute;plica&quot;. Esta funci&amp;oacute;n se ejecuta en &quot;contexto de r&amp;eacute;plica&quot;, lo que significa que cada operaci&amp;oacute;n se realiza por separado en cada r&amp;eacute;plica.</target>
        </trans-unit>
        <trans-unit id="d62a49dd6dc46f4c7a9acf5f4db7938f8cbc782e" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;strategy#run&quot;&gt;&lt;code&gt;tf.distribute.Strategy.run&lt;/code&gt;&lt;/a&gt; to run a function once per replica, taking values that may be &quot;per-replica&quot; (e.g. from a &lt;a href=&quot;distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt; object) and returning &quot;per-replica&quot; values. This function is executed in &quot;replica context&quot;, which means each operation is performed separately on each replica.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b44531c2feeada9ccb9c2de903665876111434ff" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;__floordiv__&lt;/code&gt; via &lt;code&gt;x // y&lt;/code&gt; instead.</source>
          <target state="translated">Utilice &lt;code&gt;__floordiv__&lt;/code&gt; a trav&amp;eacute;s de &lt;code&gt;x // y&lt;/code&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="2767ed64c3817a4622daa8e917be1f662fce734c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;as_numpy_iterator&lt;/code&gt; to inspect the content of your dataset. To see element shapes and types, print dataset elements directly instead of using &lt;code&gt;as_numpy_iterator&lt;/code&gt;.</source>
          <target state="translated">Usa &lt;code&gt;as_numpy_iterator&lt;/code&gt; para inspeccionar el contenido de tu conjunto de datos. Para ver formas y tipos de elementos, imprima los elementos del conjunto de datos directamente en lugar de usar &lt;code&gt;as_numpy_iterator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e94740ffc34912a09c1d4271d0d2a19f29965942" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;distribution&lt;/code&gt; to create a linear combination of &lt;code&gt;value&lt;/code&gt; with shape &lt;code&gt;[batch_size, Tq, dim]&lt;/code&gt;: &lt;code&gt;return tf.matmul(distribution, value)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eb34124b3d3c72e61b1960b8b0273621cb17166" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;distribution&lt;/code&gt; to create a linear combination of &lt;code&gt;value&lt;/code&gt; with shape &lt;code&gt;batch_size, Tq, dim]&lt;/code&gt;: &lt;code&gt;return tf.matmul(distribution, value)&lt;/code&gt;.</source>
          <target state="translated">Utilice la &lt;code&gt;distribution&lt;/code&gt; para crear una combinaci&amp;oacute;n lineal de &lt;code&gt;value&lt;/code&gt; con la forma &lt;code&gt;batch_size, Tq, dim]&lt;/code&gt; : &lt;code&gt;return tf.matmul(distribution, value)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="44e30be08758ea8ade80932cd95cdb8d64bb47a8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;flat_map&lt;/code&gt; if you want to make sure that the order of your dataset stays the same. For example, to flatten a dataset of batches into a dataset of their elements:</source>
          <target state="translated">Utilice &lt;code&gt;flat_map&lt;/code&gt; si desea asegurarse de que el orden de su conjunto de datos sea el mismo. Por ejemplo, para aplanar un conjunto de datos de lotes en un conjunto de datos de sus elementos:</target>
        </trans-unit>
        <trans-unit id="7a992c4c721de761461c5374c7bd3a4aff948363" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;get_slot_names()&lt;/code&gt; to get the list of slot names created by the &lt;code&gt;Optimizer&lt;/code&gt;.</source>
          <target state="translated">Utilice &lt;code&gt;get_slot_names()&lt;/code&gt; para obtener la lista de nombres de ranuras creada por el &lt;code&gt;Optimizer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="91f7ee28a1020db4d8680f6cfcc039630f6cf6c7" translate="yes" xml:space="preserve">
          <source>Use Keras-style variable management.</source>
          <target state="translated">Utiliza el manejo de variables al estilo de Keras.</target>
        </trans-unit>
        <trans-unit id="440e973c7f91d2791a9db2a23271859d554779a3" translate="yes" xml:space="preserve">
          <source>Use QuantizeAndDequantizeV2 instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c72ad8c259b53b87feb4b811bfb9903790a506c0" translate="yes" xml:space="preserve">
          <source>Use RandomPoissonV2 instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2150f7b0818a8c9614aab9559af6a58afcb70753" translate="yes" xml:space="preserve">
          <source>Use VariableV2 instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9643c07a64899011c5e66444b786696c2c1f292c" translate="yes" xml:space="preserve">
          <source>Use a GPU</source>
          <target state="translated">Usar una GPU</target>
        </trans-unit>
        <trans-unit id="0ef12200042309c3ec0320c88bb43b5872439b7c" translate="yes" xml:space="preserve">
          <source>Use a TPU</source>
          <target state="translated">Usar un TPU</target>
        </trans-unit>
        <trans-unit id="55e615040b350f7d0e69b2efeab665769ae7dff0" translate="yes" xml:space="preserve">
          <source>Use cached_session instead. (deprecated)</source>
          <target state="translated">Usa la sesión en caché en su lugar.(desaprobado)</target>
        </trans-unit>
        <trans-unit id="a45a7fcfd0c3a826284614faab211360451f5baa" translate="yes" xml:space="preserve">
          <source>Use control flow v2.</source>
          <target state="translated">Use el flujo de control v2.</target>
        </trans-unit>
        <trans-unit id="370035f7e921eeac90f213974c56e368a0053937" translate="yes" xml:space="preserve">
          <source>Use for a single program</source>
          <target state="translated">Usar para un solo programa</target>
        </trans-unit>
        <trans-unit id="f43fa9092b2f91bd555938c5ea3e365d94b5e8be" translate="yes" xml:space="preserve">
          <source>Use for multiple replicas</source>
          <target state="translated">Uso para múltiples réplicas</target>
        </trans-unit>
        <trans-unit id="475c1ea44e2680d527418552a01d0d387b8889b0" translate="yes" xml:space="preserve">
          <source>Use is_tensor to differentiate types that can ingested by TensorFlow ops without any conversion (e.g., &lt;a href=&quot;tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.SparseTensor&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt;) from types that need to be converted into tensors before they are ingested (e.g., numpy &lt;code&gt;ndarray&lt;/code&gt; and Python scalars).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1492e12db8287cba745968988a12ad01c3a722bf" translate="yes" xml:space="preserve">
          <source>Use lazy Adam instead of Adam. Lazy Adam trains faster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bb5bf2a72112cde73c306a36e21803143fe65db" translate="yes" xml:space="preserve">
          <source>Use lazy Adam instead of Adam. Lazy Adam trains faster. Please see &lt;code&gt;optimization_parameters.proto&lt;/code&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8399a93fbe608ceae7467ffa9f4443f49ecb43c5" translate="yes" xml:space="preserve">
          <source>Use regexes=[''] for a regex that will always pass.</source>
          <target state="translated">Use regexes=['']para un regex que siempre pasará.</target>
        </trans-unit>
        <trans-unit id="89fcdf03d75c5035154abf603c2a5d6a8e7923ee" translate="yes" xml:space="preserve">
          <source>Use scores to calculate a distribution with shape &lt;code&gt;[batch_size, Tq, Tv]&lt;/code&gt;: &lt;code&gt;distribution = tf.nn.softmax(scores)&lt;/code&gt;.</source>
          <target state="translated">Utilice puntuaciones para calcular una distribuci&amp;oacute;n con forma &lt;code&gt;[batch_size, Tq, Tv]&lt;/code&gt; : &lt;code&gt;distribution = tf.nn.softmax(scores)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="434fa6ee48f96c719d58baf9d88af78b48a7c5de" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;use_gpu&lt;/code&gt; and &lt;code&gt;force_gpu&lt;/code&gt; options to control where ops are run. If &lt;code&gt;force_gpu&lt;/code&gt; is True, all ops are pinned to &lt;code&gt;/device:GPU:0&lt;/code&gt;. Otherwise, if &lt;code&gt;use_gpu&lt;/code&gt; is True, TensorFlow tries to run as many ops on the GPU as possible. If both &lt;code&gt;force_gpu and&lt;/code&gt;use_gpu` are False, all ops are pinned to the CPU.</source>
          <target state="translated">Utilice las opciones &lt;code&gt;use_gpu&lt;/code&gt; y &lt;code&gt;force_gpu&lt;/code&gt; para controlar d&amp;oacute;nde se ejecutan las operaciones. Si &lt;code&gt;force_gpu&lt;/code&gt; es True, todas las operaciones se anclan a &lt;code&gt;/device:GPU:0&lt;/code&gt; . De lo contrario, si &lt;code&gt;use_gpu&lt;/code&gt; es True, TensorFlow intenta ejecutar tantas operaciones en la GPU como sea posible. Si tanto &lt;code&gt;force_gpu and&lt;/code&gt; use_gpu` son False, todas las operaciones se anclan a la CPU.</target>
        </trans-unit>
        <trans-unit id="af3eb58bfa11b2e816bf06bf154e9dd3eaba2e36" translate="yes" xml:space="preserve">
          <source>Use the adjoint of A in the matrix multiply. If A is complex, this is transpose(conj(A)). Otherwise it's transpose(A).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b81ee9831f55618dc71b894972452125c1c0e087" translate="yes" xml:space="preserve">
          <source>Use the adjoint of B in the matrix multiply. If B is complex, this is transpose(conj(B)). Otherwise it's transpose(B).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd23d3f693402848b5c571179d734fa24d293240" translate="yes" xml:space="preserve">
          <source>Use the flag on the command line multiple times to place multiple enum values into the list.</source>
          <target state="translated">Utilice la bandera en la línea de comandos varias veces para colocar varios valores enum en la lista.</target>
        </trans-unit>
        <trans-unit id="d2ec95228b5df088b9e12de695d7a5b48f073d13" translate="yes" xml:space="preserve">
          <source>Use the flag on the command line multiple times to place multiple enum values into the list. The 'default' may be a single string (which will be converted into a single-element list) or a list of strings.</source>
          <target state="translated">Utilice la bandera en la línea de comandos varias veces para colocar varios valores enum en la lista.El &quot;valor por defecto&quot; puede ser una sola cadena (que se convertirá en una lista de un solo elemento)o una lista de cadenas.</target>
        </trans-unit>
        <trans-unit id="7cd854f1deb653ced29c38efa8b46ec0bd203ec8" translate="yes" xml:space="preserve">
          <source>Use the flag on the command line multiple times to place multiple float values into the list. The 'default' may be a single float (which will be converted into a single-element list) or a list of floats.</source>
          <target state="translated">Utilice la bandera en la línea de comandos varias veces para colocar varios valores de flotación en la lista.El &quot;valor por defecto&quot; puede ser un solo flotador (que se convertirá en una lista de un solo elemento)o una lista de flotadores.</target>
        </trans-unit>
        <trans-unit id="0ba777030d82e3febc7f170821e4862f2ace63cd" translate="yes" xml:space="preserve">
          <source>Use the flag on the command line multiple times to place multiple integer values into the list. The 'default' may be a single integer (which will be converted into a single-element list) or a list of integers.</source>
          <target state="translated">Use la bandera en la línea de comando varias veces para colocar múltiples valores enteros en la lista.El &quot;valor por defecto&quot; puede ser un solo entero (que se convertirá en una lista de un solo elemento)o una lista de enteros.</target>
        </trans-unit>
        <trans-unit id="b36c5e7734d6891179ff0616c0be42883b3178af" translate="yes" xml:space="preserve">
          <source>Use the flag on the command line multiple times to place multiple string values into the list. The 'default' may be a single string (which will be converted into a single-element list) or a list of strings.</source>
          <target state="translated">Utilice la bandera en la línea de comandos varias veces para colocar varios valores de cadena en la lista.El &quot;valor por defecto&quot; puede ser una sola cadena (que se convertirá en una lista de un solo elemento)o una lista de cadenas.</target>
        </trans-unit>
        <trans-unit id="d3dd2345ae786232011837f1b50ba242eb1986f2" translate="yes" xml:space="preserve">
          <source>Use this cross-entropy loss when there are only two label classes (assumed to be 0 and 1). For each example, there should be a single floating-point value per prediction.</source>
          <target state="translated">Utilice esta pérdida de entropía cruzada cuando sólo hay dos clases de etiquetas (se supone que son 0 y 1).Para cada ejemplo,debe haber un único valor de punto flotante por predicción.</target>
        </trans-unit>
        <trans-unit id="cea461fc9af427f5cd3544343b029f1c2bab9d0b" translate="yes" xml:space="preserve">
          <source>Use this crossentropy loss function when there are two or more label classes. We expect labels to be provided as integers. If you want to provide labels using &lt;code&gt;one-hot&lt;/code&gt; representation, please use &lt;code&gt;CategoricalCrossentropy&lt;/code&gt; loss. There should be &lt;code&gt;# classes&lt;/code&gt; floating point values per feature for &lt;code&gt;y_pred&lt;/code&gt; and a single floating point value per feature for &lt;code&gt;y_true&lt;/code&gt;.</source>
          <target state="translated">Utilice esta funci&amp;oacute;n de p&amp;eacute;rdida de entrop&amp;iacute;a cruzada cuando haya dos o m&amp;aacute;s clases de etiquetas. Esperamos que las etiquetas se proporcionen como n&amp;uacute;meros enteros. Si desea proporcionar etiquetas utilizando &lt;code&gt;one-hot&lt;/code&gt; representaci&amp;oacute;n en caliente , utilice la p&amp;eacute;rdida de &lt;code&gt;CategoricalCrossentropy&lt;/code&gt; entrop&amp;iacute;a categ&amp;oacute;rica . Debe haber &lt;code&gt;# classes&lt;/code&gt; valores de punto flotante por caracter&amp;iacute;stica para &lt;code&gt;y_pred&lt;/code&gt; y un &amp;uacute;nico valor de punto flotante por caracter&amp;iacute;stica para &lt;code&gt;y_true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78d33f54d7ac855026c26bfd507ca58a0c209d64" translate="yes" xml:space="preserve">
          <source>Use this crossentropy loss function when there are two or more label classes. We expect labels to be provided in a &lt;code&gt;one_hot&lt;/code&gt; representation. If you want to provide labels as integers, please use &lt;code&gt;SparseCategoricalCrossentropy&lt;/code&gt; loss. There should be &lt;code&gt;# classes&lt;/code&gt; floating point values per feature.</source>
          <target state="translated">Utilice esta funci&amp;oacute;n de p&amp;eacute;rdida de entrop&amp;iacute;a cruzada cuando haya dos o m&amp;aacute;s clases de etiquetas. Esperamos que las etiquetas se proporcionen en una representaci&amp;oacute;n &lt;code&gt;one_hot&lt;/code&gt; . Si desea proporcionar etiquetas como n&amp;uacute;meros enteros, utilice la p&amp;eacute;rdida &lt;code&gt;SparseCategoricalCrossentropy&lt;/code&gt; . Debe haber &lt;code&gt;# classes&lt;/code&gt; valores de punto flotante por caracter&amp;iacute;stica.</target>
        </trans-unit>
        <trans-unit id="5c6c9c3f9fd66d91bb804a873975c909932a10ca" translate="yes" xml:space="preserve">
          <source>Use this crossentropy metric when there are two or more label classes. We expect labels to be provided as integers. If you want to provide labels using &lt;code&gt;one-hot&lt;/code&gt; representation, please use &lt;code&gt;CategoricalCrossentropy&lt;/code&gt; metric. There should be &lt;code&gt;# classes&lt;/code&gt; floating point values per feature for &lt;code&gt;y_pred&lt;/code&gt; and a single floating point value per feature for &lt;code&gt;y_true&lt;/code&gt;.</source>
          <target state="translated">Utilice esta m&amp;eacute;trica de entrop&amp;iacute;a cruzada cuando haya dos o m&amp;aacute;s clases de etiquetas. Esperamos que las etiquetas se proporcionen como n&amp;uacute;meros enteros. Si desea proporcionar etiquetas utilizando &lt;code&gt;one-hot&lt;/code&gt; representaci&amp;oacute;n de un solo uso, utilice la m&amp;eacute;trica &lt;code&gt;CategoricalCrossentropy&lt;/code&gt; . Debe haber &lt;code&gt;# classes&lt;/code&gt; valores de punto flotante por caracter&amp;iacute;stica para &lt;code&gt;y_pred&lt;/code&gt; y un &amp;uacute;nico valor de punto flotante por caracter&amp;iacute;stica para &lt;code&gt;y_true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d8dc9e6eb45eed6afcf79258afbec19d798dabb" translate="yes" xml:space="preserve">
          <source>Use this function in place of &lt;a href=&quot;../../../../feature_column/embedding_column&quot;&gt;&lt;code&gt;tf.compat.v1.feature_column.embedding_column&lt;/code&gt;&lt;/a&gt; when you want to use the TPU to accelerate your embedding lookups via TPU embeddings.</source>
          <target state="translated">Utilice esta funci&amp;oacute;n en lugar de &lt;a href=&quot;../../../../feature_column/embedding_column&quot;&gt; &lt;code&gt;tf.compat.v1.feature_column.embedding_column&lt;/code&gt; &lt;/a&gt; cuando desee utilizar la TPU para acelerar sus b&amp;uacute;squedas de incrustaciones a trav&amp;eacute;s de incrustaciones de TPU.</target>
        </trans-unit>
        <trans-unit id="3cc5d4e2629c110ebe8857052924d43b36a33d1a" translate="yes" xml:space="preserve">
          <source>Use this function in place of tf.compat.v1.feature_column.shared_embedding_columns` when you want to use the TPU to accelerate your embedding lookups via TPU embeddings.</source>
          <target state="translated">Utiliza esta función en lugar de tf.compat.v1.feature_column.shared_embedding_columns` cuando quieras usar el TPU para acelerar tus búsquedas de incrustación mediante incrustaciones de TPU.</target>
        </trans-unit>
        <trans-unit id="e33c1dd0300e16f424a91617a667c9261bc9be4c" translate="yes" xml:space="preserve">
          <source>Use this function to prevent regularization of variables.</source>
          <target state="translated">Utilice esta función para evitar la regularización de las variables.</target>
        </trans-unit>
        <trans-unit id="9622b2273be64542684f76f86eb661f385ac65c8" translate="yes" xml:space="preserve">
          <source>Use this function to wrap any op, maintaining its behavior in the forward pass, but replacing the original op in the backward graph with an identity. For example:</source>
          <target state="translated">Usa esta función para envolver cualquier operación,manteniendo su comportamiento en el pase delantero,pero reemplazando la operación original en el gráfico trasero con una identidad.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="fe53876e652ed0ef4c2e62692c0a8476320563f1" translate="yes" xml:space="preserve">
          <source>Use this interface if you need to provide a custom loss/head. For example, the following will be equivalent to using BoostedTreesRegressor</source>
          <target state="translated">Utilice esta interfaz si necesita proporcionar una pérdida/cabeza personalizada.Por ejemplo,lo siguiente equivaldrá a utilizar BoostedTreesRegressor</target>
        </trans-unit>
        <trans-unit id="1fc9a09a598f08be35c9b3e469cc86fb8ef5c5c8" translate="yes" xml:space="preserve">
          <source>Use this method with the &lt;code&gt;with&lt;/code&gt; keyword to specify that ops created within the scope of a block should be added to this graph. In this case, once the scope of the &lt;code&gt;with&lt;/code&gt; is exited, the previous default graph is set again as default. There is a stack, so it's ok to have multiple nested levels of &lt;code&gt;as_default&lt;/code&gt; calls.</source>
          <target state="translated">Utilice este m&amp;eacute;todo con la palabra clave &lt;code&gt;with&lt;/code&gt; para especificar que las operaciones creadas dentro del alcance de un bloque deben agregarse a este gr&amp;aacute;fico. En este caso, una vez que se sale del alcance de &lt;code&gt;with&lt;/code&gt; , el gr&amp;aacute;fico predeterminado anterior se establece nuevamente como predeterminado. Hay una pila, por lo que est&amp;aacute; bien tener varios niveles anidados de llamadas &lt;code&gt;as_default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1cb0006ae0bc4a4d2c6cc55d9288fc8e40392087" translate="yes" xml:space="preserve">
          <source>Use this transformation to produce a dataset that contains one instance of each unique element in the input. For example:</source>
          <target state="translated">Utiliza esta transformación para producir un conjunto de datos que contenga una instancia de cada elemento único en la entrada.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="c1ae07580001407b54ea6c15a5ff62a49d8bc47c" translate="yes" xml:space="preserve">
          <source>Use this transformation to produce a dataset that contains the same elements as the input, but silently drops any elements that caused an error. For example:</source>
          <target state="translated">Utiliza esta transformación para producir un conjunto de datos que contiene los mismos elementos que la entrada,pero que deja caer silenciosamente cualquier elemento que haya causado un error.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="0ecb994c8af6ea20690f2149dd63292f77fb37b5" translate="yes" xml:space="preserve">
          <source>Use this when each of your sparse inputs has both an ID and a value. For example, if you're representing text documents as a collection of word frequencies, you can provide 2 parallel sparse input features ('terms' and 'frequencies' below).</source>
          <target state="translated">Utiliza esto cuando cada una de tus escasas entradas tenga tanto un ID como un valor.Por ejemplo,si representa documentos de texto como una colección de frecuencias de palabras,puede proporcionar 2 características de entrada de datos dispersos en paralelo (&quot;términos&quot; y &quot;frecuencias&quot; más abajo).</target>
        </trans-unit>
        <trans-unit id="579c3daf1696275881a685fed877b2bca49537c7" translate="yes" xml:space="preserve">
          <source>Use this when the caller knows that this FlagValues has been parsed as if a &lt;strong&gt;call&lt;/strong&gt;() invocation has happened. This is only a public method for use by things like appcommands which do additional command like parsing.</source>
          <target state="translated">Use esto cuando la persona que llama sepa que este FlagValues ​​se ha analizado como si se hubiera producido una invocaci&amp;oacute;n de &lt;strong&gt;call&lt;/strong&gt; (). Este es solo un m&amp;eacute;todo p&amp;uacute;blico para que lo usen cosas como los comandos de aplicaciones que realizan comandos adicionales como el an&amp;aacute;lisis.</target>
        </trans-unit>
        <trans-unit id="f2352dd0c45545d0dddd83edf7a87ae1c7d6a2a5" translate="yes" xml:space="preserve">
          <source>Use this when your inputs are in string or integer format, and you have a vocabulary file that maps each value to an integer ID. By default, out-of-vocabulary values are ignored. Use either (but not both) of &lt;code&gt;num_oov_buckets&lt;/code&gt; and &lt;code&gt;default_value&lt;/code&gt; to specify how to include out-of-vocabulary values.</source>
          <target state="translated">Use esto cuando sus entradas est&amp;eacute;n en formato de cadena o entero, y tenga un archivo de vocabulario que asigne cada valor a un ID de entero. De forma predeterminada, se ignoran los valores fuera del vocabulario. Use uno (pero no ambos) de &lt;code&gt;num_oov_buckets&lt;/code&gt; y &lt;code&gt;default_value&lt;/code&gt; para especificar c&amp;oacute;mo incluir valores fuera del vocabulario.</target>
        </trans-unit>
        <trans-unit id="ebfbbc24af8cd5c1b3325ddc7e9b9110d158077e" translate="yes" xml:space="preserve">
          <source>Use this when your inputs are in string or integer format, and you have an in-memory vocabulary mapping each value to an integer ID. By default, out-of-vocabulary values are ignored. Use either (but not both) of &lt;code&gt;num_oov_buckets&lt;/code&gt; and &lt;code&gt;default_value&lt;/code&gt; to specify how to include out-of-vocabulary values.</source>
          <target state="translated">Use esto cuando sus entradas est&amp;eacute;n en formato de cadena o entero, y tenga un vocabulario en memoria que asigne cada valor a un ID de entero. De forma predeterminada, se ignoran los valores fuera del vocabulario. Use uno (pero no ambos) de &lt;code&gt;num_oov_buckets&lt;/code&gt; y &lt;code&gt;default_value&lt;/code&gt; para especificar c&amp;oacute;mo incluir valores fuera del vocabulario.</target>
        </trans-unit>
        <trans-unit id="5c2d5c81b6b22ab6aebbd8420d0922e66fb231ec" translate="yes" xml:space="preserve">
          <source>Use this when your inputs are integers in the range &lt;code&gt;[0, num_buckets)&lt;/code&gt;, and you want to use the input value itself as the categorical ID. Values outside this range will result in &lt;code&gt;default_value&lt;/code&gt; if specified, otherwise it will fail.</source>
          <target state="translated">Use esto cuando sus entradas sean n&amp;uacute;meros enteros en el rango &lt;code&gt;[0, num_buckets)&lt;/code&gt; y desee usar el valor de entrada en s&amp;iacute; como el ID categ&amp;oacute;rico. Los valores fuera de este rango dar&amp;aacute;n como resultado &lt;code&gt;default_value&lt;/code&gt; si se especifica; de lo contrario, fallar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="be55e7e6d26bbf4b36ff797d2545265b0a6866e3" translate="yes" xml:space="preserve">
          <source>Use this when your inputs are sparse and of the same type (e.g. watched and impression video IDs that share the same vocabulary), and you want to convert them to a dense representation (e.g., to feed to a DNN).</source>
          <target state="translated">Utilícelo cuando sus entradas sean escasas y del mismo tipo (por ejemplo,para ver e imprimir identificaciones de video que compartan el mismo vocabulario),y quiera convertirlas en una representación densa (por ejemplo,para alimentar a un DNN).</target>
        </trans-unit>
        <trans-unit id="ce58da03135c2b5ad93ed7aa78fffe6ae161dd6d" translate="yes" xml:space="preserve">
          <source>Use this when your inputs are sparse, but you want to convert them to a dense representation (e.g., to feed to a DNN).</source>
          <target state="translated">Utilízalo cuando tus entradas sean escasas,pero quieras convertirlas en una representación densa (por ejemplo,para alimentar a un DNN).</target>
        </trans-unit>
        <trans-unit id="c980245437253028d09a527c56663fc1386fb381" translate="yes" xml:space="preserve">
          <source>Use this when your sparse features are in string or integer format, and you want to distribute your inputs into a finite number of buckets by hashing. output_id = Hash(input_feature_string) % bucket_size for string type input. For int type input, the value is converted to its string representation first and then hashed by the same formula.</source>
          <target state="translated">Utilícelo cuando sus características dispersas estén en formato de cadena o entero,y quiera distribuir sus entradas en un número finito de cubos mediante hashing.output_id=Hash(input_feature_string)% bucket_size for string type input.Para la entrada de tipo int,el valor se convierte primero en su representación de cadena y luego se hace un hash con la misma fórmula.</target>
        </trans-unit>
        <trans-unit id="610337110a51eaf727f0158c31e03e81c30df87c" translate="yes" xml:space="preserve">
          <source>Use with &lt;a href=&quot;../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0594027b100d87bb5949b9d94aec04e20184fe6" translate="yes" xml:space="preserve">
          <source>Use with &lt;a href=&quot;../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&amp;Uacute;selo con &lt;a href=&quot;../../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7b2a8e4ff6f36d2ae408104e160d5b3b9371d34a" translate="yes" xml:space="preserve">
          <source>Use with the &lt;code&gt;with&lt;/code&gt; keyword to specify that all operations constructed within the context should have control dependencies on &lt;code&gt;control_inputs&lt;/code&gt;. For example:</source>
          <target state="translated">&amp;Uacute;selo con la palabra clave &lt;code&gt;with&lt;/code&gt; para especificar que todas las operaciones construidas dentro del contexto deben tener dependencias de control en &lt;code&gt;control_inputs&lt;/code&gt; . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="69dd6dc7e65c4b9fe7cd1454b69ad4047ff65a5d" translate="yes" xml:space="preserve">
          <source>Use with the &lt;code&gt;with&lt;/code&gt; keyword to specify that calls to &lt;a href=&quot;../../operation#run&quot;&gt;&lt;code&gt;tf.Operation.run&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../tensor#eval&quot;&gt;&lt;code&gt;tf.Tensor.eval&lt;/code&gt;&lt;/a&gt; should be executed in this session.</source>
          <target state="translated">&amp;Uacute;selo con la palabra clave &lt;code&gt;with&lt;/code&gt; para especificar que las llamadas a &lt;a href=&quot;../../operation#run&quot;&gt; &lt;code&gt;tf.Operation.run&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;../../tensor#eval&quot;&gt; &lt;code&gt;tf.Tensor.eval&lt;/code&gt; &lt;/a&gt; deben ejecutarse en esta sesi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="fefa29789a427f39795cb49ac3d13889fa028342" translate="yes" xml:space="preserve">
          <source>Used as the &lt;code&gt;_options&lt;/code&gt; argument to the &lt;code&gt;tf.Checkpoint&lt;/code&gt; constructor to adjust how variables are saved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="687844afc928e1515653eca2dc67313bcb251adb" translate="yes" xml:space="preserve">
          <source>Used for Tensor.&lt;strong&gt;div&lt;/strong&gt;.</source>
          <target state="translated">Usado para Tensor. &lt;strong&gt;div&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="acb129729f63585d898dc89a0859fbaa068d1542" translate="yes" xml:space="preserve">
          <source>Used for backwards compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ed98ab98b4d3bc08d8823f62d5fecc305aaf972" translate="yes" xml:space="preserve">
          <source>Used for generating the &lt;code&gt;sampling_table&lt;/code&gt; argument for &lt;code&gt;skipgrams&lt;/code&gt;. &lt;code&gt;sampling_table[i]&lt;/code&gt; is the probability of sampling the word i-th most common word in a dataset (more common words should be sampled less frequently, for balance).</source>
          <target state="translated">Se utiliza para generar la &lt;code&gt;sampling_table&lt;/code&gt; argumento para &lt;code&gt;skipgrams&lt;/code&gt; . &lt;code&gt;sampling_table[i]&lt;/code&gt; es la probabilidad de muestrear la palabra i-&amp;eacute;sima palabra m&amp;aacute;s com&amp;uacute;n en un conjunto de datos (las palabras m&amp;aacute;s comunes se deben muestrear con menos frecuencia, para equilibrar).</target>
        </trans-unit>
        <trans-unit id="838a9c1b2b1ad8d0483e3efe3752a2cfa857bf97" translate="yes" xml:space="preserve">
          <source>Used in &lt;code&gt;fit_generator&lt;/code&gt;, &lt;code&gt;evaluate_generator&lt;/code&gt;, &lt;code&gt;predict_generator&lt;/code&gt;.</source>
          <target state="translated">Se utiliza en &lt;code&gt;fit_generator&lt;/code&gt; , &lt;code&gt;evaluate_generator&lt;/code&gt; , &lt;code&gt;predict_generator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e032a2a6a3c13d10bf51a9e9b4ceb6f1b08ec11d" translate="yes" xml:space="preserve">
          <source>Used in a functional model:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce35a302d37a4e5f24d1589056ce4a8ade1153e6" translate="yes" xml:space="preserve">
          <source>Used in the guide:</source>
          <target state="translated">Usado en la guía:</target>
        </trans-unit>
        <trans-unit id="5d57c19f05b013abb121e6d7231e8fb33b04353e" translate="yes" xml:space="preserve">
          <source>Used in the tutorials:</source>
          <target state="translated">Usado en los tutoriales:</target>
        </trans-unit>
        <trans-unit id="666e19bae41db98d774366b280a7568a18c7a7d0" translate="yes" xml:space="preserve">
          <source>Used to create a connection to a TPU master in order to retrieve the system metadata.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d5b31850f6cd998b34c1f803e97f421ab5e927c" translate="yes" xml:space="preserve">
          <source>Used to implement efficient stacked RNNs.</source>
          <target state="translated">Se utiliza para implementar eficientes RNN apilados.</target>
        </trans-unit>
        <trans-unit id="1dc2e0b551da6f4f100efb7639cb33de1b18f9c4" translate="yes" xml:space="preserve">
          <source>Used to number checkpoints.</source>
          <target state="translated">Se usa para numerar los puntos de control.</target>
        </trans-unit>
        <trans-unit id="f25ae0ac1af6f48ad552af7fd633f8cca6feb1bf" translate="yes" xml:space="preserve">
          <source>Used to prevent positional parameters. Internal, do not use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10ff5000f97f7693594d9bc2e58cecc4845e5222" translate="yes" xml:space="preserve">
          <source>Useful e.g. connecting RNNs and convnets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33e1b276d404a935dc5326f961aab709a74eaaa4" translate="yes" xml:space="preserve">
          <source>Useful for e.g. connecting RNNs and convnets together.</source>
          <target state="translated">Útil para,por ejemplo,conectar RNNs y convnets juntos.</target>
        </trans-unit>
        <trans-unit id="2c162068f6d2673c0d1e37e670b21e118d35909f" translate="yes" xml:space="preserve">
          <source>Useful special cases:</source>
          <target state="translated">Casos especiales útiles:</target>
        </trans-unit>
        <trans-unit id="288dbdb9bfd68b877505e5e2d999c8a104f5d6ad" translate="yes" xml:space="preserve">
          <source>Useful to avoid clutter from old models / layers.</source>
          <target state="translated">Útil para evitar el desorden de los viejos modelos/capas.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
