<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="tensorflow">
    <body>
      <group id="tensorflow">
        <trans-unit id="7b76c8215965b6d6548dad5cc3be42ab9b948c2e" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;signatures&lt;/code&gt; argument controls which methods in &lt;code&gt;obj&lt;/code&gt; will be available to programs which consume &lt;code&gt;SavedModel&lt;/code&gt;s, for example, serving APIs. Python functions may be decorated with &lt;code&gt;@tf.function(input_signature=...)&lt;/code&gt; and passed as signatures directly, or lazily with a call to &lt;code&gt;get_concrete_function&lt;/code&gt; on the method decorated with &lt;code&gt;@tf.function&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eb10eb93ba6242a60bc81190f01e4562cc7c7f2" translate="yes" xml:space="preserve">
          <source>The options are &quot;global&quot; in the sense they apply to the entire dataset. If options are set multiple times, they are merged as long as different options do not use different non-default values.</source>
          <target state="translated">Las opciones son &quot;globales&quot; en el sentido de que se aplican a todo el conjunto de datos.Si las opciones se establecen varias veces,se fusionan siempre y cuando las diferentes opciones no utilicen diferentes valores no predeterminados.</target>
        </trans-unit>
        <trans-unit id="839958c9eddae1511a49cbdd886b3f520fbec271" translate="yes" xml:space="preserve">
          <source>The order of output arguments here is &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;u&lt;/code&gt;, &lt;code&gt;v&lt;/code&gt; when &lt;code&gt;compute_uv&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, as opposed to &lt;code&gt;u&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;v&lt;/code&gt; for numpy.linalg.svd.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3bc730bbfda16a7dd0623a512f8a88cc6217898" translate="yes" xml:space="preserve">
          <source>The original device on which &lt;code&gt;input_dataset&lt;/code&gt; will be placed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18d387209dd33fca87db5f4de4ba44e61656b7a9" translate="yes" xml:space="preserve">
          <source>The original input to &lt;a href=&quot;lu&quot;&gt;&lt;code&gt;tf.linalg.lu&lt;/code&gt;&lt;/a&gt;, i.e., &lt;code&gt;x&lt;/code&gt; as in, &lt;code&gt;lu_reconstruct(*tf.linalg.lu(x))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af401239a74cc22bb0656ceab277ae88265e81dd" translate="yes" xml:space="preserve">
          <source>The original method wrapped such that it enters the module's name scope.</source>
          <target state="translated">El método original envuelto de tal manera que entra en el ámbito del nombre del módulo.</target>
        </trans-unit>
        <trans-unit id="f891d19803fb509490762be082d2f8ade6148c86" translate="yes" xml:space="preserve">
          <source>The original registered Flag objects can be retrieved through the use of the dictionary-like operator, &lt;strong&gt;getitem&lt;/strong&gt;: x = FLAGS['longname'] # access the registered Flag object</source>
          <target state="translated">Los objetos Flag registrados originales se pueden recuperar mediante el uso del operador similar a un diccionario, &lt;strong&gt;getitem&lt;/strong&gt; : x = FLAGS ['longname'] # acceder al objeto Flag registrado</target>
        </trans-unit>
        <trans-unit id="b71549bb8296bfb172b0e5fa059a19b9055f4136" translate="yes" xml:space="preserve">
          <source>The other method &lt;code&gt;uniform&lt;/code&gt; only covers the range [minval, maxval), which cannot be &lt;code&gt;dtype&lt;/code&gt;'s full range because &lt;code&gt;maxval&lt;/code&gt; is of type &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="translated">El otro m&amp;eacute;todo &lt;code&gt;uniform&lt;/code&gt; e s&amp;oacute;lo cubre el rango [MINVAL, maxval), que no puede ser &lt;code&gt;dtype&lt;/code&gt; 's gama completa porque &lt;code&gt;maxval&lt;/code&gt; es de tipo &lt;code&gt;dtype&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d650eca6a136e51fc7375e0969bc2ea1115b2e2" translate="yes" xml:space="preserve">
          <source>The output &lt;code&gt;SparseTensor&lt;/code&gt; object's shape values for all dimensions but the first are the max across the input &lt;code&gt;SparseTensor&lt;/code&gt; objects' shape values for the corresponding dimensions. Its first shape value is &lt;code&gt;N&lt;/code&gt;, the minibatch size.</source>
          <target state="translated">Los valores de forma del objeto &lt;code&gt;SparseTensor&lt;/code&gt; de salida para todas las dimensiones, pero el primero es el m&amp;aacute;ximo en los valores de forma de los objetos &lt;code&gt;SparseTensor&lt;/code&gt; de entrada para las dimensiones correspondientes. Su primer valor de forma es &lt;code&gt;N&lt;/code&gt; , el tama&amp;ntilde;o del minibatch.</target>
        </trans-unit>
        <trans-unit id="f7899fd3a60fa39b01002b08a0bd2e514e0a6d60" translate="yes" xml:space="preserve">
          <source>The output &lt;code&gt;SparseTensor&lt;/code&gt; object's shape values for the original dimensions are the max across the input &lt;code&gt;SparseTensor&lt;/code&gt; objects' shape values for the corresponding dimensions. The new dimensions match the size of the batch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27cd935b967006cc01a667a4b3f9d0444d7da4c5" translate="yes" xml:space="preserve">
          <source>The output &lt;code&gt;SparseTensor&lt;/code&gt; will be in row-major order and will have the same shape as the input.</source>
          <target state="translated">El &lt;code&gt;SparseTensor&lt;/code&gt; de salida estar&amp;aacute; en orden de fila principal y tendr&amp;aacute; la misma forma que la entrada.</target>
        </trans-unit>
        <trans-unit id="3ed7c320b010e6441e9928df89e4f8feea635e72" translate="yes" xml:space="preserve">
          <source>The output &lt;code&gt;y&lt;/code&gt; has the same rank as &lt;code&gt;x&lt;/code&gt;. The shapes of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; satisfy: &lt;code&gt;y.shape[i] == x.shape[perm[i]] for i in [0, 1, ..., rank(x) - 1]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac7bc3e3640548894477903c76a63029f0684b7b" translate="yes" xml:space="preserve">
          <source>The output &lt;code&gt;y&lt;/code&gt; has the same rank as &lt;code&gt;x&lt;/code&gt;. The shapes of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; satisfy: &lt;code&gt;y.shape[i] == x.shape[perm[i]] for i in [0, 1, ..., rank(x) - 1]&lt;/code&gt;&lt;code&gt;y[i,j,k,...,s,t,u] == conj(x[perm[i], perm[j], perm[k],...,perm[s], perm[t], perm[u]])&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25a24380035e136d9ea98af6a346f119051ef56c" translate="yes" xml:space="preserve">
          <source>The output Tensor as described above, dimensions will vary based on the op provided.</source>
          <target state="translated">El Tensor de salida como se describe arriba,las dimensiones variarán en función de la operación proporcionada.</target>
        </trans-unit>
        <trans-unit id="47c4d6134bd40a175fa44afa8f9b377d5850de3c" translate="yes" xml:space="preserve">
          <source>The output consists of two tensors LU and P containing the LU decomposition of all input submatrices &lt;code&gt;[..., :, :]&lt;/code&gt;. LU encodes the lower triangular and upper triangular factors.</source>
          <target state="translated">La salida consta de dos tensores LU y P que contienen la descomposici&amp;oacute;n LU de todas las submatrices de entrada &lt;code&gt;[..., :, :]&lt;/code&gt; . LU codifica los factores triangular superior e inferior.</target>
        </trans-unit>
        <trans-unit id="797ecd44b1fb4a552924484c7a55ad507593ed55" translate="yes" xml:space="preserve">
          <source>The output dtype; defaults to &lt;a href=&quot;../../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31482f2ff54a3aa8fae10ccd117f3f60685fed5f" translate="yes" xml:space="preserve">
          <source>The output dtype; defaults to &lt;a href=&quot;../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="048c6e1cfd308f6012ab77e90cbc674670b136c0" translate="yes" xml:space="preserve">
          <source>The output elements are taken from the input at intervals given by the &lt;code&gt;rate&lt;/code&gt; argument, as in dilated convolutions.</source>
          <target state="translated">Los elementos de salida se toman de la entrada a intervalos dados por el argumento de &lt;code&gt;rate&lt;/code&gt; , como en convoluciones dilatadas.</target>
        </trans-unit>
        <trans-unit id="01cfec4a29cc69f6abe94502062c73070782ab76" translate="yes" xml:space="preserve">
          <source>The output elements will be resorted to preserve the sort order along increasing dimension number.</source>
          <target state="translated">Se recurrirá a los elementos de salida para preservar el orden de clasificación a lo largo de un número creciente de dimensiones.</target>
        </trans-unit>
        <trans-unit id="38c8f8944795768b987abf44161bc29810671bc1" translate="yes" xml:space="preserve">
          <source>The output is a tensor of rank &lt;code&gt;k+1&lt;/code&gt; with dimensions &lt;code&gt;[I, J, ..., L, M, N]&lt;/code&gt;. If &lt;code&gt;k&lt;/code&gt; is scalar or &lt;code&gt;k[0] == k[1]&lt;/code&gt;:</source>
          <target state="translated">La salida es un tensor de rango &lt;code&gt;k+1&lt;/code&gt; con dimensiones &lt;code&gt;[I, J, ..., L, M, N]&lt;/code&gt; . Si &lt;code&gt;k&lt;/code&gt; es escalar o &lt;code&gt;k[0] == k[1]&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b9f3b180f0596bc470d2fb79c1dedac7776f93d9" translate="yes" xml:space="preserve">
          <source>The output is a tensor of shape &lt;code&gt;[..., M, K]&lt;/code&gt;. If &lt;code&gt;adjoint&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; then the innermost matrices in &lt;code&gt;output&lt;/code&gt; satisfy matrix equations &lt;code&gt;matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]&lt;/code&gt;. If &lt;code&gt;adjoint&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt; then the strictly then the innermost matrices in &lt;code&gt;output&lt;/code&gt; satisfy matrix equations &lt;code&gt;adjoint(matrix[..., i, k]) * output[..., k, j] = rhs[..., i, j]&lt;/code&gt;.</source>
          <target state="translated">La salida es un tensor de forma &lt;code&gt;[..., M, K]&lt;/code&gt; . Si &lt;code&gt;adjoint&lt;/code&gt; es &lt;code&gt;True&lt;/code&gt; entonces las matrices m&amp;aacute;s internas en la &lt;code&gt;output&lt;/code&gt; satisfacen las ecuaciones &lt;code&gt;matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]&lt;/code&gt; . Si &lt;code&gt;adjoint&lt;/code&gt; es &lt;code&gt;False&lt;/code&gt; , entonces estrictamente entonces las matrices m&amp;aacute;s internas en la &lt;code&gt;output&lt;/code&gt; satisfacen las ecuaciones matriciales &lt;code&gt;adjoint(matrix[..., i, k]) * output[..., k, j] = rhs[..., i, j]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1488da1cb166b21e2e086e4e08f96c22ee229379" translate="yes" xml:space="preserve">
          <source>The output is a tensor of shape &lt;code&gt;[..., M, N]&lt;/code&gt;. If &lt;code&gt;adjoint&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; then the innermost matrices in &lt;code&gt;output&lt;/code&gt; satisfy matrix equations &lt;code&gt;matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]&lt;/code&gt;. If &lt;code&gt;adjoint&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt; then the strictly then the innermost matrices in &lt;code&gt;output&lt;/code&gt; satisfy matrix equations &lt;code&gt;adjoint(matrix[..., i, k]) * output[..., k, j] = rhs[..., i, j]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6768fd2c3c792ee19a1c494dc0c8f3d25ef95d97" translate="yes" xml:space="preserve">
          <source>The output is a tensor of shape &lt;code&gt;[..., M, N]&lt;/code&gt;. If &lt;code&gt;adjoint&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; then the innermost matrices in output satisfy matrix equations &lt;code&gt;sum_k matrix[..., i, k] * output[..., k, j] = rhs[..., i, j]&lt;/code&gt;. If &lt;code&gt;adjoint&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt; then the innermost matrices in output satisfy matrix equations &lt;code&gt;sum_k adjoint(matrix[..., i, k]) * output[..., k, j] = rhs[..., i, j]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24258a9b3cf1537928d726a4c142766d14a612d5" translate="yes" xml:space="preserve">
          <source>The output is a tensor of the same shape as &lt;code&gt;rhs&lt;/code&gt;: either &lt;code&gt;[..., M]&lt;/code&gt; or &lt;code&gt;[..., M, K]&lt;/code&gt;.</source>
          <target state="translated">La salida es un tensor de la misma forma que &lt;code&gt;rhs&lt;/code&gt; : &lt;code&gt;[..., M]&lt;/code&gt; o &lt;code&gt;[..., M, K]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d3db7f6f2ef07d73508fa555433bf8d83a75eaa" translate="yes" xml:space="preserve">
          <source>The output is a tensor of the same shape as the input containing the Cholesky decompositions for all input submatrices &lt;code&gt;[..., :, :]&lt;/code&gt;.</source>
          <target state="translated">La salida es un tensor de la misma forma que la entrada que contiene las descomposiciones de Cholesky para todas las submatrices de entrada &lt;code&gt;[..., :, :]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6194740e93c206c46e0bfecd7aa22357ddec1b58" translate="yes" xml:space="preserve">
          <source>The output is computed as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b74ff8ee45b0b8f3cea227a5cb8b0ca2512e0fa1" translate="yes" xml:space="preserve">
          <source>The output is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02cc9038a532f36829ca3735f949f57712e9a776" translate="yes" xml:space="preserve">
          <source>The output locations corresponding to the implicitly zero elements in the sparse tensor will be zero (i.e., will not take up storage space), regardless of the contents of the dense tensor (even if it's +/-INF and that INF*0 == NaN).</source>
          <target state="translated">Las ubicaciones de salida correspondientes a los elementos implícitamente cero en el tensor escaso serán cero (es decir,no ocuparán espacio de almacenamiento),independientemente del contenido del tensor denso (incluso si es +/-INF y ese INF*0 ==NaN).</target>
        </trans-unit>
        <trans-unit id="4921b3c960168ec33230d0e2275991a2a480fee7" translate="yes" xml:space="preserve">
          <source>The output of &lt;a href=&quot;../compat/v1/estimator/estimator#evaluate&quot;&gt;&lt;code&gt;Estimator.evaluate&lt;/code&gt;&lt;/a&gt; on this checkpoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b30d98674beeba8558b72dc407638d1340b74552" translate="yes" xml:space="preserve">
          <source>The output of the 1-arg function that takes the &lt;code&gt;step&lt;/code&gt; is &lt;code&gt;values[0]&lt;/code&gt; when &lt;code&gt;step &amp;lt;= boundaries[0]&lt;/code&gt;, &lt;code&gt;values[1]&lt;/code&gt; when &lt;code&gt;step &amp;gt; boundaries[0]&lt;/code&gt; and &lt;code&gt;step &amp;lt;= boundaries[1]&lt;/code&gt;, ..., and values[-1] when &lt;code&gt;step &amp;gt; boundaries[-1]&lt;/code&gt;.</source>
          <target state="translated">La salida de la funci&amp;oacute;n 1-arg que toma el &lt;code&gt;step&lt;/code&gt; son &lt;code&gt;values[0]&lt;/code&gt; cuando &lt;code&gt;step &amp;lt;= boundaries[0]&lt;/code&gt; , &lt;code&gt;values[1]&lt;/code&gt; cuando &lt;code&gt;step &amp;gt; boundaries[0]&lt;/code&gt; y &lt;code&gt;step &amp;lt;= boundaries[1]&lt;/code&gt; , ..., y valores [-1] cuando &lt;code&gt;step &amp;gt; boundaries[-1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d04584f160db196293c2030ae17c2dacfbfcd30d" translate="yes" xml:space="preserve">
          <source>The output of this Op is a single bounding box that may be used to crop the original image. The output is returned as 3 tensors: &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;size&lt;/code&gt; and &lt;code&gt;bboxes&lt;/code&gt;. The first 2 tensors can be fed directly into &lt;a href=&quot;../../../slice&quot;&gt;&lt;code&gt;tf.slice&lt;/code&gt;&lt;/a&gt; to crop the image. The latter may be supplied to &lt;a href=&quot;../../../image/draw_bounding_boxes&quot;&gt;&lt;code&gt;tf.image.draw_bounding_boxes&lt;/code&gt;&lt;/a&gt; to visualize what the bounding box looks like.</source>
          <target state="translated">El resultado de esta operaci&amp;oacute;n es un cuadro delimitador &amp;uacute;nico que se puede utilizar para recortar la imagen original. La salida se devuelve como 3 tensores: &lt;code&gt;begin&lt;/code&gt; , &lt;code&gt;size&lt;/code&gt; y &lt;code&gt;bboxes&lt;/code&gt; . Los 2 primeros tensores se pueden alimentar directamente en &lt;a href=&quot;../../../slice&quot;&gt; &lt;code&gt;tf.slice&lt;/code&gt; &lt;/a&gt; para recortar la imagen. Este &amp;uacute;ltimo se puede proporcionar a &lt;a href=&quot;../../../image/draw_bounding_boxes&quot;&gt; &lt;code&gt;tf.image.draw_bounding_boxes&lt;/code&gt; &lt;/a&gt; para visualizar c&amp;oacute;mo se ve el cuadro delimitador.</target>
        </trans-unit>
        <trans-unit id="cc8ae412cea3a206e259aeb86af6654e659ed171" translate="yes" xml:space="preserve">
          <source>The output of this Op is a single bounding box that may be used to crop the original image. The output is returned as 3 tensors: &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;size&lt;/code&gt; and &lt;code&gt;bboxes&lt;/code&gt;. The first 2 tensors can be fed directly into &lt;a href=&quot;../slice&quot;&gt;&lt;code&gt;tf.slice&lt;/code&gt;&lt;/a&gt; to crop the image. The latter may be supplied to &lt;a href=&quot;../image/draw_bounding_boxes&quot;&gt;&lt;code&gt;tf.image.draw_bounding_boxes&lt;/code&gt;&lt;/a&gt; to visualize what the bounding box looks like.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e995a951ce7a3cd16e04e8cd70419e327350a30" translate="yes" xml:space="preserve">
          <source>The output of this Op is a single bounding box that may be used to crop the original image. The output is returned as 3 tensors: &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;size&lt;/code&gt; and &lt;code&gt;bboxes&lt;/code&gt;. The first 2 tensors can be fed directly into &lt;a href=&quot;../slice&quot;&gt;&lt;code&gt;tf.slice&lt;/code&gt;&lt;/a&gt; to crop the image. The latter may be supplied to &lt;a href=&quot;draw_bounding_boxes&quot;&gt;&lt;code&gt;tf.image.draw_bounding_boxes&lt;/code&gt;&lt;/a&gt; to visualize what the bounding box looks like.</source>
          <target state="translated">El resultado de esta operaci&amp;oacute;n es un cuadro delimitador &amp;uacute;nico que se puede utilizar para recortar la imagen original. La salida se devuelve como 3 tensores: &lt;code&gt;begin&lt;/code&gt; , &lt;code&gt;size&lt;/code&gt; y &lt;code&gt;bboxes&lt;/code&gt; . Los 2 primeros tensores se pueden alimentar directamente en &lt;a href=&quot;../slice&quot;&gt; &lt;code&gt;tf.slice&lt;/code&gt; &lt;/a&gt; para recortar la imagen. Este &amp;uacute;ltimo se puede proporcionar a &lt;a href=&quot;draw_bounding_boxes&quot;&gt; &lt;code&gt;tf.image.draw_bounding_boxes&lt;/code&gt; &lt;/a&gt; para visualizar c&amp;oacute;mo se ve el cuadro delimitador.</target>
        </trans-unit>
        <trans-unit id="867a41c15dc52766b0de85d04ee44344a9063866" translate="yes" xml:space="preserve">
          <source>The output of this method is a 3D &lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;[batch_size, T, D]&lt;/code&gt;. &lt;code&gt;T&lt;/code&gt; is the maximum sequence length for this batch, which could differ from batch to batch.</source>
          <target state="translated">El resultado de este m&amp;eacute;todo es un &lt;code&gt;Tensor&lt;/code&gt; 3D de forma &lt;code&gt;[batch_size, T, D]&lt;/code&gt; . &lt;code&gt;T&lt;/code&gt; es la longitud m&amp;aacute;xima de secuencia para este lote, que puede diferir de un lote a otro.</target>
        </trans-unit>
        <trans-unit id="753b9e20d6aac1628ca75bf0511c387d43eb2530" translate="yes" xml:space="preserve">
          <source>The output of this operation is a set of integers indexing into the input collection of bounding boxes representing the selected boxes. The bounding box coordinates corresponding to the selected indices can then be obtained using the &lt;code&gt;tf.gather operation&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da6a14177a19f48147884875b20440b0d347e68f" translate="yes" xml:space="preserve">
          <source>The output shape is identical to the inputs', except along the concat dimension, where it is the sum of the inputs' sizes along that dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b30057b1110d4946855f0f7f77e28efcaa8cc94" translate="yes" xml:space="preserve">
          <source>The output shapes are compatible in a way that the first dimension of all tensors are the same and equal to the number of possible split nodes for each feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3907a316796c56324c363351b8f0ffb1dbcb1c06" translate="yes" xml:space="preserve">
          <source>The output signature of &lt;code&gt;fn&lt;/code&gt;. Must be specified if &lt;code&gt;fn&lt;/code&gt;'s input and output signatures are different (i.e., if their structures, dtypes, or tensor types do not match). &lt;code&gt;fn_output_signature&lt;/code&gt; can be specified using any of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eac10a40d7ace5a75143c2fbccbd028ece77a9fb" translate="yes" xml:space="preserve">
          <source>The output slice &lt;code&gt;i&lt;/code&gt; along dimension &lt;code&gt;batch_axis&lt;/code&gt; is then given by input slice &lt;code&gt;i&lt;/code&gt;, with the first &lt;code&gt;seq_lengths[i]&lt;/code&gt; slices along dimension &lt;code&gt;seq_axis&lt;/code&gt; reversed.</source>
          <target state="translated">El segmento de salida &lt;code&gt;i&lt;/code&gt; a lo largo de la dimensi&amp;oacute;n &lt;code&gt;batch_axis&lt;/code&gt; viene dado por el segmento de entrada &lt;code&gt;i&lt;/code&gt; , con los primeros &lt;code&gt;seq_lengths[i]&lt;/code&gt; largo de la dimensi&amp;oacute;n &lt;code&gt;seq_axis&lt;/code&gt; invertidos.</target>
        </trans-unit>
        <trans-unit id="b24ce3e8aaca6570e3ec8cec6e775f6c5f2c52dd" translate="yes" xml:space="preserve">
          <source>The output slice &lt;code&gt;i&lt;/code&gt; along dimension &lt;code&gt;batch_dim&lt;/code&gt; is then given by input slice &lt;code&gt;i&lt;/code&gt;, with the first &lt;code&gt;seq_lengths[i]&lt;/code&gt; slices along dimension &lt;code&gt;seq_dim&lt;/code&gt; reversed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76e5d3d89821526e9a3ed69b0fc0e5605bddfe28" translate="yes" xml:space="preserve">
          <source>The output stream, logging level, or file to print to. Defaults to sys.stderr, but sys.stdout, tf.compat.v1.logging.info, tf.compat.v1.logging.warning, tf.compat.v1.logging.error, absl.logging.info, absl.logging.warning and absl.logging.error are also supported. To print to a file, pass a string started with &quot;file://&quot; followed by the file path, e.g., &quot;file:///tmp/foo.out&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="098e1ce5365a1d1a1384c17c4ced06e659b0880f" translate="yes" xml:space="preserve">
          <source>The output subscripts must contain only labels appearing in at least one of the input subscripts. Furthermore, all dimensions mapping to the same axis label must be equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0270145e0963e3fa6b4466fddef88fdbf60e481" translate="yes" xml:space="preserve">
          <source>The output tensor has shape &lt;code&gt;[1, 2, 2, 1]&lt;/code&gt; and value:</source>
          <target state="translated">El tensor de salida tiene forma &lt;code&gt;[1, 2, 2, 1]&lt;/code&gt; y valor:</target>
        </trans-unit>
        <trans-unit id="aff644b1606cf977042c3f329c0b44912b343d5f" translate="yes" xml:space="preserve">
          <source>The output tensor has shape &lt;code&gt;[1, 2, 2, 3]&lt;/code&gt; and value:</source>
          <target state="translated">El tensor de salida tiene forma &lt;code&gt;[1, 2, 2, 3]&lt;/code&gt; y valor:</target>
        </trans-unit>
        <trans-unit id="26ecc2d485656620c8ddae36c3377b136f2c8ef6" translate="yes" xml:space="preserve">
          <source>The output tensor has shape &lt;code&gt;[1, 4, 4, 1]&lt;/code&gt; and value:</source>
          <target state="translated">El tensor de salida tiene forma &lt;code&gt;[1, 4, 4, 1]&lt;/code&gt; y valor:</target>
        </trans-unit>
        <trans-unit id="413cce56d7e73e0557f6955da012eeb198f78207" translate="yes" xml:space="preserve">
          <source>The output tensor has shape &lt;code&gt;[2, 2, 4, 1]&lt;/code&gt; and value:</source>
          <target state="translated">El tensor de salida tiene forma &lt;code&gt;[2, 2, 4, 1]&lt;/code&gt; y valor:</target>
        </trans-unit>
        <trans-unit id="580524501d7754a464d140a489afd8a69565b7e8" translate="yes" xml:space="preserve">
          <source>The output tensor has shape &lt;code&gt;[4, 1, 1, 1]&lt;/code&gt; and value:</source>
          <target state="translated">El tensor de salida tiene forma &lt;code&gt;[4, 1, 1, 1]&lt;/code&gt; y valor:</target>
        </trans-unit>
        <trans-unit id="43b93cea1c5beede2692779450404b22ddd16414" translate="yes" xml:space="preserve">
          <source>The output tensor has shape &lt;code&gt;[4, 1, 1, 3]&lt;/code&gt; and value:</source>
          <target state="translated">El tensor de salida tiene forma &lt;code&gt;[4, 1, 1, 3]&lt;/code&gt; y valor:</target>
        </trans-unit>
        <trans-unit id="863590a97a6747705662d02c1d09d524c465ba85" translate="yes" xml:space="preserve">
          <source>The output tensor has shape &lt;code&gt;[4, 2, 2, 1]&lt;/code&gt; and value:</source>
          <target state="translated">El tensor de salida tiene forma &lt;code&gt;[4, 2, 2, 1]&lt;/code&gt; y valor:</target>
        </trans-unit>
        <trans-unit id="951a2f1acb5ea54cd01c5c69fad552b3af0398ec" translate="yes" xml:space="preserve">
          <source>The output tensor has shape &lt;code&gt;[8, 1, 2, 1]&lt;/code&gt; and value:</source>
          <target state="translated">El tensor de salida tiene forma &lt;code&gt;[8, 1, 2, 1]&lt;/code&gt; y valor:</target>
        </trans-unit>
        <trans-unit id="b991f9c184601aa1cf79a030dce35cd2e1811686" translate="yes" xml:space="preserve">
          <source>The output tensor has shape &lt;code&gt;[8, 1, 3, 1]&lt;/code&gt; and value:</source>
          <target state="translated">El tensor de salida tiene forma &lt;code&gt;[8, 1, 3, 1]&lt;/code&gt; y valor:</target>
        </trans-unit>
        <trans-unit id="8a7212b9117e06db921246aafe5499cc8ff0cedb" translate="yes" xml:space="preserve">
          <source>The output tensor is 2-D or higher with shape &lt;code&gt;[..., r_o, c_o]&lt;/code&gt;, where:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6dc975d4ffc27e7fe4b516c5e078460e61b472d" translate="yes" xml:space="preserve">
          <source>The output tensor is a tensor with dimensions described by 'size' whose values are extracted from 'input' starting at the offsets in 'begin'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="018a92a28c57571fe5c1edcfb924689c52abc4b8" translate="yes" xml:space="preserve">
          <source>The output tensor, of rank 3.</source>
          <target state="translated">El tensor de salida,de rango 3.</target>
        </trans-unit>
        <trans-unit id="1f5eef2e4414626524178eb10c4ab831f83220c9" translate="yes" xml:space="preserve">
          <source>The output tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f156d1cf6b13fd91d5c1751333de4bfa7481e5ec" translate="yes" xml:space="preserve">
          <source>The output tensors for the loop variables after the loop. If &lt;code&gt;return_same_structure&lt;/code&gt; is True, the return value has the same structure as &lt;code&gt;loop_vars&lt;/code&gt;. If &lt;code&gt;return_same_structure&lt;/code&gt; is False, the return value is a Tensor, TensorArray or IndexedSlice if the length of &lt;code&gt;loop_vars&lt;/code&gt; is 1, or a list otherwise.</source>
          <target state="translated">Los tensores de salida para las variables de bucle despu&amp;eacute;s del bucle. Si &lt;code&gt;return_same_structure&lt;/code&gt; es True, el valor de retorno tiene la misma estructura que &lt;code&gt;loop_vars&lt;/code&gt; . Si &lt;code&gt;return_same_structure&lt;/code&gt; es False, el valor de retorno es un Tensor, TensorArray o IndexedSlice si la longitud de &lt;code&gt;loop_vars&lt;/code&gt; es 1, o una lista en caso contrario.</target>
        </trans-unit>
        <trans-unit id="0bda5fbd6b0783b500c1218ac7c4c0e7746a4905" translate="yes" xml:space="preserve">
          <source>The output tensors for the loop variables after the loop. The return value has the same structure as &lt;code&gt;loop_vars&lt;/code&gt;.</source>
          <target state="translated">Los tensores de salida para las variables de bucle despu&amp;eacute;s del bucle. El valor de retorno tiene la misma estructura que &lt;code&gt;loop_vars&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a54d6c5881e40fdc200259b55b1119a1261f8a4" translate="yes" xml:space="preserve">
          <source>The output type (&lt;code&gt;int32&lt;/code&gt; or &lt;code&gt;int64&lt;/code&gt;). Default is &lt;a href=&quot;../tf#int32&quot;&gt;&lt;code&gt;tf.int32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abf2d0fef772f974b83b58a081ba47917d2e0a4c" translate="yes" xml:space="preserve">
          <source>The output will be a 3x2 matrix:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bcada90c4c3eacc21413e8c1e200a0e90b07ffc" translate="yes" xml:space="preserve">
          <source>The output will then have shape &lt;code&gt;(32, 10, 32)&lt;/code&gt;.</source>
          <target state="translated">La salida entonces tendr&amp;aacute; forma &lt;code&gt;(32, 10, 32)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d23cb786d0f9d1271884eaa7c1f7cc8c8a656c8" translate="yes" xml:space="preserve">
          <source>The output will then have shape &lt;code&gt;(32, 10, 8)&lt;/code&gt;.</source>
          <target state="translated">La salida tendr&amp;aacute; forma &lt;code&gt;(32, 10, 8)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95238fe986246430e838c38242139b3ddafc69a1" translate="yes" xml:space="preserve">
          <source>The output(s) of the model. See Functional API example below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25ae41f4c527c0741341a2f8b321fd1e43f0f98b" translate="yes" xml:space="preserve">
          <source>The outputs are a deterministic function of &lt;code&gt;shape&lt;/code&gt; and &lt;code&gt;seed&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="179a09c09a45e5c62e2dec3d73d951ec617567f3" translate="yes" xml:space="preserve">
          <source>The outputs are a deterministic function of &lt;code&gt;shape&lt;/code&gt;, &lt;code&gt;seed&lt;/code&gt;, &lt;code&gt;counts&lt;/code&gt;, and &lt;code&gt;probs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d94bca360c8d84e96136112086d8b12a0b843587" translate="yes" xml:space="preserve">
          <source>The outputs are a deterministic function of &lt;code&gt;shape&lt;/code&gt;, &lt;code&gt;seed&lt;/code&gt;, &lt;code&gt;minval&lt;/code&gt;, and &lt;code&gt;maxval&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94289abe2083c6f7cb75f0c826a60167f1e5c8a7" translate="yes" xml:space="preserve">
          <source>The outputs are a deterministic function of &lt;code&gt;shape&lt;/code&gt;, &lt;code&gt;seed&lt;/code&gt;, and &lt;code&gt;alpha&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="228f72119b53e369b51ce6a29a98f2313a7f281f" translate="yes" xml:space="preserve">
          <source>The outputs are a deterministic function of &lt;code&gt;shape&lt;/code&gt;, &lt;code&gt;seed&lt;/code&gt;, and &lt;code&gt;lam&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="262b53d310948dd3d4d6f3d1b24c8027dcc78d4c" translate="yes" xml:space="preserve">
          <source>The outputs from all shards are concatenated back together along their 0-th dimension.</source>
          <target state="translated">Las salidas de todos los fragmentos se concatenan de nuevo a lo largo de su dimensión 0.</target>
        </trans-unit>
        <trans-unit id="fec5d02e1747f7a22db33ab6777959dc638f2020" translate="yes" xml:space="preserve">
          <source>The outputs of functions used as &lt;code&gt;signatures&lt;/code&gt; must either be flat lists, in which case outputs will be numbered, or a dictionary mapping string keys to &lt;code&gt;Tensor&lt;/code&gt;, in which case the keys will be used to name outputs.</source>
          <target state="translated">Las salidas de las funciones utilizadas como &lt;code&gt;signatures&lt;/code&gt; deben ser listas planas, en cuyo caso las salidas se numerar&amp;aacute;n, o un diccionario que asigne claves de cadena a &lt;code&gt;Tensor&lt;/code&gt; , en cuyo caso las claves se utilizar&amp;aacute;n para nombrar las salidas.</target>
        </trans-unit>
        <trans-unit id="3777ae82c580b33611793d1c79fb38091c169efb" translate="yes" xml:space="preserve">
          <source>The package that this class belongs to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4fe37226e907ad6b84032ccb7a1a60c428d9656" translate="yes" xml:space="preserve">
          <source>The padded size of each dimension D of the output is:</source>
          <target state="translated">El tamaño del relleno de cada dimensión D de la salida es:</target>
        </trans-unit>
        <trans-unit id="a3493bda610bfabe1d614c17be7bea5bab6bc509" translate="yes" xml:space="preserve">
          <source>The padding algorithm, must be &quot;SAME&quot; or &quot;VALID&quot;. Defaults to &quot;SAME&quot;. See the &quot;returns&quot; section of &lt;a href=&quot;convolution&quot;&gt;&lt;code&gt;tf.nn.convolution&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94a793cb35afefaa9825726cef177d5eba1c0835" translate="yes" xml:space="preserve">
          <source>The padding algorithm, must be &quot;SAME&quot; or &quot;VALID&quot;. See the &quot;returns&quot; section of &lt;a href=&quot;../../../nn/convolution&quot;&gt;&lt;code&gt;tf.nn.convolution&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82cf1bc0ef022c1c7dcb21d0cd3cf77bf756e7b4" translate="yes" xml:space="preserve">
          <source>The paper demonstrates the performance of MobileNets using &lt;code&gt;alpha&lt;/code&gt; values of 1.0 (also called 100 % MobileNet), 0.35, 0.5, 0.75, 1.0, 1.3, and 1.4 For each of these &lt;code&gt;alpha&lt;/code&gt; values, weights for 5 different input image sizes are provided (224, 192, 160, 128, and 96).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07d5b7b8864997727d8fb01740ad8b9e08b14f5f" translate="yes" xml:space="preserve">
          <source>The paper demonstrates the performance of MobileNets using &lt;code&gt;alpha&lt;/code&gt; values of 1.0 (also called 100 % MobileNet), 0.75, 0.5 and 0.25. For each of these &lt;code&gt;alpha&lt;/code&gt; values, weights for 4 different input image sizes are provided (224, 192, 160, 128).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d91e185b3ec2b95e4e28b058fb7de6ed54c4f63d" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;concentration&lt;/code&gt; and &lt;code&gt;rate&lt;/code&gt; must be shaped in a way that supports broadcasting (e.g. &lt;code&gt;concentration + rate&lt;/code&gt; is a valid operation).</source>
          <target state="translated">Los par&amp;aacute;metros de &lt;code&gt;concentration&lt;/code&gt; y &lt;code&gt;rate&lt;/code&gt; deben configurarse de manera que apoyen la transmisi&amp;oacute;n (por ejemplo, &lt;code&gt;concentration + rate&lt;/code&gt; es una operaci&amp;oacute;n v&amp;aacute;lida).</target>
        </trans-unit>
        <trans-unit id="c4bf0f9162b85380657aa85a48762d0989942eac" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;df&lt;/code&gt;, &lt;code&gt;loc&lt;/code&gt;, and &lt;code&gt;scale&lt;/code&gt; must be shaped in a way that supports broadcasting (e.g. &lt;code&gt;df + loc + scale&lt;/code&gt; is a valid operation).</source>
          <target state="translated">Los par&amp;aacute;metros &lt;code&gt;df&lt;/code&gt; , &lt;code&gt;loc&lt;/code&gt; y &lt;code&gt;scale&lt;/code&gt; deben tener una forma que admita la transmisi&amp;oacute;n (por ejemplo, &lt;code&gt;df + loc + scale&lt;/code&gt; es una operaci&amp;oacute;n v&amp;aacute;lida).</target>
        </trans-unit>
        <trans-unit id="f624db393a0283cdff3712a3c4bd723d749a30a5" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;loc&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; must be shaped in a way that supports broadcasting (e.g. &lt;code&gt;loc + scale&lt;/code&gt; is a valid operation).</source>
          <target state="translated">Los par&amp;aacute;metros &lt;code&gt;loc&lt;/code&gt; y &lt;code&gt;scale&lt;/code&gt; deben tener una forma que admita la transmisi&amp;oacute;n (por ejemplo, &lt;code&gt;loc + scale&lt;/code&gt; es una operaci&amp;oacute;n v&amp;aacute;lida).</target>
        </trans-unit>
        <trans-unit id="a2bb7ef60bf0239928d550799fd1318ab8a8e22c" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;loc&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; must be shaped in a way that supports broadcasting (e.g., &lt;code&gt;loc / scale&lt;/code&gt; is a valid operation).</source>
          <target state="translated">Los par&amp;aacute;metros &lt;code&gt;loc&lt;/code&gt; y &lt;code&gt;scale&lt;/code&gt; deben tener una forma que admita la transmisi&amp;oacute;n (por ejemplo, &lt;code&gt;loc / scale&lt;/code&gt; es una operaci&amp;oacute;n v&amp;aacute;lida).</target>
        </trans-unit>
        <trans-unit id="caea2d657314fc74a3b4c82a6b1a8e2927d4e265" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;low&lt;/code&gt; and &lt;code&gt;high&lt;/code&gt; must be shaped in a way that supports broadcasting (e.g., &lt;code&gt;high - low&lt;/code&gt; is a valid operation).</source>
          <target state="translated">Los par&amp;aacute;metros &lt;code&gt;low&lt;/code&gt; y &lt;code&gt;high&lt;/code&gt; deben tener una forma que admita la radiodifusi&amp;oacute;n (por ejemplo, &lt;code&gt;high - low&lt;/code&gt; es una operaci&amp;oacute;n v&amp;aacute;lida).</target>
        </trans-unit>
        <trans-unit id="2da0524f5e34c476f58d52fd7e4bbaca30e3840a" translate="yes" xml:space="preserve">
          <source>The parameters apply to and only to the immediately enclosing loop. It only has effect if the loop is staged as a TF while_loop; otherwise the parameters have no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f861e09ace62d9cf6a436ce61f90b0514dff3612" translate="yes" xml:space="preserve">
          <source>The parameters can be intuited via their relationship to mean and stddev,</source>
          <target state="translated">Los parámetros pueden ser intuidos a través de su relación con la media y el stddev,</target>
        </trans-unit>
        <trans-unit id="78832ff2cd51fc67f3284e123b0a8c7a1096d66b" translate="yes" xml:space="preserve">
          <source>The parent could be a module when the child is a function at module scope. Or the parent could be a class when a class' method is being replaced. The named child is set to new_child, while the prior definition is saved away for later, when UnsetAll() is called.</source>
          <target state="translated">El padre podría ser un módulo cuando el hijo es una función en el ámbito del módulo.O el padre podría ser una clase cuando un método de &quot;clase&quot; está siendo reemplazado.El hijo nombrado se establece como new_child,mientras que la definición anterior se guarda para más tarde,cuando se llama a UnsetAll().</target>
        </trans-unit>
        <trans-unit id="cc13d476090ccb6ba884188ddcc28a81f62b0726" translate="yes" xml:space="preserve">
          <source>The parse() method checks to make sure that the string argument is a legal value and convert it to a native type. If the value cannot be converted, it should throw a 'ValueError' exception with a human readable explanation of why the value is illegal.</source>
          <target state="translated">El método parse()comprueba que el argumento de la cadena es un valor legal y lo convierte a un tipo nativo.Si el valor no puede ser convertido,debe lanzar una excepción &quot;ValueError&quot; con una explicación legible para los humanos de por qué el valor es ilegal.</target>
        </trans-unit>
        <trans-unit id="cf0794be97523b0be42896e118da1be5a61ff4da" translate="yes" xml:space="preserve">
          <source>The parsed value in native type.</source>
          <target state="translated">El valor analizado en el tipo nativo.</target>
        </trans-unit>
        <trans-unit id="8cff8c184992ecf7d79d6a190fc8e2ad81b8dd10" translate="yes" xml:space="preserve">
          <source>The partitioned embedding in &lt;code&gt;embedding_weights&lt;/code&gt; must all be the same shape except for the first dimension. The first dimension is allowed to vary as the vocabulary size is not necessarily a multiple of &lt;code&gt;P&lt;/code&gt;. &lt;code&gt;embedding_weights&lt;/code&gt; may be a &lt;code&gt;PartitionedVariable&lt;/code&gt; as returned by using &lt;a href=&quot;../compat/v1/get_variable&quot;&gt;&lt;code&gt;tf.compat.v1.get_variable()&lt;/code&gt;&lt;/a&gt; with a partitioner.</source>
          <target state="translated">La incrustaci&amp;oacute;n particionada en &lt;code&gt;embedding_weights&lt;/code&gt; debe tener la misma forma, excepto la primera dimensi&amp;oacute;n. Se deja que la primera dimensi&amp;oacute;n a variar a medida que el tama&amp;ntilde;o del vocabulario no es necesariamente un m&amp;uacute;ltiplo de &lt;code&gt;P&lt;/code&gt; . &lt;code&gt;embedding_weights&lt;/code&gt; puede ser una &lt;code&gt;PartitionedVariable&lt;/code&gt; como se devuelve usando &lt;a href=&quot;../compat/v1/get_variable&quot;&gt; &lt;code&gt;tf.compat.v1.get_variable()&lt;/code&gt; &lt;/a&gt; con un particionador.</target>
        </trans-unit>
        <trans-unit id="8e157288a667a186f035deba918682c801fa1abf" translate="yes" xml:space="preserve">
          <source>The partitioned embedding in &lt;code&gt;embedding_weights&lt;/code&gt; must all be the same shape except for the first dimension. The first dimension is allowed to vary as the vocabulary size is not necessarily a multiple of &lt;code&gt;P&lt;/code&gt;. &lt;code&gt;embedding_weights&lt;/code&gt; may be a &lt;code&gt;PartitionedVariable&lt;/code&gt; as returned by using &lt;a href=&quot;../get_variable&quot;&gt;&lt;code&gt;tf.compat.v1.get_variable()&lt;/code&gt;&lt;/a&gt; with a partitioner.</source>
          <target state="translated">La incrustaci&amp;oacute;n particionada en &lt;code&gt;embedding_weights&lt;/code&gt; debe tener la misma forma, excepto la primera dimensi&amp;oacute;n. Se deja que la primera dimensi&amp;oacute;n a variar a medida que el tama&amp;ntilde;o del vocabulario no es necesariamente un m&amp;uacute;ltiplo de &lt;code&gt;P&lt;/code&gt; . &lt;code&gt;embedding_weights&lt;/code&gt; puede ser una &lt;code&gt;PartitionedVariable&lt;/code&gt; como se devuelve usando &lt;a href=&quot;../get_variable&quot;&gt; &lt;code&gt;tf.compat.v1.get_variable()&lt;/code&gt; &lt;/a&gt; con un particionador.</target>
        </trans-unit>
        <trans-unit id="1549f14314cb2911099be0c08464c7d5489a22a6" translate="yes" xml:space="preserve">
          <source>The partitioned embedding in &lt;code&gt;embedding_weights&lt;/code&gt; must all be the same shape except for the first dimension. The first dimension is allowed to vary as the vocabulary size is not necessarily a multiple of num of shards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3b7bcbb761db59d963bb51839f46a4b29f4af4e" translate="yes" xml:space="preserve">
          <source>The path is relative to tensorflow/</source>
          <target state="translated">La ruta es relativa al flujo tensorial.</target>
        </trans-unit>
        <trans-unit id="f48baa97e568a9b9e3b5f52a6ab7e866fecd8550" translate="yes" xml:space="preserve">
          <source>The path of the output proto file.</source>
          <target state="translated">La ruta del prototipo de salida.</target>
        </trans-unit>
        <trans-unit id="ee14c49610bbef1394c243e137f1c0c32f1960be" translate="yes" xml:space="preserve">
          <source>The path to a directory in which to write checkpoints. A special file named &quot;checkpoint&quot; is also written to this directory (in a human-readable text format) which contains the state of the &lt;code&gt;CheckpointManager&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3d2248f6c5ba1b79f5657059376b70c88f9d6c1" translate="yes" xml:space="preserve">
          <source>The path to an event file created by a &lt;code&gt;SummaryWriter&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a7713229c9d7bf490b65513fab0d07d2cad4f51" translate="yes" xml:space="preserve">
          <source>The path to the TFRecords file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84c5edf8f8528c6dcc19dfeb36d929c09dc91f28" translate="yes" xml:space="preserve">
          <source>The path to the checkpoint as returned by &lt;code&gt;write&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8030756c5c759c44f9f3cb2091477d30b127210" translate="yes" xml:space="preserve">
          <source>The path to the checkpoint, as returned by &lt;code&gt;save&lt;/code&gt; or &lt;a href=&quot;../../../train/latest_checkpoint&quot;&gt;&lt;code&gt;tf.train.latest_checkpoint&lt;/code&gt;&lt;/a&gt;. If None (as when there is no latest checkpoint for &lt;a href=&quot;../../../train/latest_checkpoint&quot;&gt;&lt;code&gt;tf.train.latest_checkpoint&lt;/code&gt;&lt;/a&gt; to return), returns an object which may run initializers for objects in the dependency graph. If the checkpoint was written by the name-based &lt;a href=&quot;saver&quot;&gt;&lt;code&gt;tf.compat.v1.train.Saver&lt;/code&gt;&lt;/a&gt;, names are used to match variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d9bb46d11e0a3efc649638be0d00aa480e84e55" translate="yes" xml:space="preserve">
          <source>The path to the checkpoint, as returned by &lt;code&gt;save&lt;/code&gt; or &lt;a href=&quot;latest_checkpoint&quot;&gt;&lt;code&gt;tf.train.latest_checkpoint&lt;/code&gt;&lt;/a&gt;. If the checkpoint was written by the name-based &lt;a href=&quot;../compat/v1/train/saver&quot;&gt;&lt;code&gt;tf.compat.v1.train.Saver&lt;/code&gt;&lt;/a&gt;, names are used to match variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3c8f8b6fd3cf107eb955208c8e6315d0e1a6163" translate="yes" xml:space="preserve">
          <source>The path to the exported directory as a bytes object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c6d384388d19ed3fa790b1769ea860a0e6be8d0" translate="yes" xml:space="preserve">
          <source>The path to the new checkpoint. It is also recorded in the &lt;code&gt;checkpoints&lt;/code&gt; and &lt;code&gt;latest_checkpoint&lt;/code&gt; properties.</source>
          <target state="translated">El camino al nuevo punto de control. Tambi&amp;eacute;n se registra en los &lt;code&gt;checkpoints&lt;/code&gt; y en &lt;code&gt;latest_checkpoint&lt;/code&gt; propiedades de latest_checkpoint .</target>
        </trans-unit>
        <trans-unit id="995443700e473d68dc872f5c69aa35e966bca809" translate="yes" xml:space="preserve">
          <source>The path to the new checkpoint. It is also recorded in the &lt;code&gt;checkpoints&lt;/code&gt; and &lt;code&gt;latest_checkpoint&lt;/code&gt; properties. &lt;code&gt;None&lt;/code&gt; if no checkpoint is saved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ee0e0b9b831848f3b4065f81ba73b2d7593c0f8" translate="yes" xml:space="preserve">
          <source>The path to the specified file present in the data attribute of py_test or py_binary.</source>
          <target state="translated">La ruta del archivo especificado presente en el atributo de datos de py_test o py_binary.</target>
        </trans-unit>
        <trans-unit id="c28b39685fa19f5fe1fe963ce50d396e16dbe87f" translate="yes" xml:space="preserve">
          <source>The path to the specified file present in the data attribute of py_test or py_binary. Falls back to returning the same as get_data_files_path if it fails to detect a bazel runfiles directory.</source>
          <target state="translated">La ruta del archivo especificado presente en el atributo de datos de py_test o py_binary.Vuelve a devolver lo mismo que get_data_files_path si no detecta un directorio de archivos de ejecución de bazel.</target>
        </trans-unit>
        <trans-unit id="87756ef48ceb2a46a88324fa1e20a23d5ed02a12" translate="yes" xml:space="preserve">
          <source>The path to which the SavedModel protocol buffer was written.</source>
          <target state="translated">La ruta en la que se escribió el buffer de protocolo de SavedModel.</target>
        </trans-unit>
        <trans-unit id="8be5bab78d1909543ad9986a84ecdbc0832b8254" translate="yes" xml:space="preserve">
          <source>The path to which the SavedModel will be stored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dab2a06ad633869bd90e943c4184ac0e2fe54a0" translate="yes" xml:space="preserve">
          <source>The pattern follows the re2 syntax (&lt;a href=&quot;https://github.com/google/re2/wiki/Syntax&quot;&gt;https://github.com/google/re2/wiki/Syntax&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7281e72ad08903abeb2bd587c7c0dfd0d8772e6" translate="yes" xml:space="preserve">
          <source>The pattern follows the re2 syntax (https://github.com/google/re2/wiki/Syntax)</source>
          <target state="translated">El patrón sigue la sintaxis re2 (https://github.com/google/re2/wiki/Syntax)</target>
        </trans-unit>
        <trans-unit id="6073374fbdf4fdacc0b93351a02133e64c1915d8" translate="yes" xml:space="preserve">
          <source>The patterns are defined as strings. Supported patterns are defined here. Note that the pattern can be a Python iteratable of string patterns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c52ca33f774b534fe80a4db87092be76893e002" translate="yes" xml:space="preserve">
          <source>The peephole implementation is based on:</source>
          <target state="translated">La implementación de la mirilla se basa en:</target>
        </trans-unit>
        <trans-unit id="baf8710cc0a85723dd8aa2526d303f0863e63136" translate="yes" xml:space="preserve">
          <source>The performance of &lt;code&gt;LinearOperatorAdjoint&lt;/code&gt; depends on the underlying operators performance.</source>
          <target state="translated">El rendimiento de &lt;code&gt;LinearOperatorAdjoint&lt;/code&gt; depende del rendimiento de los operadores subyacentes.</target>
        </trans-unit>
        <trans-unit id="80d488d70fd1fbe1594d7c6c118ae3795bd1145d" translate="yes" xml:space="preserve">
          <source>The performance of &lt;code&gt;LinearOperatorBlockDiag&lt;/code&gt; on any operation is equal to the sum of the individual operators' operations.</source>
          <target state="translated">El rendimiento de &lt;code&gt;LinearOperatorBlockDiag&lt;/code&gt; en cualquier operaci&amp;oacute;n es igual a la suma de las operaciones de los operadores individuales.</target>
        </trans-unit>
        <trans-unit id="9b2ab24a37ac3d66ce6ff090c15ce4c8f5b1d480" translate="yes" xml:space="preserve">
          <source>The performance of &lt;code&gt;LinearOperatorComposition&lt;/code&gt; on any operation is equal to the sum of the individual operators' operations.</source>
          <target state="translated">El rendimiento de &lt;code&gt;LinearOperatorComposition&lt;/code&gt; en cualquier operaci&amp;oacute;n es igual a la suma de las operaciones de los operadores individuales.</target>
        </trans-unit>
        <trans-unit id="f94bad31467a9ea9f4b4d537674d8e77b0cf1a22" translate="yes" xml:space="preserve">
          <source>The performance of &lt;code&gt;LinearOperatorInversion&lt;/code&gt; depends on the underlying operators performance: &lt;code&gt;solve&lt;/code&gt; and &lt;code&gt;matmul&lt;/code&gt; are swapped, and determinant is inverted.</source>
          <target state="translated">El rendimiento de &lt;code&gt;LinearOperatorInversion&lt;/code&gt; depende del rendimiento de los operadores subyacentes: se intercambian &lt;code&gt;solve&lt;/code&gt; y &lt;code&gt;matmul&lt;/code&gt; y se invierte el determinante.</target>
        </trans-unit>
        <trans-unit id="bc0efd32d22cd6d37162492744eb9c09073101ec" translate="yes" xml:space="preserve">
          <source>The performance of &lt;code&gt;LinearOperatorKronecker&lt;/code&gt; on any operation is equal to the sum of the individual operators' operations.</source>
          <target state="translated">El rendimiento de &lt;code&gt;LinearOperatorKronecker&lt;/code&gt; en cualquier operaci&amp;oacute;n es igual a la suma de las operaciones de los operadores individuales.</target>
        </trans-unit>
        <trans-unit id="3adcc83502b5bf35b4db3b88505bc6feb67f24c9" translate="yes" xml:space="preserve">
          <source>The polygamma function is defined as:</source>
          <target state="translated">La función poligámica se define como:</target>
        </trans-unit>
        <trans-unit id="58805a4c695a0c84e281d698b93c5605de911e7d" translate="yes" xml:space="preserve">
          <source>The port the TensorFlow server is listening on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="278a092ca102f6f63192c91f543df0b76f86bf53" translate="yes" xml:space="preserve">
          <source>The position where padding or truncation happens is determined by the arguments &lt;code&gt;padding&lt;/code&gt; and &lt;code&gt;truncating&lt;/code&gt;, respectively. Pre-padding or removing values from the beginning of the sequence is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d524ae593bfca1cec825db026e283842ef95ed3" translate="yes" xml:space="preserve">
          <source>The possible number of labels the classification task can have. If this value is not provided, it will be calculated using both predictions and labels array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8efb3a74fd166658f111b04a0c0279818ee74864" translate="yes" xml:space="preserve">
          <source>The possible number of labels the prediction task can have. This value must be provided, since a confusion matrix of dimension = [num_classes, num_classes] will be allocated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e0a01897541e4cc7358dd44c0abef35501aae05" translate="yes" xml:space="preserve">
          <source>The possible number of labels the prediction task can have. This value must be provided, since two variables with shape = [num_classes] will be allocated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="692359d83812b544d928c04fadf8b5c3c2df67a0" translate="yes" xml:space="preserve">
          <source>The possible values are: &lt;code&gt;GATE_NONE&lt;/code&gt;, &lt;code&gt;GATE_OP&lt;/code&gt;, and &lt;code&gt;GATE_GRAPH&lt;/code&gt;.</source>
          <target state="translated">Los valores posibles son: &lt;code&gt;GATE_NONE&lt;/code&gt; , &lt;code&gt;GATE_OP&lt;/code&gt; y &lt;code&gt;GATE_GRAPH&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5d3e18deacf1c7ef93bee6d5b865603caff1a2a" translate="yes" xml:space="preserve">
          <source>The potentially support list contains a list of ops that are partially or fully supported, which is derived by simply scanning op names to check whether they can be handled without real conversion and specific parameters.</source>
          <target state="translated">La lista de apoyo potencial contiene una lista de operaciones que están parcial o totalmente apoyadas,que se obtiene simplemente escaneando los nombres de las operaciones para comprobar si se pueden manejar sin conversión real y parámetros específicos.</target>
        </trans-unit>
        <trans-unit id="7c853ad9a21d66e7bd6fdc646ae396c38787f2e0" translate="yes" xml:space="preserve">
          <source>The predicted outputs, a tensor of size &lt;code&gt;[batch_size, d0, .. dN]&lt;/code&gt; where N+1 is the total number of dimensions in &lt;code&gt;predictions&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f104bcdd7d5f421504142d2c94d5f8c62a0e743f" translate="yes" xml:space="preserve">
          <source>The predicted outputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a70f131e2a7ce29596591e28a1cfededaebaff6a" translate="yes" xml:space="preserve">
          <source>The predicted values, a &lt;code&gt;Tensor&lt;/code&gt; of any shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6728a30c6037094fe5c0a9ed3f50b7de76aa2e0d" translate="yes" xml:space="preserve">
          <source>The predicted values, a &lt;code&gt;Tensor&lt;/code&gt; of arbitrary dimensions. Will be cast to &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71f7a8826bad533ae16d312cbce730009c206751" translate="yes" xml:space="preserve">
          <source>The predicted values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4778ceab3533971f6aa86d7a9cab9cffa7b4ebb" translate="yes" xml:space="preserve">
          <source>The predicted values. Each element must be in the range &lt;code&gt;[0, 1]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86f018a513047301d5f31c33cb992832bb0aa35d" translate="yes" xml:space="preserve">
          <source>The predicted values. shape = &lt;code&gt;[batch_size, d0, .. dN]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9916875b88168e8e1d45339b98305ac670cab32" translate="yes" xml:space="preserve">
          <source>The predicted values. shape = &lt;code&gt;[batch_size, d0, .. dN]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="350857c387e91589b30efc773f0aa8bb73f1dd8b" translate="yes" xml:space="preserve">
          <source>The prediction values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22221eb5e9024f9d30d6d77902385bdae34280a3" translate="yes" xml:space="preserve">
          <source>The prefix of a V1 or V2 checkpoint. Typically the result of &lt;code&gt;Saver.save()&lt;/code&gt; or that of &lt;a href=&quot;../../../train/latest_checkpoint&quot;&gt;&lt;code&gt;tf.train.latest_checkpoint()&lt;/code&gt;&lt;/a&gt;, regardless of sharded/non-sharded or V1/V2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaf184bbd1e736ec9f0efcfa8ff77fd74b286f9f" translate="yes" xml:space="preserve">
          <source>The prefix of the most recent checkpoint in &lt;code&gt;directory&lt;/code&gt;.</source>
          <target state="translated">El prefijo del punto de control m&amp;aacute;s reciente en el &lt;code&gt;directory&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e79e9868436b7bc9300626a15307ccf5673bf8d" translate="yes" xml:space="preserve">
          <source>The prefix to use on all names created within the name scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43a7df5de41d0edab56a0d1dc85f3a8f7b95e198" translate="yes" xml:space="preserve">
          <source>The primary case where you need extra work to support mixed precision or float64 is when you create a new tensor, such as with &lt;a href=&quot;../../../ones&quot;&gt;&lt;code&gt;tf.ones&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../constant&quot;&gt;&lt;code&gt;tf.constant&lt;/code&gt;&lt;/a&gt;. In such cases, you must create the tensor of the correct dtype. For example, suppose you modify the &lt;code&gt;MyDense&lt;/code&gt; layer to add a random number to the output using &lt;a href=&quot;../../../random/normal&quot;&gt;&lt;code&gt;tf.random.normal&lt;/code&gt;&lt;/a&gt;. You must pass the input dtype to &lt;a href=&quot;../../../random/normal&quot;&gt;&lt;code&gt;tf.random.normal&lt;/code&gt;&lt;/a&gt; to ensure the dtypes match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70445e39cb7672ad4a6b06501270c1f13979a70f" translate="yes" xml:space="preserve">
          <source>The primary use case for this API is to put tensors in a set/dictionary. We can't put tensors in a set/dictionary as &lt;code&gt;tensor.__hash__()&lt;/code&gt; is no longer available starting Tensorflow 2.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0c5bb1e4f98a69939280a641cea06563cef1412" translate="yes" xml:space="preserve">
          <source>The primary use case for this API is to put variables in a set/dictionary. We can't put variables in a set/dictionary as &lt;code&gt;variable.__hash__()&lt;/code&gt; is no longer available starting Tensorflow 2.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cdbe0557abf05d8c31ba3846734c76d96d3bcc3" translate="yes" xml:space="preserve">
          <source>The primary usecase for this API is to put tensors in a set/dictionary. We can't put tensors in a set/dictionary as &lt;code&gt;tensor.__hash__()&lt;/code&gt; is no longer available starting Tensorflow 2.0.</source>
          <target state="translated">El caso de uso principal de esta API es poner tensores en un conjunto / diccionario. No podemos poner tensores en un conjunto / diccionario como &lt;code&gt;tensor.__hash__()&lt;/code&gt; ya no est&amp;aacute; disponible a partir de Tensorflow 2.0.</target>
        </trans-unit>
        <trans-unit id="14c5ca1e155e62f217839df947a76604aa7befe7" translate="yes" xml:space="preserve">
          <source>The primary usecase for this API is to put variables in a set/dictionary. We can't put variables in a set/dictionary as &lt;code&gt;variable.__hash__()&lt;/code&gt; is no longer available starting Tensorflow 2.0.</source>
          <target state="translated">El caso de uso principal de esta API es poner variables en un conjunto / diccionario. No podemos poner variables en un conjunto / diccionario como &lt;code&gt;variable.__hash__()&lt;/code&gt; ya no est&amp;aacute; disponible a partir de Tensorflow 2.0.</target>
        </trans-unit>
        <trans-unit id="bfffea38233a7f94cfc568cf11eefdfb38392417" translate="yes" xml:space="preserve">
          <source>The probability density function (pdf) is,</source>
          <target state="translated">La función de densidad de probabilidad (pdf)es,</target>
        </trans-unit>
        <trans-unit id="d639692ffbb24f5fe23fd0cf8f29f9ea56836d74" translate="yes" xml:space="preserve">
          <source>The probability density function (pdf) of this distribution is,</source>
          <target state="translated">La función de densidad de probabilidad (pdf)de esta distribución es,</target>
        </trans-unit>
        <trans-unit id="c2092fccabcd3a2abdef73412d545365899001b8" translate="yes" xml:space="preserve">
          <source>The probability mass function (pmf) is,</source>
          <target state="translated">La función de masa de probabilidad (pmf)es,</target>
        </trans-unit>
        <trans-unit id="331d712cc96a7cb254a89657cf4ba910cc781864" translate="yes" xml:space="preserve">
          <source>The processing of each sample contains the following steps:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1597763a35d57db9c807276fa76fead0e6bf3d7" translate="yes" xml:space="preserve">
          <source>The processing of each sample contains the following steps: 1) standardize each sample (usually lowercasing + punctuation stripping) 2) split each sample into substrings (usually words) 3) recombine substrings into tokens (usually ngrams) 4) index tokens (associate a unique int value with each token) 5) transform each sample using this index, either into a vector of ints or a dense float vector.</source>
          <target state="translated">El procesamiento de cada muestra contiene los siguientes pasos:1)normalizar cada muestra (generalmente en minúsculas+eliminación de la puntuación)2)dividir cada muestra en subcadenas (generalmente palabras)3)recombinar las subcadenas en fichas (generalmente ngrams)4)indexar las fichas (asociar un valor int único a cada ficha)5)transformar cada muestra utilizando este índice,ya sea en un vector de ints o en un vector flotante denso.</target>
        </trans-unit>
        <trans-unit id="bc3e043e3089ab9c2cc2954b166a1bf6364579df" translate="yes" xml:space="preserve">
          <source>The profiler server will exit when the process finishes. The service is defined in tensorflow/core/profiler/profiler_service.proto.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e67a4435185658688f7c2b52360cda7ea81a0d75" translate="yes" xml:space="preserve">
          <source>The profiler session will be stopped and profile results can be saved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddcf3e7dfeb12410a9d6122f19a6f9f6186a333b" translate="yes" xml:space="preserve">
          <source>The protocol TensorFlow used to communicate between nodes. Defaults to 'grpc'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e9c7a33590d968d1c4d2adb1f14e30ca9d6e013" translate="yes" xml:space="preserve">
          <source>The provided generator can be finite in which case the class will throw a &lt;code&gt;StopIteration&lt;/code&gt; exception.</source>
          <target state="translated">El generador proporcionado puede ser finito, en cuyo caso la clase lanzar&amp;aacute; una excepci&amp;oacute;n &lt;code&gt;StopIteration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8129f9559f62303b98c598e584d99bb1465d425d" translate="yes" xml:space="preserve">
          <source>The provided value can be a python boolean, a scalar boolean Tensor, or or a callable providing such a value; if a callable is passed it will be invoked on-demand to determine whether summary writing will occur.</source>
          <target state="translated">El valor proporcionado puede ser un pitón booleano,un tensor booleano escalar o un llamable que proporcione tal valor;si se pasa un llamable se invocará a petición para determinar si se producirá la escritura de un resumen.</target>
        </trans-unit>
        <trans-unit id="d84a7589708b247ba11ef0a6241d0276fd1c0415" translate="yes" xml:space="preserve">
          <source>The pseudo-inverse of a matrix &lt;code&gt;A&lt;/code&gt;, is defined as: 'the matrix that 'solves' [the least-squares problem] &lt;code&gt;A @ x = b&lt;/code&gt;,' i.e., if &lt;code&gt;x_hat&lt;/code&gt; is a solution, then &lt;code&gt;A_pinv&lt;/code&gt; is the matrix such that &lt;code&gt;x_hat = A_pinv @ b&lt;/code&gt;. It can be shown that if &lt;code&gt;U @ Sigma @ V.T = A&lt;/code&gt; is the singular value decomposition of &lt;code&gt;A&lt;/code&gt;, then &lt;code&gt;A_pinv = V @ inv(Sigma) U^T&lt;/code&gt;. [(Strang, 1980)][1]</source>
          <target state="translated">La pseudo-inversa de una matriz &lt;code&gt;A&lt;/code&gt; , se define como: 'la matriz que' resuelve '[el problema de m&amp;iacute;nimos cuadrados] &lt;code&gt;A @ x = b&lt;/code&gt; ,' es decir, si &lt;code&gt;x_hat&lt;/code&gt; es una soluci&amp;oacute;n, entonces &lt;code&gt;A_pinv&lt;/code&gt; es la matriz tal que &lt;code&gt;x_hat = A_pinv @ b&lt;/code&gt; . Se puede demostrar que si &lt;code&gt;U @ Sigma @ V.T = A&lt;/code&gt; es la descomposici&amp;oacute;n de valor singular de &lt;code&gt;A&lt;/code&gt; , entonces &lt;code&gt;A_pinv = V @ inv(Sigma) U^T&lt;/code&gt; . [(Strang, 1980)] [1]</target>
        </trans-unit>
        <trans-unit id="9b22641be848196f7d9c02ba6fc3610602324007" translate="yes" xml:space="preserve">
          <source>The purpose of this function is to allow users of existing layers to slowly transition to Keras layers API without breaking existing functionality.</source>
          <target state="translated">El propósito de esta función es permitir a los usuarios de las capas existentes hacer una transición lenta a la API de las capas Keras sin romper la funcionalidad existente.</target>
        </trans-unit>
        <trans-unit id="d088d5e5d63d8b56ec540e3afc689671a1995e6f" translate="yes" xml:space="preserve">
          <source>The purpose of this scope is to allow users of existing layers to slowly transition to a Keras layers API without breaking existing functionality.</source>
          <target state="translated">El propósito de este alcance es permitir a los usuarios de las capas existentes hacer una transición lenta a una API de capas Keras sin romper la funcionalidad existente.</target>
        </trans-unit>
        <trans-unit id="7c5cb70c5a3b792465bd5ce774c8ea2af3bb85e3" translate="yes" xml:space="preserve">
          <source>The python function &lt;code&gt;fn&lt;/code&gt; will be called once with symbolic arguments specified in the &lt;code&gt;signature&lt;/code&gt;, traced, and turned into a graph function. Any variables created by &lt;code&gt;fn&lt;/code&gt; will be owned by the object returned by &lt;code&gt;wrap_function&lt;/code&gt;. The resulting graph function can be called with tensors which match the signature.</source>
          <target state="translated">La funci&amp;oacute;n de python &lt;code&gt;fn&lt;/code&gt; se llamar&amp;aacute; una vez con argumentos simb&amp;oacute;licos especificados en la &lt;code&gt;signature&lt;/code&gt; , se rastrear&amp;aacute; y se convertir&amp;aacute; en una funci&amp;oacute;n gr&amp;aacute;fica. Cualquier variable creada por &lt;code&gt;fn&lt;/code&gt; ser&amp;aacute; propiedad del objeto devuelto por &lt;code&gt;wrap_function&lt;/code&gt; . La funci&amp;oacute;n gr&amp;aacute;fica resultante se puede llamar con tensores que coincidan con la firma.</target>
        </trans-unit>
        <trans-unit id="d03bcbea9ec248eeaa20713d75d526a9879de1ff" translate="yes" xml:space="preserve">
          <source>The quantity to be monitored needs to be available in &lt;code&gt;logs&lt;/code&gt; dict. To make it so, pass the loss or metrics at &lt;code&gt;model.compile()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d8a7f5ae13c0deb4cd4a8012ab18a5fdec064e5" translate="yes" xml:space="preserve">
          <source>The queue reference, i.e. the output of the queue op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaadc5a70ca763680cae28ccccd312176ae7929f" translate="yes" xml:space="preserve">
          <source>The ragged rank for the &lt;code&gt;RaggedTensor&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf2591fdff5d530b2526efe01b41c14d72949b69" translate="yes" xml:space="preserve">
          <source>The random integers are slightly biased unless &lt;code&gt;maxval - minval&lt;/code&gt; is an exact power of two. The bias is small for values of &lt;code&gt;maxval - minval&lt;/code&gt; significantly smaller than the range of the output (either &lt;code&gt;2^32&lt;/code&gt; or &lt;code&gt;2^64&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b20ff491ff5822812275688511b761f22476aa65" translate="yes" xml:space="preserve">
          <source>The range of pixel values for the output image might be slightly different from the range for the input image because of limited numerical precision. To guarantee an output range, for example &lt;code&gt;[0.0, 1.0]&lt;/code&gt;, apply &lt;a href=&quot;../../../clip_by_value&quot;&gt;&lt;code&gt;tf.clip_by_value&lt;/code&gt;&lt;/a&gt; to the output.</source>
          <target state="translated">El rango de valores de p&amp;iacute;xeles para la imagen de salida puede ser ligeramente diferente del rango de la imagen de entrada debido a la precisi&amp;oacute;n num&amp;eacute;rica limitada. Para garantizar un rango de salida, por ejemplo &lt;code&gt;[0.0, 1.0]&lt;/code&gt; , aplique &lt;a href=&quot;../../../clip_by_value&quot;&gt; &lt;code&gt;tf.clip_by_value&lt;/code&gt; &lt;/a&gt; a la salida.</target>
        </trans-unit>
        <trans-unit id="e8fedfebee027b536f10130b6d675ab2045757c3" translate="yes" xml:space="preserve">
          <source>The range of pixel values for the output image might be slightly different from the range for the input image because of limited numerical precision. To guarantee an output range, for example &lt;code&gt;[0.0, 1.0]&lt;/code&gt;, apply &lt;a href=&quot;../clip_by_value&quot;&gt;&lt;code&gt;tf.clip_by_value&lt;/code&gt;&lt;/a&gt; to the output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6294e1714e1b2b241bb1943b70eb74fc15a98222" translate="yes" xml:space="preserve">
          <source>The reason we get 'A2' instead 'A1' on the second call of &lt;a href=&quot;uniform&quot;&gt;&lt;code&gt;tf.random.uniform&lt;/code&gt;&lt;/a&gt; above is because the same &lt;a href=&quot;uniform&quot;&gt;&lt;code&gt;tf.random.uniform&lt;/code&gt;&lt;/a&gt; kernel (i.e. internal representation) is used by TensorFlow for all calls of it with the same arguments, and the kernel maintains an internal counter which is incremented every time it is executed, generating different results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afabff9ee6287914682ddea57965fb5330ae1825" translate="yes" xml:space="preserve">
          <source>The reason we get 'A2' instead 'A1' on the second call of &lt;a href=&quot;uniform&quot;&gt;&lt;code&gt;tf.random.uniform&lt;/code&gt;&lt;/a&gt; above is because the same &lt;a href=&quot;uniform&quot;&gt;&lt;code&gt;tf.random.uniform&lt;/code&gt;&lt;/a&gt; kernel (i.e. internel representation) is used by TensorFlow for all calls of it with the same arguments, and the kernel maintains an internal counter which is incremented every time it is executed, generating different results.</source>
          <target state="translated">La raz&amp;oacute;n por la que obtenemos 'A2' en lugar de 'A1' en la segunda llamada de &lt;a href=&quot;uniform&quot;&gt; &lt;code&gt;tf.random.uniform&lt;/code&gt; &lt;/a&gt; anterior es porque TensorFlow usa el mismo kernel &lt;a href=&quot;uniform&quot;&gt; &lt;code&gt;tf.random.uniform&lt;/code&gt; &lt;/a&gt; (es decir, representaci&amp;oacute;n interna) para todas las llamadas con los mismos argumentos , y el kernel mantiene un contador interno que se incrementa cada vez que se ejecuta generando diferentes resultados.</target>
        </trans-unit>
        <trans-unit id="466c31e39da78ea430b94cdcadf9fd7405e0f0cf" translate="yes" xml:space="preserve">
          <source>The reason we get 'A2' instead 'A1' on the second call of &lt;a href=&quot;uniform&quot;&gt;&lt;code&gt;tf.random.uniform&lt;/code&gt;&lt;/a&gt; above is because the secand call uses a different operation seed.</source>
          <target state="translated">La raz&amp;oacute;n por la que obtenemos 'A2' en lugar de 'A1' en la segunda llamada de &lt;a href=&quot;uniform&quot;&gt; &lt;code&gt;tf.random.uniform&lt;/code&gt; &lt;/a&gt; anterior es porque la llamada secando usa una semilla de operaci&amp;oacute;n diferente.</target>
        </trans-unit>
        <trans-unit id="784df8a2c4aec00572bf8c70feb9ae2a52a2afdd" translate="yes" xml:space="preserve">
          <source>The reason we get 'A2' instead 'A1' on the second call of &lt;a href=&quot;uniform&quot;&gt;&lt;code&gt;tf.random.uniform&lt;/code&gt;&lt;/a&gt; above is because the second call uses a different operation seed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1280cfc6968446075563e60ad83288d637db87ba" translate="yes" xml:space="preserve">
          <source>The reconstruct one or more matrices from their LU decomposition(s).</source>
          <target state="translated">Los reconstruyen una o más matrices a partir de su(s)descomposición(es)de LU.</target>
        </trans-unit>
        <trans-unit id="39397157700bab61929a7d8ce8314e15144efa4b" translate="yes" xml:space="preserve">
          <source>The reduced SparseTensor.</source>
          <target state="translated">El SparseTensor reducido.</target>
        </trans-unit>
        <trans-unit id="162a81b2ee639009df98d0138880fb964fcbc8fc" translate="yes" xml:space="preserve">
          <source>The reduced Tensor or the reduced SparseTensor if &lt;code&gt;output_is_sparse&lt;/code&gt; is True.</source>
          <target state="translated">El Tensor reducido o el SparseTensor reducido si &lt;code&gt;output_is_sparse&lt;/code&gt; es True.</target>
        </trans-unit>
        <trans-unit id="1e34999a75a17ec65b85f93cb20fe03874e9d9e8" translate="yes" xml:space="preserve">
          <source>The reduced Tensor.</source>
          <target state="translated">El Tensor reducido.</target>
        </trans-unit>
        <trans-unit id="fa52820210f038254236a33cd72deaaa4f2921cc" translate="yes" xml:space="preserve">
          <source>The reduced tensor (number of nonzero values).</source>
          <target state="translated">El tensor reducido (número de valores no nulos).</target>
        </trans-unit>
        <trans-unit id="5089f15002ac696c728750d278b7a2bb4b8292fd" translate="yes" xml:space="preserve">
          <source>The reduced tensor, of the same dtype as the input_tensor.</source>
          <target state="translated">El tensor reducido,del mismo tipo que el input_tensor.</target>
        </trans-unit>
        <trans-unit id="db036397ce15010ca38b7140e4ed7771da72f4bd" translate="yes" xml:space="preserve">
          <source>The reduced tensor, of the same dtype as the input_tensor. Note, for &lt;code&gt;complex64&lt;/code&gt; or &lt;code&gt;complex128&lt;/code&gt; input, the returned &lt;code&gt;Tensor&lt;/code&gt; will be of type &lt;code&gt;float32&lt;/code&gt; or &lt;code&gt;float64&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="377005a84a788fcaae09139342bfe31ee6c3e407" translate="yes" xml:space="preserve">
          <source>The reduced tensor.</source>
          <target state="translated">El tensor reducido.</target>
        </trans-unit>
        <trans-unit id="4ca20066ecafb2f76458db7f5aae15b94f4599bf" translate="yes" xml:space="preserve">
          <source>The reduction to apply to the shard losses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32126f130f539d8b348c3776e0d288e0eb3023ae" translate="yes" xml:space="preserve">
          <source>The reference to the TensorArray.</source>
          <target state="translated">La referencia al TensorArray.</target>
        </trans-unit>
        <trans-unit id="bec5f1d035188c5f615977438d1fd8d80cd736d2" translate="yes" xml:space="preserve">
          <source>The regular expressions we want to match against str. See &quot;Notes&quot; above for detailed notes on how this is interpreted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="626421317b8daa7c4481578d7b1400cbc817027c" translate="yes" xml:space="preserve">
          <source>The regularized incomplete beta integral is defined as:</source>
          <target state="translated">La integral beta incompleta regularizada se define como:</target>
        </trans-unit>
        <trans-unit id="6b4ae5690943cd94c52d8b3b53e424b70c0a6f84" translate="yes" xml:space="preserve">
          <source>The remapping tensors can be generated using the GenerateVocabRemapping op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f76fd4e0a09c22f0b1432236fcf10360b759293" translate="yes" xml:space="preserve">
          <source>The remappings are 1-D tensors with the following properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eb549ec0edb51386556b04bcb293e63f29c79c8" translate="yes" xml:space="preserve">
          <source>The replacement character codepoint to be used in place of any invalid input when &lt;code&gt;errors='replace'&lt;/code&gt;. Any valid unicode codepoint may be used. The default value is the default unicode replacement character which is 0xFFFD (U+65533).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc58567cf18ed1da38d660adbff7112eaf4a0c43" translate="yes" xml:space="preserve">
          <source>The replacement codepoint to be used in place of invalid substrings in &lt;code&gt;input&lt;/code&gt; when &lt;code&gt;errors='replace'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5861bd77b8284cbd383ce9fa80004e5915d9c8c5" translate="yes" xml:space="preserve">
          <source>The replacement codepoint to be used in place of invalid substrings in &lt;code&gt;input&lt;/code&gt; when &lt;code&gt;errors='replace'&lt;/code&gt;; and in place of C0 control characters in &lt;code&gt;input&lt;/code&gt; when &lt;code&gt;replace_control_characters=True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08f7982eae76c3d1b8d5c546c5c6087586c14c26" translate="yes" xml:space="preserve">
          <source>The request does not have valid authentication credentials.</source>
          <target state="translated">La solicitud no tiene credenciales de autenticación válidas.</target>
        </trans-unit>
        <trans-unit id="11fac311a887cb1b94b956ea27985cb8f91c9eab" translate="yes" xml:space="preserve">
          <source>The requirements to use the cuDNN implementation are:</source>
          <target state="translated">Los requisitos para utilizar la implementación de la cuDNN son:</target>
        </trans-unit>
        <trans-unit id="b7f944aa478f301b9d7d37d3ac6e02aa0ab614e1" translate="yes" xml:space="preserve">
          <source>The rescaling is applied both during training and inference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e10dd1c4bdea08780ec12768ba2f0c0cc6e6418e" translate="yes" xml:space="preserve">
          <source>The resizing Ops accept input images as tensors of several types. They always output resized images as float32 tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f32138dd7f669a33bea7319cf66264923452d20" translate="yes" xml:space="preserve">
          <source>The restored checkpoint path if the lastest checkpoint is found and restored. Otherwise None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d06ff612c69fb3df1f3d794bb785e13f8da40620" translate="yes" xml:space="preserve">
          <source>The result is a 4-D tensor of shape &lt;code&gt;[batch_size, glimpse_height, glimpse_width, channels]&lt;/code&gt;. The channels and batch dimensions are the same as that of the input tensor. The height and width of the output windows are specified in the &lt;code&gt;size&lt;/code&gt; parameter.</source>
          <target state="translated">El resultado es un tensor de forma 4-D &lt;code&gt;[batch_size, glimpse_height, glimpse_width, channels]&lt;/code&gt; . Los canales y las dimensiones del lote son los mismos que los del tensor de entrada. La altura y el ancho de las ventanas de salida se especifican en el par&amp;aacute;metro de &lt;code&gt;size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af8e15d374bd08a8ea2bebed96d25f27af99cc58" translate="yes" xml:space="preserve">
          <source>The result is a 4D tensor which is indexed by batch, row, and column. &lt;code&gt;output[i, x, y]&lt;/code&gt; contains a flattened patch of size &lt;code&gt;sizes[1], sizes[2]&lt;/code&gt; which is taken from the input starting at &lt;code&gt;images[i, x*strides[1], y*strides[2]]&lt;/code&gt;.</source>
          <target state="translated">El resultado es un tensor 4D indexado por lote, fila y columna. &lt;code&gt;output[i, x, y]&lt;/code&gt; contiene un parche aplanado de &lt;code&gt;sizes[1], sizes[2]&lt;/code&gt; que se toma de la entrada que comienza en las &lt;code&gt;images[i, x*strides[1], y*strides[2]]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3408db8eec06fef64e88ca8c2438893f2827e593" translate="yes" xml:space="preserve">
          <source>The result is a [..., M+1, M] matrix with [..., 0,:] containing the eigenvalues, and subsequent [...,1:, :] containing the eigenvectors. The eigenvalues are sorted in non-decreasing order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91e981525729cfb7323f601fab3d959548453e14" translate="yes" xml:space="preserve">
          <source>The result is not a global index to the entire &lt;code&gt;Tensor&lt;/code&gt;, but rather just the index in the last dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc0fc847805d05865dd1fc80479599ef10e030da" translate="yes" xml:space="preserve">
          <source>The result of calling parse_example on these examples will produce a dictionary with entries for &quot;ids&quot; and &quot;values&quot;. Passing those two objects to this function along with vocab_size=6, will produce a &lt;code&gt;SparseTensor&lt;/code&gt; that sparsely represents all three instances. Namely, the &lt;code&gt;indices&lt;/code&gt; property will contain the coordinates of the non-zero entries in the feature matrix (the first dimension is the row number in the matrix, i.e., the index within the batch, and the second dimension is the column number, i.e., the feature id); &lt;code&gt;values&lt;/code&gt; will contain the actual values. &lt;code&gt;shape&lt;/code&gt; will be the shape of the original matrix, i.e., (3, 6). For our example above, the output will be equal to:</source>
          <target state="translated">El resultado de llamar a parse_example en estos ejemplos producir&amp;aacute; un diccionario con entradas para &quot;ids&quot; y &quot;valores&quot;. Pasar esos dos objetos a esta funci&amp;oacute;n junto con vocab_size = 6, producir&amp;aacute; un &lt;code&gt;SparseTensor&lt;/code&gt; que representa escasamente las tres instancias. Es decir, la propiedad de &lt;code&gt;indices&lt;/code&gt; contendr&amp;aacute; las coordenadas de las entradas distintas de cero en la matriz de caracter&amp;iacute;sticas (la primera dimensi&amp;oacute;n es el n&amp;uacute;mero de fila en la matriz, es decir, el &amp;iacute;ndice dentro del lote, y la segunda dimensi&amp;oacute;n es el n&amp;uacute;mero de columna, es decir, la identificaci&amp;oacute;n de la funci&amp;oacute;n); &lt;code&gt;values&lt;/code&gt; contendr&amp;aacute;n los valores reales. &lt;code&gt;shape&lt;/code&gt; ser&amp;aacute; la forma de la matriz original, es decir, (3, 6). Para nuestro ejemplo anterior, la salida ser&amp;aacute; igual a:</target>
        </trans-unit>
        <trans-unit id="c532f85716ab7d9d5ac1221540a16a00cf14d0f8" translate="yes" xml:space="preserve">
          <source>The result of one inference step, typically the output of calling the &lt;code&gt;Model&lt;/code&gt; on data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b712de5339fc3e663594598e87ccb0f331d98d0d" translate="yes" xml:space="preserve">
          <source>The result of the elementwise &lt;code&gt;!=&lt;/code&gt; operation, or &lt;code&gt;True&lt;/code&gt; if the arguments are not broadcast-compatible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65bf62ac9a12a3ed583f3696b9ec4dfdd36908c0" translate="yes" xml:space="preserve">
          <source>The result of the elementwise &lt;code&gt;+&lt;/code&gt; operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a0379f511e04f35dbfdf4e95a15f796515177e5" translate="yes" xml:space="preserve">
          <source>The result of the elementwise &lt;code&gt;==&lt;/code&gt; operation, or &lt;code&gt;False&lt;/code&gt; if the arguments are not broadcast-compatible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7181bf7e73106c9b2b97d9fffba14ef65fbf1f8" translate="yes" xml:space="preserve">
          <source>The result of this op should be passed through a &lt;code&gt;sparse_to_dense&lt;/code&gt; operation, then added to the logits of the sampled classes. This removes the contradictory effect of accidentally sampling the true target classes as noise classes for the same example.</source>
          <target state="translated">El resultado de esta operaci&amp;oacute;n debe pasar a trav&amp;eacute;s de una operaci&amp;oacute;n &lt;code&gt;sparse_to_dense&lt;/code&gt; , luego agregarse a los logits de las clases muestreadas. Esto elimina el efecto contradictorio de muestrear accidentalmente las verdaderas clases objetivo como clases de ruido para el mismo ejemplo.</target>
        </trans-unit>
        <trans-unit id="95bce95270c24fcef8ff10f45294119d2cbaf8aa" translate="yes" xml:space="preserve">
          <source>The result will be biased towards the initial value of the variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01298564c21aafdba5ad8531a719b0b62528e9fe" translate="yes" xml:space="preserve">
          <source>The result will have those bits set, that are different in &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. The computation is performed on the underlying representations of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">El resultado ser&amp;aacute; tener esos bits establecidos, que son diferentes en &lt;code&gt;x&lt;/code&gt; y &lt;code&gt;y&lt;/code&gt; . El c&amp;aacute;lculo se realiza sobre las representaciones subyacentes de &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="685b62e5962fffb0313c314fe8766a83e91dc7ce" translate="yes" xml:space="preserve">
          <source>The result will have those bits set, that are set in &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; or both. The computation is performed on the underlying representations of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">El resultado tendr&amp;aacute; esos bits establecidos en &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; o o ambos. El c&amp;aacute;lculo se realiza sobre las representaciones subyacentes de &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b74f37adc87a210e3154c60f498551da0c0a3084" translate="yes" xml:space="preserve">
          <source>The result will have those bits set, that are set in both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. The computation is performed on the underlying representations of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">El resultado tendr&amp;aacute; esos bits establecidos, que se establecen tanto en &lt;code&gt;x&lt;/code&gt; como en &lt;code&gt;y&lt;/code&gt; . El c&amp;aacute;lculo se realiza sobre las representaciones subyacentes de &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a454b218545175a81109283a1b62827f2751cc1d" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Tensor&lt;/code&gt; of parsing a single &lt;code&gt;SequenceExample&lt;/code&gt; or &lt;code&gt;Example&lt;/code&gt; has a static &lt;code&gt;shape&lt;/code&gt; of &lt;code&gt;[None] + shape&lt;/code&gt; and the specified &lt;code&gt;dtype&lt;/code&gt;. The resulting &lt;code&gt;Tensor&lt;/code&gt; of parsing a &lt;code&gt;batch_size&lt;/code&gt; many &lt;code&gt;Example&lt;/code&gt;s has a static &lt;code&gt;shape&lt;/code&gt; of &lt;code&gt;[batch_size, None] + shape&lt;/code&gt; and the specified &lt;code&gt;dtype&lt;/code&gt;. The entries in the &lt;code&gt;batch&lt;/code&gt; from different &lt;code&gt;Examples&lt;/code&gt; will be padded with &lt;code&gt;default_value&lt;/code&gt; to the maximum length present in the &lt;code&gt;batch&lt;/code&gt;.</source>
          <target state="translated">El &lt;code&gt;Tensor&lt;/code&gt; resultante de analizar un solo &lt;code&gt;SequenceExample&lt;/code&gt; o &lt;code&gt;Example&lt;/code&gt; tiene una &lt;code&gt;shape&lt;/code&gt; est&amp;aacute;tica de &lt;code&gt;[None] + shape&lt;/code&gt; y el &lt;code&gt;dtype&lt;/code&gt; especificado . El &lt;code&gt;Tensor&lt;/code&gt; resultante de analizar un &lt;code&gt;batch_size&lt;/code&gt; muchos &lt;code&gt;Example&lt;/code&gt; s tiene una &lt;code&gt;shape&lt;/code&gt; est&amp;aacute;tica de &lt;code&gt;[batch_size, None] + shape&lt;/code&gt; y el &lt;code&gt;dtype&lt;/code&gt; especificado . Las entradas en el &lt;code&gt;batch&lt;/code&gt; de diferentes &lt;code&gt;Examples&lt;/code&gt; se rellenar&amp;aacute;n con &lt;code&gt;default_value&lt;/code&gt; hasta la longitud m&amp;aacute;xima presente en el &lt;code&gt;batch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a538e992c4e715c1f91b7c40110e2510e29c989" translate="yes" xml:space="preserve">
          <source>The resulting SavedModel is then servable with an input named &quot;x&quot;, its value having any shape and dtype float32.</source>
          <target state="translated">El SavedModel resultante es entonces servible con una entrada llamada &quot;x&quot;,su valor tiene cualquier forma y tipo de flotador32.</target>
        </trans-unit>
        <trans-unit id="b71ce2b54de94b7e8ecf2e651366ba952c5ce3a3" translate="yes" xml:space="preserve">
          <source>The resulting dataset is similar to the &lt;code&gt;InterleaveDataset&lt;/code&gt;, except that the dataset will fetch records from the interleaved datasets in parallel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d8659c50ab2dced91f800b38d49965e49b25d1c" translate="yes" xml:space="preserve">
          <source>The resulting dataset is similar to the &lt;code&gt;InterleaveDataset&lt;/code&gt;, with the exception that if retrieving the next value from a dataset would cause the requester to block, it will skip that input dataset. This dataset is especially useful when loading data from a variable-latency datastores (e.g. HDFS, GCS), as it allows the training step to proceed so long as some data is available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd835a476d97294a9a531a06c729ae1427276dc8" translate="yes" xml:space="preserve">
          <source>The resulting function is assumed stateful and will never be optimized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f53b61193a80c029c5a448efed06c1a8f6588c5" translate="yes" xml:space="preserve">
          <source>The resulting output shape when using the &quot;same&quot; padding option is: &lt;code&gt;output_shape = input_shape / strides&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ef25e64d2e423f7de1f3a02ba7a25085c38c8a1" translate="yes" xml:space="preserve">
          <source>The resulting tensor is populated with values of type &lt;code&gt;dtype&lt;/code&gt;, as specified by arguments &lt;code&gt;value&lt;/code&gt; and (optionally) &lt;code&gt;shape&lt;/code&gt; (see examples below).</source>
          <target state="translated">El tensor resultante se completa con valores de tipo &lt;code&gt;dtype&lt;/code&gt; , seg&amp;uacute;n lo especificado por el &lt;code&gt;value&lt;/code&gt; argumentos y (opcionalmente) la &lt;code&gt;shape&lt;/code&gt; (ver ejemplos a continuaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="0b674f3072695f2111704701dbc3947bfb383f3f" translate="yes" xml:space="preserve">
          <source>The resulting tensor is populated with values of type &lt;code&gt;dtype&lt;/code&gt;, as specified by arguments &lt;code&gt;value&lt;/code&gt; following the desired &lt;code&gt;shape&lt;/code&gt; of the new tensor (see examples below).</source>
          <target state="translated">El tensor resultante se completa con valores de tipo &lt;code&gt;dtype&lt;/code&gt; , seg&amp;uacute;n lo especificado por el &lt;code&gt;value&lt;/code&gt; argumentos siguiendo la &lt;code&gt;shape&lt;/code&gt; deseada del nuevo tensor (ver ejemplos a continuaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="ef74e8f16df07a307babda0cfa120db0e980020d" translate="yes" xml:space="preserve">
          <source>The resulting tensor would look like this:</source>
          <target state="translated">El tensor resultante se vería así:</target>
        </trans-unit>
        <trans-unit id="381b1e6543678db4ed459c1cba156ecc8ca01172" translate="yes" xml:space="preserve">
          <source>The resulting update to ref would look like this:</source>
          <target state="translated">La actualización resultante para el árbitro se vería así:</target>
        </trans-unit>
        <trans-unit id="cbbd169c06c5469910e771887e06b5ed0c01b738" translate="yes" xml:space="preserve">
          <source>The resulting update to v would look like this:</source>
          <target state="translated">La actualización resultante de v se vería así:</target>
        </trans-unit>
        <trans-unit id="993bb51caef566927c6f2034eead7ae47fdb56d0" translate="yes" xml:space="preserve">
          <source>The resulting value &lt;code&gt;output&lt;/code&gt; would look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cc6293ac412a772df6f0e78ca55482c98eb64a2" translate="yes" xml:space="preserve">
          <source>The results of the lookup are concatenated into a dense tensor. The returned tensor has shape &lt;code&gt;shape(ids) + shape(params)[1:]&lt;/code&gt;.</source>
          <target state="translated">Los resultados de la b&amp;uacute;squeda se concatenan en un tensor denso. El tensor devuelto tiene forma &lt;code&gt;shape(ids) + shape(params)[1:]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f1f40e1bca978cc7aa38e548317ee19cb7dfd8c" translate="yes" xml:space="preserve">
          <source>The return value has the same type as &lt;code&gt;images&lt;/code&gt; if &lt;code&gt;method&lt;/code&gt; is &lt;a href=&quot;../../../image/resizemethod#NEAREST_NEIGHBOR&quot;&gt;&lt;code&gt;ResizeMethod.NEAREST_NEIGHBOR&lt;/code&gt;&lt;/a&gt;. It will also have the same type as &lt;code&gt;images&lt;/code&gt; if the size of &lt;code&gt;images&lt;/code&gt; can be statically determined to be the same as &lt;code&gt;size&lt;/code&gt;, because &lt;code&gt;images&lt;/code&gt; is returned in this case. Otherwise, the return value has type &lt;code&gt;float32&lt;/code&gt;.</source>
          <target state="translated">El valor de retorno tiene el mismo tipo que las &lt;code&gt;images&lt;/code&gt; si el &lt;code&gt;method&lt;/code&gt; es &lt;a href=&quot;../../../image/resizemethod#NEAREST_NEIGHBOR&quot;&gt; &lt;code&gt;ResizeMethod.NEAREST_NEIGHBOR&lt;/code&gt; &lt;/a&gt; . Tambi&amp;eacute;n tendr&amp;aacute; el mismo tipo que las &lt;code&gt;images&lt;/code&gt; si se puede determinar est&amp;aacute;ticamente que el tama&amp;ntilde;o de las &lt;code&gt;images&lt;/code&gt; es el mismo que el &lt;code&gt;size&lt;/code&gt; , porque las &lt;code&gt;images&lt;/code&gt; se devuelven en este caso. De lo contrario, el valor de retorno tiene el tipo &lt;code&gt;float32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d56a51802c9fd20b938ff0224e17cc92fbe0a0fd" translate="yes" xml:space="preserve">
          <source>The return value has the same type as &lt;code&gt;images&lt;/code&gt; if &lt;code&gt;method&lt;/code&gt; is &lt;a href=&quot;../../../image/resizemethod#NEAREST_NEIGHBOR&quot;&gt;&lt;code&gt;tf.image.ResizeMethod.NEAREST_NEIGHBOR&lt;/code&gt;&lt;/a&gt;. It will also have the same type as &lt;code&gt;images&lt;/code&gt; if the size of &lt;code&gt;images&lt;/code&gt; can be statically determined to be the same as &lt;code&gt;size&lt;/code&gt;, because &lt;code&gt;images&lt;/code&gt; is returned in this case. Otherwise, the return value has type &lt;code&gt;float32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90335752084dfbdd6479bc3425e07c2c184fac03" translate="yes" xml:space="preserve">
          <source>The return value has the same type as &lt;code&gt;images&lt;/code&gt; if &lt;code&gt;method&lt;/code&gt; is &lt;a href=&quot;resizemethod#NEAREST_NEIGHBOR&quot;&gt;&lt;code&gt;ResizeMethod.NEAREST_NEIGHBOR&lt;/code&gt;&lt;/a&gt;. Otherwise, the return value has type &lt;code&gt;float32&lt;/code&gt;.</source>
          <target state="translated">El valor de retorno tiene el mismo tipo que las &lt;code&gt;images&lt;/code&gt; si el &lt;code&gt;method&lt;/code&gt; es &lt;a href=&quot;resizemethod#NEAREST_NEIGHBOR&quot;&gt; &lt;code&gt;ResizeMethod.NEAREST_NEIGHBOR&lt;/code&gt; &lt;/a&gt; . De lo contrario, el valor de retorno tiene el tipo &lt;code&gt;float32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d380f2c5d4525994512f90f349c7eb51132c6e2" translate="yes" xml:space="preserve">
          <source>The return value has type &lt;code&gt;float32&lt;/code&gt;, unless the &lt;code&gt;method&lt;/code&gt; is &lt;a href=&quot;resizemethod#NEAREST_NEIGHBOR&quot;&gt;&lt;code&gt;ResizeMethod.NEAREST_NEIGHBOR&lt;/code&gt;&lt;/a&gt;, then the return dtype is the dtype of &lt;code&gt;images&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6db6bf11d3c25e837bbcedc93fcb0930b2a99ab3" translate="yes" xml:space="preserve">
          <source>The return value is not the same Tensor as the original, but contains the same values. This operation is fast when used on the same device.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e3b67eed807726677126c856d0a6214fa8f8e4a" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;merge_fn&lt;/code&gt;, except for &lt;code&gt;PerReplica&lt;/code&gt; values which are unpacked.</source>
          <target state="translated">El valor de retorno de &lt;code&gt;merge_fn&lt;/code&gt; , excepto los valores de &lt;code&gt;PerReplica&lt;/code&gt; que est&amp;aacute;n descomprimidos.</target>
        </trans-unit>
        <trans-unit id="b729f575891182a1cf2b646557e584015983e0cf" translate="yes" xml:space="preserve">
          <source>The return values from &lt;code&gt;Session.run()&lt;/code&gt; corresponding to the fetches attribute returned in the RunArgs. Note that this has the same shape as the RunArgs fetches. For example: fetches = global_step_tensor =&amp;gt; results = nparray(int) fetches = [train_op, summary_op, global_step_tensor] =&amp;gt; results = [None, nparray(string), nparray(int)] fetches = {'step': global_step_tensor, 'summ': summary_op} =&amp;gt; results = {'step': nparray(int), 'summ': nparray(string)}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e968254f01cab6234b67bba030e47e2fb4dbf82" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;../../../../distribute/distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt; can be iterated over similar to how regular datasets can. NOTE: The user cannot add any more transformations to a &lt;a href=&quot;../../../../distribute/distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e54bb88894be8aec22542ba047bf035708660a8b" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;../../../distribute/distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt; can be iterated over similar to how regular datasets can. NOTE: The user cannot add any more transformations to a &lt;a href=&quot;../../../distribute/distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bc73b952597eebba1bc9614e25b86603811dd74" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;../distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt; can be iterated over similar to how regular datasets can. NOTE: The user cannot add any more transformations to a &lt;a href=&quot;../distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77573df9f9325728fade9f377ed047dae4204229" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt; can be iterated over similar to how regular datasets can. NOTE: The user cannot add any more transformations to a &lt;a href=&quot;distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dea02fa1b7f8947a51fb716ddcefda916820715" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;tensorshape&quot;&gt;&lt;code&gt;tf.TensorShape&lt;/code&gt;&lt;/a&gt; is determined at &lt;em&gt;build&lt;/em&gt; time, without executing the underlying kernel. It is not a &lt;a href=&quot;tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;. If you need a shape &lt;em&gt;tensor&lt;/em&gt;, either convert the &lt;a href=&quot;tensorshape&quot;&gt;&lt;code&gt;tf.TensorShape&lt;/code&gt;&lt;/a&gt; to a &lt;a href=&quot;constant&quot;&gt;&lt;code&gt;tf.constant&lt;/code&gt;&lt;/a&gt;, or use the &lt;a href=&quot;shape&quot;&gt;&lt;code&gt;tf.shape(tensor)&lt;/code&gt;&lt;/a&gt; function, which returns the tensor's shape at &lt;em&gt;execution&lt;/em&gt; time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="111bba19cc7fb0062ed6fe66a53428292ab2ad62" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;RaggedTensor&lt;/code&gt; corresponds with the python list defined by:</source>
          <target state="translated">El &lt;code&gt;RaggedTensor&lt;/code&gt; devuelto se corresponde con la lista de Python definida por:</target>
        </trans-unit>
        <trans-unit id="ecbcae5eb984661e7de2445f57c60c5e40e3d894" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Session&lt;/code&gt; will be the innermost session on which a &lt;code&gt;Session&lt;/code&gt; or &lt;code&gt;Session.as_default()&lt;/code&gt; context has been entered.</source>
          <target state="translated">La &lt;code&gt;Session&lt;/code&gt; devuelta ser&amp;aacute; la sesi&amp;oacute;n m&amp;aacute;s interna en la que se ha ingresado un contexto &lt;code&gt;Session&lt;/code&gt; o &lt;code&gt;Session.as_default()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95a65357f0f57659490bed4f233c4a4d8fc08588" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Tensor&lt;/code&gt; will be close to an exact solution if &lt;code&gt;A&lt;/code&gt; is well conditioned. Otherwise closeness will vary. See class docstring for details.</source>
          <target state="translated">El &lt;code&gt;Tensor&lt;/code&gt; devuelto estar&amp;aacute; cerca de una soluci&amp;oacute;n exacta si &lt;code&gt;A&lt;/code&gt; est&amp;aacute; bien acondicionado. De lo contrario, la cercan&amp;iacute;a variar&amp;aacute;. Consulte la cadena de documentaci&amp;oacute;n de la clase para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="210a2253a38d62adf49c231834e4374a228751a1" translate="yes" xml:space="preserve">
          <source>The returned callable will have the same return type as &lt;code&gt;tf.Session.run(fetches, ...)&lt;/code&gt;. For example, if &lt;code&gt;fetches&lt;/code&gt; is a &lt;a href=&quot;../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;, the callable will return a numpy ndarray; if &lt;code&gt;fetches&lt;/code&gt; is a &lt;a href=&quot;../../operation&quot;&gt;&lt;code&gt;tf.Operation&lt;/code&gt;&lt;/a&gt;, it will return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">El invocable devuelto tendr&amp;aacute; el mismo tipo de retorno que &lt;code&gt;tf.Session.run(fetches, ...)&lt;/code&gt; . Por ejemplo, si &lt;code&gt;fetches&lt;/code&gt; es un &lt;a href=&quot;../../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt; , el invocable devolver&amp;aacute; un ndarray numpy; si &lt;code&gt;fetches&lt;/code&gt; es una &lt;a href=&quot;../../operation&quot;&gt; &lt;code&gt;tf.Operation&lt;/code&gt; &lt;/a&gt; , devolver&amp;aacute; &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfdda7d94aac832546a913098111bedb3a5af104" translate="yes" xml:space="preserve">
          <source>The returned callable will take &lt;code&gt;len(feed_list)&lt;/code&gt; arguments whose types must be compatible feed values for the respective elements of &lt;code&gt;feed_list&lt;/code&gt;. For example, if element &lt;code&gt;i&lt;/code&gt; of &lt;code&gt;feed_list&lt;/code&gt; is a &lt;a href=&quot;../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;i&lt;/code&gt;th argument to the returned callable must be a numpy ndarray (or something convertible to an ndarray) with matching element type and shape. See &lt;code&gt;tf.Session.run&lt;/code&gt; for details of the allowable feed key and value types.</source>
          <target state="translated">El invocable devuelto tomar&amp;aacute; argumentos &lt;code&gt;len(feed_list)&lt;/code&gt; cuyos tipos deben ser valores de feed compatibles para los elementos respectivos de &lt;code&gt;feed_list&lt;/code&gt; . Por ejemplo, si el elemento &lt;code&gt;i&lt;/code&gt; de &lt;code&gt;feed_list&lt;/code&gt; es un &lt;a href=&quot;../../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt; , el &lt;code&gt;i&lt;/code&gt; &amp;eacute;simo argumento al regresar exigible debe ser un ndarray numpy (o algo convertible a un ndarray) con el tipo y la forma elemento coincidente. Consulte &lt;code&gt;tf.Session.run&lt;/code&gt; para obtener detalles sobre los tipos de valor y clave de alimentaci&amp;oacute;n permitidos.</target>
        </trans-unit>
        <trans-unit id="5ae9baaba07ae2a863bb456cb56b210b15bfeca4" translate="yes" xml:space="preserve">
          <source>The returned dataset is a wrapped strategy dataset which creates a multidevice iterator under the hood. It prefetches the input data to the specified devices on the worker. The returned distributed dataset can be iterated over similar to how regular datasets can.</source>
          <target state="translated">El conjunto de datos devuelto es un conjunto de datos de estrategia envuelto que crea un iterador multidispositivo bajo el capó.Prefiere los datos de entrada a los dispositivos especificados en el trabajador.El conjunto de datos distribuidos devueltos puede ser iterado de forma similar a como lo hacen los conjuntos de datos regulares.</target>
        </trans-unit>
        <trans-unit id="b16f128652226cd5df44d3210c5abe8996d2a7b8" translate="yes" xml:space="preserve">
          <source>The returned dict may have the following keys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f7e2363fe125c1a5cdb798835abe8de5ac8aef0" translate="yes" xml:space="preserve">
          <source>The returned dictionary can be used as arg 'features' in &lt;a href=&quot;../../../io/parse_example&quot;&gt;&lt;code&gt;tf.io.parse_example&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El diccionario devuelto se puede usar como 'caracter&amp;iacute;sticas' arg en &lt;a href=&quot;../../../io/parse_example&quot;&gt; &lt;code&gt;tf.io.parse_example&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="27148d9610fe5857a584045bc355cd08d4ce68b2" translate="yes" xml:space="preserve">
          <source>The returned dictionary can be used as arg 'features' in &lt;a href=&quot;../io/parse_example&quot;&gt;&lt;code&gt;tf.io.parse_example&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El diccionario devuelto se puede usar como 'caracter&amp;iacute;sticas' arg en &lt;a href=&quot;../io/parse_example&quot;&gt; &lt;code&gt;tf.io.parse_example&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e41cdf1dd9ec5b48c6c1a627e04bc9cd0f5646ec" translate="yes" xml:space="preserve">
          <source>The returned distributed dataset can be iterated over similar to how regular datasets can. NOTE: Currently, the user cannot add any more transformations to a distributed dataset.</source>
          <target state="translated">El conjunto de datos distribuidos devueltos puede ser iterado de manera similar a como lo pueden hacer los conjuntos de datos regulares.NOTA:Actualmente,el usuario no puede añadir más transformaciones a un conjunto de datos distribuidos.</target>
        </trans-unit>
        <trans-unit id="8e5c9b1714c669dc39fd802e652891ab6982a58a" translate="yes" xml:space="preserve">
          <source>The returned graph will be the innermost graph on which a &lt;a href=&quot;../../graph#as_default&quot;&gt;&lt;code&gt;Graph.as_default()&lt;/code&gt;&lt;/a&gt; context has been entered, or a global default graph if none has been explicitly created.</source>
          <target state="translated">El gr&amp;aacute;fico devuelto ser&amp;aacute; el gr&amp;aacute;fico m&amp;aacute;s interno en el que se ha ingresado un contexto &lt;a href=&quot;../../graph#as_default&quot;&gt; &lt;code&gt;Graph.as_default()&lt;/code&gt; &lt;/a&gt; , o un gr&amp;aacute;fico predeterminado global si no se ha creado expl&amp;iacute;citamente.</target>
        </trans-unit>
        <trans-unit id="a3ca6a76bf18bc7eb9e290fd0f8d92384b3fc63a" translate="yes" xml:space="preserve">
          <source>The returned graph will be the innermost graph on which a &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/Graph#as_default&quot;&gt;&lt;code&gt;Graph.as_default()&lt;/code&gt;&lt;/a&gt; context has been entered, or a global default graph if none has been explicitly created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4983b6188d9b3a5503f72bc1978affb47cac7b6d" translate="yes" xml:space="preserve">
          <source>The returned iterator implements the Python Iterator protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b38dad137146b9ef38ba7c509e2c0442b75c1f0" translate="yes" xml:space="preserve">
          <source>The returned iterator implements the Python iterator protocol and therefore can only be used in eager mode.</source>
          <target state="translated">El iterador devuelto implementa el protocolo del iterador de Python y,por lo tanto,sólo puede ser usado en modo ansioso.</target>
        </trans-unit>
        <trans-unit id="7e0593141fa29e4d333dddf121d2181c125317c5" translate="yes" xml:space="preserve">
          <source>The returned iterator is not bound to a particular dataset, and it has no &lt;code&gt;initializer&lt;/code&gt;. To initialize the iterator, run the operation returned by &lt;code&gt;Iterator.make_initializer(dataset)&lt;/code&gt;.</source>
          <target state="translated">El iterador devuelto no est&amp;aacute; vinculado a un conjunto de datos en particular y no tiene &lt;code&gt;initializer&lt;/code&gt; . Para inicializar el iterador, ejecute la operaci&amp;oacute;n devuelta por &lt;code&gt;Iterator.make_initializer(dataset)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35c004b6fa1c65f47bcd7047f0f10a1978a605f3" translate="yes" xml:space="preserve">
          <source>The returned operation is a dequeue operation and will throw &lt;a href=&quot;../../../errors/outofrangeerror&quot;&gt;&lt;code&gt;tf.errors.OutOfRangeError&lt;/code&gt;&lt;/a&gt; if the input queue is exhausted. If this operation is feeding another input queue, its queue runner will catch this exception, however, if this operation is used in your main thread you are responsible for catching this yourself.</source>
          <target state="translated">La operaci&amp;oacute;n devuelta es una operaci&amp;oacute;n de sacar de cola y arrojar&amp;aacute; &lt;a href=&quot;../../../errors/outofrangeerror&quot;&gt; &lt;code&gt;tf.errors.OutOfRangeError&lt;/code&gt; &lt;/a&gt; si la cola de entrada se agota. Si esta operaci&amp;oacute;n alimenta otra cola de entrada, su corredor de cola detectar&amp;aacute; esta excepci&amp;oacute;n, sin embargo, si esta operaci&amp;oacute;n se usa en su hilo principal, usted es responsable de detectarla usted mismo.</target>
        </trans-unit>
        <trans-unit id="388161f4aeaed3801662f433bd19fe4a8d446b0a" translate="yes" xml:space="preserve">
          <source>The returned permutation may be used to permute the rows and columns of the given sparse matrix. This typically results in permuted sparse matrix's sparse Cholesky (or other decompositions) in having fewer zero fill-in compared to decomposition of the original matrix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34611a4904c47d805a50142b42fe43a0ecae787f" translate="yes" xml:space="preserve">
          <source>The returned sparse matrix has the same dense shape as the input sparse matrix. For each component &lt;code&gt;A&lt;/code&gt; of the input sparse matrix, the corresponding output sparse matrix represents &lt;code&gt;L&lt;/code&gt;, the lower triangular Cholesky factor satisfying the following identity:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="283d98979ab1e70cde916469a5e89b9e786cbb6c" translate="yes" xml:space="preserve">
          <source>The returned status object has the following methods:</source>
          <target state="translated">El objeto de estado devuelto tiene los siguientes métodos:</target>
        </trans-unit>
        <trans-unit id="b692f2b05a18e92aff1d5bc6f670c1b3f429e602" translate="yes" xml:space="preserve">
          <source>The returned string will be in the form protocol://address, e.g. &quot;grpc://localhost:5050&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c118b1fddbb7639875cad9b7ab197644effe14a5" translate="yes" xml:space="preserve">
          <source>The returned tensor uses the memory shared by dlpack capsules from other framework.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76a9be24217f14af8b4e90ac374a00f3e69a4114" translate="yes" xml:space="preserve">
          <source>The returned tensor will contain a serialized &lt;a href=&quot;../../summary&quot;&gt;&lt;code&gt;tf.compat.v1.summary.Summary&lt;/code&gt;&lt;/a&gt; protocol buffer, which can be used with the standard TensorBoard logging facilities.</source>
          <target state="translated">El tensor devuelto contendr&amp;aacute; un &lt;a href=&quot;../../summary&quot;&gt; &lt;code&gt;tf.compat.v1.summary.Summary&lt;/code&gt; &lt;/a&gt; protocolo tf.compat.v1.summary.Summary serializado , que se puede usar con las funciones de registro est&amp;aacute;ndar de TensorBoard.</target>
        </trans-unit>
        <trans-unit id="c2eac31d16e8529bfab56c61e3821bc8b01c5d91" translate="yes" xml:space="preserve">
          <source>The returned tensor's dimension &lt;code&gt;i&lt;/code&gt; will correspond to the input dimension &lt;code&gt;perm[i]&lt;/code&gt;. If &lt;code&gt;perm&lt;/code&gt; is not given, it is set to (n-1...0), where n is the rank of the input tensor. Hence by default, this operation performs a regular matrix transpose on 2-D input Tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82d1c361e6f8f0d84bf0a1bcea9214b49e8cf3d3" translate="yes" xml:space="preserve">
          <source>The returned tensor's dimension i will correspond to the input dimension &lt;code&gt;perm[i]&lt;/code&gt;. If &lt;code&gt;perm&lt;/code&gt; is not given, it is set to (n-1...0), where n is the rank of the input tensor. Hence by default, this operation performs a regular matrix transpose on 2-D input Tensors.</source>
          <target state="translated">La dimensi&amp;oacute;n i del tensor devuelto corresponder&amp;aacute; a la dimensi&amp;oacute;n de entrada &lt;code&gt;perm[i]&lt;/code&gt; . Si no se da &lt;code&gt;perm&lt;/code&gt; , se establece en (n-1 ... 0), donde n es el rango del tensor de entrada. Por lo tanto, de forma predeterminada, esta operaci&amp;oacute;n realiza una transposici&amp;oacute;n de matriz regular en tensores de entrada 2-D.</target>
        </trans-unit>
        <trans-unit id="d9c115cc2d00147127224aefb2bd6a8e1bbe0c5c" translate="yes" xml:space="preserve">
          <source>The returned tensor's dimension i will correspond to the input dimension &lt;code&gt;perm[i]&lt;/code&gt;. If &lt;code&gt;perm&lt;/code&gt; is not given, it is set to (n-1...0), where n is the rank of the input tensor. Hence by default, this operation performs a regular matrix transpose on 2-D input Tensors. If conjugate is True and &lt;code&gt;a.dtype&lt;/code&gt; is either &lt;code&gt;complex64&lt;/code&gt; or &lt;code&gt;complex128&lt;/code&gt; then the values of &lt;code&gt;a&lt;/code&gt; are conjugated and transposed.</source>
          <target state="translated">La dimensi&amp;oacute;n i del tensor devuelto corresponder&amp;aacute; a la dimensi&amp;oacute;n de entrada &lt;code&gt;perm[i]&lt;/code&gt; . Si no se da &lt;code&gt;perm&lt;/code&gt; , se establece en (n-1 ... 0), donde n es el rango del tensor de entrada. Por lo tanto, de forma predeterminada, esta operaci&amp;oacute;n realiza una transposici&amp;oacute;n de matriz regular en tensores de entrada 2-D. Si conjugate es True y &lt;code&gt;a.dtype&lt;/code&gt; es &lt;code&gt;complex64&lt;/code&gt; o &lt;code&gt;complex128&lt;/code&gt; , entonces los valores de &lt;code&gt;a&lt;/code&gt; se conjugan y transponen.</target>
        </trans-unit>
        <trans-unit id="838e6e70eeb12ce61fde540b38b4044a46a8f134" translate="yes" xml:space="preserve">
          <source>The returned tensors are &lt;a href=&quot;../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;s if &lt;code&gt;input&lt;/code&gt; is a scalar, or &lt;a href=&quot;../raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt;s otherwise.</source>
          <target state="translated">Los tensores devueltos son &lt;a href=&quot;../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt; s si la &lt;code&gt;input&lt;/code&gt; es un escalar, o &lt;a href=&quot;../raggedtensor&quot;&gt; &lt;code&gt;tf.RaggedTensor&lt;/code&gt; &lt;/a&gt; s en caso contrario.</target>
        </trans-unit>
        <trans-unit id="710644f5cd50999519cd748e88ddf36f02a2b455" translate="yes" xml:space="preserve">
          <source>The right-hand side of the &lt;code&gt;!=&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e668edbb07540997101fa0f49a39faa5f38caec8" translate="yes" xml:space="preserve">
          <source>The right-hand side of the &lt;code&gt;+&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff72258325f43cdf735f357c785333acbdbfc89a" translate="yes" xml:space="preserve">
          <source>The right-hand side of the &lt;code&gt;==&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca75c2c84ca7c94aaa9f8f708d895cba56b5cf74" translate="yes" xml:space="preserve">
          <source>The row partition tensors are in the order of the dimensions. At present, the types can be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85216d0bd898c6d1680f5aac974d5348d1d96c2f" translate="yes" xml:space="preserve">
          <source>The row-split indices for this ragged tensor's &lt;code&gt;values&lt;/code&gt;.</source>
          <target state="translated">Los &amp;iacute;ndices de fila-split para de este tensor desigual &lt;code&gt;values&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5854e78835764512ec754b4ac011bb9b48f7d380" translate="yes" xml:space="preserve">
          <source>The row_splits for all ragged dimensions in this ragged tensor value.</source>
          <target state="translated">El row_splits para todas las dimensiones de este valor de tensor desigual.</target>
        </trans-unit>
        <trans-unit id="5158c81c5ea5bb74de68daed2eacbf5dc32d4ad8" translate="yes" xml:space="preserve">
          <source>The runtime is then free to make optimizations based on this.</source>
          <target state="translated">El tiempo de ejecución es entonces libre para hacer optimizaciones basadas en esto.</target>
        </trans-unit>
        <trans-unit id="ca5cdf682a9605ca998129dd4a854da399041aba" translate="yes" xml:space="preserve">
          <source>The same array (Numpy array if &lt;code&gt;x&lt;/code&gt; was a Numpy array, or TensorFlow tensor if &lt;code&gt;x&lt;/code&gt; was a tensor), cast to its new type.</source>
          <target state="translated">La misma matriz (matriz Numpy si &lt;code&gt;x&lt;/code&gt; era una matriz Numpy, o tensor de TensorFlow si &lt;code&gt;x&lt;/code&gt; era un tensor), se env&amp;iacute;a a su nuevo tipo.</target>
        </trans-unit>
        <trans-unit id="e4b3e7c37b806fc9d4b600343aa28d9179c53706" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;../../raggedtensor#__div__&quot;&gt;&lt;code&gt;tf.compat.v1.div(x,y)&lt;/code&gt;&lt;/a&gt; for integers, but uses &lt;code&gt;tf.floor(tf.compat.v1.div(x,y))&lt;/code&gt; for floating point arguments so that the result is always an integer (though possibly an integer represented as floating point). This op is generated by &lt;code&gt;x // y&lt;/code&gt; floor division in Python 3 and in Python 2.7 with &lt;code&gt;from __future__ import division&lt;/code&gt;.</source>
          <target state="translated">Lo mismo que &lt;a href=&quot;../../raggedtensor#__div__&quot;&gt; &lt;code&gt;tf.compat.v1.div(x,y)&lt;/code&gt; &lt;/a&gt; para enteros, pero usa &lt;code&gt;tf.floor(tf.compat.v1.div(x,y))&lt;/code&gt; para argumentos de punto flotante, de modo que el resultado siempre sea un entero ( aunque posiblemente un n&amp;uacute;mero entero representado como punto flotante). Esta operaci&amp;oacute;n se genera mediante la divisi&amp;oacute;n de piso &lt;code&gt;x // y&lt;/code&gt; en Python 3 y en Python 2.7 con la &lt;code&gt;from __future__ import division&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07525f9495ce7a62b86179e9f6083e34f20d8d8b" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;../raggedtensor#__div__&quot;&gt;&lt;code&gt;tf.compat.v1.div(x,y)&lt;/code&gt;&lt;/a&gt; for integers, but uses &lt;code&gt;tf.floor(tf.compat.v1.div(x,y))&lt;/code&gt; for floating point arguments so that the result is always an integer (though possibly an integer represented as floating point). This op is generated by &lt;code&gt;x // y&lt;/code&gt; floor division in Python 3 and in Python 2.7 with &lt;code&gt;from __future__ import division&lt;/code&gt;.</source>
          <target state="translated">Lo mismo que &lt;a href=&quot;../raggedtensor#__div__&quot;&gt; &lt;code&gt;tf.compat.v1.div(x,y)&lt;/code&gt; &lt;/a&gt; para enteros, pero usa &lt;code&gt;tf.floor(tf.compat.v1.div(x,y))&lt;/code&gt; para argumentos de punto flotante, de modo que el resultado siempre sea un entero ( aunque posiblemente un n&amp;uacute;mero entero representado como punto flotante). Esta operaci&amp;oacute;n se genera mediante la divisi&amp;oacute;n de piso &lt;code&gt;x // y&lt;/code&gt; en Python 3 y en Python 2.7 con la &lt;code&gt;from __future__ import division&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3240798db52d492b4a5e0a4f1101b0ce22e5dea6" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;raggedtensor#__div__&quot;&gt;&lt;code&gt;tf.compat.v1.div(x,y)&lt;/code&gt;&lt;/a&gt; for integers, but uses &lt;code&gt;tf.floor(tf.compat.v1.div(x,y))&lt;/code&gt; for floating point arguments so that the result is always an integer (though possibly an integer represented as floating point). This op is generated by &lt;code&gt;x // y&lt;/code&gt; floor division in Python 3 and in Python 2.7 with &lt;code&gt;from __future__ import division&lt;/code&gt;.</source>
          <target state="translated">Lo mismo que &lt;a href=&quot;raggedtensor#__div__&quot;&gt; &lt;code&gt;tf.compat.v1.div(x,y)&lt;/code&gt; &lt;/a&gt; para enteros, pero usa &lt;code&gt;tf.floor(tf.compat.v1.div(x,y))&lt;/code&gt; para argumentos de punto flotante, de modo que el resultado siempre sea un entero ( aunque posiblemente un n&amp;uacute;mero entero representado como punto flotante). Esta operaci&amp;oacute;n se genera mediante la divisi&amp;oacute;n de piso &lt;code&gt;x // y&lt;/code&gt; en Python 3 y en Python 2.7 con la &lt;code&gt;from __future__ import division&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6016fab50d93b1e77917677d258e0e003f237e6" translate="yes" xml:space="preserve">
          <source>The same tensor &lt;code&gt;x&lt;/code&gt;, unchanged.</source>
          <target state="translated">El mismo tensor &lt;code&gt;x&lt;/code&gt; , sin cambios.</target>
        </trans-unit>
        <trans-unit id="e28b3d74027804ad355c817f8c256af8b2d25a2a" translate="yes" xml:space="preserve">
          <source>The samples are differentiable w.r.t. alpha and beta. The derivatives are computed using the approach described in (Figurnov et al., 2018).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c3935638fc889928b31f22a28b40af71a593afd" translate="yes" xml:space="preserve">
          <source>The samples are differentiable w.r.t. alpha and beta. The derivatives are computed using the approach described in the paper</source>
          <target state="translated">Las muestras son diferenciables con la T.R.A.alfa y beta.Los derivados se calculan utilizando el enfoque descrito en el documento</target>
        </trans-unit>
        <trans-unit id="92952659dac1bf101ab8c26a5fd0e7570c899948" translate="yes" xml:space="preserve">
          <source>The sampling probabilities are generated according to the sampling distribution used in word2vec:</source>
          <target state="translated">Las probabilidades de muestreo se generan de acuerdo con la distribución de muestreo utilizada en word2vec:</target>
        </trans-unit>
        <trans-unit id="7e70c09e21b733e9d2a808af0f600268962663fb" translate="yes" xml:space="preserve">
          <source>The save counter variable.</source>
          <target state="translated">La variable del contador de salvamento.</target>
        </trans-unit>
        <trans-unit id="ab43a8a642f72175fe828def8c8d03e9a692fe7b" translate="yes" xml:space="preserve">
          <source>The saved checkpoint includes variables created by this object and any trackable objects it depends on at the time &lt;a href=&quot;../../../train/checkpoint#save&quot;&gt;&lt;code&gt;Checkpoint.save()&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">El punto de control guardado incluye variables creadas por este objeto y cualquier objeto rastreable del que depende en el momento en que se llama a &lt;a href=&quot;../../../train/checkpoint#save&quot;&gt; &lt;code&gt;Checkpoint.save()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="21ba0881308b74c027819f31603cfc6647b52c80" translate="yes" xml:space="preserve">
          <source>The saved checkpoint includes variables created by this object and any trackable objects it depends on at the time &lt;a href=&quot;checkpoint#save&quot;&gt;&lt;code&gt;Checkpoint.save()&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">El punto de control guardado incluye variables creadas por este objeto y cualquier objeto rastreable del que depende en el momento en que se llama a &lt;a href=&quot;checkpoint#save&quot;&gt; &lt;code&gt;Checkpoint.save()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="38adbe2f58aa8b45a85ccd9d545a08f193885a40" translate="yes" xml:space="preserve">
          <source>The saved checkpoint includes variables created by this object and any trackable objects it depends on at the time &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/train/Checkpoint#save&quot;&gt;&lt;code&gt;Checkpoint.save()&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6290af5f5d901c235fa2702c12d35d14bd8fbb8" translate="yes" xml:space="preserve">
          <source>The saved dataset is saved in multiple file &quot;shards&quot;. By default, the dataset output is divided to shards in a round-robin fashion but custom sharding can be specified via the &lt;code&gt;shard_func&lt;/code&gt; function. For example, you can save the dataset to using a single shard as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32eabd05b895cc5cbd843e5d58a26478d871b570" translate="yes" xml:space="preserve">
          <source>The saved model contains:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3b7070f1ecc16e817793f6b5d01b2b53b58703e" translate="yes" xml:space="preserve">
          <source>The saved model contains: - the model's configuration (topology) - the model's weights - the model's optimizer's state (if any)</source>
          <target state="translated">El modelo guardado contiene:-la configuración del modelo (topología)-los pesos del modelo-el estado del optimizador del modelo (si lo hay)</target>
        </trans-unit>
        <trans-unit id="eeb866c0e9b8a790b2b06bb4bf72fe83fcf3b7fd" translate="yes" xml:space="preserve">
          <source>The savefile includes:</source>
          <target state="translated">El archivo de guardado incluye:</target>
        </trans-unit>
        <trans-unit id="2be8f8b013a0bea1b78a799bc083aef46d344f06" translate="yes" xml:space="preserve">
          <source>The scalar &lt;code&gt;default_value&lt;/code&gt; is the value output for keys not present in the table. It must also be of the same type as the table values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff3fd5f27f08bbd84c446309ecdaecd1825d0b40" translate="yes" xml:space="preserve">
          <source>The scalar PSNR between a and b. The returned tensor has type &lt;a href=&quot;../../tf#float32&quot;&gt;&lt;code&gt;tf.float32&lt;/code&gt;&lt;/a&gt; and shape [batch_size, 1].</source>
          <target state="translated">El PSNR escalar entre ay b. El tensor devuelto tiene el tipo &lt;a href=&quot;../../tf#float32&quot;&gt; &lt;code&gt;tf.float32&lt;/code&gt; &lt;/a&gt; y la forma [batch_size, 1].</target>
        </trans-unit>
        <trans-unit id="dd78e4034ea5bbefe47a5585f3fa965bc5acaa8e" translate="yes" xml:space="preserve">
          <source>The scaled exponential unit activation: &lt;code&gt;scale * elu(x, alpha)&lt;/code&gt;.</source>
          <target state="translated">La activaci&amp;oacute;n de la unidad exponencial escalada: &lt;code&gt;scale * elu(x, alpha)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7cdf9b27ca1dd2bbd540e30d82d6f1126674d88" translate="yes" xml:space="preserve">
          <source>The scaling_factor is determined from &lt;code&gt;min_range&lt;/code&gt;, &lt;code&gt;max_range&lt;/code&gt;, and &lt;code&gt;narrow_range&lt;/code&gt; in a way that is compatible with &lt;code&gt;QuantizeAndDequantize{V2|V3}&lt;/code&gt; and &lt;code&gt;QuantizeV2&lt;/code&gt;, using the following algorithm:</source>
          <target state="translated">El factor de escala se determina a partir de &lt;code&gt;min_range&lt;/code&gt; , &lt;code&gt;max_range&lt;/code&gt; y &lt;code&gt;narrow_range&lt;/code&gt; de manera que sea compatible con &lt;code&gt;QuantizeAndDequantize{V2|V3}&lt;/code&gt; y &lt;code&gt;QuantizeV2&lt;/code&gt; , utilizando el siguiente algoritmo:</target>
        </trans-unit>
        <trans-unit id="d82c0e384909c0dd188de5ead9b2872459677ae8" translate="yes" xml:space="preserve">
          <source>The schedule a 1-arg callable that produces a decayed learning rate when passed the current optimizer step. This can be useful for changing the learning rate value across different invocations of optimizer functions.</source>
          <target state="translated">El programa es un 1-Grupo que produce una tasa de aprendizaje decadente cuando se pasa el paso actual del optimizador.Esto puede ser útil para cambiar el valor de la tasa de aprendizaje a través de diferentes invocaciones de las funciones del optimizador.</target>
        </trans-unit>
        <trans-unit id="c2ad88fa788374ec95b4583696db082a634b18eb" translate="yes" xml:space="preserve">
          <source>The schedule a 1-arg callable that produces a decayed learning rate when passed the current optimizer step. This can be useful for changing the learning rate value across different invocations of optimizer functions. It is computed as:</source>
          <target state="translated">El programa es un 1-Grupo que produce una tasa de aprendizaje decadente cuando se pasa el paso actual del optimizador.Esto puede ser útil para cambiar el valor de la tasa de aprendizaje a través de diferentes invocaciones de las funciones del optimizador.Se calcula como:</target>
        </trans-unit>
        <trans-unit id="71d2993ed1ad7b32ffe04dab2486da899c3f2739" translate="yes" xml:space="preserve">
          <source>The schedule is a 1-arg callable that produces a decayed learning rate when passed the current optimizer step. This can be useful for changing the learning rate value across different invocations of optimizer functions. It is computed as:</source>
          <target state="translated">El horario es un 1arg llamable que produce una tasa de aprendizaje decaída cuando se pasa el paso actual del optimizador.Esto puede ser útil para cambiar el valor de la tasa de aprendizaje a través de diferentes invocaciones de las funciones del optimizador.Se calcula como:</target>
        </trans-unit>
        <trans-unit id="70da9d42a4b299e69bb575bc1c369e715f3022f0" translate="yes" xml:space="preserve">
          <source>The scope for the operations performed in computing the loss.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bf5542bf013cf2cd0c7e2cee3c5c6cd6c529ad0" translate="yes" xml:space="preserve">
          <source>The scope name.</source>
          <target state="translated">El nombre del alcance.</target>
        </trans-unit>
        <trans-unit id="50f230356c528b135a5e5c8be0185503e716f9b3" translate="yes" xml:space="preserve">
          <source>The second call of &lt;code&gt;foo&lt;/code&gt; returns '(A2, A2)' instead of '(A1, A1)' because &lt;a href=&quot;uniform&quot;&gt;&lt;code&gt;tf.random.uniform&lt;/code&gt;&lt;/a&gt; maintains an internal counter. If you want &lt;code&gt;foo&lt;/code&gt; to return '(A1, A1)' every time, use the stateless random ops such as &lt;a href=&quot;stateless_uniform&quot;&gt;&lt;code&gt;tf.random.stateless_uniform&lt;/code&gt;&lt;/a&gt;. Also see &lt;a href=&quot;experimental/generator&quot;&gt;&lt;code&gt;tf.random.experimental.Generator&lt;/code&gt;&lt;/a&gt; for a new set of stateful random ops that use external variables to manage their states.</source>
          <target state="translated">La segunda llamada de &lt;code&gt;foo&lt;/code&gt; devuelve '(A2, A2)' en lugar de '(A1, A1)' porque &lt;a href=&quot;uniform&quot;&gt; &lt;code&gt;tf.random.uniform&lt;/code&gt; &lt;/a&gt; mantiene un contador interno. Si desea que &lt;code&gt;foo&lt;/code&gt; devuelva '(A1, A1)' cada vez, use las operaciones aleatorias sin estado como &lt;a href=&quot;stateless_uniform&quot;&gt; &lt;code&gt;tf.random.stateless_uniform&lt;/code&gt; &lt;/a&gt; . Tambi&amp;eacute;n vea &lt;a href=&quot;experimental/generator&quot;&gt; &lt;code&gt;tf.random.experimental.Generator&lt;/code&gt; &lt;/a&gt; para un nuevo conjunto de operaciones aleatorias con estado que usan variables externas para administrar sus estados.</target>
        </trans-unit>
        <trans-unit id="99c1ec05a48b05e1a2d2c74a95c41738070d1d52" translate="yes" xml:space="preserve">
          <source>The second call of &lt;code&gt;foo&lt;/code&gt; returns '(A2, A2)' instead of '(A1, A1)' because &lt;a href=&quot;uniform&quot;&gt;&lt;code&gt;tf.random.uniform&lt;/code&gt;&lt;/a&gt; maintains an internal counter. If you want &lt;code&gt;foo&lt;/code&gt; to return '(A1, A1)' every time, use the stateless random ops such as &lt;a href=&quot;stateless_uniform&quot;&gt;&lt;code&gt;tf.random.stateless_uniform&lt;/code&gt;&lt;/a&gt;. Also see &lt;a href=&quot;generator&quot;&gt;&lt;code&gt;tf.random.experimental.Generator&lt;/code&gt;&lt;/a&gt; for a new set of stateful random ops that use external variables to manage their states.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08568c721bd015f102f6c3ec1b535d6153171292" translate="yes" xml:space="preserve">
          <source>The second dict contains the feature_list key/values.</source>
          <target state="translated">El segundo dictado contiene la clave/valores de la lista de características.</target>
        </trans-unit>
        <trans-unit id="55c0e48b341890b90c7222213ebdf6711ed127c5" translate="yes" xml:space="preserve">
          <source>The second distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73916e07f6ea34c81abd799027349571045df1c6" translate="yes" xml:space="preserve">
          <source>The second innermost dimension of &lt;code&gt;diagonal&lt;/code&gt; has double meaning. When &lt;code&gt;k&lt;/code&gt; is scalar or &lt;code&gt;k[0] == k[1]&lt;/code&gt;, &lt;code&gt;M&lt;/code&gt; is part of the batch size [I, J, ..., M], and the output tensor is:</source>
          <target state="translated">La segunda dimensi&amp;oacute;n m&amp;aacute;s interna de la &lt;code&gt;diagonal&lt;/code&gt; tiene un doble significado. Cuando &lt;code&gt;k&lt;/code&gt; es escalar o &lt;code&gt;k[0] == k[1]&lt;/code&gt; , &lt;code&gt;M&lt;/code&gt; es parte del tama&amp;ntilde;o del lote [I, J, ..., M] y el tensor de salida es:</target>
        </trans-unit>
        <trans-unit id="897c8f258e58c08596b32bdbc51f703aa19e32cb" translate="yes" xml:space="preserve">
          <source>The second list to compare.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07d2101b8340d508be1c61741652a76d9deb3b07" translate="yes" xml:space="preserve">
          <source>The second operand; &lt;code&gt;SparseTensor&lt;/code&gt; or &lt;code&gt;Tensor&lt;/code&gt;. At least one operand must be sparse.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb28a5566b72083d75d5c15273e66594bb2b10e4" translate="yes" xml:space="preserve">
          <source>The second sequence to compare.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f44476a07dabc329393369e874eaf7a10133de21" translate="yes" xml:space="preserve">
          <source>The second set to compare.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f193b83c375843f2a04bc17c95ee85c91007fcdb" translate="yes" xml:space="preserve">
          <source>The second structure to compare.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1bef3c10ad61ff65c7724ce0d24e0698479866c" translate="yes" xml:space="preserve">
          <source>The second tuple to compare.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b310dae88696133dc7ed85369e494d665ee6beaf" translate="yes" xml:space="preserve">
          <source>The second variant is compatible with CuDNNGRU (GPU-only) and allows inference on CPU. Thus it has separate biases for &lt;code&gt;kernel&lt;/code&gt; and &lt;code&gt;recurrent_kernel&lt;/code&gt;. To use this variant, set &lt;code&gt;'reset_after'=True&lt;/code&gt; and &lt;code&gt;recurrent_activation='sigmoid'&lt;/code&gt;.</source>
          <target state="translated">La segunda variante es compatible con CuDNNGRU (solo GPU) y permite la inferencia en la CPU. Por lo tanto, tiene sesgos separados para &lt;code&gt;kernel&lt;/code&gt; y &lt;code&gt;recurrent_kernel&lt;/code&gt; . Para usar esta variante, configure &lt;code&gt;'reset_after'=True&lt;/code&gt; y &lt;code&gt;recurrent_activation='sigmoid'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="44fd41a3b2fd550cb5e331da22b4349e8495f086" translate="yes" xml:space="preserve">
          <source>The second variant is compatible with CuDNNGRU (GPU-only) and allows inference on CPU. Thus it has separate biases for &lt;code&gt;kernel&lt;/code&gt; and &lt;code&gt;recurrent_kernel&lt;/code&gt;. Use &lt;code&gt;'reset_after'=True&lt;/code&gt; and &lt;code&gt;recurrent_activation='sigmoid'&lt;/code&gt;.</source>
          <target state="translated">La segunda variante es compatible con CuDNNGRU (solo GPU) y permite la inferencia en la CPU. Por lo tanto, tiene sesgos separados para &lt;code&gt;kernel&lt;/code&gt; y &lt;code&gt;recurrent_kernel&lt;/code&gt; . Utilice &lt;code&gt;'reset_after'=True&lt;/code&gt; y &lt;code&gt;recurrent_activation='sigmoid'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ef054429664e25cebbffadf1c7499db194568c6" translate="yes" xml:space="preserve">
          <source>The second way is through a callable function that does not accept any arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b1ff7b195e25bb1e934a1faddac3cb31e9dda14" translate="yes" xml:space="preserve">
          <source>The selected tensor.</source>
          <target state="translated">El tensor seleccionado.</target>
        </trans-unit>
        <trans-unit id="6d81fff9b6102438ec592417def3c2112c0846b7" translate="yes" xml:space="preserve">
          <source>The semantics of the input tensor depends on tensor_debug_mode. In typical usage, the input tensor comes directly from the user computation only when graph_debug_mode is FULL_TENSOR (see protobuf/debug_event.proto for a list of all the possible values of graph_debug_mode). For the other debug modes, the input tensor should be produced by an additional op or subgraph that computes summary information about one or more tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1450544c35748cfa003192a74e09ceb10f67e4f7" translate="yes" xml:space="preserve">
          <source>The separator string used between ngram elements. Must be a string constant, not a Tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c84f4757d0db527182bb06d2afdc87b1042d6fea" translate="yes" xml:space="preserve">
          <source>The sequence in which to look for prefix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14448741add9013596276b373f9b2b4fe8b71b2b" translate="yes" xml:space="preserve">
          <source>The sequence of &lt;code&gt;Tensor&lt;/code&gt; objects representing the data inputs of this op.</source>
          <target state="translated">La secuencia de objetos &lt;code&gt;Tensor&lt;/code&gt; que representan las entradas de datos de esta operaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ad56b1734b2aec94010201da62b3c74ae59652ee" translate="yes" xml:space="preserve">
          <source>The sequence that we are testing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c721fd10cd508d808b1312a2194dc7e4890a7fc" translate="yes" xml:space="preserve">
          <source>The serialized &lt;code&gt;GraphDef&lt;/code&gt; can be imported into another &lt;code&gt;Graph&lt;/code&gt; (using &lt;a href=&quot;graph_util/import_graph_def&quot;&gt;&lt;code&gt;tf.import_graph_def&lt;/code&gt;&lt;/a&gt;) or used with the &lt;a href=&quot;https://www.tensorflow.org/api_docs/api_docs/cc/index&quot;&gt;C++ Session API&lt;/a&gt;.</source>
          <target state="translated">El &lt;code&gt;GraphDef&lt;/code&gt; serializado se puede importar a otro &lt;code&gt;Graph&lt;/code&gt; (usando &lt;a href=&quot;graph_util/import_graph_def&quot;&gt; &lt;code&gt;tf.import_graph_def&lt;/code&gt; &lt;/a&gt; ) o usarse con la &lt;a href=&quot;https://www.tensorflow.org/api_docs/api_docs/cc/index&quot;&gt;API de sesi&amp;oacute;n de C ++&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="73859165e320015abdcf466de88e9720ebb22082" translate="yes" xml:space="preserve">
          <source>The serialized &lt;code&gt;GraphDef&lt;/code&gt; can be imported into another &lt;code&gt;Graph&lt;/code&gt; (using &lt;a href=&quot;graph_util/import_graph_def&quot;&gt;&lt;code&gt;tf.import_graph_def&lt;/code&gt;&lt;/a&gt;) or used with the &lt;a href=&quot;https://www.tensorflow.org/versions/r2.3/api_docs/api_docs/cc/index&quot;&gt;C++ Session API&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="766157bb0379c94a2b06eab4d5860dfc7335b141" translate="yes" xml:space="preserve">
          <source>The session to evaluate variables in. Ignored when executing eagerly. If not provided when graph building, the default session is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a72456f672e80ba24848fd6a912b31242ea6b05" translate="yes" xml:space="preserve">
          <source>The session to use to evaluate this variable. If none, the default session is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec73351af802bdf6746d29fb3d40b6d4c532bba4" translate="yes" xml:space="preserve">
          <source>The set of absent/default values may be specified using a vector of lengths or a padding value (but not both). If &lt;code&gt;lengths&lt;/code&gt; is specified, then the output tensor will satisfy &lt;code&gt;output[row] = tensor[row][:lengths[row]]&lt;/code&gt;. If 'lengths' is a list of lists or tuple of lists, those lists will be used as nested row lengths. If &lt;code&gt;padding&lt;/code&gt; is specified, then any row &lt;em&gt;suffix&lt;/em&gt; consisting entirely of &lt;code&gt;padding&lt;/code&gt; will be excluded from the returned &lt;code&gt;RaggedTensor&lt;/code&gt;. If neither &lt;code&gt;lengths&lt;/code&gt; nor &lt;code&gt;padding&lt;/code&gt; is specified, then the returned &lt;code&gt;RaggedTensor&lt;/code&gt; will have no absent/default values.</source>
          <target state="translated">El conjunto de valores ausentes / predeterminados se puede especificar mediante un vector de longitudes o un valor de relleno (pero no ambos). Si se especifica &lt;code&gt;lengths&lt;/code&gt; , entonces el tensor de salida satisfar&amp;aacute; la &lt;code&gt;output[row] = tensor[row][:lengths[row]]&lt;/code&gt; . Si 'longitudes' es una lista de listas o una tupla de listas, esas listas se utilizar&amp;aacute;n como longitudes de filas anidadas. Si se especifica &lt;code&gt;padding&lt;/code&gt; , cualquier &lt;em&gt;sufijo de&lt;/em&gt; fila &lt;em&gt;que&lt;/em&gt; consista completamente en &lt;code&gt;padding&lt;/code&gt; ser&amp;aacute; excluido del &lt;code&gt;RaggedTensor&lt;/code&gt; devuelto . Si no se especifican &lt;code&gt;lengths&lt;/code&gt; ni &lt;code&gt;padding&lt;/code&gt; , el &lt;code&gt;RaggedTensor&lt;/code&gt; devuelto no tendr&amp;aacute; valores ausentes / predeterminados.</target>
        </trans-unit>
        <trans-unit id="0c1258f12879c9bd1b917a210f7db35cdd522088" translate="yes" xml:space="preserve">
          <source>The set of ops to be run as part of the main op upon the load operation.</source>
          <target state="translated">El conjunto de operaciones que se llevarán a cabo como parte de la operación principal sobre la operación de carga.</target>
        </trans-unit>
        <trans-unit id="b8a942e9ca1e31cdbe28c47ba81e62ec5b4daae6" translate="yes" xml:space="preserve">
          <source>The set of variable names to convert (by default, all variables are converted).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="708ef0da29666e679f2d004edd19c8b18d49eb0b" translate="yes" xml:space="preserve">
          <source>The set of variable names to omit converting to constants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fc94cf8836a9ff2b4e0118d0144216371d4137e" translate="yes" xml:space="preserve">
          <source>The shape and dtype of any intermediate or output tensors in the computation of &lt;code&gt;fn&lt;/code&gt; should not depend on the input to &lt;code&gt;fn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="915b2e710b3b023da7cd3921f1c34459542c194c" translate="yes" xml:space="preserve">
          <source>The shape for individual flat values in the &lt;code&gt;RaggedTensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1218538acb5cc473fe08e57d6e893aaca21938d" translate="yes" xml:space="preserve">
          <source>The shape format of the &lt;code&gt;inputs&lt;/code&gt; Tensors. If True, these &lt;code&gt;Tensors&lt;/code&gt; must be shaped &lt;code&gt;[max_time, batch_size, num_classes]&lt;/code&gt;. If False, these &lt;code&gt;Tensors&lt;/code&gt; must be shaped &lt;code&gt;[batch_size, max_time, num_classes]&lt;/code&gt;. Using &lt;code&gt;time_major = True&lt;/code&gt; (default) is a bit more efficient because it avoids transposes at the beginning of the ctc_loss calculation. However, most TensorFlow data is batch-major, so by this function also accepts inputs in batch-major form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd03f61b772d8cecf2105a6fa68f431df30d2490" translate="yes" xml:space="preserve">
          <source>The shape format of the &lt;code&gt;inputs&lt;/code&gt; and &lt;code&gt;outputs&lt;/code&gt; Tensors. If true, these &lt;code&gt;Tensors&lt;/code&gt; must be shaped &lt;code&gt;[max_time, batch_size, depth]&lt;/code&gt;. If false, these &lt;code&gt;Tensors&lt;/code&gt; must be shaped &lt;code&gt;[batch_size, max_time, depth]&lt;/code&gt;. Using &lt;code&gt;time_major = True&lt;/code&gt; is a bit more efficient because it avoids transposes at the beginning and end of the RNN calculation. However, most TensorFlow data is batch-major, so by default this function accepts input and emits output in batch-major form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4fa5d6d5a2b3f7febe8c6a21da6334423de8f46" translate="yes" xml:space="preserve">
          <source>The shape format of the &lt;code&gt;inputs&lt;/code&gt; and &lt;code&gt;outputs&lt;/code&gt; tensors. If True, the inputs and outputs will be in shape &lt;code&gt;(timesteps, batch, ...)&lt;/code&gt;, whereas in the False case, it will be &lt;code&gt;(batch, timesteps, ...)&lt;/code&gt;. Using &lt;code&gt;time_major = True&lt;/code&gt; is a bit more efficient because it avoids transposes at the beginning and end of the RNN calculation. However, most TensorFlow data is batch-major, so by default this function accepts input and emits output in batch-major form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ca9d07b430e38f671c59fb716e05624f9098d82" translate="yes" xml:space="preserve">
          <source>The shape format of the &lt;code&gt;inputs&lt;/code&gt; and &lt;code&gt;outputs&lt;/code&gt; tensors. If True, the inputs and outputs will be in shape &lt;code&gt;[timesteps, batch, feature]&lt;/code&gt;, whereas in the False case, it will be &lt;code&gt;[batch, timesteps, feature]&lt;/code&gt;. Using &lt;code&gt;time_major = True&lt;/code&gt; is a bit more efficient because it avoids transposes at the beginning and end of the RNN calculation. However, most TensorFlow data is batch-major, so by default this function accepts input and emits output in batch-major form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9705c68d850f3729f14c8b0e86c4e7a7c9b8a9c5" translate="yes" xml:space="preserve">
          <source>The shape inference functions propagate shapes to the extent possible:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9cb3dea60cfc74ebbae7817c2108c229a9e9930" translate="yes" xml:space="preserve">
          <source>The shape invariants for the loop variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="081af2a7657fa36a381b1785e67936a8d191debb" translate="yes" xml:space="preserve">
          <source>The shape is computed using shape inference functions that are registered for each &lt;a href=&quot;operation&quot;&gt;&lt;code&gt;tf.Operation&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bc1bd93e711b8be01e066d838cfcf34409f0c38" translate="yes" xml:space="preserve">
          <source>The shape is computed using shape inference functions that are registered in the Op for each &lt;code&gt;Operation&lt;/code&gt;. See &lt;a href=&quot;tensorshape&quot;&gt;&lt;code&gt;tf.TensorShape&lt;/code&gt;&lt;/a&gt; for more details of what a shape represents.</source>
          <target state="translated">La forma se calcula utilizando funciones de inferencia de formas que se registran en el Op para cada &lt;code&gt;Operation&lt;/code&gt; . Consulte &lt;a href=&quot;tensorshape&quot;&gt; &lt;code&gt;tf.TensorShape&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s detalles sobre lo que representa una forma.</target>
        </trans-unit>
        <trans-unit id="5319f783b1231c02b92342d27602eef300f0a629" translate="yes" xml:space="preserve">
          <source>The shape of arguments to &lt;code&gt;__init__&lt;/code&gt;, &lt;code&gt;cdf&lt;/code&gt;, &lt;code&gt;log_cdf&lt;/code&gt;, &lt;code&gt;prob&lt;/code&gt;, and &lt;code&gt;log_prob&lt;/code&gt; reflect this broadcasting, as does the return value of &lt;code&gt;sample&lt;/code&gt; and &lt;code&gt;sample_n&lt;/code&gt;.</source>
          <target state="translated">La forma de los argumentos para &lt;code&gt;__init__&lt;/code&gt; , &lt;code&gt;cdf&lt;/code&gt; , &lt;code&gt;log_cdf&lt;/code&gt; , &lt;code&gt;prob&lt;/code&gt; y &lt;code&gt;log_prob&lt;/code&gt; reflejan esta transmisi&amp;oacute;n, al igual que el valor de retorno de &lt;code&gt;sample&lt;/code&gt; y &lt;code&gt;sample_n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9539ceccae379560bc28e4de427220124dc1b7f" translate="yes" xml:space="preserve">
          <source>The shape of each element in the &lt;code&gt;TensorArray&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="019adcd66453633d864b6a68c6e8a1ef2fb39d18" translate="yes" xml:space="preserve">
          <source>The shape of the &lt;code&gt;indices&lt;/code&gt; component, which indicates how many slices are in the &lt;code&gt;IndexedSlices&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a83199f6a8139b3838bc185a252e39d72f892d5" translate="yes" xml:space="preserve">
          <source>The shape of the RaggedTensor, or &lt;code&gt;None&lt;/code&gt; to allow any shape. If a shape is specified, then all ragged dimensions must have size &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aed84e9082260c1530ba06836ab583c0743099df" translate="yes" xml:space="preserve">
          <source>The shape of the elements of the given list, as a tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ae769cd7a979ed862a9572cd30406fef8fee2dc" translate="yes" xml:space="preserve">
          <source>The shape of the input data per sequence id. E.g. if &lt;code&gt;shape=(2,)&lt;/code&gt;, each example must contain &lt;code&gt;2 * sequence_length&lt;/code&gt; values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3720998b3d73539e8c9661d288914e2cdaa82ba7" translate="yes" xml:space="preserve">
          <source>The shape of the output tensor is:</source>
          <target state="translated">La forma del tensor de salida es:</target>
        </trans-unit>
        <trans-unit id="b54a3296d32e764f7303629c8f4e133de6a9a7b0" translate="yes" xml:space="preserve">
          <source>The shape of the output will be:</source>
          <target state="translated">La forma de la salida será:</target>
        </trans-unit>
        <trans-unit id="ac04b940314214f5e17141730326fbc95d00e6e3" translate="yes" xml:space="preserve">
          <source>The shape of the resulting dense tensor. In particular, &lt;code&gt;result.shape[i]&lt;/code&gt; is &lt;code&gt;shape[i]&lt;/code&gt; (if &lt;code&gt;shape[i]&lt;/code&gt; is not None), or &lt;code&gt;self.bounding_shape(i)&lt;/code&gt; (otherwise).&lt;code&gt;shape.rank&lt;/code&gt; must be &lt;code&gt;None&lt;/code&gt; or equal to &lt;code&gt;self.rank&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c9a810e455caa2b0b6f686bf9c200a962c54ef3" translate="yes" xml:space="preserve">
          <source>The shape of the state is algorithm-specific.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3389c6b2701837ccb66fc16af6826d909f63b514" translate="yes" xml:space="preserve">
          <source>The shape of the tensor to be fed (optional). If the shape is not specified, you can feed a sparse tensor of any shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="376d2cc370b5ba232fdf37d951603c116bb04786" translate="yes" xml:space="preserve">
          <source>The shape of the tensor to be fed (optional). If the shape is not specified, you can feed a tensor of any shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b04d4e03100c6f081b5e785ea772cca017db1933" translate="yes" xml:space="preserve">
          <source>The shapes of the two operands must match: broadcasting is not supported.</source>
          <target state="translated">Las formas de los dos operandos deben coincidir:no se admite la radiodifusión.</target>
        </trans-unit>
        <trans-unit id="348113de328d02812f9ca2ed7f6d52b929c19ce9" translate="yes" xml:space="preserve">
          <source>The simplest form of RNN network generated is:</source>
          <target state="translated">La forma más simple de red RNN generada es:</target>
        </trans-unit>
        <trans-unit id="ff2f171ddc511ae06abeb2ff57b6d8a5b4678a63" translate="yes" xml:space="preserve">
          <source>The simplest form of scatter is to insert individual elements in a tensor by index. For example, say we want to insert 4 scattered elements in a rank-1 tensor with 8 elements.</source>
          <target state="translated">La forma más simple de dispersión es insertar elementos individuales en un tensor por índice.Por ejemplo,digamos que queremos insertar 4 elementos dispersos en un tensor de rango 1 con 8 elementos.</target>
        </trans-unit>
        <trans-unit id="f366cdfba69e2fc90954206f2645c89f45fbcd17" translate="yes" xml:space="preserve">
          <source>The simplest form of tensor_scatter_add is to add individual elements to a tensor by index. For example, say we want to add 4 elements in a rank-1 tensor with 8 elements.</source>
          <target state="translated">La forma más simple de tensor_dispersión_agregado es añadir elementos individuales a un tensor por índice.Por ejemplo,digamos que queremos añadir 4 elementos en un tensor de rango 1 con 8 elementos.</target>
        </trans-unit>
        <trans-unit id="3af9f04f82cbb797b19d70da5fb65e10e6f6ef91" translate="yes" xml:space="preserve">
          <source>The simplest form of tensor_scatter_sub is to subtract individual elements from a tensor by index. For example, say we want to insert 4 scattered elements in a rank-1 tensor with 8 elements.</source>
          <target state="translated">La forma más simple de tensor_dispersión_sub es restar elementos individuales de un tensor por índice.Por ejemplo,digamos que queremos insertar 4 elementos dispersos en un tensor de rango 1 con 8 elementos.</target>
        </trans-unit>
        <trans-unit id="802d517fc471afa54d770d15cdbc678a89e0c7a9" translate="yes" xml:space="preserve">
          <source>The simplest version of &lt;code&gt;map_fn&lt;/code&gt; repeatedly applies the callable &lt;code&gt;fn&lt;/code&gt; to a sequence of elements from first to last. The elements are made of the tensors unpacked from &lt;code&gt;elems&lt;/code&gt;. &lt;code&gt;dtype&lt;/code&gt; is the data type of the return value of &lt;code&gt;fn&lt;/code&gt;. Users must provide &lt;code&gt;dtype&lt;/code&gt; if it is different from the data type of &lt;code&gt;elems&lt;/code&gt;.</source>
          <target state="translated">La versi&amp;oacute;n m&amp;aacute;s simple de &lt;code&gt;map_fn&lt;/code&gt; aplica repetidamente el &lt;code&gt;fn&lt;/code&gt; invocable a una secuencia de elementos del primero al &amp;uacute;ltimo. Los elementos est&amp;aacute;n hechos de tensores desempaquetados de &lt;code&gt;elems&lt;/code&gt; . &lt;code&gt;dtype&lt;/code&gt; es el tipo de datos del valor de retorno de &lt;code&gt;fn&lt;/code&gt; . Los usuarios deben proporcionar &lt;code&gt;dtype&lt;/code&gt; si es diferente del tipo de datos de &lt;code&gt;elems&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7f6d20e0852a13ae739990f6fedc34688b995c0" translate="yes" xml:space="preserve">
          <source>The simplest version of &lt;code&gt;scan&lt;/code&gt; repeatedly applies the callable &lt;code&gt;fn&lt;/code&gt; to a sequence of elements from first to last. The elements are made of the tensors unpacked from &lt;code&gt;elems&lt;/code&gt; on dimension 0. The callable fn takes two tensors as arguments. The first argument is the accumulated value computed from the preceding invocation of fn, and the second is the value at the current position of &lt;code&gt;elems&lt;/code&gt;. If &lt;code&gt;initializer&lt;/code&gt; is None, &lt;code&gt;elems&lt;/code&gt; must contain at least one element, and its first element is used as the initializer.</source>
          <target state="translated">La versi&amp;oacute;n m&amp;aacute;s simple de &lt;code&gt;scan&lt;/code&gt; aplica repetidamente el &lt;code&gt;fn&lt;/code&gt; invocable a una secuencia de elementos del primero al &amp;uacute;ltimo. Los elementos est&amp;aacute;n hechos de tensores desempaquetados de &lt;code&gt;elems&lt;/code&gt; en la dimensi&amp;oacute;n 0. El fn invocable toma dos tensores como argumentos. El primer argumento es el valor acumulado calculado a partir de la invocaci&amp;oacute;n anterior de fn, y el segundo es el valor en la posici&amp;oacute;n actual de &lt;code&gt;elems&lt;/code&gt; . Si el &lt;code&gt;initializer&lt;/code&gt; es Ninguno, &lt;code&gt;elems&lt;/code&gt; debe contener al menos un elemento y su primer elemento se utiliza como inicializador.</target>
        </trans-unit>
        <trans-unit id="7a38981091aad7a606ea4d4d2a567d64ac905976" translate="yes" xml:space="preserve">
          <source>The simplest way to create a dataset is to create it from a python &lt;code&gt;list&lt;/code&gt;:</source>
          <target state="translated">La forma m&amp;aacute;s sencilla de crear un conjunto de datos es crearlo a partir de una &lt;code&gt;list&lt;/code&gt; a de Python :</target>
        </trans-unit>
        <trans-unit id="8c730f2755df0951b225a0138c6c5b2d885cf90a" translate="yes" xml:space="preserve">
          <source>The size of &lt;code&gt;tensor_names&lt;/code&gt; must match the number of tensors in &lt;code&gt;data&lt;/code&gt;. &lt;code&gt;data[i]&lt;/code&gt; is written to &lt;code&gt;filename&lt;/code&gt; with name &lt;code&gt;tensor_names[i]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab51731901ff080d9eff54a48d6859d0f1323c1a" translate="yes" xml:space="preserve">
          <source>The size of the resulting dataset will match the size of the smallest input dataset, and no error will be raised if input datasets have different sizes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="017e6c560666c8b8adcda856df4242248fd294ae" translate="yes" xml:space="preserve">
          <source>The sizes of the pooling regions are generated randomly but are fairly uniform. For example, let's look at the height dimension, and the constraints on the list of rows that will be pool boundaries.</source>
          <target state="translated">Los tamaños de las regiones de agrupación se generan al azar pero son bastante uniformes.Por ejemplo,veamos la dimensión de la altura,y las limitaciones de la lista de filas que serán los límites de la piscina.</target>
        </trans-unit>
        <trans-unit id="3c43eb48e9249082c6dab3dc37ecd5648014a1b5" translate="yes" xml:space="preserve">
          <source>The snapshot API allows users to transparently persist the output of their preprocessing pipeline to disk, and materialize the pre-processed data on a different training run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50a231b5d401442573df3e17bbb0c7335e8e5d44" translate="yes" xml:space="preserve">
          <source>The softmax of each vector x is calculated by &lt;code&gt;exp(x)/tf.reduce_sum(exp(x))&lt;/code&gt;. The input values in are the log-odds of the resulting probability.</source>
          <target state="translated">El softmax de cada vector x se calcula mediante &lt;code&gt;exp(x)/tf.reduce_sum(exp(x))&lt;/code&gt; . Los valores de entrada en son las probabilidades logar&amp;iacute;tmicas de la probabilidad resultante.</target>
        </trans-unit>
        <trans-unit id="887fc2159220b03235a84826c28912f3876b1988" translate="yes" xml:space="preserve">
          <source>The softmax of each vector x is computed as &lt;code&gt;exp(x) / tf.reduce_sum(exp(x))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6d8793457c083f0d11acb319bb58de8dcf61657" translate="yes" xml:space="preserve">
          <source>The softplus activation: &lt;code&gt;log(exp(x) + 1)&lt;/code&gt;.</source>
          <target state="translated">La activaci&amp;oacute;n de softplus: &lt;code&gt;log(exp(x) + 1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a35f61726860bd793a42b2269f7f12bfff5f5061" translate="yes" xml:space="preserve">
          <source>The softplus activation: &lt;code&gt;x / (abs(x) + 1)&lt;/code&gt;.</source>
          <target state="translated">La activaci&amp;oacute;n de softplus: &lt;code&gt;x / (abs(x) + 1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6cdf43d3dd10a8cc3aa784daa0a9e1312644b77d" translate="yes" xml:space="preserve">
          <source>The softsign activation: &lt;code&gt;x / (abs(x) + 1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6542d7e39f0c310801daa6538837ad6138ffae82" translate="yes" xml:space="preserve">
          <source>The solution is to ensure any access to the underlying resource &lt;code&gt;v&lt;/code&gt; is only processed through a critical section:</source>
          <target state="translated">La soluci&amp;oacute;n es garantizar que cualquier acceso al recurso subyacente &lt;code&gt;v&lt;/code&gt; solo se procese a trav&amp;eacute;s de una secci&amp;oacute;n cr&amp;iacute;tica:</target>
        </trans-unit>
        <trans-unit id="48c0d2fec393318121a3ea291f2dd8dccd7b38fa" translate="yes" xml:space="preserve">
          <source>The solution is to identify which gradient call this particular TensorArray gradient is being called in. This is performed by identifying a unique string (e.g. &quot;gradients&quot;, &quot;gradients_1&quot;, ...) from the input gradient Tensor's name. This string is used as a suffix when creating the TensorArray gradient object here (the attribute &lt;code&gt;source&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a9c87c3bbd16608d71f6244bf102c899fcfe323" translate="yes" xml:space="preserve">
          <source>The solution is to wrap the model construction and execution in a keras-style scope:</source>
          <target state="translated">La solución es envolver la construcción y ejecución del modelo en un ámbito estilo keras:</target>
        </trans-unit>
        <trans-unit id="e590f462584ca8d9fda3b6ea3ab70cb8db99fef3" translate="yes" xml:space="preserve">
          <source>The source of the non-determinism will be platform- and time-dependent.</source>
          <target state="translated">La fuente del no-determinismo será dependiente de la plataforma y del tiempo.</target>
        </trans-unit>
        <trans-unit id="7b94d68698f376ae68caf545ac2ad9ff65451535" translate="yes" xml:space="preserve">
          <source>The sparse implementation of this algorithm (used when the gradient is an IndexedSlices object, typically because of &lt;a href=&quot;../../../gather&quot;&gt;&lt;code&gt;tf.gather&lt;/code&gt;&lt;/a&gt; or an embedding lookup in the forward pass) does apply momentum to variable slices even if they were not used in the forward pass (meaning they have a gradient equal to zero). Momentum decay (beta1) is also applied to the entire momentum accumulator. This means that the sparse behavior is equivalent to the dense behavior (in contrast to some momentum implementations which ignore momentum unless a variable slice was actually used).</source>
          <target state="translated">La implementaci&amp;oacute;n escasa de este algoritmo (usado cuando el gradiente es un objeto IndexedSlices, generalmente debido a &lt;a href=&quot;../../../gather&quot;&gt; &lt;code&gt;tf.gather&lt;/code&gt; &lt;/a&gt; o una b&amp;uacute;squeda incrustada en el pase hacia adelante) aplica impulso a los cortes variables incluso si no se usaron en el pase hacia adelante (lo que significa que tienen un gradiente igual a cero). La ca&amp;iacute;da del momento (beta1) tambi&amp;eacute;n se aplica a todo el acumulador de momento. Esto significa que el comportamiento escaso es equivalente al comportamiento denso (en contraste con algunas implementaciones de impulso que ignoran el impulso a menos que se haya utilizado realmente un corte variable).</target>
        </trans-unit>
        <trans-unit id="2c28505e1992f5a2d21a399d52aaf1d49a6228f7" translate="yes" xml:space="preserve">
          <source>The sparse implementation of this algorithm (used when the gradient is an IndexedSlices object, typically because of &lt;a href=&quot;../../gather&quot;&gt;&lt;code&gt;tf.gather&lt;/code&gt;&lt;/a&gt; or an embedding lookup in the forward pass) does apply momentum to variable slices even if they were not used in the forward pass (meaning they have a gradient equal to zero). Momentum decay (beta1) is also applied to the entire momentum accumulator. This means that the sparse behavior is equivalent to the dense behavior (in contrast to some momentum implementations which ignore momentum unless a variable slice was actually used).</source>
          <target state="translated">La implementaci&amp;oacute;n escasa de este algoritmo (usado cuando el gradiente es un objeto IndexedSlices, generalmente debido a &lt;a href=&quot;../../gather&quot;&gt; &lt;code&gt;tf.gather&lt;/code&gt; &lt;/a&gt; o una b&amp;uacute;squeda incrustada en el pase hacia adelante) aplica impulso a los cortes variables incluso si no se usaron en el pase hacia adelante (lo que significa que tienen un gradiente igual a cero). La ca&amp;iacute;da del momento (beta1) tambi&amp;eacute;n se aplica a todo el acumulador de momento. Esto significa que el comportamiento escaso es equivalente al comportamiento denso (en contraste con algunas implementaciones de impulso que ignoran el impulso a menos que se haya utilizado realmente un corte variable).</target>
        </trans-unit>
        <trans-unit id="e5bdcabcaa194b28393438e39e1590c0f77ff2c8" translate="yes" xml:space="preserve">
          <source>The sparse matrix product may have numeric (non-structural) zeros.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dedfba1684c4375e13d104a45eb8d51735e2b834" translate="yes" xml:space="preserve">
          <source>The sparse tensor to convert. Must have rank 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b54e597f7fe46cc2667d4b65cc738c9c9db301ba" translate="yes" xml:space="preserve">
          <source>The specified output type of the operation (&lt;code&gt;int32&lt;/code&gt; or &lt;code&gt;int64&lt;/code&gt;). Defaults to &lt;a href=&quot;../tf#int32&quot;&gt;&lt;code&gt;tf.int32&lt;/code&gt;&lt;/a&gt;(optional).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b88004b19728b58b00753256fbdb980b735e8d2" translate="yes" xml:space="preserve">
          <source>The split indices for the ragged tensor value.</source>
          <target state="translated">Los índices de división para el valor tensorial desigual.</target>
        </trans-unit>
        <trans-unit id="f49d81f2a44d35cf534ae7fd8c45debcfaf469ae" translate="yes" xml:space="preserve">
          <source>The split information is the best threshold (bucket id), gains and left/right node contributions per node for each feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25fdcf5ad4499cdb6d4201c3ecb0186f730f52b9" translate="yes" xml:space="preserve">
          <source>The standard &lt;code&gt;segment_*&lt;/code&gt; functions assert that the segment indices are sorted. If you have unsorted indices use the equivalent &lt;code&gt;unsorted_segment_&lt;/code&gt; function. These functions take an additional argument &lt;code&gt;num_segments&lt;/code&gt; so that the output tensor can be efficiently allocated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b29667fc1f908940634484906fb6441d097a55ad" translate="yes" xml:space="preserve">
          <source>The standard &lt;code&gt;segment_*&lt;/code&gt; functions assert that the segment indices are sorted. If you have unsorted indices use the equivalent &lt;code&gt;unsorted_segment_&lt;/code&gt; function. Thses functions take an additional argument &lt;code&gt;num_segments&lt;/code&gt; so that the output tensor can be efficiently allocated.</source>
          <target state="translated">Las funciones est&amp;aacute;ndar &lt;code&gt;segment_*&lt;/code&gt; afirman que los &amp;iacute;ndices de segmento est&amp;aacute;n ordenados. Si tiene &amp;iacute;ndices sin clasificar, use la funci&amp;oacute;n equivalente &lt;code&gt;unsorted_segment_&lt;/code&gt; . Estas funciones toman un argumento adicional &lt;code&gt;num_segments&lt;/code&gt; para que el tensor de salida se pueda asignar de manera eficiente.</target>
        </trans-unit>
        <trans-unit id="6cf74e13a5dc987612c9d705626f37de29ad545f" translate="yes" xml:space="preserve">
          <source>The standard library uses various well-known names to collect and retrieve values associated with a graph. For example, the &lt;code&gt;tf.Optimizer&lt;/code&gt; subclasses default to optimizing the variables collected under &lt;code&gt;tf.GraphKeys.TRAINABLE_VARIABLES&lt;/code&gt; if none is specified, but it is also possible to pass an explicit list of variables.</source>
          <target state="translated">La biblioteca est&amp;aacute;ndar utiliza varios nombres conocidos para recopilar y recuperar valores asociados con un gr&amp;aacute;fico. Por ejemplo, las subclases de &lt;code&gt;tf.Optimizer&lt;/code&gt; optimizan de forma predeterminada las variables recopiladas en &lt;code&gt;tf.GraphKeys.TRAINABLE_VARIABLES&lt;/code&gt; si no se especifica ninguna, pero tambi&amp;eacute;n es posible pasar una lista expl&amp;iacute;cita de variables.</target>
        </trans-unit>
        <trans-unit id="ce8c36f190ecab29f1604c69bb1fdd2396d6f9bd" translate="yes" xml:space="preserve">
          <source>The standard pattern for updating variables is to:</source>
          <target state="translated">El patrón estándar para la actualización de las variables es</target>
        </trans-unit>
        <trans-unit id="1df550e9ac2ff1efc86381fe4007d40151e6c36c" translate="yes" xml:space="preserve">
          <source>The started thread is added to the list of threads managed by the supervisor so it does not need to be passed to the &lt;code&gt;stop()&lt;/code&gt; method.</source>
          <target state="translated">El hilo iniciado se agrega a la lista de hilos administrados por el supervisor, por lo que no es necesario pasarlo al m&amp;eacute;todo &lt;code&gt;stop()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22b0c0a61720b2b49f3bdb46b68ab2ffe3bd7116" translate="yes" xml:space="preserve">
          <source>The started thread.</source>
          <target state="translated">El hilo de arranque.</target>
        </trans-unit>
        <trans-unit id="04fb16ca663bd50a2194064568a76d4c96b84f17" translate="yes" xml:space="preserve">
          <source>The starting value for accumulators. Only zero or positive values are allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c25d85454a9ea543e59596d91af95b242b42d7a4" translate="yes" xml:space="preserve">
          <source>The state of the RNG after &lt;code&gt;rng_skip(n)&lt;/code&gt; will be the same as that after &lt;code&gt;stateful_uniform([n])&lt;/code&gt; (or any other distribution). The actual increment added to the counter is an unspecified implementation detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd546c154f1294509a35cef6daf7e05272419f55" translate="yes" xml:space="preserve">
          <source>The state of the optimizer, allowing to resume training exactly where you left off.</source>
          <target state="translated">El estado del optimizador,permite reanudar el entrenamiento exactamente donde lo dejaste.</target>
        </trans-unit>
        <trans-unit id="712f8a6f55bf7c5b4fd684dab030efe40f46ccee" translate="yes" xml:space="preserve">
          <source>The statically known shape of this ragged tensor.</source>
          <target state="translated">La forma estáticamente conocida de este tensor andrajoso.</target>
        </trans-unit>
        <trans-unit id="05eef5966a4733b45681c7bb2c1cfa7fcd7e3ded" translate="yes" xml:space="preserve">
          <source>The statistics options associated with the dataset. See &lt;a href=&quot;experimental/statsoptions&quot;&gt;&lt;code&gt;tf.data.experimental.StatsOptions&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">Las opciones de estad&amp;iacute;sticas asociadas con el conjunto de datos. Consulte &lt;a href=&quot;experimental/statsoptions&quot;&gt; &lt;code&gt;tf.data.experimental.StatsOptions&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="a8c6e46a80c3223660eded889659ea2c4138b476" translate="yes" xml:space="preserve">
          <source>The step set by &lt;a href=&quot;set_step&quot;&gt;&lt;code&gt;tf.summary.experimental.set_step()&lt;/code&gt;&lt;/a&gt; if one has been set, otherwise None.</source>
          <target state="translated">El paso establecido por &lt;a href=&quot;set_step&quot;&gt; &lt;code&gt;tf.summary.experimental.set_step()&lt;/code&gt; &lt;/a&gt; si se ha establecido uno, de lo contrario Ninguno.</target>
        </trans-unit>
        <trans-unit id="5dff7b910b7ad17251b2c5a9c0f91aaacc64e975" translate="yes" xml:space="preserve">
          <source>The str() operator of a 'FlagValues' object provides help for all of the registered 'Flag' objects.</source>
          <target state="translated">El operador str()de un objeto 'FlagValues' proporciona ayuda para todos los objetos 'Flag' registrados.</target>
        </trans-unit>
        <trans-unit id="13be6068510e1bba9bcaba7458adf0809e711454" translate="yes" xml:space="preserve">
          <source>The strategy may choose to put the variable on multiple devices, like mirrored variables, but unlike mirrored variables we don't synchronize the updates to them to make sure they have the same value. Instead, the synchronization is performed when reading in cross-replica context. In a replica context, reads and writes are performed on the local copy (we allow reads so you can write code like &lt;code&gt;v = 0.9*v + 0.1*update&lt;/code&gt;). We don't allow operations like &lt;code&gt;v.assign_add&lt;/code&gt; in a cross-replica context for sync on read variables; right now we don't have a use case for such updates and depending on the aggregation mode such updates may not be sensible.</source>
          <target state="translated">La estrategia puede optar por colocar la variable en varios dispositivos, como las variables reflejadas, pero a diferencia de las variables reflejadas, no sincronizamos las actualizaciones para asegurarnos de que tengan el mismo valor. En cambio, la sincronizaci&amp;oacute;n se realiza cuando se lee en un contexto de r&amp;eacute;plica cruzada. En un contexto de r&amp;eacute;plica, las lecturas y escrituras se realizan en la copia local (permitimos lecturas para que pueda escribir c&amp;oacute;digo como &lt;code&gt;v = 0.9*v + 0.1*update&lt;/code&gt; ). No permitimos operaciones como &lt;code&gt;v.assign_add&lt;/code&gt; en un contexto de r&amp;eacute;plicas cruzadas para sincronizar las variables de lectura; en este momento no tenemos un caso de uso para tales actualizaciones y, dependiendo del modo de agregaci&amp;oacute;n, tales actualizaciones pueden no ser sensatas.</target>
        </trans-unit>
        <trans-unit id="d3fd5c3cf46ac06d0260b1f659bcc1a0b81cadee" translate="yes" xml:space="preserve">
          <source>The stream whose writes should be captured. This stream must have a file descriptor, support writing via using that file descriptor, and must have a &lt;code&gt;.flush()&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="644f3a81fca55d1677b34a373591148f236e0ab3" translate="yes" xml:space="preserve">
          <source>The string &quot;tensorflow&quot;.</source>
          <target state="translated">La cadena &quot;flujo tensorial&quot;.</target>
        </trans-unit>
        <trans-unit id="cc503fc832fae0582037d46d99a283b2143a5687" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;-&lt;/code&gt; meaning that the slice covers all indices of this dimension</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8540ba2c73157ed83e7a8b8d1ba5f66009b9e41f" translate="yes" xml:space="preserve">
          <source>The string name of a job in this cluster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56132600b50269345758de3a44957eaf5ba36a10" translate="yes" xml:space="preserve">
          <source>The string name of the device to which this op has been assigned, or an empty string if it has not been assigned to a device.</source>
          <target state="translated">El nombre de la cadena del dispositivo al que se ha asignado esta operación,o una cadena vacía si no se ha asignado a un dispositivo.</target>
        </trans-unit>
        <trans-unit id="8992e1dfe2880c9a4de6beb1ac8e0230422a7a79" translate="yes" xml:space="preserve">
          <source>The string name of the underlying Queue.</source>
          <target state="translated">El nombre de la cadena de la cola subyacente.</target>
        </trans-unit>
        <trans-unit id="a96aa4c9d9595a33bb0f9789d55b573d138edebb" translate="yes" xml:space="preserve">
          <source>The string name of this tensor.</source>
          <target state="translated">El nombre de la cadena de este tensor.</target>
        </trans-unit>
        <trans-unit id="c67de356b037fd5e8be6d855afae37205aa00794" translate="yes" xml:space="preserve">
          <source>The string path to the exported directory or &lt;code&gt;None&lt;/code&gt; if export is skipped.</source>
          <target state="translated">La ruta de la cadena al directorio exportado o &lt;code&gt;None&lt;/code&gt; si se omite la exportaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e5efe1c4c830550f08c9bea1e979d7c9a7668a12" translate="yes" xml:space="preserve">
          <source>The string path to the exported directory.</source>
          <target state="translated">La ruta de la cadena del directorio exportado.</target>
        </trans-unit>
        <trans-unit id="e6d17d88d9f96bec8835a8d4d00d7ee284382edf" translate="yes" xml:space="preserve">
          <source>The string representation of a persistent tensor handle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8d628e9b8c8f44ad4c03facb818cd42847e7780" translate="yes" xml:space="preserve">
          <source>The string to use to separate the inputs. Defaults to &quot; &quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4d0576ccdc2458c02c95d244e31139154833425" translate="yes" xml:space="preserve">
          <source>The string type of an operation. This corresponds to the &lt;code&gt;OpDef.name&lt;/code&gt; field for the proto that defines the operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a17bd3da8a69a3dada0980459ac9d927bbc1c342" translate="yes" xml:space="preserve">
          <source>The string we try to match with the items in regexes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb20559dca432fe77c06ffe1211357d7726b77ab" translate="yes" xml:space="preserve">
          <source>The structure of the components of this optional.</source>
          <target state="translated">La estructura de los componentes de este opcional.</target>
        </trans-unit>
        <trans-unit id="636182e5686aa0b143279a1925716c9803dd42dc" translate="yes" xml:space="preserve">
          <source>The stubbing is using the builtin getattr and setattr. So, the &lt;strong&gt;get&lt;/strong&gt; and &lt;strong&gt;set&lt;/strong&gt; will be called when stubbing ( probably be to manipulate obj.&lt;strong&gt;dict&lt;/strong&gt; instead of getattr() and setattr()).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10e607f82b834bedf8082612b2f31785cf1834ed" translate="yes" xml:space="preserve">
          <source>The stubbing is using the builtin getattr and setattr. So, the &lt;strong&gt;get&lt;/strong&gt; and &lt;strong&gt;set&lt;/strong&gt; will be called when stubbing (TODO: A better idea would probably be to manipulate obj.&lt;strong&gt;dict&lt;/strong&gt; instead of getattr() and setattr()).</source>
          <target state="translated">El stubbing est&amp;aacute; usando getattr y setattr incorporados. Por lo tanto, el &lt;strong&gt;get&lt;/strong&gt; y &lt;strong&gt;set&lt;/strong&gt; ser&amp;aacute;n llamados de la brasa (TODO:. Una mejor idea ser&amp;iacute;a probablemente para manipular obj &lt;strong&gt;dict&lt;/strong&gt; en lugar de getattr () y setattr ()).</target>
        </trans-unit>
        <trans-unit id="e3a83e1ccdb64a4c6aff88c02b12dcc686b2bf3b" translate="yes" xml:space="preserve">
          <source>The suffix for the variable that keeps the gradient squared accumulator. If not present, defaults to name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="628f884b08eaa26944d28d228cad39f4b6e377f6" translate="yes" xml:space="preserve">
          <source>The suffix for the variable that keeps the linear gradient accumulator. If not present, defaults to name + &quot;&lt;em&gt;1&quot;. &lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b87677b2e7091b18f84e0a5a53ce47bf2fbc17a" translate="yes" xml:space="preserve">
          <source>The sum of the squared distance from each point in the first batch of inputs to its nearest cluster center.</source>
          <target state="translated">La suma de la distancia al cuadrado de cada punto del primer lote de entradas a su centro de cúmulo más cercano.</target>
        </trans-unit>
        <trans-unit id="b87e105d01203888c35de69e0d8cabac2d7238b3" translate="yes" xml:space="preserve">
          <source>The summary has up to &lt;code&gt;max_images&lt;/code&gt; summary values containing images. The images are built from &lt;code&gt;tensor&lt;/code&gt; which must be 4-D with shape &lt;code&gt;[batch_size, height, width, channels]&lt;/code&gt; and where &lt;code&gt;channels&lt;/code&gt; can be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3f45fd11021d0fbbacbdd0bd0b9e463916250a5" translate="yes" xml:space="preserve">
          <source>The summary has up to &lt;code&gt;max_outputs&lt;/code&gt; summary values containing audio. The audio is built from &lt;code&gt;tensor&lt;/code&gt; which must be 3-D with shape &lt;code&gt;[batch_size, frames, channels]&lt;/code&gt; or 2-D with shape &lt;code&gt;[batch_size, frames]&lt;/code&gt;. The values are assumed to be in the range of &lt;code&gt;[-1.0, 1.0]&lt;/code&gt; with a sample rate of &lt;code&gt;sample_rate&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c8749a05b6c387d61ef6d60497d42b829e20f04" translate="yes" xml:space="preserve">
          <source>The summary has up to &lt;code&gt;max_outputs&lt;/code&gt; summary values containing images. The images are built from &lt;code&gt;tensor&lt;/code&gt; which must be 4-D with shape &lt;code&gt;[batch_size, height, width, channels]&lt;/code&gt; and where &lt;code&gt;channels&lt;/code&gt; can be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45ad74c802e798c2d2739d6fd3d4c8a9a95f1067" translate="yes" xml:space="preserve">
          <source>The summary stats contains gradients and hessians accumulated for each node, bucket and dimension id.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b4c4f21208a76ec80b0674286557919ec4d96bb" translate="yes" xml:space="preserve">
          <source>The summary stats contains gradients and hessians accumulated for each node, feature dimension id and bucket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdad9771b45b958101ba790c70a250dceed1de82" translate="yes" xml:space="preserve">
          <source>The summary stats contains gradients and hessians accumulated into the corresponding node and bucket for each example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa003ab56e1eb5342f9795fdbfba586bfe2f1900" translate="yes" xml:space="preserve">
          <source>The supervisor is notified of any exception raised by one of the services. After an exception is raised, &lt;code&gt;should_stop()&lt;/code&gt; returns &lt;code&gt;True&lt;/code&gt;. In that case the training loop should also stop. This is why the training loop has to check for &lt;code&gt;sv.should_stop()&lt;/code&gt;.</source>
          <target state="translated">Se notifica al supervisor de cualquier excepci&amp;oacute;n planteada por uno de los servicios. Despu&amp;eacute;s de que se &lt;code&gt;should_stop()&lt;/code&gt; una excepci&amp;oacute;n, should_stop () devuelve &lt;code&gt;True&lt;/code&gt; . En ese caso, el ciclo de entrenamiento tambi&amp;eacute;n deber&amp;iacute;a detenerse. Es por eso que el ciclo de entrenamiento debe buscar &lt;code&gt;sv.should_stop()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50528fab5ce38e9d3b4fc6e5612ddf34e494bebf" translate="yes" xml:space="preserve">
          <source>The swish activation applied to &lt;code&gt;x&lt;/code&gt; (see reference paper for details).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c298d20320b239b254c85a68c7638e9b3d6999d9" translate="yes" xml:space="preserve">
          <source>The table initializer to use. See &lt;code&gt;HashTable&lt;/code&gt; kernel for supported key and value types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b372ddff28f44f63c6e232f1c30d44e36e67c586" translate="yes" xml:space="preserve">
          <source>The table key dtype.</source>
          <target state="translated">El tipo de llave de mesa.</target>
        </trans-unit>
        <trans-unit id="92555821a111ce6704d66c3accb512005dcb54c2" translate="yes" xml:space="preserve">
          <source>The table to be initialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="284ce4f13ba5d1db3bbec94a52d693d3d2283853" translate="yes" xml:space="preserve">
          <source>The table to initialize.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45ea7c0740084e6be8859e3f6c6a5a25999322a4" translate="yes" xml:space="preserve">
          <source>The table value dtype.</source>
          <target state="translated">El tipo de valor de la tabla.</target>
        </trans-unit>
        <trans-unit id="8e9701fdc91c90f3e0a50b0354216b715e7e2b61" translate="yes" xml:space="preserve">
          <source>The tag name for this metadata.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e6370789b18c4cef6f8f91690bde182484827c1" translate="yes" xml:space="preserve">
          <source>The target value of comparison.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6bc45ea60aa5301cecc35d1fbbe5b21036c5bda" translate="yes" xml:space="preserve">
          <source>The task index for this particular VM, within the GCE instance group. In particular, every single instance should be assigned a unique ordinal index within an instance group manually so that they can be distinguished from each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39fc3d1afa951ce1fc0c6acdffe30bf9d05aaa6f" translate="yes" xml:space="preserve">
          <source>The task of an Enqueuer is to use parallelism to speed up preprocessing. This is done with processes or threads.</source>
          <target state="translated">La tarea de un Enqueuer es usar el paralelismo para acelerar el preprocesamiento.Esto se hace con procesos o hilos.</target>
        </trans-unit>
        <trans-unit id="8d203e324545cf312d1311ac6ed39dbe8533902e" translate="yes" xml:space="preserve">
          <source>The temporary directory.</source>
          <target state="translated">El directorio temporal.</target>
        </trans-unit>
        <trans-unit id="89760396be504814d1d16fffe685b4c4ed9d185b" translate="yes" xml:space="preserve">
          <source>The tensor &lt;code&gt;keys&lt;/code&gt; must be of the same type as the keys of the table. The tensor &lt;code&gt;values&lt;/code&gt; must be of the type of the table values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba629a56d84ff4136c8aeadbf5a5b5c5e14b4183" translate="yes" xml:space="preserve">
          <source>The tensor &lt;code&gt;keys&lt;/code&gt; must of the same type as the keys of the table. Keys not already in the table are silently ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="784e799f8d450863febee3c764bd275192b18bd8" translate="yes" xml:space="preserve">
          <source>The tensor &lt;code&gt;keys&lt;/code&gt; must of the same type as the keys of the table. The output &lt;code&gt;values&lt;/code&gt; is of the type of the table values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba8d97a1a9f6a392dad767f9f5f935fc3b942c5f" translate="yes" xml:space="preserve">
          <source>The tensor at index &lt;code&gt;index&lt;/code&gt;.</source>
          <target state="translated">El tensor en el &amp;iacute;ndice &lt;code&gt;index&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2316496cec696b46dadd19db7c5fa7648eaa2e07" translate="yes" xml:space="preserve">
          <source>The tensor for the keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0acc2ca709af133edb5533c7cf72d36eab353cfc" translate="yes" xml:space="preserve">
          <source>The tensor for the values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b8bac0316b66126d9a5f3d03ead635dc9c4e503" translate="yes" xml:space="preserve">
          <source>The tensor is shuffled along dimension 0, such that each &lt;code&gt;value[j]&lt;/code&gt; is mapped to one and only one &lt;code&gt;output[i]&lt;/code&gt;. For example, a mapping that might occur for a 3x2 tensor is:</source>
          <target state="translated">El tensor se baraja a lo largo de la dimensi&amp;oacute;n 0, de modo que cada &lt;code&gt;value[j]&lt;/code&gt; se asigna a una y s&amp;oacute;lo una &lt;code&gt;output[i]&lt;/code&gt; . Por ejemplo, un mapeo que podr&amp;iacute;a ocurrir para un tensor 3x2 es:</target>
        </trans-unit>
        <trans-unit id="b2ebac51ffaed872fc6c58ab59a37320ff00d8b4" translate="yes" xml:space="preserve">
          <source>The tensor over which to pool. Must have rank 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67d66a49c4d56f6740c34ad1abd2330c2a53d237" translate="yes" xml:space="preserve">
          <source>The tensor over which to pool. Must have rank 4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d6751ac1718f3abff2c47f31b4ce194ddbe60a5" translate="yes" xml:space="preserve">
          <source>The tensor over which to pool. Must have rank 5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ba96488585c7e70161cf56eacc0bc675e7c2bf5" translate="yes" xml:space="preserve">
          <source>The tensor returned by this operation is immutable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="374a08aed4e22028f8c4f1a7a5332f381742c546" translate="yes" xml:space="preserve">
          <source>The tensor to reduce. Should be of numeric type, &lt;code&gt;bool&lt;/code&gt;, or &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af6cdbb07f5f2007c7664b9fc800d495933f2079" translate="yes" xml:space="preserve">
          <source>The tensor to reduce. Should have numeric type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f76ee355f90903f0cc3c888c4e5cbb97172bd55d" translate="yes" xml:space="preserve">
          <source>The tensor to reduce. Should have real numeric type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8f9620fdd17bd0ae7e2e11319433d1d510e064f" translate="yes" xml:space="preserve">
          <source>The tensor to reduce. Should have real or complex type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60a48c532dffc217f038e38531b427ddb3f91bda" translate="yes" xml:space="preserve">
          <source>The tensor to start from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc7b892140fc1cca57f3b6847beb68b7faa703c7" translate="yes" xml:space="preserve">
          <source>The tensor type for the result: one of &lt;code&gt;&quot;RaggedTensor&quot;&lt;/code&gt; or &lt;code&gt;&quot;SparseTensor&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1c73ec4612fec81093c6dca3603df5977d11e17" translate="yes" xml:space="preserve">
          <source>The tensor_shape to resize the input to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79aa982763ef4786022042e868a3556033a0c5ec" translate="yes" xml:space="preserve">
          <source>The tensors at corresponding positions in the three input lists (sample_indices, embedding_indices and aggregation_weights) must have the same shape, i.e. rank 1 with dim_size() equal to the total number of lookups into the table described by the corresponding feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f41fba569c688c2ad85251ea878f2cfba46898a" translate="yes" xml:space="preserve">
          <source>The tensors at corresponding positions in the three input lists must have the same shape, i.e. rank 1 with dim_size() equal to the total number of lookups into the table described by the corresponding table_id.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5925b962b25493edc9ea9353afe8ff0989d3ebc" translate="yes" xml:space="preserve">
          <source>The tensors at corresponding positions in two of the input lists, embedding_indices and aggregation_weights, must have the same shape, i.e. rank 1 with dim_size() equal to the total number of lookups into the table described by the corresponding feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="263280cf1684ff5fb9dc90aff492167c49c357e8" translate="yes" xml:space="preserve">
          <source>The tensors in the &lt;code&gt;TensorArray&lt;/code&gt; selected by &lt;code&gt;indices&lt;/code&gt;, packed into one tensor.</source>
          <target state="translated">Los tensores en &lt;code&gt;TensorArray&lt;/code&gt; seleccionados por &lt;code&gt;indices&lt;/code&gt; , empaquetados en un tensor.</target>
        </trans-unit>
        <trans-unit id="14d5f93ad26c02d132da873b0983deda8cc5ede0" translate="yes" xml:space="preserve">
          <source>The tensors returned by the callable identified by &lt;code&gt;branch_index&lt;/code&gt;, or those returned by &lt;code&gt;default&lt;/code&gt; if no key matches and &lt;code&gt;default&lt;/code&gt; was provided, or those returned by the max-keyed &lt;code&gt;branch_fn&lt;/code&gt; if no &lt;code&gt;default&lt;/code&gt; is provided.</source>
          <target state="translated">Los tensores devueltos por el invocable identificados por &lt;code&gt;branch_index&lt;/code&gt; , o los devueltos por &lt;code&gt;default&lt;/code&gt; si no se proporciona ninguna clave y se proporcion&amp;oacute; el &lt;code&gt;default&lt;/code&gt; , o los devueltos por el &lt;code&gt;branch_fn&lt;/code&gt; con clave m&amp;aacute;xima si no se proporciona ning&amp;uacute;n &lt;code&gt;default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ea9d9d23c406f164fd2c56245bf91a63b2aa423" translate="yes" xml:space="preserve">
          <source>The tensors returned by the first pair whose predicate evaluated to True, or those returned by &lt;code&gt;default&lt;/code&gt; if none does.</source>
          <target state="translated">Los tensores devueltos por el primer par cuyo predicado se evalu&amp;oacute; como Verdadero, o los devueltos por &lt;code&gt;default&lt;/code&gt; si ninguno lo hace.</target>
        </trans-unit>
        <trans-unit id="62c909c71b66d6f5bfc11fa3e5279c6761971045" translate="yes" xml:space="preserve">
          <source>The tensors returned from &lt;code&gt;fn()&lt;/code&gt;.</source>
          <target state="translated">Los tensores regresaron de &lt;code&gt;fn()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ac69b5b20154b08a328b1d97feb7527a2ebab36" translate="yes" xml:space="preserve">
          <source>The tensors to print out if the condition is False. Defaults to error message and first few entries of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de476c8a1f81cdd546d80c349f6129aaf3737e55" translate="yes" xml:space="preserve">
          <source>The tensors to print out if the condition is False. Defaults to error message and first few entries of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d755f0b97c63b7eff4b6dbe33de5d6acf734d32c" translate="yes" xml:space="preserve">
          <source>The tensors to print out if the condition is False. Defaults to error message and first few entries of the violating tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41e71fc634a3e1532ea4fdaf908aef7f0776c5d2" translate="yes" xml:space="preserve">
          <source>The tensors to print out if the condition is False. Defaults to error message and the shape of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3c87ea478ca9312b37363d8086e97ef6cac7d50" translate="yes" xml:space="preserve">
          <source>The tensors to print out when condition is false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f38446647c9bdb5f6c17c4098bf60d7f38504af" translate="yes" xml:space="preserve">
          <source>The tensors will be printed to the log, with &lt;code&gt;INFO&lt;/code&gt; severity. If you are not seeing the logs, you might want to add the following line after your imports:</source>
          <target state="translated">Los tensores se imprimir&amp;aacute;n en el registro, con &lt;code&gt;INFO&lt;/code&gt; severidad. Si no ve los registros, es posible que desee agregar la siguiente l&amp;iacute;nea despu&amp;eacute;s de sus importaciones:</target>
        </trans-unit>
        <trans-unit id="6922a3a9fd52a35b3e308cba8bec364b7d504e80" translate="yes" xml:space="preserve">
          <source>The tf.Graph in which tensors are looked up. If None, the current default graph is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11bfdd9c3d39d4a32c1a375c3ce8bfd375bd0b18" translate="yes" xml:space="preserve">
          <source>The tf.tpu.Topology object for the topology of the TPU cluster.</source>
          <target state="translated">El tf.tpu.Objeto de topología para la topología del grupo TPU.</target>
        </trans-unit>
        <trans-unit id="befdc8701902b7376e60ef81bed3d724c3bb2879" translate="yes" xml:space="preserve">
          <source>The the elements of the output vector are in range (0, 1) and sum to 1.</source>
          <target state="translated">Los elementos del vector de salida se encuentran en el rango (0,1)y suman 1.</target>
        </trans-unit>
        <trans-unit id="e8a1b74b382d4bec7d008b052874fc8efea06387" translate="yes" xml:space="preserve">
          <source>The threading options associated with the dataset. See &lt;a href=&quot;experimental/threadingoptions&quot;&gt;&lt;code&gt;tf.data.experimental.ThreadingOptions&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">Las opciones de subprocesamiento asociadas con el conjunto de datos. Consulte &lt;a href=&quot;experimental/threadingoptions&quot;&gt; &lt;code&gt;tf.data.experimental.ThreadingOptions&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="ed8f460f2dbd5613ea876b9d93397d3969bdc742" translate="yes" xml:space="preserve">
          <source>The thresholds used for evaluating AUC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d718a76c8894d5837a42ef966440d43045adca5" translate="yes" xml:space="preserve">
          <source>The token representing an out-of-vocabulary value. Defaults to &quot;[UNK]&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3e4fd90c9e18807d72bafd4f4716080dd6bc34f" translate="yes" xml:space="preserve">
          <source>The total number of dimensions in a &lt;code&gt;RaggedTensor&lt;/code&gt; is called its &lt;em&gt;rank&lt;/em&gt;, and the number of ragged dimensions in a &lt;code&gt;RaggedTensor&lt;/code&gt; is called its &lt;em&gt;ragged-rank&lt;/em&gt;. A &lt;code&gt;RaggedTensor&lt;/code&gt;'s ragged-rank is fixed at graph creation time: it can't depend on the runtime values of &lt;code&gt;Tensor&lt;/code&gt;s, and can't vary dynamically for different session runs.</source>
          <target state="translated">El n&amp;uacute;mero total de dimensiones en un &lt;code&gt;RaggedTensor&lt;/code&gt; se llama su &lt;em&gt;rango&lt;/em&gt; , y el n&amp;uacute;mero de dimensiones irregulares en un &lt;code&gt;RaggedTensor&lt;/code&gt; se llama su &lt;em&gt;rango irregular&lt;/em&gt; . El &lt;code&gt;RaggedTensor&lt;/code&gt; irregular de un RaggedTensor se fija en el momento de la creaci&amp;oacute;n del gr&amp;aacute;fico: no puede depender de los valores de tiempo de ejecuci&amp;oacute;n de &lt;code&gt;Tensor&lt;/code&gt; s, y no puede variar din&amp;aacute;micamente para diferentes ejecuciones de sesi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7366f216b0f07a06f98c4cfb72b6efd8edad2b69" translate="yes" xml:space="preserve">
          <source>The total variation is the sum of the absolute differences for neighboring pixel-values in the input images. This measures how much noise is in the images.</source>
          <target state="translated">La variación total es la suma de las diferencias absolutas de los valores de los píxeles vecinos en las imágenes de entrada.Esto mide cuánto ruido hay en las imágenes.</target>
        </trans-unit>
        <trans-unit id="4cd5555b6721cf29a977af9cf8bb6114222ca75d" translate="yes" xml:space="preserve">
          <source>The total variation of &lt;code&gt;images&lt;/code&gt;.</source>
          <target state="translated">La variaci&amp;oacute;n total de &lt;code&gt;images&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1be006e04763947d6204304381da8047ab403c6" translate="yes" xml:space="preserve">
          <source>The trace of input tensor.</source>
          <target state="translated">El rastro del tensor de entrada.</target>
        </trans-unit>
        <trans-unit id="e883a1ea41a9a9c563ecd15d66e0cea02e0fd475" translate="yes" xml:space="preserve">
          <source>The transformation calls &lt;code&gt;reduce_func&lt;/code&gt; successively on every element of the input dataset until the dataset is exhausted, aggregating information in its internal state. The &lt;code&gt;initial_state&lt;/code&gt; argument is used for the initial state and the final state is returned as the result.</source>
          <target state="translated">La transformaci&amp;oacute;n llama a &lt;code&gt;reduce_func&lt;/code&gt; sucesivamente en cada elemento del conjunto de datos de entrada hasta que se agota el conjunto de datos, agregando informaci&amp;oacute;n en su estado interno. El argumento &lt;code&gt;initial_state&lt;/code&gt; se usa para el estado inicial y el estado final se devuelve como resultado.</target>
        </trans-unit>
        <trans-unit id="a76374d8db32ee668d78ea0cbd0b4fb2bd9d2baf" translate="yes" xml:space="preserve">
          <source>The transpose of &lt;code&gt;atrous_conv2d&lt;/code&gt;.</source>
          <target state="translated">La transposici&amp;oacute;n de &lt;code&gt;atrous_conv2d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24fae844f58c6b39229d2519fcdd2125a204111b" translate="yes" xml:space="preserve">
          <source>The transpose of &lt;code&gt;conv1d&lt;/code&gt;.</source>
          <target state="translated">La transposici&amp;oacute;n de &lt;code&gt;conv1d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5584a45278a21e44f011bf21c57aa5501a09482" translate="yes" xml:space="preserve">
          <source>The transpose of &lt;code&gt;conv2d&lt;/code&gt;.</source>
          <target state="translated">La transposici&amp;oacute;n de &lt;code&gt;conv2d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88458abd7b78099fd74249ee9fe81104261b47e7" translate="yes" xml:space="preserve">
          <source>The transpose of &lt;code&gt;conv3d&lt;/code&gt;.</source>
          <target state="translated">La transposici&amp;oacute;n de &lt;code&gt;conv3d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4974672a5f0bdf2f1f4a3ac2ea5cc95568047305" translate="yes" xml:space="preserve">
          <source>The transpose of &lt;code&gt;convolution&lt;/code&gt;.</source>
          <target state="translated">La transposici&amp;oacute;n de la &lt;code&gt;convolution&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1519a20ef4fe586180643d48497a05b2e0fad92f" translate="yes" xml:space="preserve">
          <source>The tuple of concatenated tensors that was dequeued.</source>
          <target state="translated">La tupla de tensores concatenados que estaba en cola.</target>
        </trans-unit>
        <trans-unit id="947a12be95ae913828fb29965c58acb416f681d0" translate="yes" xml:space="preserve">
          <source>The tuple of tensors that was dequeued.</source>
          <target state="translated">La tupla de tensores que estaba en cola.</target>
        </trans-unit>
        <trans-unit id="3ac8da8c53a0fe7729ca96dc99672e3deaee4160" translate="yes" xml:space="preserve">
          <source>The tutorials cover how to use &lt;a href=&quot;../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; to do distributed training with native Keras APIs, custom training loops, and Esitmator APIs. They also cover how to save/load model when using &lt;a href=&quot;../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81263e37d187db94dad3d1abafbff5fd315364f1" translate="yes" xml:space="preserve">
          <source>The tutorials cover how to use &lt;a href=&quot;distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; to do distributed training with native Keras APIs, custom training loops, and Esitmator APIs. They also cover how to save/load model when using &lt;a href=&quot;distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcce8e7308a1f27fd06f367ce630638c93d290a0" translate="yes" xml:space="preserve">
          <source>The two arguments should be data trees consisting of trees of dicts and lists. They will be deeply compared by walking into the contents of dicts and lists; other items will be compared using the == operator. If the two structures differ in content, the failure message will indicate the location within the structures where the first difference is found. This may be helpful when comparing large structures.</source>
          <target state="translated">Los dos argumentos deben ser árboles de datos que consisten en árboles de dictados y listas.Se compararán profundamente al entrar en el contenido de los dictados y listas;otros elementos se compararán usando el operador ==.Si las dos estructuras difieren en su contenido,el mensaje de fallo indicará la ubicación dentro de las estructuras donde se encuentra la primera diferencia.Esto puede ser útil cuando se comparan grandes estructuras.</target>
        </trans-unit>
        <trans-unit id="c63ea59f28eeb3c5ef7f12904295f5acd2abba7d" translate="yes" xml:space="preserve">
          <source>The two optional lists, &lt;code&gt;shapes&lt;/code&gt; and &lt;code&gt;names&lt;/code&gt;, must be of the same length as &lt;code&gt;dtypes&lt;/code&gt; if provided. The values at a given index &lt;code&gt;i&lt;/code&gt; indicate the shape and name to use for the corresponding queue component in &lt;code&gt;dtypes&lt;/code&gt;.</source>
          <target state="translated">Las dos listas opcionales, &lt;code&gt;shapes&lt;/code&gt; y &lt;code&gt;names&lt;/code&gt; , deben tener la misma longitud que los &lt;code&gt;dtypes&lt;/code&gt; si se proporcionan. Los valores a un &amp;iacute;ndice dado &lt;code&gt;i&lt;/code&gt; indican la forma y el nombre que se utilizar&amp;aacute; para el componente de cola correspondiente en &lt;code&gt;dtypes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2509253fc683a9173057f5630f71d4971cacd9bd" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;values&lt;/code&gt; elements in the tensor to be fed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c1114eda45ad0aa9835c881c7ed41948119a5f6" translate="yes" xml:space="preserve">
          <source>The type of alpha, beta, and the output: &lt;code&gt;float16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, or &lt;code&gt;float64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcb9c58891241a3653f7ed23f1f4e9ce6c454d7f" translate="yes" xml:space="preserve">
          <source>The type of an element in the resulting &lt;code&gt;Tensor&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cccbb2c85e31880b8682b2d0adfb113b78b64da" translate="yes" xml:space="preserve">
          <source>The type of compression for the record.</source>
          <target state="translated">El tipo de compresión para el registro.</target>
        </trans-unit>
        <trans-unit id="1b4dd7863bb3d0a86631168ad97e3c5ad4e8e603" translate="yes" xml:space="preserve">
          <source>The type of element in the resulting &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94422215aeace7edcb47320386970071b5179d19" translate="yes" xml:space="preserve">
          <source>The type of elements for the returned &lt;code&gt;RaggedTensor&lt;/code&gt;. If not specified, then a default is chosen based on the scalar values in &lt;code&gt;pylist&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a013615eda1f8f0ede1ff237cff4a624ad2cf8a" translate="yes" xml:space="preserve">
          <source>The type of elements in the tensor to be fed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffc1d3e87a785b70bd5fa0c191f6b8f9a2dab411" translate="yes" xml:space="preserve">
          <source>The type of encoding for the file. Defaults to none.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f00002f765021b74ae3866db29b33e5675d9c97a" translate="yes" xml:space="preserve">
          <source>The type of features. Only string and integer types are supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="405fc0a59f40a1f68ad3da9d2cbead3200ca93bb" translate="yes" xml:space="preserve">
          <source>The type of features. Only string and integer types are supported. If &lt;code&gt;None&lt;/code&gt;, it will be inferred from &lt;code&gt;vocabulary_list&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e39ef94a4f11a83b4f0f2df2ede7e0ef31ede65" translate="yes" xml:space="preserve">
          <source>The type of loss reduction used in the head.</source>
          <target state="translated">El tipo de reducción de pérdidas utilizado en la cabeza.</target>
        </trans-unit>
        <trans-unit id="9e1c8635c975f4590fc90901ef34444f7e5713cc" translate="yes" xml:space="preserve">
          <source>The type of sharding that auto-shard should attempt. If this is set to FILE, then we will attempt to shard by files (each worker will get a set of files to process). If we cannot find a set of files to shard for at least one file per worker, we will error out. When this option is selected, make sure that you have enough files so that each worker gets at least one file. There will be a runtime error thrown if there are insufficient files. If this is set to DATA, then we will shard by elements produced by the dataset, and each worker will process the whole dataset and discard the portion that is not for itself. If this is set to OFF, then we will not autoshard, and each worker will receive a copy of the full dataset. This option is set to AUTO by default, AUTO will attempt to first shard by FILE, and fall back to sharding by DATA if we cannot find a set of files to shard.</source>
          <target state="translated">El tipo de fragmentación que debería intentar esa auto-fractura.Si se establece en ARCHIVO,entonces intentaremos fragmentar por archivos (cada trabajador obtendrá un conjunto de archivos para procesar).Si no podemos encontrar un conjunto de archivos para fragmentar por lo menos un archivo por trabajador,daremos un error.Cuando se seleccione esta opción,asegúrese de tener suficientes archivos para que cada trabajador obtenga al menos un archivo.Se producirá un error de ejecución si no hay suficientes archivos.Si esto se establece en DATA,entonces nos fragmentaremos por los elementos producidos por el conjunto de datos,y cada trabajador procesará todo el conjunto de datos y descartará la parte que no es para sí mismo.Si esto se pone en OFF,entonces no nos autodirigiremos,y cada trabajador recibirá una copia del conjunto de datos completo.Esta opción se establece en AUTO por defecto,AUTO intentará primero fragmentar por ARCHIVO,y volverá a fragmentar por DATOS si no podemos encontrar un conjunto de archivos para fragmentar.</target>
        </trans-unit>
        <trans-unit id="1076c8ce1d97d2aae1dd52bec1be1eb1d7da0726" translate="yes" xml:space="preserve">
          <source>The type of the elements of the resulting tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e8bb7b7574042b37e7c6afeec47ae6a75f4b513" translate="yes" xml:space="preserve">
          <source>The type of the elements of the resulting tensor. If not specified, then a value is chosen based on the other args.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aed6e689e6786fb190bf4135aa5cf05a31f4f0b3" translate="yes" xml:space="preserve">
          <source>The type of the event samples (default: int32).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a0617255d963a3d9373238c1968c00abc24574b" translate="yes" xml:space="preserve">
          <source>The type of the event samples. &lt;code&gt;None&lt;/code&gt; implies no type-enforcement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e6ae3861b6b33f7202d6cb04f51d8a43f2ebb83" translate="yes" xml:space="preserve">
          <source>The type of the event samples. Default: &lt;code&gt;int32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5ac8c9ef31246fab5b3b784f6fdb5ffec2b2eba" translate="yes" xml:space="preserve">
          <source>The type of the op (e.g. &lt;code&gt;&quot;MatMul&quot;&lt;/code&gt;).</source>
          <target state="translated">El tipo de &lt;code&gt;&quot;MatMul&quot;&lt;/code&gt; (por ejemplo, &quot;MatMul&quot; ).</target>
        </trans-unit>
        <trans-unit id="067097eae217bc20b817dae41bcd6adaa941c2bf" translate="yes" xml:space="preserve">
          <source>The type of the op that generated the tensor with bad numerics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a9b8c589712a808dd41511f2b9583296c78486" translate="yes" xml:space="preserve">
          <source>The type of the output tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ac7350774189c9f4f0f6d153487ae1c0df2dfef" translate="yes" xml:space="preserve">
          <source>The type of the output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da83b3257815d9c8a52c8c2fe774ab08e0d4a548" translate="yes" xml:space="preserve">
          <source>The type of the output. Default: tf.int32</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa045fdeece95a6373419965f4b455817b39af60" translate="yes" xml:space="preserve">
          <source>The type of the output: &lt;code&gt;float16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt; or &lt;code&gt;int64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f27b43df09bda0cc0e4bd074ae7a03dba23972ee" translate="yes" xml:space="preserve">
          <source>The type of the output: &lt;code&gt;float16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, or &lt;code&gt;int64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8cc4d05affc30251cb4e72ec85d99c502c39e2b" translate="yes" xml:space="preserve">
          <source>The type of the output: &lt;code&gt;float16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, or &lt;code&gt;int64&lt;/code&gt;. For unbounded uniform ints (&lt;code&gt;minval&lt;/code&gt;, &lt;code&gt;maxval&lt;/code&gt; both &lt;code&gt;None&lt;/code&gt;), &lt;code&gt;uint32&lt;/code&gt; and &lt;code&gt;uint64&lt;/code&gt; may be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b2e4f649b30bc99091c2da410cb8448c8ba873a" translate="yes" xml:space="preserve">
          <source>The type of the this &lt;code&gt;LinearOperator&lt;/code&gt;. Arguments to &lt;code&gt;matmul&lt;/code&gt; and &lt;code&gt;solve&lt;/code&gt; will have to be this type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74e0737155eb6c648136eb7aa61f1f5f53eaee2c" translate="yes" xml:space="preserve">
          <source>The type of the variable. Defaults to &lt;code&gt;self.dtype&lt;/code&gt; or &lt;code&gt;float32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89eb9b54cfc1eb5edbdf1804af86410f57c03f40" translate="yes" xml:space="preserve">
          <source>The type of values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc791524ffdf48de9024b17fb2e81e72b1743abc" translate="yes" xml:space="preserve">
          <source>The type specification of an element of &lt;a href=&quot;distributediterator&quot;&gt;&lt;code&gt;tf.distribute.DistributedIterator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="586865cdc2362857bdac73e4d9d4aafd45add2e6" translate="yes" xml:space="preserve">
          <source>The type specification of an element of this &lt;a href=&quot;distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f4d546108b4584207f8473dd28294356ddeede5" translate="yes" xml:space="preserve">
          <source>The type specification of an element of this dataset.</source>
          <target state="translated">La especificación del tipo de un elemento de este conjunto de datos.</target>
        </trans-unit>
        <trans-unit id="31f5cdd5cadead57bcfc00f19cdc637b778a8dfa" translate="yes" xml:space="preserve">
          <source>The type specification of an element of this iterator.</source>
          <target state="translated">La especificación del tipo de un elemento de este iterador.</target>
        </trans-unit>
        <trans-unit id="31e1b2499af19cb707e87dbc9b32089b65e02169" translate="yes" xml:space="preserve">
          <source>The type specification of an element of this optional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bce40406c73aa0072207096be99446cc37cd3334" translate="yes" xml:space="preserve">
          <source>The types of the tensors in &lt;code&gt;values&lt;/code&gt; must match the schema for the fields specified in &lt;code&gt;field_names&lt;/code&gt;. All the tensors in &lt;code&gt;values&lt;/code&gt; must have a common shape prefix, &lt;em&gt;batch_shape&lt;/em&gt;.</source>
          <target state="translated">Los tipos de tensores en &lt;code&gt;values&lt;/code&gt; deben coincidir con el esquema de los campos especificados en &lt;code&gt;field_names&lt;/code&gt; . Todos los tensores en &lt;code&gt;values&lt;/code&gt; deben tener un prefijo de forma com&amp;uacute;n, &lt;em&gt;batch_shape&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e5381b2e579e07c748270f78ee35dd566e3eb442" translate="yes" xml:space="preserve">
          <source>The typical scenario for &lt;code&gt;ExponentialMovingAverage&lt;/code&gt; is to compute moving averages of variables during training, and restore the variables from the computed moving averages during evaluations.</source>
          <target state="translated">El escenario t&amp;iacute;pico de &lt;code&gt;ExponentialMovingAverage&lt;/code&gt; es calcular las medias m&amp;oacute;viles de las variables durante el entrenamiento y restaurar las variables de las medias m&amp;oacute;viles calculadas durante las evaluaciones.</target>
        </trans-unit>
        <trans-unit id="3da77fbceb0e840441ce8c39192555e97fa2928b" translate="yes" xml:space="preserve">
          <source>The underlying accumulator reference.</source>
          <target state="translated">La referencia del acumulador subyacente.</target>
        </trans-unit>
        <trans-unit id="c25ef637b6290d9c594d8a4f22f2ec949aa1bd01" translate="yes" xml:space="preserve">
          <source>The underlying queue reference.</source>
          <target state="translated">La referencia de la cola subyacente.</target>
        </trans-unit>
        <trans-unit id="e903c075a80c182337230b41e8fc05a166057ed0" translate="yes" xml:space="preserve">
          <source>The unique &lt;code&gt;frame_name&lt;/code&gt; is used by the &lt;code&gt;Executor&lt;/code&gt; to identify frames. If &lt;code&gt;is_constant&lt;/code&gt; is true, &lt;code&gt;output&lt;/code&gt; is a constant in the child frame; otherwise it may be changed in the child frame. At most &lt;code&gt;parallel_iterations&lt;/code&gt; iterations are run in parallel in the child frame.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2570833b8fed9aa7ee0f6db077c7e434ab3d563b" translate="yes" xml:space="preserve">
          <source>The unpacked tuple, with &lt;code&gt;None&lt;/code&gt;s for &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;sample_weight&lt;/code&gt; if they are not provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d25a2d45745d4308947942d9bddb3fe51f90e219" translate="yes" xml:space="preserve">
          <source>The update rule for &lt;code&gt;variable&lt;/code&gt; with gradient &lt;code&gt;g&lt;/code&gt; uses an optimization described at the end of section 2 of the paper:</source>
          <target state="translated">La regla de actualizaci&amp;oacute;n para la &lt;code&gt;variable&lt;/code&gt; con gradiente &lt;code&gt;g&lt;/code&gt; utiliza una optimizaci&amp;oacute;n descrita al final de la secci&amp;oacute;n 2 del documento:</target>
        </trans-unit>
        <trans-unit id="dcaa87717690c893cddcbb06c2774de0d640ef88" translate="yes" xml:space="preserve">
          <source>The update rule for &lt;code&gt;variable&lt;/code&gt; with gradient &lt;code&gt;g&lt;/code&gt; uses an optimization described at the end of section 7.1 of the paper:</source>
          <target state="translated">La regla de actualizaci&amp;oacute;n para la &lt;code&gt;variable&lt;/code&gt; con gradiente &lt;code&gt;g&lt;/code&gt; utiliza una optimizaci&amp;oacute;n descrita al final de la secci&amp;oacute;n 7.1 del documento:</target>
        </trans-unit>
        <trans-unit id="0efd76819f39cf3bcb5dd14bc65d8c8c72cef23d" translate="yes" xml:space="preserve">
          <source>The update rule for parameter &lt;code&gt;w&lt;/code&gt; with gradient &lt;code&gt;g&lt;/code&gt; is described at the end of section 7.1 of the paper:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a9901f8d5a239b98ad1f04b6bbdac6a25b5dbe0" translate="yes" xml:space="preserve">
          <source>The updated config has something needed to run a strategy, e.g. configuration to run collective ops, or device filters to improve distributed training performance.</source>
          <target state="translated">La configuración actualizada tiene algo necesario para ejecutar una estrategia,por ejemplo,la configuración para ejecutar operaciones colectivas,o los filtros de dispositivos para mejorar el rendimiento del entrenamiento distribuido.</target>
        </trans-unit>
        <trans-unit id="60dd7fe2afadb5341f05d411ef207c2859229807" translate="yes" xml:space="preserve">
          <source>The updated copy of the &lt;code&gt;config_proto&lt;/code&gt;.</source>
          <target state="translated">La copia actualizada de &lt;code&gt;config_proto&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d9e39fd60700bb347ed0039e54d9af3ef5a5100" translate="yes" xml:space="preserve">
          <source>The updated decorator. If decorator_func is not a tf_decorator, new_target is returned.</source>
          <target state="translated">El decorador actualizado.Si decorator_func no es un tf_decorator,se devuelve new_target.</target>
        </trans-unit>
        <trans-unit id="fa6ecd5172af3b96400529c50d0c7eb9f4adaa33" translate="yes" xml:space="preserve">
          <source>The updated variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb0ce841932dc29d8f332a4acc96a1313d2133b7" translate="yes" xml:space="preserve">
          <source>The updated variable. If &lt;code&gt;read_value&lt;/code&gt; is false, instead returns None in Eager mode and the assign op in graph mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d8daec55baf3c813ce2f2fc4a5eab596ea78fbf" translate="yes" xml:space="preserve">
          <source>The upper regularized incomplete Gamma function is defined as:</source>
          <target state="translated">La función Gamma incompleta regularizada superior se define como:</target>
        </trans-unit>
        <trans-unit id="a16fb2ccec6d9e76f7b18eacf6123674146710e7" translate="yes" xml:space="preserve">
          <source>The user could also use &lt;code&gt;make_input_fn_iterator&lt;/code&gt; if they want to customize which input is fed to which replica/worker etc.</source>
          <target state="translated">El usuario tambi&amp;eacute;n puede usar &lt;code&gt;make_input_fn_iterator&lt;/code&gt; si desea personalizar qu&amp;eacute; entrada se env&amp;iacute;a a qu&amp;eacute; r&amp;eacute;plica / trabajador, etc.</target>
        </trans-unit>
        <trans-unit id="ab789081815c49957f21bd695c2a3924b82c20ff" translate="yes" xml:space="preserve">
          <source>The user is given the option of raising an exception or returning &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">El usuario tiene la opci&amp;oacute;n de generar una excepci&amp;oacute;n o devolver &lt;code&gt;NaN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d78e502adf2b1729b9f368b8135c69dbb97bac0" translate="yes" xml:space="preserve">
          <source>The usual cross-entropy cost is defined as:</source>
          <target state="translated">El coste habitual de la entropía cruzada se define como:</target>
        </trans-unit>
        <trans-unit id="55894b0693429bc52d5ca851ab5e7e50a45cb526" translate="yes" xml:space="preserve">
          <source>The valid keyword arguments in kwds are:</source>
          <target state="translated">Los argumentos válidos de las palabras clave en kwds son:</target>
        </trans-unit>
        <trans-unit id="2e9dcb12c3ec9343c2b4d76ebee61442f18c708d" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;delta&lt;/code&gt; is added to all components of the tensor &lt;code&gt;image&lt;/code&gt;. &lt;code&gt;image&lt;/code&gt; is converted to &lt;code&gt;float&lt;/code&gt; and scaled appropriately if it is in fixed-point representation, and &lt;code&gt;delta&lt;/code&gt; is converted to the same data type. For regular images, &lt;code&gt;delta&lt;/code&gt; should be in the range &lt;code&gt;[0,1)&lt;/code&gt;, as it is added to the image in floating point representation, where pixel values are in the &lt;code&gt;[0,1)&lt;/code&gt; range.</source>
          <target state="translated">El valor &lt;code&gt;delta&lt;/code&gt; se agrega a todos los componentes de la &lt;code&gt;image&lt;/code&gt; n del tensor . &lt;code&gt;image&lt;/code&gt; se convierte en &lt;code&gt;float&lt;/code&gt; y se escala de forma adecuada si est&amp;aacute; en representaci&amp;oacute;n de punto fijo, y &lt;code&gt;delta&lt;/code&gt; se convierte al mismo tipo de datos. Para im&amp;aacute;genes regulares, &lt;code&gt;delta&lt;/code&gt; debe estar en el rango &lt;code&gt;[0,1)&lt;/code&gt; , ya que se agrega a la imagen en representaci&amp;oacute;n de punto flotante, donde los valores de p&amp;iacute;xeles est&amp;aacute;n en el rango &lt;code&gt;[0,1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0cc40289aaf5ca63368c701a28edf746620f686" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;self.value &amp;gt; other.value&lt;/code&gt; if both are known, otherwise None.</source>
          <target state="translated">El valor de &lt;code&gt;self.value &amp;gt; other.value&lt;/code&gt; si ambos son conocidos, de lo contrario Ninguno.</target>
        </trans-unit>
        <trans-unit id="28eee150e3c68dabbd6edcffc1df83846a31e392" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;self.value &amp;gt;= other.value&lt;/code&gt; if both are known, otherwise None.</source>
          <target state="translated">El valor de &lt;code&gt;self.value &amp;gt;= other.value&lt;/code&gt; si ambos son conocidos, de lo contrario Ninguno.</target>
        </trans-unit>
        <trans-unit id="1ac388cf68a7917e640172de08cfda57213cf191" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;self.value &amp;lt; other.value&lt;/code&gt; if both are known, otherwise None.</source>
          <target state="translated">El valor de &lt;code&gt;self.value &amp;lt; other.value&lt;/code&gt; si se conocen ambos, de lo contrario Ninguno.</target>
        </trans-unit>
        <trans-unit id="b01cea77304d81c49aa6bfe991a86b9994cc913b" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;self.value &amp;lt;= other.value&lt;/code&gt; if both are known, otherwise None.</source>
          <target state="translated">El valor de &lt;code&gt;self.value &amp;lt;= other.value&lt;/code&gt; si ambos son conocidos, de lo contrario Ninguno.</target>
        </trans-unit>
        <trans-unit id="97a93b3e6e5220aba9e50c43c510d2bbbc1a87e0" translate="yes" xml:space="preserve">
          <source>The value of such a flag is a list that contains the individual values from all the appearances of that flag on the command-line.</source>
          <target state="translated">El valor de dicha bandera es una lista que contiene los valores individuales de todas las apariciones de esa bandera en la línea de comandos.</target>
        </trans-unit>
        <trans-unit id="a54451b41292d69deaf5cd8ce0771065680d134d" translate="yes" xml:space="preserve">
          <source>The value of the attr, as a Python object.</source>
          <target state="translated">El valor de la atracción,como un objeto de Python.</target>
        </trans-unit>
        <trans-unit id="6e7716dffe6353c157e4a2c3f2e655d155be6b4b" translate="yes" xml:space="preserve">
          <source>The value of the flag is always a list, even if the option was only supplied once, and even if the default value is a single value</source>
          <target state="translated">El valor de la bandera es siempre una lista,aunque la opción sólo se haya suministrado una vez,e incluso si el valor por defecto es un valor único</target>
        </trans-unit>
        <trans-unit id="f28d312af2bea03bbf52afb2a569177bf8ca705a" translate="yes" xml:space="preserve">
          <source>The value of the flag, empty if the flag is not defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf8b3cb3b48dec54fd1680c59ba7cefb3dfc3602" translate="yes" xml:space="preserve">
          <source>The value of the variable after the update.</source>
          <target state="translated">El valor de la variable después de la actualización.</target>
        </trans-unit>
        <trans-unit id="d29c684e1056225784225bef1dc61fddd3c411d6" translate="yes" xml:space="preserve">
          <source>The value of this dimension, or None if it is unknown.</source>
          <target state="translated">El valor de esta dimensión,o ninguno si es desconocido.</target>
        </trans-unit>
        <trans-unit id="dc40d49743dfe15cf0fa34edb80ecfa5afa70d65" translate="yes" xml:space="preserve">
          <source>The value or values returned by &lt;code&gt;map_func&lt;/code&gt; determine the structure of each element in the returned dataset.</source>
          <target state="translated">El valor o los valores devueltos por &lt;code&gt;map_func&lt;/code&gt; determinan la estructura de cada elemento en el conjunto de datos devuelto.</target>
        </trans-unit>
        <trans-unit id="277f6e101a6f4f13a9cc5f1fee440972491084f4" translate="yes" xml:space="preserve">
          <source>The value representing an out-of-vocabulary value. Defaults to -1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27a9bdb78e692ccca6e6eeacfe9cf8259c37e6d7" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;run()&lt;/code&gt; has the same shape as the &lt;code&gt;fetches&lt;/code&gt; argument, where the leaves are replaced by the corresponding values returned by TensorFlow.</source>
          <target state="translated">El valor devuelto por &lt;code&gt;run()&lt;/code&gt; tiene la misma forma que el argumento &lt;code&gt;fetches&lt;/code&gt; , donde las hojas se reemplazan por los valores correspondientes devueltos por TensorFlow.</target>
        </trans-unit>
        <trans-unit id="6455c45d9b49b1bb8f4ec9b5dff00531b9342ec2" translate="yes" xml:space="preserve">
          <source>The value returned by the &lt;code&gt;activity_regularizer&lt;/code&gt; is divided by the input batch size so that the relative weighting between the weight regularizers and the activity regularizers does not change with the batch size.</source>
          <target state="translated">El valor devuelto por &lt;code&gt;activity_regularizer&lt;/code&gt; se divide por el tama&amp;ntilde;o del lote de entrada para que la ponderaci&amp;oacute;n relativa entre los regularizadores de peso y los regularizadores de actividad no cambie con el tama&amp;ntilde;o del lote.</target>
        </trans-unit>
        <trans-unit id="e67ea60a1d86085a3a91a8df093188ea7d78231f" translate="yes" xml:space="preserve">
          <source>The value returned by this operation is guaranteed to be influenced by all the writes on which this operation depends directly or indirectly, and to not be influenced by any of the writes which depend directly or indirectly on this operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca8a88dac26c441fe66426635dcf33f3ecddba85" translate="yes" xml:space="preserve">
          <source>The value to add to the collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67488a526901c9a4f2769ad17a3b244c04775dbb" translate="yes" xml:space="preserve">
          <source>The value to add to the collections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0467f1eec9e713645aba39b382503cafa6ae6856" translate="yes" xml:space="preserve">
          <source>The value to fill for empty rows, with the same type as &lt;code&gt;sp_input.&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c9729e11273c726456e8e0c3c8e270a5166729e" translate="yes" xml:space="preserve">
          <source>The value to fill the area outside the specified diagonal band with. Default is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53f548425b8c43bbee75c542b6da5327e5f5f507" translate="yes" xml:space="preserve">
          <source>The value to use if a key is missing in the table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46cf38cbb0627d0763f0f1b40f1bcbf960cd2dde" translate="yes" xml:space="preserve">
          <source>The values generated are similar to values from a &lt;a href=&quot;randomnormal&quot;&gt;&lt;code&gt;tf.keras.initializers.RandomNormal&lt;/code&gt;&lt;/a&gt; initializer except that values more than two standard deviations from the mean are discarded and re-drawn.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c61a71eb4077cf30110803e381657708b49ae932" translate="yes" xml:space="preserve">
          <source>The values must include 0. There can be no duplicate values or negative values.</source>
          <target state="translated">Los valores deben incluir 0.No puede haber valores duplicados o valores negativos.</target>
        </trans-unit>
        <trans-unit id="1050986413ba8aa09be08e1ada6c99bfa286c827" translate="yes" xml:space="preserve">
          <source>The values not defined in &lt;code&gt;sp_input&lt;/code&gt; don't participate in the reduce max, as opposed to be implicitly assumed 0 -- hence it can return negative values for sparse &lt;code&gt;axis&lt;/code&gt;. But, in case there are no values in &lt;code&gt;axis&lt;/code&gt;, it will reduce to 0. See second example below.</source>
          <target state="translated">Los valores no definidos en &lt;code&gt;sp_input&lt;/code&gt; no participan en la reducci&amp;oacute;n m&amp;aacute;xima, a diferencia de que se asume impl&amp;iacute;citamente 0, por lo que puede devolver valores negativos para el &lt;code&gt;axis&lt;/code&gt; disperso . Pero, en caso de que no haya valores en el &lt;code&gt;axis&lt;/code&gt; , se reducir&amp;aacute; a 0. Vea el segundo ejemplo a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="15f0cbbec41c8cec7a1600faa3fd0ba6c8267aeb" translate="yes" xml:space="preserve">
          <source>The values not defined in &lt;code&gt;sp_input&lt;/code&gt; don't participate in the reduce max, as opposed to be implicitly assumed 0 -- hence it can return negative values for sparse &lt;code&gt;reduction_axes&lt;/code&gt;. But, in case there are no values in &lt;code&gt;reduction_axes&lt;/code&gt;, it will reduce to 0. See second example below.</source>
          <target state="translated">Los valores no definidos en &lt;code&gt;sp_input&lt;/code&gt; no participan en el m&amp;aacute;ximo de reducci&amp;oacute;n, a diferencia de que se asume impl&amp;iacute;citamente 0; por lo tanto, puede devolver valores negativos para ejes de &lt;code&gt;reduction_axes&lt;/code&gt; dispersos . Pero, en caso de que no haya valores en &lt;code&gt;reduction_axes&lt;/code&gt; , se reducir&amp;aacute; a 0. Vea el segundo ejemplo a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="01b28056c2bd0c58a2e89c42fd350d1a9e497580" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;alpha&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; are chosen so that the mean and variance of the inputs are preserved between two consecutive layers as long as the weights are initialized correctly (see &lt;a href=&quot;../initializers/lecun_normal&quot;&gt;&lt;code&gt;lecun_normal&lt;/code&gt; initialization&lt;/a&gt;) and the number of inputs is &quot;large enough&quot; (see references for more information).</source>
          <target state="translated">Los valores de &lt;code&gt;alpha&lt;/code&gt; y &lt;code&gt;scale&lt;/code&gt; se eligen de modo que la media y la varianza de las entradas se conserven entre dos capas consecutivas siempre que los pesos se inicialicen correctamente (consulte la &lt;a href=&quot;../initializers/lecun_normal&quot;&gt;inicializaci&amp;oacute;n de &lt;/a&gt; &lt;code&gt;lecun_normal&lt;/code&gt; ) y el n&amp;uacute;mero de entradas sea &quot;suficientemente grande&quot; (consulte las referencias de m&amp;aacute;s informaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="64ea94b6b8cce4972e532c22a39ade0ab1c04bbd" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;alpha&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; are chosen so that the mean and variance of the inputs are preserved between two consecutive layers as long as the weights are initialized correctly (see &lt;a href=&quot;../initializers/lecunnormal&quot;&gt;&lt;code&gt;tf.keras.initializers.LecunNormal&lt;/code&gt;&lt;/a&gt; initializer) and the number of input units is &quot;large enough&quot; (see reference paper for more information).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f733a02fe3b03768ab1ca9ec4da3805a1ad4b791" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;value&lt;/code&gt; are assigned to the positions in the tensor &lt;code&gt;input&lt;/code&gt; that are selected by the slice parameters. The slice parameters &lt;code&gt;begin&lt;/code&gt;&lt;code&gt;end&lt;/code&gt;&lt;code&gt;strides&lt;/code&gt; etc. work exactly as in &lt;code&gt;StridedSlice&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f39cb348464cd40ba244caddc3b9020cc754ba4b" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;value&lt;/code&gt; are assigned to the positions in the variable &lt;code&gt;ref&lt;/code&gt; that are selected by the slice parameters. The slice parameters &lt;code&gt;begin,&lt;/code&gt;end&lt;code&gt;,&lt;/code&gt;strides&lt;code&gt;, etc. work exactly as in&lt;/code&gt;StridedSlice`.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f2d5c98a3c37925f071ae528d2a1426fcf8d79c" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;value&lt;/code&gt; are assigned to the positions in the variable &lt;code&gt;ref&lt;/code&gt; that are selected by the slice parameters. The slice parameters &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, &lt;code&gt;strides&lt;/code&gt;, etc. work exactly as in &lt;code&gt;StridedSlice&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="823a169cfff816da0e0ed79e7aa0fca33f12184b" translate="yes" xml:space="preserve">
          <source>The values to be used in the operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="340b53ddcc61e1600456fa6a942b3a9db9dcd7f4" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;x&lt;/code&gt; updated.</source>
          <target state="translated">La variable &lt;code&gt;x&lt;/code&gt; actualizada.</target>
        </trans-unit>
        <trans-unit id="9b98520ded5c59855ccbb91e15451f218e4fed8a" translate="yes" xml:space="preserve">
          <source>The variable corresponding to &lt;code&gt;input_&lt;/code&gt; or None</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b58067393f30493e389388e4808eed6d24490c13" translate="yes" xml:space="preserve">
          <source>The variable dtype of this policy, or None if the variable dtype should be inferred from the inputs.</source>
          <target state="translated">El tipo de variable de esta política,o Ninguna si el tipo de variable debe ser inferido de las entradas.</target>
        </trans-unit>
        <trans-unit id="bb822034c75bacc81fb53dec6e4b25c54f49ac48" translate="yes" xml:space="preserve">
          <source>The variable dtype of this policy.</source>
          <target state="translated">El tipo variable de esta política.</target>
        </trans-unit>
        <trans-unit id="cf801794eaaba6ef2f8f7f433ed37a63d7d2327d" translate="yes" xml:space="preserve">
          <source>The variance for Student's T equals</source>
          <target state="translated">La variación de la T de Student es igual a</target>
        </trans-unit>
        <trans-unit id="d641778ea2685b7b78fd228569c0026aa6abdc9c" translate="yes" xml:space="preserve">
          <source>The vocabulary file name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde4cff8a5ecda6c3308cd587b5940a27adec93c" translate="yes" xml:space="preserve">
          <source>The vocabulary file should be in CSV-like format, with the last field being the weight associated with the word.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1063f666d548cfe042252b2f4239aa647a4b8506" translate="yes" xml:space="preserve">
          <source>The weights of a layer represent the state of the layer. This function returns both trainable and non-trainable weight values associated with this layer as a list of Numpy arrays, which can in turn be used to load state into similarly parameterized layers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf4e9211223da35fb0cefc91c559dd39cd92d9f5" translate="yes" xml:space="preserve">
          <source>The weights of a layer represent the state of the layer. This function sets the weight values from numpy arrays. The weight values should be passed in the order they are created by the layer. Note that the layer's weights must be instantiated before calling this function by calling the layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c9c5e7f6fe29d5feb4e712a5efa9aacc5795ce1" translate="yes" xml:space="preserve">
          <source>The weights of an optimizer are its state (ie, variables). This function returns the weight values associated with this optimizer as a list of Numpy arrays. The first value is always the iterations count of the optimizer, followed by the optimizer's state variables in the order they were created. The returned list can in turn be used to load state into similarly parameterized optimizers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dbc3d68ba3835fc93e47564b7ed4f1325c6e8cd" translate="yes" xml:space="preserve">
          <source>The weights of an optimizer are its state (ie, variables). This function takes the weight values associated with this optimizer as a list of Numpy arrays. The first value is always the iterations count of the optimizer, followed by the optimizer's state variables in the order they are created. The passed values are used to set the new state of the optimizer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15e91da427b6cf2b2fbc5ac9447fe8b24dd8aa82" translate="yes" xml:space="preserve">
          <source>The width the output tensor is &lt;code&gt;input_depth * block_size&lt;/code&gt;, whereas the height is &lt;code&gt;input_height * block_size&lt;/code&gt;.</source>
          <target state="translated">El ancho del tensor de salida es &lt;code&gt;input_depth * block_size&lt;/code&gt; , mientras que la altura es &lt;code&gt;input_height * block_size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a165b5ce96be1f52d9f7edf6d8a65c227dd997f" translate="yes" xml:space="preserve">
          <source>The width(s) of the ngrams to create. If this is a list or tuple, the op will return ngrams of all specified arities in list order. Values must be non-Tensor integers greater than 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78fda38eef982ddecbfd2142c00746b57a76815b" translate="yes" xml:space="preserve">
          <source>The word index dictionary.</source>
          <target state="translated">El diccionario de índice de palabras.</target>
        </trans-unit>
        <trans-unit id="524d27d9a78ab988dfdffc5a8ddf699fa93cbe93" translate="yes" xml:space="preserve">
          <source>The word index dictionary. Keys are word strings, values are their index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="273384d93f6363b2a2a4c34767e0268890f5d5af" translate="yes" xml:space="preserve">
          <source>The wrapped input tensor.</source>
          <target state="translated">El tensor de entrada envuelto.</target>
        </trans-unit>
        <trans-unit id="e4a82e3bb086ae7e63715facddf72f40e0765006" translate="yes" xml:space="preserve">
          <source>The wrapped output tensor.</source>
          <target state="translated">El tensor de salida envuelto.</target>
        </trans-unit>
        <trans-unit id="52457270e7a01e13ee00378b3108ea8fc12315e0" translate="yes" xml:space="preserve">
          <source>The wrapped value.</source>
          <target state="translated">El valor de la envoltura.</target>
        </trans-unit>
        <trans-unit id="bb274ffefe3874a86b65898ba52aa9be06563172" translate="yes" xml:space="preserve">
          <source>The wrapper function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c29d607aec40364caa8044d1b086cb311bf2d17" translate="yes" xml:space="preserve">
          <source>Theano-like behavior example</source>
          <target state="translated">Ejemplo de comportamiento teánico</target>
        </trans-unit>
        <trans-unit id="c3d562c283b894723caae359b0851a3c4fb15dc1" translate="yes" xml:space="preserve">
          <source>Then calling &lt;code&gt;image_dataset_from_directory(main_directory, labels='inferred')&lt;/code&gt; will return a &lt;a href=&quot;../../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; that yields batches of images from the subdirectories &lt;code&gt;class_a&lt;/code&gt; and &lt;code&gt;class_b&lt;/code&gt;, together with labels 0 and 1 (0 corresponding to &lt;code&gt;class_a&lt;/code&gt; and 1 corresponding to &lt;code&gt;class_b&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5fae7664a9f8954314f95eaa134030803e80ccc" translate="yes" xml:space="preserve">
          <source>Then calling &lt;code&gt;text_dataset_from_directory(main_directory, labels='inferred')&lt;/code&gt; will return a &lt;a href=&quot;../../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; that yields batches of texts from the subdirectories &lt;code&gt;class_a&lt;/code&gt; and &lt;code&gt;class_b&lt;/code&gt;, together with labels 0 and 1 (0 corresponding to &lt;code&gt;class_a&lt;/code&gt; and 1 corresponding to &lt;code&gt;class_b&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb44a39f5e3304ba1e47cd9001107c1190200e02" translate="yes" xml:space="preserve">
          <source>Then output is &lt;code&gt;[2 x 2 x 3]&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70803c29e37a6cdd022ef83164306a19f47318ca" translate="yes" xml:space="preserve">
          <source>Then output is &lt;code&gt;[3 x 4]&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="609a89b6f4ea61b7d43929c28cac3cb16c1a8704" translate="yes" xml:space="preserve">
          <source>Then output is &lt;code&gt;[4 x 3]&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6380335743da8e76766d68f136c813dfdf80835" translate="yes" xml:space="preserve">
          <source>Then the final line will print out:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d073abde2a1df4b5c62a21448d955ee1c50a80df" translate="yes" xml:space="preserve">
          <source>Then the output is a dictionary:</source>
          <target state="translated">Entonces la salida es un diccionario:</target>
        </trans-unit>
        <trans-unit id="4c6244085178ac4f66fb4367c44b652758bf26c2" translate="yes" xml:space="preserve">
          <source>Then you can run a &lt;a href=&quot;../math/add&quot;&gt;&lt;code&gt;tf.add&lt;/code&gt;&lt;/a&gt; operation only on logical device 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f77a2ae4d69da67530e4f97b9e84f16f29f79cdf" translate="yes" xml:space="preserve">
          <source>Then,</source>
          <target state="translated">Then,</target>
        </trans-unit>
        <trans-unit id="18c6dda9e31a83fdb5a90169c27005c658e8056f" translate="yes" xml:space="preserve">
          <source>Then, row_pooling_sequence should satisfy:</source>
          <target state="translated">Entonces,row_pooling_sequence debería satisfacer:</target>
        </trans-unit>
        <trans-unit id="3debd4416d24691c45dc01b19b3489468194d8c2" translate="yes" xml:space="preserve">
          <source>There are a number of questions to ask in the decision process, including:</source>
          <target state="translated">Hay una serie de preguntas para hacer en el proceso de decisión,incluyendo:</target>
        </trans-unit>
        <trans-unit id="6f58afb7ffb8a1e95bc14a4cccd59e26c144fddb" translate="yes" xml:space="preserve">
          <source>There are a number of requirements on what needs to happen inside the scope. However, in places where we have information about which strategy is in use, we often enter the scope for the user, so they don't have to do it explicitly (i.e. calling those either inside or outside the scope is OK).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0dc8d396849561a849ade939c069a913c651243" translate="yes" xml:space="preserve">
          <source>There are different ways to quantize. This version uses only scaling, so 0.0 maps to 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="372d16d9e0a1868251f75c59e5f513839dddd179" translate="yes" xml:space="preserve">
          <source>There are many different ways to implement atrous convolution (see the refs above). The implementation here reduces</source>
          <target state="translated">Hay muchas maneras diferentes de implementar la convolución atómica (ver las referencias anteriores).La implementación aquí reduce</target>
        </trans-unit>
        <trans-unit id="4b4c86e082be3a02799da3aa4833e74149042874" translate="yes" xml:space="preserve">
          <source>There are nodes like Identity and CheckNumerics that are only useful during training, and can be removed in graphs that will be used for nothing but inference. Here we identify and remove them, returning an equivalent graph. To be specific, CheckNumerics nodes are always removed, and Identity nodes that aren't involved in control edges are spliced out so that their input and outputs are directly connected.</source>
          <target state="translated">Hay nodos como Identity y CheckNumerics que sólo son útiles durante el entrenamiento,y que pueden ser eliminados en gráficos que no se utilizarán más que para la inferencia.Aquí los identificamos y los eliminamos,devolviendo un gráfico equivalente.En concreto,los nodos CheckNumerics siempre se eliminan,y los nodos Identity que no están involucrados en los bordes de control se empalman para que sus entradas y salidas estén directamente conectadas.</target>
        </trans-unit>
        <trans-unit id="a4fe5597954ba439b4679d614be0e1e5164b606b" translate="yes" xml:space="preserve">
          <source>There are several delicate issues when running multiple threads that way: closing the queues in sequence as the input is exhausted, correctly catching and reporting exceptions, etc.</source>
          <target state="translated">Hay varias cuestiones delicadas cuando se ejecutan múltiples hilos de esa manera:cerrar las colas en secuencia a medida que se agota la entrada,captar e informar correctamente las excepciones,etc.</target>
        </trans-unit>
        <trans-unit id="20bc80fe9d0b075a12bc0575d2ba4a5d5fe1269d" translate="yes" xml:space="preserve">
          <source>There are several ways to run the conversion:</source>
          <target state="translated">Hay varias maneras de ejecutar la conversión:</target>
        </trans-unit>
        <trans-unit id="9a0c34e11b24dd273612b5e842b9ca3db6c2dc5f" translate="yes" xml:space="preserve">
          <source>There are three important concepts associated with TensorFlow Distributions shapes:</source>
          <target state="translated">Hay tres conceptos importantes asociados a las formas de distribución de TensorFlow:</target>
        </trans-unit>
        <trans-unit id="d89ee0299ae366416b4bb7507b2e32a19b6a4278" translate="yes" xml:space="preserve">
          <source>There are two APIs to create a &lt;a href=&quot;distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt; object: &lt;a href=&quot;strategy#experimental_distribute_dataset&quot;&gt;&lt;code&gt;tf.distribute.Strategy.experimental_distribute_dataset(dataset)&lt;/code&gt;&lt;/a&gt;and &lt;a href=&quot;strategy#experimental_distribute_datasets_from_function&quot;&gt;&lt;code&gt;tf.distribute.Strategy.experimental_distribute_datasets_from_function(dataset_fn)&lt;/code&gt;&lt;/a&gt;. &lt;em&gt;When to use which?&lt;/em&gt; When you have a &lt;a href=&quot;../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; instance, and the regular batch splitting (i.e. re-batch the input &lt;a href=&quot;../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; instance with a new batch size that is equal to the global batch size divided by the number of replicas in sync) and autosharding (i.e. the &lt;a href=&quot;../data/experimental/autoshardpolicy&quot;&gt;&lt;code&gt;tf.data.experimental.AutoShardPolicy&lt;/code&gt;&lt;/a&gt; options) work for you, use the former API. Otherwise, if you are &lt;em&gt;not&lt;/em&gt; using a canonical &lt;a href=&quot;../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; instance, or you would like to customize the batch splitting or sharding, you can wrap these logic in a &lt;code&gt;dataset_fn&lt;/code&gt; and use the latter API. Both API handles prefetch to device for the user. For more details and examples, follow the links to the APIs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b8f13eb2103d67ac4feee46d41de0d462019931" translate="yes" xml:space="preserve">
          <source>There are two main usages of a &lt;code&gt;DistributedDataset&lt;/code&gt; object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3536015a851856ea989836d31de530e9b064da8c" translate="yes" xml:space="preserve">
          <source>There are two means to control the logging verbosity:</source>
          <target state="translated">Hay dos medios para controlar la verborrea del registro:</target>
        </trans-unit>
        <trans-unit id="93dc11cfab5744c0fd203945e6587a775aa790bd" translate="yes" xml:space="preserve">
          <source>There are two modes under which the &lt;code&gt;TPUEmbedding&lt;/code&gt; class can used. This depends on if the class was created under a &lt;code&gt;TPUStrategy&lt;/code&gt; scope or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfe77a90ab442852a7e0e410775f1f4aa154097a" translate="yes" xml:space="preserve">
          <source>There are two possible return values, &quot;google&quot; (when TensorFlow is running in a Google-internal environment) or an empty string (when TensorFlow is running elsewhere).</source>
          <target state="translated">Hay dos posibles valores de retorno,&quot;google&quot; (cuando TensorFlow se ejecuta en un entorno interno de Google)o una cadena vacía (cuando TensorFlow se ejecuta en otro lugar).</target>
        </trans-unit>
        <trans-unit id="c121ae8dd46f0cedd4d9939e53220e70d1795c85" translate="yes" xml:space="preserve">
          <source>There are two questions to ask in the decision process: Do you need gradients computed as sparse too? Is your sparse data represented as two &lt;code&gt;SparseTensor&lt;/code&gt;s: ids and values? There is more explanation about data format below. If you answer any of these questions as yes, consider using &lt;a href=&quot;../nn/embedding_lookup_sparse&quot;&gt;&lt;code&gt;tf.nn.embedding_lookup_sparse&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Hay dos preguntas que hacer en el proceso de decisi&amp;oacute;n: &amp;iquest;Necesita que los gradientes tambi&amp;eacute;n se calculen como dispersos? &amp;iquest; &lt;code&gt;SparseTensor&lt;/code&gt; sus datos dispersos representados como dos SparseTensor s: ids y valores? Hay m&amp;aacute;s explicaciones sobre el formato de datos a continuaci&amp;oacute;n. Si responde afirmativamente a alguna de estas preguntas, considere usar &lt;a href=&quot;../nn/embedding_lookup_sparse&quot;&gt; &lt;code&gt;tf.nn.embedding_lookup_sparse&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0878716bd35f31f600ff16927cc66d2e1bdcca8d" translate="yes" xml:space="preserve">
          <source>There are two variants of the GRU implementation. The default one is based on &lt;a href=&quot;https://arxiv.org/abs/1406.1078v3&quot;&gt;v3&lt;/a&gt; and has reset gate applied to hidden state before matrix multiplication. The other one is based on &lt;a href=&quot;https://arxiv.org/abs/1406.1078v1&quot;&gt;original&lt;/a&gt; and has the order reversed.</source>
          <target state="translated">Hay dos variantes de la implementaci&amp;oacute;n de GRU. El predeterminado se basa en &lt;a href=&quot;https://arxiv.org/abs/1406.1078v3&quot;&gt;v3&lt;/a&gt; y tiene una puerta de reinicio aplicada al estado oculto antes de la multiplicaci&amp;oacute;n de matrices. El otro se basa en el &lt;a href=&quot;https://arxiv.org/abs/1406.1078v1&quot;&gt;original&lt;/a&gt; y tiene el orden inverso.</target>
        </trans-unit>
        <trans-unit id="f3d0da97f844d09b6bac8339000119f443c41934" translate="yes" xml:space="preserve">
          <source>There are two variants. The default one is based on 1406.1078v3 and has reset gate applied to hidden state before matrix multiplication. The other one is based on original 1406.1078v1 and has the order reversed.</source>
          <target state="translated">Hay dos variantes.La predeterminada se basa en 1406.1078v3 y tiene la puerta reseteada aplicada al estado oculto antes de la multiplicación de la matriz.La otra se basa en la versión original de 1406.1078v1 y tiene el orden invertido.</target>
        </trans-unit>
        <trans-unit id="f1e5ef8034bae35c3455bef5218f7a32bbdb1aa7" translate="yes" xml:space="preserve">
          <source>There are two versions of the API: 1 or 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19c11322b50f362088a37650ccaf3b2e479b115a" translate="yes" xml:space="preserve">
          <source>There are two versions of the API: ExportSavedModelApiVersion.V1 and V2.</source>
          <target state="translated">Hay dos versiones de la API:ExportSavedModelApiVersion.V1 y V2.</target>
        </trans-unit>
        <trans-unit id="c409af06e5c37c31d5d6e63ae53409968bb739b2" translate="yes" xml:space="preserve">
          <source>There are two ways to create decorators that TensorFlow can introspect into. This is important for documentation generation purposes, so that function signatures aren't obscured by the (*args, **kwds) signature that decorators often provide.</source>
          <target state="translated">Hay dos formas de crear decoradores en los que TensorFlow puede introspectar.Esto es importante para la generación de documentación,para que las firmas de las funciones no se vean oscurecidas por la (*args,**kwds)firma que los decoradores suelen proporcionar.</target>
        </trans-unit>
        <trans-unit id="49196c8dfb0588201d8b9733a14917623170a741" translate="yes" xml:space="preserve">
          <source>There are two ways to instantiate a &lt;code&gt;Model&lt;/code&gt;:</source>
          <target state="translated">Hay dos formas de crear una instancia de un &lt;code&gt;Model&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a3e498654dcff830e5be467e55fbbbbc20e2910f" translate="yes" xml:space="preserve">
          <source>There are two ways to use the moving averages for evaluations:</source>
          <target state="translated">Hay dos maneras de utilizar los promedios móviles para las evaluaciones:</target>
        </trans-unit>
        <trans-unit id="14b50269ad70f1441184d03f5b9e983ae0e09462" translate="yes" xml:space="preserve">
          <source>There is a special node with &lt;code&gt;task_type&lt;/code&gt; as &lt;code&gt;evaluator&lt;/code&gt;, which is not part of the (training) &lt;code&gt;cluster_spec&lt;/code&gt;. It handles the distributed evaluation job.</source>
          <target state="translated">Hay un nodo especial con &lt;code&gt;task_type&lt;/code&gt; como &lt;code&gt;evaluator&lt;/code&gt; , que no forma parte de la (formaci&amp;oacute;n) &lt;code&gt;cluster_spec&lt;/code&gt; . Maneja el trabajo de evaluaci&amp;oacute;n distribuida.</target>
        </trans-unit>
        <trans-unit id="ff5a342ad76b4f6dbc02bde4742c1939d0847ee4" translate="yes" xml:space="preserve">
          <source>There is also a global generator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0a273890eb3544a6c0002e05e862f10bbfd245d" translate="yes" xml:space="preserve">
          <source>There is an equivalent description in terms of the [batch] spectrum &lt;code&gt;H&lt;/code&gt; and Fourier transforms. Here we consider &lt;code&gt;A.shape = [N, N]&lt;/code&gt; and ignore batch dimensions.</source>
          <target state="translated">Existe una descripci&amp;oacute;n equivalente en t&amp;eacute;rminos del espectro [por lotes] &lt;code&gt;H&lt;/code&gt; y transformadas de Fourier. Aqu&amp;iacute; consideramos &lt;code&gt;A.shape = [N, N]&lt;/code&gt; e ignoramos las dimensiones del lote.</target>
        </trans-unit>
        <trans-unit id="34b53209d83711d378deaa8b481a2f90355eb0e3" translate="yes" xml:space="preserve">
          <source>There is an equivalent description in terms of the [batch] spectrum &lt;code&gt;H&lt;/code&gt; and Fourier transforms. Here we consider &lt;code&gt;A.shape = [N, N]&lt;/code&gt; and ignore batch dimensions. Define the discrete Fourier transform (DFT) and its inverse by</source>
          <target state="translated">Existe una descripci&amp;oacute;n equivalente en t&amp;eacute;rminos del espectro [por lotes] &lt;code&gt;H&lt;/code&gt; y transformadas de Fourier. Aqu&amp;iacute; consideramos &lt;code&gt;A.shape = [N, N]&lt;/code&gt; e ignoramos las dimensiones del lote. Defina la transformada discreta de Fourier (DFT) y su inversa por</target>
        </trans-unit>
        <trans-unit id="70db84bf8987013d7aeb820bf2eec70af7a073ca" translate="yes" xml:space="preserve">
          <source>There is no need to delete the directory after the test.</source>
          <target state="translated">No hay necesidad de borrar el directorio después de la prueba.</target>
        </trans-unit>
        <trans-unit id="897a9d5198f512dcaeb305f37bd31486ee120960" translate="yes" xml:space="preserve">
          <source>There is no transformation in the &lt;a href=&quot;../data&quot;&gt;&lt;code&gt;tf.data&lt;/code&gt;&lt;/a&gt; Python API for creating this dataset. Instead, it is created as a result of the &lt;code&gt;filter_with_random_uniform_fusion&lt;/code&gt; static optimization. Whether this optimization is performed is determined by the &lt;code&gt;experimental_optimization.filter_with_random_uniform_fusion&lt;/code&gt; option of &lt;a href=&quot;../data/options&quot;&gt;&lt;code&gt;tf.data.Options&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b246461630b3c81ed498d37ca7dc4b93263133aa" translate="yes" xml:space="preserve">
          <source>There is often a need to lift variable initialization ops out of control-flow scopes, function-building graphs, and gradient tapes. Entering an &lt;code&gt;init_scope&lt;/code&gt; is a mechanism for satisfying these desiderata. In particular, entering an &lt;code&gt;init_scope&lt;/code&gt; has three effects:</source>
          <target state="translated">A menudo es necesario eliminar las operaciones de inicializaci&amp;oacute;n de variables de los &amp;aacute;mbitos de flujo de control, los gr&amp;aacute;ficos de creaci&amp;oacute;n de funciones y las cintas de degradado. Ingresar un &lt;code&gt;init_scope&lt;/code&gt; es un mecanismo para satisfacer estos desiderata. En particular, ingresar un &lt;code&gt;init_scope&lt;/code&gt; tiene tres efectos:</target>
        </trans-unit>
        <trans-unit id="9600bed3adf3351d3b6785f43a000c7d51f5ddee" translate="yes" xml:space="preserve">
          <source>There is one exception: if the final (i.e., innermost) element(s) of &lt;code&gt;partitions&lt;/code&gt; are &lt;code&gt;UniformRowLength&lt;/code&gt;s, then the values are simply reshaped (as a higher-dimensional &lt;a href=&quot;../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;), rather than being wrapped in a &lt;a href=&quot;../raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Hay una excepci&amp;oacute;n: si los elementos finales (es decir, los m&amp;aacute;s internos) de las &lt;code&gt;partitions&lt;/code&gt; son &lt;code&gt;UniformRowLength&lt;/code&gt; s, entonces los valores simplemente se reforman (como un &lt;a href=&quot;../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; de&lt;/a&gt; dimensi&amp;oacute;n superior ), en lugar de estar envueltos en un &lt;a href=&quot;../raggedtensor&quot;&gt; &lt;code&gt;tf.RaggedTensor&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b0e762e9fe47e7a8aaa65fed7f11b0b738414c89" translate="yes" xml:space="preserve">
          <source>There should be no data dependency between the different semantic invocations of &lt;code&gt;fn&lt;/code&gt;, i.e. it should be safe to map the elements of the inputs in any order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69f7128e30301479f7dbfc0ac8f483f3d6d00a4d" translate="yes" xml:space="preserve">
          <source>Therefore we introduce some decoupling using a queue. The queue contains the work units and the Reader dequeues from the queue when it is asked to produce a record (via Read()) but it has finished the last work unit.</source>
          <target state="translated">Por lo tanto,introducimos un desacoplamiento usando una cola.La cola contiene las unidades de trabajo y el lector se pone en cola cuando se le pide que produzca un registro (vía Read())pero ha terminado la última unidad de trabajo.</target>
        </trans-unit>
        <trans-unit id="86cd25893d67c9049a975fb7c203728b1fcc6c8b" translate="yes" xml:space="preserve">
          <source>These are arguments passed to the optimizer subclass constructor (the &lt;code&gt;__init__&lt;/code&gt; method), and then passed to &lt;code&gt;self._set_hyper()&lt;/code&gt;. They can be either regular Python values (like 1.0), tensors, or callables. If they are callable, the callable will be called during &lt;code&gt;apply_gradients()&lt;/code&gt; to get the value for the hyper parameter.</source>
          <target state="translated">Estos son argumentos pasados ​​al constructor de la subclase del optimizador (el m&amp;eacute;todo &lt;code&gt;__init__&lt;/code&gt; ), y luego pasados ​​a &lt;code&gt;self._set_hyper()&lt;/code&gt; . Pueden ser valores Python regulares (como 1.0), tensores o invocables. Si son invocables, se llamar&amp;aacute; al invocable durante &lt;code&gt;apply_gradients()&lt;/code&gt; para obtener el valor del hiperpar&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="d1eefae8eebd09f04dd361373c7c577f0cf1144d" translate="yes" xml:space="preserve">
          <source>These conversion options are experimental. They are subject to change without notice and offer no guarantees.</source>
          <target state="translated">Estas opciones de conversión son experimentales.Están sujetas a cambios sin previo aviso y no ofrecen garantías.</target>
        </trans-unit>
        <trans-unit id="c291964ed47da0b87e8a53387f07ca95b28e890c" translate="yes" xml:space="preserve">
          <source>These indices specify where the values for each row begin in &lt;code&gt;self.values&lt;/code&gt;. &lt;code&gt;rt.row_starts()&lt;/code&gt; is equal to &lt;code&gt;rt.row_splits[:-1]&lt;/code&gt;.</source>
          <target state="translated">Estos &amp;iacute;ndices especifican d&amp;oacute;nde comienzan los valores de cada fila en &lt;code&gt;self.values&lt;/code&gt; . &lt;code&gt;rt.row_starts()&lt;/code&gt; es igual a &lt;code&gt;rt.row_splits[:-1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99b0058dc30c77b214aebabddab907af2da4a216" translate="yes" xml:space="preserve">
          <source>These indices specify where the values for each row end in &lt;code&gt;self.values&lt;/code&gt;. &lt;code&gt;rt.row_limits(self)&lt;/code&gt; is equal to &lt;code&gt;rt.row_splits[:-1]&lt;/code&gt;.</source>
          <target state="translated">Estos &amp;iacute;ndices especifican d&amp;oacute;nde terminan los valores de cada fila en &lt;code&gt;self.values&lt;/code&gt; . &lt;code&gt;rt.row_limits(self)&lt;/code&gt; es igual a &lt;code&gt;rt.row_splits[:-1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23fdcaa94183d818b1595f88d3e5484cc7528a37" translate="yes" xml:space="preserve">
          <source>These layers expose 3 keyword arguments:</source>
          <target state="translated">Estas capas exponen 3 argumentos de palabras clave:</target>
        </trans-unit>
        <trans-unit id="76c2c66d43654cd0b29da8b2ca646058c82ed16b" translate="yes" xml:space="preserve">
          <source>These might be stored sparsely in the following Example protos by storing only the feature ids (column number if the vectors are treated as a matrix) of the non-zero elements and the corresponding values:</source>
          <target state="translated">Éstos podrían almacenarse escasamente en las siguientes protos de ejemplo almacenando sólo los identificadores de características (número de columna si los vectores se tratan como una matriz)de los elementos que no son cero y los valores correspondientes:</target>
        </trans-unit>
        <trans-unit id="e47f03b2a63c4e509a81c6c7d3f37f7d1be1a857" translate="yes" xml:space="preserve">
          <source>These sufficient statistics are computed using the one pass algorithm on an input that's optionally shifted. See: &lt;a href=&quot;https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Computing_shifted_data&quot;&gt;https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Computing_shifted_data&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df0616278e0670c1f8a838c05616c2906a5ad628" translate="yes" xml:space="preserve">
          <source>These sufficient statistics are computed using the one pass algorithm on an input that's optionally shifted. See: https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Computing_shifted_data</source>
          <target state="translated">Estas estadísticas suficientes se calculan usando el algoritmo de una sola pasada en una entrada que es opcionalmente desplazada.Véase:https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Computing_shifted_data</target>
        </trans-unit>
        <trans-unit id="5c983cdacd0a0593413a5e4ab438ec1b6414a3f5" translate="yes" xml:space="preserve">
          <source>These typically correspond to model heads.</source>
          <target state="translated">Estas típicamente corresponden a cabezas de modelo.</target>
        </trans-unit>
        <trans-unit id="a2e13849b656ad081d144e8fb21e76af2be31973" translate="yes" xml:space="preserve">
          <source>These values are similar to values from a &lt;code&gt;random_normal_initializer&lt;/code&gt; except that values more than two standard deviations from the mean are discarded and re-drawn. This is the recommended initializer for neural network weights and filters.</source>
          <target state="translated">Estos valores son similares a los valores de un &lt;code&gt;random_normal_initializer&lt;/code&gt; excepto que los valores de m&amp;aacute;s de dos desviaciones est&amp;aacute;ndar de la media se descartan y se vuelven a dibujar. Este es el inicializador recomendado para filtros y pesos de redes neuronales.</target>
        </trans-unit>
        <trans-unit id="6f69d15ae681fb68548cb2f0cf5da97b8f2f416c" translate="yes" xml:space="preserve">
          <source>They are not resettable. Once a one-shot iterator reaches the end of its underlying dataset, subsequent &quot;IteratorGetNext&quot; operations on that iterator will always produce an &lt;code&gt;OutOfRange&lt;/code&gt; error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82a7de6a736dfa8a46716669d941754c78b26714" translate="yes" xml:space="preserve">
          <source>They do not support parameterization: all logic for creating the underlying dataset must be bundled in the &lt;code&gt;dataset_factory&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="035fa9e40dd64ae60fe7c5634de4cc5ea73a82db" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;LinearOperator&lt;/code&gt; is initialized to have shape &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; by providing &lt;code&gt;spectrum&lt;/code&gt;, a &lt;code&gt;[B1,...,Bb, N0, N1, N2]&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; with &lt;code&gt;N0*N1*N2 = N&lt;/code&gt;.</source>
          <target state="translated">Este &lt;code&gt;LinearOperator&lt;/code&gt; se inicializa a tener forma &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; proporcionando &lt;code&gt;spectrum&lt;/code&gt; , un &lt;code&gt;[B1,...,Bb, N0, N1, N2]&lt;/code&gt; &lt;code&gt;Tensor&lt;/code&gt; con &lt;code&gt;N0*N1*N2 = N&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7dc76893f409505eb4af8e3ca9d9b50f0907d32c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;LinearOperator&lt;/code&gt; is initialized to have shape &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; by providing &lt;code&gt;spectrum&lt;/code&gt;, a &lt;code&gt;[B1,...,Bb, N0, N1]&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; with &lt;code&gt;N0*N1 = N&lt;/code&gt;.</source>
          <target state="translated">Este &lt;code&gt;LinearOperator&lt;/code&gt; se inicializa a tener forma &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; proporcionando &lt;code&gt;spectrum&lt;/code&gt; , un &lt;code&gt;[B1,...,Bb, N0, N1]&lt;/code&gt; &lt;code&gt;Tensor&lt;/code&gt; con &lt;code&gt;N0*N1 = N&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45faa2260146699c38e2dafd91d1b8425180a30a" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;LinearOperator&lt;/code&gt; is initialized to have shape &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; by providing &lt;code&gt;spectrum&lt;/code&gt;, a &lt;code&gt;[B1,...,Bb, N]&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="translated">Este &lt;code&gt;LinearOperator&lt;/code&gt; se inicializa para que tenga la forma &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; proporcionando &lt;code&gt;spectrum&lt;/code&gt; , un &lt;code&gt;Tensor&lt;/code&gt; &lt;code&gt;[B1,...,Bb, N]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14d38c8190663bcf5aee0e569e1c9fa815f97d9a" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;LinearOperator&lt;/code&gt; is initialized with boolean flags of the form &lt;code&gt;is_X&lt;/code&gt;, for &lt;code&gt;X = non_singular, self_adjoint, positive_definite, square&lt;/code&gt;. These have the following meaning</source>
          <target state="translated">Este &lt;code&gt;LinearOperator&lt;/code&gt; se inicializa con indicadores booleanos de la forma &lt;code&gt;is_X&lt;/code&gt; , para &lt;code&gt;X = non_singular, self_adjoint, positive_definite, square&lt;/code&gt; . Estos tienen el siguiente significado</target>
        </trans-unit>
        <trans-unit id="59e2aeacdf121218eb0206f7223d277271e20ff4" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;LinearOperator&lt;/code&gt; is initialized with boolean flags of the form &lt;code&gt;is_X&lt;/code&gt;, for &lt;code&gt;X = non_singular, self_adjoint, positive_definite, square&lt;/code&gt;. These have the following meaning:</source>
          <target state="translated">Este &lt;code&gt;LinearOperator&lt;/code&gt; se inicializa con indicadores booleanos de la forma &lt;code&gt;is_X&lt;/code&gt; , para &lt;code&gt;X = non_singular, self_adjoint, positive_definite, square&lt;/code&gt; . Estos tienen el siguiente significado:</target>
        </trans-unit>
        <trans-unit id="c893a77a5cadc49b62c18f0fba68970cb1dcbaf6" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;LinearOperator&lt;/code&gt; is initialized with boolean flags of the form &lt;code&gt;is_X&lt;/code&gt;, for &lt;code&gt;X = non_singular&lt;/code&gt;, &lt;code&gt;self_adjoint&lt;/code&gt;, &lt;code&gt;positive_definite&lt;/code&gt;, &lt;code&gt;diag_update_positive&lt;/code&gt; and &lt;code&gt;square&lt;/code&gt;. These have the following meaning:</source>
          <target state="translated">Este &lt;code&gt;LinearOperator&lt;/code&gt; se inicializa con indicadores booleanos de la forma &lt;code&gt;is_X&lt;/code&gt; , para &lt;code&gt;X = non_singular&lt;/code&gt; , &lt;code&gt;self_adjoint&lt;/code&gt; , &lt;code&gt;positive_definite&lt;/code&gt; , &lt;code&gt;diag_update_positive&lt;/code&gt; y &lt;code&gt;square&lt;/code&gt; . Estos tienen el siguiente significado:</target>
        </trans-unit>
        <trans-unit id="1af767d14077ff11d4e7fc9b014e22bbf1d448de" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;Model&lt;/code&gt; has a dependency named &quot;input_transform&quot; on its &lt;code&gt;Dense&lt;/code&gt; layer, which in turn depends on its variables. As a result, saving an instance of &lt;code&gt;Regress&lt;/code&gt; using &lt;a href=&quot;../../../train/checkpoint&quot;&gt;&lt;code&gt;tf.train.Checkpoint&lt;/code&gt;&lt;/a&gt; will also save all the variables created by the &lt;code&gt;Dense&lt;/code&gt; layer.</source>
          <target state="translated">Este &lt;code&gt;Model&lt;/code&gt; tiene una dependencia denominada &quot;input_transform&quot; en su capa &lt;code&gt;Dense&lt;/code&gt; , que a su vez depende de sus variables. Como resultado, guardar una instancia de &lt;code&gt;Regress&lt;/code&gt; usando &lt;a href=&quot;../../../train/checkpoint&quot;&gt; &lt;code&gt;tf.train.Checkpoint&lt;/code&gt; &lt;/a&gt; tambi&amp;eacute;n guardar&amp;aacute; todas las variables creadas por la capa &lt;code&gt;Dense&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bb0cfce4d3ef61c634cae7fd40aef46d6d26e65" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;Model&lt;/code&gt; has a dependency named &quot;input_transform&quot; on its &lt;code&gt;Dense&lt;/code&gt; layer, which in turn depends on its variables. As a result, saving an instance of &lt;code&gt;Regress&lt;/code&gt; using &lt;a href=&quot;checkpoint&quot;&gt;&lt;code&gt;tf.train.Checkpoint&lt;/code&gt;&lt;/a&gt; will also save all the variables created by the &lt;code&gt;Dense&lt;/code&gt; layer.</source>
          <target state="translated">Este &lt;code&gt;Model&lt;/code&gt; tiene una dependencia denominada &quot;input_transform&quot; en su capa &lt;code&gt;Dense&lt;/code&gt; , que a su vez depende de sus variables. Como resultado, guardar una instancia de &lt;code&gt;Regress&lt;/code&gt; usando &lt;a href=&quot;checkpoint&quot;&gt; &lt;code&gt;tf.train.Checkpoint&lt;/code&gt; &lt;/a&gt; tambi&amp;eacute;n guardar&amp;aacute; todas las variables creadas por la capa &lt;code&gt;Dense&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5871012b5796b5a485fbd2ea90e6e96dc8a6361" translate="yes" xml:space="preserve">
          <source>This API allows querying the physical hardware resources prior to runtime initialization. Thus, giving an opportunity to call any additional configuration APIs. This is in contrast to &lt;a href=&quot;list_logical_devices&quot;&gt;&lt;code&gt;tf.config.list_logical_devices&lt;/code&gt;&lt;/a&gt;, which triggers runtime initialization in order to list the configured devices.</source>
          <target state="translated">Esta API permite consultar los recursos f&amp;iacute;sicos de hardware antes de la inicializaci&amp;oacute;n del tiempo de ejecuci&amp;oacute;n. Por lo tanto, brinda la oportunidad de llamar a cualquier API de configuraci&amp;oacute;n adicional. Esto contrasta con &lt;a href=&quot;list_logical_devices&quot;&gt; &lt;code&gt;tf.config.list_logical_devices&lt;/code&gt; &lt;/a&gt; , que activa la inicializaci&amp;oacute;n del tiempo de ejecuci&amp;oacute;n para listar los dispositivos configurados.</target>
        </trans-unit>
        <trans-unit id="74aac56e82063765baca7f72b6ef73462943063c" translate="yes" xml:space="preserve">
          <source>This API enables repeated preprocessing steps to be consolidated, and allows re-use of already processed data, trading off disk storage and network bandwidth for freeing up more valuable CPU resources and accelerator compute time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="762aea1a89e9b0e55d82633b7d3d567f5d2f187d" translate="yes" xml:space="preserve">
          <source>This API takes in a &lt;a href=&quot;../physicaldevice&quot;&gt;&lt;code&gt;tf.config.PhysicalDevice&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;../list_physical_devices&quot;&gt;&lt;code&gt;tf.config.list_physical_devices&lt;/code&gt;&lt;/a&gt;. It returns a dict with string keys containing various details about the device. Each key is only supported by a subset of devices, so you should not assume the returned dict will have any particular key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22207bc9bfb65faecbe8df80de09b7c7ff71edfd" translate="yes" xml:space="preserve">
          <source>This API will connect to remote TPU cluster and initialize the TPU hardwares. Example usage:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb9102764cadc1d75fc4b0e80481d3d9ed63d68c" translate="yes" xml:space="preserve">
          <source>This Estimator implements the following variants of the K-means algorithm:</source>
          <target state="translated">Este Estimador implementa las siguientes variantes del algoritmo K-means:</target>
        </trans-unit>
        <trans-unit id="80c1b7fb2eecacd5d699b9ee230de5704ca37c8d" translate="yes" xml:space="preserve">
          <source>This Multinomial distribution is parameterized by &lt;code&gt;probs&lt;/code&gt;, a (batch of) length-&lt;code&gt;K&lt;/code&gt;&lt;code&gt;prob&lt;/code&gt; (probability) vectors (&lt;code&gt;K &amp;gt; 1&lt;/code&gt;) such that &lt;code&gt;tf.reduce_sum(probs, -1) = 1&lt;/code&gt;, and a &lt;code&gt;total_count&lt;/code&gt; number of trials, i.e., the number of trials per draw from the Multinomial. It is defined over a (batch of) length-&lt;code&gt;K&lt;/code&gt; vector &lt;code&gt;counts&lt;/code&gt; such that &lt;code&gt;tf.reduce_sum(counts, -1) = total_count&lt;/code&gt;. The Multinomial is identically the Binomial distribution when &lt;code&gt;K = 2&lt;/code&gt;.</source>
          <target state="translated">Esta distribuci&amp;oacute;n multinomial est&amp;aacute; parametrizada por &lt;code&gt;probs&lt;/code&gt; , un (lote de) longitud- &lt;code&gt;K&lt;/code&gt; &lt;code&gt;prob&lt;/code&gt; (probabilidad) vectores ( &lt;code&gt;K &amp;gt; 1&lt;/code&gt; ) tal que &lt;code&gt;tf.reduce_sum(probs, -1) = 1&lt;/code&gt; , y un n&amp;uacute;mero &lt;code&gt;total_count&lt;/code&gt; de ensayos, es decir, el n&amp;uacute;mero de ensayos por sorteo del Multinomial. Se define sobre un (lote de) longitud: &lt;code&gt;K&lt;/code&gt; &lt;code&gt;counts&lt;/code&gt; vectores de manera que &lt;code&gt;tf.reduce_sum(counts, -1) = total_count&lt;/code&gt; . El Multinomial es id&amp;eacute;nticamente la distribuci&amp;oacute;n Binomial cuando &lt;code&gt;K = 2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61586b843c2a7242a7ce5f726a415d728d094add" translate="yes" xml:space="preserve">
          <source>This Op also supports repeated indices in the output subscript, which is not supported by &lt;code&gt;numpy.einsum&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0c42e63acc7dcc7eea605a766b11674d1c53e82" translate="yes" xml:space="preserve">
          <source>This Op checks that &lt;code&gt;x[i] != y[i]&lt;/code&gt; holds for every pair of (possibly broadcast) elements of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">Esta operaci&amp;oacute;n verifica que &lt;code&gt;x[i] != y[i]&lt;/code&gt; cumple para cada par de elementos (posiblemente transmitidos) de &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; . Si tanto &lt;code&gt;x&lt;/code&gt; como &lt;code&gt;y&lt;/code&gt; est&amp;aacute;n vac&amp;iacute;os, esto se satisface trivialmente.</target>
        </trans-unit>
        <trans-unit id="74ec1aa4f8491ea53037a0fc532d4741eb9218bd" translate="yes" xml:space="preserve">
          <source>This Op checks that &lt;code&gt;x[i] &amp;gt; 0&lt;/code&gt; holds for every element of &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is empty, this is trivially satisfied.</source>
          <target state="translated">Esta operaci&amp;oacute;n comprueba que &lt;code&gt;x[i] &amp;gt; 0&lt;/code&gt; cumple para cada elemento de &lt;code&gt;x&lt;/code&gt; . Si &lt;code&gt;x&lt;/code&gt; est&amp;aacute; vac&amp;iacute;o, esto se satisface trivialmente.</target>
        </trans-unit>
        <trans-unit id="64284c5803db04a210d1a9048bfe82459a849a9d" translate="yes" xml:space="preserve">
          <source>This Op checks that &lt;code&gt;x[i] &amp;gt; y[i]&lt;/code&gt; holds for every pair of (possibly broadcast) elements of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">Esta operaci&amp;oacute;n comprueba que &lt;code&gt;x[i] &amp;gt; y[i]&lt;/code&gt; cumple para cada par de elementos (posiblemente difundidos) de &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; . Si tanto &lt;code&gt;x&lt;/code&gt; como &lt;code&gt;y&lt;/code&gt; est&amp;aacute;n vac&amp;iacute;os, esto se satisface trivialmente.</target>
        </trans-unit>
        <trans-unit id="382c384f5bde2874efffdf9480af145ba234b875" translate="yes" xml:space="preserve">
          <source>This Op checks that &lt;code&gt;x[i] &amp;gt;= 0&lt;/code&gt; holds for every element of &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is empty, this is trivially satisfied.</source>
          <target state="translated">Esta Op comprueba que &lt;code&gt;x[i] &amp;gt;= 0&lt;/code&gt; cumple para cada elemento de &lt;code&gt;x&lt;/code&gt; . Si &lt;code&gt;x&lt;/code&gt; est&amp;aacute; vac&amp;iacute;o, esto se satisface trivialmente.</target>
        </trans-unit>
        <trans-unit id="501dbba0dad9772b46dd6dbe6d32dfc34b3073e4" translate="yes" xml:space="preserve">
          <source>This Op checks that &lt;code&gt;x[i] &amp;gt;= y[i]&lt;/code&gt; holds for every pair of (possibly broadcast) elements of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">Esta operaci&amp;oacute;n verifica que &lt;code&gt;x[i] &amp;gt;= y[i]&lt;/code&gt; cumple para cada par de elementos (posiblemente transmitidos) de &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; . Si tanto &lt;code&gt;x&lt;/code&gt; como &lt;code&gt;y&lt;/code&gt; est&amp;aacute;n vac&amp;iacute;os, esto se satisface trivialmente.</target>
        </trans-unit>
        <trans-unit id="86a98c771b136d5122e127f8b045988c2c9039d5" translate="yes" xml:space="preserve">
          <source>This Op checks that &lt;code&gt;x[i] &amp;lt; 0&lt;/code&gt; holds for every element of &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is empty, this is trivially satisfied.</source>
          <target state="translated">Esta operaci&amp;oacute;n comprueba que &lt;code&gt;x[i] &amp;lt; 0&lt;/code&gt; cumple para cada elemento de &lt;code&gt;x&lt;/code&gt; . Si &lt;code&gt;x&lt;/code&gt; est&amp;aacute; vac&amp;iacute;o, esto se satisface trivialmente.</target>
        </trans-unit>
        <trans-unit id="a26f9f0c29e64714922c2bda7e956bffe84f5c0c" translate="yes" xml:space="preserve">
          <source>This Op checks that &lt;code&gt;x[i] &amp;lt; y[i]&lt;/code&gt; holds for every pair of (possibly broadcast) elements of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">Esta operaci&amp;oacute;n comprueba que &lt;code&gt;x[i] &amp;lt; y[i]&lt;/code&gt; cumple para cada par de elementos (posiblemente difundidos) de &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; . Si tanto &lt;code&gt;x&lt;/code&gt; como &lt;code&gt;y&lt;/code&gt; est&amp;aacute;n vac&amp;iacute;os, esto se satisface trivialmente.</target>
        </trans-unit>
        <trans-unit id="c63795d0aad1b74648e6a4624d3ec74f6c7d4a1e" translate="yes" xml:space="preserve">
          <source>This Op checks that &lt;code&gt;x[i] &amp;lt;= 0&lt;/code&gt; holds for every element of &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is empty, this is trivially satisfied.</source>
          <target state="translated">Esta operaci&amp;oacute;n verifica que &lt;code&gt;x[i] &amp;lt;= 0&lt;/code&gt; v&amp;aacute;lido para cada elemento de &lt;code&gt;x&lt;/code&gt; . Si &lt;code&gt;x&lt;/code&gt; est&amp;aacute; vac&amp;iacute;o, esto se satisface trivialmente.</target>
        </trans-unit>
        <trans-unit id="52d38297a91871d25885ecc0eb75b01217f176df" translate="yes" xml:space="preserve">
          <source>This Op checks that &lt;code&gt;x[i] &amp;lt;= y[i]&lt;/code&gt; holds for every pair of (possibly broadcast) elements of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">Esta operaci&amp;oacute;n comprueba que &lt;code&gt;x[i] &amp;lt;= y[i]&lt;/code&gt; cumple para cada par de elementos (posiblemente difundidos) de &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; . Si tanto &lt;code&gt;x&lt;/code&gt; como &lt;code&gt;y&lt;/code&gt; est&amp;aacute;n vac&amp;iacute;os, esto se satisface trivialmente.</target>
        </trans-unit>
        <trans-unit id="a274dbd07debbab7fc4511fde87c45ce7dd5f11a" translate="yes" xml:space="preserve">
          <source>This Op checks that &lt;code&gt;x[i] - y[i] &amp;lt; atol + rtol * tf.abs(y[i])&lt;/code&gt; holds for every pair of (possibly broadcast) elements of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">Esta operaci&amp;oacute;n verifica que &lt;code&gt;x[i] - y[i] &amp;lt; atol + rtol * tf.abs(y[i])&lt;/code&gt; cumple para cada par de elementos (posiblemente transmitidos) de &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; . Si tanto &lt;code&gt;x&lt;/code&gt; como &lt;code&gt;y&lt;/code&gt; est&amp;aacute;n vac&amp;iacute;os, esto se satisface trivialmente.</target>
        </trans-unit>
        <trans-unit id="afe67f7444ede4a73d34ba9ae37a78f686f755dd" translate="yes" xml:space="preserve">
          <source>This Op checks that &lt;code&gt;x[i] == y[i]&lt;/code&gt; holds for every pair of (possibly broadcast) elements of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">Esta operaci&amp;oacute;n comprueba que &lt;code&gt;x[i] == y[i]&lt;/code&gt; cumple para cada par de elementos (posiblemente transmitidos) de &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; . Si tanto &lt;code&gt;x&lt;/code&gt; como &lt;code&gt;y&lt;/code&gt; est&amp;aacute;n vac&amp;iacute;os, esto se satisface trivialmente.</target>
        </trans-unit>
        <trans-unit id="47fcdf77a806254f145cef6045f72f7418b87096" translate="yes" xml:space="preserve">
          <source>This Op checks that a collection of tensors shape relationships satisfies given constraints.</source>
          <target state="translated">Esta operación comprueba que un conjunto de tensores que conforman las relaciones satisfacen determinadas limitaciones.</target>
        </trans-unit>
        <trans-unit id="70d8b32973294baa04c2b6c2343f69d0d35b251b" translate="yes" xml:space="preserve">
          <source>This Op checks that the rank of &lt;code&gt;x&lt;/code&gt; is equal to &lt;code&gt;rank&lt;/code&gt;.</source>
          <target state="translated">Esta operaci&amp;oacute;n verifica que el rango de &lt;code&gt;x&lt;/code&gt; sea ​​igual al &lt;code&gt;rank&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45bf526016d2ed135926c16509b05dd90dd8b920" translate="yes" xml:space="preserve">
          <source>This Op checks that the rank of &lt;code&gt;x&lt;/code&gt; is greater or equal to &lt;code&gt;rank&lt;/code&gt;.</source>
          <target state="translated">Esta operaci&amp;oacute;n verifica que el rango de &lt;code&gt;x&lt;/code&gt; sea ​​mayor o igual al &lt;code&gt;rank&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef8abcb7ef7c82e56e48acf10aee7a915b661e8e" translate="yes" xml:space="preserve">
          <source>This Op checks that the rank of &lt;code&gt;x&lt;/code&gt; is in &lt;code&gt;ranks&lt;/code&gt;.</source>
          <target state="translated">Esta operaci&amp;oacute;n verifica que el rango de &lt;code&gt;x&lt;/code&gt; est&amp;eacute; en &lt;code&gt;ranks&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9bbbc71838cec9daa4b798c766e634988ae8eda0" translate="yes" xml:space="preserve">
          <source>This Op does not require &lt;code&gt;a_indices&lt;/code&gt; be sorted in standard lexicographic order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="995662dbb5ee7bd63655bfa102038ae50bbbb546" translate="yes" xml:space="preserve">
          <source>This Op does not support implicit form. (i.e. equations without &lt;code&gt;-&amp;gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b037dc8de7a8b2184874f7694988339f20126019" translate="yes" xml:space="preserve">
          <source>This Op eases the porting of code that uses embedding_lookup_sparse(), although some Python preprocessing of the SparseTensor arguments to embedding_lookup_sparse() is required to produce the arguments to this Op, since only a single EnqueueTPUEmbeddingSparseBatch Op is allowed per training step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3230f00e0154436022761e6b1f967d770055298" translate="yes" xml:space="preserve">
          <source>This Op first attempts to find the V2 index file pointed to by &quot;prefix&quot;, and if found proceed to read it as a V2 checkpoint;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ed5e982672256e8ea90d7bd0d72e83dbb1172c0" translate="yes" xml:space="preserve">
          <source>This Op only supports unary and binary forms of &lt;code&gt;numpy.einsum&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="793a60433b6712b8062346cc2fb3747282971aed" translate="yes" xml:space="preserve">
          <source>This Op picks a random location in &lt;code&gt;image&lt;/code&gt; and crops a &lt;code&gt;height&lt;/code&gt; by &lt;code&gt;width&lt;/code&gt; rectangle from that location. The random location is picked so the cropped area will fit inside the original image.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="214a679e138acba179edb8672f1201325c1e87b6" translate="yes" xml:space="preserve">
          <source>This Op produces a set of TPU cores (for warm-up) or a single TPU core (for regular inference) to execute the TPU program on. The output is consumed by TPUPartitionedCall.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1956a13a2a0626040a0d05adca12d21c39b428f4" translate="yes" xml:space="preserve">
          <source>This Op takes a SparseTensor and is the sparse counterpart to &lt;a href=&quot;../../math/reduce_max&quot;&gt;&lt;code&gt;tf.reduce_max()&lt;/code&gt;&lt;/a&gt;. In contrast to SparseReduceSum, this Op returns a SparseTensor.</source>
          <target state="translated">Esta operaci&amp;oacute;n toma un SparseTensor y es la contraparte dispersa de &lt;a href=&quot;../../math/reduce_max&quot;&gt; &lt;code&gt;tf.reduce_max()&lt;/code&gt; &lt;/a&gt; . A diferencia de SparseReduceSum, esta Op devuelve un SparseTensor.</target>
        </trans-unit>
        <trans-unit id="21543202b1cccf9199ac85ba0b6367bb37a43438" translate="yes" xml:space="preserve">
          <source>This Op takes a SparseTensor and is the sparse counterpart to &lt;a href=&quot;../../math/reduce_max&quot;&gt;&lt;code&gt;tf.reduce_max()&lt;/code&gt;&lt;/a&gt;. In particular, this Op also returns a dense &lt;code&gt;Tensor&lt;/code&gt; instead of a sparse one.</source>
          <target state="translated">Esta operaci&amp;oacute;n toma un SparseTensor y es la contraparte dispersa de &lt;a href=&quot;../../math/reduce_max&quot;&gt; &lt;code&gt;tf.reduce_max()&lt;/code&gt; &lt;/a&gt; . En particular, esta Op tambi&amp;eacute;n devuelve un &lt;code&gt;Tensor&lt;/code&gt; denso en lugar de uno escaso.</target>
        </trans-unit>
        <trans-unit id="a92cf7c266fad63ba2ede16d013a7954c0a3ed23" translate="yes" xml:space="preserve">
          <source>This Op takes a SparseTensor and is the sparse counterpart to &lt;a href=&quot;../../math/reduce_sum&quot;&gt;&lt;code&gt;tf.reduce_sum()&lt;/code&gt;&lt;/a&gt;. In contrast to SparseReduceSum, this Op returns a SparseTensor.</source>
          <target state="translated">Esta operaci&amp;oacute;n toma un SparseTensor y es la contraparte dispersa de &lt;a href=&quot;../../math/reduce_sum&quot;&gt; &lt;code&gt;tf.reduce_sum()&lt;/code&gt; &lt;/a&gt; . A diferencia de SparseReduceSum, esta Op devuelve un SparseTensor.</target>
        </trans-unit>
        <trans-unit id="eff3316c87e58a0e09844e295d654acad826f230" translate="yes" xml:space="preserve">
          <source>This Op takes a SparseTensor and is the sparse counterpart to &lt;a href=&quot;../../math/reduce_sum&quot;&gt;&lt;code&gt;tf.reduce_sum()&lt;/code&gt;&lt;/a&gt;. In particular, this Op also returns a dense &lt;code&gt;Tensor&lt;/code&gt; instead of a sparse one.</source>
          <target state="translated">Esta operaci&amp;oacute;n toma un SparseTensor y es la contraparte dispersa de &lt;a href=&quot;../../math/reduce_sum&quot;&gt; &lt;code&gt;tf.reduce_sum()&lt;/code&gt; &lt;/a&gt; . En particular, esta Op tambi&amp;eacute;n devuelve un &lt;code&gt;Tensor&lt;/code&gt; denso en lugar de uno escaso.</target>
        </trans-unit>
        <trans-unit id="02bfe7eb6e17547c27337071dde6515aea09a633" translate="yes" xml:space="preserve">
          <source>This Op takes a SparseTensor and is the sparse counterpart to &lt;a href=&quot;../math/reduce_max&quot;&gt;&lt;code&gt;tf.reduce_max()&lt;/code&gt;&lt;/a&gt;. In contrast to SparseReduceMax, this Op returns a SparseTensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7321159b3f380865d8a3ddbbd1ea9288e20a93c6" translate="yes" xml:space="preserve">
          <source>This Op takes a SparseTensor and is the sparse counterpart to &lt;a href=&quot;../math/reduce_max&quot;&gt;&lt;code&gt;tf.reduce_max()&lt;/code&gt;&lt;/a&gt;. In particular, this Op also returns a dense &lt;code&gt;Tensor&lt;/code&gt; if &lt;code&gt;output_is_sparse&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, or a &lt;code&gt;SparseTensor&lt;/code&gt; if &lt;code&gt;output_is_sparse&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">Esta operaci&amp;oacute;n toma un SparseTensor y es la contraparte dispersa de &lt;a href=&quot;../math/reduce_max&quot;&gt; &lt;code&gt;tf.reduce_max()&lt;/code&gt; &lt;/a&gt; . En particular, esta Op tambi&amp;eacute;n devuelve un &lt;code&gt;Tensor&lt;/code&gt; denso si &lt;code&gt;output_is_sparse&lt;/code&gt; es &lt;code&gt;False&lt;/code&gt; , o un &lt;code&gt;SparseTensor&lt;/code&gt; si &lt;code&gt;output_is_sparse&lt;/code&gt; es &lt;code&gt;True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1103b246b6e1caad53d997c04c64c3898e6d3b5" translate="yes" xml:space="preserve">
          <source>This Op takes a SparseTensor and is the sparse counterpart to &lt;a href=&quot;../math/reduce_max&quot;&gt;&lt;code&gt;tf.reduce_max()&lt;/code&gt;&lt;/a&gt;. In particular, this Op also returns a dense &lt;code&gt;Tensor&lt;/code&gt; instead of a sparse one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a81865bba66b7cb3ccd5c843f29a627466d44c58" translate="yes" xml:space="preserve">
          <source>This Op takes a SparseTensor and is the sparse counterpart to &lt;a href=&quot;../math/reduce_sum&quot;&gt;&lt;code&gt;tf.reduce_sum()&lt;/code&gt;&lt;/a&gt;. In contrast to SparseReduceSum, this Op returns a SparseTensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a574e60c745da5b56aeabab5fc189ca97095b4e6" translate="yes" xml:space="preserve">
          <source>This Op takes a SparseTensor and is the sparse counterpart to &lt;a href=&quot;../math/reduce_sum&quot;&gt;&lt;code&gt;tf.reduce_sum()&lt;/code&gt;&lt;/a&gt;. In particular, this Op also returns a dense &lt;code&gt;Tensor&lt;/code&gt; if &lt;code&gt;output_is_sparse&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, or a &lt;code&gt;SparseTensor&lt;/code&gt; if &lt;code&gt;output_is_sparse&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">Esta operaci&amp;oacute;n toma un SparseTensor y es la contraparte dispersa de &lt;a href=&quot;../math/reduce_sum&quot;&gt; &lt;code&gt;tf.reduce_sum()&lt;/code&gt; &lt;/a&gt; . En particular, esta Op tambi&amp;eacute;n devuelve un &lt;code&gt;Tensor&lt;/code&gt; denso si &lt;code&gt;output_is_sparse&lt;/code&gt; es &lt;code&gt;False&lt;/code&gt; , o un &lt;code&gt;SparseTensor&lt;/code&gt; si &lt;code&gt;output_is_sparse&lt;/code&gt; es &lt;code&gt;True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0611fe28cd2ae42a84cd683414a5531be62247ed" translate="yes" xml:space="preserve">
          <source>This Op takes a SparseTensor and is the sparse counterpart to &lt;a href=&quot;../math/reduce_sum&quot;&gt;&lt;code&gt;tf.reduce_sum()&lt;/code&gt;&lt;/a&gt;. In particular, this Op also returns a dense &lt;code&gt;Tensor&lt;/code&gt; instead of a sparse one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9513360fe89de6564516b0de822250d992516167" translate="yes" xml:space="preserve">
          <source>This adjusts the dynamic range of the gradient evaluation by scaling up the &lt;code&gt;loss&lt;/code&gt; value. The gradient values are then scaled back down by the recipricol of the loss scale. This is useful in reduced precision training where small gradient values would otherwise underflow the representable range.</source>
          <target state="translated">Esto ajusta el rango din&amp;aacute;mico de la evaluaci&amp;oacute;n de gradiente aumentando el valor de &lt;code&gt;loss&lt;/code&gt; . A continuaci&amp;oacute;n, los valores de gradiente se reducen mediante el rec&amp;iacute;proco de la escala de p&amp;eacute;rdidas. Esto es &amp;uacute;til en el entrenamiento de precisi&amp;oacute;n reducida donde peque&amp;ntilde;os valores de gradiente de otro modo rebasar&amp;iacute;an el rango representable.</target>
        </trans-unit>
        <trans-unit id="f5e97086794cce37b1d5d739075a4835500e01f8" translate="yes" xml:space="preserve">
          <source>This adjusts the dynamic range of the gradient evaluation by scaling up the &lt;code&gt;loss&lt;/code&gt; value. The gradient values are then scaled back down by the reciprocal of the loss scale. This is useful in reduced precision training where small gradient values would otherwise underflow the representable range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33c2fc8a5963a345edc285e854dc6f61f0166cef" translate="yes" xml:space="preserve">
          <source>This allows 'names' which should be a list of names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4742c30308cfd6082fa96c4df5f33b7fbb5afa83" translate="yes" xml:space="preserve">
          <source>This allows communication and coordination when there are multiple calls to the step_fn triggered by a call to &lt;code&gt;strategy.experimental_run_v2(step_fn, ...)&lt;/code&gt;.</source>
          <target state="translated">Esto permite la comunicaci&amp;oacute;n y la coordinaci&amp;oacute;n cuando hay m&amp;uacute;ltiples llamadas al step_fn desencadenadas por una llamada a &lt;code&gt;strategy.experimental_run_v2(step_fn, ...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54e8d42d088337b5915c0ad3a362c2e5bfd670e4" translate="yes" xml:space="preserve">
          <source>This allows communication and coordination when there are multiple calls to the step_fn triggered by a call to &lt;code&gt;strategy.run(step_fn, ...)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6406854276bccf2ce7a8330ff5c67c7e93bc6f24" translate="yes" xml:space="preserve">
          <source>This allows creating a sub-tensor from part of the current contents of a variable. See &lt;a href=&quot;../../tensor#__getitem__&quot;&gt;&lt;code&gt;tf.Tensor.&lt;strong&gt;getitem&lt;/strong&gt;&lt;/code&gt;&lt;/a&gt; for detailed examples of slicing.</source>
          <target state="translated">Esto permite crear un subtensor a partir de parte del contenido actual de una variable. Ver &lt;a href=&quot;../../tensor#__getitem__&quot;&gt; &lt;code&gt;tf.Tensor.&lt;strong&gt;getitem&lt;/strong&gt;&lt;/code&gt; &lt;/a&gt; para ver ejemplos detallados de corte.</target>
        </trans-unit>
        <trans-unit id="3f9bd14a03a5b9808d578e330775308ae0518e1f" translate="yes" xml:space="preserve">
          <source>This allows creating a sub-tensor from part of the current contents of a variable. See &lt;a href=&quot;tensor#__getitem__&quot;&gt;&lt;code&gt;tf.Tensor.&lt;strong&gt;getitem&lt;/strong&gt;&lt;/code&gt;&lt;/a&gt; for detailed examples of slicing.</source>
          <target state="translated">Esto permite crear un subtensor a partir de parte del contenido actual de una variable. Ver &lt;a href=&quot;tensor#__getitem__&quot;&gt; &lt;code&gt;tf.Tensor.&lt;strong&gt;getitem&lt;/strong&gt;&lt;/code&gt; &lt;/a&gt; para ver ejemplos detallados de corte.</target>
        </trans-unit>
        <trans-unit id="4a0031976f29ed8ed5b38f0545ffe09ca05a84a3" translate="yes" xml:space="preserve">
          <source>This allows reading and writing to this tensors w/o copies. This more closely mirrors the C++ Interpreter class interface's tensor() member, hence the name. Be careful to not hold these output references through calls to &lt;code&gt;allocate_tensors()&lt;/code&gt; and &lt;code&gt;invoke()&lt;/code&gt;. This function cannot be used to read intermediate results.</source>
          <target state="translated">Esto permite leer y escribir a estos tensores sin copias. Esto refleja m&amp;aacute;s de cerca el miembro tensor () de la interfaz de la clase Int&amp;eacute;rprete de C ++, de ah&amp;iacute; el nombre. Tenga cuidado de no mantener estas referencias de salida a trav&amp;eacute;s de llamadas a &lt;code&gt;allocate_tensors()&lt;/code&gt; e &lt;code&gt;invoke()&lt;/code&gt; . Esta funci&amp;oacute;n no se puede utilizar para leer resultados intermedios.</target>
        </trans-unit>
        <trans-unit id="aab58add7bb75e6c4119bf13ecc09894979d960d" translate="yes" xml:space="preserve">
          <source>This allows you to save the entirety of the state of a model in a single file.</source>
          <target state="translated">Esto permite guardar la totalidad del estado de un modelo en un solo archivo.</target>
        </trans-unit>
        <trans-unit id="083c822ae2751294f6b801ab1aec618144643d76" translate="yes" xml:space="preserve">
          <source>This also supports either output striding via the optional &lt;code&gt;strides&lt;/code&gt; parameter or atrous convolution (also known as convolution with holes or dilated convolution, based on the French word &quot;trous&quot; meaning holes in English) via the optional &lt;code&gt;dilation_rate&lt;/code&gt; parameter. Currently, however, output striding is not supported for atrous convolutions.</source>
          <target state="translated">Esto tambi&amp;eacute;n admite pasos de salida a trav&amp;eacute;s del par&amp;aacute;metro de &lt;code&gt;strides&lt;/code&gt; opcional o convoluci&amp;oacute;n atrous (tambi&amp;eacute;n conocida como convoluci&amp;oacute;n con agujeros o convoluci&amp;oacute;n dilatada, seg&amp;uacute;n la palabra francesa &quot;trous&quot; que significa agujeros en ingl&amp;eacute;s) a trav&amp;eacute;s del par&amp;aacute;metro &lt;code&gt;dilation_rate&lt;/code&gt; opcional . Sin embargo, actualmente, la salida a zancadas no es compatible con convoluciones atroces.</target>
        </trans-unit>
        <trans-unit id="0282c5f56f860d1be334e321248ec8429b6f156d" translate="yes" xml:space="preserve">
          <source>This also supports either output striding via the optional &lt;code&gt;strides&lt;/code&gt; parameter or atrous convolution (also known as convolution with holes or dilated convolution, based on the French word &quot;trous&quot; meaning holes in English) via the optional &lt;code&gt;dilations&lt;/code&gt; parameter. Currently, however, output striding is not supported for atrous convolutions.</source>
          <target state="translated">Esto tambi&amp;eacute;n admite pasos de salida a trav&amp;eacute;s del par&amp;aacute;metro de &lt;code&gt;strides&lt;/code&gt; opcional o convoluci&amp;oacute;n atroz (tambi&amp;eacute;n conocida como convoluci&amp;oacute;n con agujeros o convoluci&amp;oacute;n dilatada, seg&amp;uacute;n la palabra francesa &quot;trous&quot; que significa agujeros en ingl&amp;eacute;s) a trav&amp;eacute;s del par&amp;aacute;metro de &lt;code&gt;dilations&lt;/code&gt; opcional . Sin embargo, actualmente, la salida a zancadas no es compatible con convoluciones atroces.</target>
        </trans-unit>
        <trans-unit id="40ecf12ea54cbb9c03cee235c92870bdadc05d0e" translate="yes" xml:space="preserve">
          <source>This assumes the input dictionary contains a &lt;code&gt;SparseTensor&lt;/code&gt; for key 'terms', and a &lt;code&gt;SparseTensor&lt;/code&gt; for key 'frequencies'. These 2 tensors must have the same indices and dense shape.</source>
          <target state="translated">Esto supone que el diccionario de entrada contiene un &lt;code&gt;SparseTensor&lt;/code&gt; para 't&amp;eacute;rminos' clave y un &lt;code&gt;SparseTensor&lt;/code&gt; para 'frecuencias' clave. Estos 2 tensores deben tener los mismos &amp;iacute;ndices y forma densa.</target>
        </trans-unit>
        <trans-unit id="ec5e01502dedce9b5506d5284b5d16bed3dce6f8" translate="yes" xml:space="preserve">
          <source>This avoids adding &lt;code&gt;numpy_input&lt;/code&gt; as a large constant in the graph, and copies the data to the machine or machines that will be processing the input.</source>
          <target state="translated">Esto evita agregar &lt;code&gt;numpy_input&lt;/code&gt; como una gran constante en el gr&amp;aacute;fico y copia los datos a la m&amp;aacute;quina o m&amp;aacute;quinas que procesar&amp;aacute;n la entrada.</target>
        </trans-unit>
        <trans-unit id="542cdf0657b556d7d4f13254bf996896da1af7f2" translate="yes" xml:space="preserve">
          <source>This behaves similarly to &lt;a href=&quot;../../name_scope&quot;&gt;&lt;code&gt;tf.name_scope&lt;/code&gt;&lt;/a&gt;, except that it returns a generated summary tag in addition to the scope name. The tag is structurally similar to the scope name - derived from the user-provided name, prefixed with enclosing name scopes if any - but we relax the constraint that it be uniquified, as well as the character set limitation (so the user-provided name can contain characters not legal for scope names; in the scope name these are removed).</source>
          <target state="translated">Esto se comporta de manera similar a &lt;a href=&quot;../../name_scope&quot;&gt; &lt;code&gt;tf.name_scope&lt;/code&gt; &lt;/a&gt; , excepto que devuelve una etiqueta de resumen generada adem&amp;aacute;s del nombre del alcance. La etiqueta es estructuralmente similar al nombre del alcance, derivado del nombre proporcionado por el usuario, con el prefijo adjunto a los alcances de nombre, si los hubiera, pero relajamos la restricci&amp;oacute;n de que no est&amp;eacute; dividido, as&amp;iacute; como la limitaci&amp;oacute;n del conjunto de caracteres (por lo que el nombre proporcionado por el usuario puede contener caracteres no legales para los nombres de alcance; en el nombre de alcance, estos se eliminan).</target>
        </trans-unit>
        <trans-unit id="5d690c9d397a6da08fd08939e695a0fb6ea89e4b" translate="yes" xml:space="preserve">
          <source>This behavior gives control to callers on what to do if checkpoints do not come fast enough or stop being generated. For example, if callers have a way to detect that the training has stopped and know that no new checkpoints will be generated, they can provide a &lt;code&gt;timeout_fn&lt;/code&gt; that returns &lt;code&gt;True&lt;/code&gt; when the training has stopped. If they know that the training is still going on they return &lt;code&gt;False&lt;/code&gt; instead.</source>
          <target state="translated">Este comportamiento les da control a las personas que llaman sobre qu&amp;eacute; hacer si los puntos de control no llegan lo suficientemente r&amp;aacute;pido o dejan de generarse. Por ejemplo, si las personas que llaman tienen una forma de detectar que el entrenamiento se ha detenido y saben que no se generar&amp;aacute;n nuevos puntos de control, pueden proporcionar un &lt;code&gt;timeout_fn&lt;/code&gt; que devuelve &lt;code&gt;True&lt;/code&gt; cuando el entrenamiento se ha detenido. Si saben que el entrenamiento a&amp;uacute;n est&amp;aacute; en curso, devuelven &lt;code&gt;False&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d87911d57456c793352550a56288318dbdc2112" translate="yes" xml:space="preserve">
          <source>This behavior has been introduced in TensorFlow 2.0, in order to enable &lt;code&gt;layer.trainable = False&lt;/code&gt; to produce the most commonly expected behavior in the convnet fine-tuning use case.</source>
          <target state="translated">Este comportamiento se introdujo en TensorFlow 2.0 para permitir que &lt;code&gt;layer.trainable = False&lt;/code&gt; produzca el comportamiento m&amp;aacute;s com&amp;uacute;nmente esperado en el caso de uso de ajuste fino de convnet.</target>
        </trans-unit>
        <trans-unit id="566da943133ad9f7ff89e0ae58ccee97f0942cd9" translate="yes" xml:space="preserve">
          <source>This behavior only occurs as of TensorFlow 2.0. In 1.*, setting &lt;code&gt;layer.trainable = False&lt;/code&gt; would freeze the layer but would not switch it to inference mode.</source>
          <target state="translated">Este comportamiento solo ocurre a partir de TensorFlow 2.0. En 1. *, configurar &lt;code&gt;layer.trainable = False&lt;/code&gt; congelar&amp;iacute;a la capa pero no la cambiar&amp;iacute;a al modo de inferencia.</target>
        </trans-unit>
        <trans-unit id="947e43a536a4f632b306b7d5c3e4805a08d13eec" translate="yes" xml:space="preserve">
          <source>This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs.</source>
          <target state="translated">Esto bloquea el hilo de llamada hasta que el hilo cuyo método join()se llama termine,ya sea normalmente o a través de una excepción no manejada o hasta que se produzca el timeout opcional.</target>
        </trans-unit>
        <trans-unit id="f576e406288a87f269b5d6306d3d486ac32d4798" translate="yes" xml:space="preserve">
          <source>This boolean flag determines whether variables should be initialized as they are instantiated (default), or if the user should handle the initialization (e.g. via &lt;a href=&quot;../../compat/v1/initialize_all_variables&quot;&gt;&lt;code&gt;tf.compat.v1.initialize_all_variables()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Esta bandera booleana determina si las variables deben inicializarse a medida que se instancian (predeterminado) o si el usuario debe manejar la inicializaci&amp;oacute;n (por ejemplo, a trav&amp;eacute;s de &lt;a href=&quot;../../compat/v1/initialize_all_variables&quot;&gt; &lt;code&gt;tf.compat.v1.initialize_all_variables()&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4711e34ac0b0f311f0826db62648fbfab1ecfcb6" translate="yes" xml:space="preserve">
          <source>This boolean is True when this is an export in the end of training. It is False for the intermediate exports during the training. When passing &lt;code&gt;Exporter&lt;/code&gt; to &lt;a href=&quot;train_and_evaluate&quot;&gt;&lt;code&gt;tf.estimator.train_and_evaluate&lt;/code&gt;&lt;/a&gt;&lt;code&gt;is_the_final_export&lt;/code&gt; is always False if &lt;a href=&quot;trainspec#max_steps&quot;&gt;&lt;code&gt;TrainSpec.max_steps&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d320c46f5814a56c1f3f60058177b848b6fe981" translate="yes" xml:space="preserve">
          <source>This call blocks until a set of threads have terminated. The set of thread is the union of the threads passed in the &lt;code&gt;threads&lt;/code&gt; argument and the list of threads that registered with the coordinator by calling &lt;a href=&quot;coordinator#register_thread&quot;&gt;&lt;code&gt;Coordinator.register_thread()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esta llamada se bloquea hasta que finaliza un conjunto de subprocesos. El conjunto de subprocesos es la uni&amp;oacute;n de los subprocesos pasados ​​en el argumento &lt;code&gt;threads&lt;/code&gt; y la lista de subprocesos que se registraron con el coordinador al llamar a &lt;a href=&quot;coordinator#register_thread&quot;&gt; &lt;code&gt;Coordinator.register_thread()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="51c54c7d5726811d44822079b16e485771669c24" translate="yes" xml:space="preserve">
          <source>This call is ignored when eager execution is enabled (in that case, variable updates are run on the fly and thus do not need to be tracked for later execution).</source>
          <target state="translated">Esta llamada es ignorada cuando se habilita la ejecución ansiosa (en ese caso,las actualizaciones variables se ejecutan sobre la marcha y,por lo tanto,no necesitan ser rastreadas para su posterior ejecución).</target>
        </trans-unit>
        <trans-unit id="062df39159f4972c7eb0c0bbc3c621a80385af7d" translate="yes" xml:space="preserve">
          <source>This callback is automatically applied to every Keras model.</source>
          <target state="translated">Esta llamada se aplica automáticamente a todos los modelos de Keras.</target>
        </trans-unit>
        <trans-unit id="4a2209138c3b99588918296a296e9d5cba348ee9" translate="yes" xml:space="preserve">
          <source>This callback is automatically applied to every Keras model. The &lt;code&gt;History&lt;/code&gt; object gets returned by the &lt;code&gt;fit&lt;/code&gt; method of models.</source>
          <target state="translated">Esta devoluci&amp;oacute;n de llamada se aplica autom&amp;aacute;ticamente a todos los modelos de Keras. El objeto &lt;code&gt;History&lt;/code&gt; se devuelve mediante el m&amp;eacute;todo de &lt;code&gt;fit&lt;/code&gt; de modelos.</target>
        </trans-unit>
        <trans-unit id="9a8fccab0666eafd61c1fb78dee506da35fb92ce" translate="yes" xml:space="preserve">
          <source>This callback is constructed with anonymous functions that will be called at the appropriate time. Note that the callbacks expects positional arguments, as:</source>
          <target state="translated">Esta llamada se construye con funciones anónimas que serán llamadas en el momento apropiado.Tengan en cuenta que las llamadas de retorno esperan argumentos posicionales,como:</target>
        </trans-unit>
        <trans-unit id="d5a28ff485e6238d1ad10ebb9f92b4945e5fbef4" translate="yes" xml:space="preserve">
          <source>This callback is not compatible with disabling eager execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2fd53cd69211c630c172b830b110ef6741f78e7" translate="yes" xml:space="preserve">
          <source>This callback logs events for TensorBoard, including:</source>
          <target state="translated">Esta llamada registra los eventos para TensorBoard,incluyendo:</target>
        </trans-unit>
        <trans-unit id="6cbedc26a564f8697fb303c927049b43625f8671" translate="yes" xml:space="preserve">
          <source>This can also be used in a &lt;a href=&quot;tableconfig&quot;&gt;&lt;code&gt;tf.tpu.experimental.embedding.TableConfig&lt;/code&gt;&lt;/a&gt; as the optimizer parameter to set a table specific optimizer. This will override the optimizer and parameters for global embedding optimizer defined above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c4d9ff06bd1c217d75cb9a57ebc28626f964add" translate="yes" xml:space="preserve">
          <source>This can always be checked statically, so this method returns nothing.</source>
          <target state="translated">Esto siempre se puede comprobar estáticamente,por lo que este método no devuelve nada.</target>
        </trans-unit>
        <trans-unit id="6f195f030f5d6a3952c927a303c10a3d51f131c5" translate="yes" xml:space="preserve">
          <source>This can be faster than multiple individual &lt;code&gt;reduce&lt;/code&gt;s because we can fuse several tensors into one or multiple packs before reduction.</source>
          <target state="translated">Esto puede ser m&amp;aacute;s r&amp;aacute;pido que m&amp;uacute;ltiples individuo &lt;code&gt;reduce&lt;/code&gt; s porque podemos fusionar varios tensores en uno o varios paquetes antes de la reducci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ef728ae4ad68ee3a6531133cdd224d4406968fce" translate="yes" xml:space="preserve">
          <source>This can be passed to methods like &lt;code&gt;tf.distribute.get_replica_context().all_reduce()&lt;/code&gt; to optimize collective operation performance. Note that these are only hints, which may or may not change the actual behavior. Some options only apply to certain strategy and are ignored by others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4c1e8ee1a694edb65fdf5329eae65afdec683d9" translate="yes" xml:space="preserve">
          <source>This can be used as a &quot;join&quot; mechanism for parallel computations: all the argument tensors can be computed in parallel, but the values of any tensor returned by &lt;code&gt;tuple&lt;/code&gt; are only available after all the parallel computations are done.</source>
          <target state="translated">Esto se puede usar como un mecanismo de &quot;uni&amp;oacute;n&quot; para c&amp;aacute;lculos paralelos: todos los tensores de argumento se pueden calcular en paralelo, pero los valores de cualquier tensor devuelto por &lt;code&gt;tuple&lt;/code&gt; s&amp;oacute;lo est&amp;aacute;n disponibles despu&amp;eacute;s de que se hayan realizado todos los c&amp;aacute;lculos paralelos.</target>
        </trans-unit>
        <trans-unit id="66b08400383b183cc1cba0b591ec90b5fe85d73d" translate="yes" xml:space="preserve">
          <source>This can be used as a loss-function during optimization so as to suppress noise in images. If you have a batch of images, then you should calculate the scalar loss-value as the sum: &lt;code&gt;loss = tf.reduce_sum(tf.image.total_variation(images))&lt;/code&gt;</source>
          <target state="translated">Esto se puede utilizar como funci&amp;oacute;n de p&amp;eacute;rdida durante la optimizaci&amp;oacute;n para suprimir el ruido en las im&amp;aacute;genes. Si tiene un lote de im&amp;aacute;genes, entonces deber&amp;iacute;a calcular el valor de p&amp;eacute;rdida escalar como la suma: &lt;code&gt;loss = tf.reduce_sum(tf.image.total_variation(images))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f9d5c2eebbfc8025f5c8da3b80769337a79a6187" translate="yes" xml:space="preserve">
          <source>This can be used to hold some strategy specific configs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff61da80eb1038583fadf6e588b06357b27a55d8" translate="yes" xml:space="preserve">
          <source>This can be useful for debugging or profiling. For example, let's say you implemented a simple iterative sqrt function, and you want to collect the intermediate values and plot the convergence. Appending the values to a list in &lt;code&gt;@tf.function&lt;/code&gt; normally wouldn't work since it will just record the Tensors being traced, not the values. Instead, you can do the following.</source>
          <target state="translated">Esto puede resultar &amp;uacute;til para depurar o generar perfiles. Por ejemplo, digamos que implement&amp;oacute; una funci&amp;oacute;n sqrt iterativa simple y desea recopilar los valores intermedios y trazar la convergencia. Agregar los valores a una lista en &lt;code&gt;@tf.function&lt;/code&gt; normalmente no funcionar&amp;iacute;a ya que solo registrar&amp;aacute; los tensores que se est&amp;aacute;n rastreando, no los valores. En su lugar, puede hacer lo siguiente.</target>
        </trans-unit>
        <trans-unit id="5bc85a9ecd105989dec28b806afbbe4faa69f248" translate="yes" xml:space="preserve">
          <source>This can be useful if you want to log debug a training algorithm, report stats about the slots, etc.</source>
          <target state="translated">Esto puede ser útil si quieres registrar la depuración de un algoritmo de entrenamiento,reportar estadísticas sobre las ranuras,etc.</target>
        </trans-unit>
        <trans-unit id="de803dd8ed0f3487c59166443a170b97850a2c8d" translate="yes" xml:space="preserve">
          <source>This class allows to vectorize a text corpus, by turning each text into either a sequence of integers (each integer being the index of a token in a dictionary) or into a vector where the coefficient for each token could be binary, based on word count, based on tf-idf...</source>
          <target state="translated">Esta clase permite vectorizar un corpus de texto,convirtiendo cada texto en una secuencia de números enteros (cada número entero es el índice de una ficha en un diccionario)o en un vector en el que el coeficiente de cada ficha puede ser binario,basado en el recuento de palabras,basado en tf-idf...</target>
        </trans-unit>
        <trans-unit id="c35c7cb7e9df11039724d697524b210395fe269e" translate="yes" xml:space="preserve">
          <source>This class assumes each worker is running the same code independently, but parameter servers are running a standard server. This means that while each worker will synchronously compute a single gradient update across all GPUs, updates between workers proceed asynchronously. Operations that occur only on the first replica (such as incrementing the global step), will occur on the first replica &lt;em&gt;of every worker&lt;/em&gt;.</source>
          <target state="translated">Esta clase supone que cada trabajador ejecuta el mismo c&amp;oacute;digo de forma independiente, pero los servidores de par&amp;aacute;metros ejecutan un servidor est&amp;aacute;ndar. Esto significa que, si bien cada trabajador calcular&amp;aacute; de forma sincr&amp;oacute;nica una &amp;uacute;nica actualizaci&amp;oacute;n de gradiente en todas las GPU, las actualizaciones entre los trabajadores proceden de forma asincr&amp;oacute;nica. Las operaciones que ocurren solo en la primera r&amp;eacute;plica (como incrementar el paso global), ocurrir&amp;aacute;n en la primera r&amp;eacute;plica &lt;em&gt;de cada trabajador&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1ea4dadc6d5580b6a9567a54f238c77dab3d0a06" translate="yes" xml:space="preserve">
          <source>This class caches file writers, one per directory.</source>
          <target state="translated">Esta clase almacena en caché a los escritores de archivos,uno por cada directorio.</target>
        </trans-unit>
        <trans-unit id="b8684cfbd26f7ff4ba54e9a816ce8e5ac6de8988" translate="yes" xml:space="preserve">
          <source>This class can be used to support training large embeddings on TPU. When creating an instance of this class, you must specify the complete set of tables and features you expect to lookup in those tables. See the documentation of &lt;a href=&quot;tableconfig&quot;&gt;&lt;code&gt;tf.tpu.experimental.embedding.TableConfig&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;featureconfig&quot;&gt;&lt;code&gt;tf.tpu.experimental.embedding.FeatureConfig&lt;/code&gt;&lt;/a&gt; for more details on the complete set of options. We will cover the basic usage here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9243b860278b8d7215f95a8eb101fc7a883ab5b" translate="yes" xml:space="preserve">
          <source>This class can create placeholders for tf.Tensors, tf.SparseTensors, and tf.RaggedTensors by choosing 'sparse=True' or 'ragged=True'.</source>
          <target state="translated">Esta clase puede crear marcadores de posición para tf.Tensors,tf.SparseTensors,y tf.RaggedTensors eligiendo 'sparse=True' o 'ragged=True'.</target>
        </trans-unit>
        <trans-unit id="805ec9c49684c57a889497d64617b10bca6259a1" translate="yes" xml:space="preserve">
          <source>This class can create placeholders for tf.Tensors, tf.SparseTensors, and tf.RaggedTensors by choosing 'sparse=True' or 'ragged=True'. Note that 'sparse' and 'ragged' can't be configured to True at same time. Usage:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b93eb86d4b8b199ed8de190972226d76d3ddbda5" translate="yes" xml:space="preserve">
          <source>This class defines the API to add Ops to train a model. You never use this class directly, but instead instantiate one of its subclasses such as &lt;a href=&quot;sgd&quot;&gt;&lt;code&gt;tf.keras.optimizers.SGD&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;adam&quot;&gt;&lt;code&gt;tf.keras.optimizers.Adam&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esta clase define la API para agregar operaciones para entrenar un modelo. Nunca usa esta clase directamente, sino que crea una instancia de una de sus subclases, como &lt;a href=&quot;sgd&quot;&gt; &lt;code&gt;tf.keras.optimizers.SGD&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;adam&quot;&gt; &lt;code&gt;tf.keras.optimizers.Adam&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1921ba1f544676f9bbcb9030a711c397087751d1" translate="yes" xml:space="preserve">
          <source>This class defines the API to add Ops to train a model. You never use this class directly, but instead instantiate one of its subclasses such as &lt;code&gt;GradientDescentOptimizer&lt;/code&gt;, &lt;code&gt;AdagradOptimizer&lt;/code&gt;, or &lt;code&gt;MomentumOptimizer&lt;/code&gt;.</source>
          <target state="translated">Esta clase define la API para agregar operaciones para entrenar un modelo. Nunca usa esta clase directamente, sino que crea una instancia de una de sus subclases, como &lt;code&gt;GradientDescentOptimizer&lt;/code&gt; , &lt;code&gt;AdagradOptimizer&lt;/code&gt; o &lt;code&gt;MomentumOptimizer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1b4934ebc6e87e946a8327b096ccaba6f902fbb" translate="yes" xml:space="preserve">
          <source>This class defines the key and value used for tf.lookup.TextFileInitializer.</source>
          <target state="translated">Esta clase define la clave y el valor usado para tf.lookup.TextFileInitializer.</target>
        </trans-unit>
        <trans-unit id="bbef232ee84dd43e03ff0bb31e2fff3d62ddb086" translate="yes" xml:space="preserve">
          <source>This class exports the serving graph and checkpoints at the end.</source>
          <target state="translated">Esta clase exporta el gráfico de la porción y los puntos de control al final.</target>
        </trans-unit>
        <trans-unit id="2398f265a0682e91ce8fc30c31cc00a32b85cf94" translate="yes" xml:space="preserve">
          <source>This class exports the serving graph and checkpoints of the best models.</source>
          <target state="translated">Esta clase exporta el gráfico de servicio y los puntos de control de los mejores modelos.</target>
        </trans-unit>
        <trans-unit id="f378b5fe5691dc39f9cd3d236136a8685104c4fd" translate="yes" xml:space="preserve">
          <source>This class has been deprecated. Please use &lt;a href=&quot;../../../lite/tfliteconverter&quot;&gt;&lt;code&gt;lite.TFLiteConverter&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Esta clase ha quedado obsoleta. &lt;a href=&quot;../../../lite/tfliteconverter&quot;&gt; &lt;code&gt;lite.TFLiteConverter&lt;/code&gt; &lt;/a&gt; lugar, utilice lite.TFLiteConverter .</target>
        </trans-unit>
        <trans-unit id="56db13aef8a0368de7cd44eab17a2a6ce7b0dc42" translate="yes" xml:space="preserve">
          <source>This class has been deprecated. Please use &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/lite/TFLiteConverter&quot;&gt;&lt;code&gt;lite.TFLiteConverter&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8616741a1ce86b957920807cdf7bdf7cd9ce000e" translate="yes" xml:space="preserve">
          <source>This class has two primary purposes:</source>
          <target state="translated">Esta clase tiene dos propósitos principales:</target>
        </trans-unit>
        <trans-unit id="42f7db2b92ba92041bfe671280afd36a3919a9f0" translate="yes" xml:space="preserve">
          <source>This class holds the configuration data for a single embedding feature. The main use is to assign features to &lt;a href=&quot;tableconfig&quot;&gt;&lt;code&gt;tf.tpu.experimental.embedding.TableConfig&lt;/code&gt;&lt;/a&gt;s via the table parameter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a9133b931fbc77d042cdefc7dee2428d484b0ed" translate="yes" xml:space="preserve">
          <source>This class holds the configuration data for a single embedding table. It is used as the &lt;code&gt;table&lt;/code&gt; parameter of a &lt;a href=&quot;featureconfig&quot;&gt;&lt;code&gt;tf.tpu.experimental.embedding.FeatureConfig&lt;/code&gt;&lt;/a&gt;. Multiple &lt;a href=&quot;featureconfig&quot;&gt;&lt;code&gt;tf.tpu.experimental.embedding.FeatureConfig&lt;/code&gt;&lt;/a&gt; objects can use the same &lt;a href=&quot;tableconfig&quot;&gt;&lt;code&gt;tf.tpu.experimental.embedding.TableConfig&lt;/code&gt;&lt;/a&gt; object. In this case a shared table will be created for those feature lookups.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e41eb7b59b50f02eb388655630751957c627b643" translate="yes" xml:space="preserve">
          <source>This class implements &lt;code&gt;__enter__&lt;/code&gt; and &lt;code&gt;__exit__&lt;/code&gt;, and can be used in &lt;code&gt;with&lt;/code&gt; blocks like a normal file.</source>
          <target state="translated">Esta clase implementa &lt;code&gt;__enter__&lt;/code&gt; y &lt;code&gt;__exit__&lt;/code&gt; , y se puede usar &lt;code&gt;with&lt;/code&gt; bloques como un archivo normal.</target>
        </trans-unit>
        <trans-unit id="8e6a775ae22bedf95251724d923983db37089b28" translate="yes" xml:space="preserve">
          <source>This class implements &lt;code&gt;__enter__&lt;/code&gt; and &lt;code&gt;__exit__&lt;/code&gt;, and can be used in &lt;code&gt;with&lt;/code&gt; blocks like a normal file. (See the usage example above.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61d78e6233b72d451051551f631a8d253b9c0d10" translate="yes" xml:space="preserve">
          <source>This class implements a simple mechanism to coordinate the termination of a set of threads.</source>
          <target state="translated">Esta clase implementa un mecanismo simple para coordinar la terminación de un conjunto de hilos.</target>
        </trans-unit>
        <trans-unit id="2c453470b9fb7d2dd4c8372805a2c5b45dcafe1a" translate="yes" xml:space="preserve">
          <source>This class in stateful and thread-compatible.</source>
          <target state="translated">Esta clase en estado y compatible con el hilo.</target>
        </trans-unit>
        <trans-unit id="b6c71f2399c238428100228254e29a64f6c45e19" translate="yes" xml:space="preserve">
          <source>This class is a simple wrapper for a pair of &lt;code&gt;Tensor&lt;/code&gt; objects:</source>
          <target state="translated">Esta clase es un contenedor simple para un par de objetos &lt;code&gt;Tensor&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="aaddfb846b1d90d727149969bb3d79f9de0c7466" translate="yes" xml:space="preserve">
          <source>This class is a small wrapper that takes care of session creation and checkpoint recovery. It also provides functions that to facilitate coordination among multiple training threads or processes.</source>
          <target state="translated">Esta clase es un pequeño envoltorio que se encarga de la creación de sesiones y la recuperación de puntos de control.También proporciona funciones que facilitan la coordinación entre múltiples hilos o procesos de entrenamiento.</target>
        </trans-unit>
        <trans-unit id="17463f3d93317c6b5e6f0cc508b2a6f39e7358ea" translate="yes" xml:space="preserve">
          <source>This class is deprecated. For synchrononous training, please use &lt;a href=&quot;https://github.com/tensorflow/tensorflow/tree/master/tensorflow/contrib/distribute&quot;&gt;Distribution Strategies&lt;/a&gt;.</source>
          <target state="translated">Esta clase est&amp;aacute; obsoleta. Para el entrenamiento sincr&amp;oacute;nico, utilice &lt;a href=&quot;https://github.com/tensorflow/tensorflow/tree/master/tensorflow/contrib/distribute&quot;&gt;Estrategias de distribuci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="000d9e8de17ad9ab35fd8858d3f373310d7cf1c7" translate="yes" xml:space="preserve">
          <source>This class is deprecated. For synchronous training, please use &lt;a href=&quot;https://github.com/tensorflow/tensorflow/tree/master/tensorflow/contrib/distribute&quot;&gt;Distribution Strategies&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4616d8f2e476585f5e22705937707332b5baeb5b" translate="yes" xml:space="preserve">
          <source>This class is deprecated. Please use &lt;a href=&quot;monitoredtrainingsession&quot;&gt;&lt;code&gt;tf.compat.v1.train.MonitoredTrainingSession&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Esta clase est&amp;aacute; obsoleta. &lt;a href=&quot;monitoredtrainingsession&quot;&gt; &lt;code&gt;tf.compat.v1.train.MonitoredTrainingSession&lt;/code&gt; &lt;/a&gt; lugar, utilice tf.compat.v1.train.MonitoredTrainingSession .</target>
        </trans-unit>
        <trans-unit id="42d3bc86be52a8736e6d7aa317815110401307ef" translate="yes" xml:space="preserve">
          <source>This class is heavily overloaded:</source>
          <target state="translated">Esta clase está muy sobrecargada:</target>
        </trans-unit>
        <trans-unit id="22170de053f3420fc08a96260e613e3fa8486018" translate="yes" xml:space="preserve">
          <source>This class is meant to be used with dynamic iteration primitives such as &lt;code&gt;while_loop&lt;/code&gt; and &lt;code&gt;map_fn&lt;/code&gt;. It supports gradient back-propagation via special &quot;flow&quot; control flow dependencies.</source>
          <target state="translated">Esta clase est&amp;aacute; destinada a utilizarse con primitivas de iteraci&amp;oacute;n din&amp;aacute;mica como &lt;code&gt;while_loop&lt;/code&gt; y &lt;code&gt;map_fn&lt;/code&gt; . Es compatible con la retropropagaci&amp;oacute;n del gradiente a trav&amp;eacute;s de dependencias de flujo de control de &quot;flujo&quot; especiales.</target>
        </trans-unit>
        <trans-unit id="3c5c516c190cd8f8be6eb152047649a9bf6735af" translate="yes" xml:space="preserve">
          <source>This class is not thread-safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="121c6274230c0f7d1b806b54f9d580ba8e2d228a" translate="yes" xml:space="preserve">
          <source>This class merges the output of multiple &lt;code&gt;Head&lt;/code&gt; objects. Specifically:</source>
          <target state="translated">Esta clase fusiona la salida de varios objetos &lt;code&gt;Head&lt;/code&gt; . Espec&amp;iacute;ficamente:</target>
        </trans-unit>
        <trans-unit id="7cd980fdc04e7da43f8abb3e3be6ffdf25b7685d" translate="yes" xml:space="preserve">
          <source>This class performs a model export everytime the new model is better than any existing model.</source>
          <target state="translated">Esta clase realiza una exportación de modelos cada vez que el nuevo modelo es mejor que cualquier modelo existente.</target>
        </trans-unit>
        <trans-unit id="391aed511e9154256ca236f23d6877cb0f9d37db" translate="yes" xml:space="preserve">
          <source>This class performs a single export at the end of training.</source>
          <target state="translated">Esta clase realiza una única exportación al final del entrenamiento.</target>
        </trans-unit>
        <trans-unit id="b83c252083ca3edbed9d1168a0ed9755da22c25f" translate="yes" xml:space="preserve">
          <source>This class performs a union given two or more existing ClusterResolvers. It merges the underlying ClusterResolvers, and returns one unified ClusterSpec when cluster_spec is called. The details of the merge function is documented in the cluster_spec function.</source>
          <target state="translated">Esta clase realiza una unión dada dos o más ClusterResolvers existentes.Fusiona los ClusterResolvers subyacentes,y devuelve un ClusterSpec unificado cuando se llama cluster_spec.Los detalles de la función de fusión se documentan en la función cluster_spec.</target>
        </trans-unit>
        <trans-unit id="631d6a58bb184da4fc166c1a1dbaf36a0e45d9c8" translate="yes" xml:space="preserve">
          <source>This class performs the softmax operation for you, so inputs should be e.g. linear projections of outputs by an LSTM.</source>
          <target state="translated">Esta clase realiza la operación de softmax por usted,por lo que las entradas deben ser,por ejemplo,proyecciones lineales de las salidas por un LSTM.</target>
        </trans-unit>
        <trans-unit id="d2810b13f641fd9987b2ce8b38f939b3369079e3" translate="yes" xml:space="preserve">
          <source>This class processes one step within the whole time sequence input, whereas &lt;code&gt;tf.keras.layer.GRU&lt;/code&gt; processes the whole sequence.</source>
          <target state="translated">Esta clase procesa un paso dentro de toda la entrada de la secuencia de tiempo, mientras que &lt;code&gt;tf.keras.layer.GRU&lt;/code&gt; procesa toda la secuencia.</target>
        </trans-unit>
        <trans-unit id="9a1d5a35670a2cc4cfac2401e85535a1c8acffb8" translate="yes" xml:space="preserve">
          <source>This class processes one step within the whole time sequence input, whereas &lt;code&gt;tf.keras.layer.LSTM&lt;/code&gt; processes the whole sequence.</source>
          <target state="translated">Esta clase procesa un paso dentro de toda la entrada de la secuencia de tiempo, mientras que &lt;code&gt;tf.keras.layer.LSTM&lt;/code&gt; procesa toda la secuencia.</target>
        </trans-unit>
        <trans-unit id="85aecc3ec7757c0f4286579ce3ab5119031dd197" translate="yes" xml:space="preserve">
          <source>This class processes one step within the whole time sequence input, whereas &lt;code&gt;tf.keras.layer.SimpleRNN&lt;/code&gt; processes the whole sequence.</source>
          <target state="translated">Esta clase procesa un paso dentro de toda la entrada de la secuencia de tiempo, mientras que &lt;code&gt;tf.keras.layer.SimpleRNN&lt;/code&gt; procesa toda la secuencia.</target>
        </trans-unit>
        <trans-unit id="c2cd1ab18438d633073fa2c3300d94950ce386b5" translate="yes" xml:space="preserve">
          <source>This class regularly exports the serving graph and checkpoints.</source>
          <target state="translated">Esta clase exporta regularmente el gráfico de la porción y los puntos de control.</target>
        </trans-unit>
        <trans-unit id="44829f1dbd5fa6ec4b7c405e96fb0cb7473fedd5" translate="yes" xml:space="preserve">
          <source>This class specifies the configurations for an &lt;code&gt;Estimator&lt;/code&gt; run.</source>
          <target state="translated">Esta clase especifica las configuraciones para una ejecuci&amp;oacute;n de &lt;code&gt;Estimator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="349b70f1528f5d483fc48af054599841c5669982" translate="yes" xml:space="preserve">
          <source>This class takes in a sequence of data-points gathered at equal intervals, along with time series parameters such as stride, length of history, etc., to produce batches for training/validation.</source>
          <target state="translated">Esta clase toma una secuencia de puntos de datos reunidos a intervalos iguales,junto con parámetros de series de tiempo como el paso,la longitud de la historia,etc.,para producir lotes para su entrenamiento/validación.</target>
        </trans-unit>
        <trans-unit id="2020d8f19309c20263f69977f3eb5adfc93381e1" translate="yes" xml:space="preserve">
          <source>This class uses a &lt;a href=&quot;../variable&quot;&gt;&lt;code&gt;tf.Variable&lt;/code&gt;&lt;/a&gt; to manage its internal state. Every time random numbers are generated, the state of the generator will change. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45bad515b0c24287a7857bc49730849b980995da" translate="yes" xml:space="preserve">
          <source>This classifier ignores feature values and will learn to predict the average value of each label. For single-label problems, this will predict the probability distribution of the classes as seen in the labels. For multi-label problems, this will predict the fraction of examples that are positive for each class.</source>
          <target state="translated">Este clasificador ignora los valores de las características y aprenderá a predecir el valor medio de cada etiqueta.Para los problemas de una sola etiqueta,esto predecirá la distribución de probabilidad de las clases como se ve en las etiquetas.Para los problemas de múltiples etiquetas,esto predecirá la fracción de ejemplos que son positivos para cada clase.</target>
        </trans-unit>
        <trans-unit id="1203741987f9f009e5e86b580142b5f23085017c" translate="yes" xml:space="preserve">
          <source>This computes the internal data stats related to the data-dependent transformations, based on an array of sample data.</source>
          <target state="translated">De este modo se calculan las estadísticas de los datos internos relacionados con las transformaciones dependientes de los datos,sobre la base de un conjunto de datos de muestra.</target>
        </trans-unit>
        <trans-unit id="38619017d4eec4e645fa2f91a523c788477cd3cb" translate="yes" xml:space="preserve">
          <source>This condition holds if for every pair of (possibly broadcast) elements &lt;code&gt;x[i]&lt;/code&gt;, &lt;code&gt;y[i]&lt;/code&gt;, we have</source>
          <target state="translated">Esta condici&amp;oacute;n se cumple si para cada par de elementos (posiblemente difundidos) &lt;code&gt;x[i]&lt;/code&gt; , &lt;code&gt;y[i]&lt;/code&gt; , tenemos</target>
        </trans-unit>
        <trans-unit id="462aa0ba39503de33a78d3a4ed1c72d0eb71fa77" translate="yes" xml:space="preserve">
          <source>This condition holds if for every pair of (possibly broadcast) elements &lt;code&gt;x[i]&lt;/code&gt;, &lt;code&gt;y[i]&lt;/code&gt;, we have &lt;code&gt;x[i] != y[i]&lt;/code&gt;. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">Esta condici&amp;oacute;n se cumple si para cada par de elementos (posiblemente difundidos) &lt;code&gt;x[i]&lt;/code&gt; , &lt;code&gt;y[i]&lt;/code&gt; , tenemos &lt;code&gt;x[i] != y[i]&lt;/code&gt; . Si tanto &lt;code&gt;x&lt;/code&gt; como &lt;code&gt;y&lt;/code&gt; est&amp;aacute;n vac&amp;iacute;os, esto se satisface trivialmente.</target>
        </trans-unit>
        <trans-unit id="e25b6ae62c3ffc2ef4953d25e9698856f0a3b77a" translate="yes" xml:space="preserve">
          <source>This condition holds if for every pair of (possibly broadcast) elements &lt;code&gt;x[i]&lt;/code&gt;, &lt;code&gt;y[i]&lt;/code&gt;, we have &lt;code&gt;x[i] &amp;gt; y[i]&lt;/code&gt;. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">Esta condici&amp;oacute;n se cumple si para cada par de elementos (posiblemente difundidos) &lt;code&gt;x[i]&lt;/code&gt; , &lt;code&gt;y[i]&lt;/code&gt; , tenemos &lt;code&gt;x[i] &amp;gt; y[i]&lt;/code&gt; . Si tanto &lt;code&gt;x&lt;/code&gt; como &lt;code&gt;y&lt;/code&gt; est&amp;aacute;n vac&amp;iacute;os, esto se satisface trivialmente.</target>
        </trans-unit>
        <trans-unit id="ad801aabcdd92fbf94ec233e05dfeadd68d460b3" translate="yes" xml:space="preserve">
          <source>This condition holds if for every pair of (possibly broadcast) elements &lt;code&gt;x[i]&lt;/code&gt;, &lt;code&gt;y[i]&lt;/code&gt;, we have &lt;code&gt;x[i] &amp;gt;= y[i]&lt;/code&gt;. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">Esta condici&amp;oacute;n se cumple si para cada par de elementos (posiblemente difundidos) &lt;code&gt;x[i]&lt;/code&gt; , &lt;code&gt;y[i]&lt;/code&gt; , tenemos &lt;code&gt;x[i] &amp;gt;= y[i]&lt;/code&gt; . Si tanto &lt;code&gt;x&lt;/code&gt; como &lt;code&gt;y&lt;/code&gt; est&amp;aacute;n vac&amp;iacute;os, esto se satisface trivialmente.</target>
        </trans-unit>
        <trans-unit id="512ed74cbec98906ad1a4d1866d9484e4d2ad504" translate="yes" xml:space="preserve">
          <source>This condition holds if for every pair of (possibly broadcast) elements &lt;code&gt;x[i]&lt;/code&gt;, &lt;code&gt;y[i]&lt;/code&gt;, we have &lt;code&gt;x[i] &amp;lt; y[i]&lt;/code&gt;. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">Esta condici&amp;oacute;n se cumple si para cada par de elementos (posiblemente difundidos) &lt;code&gt;x[i]&lt;/code&gt; , &lt;code&gt;y[i]&lt;/code&gt; , tenemos &lt;code&gt;x[i] &amp;lt; y[i]&lt;/code&gt; . Si tanto &lt;code&gt;x&lt;/code&gt; como &lt;code&gt;y&lt;/code&gt; est&amp;aacute;n vac&amp;iacute;os, esto se satisface trivialmente.</target>
        </trans-unit>
        <trans-unit id="81434868d39629bbc35c170df36a994a92015b46" translate="yes" xml:space="preserve">
          <source>This condition holds if for every pair of (possibly broadcast) elements &lt;code&gt;x[i]&lt;/code&gt;, &lt;code&gt;y[i]&lt;/code&gt;, we have &lt;code&gt;x[i] &amp;lt;= y[i]&lt;/code&gt;. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">Esta condici&amp;oacute;n se cumple si para cada par de elementos (posiblemente difundidos) &lt;code&gt;x[i]&lt;/code&gt; , &lt;code&gt;y[i]&lt;/code&gt; , tenemos &lt;code&gt;x[i] &amp;lt;= y[i]&lt;/code&gt; . Si tanto &lt;code&gt;x&lt;/code&gt; como &lt;code&gt;y&lt;/code&gt; est&amp;aacute;n vac&amp;iacute;os, esto se satisface trivialmente.</target>
        </trans-unit>
        <trans-unit id="93ee9d4d5438fdc7dae43626edce4fb33cefa73b" translate="yes" xml:space="preserve">
          <source>This condition holds if for every pair of (possibly broadcast) elements &lt;code&gt;x[i]&lt;/code&gt;, &lt;code&gt;y[i]&lt;/code&gt;, we have &lt;code&gt;x[i] == y[i]&lt;/code&gt;. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">Esta condici&amp;oacute;n se cumple si para cada par de elementos (posiblemente difundidos) &lt;code&gt;x[i]&lt;/code&gt; , &lt;code&gt;y[i]&lt;/code&gt; , tenemos &lt;code&gt;x[i] == y[i]&lt;/code&gt; . Si tanto &lt;code&gt;x&lt;/code&gt; como &lt;code&gt;y&lt;/code&gt; est&amp;aacute;n vac&amp;iacute;os, esto se satisface trivialmente.</target>
        </trans-unit>
        <trans-unit id="1107421e32062956898c5a66e60e49bd95c7ed45" translate="yes" xml:space="preserve">
          <source>This constraint can be applied to any &lt;code&gt;Conv2D&lt;/code&gt; layer version, including &lt;code&gt;Conv2DTranspose&lt;/code&gt; and &lt;code&gt;SeparableConv2D&lt;/code&gt;, and with either &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt; or &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt; data format. The method assumes the weight tensor is of shape &lt;code&gt;(rows, cols, input_depth, output_depth)&lt;/code&gt;.</source>
          <target state="translated">Esta restricci&amp;oacute;n se puede aplicar a cualquier versi&amp;oacute;n de la capa &lt;code&gt;Conv2D&lt;/code&gt; , incluidas &lt;code&gt;Conv2DTranspose&lt;/code&gt; y &lt;code&gt;SeparableConv2D&lt;/code&gt; , y con el formato de datos &lt;code&gt;&quot;channels_last&quot;&lt;/code&gt; o &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt; . El m&amp;eacute;todo asume que el tensor de peso tiene forma &lt;code&gt;(rows, cols, input_depth, output_depth)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5e140df8d55549c17df75f17763f4c88b908cd9" translate="yes" xml:space="preserve">
          <source>This constructor creates both a &lt;code&gt;variable&lt;/code&gt; Op and an &lt;code&gt;assign&lt;/code&gt; Op to set the variable to its initial value.</source>
          <target state="translated">Este constructor crea tanto una &lt;code&gt;variable&lt;/code&gt; de Op y un &lt;code&gt;assign&lt;/code&gt; op para establecer la variable a su valor inicial.</target>
        </trans-unit>
        <trans-unit id="0853b5f1d96849514913dcea4715e205fe7e9be9" translate="yes" xml:space="preserve">
          <source>This constructor is private -- please use one of the following ops to build &lt;code&gt;RaggedTensor&lt;/code&gt;s:</source>
          <target state="translated">Este constructor es privado; utilice una de las siguientes operaciones para compilar &lt;code&gt;RaggedTensor&lt;/code&gt; s:</target>
        </trans-unit>
        <trans-unit id="fa9706d28ea0bf76646310aace552e8f79dee4fd" translate="yes" xml:space="preserve">
          <source>This constructor only applies if the algorithm is a counter-based algorithm. See method &lt;code&gt;key&lt;/code&gt; for the meaning of &quot;key&quot; and &quot;counter&quot;.</source>
          <target state="translated">Este constructor solo se aplica si el algoritmo es un algoritmo basado en contador. Consulte la &lt;code&gt;key&lt;/code&gt; m&amp;eacute;todo para conocer el significado de &quot;clave&quot; y &quot;contador&quot;.</target>
        </trans-unit>
        <trans-unit id="abd1f92b92080f9534139ad50b5578924ec063f6" translate="yes" xml:space="preserve">
          <source>This contains most of the synchronization implementation and also wraps the apply_gradients() from the real optimizer.</source>
          <target state="translated">Esto contiene la mayor parte de la implementación de la sincronización y también envuelve los apply_gradients()del optimizador real.</target>
        </trans-unit>
        <trans-unit id="dac62a0f0dbdc3c6a9231598871c80876ac21c3b" translate="yes" xml:space="preserve">
          <source>This context handler simplifies the exception handling. Use it as follows:</source>
          <target state="translated">Este manejador de contexto simplifica el manejo de las excepciones.Utilícelo de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="92e2326270a118c9b1678bb4952443a859f4c559" translate="yes" xml:space="preserve">
          <source>This context manager can be used to override the gradient function that will be used for ops within the scope of the context.</source>
          <target state="translated">Este gestor de contexto puede utilizarse para anular la función de gradiente que se utilizará para las operaciones dentro del ámbito del contexto.</target>
        </trans-unit>
        <trans-unit id="790e879037e30f5e5546c1be4c06bf6476dca2dd" translate="yes" xml:space="preserve">
          <source>This context manager captures all writes to a given stream inside of a &lt;code&gt;CapturedWrites&lt;/code&gt; object. When this context manager is created, it yields the &lt;code&gt;CapturedWrites&lt;/code&gt; object. The captured contents can be accessed by calling &lt;code&gt;.contents()&lt;/code&gt; on the &lt;code&gt;CapturedWrites&lt;/code&gt;.</source>
          <target state="translated">Este administrador de contexto captura todas las escrituras en una secuencia determinada dentro de un objeto &lt;code&gt;CapturedWrites&lt;/code&gt; . Cuando se crea este administrador de contexto, produce el objeto &lt;code&gt;CapturedWrites&lt;/code&gt; . Se puede acceder a los contenidos capturados llamando a &lt;code&gt;.contents()&lt;/code&gt; en &lt;code&gt;CapturedWrites&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41c375fab79db6dca2a3052fe26a3bb1f0a48127" translate="yes" xml:space="preserve">
          <source>This context manager creates and automatically recovers a session. It optionally starts the standard services that handle checkpoints and summaries. It monitors exceptions raised from the &lt;code&gt;with&lt;/code&gt; block or from the services and stops the supervisor as needed.</source>
          <target state="translated">Este administrador de contexto crea y recupera autom&amp;aacute;ticamente una sesi&amp;oacute;n. Opcionalmente inicia los servicios est&amp;aacute;ndar que manejan puntos de control y res&amp;uacute;menes. Supervisa las excepciones generadas desde el bloque &lt;code&gt;with&lt;/code&gt; o desde los servicios y detiene al supervisor seg&amp;uacute;n sea necesario.</target>
        </trans-unit>
        <trans-unit id="1dfc6367da2112861ba5a19ab74136e2bfa59bd7" translate="yes" xml:space="preserve">
          <source>This context manager pushes a name scope, which will make the name of all operations added within it have a prefix.</source>
          <target state="translated">Este gestor de contexto empuja un ámbito de nombre,que hará que el nombre de todas las operaciones añadidas dentro de él tengan un prefijo.</target>
        </trans-unit>
        <trans-unit id="cadf2e29564a69f6d9e78e18436e128fc8603a09" translate="yes" xml:space="preserve">
          <source>This context manager validates that the (optional) &lt;code&gt;values&lt;/code&gt; are from the same graph, ensures that graph is the default graph, and pushes a name scope and a variable scope.</source>
          <target state="translated">Este administrador de contexto valida que los &lt;code&gt;values&lt;/code&gt; (opcionales) son del mismo gr&amp;aacute;fico, asegura que el gr&amp;aacute;fico es el gr&amp;aacute;fico predeterminado y empuja un alcance de nombre y un alcance de variable.</target>
        </trans-unit>
        <trans-unit id="9fe8f8972b4d68b13082f0d96ff8de4b430acf3b" translate="yes" xml:space="preserve">
          <source>This context manager validates that the given &lt;code&gt;values&lt;/code&gt; are from the same graph, makes that graph the default graph, and pushes a name scope in that graph (see &lt;a href=&quot;../../../../graph#name_scope&quot;&gt;&lt;code&gt;tf.Graph.name_scope&lt;/code&gt;&lt;/a&gt; for more details on that).</source>
          <target state="translated">Este administrador de contexto valida que los &lt;code&gt;values&lt;/code&gt; dados son del mismo gr&amp;aacute;fico, hace que ese gr&amp;aacute;fico sea el gr&amp;aacute;fico predeterminado e inserta un alcance de nombre en ese gr&amp;aacute;fico (consulte &lt;a href=&quot;../../../../graph#name_scope&quot;&gt; &lt;code&gt;tf.Graph.name_scope&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s detalles sobre eso).</target>
        </trans-unit>
        <trans-unit id="8bc9405ecd91e0aa7f29a32f0b001ccc17dfce1e" translate="yes" xml:space="preserve">
          <source>This convenience method requires a session where the graph containing this variable has been launched. If no session is passed, the default session is used. See &lt;a href=&quot;compat/v1/session&quot;&gt;&lt;code&gt;tf.compat.v1.Session&lt;/code&gt;&lt;/a&gt; for more information on launching a graph and on sessions.</source>
          <target state="translated">Este m&amp;eacute;todo de conveniencia requiere una sesi&amp;oacute;n en la que se haya lanzado el gr&amp;aacute;fico que contiene esta variable. Si no se pasa ninguna sesi&amp;oacute;n, se utiliza la sesi&amp;oacute;n predeterminada. Consulte &lt;a href=&quot;compat/v1/session&quot;&gt; &lt;code&gt;tf.compat.v1.Session&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n sobre el lanzamiento de un gr&amp;aacute;fico y las sesiones.</target>
        </trans-unit>
        <trans-unit id="69597b8afaecf26bf780e17dbe96db99a176f9db" translate="yes" xml:space="preserve">
          <source>This convenience method requires a session where the graph containing this variable has been launched. If no session is passed, the default session is used. See &lt;a href=&quot;session&quot;&gt;&lt;code&gt;tf.compat.v1.Session&lt;/code&gt;&lt;/a&gt; for more information on launching a graph and on sessions.</source>
          <target state="translated">Este m&amp;eacute;todo de conveniencia requiere una sesi&amp;oacute;n en la que se haya lanzado el gr&amp;aacute;fico que contiene esta variable. Si no se pasa ninguna sesi&amp;oacute;n, se utiliza la sesi&amp;oacute;n predeterminada. Consulte &lt;a href=&quot;session&quot;&gt; &lt;code&gt;tf.compat.v1.Session&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n sobre el lanzamiento de un gr&amp;aacute;fico y las sesiones.</target>
        </trans-unit>
        <trans-unit id="049bd1098346a19ff3fab486ff6a7b47c3fd7819" translate="yes" xml:space="preserve">
          <source>This creates a &lt;code&gt;LinearOperator&lt;/code&gt; of the form &lt;code&gt;A = L + U D V^H&lt;/code&gt;, with &lt;code&gt;L&lt;/code&gt; a &lt;code&gt;LinearOperator&lt;/code&gt;, &lt;code&gt;U, V&lt;/code&gt; both [batch] matrices, and &lt;code&gt;D&lt;/code&gt; a [batch] diagonal matrix.</source>
          <target state="translated">Esto crea un &lt;code&gt;LinearOperator&lt;/code&gt; de la forma &lt;code&gt;A = L + U D V^H&lt;/code&gt; , con &lt;code&gt;L&lt;/code&gt; a &lt;code&gt;LinearOperator&lt;/code&gt; , &lt;code&gt;U, V&lt;/code&gt; ambas matrices [lote] y &lt;code&gt;D&lt;/code&gt; una matriz diagonal [lote].</target>
        </trans-unit>
        <trans-unit id="20e733fb47526c81e38b7224224a075d45127bb0" translate="yes" xml:space="preserve">
          <source>This creates a named directory on disk that is isolated to this test, and will be properly cleaned up by the test. This avoids several pitfalls of creating temporary directories for test purposes, as well as makes it easier to setup directories and verify their contents.</source>
          <target state="translated">Esto crea un directorio con nombre en el disco que está aislado a esta prueba,y será limpiado apropiadamente por la prueba.Esto evita varios escollos de la creación de directorios temporales para la prueba,así como facilita la creación de directorios y la verificación de su contenido.</target>
        </trans-unit>
        <trans-unit id="63a4f566bb13c25047e12750280d68497191b0d8" translate="yes" xml:space="preserve">
          <source>This creates a named directory on disk that is isolated to this test, and will be properly cleaned up by the test. This avoids several pitfalls of creating temporary directories for test purposes, as well as makes it easier to setup directories and verify their contents. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75714df8d9550841d3043fbd62dad500169275e6" translate="yes" xml:space="preserve">
          <source>This creates a named file on disk that is isolated to this test, and will be properly cleaned up by the test. This avoids several pitfalls of creating temporary files for test purposes, as well as makes it easier to setup files, their data, read them back, and inspect them when a test fails.</source>
          <target state="translated">Esto crea un archivo con nombre en el disco que se aísla a esta prueba,y será limpiado adecuadamente por la prueba.Esto evita varios escollos de la creación de archivos temporales para fines de prueba,así como facilita la configuración de los archivos,sus datos,su lectura y su inspección cuando una prueba falla.</target>
        </trans-unit>
        <trans-unit id="2f4f8ffa306c5f0499e24ea63e1e0e690360c7a3" translate="yes" xml:space="preserve">
          <source>This creates a named file on disk that is isolated to this test, and will be properly cleaned up by the test. This avoids several pitfalls of creating temporary files for test purposes, as well as makes it easier to setup files, their data, read them back, and inspect them when a test fails. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42646afd71d42ede988399add1a74a5f6b4c93c2" translate="yes" xml:space="preserve">
          <source>This creates a tuple of tensors with the same values as the &lt;code&gt;tensors&lt;/code&gt; argument, except that the value of each tensor is only returned after the values of all tensors have been computed.</source>
          <target state="translated">Esto crea una tupla de tensores con los mismos valores que el argumento de &lt;code&gt;tensors&lt;/code&gt; , excepto que el valor de cada tensor solo se devuelve despu&amp;eacute;s de que se hayan calculado los valores de todos los tensores.</target>
        </trans-unit>
        <trans-unit id="89651a110f241aba282c0d3c4d5816a82b95a5ce" translate="yes" xml:space="preserve">
          <source>This dataset attempts to determine whether a valid snapshot exists at the &lt;code&gt;snapshot_path&lt;/code&gt;, and reads from the snapshot in lieu of using &lt;code&gt;input_dataset&lt;/code&gt;. If not, it will run the preprocessing pipeline as usual, and write out a snapshot of the data processed for future use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9dc1c4d1a56233dc4a8e886da12f3f0a495623a" translate="yes" xml:space="preserve">
          <source>This dataset fills a buffer with &lt;code&gt;buffer_size&lt;/code&gt; elements, then randomly samples elements from this buffer, replacing the selected elements with new elements. For perfect shuffling, a buffer size greater than or equal to the full size of the dataset is required.</source>
          <target state="translated">Este conjunto de datos llena un b&amp;uacute;fer con elementos &lt;code&gt;buffer_size&lt;/code&gt; , luego muestrea aleatoriamente los elementos de este b&amp;uacute;fer, reemplazando los elementos seleccionados con elementos nuevos. Para una mezcla perfecta, se requiere un tama&amp;ntilde;o de b&amp;uacute;fer mayor o igual que el tama&amp;ntilde;o completo del conjunto de datos.</target>
        </trans-unit>
        <trans-unit id="28c299276126ace248fef26b3267fca38b82ca7a" translate="yes" xml:space="preserve">
          <source>This dataset has been superseded by &lt;code&gt;ParallelInterleaveDatasetV2&lt;/code&gt;. New code should use &lt;code&gt;ParallelInterleaveDatasetV2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97fff19a84ee410a08999fab8be4d199f9066fdc" translate="yes" xml:space="preserve">
          <source>This dataset operator is very useful when running distributed training, as it allows each worker to read a unique subset.</source>
          <target state="translated">Este operador del conjunto de datos es muy útil cuando se realiza un entrenamiento distribuido,ya que permite a cada trabajador leer un subconjunto único.</target>
        </trans-unit>
        <trans-unit id="0601b18d7846c9e12aa36064d4b2b93f04fe9903" translate="yes" xml:space="preserve">
          <source>This dataset will throw a NotFound error if we cannot shard the dataset automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38966f21ae4fd315566bc2e9e41902f2d11ad1fd" translate="yes" xml:space="preserve">
          <source>This decorator allows fine grained control over the gradients of a sequence for operations. This may be useful for multiple reasons, including providing a more efficient or numerically stable gradient for a sequence of operations.</source>
          <target state="translated">Este decorador permite un control de grano fino sobre los gradientes de una secuencia para operaciones.Esto puede ser útil por múltiples razones,entre ellas la de proporcionar un gradiente más eficiente o numéricamente estable para una secuencia de operaciones.</target>
        </trans-unit>
        <trans-unit id="507c4c48f689d10862643a9c65b8ad1497b61251" translate="yes" xml:space="preserve">
          <source>This decorator injects the decorated class or function into the Keras custom object dictionary, so that it can be serialized and deserialized without needing an entry in the user-provided custom object dict. It also injects a function that Keras will call to get the object's serializable string key.</source>
          <target state="translated">Este decorador inyecta la clase o función decorada en el diccionario de objetos personalizados de Keras,para que pueda ser serializada y deserializada sin necesidad de una entrada en el diccionario de objetos personalizados proporcionado por el usuario.También inyecta una función que Keras llamará para obtener la clave de cadena serializable del objeto.</target>
        </trans-unit>
        <trans-unit id="99ba7a22516d6648f4353818a77d3239c06fe661" translate="yes" xml:space="preserve">
          <source>This decorator is only used when defining a new op type. For an op with &lt;code&gt;m&lt;/code&gt; inputs and &lt;code&gt;n&lt;/code&gt; outputs, the gradient function is a function that takes the original &lt;code&gt;Operation&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; objects (representing the gradients with respect to each output of the op), and returns &lt;code&gt;m&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; objects (representing the partial gradients with respect to each input of the op).</source>
          <target state="translated">Este decorador solo se usa al definir un nuevo tipo de operaci&amp;oacute;n. Para una operaci&amp;oacute;n con &lt;code&gt;m&lt;/code&gt; entradas &lt;code&gt;n&lt;/code&gt; salidas, la funci&amp;oacute;n de gradiente es una funci&amp;oacute;n que toma la &lt;code&gt;Operation&lt;/code&gt; original y &lt;code&gt;n&lt;/code&gt; objetos &lt;code&gt;Tensor&lt;/code&gt; (que representan los gradientes con respecto a cada salida de la operaci&amp;oacute;n ), y devuelve &lt;code&gt;m&lt;/code&gt; objetos &lt;code&gt;Tensor&lt;/code&gt; (que representan los gradientes parciales con respecto a cada entrada de la operaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="f69390eec43b9170084ec67f23f7df44213faadc" translate="yes" xml:space="preserve">
          <source>This defines the skeleton for all implementations of ClusterResolvers. ClusterResolvers are a way for TensorFlow to communicate with various cluster management systems (e.g. GCE, AWS, etc...) and gives TensorFlow necessary information to set up distributed training.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31c4ff795b26f67c26110ef2a390028f451d7769" translate="yes" xml:space="preserve">
          <source>This defines the skeleton for all implementations of ClusterResolvers. ClusterResolvers are a way for TensorFlow to communicate with various cluster management systems (e.g. GCE, AWS, etc...).</source>
          <target state="translated">Esto define el esqueleto de todas las implementaciones de los ClusterResolvers.Los ClusterResolvers son una forma de que TensorFlow se comunique con varios sistemas de gestión de clústeres (por ejemplo,GCE,AWS,etc...).</target>
        </trans-unit>
        <trans-unit id="0df31e40439c17db3321616e25b535cdb0316252" translate="yes" xml:space="preserve">
          <source>This definition of cell differs from the definition used in the literature. In the literature, 'cell' refers to an object with a single scalar output. This definition refers to a horizontal array of such units.</source>
          <target state="translated">Esta definición de célula difiere de la definición utilizada en la literatura.En la literatura,&quot;célula&quot; se refiere a un objeto con una única salida escalar.Esta definición se refiere a un conjunto horizontal de tales unidades.</target>
        </trans-unit>
        <trans-unit id="0725a72c209eb53df1440f5a39a25dbf2ab21a14" translate="yes" xml:space="preserve">
          <source>This distribution has parameters: degree of freedom &lt;code&gt;df&lt;/code&gt;, location &lt;code&gt;loc&lt;/code&gt;, and &lt;code&gt;scale&lt;/code&gt;.</source>
          <target state="translated">Esta distribuci&amp;oacute;n tiene par&amp;aacute;metros: grado de libertad &lt;code&gt;df&lt;/code&gt; , ubicaci&amp;oacute;n &lt;code&gt;loc&lt;/code&gt; y &lt;code&gt;scale&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11a222f9738197dadd6eb7c453e22ae24d0f3567" translate="yes" xml:space="preserve">
          <source>This does not close the session.</source>
          <target state="translated">Esto no cierra la sesión.</target>
        </trans-unit>
        <trans-unit id="e3bddf2a09aebf2b7d2bb27cde671e8328a7dc27" translate="yes" xml:space="preserve">
          <source>This does not undo the effects of loss scaling. Any optimizers wrapped with a LossScaleOptimizer will continue to do loss scaling, although this loss scaling will no longer be useful if the optimizer is used in new Sessions, as the graph rewrite no longer converts the graph to use float16.</source>
          <target state="translated">Esto no anula los efectos de la escala de pérdidas.Cualquier optimizador envuelto con un Optimizador de Escala de Pérdidas continuará haciendo escalado de pérdidas,aunque este escalado de pérdidas ya no será útil si el optimizador se utiliza en nuevas Sesiones,ya que la reescritura de la gráfica ya no convierte la gráfica para utilizar el flotador16.</target>
        </trans-unit>
        <trans-unit id="02c54112c729e547b6e3e03e55cab5ced9766b9c" translate="yes" xml:space="preserve">
          <source>This does not undo the effects of loss scaling. Any optimizers wrapped with a LossScaleOptimizer will continue to do loss scaling, although this loss scaling will no longer be useful, as the graph rewrite no longer converts tf.functions to use float16.</source>
          <target state="translated">Esto no anula los efectos de la escala de pérdidas.Cualquier optimizador envuelto con un Optimizador de Escala de Pérdidas continuará haciendo escalada de pérdidas,aunque esta escalada de pérdidas ya no será útil,ya que la reescritura del gráfico ya no convierte a tf.functions a usar float16.</target>
        </trans-unit>
        <trans-unit id="3bfa5300d7e625917e03fb074107ed12abbdcbbe" translate="yes" xml:space="preserve">
          <source>This eliminates the overhead of &lt;code&gt;k-1&lt;/code&gt; calls to &lt;code&gt;space_to_batch_nd&lt;/code&gt; and &lt;code&gt;batch_to_space_nd&lt;/code&gt;.</source>
          <target state="translated">Esto elimina la sobrecarga de llamadas &lt;code&gt;k-1&lt;/code&gt; a &lt;code&gt;space_to_batch_nd&lt;/code&gt; y &lt;code&gt;batch_to_space_nd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c1542adb4efbb08745cf8660782eb015be7e9a8" translate="yes" xml:space="preserve">
          <source>This enables the new behavior.</source>
          <target state="translated">Esto permite el nuevo comportamiento.</target>
        </trans-unit>
        <trans-unit id="e158c4e53eb8ef556e4d562ffa77e16f6fc696bb" translate="yes" xml:space="preserve">
          <source>This enables the user to close and release the resource in the middle of a step/run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b70309885ebd2feded30214b2bff057bfcef522b" translate="yes" xml:space="preserve">
          <source>This enables variables to be read as bfloat16 type when using get_variable.</source>
          <target state="translated">Esto permite que las variables sean leídas como tipo bfloat16 cuando se usa get_variable.</target>
        </trans-unit>
        <trans-unit id="9b4ec5604b14a4a73674990062864327b53e189b" translate="yes" xml:space="preserve">
          <source>This enumeration represents optional conversion options.</source>
          <target state="translated">Esta enumeración representa opciones de conversión opcionales.</target>
        </trans-unit>
        <trans-unit id="26d8315a3de6d7adfdf3bbd23a3ef83e0e870212" translate="yes" xml:space="preserve">
          <source>This estimator ignores feature values and will learn to predict the average value of each label. E.g. for single-label classification problems, this will predict the probability distribution of the classes as seen in the labels. For multi-label classification problems, it will predict the ratio of examples that contain each class.</source>
          <target state="translated">Este estimador ignora los valores de las características y aprenderá a predecir el valor promedio de cada etiqueta.Por ejemplo,para los problemas de clasificación de una sola etiqueta,esto predecirá la distribución de probabilidad de las clases como se ve en las etiquetas.Para problemas de clasificación de múltiples etiquetas,predecirá la proporción de ejemplos que contienen cada clase.</target>
        </trans-unit>
        <trans-unit id="c0a3c93652b7acdf673bb2d9770fb27696ed0299" translate="yes" xml:space="preserve">
          <source>This example creates a lookup layer and generates the vocabulary by analyzing the dataset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9de20f542fbd733883e56dc873754dfb758c273" translate="yes" xml:space="preserve">
          <source>This example creates a lookup layer with a pre-existing vocabulary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0b0f0177841bd64344b603ca5701c7a1c4bfeec" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to map indices to strings using this layer. (You can also use adapt() with inverse=True, but for simplicity we'll pass the vocab in this example.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a755e66edb0249a30f62c3fbfa9da1107d08395" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to map indices to values using this layer. (You can also use adapt() with inverse=True, but for simplicity we'll pass the vocab in this example.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="494bbe4febd153531076a3e5cddcbab4e936bc24" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to use a lookup layer with multiple OOV tokens. When a layer is created with more than one OOV token, any OOV values are hashed into the number of OOV buckets, distributing OOV values in a deterministic fashion across the set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69a4365d2fc53f53ca98893f19670abd4d1d2032" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to use the vocabulary of a standard lookup layer to create an inverse lookup layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a68786f5a17b7958b628ee0e8691b24f56ab38dc" translate="yes" xml:space="preserve">
          <source>This example gives binary output instead of counting the occurrence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f03708fe58a6d112475001cb64ef56af4e257ac" translate="yes" xml:space="preserve">
          <source>This example instantiates a TextVectorization layer that lowercases text, splits on whitespace, strips punctuation, and outputs integer vocab indices.</source>
          <target state="translated">Este ejemplo instancializa una capa de TextVectorization que pone el texto en minúsculas,lo divide en espacios en blanco,elimina la puntuación y produce índices de vocabulario entero.</target>
        </trans-unit>
        <trans-unit id="ee52f3666629477330cedb91ea1ff2368d33cc78" translate="yes" xml:space="preserve">
          <source>This example shows how to instantiate a layer that applies the same dense operation to every element in a sequence, but uses the ellipsis notation instead of specifying the batch and sequence dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d7af74c46a4fae38ce9ff64ebe601e504aada00" translate="yes" xml:space="preserve">
          <source>This example shows how to instantiate a layer that applies the same dense operation to every element in a sequence. Here, the 'output_shape' has two values (since there are two non-batch dimensions in the output); the first dimension in the output_shape is &lt;code&gt;None&lt;/code&gt;, because the sequence dimension &lt;code&gt;b&lt;/code&gt; has an unknown shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7e9f20f12802c04c896151951f7fd5800246d6c" translate="yes" xml:space="preserve">
          <source>This example shows how to instantiate a standard Keras dense layer using einsum operations. This example is equivalent to &lt;a href=&quot;../dense&quot;&gt;&lt;code&gt;tf.keras.layers.Dense(64, use_bias=True)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf32128894beae4e1d5986c66f68269f1ae0857f" translate="yes" xml:space="preserve">
          <source>This example takes a 2 dimensional input and returns a &lt;code&gt;Tensor&lt;/code&gt; with bincounting on each sample.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f9c3d77008f03aede1949e1e8b86cf490084ce8" translate="yes" xml:space="preserve">
          <source>This example takes an input (which could be a Tensor, RaggedTensor, or SparseTensor) and returns a SparseTensor where (i,j) is 1 if the value j appears in batch i at least once and is 0 otherwise. Note that, even though some values (like 20 in batch 1 and 11 in batch 2) appear more than once, the 'values' tensor is all 1s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3981b34919fca04a3be3649adee342abfe3505a" translate="yes" xml:space="preserve">
          <source>This example takes an input (which could be a Tensor, RaggedTensor, or SparseTensor) and returns a SparseTensor where the value of (i,j) is the number of times value j appears in batch i.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dd04c77a84f7fb7b79c65a0782e87dc8901b29b" translate="yes" xml:space="preserve">
          <source>This example takes an input (which could be a Tensor, RaggedTensor, or SparseTensor) and returns a SparseTensor where the value of (i,j) is the number of times value j appears in batch i. However, all values of j above 'maxlength' are ignored. The dense_shape of the output sparse tensor is set to 'minlength'. Note that, while the input is identical to the example above, the value '10001' in batch item 2 is dropped, and the dense shape is [2, 500] instead of [2,10002] or [2, 102].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ad6c7816616b3241d748e89b2cfcff037903efa" translate="yes" xml:space="preserve">
          <source>This example takes two inputs - a values tensor and a weights tensor. These tensors must be identically shaped, and have the same row splits or indices in the case of RaggedTensors or SparseTensors. When performing a weighted count, the op will output a SparseTensor where the value of (i, j) is the sum of the values in the weight tensor's batch i in the locations where the values tensor has the value j. In this case, the output dtype is the same as the dtype of the weights tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b8a0001b21c834c94ffc58110b29147780ed1bc" translate="yes" xml:space="preserve">
          <source>This exception is most commonly raised when running an operation that reads a &lt;a href=&quot;../variable&quot;&gt;&lt;code&gt;tf.Variable&lt;/code&gt;&lt;/a&gt; before it has been initialized.</source>
          <target state="translated">Esta excepci&amp;oacute;n se &lt;a href=&quot;../variable&quot;&gt; &lt;code&gt;tf.Variable&lt;/code&gt; &lt;/a&gt; mayor frecuencia cuando se ejecuta una operaci&amp;oacute;n que lee una variable tf.Variable antes de que se haya inicializado.</target>
        </trans-unit>
        <trans-unit id="5c5a8c57c6d5ff0bef6c24b2e2bd3f673907515f" translate="yes" xml:space="preserve">
          <source>This exception is not currently used.</source>
          <target state="translated">Esta excepción no se utiliza actualmente.</target>
        </trans-unit>
        <trans-unit id="f99d6b607eb42d98eb52dda612321114e3e91d9d" translate="yes" xml:space="preserve">
          <source>This exception is raised in &quot;end-of-file&quot; conditions, such as when a &lt;code&gt;tf.QueueBase.dequeue&lt;/code&gt; operation is blocked on an empty queue, and a &lt;code&gt;tf.QueueBase.close&lt;/code&gt; operation executes.</source>
          <target state="translated">Esta excepci&amp;oacute;n se genera en condiciones de &quot;fin de archivo&quot;, como cuando una operaci&amp;oacute;n &lt;code&gt;tf.QueueBase.dequeue&lt;/code&gt; se bloquea en una cola vac&amp;iacute;a y se ejecuta una operaci&amp;oacute;n &lt;code&gt;tf.QueueBase.close&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78d71c0636a2aa1fd087c8298d2d2e031276f9b2" translate="yes" xml:space="preserve">
          <source>This exception is raised when some invariant expected by the runtime has been broken. Catching this exception is not recommended.</source>
          <target state="translated">Esta excepción se plantea cuando se ha roto alguna invariante esperada por el tiempo de ejecución.No se recomienda la captura de esta excepción.</target>
        </trans-unit>
        <trans-unit id="7057b737e9dfe1ba0218e510ec51533edf1eab95" translate="yes" xml:space="preserve">
          <source>This exists primarily to support the definition of type-specific summary ops like scalar() and image(), and is not intended for direct use unless defining a new type-specific summary op.</source>
          <target state="translated">Esto existe principalmente para apoyar la definición de operaciones sumarias específicas del tipo como scalar()e image(),y no está destinado a su uso directo a menos que se defina una nueva operación sumaria específica del tipo.</target>
        </trans-unit>
        <trans-unit id="42562f80c79b3f19581dfb21136c32f3ec5adea4" translate="yes" xml:space="preserve">
          <source>This facilitates a cleaner api around global state. Instead of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7cea24b85385b2c626baad7c000ac087d0ac17d" translate="yes" xml:space="preserve">
          <source>This file includes functions and constants from core (model_utils) and export.py</source>
          <target state="translated">Este archivo incluye funciones y constantes del núcleo (model_utils)y export.py</target>
        </trans-unit>
        <trans-unit id="1ed5997b223ee14f22d4d6301133fe48a3becd70" translate="yes" xml:space="preserve">
          <source>This flag will have a value of None, True or False. None is possible if default=None and the user does not specify the flag on the command line.</source>
          <target state="translated">Esta bandera tendrá un valor de Ninguno,Verdadero o Falso.Ninguno es posible si default=Ninguno y el usuario no especifica la bandera en la línea de comandos.</target>
        </trans-unit>
        <trans-unit id="edc3e42fb098d2f82cf52f313f0a2bbc39d59acf" translate="yes" xml:space="preserve">
          <source>This foldl operator repeatedly applies the callable &lt;code&gt;fn&lt;/code&gt; to a sequence of elements from first to last. The elements are made of the tensors unpacked from &lt;code&gt;elems&lt;/code&gt; on dimension 0. The callable fn takes two tensors as arguments. The first argument is the accumulated value computed from the preceding invocation of fn, and the second is the value at the current position of &lt;code&gt;elems&lt;/code&gt;. If &lt;code&gt;initializer&lt;/code&gt; is None, &lt;code&gt;elems&lt;/code&gt; must contain at least one element, and its first element is used as the initializer.</source>
          <target state="translated">Este operador foldl aplica repetidamente el &lt;code&gt;fn&lt;/code&gt; invocable a una secuencia de elementos del primero al &amp;uacute;ltimo. Los elementos est&amp;aacute;n hechos de tensores desempaquetados de &lt;code&gt;elems&lt;/code&gt; en la dimensi&amp;oacute;n 0. El fn invocable toma dos tensores como argumentos. El primer argumento es el valor acumulado calculado a partir de la invocaci&amp;oacute;n anterior de fn, y el segundo es el valor en la posici&amp;oacute;n actual de &lt;code&gt;elems&lt;/code&gt; . Si el &lt;code&gt;initializer&lt;/code&gt; es Ninguno, &lt;code&gt;elems&lt;/code&gt; debe contener al menos un elemento y su primer elemento se utiliza como inicializador.</target>
        </trans-unit>
        <trans-unit id="5c9efc4e60690682d054976cd526187b0ec74f90" translate="yes" xml:space="preserve">
          <source>This foldr operator repeatedly applies the callable &lt;code&gt;fn&lt;/code&gt; to a sequence of elements from last to first. The elements are made of the tensors unpacked from &lt;code&gt;elems&lt;/code&gt;. The callable fn takes two tensors as arguments. The first argument is the accumulated value computed from the preceding invocation of fn, and the second is the value at the current position of &lt;code&gt;elems&lt;/code&gt;. If &lt;code&gt;initializer&lt;/code&gt; is None, &lt;code&gt;elems&lt;/code&gt; must contain at least one element, and its first element is used as the initializer.</source>
          <target state="translated">Este operador foldr aplica repetidamente el &lt;code&gt;fn&lt;/code&gt; invocable a una secuencia de elementos del &amp;uacute;ltimo al primero. Los elementos est&amp;aacute;n hechos de tensores desempaquetados de &lt;code&gt;elems&lt;/code&gt; . El fn invocable toma dos tensores como argumentos. El primer argumento es el valor acumulado calculado a partir de la invocaci&amp;oacute;n anterior de fn, y el segundo es el valor en la posici&amp;oacute;n actual de &lt;code&gt;elems&lt;/code&gt; . Si el &lt;code&gt;initializer&lt;/code&gt; es Ninguno, &lt;code&gt;elems&lt;/code&gt; debe contener al menos un elemento y su primer elemento se utiliza como inicializador.</target>
        </trans-unit>
        <trans-unit id="e47bc5be6551c40b285b99814572b5e2b249a8b5" translate="yes" xml:space="preserve">
          <source>This function adds operations to the current session. To compute the error using a particular device, such as a GPU, use the standard methods for setting a device (e.g. using with sess.graph.device() or setting a device function in the session constructor).</source>
          <target state="translated">Esta función añade operaciones a la sesión actual.Para calcular el error utilizando un dispositivo concreto,como una GPU,utilice los métodos estándar para establecer un dispositivo (por ejemplo,utilizando con sess.graph.device()o estableciendo una función de dispositivo en el constructor de la sesión).</target>
        </trans-unit>
        <trans-unit id="b1c988623a891fbccad5b0fbb3db51dcb83f9a90" translate="yes" xml:space="preserve">
          <source>This function adds the following to the current &lt;code&gt;Graph&lt;/code&gt;:</source>
          <target state="translated">Esta funci&amp;oacute;n agrega lo siguiente al &lt;code&gt;Graph&lt;/code&gt; actual :</target>
        </trans-unit>
        <trans-unit id="7391056d9f36003196c437fbb04f6186eed40dde" translate="yes" xml:space="preserve">
          <source>This function allows expressing computations in a TensorFlow graph as Python functions. In particular, it wraps a Python function &lt;code&gt;func&lt;/code&gt; in a once-differentiable TensorFlow operation that executes it with eager execution enabled. As a consequence, &lt;a href=&quot;py_function&quot;&gt;&lt;code&gt;tf.py_function&lt;/code&gt;&lt;/a&gt; makes it possible to express control flow using Python constructs (&lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, etc.), instead of TensorFlow control flow constructs (&lt;a href=&quot;cond&quot;&gt;&lt;code&gt;tf.cond&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;while_loop&quot;&gt;&lt;code&gt;tf.while_loop&lt;/code&gt;&lt;/a&gt;). For example, you might use &lt;a href=&quot;py_function&quot;&gt;&lt;code&gt;tf.py_function&lt;/code&gt;&lt;/a&gt; to implement the log huber function:</source>
          <target state="translated">Esta funci&amp;oacute;n permite expresar c&amp;aacute;lculos en un gr&amp;aacute;fico de TensorFlow como funciones de Python. En particular, se envuelve una funci&amp;oacute;n de Python &lt;code&gt;func&lt;/code&gt; en una operaci&amp;oacute;n TensorFlow vez diferenciable que se ejecuta con habilitada la ejecuci&amp;oacute;n ansiosos. Como consecuencia, &lt;a href=&quot;py_function&quot;&gt; &lt;code&gt;tf.py_function&lt;/code&gt; &lt;/a&gt; hace posible expresar el flujo de control usando construcciones de Python ( &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; , etc.), en lugar de construcciones de flujo de control de TensorFlow ( &lt;a href=&quot;cond&quot;&gt; &lt;code&gt;tf.cond&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;while_loop&quot;&gt; &lt;code&gt;tf.while_loop&lt;/code&gt; &lt;/a&gt; . while_loop ). Por ejemplo, puede usar &lt;a href=&quot;py_function&quot;&gt; &lt;code&gt;tf.py_function&lt;/code&gt; &lt;/a&gt; para implementar la funci&amp;oacute;n log huber:</target>
        </trans-unit>
        <trans-unit id="fa49b9c5fb3cc27a08b15ff4c8fbc286bffc2bb3" translate="yes" xml:space="preserve">
          <source>This function allows replacing a function wrapped by &lt;code&gt;decorator_func&lt;/code&gt;, assuming the decorator that wraps the function is written as described below.</source>
          <target state="translated">Esta funci&amp;oacute;n permite reemplazar una funci&amp;oacute;n envuelta por &lt;code&gt;decorator_func&lt;/code&gt; , asumiendo que el decorador que envuelve la funci&amp;oacute;n est&amp;aacute; escrito como se describe a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f1af1fe4443bcb9edf1df9ce5ca5cc1b073069a3" translate="yes" xml:space="preserve">
          <source>This function also returns a &lt;code&gt;should_apply_gradients&lt;/code&gt; bool. If False, gradients should not be applied to the variables that step, as nonfinite gradients were found, and the loss scale has been be updated to reduce the chance of finding nonfinite gradients in the next step. Some loss scale classes will always return True, as they cannot adjust themselves in response to nonfinite gradients.</source>
          <target state="translated">Esta funci&amp;oacute;n tambi&amp;eacute;n devuelve un bool &lt;code&gt;should_apply_gradients&lt;/code&gt; . Si es Falso, los gradientes no se deben aplicar a las variables de ese paso, ya que se encontraron gradientes no finitos y la escala de p&amp;eacute;rdida se ha actualizado para reducir la posibilidad de encontrar gradientes no finitos en el siguiente paso. Algunas clases de escala de p&amp;eacute;rdida siempre devolver&amp;aacute;n True, ya que no pueden ajustarse en respuesta a gradientes no finitos.</target>
        </trans-unit>
        <trans-unit id="a970dd1ee86d1ed9e7a0f4a5fcb3e14f9903fdf2" translate="yes" xml:space="preserve">
          <source>This function assumes that &lt;code&gt;img1&lt;/code&gt; and &lt;code&gt;img2&lt;/code&gt; are image batches, i.e. the last three dimensions are [height, width, channels].</source>
          <target state="translated">Esta funci&amp;oacute;n asume que &lt;code&gt;img1&lt;/code&gt; e &lt;code&gt;img2&lt;/code&gt; son lotes de im&amp;aacute;genes, es decir, las &amp;uacute;ltimas tres dimensiones son [altura, ancho, canales].</target>
        </trans-unit>
        <trans-unit id="05e4418b517bd473a485966680131f4c4c444d83" translate="yes" xml:space="preserve">
          <source>This function attempts to partially evaluate the given tensor, and returns its value as a numpy ndarray if this succeeds.</source>
          <target state="translated">Esta función intenta evaluar parcialmente el tensor dado,y devuelve su valor como un ndarray numérico si esto tiene éxito.</target>
        </trans-unit>
        <trans-unit id="cf86c424c057435bb07a468ed262a1bc87e5ff48" translate="yes" xml:space="preserve">
          <source>This function can be called at the beginning of the program (before &lt;code&gt;Tensors&lt;/code&gt;, &lt;code&gt;Graphs&lt;/code&gt; or other structures have been created, and before devices have been initialized. It switches all global behaviors that are different between TensorFlow 1.x and 2.x to behave as intended for 1.x.</source>
          <target state="translated">Esta funci&amp;oacute;n se puede llamar al comienzo del programa (antes de que se &lt;code&gt;Tensors&lt;/code&gt; , &lt;code&gt;Graphs&lt;/code&gt; u otras estructuras, y antes de que se inicialicen los dispositivos. Cambia todos los comportamientos globales que son diferentes entre TensorFlow 1.xy 2.x para que se comporten como destinado a 1.x.</target>
        </trans-unit>
        <trans-unit id="10057d11c28687d408d56022580e8ea6fe2a793b" translate="yes" xml:space="preserve">
          <source>This function can be called at the beginning of the program (before &lt;code&gt;Tensors&lt;/code&gt;, &lt;code&gt;Graphs&lt;/code&gt; or other structures have been created, and before devices have been initialized. It switches all global behaviors that are different between TensorFlow 1.x and 2.x to behave as intended for 2.x.</source>
          <target state="translated">Esta funci&amp;oacute;n se puede llamar al comienzo del programa (antes de que se &lt;code&gt;Tensors&lt;/code&gt; , &lt;code&gt;Graphs&lt;/code&gt; u otras estructuras, y antes de que se inicialicen los dispositivos. Cambia todos los comportamientos globales que son diferentes entre TensorFlow 1.xy 2.x para que se comporten como destinado a 2.x.</target>
        </trans-unit>
        <trans-unit id="b42e569daa67e0a1534f20b78d521ba43e71fa0e" translate="yes" xml:space="preserve">
          <source>This function can be used to calculate a suitable paddings argument for use with space_to_batch_nd and batch_to_space_nd.</source>
          <target state="translated">Esta función puede utilizarse para calcular un argumento de relleno adecuado para su uso con space_to_batch_nd y batch_to_space_nd.</target>
        </trans-unit>
        <trans-unit id="c744362e6d55098ce01656aff7353b51e78a3f8e" translate="yes" xml:space="preserve">
          <source>This function can be useful when composing a new operation in Python (such as &lt;code&gt;my_func&lt;/code&gt; in the example above). All standard Python op constructors apply this function to each of their Tensor-valued inputs, which allows those ops to accept numpy arrays, Python lists, and scalars in addition to &lt;code&gt;Tensor&lt;/code&gt; objects.</source>
          <target state="translated">Esta funci&amp;oacute;n puede ser &amp;uacute;til al componer una nueva operaci&amp;oacute;n en Python (como &lt;code&gt;my_func&lt;/code&gt; en el ejemplo anterior). Todos los constructores de operaciones est&amp;aacute;ndar de Python aplican esta funci&amp;oacute;n a cada una de sus entradas valoradas por Tensor, lo que permite que esas operaciones acepten matrices numerosas, listas de Python y escalares adem&amp;aacute;s de los objetos &lt;code&gt;Tensor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="217d0b2441a5002feaf4d45bd68846f61852099e" translate="yes" xml:space="preserve">
          <source>This function can compute several different vector norms (the 1-norm, the Euclidean or 2-norm, the inf-norm, and in general the p-norm for p &amp;gt; 0) and matrix norms (Frobenius, 1-norm, 2-norm and inf-norm).</source>
          <target state="translated">Esta funci&amp;oacute;n puede calcular varias normas vectoriales diferentes (la norma 1, la euclidiana o la norma 2, la norma inf y, en general, la p-norma para p&amp;gt; 0) y las normas matriciales (Frobenius, 1-norma, 2- norma e inf-norma).</target>
        </trans-unit>
        <trans-unit id="3ea434ce2125739c9300b55f884e2363f68836bb" translate="yes" xml:space="preserve">
          <source>This function can only be called before any Graphs, Ops, or Tensors have been created. It can be used at the beginning of the program for complex migration projects from TensorFlow 1.x to 2.x.</source>
          <target state="translated">Esta función sólo puede ser llamada antes de que se haya creado cualquier gráfico,operación o tensor.Puede ser utilizada al principio del programa para proyectos complejos de migración de TensorFlow 1.x a 2.x.</target>
        </trans-unit>
        <trans-unit id="588718f27309c0577e10569b211613b30b1126d6" translate="yes" xml:space="preserve">
          <source>This function casts the input to &lt;code&gt;dtype&lt;/code&gt; without applying any scaling. If there is a danger that values would over or underflow in the cast, this op applies the appropriate clamping before the cast.</source>
          <target state="translated">Esta funci&amp;oacute;n &lt;code&gt;dtype&lt;/code&gt; la entrada en dtype sin aplicar ninguna escala. Si existe el peligro de que los valores se desborden o desborden en el modelo, esta operaci&amp;oacute;n aplica la sujeci&amp;oacute;n adecuada antes del modelo.</target>
        </trans-unit>
        <trans-unit id="09decee67bf539dd150a70f2c58935c601acb068" translate="yes" xml:space="preserve">
          <source>This function computes the exponential of every element in the input tensor. i.e. &lt;code&gt;exp(x)&lt;/code&gt; or &lt;code&gt;e^(x)&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is the input tensor. &lt;code&gt;e&lt;/code&gt; denotes Euler's number and is approximately equal to 2.718281. Output is positive for any real input.</source>
          <target state="translated">Esta funci&amp;oacute;n calcula el exponencial de cada elemento en el tensor de entrada. es decir, &lt;code&gt;exp(x)&lt;/code&gt; o &lt;code&gt;e^(x)&lt;/code&gt; , donde &lt;code&gt;x&lt;/code&gt; es el tensor de entrada. &lt;code&gt;e&lt;/code&gt; denota el n&amp;uacute;mero de Euler y es aproximadamente igual a 2.718281. La salida es positiva para cualquier entrada real.</target>
        </trans-unit>
        <trans-unit id="5fcc9bd16353155f925829234fcc96a9dbe0c86d" translate="yes" xml:space="preserve">
          <source>This function computes the exponential of the input tensor element-wise. i.e. &lt;a href=&quot;exp&quot;&gt;&lt;code&gt;math.exp(x)&lt;/code&gt;&lt;/a&gt; or \(e^x\), where &lt;code&gt;x&lt;/code&gt; is the input tensor. \(e\) denotes Euler's number and is approximately equal to 2.718281. Output is positive for any real input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c0a191a50e5e9af59c01d8569f306fc43d930b1" translate="yes" xml:space="preserve">
          <source>This function computes the matrix logarithm using the Schur-Parlett algorithm. Details of the algorithm can be found in Section 11.6.2 of: Nicholas J. Higham, Functions of Matrices: Theory and Computation, SIAM 2008. ISBN 978-0-898716-46-7.</source>
          <target state="translated">Esta función calcula el logaritmo de la matriz usando el algoritmo de Schur-Parlett.Los detalles del algoritmo se pueden encontrar en la sección 11.6.2 de:Nicholas J.Higham,Funciones de las matrices:Theory and Computation,SIAM 2008.ISBN 978-0-898716-46-7.</target>
        </trans-unit>
        <trans-unit id="be1f544dd8e61bda50e9ba11ee30c7fa32e6f8ea" translate="yes" xml:space="preserve">
          <source>This function converts Python objects of various types to &lt;code&gt;Tensor&lt;/code&gt; objects. It accepts &lt;code&gt;Tensor&lt;/code&gt; objects, numpy arrays, Python lists, and Python scalars. For example:</source>
          <target state="translated">Esta funci&amp;oacute;n convierte objetos de Python de varios tipos en objetos &lt;code&gt;Tensor&lt;/code&gt; . Acepta objetos &lt;code&gt;Tensor&lt;/code&gt; , matrices numpy, listas de Python y escalares de Python. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="e487da37eb7d13adb8d956491efcafe1ed6b6abd" translate="yes" xml:space="preserve">
          <source>This function creates a new Generator object (and the Variable object within), which does not work well with tf.function because (1) tf.function puts restrictions on Variable creation thus reset_global_generator can't be freely used inside tf.function; (2) redirecting a global variable to a new object is problematic with tf.function because the old object may be captured by a 'tf.function'ed function and still be used by it. A 'tf.function'ed function only keeps weak references to variables, so deleting a variable and then calling that function again may raise an error, as demonstrated by random_test.py/RandomTest.testResetGlobalGeneratorBadWithDefun .</source>
          <target state="translated">Esta función crea un nuevo objeto Generador (y el objeto Variable dentro de él),que no funciona bien con tf.function porque (1)tf.function pone restricciones a la creación de variables,por lo que reset_global_generator no puede ser utilizado libremente dentro de tf.function;(2)redirigir una variable global a un nuevo objeto es problemático con tf.function porque el antiguo objeto puede ser capturado por una función 'tf.function'ed y seguir siendo utilizado por ella.Una función 'tf.function'ed sólo mantiene referencias débiles a las variables,por lo que borrar una variable y volver a llamar a esa función puede dar lugar a un error,como se demuestra en random_test.py/RandomTest.testResetGlobalGeneratorBadWithDefun .</target>
        </trans-unit>
        <trans-unit id="7bd8be377fdf00edb4e98ffd4a0d17d3f66c21a2" translate="yes" xml:space="preserve">
          <source>This function divides &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, forcing Python 2 semantics. That is, if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both integers then the result will be an integer. This is in contrast to Python 3, where division with &lt;code&gt;/&lt;/code&gt; is always a float while division with &lt;code&gt;//&lt;/code&gt; is always an integer.</source>
          <target state="translated">Esta funci&amp;oacute;n divide &lt;code&gt;x&lt;/code&gt; y &lt;code&gt;y&lt;/code&gt; , forzando Python 2 sem&amp;aacute;ntica. Es decir, si &lt;code&gt;x&lt;/code&gt; y &lt;code&gt;y&lt;/code&gt; son enteros, entonces el resultado ser&amp;aacute; un n&amp;uacute;mero entero. Esto contrasta con Python 3, donde la divisi&amp;oacute;n con &lt;code&gt;/&lt;/code&gt; siempre es flotante mientras que la divisi&amp;oacute;n con &lt;code&gt;//&lt;/code&gt; es siempre un n&amp;uacute;mero entero.</target>
        </trans-unit>
        <trans-unit id="d24aa00a66ce40fc5a2092349ae7643f400f331a" translate="yes" xml:space="preserve">
          <source>This function enables you to use a &lt;a href=&quot;../dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; in a stateless &quot;tensor-in tensor-out&quot; expression, without creating a &lt;a href=&quot;../../compat/v1/data/iterator&quot;&gt;&lt;code&gt;tf.compat.v1.data.Iterator&lt;/code&gt;&lt;/a&gt;. This can be useful when your preprocessing transformations are expressed as a &lt;code&gt;Dataset&lt;/code&gt;, and you want to use the transformation at serving time. For example:</source>
          <target state="translated">Esta funci&amp;oacute;n le permite utilizar un &lt;a href=&quot;../dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; &lt;/a&gt; en una expresi&amp;oacute;n &quot;tensor-in tensor-out&quot; sin estado, sin crear un &lt;a href=&quot;../../compat/v1/data/iterator&quot;&gt; &lt;code&gt;tf.compat.v1.data.Iterator&lt;/code&gt; &lt;/a&gt; . Esto puede ser &amp;uacute;til cuando sus transformaciones de preprocesamiento se expresan como un &lt;code&gt;Dataset&lt;/code&gt; y desea utilizar la transformaci&amp;oacute;n en el momento de la publicaci&amp;oacute;n. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="dcd4ee76305c19cb19df5a4e6d70410c1e1185ec" translate="yes" xml:space="preserve">
          <source>This function enables you to use a &lt;a href=&quot;../dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; in a stateless &quot;tensor-in tensor-out&quot; expression, without creating an iterator. This can be useful when your preprocessing transformations are expressed as a &lt;code&gt;Dataset&lt;/code&gt;, and you want to use the transformation at serving time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43245fcf24b3e5f89c388ed18c02c0b4b9e1fd8d" translate="yes" xml:space="preserve">
          <source>This function enqueues a structure of features to be looked up in the embedding tables. We expect that the batch size of each of the tensors in features matches the per core batch size. This will automatically happen if your input dataset is batched to the global batch size and you use &lt;a href=&quot;../../../distribute/tpustrategy&quot;&gt;&lt;code&gt;tf.distribute.TPUStrategy&lt;/code&gt;&lt;/a&gt;'s &lt;code&gt;experimental_distribute_dataset&lt;/code&gt; or if you use &lt;code&gt;experimental_distribute_datasets_from_function&lt;/code&gt; and batch to the per core batch size computed by the context passed to your input function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af17991dd15e2b7fa7774cc8e8187690043ab3dd" translate="yes" xml:space="preserve">
          <source>This function exists only for backwards compatibility purposes; new code should use &lt;code&gt;__floordiv__&lt;/code&gt; via the syntax &lt;code&gt;x // y&lt;/code&gt;. Using &lt;code&gt;x // y&lt;/code&gt; communicates clearly that the result rounds down, and is forward compatible to Python 3.</source>
          <target state="translated">Esta funci&amp;oacute;n existe solo para prop&amp;oacute;sitos de compatibilidad con versiones anteriores; el nuevo c&amp;oacute;digo debe usar &lt;code&gt;__floordiv__&lt;/code&gt; a trav&amp;eacute;s de la sintaxis &lt;code&gt;x // y&lt;/code&gt; . El uso de &lt;code&gt;x // y&lt;/code&gt; comunica claramente que el resultado se redondea hacia abajo y es compatible con Python 3.</target>
        </trans-unit>
        <trans-unit id="1a2f6439e571c218e4f990c2f6f9f31b011962aa" translate="yes" xml:space="preserve">
          <source>This function exists only to have a better error message. Instead of: &lt;code&gt;TypeError: unsupported operand type(s) for /: 'Dimension' and 'int'&lt;/code&gt;, this function will explicitly call for usage of &lt;code&gt;//&lt;/code&gt; instead.</source>
          <target state="translated">Esta funci&amp;oacute;n existe solo para tener un mejor mensaje de error. En lugar de: &lt;code&gt;TypeError: unsupported operand type(s) for /: 'Dimension' and 'int'&lt;/code&gt; , esta funci&amp;oacute;n llamar&amp;aacute; expl&amp;iacute;citamente para el uso de &lt;code&gt;//&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="6bf09410a9b47558afad7eb9fc6a9929885c6dd9" translate="yes" xml:space="preserve">
          <source>This function exists only to have a better error message. Instead of: &lt;code&gt;TypeError: unsupported operand type(s) for /: 'int' and 'Dimension'&lt;/code&gt;, this function will explicitly call for usage of &lt;code&gt;//&lt;/code&gt; instead.</source>
          <target state="translated">Esta funci&amp;oacute;n existe solo para tener un mejor mensaje de error. En lugar de: &lt;code&gt;TypeError: unsupported operand type(s) for /: 'int' and 'Dimension'&lt;/code&gt; , esta funci&amp;oacute;n llamar&amp;aacute; expl&amp;iacute;citamente para el uso de &lt;code&gt;//&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="7046a2ab2d223422699f2f1db88f8efbcff064ed" translate="yes" xml:space="preserve">
          <source>This function exports the graph, saver, and collection objects into &lt;code&gt;MetaGraphDef&lt;/code&gt; protocol buffer with the intention of it being imported at a later time or location to restart training, run inference, or be a subgraph.</source>
          <target state="translated">Esta funci&amp;oacute;n exporta el gr&amp;aacute;fico, el protector y los objetos de colecci&amp;oacute;n al &lt;code&gt;MetaGraphDef&lt;/code&gt; protocolo MetaGraphDef con la intenci&amp;oacute;n de que se importe en un momento o ubicaci&amp;oacute;n posterior para reiniciar el entrenamiento, ejecutar la inferencia o ser un subgr&amp;aacute;fico.</target>
        </trans-unit>
        <trans-unit id="7a855742752eb51788b391963ce908a091cbe366" translate="yes" xml:space="preserve">
          <source>This function follows the &lt;a href=&quot;http://htk.eng.cam.ac.uk/&quot;&gt;Hidden Markov Model Toolkit (HTK)&lt;/a&gt; convention, defining the mel scale in terms of a frequency in hertz according to the following formula:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a27fb60b44269b202e3c908e7cb802642c2ac28" translate="yes" xml:space="preserve">
          <source>This function forces Python 3 division operator semantics where all integer arguments are cast to floating types first. This op is generated by normal &lt;code&gt;x / y&lt;/code&gt; division in Python 3 and in Python 2.7 with &lt;code&gt;from __future__ import division&lt;/code&gt;. If you want integer division that rounds down, use &lt;code&gt;x // y&lt;/code&gt; or &lt;code&gt;tf.math.floordiv&lt;/code&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n fuerza la sem&amp;aacute;ntica del operador de divisi&amp;oacute;n de Python 3 donde todos los argumentos enteros se lanzan primero a tipos flotantes. Esta operaci&amp;oacute;n se genera mediante la divisi&amp;oacute;n &lt;code&gt;x / y&lt;/code&gt; normal en Python 3 y en Python 2.7 con la &lt;code&gt;from __future__ import division&lt;/code&gt; . Si quieres entero divisi&amp;oacute;n que redondea hacia abajo, el uso &lt;code&gt;x // y&lt;/code&gt; o &lt;code&gt;tf.math.floordiv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d4720bce15c58196c687612f77168d6737d499a" translate="yes" xml:space="preserve">
          <source>This function generalizes the &lt;a href=&quot;non_max_suppression&quot;&gt;&lt;code&gt;tf.image.non_max_suppression&lt;/code&gt;&lt;/a&gt; op by also supporting a Soft-NMS (with Gaussian weighting) mode (c.f. Bodla et al, https://arxiv.org/abs/1704.04503) where boxes reduce the score of other overlapping boxes instead of directly causing them to be pruned. Consequently, in contrast to &lt;a href=&quot;non_max_suppression&quot;&gt;&lt;code&gt;tf.image.non_max_suppression&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;non_max_suppression_padded&quot;&gt;&lt;code&gt;tf.image.non_max_suppression_padded&lt;/code&gt;&lt;/a&gt; returns the new scores of each input box in the second output, &lt;code&gt;selected_scores&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b139bf71180b25aa620a27f39c22f066fe31fcf7" translate="yes" xml:space="preserve">
          <source>This function generalizes the &lt;a href=&quot;non_max_suppression&quot;&gt;&lt;code&gt;tf.image.non_max_suppression&lt;/code&gt;&lt;/a&gt; op by also supporting a Soft-NMS (with Gaussian weighting) mode (c.f. Bodla et al, https://arxiv.org/abs/1704.04503) where boxes reduce the score of other overlapping boxes instead of directly causing them to be pruned. Consequently, in contrast to &lt;a href=&quot;non_max_suppression&quot;&gt;&lt;code&gt;tf.image.non_max_suppression&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;tf.image.non_max_suppression_v2&lt;/code&gt; returns the new scores of each input box in the second output, &lt;code&gt;selected_scores&lt;/code&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n generaliza la &lt;a href=&quot;non_max_suppression&quot;&gt; &lt;code&gt;tf.image.non_max_suppression&lt;/code&gt; &lt;/a&gt; al admitir tambi&amp;eacute;n un modo Soft-NMS (con ponderaci&amp;oacute;n gaussiana) (cf Bodla et al, https://arxiv.org/abs/1704.04503) donde los cuadros reducen la puntuaci&amp;oacute;n de otros cuadros superpuestos en lugar de hacer que se poden directamente. En consecuencia, a diferencia de &lt;a href=&quot;non_max_suppression&quot;&gt; &lt;code&gt;tf.image.non_max_suppression&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;tf.image.non_max_suppression_v2&lt;/code&gt; devuelve las nuevas puntuaciones de cada cuadro de entrada en la segunda salida, &lt;code&gt;selected_scores&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f78cfdbddd70d6ebd322125da902964ca2c0221" translate="yes" xml:space="preserve">
          <source>This function generates a weighted sum based on output dimension &lt;code&gt;units&lt;/code&gt;. Weighted sum refers to logits in classification problems. It refers to the prediction itself for linear regression problems.</source>
          <target state="translated">Esta funci&amp;oacute;n genera una suma ponderada basada en &lt;code&gt;units&lt;/code&gt; dimensi&amp;oacute;n de salida . La suma ponderada se refiere a los logits en los problemas de clasificaci&amp;oacute;n. Se refiere a la predicci&amp;oacute;n en s&amp;iacute; para problemas de regresi&amp;oacute;n lineal.</target>
        </trans-unit>
        <trans-unit id="b7164aa4227947230adf26e333ecf50d207f9d4e" translate="yes" xml:space="preserve">
          <source>This function ignores flags whose value is None. Each flag assignment is separated by a newline.</source>
          <target state="translated">Esta función ignora las banderas cuyo valor es Ninguno.Cada asignación de bandera está separada por una nueva línea.</target>
        </trans-unit>
        <trans-unit id="0c81aeff7442b1d7f71d30de1b5da89dfe187de7" translate="yes" xml:space="preserve">
          <source>This function in addition also allows assignment to a sliced range. This is similar to &lt;code&gt;__setitem__&lt;/code&gt; functionality in Python. However, the syntax is different so that the user can capture the assignment operation for grouping or passing to &lt;code&gt;sess.run()&lt;/code&gt;. For example,</source>
          <target state="translated">Adem&amp;aacute;s, esta funci&amp;oacute;n tambi&amp;eacute;n permite la asignaci&amp;oacute;n a un rango cortado. Esto es similar a la funcionalidad &lt;code&gt;__setitem__&lt;/code&gt; en Python. Sin embargo, la sintaxis es diferente para que el usuario pueda capturar la operaci&amp;oacute;n de asignaci&amp;oacute;n para agrupar o pasar a &lt;code&gt;sess.run()&lt;/code&gt; . Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="f477dc6f411c004d0b07e1741886385a8bad1741" translate="yes" xml:space="preserve">
          <source>This function is a more primitive version of &lt;code&gt;dynamic_rnn&lt;/code&gt; that provides more direct access to the inputs each iteration. It also provides more control over when to start and finish reading the sequence, and what to emit for the output.</source>
          <target state="translated">Esta funci&amp;oacute;n es una versi&amp;oacute;n m&amp;aacute;s primitiva de &lt;code&gt;dynamic_rnn&lt;/code&gt; que proporciona un acceso m&amp;aacute;s directo a las entradas en cada iteraci&amp;oacute;n. Tambi&amp;eacute;n proporciona m&amp;aacute;s control sobre cu&amp;aacute;ndo comenzar y terminar de leer la secuencia, y qu&amp;eacute; emitir para la salida.</target>
        </trans-unit>
        <trans-unit id="b35cb926e7e56c5e0bb4984bfdd19c6c71696446" translate="yes" xml:space="preserve">
          <source>This function is a simpler wrapper around the more general &lt;a href=&quot;convolution&quot;&gt;&lt;code&gt;tf.nn.convolution&lt;/code&gt;&lt;/a&gt;, and exists only for backwards compatibility. You can use &lt;a href=&quot;convolution&quot;&gt;&lt;code&gt;tf.nn.convolution&lt;/code&gt;&lt;/a&gt; to perform 1-D, 2-D, or 3-D atrous convolution.</source>
          <target state="translated">Esta funci&amp;oacute;n es una envoltura m&amp;aacute;s simple alrededor de &lt;a href=&quot;convolution&quot;&gt; &lt;code&gt;tf.nn.convolution&lt;/code&gt; &lt;/a&gt; m&amp;aacute;s general , y existe solo para compatibilidad con versiones anteriores. Puede usar &lt;a href=&quot;convolution&quot;&gt; &lt;code&gt;tf.nn.convolution&lt;/code&gt; &lt;/a&gt; para realizar una convoluci&amp;oacute;n impresionante en 1-D, 2-D o 3-D.</target>
        </trans-unit>
        <trans-unit id="1fde94a598e8772eaea3cc47dd741a3aa23b5c85" translate="yes" xml:space="preserve">
          <source>This function is analogous to &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.pinv.html&quot;&gt;&lt;code&gt;numpy.linalg.pinv&lt;/code&gt;&lt;/a&gt;. It differs only in default value of &lt;code&gt;rcond&lt;/code&gt;. In &lt;code&gt;numpy.linalg.pinv&lt;/code&gt;, the default &lt;code&gt;rcond&lt;/code&gt; is &lt;code&gt;1e-15&lt;/code&gt;. Here the default is &lt;code&gt;10. * max(num_rows, num_cols) * np.finfo(dtype).eps&lt;/code&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n es an&amp;aacute;loga a &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.pinv.html&quot;&gt; &lt;code&gt;numpy.linalg.pinv&lt;/code&gt; &lt;/a&gt; . Solo difiere en el valor predeterminado de &lt;code&gt;rcond&lt;/code&gt; . En &lt;code&gt;numpy.linalg.pinv&lt;/code&gt; , el &lt;code&gt;rcond&lt;/code&gt; predeterminado es &lt;code&gt;1e-15&lt;/code&gt; . Aqu&amp;iacute; el valor predeterminado es &lt;code&gt;10. * max(num_rows, num_cols) * np.finfo(dtype).eps&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c82b17de9fe920f72f7a5369e74c77b8a5f75d81" translate="yes" xml:space="preserve">
          <source>This function is based on the standard SSIM implementation from: Wang, Z., Bovik, A. C., Sheikh, H. R., &amp;amp; Simoncelli, E. P. (2004). Image quality assessment: from error visibility to structural similarity. IEEE transactions on image processing.</source>
          <target state="translated">Esta funci&amp;oacute;n se basa en la implementaci&amp;oacute;n est&amp;aacute;ndar SSIM de: Wang, Z., Bovik, AC, Sheikh, HR y Simoncelli, EP (2004). Evaluaci&amp;oacute;n de la calidad de la imagen: desde la visibilidad del error hasta la similitud estructural. Transacciones IEEE sobre procesamiento de im&amp;aacute;genes.</target>
        </trans-unit>
        <trans-unit id="3f78f322021258197ee0401af332233d4fb6c937" translate="yes" xml:space="preserve">
          <source>This function is cached the first time &lt;a href=&quot;../model#evaluate&quot;&gt;&lt;code&gt;Model.evaluate&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../model#test_on_batch&quot;&gt;&lt;code&gt;Model.test_on_batch&lt;/code&gt;&lt;/a&gt; is called. The cache is cleared whenever &lt;a href=&quot;../model#compile&quot;&gt;&lt;code&gt;Model.compile&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03d4062526248415274d1920f151d5925ea1d106" translate="yes" xml:space="preserve">
          <source>This function is cached the first time &lt;a href=&quot;../model#fit&quot;&gt;&lt;code&gt;Model.fit&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../model#train_on_batch&quot;&gt;&lt;code&gt;Model.train_on_batch&lt;/code&gt;&lt;/a&gt; is called. The cache is cleared whenever &lt;a href=&quot;../model#compile&quot;&gt;&lt;code&gt;Model.compile&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a73ed236f67dee6103073403c6d29f26833958d9" translate="yes" xml:space="preserve">
          <source>This function is cached the first time &lt;a href=&quot;../model#predict&quot;&gt;&lt;code&gt;Model.predict&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../model#predict_on_batch&quot;&gt;&lt;code&gt;Model.predict_on_batch&lt;/code&gt;&lt;/a&gt; is called. The cache is cleared whenever &lt;a href=&quot;../model#compile&quot;&gt;&lt;code&gt;Model.compile&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c02b98872d235ad42d3656b50ce22017eda7ff2" translate="yes" xml:space="preserve">
          <source>This function is cached the first time &lt;a href=&quot;model#evaluate&quot;&gt;&lt;code&gt;Model.evaluate&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;model#test_on_batch&quot;&gt;&lt;code&gt;Model.test_on_batch&lt;/code&gt;&lt;/a&gt; is called. The cache is cleared whenever &lt;a href=&quot;model#compile&quot;&gt;&lt;code&gt;Model.compile&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d1d8a8ff69ef7a941ba68b453aec429bfe458e1" translate="yes" xml:space="preserve">
          <source>This function is cached the first time &lt;a href=&quot;model#fit&quot;&gt;&lt;code&gt;Model.fit&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;model#train_on_batch&quot;&gt;&lt;code&gt;Model.train_on_batch&lt;/code&gt;&lt;/a&gt; is called. The cache is cleared whenever &lt;a href=&quot;model#compile&quot;&gt;&lt;code&gt;Model.compile&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d0db761a3ad75448d327cc87f61eb8b0729f377" translate="yes" xml:space="preserve">
          <source>This function is cached the first time &lt;a href=&quot;model#predict&quot;&gt;&lt;code&gt;Model.predict&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;model#predict_on_batch&quot;&gt;&lt;code&gt;Model.predict_on_batch&lt;/code&gt;&lt;/a&gt; is called. The cache is cleared whenever &lt;a href=&quot;model#compile&quot;&gt;&lt;code&gt;Model.compile&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecacc04269db8f28f91780c2b346f24c2d101704" translate="yes" xml:space="preserve">
          <source>This function is called between epochs/steps, when a metric is evaluated during training.</source>
          <target state="translated">Esta función se llama entre épocas/escalones,cuando se evalúa una métrica durante el entrenamiento.</target>
        </trans-unit>
        <trans-unit id="a75cbe1aa934dcb50e2537aae264b28dbab09250" translate="yes" xml:space="preserve">
          <source>This function is called by FLAGS(argv). It scans the input list for a flag that looks like: --flagfile=</source>
          <target state="translated">Esta función se llama FLAGS(argv).Escanea la lista de entradas en busca de una bandera que se parezca:--flagfile=</target>
        </trans-unit>
        <trans-unit id="e57b5dff2b7e230f6a359d3b07cb810778cc3047" translate="yes" xml:space="preserve">
          <source>This function is called in the main TensorFlow &lt;code&gt;__init__.py&lt;/code&gt; file, user should not need to call it, except during complex migrations.</source>
          <target state="translated">Esta funci&amp;oacute;n se llama en el archivo principal &lt;code&gt;__init__.py&lt;/code&gt; de TensorFlow , el usuario no deber&amp;iacute;a necesitar llamarla, excepto durante migraciones complejas.</target>
        </trans-unit>
        <trans-unit id="0831cfa041ba84a9c1bb953a8575728ee9dbe8bf" translate="yes" xml:space="preserve">
          <source>This function is faster and numerically stabler than &lt;code&gt;bessel_i0(x)&lt;/code&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n es m&amp;aacute;s r&amp;aacute;pida y num&amp;eacute;ricamente m&amp;aacute;s estable que &lt;code&gt;bessel_i0(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f2e499db54e57708a372078c16af5df37036099" translate="yes" xml:space="preserve">
          <source>This function is faster and numerically stabler than &lt;code&gt;bessel_i1(x)&lt;/code&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n es m&amp;aacute;s r&amp;aacute;pida y num&amp;eacute;ricamente m&amp;aacute;s estable que &lt;code&gt;bessel_i1(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7e374cf0f52d98689ddb22ec7b9e2a428cd4956" translate="yes" xml:space="preserve">
          <source>This function is implemented using a queue. A &lt;code&gt;QueueRunner&lt;/code&gt; for the queue is added to the current &lt;code&gt;Graph&lt;/code&gt;'s &lt;code&gt;QUEUE_RUNNER&lt;/code&gt; collection.</source>
          <target state="translated">Esta funci&amp;oacute;n se implementa mediante una cola. Un &lt;code&gt;QueueRunner&lt;/code&gt; para la cola se a&amp;ntilde;ade a la corriente &lt;code&gt;Graph&lt;/code&gt; 's &lt;code&gt;QUEUE_RUNNER&lt;/code&gt; colecci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="4c4c3026638168daaa4ab1a3c114680f01d9d246" translate="yes" xml:space="preserve">
          <source>This function is more numerically stable than log(sum(exp(input))). It avoids overflows caused by taking the exp of large inputs and underflows caused by taking the log of small inputs.</source>
          <target state="translated">Esta función es más estable numéricamente que log(sum(exp(input)).Evita los desbordamientos causados por la toma de exp de grandes entradas y los desbordamientos causados por la toma del log de pequeñas entradas.</target>
        </trans-unit>
        <trans-unit id="80c0f02cfab4a0ee1574d2a1145f5fca28f12b11" translate="yes" xml:space="preserve">
          <source>This function is only available with the TensorFlow backend for the time being.</source>
          <target state="translated">Esta función sólo está disponible con el backend TensorFlow por el momento.</target>
        </trans-unit>
        <trans-unit id="11a7ac7f028baf06c483242a158777b17ee8b353" translate="yes" xml:space="preserve">
          <source>This function is only used when defining a new op type. It may be used for ops such as &lt;a href=&quot;size&quot;&gt;&lt;code&gt;tf.size()&lt;/code&gt;&lt;/a&gt; that are not differentiable. For example:</source>
          <target state="translated">Esta funci&amp;oacute;n solo se usa al definir un nuevo tipo de operaci&amp;oacute;n. Se puede usar para operaciones como &lt;a href=&quot;size&quot;&gt; &lt;code&gt;tf.size()&lt;/code&gt; &lt;/a&gt; que no son diferenciables. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="61969c39a3dfe9d632e8e43316d05aa062590efa" translate="yes" xml:space="preserve">
          <source>This function is part of the Keras serialization and deserialization framework. It maps objects to the string names associated with those objects for serialization/deserialization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aa4be9a74ac3f90821c5e3ef2a47e10c4dfdcb8" translate="yes" xml:space="preserve">
          <source>This function is part of the Keras serialization and deserialization framework. It maps strings to the objects associated with them for serialization/deserialization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="577a32736f43471cd2cd1266738343fb80596d48" translate="yes" xml:space="preserve">
          <source>This function is the canonical way to get/validate an object of one of the allowed types from an external argument reference in the Session API.</source>
          <target state="translated">Esta función es la forma canónica de obtener/validar un objeto de uno de los tipos permitidos a partir de una referencia de argumento externo en la API de la sesión.</target>
        </trans-unit>
        <trans-unit id="130785c66d51b0bf917ff1a83e8cb5fd0234052e" translate="yes" xml:space="preserve">
          <source>This function is to generate &lt;a href=&quot;../distributedvalues&quot;&gt;&lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt;&lt;/a&gt; to pass into &lt;code&gt;run&lt;/code&gt;, &lt;code&gt;reduce&lt;/code&gt;, or other methods that take distributed values when not using datasets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84ff67d2523742ed898675e46a84da4adae4f6b1" translate="yes" xml:space="preserve">
          <source>This function is to generate &lt;a href=&quot;distributedvalues&quot;&gt;&lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt;&lt;/a&gt; to pass into &lt;code&gt;run&lt;/code&gt;, &lt;code&gt;reduce&lt;/code&gt;, or other methods that take distributed values when not using datasets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="691cc7f8251e205cf948be38afb6e034f26a2e72" translate="yes" xml:space="preserve">
          <source>This function is used to perform parallel lookups on the list of tensors in &lt;code&gt;params&lt;/code&gt;. It is a generalization of &lt;a href=&quot;../../../gather&quot;&gt;&lt;code&gt;tf.gather&lt;/code&gt;&lt;/a&gt;, where &lt;code&gt;params&lt;/code&gt; is interpreted as a partitioning of a large embedding tensor. &lt;code&gt;params&lt;/code&gt; may be a &lt;code&gt;PartitionedVariable&lt;/code&gt; as returned by using &lt;a href=&quot;../get_variable&quot;&gt;&lt;code&gt;tf.compat.v1.get_variable()&lt;/code&gt;&lt;/a&gt; with a partitioner.</source>
          <target state="translated">Esta funci&amp;oacute;n se utiliza para realizar b&amp;uacute;squedas paralelas en la lista de tensores en &lt;code&gt;params&lt;/code&gt; . Es una generalizaci&amp;oacute;n de &lt;a href=&quot;../../../gather&quot;&gt; &lt;code&gt;tf.gather&lt;/code&gt; &lt;/a&gt; , donde &lt;code&gt;params&lt;/code&gt; se interpreta como una partici&amp;oacute;n de un tensor de incrustaci&amp;oacute;n grande. &lt;code&gt;params&lt;/code&gt; puede ser una &lt;code&gt;PartitionedVariable&lt;/code&gt; como se devuelve usando &lt;a href=&quot;../get_variable&quot;&gt; &lt;code&gt;tf.compat.v1.get_variable()&lt;/code&gt; &lt;/a&gt; con un particionador.</target>
        </trans-unit>
        <trans-unit id="4938f0a72e046cd0e52c1383bdb6cd4186015a22" translate="yes" xml:space="preserve">
          <source>This function is used to perform parallel lookups on the list of tensors in &lt;code&gt;params&lt;/code&gt;. It is a generalization of &lt;a href=&quot;../gather&quot;&gt;&lt;code&gt;tf.gather&lt;/code&gt;&lt;/a&gt;, where &lt;code&gt;params&lt;/code&gt; is interpreted as a partitioning of a large embedding tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="237e26d699d02ce05b0e4079a36fba68db8a8789" translate="yes" xml:space="preserve">
          <source>This function is used to perform parallel lookups on the list of tensors in &lt;code&gt;params&lt;/code&gt;. It is a generalization of &lt;a href=&quot;../gather&quot;&gt;&lt;code&gt;tf.gather&lt;/code&gt;&lt;/a&gt;, where &lt;code&gt;params&lt;/code&gt; is interpreted as a partitioning of a large embedding tensor. &lt;code&gt;params&lt;/code&gt; may be a &lt;code&gt;PartitionedVariable&lt;/code&gt; as returned by using &lt;a href=&quot;../compat/v1/get_variable&quot;&gt;&lt;code&gt;tf.compat.v1.get_variable()&lt;/code&gt;&lt;/a&gt; with a partitioner.</source>
          <target state="translated">Esta funci&amp;oacute;n se utiliza para realizar b&amp;uacute;squedas paralelas en la lista de tensores en &lt;code&gt;params&lt;/code&gt; . Es una generalizaci&amp;oacute;n de &lt;a href=&quot;../gather&quot;&gt; &lt;code&gt;tf.gather&lt;/code&gt; &lt;/a&gt; , donde &lt;code&gt;params&lt;/code&gt; se interpreta como una partici&amp;oacute;n de un tensor de incrustaci&amp;oacute;n grande. &lt;code&gt;params&lt;/code&gt; puede ser una &lt;code&gt;PartitionedVariable&lt;/code&gt; como se devuelve usando &lt;a href=&quot;../compat/v1/get_variable&quot;&gt; &lt;code&gt;tf.compat.v1.get_variable()&lt;/code&gt; &lt;/a&gt; con un particionador.</target>
        </trans-unit>
        <trans-unit id="f577da20d8fc0c2379f7e51688987afe782aa9c2" translate="yes" xml:space="preserve">
          <source>This function is useful for unit testing. A unit test can test using the mixed precision graph rewrite, then disable it so future unit tests continue using float32.</source>
          <target state="translated">Esta función es útil para la prueba de la unidad.Una prueba unitaria puede probar usando la reescritura de la gráfica de precisión mixta,y luego desactivarla para que las futuras pruebas unitarias continúen usando el flotador32.</target>
        </trans-unit>
        <trans-unit id="d61d06f477fe487d45a847bca66c249257c10fe4" translate="yes" xml:space="preserve">
          <source>This function is useful for unit testing. A unit tests can test using the mixed precision graph rewrite, then disable it so future unit tests continue using float32. If this is done, unit tests should not share a single session, as &lt;code&gt;enable_mixed_precision_graph_rewrite&lt;/code&gt; and &lt;code&gt;disable_mixed_precision_graph_rewrite&lt;/code&gt; have no effect on existing sessions.</source>
          <target state="translated">Esta funci&amp;oacute;n es &amp;uacute;til para pruebas unitarias. Las pruebas unitarias pueden probar usando la reescritura de gr&amp;aacute;ficos de precisi&amp;oacute;n mixta, luego deshabilitarla para que las pruebas unitarias futuras contin&amp;uacute;en usando float32. Si se hace esto, las pruebas unitarias no deben compartir una sola sesi&amp;oacute;n, ya que &lt;code&gt;enable_mixed_precision_graph_rewrite&lt;/code&gt; y &lt;code&gt;disable_mixed_precision_graph_rewrite&lt;/code&gt; no tienen ning&amp;uacute;n efecto en las sesiones existentes.</target>
        </trans-unit>
        <trans-unit id="929b9d5a5eeca32709da98b98c1fa20f11f6684a" translate="yes" xml:space="preserve">
          <source>This function may be used in the &lt;code&gt;options&lt;/code&gt; argument in functions that load a SavedModel (&lt;a href=&quot;load&quot;&gt;&lt;code&gt;tf.saved_model.load&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../keras/models/load_model&quot;&gt;&lt;code&gt;tf.keras.models.load_model&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4e537bea1c76cb2cbcdaeafa3c9baedcb0e335e" translate="yes" xml:space="preserve">
          <source>This function may be used in the &lt;code&gt;options&lt;/code&gt; argument in functions that save a SavedModel (&lt;a href=&quot;save&quot;&gt;&lt;code&gt;tf.saved_model.save&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../keras/models/save_model&quot;&gt;&lt;code&gt;tf.keras.models.save_model&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Esta funci&amp;oacute;n se puede usar en el argumento de &lt;code&gt;options&lt;/code&gt; en funciones que guardan un modelo guardado ( &lt;a href=&quot;save&quot;&gt; &lt;code&gt;tf.saved_model.save&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../keras/models/save_model&quot;&gt; &lt;code&gt;tf.keras.models.save_model&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="23d4449e48af4e4a9efae86d49cf037eac266df3" translate="yes" xml:space="preserve">
          <source>This function only gets the device policy for the current thread. Any subsequently started thread will again use the default policy.</source>
          <target state="translated">Esta función sólo obtiene la política del dispositivo para el hilo actual.Cualquier hilo iniciado posteriormente volverá a utilizar la política por defecto.</target>
        </trans-unit>
        <trans-unit id="69c8cb582945069c7d9496b069e6902700fc7e3d" translate="yes" xml:space="preserve">
          <source>This function only sets the device policy for the current thread. Any subsequently started thread will again use the default policy.</source>
          <target state="translated">Esta función sólo establece la política del dispositivo para el hilo actual.Cualquier hilo iniciado posteriormente volverá a utilizar la política por defecto.</target>
        </trans-unit>
        <trans-unit id="128baaf391e006514e7e2e442ed3dbb64e14a3c9" translate="yes" xml:space="preserve">
          <source>This function performs the equivalent of</source>
          <target state="translated">Esta función realiza el equivalente de</target>
        </trans-unit>
        <trans-unit id="fac08ba1f46139129a2f42247910a712f1085f49" translate="yes" xml:space="preserve">
          <source>This function prefixes the name with the current variable scope and performs reuse checks. See the &lt;a href=&quot;https://tensorflow.org/guide/variables&quot;&gt;Variable Scope How To&lt;/a&gt; for an extensive description of how reusing works. Here is a basic example:</source>
          <target state="translated">Esta funci&amp;oacute;n antepone el nombre con el &amp;aacute;mbito de la variable actual y realiza comprobaciones de reutilizaci&amp;oacute;n. Consulte las &lt;a href=&quot;https://tensorflow.org/guide/variables&quot;&gt;instrucciones de alcance variable&lt;/a&gt; para obtener una descripci&amp;oacute;n detallada de c&amp;oacute;mo funciona la reutilizaci&amp;oacute;n. A continuaci&amp;oacute;n, se muestra un ejemplo b&amp;aacute;sico:</target>
        </trans-unit>
        <trans-unit id="85bc4aa7e8b39b071c3a83bcd2bcb628b96948b5" translate="yes" xml:space="preserve">
          <source>This function produces signatures intended for use with the TensorFlow Serving Classify API (tensorflow_serving/apis/prediction_service.proto), and so constrains the input and output types to those allowed by TensorFlow Serving.</source>
          <target state="translated">Esta función produce firmas destinadas a ser utilizadas con el API de clasificación de TensorFlow Serving (tensorflow_serving/apis/prediction_service.proto),y así restringe los tipos de entrada y salida a los permitidos por TensorFlow Serving.</target>
        </trans-unit>
        <trans-unit id="795898cb16fc0e553ecaa87cbe16e8417edef412" translate="yes" xml:space="preserve">
          <source>This function produces signatures intended for use with the TensorFlow Serving Predict API (tensorflow_serving/apis/prediction_service.proto). This API imposes no constraints on the input and output types.</source>
          <target state="translated">Esta función produce firmas destinadas a ser utilizadas con el TensorFlow Serving Predict API (tensorflow_serving/apis/prediction_service.proto).Esta API no impone ninguna restricción a los tipos de entrada y salida.</target>
        </trans-unit>
        <trans-unit id="0bd91f24173f9c6c06caccaa86fb2987286936b9" translate="yes" xml:space="preserve">
          <source>This function produces signatures intended for use with the TensorFlow Serving Regress API (tensorflow_serving/apis/prediction_service.proto), and so constrains the input and output types to those allowed by TensorFlow Serving.</source>
          <target state="translated">Esta función produce firmas destinadas a ser utilizadas con el API de TensorFlow Serving Regress (tensorflow_serving/apis/prediction_service.proto),y así restringe los tipos de entrada y salida a los permitidos por TensorFlow Serving.</target>
        </trans-unit>
        <trans-unit id="da2207550b053f2e41ed03fce80a539629a65e2e" translate="yes" xml:space="preserve">
          <source>This function provides a way to import a serialized TensorFlow &lt;a href=&quot;https://www.tensorflow.org/code/tensorflow/core/framework/graph.proto&quot;&gt;&lt;code&gt;GraphDef&lt;/code&gt;&lt;/a&gt; protocol buffer, and extract individual objects in the &lt;code&gt;GraphDef&lt;/code&gt; as &lt;a href=&quot;../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../operation&quot;&gt;&lt;code&gt;tf.Operation&lt;/code&gt;&lt;/a&gt; objects. Once extracted, these objects are placed into the current default &lt;code&gt;Graph&lt;/code&gt;. See &lt;a href=&quot;../graph#as_graph_def&quot;&gt;&lt;code&gt;tf.Graph.as_graph_def&lt;/code&gt;&lt;/a&gt; for a way to create a &lt;code&gt;GraphDef&lt;/code&gt; proto.</source>
          <target state="translated">Esta funci&amp;oacute;n proporciona una manera de importar un b&amp;uacute;fer de protocolo &lt;a href=&quot;https://www.tensorflow.org/code/tensorflow/core/framework/graph.proto&quot;&gt; &lt;code&gt;GraphDef&lt;/code&gt; de&lt;/a&gt; TensorFlow serializado y extraer objetos individuales en &lt;code&gt;GraphDef&lt;/code&gt; como objetos &lt;a href=&quot;../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../operation&quot;&gt; &lt;code&gt;tf.Operation&lt;/code&gt; &lt;/a&gt; . Una vez extra&amp;iacute;dos, estos objetos se colocan en el &lt;code&gt;Graph&lt;/code&gt; predeterminado actual . Consulte &lt;a href=&quot;../graph#as_graph_def&quot;&gt; &lt;code&gt;tf.Graph.as_graph_def&lt;/code&gt; &lt;/a&gt; para ver una forma de crear un proto &lt;code&gt;GraphDef&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59bf9d9f9818c530570cd3baaed9172f0b655e0a" translate="yes" xml:space="preserve">
          <source>This function raises &lt;code&gt;ValueError&lt;/code&gt; unless it can be certain that the given &lt;code&gt;tensor&lt;/code&gt; is a scalar. &lt;code&gt;ValueError&lt;/code&gt; is also raised if the shape of &lt;code&gt;tensor&lt;/code&gt; is unknown.</source>
          <target state="translated">Esta funci&amp;oacute;n genera &lt;code&gt;ValueError&lt;/code&gt; a menos que pueda estar seguro de que el &lt;code&gt;tensor&lt;/code&gt; dado es un escalar. &lt;code&gt;ValueError&lt;/code&gt; tambi&amp;eacute;n se genera si se desconoce la forma del &lt;code&gt;tensor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22fe780c67f001ded49fb5e4133cb0847481dd48" translate="yes" xml:space="preserve">
          <source>This function receives as input a string of text and returns a list of encoded integers each corresponding to a word (or token) in the given input string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3009d910bdcd32cff99d1458043403e12c1c254c" translate="yes" xml:space="preserve">
          <source>This function reinstantiates model state by:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a733b4ff78c36cb4d261221c5118416ce8061d8e" translate="yes" xml:space="preserve">
          <source>This function reinstantiates model state by: 1) loading model topology from json (this will eventually come from metagraph). 2) loading model weights from checkpoint.</source>
          <target state="translated">Esta función reinstala el estado modelo por:1)cargando la topología del modelo desde json (esto vendrá eventualmente de la metagrafía).2)cargando los pesos del modelo desde el punto de control.</target>
        </trans-unit>
        <trans-unit id="ff0b45b19346e757b8eb62e1bc7385c9d06f1d69" translate="yes" xml:space="preserve">
          <source>This function returns a tensor whose elements are defined by &lt;code&gt;equation&lt;/code&gt;, which is written in a shorthand form inspired by the Einstein summation convention. As an example, consider multiplying two matrices A and B to form a matrix C. The elements of C are given by:</source>
          <target state="translated">Esta funci&amp;oacute;n devuelve un tensor cuyos elementos est&amp;aacute;n definidos por la &lt;code&gt;equation&lt;/code&gt; , que est&amp;aacute; escrito en forma abreviada inspirada en la convenci&amp;oacute;n de suma de Einstein. Como ejemplo, considere multiplicar dos matrices A y B para formar una matriz C. Los elementos de C est&amp;aacute;n dados por:</target>
        </trans-unit>
        <trans-unit id="0b7b7a286f6486a214583e48df98d413e08472ce" translate="yes" xml:space="preserve">
          <source>This function should &lt;em&gt;not&lt;/em&gt; be used for operations that have a well-defined gradient that is not yet implemented.</source>
          <target state="translated">Esta funci&amp;oacute;n &lt;em&gt;no&lt;/em&gt; debe usarse para operaciones que tienen un gradiente bien definido que a&amp;uacute;n no est&amp;aacute; implementado.</target>
        </trans-unit>
        <trans-unit id="1b640a4c1fd849556e2182a5a501c968b01e5603" translate="yes" xml:space="preserve">
          <source>This function should contain the mathemetical logic for one step of evaluation. This typically includes the forward pass, loss calculation, and metrics updates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48eea658706b62c655231b07e7ecfd12850950f0" translate="yes" xml:space="preserve">
          <source>This function should only be called during TRAIN mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92add72d0f856bfc3fd4e7bcbf6ab90dc2a5a26d" translate="yes" xml:space="preserve">
          <source>This function specifies the device to be used for ops created/executed in a particular context. Nested contexts will inherit and also create/execute their ops on the specified device. If a specific device is not required, consider not using this function so that a device can be automatically assigned. In general the use of this function is optional. &lt;code&gt;device_name&lt;/code&gt; can be fully specified, as in &quot;/job:worker/task:1/device:cpu:0&quot;, or partially specified, containing only a subset of the &quot;/&quot;-separated fields. Any fields which are specified will override device annotations from outer scopes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c538dca8aca927a7d8bbd1b0bb2e590f6c5ad3a5" translate="yes" xml:space="preserve">
          <source>This function supports a subset of tf.gather, see tf.gather for details on usage.</source>
          <target state="translated">Esta función soporta un subconjunto de tf.gather,ver tf.gather para detalles de uso.</target>
        </trans-unit>
        <trans-unit id="e857d76db9c7bac209f1715cec1437cf523540d8" translate="yes" xml:space="preserve">
          <source>This function swaps half-spaces for all axes listed (defaults to all). Note that &lt;code&gt;y[0]&lt;/code&gt; is the Nyquist component only if &lt;code&gt;len(x)&lt;/code&gt; is even.</source>
          <target state="translated">Esta funci&amp;oacute;n intercambia medios espacios para todos los ejes enumerados (predeterminado en todos). Tenga en cuenta que &lt;code&gt;y[0]&lt;/code&gt; es el componente de Nyquist solo si &lt;code&gt;len(x)&lt;/code&gt; es par.</target>
        </trans-unit>
        <trans-unit id="700dee7b88966a0547c5ef0b6e43b47147bea1dd" translate="yes" xml:space="preserve">
          <source>This function takes a &lt;code&gt;MetaGraphDef&lt;/code&gt; protocol buffer as input. If the argument is a file containing a &lt;code&gt;MetaGraphDef&lt;/code&gt; protocol buffer , it constructs a protocol buffer from the file content. The function then adds all the nodes from the &lt;code&gt;graph_def&lt;/code&gt; field to the current graph, recreates all the collections, and returns a saver constructed from the &lt;code&gt;saver_def&lt;/code&gt; field.</source>
          <target state="translated">Esta funci&amp;oacute;n toma un &lt;code&gt;MetaGraphDef&lt;/code&gt; protocolo MetaGraphDef como entrada. Si el argumento es un archivo que contiene un &lt;code&gt;MetaGraphDef&lt;/code&gt; protocolo MetaGraphDef , construye un b&amp;uacute;fer de protocolo a partir del contenido del archivo. Luego, la funci&amp;oacute;n agrega todos los nodos del campo &lt;code&gt;graph_def&lt;/code&gt; al gr&amp;aacute;fico actual, recrea todas las colecciones y devuelve un ahorrador construido a partir del campo &lt;code&gt;saver_def&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd08a12501f4bce4f0a38bb7f61e556860ac6186" translate="yes" xml:space="preserve">
          <source>This function takes in a sequence of data-points gathered at equal intervals, along with time series parameters such as length of the sequences/windows, spacing between two sequence/windows, etc., to produce batches of timeseries inputs and targets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6d25a51ea520664ee90a7477aef16d45f240f73" translate="yes" xml:space="preserve">
          <source>This function transforms a list (of length &lt;code&gt;num_samples&lt;/code&gt;) of sequences (lists of integers) into a 2D Numpy array of shape &lt;code&gt;(num_samples, num_timesteps)&lt;/code&gt;. &lt;code&gt;num_timesteps&lt;/code&gt; is either the &lt;code&gt;maxlen&lt;/code&gt; argument if provided, or the length of the longest sequence in the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94fc01032dc6978adba1e0b4d64fc3f4b8d2c710" translate="yes" xml:space="preserve">
          <source>This function transforms a list of &lt;code&gt;num_samples&lt;/code&gt; sequences (lists of integers) into a 2D Numpy array of shape &lt;code&gt;(num_samples, num_timesteps)&lt;/code&gt;. &lt;code&gt;num_timesteps&lt;/code&gt; is either the &lt;code&gt;maxlen&lt;/code&gt; argument if provided, or the length of the longest sequence otherwise.</source>
          <target state="translated">Esta funci&amp;oacute;n transforma una lista de secuencias &lt;code&gt;num_samples&lt;/code&gt; (listas de enteros) en una matriz de forma Numpy 2D &lt;code&gt;(num_samples, num_timesteps)&lt;/code&gt; . &lt;code&gt;num_timesteps&lt;/code&gt; es el argumento &lt;code&gt;maxlen&lt;/code&gt; si se proporciona, o la longitud de la secuencia m&amp;aacute;s larga en caso contrario.</target>
        </trans-unit>
        <trans-unit id="c60464500521000032d7d0dd44fb1270d9c6691c" translate="yes" xml:space="preserve">
          <source>This function transforms a sequence of word indexes (list of integers) into tuples of words of the form:</source>
          <target state="translated">Esta función transforma una secuencia de índices de palabras (lista de números enteros)en tuplas de palabras de la forma:</target>
        </trans-unit>
        <trans-unit id="109cf8b58e8d5422a5502fb692567a43d8008aa5" translate="yes" xml:space="preserve">
          <source>This function transforms a string of text into a list of words while ignoring &lt;code&gt;filters&lt;/code&gt; which include punctuations by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cf6cff1a07ce3f9dd6dd3457b8400fd6ba9faf8" translate="yes" xml:space="preserve">
          <source>This function uses substring matching, i.e. the matching succeeds if &lt;em&gt;any&lt;/em&gt; substring of the error message matches &lt;em&gt;any&lt;/em&gt; regex in the list. This is more convenient for the user than full-string matching.</source>
          <target state="translated">Esta funci&amp;oacute;n utiliza la coincidencia de subcadenas, es decir, la coincidencia se realiza correctamente si &lt;em&gt;alguna&lt;/em&gt; subcadena del mensaje de error coincide con &lt;em&gt;cualquier&lt;/em&gt; expresi&amp;oacute;n regular de la lista. Esto es m&amp;aacute;s conveniente para el usuario que la coincidencia de cadenas completas.</target>
        </trans-unit>
        <trans-unit id="6ea3c37a0724be70d72aba9456ec479ad3e1efd0" translate="yes" xml:space="preserve">
          <source>This function validates that &lt;code&gt;obj&lt;/code&gt; represents an element of this graph, and gives an informative error message if it is not.</source>
          <target state="translated">Esta funci&amp;oacute;n valida que &lt;code&gt;obj&lt;/code&gt; representa un elemento de este gr&amp;aacute;fico y da un mensaje de error informativo si no lo es.</target>
        </trans-unit>
        <trans-unit id="5535ae7e49ad8d44ba9e9cbd32412f5d3383ba9d" translate="yes" xml:space="preserve">
          <source>This function will check the outermost context for the program and see if it is in eager mode. It is useful comparing to &lt;a href=&quot;../../executing_eagerly&quot;&gt;&lt;code&gt;tf.executing_eagerly()&lt;/code&gt;&lt;/a&gt;, which checks the current context and will return &lt;code&gt;False&lt;/code&gt; within a &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; body. It can be used to build library that behave differently in eager runtime and v1 session runtime (deprecated).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b809c8513edcf65ff2e661e67bc392f776c9e7e" translate="yes" xml:space="preserve">
          <source>This function will create the global generator the first time it is called, and the generator will be placed at the default device at that time, so one needs to be careful when this function is first called. Using a generator placed on a less-ideal device will incur performance regression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89bde45a9d6e8e699bac43f2a09b2f06fe6c3d12" translate="yes" xml:space="preserve">
          <source>This function will modify the tensors passed in as it adds more operations and hence changing the consumers of the operations of the input tensors.</source>
          <target state="translated">Esta función modificará los tensores pasados,ya que añade más operaciones y,por lo tanto,cambia los consumidores de las operaciones de los tensores de entrada.</target>
        </trans-unit>
        <trans-unit id="e4e12e3274ef470af1606308b5afb5383f0e4373" translate="yes" xml:space="preserve">
          <source>This function works on either a single image (&lt;code&gt;image&lt;/code&gt; is a 3-D Tensor), or a batch of images (&lt;code&gt;image&lt;/code&gt; is a 4-D Tensor).</source>
          <target state="translated">Esta funci&amp;oacute;n funciona con una sola imagen (la &lt;code&gt;image&lt;/code&gt; n es un tensor 3-D) o un lote de im&amp;aacute;genes (la &lt;code&gt;image&lt;/code&gt; n es un tensor 4-D).</target>
        </trans-unit>
        <trans-unit id="3bc4d91f81e39f3ea54e11412256f8f82c2a442a" translate="yes" xml:space="preserve">
          <source>This function wraps tensor placeholders in a supervised_receiver_fn with the expectation that the features and labels appear precisely as the model_fn expects them. Features and labels can therefore be dicts of tensors, or raw tensors.</source>
          <target state="translated">Esta función envuelve a los marcadores de posición tensores en un supervised_receiver_fn con la expectativa de que las características y etiquetas aparezcan exactamente como el model_fn las espera.Por lo tanto,las características y etiquetas pueden ser dictados de tensores,o tensores en bruto.</target>
        </trans-unit>
        <trans-unit id="390f51be88bc027febcd4f2fc680ab5ff0ecb909" translate="yes" xml:space="preserve">
          <source>This functionality can be used to remap both row vocabularies (typically, features) and column vocabularies (typically, classes) from TensorFlow checkpoints. Note that the partitioning logic relies on contiguous vocabularies corresponding to div-partitioned variables. Moreover, the underlying remapping uses an IndexTable (as opposed to an inexact CuckooTable), so client code should use the corresponding index_table_from_file() as the FeatureColumn framework does (as opposed to tf.feature_to_id(), which uses a CuckooTable).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="061aef760e659c96c1579128f6e2913f90a85e0a" translate="yes" xml:space="preserve">
          <source>This has the effect of transforming sliding window operations into the corresponding &quot;atrous&quot; operation in which the input is sampled at the specified &lt;code&gt;dilation_rate&lt;/code&gt;.</source>
          <target state="translated">Esto tiene el efecto de transformar las operaciones de la ventana deslizante en la correspondiente operaci&amp;oacute;n &quot;atroz&quot; en la que la entrada se muestrea a la tasa de &lt;code&gt;dilation_rate&lt;/code&gt; especificada .</target>
        </trans-unit>
        <trans-unit id="10c41b6251ef0bcbec27e5d4c8ebb2292ccebcaa" translate="yes" xml:space="preserve">
          <source>This helper method provides a higher-level alternative to using &lt;code&gt;tf.contrib.summary.summary_writer_initializer_op&lt;/code&gt; and &lt;code&gt;tf.contrib.summary.graph&lt;/code&gt;.</source>
          <target state="translated">Este m&amp;eacute;todo auxiliar proporciona una alternativa de nivel superior al uso de &lt;code&gt;tf.contrib.summary.summary_writer_initializer_op&lt;/code&gt; y &lt;code&gt;tf.contrib.summary.graph&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="671c9eb768ee498e26815ceb625e7ee7c309f7e7" translate="yes" xml:space="preserve">
          <source>This hook delays execution until global step reaches to &lt;code&gt;wait_until_step&lt;/code&gt;. It is used to gradually start workers in distributed settings. One example usage would be setting &lt;code&gt;wait_until_step=int(K*log(task_id+1))&lt;/code&gt; assuming that task_id=0 is the chief.</source>
          <target state="translated">Este gancho retrasa la ejecuci&amp;oacute;n hasta que el paso global llega a &lt;code&gt;wait_until_step&lt;/code&gt; . Se utiliza para iniciar gradualmente a los trabajadores en entornos distribuidos. Un ejemplo de uso ser&amp;iacute;a establecer &lt;code&gt;wait_until_step=int(K*log(task_id+1))&lt;/code&gt; asumiendo que task_id = 0 es el jefe.</target>
        </trans-unit>
        <trans-unit id="1a0fa0f63117915fa2c817fa42b4c67a4f5c8b33" translate="yes" xml:space="preserve">
          <source>This hook requests stop after either a number of steps have been executed or a last step has been reached. Only one of the two options can be specified.</source>
          <target state="translated">Este gancho pide que se detenga después de que se hayan ejecutado varios pasos o se haya alcanzado un último paso.Sólo se puede especificar una de las dos opciones.</target>
        </trans-unit>
        <trans-unit id="29326e19d0dc3f4c325692b2b9f948f424da0e4f" translate="yes" xml:space="preserve">
          <source>This hook saves the state of the iterators in the &lt;code&gt;Graph&lt;/code&gt; so that when training is resumed the input pipeline continues from where it left off. This could potentially avoid overfitting in certain pipelines where the number of training steps per eval are small compared to the dataset size or if the training pipeline is pre-empted.</source>
          <target state="translated">Este gancho guarda el estado de los iteradores en el &lt;code&gt;Graph&lt;/code&gt; modo que cuando se reanuda el entrenamiento, la canalizaci&amp;oacute;n de entrada contin&amp;uacute;a desde donde se qued&amp;oacute;. Esto podr&amp;iacute;a evitar el sobreajuste en ciertas canalizaciones en las que el n&amp;uacute;mero de pasos de entrenamiento por evaluaci&amp;oacute;n es peque&amp;ntilde;o en comparaci&amp;oacute;n con el tama&amp;ntilde;o del conjunto de datos o si la canalizaci&amp;oacute;n de entrenamiento es anticipada.</target>
        </trans-unit>
        <trans-unit id="362202ba29e8d6beed9c2059ae03ede13f3cd76f" translate="yes" xml:space="preserve">
          <source>This hook should be used if the input pipeline state needs to be saved separate from the model checkpoint. Doing so may be useful for a few reasons:</source>
          <target state="translated">Este gancho debe ser usado si el estado de la tubería de entrada necesita ser guardado separado del punto de control del modelo.Hacerlo puede ser útil por algunas razones:</target>
        </trans-unit>
        <trans-unit id="b6ae1f6a6bb162ce4153046b8500ec1c1479c758" translate="yes" xml:space="preserve">
          <source>This identifies the replica that is part of a sync group. Currently we assume that all sync groups contain the same number of replicas. The value of the replica id can range from 0 to &lt;code&gt;num_replica_in_sync&lt;/code&gt; - 1.</source>
          <target state="translated">Esto identifica la r&amp;eacute;plica que forma parte de un grupo de sincronizaci&amp;oacute;n. Actualmente asumimos que todos los grupos de sincronizaci&amp;oacute;n contienen el mismo n&amp;uacute;mero de r&amp;eacute;plicas. El valor de la identificaci&amp;oacute;n de la r&amp;eacute;plica puede oscilar entre 0 y &lt;code&gt;num_replica_in_sync&lt;/code&gt; - 1.</target>
        </trans-unit>
        <trans-unit id="1b29036c26df39b1ea3c52cbf28f86f795fcf9f0" translate="yes" xml:space="preserve">
          <source>This implementation is based off of the Cephes math library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f20df5d52794499c7d70f58fc604ea383aee58e" translate="yes" xml:space="preserve">
          <source>This implementation is to be used in conjunction of BlockLSTMV2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4e20691c6271c3052db6329ff09bab3c3926f92" translate="yes" xml:space="preserve">
          <source>This implementation is to be used in conjunction of LSTMBlock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2023d65f880c26efdc064ba734473728a5acce91" translate="yes" xml:space="preserve">
          <source>This implementation is to be used in conjunction of LSTMBlockCell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecd5efd797cabcd540fdce983afef271dcb8292a" translate="yes" xml:space="preserve">
          <source>This implementation of RMSprop uses plain momentum, not Nesterov momentum.</source>
          <target state="translated">Esta implementación de RMSprop utiliza el impulso simple,no el impulso de Nesterov.</target>
        </trans-unit>
        <trans-unit id="32650114feea17cac9bd97ba7f3acc193158dc56" translate="yes" xml:space="preserve">
          <source>This implementation uses 1 weight matrix and 1 bias vector, and there's an optional peephole connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69398f914b35c5353b93476810576462db6eec45" translate="yes" xml:space="preserve">
          <source>This implements the anisotropic 2-D version of the formula described here:</source>
          <target state="translated">Esto implementa la versión anisotrópica en 2-D de la fórmula descrita aquí:</target>
        </trans-unit>
        <trans-unit id="cd31200075bd4a5cc039e35e154eab86539a7999" translate="yes" xml:space="preserve">
          <source>This improves training speed. Please see &lt;code&gt;optimization_parameters.proto&lt;/code&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaa40933c0c7c31f3c54363539d17de16903a6ff" translate="yes" xml:space="preserve">
          <source>This includes ops from TF 2.0 tf.summary and TF 1.x tf.contrib.summary (except for &lt;code&gt;tf.contrib.summary.graph&lt;/code&gt; and &lt;code&gt;tf.contrib.summary.import_event&lt;/code&gt;), but does &lt;em&gt;not&lt;/em&gt; include TF 1.x tf.summary ops.</source>
          <target state="translated">Esto incluye operaciones de TF 2.0 tf.summary y TF 1.x tf.contrib.summary (excepto para &lt;code&gt;tf.contrib.summary.graph&lt;/code&gt; y &lt;code&gt;tf.contrib.summary.import_event&lt;/code&gt; ), pero &lt;em&gt;no&lt;/em&gt; incluye TF 1.x tf.summary ops.</target>
        </trans-unit>
        <trans-unit id="2cbffbf5b87e7d08406cd7f76d2f7936c22b5d07" translate="yes" xml:space="preserve">
          <source>This includes the operations to synchronize replicas: aggregate gradients, apply to variables, increment global step, insert tokens to token queue.</source>
          <target state="translated">Esto incluye las operaciones para sincronizar las réplicas:agregar gradientes,aplicar a las variables,incrementar el paso global,insertar fichas a la cola de fichas.</target>
        </trans-unit>
        <trans-unit id="dc77baa2dba67576cde30b92064b3afa6abe84f1" translate="yes" xml:space="preserve">
          <source>This induces quasi-linear speedup on up to 8 GPUs.</source>
          <target state="translated">Esto induce una aceleración cuasi lineal en hasta 8 GPU.</target>
        </trans-unit>
        <trans-unit id="9e91bcd2748922b865fbdb3c28f16a3f92c87b0e" translate="yes" xml:space="preserve">
          <source>This initializer assigns one entry in the table for each line in the file.</source>
          <target state="translated">Este inicializador asigna una entrada en la tabla para cada línea del archivo.</target>
        </trans-unit>
        <trans-unit id="93a30392533a2023857f78a57a8100de69db56b7" translate="yes" xml:space="preserve">
          <source>This initializes a new Kubernetes ClusterResolver. The ClusterResolver will attempt to talk to the Kubernetes master to retrieve all the instances of pods matching a label selector.</source>
          <target state="translated">Esto inicializa un nuevo Kubernetes ClusterResolver.El ClusterResolver intentará hablar con el maestro de Kubernetes para recuperar todas las instancias de las vainas que coincidan con un selector de etiquetas.</target>
        </trans-unit>
        <trans-unit id="ded15c2fc6dc030fcd9627bdc75c00460c2cb65d" translate="yes" xml:space="preserve">
          <source>This is (mostly) a special case of &lt;a href=&quot;../math/add&quot;&gt;&lt;code&gt;tf.add&lt;/code&gt;&lt;/a&gt; where &lt;code&gt;bias&lt;/code&gt; is restricted to 1-D. Broadcasting is supported, so &lt;code&gt;value&lt;/code&gt; may have any number of dimensions. Unlike &lt;a href=&quot;../math/add&quot;&gt;&lt;code&gt;tf.add&lt;/code&gt;&lt;/a&gt;, the type of &lt;code&gt;bias&lt;/code&gt; is allowed to differ from &lt;code&gt;value&lt;/code&gt; in the case where both types are quantized.</source>
          <target state="translated">Este es (en su mayor&amp;iacute;a) un caso especial de &lt;a href=&quot;../math/add&quot;&gt; &lt;code&gt;tf.add&lt;/code&gt; &lt;/a&gt; donde el &lt;code&gt;bias&lt;/code&gt; est&amp;aacute; restringido a 1-D. Se admite la transmisi&amp;oacute;n, por lo que el &lt;code&gt;value&lt;/code&gt; puede tener cualquier n&amp;uacute;mero de dimensiones. A diferencia de &lt;a href=&quot;../math/add&quot;&gt; &lt;code&gt;tf.add&lt;/code&gt; &lt;/a&gt; , el tipo de &lt;code&gt;bias&lt;/code&gt; puede diferir del &lt;code&gt;value&lt;/code&gt; en el caso de que se cuantifiquen ambos tipos.</target>
        </trans-unit>
        <trans-unit id="9f67d123191520f4a8994999dc8cd88f7fe320b7" translate="yes" xml:space="preserve">
          <source>This is EXPERIMENTAL and subject to change.</source>
          <target state="translated">Esto es EXPERIMENTAL y está sujeto a cambios.</target>
        </trans-unit>
        <trans-unit id="02f8d625292f24a8f6fa6d8a843ae5c003159e97" translate="yes" xml:space="preserve">
          <source>This is a class method that describes what key/value arguments are required to instantiate the given &lt;code&gt;Distribution&lt;/code&gt; so that a particular shape is returned for that instance's call to &lt;code&gt;sample()&lt;/code&gt;.</source>
          <target state="translated">Este es un m&amp;eacute;todo de clase que describe qu&amp;eacute; argumentos clave / valor se requieren para instanciar la &lt;code&gt;Distribution&lt;/code&gt; dada de modo que se devuelva una forma particular para la llamada de esa instancia a &lt;code&gt;sample()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="012a7836bd88d1e3c2c595506564d4812be83ba5" translate="yes" xml:space="preserve">
          <source>This is a class method that describes what key/value arguments are required to instantiate the given &lt;code&gt;Distribution&lt;/code&gt; so that a particular shape is returned for that instance's call to &lt;code&gt;sample()&lt;/code&gt;. Assumes that the sample's shape is known statically.</source>
          <target state="translated">Este es un m&amp;eacute;todo de clase que describe qu&amp;eacute; argumentos clave / valor se requieren para instanciar la &lt;code&gt;Distribution&lt;/code&gt; dada de modo que se devuelva una forma particular para la llamada de esa instancia a &lt;code&gt;sample()&lt;/code&gt; . Supone que la forma de la muestra se conoce est&amp;aacute;ticamente.</target>
        </trans-unit>
        <trans-unit id="fead40a760af2fb3753f3e33415c41be437e055a" translate="yes" xml:space="preserve">
          <source>This is a companion method to &lt;code&gt;add_queue_runner()&lt;/code&gt;. It just starts threads for all queue runners collected in the graph. It returns the list of all threads.</source>
          <target state="translated">Este es un m&amp;eacute;todo complementario de &lt;code&gt;add_queue_runner()&lt;/code&gt; . Simplemente inicia subprocesos para todos los corredores de cola recopilados en el gr&amp;aacute;fico. Devuelve la lista de todos los hilos.</target>
        </trans-unit>
        <trans-unit id="9590afd024cc456ab84ee4d2f95cabc25b5ebe3a" translate="yes" xml:space="preserve">
          <source>This is a context class that is passed to the &lt;code&gt;value_fn&lt;/code&gt; in &lt;code&gt;strategy.experimental_distribute_values_from_function&lt;/code&gt; and contains information about the compute replicas. The &lt;code&gt;num_replicas_in_sync&lt;/code&gt; and &lt;code&gt;replica_id&lt;/code&gt; can be used to customize the value on each replica.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="309ae6e7b107ea04158b03fa5671cc2764a5cdf7" translate="yes" xml:space="preserve">
          <source>This is a context class that is passed to the user's input function and contains information about the compute replicas and input pipelines. The number of compute replicas (in sync training) helps compute the local batch size from the desired global batch size for each replica. The input pipeline information can be used to return a different subset of the input in each replica (for e.g. shard the input pipeline, use a different input source etc).</source>
          <target state="translated">Se trata de una clase de contexto que se pasa a la función de entrada del usuario y contiene información sobre las réplicas de los ordenadores y las tuberías de entrada.El número de réplicas de cálculo (en entrenamiento de sincronización)ayuda a calcular el tamaño del lote local a partir del tamaño del lote global deseado para cada réplica.La información de la tubería de entrada puede utilizarse para devolver un subconjunto diferente de la entrada en cada réplica (para,por ejemplo,desmenuzar la tubería de entrada,utilizar una fuente de entrada diferente,etc.).</target>
        </trans-unit>
        <trans-unit id="1659a3286a3bedb8cf721b60523b4bfde4d51caf" translate="yes" xml:space="preserve">
          <source>This is a convenience method that converts RGB images to float representation, adjusts their brightness, and then converts them back to the original data type. If several adjustments are chained, it is advisable to minimize the number of redundant conversions.</source>
          <target state="translated">Este es un método conveniente que convierte las imágenes RGB en representación flotante,ajusta su brillo y luego las convierte de nuevo al tipo de datos original.Si se encadenan varios ajustes,es aconsejable minimizar el número de conversiones redundantes.</target>
        </trans-unit>
        <trans-unit id="7bcc711030b8e6b303b05fbb2eadad7a51295960" translate="yes" xml:space="preserve">
          <source>This is a convenience method that converts RGB images to float representation, adjusts their contrast, and then converts them back to the original data type. If several adjustments are chained, it is advisable to minimize the number of redundant conversions.</source>
          <target state="translated">Este es un método conveniente que convierte las imágenes RGB en representación flotante,ajusta su contraste y luego las convierte de nuevo al tipo de datos original.Si se encadenan varios ajustes,es aconsejable minimizar el número de conversiones redundantes.</target>
        </trans-unit>
        <trans-unit id="689582a22623e8b58ba6e0ed65682c48dc03d8f0" translate="yes" xml:space="preserve">
          <source>This is a convenience method that converts RGB images to float representation, converts them to HSV, add an offset to the saturation channel, converts back to RGB and then back to the original data type. If several adjustments are chained it is advisable to minimize the number of redundant conversions.</source>
          <target state="translated">Este es un método conveniente que convierte las imágenes RGB en representación flotante,las convierte en HSV,añade un desplazamiento al canal de saturación,vuelve a convertir a RGB y luego vuelve al tipo de datos original.Si se encadenan varios ajustes es aconsejable minimizar el número de conversiones redundantes.</target>
        </trans-unit>
        <trans-unit id="154fc7928cd01964ea2a05b16a1fbc2cadc62c3b" translate="yes" xml:space="preserve">
          <source>This is a convenience method that converts RGB images to float representation, converts them to HSV, adds an offset to the saturation channel, converts back to RGB and then back to the original data type. If several adjustments are chained it is advisable to minimize the number of redundant conversions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="157983bd7b4bf865fccf95ec9e2bc8ddd381392d" translate="yes" xml:space="preserve">
          <source>This is a convenience method that converts an RGB image to float representation, converts it to HSV, add an offset to the hue channel, converts back to RGB and then back to the original data type. If several adjustments are chained it is advisable to minimize the number of redundant conversions.</source>
          <target state="translated">Este es un método conveniente que convierte una imagen RGB en una representación flotante,la convierte en HSV,agrega un desplazamiento al canal de tonalidad,vuelve a convertirla en RGB y luego vuelve al tipo de datos original.Si se encadenan varios ajustes es aconsejable minimizar el número de conversiones redundantes.</target>
        </trans-unit>
        <trans-unit id="bc1addde10acbe587836014417c1c886ecf1e9cf" translate="yes" xml:space="preserve">
          <source>This is a convenience method that converts an RGB image to float representation, converts it to HSV, adds an offset to the hue channel, converts back to RGB and then back to the original data type. If several adjustments are chained it is advisable to minimize the number of redundant conversions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b85cb6fb2b17c1cfe1f8becbb4b4eeadf576adb" translate="yes" xml:space="preserve">
          <source>This is a convenience method that converts an image to uint8 representation, encodes it to jpeg with &lt;code&gt;jpeg_quality&lt;/code&gt;, decodes it, and then converts back to the original data type.</source>
          <target state="translated">Este es un m&amp;eacute;todo conveniente que convierte una imagen a la representaci&amp;oacute;n uint8, la codifica a jpeg con &lt;code&gt;jpeg_quality&lt;/code&gt; , la decodifica y luego la convierte de nuevo al tipo de datos original.</target>
        </trans-unit>
        <trans-unit id="040dbe98920d5a5c1090b8783413f490c3abe113" translate="yes" xml:space="preserve">
          <source>This is a convenience utility for packing data into the tuple formats that &lt;a href=&quot;../model#fit&quot;&gt;&lt;code&gt;Model.fit&lt;/code&gt;&lt;/a&gt; uses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="177a96552c22761995fc2a02f86657fdf66dd73d" translate="yes" xml:space="preserve">
          <source>This is a convenience utility to be used when overriding &lt;a href=&quot;../model#train_step&quot;&gt;&lt;code&gt;Model.train_step&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../model#test_step&quot;&gt;&lt;code&gt;Model.test_step&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../model#predict_step&quot;&gt;&lt;code&gt;Model.predict_step&lt;/code&gt;&lt;/a&gt;. This utility makes it easy to support data of the form &lt;code&gt;(x,)&lt;/code&gt;, &lt;code&gt;(x, y)&lt;/code&gt;, or &lt;code&gt;(x, y, sample_weight)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0b259f9b8e5db6abf1f7ca2cc64744a095dde1b" translate="yes" xml:space="preserve">
          <source>This is a dataset of 11,228 newswires from Reuters, labeled over 46 topics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="768eb884c8ee5b48b0c147f90ce4407a6a9884da" translate="yes" xml:space="preserve">
          <source>This is a dataset of 25,000 movies reviews from IMDB, labeled by sentiment (positive/negative). Reviews have been preprocessed, and each review is encoded as a list of word indexes (integers). For convenience, words are indexed by overall frequency in the dataset, so that for instance the integer &quot;3&quot; encodes the 3rd most frequent word in the data. This allows for quick filtering operations such as: &quot;only consider the top 10,000 most common words, but eliminate the top 20 most common words&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e86bf0041eb6fb31b4e9ede482e55b7d43a98c80" translate="yes" xml:space="preserve">
          <source>This is a dataset of 50,000 32x32 color training images and 10,000 test images, labeled over 10 categories. See more info at the &lt;a href=&quot;https://www.cs.toronto.edu/%7Ekriz/cifar.html&quot;&gt;CIFAR homepage&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="435f80948690367d77e0f3784d30df76f7f3d98a" translate="yes" xml:space="preserve">
          <source>This is a dataset of 50,000 32x32 color training images and 10,000 test images, labeled over 100 fine-grained classes that are grouped into 20 coarse-grained classes. See more info at the &lt;a href=&quot;https://www.cs.toronto.edu/%7Ekriz/cifar.html&quot;&gt;CIFAR homepage&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33a8fb4dd54ee096f6f9e8b6100e0ded183914c6" translate="yes" xml:space="preserve">
          <source>This is a dataset of 60,000 28x28 grayscale images of 10 fashion categories, along with a test set of 10,000 images. This dataset can be used as a drop-in replacement for MNIST. The class labels are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e30665bff921b2720a3a63831af563bf188d5b46" translate="yes" xml:space="preserve">
          <source>This is a dataset of 60,000 28x28 grayscale images of the 10 digits, along with a test set of 10,000 images. More info can be found at the &lt;a href=&quot;http://yann.lecun.com/exdb/mnist/&quot;&gt;MNIST homepage&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="710ac221d7447de49c2c2452f75596e4bb685c1c" translate="yes" xml:space="preserve">
          <source>This is a dataset taken from the StatLib library which is maintained at Carnegie Mellon University.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab28ad9476b59e4ae1d47c731d1e80592c84261d" translate="yes" xml:space="preserve">
          <source>This is a deprecated version of &lt;code&gt;fractional_avg_pool&lt;/code&gt;.</source>
          <target state="translated">Esta es una versi&amp;oacute;n obsoleta de &lt;code&gt;fractional_avg_pool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89fac60f109fd0365fd768e5b0c1efda980aac29" translate="yes" xml:space="preserve">
          <source>This is a deprecated version of &lt;code&gt;fractional_max_pool&lt;/code&gt;.</source>
          <target state="translated">Esta es una versi&amp;oacute;n obsoleta de &lt;code&gt;fractional_max_pool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec0b5065eeff136feb43dbfad07e272612b79d8c" translate="yes" xml:space="preserve">
          <source>This is a deprecated version of BiasAdd and will be soon removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="066f7ab7935722a8bd3e79702ee438f7b2aad916" translate="yes" xml:space="preserve">
          <source>This is a difference between DatasetV1 and DatasetV2. DatasetV1 does not take anything in its constructor whereas in the DatasetV2, we expect subclasses to create a variant_tensor and pass it in to the super() call.</source>
          <target state="translated">Esta es una diferencia entre DatasetV1 y DatasetV2.DatasetV1 no toma nada en su constructor mientras que en DatasetV2,esperamos que las subclases creen un tensor_variante y lo pasen a la llamada super().</target>
        </trans-unit>
        <trans-unit id="e7c85e6a460e7ff32a9089528b0d0f38042adaa0" translate="yes" xml:space="preserve">
          <source>This is a faster way to train a softmax classifier over a huge number of classes.</source>
          <target state="translated">Es una forma más rápida de entrenar un clasificador softmax en un gran número de clases.</target>
        </trans-unit>
        <trans-unit id="d7e11ee2edab133ca8b8374faafd78e7821ed539" translate="yes" xml:space="preserve">
          <source>This is a legacy behaviour of TensorFlow and is highly discouraged.</source>
          <target state="translated">Este es un comportamiento heredado de TensorFlow y es muy desalentado.</target>
        </trans-unit>
        <trans-unit id="a3be19c517fb6a6f6742dcaed9be8bb79e5a6a4d" translate="yes" xml:space="preserve">
          <source>This is a legacy version of the more general BatchToSpaceND.</source>
          <target state="translated">Esta es una versión heredada de la más general BatchToSpaceND.</target>
        </trans-unit>
        <trans-unit id="c2584be3bd38ee90f3ac17e87b40fd5fb1908bdb" translate="yes" xml:space="preserve">
          <source>This is a legacy version of the more general SpaceToBatchND.</source>
          <target state="translated">Esta es una versión heredada de la más general SpaceToBatchND.</target>
        </trans-unit>
        <trans-unit id="c0ae3cb7ef651d4c8fb957d4b4823d4c0713533f" translate="yes" xml:space="preserve">
          <source>This is a low-level interface for creating an &lt;code&gt;Operation&lt;/code&gt;. Most programs will not call this method directly, and instead use the Python op constructors, such as &lt;a href=&quot;constant&quot;&gt;&lt;code&gt;tf.constant()&lt;/code&gt;&lt;/a&gt;, which add ops to the default graph.</source>
          <target state="translated">Esta es una interfaz de bajo nivel para crear una &lt;code&gt;Operation&lt;/code&gt; . La mayor&amp;iacute;a de los programas no llamar&amp;aacute;n a este m&amp;eacute;todo directamente, sino que utilizar&amp;aacute;n los constructores de operaciones de Python, como &lt;a href=&quot;constant&quot;&gt; &lt;code&gt;tf.constant()&lt;/code&gt; &lt;/a&gt; , que a&amp;ntilde;aden operaciones al gr&amp;aacute;fico predeterminado.</target>
        </trans-unit>
        <trans-unit id="1cd850dc655362d680df73debd3d92a42edd1883" translate="yes" xml:space="preserve">
          <source>This is a method that implementers of subclasses of &lt;code&gt;Layer&lt;/code&gt; or &lt;code&gt;Model&lt;/code&gt; can override if they need a state-creation step in-between layer instantiation and layer call.</source>
          <target state="translated">Este es un m&amp;eacute;todo que los implementadores de subclases de &lt;code&gt;Layer&lt;/code&gt; o &lt;code&gt;Model&lt;/code&gt; o pueden anular si necesitan un paso de creaci&amp;oacute;n de estado entre la instanciaci&amp;oacute;n de capa y la llamada de capa.</target>
        </trans-unit>
        <trans-unit id="62c4042c7b665a4296b8d1a943304048eb64aec7" translate="yes" xml:space="preserve">
          <source>This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited.</source>
          <target state="translated">Este es un número entero distinto de cero.Mira la función get_ident().Los identificadores de hilos pueden ser reciclados cuando un hilo sale y se crea otro hilo.El identificador está disponible incluso después de que el hilo haya salido.</target>
        </trans-unit>
        <trans-unit id="31eb573dcb4f05e127842ce7a2c523b4f9fd2e61" translate="yes" xml:space="preserve">
          <source>This is a reduction created for Nvidia DGX-1 which assumes GPUs connects like that on DGX-1 machine. If you have different GPU inter-connections, it is likely that it would be slower than &lt;a href=&quot;reductiontoonedevice&quot;&gt;&lt;code&gt;tf.distribute.ReductionToOneDevice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esta es una reducci&amp;oacute;n creada para Nvidia DGX-1 que asume que las GPU se conectan as&amp;iacute; en la m&amp;aacute;quina DGX-1. Si tiene diferentes interconexiones de GPU, es probable que sea m&amp;aacute;s lento que &lt;a href=&quot;reductiontoonedevice&quot;&gt; &lt;code&gt;tf.distribute.ReductionToOneDevice&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="85f7e8c05b61af3e5451f6e510d0b0985383c1d8" translate="yes" xml:space="preserve">
          <source>This is a special case of &lt;a href=&quot;../math/add&quot;&gt;&lt;code&gt;tf.add&lt;/code&gt;&lt;/a&gt; where &lt;code&gt;bias&lt;/code&gt; is restricted to be 1-D. Broadcasting is supported, so &lt;code&gt;value&lt;/code&gt; may have any number of dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbdbb1332709a943bc7d0db1d68caf76c3a99f69" translate="yes" xml:space="preserve">
          <source>This is a stateless version of &lt;a href=&quot;../../../random/categorical&quot;&gt;&lt;code&gt;tf.random.categorical&lt;/code&gt;&lt;/a&gt;: if run twice with the same seeds and shapes, it will produce the same pseudorandom numbers. The output is consistent across multiple runs on the same hardware (and between CPU and GPU), but may change between versions of TensorFlow or on non-CPU/GPU hardware.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81cb44c6cca42a31a07fbae208fd1a7a56619cfa" translate="yes" xml:space="preserve">
          <source>This is a stateless version of &lt;a href=&quot;../../../random/categorical&quot;&gt;&lt;code&gt;tf.random.categorical&lt;/code&gt;&lt;/a&gt;: if run twice with the same seeds, it will produce the same pseudorandom numbers. The output is consistent across multiple runs on the same hardware (and between CPU and GPU), but may change between versions of TensorFlow or on non-CPU/GPU hardware.</source>
          <target state="translated">Esta es una versi&amp;oacute;n sin estado de &lt;a href=&quot;../../../random/categorical&quot;&gt; &lt;code&gt;tf.random.categorical&lt;/code&gt; &lt;/a&gt; : si se ejecuta dos veces con las mismas semillas, producir&amp;aacute; los mismos n&amp;uacute;meros pseudoaleatorios. El resultado es consistente en varias ejecuciones en el mismo hardware (y entre CPU y GPU), pero puede cambiar entre versiones de TensorFlow o en hardware sin CPU / GPU.</target>
        </trans-unit>
        <trans-unit id="de68a47b12e07130e567ec24bb61927f4f535092" translate="yes" xml:space="preserve">
          <source>This is a stateless version of &lt;a href=&quot;gamma&quot;&gt;&lt;code&gt;tf.random.gamma&lt;/code&gt;&lt;/a&gt;: if run twice with the same seeds and shapes, it will produce the same pseudorandom numbers. The output is consistent across multiple runs on the same hardware (and between CPU and GPU), but may change between versions of TensorFlow or on non-CPU/GPU hardware.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d527e38ee04e494f8d4e9909ef23824c02f218d2" translate="yes" xml:space="preserve">
          <source>This is a stateless version of &lt;a href=&quot;generator#binomial&quot;&gt;&lt;code&gt;tf.random.Generator.binomial&lt;/code&gt;&lt;/a&gt;: if run twice with the same seeds and shapes, it will produce the same pseudorandom numbers. The output is consistent across multiple runs on the same hardware (and between CPU and GPU), but may change between versions of TensorFlow or on non-CPU/GPU hardware.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f9d7559f26ce2def191894981d83e7101b4893f" translate="yes" xml:space="preserve">
          <source>This is a stateless version of &lt;a href=&quot;normal&quot;&gt;&lt;code&gt;tf.random.normal&lt;/code&gt;&lt;/a&gt;: if run twice with the same seeds and shapes, it will produce the same pseudorandom numbers. The output is consistent across multiple runs on the same hardware (and between CPU and GPU), but may change between versions of TensorFlow or on non-CPU/GPU hardware.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="812a072511f22cc831859b50e28ff4fe62133693" translate="yes" xml:space="preserve">
          <source>This is a stateless version of &lt;a href=&quot;normal&quot;&gt;&lt;code&gt;tf.random.normal&lt;/code&gt;&lt;/a&gt;: if run twice with the same seeds, it will produce the same pseudorandom numbers. The output is consistent across multiple runs on the same hardware (and between CPU and GPU), but may change between versions of TensorFlow or on non-CPU/GPU hardware.</source>
          <target state="translated">Esta es una versi&amp;oacute;n sin estado de &lt;a href=&quot;normal&quot;&gt; &lt;code&gt;tf.random.normal&lt;/code&gt; &lt;/a&gt; : si se ejecuta dos veces con las mismas semillas, producir&amp;aacute; los mismos n&amp;uacute;meros pseudoaleatorios. El resultado es consistente en varias ejecuciones en el mismo hardware (y entre CPU y GPU), pero puede cambiar entre versiones de TensorFlow o en hardware sin CPU / GPU.</target>
        </trans-unit>
        <trans-unit id="eb02c3777bd174779389bb97e4e8d5e8436a288c" translate="yes" xml:space="preserve">
          <source>This is a stateless version of &lt;a href=&quot;poisson&quot;&gt;&lt;code&gt;tf.random.poisson&lt;/code&gt;&lt;/a&gt;: if run twice with the same seeds and shapes, it will produce the same pseudorandom numbers. The output is consistent across multiple runs on the same hardware, but may change between versions of TensorFlow or on non-CPU/GPU hardware.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ca51d036bc29518d8577d5bfc5e3dc7a0421db6" translate="yes" xml:space="preserve">
          <source>This is a stateless version of &lt;a href=&quot;truncated_normal&quot;&gt;&lt;code&gt;tf.random.truncated_normal&lt;/code&gt;&lt;/a&gt;: if run twice with the same seeds and shapes, it will produce the same pseudorandom numbers. The output is consistent across multiple runs on the same hardware (and between CPU and GPU), but may change between versions of TensorFlow or on non-CPU/GPU hardware.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd6096e0d7eff9f42170cc05a1fe61ba85be91f4" translate="yes" xml:space="preserve">
          <source>This is a stateless version of &lt;a href=&quot;truncated_normal&quot;&gt;&lt;code&gt;tf.random.truncated_normal&lt;/code&gt;&lt;/a&gt;: if run twice with the same seeds, it will produce the same pseudorandom numbers. The output is consistent across multiple runs on the same hardware (and between CPU and GPU), but may change between versions of TensorFlow or on non-CPU/GPU hardware.</source>
          <target state="translated">Esta es una versi&amp;oacute;n sin estado de &lt;a href=&quot;truncated_normal&quot;&gt; &lt;code&gt;tf.random.truncated_normal&lt;/code&gt; &lt;/a&gt; : si se ejecuta dos veces con las mismas semillas, producir&amp;aacute; los mismos n&amp;uacute;meros pseudoaleatorios. El resultado es consistente en varias ejecuciones en el mismo hardware (y entre CPU y GPU), pero puede cambiar entre versiones de TensorFlow o en hardware sin CPU / GPU.</target>
        </trans-unit>
        <trans-unit id="ac72baa117d9b4a5bdf610d359eb9848fb6723ce" translate="yes" xml:space="preserve">
          <source>This is a stateless version of &lt;a href=&quot;uniform&quot;&gt;&lt;code&gt;tf.random.uniform&lt;/code&gt;&lt;/a&gt;: if run twice with the same seeds and shapes, it will produce the same pseudorandom numbers. The output is consistent across multiple runs on the same hardware (and between CPU and GPU), but may change between versions of TensorFlow or on non-CPU/GPU hardware.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b120804ac2994699c2b37663ac0990fd63dfd70" translate="yes" xml:space="preserve">
          <source>This is a stateless version of &lt;a href=&quot;uniform&quot;&gt;&lt;code&gt;tf.random.uniform&lt;/code&gt;&lt;/a&gt;: if run twice with the same seeds, it will produce the same pseudorandom numbers. The output is consistent across multiple runs on the same hardware (and between CPU and GPU), but may change between versions of TensorFlow or on non-CPU/GPU hardware.</source>
          <target state="translated">Esta es una versi&amp;oacute;n sin estado de &lt;a href=&quot;uniform&quot;&gt; &lt;code&gt;tf.random.uniform&lt;/code&gt; &lt;/a&gt; : si se ejecuta dos veces con las mismas semillas, producir&amp;aacute; los mismos n&amp;uacute;meros pseudoaleatorios. El resultado es consistente en varias ejecuciones en el mismo hardware (y entre CPU y GPU), pero puede cambiar entre versiones de TensorFlow o en hardware sin CPU / GPU.</target>
        </trans-unit>
        <trans-unit id="93abfee5707aabda372725092df92726179f4164" translate="yes" xml:space="preserve">
          <source>This is a stateless version of &lt;code&gt;tf.categorical&lt;/code&gt;: if run twice with the same seeds and shapes, it will produce the same pseudorandom numbers. The output is consistent across multiple runs on the same hardware (and between CPU and GPU), but may change between versions of TensorFlow or on non-CPU/GPU hardware.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ada11b1aaca11d67319d958bd7d1da13f15ebb7f" translate="yes" xml:space="preserve">
          <source>This is a stateless version of &lt;code&gt;tf.categorical&lt;/code&gt;: if run twice with the same seeds, it will produce the same pseudorandom numbers. The output is consistent across multiple runs on the same hardware (and between CPU and GPU), but may change between versions of TensorFlow or on non-CPU/GPU hardware.</source>
          <target state="translated">Esta es una versi&amp;oacute;n sin estado de &lt;code&gt;tf.categorical&lt;/code&gt; : si se ejecuta dos veces con las mismas semillas, producir&amp;aacute; los mismos n&amp;uacute;meros pseudoaleatorios. El resultado es consistente en varias ejecuciones en el mismo hardware (y entre CPU y GPU), pero puede cambiar entre versiones de TensorFlow o en hardware sin CPU / GPU.</target>
        </trans-unit>
        <trans-unit id="9603abb8f073d177d05702e0bc2ac4de5a04a74c" translate="yes" xml:space="preserve">
          <source>This is a wrapper to the &lt;code&gt;hashing_trick&lt;/code&gt; function using &lt;code&gt;hash&lt;/code&gt; as the hashing function; unicity of word to index mapping non-guaranteed.</source>
          <target state="translated">Esta es una envoltura de la funci&amp;oacute;n &lt;code&gt;hashing_trick&lt;/code&gt; que usa &lt;code&gt;hash&lt;/code&gt; como funci&amp;oacute;n hash; la unicidad de la asignaci&amp;oacute;n de palabras a &amp;iacute;ndices no est&amp;aacute; garantizada.</target>
        </trans-unit>
        <trans-unit id="5b00a32a0d99275c6a4a177506328b41e8a5cbe9" translate="yes" xml:space="preserve">
          <source>This is almost identical to QuantizeAndDequantizeV2, except that num_bits is a tensor, so its value can change during training.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac7a813777192ceaa721f12e2b167eefa5ce19d7" translate="yes" xml:space="preserve">
          <source>This is always checked statically, so this method returns nothing.</source>
          <target state="translated">Esto siempre se comprueba estáticamente,así que este método no devuelve nada.</target>
        </trans-unit>
        <trans-unit id="edf37ccd5d1846dec567da6f67dc930901f7907c" translate="yes" xml:space="preserve">
          <source>This is an abstract base class, so you cannot instantiate it directly. Instead, use one of its concrete subclasses:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acb8330008d86d94ea39351a6992d0b396765e55" translate="yes" xml:space="preserve">
          <source>This is an abstract class which allows extensions to TensorFlow's object-based checkpointing (see &lt;a href=&quot;../checkpoint&quot;&gt;&lt;code&gt;tf.train.Checkpoint&lt;/code&gt;&lt;/a&gt;). For example a wrapper for NumPy arrays:</source>
          <target state="translated">Esta es una clase abstracta que permite extensiones a los puntos de control basados ​​en objetos de TensorFlow (consulte &lt;a href=&quot;../checkpoint&quot;&gt; &lt;code&gt;tf.train.Checkpoint&lt;/code&gt; &lt;/a&gt; ). Por ejemplo, un contenedor para matrices NumPy:</target>
        </trans-unit>
        <trans-unit id="f0c3e68e0358a0f76609938022081ba5ccf573dd" translate="yes" xml:space="preserve">
          <source>This is an experimental op for internal use only and it is possible to use this op in unsafe ways. DO NOT USE unless you fully understand the risks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bbaa33b6f8b11a0355ba861cdf03d3e08622a92" translate="yes" xml:space="preserve">
          <source>This is an identity op (behaves like &lt;a href=&quot;../../identity&quot;&gt;&lt;code&gt;tf.identity&lt;/code&gt;&lt;/a&gt;) with the side effect of printing &lt;code&gt;data&lt;/code&gt; when evaluating.</source>
          <target state="translated">Esta es una &lt;a href=&quot;../../identity&quot;&gt; &lt;code&gt;tf.identity&lt;/code&gt; &lt;/a&gt; identidad (se comporta como tf.identity ) con el efecto secundario de imprimir &lt;code&gt;data&lt;/code&gt; al evaluar.</target>
        </trans-unit>
        <trans-unit id="5c9b3651662523b2ca2e5016d6f25cb9aff58541" translate="yes" xml:space="preserve">
          <source>This is an implementation of ClusterResolver for Slurm clusters. This allows the specification of jobs and task counts, number of tasks per node, number of GPUs on each node and number of GPUs for each task. It retrieves system attributes by Slurm environment variables, resolves allocated computing node names, constructs a cluster and returns a ClusterResolver object which can be used for distributed TensorFlow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04be17d14e8556e45ddfd971016c00de8c4f5796" translate="yes" xml:space="preserve">
          <source>This is an implementation of cluster resolvers for Kubernetes. When given the the Kubernetes namespace and label selector for pods, we will retrieve the pod IP addresses of all running pods matching the selector, and return a ClusterSpec based on that information.</source>
          <target state="translated">Esta es una implementación de los resolutores de clusters para los Kubernetes.Cuando se le da el espacio de nombres de Kubernetes y el selector de etiquetas para los pods,recuperamos las direcciones IP de todos los pods en ejecución que coinciden con el selector,y devolvemos un ClusterSpec basado en esa información.</target>
        </trans-unit>
        <trans-unit id="fbfdd6a723bd3e94666f26590d4249971ef2fb48" translate="yes" xml:space="preserve">
          <source>This is an implementation of cluster resolvers for Slurm clusters. This allows the specification of jobs and task counts, number of tasks per node, number of GPUs on each node and number of GPUs for each task. It retrieves system attributes by Slurm environment variables, resolves allocated computing node names, constructs a cluster and returns a ClusterResolver object which can be use for distributed TensorFlow.</source>
          <target state="translated">Esta es una implementación de los resolutores de cúmulos para los cúmulos de Slurm.Esto permite la especificación de trabajos y recuentos de tareas,número de tareas por nodo,número de GPUs en cada nodo y número de GPUs para cada tarea.Recupera los atributos del sistema mediante variables de entorno de Slurm,resuelve los nombres de los nodos de computación asignados,construye un clúster y devuelve un objeto ClusterResolver que puede utilizarse para TensorFlow distribuido.</target>
        </trans-unit>
        <trans-unit id="6c7332a1bfb936db2e58085e5162712580a9aab8" translate="yes" xml:space="preserve">
          <source>This is an implementation of cluster resolvers for the Google Cloud TPU service.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71688349367e3a46bf633affe83f7f67a539cf79" translate="yes" xml:space="preserve">
          <source>This is an implementation of cluster resolvers for the Google Cloud TPU service. As Cloud TPUs are in alpha, you will need to specify a API definition file for this to consume, in addition to a list of Cloud TPUs in your Google Cloud Platform project.</source>
          <target state="translated">Esta es una implementación de los resolutores de clúster para el servicio TPU de Google Cloud.Como los TPUs Cloud están en alfa,usted necesitará especificar un archivo de definición de API para que éste se consuma,además de una lista de TPUs Cloud en su proyecto de Plataforma Google Cloud.</target>
        </trans-unit>
        <trans-unit id="ad683e8f469fc31a1a6f2ec923965536267cfedf" translate="yes" xml:space="preserve">
          <source>This is an implementation of cluster resolvers for the Google Compute Engine instance group platform. By specifying a project, zone, and instance group, this will retrieve the IP address of all the instances within the instance group and return a ClusterResolver object suitable for use for distributed TensorFlow.</source>
          <target state="translated">Esta es una implementación de los resolutores de clusters para la plataforma de grupos de instancias de Google Compute Engine.Al especificar un proyecto,zona y grupo de instancias,esto recuperará la dirección IP de todas las instancias dentro del grupo de instancias y devolverá un objeto ClusterResolver adecuado para el uso de TensorFlow distribuido.</target>
        </trans-unit>
        <trans-unit id="a371677e8e3150f82fcdcb41fbdf4b2aece50db2" translate="yes" xml:space="preserve">
          <source>This is an implementation of cluster resolvers when using TF_CONFIG to set information about the cluster. The cluster spec returned will be initialized from the TF_CONFIG environment variable.</source>
          <target state="translated">Se trata de una implementación de los resolutores de cúmulos cuando se utiliza TF_CONFIG para establecer información sobre el cúmulo.La especificación del clúster devuelta se inicializará a partir de la variable de entorno TF_CONFIG.</target>
        </trans-unit>
        <trans-unit id="f2e4a40b99bc22ad76a6b8d488160787266d96b7" translate="yes" xml:space="preserve">
          <source>This is because evaluating the gradient graph does not require evaluating the constant(1) op created in the forward pass.</source>
          <target state="translated">Esto se debe a que la evaluación del gráfico de gradiente no requiere la evaluación de la constante(1)op creada en el pase de avance.</target>
        </trans-unit>
        <trans-unit id="b402b2ea93d17cfe8814c2e2dd9513661013af48" translate="yes" xml:space="preserve">
          <source>This is called to signal the hooks that a new session has been created. This has two essential differences with the situation in which &lt;code&gt;begin&lt;/code&gt; is called:</source>
          <target state="translated">Esto se llama para indicar a los ganchos que se ha creado una nueva sesi&amp;oacute;n. Esto tiene dos diferencias esenciales con la situaci&amp;oacute;n en la que &lt;code&gt;begin&lt;/code&gt; se llama:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
