<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="tensorflow">
    <body>
      <group id="tensorflow">
        <trans-unit id="2a153ad993b58e91534aaa1b0194100c39e780a2" translate="yes" xml:space="preserve">
          <source>Float. Range for random channel shifts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f298b29df0aaed3c2269372e55d5d95d6479cc14" translate="yes" xml:space="preserve">
          <source>Float. Shear Intensity (Shear angle in counter-clockwise direction in degrees)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d61a6c9d692f4f07e8ed530942501016a4e248b8" translate="yes" xml:space="preserve">
          <source>Float. Sleep for up to that many seconds waiting for should_stop() to become True.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b216453945e2387161200857251f449d037b3948" translate="yes" xml:space="preserve">
          <source>Float. The decay to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a8d2374e2cdf12bb0ad483865021b7b46af8084" translate="yes" xml:space="preserve">
          <source>Float. Threshold value for thresholded activation. Default to 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bb464c8d0de78b41f137b84b0a45a7ef1df1306" translate="yes" xml:space="preserve">
          <source>Float; L1 regularization factor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e545332d824ca10ae9436e8e94121d2688432cd4" translate="yes" xml:space="preserve">
          <source>Float; L2 regularization factor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d98d28f78e216bda13139a52fd08416526b5fd50" translate="yes" xml:space="preserve">
          <source>Floating point dtype of &lt;code&gt;alpha&lt;/code&gt;, &lt;code&gt;beta&lt;/code&gt;, and the output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1108f1c23cbc1e57319f627f818d48f1bc5ea8b3" translate="yes" xml:space="preserve">
          <source>Floating point tensor representing unnormalized log-probabilities of a positive event with shape broadcastable to &lt;code&gt;[N1,..., Nm, K]&lt;/code&gt;&lt;code&gt;m &amp;gt;= 0&lt;/code&gt;, and the same dtype as &lt;code&gt;total_count&lt;/code&gt;. Defines this as a batch of &lt;code&gt;N1 x ... x Nm&lt;/code&gt; different &lt;code&gt;K&lt;/code&gt; class Multinomial distributions. Only one of &lt;code&gt;logits&lt;/code&gt; or &lt;code&gt;probs&lt;/code&gt; should be passed in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecab45c217e3d9a346314ec4e398aa11dd87ce21" translate="yes" xml:space="preserve">
          <source>Floating point tensor which characterizes the location (center) of the distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c22ad41332a3111722a8770b295e776925f1ab64" translate="yes" xml:space="preserve">
          <source>Floating point tensor, equivalent to &lt;code&gt;1 / mean&lt;/code&gt;. Must contain only positive values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebec1c58e95127ff044f512a93e456ed5e0f423a" translate="yes" xml:space="preserve">
          <source>Floating point tensor, lower boundary of the output interval. Must have &lt;code&gt;low &amp;lt; high&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0a469e0804bf541623d16583f6919e570634685" translate="yes" xml:space="preserve">
          <source>Floating point tensor, the concentration params of the distribution(s). Must contain only positive values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c8a724a94fb47724c39c1be0f5af846a44c632d" translate="yes" xml:space="preserve">
          <source>Floating point tensor, the inverse scale params of the distribution(s). Must contain only positive values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5327a6fa2b169fe97edfd87b3231c2fc0e85d1d3" translate="yes" xml:space="preserve">
          <source>Floating point tensor, upper boundary of the output interval. Must have &lt;code&gt;low &amp;lt; high&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f21ecae5ea295908a041bff28ab082db7d65a86e" translate="yes" xml:space="preserve">
          <source>Floating point tensor; the means of the distribution(s).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1f7e6b0fe6613bd3d52f8409a688348e04f4a6d" translate="yes" xml:space="preserve">
          <source>Floating point tensor; the stddevs of the distribution(s). Must contain only positive values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddaf74f02e9ba66941d4fb8e98d09812330541ef" translate="yes" xml:space="preserve">
          <source>Floating-point &lt;code&gt;Tensor&lt;/code&gt; with shape &lt;code&gt;[B1, ..., Bn, k', k']&lt;/code&gt; where the first &lt;code&gt;n&lt;/code&gt; dimensions are batch coordinates and &lt;code&gt;k' = reduce_prod(self.event_shape)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1009ba855ce72dff0358aacd603e698195e0cc2e" translate="yes" xml:space="preserve">
          <source>Floating-point &lt;code&gt;Tensor&lt;/code&gt; with shape identical to &lt;code&gt;batch_shape + event_shape&lt;/code&gt;, i.e., the same shape as &lt;code&gt;self.mean()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc7844a942513a10bbbb9e00e72332f173c63976" translate="yes" xml:space="preserve">
          <source>Floating-point &lt;code&gt;Tensor&lt;/code&gt;. The degrees of freedom of the distribution(s). &lt;code&gt;df&lt;/code&gt; must contain only positive values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d90b467f05cdb99ed3725de235ef01720d9a043" translate="yes" xml:space="preserve">
          <source>Floating-point &lt;code&gt;Tensor&lt;/code&gt;. The mean(s) of the distribution(s).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30e8504e26a1e405a364b16182f146926ce77d1d" translate="yes" xml:space="preserve">
          <source>Floating-point &lt;code&gt;Tensor&lt;/code&gt;. The scaling factor(s) for the distribution(s). Note that &lt;code&gt;scale&lt;/code&gt; is not technically the standard deviation of this distribution but has semantics more similar to standard deviation than variance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7db82f74092fc3160e6bc0d9e9bd4849c5c06c0f" translate="yes" xml:space="preserve">
          <source>Floor</source>
          <target state="translated">Floor</target>
        </trans-unit>
        <trans-unit id="6459c53ba8e729ad9aabb9ade4a34e551f147d2f" translate="yes" xml:space="preserve">
          <source>FloorDiv</source>
          <target state="translated">FloorDiv</target>
        </trans-unit>
        <trans-unit id="e19f1321e0f0e74f314d249fb2231ea22ddbb827" translate="yes" xml:space="preserve">
          <source>FloorMod</source>
          <target state="translated">FloorMod</target>
        </trans-unit>
        <trans-unit id="3a522d2554ce1f4be52f55076b2741713cbd45ec" translate="yes" xml:space="preserve">
          <source>Flush the file.</source>
          <target state="translated">Tira el archivo.</target>
        </trans-unit>
        <trans-unit id="dd5993032f3482cc7f5027e64c00852d5ba8b251" translate="yes" xml:space="preserve">
          <source>Flush the quantile summaries from each quantile stream resource.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfeaaa5a96eaede43e8bbe386e2dc6ef41feac38" translate="yes" xml:space="preserve">
          <source>Flush the summaries for a quantile stream resource.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd5e3fc25c8039e27103eb4fe6d62a39fa677f1d" translate="yes" xml:space="preserve">
          <source>FlushSummaryWriter</source>
          <target state="translated">FlushSummaryWriter</target>
        </trans-unit>
        <trans-unit id="6f8d4e8b184b36bf829848dabccbd29eed8aad30" translate="yes" xml:space="preserve">
          <source>Flushes and closes the summary writer.</source>
          <target state="translated">Se ruboriza y se cierra el resumen del escritor.</target>
        </trans-unit>
        <trans-unit id="9dbf53cec96a5446255caa0966d9befabc811892" translate="yes" xml:space="preserve">
          <source>Flushes any buffered data.</source>
          <target state="translated">Elimina cualquier dato almacenado en el buffer.</target>
        </trans-unit>
        <trans-unit id="bb205e45a353b942abb883e789503bde26fce540" translate="yes" xml:space="preserve">
          <source>Flushes the Writable file.</source>
          <target state="translated">Tira por la borda el archivo de escritura.</target>
        </trans-unit>
        <trans-unit id="7ba4cab89493ed49c06282e139f3f44d50a23884" translate="yes" xml:space="preserve">
          <source>Flushes the event file to disk and close the file.</source>
          <target state="translated">Descarga el archivo de eventos en el disco y cierra el archivo.</target>
        </trans-unit>
        <trans-unit id="411ec1b384ddb34e5e50e858b2000e66bb3e655d" translate="yes" xml:space="preserve">
          <source>Flushes the event file to disk.</source>
          <target state="translated">Descarga el archivo de eventos al disco.</target>
        </trans-unit>
        <trans-unit id="9b7edfcf83a187737117b2f47b6141554f630be7" translate="yes" xml:space="preserve">
          <source>Folds in data to an RNG seed to form a new RNG seed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15713d62ed5ca4009b476df4c237ce2bc0ad0830" translate="yes" xml:space="preserve">
          <source>Following explains differences between the expected SparseTensors: For example if dense form of your sparse data has shape &lt;code&gt;[3, 5]&lt;/code&gt; and values:</source>
          <target state="translated">A continuaci&amp;oacute;n se explican las diferencias entre los SparseTensors esperados: Por ejemplo, si la forma densa de sus datos dispersos tiene forma &lt;code&gt;[3, 5]&lt;/code&gt; y valores:</target>
        </trans-unit>
        <trans-unit id="1f587840359f89bcceb77644a681ee1053752a4d" translate="yes" xml:space="preserve">
          <source>Following standard Python indexing rules, a negative &lt;code&gt;axis&lt;/code&gt; counts from the end so &lt;code&gt;axis=-1&lt;/code&gt; adds an inner most dimension:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a4d707a678724dde2fddb59f45c1e15e1429fb9" translate="yes" xml:space="preserve">
          <source>Following standard python indexing rules, a negative &lt;code&gt;axis&lt;/code&gt; counts from the end so &lt;code&gt;axis=-1&lt;/code&gt; adds an inner most dimension:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7880600348a091a43e2a84906d6002820643108" translate="yes" xml:space="preserve">
          <source>For</source>
          <target state="translated">For</target>
        </trans-unit>
        <trans-unit id="4fd9985785e46b3b8d2eb080ecf31ffb84a61f11" translate="yes" xml:space="preserve">
          <source>For &amp;gt;0D tensors, truthiness is determined by looking at the number of elements. If has zero elements, then the result is false. Otherwise the result is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9f9a841a7e0cc5b022e6318bea78b55a9efc104" translate="yes" xml:space="preserve">
          <source>For 'channels_last' data_format, the 2nd, 3rd and 4th dimension will be padded. For 'channels_first' data_format, the 3rd, 4th and 5th dimension will be padded.</source>
          <target state="translated">Para el formato de datos 'channels_last',la 2ª,3ª y 4ª dimensión serán acolchadas.Para el formato de datos 'channels_first',la 3ª,4ª y 5ª dimensión serán rellenadas.</target>
        </trans-unit>
        <trans-unit id="4d447d9221f45cdb582dda20329208318ce162fc" translate="yes" xml:space="preserve">
          <source>For 0 &amp;lt;= i &amp;lt; len(spatial_dims), we assign:</source>
          <target state="translated">Para 0 &amp;lt;= i &amp;lt;len (space_dims), asignamos:</target>
        </trans-unit>
        <trans-unit id="146f00a85b68b92b896f97b975828e18300e6475" translate="yes" xml:space="preserve">
          <source>For 0-D (scalar) &lt;code&gt;indices&lt;/code&gt;:</source>
          <target state="translated">Para &lt;code&gt;indices&lt;/code&gt; 0-D (escalares) :</target>
        </trans-unit>
        <trans-unit id="547112f2822cdd1e4adf3817f29d09a381834041" translate="yes" xml:space="preserve">
          <source>For 0D tensors, truthiness is determined by comparing against a &quot;zero&quot; value. For numerical types it is the obvious zero. For strings it is the empty string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93086c1250897fa853eb236163fc696ad9b7ad7a" translate="yes" xml:space="preserve">
          <source>For 1-D (vector) &lt;code&gt;indices&lt;/code&gt; with &lt;code&gt;batch_dims=0&lt;/code&gt;:</source>
          <target state="translated">Para &lt;code&gt;indices&lt;/code&gt; 1-D (vector) con &lt;code&gt;batch_dims=0&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0a015181e096f8a1581f3a9641d414e5785efcf9" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;1+1j&lt;/code&gt; the value would be computed as: \(e^1{\\cos(1)+i\\sin(1)} = 2.7182817 \\times (0.5403023+0.84147096j)\)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="defba424886a691f2ba7bcc4056171fb0d0e0d47" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;SparseTensor&lt;/code&gt;s, the first (batch) column of the indices matrix is removed (the indices matrix is a column vector), the values vector is unchanged, and the first (&lt;code&gt;batch_size&lt;/code&gt;) entry of the shape vector is removed (it is now a single element vector).</source>
          <target state="translated">Para &lt;code&gt;SparseTensor&lt;/code&gt; s, se elimina la primera columna (lote) de la matriz de &amp;iacute;ndices (la matriz de &amp;iacute;ndices es un vector de columna), el vector de valores no cambia y se &lt;code&gt;batch_size&lt;/code&gt; la primera entrada ( batch_size ) del vector de forma (ahora es un vector de elemento &amp;uacute;nico).</target>
        </trans-unit>
        <trans-unit id="44ae4bb96a98281ba7a5f41018a3c0cf10c4dea5" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;mode == ModeKeys.EVAL&lt;/code&gt;: required field is &lt;code&gt;loss&lt;/code&gt;.</source>
          <target state="translated">Para &lt;code&gt;mode == ModeKeys.EVAL&lt;/code&gt; : el campo obligatorio es una &lt;code&gt;loss&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa798daa39c957c071f1ef2d8ef9c584caee3af3" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;mode == ModeKeys.PREDICT&lt;/code&gt;: required fields are &lt;code&gt;predictions&lt;/code&gt;.</source>
          <target state="translated">Para &lt;code&gt;mode == ModeKeys.PREDICT&lt;/code&gt; : los campos obligatorios son &lt;code&gt;predictions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c1da15aacc237948a45719180b4b1f05786246a" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;mode == ModeKeys.TRAIN&lt;/code&gt;: required fields are &lt;code&gt;loss&lt;/code&gt; and &lt;code&gt;train_op&lt;/code&gt;.</source>
          <target state="translated">Para &lt;code&gt;mode == ModeKeys.TRAIN&lt;/code&gt; : los campos obligatorios son &lt;code&gt;loss&lt;/code&gt; y &lt;code&gt;train_op&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7f68e1644d616fa9efc4179ea412ad0959f6e10" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;nesterov=True&lt;/code&gt;, See &lt;a href=&quot;http://jmlr.org/proceedings/papers/v28/sutskever13.pdf&quot;&gt;Sutskever et al., 2013&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66bd7f5eecabe99afa580fb13d864a7f7973624c" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;x&lt;/code&gt; with more dimensions, independently normalizes each 1-D slice along dimension &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">Para &lt;code&gt;x&lt;/code&gt; con m&amp;aacute;s dimensiones, normaliza de forma independiente cada sector 1-D a lo largo del &lt;code&gt;axis&lt;/code&gt; dimensi&amp;oacute;n .</target>
        </trans-unit>
        <trans-unit id="43544e8b815a7d32d165c045ffe8994b597cc573" translate="yes" xml:space="preserve">
          <source>For AMSGrad see &lt;a href=&quot;https://openreview.net/pdf?id=ryQu7f-RZ&quot;&gt;On The Convergence Of Adam And Beyond. Reddi et al., 5-8&lt;/a&gt;.</source>
          <target state="translated">Para AMSGrad, ver &lt;a href=&quot;https://openreview.net/pdf?id=ryQu7f-RZ&quot;&gt;Sobre la convergencia de Ad&amp;aacute;n y m&amp;aacute;s all&amp;aacute;. Reddi y col., 5-8&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="13ebc2a0e8c090e78de3fad9e601fded772c3334" translate="yes" xml:space="preserve">
          <source>For DNN model, &lt;code&gt;indicator_column&lt;/code&gt; can be used to wrap any &lt;code&gt;categorical_column_*&lt;/code&gt; (e.g., to feed to DNN). Consider to Use &lt;code&gt;embedding_column&lt;/code&gt; if the number of buckets/unique(values) are large.</source>
          <target state="translated">Para el modelo DNN, la &lt;code&gt;indicator_column&lt;/code&gt; se puede utilizar para envolver cualquier &lt;code&gt;categorical_column_*&lt;/code&gt; (por ejemplo, para alimentar a DNN). Considere usar &lt;code&gt;embedding_column&lt;/code&gt; si el n&amp;uacute;mero de dep&amp;oacute;sitos / (valores) &amp;uacute;nicos es grande.</target>
        </trans-unit>
        <trans-unit id="358d84aa8148063b462186c221ef88a0bda8ec99" translate="yes" xml:space="preserve">
          <source>For Example:</source>
          <target state="translated">Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="698c0c83d084957c23756fca89030c92b5e65b9c" translate="yes" xml:space="preserve">
          <source>For Gaussian and Laplacian kernels, this corresponds to a scaling factor of the corresponding kernel approximated by the layer (see concrete definitions above). When provided, it should be a positive float. If None, a default value is used: if the kernel initializer is set to &quot;gaussian&quot;, &lt;code&gt;scale&lt;/code&gt; defaults to &lt;code&gt;sqrt(input_dim / 2)&lt;/code&gt;, otherwise, it defaults to 1.0. Both the approximation error of the kernel and the classification quality are sensitive to this parameter. If &lt;code&gt;trainable&lt;/code&gt; is set to &lt;code&gt;True&lt;/code&gt;, this parameter is learned end-to-end during training and the provided value serves as the initial value. &lt;strong&gt;Note:&lt;/strong&gt; When features from this layer are fed to a linear model, by making &lt;code&gt;scale&lt;/code&gt; trainable, the resulting optimization problem is no longer convex (even if the loss function used by the linear model is convex).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12448879835e54272469ca384e2db601805a9b6d" translate="yes" xml:space="preserve">
          <source>For NVIDIA GPUs with Tensor cores, as a general performance guide, dimensions (such as batch size, input size, output size, and channel counts) should be powers of two if under 256, or otherwise divisible by 8 if above 256. For more information, check out the &lt;a href=&quot;https://docs.nvidia.com/deeplearning/sdk/dl-performance-guide/index.html&quot;&gt;NVIDIA Deep Learning Performance Guide&lt;/a&gt;.</source>
          <target state="translated">Para las GPU NVIDIA con n&amp;uacute;cleos Tensor, como gu&amp;iacute;a general de rendimiento, las dimensiones (como tama&amp;ntilde;o de lote, tama&amp;ntilde;o de entrada, tama&amp;ntilde;o de salida y recuento de canales) deben ser potencias de dos si son inferiores a 256, o divisibles por 8 si son superiores a 256. Para m&amp;aacute;s informaci&amp;oacute;n informaci&amp;oacute;n, consulte la &lt;a href=&quot;https://docs.nvidia.com/deeplearning/sdk/dl-performance-guide/index.html&quot;&gt;Gu&amp;iacute;a de rendimiento de aprendizaje profundo de NVIDIA&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e6c57b61b2025e89cc1b96b3f8c44dc568631574" translate="yes" xml:space="preserve">
          <source>For RaggedTensors with multiple ragged dimensions, the &lt;code&gt;row_splits&lt;/code&gt; for all nested &lt;code&gt;RaggedTensor&lt;/code&gt; objects are cast to the given dtype.</source>
          <target state="translated">Para RaggedTensors con m&amp;uacute;ltiples dimensiones irregulares, los &lt;code&gt;row_splits&lt;/code&gt; para todos los objetos &lt;code&gt;RaggedTensor&lt;/code&gt; anidados se lanzan al tipo d dado.</target>
        </trans-unit>
        <trans-unit id="680d2331fce0b7a83d542b4d1de0958158b6ff5b" translate="yes" xml:space="preserve">
          <source>For Tensor arguments, &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; instantiates a separate graph for every unique set of input shapes and datatypes. The example below creates two separate graphs, each specialized to a different shape:</source>
          <target state="translated">Para los argumentos de Tensor, &lt;a href=&quot;function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; crea&lt;/a&gt; una instancia de un gr&amp;aacute;fico separado para cada conjunto &amp;uacute;nico de formas de entrada y tipos de datos. El siguiente ejemplo crea dos gr&amp;aacute;ficos separados, cada uno especializado en una forma diferente:</target>
        </trans-unit>
        <trans-unit id="affb3fda9deede559b712893d926e23f939195d8" translate="yes" xml:space="preserve">
          <source>For Unicode, see the &lt;a href=&quot;working%20with%20unicode%20text&quot;&gt;https://www.tensorflow.org/tutorials/representation/unicode&lt;/a&gt; tutorial.</source>
          <target state="translated">Para Unicode, consulte el tutorial &lt;a href=&quot;working%20with%20unicode%20text&quot;&gt;https://www.tensorflow.org/tutorials/representation/unicode&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="438450c314656d91b7eb58ac47d34990ac07e0e9" translate="yes" xml:space="preserve">
          <source>For Wide (aka linear) model, &lt;code&gt;indicator_column&lt;/code&gt; is the internal representation for categorical column when passing categorical column directly (as any element in feature_columns) to &lt;code&gt;linear_model&lt;/code&gt;. See &lt;code&gt;linear_model&lt;/code&gt; for details.</source>
          <target state="translated">Para el modelo ancho (tambi&amp;eacute;n conocido como lineal), la &lt;code&gt;indicator_column&lt;/code&gt; es la representaci&amp;oacute;n interna de la columna categ&amp;oacute;rica cuando se pasa la columna categ&amp;oacute;rica directamente (como cualquier elemento en feature_columns) a &lt;code&gt;linear_model&lt;/code&gt; . Consulte &lt;code&gt;linear_model&lt;/code&gt; para m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="d1809fcc8df392d7ea85c0ac28ccfcbd2a81ee6c" translate="yes" xml:space="preserve">
          <source>For a 1-D tensor with &lt;code&gt;axis = 0&lt;/code&gt;, computes</source>
          <target state="translated">Para un tensor 1-D con &lt;code&gt;axis = 0&lt;/code&gt; , calcula</target>
        </trans-unit>
        <trans-unit id="eb040fc5b017a63cdc59b792f1488c8b7f490212" translate="yes" xml:space="preserve">
          <source>For a 1D tensor, &lt;code&gt;tf.gather(values, tf.argsort(values))&lt;/code&gt; is equivalent to &lt;a href=&quot;sort&quot;&gt;&lt;code&gt;tf.sort(values)&lt;/code&gt;&lt;/a&gt;. For higher dimensions, the output has the same shape as &lt;code&gt;values&lt;/code&gt;, but along the given axis, values represent the index of the sorted element in that slice of the tensor at the given position.</source>
          <target state="translated">Para un tensor 1D, &lt;code&gt;tf.gather(values, tf.argsort(values))&lt;/code&gt; es equivalente a &lt;a href=&quot;sort&quot;&gt; &lt;code&gt;tf.sort(values)&lt;/code&gt; &lt;/a&gt; . Para dimensiones m&amp;aacute;s altas, la salida tiene la misma forma que los &lt;code&gt;values&lt;/code&gt; , pero a lo largo del eje dado, los valores representan el &amp;iacute;ndice del elemento ordenado en esa porci&amp;oacute;n del tensor en la posici&amp;oacute;n dada.</target>
        </trans-unit>
        <trans-unit id="fb2c582ee71ccd0dae80f698e01ac135396f67ca" translate="yes" xml:space="preserve">
          <source>For a chief, this utility sets proper session initializer/restorer. It also creates hooks related to checkpoint and summary saving. For workers, this utility sets proper session creator which waits for the chief to initialize/restore. Please check &lt;a href=&quot;monitoredsession&quot;&gt;&lt;code&gt;tf.compat.v1.train.MonitoredSession&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">Para un jefe, esta utilidad establece el inicializador / restaurador de sesi&amp;oacute;n adecuado. Tambi&amp;eacute;n crea ganchos relacionados con el punto de control y el guardado de resumen. Para los trabajadores, esta utilidad establece el creador de sesi&amp;oacute;n adecuado que espera a que el jefe se inicialice / restaure. Consulte &lt;a href=&quot;monitoredsession&quot;&gt; &lt;code&gt;tf.compat.v1.train.MonitoredSession&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1e685a37c8c58056e8f3530b78115d9f73810c25" translate="yes" xml:space="preserve">
          <source>For a complete example showing the speed-up on training an image classification task on CIFAR10, check out this Colab notebook.</source>
          <target state="translated">Para un ejemplo completo que muestra la aceleración en el entrenamiento de una tarea de clasificación de imágenes en CIFAR10,mira este cuaderno de Colab.</target>
        </trans-unit>
        <trans-unit id="b151bbc686479044821007cc7d7dd7e642e9457f" translate="yes" xml:space="preserve">
          <source>For a counter-base RNG algorithm such as Philox and ThreeFry (as described in paper 'Parallel Random Numbers: As Easy as 1, 2, 3' [&lt;a href=&quot;https://www.thesalmons.org/john/random123/papers/random123sc11.pdf&quot;&gt;https://www.thesalmons.org/john/random123/papers/random123sc11.pdf&lt;/a&gt;]), the RNG state consists of two parts: counter and key. The output is generated via the formula: output=hash(key, counter), i.e. a hashing of the counter parametrized by the key. Two RNGs with two different keys can be thought as generating two independent random-number streams (a stream is formed by increasing the counter).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0f028ef007ecbff710e7dba8c5a5dabc991f9c1" translate="yes" xml:space="preserve">
          <source>For a counter-base RNG algorithm such as Philox and ThreeFry (as described in paper 'Parallel Random Numbers: As Easy as 1, 2, 3' [https://www.thesalmons.org/john/random123/papers/random123sc11.pdf]), the RNG state consists of two parts: counter and key. The output is generated via the formula: output=hash(key, counter), i.e. a hashing of the counter parametrized by the key. Two RNGs with two different keys can be thought as generating two independent random-number streams (a stream is formed by increasing the counter).</source>
          <target state="translated">Para un algoritmo RNG de base contraria como Philox y ThreeFry (como se describe en el artículo &quot;Parallel Random Numbers:Tan fácil como 1,2,3' [https://www.thesalmons.org/john/random123/papers/random123sc11.pdf]),el estado RNG consiste en dos partes:contador y clave.La salida se genera a través de la fórmula:output=hash(tecla,contador),es decir,un hash del contador parametrizado por la tecla.Se puede pensar que dos RNG con dos claves diferentes generan dos corrientes de números aleatorios independientes (una corriente se forma al aumentar el contador).</target>
        </trans-unit>
        <trans-unit id="9a5ce116616d9115cf39dfc32b5ace717bbeef6e" translate="yes" xml:space="preserve">
          <source>For a description of atrous convolution and how it can be used for dense feature extraction, please see: (Chen et al., 2015). The same operation is investigated further in (Yu et al., 2016). Previous works that effectively use atrous convolution in different ways are, among others, (Sermanet et al., 2014) and (Giusti et al., 2013). Atrous convolution is also closely related to the so-called noble identities in multi-rate signal processing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9459e940f5730676b9001d651d28cb51b42d969c" translate="yes" xml:space="preserve">
          <source>For a description of atrous convolution and how it can be used for dense feature extraction, please see: &lt;a href=&quot;http://arxiv.org/abs/1412.7062&quot;&gt;Semantic Image Segmentation with Deep Convolutional Nets and Fully Connected CRFs&lt;/a&gt;. The same operation is investigated further in &lt;a href=&quot;http://arxiv.org/abs/1511.07122&quot;&gt;Multi-Scale Context Aggregation by Dilated Convolutions&lt;/a&gt;. Previous works that effectively use atrous convolution in different ways are, among others, &lt;a href=&quot;http://arxiv.org/abs/1312.6229&quot;&gt;OverFeat: Integrated Recognition, Localization and Detection using Convolutional Networks&lt;/a&gt; and &lt;a href=&quot;http://arxiv.org/abs/1302.1700&quot;&gt;Fast Image Scanning with Deep Max-Pooling Convolutional Neural Networks&lt;/a&gt;. Atrous convolution is also closely related to the so-called noble identities in multi-rate signal processing.</source>
          <target state="translated">Para obtener una descripci&amp;oacute;n de la convoluci&amp;oacute;n atroz y c&amp;oacute;mo se puede utilizar para la extracci&amp;oacute;n de caracter&amp;iacute;sticas densas, consulte: &lt;a href=&quot;http://arxiv.org/abs/1412.7062&quot;&gt;Segmentaci&amp;oacute;n de im&amp;aacute;genes sem&amp;aacute;nticas con redes convolucionales profundas y CRF totalmente conectados&lt;/a&gt; . La misma operaci&amp;oacute;n se investiga m&amp;aacute;s en la &lt;a href=&quot;http://arxiv.org/abs/1511.07122&quot;&gt;agregaci&amp;oacute;n de contexto de m&amp;uacute;ltiples escalas por convoluciones dilatadas&lt;/a&gt; . Trabajos anteriores que utilizan eficazmente la convoluci&amp;oacute;n atroz de diferentes maneras son, entre otros, &lt;a href=&quot;http://arxiv.org/abs/1312.6229&quot;&gt;OverFeat: reconocimiento, localizaci&amp;oacute;n y detecci&amp;oacute;n integrados usando redes convolucionales&lt;/a&gt; y &lt;a href=&quot;http://arxiv.org/abs/1302.1700&quot;&gt;escaneo r&amp;aacute;pido de im&amp;aacute;genes con redes neuronales convolucionales profundas de agrupaci&amp;oacute;n m&amp;aacute;xima&lt;/a&gt; . La convoluci&amp;oacute;n atroz tambi&amp;eacute;n est&amp;aacute; estrechamente relacionada con las denominadas identidades nobles en el procesamiento de se&amp;ntilde;ales de m&amp;uacute;ltiples velocidades.</target>
        </trans-unit>
        <trans-unit id="9395aea9a50261f21aee7ad93d28f55ca17890b1" translate="yes" xml:space="preserve">
          <source>For a detailed guide, see &lt;a href=&quot;https://tensorflow.org/guide/saved_model#savedmodels_from_estimators&quot;&gt;SavedModel from Estimators&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faf1eab5a6b813e3139fd4358594343e9ec1b061" translate="yes" xml:space="preserve">
          <source>For a detailed guide, see &lt;a href=&quot;https://tensorflow.org/guide/saved_model#using_savedmodel_with_estimators&quot;&gt;Using SavedModel with Estimators&lt;/a&gt;.</source>
          <target state="translated">Para obtener una gu&amp;iacute;a detallada, consulte &lt;a href=&quot;https://tensorflow.org/guide/saved_model#using_savedmodel_with_estimators&quot;&gt;Uso del modelo guardado con estimadores&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="57997fbb3307d6157f9ed4d1c8e94e6ae2cc97cf" translate="yes" xml:space="preserve">
          <source>For a given score-label-distribution the required precision might not be achievable, in this case 0.0 is returned as recall.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82871db36d8768d1a3be8c39394657eb4327cd7d" translate="yes" xml:space="preserve">
          <source>For a nested python tuple:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="220ccd8b164a992646be9626d306ae4431c07d07" translate="yes" xml:space="preserve">
          <source>For a profile data structure, profiler first finds the profiler nodes matching 'start_name_regexes', and starts displaying profiler nodes from there. Then, if a node matches 'show_name_regexes' and doesn't match 'hide_name_regexes', it's displayed. If a node matches 'trim_name_regexes', profiler stops further searching that branch.</source>
          <target state="translated">Para una estructura de datos de perfil,el perfilador primero encuentra los nodos del perfil que coinciden con 'start_name_regexes',y comienza a mostrar los nodos del perfilador desde allí.Luego,si un nodo coincide con 'show_name_regexes' y no coincide con 'hide_name_regexes',se muestra.Si un nodo coincide con 'trim_name_regexes',el perfilador deja de buscar más en esa rama.</target>
        </trans-unit>
        <trans-unit id="9939180266b3d93448c8fea23d0f6dfa98cc31b6" translate="yes" xml:space="preserve">
          <source>For a tutorial, see the &lt;a href=&quot;https://www.tensorflow.org/guide/function&quot;&gt;tf.function and AutoGraph guide&lt;/a&gt;. For more detailed information, see the &lt;a href=&quot;https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/autograph/g3doc/reference/index.md&quot;&gt;AutoGraph reference documentation&lt;/a&gt;.</source>
          <target state="translated">Para obtener un tutorial, consulte la &lt;a href=&quot;https://www.tensorflow.org/guide/function&quot;&gt;gu&amp;iacute;a tf.function y AutoGraph&lt;/a&gt; . Para obtener informaci&amp;oacute;n m&amp;aacute;s detallada, consulte la &lt;a href=&quot;https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/autograph/g3doc/reference/index.md&quot;&gt;documentaci&amp;oacute;n de referencia de AutoGraph&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3961b8c97504a885300108217230a73b23f20c07" translate="yes" xml:space="preserve">
          <source>For additional ClusterResolver properties such as task type, task index, rpc layer, environment, etc..., we will return the value from the first ClusterResolver in the union.</source>
          <target state="translated">Para propiedades adicionales de ClusterResolver como tipo de tarea,índice de tarea,capa rpc,entorno,etc...,devolveremos el valor del primer ClusterResolver de la unión.</target>
        </trans-unit>
        <trans-unit id="4710c7702380e37df383d4f1e0b6d32988898a50" translate="yes" xml:space="preserve">
          <source>For additional information about specificity and sensitivity, see &lt;a href=&quot;https://en.wikipedia.org/wiki/Sensitivity_and_specificity&quot;&gt;the following&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28b4f32d54970e27ef51cc570317aa7cc036c269" translate="yes" xml:space="preserve">
          <source>For additional information about specificity and sensitivity, see the following: &lt;a href=&quot;https://en.wikipedia.org/wiki/Sensitivity_and_specificity&quot;&gt;https://en.wikipedia.org/wiki/Sensitivity_and_specificity&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ba9a27fb906c20b62b7961623bd63a85b7a2467" translate="yes" xml:space="preserve">
          <source>For additional information about specificity and sensitivity, see the following: https://en.wikipedia.org/wiki/Sensitivity_and_specificity</source>
          <target state="translated">Para obtener información adicional sobre la especificidad y la sensibilidad,véase lo siguiente:https://en.wikipedia.org/wiki/Sensitivity_and_specificity</target>
        </trans-unit>
        <trans-unit id="63527db3074c5cfec63b6889a3a6425bedc1846b" translate="yes" xml:space="preserve">
          <source>For advanced models, please use the full &lt;a href=&quot;lstmcell&quot;&gt;&lt;code&gt;tf.compat.v1.nn.rnn_cell.LSTMCell&lt;/code&gt;&lt;/a&gt; that follows.</source>
          <target state="translated">Para modelos avanzados, utilice el &lt;a href=&quot;lstmcell&quot;&gt; &lt;code&gt;tf.compat.v1.nn.rnn_cell.LSTMCell&lt;/code&gt; &lt;/a&gt; completo que se muestra a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="343d6ea49aad072975b79ade2c38a0aa2de8f433" translate="yes" xml:space="preserve">
          <source>For an &lt;code&gt;2-D&lt;/code&gt; tensor &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;axis = 0&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="716108a64b24f9071a5ec3137f73a30034ffd3e1" translate="yes" xml:space="preserve">
          <source>For an &lt;code&gt;2-D&lt;/code&gt; tensor &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;axis = 1&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eadb22d5f122e214c4d8d886fe174ffa6b50bd2b" translate="yes" xml:space="preserve">
          <source>For an explanation see &quot;Differentiation of the Cholesky algorithm&quot; by Iain Murray &lt;a href=&quot;http://arxiv.org/abs/1602.07527&quot;&gt;http://arxiv.org/abs/1602.07527&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb090946cbd078325cc5454075dae1f83d327ccf" translate="yes" xml:space="preserve">
          <source>For an explanation see &quot;Differentiation of the Cholesky algorithm&quot; by Iain Murray &lt;a href=&quot;https://arxiv.org/abs/1602.07527&quot;&gt;http://arxiv.org/abs/1602.07527&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58bdfb47c0eae123b4f1b48443620758180eb094" translate="yes" xml:space="preserve">
          <source>For an input tensor with larger depth, here of shape &lt;code&gt;[1, 1, 1, 12]&lt;/code&gt;, e.g.</source>
          <target state="translated">Para un tensor de entrada con mayor profundidad, aqu&amp;iacute; de forma &lt;code&gt;[1, 1, 1, 12]&lt;/code&gt; , p. Ej.</target>
        </trans-unit>
        <trans-unit id="73c52c9278ce524597d2c5b7b688185a99fdfc11" translate="yes" xml:space="preserve">
          <source>For an input tensor with larger depth, here of shape &lt;code&gt;[1, 2, 2, 3]&lt;/code&gt;, e.g.</source>
          <target state="translated">Para un tensor de entrada con mayor profundidad, aqu&amp;iacute; de forma &lt;code&gt;[1, 2, 2, 3]&lt;/code&gt; , p. Ej.</target>
        </trans-unit>
        <trans-unit id="1f05e924ab8a0eee6cd58d652fef01bc7ebd2bac" translate="yes" xml:space="preserve">
          <source>For backward compatibility with the V1 format, this Op currently allows restoring from a V1 checkpoint as well:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="870b413d457e7d3b6fb91573e35aa40eaf69e580" translate="yes" xml:space="preserve">
          <source>For backwards compatibility only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bbf0e36ec059b3f4c0f63308a870c314c931ac4" translate="yes" xml:space="preserve">
          <source>For best results, &lt;code&gt;predictions&lt;/code&gt; should be distributed approximately uniformly in the range [0, 1] and not peaked around 0 or 1. The quality of the AUC approximation may be poor if this is not the case. Setting &lt;code&gt;summation_method&lt;/code&gt; to 'minoring' or 'majoring' can help quantify the error in the approximation by providing lower or upper bound estimate of the AUC.</source>
          <target state="translated">Para obtener los mejores resultados, las &lt;code&gt;predictions&lt;/code&gt; deben distribuirse aproximadamente de manera uniforme en el rango [0, 1] y no alcanzar un pico alrededor de 0 o 1. La calidad de la aproximaci&amp;oacute;n del AUC puede ser mala si este no es el caso. Establecer &lt;code&gt;summation_method&lt;/code&gt; en 'minoring' o 'majoring' puede ayudar a cuantificar el error en la aproximaci&amp;oacute;n al proporcionar una estimaci&amp;oacute;n del l&amp;iacute;mite superior o inferior del AUC.</target>
        </trans-unit>
        <trans-unit id="f78743990c17f9299a8953827006e26051a5a3fd" translate="yes" xml:space="preserve">
          <source>For best results, &lt;code&gt;predictions&lt;/code&gt; should be distributed approximately uniformly in the range [0, 1] and not peaked around 0 or 1. The quality of the AUC approximation may be poor if this is not the case. Setting &lt;code&gt;summation_method&lt;/code&gt; to 'minoring' or 'majoring' can help quantify the error in the approximation by providing lower or upper bound estimate of the AUC. The &lt;code&gt;thresholds&lt;/code&gt; parameter can be used to manually specify thresholds which split the predictions more evenly.</source>
          <target state="translated">Para obtener los mejores resultados, las &lt;code&gt;predictions&lt;/code&gt; deben distribuirse aproximadamente de manera uniforme en el rango [0, 1] y no alcanzar un pico alrededor de 0 o 1. La calidad de la aproximaci&amp;oacute;n del AUC puede ser mala si este no es el caso. Establecer &lt;code&gt;summation_method&lt;/code&gt; en 'minoring' o 'majoring' puede ayudar a cuantificar el error en la aproximaci&amp;oacute;n al proporcionar una estimaci&amp;oacute;n del l&amp;iacute;mite superior o inferior del AUC. El par&amp;aacute;metro de &lt;code&gt;thresholds&lt;/code&gt; se puede utilizar para especificar manualmente los umbrales que dividen las predicciones de manera m&amp;aacute;s uniforme.</target>
        </trans-unit>
        <trans-unit id="daff1b722d0fb127a20bad0fd4ebd0412bf72bd5" translate="yes" xml:space="preserve">
          <source>For brevity, let &lt;code&gt;c = log(x) = log_input&lt;/code&gt;, &lt;code&gt;z = targets&lt;/code&gt;. The log Poisson loss is</source>
          <target state="translated">Por brevedad, sea &lt;code&gt;c = log(x) = log_input&lt;/code&gt; , &lt;code&gt;z = targets&lt;/code&gt; . La p&amp;eacute;rdida de registro de Poisson es</target>
        </trans-unit>
        <trans-unit id="d6219a532f9c408cd0729ad6b959c0bbe42f179a" translate="yes" xml:space="preserve">
          <source>For brevity, let &lt;code&gt;x = logits&lt;/code&gt;, &lt;code&gt;z = labels&lt;/code&gt;, &lt;code&gt;q = pos_weight&lt;/code&gt;. The loss is:</source>
          <target state="translated">Por brevedad, sea &lt;code&gt;x = logits&lt;/code&gt; , &lt;code&gt;z = labels&lt;/code&gt; , &lt;code&gt;q = pos_weight&lt;/code&gt; . La perdida es:</target>
        </trans-unit>
        <trans-unit id="ff9d01f67c929c82f2ffed8b81b820d23e32b1da" translate="yes" xml:space="preserve">
          <source>For brevity, let &lt;code&gt;x = logits&lt;/code&gt;, &lt;code&gt;z = labels&lt;/code&gt;. The logistic loss is</source>
          <target state="translated">Por brevedad, sea &lt;code&gt;x = logits&lt;/code&gt; , &lt;code&gt;z = labels&lt;/code&gt; . La p&amp;eacute;rdida log&amp;iacute;stica es</target>
        </trans-unit>
        <trans-unit id="1301e2ab85c859b04f71a10ca5d0a61ed66dc9bc" translate="yes" xml:space="preserve">
          <source>For classification: binary label.</source>
          <target state="translated">Para la clasificación:etiqueta binaria.</target>
        </trans-unit>
        <trans-unit id="e22a3f22d875842280028907e515e5b1ceef3a59" translate="yes" xml:space="preserve">
          <source>For complex numbers, &lt;code&gt;y = sign(x) = x / |x|&lt;/code&gt; if &lt;code&gt;x != 0&lt;/code&gt;, otherwise &lt;code&gt;y = 0&lt;/code&gt;.</source>
          <target state="translated">Para n&amp;uacute;meros complejos, &lt;code&gt;y = sign(x) = x / |x|&lt;/code&gt; si &lt;code&gt;x != 0&lt;/code&gt; , en caso contrario &lt;code&gt;y = 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b4484477dc0ad27cefcf137a2c8cf12a0ec4bd1" translate="yes" xml:space="preserve">
          <source>For complex numbers, the exponential value is calculated as \(e^{x+iy}={e^x}{e^{iy} }={e^x}{\\cos(y)+i\\sin(y)}\)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb5d4419a8e723474e43b51cd45a962afee640c2" translate="yes" xml:space="preserve">
          <source>For complex numbers, the exponential value is calculated as follows:</source>
          <target state="translated">Para los números complejos,el valor exponencial se calcula de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="ab8f171225b6810fb2121ef3a2ccfb37c7669be7" translate="yes" xml:space="preserve">
          <source>For complex numbers, y = sign(x) = x / |x| if x != 0, otherwise y = 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49462dde41ed51282a18f24b9ae73b7df90a2ba4" translate="yes" xml:space="preserve">
          <source>For convenience, The requested number of partitions does not have to divide the corresponding dimension evenly. If it does not, the shapes of the partitions are incremented by 1 starting from partition 0 until all slack is absorbed. The adjustment rules may change in the future, but as you can save/restore these variables with different slicing specifications this should not be a problem.</source>
          <target state="translated">Para mayor comodidad,el número de particiones solicitado no tiene que dividir la dimensión correspondiente de manera uniforme.Si no lo hace,las formas de las particiones se incrementan en 1 empezando por la partición 0 hasta que se absorba toda la holgura.Las reglas de ajuste pueden cambiar en el futuro,pero como se pueden guardar/restaurar estas variables con diferentes especificaciones de corte,esto no debería ser un problema.</target>
        </trans-unit>
        <trans-unit id="1350aabb6a166b4a9adc5331f9bfc6c8e1f4e703" translate="yes" xml:space="preserve">
          <source>For convenience, this function sets a default value for the &lt;code&gt;step&lt;/code&gt; parameter used in summary-writing functions elsewhere in the API so that it need not be explicitly passed in every such invocation. The value can be a constant or a variable, and can be retrieved via &lt;a href=&quot;get_step&quot;&gt;&lt;code&gt;tf.summary.experimental.get_step()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Por conveniencia, esta funci&amp;oacute;n establece un valor predeterminado para el par&amp;aacute;metro de &lt;code&gt;step&lt;/code&gt; utilizado en funciones de escritura de resumen en otras partes de la API, de modo que no es necesario pasarlo expl&amp;iacute;citamente en cada invocaci&amp;oacute;n de este tipo. El valor puede ser una constante o una variable, y se puede recuperar mediante &lt;a href=&quot;get_step&quot;&gt; &lt;code&gt;tf.summary.experimental.get_step()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4334d314960569ae2e72fe3de9077256f0d3ba99" translate="yes" xml:space="preserve">
          <source>For correctness, &lt;a href=&quot;../../while_loop&quot;&gt;&lt;code&gt;tf.while_loop()&lt;/code&gt;&lt;/a&gt; strictly enforces shape invariants for the loop variables. A shape invariant is a (possibly partial) shape that is unchanged across the iterations of the loop. An error will be raised if the shape of a loop variable after an iteration is determined to be more general than or incompatible with its shape invariant. For example, a shape of [11, None] is more general than a shape of [11, 17], and [11, 21] is not compatible with [11, 17]. By default (if the argument &lt;code&gt;shape_invariants&lt;/code&gt; is not specified), it is assumed that the initial shape of each tensor in &lt;code&gt;loop_vars&lt;/code&gt; is the same in every iteration. The &lt;code&gt;shape_invariants&lt;/code&gt; argument allows the caller to specify a less specific shape invariant for each loop variable, which is needed if the shape varies between iterations. The &lt;a href=&quot;../../tensor#set_shape&quot;&gt;&lt;code&gt;tf.Tensor.set_shape&lt;/code&gt;&lt;/a&gt; function may also be used in the &lt;code&gt;body&lt;/code&gt; function to indicate that the output loop variable has a particular shape. The shape invariant for SparseTensor and IndexedSlices are treated specially as follows:</source>
          <target state="translated">Para que sea correcto, &lt;a href=&quot;../../while_loop&quot;&gt; &lt;code&gt;tf.while_loop()&lt;/code&gt; &lt;/a&gt; . while_loop () aplica estrictamente invariantes de forma para las variables de ciclo. Una forma invariante es una forma (posiblemente parcial) que no cambia en las iteraciones del bucle. Se producir&amp;aacute; un error si se determina que la forma de una variable de ciclo despu&amp;eacute;s de una iteraci&amp;oacute;n es m&amp;aacute;s general o incompatible con su forma invariante. Por ejemplo, una forma de [11, None] es m&amp;aacute;s general que una forma de [11, 17] y [11, 21] no es compatible con [11, 17]. Por defecto (si no se especifica el argumento &lt;code&gt;shape_invariants&lt;/code&gt; ), se asume que la forma inicial de cada tensor en &lt;code&gt;loop_vars&lt;/code&gt; es la misma en cada iteraci&amp;oacute;n. Los &lt;code&gt;shape_invariants&lt;/code&gt; El argumento permite al llamador especificar una forma menos espec&amp;iacute;fica invariante para cada variable de ciclo, que es necesaria si la forma var&amp;iacute;a entre iteraciones. La funci&amp;oacute;n &lt;a href=&quot;../../tensor#set_shape&quot;&gt; &lt;code&gt;tf.Tensor.set_shape&lt;/code&gt; &lt;/a&gt; tambi&amp;eacute;n se puede usar en la funci&amp;oacute;n &lt;code&gt;body&lt;/code&gt; para indicar que la variable de ciclo de salida tiene una forma particular. La forma invariante para SparseTensor e IndexedSlices se trata especialmente de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="2d86798b077ac794a34c4729b8903d92155fb358" translate="yes" xml:space="preserve">
          <source>For correctness, &lt;a href=&quot;while_loop&quot;&gt;&lt;code&gt;tf.while_loop()&lt;/code&gt;&lt;/a&gt; strictly enforces shape invariants for the loop variables. A shape invariant is a (possibly partial) shape that is unchanged across the iterations of the loop. An error will be raised if the shape of a loop variable after an iteration is determined to be more general than or incompatible with its shape invariant. For example, a shape of [11, None] is more general than a shape of [11, 17], and [11, 21] is not compatible with [11, 17]. By default (if the argument &lt;code&gt;shape_invariants&lt;/code&gt; is not specified), it is assumed that the initial shape of each tensor in &lt;code&gt;loop_vars&lt;/code&gt; is the same in every iteration. The &lt;code&gt;shape_invariants&lt;/code&gt; argument allows the caller to specify a less specific shape invariant for each loop variable, which is needed if the shape varies between iterations. The &lt;a href=&quot;tensor#set_shape&quot;&gt;&lt;code&gt;tf.Tensor.set_shape&lt;/code&gt;&lt;/a&gt; function may also be used in the &lt;code&gt;body&lt;/code&gt; function to indicate that the output loop variable has a particular shape. The shape invariant for SparseTensor and IndexedSlices are treated specially as follows:</source>
          <target state="translated">Para que sea correcto, &lt;a href=&quot;while_loop&quot;&gt; &lt;code&gt;tf.while_loop()&lt;/code&gt; &lt;/a&gt; . while_loop () aplica estrictamente invariantes de forma para las variables de ciclo. Una forma invariante es una forma (posiblemente parcial) que no cambia en las iteraciones del bucle. Se producir&amp;aacute; un error si se determina que la forma de una variable de ciclo despu&amp;eacute;s de una iteraci&amp;oacute;n es m&amp;aacute;s general o incompatible con su forma invariante. Por ejemplo, una forma de [11, None] es m&amp;aacute;s general que una forma de [11, 17] y [11, 21] no es compatible con [11, 17]. Por defecto (si no se especifica el argumento &lt;code&gt;shape_invariants&lt;/code&gt; ), se asume que la forma inicial de cada tensor en &lt;code&gt;loop_vars&lt;/code&gt; es la misma en cada iteraci&amp;oacute;n. Los &lt;code&gt;shape_invariants&lt;/code&gt; El argumento permite al llamador especificar una forma menos espec&amp;iacute;fica invariante para cada variable de ciclo, que es necesaria si la forma var&amp;iacute;a entre iteraciones. La funci&amp;oacute;n &lt;a href=&quot;tensor#set_shape&quot;&gt; &lt;code&gt;tf.Tensor.set_shape&lt;/code&gt; &lt;/a&gt; tambi&amp;eacute;n se puede usar en la funci&amp;oacute;n &lt;code&gt;body&lt;/code&gt; para indicar que la variable de ciclo de salida tiene una forma particular. La forma invariante para SparseTensor e IndexedSlices se trata especialmente de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="cbc00d3ab4b824f23aa4250f9ca61bea7ee84f1a" translate="yes" xml:space="preserve">
          <source>For dense results in two serialized &lt;code&gt;Example&lt;/code&gt;s:</source>
          <target state="translated">Para obtener resultados densos en dos &lt;code&gt;Example&lt;/code&gt; serializados :</target>
        </trans-unit>
        <trans-unit id="260832edfc6e827a99bc3598303ea1cef15de510" translate="yes" xml:space="preserve">
          <source>For dense tensors, the returned &lt;code&gt;Tensor&lt;/code&gt; is identical to the output of &lt;code&gt;parse_example&lt;/code&gt;, except there is no batch dimension, the output shape is the same as the shape given in &lt;code&gt;dense_shape&lt;/code&gt;.</source>
          <target state="translated">Para tensores densos, el &lt;code&gt;Tensor&lt;/code&gt; devuelto es id&amp;eacute;ntico a la salida de &lt;code&gt;parse_example&lt;/code&gt; , excepto que no hay una dimensi&amp;oacute;n de lote, la forma de salida es la misma que la forma dada en &lt;code&gt;dense_shape&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4cd4bd6d5ebf6a3540e2292e02f738b12afb9ed8" translate="yes" xml:space="preserve">
          <source>For detailed usage examples of TensorFlow Distributions shapes, see &lt;a href=&quot;https://github.com/tensorflow/probability/blob/master/tensorflow_probability/examples/jupyter_notebooks/Understanding_TensorFlow_Distributions_Shapes.ipynb&quot;&gt;this tutorial&lt;/a&gt;</source>
          <target state="translated">Para obtener ejemplos de uso detallados de las formas de distribuciones de TensorFlow, consulte &lt;a href=&quot;https://github.com/tensorflow/probability/blob/master/tensorflow_probability/examples/jupyter_notebooks/Understanding_TensorFlow_Distributions_Shapes.ipynb&quot;&gt;este tutorial&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="868bc9411021e63ffd85c6f1e5eb98ca3d3b255f" translate="yes" xml:space="preserve">
          <source>For details on how the graph-level seed interacts with op seeds, see &lt;a href=&quot;set_random_seed&quot;&gt;&lt;code&gt;tf.compat.v1.random.set_random_seed&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para obtener detalles sobre c&amp;oacute;mo la semilla a nivel de gr&amp;aacute;fico interact&amp;uacute;a con las semillas op, consulte &lt;a href=&quot;set_random_seed&quot;&gt; &lt;code&gt;tf.compat.v1.random.set_random_seed&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d5b62bcdafb111a4f348589cf96332ab6f0a487b" translate="yes" xml:space="preserve">
          <source>For details on the meaning of each version, see &lt;a href=&quot;https://www.tensorflow.org/code/tensorflow/core/framework/graph.proto&quot;&gt;&lt;code&gt;GraphDef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para obtener detalles sobre el significado de cada versi&amp;oacute;n, consulte &lt;a href=&quot;https://www.tensorflow.org/code/tensorflow/core/framework/graph.proto&quot;&gt; &lt;code&gt;GraphDef&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c866dd9eacd53156ef05bb3168960ebd7b5e18a3" translate="yes" xml:space="preserve">
          <source>For details, see &lt;a href=&quot;http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks&quot;&gt;Krizhevsky et al., ImageNet classification with deep convolutional neural networks (NIPS 2012)&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n, consulte &lt;a href=&quot;http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks&quot;&gt;Krizhevsky et al., Clasificaci&amp;oacute;n de ImageNet con redes neuronales convolucionales profundas (NIPS 2012)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="11f72ea95f4d5434f57a9675d8fca114eb68909d" translate="yes" xml:space="preserve">
          <source>For each 3-D image &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;image&lt;/code&gt;, computes &lt;code&gt;(x - mean) / adjusted_stddev&lt;/code&gt;, where</source>
          <target state="translated">Para cada imagen 3-D &lt;code&gt;x&lt;/code&gt; en la &lt;code&gt;image&lt;/code&gt; n , calcula &lt;code&gt;(x - mean) / adjusted_stddev&lt;/code&gt; , donde</target>
        </trans-unit>
        <trans-unit id="3227496e32cef4b95ac21bbcfb379b6c8563c22f" translate="yes" xml:space="preserve">
          <source>For each batch &lt;code&gt;i&lt;/code&gt; and class &lt;code&gt;j&lt;/code&gt; we have</source>
          <target state="translated">Para cada lote &lt;code&gt;i&lt;/code&gt; y clase &lt;code&gt;j&lt;/code&gt; tenemos</target>
        </trans-unit>
        <trans-unit id="38ee7d6b0b564eb41b147c9865f0b162072dea3f" translate="yes" xml:space="preserve">
          <source>For each batch of counts, &lt;code&gt;value = [n_0, ... ,n_{k-1}]&lt;/code&gt;, &lt;code&gt;P[value]&lt;/code&gt; is the probability that after sampling &lt;code&gt;self.total_count&lt;/code&gt; draws from this Multinomial distribution, the number of draws falling in class &lt;code&gt;j&lt;/code&gt; is &lt;code&gt;n_j&lt;/code&gt;. Since this definition is &lt;a href=&quot;https://en.wikipedia.org/wiki/Exchangeable_random_variables&quot;&gt;exchangeable&lt;/a&gt;; different sequences have the same counts so the probability includes a combinatorial coefficient.</source>
          <target state="translated">Para cada lote de recuentos, &lt;code&gt;value = [n_0, ... ,n_{k-1}]&lt;/code&gt; , &lt;code&gt;P[value]&lt;/code&gt; es la probabilidad de que despu&amp;eacute;s de muestrear &lt;code&gt;self.total_count&lt;/code&gt; extrae de esta distribuci&amp;oacute;n multinomial, el n&amp;uacute;mero de extractos que caen en la clase &lt;code&gt;j&lt;/code&gt; es &lt;code&gt;n_j&lt;/code&gt; . Dado que esta definici&amp;oacute;n es &lt;a href=&quot;https://en.wikipedia.org/wiki/Exchangeable_random_variables&quot;&gt;intercambiable&lt;/a&gt; ; diferentes secuencias tienen los mismos recuentos, por lo que la probabilidad incluye un coeficiente combinatorio.</target>
        </trans-unit>
        <trans-unit id="62e6f600d1795850660493678c7d313f17bb03f6" translate="yes" xml:space="preserve">
          <source>For each batch of counts, &lt;code&gt;value = [n_0, ..., n_{K-1}]&lt;/code&gt;, &lt;code&gt;P[value]&lt;/code&gt; is the probability that after sampling &lt;code&gt;self.total_count&lt;/code&gt; draws from this Dirichlet-Multinomial distribution, the number of draws falling in class &lt;code&gt;j&lt;/code&gt; is &lt;code&gt;n_j&lt;/code&gt;. Since this definition is &lt;a href=&quot;https://en.wikipedia.org/wiki/Exchangeable_random_variables&quot;&gt;exchangeable&lt;/a&gt;; different sequences have the same counts so the probability includes a combinatorial coefficient.</source>
          <target state="translated">Para cada lote de conteos, &lt;code&gt;value = [n_0, ..., n_{K-1}]&lt;/code&gt; , &lt;code&gt;P[value]&lt;/code&gt; es la probabilidad de que despu&amp;eacute;s de muestrear &lt;code&gt;self.total_count&lt;/code&gt; extrae de esta distribuci&amp;oacute;n de Dirichlet-Multinomial, el n&amp;uacute;mero de extractos que cae en la clase &lt;code&gt;j&lt;/code&gt; es &lt;code&gt;n_j&lt;/code&gt; . Dado que esta definici&amp;oacute;n es &lt;a href=&quot;https://en.wikipedia.org/wiki/Exchangeable_random_variables&quot;&gt;intercambiable&lt;/a&gt; ; diferentes secuencias tienen los mismos recuentos, por lo que la probabilidad incluye un coeficiente combinatorio.</target>
        </trans-unit>
        <trans-unit id="bb818b9007e09539540e92f84325c27b3ee59e8b" translate="yes" xml:space="preserve">
          <source>For each batch, this op picks a single set of sampled candidate labels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd53ff76cccc96ec695fa6a623c56b5fe4ad9802" translate="yes" xml:space="preserve">
          <source>For each channel, the Op first computes the mean of the image pixels in the channel and then adjusts each component of each pixel to &lt;code&gt;(x - mean) * contrast_factor + mean&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b564f7dfac5634b944029ff0a934eb0322773539" translate="yes" xml:space="preserve">
          <source>For each channel, this Op computes the mean of the image pixels in the channel and then adjusts each component &lt;code&gt;x&lt;/code&gt; of each pixel to &lt;code&gt;(x - mean) * contrast_factor + mean&lt;/code&gt;.</source>
          <target state="translated">Para cada canal, esta Op calcula la media de los p&amp;iacute;xeles de la imagen en el canal y luego ajusta cada componente &lt;code&gt;x&lt;/code&gt; de cada p&amp;iacute;xel a &lt;code&gt;(x - mean) * contrast_factor + mean&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff2fe1b034bb2ad174dd976537594c894cf480ba" translate="yes" xml:space="preserve">
          <source>For each channel, this layer computes the mean of the image pixels in the channel and then adjusts each component &lt;code&gt;x&lt;/code&gt; of each pixel to &lt;code&gt;(x - mean) * contrast_factor + mean&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e51add3cb58cbf81d2d2183dae647c67c4f8839c" translate="yes" xml:space="preserve">
          <source>For each element of &lt;code&gt;x&lt;/code&gt;, with probability &lt;code&gt;rate&lt;/code&gt;, outputs &lt;code&gt;0&lt;/code&gt;, and otherwise scales up the input by &lt;code&gt;1 / (1-rate)&lt;/code&gt;. The scaling is such that the expected sum is unchanged.</source>
          <target state="translated">Para cada elemento de &lt;code&gt;x&lt;/code&gt; , con &lt;code&gt;rate&lt;/code&gt; probabilidad , produce &lt;code&gt;0&lt;/code&gt; y, de lo contrario, escala la entrada en &lt;code&gt;1 / (1-rate)&lt;/code&gt; . La escala es tal que la suma esperada no cambia.</target>
        </trans-unit>
        <trans-unit id="86602bb631fb5fb59349ca0b2955fe851ca22911" translate="yes" xml:space="preserve">
          <source>For each entry in &lt;code&gt;x&lt;/code&gt;, calculates the number of &lt;code&gt;1&lt;/code&gt; (on) bits in the binary representation of that entry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28ab9495d8c09b2b7b1ceee1fc8792b4dada3fe0" translate="yes" xml:space="preserve">
          <source>For each index tuple &lt;code&gt;js&lt;/code&gt; of size &lt;code&gt;partitions.ndim&lt;/code&gt;, the slice &lt;code&gt;data[js, ...]&lt;/code&gt; becomes part of &lt;code&gt;outputs[partitions[js]]&lt;/code&gt;. The slices with &lt;code&gt;partitions[js] = i&lt;/code&gt; are placed in &lt;code&gt;outputs[i]&lt;/code&gt; in lexicographic order of &lt;code&gt;js&lt;/code&gt;, and the first dimension of &lt;code&gt;outputs[i]&lt;/code&gt; is the number of entries in &lt;code&gt;partitions&lt;/code&gt; equal to &lt;code&gt;i&lt;/code&gt;. In detail,</source>
          <target state="translated">Para cada tupla de &amp;iacute;ndice &lt;code&gt;js&lt;/code&gt; de tama&amp;ntilde;o &lt;code&gt;partitions.ndim&lt;/code&gt; , los &lt;code&gt;data[js, ...]&lt;/code&gt; del segmento [js, ...] se vuelven parte de las &lt;code&gt;outputs[partitions[js]]&lt;/code&gt; . Los cortes con &lt;code&gt;partitions[js] = i&lt;/code&gt; se colocan en las &lt;code&gt;outputs[i]&lt;/code&gt; en orden lexicogr&amp;aacute;fico de &lt;code&gt;js&lt;/code&gt; , y la primera dimensi&amp;oacute;n de las &lt;code&gt;outputs[i]&lt;/code&gt; es el n&amp;uacute;mero de entradas en las &lt;code&gt;partitions&lt;/code&gt; iguales a &lt;code&gt;i&lt;/code&gt; . En detalle,</target>
        </trans-unit>
        <trans-unit id="8f890fa1a354ef3fc8ec0c534b58bd8321503214" translate="yes" xml:space="preserve">
          <source>For each input submatrix of shape &lt;code&gt;[M, M]&lt;/code&gt;, L is a lower triangular matrix of shape &lt;code&gt;[M, M]&lt;/code&gt; with unit diagonal whose entries correspond to the strictly lower triangular part of LU. U is a upper triangular matrix of shape &lt;code&gt;[M, M]&lt;/code&gt; whose entries correspond to the upper triangular part, including the diagonal, of LU.</source>
          <target state="translated">Para cada submatriz de entrada de forma &lt;code&gt;[M, M]&lt;/code&gt; , L es una matriz triangular inferior de forma &lt;code&gt;[M, M]&lt;/code&gt; con diagonal unitaria cuyas entradas corresponden a la parte triangular estrictamente inferior de LU. U es una matriz triangular superior de forma &lt;code&gt;[M, M]&lt;/code&gt; cuyas entradas corresponden a la parte triangular superior, incluida la diagonal, de LU.</target>
        </trans-unit>
        <trans-unit id="c00b7a881865ff1e4e2196d95bae3abcdc4cd784" translate="yes" xml:space="preserve">
          <source>For each job, if the task index space is dense, the corresponding value will be a list of network addresses; otherwise it will be a dictionary mapping (sparse) task indices to the corresponding addresses.</source>
          <target state="translated">Para cada trabajo,si el espacio del índice de tareas es denso,el valor correspondiente será una lista de direcciones de red;de lo contrario,será un diccionario que asigna índices de tareas (dispersas)a las direcciones correspondientes.</target>
        </trans-unit>
        <trans-unit id="aea6c2ab4366a16a529a52527d4b03de1704be35" translate="yes" xml:space="preserve">
          <source>For each key, assigns the respective value to the specified component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="487d8b92f2cc03f24f4ba27c6c59fe187e5d7046" translate="yes" xml:space="preserve">
          <source>For each mode passed in via the &lt;code&gt;input_receiver_fn_map&lt;/code&gt;, this method builds a new graph by calling the &lt;code&gt;input_receiver_fn&lt;/code&gt; to obtain feature and label &lt;code&gt;Tensor&lt;/code&gt;s. Next, this method calls the &lt;code&gt;Estimator&lt;/code&gt;'s &lt;code&gt;model_fn&lt;/code&gt; in the passed mode to generate the model graph based on those features and labels, and restores the given checkpoint (or, lacking that, the most recent checkpoint) into the graph. Only one of the modes is used for saving variables to the &lt;code&gt;SavedModel&lt;/code&gt; (order of preference: &lt;a href=&quot;../../../../estimator/modekeys#TRAIN&quot;&gt;&lt;code&gt;tf.estimator.ModeKeys.TRAIN&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../../../estimator/modekeys#EVAL&quot;&gt;&lt;code&gt;tf.estimator.ModeKeys.EVAL&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../../../../estimator/modekeys#PREDICT&quot;&gt;&lt;code&gt;tf.estimator.ModeKeys.PREDICT&lt;/code&gt;&lt;/a&gt;), such that up to three &lt;code&gt;tf.MetaGraphDefs&lt;/code&gt; are saved with a single set of variables in a single &lt;code&gt;SavedModel&lt;/code&gt; directory.</source>
          <target state="translated">Para cada modo pasado a trav&amp;eacute;s de &lt;code&gt;input_receiver_fn_map&lt;/code&gt; , este m&amp;eacute;todo crea un nuevo gr&amp;aacute;fico llamando al &lt;code&gt;input_receiver_fn&lt;/code&gt; para obtener la funci&amp;oacute;n y la etiqueta &lt;code&gt;Tensor&lt;/code&gt; s. A continuaci&amp;oacute;n, este m&amp;eacute;todo llama al &lt;code&gt;Estimator&lt;/code&gt; 's &lt;code&gt;model_fn&lt;/code&gt; en el modo pasado para generar el gr&amp;aacute;fico modelo basado en las caracter&amp;iacute;sticas y etiquetas, y restaura el punto de control dado (o, a falta de eso, el &amp;uacute;ltimo punto de control) en el gr&amp;aacute;fico. Solo uno de los modos se usa para guardar variables en el &lt;code&gt;SavedModel&lt;/code&gt; (orden de preferencia: &lt;a href=&quot;../../../../estimator/modekeys#TRAIN&quot;&gt; &lt;code&gt;tf.estimator.ModeKeys.TRAIN&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../../../estimator/modekeys#EVAL&quot;&gt; &lt;code&gt;tf.estimator.ModeKeys.EVAL&lt;/code&gt; &lt;/a&gt; , luego &lt;a href=&quot;../../../../estimator/modekeys#PREDICT&quot;&gt; &lt;code&gt;tf.estimator.ModeKeys.PREDICT&lt;/code&gt; &lt;/a&gt; ), de modo que hasta tres &lt;code&gt;tf.MetaGraphDefs&lt;/code&gt; se guardan con un solo conjunto de variables en un solo directorio &lt;code&gt;SavedModel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="894633909e50b7d3307fbbac8ff5cae1f413ff86" translate="yes" xml:space="preserve">
          <source>For each mode passed in via the &lt;code&gt;input_receiver_fn_map&lt;/code&gt;, this method builds a new graph by calling the &lt;code&gt;input_receiver_fn&lt;/code&gt; to obtain feature and label &lt;code&gt;Tensor&lt;/code&gt;s. Next, this method calls the &lt;code&gt;Estimator&lt;/code&gt;'s &lt;code&gt;model_fn&lt;/code&gt; in the passed mode to generate the model graph based on those features and labels, and restores the given checkpoint (or, lacking that, the most recent checkpoint) into the graph. Only one of the modes is used for saving variables to the &lt;code&gt;SavedModel&lt;/code&gt; (order of preference: &lt;a href=&quot;../../../estimator/modekeys#TRAIN&quot;&gt;&lt;code&gt;tf.estimator.ModeKeys.TRAIN&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../../estimator/modekeys#EVAL&quot;&gt;&lt;code&gt;tf.estimator.ModeKeys.EVAL&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../../../estimator/modekeys#PREDICT&quot;&gt;&lt;code&gt;tf.estimator.ModeKeys.PREDICT&lt;/code&gt;&lt;/a&gt;), such that up to three &lt;code&gt;tf.MetaGraphDefs&lt;/code&gt; are saved with a single set of variables in a single &lt;code&gt;SavedModel&lt;/code&gt; directory.</source>
          <target state="translated">Para cada modo pasado a trav&amp;eacute;s de &lt;code&gt;input_receiver_fn_map&lt;/code&gt; , este m&amp;eacute;todo crea un nuevo gr&amp;aacute;fico llamando al &lt;code&gt;input_receiver_fn&lt;/code&gt; para obtener la funci&amp;oacute;n y la etiqueta &lt;code&gt;Tensor&lt;/code&gt; s. A continuaci&amp;oacute;n, este m&amp;eacute;todo llama al &lt;code&gt;Estimator&lt;/code&gt; 's &lt;code&gt;model_fn&lt;/code&gt; en el modo pasado para generar el gr&amp;aacute;fico modelo basado en las caracter&amp;iacute;sticas y etiquetas, y restaura el punto de control dado (o, a falta de eso, el &amp;uacute;ltimo punto de control) en el gr&amp;aacute;fico. Solo uno de los modos se usa para guardar variables en el &lt;code&gt;SavedModel&lt;/code&gt; (orden de preferencia: &lt;a href=&quot;../../../estimator/modekeys#TRAIN&quot;&gt; &lt;code&gt;tf.estimator.ModeKeys.TRAIN&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../../estimator/modekeys#EVAL&quot;&gt; &lt;code&gt;tf.estimator.ModeKeys.EVAL&lt;/code&gt; &lt;/a&gt; , luego &lt;a href=&quot;../../../estimator/modekeys#PREDICT&quot;&gt; &lt;code&gt;tf.estimator.ModeKeys.PREDICT&lt;/code&gt; &lt;/a&gt; ), de modo que hasta tres &lt;code&gt;tf.MetaGraphDefs&lt;/code&gt; se guardan con un solo conjunto de variables en un solo directorio &lt;code&gt;SavedModel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84ad1b7c0e6d676b66b6c0000beb81f60843b517" translate="yes" xml:space="preserve">
          <source>For each mode passed in via the &lt;code&gt;input_receiver_fn_map&lt;/code&gt;, this method builds a new graph by calling the &lt;code&gt;input_receiver_fn&lt;/code&gt; to obtain feature and label &lt;code&gt;Tensor&lt;/code&gt;s. Next, this method calls the &lt;code&gt;Estimator&lt;/code&gt;'s &lt;code&gt;model_fn&lt;/code&gt; in the passed mode to generate the model graph based on those features and labels, and restores the given checkpoint (or, lacking that, the most recent checkpoint) into the graph. Only one of the modes is used for saving variables to the &lt;code&gt;SavedModel&lt;/code&gt; (order of preference: &lt;a href=&quot;../modekeys#TRAIN&quot;&gt;&lt;code&gt;tf.estimator.ModeKeys.TRAIN&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../modekeys#EVAL&quot;&gt;&lt;code&gt;tf.estimator.ModeKeys.EVAL&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../modekeys#PREDICT&quot;&gt;&lt;code&gt;tf.estimator.ModeKeys.PREDICT&lt;/code&gt;&lt;/a&gt;), such that up to three &lt;code&gt;tf.MetaGraphDefs&lt;/code&gt; are saved with a single set of variables in a single &lt;code&gt;SavedModel&lt;/code&gt; directory.</source>
          <target state="translated">Para cada modo pasado a trav&amp;eacute;s de &lt;code&gt;input_receiver_fn_map&lt;/code&gt; , este m&amp;eacute;todo crea un nuevo gr&amp;aacute;fico llamando al &lt;code&gt;input_receiver_fn&lt;/code&gt; para obtener la funci&amp;oacute;n y la etiqueta &lt;code&gt;Tensor&lt;/code&gt; s. A continuaci&amp;oacute;n, este m&amp;eacute;todo llama al &lt;code&gt;Estimator&lt;/code&gt; 's &lt;code&gt;model_fn&lt;/code&gt; en el modo pasado para generar el gr&amp;aacute;fico modelo basado en las caracter&amp;iacute;sticas y etiquetas, y restaura el punto de control dado (o, a falta de eso, el &amp;uacute;ltimo punto de control) en el gr&amp;aacute;fico. Solo uno de los modos se usa para guardar variables en el &lt;code&gt;SavedModel&lt;/code&gt; (orden de preferencia: &lt;a href=&quot;../modekeys#TRAIN&quot;&gt; &lt;code&gt;tf.estimator.ModeKeys.TRAIN&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../modekeys#EVAL&quot;&gt; &lt;code&gt;tf.estimator.ModeKeys.EVAL&lt;/code&gt; &lt;/a&gt; , luego &lt;a href=&quot;../modekeys#PREDICT&quot;&gt; &lt;code&gt;tf.estimator.ModeKeys.PREDICT&lt;/code&gt; &lt;/a&gt; ), de modo que hasta tres &lt;code&gt;tf.MetaGraphDefs&lt;/code&gt; se guardan con un solo conjunto de variables en un solo directorio &lt;code&gt;SavedModel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b412fda993e08f3c91f400db4d8146e4d0f5bc5f" translate="yes" xml:space="preserve">
          <source>For each mode passed in via the &lt;code&gt;input_receiver_fn_map&lt;/code&gt;, this method builds a new graph by calling the &lt;code&gt;input_receiver_fn&lt;/code&gt; to obtain feature and label &lt;code&gt;Tensor&lt;/code&gt;s. Next, this method calls the &lt;code&gt;Estimator&lt;/code&gt;'s &lt;code&gt;model_fn&lt;/code&gt; in the passed mode to generate the model graph based on those features and labels, and restores the given checkpoint (or, lacking that, the most recent checkpoint) into the graph. Only one of the modes is used for saving variables to the &lt;code&gt;SavedModel&lt;/code&gt; (order of preference: &lt;a href=&quot;modekeys#TRAIN&quot;&gt;&lt;code&gt;tf.estimator.ModeKeys.TRAIN&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;modekeys#EVAL&quot;&gt;&lt;code&gt;tf.estimator.ModeKeys.EVAL&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;modekeys#PREDICT&quot;&gt;&lt;code&gt;tf.estimator.ModeKeys.PREDICT&lt;/code&gt;&lt;/a&gt;), such that up to three &lt;code&gt;tf.MetaGraphDefs&lt;/code&gt; are saved with a single set of variables in a single &lt;code&gt;SavedModel&lt;/code&gt; directory.</source>
          <target state="translated">Para cada modo pasado a trav&amp;eacute;s de &lt;code&gt;input_receiver_fn_map&lt;/code&gt; , este m&amp;eacute;todo crea un nuevo gr&amp;aacute;fico llamando al &lt;code&gt;input_receiver_fn&lt;/code&gt; para obtener la funci&amp;oacute;n y la etiqueta &lt;code&gt;Tensor&lt;/code&gt; s. A continuaci&amp;oacute;n, este m&amp;eacute;todo llama al &lt;code&gt;Estimator&lt;/code&gt; 's &lt;code&gt;model_fn&lt;/code&gt; en el modo pasado para generar el gr&amp;aacute;fico modelo basado en las caracter&amp;iacute;sticas y etiquetas, y restaura el punto de control dado (o, a falta de eso, el &amp;uacute;ltimo punto de control) en el gr&amp;aacute;fico. Solo uno de los modos se usa para guardar variables en el &lt;code&gt;SavedModel&lt;/code&gt; (orden de preferencia: &lt;a href=&quot;modekeys#TRAIN&quot;&gt; &lt;code&gt;tf.estimator.ModeKeys.TRAIN&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;modekeys#EVAL&quot;&gt; &lt;code&gt;tf.estimator.ModeKeys.EVAL&lt;/code&gt; &lt;/a&gt; , luego &lt;a href=&quot;modekeys#PREDICT&quot;&gt; &lt;code&gt;tf.estimator.ModeKeys.PREDICT&lt;/code&gt; &lt;/a&gt; ), de modo que hasta tres &lt;code&gt;tf.MetaGraphDefs&lt;/code&gt; se guardan con un solo conjunto de variables en un solo directorio &lt;code&gt;SavedModel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36b982fc21506a7f2190761f16a3f5fcc9ede9c0" translate="yes" xml:space="preserve">
          <source>For each patch, right-multiplies the filter matrix and the image patch vector.</source>
          <target state="translated">Para cada parche,la derecha multiplica la matriz de filtro y el vector de parche de imagen.</target>
        </trans-unit>
        <trans-unit id="495118d7bdd44315c26aae5e3bf24f66dcd99d0d" translate="yes" xml:space="preserve">
          <source>For each point that is sampled during kmeans++ initialization, this parameter specifies the number of additional points to draw from the current distribution before selecting the best. If a negative value is specified, a heuristic is used to sample &lt;code&gt;O(log(num_to_sample))&lt;/code&gt; additional points. Used only if &lt;code&gt;initial_clusters=KMeansClustering.KMEANS_PLUS_PLUS_INIT&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="840e6ba53f4417ca11f6403319bc3e83421092e5" translate="yes" xml:space="preserve">
          <source>For each sample &lt;code&gt;x_i&lt;/code&gt; in &lt;code&gt;inputs&lt;/code&gt; with &lt;code&gt;k&lt;/code&gt; features, we compute the mean and variance of the sample:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c15a30d01baef30188c69bc7ff85b21e3e935e7" translate="yes" xml:space="preserve">
          <source>For each step, calls &lt;code&gt;input_fn&lt;/code&gt;, which returns one batch of data. Evaluates until:</source>
          <target state="translated">Para cada paso, llama a &lt;code&gt;input_fn&lt;/code&gt; , que devuelve un lote de datos. Eval&amp;uacute;a hasta:</target>
        </trans-unit>
        <trans-unit id="76eabb6e369edfcf348e56ad957e852ddec0f36e" translate="yes" xml:space="preserve">
          <source>For each string in the input &lt;code&gt;Tensor&lt;/code&gt;, creates a substring starting at index &lt;code&gt;pos&lt;/code&gt; with a total length of &lt;code&gt;len&lt;/code&gt;.</source>
          <target state="translated">Para cada cadena en la entrada &lt;code&gt;Tensor&lt;/code&gt; , crea una subcadena a partir de &amp;iacute;ndice &lt;code&gt;pos&lt;/code&gt; con una longitud total de &lt;code&gt;len&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad124c85b4e4ed2992f3d2d7226cc6682efb0d10" translate="yes" xml:space="preserve">
          <source>For each timestep in the input tensor (dimension #1 in the tensor), if all values in the input tensor at that timestep are equal to &lt;code&gt;mask_value&lt;/code&gt;, then the timestep will be masked (skipped) in all downstream layers (as long as they support masking).</source>
          <target state="translated">Para cada paso de tiempo en el tensor de entrada (dimensi&amp;oacute;n n. &amp;deg; 1 en el tensor), si todos los valores en el tensor de entrada en ese paso de tiempo son iguales a &lt;code&gt;mask_value&lt;/code&gt; , entonces el paso de tiempo se enmascarar&amp;aacute; (saltar&amp;aacute;) en todas las capas posteriores (siempre que admitan enmascaramiento).</target>
        </trans-unit>
        <trans-unit id="2370b2414271135ef1678cb23ef39f45a5fc2cb3" translate="yes" xml:space="preserve">
          <source>For each value x in &lt;code&gt;error = y_true - y_pred&lt;/code&gt;:</source>
          <target state="translated">Para cada valor x en &lt;code&gt;error = y_true - y_pred&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b30a7e920276e3b902f956f91fd308b9a443509f" translate="yes" xml:space="preserve">
          <source>For each value x in &lt;code&gt;error=labels-predictions&lt;/code&gt;, the following is calculated:</source>
          <target state="translated">Para cada valor x en &lt;code&gt;error=labels-predictions&lt;/code&gt; , se calcula lo siguiente:</target>
        </trans-unit>
        <trans-unit id="0e81aa8da6e2ca9d6903d446870611925fa37da7" translate="yes" xml:space="preserve">
          <source>For estimation of the metric over a stream of data, the function creates an &lt;code&gt;update_op&lt;/code&gt; operation that updates the accuracy of each class and returns them.</source>
          <target state="translated">Para la estimaci&amp;oacute;n de la m&amp;eacute;trica sobre un flujo de datos, la funci&amp;oacute;n crea una operaci&amp;oacute;n &lt;code&gt;update_op&lt;/code&gt; que actualiza la precisi&amp;oacute;n de cada clase y las devuelve.</target>
        </trans-unit>
        <trans-unit id="bbcc260a82187cfff98a34fb724a50f62fa1bb51" translate="yes" xml:space="preserve">
          <source>For estimation of the metric over a stream of data, the function creates an &lt;code&gt;update_op&lt;/code&gt; operation that updates these variables and returns the &lt;code&gt;accuracy&lt;/code&gt;. Internally, an &lt;code&gt;is_correct&lt;/code&gt; operation computes a &lt;code&gt;Tensor&lt;/code&gt; with elements 1.0 where the corresponding elements of &lt;code&gt;predictions&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt; match and 0.0 otherwise. Then &lt;code&gt;update_op&lt;/code&gt; increments &lt;code&gt;total&lt;/code&gt; with the reduced sum of the product of &lt;code&gt;weights&lt;/code&gt; and &lt;code&gt;is_correct&lt;/code&gt;, and it increments &lt;code&gt;count&lt;/code&gt; with the reduced sum of &lt;code&gt;weights&lt;/code&gt;.</source>
          <target state="translated">Para la estimaci&amp;oacute;n de la m&amp;eacute;trica sobre un flujo de datos, la funci&amp;oacute;n crea una operaci&amp;oacute;n &lt;code&gt;update_op&lt;/code&gt; que actualiza estas variables y devuelve la &lt;code&gt;accuracy&lt;/code&gt; . Internamente, una operaci&amp;oacute;n &lt;code&gt;is_correct&lt;/code&gt; calcula un &lt;code&gt;Tensor&lt;/code&gt; con elementos 1.0 donde los elementos correspondientes de &lt;code&gt;predictions&lt;/code&gt; y &lt;code&gt;labels&lt;/code&gt; coinciden y 0.0 en caso contrario. Luego &lt;code&gt;update_op&lt;/code&gt; incrementa el &lt;code&gt;total&lt;/code&gt; con la suma reducida del producto de &lt;code&gt;weights&lt;/code&gt; e &lt;code&gt;is_correct&lt;/code&gt; , y los incrementos &lt;code&gt;count&lt;/code&gt; con la suma reducida de &lt;code&gt;weights&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dad08a503e11b5156a4a3427dfc7515950a48e4f" translate="yes" xml:space="preserve">
          <source>For estimation of the metric over a stream of data, the function creates an &lt;code&gt;update_op&lt;/code&gt; operation that updates these variables and returns the &lt;code&gt;auc&lt;/code&gt;.</source>
          <target state="translated">Para la estimaci&amp;oacute;n de la m&amp;eacute;trica sobre un flujo de datos, la funci&amp;oacute;n crea una operaci&amp;oacute;n &lt;code&gt;update_op&lt;/code&gt; que actualiza estas variables y devuelve el &lt;code&gt;auc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e6ad6df8adaafa9f6c503da039855e65bd9b58e" translate="yes" xml:space="preserve">
          <source>For estimation of the metric over a stream of data, the function creates an &lt;code&gt;update_op&lt;/code&gt; operation that updates these variables and returns the &lt;code&gt;mean&lt;/code&gt;. &lt;code&gt;update_op&lt;/code&gt; increments &lt;code&gt;total&lt;/code&gt; with the reduced sum of the product of &lt;code&gt;values&lt;/code&gt; and &lt;code&gt;weights&lt;/code&gt;, and it increments &lt;code&gt;count&lt;/code&gt; with the reduced sum of &lt;code&gt;weights&lt;/code&gt;.</source>
          <target state="translated">Para estimar la m&amp;eacute;trica sobre un flujo de datos, la funci&amp;oacute;n crea una operaci&amp;oacute;n &lt;code&gt;update_op&lt;/code&gt; que actualiza estas variables y devuelve la &lt;code&gt;mean&lt;/code&gt; . &lt;code&gt;update_op&lt;/code&gt; incrementos &lt;code&gt;total&lt;/code&gt; con la suma reducida del producto de &lt;code&gt;values&lt;/code&gt; y &lt;code&gt;weights&lt;/code&gt; , y incrementos &lt;code&gt;count&lt;/code&gt; con la suma reducida de &lt;code&gt;weights&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4ab931d2efc0e42b3a757d047bf7f98096c2b78" translate="yes" xml:space="preserve">
          <source>For estimation of the metric over a stream of data, the function creates an &lt;code&gt;update_op&lt;/code&gt; operation that updates these variables and returns the &lt;code&gt;mean_absolute_error&lt;/code&gt;. Internally, an &lt;code&gt;absolute_errors&lt;/code&gt; operation computes the absolute value of the differences between &lt;code&gt;predictions&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt;. Then &lt;code&gt;update_op&lt;/code&gt; increments &lt;code&gt;total&lt;/code&gt; with the reduced sum of the product of &lt;code&gt;weights&lt;/code&gt; and &lt;code&gt;absolute_errors&lt;/code&gt;, and it increments &lt;code&gt;count&lt;/code&gt; with the reduced sum of &lt;code&gt;weights&lt;/code&gt;</source>
          <target state="translated">Para la estimaci&amp;oacute;n de la m&amp;eacute;trica sobre un flujo de datos, la funci&amp;oacute;n crea una operaci&amp;oacute;n &lt;code&gt;update_op&lt;/code&gt; que actualiza estas variables y devuelve &lt;code&gt;mean_absolute_error&lt;/code&gt; . Internamente, una operaci&amp;oacute;n &lt;code&gt;absolute_errors&lt;/code&gt; calcula el valor absoluto de las diferencias entre &lt;code&gt;predictions&lt;/code&gt; y &lt;code&gt;labels&lt;/code&gt; . Luego &lt;code&gt;update_op&lt;/code&gt; incrementa el &lt;code&gt;total&lt;/code&gt; con la suma reducida del producto de &lt;code&gt;weights&lt;/code&gt; y &lt;code&gt;absolute_errors&lt;/code&gt; , y los incrementos &lt;code&gt;count&lt;/code&gt; con la suma reducida de &lt;code&gt;weights&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="614a1783a568ced9d248f52d9352d35b40792a7a" translate="yes" xml:space="preserve">
          <source>For estimation of the metric over a stream of data, the function creates an &lt;code&gt;update_op&lt;/code&gt; operation that updates these variables and returns the &lt;code&gt;mean_distance&lt;/code&gt;.</source>
          <target state="translated">Para la estimaci&amp;oacute;n de la m&amp;eacute;trica sobre un flujo de datos, la funci&amp;oacute;n crea una operaci&amp;oacute;n &lt;code&gt;update_op&lt;/code&gt; que actualiza estas variables y devuelve &lt;code&gt;mean_distance&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7bdad2b2535c192103954072920dd86f8d7f97e" translate="yes" xml:space="preserve">
          <source>For estimation of the metric over a stream of data, the function creates an &lt;code&gt;update_op&lt;/code&gt; operation that updates these variables and returns the &lt;code&gt;mean_iou&lt;/code&gt;.</source>
          <target state="translated">Para la estimaci&amp;oacute;n de la m&amp;eacute;trica sobre un flujo de datos, la funci&amp;oacute;n crea una operaci&amp;oacute;n &lt;code&gt;update_op&lt;/code&gt; que actualiza estas variables y devuelve &lt;code&gt;mean_iou&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="21a28b15071e2e3057222499cce4c758670a6204" translate="yes" xml:space="preserve">
          <source>For estimation of the metric over a stream of data, the function creates an &lt;code&gt;update_op&lt;/code&gt; operation that updates these variables and returns the &lt;code&gt;mean_reative_error&lt;/code&gt;. Internally, a &lt;code&gt;relative_errors&lt;/code&gt; operation divides the absolute value of the differences between &lt;code&gt;predictions&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt; by the &lt;code&gt;normalizer&lt;/code&gt;. Then &lt;code&gt;update_op&lt;/code&gt; increments &lt;code&gt;total&lt;/code&gt; with the reduced sum of the product of &lt;code&gt;weights&lt;/code&gt; and &lt;code&gt;relative_errors&lt;/code&gt;, and it increments &lt;code&gt;count&lt;/code&gt; with the reduced sum of &lt;code&gt;weights&lt;/code&gt;.</source>
          <target state="translated">Para la estimaci&amp;oacute;n de la m&amp;eacute;trica sobre un flujo de datos, la funci&amp;oacute;n crea una operaci&amp;oacute;n &lt;code&gt;update_op&lt;/code&gt; que actualiza estas variables y devuelve &lt;code&gt;mean_reative_error&lt;/code&gt; . Internamente, una &lt;code&gt;relative_errors&lt;/code&gt; operaci&amp;oacute;n divide el valor absoluto de las diferencias entre &lt;code&gt;predictions&lt;/code&gt; y &lt;code&gt;labels&lt;/code&gt; por el &lt;code&gt;normalizer&lt;/code&gt; . Luego &lt;code&gt;update_op&lt;/code&gt; incrementa el &lt;code&gt;total&lt;/code&gt; con la suma reducida del producto de los &lt;code&gt;weights&lt;/code&gt; y los errores &lt;code&gt;relative_errors&lt;/code&gt; , y los incrementos &lt;code&gt;count&lt;/code&gt; con la suma reducida de los &lt;code&gt;weights&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2622e71a2a20b6c576fe07f66c3861f4ae1d6554" translate="yes" xml:space="preserve">
          <source>For estimation of the metric over a stream of data, the function creates an &lt;code&gt;update_op&lt;/code&gt; operation that updates these variables and returns the &lt;code&gt;mean_squared_error&lt;/code&gt;. Internally, a &lt;code&gt;squared_error&lt;/code&gt; operation computes the element-wise square of the difference between &lt;code&gt;predictions&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt;. Then &lt;code&gt;update_op&lt;/code&gt; increments &lt;code&gt;total&lt;/code&gt; with the reduced sum of the product of &lt;code&gt;weights&lt;/code&gt; and &lt;code&gt;squared_error&lt;/code&gt;, and it increments &lt;code&gt;count&lt;/code&gt; with the reduced sum of &lt;code&gt;weights&lt;/code&gt;.</source>
          <target state="translated">Para la estimaci&amp;oacute;n de la m&amp;eacute;trica sobre un flujo de datos, la funci&amp;oacute;n crea una operaci&amp;oacute;n &lt;code&gt;update_op&lt;/code&gt; que actualiza estas variables y devuelve &lt;code&gt;mean_squared_error&lt;/code&gt; . Internamente, una operaci&amp;oacute;n &lt;code&gt;squared_error&lt;/code&gt; calcula el cuadrado de elementos de la diferencia entre &lt;code&gt;predictions&lt;/code&gt; y &lt;code&gt;labels&lt;/code&gt; . Luego &lt;code&gt;update_op&lt;/code&gt; incrementa el &lt;code&gt;total&lt;/code&gt; con la suma reducida del producto de &lt;code&gt;weights&lt;/code&gt; y &lt;code&gt;squared_error&lt;/code&gt; , y los incrementos &lt;code&gt;count&lt;/code&gt; con la suma reducida de &lt;code&gt;weights&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="482044def86d900d6f880303c2541fe53cd45fe2" translate="yes" xml:space="preserve">
          <source>For estimation of the metric over a stream of data, the function creates an &lt;code&gt;update_op&lt;/code&gt; operation that updates these variables and returns the &lt;code&gt;percentage&lt;/code&gt;.</source>
          <target state="translated">Para la estimaci&amp;oacute;n de la m&amp;eacute;trica sobre un flujo de datos, la funci&amp;oacute;n crea una operaci&amp;oacute;n &lt;code&gt;update_op&lt;/code&gt; que actualiza estas variables y devuelve el &lt;code&gt;percentage&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11887ce5609f24f245ab19a0dae14981801f1e03" translate="yes" xml:space="preserve">
          <source>For estimation of the metric over a stream of data, the function creates an &lt;code&gt;update_op&lt;/code&gt; operation that updates these variables and returns the &lt;code&gt;precision&lt;/code&gt;.</source>
          <target state="translated">Para la estimaci&amp;oacute;n de la m&amp;eacute;trica sobre un flujo de datos, la funci&amp;oacute;n crea una operaci&amp;oacute;n &lt;code&gt;update_op&lt;/code&gt; que actualiza estas variables y devuelve la &lt;code&gt;precision&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2073b65f678bcea68507c8aced29c54089672a4c" translate="yes" xml:space="preserve">
          <source>For estimation of the metric over a stream of data, the function creates an &lt;code&gt;update_op&lt;/code&gt; operation that updates these variables and returns the &lt;code&gt;precision&lt;/code&gt;. &lt;code&gt;update_op&lt;/code&gt; weights each prediction by the corresponding value in &lt;code&gt;weights&lt;/code&gt;.</source>
          <target state="translated">Para la estimaci&amp;oacute;n de la m&amp;eacute;trica sobre un flujo de datos, la funci&amp;oacute;n crea una operaci&amp;oacute;n &lt;code&gt;update_op&lt;/code&gt; que actualiza estas variables y devuelve la &lt;code&gt;precision&lt;/code&gt; . &lt;code&gt;update_op&lt;/code&gt; pondera cada predicci&amp;oacute;n por el valor correspondiente en &lt;code&gt;weights&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5fa9d8aac2d1f3e8b41e5f969b7c9069f2763710" translate="yes" xml:space="preserve">
          <source>For estimation of the metric over a stream of data, the function creates an &lt;code&gt;update_op&lt;/code&gt; operation that updates these variables and returns the &lt;code&gt;precision_at_&amp;lt;k&amp;gt;&lt;/code&gt;. Internally, a &lt;code&gt;top_k&lt;/code&gt; operation computes a &lt;code&gt;Tensor&lt;/code&gt; indicating the top &lt;code&gt;k&lt;/code&gt;&lt;code&gt;predictions&lt;/code&gt;. Set operations applied to &lt;code&gt;top_k&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt; calculate the true positives and false positives weighted by &lt;code&gt;weights&lt;/code&gt;. Then &lt;code&gt;update_op&lt;/code&gt; increments &lt;code&gt;true_positive_at_&amp;lt;k&amp;gt;&lt;/code&gt; and &lt;code&gt;false_positive_at_&amp;lt;k&amp;gt;&lt;/code&gt; using these values.</source>
          <target state="translated">Para la estimaci&amp;oacute;n de la m&amp;eacute;trica sobre un flujo de datos, la funci&amp;oacute;n crea una operaci&amp;oacute;n &lt;code&gt;update_op&lt;/code&gt; que actualiza estas variables y devuelve la &lt;code&gt;precision_at_&amp;lt;k&amp;gt;&lt;/code&gt; . Internamente, una operaci&amp;oacute;n &lt;code&gt;top_k&lt;/code&gt; calcula un &lt;code&gt;Tensor&lt;/code&gt; indica las &lt;code&gt;k&lt;/code&gt; &lt;code&gt;predictions&lt;/code&gt; . Establecer operaciones aplicadas a &lt;code&gt;top_k&lt;/code&gt; y las &lt;code&gt;labels&lt;/code&gt; calculan los verdaderos positivos y falsos positivos ponderados por &lt;code&gt;weights&lt;/code&gt; . Luego, &lt;code&gt;update_op&lt;/code&gt; incrementa &lt;code&gt;true_positive_at_&amp;lt;k&amp;gt;&lt;/code&gt; y &lt;code&gt;false_positive_at_&amp;lt;k&amp;gt;&lt;/code&gt; usando estos valores.</target>
        </trans-unit>
        <trans-unit id="1d641bbb0bd1f36939980470649afd513c5fe109" translate="yes" xml:space="preserve">
          <source>For estimation of the metric over a stream of data, the function creates an &lt;code&gt;update_op&lt;/code&gt; operation that updates these variables and returns the &lt;code&gt;recall&lt;/code&gt;.</source>
          <target state="translated">Para la estimaci&amp;oacute;n de la m&amp;eacute;trica sobre un flujo de datos, la funci&amp;oacute;n crea una operaci&amp;oacute;n &lt;code&gt;update_op&lt;/code&gt; que actualiza estas variables y devuelve la &lt;code&gt;recall&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e926696bf238fa1af7b7fd153c6b149672d0579" translate="yes" xml:space="preserve">
          <source>For estimation of the metric over a stream of data, the function creates an &lt;code&gt;update_op&lt;/code&gt; operation that updates these variables and returns the &lt;code&gt;recall_at_&amp;lt;k&amp;gt;&lt;/code&gt;. Internally, a &lt;code&gt;top_k&lt;/code&gt; operation computes a &lt;code&gt;Tensor&lt;/code&gt; indicating the top &lt;code&gt;k&lt;/code&gt;&lt;code&gt;predictions&lt;/code&gt;. Set operations applied to &lt;code&gt;top_k&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt; calculate the true positives and false negatives weighted by &lt;code&gt;weights&lt;/code&gt;. Then &lt;code&gt;update_op&lt;/code&gt; increments &lt;code&gt;true_positive_at_&amp;lt;k&amp;gt;&lt;/code&gt; and &lt;code&gt;false_negative_at_&amp;lt;k&amp;gt;&lt;/code&gt; using these values.</source>
          <target state="translated">Para la estimaci&amp;oacute;n de la m&amp;eacute;trica sobre una secuencia de datos, la funci&amp;oacute;n crea una operaci&amp;oacute;n &lt;code&gt;update_op&lt;/code&gt; que actualiza estas variables y devuelve &lt;code&gt;recall_at_&amp;lt;k&amp;gt;&lt;/code&gt; . Internamente, una operaci&amp;oacute;n &lt;code&gt;top_k&lt;/code&gt; calcula un &lt;code&gt;Tensor&lt;/code&gt; indica las &lt;code&gt;k&lt;/code&gt; &lt;code&gt;predictions&lt;/code&gt; . Establecer operaciones aplicadas a &lt;code&gt;top_k&lt;/code&gt; y las &lt;code&gt;labels&lt;/code&gt; calculan los verdaderos positivos y falsos negativos ponderados por &lt;code&gt;weights&lt;/code&gt; . Luego &lt;code&gt;update_op&lt;/code&gt; incrementa &lt;code&gt;true_positive_at_&amp;lt;k&amp;gt;&lt;/code&gt; y &lt;code&gt;false_negative_at_&amp;lt;k&amp;gt;&lt;/code&gt; usando estos valores.</target>
        </trans-unit>
        <trans-unit id="e592409ad4457c95b12184bde9fb30acffe72920" translate="yes" xml:space="preserve">
          <source>For estimation of the metric over a stream of data, the function creates an &lt;code&gt;update_op&lt;/code&gt; operation that updates these variables and returns the &lt;code&gt;root_mean_squared_error&lt;/code&gt;. Internally, a &lt;code&gt;squared_error&lt;/code&gt; operation computes the element-wise square of the difference between &lt;code&gt;predictions&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt;. Then &lt;code&gt;update_op&lt;/code&gt; increments &lt;code&gt;total&lt;/code&gt; with the reduced sum of the product of &lt;code&gt;weights&lt;/code&gt; and &lt;code&gt;squared_error&lt;/code&gt;, and it increments &lt;code&gt;count&lt;/code&gt; with the reduced sum of &lt;code&gt;weights&lt;/code&gt;.</source>
          <target state="translated">Para la estimaci&amp;oacute;n de la m&amp;eacute;trica sobre un flujo de datos, la funci&amp;oacute;n crea una operaci&amp;oacute;n &lt;code&gt;update_op&lt;/code&gt; que actualiza estas variables y devuelve &lt;code&gt;root_mean_squared_error&lt;/code&gt; . Internamente, una operaci&amp;oacute;n &lt;code&gt;squared_error&lt;/code&gt; calcula el cuadrado de elementos de la diferencia entre &lt;code&gt;predictions&lt;/code&gt; y &lt;code&gt;labels&lt;/code&gt; . Luego &lt;code&gt;update_op&lt;/code&gt; incrementa el &lt;code&gt;total&lt;/code&gt; con la suma reducida del producto de &lt;code&gt;weights&lt;/code&gt; y &lt;code&gt;squared_error&lt;/code&gt; , y los incrementos &lt;code&gt;count&lt;/code&gt; con la suma reducida de &lt;code&gt;weights&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a7f0bed98595b5568f1d9ffe04c5cc4a5ca7387" translate="yes" xml:space="preserve">
          <source>For estimation of the metric over a stream of data, the function creates an &lt;code&gt;update_op&lt;/code&gt; operation that updates these variables and returns the &lt;code&gt;sensitivity&lt;/code&gt;. &lt;code&gt;update_op&lt;/code&gt; increments the &lt;code&gt;true_positives&lt;/code&gt;, &lt;code&gt;true_negatives&lt;/code&gt;, &lt;code&gt;false_positives&lt;/code&gt; and &lt;code&gt;false_negatives&lt;/code&gt; counts with the weight of each case found in the &lt;code&gt;predictions&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt;.</source>
          <target state="translated">Para la estimaci&amp;oacute;n de la m&amp;eacute;trica sobre un flujo de datos, la funci&amp;oacute;n crea una operaci&amp;oacute;n &lt;code&gt;update_op&lt;/code&gt; que actualiza estas variables y devuelve la &lt;code&gt;sensitivity&lt;/code&gt; . &lt;code&gt;update_op&lt;/code&gt; incrementa los &lt;code&gt;true_positives&lt;/code&gt; , &lt;code&gt;true_negatives&lt;/code&gt; , &lt;code&gt;false_positives&lt;/code&gt; y &lt;code&gt;false_negatives&lt;/code&gt; con el peso de cada caso encontrado en las &lt;code&gt;predictions&lt;/code&gt; y &lt;code&gt;labels&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b07e75d0103c0e548428284e5efc113eab68537b" translate="yes" xml:space="preserve">
          <source>For estimation of the metric over a stream of data, the function creates an &lt;code&gt;update_op&lt;/code&gt; operation that updates these variables and returns the &lt;code&gt;specificity&lt;/code&gt;. &lt;code&gt;update_op&lt;/code&gt; increments the &lt;code&gt;true_positives&lt;/code&gt;, &lt;code&gt;true_negatives&lt;/code&gt;, &lt;code&gt;false_positives&lt;/code&gt; and &lt;code&gt;false_negatives&lt;/code&gt; counts with the weight of each case found in the &lt;code&gt;predictions&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt;.</source>
          <target state="translated">Para la estimaci&amp;oacute;n de la m&amp;eacute;trica sobre un flujo de datos, la funci&amp;oacute;n crea una operaci&amp;oacute;n &lt;code&gt;update_op&lt;/code&gt; que actualiza estas variables y devuelve la &lt;code&gt;specificity&lt;/code&gt; . &lt;code&gt;update_op&lt;/code&gt; incrementa los &lt;code&gt;true_positives&lt;/code&gt; , &lt;code&gt;true_negatives&lt;/code&gt; , &lt;code&gt;false_positives&lt;/code&gt; y &lt;code&gt;false_negatives&lt;/code&gt; con el peso de cada caso encontrado en las &lt;code&gt;predictions&lt;/code&gt; y &lt;code&gt;labels&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84f3ab8b259e10c767171cb16e1ed0bedcdf7bd6" translate="yes" xml:space="preserve">
          <source>For estimation of the metric over a stream of data, the function creates an &lt;code&gt;update_op&lt;/code&gt; that updates these variables and returns the &lt;code&gt;recall&lt;/code&gt;. &lt;code&gt;update_op&lt;/code&gt; weights each prediction by the corresponding value in &lt;code&gt;weights&lt;/code&gt;.</source>
          <target state="translated">Para la estimaci&amp;oacute;n de la m&amp;eacute;trica sobre un flujo de datos, la funci&amp;oacute;n crea un &lt;code&gt;update_op&lt;/code&gt; que actualiza estas variables y devuelve la &lt;code&gt;recall&lt;/code&gt; . &lt;code&gt;update_op&lt;/code&gt; pondera cada predicci&amp;oacute;n por el valor correspondiente en &lt;code&gt;weights&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16fe84732ca0277f0c85a01f97b90cbe49eed312" translate="yes" xml:space="preserve">
          <source>For eval, merges metrics by adding &lt;code&gt;head.name&lt;/code&gt; suffix to the keys in eval metrics, such as &lt;code&gt;precision/head1.name&lt;/code&gt;, &lt;code&gt;precision/head2.name&lt;/code&gt;.</source>
          <target state="translated">Para eval, fusiona m&amp;eacute;tricas agregando el sufijo &lt;code&gt;head.name&lt;/code&gt; a las claves en las m&amp;eacute;tricas de eval, como &lt;code&gt;precision/head1.name&lt;/code&gt; , &lt;code&gt;precision/head2.name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="096f439eadd884160cca18be357dd236e0d9b954" translate="yes" xml:space="preserve">
          <source>For evaluation and prediction, &lt;code&gt;model_fn&lt;/code&gt; gets per-core batch size and &lt;code&gt;input_fn&lt;/code&gt; get per-host batch size.</source>
          <target state="translated">Para evaluaci&amp;oacute;n y predicci&amp;oacute;n, &lt;code&gt;model_fn&lt;/code&gt; obtiene el tama&amp;ntilde;o de lote por n&amp;uacute;cleo y &lt;code&gt;input_fn&lt;/code&gt; obtiene el tama&amp;ntilde;o de lote por host.</target>
        </trans-unit>
        <trans-unit id="9aaddffdb76b42aacd2bb37b2bc66b758d2d660a" translate="yes" xml:space="preserve">
          <source>For evaluation, &lt;code&gt;eval_metrics&lt;/code&gt;is a tuple of &lt;code&gt;metric_fn&lt;/code&gt; and &lt;code&gt;tensors&lt;/code&gt;, where &lt;code&gt;metric_fn&lt;/code&gt; runs on CPU to generate metrics and &lt;code&gt;tensors&lt;/code&gt; represents the &lt;code&gt;Tensor&lt;/code&gt;s transferred from TPU system to CPU host and passed to &lt;code&gt;metric_fn&lt;/code&gt;. To be precise, TPU evaluation expects a slightly different signature from the &lt;a href=&quot;../../../../estimator/estimator&quot;&gt;&lt;code&gt;tf.estimator.Estimator&lt;/code&gt;&lt;/a&gt;. While &lt;a href=&quot;../../../../estimator/estimatorspec#eval_metric_ops&quot;&gt;&lt;code&gt;EstimatorSpec.eval_metric_ops&lt;/code&gt;&lt;/a&gt; expects a dict, &lt;code&gt;TPUEstimatorSpec.eval_metrics&lt;/code&gt; is a tuple of &lt;code&gt;metric_fn&lt;/code&gt; and &lt;code&gt;tensors&lt;/code&gt;. The &lt;code&gt;tensors&lt;/code&gt; could be a list of &lt;code&gt;Tensor&lt;/code&gt;s or dict of names to &lt;code&gt;Tensor&lt;/code&gt;s. The &lt;code&gt;tensors&lt;/code&gt; usually specify the model logits, which are transferred back from TPU system to CPU host. All tensors must have be batch-major, i.e., the batch size is the first dimension. Once all tensors are available at CPU host from all shards, they are concatenated (on CPU) and passed as positional arguments to the &lt;code&gt;metric_fn&lt;/code&gt; if &lt;code&gt;tensors&lt;/code&gt; is list or keyword arguments if &lt;code&gt;tensors&lt;/code&gt; is a dict. &lt;code&gt;metric_fn&lt;/code&gt; takes the &lt;code&gt;tensors&lt;/code&gt; and returns a dict from metric string name to the result of calling a metric function, namely a &lt;code&gt;(metric_tensor, update_op)&lt;/code&gt; tuple. See &lt;code&gt;TPUEstimator&lt;/code&gt; for MNIST example how to specify the &lt;code&gt;eval_metrics&lt;/code&gt;.</source>
          <target state="translated">Para la evaluaci&amp;oacute;n, &lt;code&gt;eval_metrics&lt;/code&gt; es una tupla de &lt;code&gt;metric_fn&lt;/code&gt; y &lt;code&gt;tensors&lt;/code&gt; , donde &lt;code&gt;metric_fn&lt;/code&gt; se ejecuta en la CPU para generar m&amp;eacute;tricas y &lt;code&gt;tensors&lt;/code&gt; representa el &lt;code&gt;Tensor&lt;/code&gt; s transferido desde el sistema de TPU para anfitri&amp;oacute;n CPU y se pasa a &lt;code&gt;metric_fn&lt;/code&gt; . Para ser precisos, la evaluaci&amp;oacute;n de TPU espera una firma ligeramente diferente de &lt;a href=&quot;../../../../estimator/estimator&quot;&gt; &lt;code&gt;tf.estimator.Estimator&lt;/code&gt; &lt;/a&gt; . Mientras &lt;a href=&quot;../../../../estimator/estimatorspec#eval_metric_ops&quot;&gt; &lt;code&gt;EstimatorSpec.eval_metric_ops&lt;/code&gt; &lt;/a&gt; espera un diccionario, &lt;code&gt;TPUEstimatorSpec.eval_metrics&lt;/code&gt; es una tupla de &lt;code&gt;metric_fn&lt;/code&gt; y &lt;code&gt;tensors&lt;/code&gt; . Los &lt;code&gt;tensors&lt;/code&gt; podr&amp;iacute;an ser una lista de &lt;code&gt;Tensor&lt;/code&gt; s o dict of names to &lt;code&gt;Tensor&lt;/code&gt; s. Los &lt;code&gt;tensors&lt;/code&gt; generalmente especifican los logits del modelo, que se transfieren del sistema de TPU al host de la CPU. Todos los tensores deben tener un lote mayor, es decir, el tama&amp;ntilde;o del lote es la primera dimensi&amp;oacute;n. Una vez que todos los tensores est&amp;aacute;n disponibles en el host de CPU de todos los fragmentos, que se concatenan (de CPU) y pasan como argumentos posicionales a la &lt;code&gt;metric_fn&lt;/code&gt; si &lt;code&gt;tensors&lt;/code&gt; es la lista de palabras clave o argumentos, si &lt;code&gt;tensors&lt;/code&gt; es un dict. &lt;code&gt;metric_fn&lt;/code&gt; toma los &lt;code&gt;tensors&lt;/code&gt; y devuelve un dict del nombre de la cadena m&amp;eacute;trica al resultado de llamar a una funci&amp;oacute;n m&amp;eacute;trica, es decir, una &lt;code&gt;(metric_tensor, update_op)&lt;/code&gt; . Ver &lt;code&gt;TPUEstimator&lt;/code&gt; para el ejemplo de MNIST, c&amp;oacute;mo especificar &lt;code&gt;eval_metrics&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f118a36ef432860d92562aadbab18ae4b06bc7e8" translate="yes" xml:space="preserve">
          <source>For evaluation, &lt;code&gt;eval_metrics&lt;/code&gt;is a tuple of &lt;code&gt;metric_fn&lt;/code&gt; and &lt;code&gt;tensors&lt;/code&gt;, where &lt;code&gt;metric_fn&lt;/code&gt; runs on CPU to generate metrics and &lt;code&gt;tensors&lt;/code&gt; represents the &lt;code&gt;Tensor&lt;/code&gt;s transferred from TPU system to CPU host and passed to &lt;code&gt;metric_fn&lt;/code&gt;. To be precise, TPU evaluation expects a slightly different signature from the &lt;a href=&quot;../../../../estimator/estimator&quot;&gt;&lt;code&gt;tf.estimator.Estimator&lt;/code&gt;&lt;/a&gt;. While &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/estimator/EstimatorSpec#eval_metric_ops&quot;&gt;&lt;code&gt;EstimatorSpec.eval_metric_ops&lt;/code&gt;&lt;/a&gt; expects a dict, &lt;code&gt;TPUEstimatorSpec.eval_metrics&lt;/code&gt; is a tuple of &lt;code&gt;metric_fn&lt;/code&gt; and &lt;code&gt;tensors&lt;/code&gt;. The &lt;code&gt;tensors&lt;/code&gt; could be a list of &lt;code&gt;Tensor&lt;/code&gt;s or dict of names to &lt;code&gt;Tensor&lt;/code&gt;s. The &lt;code&gt;tensors&lt;/code&gt; usually specify the model logits, which are transferred back from TPU system to CPU host. All tensors must have be batch-major, i.e., the batch size is the first dimension. Once all tensors are available at CPU host from all shards, they are concatenated (on CPU) and passed as positional arguments to the &lt;code&gt;metric_fn&lt;/code&gt; if &lt;code&gt;tensors&lt;/code&gt; is list or keyword arguments if &lt;code&gt;tensors&lt;/code&gt; is a dict. &lt;code&gt;metric_fn&lt;/code&gt; takes the &lt;code&gt;tensors&lt;/code&gt; and returns a dict from metric string name to the result of calling a metric function, namely a &lt;code&gt;(metric_tensor, update_op)&lt;/code&gt; tuple. See &lt;code&gt;TPUEstimator&lt;/code&gt; for MNIST example how to specify the &lt;code&gt;eval_metrics&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="233690c252f396e774e862ecef25a5d76e450f3d" translate="yes" xml:space="preserve">
          <source>For every layer, a &lt;code&gt;group&lt;/code&gt; named &lt;code&gt;layer.name&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e630abe4632e77580d682ff1b578d80d9f94bb8" translate="yes" xml:space="preserve">
          <source>For every such layer group, a group attribute &lt;code&gt;weight_names&lt;/code&gt;, a list of strings (ordered names of weights tensor of the layer).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="922382a037863a11613e937b2f92117b3dfa1b3d" translate="yes" xml:space="preserve">
          <source>For every weight in the layer, a dataset storing the weight value, named after the weight tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="177050bf0b29fb3f08398a12bddac7a0a078af5e" translate="yes" xml:space="preserve">
          <source>For example &lt;code&gt;foo[3:5,...,4:5]&lt;/code&gt; on a shape 10x3x3x10 tensor is equivalent to &lt;code&gt;foo[3:5,:,:,4:5]&lt;/code&gt; and &lt;code&gt;foo[3:5,...]&lt;/code&gt; is equivalent to &lt;code&gt;foo[3:5,:,:,:]&lt;/code&gt;.</source>
          <target state="translated">Por ejemplo &lt;code&gt;foo[3:5,...,4:5]&lt;/code&gt; en un tensor de forma 10x3x3x10 es equivalente a &lt;code&gt;foo[3:5,:,:,4:5]&lt;/code&gt; y &lt;code&gt;foo[3:5,...]&lt;/code&gt; es equivalente a &lt;code&gt;foo[3:5,:,:,:]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4dd7ff6a28b3c8f6de1619b3709d89a90256ca48" translate="yes" xml:space="preserve">
          <source>For example if we have a file with the following content:</source>
          <target state="translated">Por ejemplo,si tenemos un archivo con el siguiente contenido:</target>
        </trans-unit>
        <trans-unit id="315792fe0731f8fd6c7594397b55834eb861bb3c" translate="yes" xml:space="preserve">
          <source>For example if you know all the images in a dataset have shape [28,28,3] you can set it with &lt;code&gt;tf.set_shape&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="f7cb3885a2d5b333dd84f8883e526c3c627d832d" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;'s &lt;code&gt;input_signature&lt;/code&gt; argument accepts a list (or nested structure) of &lt;code&gt;TypeSpec&lt;/code&gt;s.</source>
          <target state="translated">Por ejemplo, &lt;a href=&quot;function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; 's &lt;code&gt;input_signature&lt;/code&gt; argumento acepta una lista (o estructura anidada) de &lt;code&gt;TypeSpec&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="3e0fb3305e7269deaf00a94f40306ad8dc3b8739" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;foo[:4, tf.newaxis, :2]&lt;/code&gt; would produce a shape &lt;code&gt;(4, 1, 2)&lt;/code&gt; tensor.</source>
          <target state="translated">Por ejemplo, &lt;code&gt;foo[:4, tf.newaxis, :2]&lt;/code&gt; producir&amp;iacute;a un tensor de forma &lt;code&gt;(4, 1, 2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc792685b1d9aab00aa3a406ffbf92c58d9d4cb3" translate="yes" xml:space="preserve">
          <source>For example, N = 2, source[0] is 'hello world' and source[1] is 'a b c', then the output will be</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cb0994aab88328f91b6706a654056d092b65ec9" translate="yes" xml:space="preserve">
          <source>For example, a &lt;a href=&quot;../../layers/dense&quot;&gt;&lt;code&gt;tf.keras.layers.Dense&lt;/code&gt;&lt;/a&gt; layer, when run on a GPU with a float16 compute dtype, will pass float16 inputs to tf.matmul. But, tf.matmul will do use float32 intermediate math. The performance benefit of float16 is still apparent, due to increased memory bandwidth and the fact modern GPUs have specialized hardware for computing matmuls on float16 while still keeping intermediate computations in float32.</source>
          <target state="translated">Por ejemplo, una capa &lt;a href=&quot;../../layers/dense&quot;&gt; &lt;code&gt;tf.keras.layers.Dense&lt;/code&gt; &lt;/a&gt; , cuando se ejecuta en una GPU con un tipo de c&amp;aacute;lculo float16, pasar&amp;aacute; las entradas float16 a tf.matmul. Pero, tf.matmul usar&amp;aacute; matem&amp;aacute;ticas intermedias float32. El beneficio de rendimiento de float16 a&amp;uacute;n es evidente, debido al mayor ancho de banda de la memoria y al hecho de que las GPU modernas tienen hardware especializado para computar matmuls en float16 mientras mantienen los c&amp;aacute;lculos intermedios en float32.</target>
        </trans-unit>
        <trans-unit id="5f7fb0826a5a86cfd624ab2a8d7d2b8c6ddef6b1" translate="yes" xml:space="preserve">
          <source>For example, a Dense layer returns a list of two values-- per-output weights and the bias value. These can be used to set the weights of another Dense layer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85a2affea67c5e39397e4468831c1fffecfdec41" translate="yes" xml:space="preserve">
          <source>For example, a blockwise &lt;code&gt;3 x 3&lt;/code&gt;&lt;code&gt;LinearOperatorBlockLowerTriangular&lt;/code&gt; is initialized with the list &lt;code&gt;[[op_00], [op_10, op_11], [op_20, op_21, op_22]]&lt;/code&gt;, where the &lt;code&gt;op_ij&lt;/code&gt;, &lt;code&gt;i &amp;lt; 3, j &amp;lt;= i&lt;/code&gt;, are &lt;code&gt;LinearOperator&lt;/code&gt; instances. The &lt;code&gt;LinearOperatorBlockLowerTriangular&lt;/code&gt; behaves as the following blockwise matrix, where &lt;code&gt;0&lt;/code&gt; represents appropriately-sized [batch] matrices of zeros:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcebdd5340244173df800627bd1fd4d61eafaaf9" translate="yes" xml:space="preserve">
          <source>For example, a long-running operation (e.g. &lt;code&gt;tf.QueueBase.enqueue&lt;/code&gt; may be cancelled by running another operation (e.g. &lt;code&gt;tf.QueueBase.close&lt;/code&gt;, or by &lt;code&gt;tf.Session.close&lt;/code&gt;. A step that is running such a long-running operation will fail by raising &lt;code&gt;CancelledError&lt;/code&gt;.</source>
          <target state="translated">Por ejemplo, una operaci&amp;oacute;n de larga duraci&amp;oacute;n (por ejemplo, &lt;code&gt;tf.QueueBase.enqueue&lt;/code&gt; puede cancelarse ejecutando otra operaci&amp;oacute;n (por ejemplo , &lt;code&gt;tf.QueueBase.close&lt;/code&gt; , o por &lt;code&gt;tf.Session.close&lt;/code&gt; ) . Un paso que ejecuta una operaci&amp;oacute;n de larga duraci&amp;oacute;n falla al generar &lt;code&gt;CancelledError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8e89184316bed55c53786f62c2b2ad4e3ff94d1" translate="yes" xml:space="preserve">
          <source>For example, a variable created under a &lt;code&gt;MirroredStrategy&lt;/code&gt; is a &lt;code&gt;MirroredVariable&lt;/code&gt;. If no devices are specified in the constructor argument of the strategy then it will use all the available GPUs. If no GPUs are found, it will use the available CPUs. Note that TensorFlow treats all CPUs on a machine as a single device, and uses threads internally for parallelism.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef45f8f5ea52443b495bf1c4d1f242d4e99b9f14" translate="yes" xml:space="preserve">
          <source>For example, assuming that operations of type &lt;code&gt;&quot;Sub&quot;&lt;/code&gt; take two inputs &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, and return a single output &lt;code&gt;x - y&lt;/code&gt;, the following gradient function would be registered:</source>
          <target state="translated">Por ejemplo, suponiendo que las operaciones de tipo &lt;code&gt;&quot;Sub&quot;&lt;/code&gt; toman dos entradas &lt;code&gt;x&lt;/code&gt; y &lt;code&gt;y&lt;/code&gt; , y devuelven un de salida &amp;uacute;nica &lt;code&gt;x - y&lt;/code&gt; , la siguiente funci&amp;oacute;n gradiente ser&amp;iacute;a registrada:</target>
        </trans-unit>
        <trans-unit id="180f2ef709a54a11af8fe0feb0049ea09edaa93b" translate="yes" xml:space="preserve">
          <source>For example, consider the case where a new operation &lt;code&gt;MyNewAwesomeAdd&lt;/code&gt; is created with the intent of replacing the implementation of an existing Python wrapper - &lt;a href=&quot;../math/add&quot;&gt;&lt;code&gt;tf.add&lt;/code&gt;&lt;/a&gt;. The Python wrapper implementation should change from something like:</source>
          <target state="translated">Por ejemplo, considere el caso en el que se crea una nueva operaci&amp;oacute;n &lt;code&gt;MyNewAwesomeAdd&lt;/code&gt; con la intenci&amp;oacute;n de reemplazar la implementaci&amp;oacute;n de un contenedor Python existente: &lt;a href=&quot;../math/add&quot;&gt; &lt;code&gt;tf.add&lt;/code&gt; &lt;/a&gt; . La implementaci&amp;oacute;n del contenedor de Python deber&amp;iacute;a cambiar de algo como:</target>
        </trans-unit>
        <trans-unit id="5485292a2195c6dfb3a48825eb198beefa168928" translate="yes" xml:space="preserve">
          <source>For example, consider the following feature vectors:</source>
          <target state="translated">Por ejemplo,consideremos los siguientes vectores característicos:</target>
        </trans-unit>
        <trans-unit id="4ebe2904fc13a0afda0a0801fae06da9da930550" translate="yes" xml:space="preserve">
          <source>For example, consider the following function that commonly occurs in the computation of cross entropy and log likelihoods:</source>
          <target state="translated">Por ejemplo,considérese la siguiente función que se produce comúnmente en el cómputo de la entropía cruzada y las probabilidades logarítmicas:</target>
        </trans-unit>
        <trans-unit id="36b3d8f67113dade2a57685778931fd4aac40c92" translate="yes" xml:space="preserve">
          <source>For example, consider the function &lt;code&gt;y = x * x&lt;/code&gt;. The gradient at &lt;code&gt;x = 3.0&lt;/code&gt; can be computed as:</source>
          <target state="translated">Por ejemplo, considere la funci&amp;oacute;n &lt;code&gt;y = x * x&lt;/code&gt; . El gradiente en &lt;code&gt;x = 3.0&lt;/code&gt; se puede calcular como:</target>
        </trans-unit>
        <trans-unit id="a0f0b737266cb9508dec913b7e40d2a11a33a917" translate="yes" xml:space="preserve">
          <source>For example, for a cluster set up for parameter server training, the following device filters might be specified:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="623e0c89de281259a4a76c11ecbd4f9ce138793a" translate="yes" xml:space="preserve">
          <source>For example, for a length-&lt;code&gt;k&lt;/code&gt;, vector-valued distribution, it is calculated as,</source>
          <target state="translated">Por ejemplo, para una distribuci&amp;oacute;n de valor vectorial de longitud- &lt;code&gt;k&lt;/code&gt; , se calcula como,</target>
        </trans-unit>
        <trans-unit id="f6368f536fbdc467faaf091386024de7a14c3cdc" translate="yes" xml:space="preserve">
          <source>For example, for a vocabulary containing 3 labels &lt;code&gt;[a, b, c]&lt;/code&gt;, &lt;code&gt;num_classes = 4&lt;/code&gt; and the labels indexing is &lt;code&gt;{a: 0, b: 1, c: 2, blank: 3}&lt;/code&gt;.</source>
          <target state="translated">Por ejemplo, para un vocabulario que contiene 3 etiquetas &lt;code&gt;[a, b, c]&lt;/code&gt; , &lt;code&gt;num_classes = 4&lt;/code&gt; y la indexaci&amp;oacute;n de etiquetas es &lt;code&gt;{a: 0, b: 1, c: 2, blank: 3}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3115c15a9fb018968e5c6d980aaf6a85e52aa08" translate="yes" xml:space="preserve">
          <source>For example, for stride=(1,1) and padding=&quot;same&quot;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00cb23acbd39732b0289b04ffd814e294ed82c1d" translate="yes" xml:space="preserve">
          <source>For example, for stride=(1,1) and padding=&quot;valid&quot;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f975567f0c60114a08dd76e03f219202f64cefff" translate="yes" xml:space="preserve">
          <source>For example, for stride=(2,2) and padding=&quot;valid&quot;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7255e66a73d48695729736c11b4e69788bd57bb6" translate="yes" xml:space="preserve">
          <source>For example, for strides=1 and padding=&quot;same&quot;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="085e925d53c95cbefd7abeb57a30c1ff2277f50b" translate="yes" xml:space="preserve">
          <source>For example, for strides=1 and padding=&quot;valid&quot;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb7d3255ed5f8e3928e920d565d5aea04bdcc956" translate="yes" xml:space="preserve">
          <source>For example, for strides=2 and padding=&quot;valid&quot;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f5c38b8eb7488176cf43cc68fe176bcdaf5ad82" translate="yes" xml:space="preserve">
          <source>For example, for system with 8 logical devices, if &lt;code&gt;tensor&lt;/code&gt; is an image tensor with shape (batch_size, width, height, channel) and &lt;code&gt;partition_dimensions&lt;/code&gt; is [1, 2, 4, 1], then &lt;code&gt;tensor&lt;/code&gt; will be split 2 in width dimension and 4 way in height dimension and the split tensor values will be fed into 8 logical devices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04995a90d2cbb2770c2b48eb75173d51eb847e39" translate="yes" xml:space="preserve">
          <source>For example, given a tensor of shape &lt;code&gt;(A, B, C, D)&lt;/code&gt;;</source>
          <target state="translated">Por ejemplo, dado un tensor de forma &lt;code&gt;(A, B, C, D)&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="e1b94d04ee53deb5a3f4899863cd8936a9a93808" translate="yes" xml:space="preserve">
          <source>For example, given an input of shape &lt;code&gt;[1, 1, 1, 4]&lt;/code&gt;, data_format = &quot;NHWC&quot; and block_size = 2:</source>
          <target state="translated">Por ejemplo, dada una entrada de forma &lt;code&gt;[1, 1, 1, 4]&lt;/code&gt; , data_format = &quot;NHWC&quot; y block_size = 2:</target>
        </trans-unit>
        <trans-unit id="73901e6b47ecbf656dbf0c63bc23506a1582b4f9" translate="yes" xml:space="preserve">
          <source>For example, given an input of shape &lt;code&gt;[1, 2, 2, 1]&lt;/code&gt;, data_format = &quot;NHWC&quot; and block_size = 2:</source>
          <target state="translated">Por ejemplo, dada una entrada de forma &lt;code&gt;[1, 2, 2, 1]&lt;/code&gt; , data_format = &quot;NHWC&quot; y block_size = 2:</target>
        </trans-unit>
        <trans-unit id="9e72f264d4068a89cde912a017b35e1218d4d07d" translate="yes" xml:space="preserve">
          <source>For example, given the following datasets:</source>
          <target state="translated">Por ejemplo,dados los siguientes conjuntos de datos:</target>
        </trans-unit>
        <trans-unit id="36e6a7cc02c6b3197df385da6bc03f401a87598e" translate="yes" xml:space="preserve">
          <source>For example, given the following input:</source>
          <target state="translated">Por ejemplo,dada la siguiente entrada:</target>
        </trans-unit>
        <trans-unit id="72fef8ba715160aa4ba1e8d1a7eac5b78987feac" translate="yes" xml:space="preserve">
          <source>For example, given this input:</source>
          <target state="translated">Por ejemplo,dada esta entrada:</target>
        </trans-unit>
        <trans-unit id="ccbd1974587f66c012f3ce45843b4a9f5f326074" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;axis = 1&lt;/code&gt; and the inputs are</source>
          <target state="translated">Por ejemplo, si &lt;code&gt;axis = 1&lt;/code&gt; y las entradas son</target>
        </trans-unit>
        <trans-unit id="6b23a8e10aeea8f89169181db0354df162a5d3fd" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;concat_dim = 1&lt;/code&gt; and the inputs are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12db4e70afdf1bc3643b5acdc6bad82dd0e10f2e" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;elems&lt;/code&gt; is &lt;code&gt;(t1, [t2, t3])&lt;/code&gt; and &lt;code&gt;initializer&lt;/code&gt; is &lt;code&gt;[i1, i2]&lt;/code&gt; then an appropriate signature for &lt;code&gt;fn&lt;/code&gt; in &lt;code&gt;python2&lt;/code&gt; is: &lt;code&gt;fn = lambda (acc_p1, acc_p2), (t1, [t2, t3]):&lt;/code&gt; and &lt;code&gt;fn&lt;/code&gt; must return a list, &lt;code&gt;[acc_n1, acc_n2]&lt;/code&gt;. An alternative correct signature for &lt;code&gt;fn&lt;/code&gt;, and the one that works in &lt;code&gt;python3&lt;/code&gt;, is: &lt;code&gt;fn = lambda a, t:&lt;/code&gt;, where &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt; correspond to the input tuples.</source>
          <target state="translated">Por ejemplo, si &lt;code&gt;elems&lt;/code&gt; es &lt;code&gt;(t1, [t2, t3])&lt;/code&gt; y el &lt;code&gt;initializer&lt;/code&gt; es &lt;code&gt;[i1, i2]&lt;/code&gt; entonces una firma apropiada para &lt;code&gt;fn&lt;/code&gt; en &lt;code&gt;python2&lt;/code&gt; es: &lt;code&gt;fn = lambda (acc_p1, acc_p2), (t1, [t2, t3]):&lt;/code&gt; y &lt;code&gt;fn&lt;/code&gt; debe devolver una lista, &lt;code&gt;[acc_n1, acc_n2]&lt;/code&gt; . Una firma alternativa correcta para &lt;code&gt;fn&lt;/code&gt; , y la que funciona en &lt;code&gt;python3&lt;/code&gt; , es: &lt;code&gt;fn = lambda a, t:&lt;/code&gt; donde &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;t&lt;/code&gt; corresponden a las tuplas de entrada.</target>
        </trans-unit>
        <trans-unit id="cc61fc022fbf77e9b491b661c7505399625f7c88" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;labels&lt;/code&gt;=[a, b, c] and &lt;code&gt;predictions&lt;/code&gt;=[x, y, z], there are three pairs of differences are summed to compute the loss: loss = [ ((a-b) - (x-y)).^2 + ((a-c) - (x-z)).^2 + ((b-c) - (y-z)).^2 ] / 3</source>
          <target state="translated">Por ejemplo, si &lt;code&gt;labels&lt;/code&gt; = [a, b, c] y &lt;code&gt;predictions&lt;/code&gt; = [x, y, z], se suman tres pares de diferencias para calcular la p&amp;eacute;rdida: p&amp;eacute;rdida = [((ab) - (xy)). ^ 2 + ((ac) - (xz)). ^ 2 + ((bc) - (yz)). ^ 2] / 3</target>
        </trans-unit>
        <trans-unit id="2baa9bbc1cf6bd691324f3eac32cd3df8cf8cd10" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;sp_input.dense_shape = [2, 3, 4]&lt;/code&gt; with non-empty values:</source>
          <target state="translated">Por ejemplo, si &lt;code&gt;sp_input.dense_shape = [2, 3, 4]&lt;/code&gt; con valores no vac&amp;iacute;os:</target>
        </trans-unit>
        <trans-unit id="82ef36e97447aa968dcbc0b94c3a5abad62654fd" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;sp_input&lt;/code&gt; has shape &lt;code&gt;[2, 3, 6]&lt;/code&gt; and &lt;code&gt;indices&lt;/code&gt; / &lt;code&gt;values&lt;/code&gt;:</source>
          <target state="translated">Por ejemplo, si &lt;code&gt;sp_input&lt;/code&gt; tiene forma &lt;code&gt;[2, 3, 6]&lt;/code&gt; e &lt;code&gt;indices&lt;/code&gt; / &lt;code&gt;values&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5fbb93d3efe7c28e2cd5aae402bb6c00323fbb4c" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;sp_input&lt;/code&gt; has shape &lt;code&gt;[3, 5]&lt;/code&gt; and non-empty string values:</source>
          <target state="translated">Por ejemplo, si &lt;code&gt;sp_input&lt;/code&gt; tiene forma &lt;code&gt;[3, 5]&lt;/code&gt; y valores de cadena no vac&amp;iacute;os:</target>
        </trans-unit>
        <trans-unit id="48e9053195f85a37348bd311aa5312c62f0d464f" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;sp_input&lt;/code&gt; has shape &lt;code&gt;[4, 5]&lt;/code&gt; and 4 non-empty string values:</source>
          <target state="translated">Por ejemplo, si &lt;code&gt;sp_input&lt;/code&gt; tiene forma &lt;code&gt;[4, 5]&lt;/code&gt; y 4 valores de cadena no vac&amp;iacute;os:</target>
        </trans-unit>
        <trans-unit id="c8378e24e7a2aa8a60e4c9f1dd742f0e0c198be9" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;sp_input&lt;/code&gt; has shape &lt;code&gt;[4, 5]&lt;/code&gt; and &lt;code&gt;indices&lt;/code&gt; / &lt;code&gt;values&lt;/code&gt;:</source>
          <target state="translated">Por ejemplo, si &lt;code&gt;sp_input&lt;/code&gt; tiene forma &lt;code&gt;[4, 5]&lt;/code&gt; e &lt;code&gt;indices&lt;/code&gt; / &lt;code&gt;values&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="079ce847d3f4ddf3969ea935f3da66bee264e67a" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;values&lt;/code&gt; is [1, 3, 5, 7] and reduction=SUM_OVER_BATCH_SIZE, then the value of &lt;code&gt;result()&lt;/code&gt; is 4. If the &lt;code&gt;sample_weight&lt;/code&gt; is specified as [1, 1, 0, 0] then value of &lt;code&gt;result()&lt;/code&gt; would be 2.</source>
          <target state="translated">Por ejemplo, si los &lt;code&gt;values&lt;/code&gt; son [1, 3, 5, 7] y la reducci&amp;oacute;n = SUM_OVER_BATCH_SIZE, entonces el valor de &lt;code&gt;result()&lt;/code&gt; es 4. Si el &lt;code&gt;sample_weight&lt;/code&gt; se especifica como [1, 1, 0, 0] entonces el valor de &lt;code&gt;result()&lt;/code&gt; ser&amp;iacute;a 2.</target>
        </trans-unit>
        <trans-unit id="74c85d63fadaf2c9b5598258a9c06918b60fbc1f" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;y_true&lt;/code&gt; is [-1., 1., 1.], and &lt;code&gt;y_pred&lt;/code&gt; is [0.6, -0.7, -0.5] the hinge metric value is 1.6.</source>
          <target state="translated">Por ejemplo, si &lt;code&gt;y_true&lt;/code&gt; es [-1., 1., 1.] y &lt;code&gt;y_pred&lt;/code&gt; es [0,6, -0,7, -0,5], el valor de la m&amp;eacute;trica de bisagra es 1,6.</target>
        </trans-unit>
        <trans-unit id="042aca995b0f38a90ddefbc3e2a8e393512784fe" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;y_true&lt;/code&gt; is [-1., 1., 1.], and &lt;code&gt;y_pred&lt;/code&gt; is [0.6, -0.7, -0.5] the squared hinge metric value is 2.6.</source>
          <target state="translated">Por ejemplo, si &lt;code&gt;y_true&lt;/code&gt; es [-1., 1., 1.] y &lt;code&gt;y_pred&lt;/code&gt; es [0.6, -0.7, -0.5] el valor m&amp;eacute;trico de la bisagra al cuadrado es 2.6.</target>
        </trans-unit>
        <trans-unit id="d39413a8be385331298ca5abd733969e733cbbd9" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;y_true&lt;/code&gt; is [0, 1, 0, 0] and &lt;code&gt;y_pred&lt;/code&gt; is [0, 0, 1, 1] then the false positives value is 2. If the weights were specified as [0, 0, 1, 0] then the false positives value would be 1.</source>
          <target state="translated">Por ejemplo, si &lt;code&gt;y_true&lt;/code&gt; es [0, 1, 0, 0] y &lt;code&gt;y_pred&lt;/code&gt; es [0, 0, 1, 1], entonces el valor de falsos positivos es 2. Si los pesos se especificaron como [0, 0, 1, 0] entonces el valor de falsos positivos ser&amp;iacute;a 1.</target>
        </trans-unit>
        <trans-unit id="01fe7d4a63a14b4e23db71a05868b30fb525abd1" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;y_true&lt;/code&gt; is [0, 1, 0, 0] and &lt;code&gt;y_pred&lt;/code&gt; is [1, 1, 0, 0] then the true negatives value is 2. If the weights were specified as [0, 0, 1, 0] then the true negatives value would be 1.</source>
          <target state="translated">Por ejemplo, si &lt;code&gt;y_true&lt;/code&gt; es [0, 1, 0, 0] y &lt;code&gt;y_pred&lt;/code&gt; es [1, 1, 0, 0], entonces el verdadero valor negativo es 2. Si los pesos se especificaron como [0, 0, 1, 0] entonces el verdadero valor negativo ser&amp;iacute;a 1.</target>
        </trans-unit>
        <trans-unit id="3ef6e2ca3f9a644f49c6e0ccb7b4d3c7a6db0fc4" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;y_true&lt;/code&gt; is [0, 1, 1, 1] and &lt;code&gt;y_pred&lt;/code&gt; is [0, 1, 0, 0] then the false negatives value is 2. If the weights were specified as [0, 0, 1, 0] then the false negatives value would be 1.</source>
          <target state="translated">Por ejemplo, si &lt;code&gt;y_true&lt;/code&gt; es [0, 1, 1, 1] y &lt;code&gt;y_pred&lt;/code&gt; es [0, 1, 0, 0], entonces el valor de falsos negativos es 2. Si los pesos se especificaron como [0, 0, 1, 0] entonces el valor de falsos negativos ser&amp;iacute;a 1.</target>
        </trans-unit>
        <trans-unit id="3c8c09a433fcd3271d82f0d4f5f64556a950bbfa" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;y_true&lt;/code&gt; is [0, 1, 1, 1] and &lt;code&gt;y_pred&lt;/code&gt; is [1, 0, 1, 1] then the precision value is 2/(2+1) ie. 0.66. If the weights were specified as [0, 0, 1, 0] then the precision value would be 1.</source>
          <target state="translated">Por ejemplo, si &lt;code&gt;y_true&lt;/code&gt; es [0, 1, 1, 1] y &lt;code&gt;y_pred&lt;/code&gt; es [1, 0, 1, 1], entonces el valor de precisi&amp;oacute;n es 2 / (2 + 1) es decir. 0,66. Si los pesos se especificaran como [0, 0, 1, 0], el valor de precisi&amp;oacute;n ser&amp;iacute;a 1.</target>
        </trans-unit>
        <trans-unit id="fd7f6e92310398a605f77c3bad5f5cad2b0e6794" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;y_true&lt;/code&gt; is [0, 1, 1, 1] and &lt;code&gt;y_pred&lt;/code&gt; is [1, 0, 1, 1] then the recall value is 2/(2+1) ie. 0.66. If the weights were specified as [0, 0, 1, 0] then the recall value would be 1.</source>
          <target state="translated">Por ejemplo, si &lt;code&gt;y_true&lt;/code&gt; es [0, 1, 1, 1] y &lt;code&gt;y_pred&lt;/code&gt; es [1, 0, 1, 1], entonces el valor de recuperaci&amp;oacute;n es 2 / (2 + 1) es decir. 0,66. Si los pesos se especificaran como [0, 0, 1, 0], el valor de recuperaci&amp;oacute;n ser&amp;iacute;a 1.</target>
        </trans-unit>
        <trans-unit id="878e23bb2323f6b8fb30fbec08a976993f265dc2" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;y_true&lt;/code&gt; is [0, 1, 1, 1] and &lt;code&gt;y_pred&lt;/code&gt; is [1, 0, 1, 1] then the true positives value is 2. If the weights were specified as [0, 0, 1, 0] then the true positives value would be 1.</source>
          <target state="translated">Por ejemplo, si &lt;code&gt;y_true&lt;/code&gt; es [0, 1, 1, 1] y &lt;code&gt;y_pred&lt;/code&gt; es [1, 0, 1, 1], entonces el verdadero valor positivo es 2. Si los pesos se especificaron como [0, 0, 1, 0] entonces el verdadero valor positivo ser&amp;iacute;a 1.</target>
        </trans-unit>
        <trans-unit id="32b3cccbb70066b6b335a50381cd94d294b3c189" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;y_true&lt;/code&gt; is [0, 1, 1], and &lt;code&gt;y_pred&lt;/code&gt; is [1, 0, 1], the cosine similarity is 0.5.</source>
          <target state="translated">Por ejemplo, si &lt;code&gt;y_true&lt;/code&gt; es [0, 1, 1] y &lt;code&gt;y_pred&lt;/code&gt; es [1, 0, 1], la similitud del coseno es 0,5.</target>
        </trans-unit>
        <trans-unit id="0c5ba23e60dac33d6e6ff20e271aa3704cc01f45" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;y_true&lt;/code&gt; is [0., 0., 1., 1.], and &lt;code&gt;y_pred&lt;/code&gt; is [1., 1., 1., 0.] the mean absolute error is 3/4 (0.75).</source>
          <target state="translated">Por ejemplo, si &lt;code&gt;y_true&lt;/code&gt; es [0., 0., 1., 1.] y &lt;code&gt;y_pred&lt;/code&gt; es [1., 1., 1., 0.] el error absoluto medio es 3/4 (0,75).</target>
        </trans-unit>
        <trans-unit id="10a6bddbd7d48d043bb0ce687f4965fd964d600b" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;y_true&lt;/code&gt; is [0., 0., 1., 1.], and &lt;code&gt;y_pred&lt;/code&gt; is [1., 1., 1., 0.] the mean absolute percentage error is 5e+08.</source>
          <target state="translated">Por ejemplo, si &lt;code&gt;y_true&lt;/code&gt; es [0., 0., 1., 1.] y &lt;code&gt;y_pred&lt;/code&gt; es [1., 1., 1., 0.] el error porcentual absoluto medio es 5e + 08.</target>
        </trans-unit>
        <trans-unit id="1db7dfad0c8212945bcb0be81f790e3411e18049" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;y_true&lt;/code&gt; is [0., 0., 1., 1.], and &lt;code&gt;y_pred&lt;/code&gt; is [1., 1., 1., 0.] the mean squared error is 3/4 (0.75).</source>
          <target state="translated">Por ejemplo, si &lt;code&gt;y_true&lt;/code&gt; es [0., 0., 1., 1.] y &lt;code&gt;y_pred&lt;/code&gt; es [1., 1., 1., 0.] el error cuadr&amp;aacute;tico medio es 3/4 (0,75).</target>
        </trans-unit>
        <trans-unit id="352820f40271575204f969d93b9125b9211bb111" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;y_true&lt;/code&gt; is [0., 0., 1., 1.], and &lt;code&gt;y_pred&lt;/code&gt; is [1., 1., 1., 0.] the mean squared logarithmic error is 0.36034.</source>
          <target state="translated">Por ejemplo, si &lt;code&gt;y_true&lt;/code&gt; es [0., 0., 1., 1.] y &lt;code&gt;y_pred&lt;/code&gt; es [1., 1., 1., 0.] el error logar&amp;iacute;tmico cuadr&amp;aacute;tico medio es 0.36034.</target>
        </trans-unit>
        <trans-unit id="92f9d133578d098af3f012a74c5de6af734aaac1" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;y_true&lt;/code&gt; is [0., 1., 1.], and &lt;code&gt;y_pred&lt;/code&gt; is [1., 0., 1.] the categorical hinge metric value is 1.0.</source>
          <target state="translated">Por ejemplo, si &lt;code&gt;y_true&lt;/code&gt; es [0., 1., 1.] y &lt;code&gt;y_pred&lt;/code&gt; es [1., 0., 1.] el valor m&amp;eacute;trico de bisagra categ&amp;oacute;rico es 1.0.</target>
        </trans-unit>
        <trans-unit id="332538af5696bac076f524f2b4f5a405f689fdfc" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;y_true&lt;/code&gt; is [1, 1, 0, 0] and &lt;code&gt;y_pred&lt;/code&gt; is [0.98, 1, 0, 0.6] then the binary accuracy is 3/4 or .75. If the weights were specified as [1, 0, 0, 1] then the binary accuracy would be 1/2 or .5.</source>
          <target state="translated">Por ejemplo, si &lt;code&gt;y_true&lt;/code&gt; es [1, 1, 0, 0] y &lt;code&gt;y_pred&lt;/code&gt; es [0.98, 1, 0, 0.6] entonces la precisi&amp;oacute;n binaria es 3/4 o .75. Si los pesos se especificaran como [1, 0, 0, 1], la precisi&amp;oacute;n binaria ser&amp;iacute;a 1/2 o 0,5.</target>
        </trans-unit>
        <trans-unit id="302da67695947e6cae183abb786ed1ed93793986" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;y_true&lt;/code&gt; is [1, 2, 3, 4] and &lt;code&gt;y_pred&lt;/code&gt; is [0, 2, 3, 4] then the accuracy is 3/4 or .75. If the weights were specified as [1, 1, 0, 0] then the accuracy would be 1/2 or .5.</source>
          <target state="translated">Por ejemplo, si &lt;code&gt;y_true&lt;/code&gt; es [1, 2, 3, 4] y &lt;code&gt;y_pred&lt;/code&gt; es [0, 2, 3, 4], entonces la precisi&amp;oacute;n es 3/4 o 0,75. Si los pesos se especificaran como [1, 1, 0, 0], la precisi&amp;oacute;n ser&amp;iacute;a 1/2 o 0,5.</target>
        </trans-unit>
        <trans-unit id="63dd4aed6e3f523156f4cc8450148bc3eb7f33cb" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;y_true&lt;/code&gt; is [[0, 0, 1], [0, 1, 0]] and &lt;code&gt;y_pred&lt;/code&gt; is [[0.1, 0.9, 0.8], [0.05, 0.95, 0]] then the categorical accuracy is 1/2 or .5. If the weights were specified as [0.7, 0.3] then the categorical accuracy would be .3. You can provide logits of classes as &lt;code&gt;y_pred&lt;/code&gt;, since argmax of logits and probabilities are same.</source>
          <target state="translated">Por ejemplo, si &lt;code&gt;y_true&lt;/code&gt; es [[0, 0, 1], [0, 1, 0]] y &lt;code&gt;y_pred&lt;/code&gt; es [[0.1, 0.9, 0.8], [0.05, 0.95, 0]], entonces la precisi&amp;oacute;n categ&amp;oacute;rica es 1 / 2 o .5. Si las ponderaciones se especificaran como [0,7, 0,3], la precisi&amp;oacute;n categ&amp;oacute;rica ser&amp;iacute;a 0,3. Puede proporcionar logits de clases como &lt;code&gt;y_pred&lt;/code&gt; , ya que argmax de logits y probabilidades son iguales.</target>
        </trans-unit>
        <trans-unit id="03b61c36d51ef6615cbd7e2f828167a558e16b95" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;y_true&lt;/code&gt; is [[2], [1]] and &lt;code&gt;y_pred&lt;/code&gt; is [[0.1, 0.9, 0.8], [0.05, 0.95, 0]] then the categorical accuracy is 1/2 or .5. If the weights were specified as [0.7, 0.3] then the categorical accuracy would be .3. You can provide logits of classes as &lt;code&gt;y_pred&lt;/code&gt;, since argmax of logits and probabilities are same.</source>
          <target state="translated">Por ejemplo, si &lt;code&gt;y_true&lt;/code&gt; es [[2], [1]] y &lt;code&gt;y_pred&lt;/code&gt; es [[0.1, 0.9, 0.8], [0.05, 0.95, 0]], entonces la precisi&amp;oacute;n categ&amp;oacute;rica es 1/2 o .5. Si las ponderaciones se especificaran como [0,7, 0,3], la precisi&amp;oacute;n categ&amp;oacute;rica ser&amp;iacute;a 0,3. Puede proporcionar logits de clases como &lt;code&gt;y_pred&lt;/code&gt; , ya que argmax de logits y probabilidades son iguales.</target>
        </trans-unit>
        <trans-unit id="8f13a7bb3ba4ef5812b22736a0c5aa5e4b5379d5" translate="yes" xml:space="preserve">
          <source>For example, if a Boolean flag was created whose long name was 'update' and whose short name was 'x', then this flag could be explicitly unset through either --noupdate or --nox.</source>
          <target state="translated">Por ejemplo,si se creó una bandera booleana cuyo nombre largo era &quot;update&quot; y cuyo nombre corto era &quot;x&quot;,entonces esta bandera podría ser explícitamente desestabilizada a través de --noupdate o --nox.</target>
        </trans-unit>
        <trans-unit id="cc9b6d5bd1871e9c4763dd68bc17d436b61c0322" translate="yes" xml:space="preserve">
          <source>For example, if an image is 100 x 200 pixels (height x width) and the bounding box is &lt;code&gt;[0.1, 0.2, 0.5, 0.9]&lt;/code&gt;, the upper-left and bottom-right coordinates of the bounding box will be &lt;code&gt;(40, 10)&lt;/code&gt; to &lt;code&gt;(100, 50)&lt;/code&gt; (in (x,y) coordinates).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="159c6f90d773fa258aa2ceb1607894f00e000d7c" translate="yes" xml:space="preserve">
          <source>For example, if an image is 100 x 200 pixels (height x width) and the bounding box is &lt;code&gt;[0.1, 0.2, 0.5, 0.9]&lt;/code&gt;, the upper-left and bottom-right coordinates of the bounding box will be &lt;code&gt;(40, 10)&lt;/code&gt; to &lt;code&gt;(180, 50)&lt;/code&gt; (in (x,y) coordinates).</source>
          <target state="translated">Por ejemplo, si una imagen tiene 100 x 200 p&amp;iacute;xeles (alto x ancho) y el cuadro delimitador es &lt;code&gt;[0.1, 0.2, 0.5, 0.9]&lt;/code&gt; , las coordenadas superior izquierda e inferior derecha del cuadro delimitador ser&amp;aacute;n &lt;code&gt;(40, 10)&lt;/code&gt; a &lt;code&gt;(180, 50)&lt;/code&gt; (en coordenadas (x, y)).</target>
        </trans-unit>
        <trans-unit id="07684173fdbd40bd293343faca9d012ab8c45162" translate="yes" xml:space="preserve">
          <source>For example, if an instance of &lt;code&gt;StaticVocabularyTable&lt;/code&gt; is initialized with a string-to-id initializer that maps:</source>
          <target state="translated">Por ejemplo, si una instancia de &lt;code&gt;StaticVocabularyTable&lt;/code&gt; se inicializa con un inicializador de cadena a identificaci&amp;oacute;n que asigna:</target>
        </trans-unit>
        <trans-unit id="eb86a4b81dfbe2a8d5b118b66c9ce83f3cdff0cb" translate="yes" xml:space="preserve">
          <source>For example, if each &lt;code&gt;indices[m]&lt;/code&gt; is scalar or vector, we have</source>
          <target state="translated">Por ejemplo, si cada &lt;code&gt;indices[m]&lt;/code&gt; es escalar o vectorial, tenemos</target>
        </trans-unit>
        <trans-unit id="14f0ac91df308245997c838649986de3acfa389b" translate="yes" xml:space="preserve">
          <source>For example, if elements of the dataset are shaped &lt;code&gt;[B, a0, a1, ...]&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; may vary for each input element, then for each element in the dataset, the unbatched dataset will contain &lt;code&gt;B&lt;/code&gt; consecutive elements of shape &lt;code&gt;[a0, a1, ...]&lt;/code&gt;.</source>
          <target state="translated">Por ejemplo, si los elementos del conjunto de datos tienen la forma &lt;code&gt;[B, a0, a1, ...]&lt;/code&gt; , donde &lt;code&gt;B&lt;/code&gt; puede variar para cada elemento de entrada, entonces, para cada elemento del conjunto de datos, el conjunto de datos no agrupado contendr&amp;aacute; &lt;code&gt;B&lt;/code&gt; elementos consecutivos de forma &lt;code&gt;[a0, a1, ...]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b758388605970f47c42af062f7d7168a335bbc88" translate="yes" xml:space="preserve">
          <source>For example, if one expects a &lt;a href=&quot;../../../tf#float32&quot;&gt;&lt;code&gt;tf.float32&lt;/code&gt;&lt;/a&gt;&lt;code&gt;VarLenFeature&lt;/code&gt;&lt;code&gt;ft&lt;/code&gt; and three serialized &lt;code&gt;Example&lt;/code&gt;s are provided:</source>
          <target state="translated">Por ejemplo, si uno espera un &lt;a href=&quot;../../../tf#float32&quot;&gt; &lt;code&gt;tf.float32&lt;/code&gt; &lt;/a&gt; &lt;code&gt;VarLenFeature&lt;/code&gt; &lt;code&gt;ft&lt;/code&gt; y se proporcionan tres &lt;code&gt;Example&lt;/code&gt; serializados :</target>
        </trans-unit>
        <trans-unit id="eb05669fcc3c2a0884538e3c5dcbdcad42ac9ef3" translate="yes" xml:space="preserve">
          <source>For example, if one expects a &lt;a href=&quot;../../tf#float32&quot;&gt;&lt;code&gt;tf.float32&lt;/code&gt;&lt;/a&gt;&lt;code&gt;VarLenFeature&lt;/code&gt;&lt;code&gt;ft&lt;/code&gt; and three serialized &lt;code&gt;Example&lt;/code&gt;s are provided:</source>
          <target state="translated">Por ejemplo, si uno espera un &lt;a href=&quot;../../tf#float32&quot;&gt; &lt;code&gt;tf.float32&lt;/code&gt; &lt;/a&gt; &lt;code&gt;VarLenFeature&lt;/code&gt; &lt;code&gt;ft&lt;/code&gt; y se proporcionan tres &lt;code&gt;Example&lt;/code&gt; serializados :</target>
        </trans-unit>
        <trans-unit id="f8bdd2413e1c95149871ce390e2fbfac69482604" translate="yes" xml:space="preserve">
          <source>For example, if shape_x is [1, 2, 3] and shape_y is [5, 1, 3], the result is a Tensor whose value is [5, 2, 3].</source>
          <target state="translated">Por ejemplo,si shape_x es [1,2,3]y shape_y es [5,1,3],el resultado es un Tensor cuyo valor es [5,2,3].</target>
        </trans-unit>
        <trans-unit id="8e1dfee76a0dd69d101ca2f4608dd28751a60789" translate="yes" xml:space="preserve">
          <source>For example, if shape_x is [1, 2, 3] and shape_y is [5, 1, 3], the result is a TensorShape whose value is [5, 2, 3].</source>
          <target state="translated">Por ejemplo,si shape_x es [1,2,3]y shape_y es [5,1,3],el resultado es un TensorShape cuyo valor es [5,2,3].</target>
        </trans-unit>
        <trans-unit id="baed7d2d04b5d92ba9788e9979fc3b16b8e8b4dc" translate="yes" xml:space="preserve">
          <source>For example, if the handles represent an input, which is a &lt;code&gt;[2, 3]&lt;/code&gt; matrix representing two original &lt;code&gt;SparseTensor&lt;/code&gt; objects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2db8bec254cdfb9c2b8d35134ff51a3f64cd250" translate="yes" xml:space="preserve">
          <source>For example, if the input features are:</source>
          <target state="translated">Por ejemplo,si las características de entrada son:</target>
        </trans-unit>
        <trans-unit id="0176458490bbd6de268b72418c42500856f34603" translate="yes" xml:space="preserve">
          <source>For example, if the input is</source>
          <target state="translated">Por ejemplo,si la entrada es</target>
        </trans-unit>
        <trans-unit id="6f37e7a6ce06d95b7008768ab5281188eb588a5d" translate="yes" xml:space="preserve">
          <source>For example, if the inputs are</source>
          <target state="translated">Por ejemplo,si las entradas son</target>
        </trans-unit>
        <trans-unit id="4a55df6baad5525fc85f361979567c6db417291a" translate="yes" xml:space="preserve">
          <source>For example, if the inputs are boundaries = [0, 10, 100] input = [[-5, 10000] [150, 10] [5, 100]]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2211633f9a2518e5f826b94adb19d9161763632d" translate="yes" xml:space="preserve">
          <source>For example, if the serialized input is a &lt;code&gt;[2 x 3]&lt;/code&gt; matrix representing two original &lt;code&gt;SparseTensor&lt;/code&gt; objects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec19dc8fbf4a531cb12fa3311a36ebe61ce15eb0" translate="yes" xml:space="preserve">
          <source>For example, if the serialized input is a &lt;code&gt;[2, 3]&lt;/code&gt; matrix representing two original &lt;code&gt;SparseTensor&lt;/code&gt; objects:</source>
          <target state="translated">Por ejemplo, si la entrada serializada es una matriz &lt;code&gt;[2, 3]&lt;/code&gt; que representa dos objetos &lt;code&gt;SparseTensor&lt;/code&gt; originales :</target>
        </trans-unit>
        <trans-unit id="a70f738ece73b26c4269166b69c29af52453cd5b" translate="yes" xml:space="preserve">
          <source>For example, if values is [1, 3, 5, 7] then the mean is 4. If the weights were specified as [1, 1, 0, 0] then the mean would be 2.</source>
          <target state="translated">Por ejemplo,si los valores son [1,3,5,7]entonces la media es 4.Si los pesos se especificaran como [1,1,0,0]entonces la media sería 2.</target>
        </trans-unit>
        <trans-unit id="e8911ee7c4d9c2878cc8d50831034ed815f5e1c3" translate="yes" xml:space="preserve">
          <source>For example, if values is [1, 3, 5, 7] then the sum is 16. If the weights were specified as [1, 1, 0, 0] then the sum would be 4.</source>
          <target state="translated">Por ejemplo,si los valores son [1,3,5,7]entonces la suma es 16.Si los pesos se especificaran como [1,1,0,0]entonces la suma sería 4.</target>
        </trans-unit>
        <trans-unit id="9e1df8c42c0b9b864ddf4232778a736fd6146a8f" translate="yes" xml:space="preserve">
          <source>For example, if you had two iterators that marked the current position in a training dataset and a test dataset, you could choose which to use in each step as follows:</source>
          <target state="translated">Por ejemplo,si tuviera dos iteradores que marcaran la posición actual en un conjunto de datos de entrenamiento y un conjunto de datos de prueba,podría elegir cuál utilizar en cada paso de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="059fadcaec40fcaea26bdf57bd124c4c9b8acb79" translate="yes" xml:space="preserve">
          <source>For example, in a distributed-training setting, suppose we have a master seed and a replica ID. We want to fold the replica ID into the master seed to form a &quot;replica seed&quot; to be used by that replica later on, so that different replicas will generate different random numbers but the reproducibility of the whole system can still be controlled by the master seed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f80318ab5209d9919d27fe805ac19a9c0931d496" translate="yes" xml:space="preserve">
          <source>For example, in the following code block:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa532f960a2ce1a036579c69315203f6c2651d89" translate="yes" xml:space="preserve">
          <source>For example, it can be used to implement the dynamic decoder of a seq2seq model.</source>
          <target state="translated">Por ejemplo,puede utilizarse para implementar el decodificador dinámico de un modelo seq2seq.</target>
        </trans-unit>
        <trans-unit id="3e600c85cc6a4cecba36365c9dcfce62fdbeb235" translate="yes" xml:space="preserve">
          <source>For example, letting &lt;code&gt;{...}&lt;/code&gt; to represent a Dataset:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf659dc49fbc636a057c5bc8faf1b5475f6913de" translate="yes" xml:space="preserve">
          <source>For example, of loading images of a known size:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e782088c1d829573c59eb47813c6583133dd6bf0" translate="yes" xml:space="preserve">
          <source>For example, running a &lt;code&gt;tf.QueueBase.enqueue&lt;/code&gt; operation may raise &lt;code&gt;AbortedError&lt;/code&gt; if a &lt;code&gt;tf.QueueBase.close&lt;/code&gt; operation previously ran.</source>
          <target state="translated">Por ejemplo, ejecutar una operaci&amp;oacute;n &lt;code&gt;tf.QueueBase.enqueue&lt;/code&gt; puede generar &lt;code&gt;AbortedError&lt;/code&gt; si una operaci&amp;oacute;n &lt;code&gt;tf.QueueBase.close&lt;/code&gt; se ejecut&amp;oacute; anteriormente.</target>
        </trans-unit>
        <trans-unit id="6fb766e4eb77cad3c4ed3c20934b9966a924fe5a" translate="yes" xml:space="preserve">
          <source>For example, running an operation that saves a file (e.g. &lt;code&gt;tf.train.Saver.save&lt;/code&gt;) could potentially raise this exception if an explicit filename for an existing file was passed.</source>
          <target state="translated">Por ejemplo, ejecutar una operaci&amp;oacute;n que guarda un archivo (por ejemplo, &lt;code&gt;tf.train.Saver.save&lt;/code&gt; ) podr&amp;iacute;a generar esta excepci&amp;oacute;n si se pasa un nombre de archivo expl&amp;iacute;cito para un archivo existente.</target>
        </trans-unit>
        <trans-unit id="18f700fd2ce897b85fe0dede4441f3a1eacfcf00" translate="yes" xml:space="preserve">
          <source>For example, running the &lt;code&gt;tf.WholeFileReader.read&lt;/code&gt; operation could raise &lt;code&gt;NotFoundError&lt;/code&gt; if it receives the name of a file that does not exist.</source>
          <target state="translated">Por ejemplo, ejecutar la operaci&amp;oacute;n &lt;code&gt;tf.WholeFileReader.read&lt;/code&gt; podr&amp;iacute;a generar &lt;code&gt;NotFoundError&lt;/code&gt; si recibe el nombre de un archivo que no existe.</target>
        </trans-unit>
        <trans-unit id="cfa313373d48902517bbb0ec4668f45e63a5050e" translate="yes" xml:space="preserve">
          <source>For example, running the &lt;code&gt;tf.WholeFileReader.read&lt;/code&gt; operation could raise &lt;code&gt;PermissionDeniedError&lt;/code&gt; if it receives the name of a file for which the user does not have the read file permission.</source>
          <target state="translated">Por ejemplo, ejecutar la operaci&amp;oacute;n &lt;code&gt;tf.WholeFileReader.read&lt;/code&gt; podr&amp;iacute;a generar &lt;code&gt;PermissionDeniedError&lt;/code&gt; si recibe el nombre de un archivo para el que el usuario no tiene permiso de lectura de archivo.</target>
        </trans-unit>
        <trans-unit id="3f9fc30c26c26b9c0cc0d112a519a99605e0e840" translate="yes" xml:space="preserve">
          <source>For example, running the same function in two separate critical sections will not ensure serial execution:</source>
          <target state="translated">Por ejemplo,ejecutar la misma función en dos secciones críticas separadas no asegurará la ejecución en serie:</target>
        </trans-unit>
        <trans-unit id="bef67e884ee584f664d6ae2ff6b50fa0e2467597" translate="yes" xml:space="preserve">
          <source>For example, say we want to add 4 scattered elements to a rank-1 tensor to 8 elements. In Python, that addition would look like this:</source>
          <target state="translated">Por ejemplo,digamos que queremos añadir 4 elementos dispersos a un tensor de rango 1 a 8 elementos.En Python,esa adición se vería así:</target>
        </trans-unit>
        <trans-unit id="1465860225753881464cf1173eca6c9061ef5e4f" translate="yes" xml:space="preserve">
          <source>For example, say we want to add 4 scattered elements to a rank-1 tensor to 8 elements. In Python, that update would look like this:</source>
          <target state="translated">Por ejemplo,digamos que queremos añadir 4 elementos dispersos a un tensor de rango 1 a 8 elementos.En Python,esa actualización se vería así:</target>
        </trans-unit>
        <trans-unit id="27f08ff4e75bc71a4d85d762bdd869d0c386d3d7" translate="yes" xml:space="preserve">
          <source>For example, say we want to subtract 4 scattered elements from a rank-1 tensor with 8 elements. In Python, that subtraction would look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="debc3020545312e69c35338b60b8ad1a5d0f1fc6" translate="yes" xml:space="preserve">
          <source>For example, say we want to subtract 4 scattered elements from a rank-1 tensor with 8 elements. In Python, that update would look like this:</source>
          <target state="translated">Por ejemplo,digamos que queremos restar 4 elementos dispersos de un tensor de rango 1 con 8 elementos.En Python,esa actualización se vería así:</target>
        </trans-unit>
        <trans-unit id="56ffaf4007daaf44f9fa50fd0b3fcda03d228d5e" translate="yes" xml:space="preserve">
          <source>For example, say we want to update 4 scattered elements to a rank-1 tensor to 8 elements. In Python, that update would look like this:</source>
          <target state="translated">Por ejemplo,digamos que queremos actualizar 4 elementos dispersos a un tensor de rango 1 a 8 elementos.En Python,esa actualización se vería así:</target>
        </trans-unit>
        <trans-unit id="9818c958e44ded80c1b979231b05b2b1e699a832" translate="yes" xml:space="preserve">
          <source>For example, say you have a class A that compares only on its attribute x. Comparators other than &lt;strong&gt;lt&lt;/strong&gt; are omitted for brevity.</source>
          <target state="translated">Por ejemplo, digamos que tiene una clase A que se compara solo en su atributo x. Los comparadores distintos a &lt;strong&gt;lt&lt;/strong&gt; se omiten por brevedad.</target>
        </trans-unit>
        <trans-unit id="0b868a0b995363e52f99179ab5b2eb1da4495ee3" translate="yes" xml:space="preserve">
          <source>For example, suppose &lt;code&gt;sp_input&lt;/code&gt; has shape &lt;code&gt;[5, 6]&lt;/code&gt; and non-empty values:</source>
          <target state="translated">Por ejemplo, supongamos que &lt;code&gt;sp_input&lt;/code&gt; tiene forma &lt;code&gt;[5, 6]&lt;/code&gt; y valores no vac&amp;iacute;os:</target>
        </trans-unit>
        <trans-unit id="4b8890d00c239dfe3d4938b6c67d2e0e8fe86301" translate="yes" xml:space="preserve">
          <source>For example, suppose that &lt;code&gt;data&lt;/code&gt; has data type &lt;a href=&quot;../tf#int32&quot;&gt;&lt;code&gt;tf.int32&lt;/code&gt;&lt;/a&gt; and shape (2, 3, 4), and that the fingerprint method is &lt;code&gt;farmhash64&lt;/code&gt;. In this case, the output shape is (2, 8), where 2 is the batch dimension size of &lt;code&gt;data&lt;/code&gt;, and 8 is the size of each fingerprint value in bytes. &lt;code&gt;output[0, :]&lt;/code&gt; is generated from 12 integers in &lt;code&gt;data[0, :, :]&lt;/code&gt; and similarly &lt;code&gt;output[1, :]&lt;/code&gt; is generated from other 12 integers in &lt;code&gt;data[1, :, :]&lt;/code&gt;.</source>
          <target state="translated">Por ejemplo, suponga que los &lt;code&gt;data&lt;/code&gt; tienen el tipo de datos &lt;a href=&quot;../tf#int32&quot;&gt; &lt;code&gt;tf.int32&lt;/code&gt; &lt;/a&gt; y shape (2, 3, 4), y que el m&amp;eacute;todo de huellas digitales es &lt;code&gt;farmhash64&lt;/code&gt; . En este caso, la forma de salida es (2, 8), donde 2 es el tama&amp;ntilde;o de la dimensi&amp;oacute;n del lote de &lt;code&gt;data&lt;/code&gt; y 8 es el tama&amp;ntilde;o de cada valor de huella digital en bytes. &lt;code&gt;output[0, :]&lt;/code&gt; se genera a partir de 12 enteros en los &lt;code&gt;data[0, :, :]&lt;/code&gt; y de manera similar la &lt;code&gt;output[1, :]&lt;/code&gt; se genera a partir de otros 12 enteros en los &lt;code&gt;data[1, :, :]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="495460b2d49d23df61667d5a8e90f92bf6025daa" translate="yes" xml:space="preserve">
          <source>For example, suppose that &lt;code&gt;data&lt;/code&gt; has data type &lt;code&gt;DT_INT32&lt;/code&gt; and shape (2, 3, 4), and that the fingerprint method is &lt;code&gt;farmhash64&lt;/code&gt;. In this case, the output shape is (2, 8), where 2 is the batch dimension size of &lt;code&gt;data&lt;/code&gt;, and 8 is the size of each fingerprint value in bytes. &lt;code&gt;output[0, :]&lt;/code&gt; is generated from 12 integers in &lt;code&gt;data[0, :, :]&lt;/code&gt; and similarly &lt;code&gt;output[1, :]&lt;/code&gt; is generated from other 12 integers in &lt;code&gt;data[1, :, :]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb886fc90913d3858a07b6c81699df2c93cbae46" translate="yes" xml:space="preserve">
          <source>For example, suppose the logical sum of two sparse operands is (densified):</source>
          <target state="translated">Por ejemplo,supongamos que la suma lógica de dos operandos dispersos es (densificada):</target>
        </trans-unit>
        <trans-unit id="4589e17a235fe89004e5860f53c4fa2f48fab5f8" translate="yes" xml:space="preserve">
          <source>For example, suppose there are 2 TPU replicas: replica 0 receives input: &lt;code&gt;[[A, B]]&lt;/code&gt; replica 1 receives input: &lt;code&gt;[[C, D]]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da5af5e9268978110edfe81515e943cf23149b6d" translate="yes" xml:space="preserve">
          <source>For example, suppose there are 4 TPU instances: &lt;code&gt;[A, B, C, D]&lt;/code&gt;. Passing source_target_pairs=&lt;code&gt;[[0,1],[1,2],[2,3],[3,0]]&lt;/code&gt; gets the outputs: &lt;code&gt;[D, A, B, C]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b1da1c1eaf2bc599840d6f5ba841c57a047114f" translate="yes" xml:space="preserve">
          <source>For example, suppose there are 8 TPU instances: &lt;code&gt;[A, B, C, D, E, F, G, H]&lt;/code&gt;. Passing group_assignment=&lt;code&gt;[[0,2,4,6],[1,3,5,7]]&lt;/code&gt; sets &lt;code&gt;A, C, E, G&lt;/code&gt; as group 0, and &lt;code&gt;B, D, F, H&lt;/code&gt; as group 1. Thus we get the outputs: &lt;code&gt;[A+C+E+G, B+D+F+H, A+C+E+G, B+D+F+H, A+C+E+G, B+D+F+H, A+C+E+G, B+D+F+H]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e241e14b323a360c93e117165ee51f625869bb65" translate="yes" xml:space="preserve">
          <source>For example, suppose we have a file 'my_file0.csv' with four CSV columns of different data types:</source>
          <target state="translated">Por ejemplo,supongamos que tenemos un archivo 'mi_archivo0.csv' con cuatro columnas CSV de diferentes tipos de datos:</target>
        </trans-unit>
        <trans-unit id="803f7401710e9c763ad1dc8693918757b743ae6b" translate="yes" xml:space="preserve">
          <source>For example, the RMSprop optimizer for this simple model returns a list of three values-- the iteration count, followed by the root-mean-square value of the kernel and bias of the single Dense layer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e264f201548e6c6b9b5c296149b210ac828d99c0" translate="yes" xml:space="preserve">
          <source>For example, the RMSprop optimizer for this simple model takes a list of three values-- the iteration count, followed by the root-mean-square value of the kernel and bias of the single Dense layer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6fbd097fdd11950b7cadc34f9682795f00f4e27" translate="yes" xml:space="preserve">
          <source>For example, the desired output for the following 4-by-4 kernel:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0636239203f94658f87029781558265ccc3966ab" translate="yes" xml:space="preserve">
          <source>For example, the desired output for the following 4-by-4 kernel::</source>
          <target state="translated">Por ejemplo,la salida deseada para el siguiente núcleo de 4 por 4::</target>
        </trans-unit>
        <trans-unit id="dd21ccc094cad8a87d4c4eacb04b552c571f6bf7" translate="yes" xml:space="preserve">
          <source>For example, the returned matrix &lt;code&gt;A&lt;/code&gt; can be used to right-multiply a spectrogram &lt;code&gt;S&lt;/code&gt; of shape &lt;code&gt;[frames, num_spectrogram_bins]&lt;/code&gt; of linear scale spectrum values (e.g. STFT magnitudes) to generate a &quot;mel spectrogram&quot; &lt;code&gt;M&lt;/code&gt; of shape &lt;code&gt;[frames, num_mel_bins]&lt;/code&gt;.</source>
          <target state="translated">Por ejemplo, la matriz &lt;code&gt;A&lt;/code&gt; devuelta se puede utilizar para multiplicar por la derecha un espectrograma &lt;code&gt;S&lt;/code&gt; de forma &lt;code&gt;[frames, num_spectrogram_bins]&lt;/code&gt; de valores de espectro de escala lineal (por ejemplo, magnitudes STFT) para generar un &quot;espectrograma mel&quot; &lt;code&gt;M&lt;/code&gt; de forma &lt;code&gt;[frames, num_mel_bins]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db3131b06d6d3d95a5212d36111977d0f86b08dc" translate="yes" xml:space="preserve">
          <source>For example, this error might be raised if a per-user quota is exhausted, or perhaps the entire file system is out of space.</source>
          <target state="translated">Por ejemplo,este error podría plantearse si se agota una cuota por usuario,o tal vez todo el sistema de archivos está fuera de espacio.</target>
        </trans-unit>
        <trans-unit id="54823754fbaf34b915d76fccb6e9c1dc44f28481" translate="yes" xml:space="preserve">
          <source>For example, this may be raised by running a &lt;code&gt;tf.WholeFileReader.read&lt;/code&gt; operation, if the file is truncated while it is being read.</source>
          <target state="translated">Por ejemplo, esto se puede &lt;code&gt;tf.WholeFileReader.read&lt;/code&gt; ejecutando una operaci&amp;oacute;n tf.WholeFileReader.read , si el archivo se trunca mientras se est&amp;aacute; leyendo.</target>
        </trans-unit>
        <trans-unit id="ba4a59b5af2c2bc4994c4eadbe6ed4b4b272e9f3" translate="yes" xml:space="preserve">
          <source>For example, this simple dense layer does not require any additional work to support mixed precision or float64. Keras automatically casts the inputs and variable to the appropriate dtype.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b4b0afbf5ba933c3cb43f3500122fd6f86887fd" translate="yes" xml:space="preserve">
          <source>For example, to create a 4 x 4 linear operator combined of three 2 x 2 operators:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abbb5690c25366ae4f227979e99899132fb6b656" translate="yes" xml:space="preserve">
          <source>For example, to define a new Python op called &lt;code&gt;my_op&lt;/code&gt;:</source>
          <target state="translated">Por ejemplo, para definir una nueva &lt;code&gt;my_op&lt;/code&gt; Python llamada my_op :</target>
        </trans-unit>
        <trans-unit id="72eb7a551315d06a0972d21f1c1b460b5d38b044" translate="yes" xml:space="preserve">
          <source>For example, to define a new summary op called &lt;code&gt;my_op&lt;/code&gt;:</source>
          <target state="translated">Por ejemplo, para definir una nueva &lt;code&gt;my_op&lt;/code&gt; resumen llamada my_op :</target>
        </trans-unit>
        <trans-unit id="2965f0eb0a6433fd2e2e4ad410d8862a35002793" translate="yes" xml:space="preserve">
          <source>For example, to set the device filters for a parameter server cluster:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66fdf1bdfa059fe195251be30a7a3ab0c36ff0bc" translate="yes" xml:space="preserve">
          <source>For example, user can select profiler nodes placed on gpu:0 with: &lt;code&gt;account_type_regexes=['.*gpu:0.*']&lt;/code&gt;</source>
          <target state="translated">Por ejemplo, el usuario puede seleccionar los nodos del generador de perfiles ubicados en gpu: 0 con: &lt;code&gt;account_type_regexes=['.*gpu:0.*']&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="386f9efb3adea5d954835eac08e3b8fcac5cfc82" translate="yes" xml:space="preserve">
          <source>For example, we can represent the following 2D &lt;code&gt;SparseTensor&lt;/code&gt;</source>
          <target state="translated">Por ejemplo, podemos representar el siguiente &lt;code&gt;SparseTensor&lt;/code&gt; 2D</target>
        </trans-unit>
        <trans-unit id="47f6cacac9bb0941442b9ab6365d7dd1f22cf231" translate="yes" xml:space="preserve">
          <source>For example, with &lt;code&gt;W&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;Y&lt;/code&gt;, &lt;code&gt;Z&lt;/code&gt; each block circulant,</source>
          <target state="translated">Por ejemplo, con &lt;code&gt;W&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; , &lt;code&gt;Y&lt;/code&gt; , &lt;code&gt;Z&lt;/code&gt; cada bloque circula,</target>
        </trans-unit>
        <trans-unit id="b91edd5cdc9ee891969b8b38deeabdcc71594122" translate="yes" xml:space="preserve">
          <source>For example, with &lt;code&gt;W&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;Y&lt;/code&gt;, &lt;code&gt;Z&lt;/code&gt; each circulant,</source>
          <target state="translated">Por ejemplo, con &lt;code&gt;W&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; , &lt;code&gt;Y&lt;/code&gt; , &lt;code&gt;Z&lt;/code&gt; cada circulante,</target>
        </trans-unit>
        <trans-unit id="4d1e66a246a36b7e8a1cc0afa1a8ecb4016d097b" translate="yes" xml:space="preserve">
          <source>For example, with &lt;code&gt;new_vocab_file&lt;/code&gt; a text file containing each of the following elements on a single line: &lt;code&gt;[f0, f1, f2, f3]&lt;/code&gt;, old_vocab_file = [f1, f0, f3], &lt;code&gt;num_new_vocab = 3, new_vocab_offset = 1&lt;/code&gt;, the returned remapping would be &lt;code&gt;[0, -1, 2]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59bbe6de1d6b96b3f8288dbb5f70eca92be21e1f" translate="yes" xml:space="preserve">
          <source>For example, within a &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;c = tf.matmul(a, b)&lt;/code&gt; creates an &lt;code&gt;Operation&lt;/code&gt; of type &quot;MatMul&quot; that takes tensors &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; as input, and produces &lt;code&gt;c&lt;/code&gt; as output.</source>
          <target state="translated">Por ejemplo, dentro de un &lt;a href=&quot;function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;c = tf.matmul(a, b)&lt;/code&gt; crea una &lt;code&gt;Operation&lt;/code&gt; de tipo &quot;MatMul&quot; que tiene tensores &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; como entrada, y produce &lt;code&gt;c&lt;/code&gt; como salida.</target>
        </trans-unit>
        <trans-unit id="798a25ee68143b917f057d252e6a3be788b95a21" translate="yes" xml:space="preserve">
          <source>For example, you can use &lt;a href=&quot;../../../../data/dataset#interleave&quot;&gt;&lt;code&gt;Dataset.interleave()&lt;/code&gt;&lt;/a&gt; to process many input files concurrently:</source>
          <target state="translated">Por ejemplo, puede usar &lt;a href=&quot;../../../../data/dataset#interleave&quot;&gt; &lt;code&gt;Dataset.interleave()&lt;/code&gt; &lt;/a&gt; para procesar muchos archivos de entrada al mismo tiempo:</target>
        </trans-unit>
        <trans-unit id="62bc270e8147fe9b0d27fc9ede5facea85ba5170" translate="yes" xml:space="preserve">
          <source>For example, you can use &lt;a href=&quot;../../../data/dataset#interleave&quot;&gt;&lt;code&gt;Dataset.interleave()&lt;/code&gt;&lt;/a&gt; to process many input files concurrently:</source>
          <target state="translated">Por ejemplo, puede usar &lt;a href=&quot;../../../data/dataset#interleave&quot;&gt; &lt;code&gt;Dataset.interleave()&lt;/code&gt; &lt;/a&gt; para procesar muchos archivos de entrada al mismo tiempo:</target>
        </trans-unit>
        <trans-unit id="0a8cdf19717ec8bf5f04585f7d033f7a2610e6d2" translate="yes" xml:space="preserve">
          <source>For example, you can use &lt;a href=&quot;../dataset#interleave&quot;&gt;&lt;code&gt;Dataset.interleave()&lt;/code&gt;&lt;/a&gt; to process many input files concurrently:</source>
          <target state="translated">Por ejemplo, puede usar &lt;a href=&quot;../dataset#interleave&quot;&gt; &lt;code&gt;Dataset.interleave()&lt;/code&gt; &lt;/a&gt; para procesar muchos archivos de entrada al mismo tiempo:</target>
        </trans-unit>
        <trans-unit id="5898266aaebf0c43713533e3d18bf9ec4db717f3" translate="yes" xml:space="preserve">
          <source>For example, you can use &lt;a href=&quot;dataset#interleave&quot;&gt;&lt;code&gt;Dataset.interleave()&lt;/code&gt;&lt;/a&gt; to process many input files concurrently:</source>
          <target state="translated">Por ejemplo, puede usar &lt;a href=&quot;dataset#interleave&quot;&gt; &lt;code&gt;Dataset.interleave()&lt;/code&gt; &lt;/a&gt; para procesar muchos archivos de entrada al mismo tiempo:</target>
        </trans-unit>
        <trans-unit id="6ded0202a2e44d8d69da3c4dc5a14b181602b6ff" translate="yes" xml:space="preserve">
          <source>For example, you can use &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/data/Dataset#interleave&quot;&gt;&lt;code&gt;Dataset.interleave()&lt;/code&gt;&lt;/a&gt; to process many input files concurrently:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="a925ece6d9c348c8aa9316dcdeed531900dee368" translate="yes" xml:space="preserve">
          <source>For example: if &lt;code&gt;filepath&lt;/code&gt; is &lt;code&gt;weights.{epoch:02d}-{val_loss:.2f}.hdf5&lt;/code&gt;, then the model checkpoints will be saved with the epoch number and the validation loss in the filename.</source>
          <target state="translated">Por ejemplo: si &lt;code&gt;filepath&lt;/code&gt; es &lt;code&gt;weights.{epoch:02d}-{val_loss:.2f}.hdf5&lt;/code&gt; , entonces los puntos de control del modelo se guardar&amp;aacute;n con el n&amp;uacute;mero de &amp;eacute;poca y la p&amp;eacute;rdida de validaci&amp;oacute;n en el nombre del archivo.</target>
        </trans-unit>
        <trans-unit id="617a3ed2e3e514be878c5bb15678122dfc4d8ecd" translate="yes" xml:space="preserve">
          <source>For f(*args, **kwargs), this supports gradients with respect to args or kwargs, but kwargs are currently only supported in eager-mode. Note that for keras layer and model objects, this is handled automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e701a0677a91df738cbd270184ad84b85cb6a3f" translate="yes" xml:space="preserve">
          <source>For f(*args, **kwargs), this supports gradients with respect to args, or to gradients with respect to any variables residing in the kwarg 'variables'. Note that for keras layer and model objects, this is handled automatically.</source>
          <target state="translated">Para f(*args,**kwargs),esto soporta gradientes con respecto a los args,o a los gradientes con respecto a cualquier variable que resida en las 'variables' kwarg.Observe que para los objetos de capa y modelo de keras,esto se maneja automáticamente.</target>
        </trans-unit>
        <trans-unit id="f4b53b836d997d79180b7e3d91c8e783a2730a27" translate="yes" xml:space="preserve">
          <source>For floats, the default range is &lt;code&gt;[0, 1)&lt;/code&gt;. For ints, at least &lt;code&gt;maxval&lt;/code&gt; must be specified explicitly.</source>
          <target state="translated">Para flotantes, el rango predeterminado es &lt;code&gt;[0, 1)&lt;/code&gt; . Para ints, al menos &lt;code&gt;maxval&lt;/code&gt; debe especificarse expl&amp;iacute;citamente.</target>
        </trans-unit>
        <trans-unit id="356031776c93a08469e52e6e9a422b36aba24087" translate="yes" xml:space="preserve">
          <source>For full-range (i.e. inclusive of both max and min) random integers, pass &lt;code&gt;minval=None&lt;/code&gt; and &lt;code&gt;maxval=None&lt;/code&gt; with an integer &lt;code&gt;dtype&lt;/code&gt;. For an integer dtype either both &lt;code&gt;minval&lt;/code&gt; and &lt;code&gt;maxval&lt;/code&gt; must be &lt;code&gt;None&lt;/code&gt; or neither may be &lt;code&gt;None&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a56bcc5ab9d5be952b7e9f40a7d23fa0400b6d0" translate="yes" xml:space="preserve">
          <source>For full-range random integers, pass &lt;code&gt;minval=None&lt;/code&gt; and &lt;code&gt;maxval=None&lt;/code&gt; with an integer &lt;code&gt;dtype&lt;/code&gt; (for integer dtypes, &lt;code&gt;minval&lt;/code&gt; and &lt;code&gt;maxval&lt;/code&gt; must be both &lt;code&gt;None&lt;/code&gt; or both not &lt;code&gt;None&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04d421a51ab8b8a27bf19870cac97753296986e8" translate="yes" xml:space="preserve">
          <source>For future expansion. The axis to compute the DCT along. Must be &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fd166b7a90884f7ea7652e9d0c336832f3c0f77" translate="yes" xml:space="preserve">
          <source>For future expansion. The length of the transform. Must be &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e111c995974685355c526b35bd247aea54214a0f" translate="yes" xml:space="preserve">
          <source>For gamma greater than 1, the histogram will shift towards left and the output image will be darker than the input image. For gamma less than 1, the histogram will shift towards right and the output image will be brighter than the input image.</source>
          <target state="translated">Para un gamma mayor que 1,el histograma se desplazará hacia la izquierda y la imagen de salida será más oscura que la de entrada.Para un gamma inferior a 1,el histograma se desplazará hacia la derecha y la imagen de salida será más brillante que la de entrada.</target>
        </trans-unit>
        <trans-unit id="b943cfdd2ff2928a3736e51095c0c36b03cbbceb" translate="yes" xml:space="preserve">
          <source>For greater flexibility, use &quot;Iterator&quot; and &quot;MakeIterator&quot; to define an iterator using an arbitrary subgraph, which may capture tensors (including fed values) as parameters, and which may be reset multiple times by rerunning &quot;MakeIterator&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a9f804d2c5657eeaad57f76da30d8419d9f80b2" translate="yes" xml:space="preserve">
          <source>For information about the valid syntax of device name strings, see the documentation in &lt;a href=&quot;https://www.tensorflow.org/code/tensorflow/core/util/device_name_utils.h&quot;&gt;&lt;code&gt;DeviceNameUtils&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para obtener informaci&amp;oacute;n sobre la sintaxis v&amp;aacute;lida de las cadenas de nombres de dispositivos, consulte la documentaci&amp;oacute;n en &lt;a href=&quot;https://www.tensorflow.org/code/tensorflow/core/util/device_name_utils.h&quot;&gt; &lt;code&gt;DeviceNameUtils&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e34ec3911430ce7f98ae14651feabc2f68db9179" translate="yes" xml:space="preserve">
          <source>For input dictionary &lt;code&gt;features&lt;/code&gt;, &lt;code&gt;features[key]&lt;/code&gt; is either &lt;code&gt;Tensor&lt;/code&gt; or &lt;code&gt;SparseTensor&lt;/code&gt;. If &lt;code&gt;Tensor&lt;/code&gt;, missing values can be represented by &lt;code&gt;-1&lt;/code&gt; for int and &lt;code&gt;''&lt;/code&gt; for string, which will be dropped by this feature column.</source>
          <target state="translated">Para las &lt;code&gt;features&lt;/code&gt; diccionario de entrada , las &lt;code&gt;features[key]&lt;/code&gt; son &lt;code&gt;Tensor&lt;/code&gt; o &lt;code&gt;SparseTensor&lt;/code&gt; . Si es &lt;code&gt;Tensor&lt;/code&gt; , los valores faltantes se pueden representar con &lt;code&gt;-1&lt;/code&gt; para int y &lt;code&gt;''&lt;/code&gt; para cadena, que se eliminar&amp;aacute; en esta columna de caracter&amp;iacute;sticas.</target>
        </trans-unit>
        <trans-unit id="972f34fd8ce79a7530b5410304e5c7ff8345495d" translate="yes" xml:space="preserve">
          <source>For instance, &lt;a href=&quot;iteratorspec&quot;&gt;&lt;code&gt;tf.data.IteratorSpec&lt;/code&gt;&lt;/a&gt; can be used to define a tf.function that takes &lt;a href=&quot;iterator&quot;&gt;&lt;code&gt;tf.data.Iterator&lt;/code&gt;&lt;/a&gt; as an input argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6ac02ce36aad1c0613f5ac2778adacecfd565ae" translate="yes" xml:space="preserve">
          <source>For instance, &lt;a href=&quot;optionalspec&quot;&gt;&lt;code&gt;tf.OptionalSpec&lt;/code&gt;&lt;/a&gt; can be used to define a tf.function that takes &lt;a href=&quot;experimental/optional&quot;&gt;&lt;code&gt;tf.experimental.Optional&lt;/code&gt;&lt;/a&gt; as an input argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd184a755e96827d1f8c5b725d00ffce6156808d" translate="yes" xml:space="preserve">
          <source>For instance, if &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; are Keras tensors, it becomes possible to do: &lt;code&gt;model = Model(input=[a, b], output=c)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5e4d4d23c7dda349004192ebc96c46b6465ca75" translate="yes" xml:space="preserve">
          <source>For instance, if &lt;code&gt;params&lt;/code&gt; is a 5x2 matrix:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d566a2f8f613dd39800087ce7bc50e2d5f86120" translate="yes" xml:space="preserve">
          <source>For instance, if a, b and c are Keras tensors, it becomes possible to do: &lt;code&gt;model = Model(input=[a, b], output=c)&lt;/code&gt;</source>
          <target state="translated">Por ejemplo, si a, byc son tensores de Keras, es posible hacer: &lt;code&gt;model = Model(input=[a, b], output=c)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0e53703556bacc5b9f2dd5c8a308f65648989002" translate="yes" xml:space="preserve">
          <source>For instance, if params is a 10x20 matrix, and sp_ids / sp_weights are</source>
          <target state="translated">Por ejemplo,si los parámetros son una matriz de 10x20,y los sp_ids/sp_weights son</target>
        </trans-unit>
        <trans-unit id="cc75bd8580ca757aae48910bd54d05e3c0b7bbe2" translate="yes" xml:space="preserve">
          <source>For instance, if your dataset contains 10,000 elements but &lt;code&gt;buffer_size&lt;/code&gt; is set to 1,000, then &lt;code&gt;shuffle&lt;/code&gt; will initially select a random element from only the first 1,000 elements in the buffer. Once an element is selected, its space in the buffer is replaced by the next (i.e. 1,001-st) element, maintaining the 1,000 element buffer.</source>
          <target state="translated">Por ejemplo, si su conjunto de datos contiene 10,000 elementos pero &lt;code&gt;buffer_size&lt;/code&gt; se establece en 1,000, entonces &lt;code&gt;shuffle&lt;/code&gt; seleccionar&amp;aacute; inicialmente un elemento aleatorio de solo los primeros 1,000 elementos en el b&amp;uacute;fer. Una vez que se selecciona un elemento, su espacio en el b&amp;uacute;fer se reemplaza por el siguiente elemento (es decir, 1,001 st), manteniendo el b&amp;uacute;fer de 1000 elementos.</target>
        </trans-unit>
        <trans-unit id="abc897209b2f98b7966665fa36a5eddbbc44f66d" translate="yes" xml:space="preserve">
          <source>For instance:</source>
          <target state="translated">Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="0a0b5cd490edef9c44f6a6d5414aa3f055e77d75" translate="yes" xml:space="preserve">
          <source>For invalid/unknown format arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f9023a39798cc65b443278b72b316a68e41f333" translate="yes" xml:space="preserve">
          <source>For many models, each layer's policy will have the same compute dtype and variable dtype, which will typically be float32. In this case, we refer to the singular dtype as the layer's dtype, which can be queried by the property &lt;a href=&quot;../../layers/layer#dtype&quot;&gt;&lt;code&gt;tf.keras.layers.Layer.dtype&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para muchos modelos, la pol&amp;iacute;tica de cada capa tendr&amp;aacute; el mismo tipo de c&amp;aacute;lculo y tipo de variable, que normalmente ser&amp;aacute; float32. En este caso, nos referimos al dtype singular como dtype de la capa, que puede ser consultado por la propiedad &lt;a href=&quot;../../layers/layer#dtype&quot;&gt; &lt;code&gt;tf.keras.layers.Layer.dtype&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e88bb5e1430cab829924a15faf891ea4f1ef4619" translate="yes" xml:space="preserve">
          <source>For matrices (resp. higher rank input), computes the entries which is the nth-smallest value in each row (resp. vector along the last dimension). Thus,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a9115e76a0ba9659e12e140504c8f7f39148287" translate="yes" xml:space="preserve">
          <source>For matrices (resp. higher rank input), computes the top &lt;code&gt;k&lt;/code&gt; entries in each row (resp. vector along the last dimension). Thus,</source>
          <target state="translated">Para matrices (resp. Entrada de rango superior), calcula las &lt;code&gt;k&lt;/code&gt; entradas superiores en cada fila (resp. Vector a lo largo de la &amp;uacute;ltima dimensi&amp;oacute;n). As&amp;iacute;,</target>
        </trans-unit>
        <trans-unit id="f6f81428f9faf616b5f58bf1dfb8c2ee23290062" translate="yes" xml:space="preserve">
          <source>For more details on fractional max pooling, see this paper: &lt;a href=&quot;http://arxiv.org/abs/1412.6071&quot;&gt;Benjamin Graham, Fractional Max-Pooling&lt;/a&gt;</source>
          <target state="translated">Para obtener m&amp;aacute;s detalles sobre la agrupaci&amp;oacute;n m&amp;aacute;xima fraccional, consulte este art&amp;iacute;culo: &lt;a href=&quot;http://arxiv.org/abs/1412.6071&quot;&gt;Benjamin Graham, Fractional Max-Pooling&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="21bd2ea7c74cf7f28ac3c97e52843c839e601f0f" translate="yes" xml:space="preserve">
          <source>For more details on fractional max pooling, see this paper: &lt;a href=&quot;https://arxiv.org/abs/1412.6071&quot;&gt;Benjamin Graham, Fractional Max-Pooling&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdc341899055084bcb94f72be25a2efd912ef0ce" translate="yes" xml:space="preserve">
          <source>For more details on warm-start configuration, see &lt;a href=&quot;../../../estimator/warmstartsettings&quot;&gt;&lt;code&gt;tf.estimator.WarmStartSettings&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s detalles sobre la configuraci&amp;oacute;n de inicio en caliente, consulte &lt;a href=&quot;../../../estimator/warmstartsettings&quot;&gt; &lt;code&gt;tf.estimator.WarmStartSettings&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1e3c977af7155e901bdef759f3dc14b55e9fc4b7" translate="yes" xml:space="preserve">
          <source>For more details on warm-start configuration, see &lt;a href=&quot;warmstartsettings&quot;&gt;&lt;code&gt;tf.estimator.WarmStartSettings&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s detalles sobre la configuraci&amp;oacute;n de inicio en caliente, consulte &lt;a href=&quot;warmstartsettings&quot;&gt; &lt;code&gt;tf.estimator.WarmStartSettings&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="13a2417d18055bf8846c48234727817863de443c" translate="yes" xml:space="preserve">
          <source>For more details, see the documentation for &lt;code&gt;keras_style_scope&lt;/code&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s detalles, consulte la documentaci&amp;oacute;n de &lt;code&gt;keras_style_scope&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc3a84c33cbfb26e5b4fe97277347db008f299e4" translate="yes" xml:space="preserve">
          <source>For more information about creating layers, see the guide &lt;a href=&quot;https://www.tensorflow.org/guide/keras/custom_layers_and_models&quot;&gt;Writing custom layers and models with Keras&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="152f8ea26d1cff79ab2d01228bf1bdbd0f39e953" translate="yes" xml:space="preserve">
          <source>For more information on eager execution, see the &lt;a href=&quot;https://tensorflow.org/guide/eager&quot;&gt;Eager guide&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre la ejecuci&amp;oacute;n ansiosa, consulte la &lt;a href=&quot;https://tensorflow.org/guide/eager&quot;&gt;gu&amp;iacute;a Eager&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="900a1418668618874090d4e9686dce63aca4019d" translate="yes" xml:space="preserve">
          <source>For more information see: &lt;a href=&quot;https://github.com/catapult-project/catapult/blob/master/tracing/README.md&quot;&gt;https://github.com/catapult-project/catapult/blob/master/tracing/README.md&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a3c4bae8cff17665d7c40bbc999f6a1d5c25c78" translate="yes" xml:space="preserve">
          <source>For more information see: https://github.com/catapult-project/catapult/blob/master/tracing/README.md</source>
          <target state="translated">Para más información,véase:https://github.com/catapult-project/catapult/blob/master/tracing/README.md</target>
        </trans-unit>
        <trans-unit id="4a2de7b882a594ae2b76e69009622fd319f6d72c" translate="yes" xml:space="preserve">
          <source>For more information, please see &lt;a href=&quot;../../../../distribute/cluster_resolver/clusterresolver&quot;&gt;&lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt;&lt;/a&gt;'s API docstring.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c8bf9775f80fdadad83c8c4c855a86b67b010f7" translate="yes" xml:space="preserve">
          <source>For more information, please see &lt;a href=&quot;../../../distribute/cluster_resolver/clusterresolver&quot;&gt;&lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt;&lt;/a&gt;'s API docstring.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f363dc145e0cc1796e063aa7c7c95c22e2b1d829" translate="yes" xml:space="preserve">
          <source>For more information, please see &lt;a href=&quot;../cluster_resolver/clusterresolver&quot;&gt;&lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt;&lt;/a&gt;'s API docstring.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0a9d42be5d971abb321854a800de6f708fb0dd0" translate="yes" xml:space="preserve">
          <source>For more information, please see &lt;a href=&quot;cluster_resolver/clusterresolver&quot;&gt;&lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt;&lt;/a&gt;'s API docstring.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1a73ddb9ef63644514bdf8fb1c157f4573b5f92" translate="yes" xml:space="preserve">
          <source>For more information, please see &lt;a href=&quot;clusterresolver&quot;&gt;&lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt;&lt;/a&gt;'s class doc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55bb2f27fa02e7cb1d336fbb0fd9c36f4d1660c5" translate="yes" xml:space="preserve">
          <source>For more information, please see &lt;a href=&quot;clusterresolver&quot;&gt;&lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt;&lt;/a&gt;'s class docstring.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b43d393bddf0580f867617eb6c2e2f89c938fa23" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;a href=&quot;https://www.tensorflow.org/guide/autograph&quot;&gt;AutoGraph guide&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n, consulte la &lt;a href=&quot;https://www.tensorflow.org/guide/autograph&quot;&gt;gu&amp;iacute;a AutoGraph&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e65c930b04240141dad57bca65273288271b2809" translate="yes" xml:space="preserve">
          <source>For more on Tensors, see the &lt;a href=&quot;https://tensorflow.org/guide/tensor&quot;&gt;guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ec21b841a665c40f4c5e83efe27648e19e46e51" translate="yes" xml:space="preserve">
          <source>For ops such as matrix multiplication, inputs and weights must be of the same float type. This function validates that all &lt;code&gt;tensors&lt;/code&gt; are the same type, validates that type is &lt;code&gt;dtype&lt;/code&gt; (if supplied), and returns the type. Type must be a floating point type. If neither &lt;code&gt;tensors&lt;/code&gt; nor &lt;code&gt;dtype&lt;/code&gt; is supplied, the function will return &lt;a href=&quot;../dtypes#float32&quot;&gt;&lt;code&gt;dtypes.float32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para operaciones como la multiplicaci&amp;oacute;n de matrices, las entradas y los pesos deben ser del mismo tipo flotante. Esta funci&amp;oacute;n valida que todos los &lt;code&gt;tensors&lt;/code&gt; sean del mismo tipo, valida que el tipo sea &lt;code&gt;dtype&lt;/code&gt; (si se proporciona) y devuelve el tipo. El tipo debe ser un tipo de coma flotante. Si no se proporcionan &lt;code&gt;tensors&lt;/code&gt; ni &lt;code&gt;dtype&lt;/code&gt; , la funci&amp;oacute;n devolver&amp;aacute; &lt;a href=&quot;../dtypes#float32&quot;&gt; &lt;code&gt;dtypes.float32&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="825adbf912a447d1f0e6ca8ee392497c694816b6" translate="yes" xml:space="preserve">
          <source>For ops that have a well-defined gradient but are not yet implemented, no declaration should be made, and an error &lt;em&gt;must&lt;/em&gt; be thrown if an attempt to request its gradient is made.</source>
          <target state="translated">Para las operaciones que tienen un gradiente bien definido pero que a&amp;uacute;n no est&amp;aacute;n implementadas, no se debe realizar ninguna declaraci&amp;oacute;n y se &lt;em&gt;debe&lt;/em&gt; generar un error si se intenta solicitar su gradiente.</target>
        </trans-unit>
        <trans-unit id="3c54552d8b9297a0500954f1e7088d433c083309" translate="yes" xml:space="preserve">
          <source>For positive numbers, this function computes log((input - 1)!) for every element in the tensor. &lt;code&gt;lgamma(5) = log((5-1)!) = log(4!) = log(24) = 3.1780539&lt;/code&gt;</source>
          <target state="translated">Para n&amp;uacute;meros positivos, esta funci&amp;oacute;n calcula log ((input - 1)!) Para cada elemento en el tensor. &lt;code&gt;lgamma(5) = log((5-1)!) = log(4!) = log(24) = 3.1780539&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17614033a9da90968bc5248bce2e63241d0b5eef" translate="yes" xml:space="preserve">
          <source>For prediction, merges predictions and updates keys in prediction dict to a 2-tuple, &lt;code&gt;(head.name, prediction_key)&lt;/code&gt;. Merges &lt;code&gt;export_outputs&lt;/code&gt; such that by default the first head is served.</source>
          <target state="translated">Para la predicci&amp;oacute;n, fusiona las predicciones y actualiza las claves en el dictado de predicci&amp;oacute;n en una tupla de 2, &lt;code&gt;(head.name, prediction_key)&lt;/code&gt; . Fusiona &lt;code&gt;export_outputs&lt;/code&gt; de modo que, de forma predeterminada, se sirve el primer encabezado.</target>
        </trans-unit>
        <trans-unit id="367d3134a5e071179a22d4af24a5885a46b948f8" translate="yes" xml:space="preserve">
          <source>For prediction, the exported &lt;code&gt;MetaGraphDef&lt;/code&gt; will provide one &lt;code&gt;SignatureDef&lt;/code&gt; for each element of the &lt;code&gt;export_outputs&lt;/code&gt; dict returned from the &lt;code&gt;model_fn&lt;/code&gt;, named using the same keys. One of these keys is always &lt;code&gt;tf.saved_model.signature_constants.DEFAULT_SERVING_SIGNATURE_DEF_KEY&lt;/code&gt;, indicating which signature will be served when a serving request does not specify one. For each signature, the outputs are provided by the corresponding &lt;a href=&quot;../../../../estimator/export/exportoutput&quot;&gt;&lt;code&gt;tf.estimator.export.ExportOutput&lt;/code&gt;&lt;/a&gt;s, and the inputs are always the input receivers provided by the &lt;code&gt;serving_input_receiver_fn&lt;/code&gt;.</source>
          <target state="translated">Para la predicci&amp;oacute;n, el &lt;code&gt;MetaGraphDef&lt;/code&gt; exportado proporcionar&amp;aacute; un &lt;code&gt;SignatureDef&lt;/code&gt; para cada elemento del dict &lt;code&gt;export_outputs&lt;/code&gt; devuelto por &lt;code&gt;model_fn&lt;/code&gt; , nombrado usando las mismas claves. Una de estas claves es siempre &lt;code&gt;tf.saved_model.signature_constants.DEFAULT_SERVING_SIGNATURE_DEF_KEY&lt;/code&gt; , que indica qu&amp;eacute; firma se entregar&amp;aacute; cuando una solicitud de servicio no especifique una. Para cada firma, las salidas son proporcionadas por los correspondientes &lt;a href=&quot;../../../../estimator/export/exportoutput&quot;&gt; &lt;code&gt;tf.estimator.export.ExportOutput&lt;/code&gt; &lt;/a&gt; s, y las entradas son siempre los receptores de entrada proporcionados por &lt;code&gt;serving_input_receiver_fn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d910d10e5e5c18870b7b9be467a883825361a57a" translate="yes" xml:space="preserve">
          <source>For prediction, the exported &lt;code&gt;MetaGraphDef&lt;/code&gt; will provide one &lt;code&gt;SignatureDef&lt;/code&gt; for each element of the &lt;code&gt;export_outputs&lt;/code&gt; dict returned from the &lt;code&gt;model_fn&lt;/code&gt;, named using the same keys. One of these keys is always &lt;code&gt;tf.saved_model.signature_constants.DEFAULT_SERVING_SIGNATURE_DEF_KEY&lt;/code&gt;, indicating which signature will be served when a serving request does not specify one. For each signature, the outputs are provided by the corresponding &lt;a href=&quot;../../../estimator/export/exportoutput&quot;&gt;&lt;code&gt;tf.estimator.export.ExportOutput&lt;/code&gt;&lt;/a&gt;s, and the inputs are always the input receivers provided by the &lt;code&gt;serving_input_receiver_fn&lt;/code&gt;.</source>
          <target state="translated">Para la predicci&amp;oacute;n, el &lt;code&gt;MetaGraphDef&lt;/code&gt; exportado proporcionar&amp;aacute; un &lt;code&gt;SignatureDef&lt;/code&gt; para cada elemento del dict &lt;code&gt;export_outputs&lt;/code&gt; devuelto por &lt;code&gt;model_fn&lt;/code&gt; , nombrado usando las mismas claves. Una de estas claves es siempre &lt;code&gt;tf.saved_model.signature_constants.DEFAULT_SERVING_SIGNATURE_DEF_KEY&lt;/code&gt; , que indica qu&amp;eacute; firma se entregar&amp;aacute; cuando una solicitud de servicio no especifique una. Para cada firma, las salidas son proporcionadas por los correspondientes &lt;a href=&quot;../../../estimator/export/exportoutput&quot;&gt; &lt;code&gt;tf.estimator.export.ExportOutput&lt;/code&gt; &lt;/a&gt; s, y las entradas son siempre los receptores de entrada proporcionados por &lt;code&gt;serving_input_receiver_fn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="85e499998a4aff01940823b0150823a9caaab4eb" translate="yes" xml:space="preserve">
          <source>For prediction, the exported &lt;code&gt;MetaGraphDef&lt;/code&gt; will provide one &lt;code&gt;SignatureDef&lt;/code&gt; for each element of the &lt;code&gt;export_outputs&lt;/code&gt; dict returned from the &lt;code&gt;model_fn&lt;/code&gt;, named using the same keys. One of these keys is always &lt;code&gt;tf.saved_model.signature_constants.DEFAULT_SERVING_SIGNATURE_DEF_KEY&lt;/code&gt;, indicating which signature will be served when a serving request does not specify one. For each signature, the outputs are provided by the corresponding &lt;a href=&quot;../export/exportoutput&quot;&gt;&lt;code&gt;tf.estimator.export.ExportOutput&lt;/code&gt;&lt;/a&gt;s, and the inputs are always the input receivers provided by the &lt;code&gt;serving_input_receiver_fn&lt;/code&gt;.</source>
          <target state="translated">Para la predicci&amp;oacute;n, el &lt;code&gt;MetaGraphDef&lt;/code&gt; exportado proporcionar&amp;aacute; un &lt;code&gt;SignatureDef&lt;/code&gt; para cada elemento del dict &lt;code&gt;export_outputs&lt;/code&gt; devuelto por &lt;code&gt;model_fn&lt;/code&gt; , nombrado usando las mismas claves. Una de estas claves es siempre &lt;code&gt;tf.saved_model.signature_constants.DEFAULT_SERVING_SIGNATURE_DEF_KEY&lt;/code&gt; , que indica qu&amp;eacute; firma se entregar&amp;aacute; cuando una solicitud de servicio no especifique una. Para cada firma, las salidas son proporcionadas por los correspondientes &lt;a href=&quot;../export/exportoutput&quot;&gt; &lt;code&gt;tf.estimator.export.ExportOutput&lt;/code&gt; &lt;/a&gt; s, y las entradas son siempre los receptores de entrada proporcionados por &lt;code&gt;serving_input_receiver_fn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f2dca7789ee2c5012c2ae28c6f51ef0341736b8" translate="yes" xml:space="preserve">
          <source>For prediction, the exported &lt;code&gt;MetaGraphDef&lt;/code&gt; will provide one &lt;code&gt;SignatureDef&lt;/code&gt; for each element of the &lt;code&gt;export_outputs&lt;/code&gt; dict returned from the &lt;code&gt;model_fn&lt;/code&gt;, named using the same keys. One of these keys is always &lt;code&gt;tf.saved_model.signature_constants.DEFAULT_SERVING_SIGNATURE_DEF_KEY&lt;/code&gt;, indicating which signature will be served when a serving request does not specify one. For each signature, the outputs are provided by the corresponding &lt;a href=&quot;export/exportoutput&quot;&gt;&lt;code&gt;tf.estimator.export.ExportOutput&lt;/code&gt;&lt;/a&gt;s, and the inputs are always the input receivers provided by the &lt;code&gt;serving_input_receiver_fn&lt;/code&gt;.</source>
          <target state="translated">Para la predicci&amp;oacute;n, el &lt;code&gt;MetaGraphDef&lt;/code&gt; exportado proporcionar&amp;aacute; un &lt;code&gt;SignatureDef&lt;/code&gt; para cada elemento del dict &lt;code&gt;export_outputs&lt;/code&gt; devuelto por &lt;code&gt;model_fn&lt;/code&gt; , nombrado usando las mismas claves. Una de estas claves es siempre &lt;code&gt;tf.saved_model.signature_constants.DEFAULT_SERVING_SIGNATURE_DEF_KEY&lt;/code&gt; , que indica qu&amp;eacute; firma se entregar&amp;aacute; cuando una solicitud de servicio no especifique una. Para cada firma, las salidas son proporcionadas por los correspondientes &lt;a href=&quot;export/exportoutput&quot;&gt; &lt;code&gt;tf.estimator.export.ExportOutput&lt;/code&gt; &lt;/a&gt; s, y las entradas son siempre los receptores de entrada proporcionados por &lt;code&gt;serving_input_receiver_fn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51b640d64056e8e41f482c3d3c805d8ad85d361d" translate="yes" xml:space="preserve">
          <source>For python 2.x.</source>
          <target state="translated">Para pitón 2.x.</target>
        </trans-unit>
        <trans-unit id="6616ed4ca65ec91b81df8451d8cc7918059964cb" translate="yes" xml:space="preserve">
          <source>For regression: one-dimensional label.</source>
          <target state="translated">Para la regresión:etiqueta unidimensional.</target>
        </trans-unit>
        <trans-unit id="ebc60d85f1c75542a5be8407d74123940e50f678" translate="yes" xml:space="preserve">
          <source>For saving the input pipeline checkpoint alongside the model weights use &lt;a href=&quot;make_saveable_from_iterator&quot;&gt;&lt;code&gt;tf.data.experimental.make_saveable_from_iterator&lt;/code&gt;&lt;/a&gt; directly to create a &lt;code&gt;SaveableObject&lt;/code&gt; and add to the &lt;code&gt;SAVEABLE_OBJECTS&lt;/code&gt; collection. Note, however, that you will need to be careful not to restore the training iterator during eval. You can do that by not adding the iterator to the SAVEABLE_OBJECTS collector when building the eval graph.</source>
          <target state="translated">Para guardar el punto de control de la canalizaci&amp;oacute;n de entrada junto con los pesos del modelo, use &lt;a href=&quot;make_saveable_from_iterator&quot;&gt; &lt;code&gt;tf.data.experimental.make_saveable_from_iterator&lt;/code&gt; &lt;/a&gt; directamente para crear un &lt;code&gt;SaveableObject&lt;/code&gt; y agregarlo a la colecci&amp;oacute;n &lt;code&gt;SAVEABLE_OBJECTS&lt;/code&gt; . Sin embargo, tenga en cuenta que deber&amp;aacute; tener cuidado de no restaurar el iterador de entrenamiento durante eval. Puede hacerlo si no agrega el iterador al recopilador SAVEABLE_OBJECTS al crear el gr&amp;aacute;fico de evaluaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6616597fc49d1e10b07181ff6fbd22315bce9b2f" translate="yes" xml:space="preserve">
          <source>For string data, one should expect &lt;code&gt;Fingerprint(data) != Fingerprint(ReduceJoin(data))&lt;/code&gt; in general.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4040772dee03e98d438db586092ddda710d40777" translate="yes" xml:space="preserve">
          <source>For string data, one should expect &lt;code&gt;tf.fingerprint(data) != tf.fingerprint(tf.string.reduce_join(data))&lt;/code&gt; in general.</source>
          <target state="translated">Para datos de cadena, uno deber&amp;iacute;a esperar &lt;code&gt;tf.fingerprint(data) != tf.fingerprint(tf.string.reduce_join(data))&lt;/code&gt; en general.</target>
        </trans-unit>
        <trans-unit id="1aee93356a8ac03609dbb2efcc3b9bc6ffc3cf8f" translate="yes" xml:space="preserve">
          <source>For the above example, make_parse_example_spec would return the dict:</source>
          <target state="translated">Para el ejemplo anterior,make_parse_example_spec devolvería el dictado:</target>
        </trans-unit>
        <trans-unit id="06ccd3d90a70db2dc3e63a184d4c540501fffaaf" translate="yes" xml:space="preserve">
          <source>For the advanced use cases like model parallelism, you can set &lt;code&gt;experimental_device_assignment&lt;/code&gt; argument when creating TPUStrategy to specify number of replicas and number of logical devices. Below is an example to initialize TPU system with 2 logical devices and 1 replica.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0235be247e65fa625cc59d166e2a6820d050e19f" translate="yes" xml:space="preserve">
          <source>For the content in &lt;code&gt;TF_CONFIG&lt;/code&gt;, assume that the training cluster spec looks like:</source>
          <target state="translated">Para el contenido de &lt;code&gt;TF_CONFIG&lt;/code&gt; , suponga que la especificaci&amp;oacute;n del cl&amp;uacute;ster de entrenamiento tiene este aspecto:</target>
        </trans-unit>
        <trans-unit id="d988a3e29b8ed246ee76e0c2e493b1b397597de1" translate="yes" xml:space="preserve">
          <source>For the idea of warm starts here controlled by &lt;code&gt;num_periods&lt;/code&gt;, see [Loshchilov &amp;amp; Hutter, ICLR2016] SGDR: Stochastic Gradient Descent with Warm Restarts. &lt;a href=&quot;https://arxiv.org/abs/1608.03983&quot;&gt;https://arxiv.org/abs/1608.03983&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f06a3bf9b1afd83f2dc01b9bce2b59a3031f004" translate="yes" xml:space="preserve">
          <source>For the idea of warm starts here controlled by &lt;code&gt;num_periods&lt;/code&gt;, see [Loshchilov &amp;amp; Hutter, ICLR2016] SGDR: Stochastic Gradient Descent with Warm Restarts. https://arxiv.org/abs/1608.03983</source>
          <target state="translated">Para la idea de inicios en caliente controlados por &lt;code&gt;num_periods&lt;/code&gt; , consulte [Loshchilov &amp;amp; Hutter, ICLR2016] SGDR: Descenso de gradiente estoc&amp;aacute;stico con reinicios en caliente. https://arxiv.org/abs/1608.03983</target>
        </trans-unit>
        <trans-unit id="44813089d644664d33f4de2b9592fffa98ddb5ec" translate="yes" xml:space="preserve">
          <source>For the most part, layers will automatically support mixed precision and float64 without any additional work, due to the fact the base layer automatically casts inputs, creates variables of the correct type, and in the case of mixed precision, wraps variables with &lt;code&gt;AutoCastVariables&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd1f2c4cb29e01e87b19426efdde9e0733dd9a05" translate="yes" xml:space="preserve">
          <source>For the most part, the mapping between Proto field types and TensorFlow dtypes is straightforward. However, there are a few special cases:</source>
          <target state="translated">En su mayor parte,el mapeo entre los tipos de campo de Proto y los tipos de TensorFlow es sencillo.Sin embargo,hay algunos casos especiales:</target>
        </trans-unit>
        <trans-unit id="c23aedef4b8e055530a87dad6ff1b4b7682cb7a9" translate="yes" xml:space="preserve">
          <source>For the purposes of this function, a valid ordered sequence type is one which can be indexed, has a length, and has an equality operator.</source>
          <target state="translated">A los efectos de esta función,un tipo de secuencia ordenada válida es aquella que puede ser indexada,tiene una longitud y tiene un operador de igualdad.</target>
        </trans-unit>
        <trans-unit id="277400dd8bda8642b7e25a7ed51e2ae99e733ee3" translate="yes" xml:space="preserve">
          <source>For the replicas:</source>
          <target state="translated">Para las réplicas:</target>
        </trans-unit>
        <trans-unit id="0a61ac4581750cc1861ea15aab1f318fa5e0885d" translate="yes" xml:space="preserve">
          <source>For the variables and &lt;code&gt;tf.MetaGraphDefs&lt;/code&gt;, a timestamped export directory below &lt;code&gt;export_dir_base&lt;/code&gt;, and writes a &lt;code&gt;SavedModel&lt;/code&gt; into it containing the &lt;code&gt;tf.MetaGraphDef&lt;/code&gt; for the given mode and its associated signatures.</source>
          <target state="translated">Para las variables y &lt;code&gt;tf.MetaGraphDefs&lt;/code&gt; , un directorio de exportaci&amp;oacute;n con sello de tiempo debajo de &lt;code&gt;export_dir_base&lt;/code&gt; , y escribe un &lt;code&gt;SavedModel&lt;/code&gt; en &amp;eacute;l que contiene el &lt;code&gt;tf.MetaGraphDef&lt;/code&gt; para el modo dado y sus firmas asociadas.</target>
        </trans-unit>
        <trans-unit id="56c86fc9affcdc3686a615c6369da410c6e71b43" translate="yes" xml:space="preserve">
          <source>For this function to work, the stream must have a file descriptor that can be modified using &lt;code&gt;os.dup&lt;/code&gt; and &lt;code&gt;os.dup2&lt;/code&gt;, and the stream must support a &lt;code&gt;.flush()&lt;/code&gt; method. The default python sys.stdout and sys.stderr are examples of this. Note that this does not work in Colab or Jupyter notebooks, because those use alternate stdout streams.</source>
          <target state="translated">Para que esta funci&amp;oacute;n funcione, la secuencia debe tener un descriptor de archivo que se pueda modificar usando &lt;code&gt;os.dup&lt;/code&gt; y &lt;code&gt;os.dup2&lt;/code&gt; , y la secuencia debe admitir un m&amp;eacute;todo &lt;code&gt;.flush()&lt;/code&gt; . Los Python sys.stdout y sys.stderr predeterminados son ejemplos de esto. Tenga en cuenta que esto no funciona en los cuadernos de Colab o Jupyter, porque utilizan flujos de salida est&amp;aacute;ndar alternativos.</target>
        </trans-unit>
        <trans-unit id="ac41fbab77768e9b6192dc00dfce9e8a5ab1aa29" translate="yes" xml:space="preserve">
          <source>For training and evaluation, the &lt;code&gt;train_op&lt;/code&gt; is stored in an extra collection, and loss, metrics, and predictions are included in a &lt;code&gt;SignatureDef&lt;/code&gt; for the mode in question.</source>
          <target state="translated">Para el entrenamiento y la evaluaci&amp;oacute;n, &lt;code&gt;train_op&lt;/code&gt; se almacena en una colecci&amp;oacute;n adicional, y las p&amp;eacute;rdidas, m&amp;eacute;tricas y predicciones se incluyen en &lt;code&gt;SignatureDef&lt;/code&gt; para el modo en cuesti&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8cb90deddea49c5d8ea800cc7d640f23ce709e57" translate="yes" xml:space="preserve">
          <source>For training, &lt;code&gt;model_fn&lt;/code&gt; gets per-core batch size; &lt;code&gt;input_fn&lt;/code&gt; may get per-core or per-host batch size depending on &lt;code&gt;per_host_input_for_training&lt;/code&gt; in &lt;code&gt;TPUConfig&lt;/code&gt; (See docstring for TPUConfig for details).</source>
          <target state="translated">Para el entrenamiento, &lt;code&gt;model_fn&lt;/code&gt; obtiene el tama&amp;ntilde;o de lote por n&amp;uacute;cleo; &lt;code&gt;input_fn&lt;/code&gt; puede obtener un tama&amp;ntilde;o de lote por n&amp;uacute;cleo o por host dependiendo de &lt;code&gt;per_host_input_for_training&lt;/code&gt; en &lt;code&gt;TPUConfig&lt;/code&gt; (consulte la cadena de documentaci&amp;oacute;n de TPUConfig para obtener m&amp;aacute;s detalles).</target>
        </trans-unit>
        <trans-unit id="851eb999d65883da2e108c88c201473ef5f90761" translate="yes" xml:space="preserve">
          <source>For training, TensorFlow stores the tensors that are produced in the forward inference and are needed in back propagation. These tensors are a main source of memory consumption and often cause OOM errors when training on GPUs. When the flag swap_memory is true, we swap out these tensors from GPU to CPU. This for example allows us to train RNN models with very long sequences and large batches.</source>
          <target state="translated">Para el entrenamiento,TensorFlow almacena los tensores que se producen en la inferencia hacia adelante y que se necesitan en la propagación hacia atrás.Estos tensores son una fuente principal de consumo de memoria y a menudo causan errores de OOM al entrenar en las GPU.Cuando la bandera swap_memory es verdadera,intercambiamos estos tensores de la GPU a la CPU.Esto,por ejemplo,nos permite entrenar modelos RNN con secuencias muy largas y grandes lotes.</target>
        </trans-unit>
        <trans-unit id="686652c961bb116ce8005add3ae7ed8c5b4c585b" translate="yes" xml:space="preserve">
          <source>For training, sums losses of each head, calls &lt;code&gt;train_op_fn&lt;/code&gt; with this final loss.</source>
          <target state="translated">Para el entrenamiento, suma las p&amp;eacute;rdidas de cada cabeza, llama a &lt;code&gt;train_op_fn&lt;/code&gt; con esta p&amp;eacute;rdida final.</target>
        </trans-unit>
        <trans-unit id="c963d2deb9cad268120d3bd485103d985f5495cf" translate="yes" xml:space="preserve">
          <source>For tutorial on the options, see &lt;a href=&quot;https://github.com/tensorflow/tensorflow/tree/master/tensorflow/core/profiler/g3doc/options.md&quot;&gt;https://github.com/tensorflow/tensorflow/tree/master/tensorflow/core/profiler/g3doc/options.md&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="249a8fecba276e5537d5687430c7832f6a097905" translate="yes" xml:space="preserve">
          <source>For tutorial on the options, see https://github.com/tensorflow/tensorflow/tree/master/tensorflow/core/profiler/g3doc/options.md</source>
          <target state="translated">Para ver el tutorial sobre las opciones,véase https://github.com/tensorflow/tensorflow/tree/master/tensorflow/core/profiler/g3doc/options.md</target>
        </trans-unit>
        <trans-unit id="e0250883f7e36fe46e791c49d58341332e74601a" translate="yes" xml:space="preserve">
          <source>For usage example, please see: &lt;a href=&quot;https://www.tensorflow.org/guide/estimators#creating_estimators_from_keras_models&quot;&gt;Creating estimators from Keras Models&lt;/a&gt;.</source>
          <target state="translated">Para ver un ejemplo de uso, consulte: &lt;a href=&quot;https://www.tensorflow.org/guide/estimators#creating_estimators_from_keras_models&quot;&gt;Creaci&amp;oacute;n de estimadores a partir de modelos Keras&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="af78702967e9ea264023f8fbaf663f2a1adc42b5" translate="yes" xml:space="preserve">
          <source>For use with &lt;a href=&quot;ctc_loss&quot;&gt;&lt;code&gt;tf.nn.ctc_loss&lt;/code&gt;&lt;/a&gt; optional argument &lt;code&gt;unique&lt;/code&gt;: This op can be used to preprocess labels in input pipeline to for better speed/memory use computing the ctc loss on TPU.</source>
          <target state="translated">Para usar con el argumento opcional &lt;a href=&quot;ctc_loss&quot;&gt; &lt;code&gt;tf.nn.ctc_loss&lt;/code&gt; &lt;/a&gt; &lt;code&gt;unique&lt;/code&gt; : esta operaci&amp;oacute;n se puede usar para preprocesar etiquetas en la canalizaci&amp;oacute;n de entrada para lograr un mejor uso de velocidad / memoria calculando la p&amp;eacute;rdida de ctc en TPU.</target>
        </trans-unit>
        <trans-unit id="740b2ee4e4d8bf4808f11e53b605666e73b665e3" translate="yes" xml:space="preserve">
          <source>For variables placed in TPU device, which includes variables created inside TPUStrategy scope, outside compilation logic must not include variable read/write. For variables placed on host, which is the case when variables created via TPUEstimator, variable read/write is only allowed if the variable is not accessed by any other ops in the TPU computation. Variable read/write from outside compilation cluster is not visible from TPU computation and vice versa. Therefore, if outside compilation logic contains such host variables read/write ops and if the variables are accessed by TPU computation as well, then this may lead to deadlock.</source>
          <target state="translated">Para las variables colocadas en el dispositivo TPU,que incluye las variables creadas dentro del ámbito de la TPUStrategy,la lógica de compilación externa no debe incluir la lectura/escritura de variables.Para las variables colocadas en el host,que es el caso de las variables creadas a través del TPUEstimator,la lectura/escritura de variables sólo está permitida si la variable no es accedida por ninguna otra operación en el cálculo del TPU.La lectura/escritura de variables desde fuera del clúster de compilación no es visible desde el cálculo del TPU y viceversa.Por lo tanto,si la lógica de compilación externa contiene tales variables de lectura/escritura del host y si se accede a las variables también mediante el cálculo del TPU,entonces esto puede llevar a un punto muerto.</target>
        </trans-unit>
        <trans-unit id="34cca35024442a2daa7b2b0c02c66c45e14c3cb9" translate="yes" xml:space="preserve">
          <source>For x &amp;lt; 0, to avoid overflow in exp(-x), we reformulate the above</source>
          <target state="translated">Para x &amp;lt;0, para evitar el desbordamiento en exp (-x), reformulamos lo anterior</target>
        </trans-unit>
        <trans-unit id="94cdf994803be6eb936ffe2768c49aa065f6d215" translate="yes" xml:space="preserve">
          <source>For x \in (-inf, inf) =&amp;gt; sigmoid(x) \in (0, 1)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dfe58b9051d5a627bc446c6f93be3012efd4568" translate="yes" xml:space="preserve">
          <source>Forces summary writer to send any buffered data to storage.</source>
          <target state="translated">Obliga al escritor de resúmenes a enviar cualquier dato almacenado en el buffer.</target>
        </trans-unit>
        <trans-unit id="d2dccd3937aceeadad57b5db753b0a63c00ec1a4" translate="yes" xml:space="preserve">
          <source>Format to use for saving sample images (if &lt;code&gt;save_to_dir&lt;/code&gt; is set).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9f17deb03f3afa151a329975529588281686220" translate="yes" xml:space="preserve">
          <source>Formats a string template using a list of tensors, abbreviating tensors by only printing the first and last &lt;code&gt;summarize&lt;/code&gt; elements of each dimension (recursively). If formatting only one tensor into a template, the tensor does not have to be wrapped in a list.</source>
          <target state="translated">Formatea una plantilla de cadena usando una lista de tensores, abreviando tensores imprimiendo solo el primer y &amp;uacute;ltimo &lt;code&gt;summarize&lt;/code&gt; elementos de cada dimensi&amp;oacute;n (recursivamente). Si formatea solo un tensor en una plantilla, el tensor no tiene que estar envuelto en una lista.</target>
        </trans-unit>
        <trans-unit id="45da02b6531e4ce47da0f14f7d9b458f2933c3d0" translate="yes" xml:space="preserve">
          <source>Formats a string template using a list of tensors, pretty-printing tensor summaries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="239f72546128721c29c8c3274ac9f9554ba33807" translate="yes" xml:space="preserve">
          <source>Formats a string template using a list of tensors.</source>
          <target state="translated">Formatea una plantilla de cuerda usando una lista de tensores.</target>
        </trans-unit>
        <trans-unit id="aab407c990b5dd2317ab563c02f7afc3c37496b1" translate="yes" xml:space="preserve">
          <source>Formats both the test method name and the first line of its docstring.</source>
          <target state="translated">Formatea tanto el nombre del método de prueba como la primera línea de su cadena de doctores.</target>
        </trans-unit>
        <trans-unit id="30411971a5c7c0c65716d7a2276bc0753edc1090" translate="yes" xml:space="preserve">
          <source>Formatting a multi-tensor template:</source>
          <target state="translated">Formateando una plantilla multi-tensorial:</target>
        </trans-unit>
        <trans-unit id="8e8e20d914a22b13e7830695a5885972e5f7dd9c" translate="yes" xml:space="preserve">
          <source>Formatting a single-tensor template:</source>
          <target state="translated">Formateando una plantilla de un solo tensor:</target>
        </trans-unit>
        <trans-unit id="8d843afdf2e57d596f25990cb1c437eb7019adc0" translate="yes" xml:space="preserve">
          <source>Formula for calculating sigmoid(x): &lt;code&gt;y = 1 / (1 + exp(-x))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7034cfa1d998a3b54fb5b3c3fa5754f76a68399a" translate="yes" xml:space="preserve">
          <source>Forward and inverse lookup pairs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c50d21ebeb5eb1221d5f8c11b87f7e8ba73b2e5f" translate="yes" xml:space="preserve">
          <source>Forward-compatibility refers to scenarios where the producer of a TensorFlow model (a GraphDef or SavedModel) is compiled against a version of the TensorFlow library newer than what the consumer was compiled against. The &quot;producer&quot; is typically a Python program that constructs and trains a model while the &quot;consumer&quot; is typically another program that loads and serves the model.</source>
          <target state="translated">La compatibilidad hacia adelante se refiere a los escenarios en los que el productor de un modelo de TensorFlow (un GraphDef o SavedModel)se compila contra una versión de la biblioteca de TensorFlow más reciente que contra la que se compiló el consumidor.El &quot;productor&quot; es típicamente un programa Python que construye y entrena un modelo mientras que el &quot;consumidor&quot; es típicamente otro programa que carga y sirve el modelo.</target>
        </trans-unit>
        <trans-unit id="d85bd4cd5990fd7543a86021751d93d42f1357b3" translate="yes" xml:space="preserve">
          <source>Forwarding the variables from the underlying optimizer.</source>
          <target state="translated">Reenviando las variables del optimizador subyacente.</target>
        </trans-unit>
        <trans-unit id="210e7c1722192470315ce4c81eb0d4f008c48b3c" translate="yes" xml:space="preserve">
          <source>Forwards &lt;code&gt;data&lt;/code&gt; to the output port determined by &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac10a67355b28b15b67e466f47812ba51acf7c5d" translate="yes" xml:space="preserve">
          <source>Forwards the &lt;code&gt;index&lt;/code&gt;th element of &lt;code&gt;inputs&lt;/code&gt; to &lt;code&gt;output&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6864a45f002f5e6954a15ab9ef9c1a8ff52d9034" translate="yes" xml:space="preserve">
          <source>Forwards the input to the output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c39cbdd42c402f4cd1012035895e06b8964ff7a6" translate="yes" xml:space="preserve">
          <source>Forwards the ref tensor &lt;code&gt;data&lt;/code&gt; to the output port determined by &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f39668f24ce7de085f554eebee46e090e3244546" translate="yes" xml:space="preserve">
          <source>Forwards the value of an available tensor from &lt;code&gt;inputs&lt;/code&gt; to &lt;code&gt;output&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c89a9afa7f5354e4a63edd2e6c0d0b4901dd765" translate="yes" xml:space="preserve">
          <source>Four &lt;code&gt;Tensor&lt;/code&gt; objects of the same type as &lt;code&gt;x&lt;/code&gt;:</source>
          <target state="translated">Cuatro objetos &lt;code&gt;Tensor&lt;/code&gt; del mismo tipo que &lt;code&gt;x&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0b64e890e12a034b5e89e178fdc9f76c74a27a3b" translate="yes" xml:space="preserve">
          <source>Fractional Max-Pooling: &lt;a href=&quot;https://arxiv.org/abs/1412.6071&quot;&gt;Graham, 2015&lt;/a&gt; (&lt;a href=&quot;https://arxiv.org/pdf/1412.6071.pdf&quot;&gt;pdf&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40d7d8597b074e3ac7474d10a611c554ad7fa982" translate="yes" xml:space="preserve">
          <source>Fractional average pooling is similar to Fractional max pooling in the pooling region generation step. The only difference is that after pooling regions are generated, a mean operation is performed instead of a max operation in each pooling region.</source>
          <target state="translated">El pooling promedio fraccionario es similar al pooling máximo fraccionario en el paso de generación de la región de pooling.La única diferencia es que después de que se generan las regiones de agrupación,se realiza una operación media en lugar de una operación máxima en cada región de agrupación.</target>
        </trans-unit>
        <trans-unit id="5041cde3f1a2533e4659d2586c2ffe569e1d7dcf" translate="yes" xml:space="preserve">
          <source>Fractional max pooling is slightly different than regular max pooling. In regular max pooling, you downsize an input set by taking the maximum value of smaller N x N subsections of the set (often 2x2), and try to reduce the set by a factor of N, where N is an integer. Fractional max pooling, as you might expect from the word &quot;fractional&quot;, means that the overall reduction ratio N does not have to be an integer.</source>
          <target state="translated">El pooling máximo fraccional es ligeramente diferente del pooling máximo regular.En la agrupación máxima regular,se reduce el tamaño de un conjunto de entrada tomando el valor máximo de las subsecciones más pequeñas de N x N del conjunto (a menudo 2x2),y se intenta reducir el conjunto por un factor de N,donde N es un número entero.La agrupación máxima fraccional,como se podría esperar de la palabra &quot;fraccional&quot;,significa que la relación de reducción global N no tiene que ser un número entero.</target>
        </trans-unit>
        <trans-unit id="cdbefc98aa39ba4bd6f437fe41a59ea0b199db5e" translate="yes" xml:space="preserve">
          <source>FractionalAvgPool</source>
          <target state="translated">FractionalAvgPool</target>
        </trans-unit>
        <trans-unit id="c9267ec6a51ddbb51448594d4c2287cf4c0d1df0" translate="yes" xml:space="preserve">
          <source>FractionalAvgPoolGrad</source>
          <target state="translated">FractionalAvgPoolGrad</target>
        </trans-unit>
        <trans-unit id="0892d35605cdd9bd30150ab584d51683167ecba4" translate="yes" xml:space="preserve">
          <source>FractionalMaxPool</source>
          <target state="translated">FractionalMaxPool</target>
        </trans-unit>
        <trans-unit id="ca1d900edc749abee96c0d0dfa0680048bb9a35a" translate="yes" xml:space="preserve">
          <source>FractionalMaxPoolGrad</source>
          <target state="translated">FractionalMaxPoolGrad</target>
        </trans-unit>
        <trans-unit id="461d49107b929069fa49ed11a5d92526668968dc" translate="yes" xml:space="preserve">
          <source>FresnelCos</source>
          <target state="translated">FresnelCos</target>
        </trans-unit>
        <trans-unit id="555de53bb5c086444e4833777660b765a262a6ca" translate="yes" xml:space="preserve">
          <source>FresnelSin</source>
          <target state="translated">FresnelSin</target>
        </trans-unit>
        <trans-unit id="266f4adbdcbde038a6a989395a6469a033656f5f" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://www.jmlr.org/papers/volume3/gers02a/gers02a.pdf&quot;&gt;Gers et al., 2002&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd28230ef13373337ce1949fe5af0d799f846337" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://www.jmlr.org/papers/volume3/gers02a/gers02a.pdf&quot;&gt;Gers et al.&lt;/a&gt;:</source>
          <target state="translated">De &lt;a href=&quot;http://www.jmlr.org/papers/volume3/gers02a/gers02a.pdf&quot;&gt;Gers et al. &lt;/a&gt;:</target>
        </trans-unit>
        <trans-unit id="f121e219c269ca1dd88e0e15be45795cfb78de9b" translate="yes" xml:space="preserve">
          <source>From the specified 'num_bits' in the quantized output type, it determines minimum and maximum representable quantized values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cdba04d7a9eac83a97bc8f1d7ed1afaf3de99f7" translate="yes" xml:space="preserve">
          <source>From these definitions, we see that</source>
          <target state="translated">A partir de estas definiciones,vemos que</target>
        </trans-unit>
        <trans-unit id="18752fdccfa3eb0aaa2135e8d0734a1264755927" translate="yes" xml:space="preserve">
          <source>Frozen TensorFlow GraphDef.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2b99f0a6d43df651b198f8a6d97f7cd7519e800" translate="yes" xml:space="preserve">
          <source>Full file name path to the checkpoint file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90027b2158c0e9bc2fd007d047143a65b064bfe9" translate="yes" xml:space="preserve">
          <source>Full filepath of HDF5 file containing the tf.keras model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ce670e0e4234ef3e699470703e6f834ee6fc5d0" translate="yes" xml:space="preserve">
          <source>Full filepath of file containing frozen GraphDef.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e14411de008f7791c1053dac7870cb082e304ab" translate="yes" xml:space="preserve">
          <source>Full filepath of folder to dump the graphs at various stages of processing GraphViz .dot files. Preferred over --output_format=GRAPHVIZ_DOT in order to keep the requirements of the output file. (default None)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aca6a2cadbde9796176b9f2bdc4ddaa5883a4b4" translate="yes" xml:space="preserve">
          <source>Fully-connected RNN where the output is to be fed back to input.</source>
          <target state="translated">RNN completamente conectado donde la salida debe ser retroalimentada a la entrada.</target>
        </trans-unit>
        <trans-unit id="04613c353330a3b030cda37163970b74de725fdc" translate="yes" xml:space="preserve">
          <source>Function builder for a dnn logit_fn.</source>
          <target state="translated">Constructor de funciones para un dnn logit_fn.</target>
        </trans-unit>
        <trans-unit id="80bb380683226de01695aa870f90690f020ccf39" translate="yes" xml:space="preserve">
          <source>Function builder for a linear logit_fn.</source>
          <target state="translated">Constructor de funciones para un logit_fn lineal.</target>
        </trans-unit>
        <trans-unit id="961134f334d4e3d099fd3b88ec79f66049e02609" translate="yes" xml:space="preserve">
          <source>Function corresponding to the input string or input function.</source>
          <target state="translated">Función correspondiente a la cadena de entrada o función de entrada.</target>
        </trans-unit>
        <trans-unit id="84942f5d7faa1848468aa47bc1832cb4ffceb2fa" translate="yes" xml:space="preserve">
          <source>Function for &lt;code&gt;decode_bmp&lt;/code&gt;, &lt;code&gt;decode_gif&lt;/code&gt;, &lt;code&gt;decode_jpeg&lt;/code&gt;, and &lt;code&gt;decode_png&lt;/code&gt;.</source>
          <target state="translated">Funci&amp;oacute;n para &lt;code&gt;decode_bmp&lt;/code&gt; , &lt;code&gt;decode_gif&lt;/code&gt; , &lt;code&gt;decode_jpeg&lt;/code&gt; y &lt;code&gt;decode_png&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="572d2bb02e89c8f3847c21f4dc5279a374c3627b" translate="yes" xml:space="preserve">
          <source>Function object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7e2223c959cab59ba23fe92444da8ee0470dc6a" translate="yes" xml:space="preserve">
          <source>Function or string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b4e76300f7233d9787f12ee14670f6240ff6bba" translate="yes" xml:space="preserve">
          <source>Function that joins arguments from threads that are given as PerReplica. It accepts &lt;a href=&quot;strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; object as the first argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3888f1a7f7ad2a4d8e9abf43dddc4f56b91e55d9" translate="yes" xml:space="preserve">
          <source>Function that maps (input, num_spatial_dims, padding) -&amp;gt; output</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29319f13ab18651cfb7537f6a5eddbd79ca1798f" translate="yes" xml:space="preserve">
          <source>Function that takes a scalar loss &lt;code&gt;Tensor&lt;/code&gt; and returns &lt;code&gt;train_op&lt;/code&gt;. Used if &lt;code&gt;optimizer&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b91e979c56b6a5a95309b72332456efabd23f242" translate="yes" xml:space="preserve">
          <source>Function that takes a scalar loss &lt;code&gt;Tensor&lt;/code&gt; and returns an op to optimize the model with the loss in TRAIN mode. Used if &lt;code&gt;optimizer&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;. Exactly one of &lt;code&gt;train_op_fn&lt;/code&gt; and &lt;code&gt;optimizer&lt;/code&gt; must be set in TRAIN mode. By default, it is &lt;code&gt;None&lt;/code&gt; in other modes. If you want to optimize loss yourself, you can pass &lt;code&gt;lambda _: tf.no_op()&lt;/code&gt; and then use &lt;a href=&quot;estimatorspec#loss&quot;&gt;&lt;code&gt;EstimatorSpec.loss&lt;/code&gt;&lt;/a&gt; to compute and apply gradients.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c8c9c9afc68cd4e3a21d1d0883f3c94b166cd76" translate="yes" xml:space="preserve">
          <source>Function to be called and extra positional args.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9668555814ce219a8e6ead49b464c78c9faea18" translate="yes" xml:space="preserve">
          <source>Function to be called, or None to return a context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f38de77bb6b57ed6e07c1cd26484aa1832921c19" translate="yes" xml:space="preserve">
          <source>Function to call. Should take the variable as the first argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b46ccb902892f13f107bf66a75f9bf8327cbae4d" translate="yes" xml:space="preserve">
          <source>Function, that has signature of ()-&amp;gt;(dict of &lt;code&gt;features&lt;/code&gt;, &lt;code&gt;target&lt;/code&gt;)</source>
          <target state="translated">Funci&amp;oacute;n, que tiene la firma de () -&amp;gt; (dictado de &lt;code&gt;features&lt;/code&gt; , &lt;code&gt;target&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="52f2894799ccb50c7b33084828e4f3851ea4df75" translate="yes" xml:space="preserve">
          <source>Function, that has signature of ()-&amp;gt;(dict of &lt;code&gt;features&lt;/code&gt;, &lt;code&gt;targets&lt;/code&gt;)</source>
          <target state="translated">Funci&amp;oacute;n, que tiene la firma de () -&amp;gt; (dictado de &lt;code&gt;features&lt;/code&gt; , &lt;code&gt;targets&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="95e988de9fb50a5cd88d6853048b67ed3a399d7b" translate="yes" xml:space="preserve">
          <source>Function. The function created by this method should accept a &lt;a href=&quot;../../data/iterator&quot;&gt;&lt;code&gt;tf.data.Iterator&lt;/code&gt;&lt;/a&gt;, and return a &lt;code&gt;dict&lt;/code&gt; containing values that will be passed to &lt;code&gt;tf.keras.Callbacks.on_test_batch_end&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="327af3c4f94777b37a0d2449a5895e659cad6e23" translate="yes" xml:space="preserve">
          <source>Function. The function created by this method should accept a &lt;a href=&quot;../../data/iterator&quot;&gt;&lt;code&gt;tf.data.Iterator&lt;/code&gt;&lt;/a&gt;, and return a &lt;code&gt;dict&lt;/code&gt; containing values that will be passed to &lt;code&gt;tf.keras.Callbacks.on_train_batch_end&lt;/code&gt;, such as &lt;code&gt;{'loss': 0.2, 'accuracy': 0.7}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="656c120741d962b4b4cb42d15057a960a5358b5f" translate="yes" xml:space="preserve">
          <source>Function. The function created by this method should accept a &lt;a href=&quot;../../data/iterator&quot;&gt;&lt;code&gt;tf.data.Iterator&lt;/code&gt;&lt;/a&gt;, and return the outputs of the &lt;code&gt;Model&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41d1aa0470499deda211a11de3b081c451856666" translate="yes" xml:space="preserve">
          <source>Function. The function created by this method should accept a &lt;a href=&quot;../data/iterator&quot;&gt;&lt;code&gt;tf.data.Iterator&lt;/code&gt;&lt;/a&gt;, and return a &lt;code&gt;dict&lt;/code&gt; containing values that will be passed to &lt;code&gt;tf.keras.Callbacks.on_test_batch_end&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d2eb314244e720ce4ba2da84d3ecfb8e0c92f66" translate="yes" xml:space="preserve">
          <source>Function. The function created by this method should accept a &lt;a href=&quot;../data/iterator&quot;&gt;&lt;code&gt;tf.data.Iterator&lt;/code&gt;&lt;/a&gt;, and return a &lt;code&gt;dict&lt;/code&gt; containing values that will be passed to &lt;code&gt;tf.keras.Callbacks.on_train_batch_end&lt;/code&gt;, such as &lt;code&gt;{'loss': 0.2, 'accuracy': 0.7}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8df0a9af5b857d1cf68b6c139f016618d2511fd" translate="yes" xml:space="preserve">
          <source>Function. The function created by this method should accept a &lt;a href=&quot;../data/iterator&quot;&gt;&lt;code&gt;tf.data.Iterator&lt;/code&gt;&lt;/a&gt;, and return the outputs of the &lt;code&gt;Model&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd4d97811c7aafbd87d5d51e0c6c137634e57d76" translate="yes" xml:space="preserve">
          <source>Functional interface for the batch normalization layer from_config(Ioffe et al., 2015). (deprecated)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88fcd90125004d28567d342c9f3165809fb40cbc" translate="yes" xml:space="preserve">
          <source>Functional interface for the batch normalization layer. (deprecated)</source>
          <target state="translated">Interfaz funcional para la capa de normalización de lotes.(desaprovechado)</target>
        </trans-unit>
        <trans-unit id="3008e201e4f95d586e2d708853592636025c56ec" translate="yes" xml:space="preserve">
          <source>Functional interface for the depthwise separable 1D convolution layer. (deprecated)</source>
          <target state="translated">Interfaz funcional para la capa de convolución 1D separable en profundidad.(desaprobado)</target>
        </trans-unit>
        <trans-unit id="843524e6eccb65e6f3f97379f7de26c2a2f2da67" translate="yes" xml:space="preserve">
          <source>Functional interface for the depthwise separable 2D convolution layer. (deprecated)</source>
          <target state="translated">Interfaz funcional para la capa de convolución 2D separable en profundidad.(desaprobado)</target>
        </trans-unit>
        <trans-unit id="55f27b3100890ca22fc05334143ec1799a0365f4" translate="yes" xml:space="preserve">
          <source>Functional interface for transposed 2D convolution layer. (deprecated)</source>
          <target state="translated">Interfaz funcional para la capa de convolución 2D transpuesta.(desaprobado)</target>
        </trans-unit>
        <trans-unit id="cc0e25ff898bc600b9c3b618d6944b678eac556b" translate="yes" xml:space="preserve">
          <source>Functional interface for transposed 3D convolution layer. (deprecated)</source>
          <target state="translated">Interfaz funcional para la capa de convolución 3D transpuesta.(desaprobado)</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="abc7c3058aaf16961ae99141267b62b102b7362a" translate="yes" xml:space="preserve">
          <source>Functions are converted into new functions with converted code.</source>
          <target state="translated">Las funciones se convierten en nuevas funciones con el código convertido.</target>
        </trans-unit>
        <trans-unit id="7f53929fbbbf3598a8477b3e21c530968bf2b1e4" translate="yes" xml:space="preserve">
          <source>Functions used to extract and analyze stacks. Faster than Python libs.</source>
          <target state="translated">Funciones utilizadas para extraer y analizar las pilas.Más rápido que las liberaciones de Python.</target>
        </trans-unit>
        <trans-unit id="1088f52ee06b617e019df677ae2d985ea8367ee8" translate="yes" xml:space="preserve">
          <source>Further, each thread starts with an empty variable scope. So if you wish to preserve name prefixes from a scope from the main thread, you should capture the main thread's scope and re-enter it in each thread. For e.g.</source>
          <target state="translated">Además,cada hilo comienza con un ámbito variable vacío.Por lo tanto,si desea preservar los prefijos de nombres de un ámbito del hilo principal,debe capturar el ámbito del hilo principal y volver a introducirlo en cada hilo.Por ejemplo.</target>
        </trans-unit>
        <trans-unit id="17d43e06d288fdecd9a150c3bd7e9213832b2bda" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;code&gt;fn&lt;/code&gt; may emit a different structure than its input. For example, &lt;code&gt;fn&lt;/code&gt; may look like: &lt;code&gt;fn = lambda t1: return (t1 + 1, t1 - 1)&lt;/code&gt;. In this case, the &lt;code&gt;dtype&lt;/code&gt; parameter is not optional: &lt;code&gt;dtype&lt;/code&gt; must be a type or (possibly nested) tuple of types matching the output of &lt;code&gt;fn&lt;/code&gt;.</source>
          <target state="translated">Adem&amp;aacute;s, &lt;code&gt;fn&lt;/code&gt; puede emitir una estructura diferente a su entrada. Por ejemplo, &lt;code&gt;fn&lt;/code&gt; puede verse as&amp;iacute;: &lt;code&gt;fn = lambda t1: return (t1 + 1, t1 - 1)&lt;/code&gt; . En este caso, el par&amp;aacute;metro &lt;code&gt;dtype&lt;/code&gt; no es opcional: &lt;code&gt;dtype&lt;/code&gt; debe ser un tipo o (posiblemente anidado) tupla de tipos que coincidan con la salida de &lt;code&gt;fn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8eca057ed1ad79a6c34545db8e733823a73dfbda" translate="yes" xml:space="preserve">
          <source>Furthermore, each component vector of &lt;code&gt;permutation&lt;/code&gt; must be of length &lt;code&gt;N&lt;/code&gt;, containing each of the integers {0, 1, ..., N - 1} exactly once, where &lt;code&gt;N&lt;/code&gt; is the number of rows of each component of the sparse matrix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cac9ee53753b3ccba19a58872a949a03e0ed0a6d" translate="yes" xml:space="preserve">
          <source>Fused implementation of &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;batch&lt;/code&gt;. (deprecated)</source>
          <target state="translated">Implementaci&amp;oacute;n fusionada de &lt;code&gt;map&lt;/code&gt; a y &lt;code&gt;batch&lt;/code&gt; . (obsoleto)</target>
        </trans-unit>
        <trans-unit id="8fa84725122a287d0cb8f17bda5fbaa9cfd37bea" translate="yes" xml:space="preserve">
          <source>FusedBatchNorm</source>
          <target state="translated">FusedBatchNorm</target>
        </trans-unit>
        <trans-unit id="f7b8da7deea4d0087270a594c3304c5206d3bf77" translate="yes" xml:space="preserve">
          <source>FusedBatchNormGrad</source>
          <target state="translated">FusedBatchNormGrad</target>
        </trans-unit>
        <trans-unit id="ff54a465b3ddf6aad5d7277a2960454bcdf5c7dd" translate="yes" xml:space="preserve">
          <source>FusedBatchNormGradV2</source>
          <target state="translated">FusedBatchNormGradV2</target>
        </trans-unit>
        <trans-unit id="efa2db95230d193fc0b2d1a7dbc258c4dc871a3a" translate="yes" xml:space="preserve">
          <source>FusedBatchNormGradV3</source>
          <target state="translated">FusedBatchNormGradV3</target>
        </trans-unit>
        <trans-unit id="2e082980a698cbd30bfdcc577a828bee3ef142c1" translate="yes" xml:space="preserve">
          <source>FusedBatchNormV2</source>
          <target state="translated">FusedBatchNormV2</target>
        </trans-unit>
        <trans-unit id="d4b44881964c817e28926bb8505ed4b17e43045a" translate="yes" xml:space="preserve">
          <source>FusedBatchNormV3</source>
          <target state="translated">FusedBatchNormV3</target>
        </trans-unit>
        <trans-unit id="9a5938911daebb6a70c3382e959fd759e820951a" translate="yes" xml:space="preserve">
          <source>FusedPadConv2D</source>
          <target state="translated">FusedPadConv2D</target>
        </trans-unit>
        <trans-unit id="a7fee6ae8ac515a2dfd04f006bf80f40a0d24a92" translate="yes" xml:space="preserve">
          <source>FusedResizeAndPadConv2D</source>
          <target state="translated">FusedResizeAndPadConv2D</target>
        </trans-unit>
        <trans-unit id="754a365f8fd6b9ceb366bc46267e7e7fae2e01b8" translate="yes" xml:space="preserve">
          <source>Future major versions of TensorFlow will allow gradients to flow into the labels input on backprop by default.</source>
          <target state="translated">Las futuras versiones principales de TensorFlow permitirán que los gradientes fluyan en las etiquetas de entrada de la contraportada por defecto.</target>
        </trans-unit>
        <trans-unit id="7dbebb53731d118027dc401234e5639569fa8c60" translate="yes" xml:space="preserve">
          <source>Fuzz factor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72267a6e30d52b94f9b577c3333196adb57b047d" translate="yes" xml:space="preserve">
          <source>GCE Credentials. If None, then we use default credentials from the oauth2client</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ad91e9a8f5cd85998e81a80a35e120f1cc77d99" translate="yes" xml:space="preserve">
          <source>GCE Credentials. If nothing is specified, this defaults to GoogleCredentials.get_application_default().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51e841ad3b27b555240bd3208409784776b78d91" translate="yes" xml:space="preserve">
          <source>GIF images with frame or transparency compression are not supported. On Linux and MacOS systems, convert animated GIFs from compressed to uncompressed by running:</source>
          <target state="translated">Las imágenes GIF con compresión de cuadro o transparencia no son compatibles.En sistemas Linux y MacOS,convierta los GIF animados de comprimidos a no comprimidos ejecutándolos:</target>
        </trans-unit>
        <trans-unit id="9bcfc99bed88388ab08e19e25125b8df695b2ec4" translate="yes" xml:space="preserve">
          <source>GNU style allows mixing of flag and non-flag arguments. See &lt;a href=&quot;http://docs.python.org/library/getopt.html#getopt.gnu_getopt&quot;&gt;http://docs.python.org/library/getopt.html#getopt.gnu_getopt&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50722eace7871bd3272fd82573850bdf2c8a1820" translate="yes" xml:space="preserve">
          <source>GNU style allows mixing of flag and non-flag arguments. See &lt;a href=&quot;https://docs.python.org/library/getopt.html#getopt.gnu_getopt&quot;&gt;http://docs.python.org/library/getopt.html#getopt.gnu_getopt&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc2cb7021c13ea83cc3e049d7402c76b692e0416" translate="yes" xml:space="preserve">
          <source>GNU style allows mixing of flag and non-flag arguments. See http://docs.python.org/library/getopt.html#getopt.gnu_getopt</source>
          <target state="translated">El estilo GNU permite la mezcla de argumentos de bandera y no bandera.Ver http://docs.python.org/library/getopt.html#getopt.gnu_getopt</target>
        </trans-unit>
        <trans-unit id="f972014286a8ef98413380743e0166a16182293b" translate="yes" xml:space="preserve">
          <source>GRU convention (whether to apply reset gate after or before matrix multiplication). False = &quot;before&quot; (default), True = &quot;after&quot; (CuDNN compatible).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f30369db80b8df66e066857b52ef066913f216c1" translate="yes" xml:space="preserve">
          <source>GRU convention (whether to apply reset gate after or before matrix multiplication). False = &quot;before&quot;, True = &quot;after&quot; (default and CuDNN compatible).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f27a3272df11e6421ae7abecb1025fb3c735f83f" translate="yes" xml:space="preserve">
          <source>GRUBlockCell</source>
          <target state="translated">GRUBlockCell</target>
        </trans-unit>
        <trans-unit id="8fb826d8ab1769785d7dd590b317670658d293c0" translate="yes" xml:space="preserve">
          <source>GRUBlockCellGrad</source>
          <target state="translated">GRUBlockCellGrad</target>
        </trans-unit>
        <trans-unit id="3c8a873ea949d50ad1aac033a294a578fd5c4e69" translate="yes" xml:space="preserve">
          <source>Gamma distribution.</source>
          <target state="translated">Distribución gamma.</target>
        </trans-unit>
        <trans-unit id="9f031510b482abd8e720846e8669696f7e91ec56" translate="yes" xml:space="preserve">
          <source>Gated Recurrent Unit - Cho et al. 2014.</source>
          <target state="translated">Gated Recurrent Unit-Cho et al.2014.</target>
        </trans-unit>
        <trans-unit id="69e499dfe689408aae1f951c32b8c1bbc6c2faf0" translate="yes" xml:space="preserve">
          <source>Gated Recurrent Unit cell (cf.</source>
          <target state="translated">Célula de la Unidad Recurrente Gated (cf.</target>
        </trans-unit>
        <trans-unit id="705812755333cca60e8bb82127bf5e243f85b469" translate="yes" xml:space="preserve">
          <source>Gated Recurrent Unit cell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d85fb4eb9b5275137b92e9c14d3dd2b6f13641af" translate="yes" xml:space="preserve">
          <source>Gather</source>
          <target state="translated">Gather</target>
        </trans-unit>
        <trans-unit id="60f8851e1dff47acde3e681a835a618b6909d153" translate="yes" xml:space="preserve">
          <source>Gather ragged slices from &lt;code&gt;params&lt;/code&gt; axis &lt;code&gt;0&lt;/code&gt; according to &lt;code&gt;indices&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b3a55dbaf071c80cf233d7df7f2695129eb5aa3" translate="yes" xml:space="preserve">
          <source>Gather slices from &lt;code&gt;params&lt;/code&gt; according to &lt;code&gt;indices&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c659ab9d2af864152ee3bccc51bb3c0d68f7ab80" translate="yes" xml:space="preserve">
          <source>Gather slices from &lt;code&gt;params&lt;/code&gt; axis &lt;code&gt;axis&lt;/code&gt; according to &lt;code&gt;indices&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d20e4a3a201cb2fbb73307001cac40611d72da6" translate="yes" xml:space="preserve">
          <source>Gather slices from &lt;code&gt;params&lt;/code&gt; into a Tensor with shape specified by &lt;code&gt;indices&lt;/code&gt;.</source>
          <target state="translated">Re&amp;uacute;na cortes de &lt;code&gt;params&lt;/code&gt; en un tensor con forma especificada por &lt;code&gt;indices&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="299d0ae5001a60c54f445823747df39bdc8fe265" translate="yes" xml:space="preserve">
          <source>Gather slices from params according to indices with leading batch dims. (deprecated)</source>
          <target state="translated">Reúne las rebanadas de los paramos de acuerdo con los índices con los principales lotes de dimisión.(desaprobado)</target>
        </trans-unit>
        <trans-unit id="f262790bfae9447f613388f0f2dfc06ee3e6e9af" translate="yes" xml:space="preserve">
          <source>Gather slices from params axis &lt;code&gt;axis&lt;/code&gt; according to &lt;code&gt;indices&lt;/code&gt;. &lt;code&gt;indices&lt;/code&gt; must be an integer tensor of any dimension (usually 0-D or 1-D).</source>
          <target state="translated">Re&amp;uacute;na cortes del eje del &lt;code&gt;axis&lt;/code&gt; de par&amp;aacute;metros de acuerdo con los &lt;code&gt;indices&lt;/code&gt; . &lt;code&gt;indices&lt;/code&gt; deben ser un tensor entero de cualquier dimensi&amp;oacute;n (generalmente 0-D o ​​1-D).</target>
        </trans-unit>
        <trans-unit id="9f385f50f48df2546a7fa47ac7842fb6cb974b02" translate="yes" xml:space="preserve">
          <source>Gather slices from params axis &lt;code&gt;axis&lt;/code&gt; according to indices.</source>
          <target state="translated">Re&amp;uacute;na cortes del eje del &lt;code&gt;axis&lt;/code&gt; de par&amp;aacute;metros de acuerdo con los &amp;iacute;ndices.</target>
        </trans-unit>
        <trans-unit id="e17db4db1be26624736cd7163c7e0a82b1dfd230" translate="yes" xml:space="preserve">
          <source>Gather slices from params axis axis according to indices.</source>
          <target state="translated">Reúne las rebanadas del eje de los paramos de acuerdo con los índices.</target>
        </trans-unit>
        <trans-unit id="73d587e4f9866c119bef7eb8951aad10a8ad7680" translate="yes" xml:space="preserve">
          <source>Gather slices from the variable pointed to by &lt;code&gt;resource&lt;/code&gt; according to &lt;code&gt;indices&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bc621ab1a08f4a178453d70596dcee1791211d7" translate="yes" xml:space="preserve">
          <source>Gather specific elements from the TensorArray into output &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d75d7d6f79f6c643b60649fcc6961cd4aaf7d3ff" translate="yes" xml:space="preserve">
          <source>GatherNd</source>
          <target state="translated">GatherNd</target>
        </trans-unit>
        <trans-unit id="9bb2e60bbbfd1cff13478f3217fccff50b488e00" translate="yes" xml:space="preserve">
          <source>GatherV2</source>
          <target state="translated">GatherV2</target>
        </trans-unit>
        <trans-unit id="1b380773b6f24a5afe663b7e22de6423bb935598" translate="yes" xml:space="preserve">
          <source>Gating Gradients</source>
          <target state="translated">Gradientes de la compuerta</target>
        </trans-unit>
        <trans-unit id="44813df257901f45ff9b654c8ba3ddd39d5df9b6" translate="yes" xml:space="preserve">
          <source>Gaussian: &lt;code&gt;K(x, y) == exp(- square(x - y) / (2 * square(scale)))&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f72dabec415cca8805069ec0515ea199976c6048" translate="yes" xml:space="preserve">
          <source>General case:</source>
          <target state="translated">Un caso general:</target>
        </trans-unit>
        <trans-unit id="6368188d3687992a62f99d6b7334f52aaac43948" translate="yes" xml:space="preserve">
          <source>Generalization of &lt;a href=&quot;scatter_update&quot;&gt;&lt;code&gt;tf.compat.v1.scatter_update&lt;/code&gt;&lt;/a&gt; to axis different than 0. (deprecated)</source>
          <target state="translated">Generalizaci&amp;oacute;n de &lt;a href=&quot;scatter_update&quot;&gt; &lt;code&gt;tf.compat.v1.scatter_update&lt;/code&gt; &lt;/a&gt; a un eje diferente a 0. (obsoleto)</target>
        </trans-unit>
        <trans-unit id="eb11ae4a716352e80393f10cd2fbf3c5ef996fc6" translate="yes" xml:space="preserve">
          <source>Generally a single example in training data is described with FeatureColumns. At the first layer of the model, this column oriented data should be converted to a single &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="translated">Generalmente, un solo ejemplo en datos de entrenamiento se describe con FeatureColumns. En la primera capa del modelo, estos datos orientados a columnas deben convertirse en un solo &lt;code&gt;Tensor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c63e0117b37d1fc0d3a2fdf6f89aed5b55248ac" translate="yes" xml:space="preserve">
          <source>Generally a single example in training data is described with FeatureColumns. At the first layer of the model, this column-oriented data should be converted to a single &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8de3a173a70a93846ce03fd16984e4335207f7a1" translate="yes" xml:space="preserve">
          <source>Generally it is best if the shard operator is used early in the dataset pipeline. For example, when reading from a set of TFRecord files, shard before converting the dataset to input samples. This avoids reading every file on every worker. The following is an example of an efficient sharding strategy within a complete pipeline:</source>
          <target state="translated">Generalmente es mejor si el operador del fragmento se utiliza al principio del proceso de datos.Por ejemplo,cuando se lee de un conjunto de archivos TFRecord,escóndete antes de convertir el conjunto de datos en muestras de entrada.Esto evita leer cada archivo de cada trabajador.El siguiente es un ejemplo de una estrategia de fragmentación eficiente dentro de una tubería completa:</target>
        </trans-unit>
        <trans-unit id="e2dd4981d0a29e58e9fcc5b1a49943c316b64754" translate="yes" xml:space="preserve">
          <source>Generate a &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.kaiser.html&quot;&gt;Kaiser window&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90b4629b3e84cf9ddd69d1cfdd41ef3ba86e8a84" translate="yes" xml:space="preserve">
          <source>Generate a &lt;a href=&quot;https://en.wikipedia.org/wiki/Kaiser_window#Kaiser%E2%80%93Bessel-derived_(KBD)_window&quot;&gt;Kaiser Bessel derived window&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11d7cd9f12caac64f12dc084266511c05d1e68e5" translate="yes" xml:space="preserve">
          <source>Generate a &lt;a href=&quot;https://en.wikipedia.org/wiki/Modified_discrete_cosine_transform#Window_functions&quot;&gt;Vorbis power complementary window&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34347d3edc6f1c3feaba292295a44f85ae9283b4" translate="yes" xml:space="preserve">
          <source>Generate a &lt;a href=&quot;https://en.wikipedia.org/wiki/Window_function#Hann_and_Hamming_windows&quot;&gt;Hamming&lt;/a&gt; window.</source>
          <target state="translated">Genere una ventana de &lt;a href=&quot;https://en.wikipedia.org/wiki/Window_function#Hann_and_Hamming_windows&quot;&gt;Hamming&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="279c13b7205ad932f6fc77bc4c11a570af2e0643" translate="yes" xml:space="preserve">
          <source>Generate a &lt;a href=&quot;https://en.wikipedia.org/wiki/Window_function#Hann_and_Hamming_windows&quot;&gt;Hann window&lt;/a&gt;.</source>
          <target state="translated">Genere una &lt;a href=&quot;https://en.wikipedia.org/wiki/Window_function#Hann_and_Hamming_windows&quot;&gt;ventana de Hann&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ac32a415109d1780683dc87c835b4bf44b9e214f" translate="yes" xml:space="preserve">
          <source>Generate a SignatureDef proto for inclusion in a MetaGraphDef.</source>
          <target state="translated">Generar un prototipo de SignatureDef para su inclusión en un MetaGraphDef.</target>
        </trans-unit>
        <trans-unit id="c002c4b3ce23a9d11b517e557ca82ee3b02cef6f" translate="yes" xml:space="preserve">
          <source>Generate a glob pattern matching all sharded file names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b79e30cedbd9d694f0b8690f5c2126451ebafb1" translate="yes" xml:space="preserve">
          <source>Generate a pprof profile gzip file.</source>
          <target state="translated">Generar un archivo gzip de perfil pprof.</target>
        </trans-unit>
        <trans-unit id="ffe3bd416f54a13ea7f1d20611db6869a2732c01" translate="yes" xml:space="preserve">
          <source>Generate a sharded filename. The filename is printf formatted as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1371c069157738d08a42f8452b9b9196d90ec61" translate="yes" xml:space="preserve">
          <source>Generate a single randomly distorted bounding box for an image.</source>
          <target state="translated">Generar un solo cuadro delimitador distorsionado al azar para una imagen.</target>
        </trans-unit>
        <trans-unit id="ac024cfebf615ec9550fa9639992f999e3b2ee72" translate="yes" xml:space="preserve">
          <source>Generate a single randomly distorted bounding box for an image. (deprecated)</source>
          <target state="translated">Generar un solo cuadro delimitador distorsionado al azar para una imagen.(desaprobado)</target>
        </trans-unit>
        <trans-unit id="a513f309f426925500e16fda01716dda1ec01c9d" translate="yes" xml:space="preserve">
          <source>Generate a timeline json file.</source>
          <target state="translated">Generar un archivo json de línea de tiempo.</target>
        </trans-unit>
        <trans-unit id="a4b61b9eadd182e79e8d7ca8f5436072061f5cd0" translate="yes" xml:space="preserve">
          <source>Generate batches of tensor image data with real-time data augmentation.</source>
          <target state="translated">Generar lotes de datos de imágenes de tensores con aumento de datos en tiempo real.</target>
        </trans-unit>
        <trans-unit id="8e985d2b987cc5cfe48af402ebd8ddad192ec795" translate="yes" xml:space="preserve">
          <source>Generate bounding box proposals from encoded bounding boxes.</source>
          <target state="translated">Generar propuestas de cajas delimitadoras a partir de cajas delimitadoras codificadas.</target>
        </trans-unit>
        <trans-unit id="c0ad06dc54e9b19d8f565750f7f75ca4b2cfa07b" translate="yes" xml:space="preserve">
          <source>Generate class predictions for the input samples.</source>
          <target state="translated">Generar predicciones de clase para las muestras de entrada.</target>
        </trans-unit>
        <trans-unit id="e88196696cce2f195fee6d21c523e69e11454eb0" translate="yes" xml:space="preserve">
          <source>Generate class predictions for the input samples. (deprecated)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7093df80f13988f753b4ffb41362fefaef5f111" translate="yes" xml:space="preserve">
          <source>Generate samples of the specified shape.</source>
          <target state="translated">Generar muestras de la forma especificada.</target>
        </trans-unit>
        <trans-unit id="576d0866bf17ce5f09b194820a38f8952d6e4b06" translate="yes" xml:space="preserve">
          <source>Generate the bucket boundaries for each feature based on accumulated summaries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e9203d473bfc408cbd4f794fe904486104787f9" translate="yes" xml:space="preserve">
          <source>Generate the set of all classes.</source>
          <target state="translated">Generar el conjunto de todas las clases.</target>
        </trans-unit>
        <trans-unit id="23f698bd99350dfeeb28f80c4b7d56c43289deab" translate="yes" xml:space="preserve">
          <source>GenerateBoundingBoxProposals</source>
          <target state="translated">GenerateBoundingBoxProposals</target>
        </trans-unit>
        <trans-unit id="3b1c4b8d98e609c7742c5fa5ed5d888e187de455" translate="yes" xml:space="preserve">
          <source>GenerateVocabRemapping</source>
          <target state="translated">GenerateVocabRemapping</target>
        </trans-unit>
        <trans-unit id="dd09a6e5d58951f89fcc802fecad98e6223e4700" translate="yes" xml:space="preserve">
          <source>Generates &lt;a href=&quot;../distributedvalues&quot;&gt;&lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt;&lt;/a&gt; from &lt;code&gt;value_fn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9836cccd1541d8044f475f870ee2ee77b1a6027f" translate="yes" xml:space="preserve">
          <source>Generates &lt;a href=&quot;distributedvalues&quot;&gt;&lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt;&lt;/a&gt; from &lt;code&gt;value_fn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f43bcd2870c5432e0a747c0e7e61691f6c6d69d4" translate="yes" xml:space="preserve">
          <source>Generates a &lt;a href=&quot;../../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; from image files in a directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f6d1ff08babf239e90da6e16be908dfc487e187" translate="yes" xml:space="preserve">
          <source>Generates a &lt;a href=&quot;../../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; from text files in a directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="377bb61844f7989feb179e9255bc056adafe1698" translate="yes" xml:space="preserve">
          <source>Generates a &lt;code&gt;SaverDef&lt;/code&gt; representation of this saver.</source>
          <target state="translated">Genera una representaci&amp;oacute;n &lt;code&gt;SaverDef&lt;/code&gt; de este ahorrador.</target>
        </trans-unit>
        <trans-unit id="ebd6ec5178119ea6a1811d87dd13d57c9a6db943" translate="yes" xml:space="preserve">
          <source>Generates a MultiDeviceIterator resource from its provided string handle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45ca970a93e98f0a96c6dd41425b7de72d75abbf" translate="yes" xml:space="preserve">
          <source>Generates a checkpoint state proto.</source>
          <target state="translated">Genera un prototipo de estado de control.</target>
        </trans-unit>
        <trans-unit id="2af4bf65e2bb4f1d1dd68fd49dd2b53aac1939ec" translate="yes" xml:space="preserve">
          <source>Generates a feature cross from a list of tensors, and returns it as a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="825f6429255ba775713386b0d2f3a17166359e07" translate="yes" xml:space="preserve">
          <source>Generates a window function that can be used in &lt;code&gt;inverse_stft&lt;/code&gt;.</source>
          <target state="translated">Genera una funci&amp;oacute;n de ventana que se puede usar en &lt;code&gt;inverse_stft&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47b0fd38944f765d01ecdf4f5dde5c9129216b79" translate="yes" xml:space="preserve">
          <source>Generates a word rank-based probabilistic sampling table.</source>
          <target state="translated">Genera una tabla de muestreo probabilístico basada en el rango de palabras.</target>
        </trans-unit>
        <trans-unit id="1eaf3ef20aca17d2ddd855b709da877935b5c644" translate="yes" xml:space="preserve">
          <source>Generates class probability predictions for the input samples.</source>
          <target state="translated">Genera predicciones de probabilidad de clase para las muestras de entrada.</target>
        </trans-unit>
        <trans-unit id="acbdf4f7e996764e39f5a1d460a1590720b7ffed" translate="yes" xml:space="preserve">
          <source>Generates class probability predictions for the input samples. (deprecated)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="649bbae2e63ab9a653a1bbb3ef6140122196b569" translate="yes" xml:space="preserve">
          <source>Generates evenly-spaced values in an interval along a given axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12a10bcf16b64dd9017853e6b82862f0dc5c5e73" translate="yes" xml:space="preserve">
          <source>Generates feature cross from a list of tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2e65b80cc8c5def122f20b61b5d83b821ccc7ce" translate="yes" xml:space="preserve">
          <source>Generates fingerprint values of &lt;code&gt;data&lt;/code&gt;.</source>
          <target state="translated">Genera valores de huellas dactilares de &lt;code&gt;data&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e89a59f26ad8f607008d022c7aae25b086f3ec9e" translate="yes" xml:space="preserve">
          <source>Generates fingerprint values.</source>
          <target state="translated">Genera los valores de las huellas dactilares.</target>
        </trans-unit>
        <trans-unit id="dbdf2df393e7c5b28c8c46b716424d6d5f6d05e3" translate="yes" xml:space="preserve">
          <source>Generates hashed feature cross from a list of tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecd2cd43082dd2fa1d698670c924b8a9339f3115" translate="yes" xml:space="preserve">
          <source>Generates hashed sparse cross from a list of sparse and dense tensors.</source>
          <target state="translated">Genera una cruz rala de una lista de tensores ralos y densos.</target>
        </trans-unit>
        <trans-unit id="39625478ffa83ceceb283552bff4daf578ea3d67" translate="yes" xml:space="preserve">
          <source>Generates labels for candidate sampling with a learned unigram distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="494f1bcb0d30b701f7c55dd7dbcf0c95bbc04be8" translate="yes" xml:space="preserve">
          <source>Generates labels for candidate sampling with a log-uniform distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d38f8146d8f4aa0acc79c3ad874070501094862" translate="yes" xml:space="preserve">
          <source>Generates labels for candidate sampling with a uniform distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d830604723f094db9bc24fb88a7e02736a2c3056" translate="yes" xml:space="preserve">
          <source>Generates output predictions for the input samples.</source>
          <target state="translated">Genera predicciones de salida para las muestras de entrada.</target>
        </trans-unit>
        <trans-unit id="b249d65bf0f914d4110d91f913e1300c01aa2889" translate="yes" xml:space="preserve">
          <source>Generates parsing spec for tf.parse_example to be used with classifiers.</source>
          <target state="translated">Genera especificaciones de análisis para tf.parse_example para ser usadas con los clasificadores.</target>
        </trans-unit>
        <trans-unit id="1aae58a59256b1fc205171c419f649a6e0c1ac2c" translate="yes" xml:space="preserve">
          <source>Generates parsing spec for tf.parse_example to be used with regressors.</source>
          <target state="translated">Genera especificaciones de análisis para tf.parse_example para ser usadas con los regresores.</target>
        </trans-unit>
        <trans-unit id="7d0f6811f98e9f7451ddd47d27cbbd2d502a54ba" translate="yes" xml:space="preserve">
          <source>Generates points from the Sobol sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2df3b2c3bfd14ecb54ef8d497e84f89bbccb46c" translate="yes" xml:space="preserve">
          <source>Generates predictions for the input samples from a data generator. (deprecated)</source>
          <target state="translated">Genera predicciones para las muestras de entrada de un generador de datos.(desaprobado)</target>
        </trans-unit>
        <trans-unit id="f0b782326dc1552a60227a419a223dd58df3f275" translate="yes" xml:space="preserve">
          <source>Generates random parameters for a transformation.</source>
          <target state="translated">Genera parámetros aleatorios para una transformación.</target>
        </trans-unit>
        <trans-unit id="29c08e7ff9dc1d9fd5830b7df9e2c9f201d13165" translate="yes" xml:space="preserve">
          <source>Generates seeds for stateless random ops.</source>
          <target state="translated">Genera semillas para operaciones aleatorias sin estado.</target>
        </trans-unit>
        <trans-unit id="929055b21af18b1410a5ef9e6f627e2fe967eded" translate="yes" xml:space="preserve">
          <source>Generates skipgram word pairs.</source>
          <target state="translated">Genera pares de palabras de salto.</target>
        </trans-unit>
        <trans-unit id="c717f055df49ec5bd1aa8121ba707a81fd38bcab" translate="yes" xml:space="preserve">
          <source>Generates sparse cross from a list of sparse and dense tensors.</source>
          <target state="translated">Genera una cruz dispersa a partir de una lista de tensores dispersos y densos.</target>
        </trans-unit>
        <trans-unit id="eee7e06216ccc809aac0d41b4d65812d7279baab" translate="yes" xml:space="preserve">
          <source>Generates the RaggedTensor &lt;code&gt;row_splits&lt;/code&gt; corresponding to a segmentation.</source>
          <target state="translated">Genera los row_splits de &lt;code&gt;row_splits&lt;/code&gt; correspondientes a una segmentaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9c8ebc23fb3d11a9fa1612cc64fdaa5515b59f5b" translate="yes" xml:space="preserve">
          <source>Generates the segmentation corresponding to a RaggedTensor &lt;code&gt;row_splits&lt;/code&gt;.</source>
          <target state="translated">Genera la segmentaci&amp;oacute;n correspondiente a un RaggedTensor &lt;code&gt;row_splits&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="847054fadb60634ee2f52424f471fb76a80ae831" translate="yes" xml:space="preserve">
          <source>Generates values in an interval.</source>
          <target state="translated">Genera valores en un intervalo.</target>
        </trans-unit>
        <trans-unit id="f83f1b24a7b8176a12bbd8754dc347723cff3a26" translate="yes" xml:space="preserve">
          <source>GeneratorDataset</source>
          <target state="translated">GeneratorDataset</target>
        </trans-unit>
        <trans-unit id="dd2f789a1badf7c47aa6e96fdc59fb1ae83e7fe2" translate="yes" xml:space="preserve">
          <source>Generic entry point script.</source>
          <target state="translated">Guión genérico de punto de entrada.</target>
        </trans-unit>
        <trans-unit id="2c95b2ae6664568cd6a269ff2188bf2127d2b537" translate="yes" xml:space="preserve">
          <source>Get a dictionary describing TensorFlow's build environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d7e04da7f8fb8474d86e3fc36734ea9ac641c99" translate="yes" xml:space="preserve">
          <source>Get a direct path to the data files colocated with the script.</source>
          <target state="translated">Obtener una ruta directa a los archivos de datos colocados con el guión.</target>
        </trans-unit>
        <trans-unit id="25e90702cc2a6266a80ebe5d73070c2394a2d997" translate="yes" xml:space="preserve">
          <source>Get a partitioner for VariableScope to keep shards below &lt;code&gt;max_shard_bytes&lt;/code&gt;.</source>
          <target state="translated">Obtenga un particionador para VariableScope para mantener los fragmentos por debajo de &lt;code&gt;max_shard_bytes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59040295d5cb452ad25fbe2e72127aba826b97ef" translate="yes" xml:space="preserve">
          <source>Get a root directory containing all the data attributes in the build rule.</source>
          <target state="translated">Obtener un directorio raíz que contenga todos los atributos de datos de la regla de construcción.</target>
        </trans-unit>
        <trans-unit id="bb88a5384f5bc20bdadfdbaa3c133110e4b6085f" translate="yes" xml:space="preserve">
          <source>Get experimental optimizer options.</source>
          <target state="translated">Consigue opciones de optimizador experimental.</target>
        </trans-unit>
        <trans-unit id="a2113882a890fee2c46d1a70f2c5138bd06f0eb7" translate="yes" xml:space="preserve">
          <source>Get from cache or create a default operation.</source>
          <target state="translated">Obtener de la caché o crear una operación por defecto.</target>
        </trans-unit>
        <trans-unit id="b670781c96420a037469ad0934765b418deb4d2f" translate="yes" xml:space="preserve">
          <source>Get if JIT compilation is enabled.</source>
          <target state="translated">Obtener si la compilación JIT está activada.</target>
        </trans-unit>
        <trans-unit id="69a0067636164f576df746229abb6b9aaceb5ae6" translate="yes" xml:space="preserve">
          <source>Get if device placements are logged.</source>
          <target state="translated">Consigue si se registran las colocaciones de los dispositivos.</target>
        </trans-unit>
        <trans-unit id="498721b0192fabfcd02ce495785bf7613c9f7cee" translate="yes" xml:space="preserve">
          <source>Get if memory growth is enabled for a &lt;code&gt;PhysicalDevice&lt;/code&gt;.</source>
          <target state="translated">Obtener si el crecimiento de memoria est&amp;aacute; habilitado para un &lt;code&gt;PhysicalDevice&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58ef7dbc31c00f8af4807e08acd0430c855e1d84" translate="yes" xml:space="preserve">
          <source>Get if soft device placement is enabled.</source>
          <target state="translated">Obtener si la colocación de dispositivos blandos está habilitada.</target>
        </trans-unit>
        <trans-unit id="c9c7c6ec42a6b32f83fcca563a931ba4fbe0ed3b" translate="yes" xml:space="preserve">
          <source>Get number of threads used for parallelism between independent operations.</source>
          <target state="translated">Obtener el número de hilos utilizados para el paralelismo entre las operaciones independientes.</target>
        </trans-unit>
        <trans-unit id="80b95985b48aaafa3e792986341c8b4ff88eead6" translate="yes" xml:space="preserve">
          <source>Get number of threads used within an individual op for parallelism.</source>
          <target state="translated">Obtener el número de hilos utilizados dentro de una operación individual para el paralelismo.</target>
        </trans-unit>
        <trans-unit id="6fc794e6fd1f995204b4b699515f189ad3b79ac8" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;TensorShape&lt;/code&gt; representing the shape of the dense tensor.</source>
          <target state="translated">Obt&amp;eacute;n &lt;code&gt;TensorShape&lt;/code&gt; que representa la forma del tensor denso.</target>
        </trans-unit>
        <trans-unit id="53ea60d80b4295960ae12cbdab1a207aed855693" translate="yes" xml:space="preserve">
          <source>Get the KL-divergence KL(distribution_a || distribution_b). (deprecated)</source>
          <target state="translated">Consigue la división KL(distribución_a |||distribución_b).(depreciado)</target>
        </trans-unit>
        <trans-unit id="0bf696fef5a21374d09e8355388763caa023a426" translate="yes" xml:space="preserve">
          <source>Get the Master string to be used for the session.</source>
          <target state="translated">Consigue que la cuerda maestra se use para la sesión.</target>
        </trans-unit>
        <trans-unit id="108dacf621a6cd835ace3ba57aa80d2b5e19236d" translate="yes" xml:space="preserve">
          <source>Get the compilation flags for custom operators.</source>
          <target state="translated">Consigue las banderas de compilación para los operadores personalizados.</target>
        </trans-unit>
        <trans-unit id="b7741d8625c9ab518a4a96df253f1b4a18258c89" translate="yes" xml:space="preserve">
          <source>Get the current size of the TensorArray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ae51f237cd7e7c81a09e6f89ce59cb258772427" translate="yes" xml:space="preserve">
          <source>Get the directory containing the TensorFlow C++ header files.</source>
          <target state="translated">Consigue el directorio que contiene los archivos de cabecera de TensorFlow C++.</target>
        </trans-unit>
        <trans-unit id="359b660afd7e217497634736e8bd4bb55153be9c" translate="yes" xml:space="preserve">
          <source>Get the directory containing the TensorFlow framework library.</source>
          <target state="translated">Consigue el directorio que contiene la biblioteca del marco de trabajo de TensorFlow.</target>
        </trans-unit>
        <trans-unit id="1b86ea9f05146578b1054be5bc6cba1a144e94aa" translate="yes" xml:space="preserve">
          <source>Get the dropout mask for RNN cell's input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac67fd4c2118b549293e874899270e15a2f87c37" translate="yes" xml:space="preserve">
          <source>Get the embedding results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="650bdecea08ce6ef81b38eabb82f7de00f8d7991" translate="yes" xml:space="preserve">
          <source>Get the global step tensor.</source>
          <target state="translated">Consigue el tensor de paso global.</target>
        </trans-unit>
        <trans-unit id="fc3b1d0c5d3365a3eaff90c6cf36385cdaa1ba29" translate="yes" xml:space="preserve">
          <source>Get the link flags for custom operators.</source>
          <target state="translated">Consigue las banderas de enlace para los operadores personalizados.</target>
        </trans-unit>
        <trans-unit id="e5b8a3ccddd79a33c1a86a133a701f8165f54b2b" translate="yes" xml:space="preserve">
          <source>Get the list of visible physical devices.</source>
          <target state="translated">Consigue la lista de dispositivos físicos visibles.</target>
        </trans-unit>
        <trans-unit id="921a66e34ee4a58c84a0efa213945cee146717d6" translate="yes" xml:space="preserve">
          <source>Get the path to the specified file in the data dependencies.</source>
          <target state="translated">Obtener la ruta de acceso al archivo especificado en las dependencias de datos.</target>
        </trans-unit>
        <trans-unit id="b6dd8217ee8de67bf5164159422b42d807287473" translate="yes" xml:space="preserve">
          <source>Get the recurrent dropout mask for RNN cell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c31cddaa67a87523e9d1624fa98876319984d178" translate="yes" xml:space="preserve">
          <source>Get the tensor of type &lt;code&gt;dtype&lt;/code&gt; by feeding a tensor handle.</source>
          <target state="translated">Obtenga el tensor de tipo &lt;code&gt;dtype&lt;/code&gt; alimentando un control tensor.</target>
        </trans-unit>
        <trans-unit id="c3cd44016bc9caf57517296a543e5f07cc70b58f" translate="yes" xml:space="preserve">
          <source>Get the value of the tensor from a tensor handle. The tensor is produced in a previous run() and stored in the state of the session.</source>
          <target state="translated">Obtener el valor del tensor de un mango de tensor.El tensor se produce en una ejecución previa()y se almacena en el estado de la sesión.</target>
        </trans-unit>
        <trans-unit id="0b696c4e43749193b332192827a0f793184a5d68" translate="yes" xml:space="preserve">
          <source>Get the value of the tensor specified by its handle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35948203feb263f7dc9fb059f6619c9f87908726" translate="yes" xml:space="preserve">
          <source>Get the virtual device configuration for a &lt;a href=&quot;physicaldevice&quot;&gt;&lt;code&gt;tf.config.PhysicalDevice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Obtenga la configuraci&amp;oacute;n del dispositivo virtual para un &lt;a href=&quot;physicaldevice&quot;&gt; &lt;code&gt;tf.config.PhysicalDevice&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0644eda96e6748128f29f7007c63dd9693a38f23" translate="yes" xml:space="preserve">
          <source>Get this scope's global variables.</source>
          <target state="translated">Consigue las variables globales de este alcance.</target>
        </trans-unit>
        <trans-unit id="887d65a3c67be69818d4fa832142026519a1083d" translate="yes" xml:space="preserve">
          <source>Get this scope's local variables.</source>
          <target state="translated">Consigue las variables locales de este alcance.</target>
        </trans-unit>
        <trans-unit id="a308585ffe5c9c1e87f02af3bd65c090f3a450c2" translate="yes" xml:space="preserve">
          <source>Get this scope's trainable variables.</source>
          <target state="translated">Consigue las variables entrenables de este telescopio.</target>
        </trans-unit>
        <trans-unit id="057e2633d0656b1fb510dea575a522fc49d9405f" translate="yes" xml:space="preserve">
          <source>Get this scope's variables.</source>
          <target state="translated">Consigue las variables de este alcance.</target>
        </trans-unit>
        <trans-unit id="5795bd8bcbae0c5fe909ec39b6d58c353b7d8911" translate="yes" xml:space="preserve">
          <source>Get unique labels and indices for batched labels for &lt;a href=&quot;ctc_loss&quot;&gt;&lt;code&gt;tf.nn.ctc_loss&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Obtenga etiquetas e &amp;iacute;ndices &amp;uacute;nicos para etiquetas por &lt;a href=&quot;ctc_loss&quot;&gt; &lt;code&gt;tf.nn.ctc_loss&lt;/code&gt; &lt;/a&gt; para tf.nn.ctc_loss .</target>
        </trans-unit>
        <trans-unit id="ad80c7ad74f9cfd40d20ded5dcca808ac13dcbc8" translate="yes" xml:space="preserve">
          <source>GetSessionHandle</source>
          <target state="translated">GetSessionHandle</target>
        </trans-unit>
        <trans-unit id="2179dea7e98769d4809990545d7093de795b9aae" translate="yes" xml:space="preserve">
          <source>GetSessionHandleV2</source>
          <target state="translated">GetSessionHandleV2</target>
        </trans-unit>
        <trans-unit id="a40b5c806adbe4a5fe6b4c1812438a81bf678aa7" translate="yes" xml:space="preserve">
          <source>GetSessionTensor</source>
          <target state="translated">GetSessionTensor</target>
        </trans-unit>
        <trans-unit id="e5f58f3a07d14b9e0032e44d6a23fe568ceffa8e" translate="yes" xml:space="preserve">
          <source>Gets a numpy-style shape tuple giving the dataset dimensions.</source>
          <target state="translated">Consigue una tupla de forma numérica que da las dimensiones del conjunto de datos.</target>
        </trans-unit>
        <trans-unit id="16edd56dc8f500661a54f70ff8aa5d3642a74f3d" translate="yes" xml:space="preserve">
          <source>Gets an existing &lt;em&gt;local&lt;/em&gt; variable or creates a new one.</source>
          <target state="translated">Obtiene una variable &lt;em&gt;local&lt;/em&gt; existente o crea una nueva.</target>
        </trans-unit>
        <trans-unit id="8363344ba8552991690effa2b825a04c73499304" translate="yes" xml:space="preserve">
          <source>Gets an existing variable with these parameters or create a new one.</source>
          <target state="translated">Obtener una variable existente con estos parámetros o crear una nueva.</target>
        </trans-unit>
        <trans-unit id="c705ed15a7fab0aed052398593737c16839589c3" translate="yes" xml:space="preserve">
          <source>Gets an existing variable with this name or create a new one.</source>
          <target state="translated">Consigue una variable existente con este nombre o crea una nueva.</target>
        </trans-unit>
        <trans-unit id="e6eb4b621d4c64dca0de29b3b8a401e1cd6303ba" translate="yes" xml:space="preserve">
          <source>Gets batch at position &lt;code&gt;index&lt;/code&gt;.</source>
          <target state="translated">Obtiene el lote en el &lt;code&gt;index&lt;/code&gt; posici&amp;oacute;n .</target>
        </trans-unit>
        <trans-unit id="9241f5d7bcc0a690cd669562fcda23fde5204e95" translate="yes" xml:space="preserve">
          <source>Gets model input details.</source>
          <target state="translated">Obtiene los detalles de la entrada del modelo.</target>
        </trans-unit>
        <trans-unit id="7cb340e682cc8a13364fea269654750b9f7ffa8f" translate="yes" xml:space="preserve">
          <source>Gets model output details.</source>
          <target state="translated">Obtiene detalles de la salida del modelo.</target>
        </trans-unit>
        <trans-unit id="12c82d522842fce5b68907e9a09973a0aa4e2bf3" translate="yes" xml:space="preserve">
          <source>Gets next element for the provided shard number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1176b88ed9f974924ce3c2aed58b5efc5abf028f" translate="yes" xml:space="preserve">
          <source>Gets parameters for this estimator.</source>
          <target state="translated">Obtiene los parámetros para este estimador.</target>
        </trans-unit>
        <trans-unit id="bf1b6d34570c76b9b641b4a8fdf7b56eacc074a4" translate="yes" xml:space="preserve">
          <source>Gets tensor details for every tensor with valid tensor details.</source>
          <target state="translated">Obtiene los detalles del tensor para cada tensor con detalles de tensor válidos.</target>
        </trans-unit>
        <trans-unit id="3f6f5f2772b01d65cdb20576211da5d66d43f685" translate="yes" xml:space="preserve">
          <source>Gets the &lt;a href=&quot;tensorshape&quot;&gt;&lt;code&gt;tf.TensorShape&lt;/code&gt;&lt;/a&gt; representing the shape of the dense tensor.</source>
          <target state="translated">Obtiene &lt;a href=&quot;tensorshape&quot;&gt; &lt;code&gt;tf.TensorShape&lt;/code&gt; que&lt;/a&gt; representa la forma del tensor denso.</target>
        </trans-unit>
        <trans-unit id="5649b7730a87257a8bf757eb14d5d260e4d8989f" translate="yes" xml:space="preserve">
          <source>Gets the checkpoint state given the provided checkpoint_dir and looks for a corresponding TensorFlow 2 (preferred) or TensorFlow 1.x checkpoint path. The latest_filename argument is only applicable if you are saving checkpoint using &lt;code&gt;v1.Saver.save&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edf919a5da9968403435a8f5bed01d1084154593" translate="yes" xml:space="preserve">
          <source>Gets the crossed output from a partial list/tuple of inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0911c623c2e60904843307f59585e7a371b0bc73" translate="yes" xml:space="preserve">
          <source>Gets the current device policy.</source>
          <target state="translated">Tiene la política actual de los dispositivos.</target>
        </trans-unit>
        <trans-unit id="84ad69761c8ff8c302a3208721f28483a943e063" translate="yes" xml:space="preserve">
          <source>Gets the datatype of the dataset.</source>
          <target state="translated">Obtiene el tipo de datos del conjunto de datos.</target>
        </trans-unit>
        <trans-unit id="c0ad71d1c926ecf4a236b3b9ed68592ba6894254" translate="yes" xml:space="preserve">
          <source>Gets the list of losses from the loss_collection.</source>
          <target state="translated">Obtiene la lista de pérdidas de la colección de pérdidas.</target>
        </trans-unit>
        <trans-unit id="d33e19f642cb6ca8f7cdb89e56c9383004a73014" translate="yes" xml:space="preserve">
          <source>Gets the list of regularization losses.</source>
          <target state="translated">Obtiene la lista de pérdidas por regularización.</target>
        </trans-unit>
        <trans-unit id="3bbcd4bcf488d6f0e10e7505b28c43087a823f71" translate="yes" xml:space="preserve">
          <source>Gets the next output from the given iterator .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94576ff1b1b843455454082862a97d7ef6376959" translate="yes" xml:space="preserve">
          <source>Gets the next output from the given iterator as an Optional variant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6dcd4f1b64cdf911fd9f684928f1da25a6cfb7f" translate="yes" xml:space="preserve">
          <source>Gets the next output from the given iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="994bf13750cf00f44f9b6b4c9dfb6f0028020c70" translate="yes" xml:space="preserve">
          <source>Gets the number of dimensions (rank) of the dataset.</source>
          <target state="translated">Obtiene el número de dimensiones (rango)del conjunto de datos.</target>
        </trans-unit>
        <trans-unit id="f23647c68125a7ba22ae0e3518d064d1d05de6f2" translate="yes" xml:space="preserve">
          <source>Gets the total dataset size (number of elements).</source>
          <target state="translated">Obtiene el tamaño total del conjunto de datos (número de elementos).</target>
        </trans-unit>
        <trans-unit id="9e0adaeaa293d7d6a42173107240437868052b8a" translate="yes" xml:space="preserve">
          <source>Gets the total regularization loss.</source>
          <target state="translated">Consigue la pérdida total de la regularización.</target>
        </trans-unit>
        <trans-unit id="73109b21436d1124b271c6807ebab80e82f19d20" translate="yes" xml:space="preserve">
          <source>Gets the value of the input tensor (get a copy).</source>
          <target state="translated">Obtiene el valor del tensor de entrada (obtener una copia).</target>
        </trans-unit>
        <trans-unit id="d0a97ae528a9e344d85b2bc74d446d4af8965e0a" translate="yes" xml:space="preserve">
          <source>Gets whether operations are executed synchronously or asynchronously.</source>
          <target state="translated">Averigua si las operaciones se ejecutan de forma sincrónica o asincrónica.</target>
        </trans-unit>
        <trans-unit id="5442e2b64fa09764b9f593867e59a97292c84059" translate="yes" xml:space="preserve">
          <source>GitHub</source>
          <target state="translated">GitHub</target>
        </trans-unit>
        <trans-unit id="6d3e28aa7a51ffcbb882909d4507c0ef3ff3db70" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;A&lt;/code&gt; representing this &lt;code&gt;LinearOperator&lt;/code&gt;, if &lt;code&gt;A&lt;/code&gt; is positive definite self-adjoint, return &lt;code&gt;L&lt;/code&gt;, where &lt;code&gt;A = L L^T&lt;/code&gt;, i.e. the cholesky decomposition.</source>
          <target state="translated">Dado &lt;code&gt;A&lt;/code&gt; que representa a este &lt;code&gt;LinearOperator&lt;/code&gt; , si &lt;code&gt;A&lt;/code&gt; es autoadjunto definido positivo, devuelve &lt;code&gt;L&lt;/code&gt; , donde &lt;code&gt;A = L L^T&lt;/code&gt; , es decir, la descomposici&amp;oacute;n de Cholesky.</target>
        </trans-unit>
        <trans-unit id="3011b88138f555206a8d8637777584fc499f20df" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;A&lt;/code&gt; representing this &lt;code&gt;LinearOperator&lt;/code&gt;, return &lt;code&gt;A*&lt;/code&gt;. Note that calling &lt;code&gt;self.adjoint()&lt;/code&gt; and &lt;code&gt;self.H&lt;/code&gt; are equivalent.</source>
          <target state="translated">Dado &lt;code&gt;A&lt;/code&gt; que representa este &lt;code&gt;LinearOperator&lt;/code&gt; , devuelve &lt;code&gt;A*&lt;/code&gt; . Tenga en cuenta que llamar a &lt;code&gt;self.adjoint()&lt;/code&gt; y &lt;code&gt;self.H&lt;/code&gt; son equivalentes.</target>
        </trans-unit>
        <trans-unit id="7004a0f51e6bcd7306d7fdb592b0811cb1a57ee7" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;A&lt;/code&gt; representing this &lt;code&gt;LinearOperator&lt;/code&gt;, return a &lt;code&gt;LinearOperator&lt;/code&gt; representing &lt;code&gt;A^-1&lt;/code&gt;.</source>
          <target state="translated">Dado &lt;code&gt;A&lt;/code&gt; que representa este &lt;code&gt;LinearOperator&lt;/code&gt; , devuelve un &lt;code&gt;LinearOperator&lt;/code&gt; que representa &lt;code&gt;A^-1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ed8e56b64256346a6878837d8ee1cfda9085e69" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;input&lt;/code&gt; and &lt;code&gt;diagonal&lt;/code&gt;, this operation returns a tensor with the same shape and values as &lt;code&gt;input&lt;/code&gt;, except for the main diagonal of the innermost matrices. These will be overwritten by the values in &lt;code&gt;diagonal&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d4eddf991c1d74f9a5d1d05bd85b438f60be0df" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;input&lt;/code&gt; and &lt;code&gt;diagonal&lt;/code&gt;, this operation returns a tensor with the same shape and values as &lt;code&gt;input&lt;/code&gt;, except for the specified diagonals of the innermost matrices. These will be overwritten by the values in &lt;code&gt;diagonal&lt;/code&gt;.</source>
          <target state="translated">Dada la &lt;code&gt;input&lt;/code&gt; y la &lt;code&gt;diagonal&lt;/code&gt; , esta operaci&amp;oacute;n devuelve un tensor con la misma forma y valores que la &lt;code&gt;input&lt;/code&gt; , excepto por las diagonales especificadas de las matrices m&amp;aacute;s internas. Estos ser&amp;aacute;n sobrescritos por los valores en &lt;code&gt;diagonal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9752e3f5f130be65433c3b1f55a7c6eed51319fb" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;s0&lt;/code&gt; and &lt;code&gt;s1&lt;/code&gt;, tensors that represent shapes, compute &lt;code&gt;r0&lt;/code&gt;, the broadcasted shape. &lt;code&gt;s0&lt;/code&gt;, &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;r0&lt;/code&gt; are all integer vectors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4667868493e23c5d3be9c3d6e074ce011a1f942" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;tensor&lt;/code&gt;, this operation returns a new &lt;a href=&quot;tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; that has the same values as &lt;code&gt;tensor&lt;/code&gt; in the same order, except with a new shape given by &lt;code&gt;shape&lt;/code&gt;.</source>
          <target state="translated">Dado el &lt;code&gt;tensor&lt;/code&gt; , esta operaci&amp;oacute;n devuelve un nuevo &lt;a href=&quot;tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt; que tiene los mismos valores que el &lt;code&gt;tensor&lt;/code&gt; en el mismo orden, excepto con una nueva forma dada por &lt;code&gt;shape&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be8be019b8aafa6e11f377f6a79a88780b77b43f" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;tensor&lt;/code&gt;, this operation returns a tensor that has the same values as &lt;code&gt;tensor&lt;/code&gt; with shape &lt;code&gt;shape&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdee36245b530dadc7a33390b261e3595f491a32" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, compute &lt;code&gt;x * log1p(y)&lt;/code&gt;. This function safely returns zero when &lt;code&gt;x = 0&lt;/code&gt;, no matter what the value of &lt;code&gt;y&lt;/code&gt; is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="270b80b5a40e2baf3fc36e77aed5580f95129897" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;x&lt;/code&gt;, compute the inverse error function of &lt;code&gt;x&lt;/code&gt;. This function is the inverse of &lt;a href=&quot;erf&quot;&gt;&lt;code&gt;tf.math.erf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Dado &lt;code&gt;x&lt;/code&gt; , calcule la funci&amp;oacute;n de error inverso de &lt;code&gt;x&lt;/code&gt; . Esta funci&amp;oacute;n es la inversa de &lt;a href=&quot;erf&quot;&gt; &lt;code&gt;tf.math.erf&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9bd6c98f31a6efc0f5ca49049729b234a4e076d8" translate="yes" xml:space="preserve">
          <source>Given N one-dimensional coordinate arrays &lt;code&gt;*args&lt;/code&gt;, returns a list &lt;code&gt;outputs&lt;/code&gt; of N-D coordinate arrays for evaluating expressions on an N-D grid.</source>
          <target state="translated">Dados N matrices de coordenadas unidimensionales &lt;code&gt;*args&lt;/code&gt; , devuelve una lista de &lt;code&gt;outputs&lt;/code&gt; de matrices de coordenadas ND para evaluar expresiones en una cuadr&amp;iacute;cula ND.</target>
        </trans-unit>
        <trans-unit id="f3b95972a12a7881c9c9398cac9152e479d5c1ef" translate="yes" xml:space="preserve">
          <source>Given a 4D input tensor ('NHWC' or 'NCHW' data formats) and a filter tensor of shape &lt;code&gt;[filter_height, filter_width, in_channels, channel_multiplier]&lt;/code&gt; containing &lt;code&gt;in_channels&lt;/code&gt; convolutional filters of depth 1, &lt;code&gt;depthwise_conv2d&lt;/code&gt; applies a different filter to each input channel (expanding from 1 channel to &lt;code&gt;channel_multiplier&lt;/code&gt; channels for each), then concatenates the results together. The output has &lt;code&gt;in_channels * channel_multiplier&lt;/code&gt; channels.</source>
          <target state="translated">Dado un tensor de entrada 4D (formatos de datos 'NHWC' o 'NCHW') y un tensor de filtro de forma &lt;code&gt;[filter_height, filter_width, in_channels, channel_multiplier]&lt;/code&gt; contiene filtros convolucionales &lt;code&gt;in_channels&lt;/code&gt; de profundidad 1, &lt;code&gt;depthwise_conv2d&lt;/code&gt; aplica un filtro diferente a cada canal de entrada (expandiendo de 1 canal a canales &lt;code&gt;channel_multiplier&lt;/code&gt; para cada uno), luego concatena los resultados. La salida tiene canales &lt;code&gt;in_channels * channel_multiplier&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="094ea9bf18f0c36eba450800d4c1f7a06e4be90d" translate="yes" xml:space="preserve">
          <source>Given a &lt;code&gt;diagonal&lt;/code&gt;, this operation returns a tensor with the &lt;code&gt;diagonal&lt;/code&gt; and everything else padded with zeros. The diagonal is computed as follows:</source>
          <target state="translated">Dada una &lt;code&gt;diagonal&lt;/code&gt; , esta operaci&amp;oacute;n devuelve un tensor con la &lt;code&gt;diagonal&lt;/code&gt; y todo lo dem&amp;aacute;s relleno con ceros. La diagonal se calcula de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="66eaeaec1eb9cbadc921ae64470886d7ed3832d0" translate="yes" xml:space="preserve">
          <source>Given a &lt;code&gt;tensor&lt;/code&gt;, and a &lt;code&gt;bool&lt;/code&gt; tensor &lt;code&gt;dims&lt;/code&gt; representing the dimensions of &lt;code&gt;tensor&lt;/code&gt;, this operation reverses each dimension i of &lt;code&gt;tensor&lt;/code&gt; where &lt;code&gt;dims[i]&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6147dea94829076776f7d46f24eec459f66088a0" translate="yes" xml:space="preserve">
          <source>Given a &lt;code&gt;tensor&lt;/code&gt;, and a &lt;code&gt;int32&lt;/code&gt; tensor &lt;code&gt;axis&lt;/code&gt; representing the set of dimensions of &lt;code&gt;tensor&lt;/code&gt; to reverse. This operation reverses each dimension &lt;code&gt;i&lt;/code&gt; for which there exists &lt;code&gt;j&lt;/code&gt; s.t. &lt;code&gt;axis[j] == i&lt;/code&gt;.</source>
          <target state="translated">Dado un &lt;code&gt;tensor&lt;/code&gt; , y un &lt;code&gt;axis&lt;/code&gt; tensor &lt;code&gt;int32&lt;/code&gt; que representa el conjunto de dimensiones del &lt;code&gt;tensor&lt;/code&gt; a invertir. Esta operaci&amp;oacute;n invierte cada dimensi&amp;oacute;n &lt;code&gt;i&lt;/code&gt; para la que existe &lt;code&gt;j&lt;/code&gt; st &lt;code&gt;axis[j] == i&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e040c53a91fa31be95603ab52d19f7c9b3eda7f" translate="yes" xml:space="preserve">
          <source>Given a Python slice &lt;code&gt;input[spec0, spec1, ..., specn]&lt;/code&gt;, this function will be called as follows.</source>
          <target state="translated">Dada una &lt;code&gt;input[spec0, spec1, ..., specn]&lt;/code&gt; segmento de Python [spec0, spec1, ..., specn] , esta funci&amp;oacute;n se llamar&amp;aacute; de la siguiente manera.</target>
        </trans-unit>
        <trans-unit id="8cc9f63fb42e045b295452edd4ecb68aa07a8d87" translate="yes" xml:space="preserve">
          <source>Given a TensorSummary node_def, retrieve its SummaryDescription.</source>
          <target state="translated">Dado un nodo TensorSummary_def,recupera su SummaryDescription.</target>
        </trans-unit>
        <trans-unit id="9dd17d0fb7fb4fa3b12e4e69ca28248800ac81b7" translate="yes" xml:space="preserve">
          <source>Given a list &lt;code&gt;x&lt;/code&gt; and a list &lt;code&gt;y&lt;/code&gt;, this operation returns a list &lt;code&gt;out&lt;/code&gt; that represents all values that are in &lt;code&gt;x&lt;/code&gt; but not in &lt;code&gt;y&lt;/code&gt;. The returned list &lt;code&gt;out&lt;/code&gt; is sorted in the same order that the numbers appear in &lt;code&gt;x&lt;/code&gt; (duplicates are preserved). This operation also returns a list &lt;code&gt;idx&lt;/code&gt; that represents the position of each &lt;code&gt;out&lt;/code&gt; element in &lt;code&gt;x&lt;/code&gt;. In other words:</source>
          <target state="translated">Dada una lista &lt;code&gt;x&lt;/code&gt; y una lista &lt;code&gt;y&lt;/code&gt; , Esta operaci&amp;oacute;n devuelve una lista &lt;code&gt;out&lt;/code&gt; que representa todos los valores que est&amp;aacute;n en &lt;code&gt;x&lt;/code&gt; , pero no en &lt;code&gt;y&lt;/code&gt; . La lista devuelta &lt;code&gt;out&lt;/code&gt; se ordena en el mismo orden que los n&amp;uacute;meros aparecen en &lt;code&gt;x&lt;/code&gt; (duplicados se conservan). Esta operaci&amp;oacute;n tambi&amp;eacute;n devuelve una lista &lt;code&gt;idx&lt;/code&gt; que representa la posici&amp;oacute;n de cada elemento de &lt;code&gt;out&lt;/code&gt; en &lt;code&gt;x&lt;/code&gt; . En otras palabras:</target>
        </trans-unit>
        <trans-unit id="5c5372b4dc12fe49c83eb4b2c2b91eba162834cd" translate="yes" xml:space="preserve">
          <source>Given a list of device names, this operation returns the index of the device this op runs. The length of the list is returned in two cases: (1) Device does not exist in the given device list. (2) It is in XLA compilation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="615eb60f085e28de1449f5a5508afeb187317b05" translate="yes" xml:space="preserve">
          <source>Given a list of string tensors of same shape, performs element-wise concatenation of the strings of the same index in all tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f469b77293ed1ff9f0eb63bb9dae24362157619" translate="yes" xml:space="preserve">
          <source>Given a list of tensors or ragged tensors with the same rank &lt;code&gt;R&lt;/code&gt; (&lt;code&gt;R &amp;gt;= axis&lt;/code&gt;), returns a rank-&lt;code&gt;R+1&lt;/code&gt;&lt;code&gt;RaggedTensor&lt;/code&gt;&lt;code&gt;result&lt;/code&gt; such that &lt;code&gt;result[i0...iaxis]&lt;/code&gt; is &lt;code&gt;[value[i0...iaxis] for value in values]&lt;/code&gt;.</source>
          <target state="translated">Dada una lista de tensores o tensores irregulares con el mismo rango &lt;code&gt;R&lt;/code&gt; ( &lt;code&gt;R &amp;gt;= axis&lt;/code&gt; ), devuelve un &lt;code&gt;result&lt;/code&gt; ado de &lt;code&gt;RaggedTensor&lt;/code&gt; &lt;code&gt;R+1&lt;/code&gt; RaggedTensor tal que el &lt;code&gt;result[i0...iaxis]&lt;/code&gt; es &lt;code&gt;[value[i0...iaxis] for value in values]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="799df442e0baab2b82fd8e748615a45625ee8074" translate="yes" xml:space="preserve">
          <source>Given a path to new and old vocabulary files, returns a remapping Tensor of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68c5f2c079927408ee33cb3fc0df6461ed870433" translate="yes" xml:space="preserve">
          <source>Given a per-replica value returned by &lt;code&gt;experimental_run_v2&lt;/code&gt;, say a per-example loss, the batch will be divided across all the replicas. This function allows you to aggregate across replicas and optionally also across batch elements. For example, if you have a global batch size of 8 and 2 replicas, values for examples &lt;code&gt;[0, 1, 2, 3]&lt;/code&gt; will be on replica 0 and &lt;code&gt;[4, 5, 6, 7]&lt;/code&gt; will be on replica 1. By default, &lt;code&gt;reduce&lt;/code&gt; will just aggregate across replicas, returning &lt;code&gt;[0+4, 1+5, 2+6, 3+7]&lt;/code&gt;. This is useful when each replica is computing a scalar or some other value that doesn't have a &quot;batch&quot; dimension (like a gradient). More often you will want to aggregate across the global batch, which you can get by specifying the batch dimension as the &lt;code&gt;axis&lt;/code&gt;, typically &lt;code&gt;axis=0&lt;/code&gt;. In this case it would return a scalar &lt;code&gt;0+1+2+3+4+5+6+7&lt;/code&gt;.</source>
          <target state="translated">Dado un valor por r&amp;eacute;plica devuelto por &lt;code&gt;experimental_run_v2&lt;/code&gt; , digamos una p&amp;eacute;rdida por ejemplo, el lote se dividir&amp;aacute; entre todas las r&amp;eacute;plicas. Esta funci&amp;oacute;n le permite agregar entre r&amp;eacute;plicas y, opcionalmente, tambi&amp;eacute;n entre elementos de lote. Por ejemplo, si tiene un tama&amp;ntilde;o de lote global de 8 y 2 r&amp;eacute;plicas, los valores de los ejemplos &lt;code&gt;[0, 1, 2, 3]&lt;/code&gt; estar&amp;aacute;n en la r&amp;eacute;plica 0 y &lt;code&gt;[4, 5, 6, 7]&lt;/code&gt; estar&amp;aacute;n en la r&amp;eacute;plica 1. Por predeterminado, la &lt;code&gt;reduce&lt;/code&gt; solo se agregar&amp;aacute; en todas las r&amp;eacute;plicas, devolviendo &lt;code&gt;[0+4, 1+5, 2+6, 3+7]&lt;/code&gt; . Esto es &amp;uacute;til cuando cada r&amp;eacute;plica calcula un valor escalar o alg&amp;uacute;n otro valor que no tiene una dimensi&amp;oacute;n de &quot;lote&quot; (como un gradiente). Con m&amp;aacute;s frecuencia, querr&amp;aacute; agregar en el lote global, lo que puede obtener especificando la dimensi&amp;oacute;n del lote como el &lt;code&gt;axis&lt;/code&gt; , normalmente &lt;code&gt;axis=0&lt;/code&gt; . En este caso, devolver&amp;iacute;a un escalar &lt;code&gt;0+1+2+3+4+5+6+7&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fba44d6afcce2f9092396c74380f9a0d2335aa38" translate="yes" xml:space="preserve">
          <source>Given a per-replica value returned by &lt;code&gt;run&lt;/code&gt;, say a per-example loss, the batch will be divided across all the replicas. This function allows you to aggregate across replicas and optionally also across batch elements. For example, if you have a global batch size of 8 and 2 replicas, values for examples &lt;code&gt;[0, 1, 2, 3]&lt;/code&gt; will be on replica 0 and &lt;code&gt;[4, 5, 6, 7]&lt;/code&gt; will be on replica 1. By default, &lt;code&gt;reduce&lt;/code&gt; will just aggregate across replicas, returning &lt;code&gt;[0+4, 1+5, 2+6, 3+7]&lt;/code&gt;. This is useful when each replica is computing a scalar or some other value that doesn't have a &quot;batch&quot; dimension (like a gradient). More often you will want to aggregate across the global batch, which you can get by specifying the batch dimension as the &lt;code&gt;axis&lt;/code&gt;, typically &lt;code&gt;axis=0&lt;/code&gt;. In this case it would return a scalar &lt;code&gt;0+1+2+3+4+5+6+7&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d356be63c806d4a57d873a70be815c506a549419" translate="yes" xml:space="preserve">
          <source>Given a python function &lt;code&gt;func&lt;/code&gt; wrap this function as an operation in a TensorFlow function. &lt;code&gt;func&lt;/code&gt; must take numpy arrays as its arguments and return numpy arrays as its outputs.</source>
          <target state="translated">Dada una funci&amp;oacute;n de Python, &lt;code&gt;func&lt;/code&gt; envuelve esta funci&amp;oacute;n como una operaci&amp;oacute;n en una funci&amp;oacute;n de TensorFlow. &lt;code&gt;func&lt;/code&gt; debe tomar matrices numpy como argumentos y devolver matrices numpy como salidas.</target>
        </trans-unit>
        <trans-unit id="3a5b52f136266fe244292b77181eab18685d5599" translate="yes" xml:space="preserve">
          <source>Given a python function &lt;code&gt;func&lt;/code&gt;, which takes numpy arrays as its arguments and returns numpy arrays as its outputs, wrap this function as an operation in a TensorFlow graph. The following snippet constructs a simple TensorFlow graph that invokes the &lt;code&gt;np.sinh()&lt;/code&gt; NumPy function as a operation in the graph:</source>
          <target state="translated">Dada una funci&amp;oacute;n de Python &lt;code&gt;func&lt;/code&gt; , que toma matrices numpy como sus argumentos y devuelve matrices numpy como salidas, envuelva esta funci&amp;oacute;n como una operaci&amp;oacute;n en un gr&amp;aacute;fico de TensorFlow. El siguiente fragmento construye un gr&amp;aacute;fico de TensorFlow simple que invoca la funci&amp;oacute;n &lt;code&gt;np.sinh()&lt;/code&gt; NumPy como una operaci&amp;oacute;n en el gr&amp;aacute;fico:</target>
        </trans-unit>
        <trans-unit id="04e5711a5b38ba52b6a8792b3c7feb0ca529ddd8" translate="yes" xml:space="preserve">
          <source>Given a quantized tensor described by &lt;code&gt;(input, input_min, input_max)&lt;/code&gt;, outputs a range that covers the actual values present in that tensor. This op is typically used to produce the &lt;code&gt;requested_output_min&lt;/code&gt; and &lt;code&gt;requested_output_max&lt;/code&gt; for &lt;code&gt;Requantize&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3da234c855426da94c463431671a4c43997129c" translate="yes" xml:space="preserve">
          <source>Given a single tensor (&lt;code&gt;tensor&lt;/code&gt;), this operation returns a tensor of the same type and shape as &lt;code&gt;tensor&lt;/code&gt; with all elements set to 1. Optionally, you can specify a new type (&lt;code&gt;dtype&lt;/code&gt;) for the returned tensor.</source>
          <target state="translated">Dado un solo tensor ( &lt;code&gt;tensor&lt;/code&gt; ), esta operaci&amp;oacute;n devuelve un tensor del mismo tipo y forma que el &lt;code&gt;tensor&lt;/code&gt; con todos los elementos establecidos en 1. Opcionalmente, puede especificar un nuevo tipo ( &lt;code&gt;dtype&lt;/code&gt; ) para el tensor devuelto.</target>
        </trans-unit>
        <trans-unit id="cef540646f64962527a87cdc8b09906dde5432ac" translate="yes" xml:space="preserve">
          <source>Given a single tensor (&lt;code&gt;tensor&lt;/code&gt;), this operation returns a tensor of the same type and shape as &lt;code&gt;tensor&lt;/code&gt; with all elements set to 1. Optionally, you can use &lt;code&gt;dtype&lt;/code&gt; to specify a new type for the returned tensor.</source>
          <target state="translated">Dado un solo tensor ( &lt;code&gt;tensor&lt;/code&gt; ), esta operaci&amp;oacute;n devuelve un tensor del mismo tipo y forma que el &lt;code&gt;tensor&lt;/code&gt; con todos los elementos establecidos en 1. Opcionalmente, puede usar &lt;code&gt;dtype&lt;/code&gt; para especificar un nuevo tipo para el tensor devuelto.</target>
        </trans-unit>
        <trans-unit id="f197c0d34900084408842c4f3cb206307ffb52c6" translate="yes" xml:space="preserve">
          <source>Given a single tensor (&lt;code&gt;tensor&lt;/code&gt;), this operation returns a tensor of the same type and shape as &lt;code&gt;tensor&lt;/code&gt; with all elements set to zero. Optionally, you can use &lt;code&gt;dtype&lt;/code&gt; to specify a new type for the returned tensor.</source>
          <target state="translated">Dado un solo tensor ( &lt;code&gt;tensor&lt;/code&gt; ), esta operaci&amp;oacute;n devuelve un tensor del mismo tipo y forma que el &lt;code&gt;tensor&lt;/code&gt; con todos los elementos establecidos en cero. Opcionalmente, puede usar &lt;code&gt;dtype&lt;/code&gt; para especificar un nuevo tipo para el tensor devuelto.</target>
        </trans-unit>
        <trans-unit id="f6c0b6671463b416e1fcd6a6f255b3952b13ff6a" translate="yes" xml:space="preserve">
          <source>Given a single tensor or array-like object (&lt;code&gt;input&lt;/code&gt;), this operation returns a tensor of the same type and shape as &lt;code&gt;input&lt;/code&gt; with all elements set to zero. Optionally, you can use &lt;code&gt;dtype&lt;/code&gt; to specify a new type for the returned tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10b69b4dd5bbe2b5280497f7bc6c2252eeb11d35" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;input&lt;/code&gt; of complex numbers, this operation returns a tensor of complex numbers that are the complex conjugate of each element in &lt;code&gt;input&lt;/code&gt;. The complex numbers in &lt;code&gt;input&lt;/code&gt; must be of the form \(a + bj\), where &lt;em&gt;a&lt;/em&gt; is the real part and &lt;em&gt;b&lt;/em&gt; is the imaginary part.</source>
          <target state="translated">Dada una &lt;code&gt;input&lt;/code&gt; de tensor de n&amp;uacute;meros complejos, esta operaci&amp;oacute;n devuelve un tensor de n&amp;uacute;meros complejos que son el conjugado complejo de cada elemento en la &lt;code&gt;input&lt;/code&gt; . Los n&amp;uacute;meros complejos en la &lt;code&gt;input&lt;/code&gt; deben tener la forma \ (a + bj \), donde &lt;em&gt;a&lt;/em&gt; es la parte real y &lt;em&gt;b&lt;/em&gt; es la parte imaginaria.</target>
        </trans-unit>
        <trans-unit id="f4a15667395d38500d3dfc23e818236844897a6a" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;input&lt;/code&gt; of complex numbers, this operation returns a tensor of type &lt;code&gt;float&lt;/code&gt; that is the argument of each element in &lt;code&gt;input&lt;/code&gt;. All elements in &lt;code&gt;input&lt;/code&gt; must be complex numbers of the form \(a + bj\), where &lt;em&gt;a&lt;/em&gt; is the real part and &lt;em&gt;b&lt;/em&gt; is the imaginary part.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af4da35de23a457876e5d3da3d8ccad06ca104b4" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;input&lt;/code&gt; of complex numbers, this operation returns a tensor of type &lt;code&gt;float&lt;/code&gt; that is the imaginary part of each element in &lt;code&gt;input&lt;/code&gt;. All elements in &lt;code&gt;input&lt;/code&gt; must be complex numbers of the form \(a + bj\), where &lt;em&gt;a&lt;/em&gt; is the real part and &lt;em&gt;b&lt;/em&gt; is the imaginary part returned by this operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ffbcbe2d85ffbf7da6ee324f57a57f9317dabd2" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;input&lt;/code&gt; of complex numbers, this operation returns a tensor of type &lt;code&gt;float&lt;/code&gt; that is the real part of each element in &lt;code&gt;input&lt;/code&gt;. All elements in &lt;code&gt;input&lt;/code&gt; must be complex numbers of the form \(a + bj\), where &lt;em&gt;a&lt;/em&gt; is the real part returned by this operation and &lt;em&gt;b&lt;/em&gt; is the imaginary part.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="806e510667c18a0441a9ae34cf672593b9c2613d" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;input&lt;/code&gt;, this operation inserts a dimension of 1 at the dimension index &lt;code&gt;axis&lt;/code&gt; of &lt;code&gt;input&lt;/code&gt;'s shape. The dimension index &lt;code&gt;axis&lt;/code&gt; starts at zero; if you specify a negative number for &lt;code&gt;axis&lt;/code&gt; it is counted backward from the end.</source>
          <target state="translated">Dada una &lt;code&gt;input&lt;/code&gt; tensor , esta operaci&amp;oacute;n inserta una dimensi&amp;oacute;n de 1 en el &lt;code&gt;axis&lt;/code&gt; del &amp;iacute;ndice de dimensi&amp;oacute;n de la forma de la &lt;code&gt;input&lt;/code&gt; . El &lt;code&gt;axis&lt;/code&gt; &amp;iacute;ndice de dimensi&amp;oacute;n comienza en cero; si especifica un n&amp;uacute;mero negativo para el &lt;code&gt;axis&lt;/code&gt; , se cuenta hacia atr&amp;aacute;s desde el final.</target>
        </trans-unit>
        <trans-unit id="d963425876592189628da6b7e7e5ed87ffb5d763" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;input&lt;/code&gt;, this operation inserts a dimension of length 1 at the dimension index &lt;code&gt;axis&lt;/code&gt; of &lt;code&gt;input&lt;/code&gt;'s shape. The dimension index follows Python indexing rules: It's zero-based, a negative index it is counted backward from the end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1431dbed06794c8031819f2ace8f4c705283bdec" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;input&lt;/code&gt;, this operation inserts a dimension of length 1 at the dimension index &lt;code&gt;axis&lt;/code&gt; of &lt;code&gt;input&lt;/code&gt;'s shape. The dimension index follows python indexing rules: It's zero-based, a negative index it is counted backward from the end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c286503b096f71983bf3319ebce75fc3df581ded" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;input&lt;/code&gt;, this operation inserts a dimension of size 1 at the dimension index &lt;code&gt;axis&lt;/code&gt; of &lt;code&gt;input&lt;/code&gt;'s shape. The dimension index &lt;code&gt;axis&lt;/code&gt; starts at zero; if you specify a negative number for &lt;code&gt;axis&lt;/code&gt; it is counted backward from the end.</source>
          <target state="translated">Dada una &lt;code&gt;input&lt;/code&gt; tensor , esta operaci&amp;oacute;n inserta una dimensi&amp;oacute;n de tama&amp;ntilde;o 1 en el &lt;code&gt;axis&lt;/code&gt; del &amp;iacute;ndice de dimensi&amp;oacute;n de la forma de la &lt;code&gt;input&lt;/code&gt; . El &lt;code&gt;axis&lt;/code&gt; &amp;iacute;ndice de dimensi&amp;oacute;n comienza en cero; si especifica un n&amp;uacute;mero negativo para el &lt;code&gt;axis&lt;/code&gt; , se cuenta hacia atr&amp;aacute;s desde el final.</target>
        </trans-unit>
        <trans-unit id="3a1fb94877fc4770061be1a2b9c38bdc7f0532ee" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;input&lt;/code&gt;, this operation returns a tensor of the same type with all dimensions of size 1 removed. If you don't want to remove all size 1 dimensions, you can remove specific size 1 dimensions by specifying &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">Dada una &lt;code&gt;input&lt;/code&gt; tensor , esta operaci&amp;oacute;n devuelve un tensor del mismo tipo con todas las dimensiones de tama&amp;ntilde;o 1 eliminadas. Si no desea eliminar todas las dimensiones de tama&amp;ntilde;o 1, puede eliminar dimensiones espec&amp;iacute;ficas de tama&amp;ntilde;o 1 especificando el &lt;code&gt;axis&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bbca199d5d5cd792b1dd02ead4c9b8f3ef441f45" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;input&lt;/code&gt;, this operation returns a tensor of type &lt;code&gt;float&lt;/code&gt; that is the argument of each element in &lt;code&gt;input&lt;/code&gt; considered as a complex number.</source>
          <target state="translated">Dada una &lt;code&gt;input&lt;/code&gt; tensor , esta operaci&amp;oacute;n devuelve un tensor de tipo &lt;code&gt;float&lt;/code&gt; que es el argumento de cada elemento en la &lt;code&gt;input&lt;/code&gt; considerado como un n&amp;uacute;mero complejo.</target>
        </trans-unit>
        <trans-unit id="f3c9874b7bb8857da64e590211bda623bc98b5d1" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;input&lt;/code&gt;, this operation returns a tensor of type &lt;code&gt;float&lt;/code&gt; that is the imaginary part of each element in &lt;code&gt;input&lt;/code&gt; considered as a complex number. If &lt;code&gt;input&lt;/code&gt; is real, a tensor of all zeros is returned.</source>
          <target state="translated">Dada una &lt;code&gt;input&lt;/code&gt; tensor , esta operaci&amp;oacute;n devuelve un tensor de tipo &lt;code&gt;float&lt;/code&gt; que es la parte imaginaria de cada elemento en la &lt;code&gt;input&lt;/code&gt; considerado como un n&amp;uacute;mero complejo. Si la &lt;code&gt;input&lt;/code&gt; es real, se devuelve un tensor de todos ceros.</target>
        </trans-unit>
        <trans-unit id="becaf7789b114f2fb84f8a1c908f9499f6b0068e" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;input&lt;/code&gt;, this operation returns a tensor of type &lt;code&gt;float&lt;/code&gt; that is the real part of each element in &lt;code&gt;input&lt;/code&gt; considered as a complex number.</source>
          <target state="translated">Dada una &lt;code&gt;input&lt;/code&gt; tensor , esta operaci&amp;oacute;n devuelve un tensor de tipo &lt;code&gt;float&lt;/code&gt; que es la parte real de cada elemento en la &lt;code&gt;input&lt;/code&gt; considerado como un n&amp;uacute;mero complejo.</target>
        </trans-unit>
        <trans-unit id="a4adc764f5b83b917078bf968adc81577aa08658" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;input&lt;/code&gt;, this operation returns a tensor that has the same buffer data as &lt;code&gt;input&lt;/code&gt; with datatype &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">Dada una &lt;code&gt;input&lt;/code&gt; tensor , esta operaci&amp;oacute;n devuelve un tensor que tiene los mismos datos de b&amp;uacute;fer que la &lt;code&gt;input&lt;/code&gt; con tipo de &lt;code&gt;type&lt;/code&gt; datos .</target>
        </trans-unit>
        <trans-unit id="44c0e89f9a11fab2d9da2eab4b6ba9dad61347c2" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;inputs&lt;/code&gt;, moments are calculated and normalization is performed across the axes specified in &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b01a7ab9f6ce08221630a8a12ac493ef6aa5e0f2" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;real&lt;/code&gt; representing the real part of a complex number, and a tensor &lt;code&gt;imag&lt;/code&gt; representing the imaginary part of a complex number, this operation returns complex numbers elementwise of the form \(a + bj\), where &lt;em&gt;a&lt;/em&gt; represents the &lt;code&gt;real&lt;/code&gt; part and &lt;em&gt;b&lt;/em&gt; represents the &lt;code&gt;imag&lt;/code&gt; part.</source>
          <target state="translated">Dado un tensor &lt;code&gt;real&lt;/code&gt; que representa la parte real de un n&amp;uacute;mero complejo, y un tensor &lt;code&gt;imag&lt;/code&gt; que representa la parte imaginaria de un n&amp;uacute;mero complejo, esta operaci&amp;oacute;n devuelve n&amp;uacute;meros complejos por elementos de la forma \ (a + bj \), donde &lt;em&gt;a&lt;/em&gt; representa la parte &lt;code&gt;real&lt;/code&gt; y &lt;em&gt;b&lt;/em&gt; representa la parte &lt;code&gt;imag&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4cde684e0bf3170cd69db48357176ad6f8be05bf" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;sp_input&lt;/code&gt;, this operation inserts a dimension of 1 at the dimension index &lt;code&gt;axis&lt;/code&gt; of &lt;code&gt;sp_input&lt;/code&gt;'s shape. The dimension index &lt;code&gt;axis&lt;/code&gt; starts at zero; if you specify a negative number for &lt;code&gt;axis&lt;/code&gt; it is counted backwards from the end.</source>
          <target state="translated">Dado un tensor &lt;code&gt;sp_input&lt;/code&gt; , esta operaci&amp;oacute;n inserta una dimensi&amp;oacute;n de 1 en el &lt;code&gt;axis&lt;/code&gt; del &amp;iacute;ndice de &lt;code&gt;sp_input&lt;/code&gt; de la forma de sp_input . El &lt;code&gt;axis&lt;/code&gt; &amp;iacute;ndice de dimensi&amp;oacute;n comienza en cero; si especifica un n&amp;uacute;mero negativo para el &lt;code&gt;axis&lt;/code&gt; , se cuenta hacia atr&amp;aacute;s desde el final.</target>
        </trans-unit>
        <trans-unit id="c7e431d8c1e8a94cc9f6ddda87a3198f535026e6" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;t&lt;/code&gt;, and a maximum clip value &lt;code&gt;clip_norm&lt;/code&gt;, this operation normalizes &lt;code&gt;t&lt;/code&gt; so that its L2-norm is less than or equal to &lt;code&gt;clip_norm&lt;/code&gt;, along the dimensions given in &lt;code&gt;axes&lt;/code&gt;. Specifically, in the default case where all dimensions are used for calculation, if the L2-norm of &lt;code&gt;t&lt;/code&gt; is already less than or equal to &lt;code&gt;clip_norm&lt;/code&gt;, then &lt;code&gt;t&lt;/code&gt; is not modified. If the L2-norm is greater than &lt;code&gt;clip_norm&lt;/code&gt;, then this operation returns a tensor of the same type and shape as &lt;code&gt;t&lt;/code&gt; with its values set to:</source>
          <target state="translated">Dado un tensor &lt;code&gt;t&lt;/code&gt; , y un valor de clip m&amp;aacute;ximo &lt;code&gt;clip_norm&lt;/code&gt; , esta operaci&amp;oacute;n normaliza &lt;code&gt;t&lt;/code&gt; de modo que su norma L2 sea menor o igual que &lt;code&gt;clip_norm&lt;/code&gt; , a lo largo de las dimensiones dadas en &lt;code&gt;axes&lt;/code&gt; . Espec&amp;iacute;ficamente, en el caso predeterminado donde se usan todas las dimensiones para el c&amp;aacute;lculo, si la norma L2 de &lt;code&gt;t&lt;/code&gt; ya es menor o igual que &lt;code&gt;clip_norm&lt;/code&gt; , entonces &lt;code&gt;t&lt;/code&gt; no se modifica. Si la norma L2 es mayor que &lt;code&gt;clip_norm&lt;/code&gt; , esta operaci&amp;oacute;n devuelve un tensor del mismo tipo y forma que &lt;code&gt;t&lt;/code&gt; con sus valores establecidos en:</target>
        </trans-unit>
        <trans-unit id="0fb66188586afb5dfa9ed28d0d11ecbbd9aa6324" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;t&lt;/code&gt;, and a maximum clip value &lt;code&gt;clip_norm&lt;/code&gt;, this operation normalizes &lt;code&gt;t&lt;/code&gt; so that its average L2-norm is less than or equal to &lt;code&gt;clip_norm&lt;/code&gt;. Specifically, if the average L2-norm is already less than or equal to &lt;code&gt;clip_norm&lt;/code&gt;, then &lt;code&gt;t&lt;/code&gt; is not modified. If the average L2-norm is greater than &lt;code&gt;clip_norm&lt;/code&gt;, then this operation returns a tensor of the same type and shape as &lt;code&gt;t&lt;/code&gt; with its values set to:</source>
          <target state="translated">Dado un tensor &lt;code&gt;t&lt;/code&gt; , y un valor de clip m&amp;aacute;ximo &lt;code&gt;clip_norm&lt;/code&gt; , esta operaci&amp;oacute;n normaliza &lt;code&gt;t&lt;/code&gt; de modo que su norma L2 promedio sea menor o igual que &lt;code&gt;clip_norm&lt;/code&gt; . Espec&amp;iacute;ficamente, si la norma L2 promedio ya es menor o igual que &lt;code&gt;clip_norm&lt;/code&gt; , entonces &lt;code&gt;t&lt;/code&gt; no se modifica. Si la norma L2 promedio es mayor que &lt;code&gt;clip_norm&lt;/code&gt; , esta operaci&amp;oacute;n devuelve un tensor del mismo tipo y forma que &lt;code&gt;t&lt;/code&gt; con sus valores establecidos en:</target>
        </trans-unit>
        <trans-unit id="7007bafda729e071b7b16ae3d3a78dcbb3100276" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;t&lt;/code&gt;, this operation returns a tensor of the same type and shape as &lt;code&gt;t&lt;/code&gt; with its values clipped to &lt;code&gt;clip_value_min&lt;/code&gt; and &lt;code&gt;clip_value_max&lt;/code&gt;. Any values less than &lt;code&gt;clip_value_min&lt;/code&gt; are set to &lt;code&gt;clip_value_min&lt;/code&gt;. Any values greater than &lt;code&gt;clip_value_max&lt;/code&gt; are set to &lt;code&gt;clip_value_max&lt;/code&gt;.</source>
          <target state="translated">Dado un tensor &lt;code&gt;t&lt;/code&gt; , esta operaci&amp;oacute;n devuelve un tensor del mismo tipo y forma que &lt;code&gt;t&lt;/code&gt; con sus valores recortados en &lt;code&gt;clip_value_min&lt;/code&gt; y &lt;code&gt;clip_value_max&lt;/code&gt; . Cualquier valor menor que &lt;code&gt;clip_value_min&lt;/code&gt; se establece en &lt;code&gt;clip_value_min&lt;/code&gt; . Cualquier valor mayor que &lt;code&gt;clip_value_max&lt;/code&gt; se establece en &lt;code&gt;clip_value_max&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d793504d9a2641fdc838d8a324aa0f0d9bef081" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;x&lt;/code&gt; and a tensor &lt;code&gt;y&lt;/code&gt;, this operation computes \(x^y\) for corresponding elements in &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. For example:</source>
          <target state="translated">Dado un tensor &lt;code&gt;x&lt;/code&gt; y un tensor &lt;code&gt;y&lt;/code&gt; , esta operaci&amp;oacute;n calcula \ (x ^ y \) para los elementos correspondientes en &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="1d97acda758edb9bf66a685f144f3b117ce1c753" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;x&lt;/code&gt; of complex numbers, this operation returns a tensor of type &lt;code&gt;float32&lt;/code&gt; or &lt;code&gt;float64&lt;/code&gt; that is the absolute value of each element in &lt;code&gt;x&lt;/code&gt;. All elements in &lt;code&gt;x&lt;/code&gt; must be complex numbers of the form \(a + bj\). The absolute value is computed as \( \sqrt{a^2 + b^2}\). For example:</source>
          <target state="translated">Dado un tensor &lt;code&gt;x&lt;/code&gt; de n&amp;uacute;meros complejos, esta operaci&amp;oacute;n devuelve un tensor de tipo &lt;code&gt;float32&lt;/code&gt; o &lt;code&gt;float64&lt;/code&gt; que es el valor absoluto de cada elemento en &lt;code&gt;x&lt;/code&gt; . Todos los elementos de &lt;code&gt;x&lt;/code&gt; deben ser n&amp;uacute;meros complejos de la forma \ (a + bj \). El valor absoluto se calcula como \ (\ sqrt {a ^ 2 + b ^ 2} \). Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="f9f18c0deb0b747c5c85a2f0f9afacc8bc3635a6" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;x&lt;/code&gt; of complex numbers, this operation returns a tensor of type &lt;code&gt;float32&lt;/code&gt; or &lt;code&gt;float64&lt;/code&gt; that is the absolute value of each element in &lt;code&gt;x&lt;/code&gt;. For a complex number \(a + bj\), its absolute value is computed as \(\sqrt{a^2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="355cf8ae9246c456614b457edc04fdaeb78e33b1" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;x&lt;/code&gt; of complex numbers, this operation returns a tensor of type &lt;code&gt;float&lt;/code&gt; or &lt;code&gt;double&lt;/code&gt; that is the absolute value of each element in &lt;code&gt;x&lt;/code&gt;. All elements in &lt;code&gt;x&lt;/code&gt; must be complex numbers of the form \(a + bj\). The absolute value is computed as \( \sqrt{a^2 + b^2}\).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20000a209981bca529c2a5888aeb027dca5cb186" translate="yes" xml:space="preserve">
          <source>Given a tensor &lt;code&gt;x&lt;/code&gt;, this operation returns a tensor containing the absolute value of each element in &lt;code&gt;x&lt;/code&gt;. For example, if x is an input element and y is an output element, this operation computes \(y = |x|\).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd81862ba7b8de323d4dc65742b6a0e0fc609451" translate="yes" xml:space="preserve">
          <source>Given a tensor of integer or floating-point values, this operation returns a tensor of the same type, where each element contains the absolute value of the corresponding element in the input.</source>
          <target state="translated">Dado un tensor de valores enteros o en coma flotante,esta operación devuelve un tensor del mismo tipo,en el que cada elemento contiene el valor absoluto del elemento correspondiente en la entrada.</target>
        </trans-unit>
        <trans-unit id="322b12c73859d8a9e4e7944b435ecab925a5124e" translate="yes" xml:space="preserve">
          <source>Given a tuple or list of tensors &lt;code&gt;t_list&lt;/code&gt;, and a clipping ratio &lt;code&gt;clip_norm&lt;/code&gt;, this operation returns a list of clipped tensors &lt;code&gt;list_clipped&lt;/code&gt; and the global norm (&lt;code&gt;global_norm&lt;/code&gt;) of all tensors in &lt;code&gt;t_list&lt;/code&gt;. Optionally, if you've already computed the global norm for &lt;code&gt;t_list&lt;/code&gt;, you can specify the global norm with &lt;code&gt;use_norm&lt;/code&gt;.</source>
          <target state="translated">Dada una tupla o lista de tensores &lt;code&gt;t_list&lt;/code&gt; , y una proporci&amp;oacute;n de recorte &lt;code&gt;clip_norm&lt;/code&gt; , esta operaci&amp;oacute;n devuelve una lista de tensores recortados &lt;code&gt;list_clipped&lt;/code&gt; y la norma global ( &lt;code&gt;global_norm&lt;/code&gt; ) de todos los tensores en &lt;code&gt;t_list&lt;/code&gt; . Opcionalmente, si ya ha calculado la norma global para &lt;code&gt;t_list&lt;/code&gt; , puede especificar la norma global con &lt;code&gt;use_norm&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb5b0e16debf84a9c22080f3acaefe368e00fdb9" translate="yes" xml:space="preserve">
          <source>Given a tuple or list of tensors &lt;code&gt;t_list&lt;/code&gt;, this operation returns the global norm of the elements in all tensors in &lt;code&gt;t_list&lt;/code&gt;. The global norm is computed as:</source>
          <target state="translated">Dada una tupla o lista de tensores &lt;code&gt;t_list&lt;/code&gt; , esta operaci&amp;oacute;n devuelve la norma global de los elementos en todos los tensores en &lt;code&gt;t_list&lt;/code&gt; . La norma global se calcula como:</target>
        </trans-unit>
        <trans-unit id="73d8bb2fac3b21f66c499488e5209e33bb02392c" translate="yes" xml:space="preserve">
          <source>Given an &lt;code&gt;IndexedSlices&lt;/code&gt; instance &lt;code&gt;a&lt;/code&gt;, returns another &lt;code&gt;IndexedSlices&lt;/code&gt; that contains a subset of the slices of &lt;code&gt;a&lt;/code&gt;. Only the slices at indices not specified in &lt;code&gt;mask_indices&lt;/code&gt; are returned.</source>
          <target state="translated">Dada una instancia de &lt;code&gt;IndexedSlices&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; , devuelve otro &lt;code&gt;IndexedSlices&lt;/code&gt; que contiene un subconjunto de los segmentos de &lt;code&gt;a&lt;/code&gt; . Solo se devuelven los segmentos de &amp;iacute;ndices no especificados en &lt;code&gt;mask_indices&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4876f0e9062c0cf2e7752902c9a4b28f41eb1e86" translate="yes" xml:space="preserve">
          <source>Given an &lt;code&gt;input&lt;/code&gt; shaped &lt;code&gt;[s0, s1, ..., s_n]&lt;/code&gt;, the output is a &lt;code&gt;uint8&lt;/code&gt; tensor shaped &lt;code&gt;[s0, s1, ..., s_n / 8]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eb4a575261e442800cb08021cae257d7dca9d5e" translate="yes" xml:space="preserve">
          <source>Given an arbitrary function, wrap it so that it does variable sharing.</source>
          <target state="translated">Dada una función arbitraria,envuélvelo para que haga un reparto variable.</target>
        </trans-unit>
        <trans-unit id="18296fc4ebda93cac42fe65939317a047745ed5f" translate="yes" xml:space="preserve">
          <source>Given an input tensor of shape &lt;code&gt;[batch, in_height, in_width, in_channels]&lt;/code&gt; and a filter / kernel tensor of shape &lt;code&gt;[filter_height, filter_width, in_channels, channel_multiplier]&lt;/code&gt;, containing &lt;code&gt;in_channels&lt;/code&gt; convolutional filters of depth 1, &lt;code&gt;depthwise_conv2d&lt;/code&gt; applies a different filter to each input channel (expanding from 1 channel to &lt;code&gt;channel_multiplier&lt;/code&gt; channels for each), then concatenates the results together. Thus, the output has &lt;code&gt;in_channels * channel_multiplier&lt;/code&gt; channels.</source>
          <target state="translated">Dado un tensor de entrada de forma &lt;code&gt;[batch, in_height, in_width, in_channels]&lt;/code&gt; y un tensor de filtro / kernel de forma &lt;code&gt;[filter_height, filter_width, in_channels, channel_multiplier]&lt;/code&gt; , que contiene filtros convolucionales &lt;code&gt;in_channels&lt;/code&gt; de profundidad 1, &lt;code&gt;depthwise_conv2d&lt;/code&gt; aplica un filtro diferente a cada canal de entrada (expandi&amp;eacute;ndose de 1 canal a canales &lt;code&gt;channel_multiplier&lt;/code&gt; para cada uno), luego concatena los resultados. Por lo tanto, la salida tiene canales &lt;code&gt;in_channels * channel_multiplier&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e370c68e5555d480a5c4df80fb0a1826a44057c" translate="yes" xml:space="preserve">
          <source>Given an input tensor of shape &lt;code&gt;[batch, in_height, in_width, in_channels]&lt;/code&gt; and a filter / kernel tensor of shape &lt;code&gt;[filter_height, filter_width, in_channels, out_channels]&lt;/code&gt;, this op performs the following:</source>
          <target state="translated">Dado un tensor de entrada de forma &lt;code&gt;[batch, in_height, in_width, in_channels]&lt;/code&gt; y un tensor de filtro / kernel de forma &lt;code&gt;[filter_height, filter_width, in_channels, out_channels]&lt;/code&gt; , esta operaci&amp;oacute;n realiza lo siguiente:</target>
        </trans-unit>
        <trans-unit id="1fab9d674065ff486a1c44d98d6d558e38ce4d8f" translate="yes" xml:space="preserve">
          <source>Given an input tensor of shape &lt;code&gt;batch_shape + [in_height, in_width, in_channels]&lt;/code&gt; and a filter / kernel tensor of shape &lt;code&gt;[filter_height, filter_width, in_channels, out_channels]&lt;/code&gt;, this op performs the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed20cb19f30785b7a38934894a0dbee86a0b0123" translate="yes" xml:space="preserve">
          <source>Given an input tensor of shape &lt;code&gt;batch_shape + [in_width, in_channels]&lt;/code&gt; if &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;NWC&quot;&lt;/code&gt;, or &lt;code&gt;batch_shape + [in_channels, in_width]&lt;/code&gt; if &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;NCW&quot;&lt;/code&gt;, and a filter / kernel tensor of shape &lt;code&gt;[filter_width, in_channels, out_channels]&lt;/code&gt;, this op reshapes the arguments to pass them to &lt;code&gt;conv2d&lt;/code&gt; to perform the equivalent convolution operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1c915a4b13f35d33a94d06e3847c2365262d62c" translate="yes" xml:space="preserve">
          <source>Given an input tensor of shape [batch, in_width, in_channels] if data_format is &quot;NWC&quot;, or [batch, in_channels, in_width] if data_format is &quot;NCW&quot;, and a filter / kernel tensor of shape [filter_width, in_channels, out_channels], this op reshapes the arguments to pass them to conv2d to perform the equivalent convolution operation.</source>
          <target state="translated">Dado un tensor de entrada de forma [batch,in_width,in_channels]si el formato de datos es &quot;NWC&quot;,o [batch,in_channels,in_width]si el formato de datos es &quot;NCW&quot;,y un tensor de filtro/núcleo de forma [filter_width,in_channels,out_channels],esta operación remodela los argumentos para pasarlos a conv2d para realizar la operación de convolución equivalente.</target>
        </trans-unit>
        <trans-unit id="2eb289cc3c5755f35510bd201bb3c7ba0da0f131" translate="yes" xml:space="preserve">
          <source>Given an input tensor, the function computes inverse hyperbolic cosine of every element. Input range is &lt;code&gt;[1, inf]&lt;/code&gt;. It returns &lt;code&gt;nan&lt;/code&gt; if the input lies outside the range.</source>
          <target state="translated">Dado un tensor de entrada, la funci&amp;oacute;n calcula el coseno hiperb&amp;oacute;lico inverso de cada elemento. El rango de entrada es &lt;code&gt;[1, inf]&lt;/code&gt; . Devuelve &lt;code&gt;nan&lt;/code&gt; si la entrada est&amp;aacute; fuera del rango.</target>
        </trans-unit>
        <trans-unit id="c2276090897040e0aeeaafa324236781f22316e6" translate="yes" xml:space="preserve">
          <source>Given an input tensor, this function computes cosine of every element in the tensor. Input range is &lt;code&gt;(-inf, inf)&lt;/code&gt; and output range is &lt;code&gt;[-1,1]&lt;/code&gt;. If input lies outside the boundary, &lt;code&gt;nan&lt;/code&gt; is returned.</source>
          <target state="translated">Dado un tensor de entrada, esta funci&amp;oacute;n calcula el coseno de cada elemento en el tensor. El rango de entrada es &lt;code&gt;(-inf, inf)&lt;/code&gt; y el rango de salida es &lt;code&gt;[-1,1]&lt;/code&gt; . Si la entrada se encuentra fuera del l&amp;iacute;mite, se devuelve &lt;code&gt;nan&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d70ae953868ca523f92404dffa44551095f71ef" translate="yes" xml:space="preserve">
          <source>Given an input tensor, this function computes hyperbolic cosine of every element in the tensor. Input range is &lt;code&gt;[-inf, inf]&lt;/code&gt; and output range is &lt;code&gt;[1, inf]&lt;/code&gt;.</source>
          <target state="translated">Dado un tensor de entrada, esta funci&amp;oacute;n calcula el coseno hiperb&amp;oacute;lico de cada elemento en el tensor. El rango de entrada es &lt;code&gt;[-inf, inf]&lt;/code&gt; y el rango de salida es &lt;code&gt;[1, inf]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b488ce799eb3a33791cfbd59693b393988e595b" translate="yes" xml:space="preserve">
          <source>Given an input tensor, this function computes hyperbolic sine of every element in the tensor. Input range is &lt;code&gt;[-inf,inf]&lt;/code&gt; and output range is &lt;code&gt;[-inf,inf]&lt;/code&gt;.</source>
          <target state="translated">Dado un tensor de entrada, esta funci&amp;oacute;n calcula el seno hiperb&amp;oacute;lico de cada elemento en el tensor. El rango de entrada es &lt;code&gt;[-inf,inf]&lt;/code&gt; y el rango de salida es &lt;code&gt;[-inf,inf]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59df85e0619df189d8729fee687f600a54d01480" translate="yes" xml:space="preserve">
          <source>Given an input tensor, this function computes hyperbolic tangent of every element in the tensor. Input range is &lt;code&gt;[-inf, inf]&lt;/code&gt; and output range is &lt;code&gt;[-1,1]&lt;/code&gt;.</source>
          <target state="translated">Dado un tensor de entrada, esta funci&amp;oacute;n calcula la tangente hiperb&amp;oacute;lica de cada elemento en el tensor. El rango de entrada es &lt;code&gt;[-inf, inf]&lt;/code&gt; y el rango de salida es &lt;code&gt;[-1,1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c73b448fa482aa6531301716ace98c25a05fd5d3" translate="yes" xml:space="preserve">
          <source>Given an input tensor, this function computes inverse hyperbolic sine for every element in the tensor. Both input and output has a range of &lt;code&gt;[-inf, inf]&lt;/code&gt;.</source>
          <target state="translated">Dado un tensor de entrada, esta funci&amp;oacute;n calcula el seno hiperb&amp;oacute;lico inverso para cada elemento del tensor. Tanto la entrada como la salida tienen un rango de &lt;code&gt;[-inf, inf]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c25eb5c30ec69042f14f0a07e82e62d1882abacc" translate="yes" xml:space="preserve">
          <source>Given an input tensor, this function computes inverse hyperbolic tangent for every element in the tensor. Input range is &lt;code&gt;[-1,1]&lt;/code&gt; and output range is &lt;code&gt;[-inf, inf]&lt;/code&gt;. If input is &lt;code&gt;-1&lt;/code&gt;, output will be &lt;code&gt;-inf&lt;/code&gt; and if the input is &lt;code&gt;1&lt;/code&gt;, output will be &lt;code&gt;inf&lt;/code&gt;. Values outside the range will have &lt;code&gt;nan&lt;/code&gt; as output.</source>
          <target state="translated">Dado un tensor de entrada, esta funci&amp;oacute;n calcula la tangente hiperb&amp;oacute;lica inversa para cada elemento del tensor. El rango de entrada es &lt;code&gt;[-1,1]&lt;/code&gt; y el rango de salida es &lt;code&gt;[-inf, inf]&lt;/code&gt; . Si la entrada es &lt;code&gt;-1&lt;/code&gt; , la salida ser&amp;aacute; &lt;code&gt;-inf&lt;/code&gt; y si la entrada es &lt;code&gt;1&lt;/code&gt; , la salida ser&amp;aacute; &lt;code&gt;inf&lt;/code&gt; . Los valores fuera del rango tendr&amp;aacute;n &lt;code&gt;nan&lt;/code&gt; como salida.</target>
        </trans-unit>
        <trans-unit id="ea097a1f54202798e40231d72b57eb14a2329e8c" translate="yes" xml:space="preserve">
          <source>Given an input tensor, this function computes sine of every element in the tensor. Input range is &lt;code&gt;(-inf, inf)&lt;/code&gt; and output range is &lt;code&gt;[-1,1]&lt;/code&gt;.</source>
          <target state="translated">Dado un tensor de entrada, esta funci&amp;oacute;n calcula el seno de cada elemento en el tensor. El rango de entrada es &lt;code&gt;(-inf, inf)&lt;/code&gt; y el rango de salida es &lt;code&gt;[-1,1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d62f8cf300097a0e2129f20828fbd0e2b4cd35f3" translate="yes" xml:space="preserve">
          <source>Given an input tensor, this function computes tangent of every element in the tensor. Input range is &lt;code&gt;(-inf, inf)&lt;/code&gt; and output range is &lt;code&gt;(-inf, inf)&lt;/code&gt;. If input lies outside the boundary, &lt;code&gt;nan&lt;/code&gt; is returned.</source>
          <target state="translated">Dado un tensor de entrada, esta funci&amp;oacute;n calcula la tangente de cada elemento en el tensor. El rango de entrada es &lt;code&gt;(-inf, inf)&lt;/code&gt; y el rango de salida es &lt;code&gt;(-inf, inf)&lt;/code&gt; . Si la entrada se encuentra fuera del l&amp;iacute;mite, se devuelve &lt;code&gt;nan&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f8bd7293b2216f6c9572d5c819802c515a646af" translate="yes" xml:space="preserve">
          <source>Given one-dimensional $z = [z_1,...,z_K]$, we define</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08d07ac5e8ef80d326d4f12521ff24313fbce652" translate="yes" xml:space="preserve">
          <source>Given one-dimensional &lt;code&gt;z = [z_0,...,z_{K-1}]&lt;/code&gt;, we define</source>
          <target state="translated">Dado &lt;code&gt;z = [z_0,...,z_{K-1}]&lt;/code&gt; unidimensional , definimos</target>
        </trans-unit>
        <trans-unit id="48fec20fa93f6484a4d59eef4d5240def79def02" translate="yes" xml:space="preserve">
          <source>Given operation-specific seed, &lt;code&gt;op_seed&lt;/code&gt;, this helper function returns two seeds derived from graph-level and op-level seeds. Many random operations internally use the two seeds to allow user to change the seed globally for a graph, or for only specific operations.</source>
          <target state="translated">Dada la semilla espec&amp;iacute;fica de la operaci&amp;oacute;n, &lt;code&gt;op_seed&lt;/code&gt; , esta funci&amp;oacute;n auxiliar devuelve dos semillas derivadas de las semillas de nivel de gr&amp;aacute;fico y de nivel de operaci&amp;oacute;n . Muchas operaciones aleatorias utilizan internamente las dos semillas para permitir al usuario cambiar la semilla globalmente para un gr&amp;aacute;fico o solo para operaciones espec&amp;iacute;ficas.</target>
        </trans-unit>
        <trans-unit id="3c4cfb563b251c993c875f25d14c9e568e980107" translate="yes" xml:space="preserve">
          <source>Given random variable &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;p in [0, 1]&lt;/code&gt;, the &lt;code&gt;quantile&lt;/code&gt; is:</source>
          <target state="translated">Dada variable aleatoria &lt;code&gt;X&lt;/code&gt; y &lt;code&gt;p in [0, 1]&lt;/code&gt; , el &lt;code&gt;quantile&lt;/code&gt; es:</target>
        </trans-unit>
        <trans-unit id="11ff9e9f8b087477a5e4158b4134eac9b64e6878" translate="yes" xml:space="preserve">
          <source>Given random variable &lt;code&gt;X&lt;/code&gt;, the cumulative distribution function &lt;code&gt;cdf&lt;/code&gt; is:</source>
          <target state="translated">Dada la variable aleatoria &lt;code&gt;X&lt;/code&gt; , la funci&amp;oacute;n de distribuci&amp;oacute;n acumulativa &lt;code&gt;cdf&lt;/code&gt; es:</target>
        </trans-unit>
        <trans-unit id="fa3f3691f019bbd881a265ec5bccfb1211e3ad29" translate="yes" xml:space="preserve">
          <source>Given random variable &lt;code&gt;X&lt;/code&gt;, the survival function is defined:</source>
          <target state="translated">Dada la variable aleatoria &lt;code&gt;X&lt;/code&gt; , la funci&amp;oacute;n de supervivencia se define:</target>
        </trans-unit>
        <trans-unit id="55eaa8e915c7da17162d07889c59a5355bf928ae" translate="yes" xml:space="preserve">
          <source>Given that some ops may be partially supported, the optimal way to determine if a model's operations are supported is by converting using the TensorFlow Lite converter.</source>
          <target state="translated">Dado que algunas operaciones pueden ser parcialmente soportadas,la forma óptima de determinar si las operaciones de un modelo son soportadas es mediante la conversión usando el convertidor TensorFlow Lite.</target>
        </trans-unit>
        <trans-unit id="9f078ae5dde89ed67ae2cd1d678f26fb93674467" translate="yes" xml:space="preserve">
          <source>Given the blockwise &lt;code&gt;n + 1&lt;/code&gt;-by-&lt;code&gt;n + 1&lt;/code&gt; linear operator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0153812f9d215780555e110de846d070c2d1cb32" translate="yes" xml:space="preserve">
          <source>Given the tensor &lt;code&gt;values&lt;/code&gt;, this operation returns a rank 1 &lt;code&gt;Tensor&lt;/code&gt; representing the indices of a histogram into which each element of &lt;code&gt;values&lt;/code&gt; would be binned. The bins are equal width and determined by the arguments &lt;code&gt;value_range&lt;/code&gt; and &lt;code&gt;nbins&lt;/code&gt;.</source>
          <target state="translated">Dados los &lt;code&gt;values&lt;/code&gt; del tensor , esta operaci&amp;oacute;n devuelve un &lt;code&gt;Tensor&lt;/code&gt; rango 1 que representa los &amp;iacute;ndices de un histograma en el que se agrupar&amp;iacute;a cada elemento de &lt;code&gt;values&lt;/code&gt; . Los bins tienen el mismo ancho y est&amp;aacute;n determinados por los argumentos &lt;code&gt;value_range&lt;/code&gt; y &lt;code&gt;nbins&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9c47520102d0ea0d116c89df4867da9b1a8141e" translate="yes" xml:space="preserve">
          <source>Given the tensor &lt;code&gt;values&lt;/code&gt;, this operation returns a rank 1 histogram counting the number of entries in &lt;code&gt;values&lt;/code&gt; that fall into every bin. The bins are equal width and determined by the arguments &lt;code&gt;value_range&lt;/code&gt; and &lt;code&gt;nbins&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13c5e2fbdbba7fa42de391b57a0a7d1e5d7df7f6" translate="yes" xml:space="preserve">
          <source>Given the tensor &lt;code&gt;values&lt;/code&gt;, this operation returns a rank 1 histogram counting the number of entries in &lt;code&gt;values&lt;/code&gt; that fell into every bin. The bins are equal width and determined by the arguments &lt;code&gt;value_range&lt;/code&gt; and &lt;code&gt;nbins&lt;/code&gt;.</source>
          <target state="translated">Dados los &lt;code&gt;values&lt;/code&gt; del tensor , esta operaci&amp;oacute;n devuelve un histograma de rango 1 que cuenta el n&amp;uacute;mero de entradas en &lt;code&gt;values&lt;/code&gt; que caen en cada contenedor. Los bins tienen el mismo ancho y est&amp;aacute;n determinados por los argumentos &lt;code&gt;value_range&lt;/code&gt; y &lt;code&gt;nbins&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54fcfc2408cd2e19b0afb43ec166a6b0b45677c6" translate="yes" xml:space="preserve">
          <source>Given two &lt;code&gt;Example&lt;/code&gt; input protos in &lt;code&gt;serialized&lt;/code&gt;:</source>
          <target state="translated">Dados dos protos de entrada de &lt;code&gt;Example&lt;/code&gt; en &lt;code&gt;serialized&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a71b5320e03ef99e09301587e5062ffa0d505637" translate="yes" xml:space="preserve">
          <source>Gives a guarantee to the TF runtime that the input tensor is a constant.</source>
          <target state="translated">Garantiza al tiempo de ejecución de la TF que el tensor de entrada es una constante.</target>
        </trans-unit>
        <trans-unit id="802a77a26d08463b8d182d4841500cc36b1bdeb1" translate="yes" xml:space="preserve">
          <source>Gives the log-likelihood loss between the prediction and the target under the assumption that the target has a Poisson distribution. Caveat: By default, this is not the exact loss, but the loss minus a constant term [log(z!)]. That has no effect for optimization, but does not play well with relative loss comparisons. To compute an approximation of the log factorial term, specify compute_full_loss=True to enable Stirling's Approximation.</source>
          <target state="translated">Da la pérdida de probabilidad logarítmica entre la predicción y el objetivo bajo el supuesto de que el objetivo tenga una distribución de Poisson.Advertencia:Por defecto,esta no es la pérdida exacta,sino la pérdida menos un término constante [log(z!)].Esto no tiene ningún efecto para la optimización,pero no juega bien con las comparaciones de pérdidas relativas.Para calcular una aproximación del término factorial log,especifique compute_full_loss=True para habilitar la Aproximación de Stirling.</target>
        </trans-unit>
        <trans-unit id="3b375b50d76db2f1ab6e919b12e87eb3c07c7837" translate="yes" xml:space="preserve">
          <source>Global Average pooling operation for 3D data.</source>
          <target state="translated">Operación de agrupación de datos en 3D de Global Average.</target>
        </trans-unit>
        <trans-unit id="490733d038a485e20b685885b26cd8e1c21ac8a1" translate="yes" xml:space="preserve">
          <source>Global Max pooling operation for 3D data.</source>
          <target state="translated">Operación de agrupación de Global Max para datos 3D.</target>
        </trans-unit>
        <trans-unit id="c372dfcc5aacad73c8ba932360de7dad2d1ce972" translate="yes" xml:space="preserve">
          <source>Global average pooling operation for spatial data.</source>
          <target state="translated">Operación de puesta en común de datos espaciales a nivel mundial.</target>
        </trans-unit>
        <trans-unit id="fc8c9db4015232abf19ef2f9a55435d1ea95b1de" translate="yes" xml:space="preserve">
          <source>Global average pooling operation for temporal data.</source>
          <target state="translated">Operación de puesta en común de datos temporales a nivel mundial.</target>
        </trans-unit>
        <trans-unit id="167efa62c3642366c4057325e9b1f061b9517117" translate="yes" xml:space="preserve">
          <source>Global dictionary of names to classes (&lt;code&gt;_GLOBAL_CUSTOM_OBJECTS&lt;/code&gt;).</source>
          <target state="translated">Diccionario global de nombres a clases ( &lt;code&gt;_GLOBAL_CUSTOM_OBJECTS&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3b675d73c44ef2c3b5ff3ee1aee82f62c38a94d3" translate="yes" xml:space="preserve">
          <source>Global id, i.e., this field, is tracking the index of the node among ALL nodes in the cluster. It is uniquely assigned. For example, for the cluster spec given above, the global ids are assigned as:</source>
          <target state="translated">Global id,es decir,este campo,está rastreando el índice del nodo entre TODOS los nodos del cúmulo.Está asignado de forma única.Por ejemplo,para la especificación del cúmulo dada arriba,los global ids se asignan como:</target>
        </trans-unit>
        <trans-unit id="861ea43bf3e08cfa679688d9126f736408dcc945" translate="yes" xml:space="preserve">
          <source>Global max pooling operation for 1D temporal data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbaffaa9e612328e1415352ab08beb6396bb657c" translate="yes" xml:space="preserve">
          <source>Global max pooling operation for spatial data.</source>
          <target state="translated">Operación de agrupación máxima global de datos espaciales.</target>
        </trans-unit>
        <trans-unit id="f0f40685c4fd8079767cd3b5779589f20e7497c4" translate="yes" xml:space="preserve">
          <source>Global max pooling operation for temporal data.</source>
          <target state="translated">Operación de agrupación máxima global de datos temporales.</target>
        </trans-unit>
        <trans-unit id="d590e8790e10ef3fdf0c5c3d8ed595c657758ce9" translate="yes" xml:space="preserve">
          <source>Global step tensor.</source>
          <target state="translated">Tensor de paso global.</target>
        </trans-unit>
        <trans-unit id="fa3649b2772ac1189dcef2f8c64d20be93fd805b" translate="yes" xml:space="preserve">
          <source>Global variables are variables that are shared across machines in a distributed environment. The &lt;code&gt;Variable()&lt;/code&gt; constructor or &lt;code&gt;get_variable()&lt;/code&gt; automatically adds new variables to the graph collection &lt;code&gt;GraphKeys.GLOBAL_VARIABLES&lt;/code&gt;. This convenience function returns the contents of that collection.</source>
          <target state="translated">Las variables globales son variables que se comparten entre m&amp;aacute;quinas en un entorno distribuido. El constructor &lt;code&gt;Variable()&lt;/code&gt; o &lt;code&gt;get_variable()&lt;/code&gt; agrega autom&amp;aacute;ticamente nuevas variables a la colecci&amp;oacute;n de gr&amp;aacute;ficos &lt;code&gt;GraphKeys.GLOBAL_VARIABLES&lt;/code&gt; . Esta funci&amp;oacute;n de conveniencia devuelve el contenido de esa colecci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1e368decdd07f40f158c5a306bc7f03b270de34b" translate="yes" xml:space="preserve">
          <source>Globs for the checkpoints pointed to by &lt;code&gt;checkpoint_paths&lt;/code&gt;. If the files exist, use their mtime as the checkpoint timestamp.</source>
          <target state="translated">Globs para los puntos de control se&amp;ntilde;alados por &lt;code&gt;checkpoint_paths&lt;/code&gt; . Si los archivos existen, utilice su mtime como marca de tiempo del punto de control.</target>
        </trans-unit>
        <trans-unit id="a9111e714242062acf83be49c369c220ccfcf860" translate="yes" xml:space="preserve">
          <source>Globs for the checkpoints pointed to by &lt;code&gt;checkpoint_prefixes&lt;/code&gt;. If the files exist, collect their mtime. Both V2 and V1 checkpoints are considered, in that priority.</source>
          <target state="translated">Globs para los puntos de control se&amp;ntilde;alados por &lt;code&gt;checkpoint_prefixes&lt;/code&gt; . Si los archivos existen, recopile su mtime. Ambos puntos de control V2 y V1 se consideran en esa prioridad.</target>
        </trans-unit>
        <trans-unit id="01cc712ba5777037862cf425ce81901fb067f024" translate="yes" xml:space="preserve">
          <source>Grace period for stopping:</source>
          <target state="translated">Período de gracia para detenerse:</target>
        </trans-unit>
        <trans-unit id="adb359f1f87c794c325871e029c1af140effe5ec" translate="yes" xml:space="preserve">
          <source>Grace period handling: When &lt;code&gt;request_stop()&lt;/code&gt; is called, threads are given 'stop_grace_period_secs' seconds to terminate. If any of them is still alive after that period expires, a &lt;code&gt;RuntimeError&lt;/code&gt; is raised. Note that if an &lt;code&gt;exc_info&lt;/code&gt; was passed to &lt;code&gt;request_stop()&lt;/code&gt; then it is raised instead of that &lt;code&gt;RuntimeError&lt;/code&gt;.</source>
          <target state="translated">Manejo del per&amp;iacute;odo de gracia: cuando se llama a request_stop &lt;code&gt;request_stop()&lt;/code&gt; , los subprocesos reciben 'stop_grace_period_secs' segundos para terminar. Si alguno de ellos sigue vivo despu&amp;eacute;s de que expire ese per&amp;iacute;odo, se &lt;code&gt;RuntimeError&lt;/code&gt; un RuntimeError . Tenga en cuenta que si se pas&amp;oacute; un &lt;code&gt;exc_info&lt;/code&gt; a &lt;code&gt;request_stop()&lt;/code&gt; , se genera en lugar de ese &lt;code&gt;RuntimeError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5149e7b8f8d0f76a4477a7c343a2d7e6cb51a37d" translate="yes" xml:space="preserve">
          <source>Grace period, in seconds, given to running threads to stop when &lt;code&gt;stop()&lt;/code&gt; is called. Defaults to 120 seconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c61a1c122223903dabaecda115cd172b19ae575" translate="yes" xml:space="preserve">
          <source>Gradient Boosted Trees: Model understanding</source>
          <target state="translated">Árboles de gradiente elevado:Modelo de comprensión</target>
        </trans-unit>
        <trans-unit id="328b1e9ac6d673a9731be1b0fee1aa7f2b9bd86a" translate="yes" xml:space="preserve">
          <source>Gradient descent (with momentum) optimizer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ccf5db0029889f6fecb177b4847ffd92845592b" translate="yes" xml:space="preserve">
          <source>Gradient for batch normalization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da1029b1e9a2a07b646e912fc9a9abfeaf36bbac" translate="yes" xml:space="preserve">
          <source>Gradient of Unbatch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70f9c4b00a1e9a42e50af0c5886037373d5b1dd7" translate="yes" xml:space="preserve">
          <source>Gradient op for &lt;code&gt;MirrorPad&lt;/code&gt; op. This op folds a mirror-padded tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="194bbc5ad5da84e49dad69cbb4f32f23b69a3786" translate="yes" xml:space="preserve">
          <source>GradientTapes can be nested to compute higher-order derivatives. For example,</source>
          <target state="translated">Las GradientTapes pueden anidarse para calcular derivados de mayor orden.Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="418595e6c8a1cac41ef43f912bdb79ac95f52c7f" translate="yes" xml:space="preserve">
          <source>Gradients for Local Response Normalization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18ab0670f94b562da8b866c0ee514e88a5366f1c" translate="yes" xml:space="preserve">
          <source>Gradients for batch normalization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c2ad4a85cafc13c2d1c2d3a2971b83be82a10c3" translate="yes" xml:space="preserve">
          <source>GraphDef containing a simplified version of the original.</source>
          <target state="translated">GraphDef que contiene una versión simplificada del original.</target>
        </trans-unit>
        <trans-unit id="f1121f5d0ae3561a0535bf5eed70bebc9b4c573d" translate="yes" xml:space="preserve">
          <source>GraphDef object holding the network.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88f6daec0a60e7783e784d139db2e8caa801c093" translate="yes" xml:space="preserve">
          <source>Graphically the output tensors are:</source>
          <target state="translated">Gráficamente los tensores de salida son:</target>
        </trans-unit>
        <trans-unit id="29346dfd9c70ea134e70f14b812447401491ea5b" translate="yes" xml:space="preserve">
          <source>Graphically this is equivalent to doing</source>
          <target state="translated">Gráficamente esto es equivalente a hacer</target>
        </trans-unit>
        <trans-unit id="20a2426b7947c82cb1587611210e101486083cc8" translate="yes" xml:space="preserve">
          <source>Graphs are used by &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;s to represent the function's computations. Each graph contains a set of &lt;a href=&quot;operation&quot;&gt;&lt;code&gt;tf.Operation&lt;/code&gt;&lt;/a&gt; objects, which represent units of computation; and &lt;a href=&quot;tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; objects, which represent the units of data that flow between operations.</source>
          <target state="translated">&lt;a href=&quot;function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; s usa gr&amp;aacute;ficos para representar los c&amp;aacute;lculos de la funci&amp;oacute;n. Cada gr&amp;aacute;fico contiene un conjunto de objetos &lt;a href=&quot;operation&quot;&gt; &lt;code&gt;tf.Operation&lt;/code&gt; &lt;/a&gt; , que representan unidades de c&amp;aacute;lculo; y objetos &lt;a href=&quot;tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt; , que representan las unidades de datos que fluyen entre operaciones.</target>
        </trans-unit>
        <trans-unit id="c0c7d8111372100880daccbc5bf26be1b2464f9e" translate="yes" xml:space="preserve">
          <source>Greater</source>
          <target state="translated">Greater</target>
        </trans-unit>
        <trans-unit id="f20c1c201cbb34ee5875869c7087a3e926efb3b7" translate="yes" xml:space="preserve">
          <source>GreaterEqual</source>
          <target state="translated">GreaterEqual</target>
        </trans-unit>
        <trans-unit id="e5695443f7cf0378e67e28d423fc90003e20fdde" translate="yes" xml:space="preserve">
          <source>Greedily selects a subset of bounding boxes in descending order of score,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58294451a76b10d6330ff549e0a6d209d1f0896b" translate="yes" xml:space="preserve">
          <source>Greedily selects a subset of bounding boxes in descending order of score.</source>
          <target state="translated">Selecciona con avidez un subconjunto de cajas delimitadoras en orden descendente de puntuación.</target>
        </trans-unit>
        <trans-unit id="e8494d1512cc20a8fe1e52f4aa1865ea4363ab3f" translate="yes" xml:space="preserve">
          <source>Ground truth values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cc2972f01b075253d91c217637ce9f71f2218ce" translate="yes" xml:space="preserve">
          <source>Ground truth values. shape = &lt;code&gt;[batch_size, d0, .. dN]&lt;/code&gt;, except sparse loss functions such as sparse categorical crossentropy where shape = &lt;code&gt;[batch_size, d0, .. dN-1]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c43440e34d61ec903c57a53c805f205165dc5754" translate="yes" xml:space="preserve">
          <source>Ground truth values. shape = &lt;code&gt;[batch_size, d0, .. dN]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38b0e82be14566bde59466131197fef45b274db7" translate="yes" xml:space="preserve">
          <source>Ground-truth targets to pass to &lt;code&gt;Model&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e75eb9da321613dade49081fbb0f38725be295e1" translate="yes" xml:space="preserve">
          <source>Group objects into a training checkpoint.</source>
          <target state="translated">Agrupar los objetos en un puesto de control de entrenamiento.</target>
        </trans-unit>
        <trans-unit id="6115c228a89d1f90769cafcbd1ad268a88285c91" translate="yes" xml:space="preserve">
          <source>Group tensors together.</source>
          <target state="translated">Agrupar los tensores.</target>
        </trans-unit>
        <trans-unit id="3e4946272ebd6af7ba4e43d36dac49e1f14d4e7c" translate="yes" xml:space="preserve">
          <source>GroupByReducerDataset</source>
          <target state="translated">GroupByReducerDataset</target>
        </trans-unit>
        <trans-unit id="be8d30eb5632b02cf8f150f0a09be3b235ef07eb" translate="yes" xml:space="preserve">
          <source>GroupByWindowDataset</source>
          <target state="translated">GroupByWindowDataset</target>
        </trans-unit>
        <trans-unit id="e354b4454dd166bc154614760aa397bafa913cb1" translate="yes" xml:space="preserve">
          <source>Groups trackable objects, saving and restoring them.</source>
          <target state="translated">Agrupa objetos rastreables,guardándolos y restaurándolos.</target>
        </trans-unit>
        <trans-unit id="9d7f80cd70980946ed16aeb04c9d084b9966606a" translate="yes" xml:space="preserve">
          <source>GuaranteeConst</source>
          <target state="translated">GuaranteeConst</target>
        </trans-unit>
        <trans-unit id="7ad9a6bc86d23788bf2c1d40a823516a6f0ed768" translate="yes" xml:space="preserve">
          <source>HALF_TO_EVEN: this is the default round_mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="920da21317add9910b40605a155029f67d570159" translate="yes" xml:space="preserve">
          <source>HALF_UP: round towards positive. In this mode 7.5 rounds up to 8 and -7.5 rounds up to -7.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29d6a74360835e2659133e31def98e713b027ad9" translate="yes" xml:space="preserve">
          <source>HSVToRGB</source>
          <target state="translated">HSVToRGB</target>
        </trans-unit>
        <trans-unit id="11ef29d704891a60b088172f8178a63b75138495" translate="yes" xml:space="preserve">
          <source>Hard sigmoid activation function.</source>
          <target state="translated">Función de activación del sigmoide duro.</target>
        </trans-unit>
        <trans-unit id="89d0493bf3e9638199b6b1d86f1632bbe9719ae3" translate="yes" xml:space="preserve">
          <source>Has Gradient</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7f2a37788a5eae46019711a7835ecdefc241070" translate="yes" xml:space="preserve">
          <source>HashTable</source>
          <target state="translated">HashTable</target>
        </trans-unit>
        <trans-unit id="acf8fdc7f2d880260a7d0b7da811515282e4330f" translate="yes" xml:space="preserve">
          <source>HashTableV2</source>
          <target state="translated">HashTableV2</target>
        </trans-unit>
        <trans-unit id="b62d591ef71e520dcc0fd2d5494b2b952c2c9902" translate="yes" xml:space="preserve">
          <source>Hasim Sak, Andrew Senior, and Francoise Beaufays. &quot;Long short-term memory recurrent neural network architectures for large scale acoustic modeling.&quot; INTERSPEECH, 2014.</source>
          <target state="translated">Hasim Sak,Andrew Senior y Francoise Beaufays.&quot;Arquitecturas de redes neuronales recurrentes de memoria a corto plazo para el modelado acústico a gran escala.&quot; INTERSPEECH,2014.</target>
        </trans-unit>
        <trans-unit id="7acbb15ccffab6beca727a0d69870bfb5c290df1" translate="yes" xml:space="preserve">
          <source>Have a &lt;code&gt;go_backwards&lt;/code&gt;, &lt;code&gt;return_sequences&lt;/code&gt; and &lt;code&gt;return_state&lt;/code&gt; attribute (with the same semantics as for the &lt;code&gt;RNN&lt;/code&gt; class).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b06caab1d8003a14cb6c5ee52eb330ca47603350" translate="yes" xml:space="preserve">
          <source>Have an &lt;code&gt;input_spec&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dd6a3bb0aa8fcc99cb2926cb3630295183067dd" translate="yes" xml:space="preserve">
          <source>Having access to such information is useful when user needs to run specific code according to task types. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4021193208114328b08be8cf728a91eb62ae42b" translate="yes" xml:space="preserve">
          <source>He et al., 2015</source>
          <target state="translated">He et al,2015</target>
        </trans-unit>
        <trans-unit id="2579614b073edd33dff24698cc0ed7a9d8d9b2ff" translate="yes" xml:space="preserve">
          <source>He normal initializer.</source>
          <target state="translated">Es un inicializador normal.</target>
        </trans-unit>
        <trans-unit id="c820b6e271aeb8c0992aef844f7e9688ee27c3ff" translate="yes" xml:space="preserve">
          <source>He uniform variance scaling initializer.</source>
          <target state="translated">Él uniformizó el inicializador de la escala de variación.</target>
        </trans-unit>
        <trans-unit id="b2a0825f5cf85b0813ba4a932833d3b427e828d7" translate="yes" xml:space="preserve">
          <source>Head sits on top of the model network and handles computing the outputs of the network. Given logits (or output of a hidden layer), a Head knows how to compute predictions, loss, train_op, metrics and export outputs. It is meant to:</source>
          <target state="translated">La cabeza se sienta encima de la red modelo y se encarga de computar las salidas de la red.Dados los logits (o la salida de una capa oculta),un Head sabe cómo calcular predicciones,pérdidas,train_op,métricas y exportar salidas.Está destinado a ello:</target>
        </trans-unit>
        <trans-unit id="110183a1eb73ab34fd4a98c264cc9d76f023cc2a" translate="yes" xml:space="preserve">
          <source>Heartbeats may be sent periodically to indicate the coordinator is still active, to retrieve the current worker status and to expedite shutdown when necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="065c2e0bd4aa8ce24245293e18fcb73620f8829e" translate="yes" xml:space="preserve">
          <source>Height of output image.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02e0e2ad93d9b9dfcf2dfc29c4e34a5e7ed6029e" translate="yes" xml:space="preserve">
          <source>Height of the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="724391cae7df3c6f2f078aa757c3203246f50dfa" translate="yes" xml:space="preserve">
          <source>Helpers to manipulate a tensor graph in python.</source>
          <target state="translated">Ayudan a manipular un gráfico tensorial en pitón.</target>
        </trans-unit>
        <trans-unit id="a9a20ef1cc1f4b45d357341f3d6bf25221e22949" translate="yes" xml:space="preserve">
          <source>Hence, the &lt;code&gt;SparseTensor&lt;/code&gt; result has exactly the same non-zero indices and shape.</source>
          <target state="translated">Por lo tanto, el resultado de &lt;code&gt;SparseTensor&lt;/code&gt; tiene exactamente los mismos &amp;iacute;ndices y forma distintos de cero.</target>
        </trans-unit>
        <trans-unit id="67314232dbebd248ae3b761c240375d141928549" translate="yes" xml:space="preserve">
          <source>Hence, to ensure stability and avoid overflow, the implementation uses this equivalent formulation</source>
          <target state="translated">Por lo tanto,para asegurar la estabilidad y evitar el desbordamiento,la aplicación utiliza esta formulación equivalente</target>
        </trans-unit>
        <trans-unit id="15496dff970b77a7dd905044c63378f4105e5937" translate="yes" xml:space="preserve">
          <source>Here is a code example for using &lt;code&gt;AdditiveAttention&lt;/code&gt; in a CNN+Attention network:</source>
          <target state="translated">Aqu&amp;iacute; hay un ejemplo de c&amp;oacute;digo para usar &lt;code&gt;AdditiveAttention&lt;/code&gt; en una red CNN + Attention:</target>
        </trans-unit>
        <trans-unit id="af1e9525f99564803e6dc214d93b54de55e718e8" translate="yes" xml:space="preserve">
          <source>Here is a code example for using &lt;code&gt;Attention&lt;/code&gt; in a CNN+Attention network:</source>
          <target state="translated">Aqu&amp;iacute; hay un ejemplo de c&amp;oacute;digo para usar &lt;code&gt;Attention&lt;/code&gt; en una red CNN + Atenci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="c2e3cf832e96b3ad2b7cfe3cb8d1e7045a255de6" translate="yes" xml:space="preserve">
          <source>Here is a table of the (roughly) expected first order behavior:</source>
          <target state="translated">Aquí hay una tabla del comportamiento de primer orden (más o menos)esperado:</target>
        </trans-unit>
        <trans-unit id="0dcb732b904f60bb8f4fb4132ab1bc7ce4c1dc40" translate="yes" xml:space="preserve">
          <source>Here is an example embedding of two features for a DNNClassifier model:</source>
          <target state="translated">Aquí hay un ejemplo de incrustación de dos características para un modelo de DNNClassifier:</target>
        </trans-unit>
        <trans-unit id="b92188d0e4470161bf6ef1be354a49527229f664" translate="yes" xml:space="preserve">
          <source>Here is an example of a standard reader function a user can define. This function enables both dataset shuffling and parallel reading of datasets:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5a139c16bbbe2e00002f4ebb6bf2d7cf0a12e13" translate="yes" xml:space="preserve">
          <source>Here is an example to create a linear model with crosses of string features:</source>
          <target state="translated">Aquí hay un ejemplo para crear un modelo lineal con cruces de características de cuerda:</target>
        </trans-unit>
        <trans-unit id="464c6369ff2a08fe078373832f4183bb8de964e9" translate="yes" xml:space="preserve">
          <source>Here is an example using &lt;code&gt;embedding_column&lt;/code&gt; with model_fn:</source>
          <target state="translated">Aqu&amp;iacute; hay un ejemplo usando &lt;code&gt;embedding_column&lt;/code&gt; con model_fn:</target>
        </trans-unit>
        <trans-unit id="bd511335f37b0684a350a25bab28497fe427dcb9" translate="yes" xml:space="preserve">
          <source>Here is an example using &lt;code&gt;shared_embedding_columns&lt;/code&gt; with model_fn:</source>
          <target state="translated">Aqu&amp;iacute; hay un ejemplo que usa &lt;code&gt;shared_embedding_columns&lt;/code&gt; con model_fn:</target>
        </trans-unit>
        <trans-unit id="e0362ba3fd11b51dc2dbcaf3363290ca8a7b99e6" translate="yes" xml:space="preserve">
          <source>Here is simplified model_fn to build a DNN regression model.</source>
          <target state="translated">Aquí está simplificado el model_fn para construir un modelo de regresión de DNN.</target>
        </trans-unit>
        <trans-unit id="bb290e88257943f8b204cd2522934a4d03f0b94a" translate="yes" xml:space="preserve">
          <source>Here the expectation is that the &lt;code&gt;input_fn_*&lt;/code&gt; functions passed to train and evaluate return a pair (dict, label_tensor) where dict has &lt;code&gt;example_id_column&lt;/code&gt; as &lt;code&gt;key&lt;/code&gt; whose value is a &lt;code&gt;Tensor&lt;/code&gt; of shape [batch_size] and dtype string. num_loss_partitions defines sigma' in eq (11) of [3]. Convergence of (global) loss is guaranteed if &lt;code&gt;num_loss_partitions&lt;/code&gt; is larger or equal to the product &lt;code&gt;(#concurrent train ops/per worker) x (#workers)&lt;/code&gt;. Larger values for &lt;code&gt;num_loss_partitions&lt;/code&gt; lead to slower convergence. The recommended value for &lt;code&gt;num_loss_partitions&lt;/code&gt; in &lt;a href=&quot;../../estimator&quot;&gt;&lt;code&gt;tf.estimator&lt;/code&gt;&lt;/a&gt; (where currently there is one process per worker) is the number of workers running the train steps. It defaults to 1 (single machine). &lt;code&gt;num_table_shards&lt;/code&gt; defines the number of shards for the internal state table, typically set to match the number of parameter servers for large data sets.</source>
          <target state="translated">Aqu&amp;iacute; la expectativa es que las funciones &lt;code&gt;input_fn_*&lt;/code&gt; pasadas para entrenar y evaluar devuelvan un par (dict, label_tensor) donde dict tiene &lt;code&gt;example_id_column&lt;/code&gt; como &lt;code&gt;key&lt;/code&gt; cuyo valor es un &lt;code&gt;Tensor&lt;/code&gt; de shape [batch_size] y dtype string. num_loss_partitions define sigma 'en la ecuaci&amp;oacute;n (11) de [3]. La convergencia de la p&amp;eacute;rdida (global) est&amp;aacute; garantizada si &lt;code&gt;num_loss_partitions&lt;/code&gt; es mayor o igual al producto &lt;code&gt;(#concurrent train ops/per worker) x (#workers)&lt;/code&gt; . Los valores m&amp;aacute;s altos para &lt;code&gt;num_loss_partitions&lt;/code&gt; conducen a una convergencia m&amp;aacute;s lenta. El valor recomendado para &lt;code&gt;num_loss_partitions&lt;/code&gt; en &lt;a href=&quot;../../estimator&quot;&gt; &lt;code&gt;tf.estimator&lt;/code&gt; &lt;/a&gt;(donde actualmente hay un proceso por trabajador) es el n&amp;uacute;mero de trabajadores que ejecutan los pasos del tren. El valor predeterminado es 1 (una sola m&amp;aacute;quina). &lt;code&gt;num_table_shards&lt;/code&gt; define el n&amp;uacute;mero de fragmentos para la tabla de estado interna, normalmente configurado para coincidir con el n&amp;uacute;mero de servidores de par&amp;aacute;metros para grandes conjuntos de datos.</target>
        </trans-unit>
        <trans-unit id="6fd075a1cf6908e13f7823aaaf120524aec476bf" translate="yes" xml:space="preserve">
          <source>Here the partial derivatives &lt;code&gt;g&lt;/code&gt; evaluate to &lt;code&gt;[1.0, 1.0]&lt;/code&gt;, compared to the total derivatives &lt;code&gt;tf.gradients(a + b, [a, b])&lt;/code&gt;, which take into account the influence of &lt;code&gt;a&lt;/code&gt; on &lt;code&gt;b&lt;/code&gt; and evaluate to &lt;code&gt;[3.0, 1.0]&lt;/code&gt;. Note that the above is equivalent to:</source>
          <target state="translated">Aqu&amp;iacute; las derivadas parciales &lt;code&gt;g&lt;/code&gt; eval&amp;uacute;an a &lt;code&gt;[1.0, 1.0]&lt;/code&gt; , en comparaci&amp;oacute;n con las derivadas totales &lt;code&gt;tf.gradients(a + b, [a, b])&lt;/code&gt; , que toman en cuenta la influencia de &lt;code&gt;a&lt;/code&gt; sobre &lt;code&gt;b&lt;/code&gt; y eval&amp;uacute;an a &lt;code&gt;[3.0, 1.0]&lt;/code&gt; . Tenga en cuenta que lo anterior es equivalente a:</target>
        </trans-unit>
        <trans-unit id="49c2e9085ffe62b7af2e00831b5211eb57d553ec" translate="yes" xml:space="preserve">
          <source>Here we check that this operator is &lt;em&gt;exactly&lt;/em&gt; equal to its hermitian transpose.</source>
          <target state="translated">Aqu&amp;iacute; comprobamos que este operador es &lt;em&gt;exactamente&lt;/em&gt; igual a su transposici&amp;oacute;n hermitiana.</target>
        </trans-unit>
        <trans-unit id="5f52f6e66184e816627dceffc4afecf746fff88d" translate="yes" xml:space="preserve">
          <source>Here we consider NASNet-A, the highest performance model that was found for the CIFAR-10 dataset, and then extended to ImageNet 2012 dataset, obtaining state of the art performance on CIFAR-10 and ImageNet 2012. Only the NASNet-A models, and their respective weights, which are suited for ImageNet 2012 are provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a715d375560e6afb15b0e0d6332a8c3f5a410ac" translate="yes" xml:space="preserve">
          <source>Here's a basic example: a layer with two variables, &lt;code&gt;w&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, that returns &lt;code&gt;y = w . x + b&lt;/code&gt;. It shows how to implement &lt;code&gt;build()&lt;/code&gt; and &lt;code&gt;call()&lt;/code&gt;. Variables set as attributes of a layer are tracked as weights of the layers (in &lt;code&gt;layer.weights&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27c376c1d7316f3407dd139c89bd36e269d0b657" translate="yes" xml:space="preserve">
          <source>Here's a simple example: a random normal initializer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66a65bf97c24fbc1825d0d9c6cb98cb1aafb52a0" translate="yes" xml:space="preserve">
          <source>Here, 'types' means the profiler nodes' properties. Profiler by default consider device name (e.g. /job:xx/.../device:GPU:0) and operation type (e.g. MatMul) as profiler nodes' properties. User can also associate customized 'types' to profiler nodes through OpLogProto proto.</source>
          <target state="translated">Aquí,&quot;tipos&quot; significa las propiedades de los nodos del perfilador.Por defecto,el perfilador considera el nombre del dispositivo (por ejemplo,/job:xx/.../dispositivo:GPU:0)y el tipo de operación (por ejemplo,MatMul)como propiedades de los nodos del perfilador.El usuario también puede asociar 'tipos' personalizados a los nodos del perfilador a través del prototipo OpLogProto.</target>
        </trans-unit>
        <trans-unit id="17b2af2adfe30a3aef16e7ccfa94f34d6e4b3818" translate="yes" xml:space="preserve">
          <source>Here, a snapshot of &lt;code&gt;v&lt;/code&gt; is captured in &lt;code&gt;value&lt;/code&gt;; and then &lt;code&gt;v&lt;/code&gt; is updated. The snapshot value is returned.</source>
          <target state="translated">Aqu&amp;iacute;, se captura una instant&amp;aacute;nea de &lt;code&gt;v&lt;/code&gt; en &lt;code&gt;value&lt;/code&gt; ; y luego &lt;code&gt;v&lt;/code&gt; se actualiza. Se devuelve el valor de la instant&amp;aacute;nea.</target>
        </trans-unit>
        <trans-unit id="ece63641c90490d540658510825631e924c7c84b" translate="yes" xml:space="preserve">
          <source>Here, adding &lt;code&gt;use_resource=True&lt;/code&gt; when constructing the variable will fix any nondeterminism issues:</source>
          <target state="translated">Aqu&amp;iacute;, agregar &lt;code&gt;use_resource=True&lt;/code&gt; al construir la variable solucionar&amp;aacute; cualquier problema no determinista:</target>
        </trans-unit>
        <trans-unit id="94f786d71b2cb60eeb24aa9948d9d1f390afdf17" translate="yes" xml:space="preserve">
          <source>Here, positive definite means that the quadratic form &lt;code&gt;x^H A x&lt;/code&gt; has positive real part for all nonzero &lt;code&gt;x&lt;/code&gt;. Note that we do not require the operator to be self-adjoint to be positive definite.</source>
          <target state="translated">Aqu&amp;iacute;, definido positivo significa que la forma cuadr&amp;aacute;tica &lt;code&gt;x^H A x&lt;/code&gt; tiene una parte real positiva para todo &lt;code&gt;x&lt;/code&gt; distinto de cero . Tenga en cuenta que no requerimos que el operador sea autoadjunto para ser definido positivo.</target>
        </trans-unit>
        <trans-unit id="51f5cbd0286b6bc2be5272d73eef56b1e6b7773c" translate="yes" xml:space="preserve">
          <source>Here, the input has a batch of 1 and each batch element has shape &lt;code&gt;[1, 1, 4]&lt;/code&gt;, the corresponding output will have 2x2 elements and will have a depth of 1 channel (1 = &lt;code&gt;4 / (block_size * block_size)&lt;/code&gt;). The output element shape is &lt;code&gt;[2, 2, 1]&lt;/code&gt;.</source>
          <target state="translated">Aqu&amp;iacute;, la entrada tiene un lote de 1 y cada elemento del lote tiene forma &lt;code&gt;[1, 1, 4]&lt;/code&gt; , la salida correspondiente tendr&amp;aacute; 2x2 elementos y tendr&amp;aacute; una profundidad de 1 canal (1 = &lt;code&gt;4 / (block_size * block_size)&lt;/code&gt; ). La forma del elemento de salida es &lt;code&gt;[2, 2, 1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2cace8ea6c5a3f6f36376df736083d35d45c704d" translate="yes" xml:space="preserve">
          <source>Here, the input has a batch of 1 and each batch element has shape &lt;code&gt;[2, 2, 1]&lt;/code&gt;, the corresponding output will have a single element (i.e. width and height are both 1) and will have a depth of 4 channels (1 * block_size * block_size). The output element shape is &lt;code&gt;[1, 1, 4]&lt;/code&gt;.</source>
          <target state="translated">Aqu&amp;iacute;, la entrada tiene un lote de 1 y cada elemento del lote tiene forma &lt;code&gt;[2, 2, 1]&lt;/code&gt; , la salida correspondiente tendr&amp;aacute; un solo elemento (es decir, el ancho y la altura son ambos 1) y tendr&amp;aacute; una profundidad de 4 canales (1 * tama&amp;ntilde;o_bloque * tama&amp;ntilde;o_bloque). La forma del elemento de salida es &lt;code&gt;[1, 1, 4]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cd54db7611e23329deb591ac691703bafcd3e97" translate="yes" xml:space="preserve">
          <source>Hierarchical level of the Ophint node, a number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ecfb1194a3a379261dd07bbb066a5568e6506a9" translate="yes" xml:space="preserve">
          <source>Hinton, 2012</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61b43f0b6cf6e4d96507128fea4cd7b8a90efe5a" translate="yes" xml:space="preserve">
          <source>Hints for collective operations like AllReduce.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d3bab4ff1c30c8ba838d1595446d9004c083483" translate="yes" xml:space="preserve">
          <source>HistogramFixedWidth</source>
          <target state="translated">HistogramFixedWidth</target>
        </trans-unit>
        <trans-unit id="a53dafd06d1ebe965ea309d8c08e1156b67e2e5e" translate="yes" xml:space="preserve">
          <source>HistogramSummary</source>
          <target state="translated">HistogramSummary</target>
        </trans-unit>
        <trans-unit id="e8876b9619eb77ec487c16beae68d94edd272b99" translate="yes" xml:space="preserve">
          <source>Holds a defined flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f41c0836949b26db8a72f139bb0d93a63f27a5d8" translate="yes" xml:space="preserve">
          <source>Holds a list of enqueue operations for a queue, each to be run in a thread.</source>
          <target state="translated">Tiene una lista de operaciones de cola para una cola,cada una para ser ejecutada en un hilo.</target>
        </trans-unit>
        <trans-unit id="82f1d229094d8c503d561ee75fa7b2f6ebb2010b" translate="yes" xml:space="preserve">
          <source>Holds state in the form of a tensor that persists across steps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7ec66187a04150d0757954c1018dca525f600f5" translate="yes" xml:space="preserve">
          <source>Hook method for deconstructing the class fixture after running all tests in the class.</source>
          <target state="translated">Método de gancho para deconstruir el aparato de la clase después de hacer todas las pruebas de la clase.</target>
        </trans-unit>
        <trans-unit id="aed79b3c251b0477f07982fb328ebad89154bf47" translate="yes" xml:space="preserve">
          <source>Hook method for deconstructing the test fixture after testing it.</source>
          <target state="translated">Método de gancho para deconstruir el aparato de prueba después de probarlo.</target>
        </trans-unit>
        <trans-unit id="d3376d91b293e2ef0e2b7a2f9d722cde34fcb75c" translate="yes" xml:space="preserve">
          <source>Hook method for setting up class fixture before running tests in the class.</source>
          <target state="translated">Método de gancho para establecer el aparato de la clase antes de hacer pruebas en la clase.</target>
        </trans-unit>
        <trans-unit id="2f3856f3bee2218da00682ea5300db8d8a163355" translate="yes" xml:space="preserve">
          <source>Hook method for setting up the test fixture before exercising it.</source>
          <target state="translated">Método de gancho para montar el aparato de prueba antes de ejercitarlo.</target>
        </trans-unit>
        <trans-unit id="8b036bc6887a5488ae47380e1e40457b96130270" translate="yes" xml:space="preserve">
          <source>Hook that counts steps per second.</source>
          <target state="translated">Gancho que cuenta los pasos por segundo.</target>
        </trans-unit>
        <trans-unit id="c583828ba4633b5282cbe15aa8308cd7a4ae402f" translate="yes" xml:space="preserve">
          <source>Hook that requests stop at a specified step.</source>
          <target state="translated">El gancho que pide que se detenga en un paso específico.</target>
        </trans-unit>
        <trans-unit id="694af7941c3209602c7a59e4452f1ab6fd0ed608" translate="yes" xml:space="preserve">
          <source>Hook to extend calls to MonitoredSession.run().</source>
          <target state="translated">Enganche para extender las llamadas a MonitoredSession.run().</target>
        </trans-unit>
        <trans-unit id="5e1bd302daecf16d1f3450073dcb3bb5f7b9e87f" translate="yes" xml:space="preserve">
          <source>Hook to run evaluation in training without a checkpoint.</source>
          <target state="translated">Gancho para ejecutar la evaluación en el entrenamiento sin un punto de control.</target>
        </trans-unit>
        <trans-unit id="094e7dc095dce31db8b2d945d9b4e16d81e5603c" translate="yes" xml:space="preserve">
          <source>Hooks can use this function to request stop of iterations. &lt;code&gt;MonitoredSession&lt;/code&gt; checks whether this is called or not.</source>
          <target state="translated">Los ganchos pueden usar esta funci&amp;oacute;n para solicitar la detenci&amp;oacute;n de iteraciones. &lt;code&gt;MonitoredSession&lt;/code&gt; comprueba si se llama o no.</target>
        </trans-unit>
        <trans-unit id="9b63e3c3d34964d61b02e9af3acc454228fbfd58" translate="yes" xml:space="preserve">
          <source>Hooks interact with the &lt;code&gt;run_with_hooks()&lt;/code&gt; call inside the &lt;code&gt;step_fn&lt;/code&gt; as they do with a &lt;code&gt;MonitoredSession.run&lt;/code&gt; call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8fa61e89297f89e6206a39ad26727e4b2370a10" translate="yes" xml:space="preserve">
          <source>Horizontal coordinate of the top-left corner of the result in the input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a54dcdd14e5ce50144dff46fc76cb90c2aac998a" translate="yes" xml:space="preserve">
          <source>How a layer uses its policy's compute dtype</source>
          <target state="translated">Cómo una capa utiliza el tipo de cálculo de su política</target>
        </trans-unit>
        <trans-unit id="8f2288d55767c1f8629065632e650bab29069f12" translate="yes" xml:space="preserve">
          <source>How a layer uses its policy's variable dtype</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd6f229db07ef1c3400e9df85c28b2f4cdc8a8b7" translate="yes" xml:space="preserve">
          <source>How identities that are created are named.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56338367b61d14699e1f7174329b84eb9405e3d2" translate="yes" xml:space="preserve">
          <source>How often to apply decay.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18377df79aa141396de4dd094b00a669cf41e8fd" translate="yes" xml:space="preserve">
          <source>How often to keep checkpoints. Defaults to 10,000 hours.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2d47c5b2670b24370374b073fdcc8981f93f9f3" translate="yes" xml:space="preserve">
          <source>How to choose:</source>
          <target state="translated">Cómo elegir:</target>
        </trans-unit>
        <trans-unit id="e3b73487529c5d6e94a503e64f0fdd72a394754d" translate="yes" xml:space="preserve">
          <source>How to gate the computation of gradients. Can be &lt;code&gt;GATE_NONE&lt;/code&gt;, &lt;code&gt;GATE_OP&lt;/code&gt;, or &lt;code&gt;GATE_GRAPH&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a70232ceb55af558f2ee0aaffe46fc01d689778f" translate="yes" xml:space="preserve">
          <source>How to handle text to bytes encoding errors. Only used if &lt;code&gt;content&lt;/code&gt; is text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b43d30453d0ca08342c32b5bf9b8ce3e75e7c394" translate="yes" xml:space="preserve">
          <source>How to set &lt;a href=&quot;../session&quot;&gt;&lt;code&gt;tf.compat.v1.Session&lt;/code&gt;&lt;/a&gt; arguments:</source>
          <target state="translated">C&amp;oacute;mo configurar los argumentos de &lt;a href=&quot;../session&quot;&gt; &lt;code&gt;tf.compat.v1.Session&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="16612609ea0121d74a2ebf85615c5cd0d97d528b" translate="yes" xml:space="preserve">
          <source>How to use float64 in a Keras model</source>
          <target state="translated">Cómo usar float64 en un modelo de Keras</target>
        </trans-unit>
        <trans-unit id="5207d3c1fa3b2863bdee0225b56cf4e73f598a8c" translate="yes" xml:space="preserve">
          <source>How to use mixed precision in a Keras model</source>
          <target state="translated">Cómo usar la precisión mixta en un modelo de Keras</target>
        </trans-unit>
        <trans-unit id="e91f1ba40e84a0d707e3f45076f0f821dd55b6b7" translate="yes" xml:space="preserve">
          <source>How to write a layer that supports mixed precision and float64.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb1a3d087cf7ab9ae32a2d72ddafa8d585fa12c7" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;broadcast_to&lt;/code&gt; does not carry with it any such benefits. The newly-created tensor takes the full memory of the broadcasted shape. (In a graph context, &lt;code&gt;broadcast_to&lt;/code&gt; might be fused to subsequent operation and then be optimized away, however.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95c24f970b239a2e8ff2902447bb8c0e66d29239" translate="yes" xml:space="preserve">
          <source>However, a few other options are available:</source>
          <target state="translated">Sin embargo,existen otras opciones:</target>
        </trans-unit>
        <trans-unit id="906c66a75c112f0781943a37770b2aadd044fd08" translate="yes" xml:space="preserve">
          <source>However, in the case of the &lt;code&gt;BatchNormalization&lt;/code&gt; layer, &lt;strong&gt;setting &lt;code&gt;trainable = False&lt;/code&gt; on the layer means that the layer will be subsequently run in inference mode&lt;/strong&gt; (meaning that it will use the moving mean and the moving variance to normalize the current batch, rather than using the mean and variance of the current batch).</source>
          <target state="translated">Sin embargo, en el caso de la capa &lt;code&gt;BatchNormalization&lt;/code&gt; , &lt;strong&gt;establecer &lt;code&gt;trainable = False&lt;/code&gt; en la capa significa que la capa se ejecutar&amp;aacute; posteriormente en modo de inferencia&lt;/strong&gt; (lo que significa que usar&amp;aacute; la media m&amp;oacute;vil y la varianza m&amp;oacute;vil para normalizar el lote actual, en lugar de usar la media y la varianza del lote actual).</target>
        </trans-unit>
        <trans-unit id="66a412ca5b09706643cf60849a60f29942f3b139" translate="yes" xml:space="preserve">
          <source>However, it is slower than &lt;code&gt;clip_by_norm()&lt;/code&gt; because all the parameters must be ready before the clipping operation can be performed.</source>
          <target state="translated">Sin embargo, es m&amp;aacute;s lento que &lt;code&gt;clip_by_norm()&lt;/code&gt; porque todos los par&amp;aacute;metros deben estar listos antes de que se pueda realizar la operaci&amp;oacute;n de recorte.</target>
        </trans-unit>
        <trans-unit id="6a7bc5ae946d568d89cd6bbe9faf1d5289b758f4" translate="yes" xml:space="preserve">
          <source>However, reducing using the above operator leads to a different computation tree (logs are taken repeatedly instead of only at the end), and the maximum is only computed pairwise instead of over the entire prefix. In general, this leads to a different and slightly less precise computation.</source>
          <target state="translated">Sin embargo,reducir el uso del operador anterior conduce a un árbol de cálculo diferente (los troncos se toman repetidamente en lugar de sólo al final),y el máximo sólo se calcula por pares en lugar de sobre el prefijo completo.En general,esto conduce a un cálculo diferente y ligeramente menos preciso.</target>
        </trans-unit>
        <trans-unit id="1596f4749baf86a816336887cccc4e62582c58ee" translate="yes" xml:space="preserve">
          <source>However, sometimes the container orchestration framework will set TF_CONFIG for you. In this case, you can just create an instance without passing in any arguments. You can find an example here to let Kuburnetes set TF_CONFIG for you: https://github.com/tensorflow/ecosystem/tree/master/kubernetes. Then you can use it with &lt;a href=&quot;../strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee99d120cbadc6a5aa63deb6ecfc26724317acd1" translate="yes" xml:space="preserve">
          <source>However, the number of GPUs available to the runtime may change during runtime initialization due to marking certain devices as not visible or configuring multiple logical devices.</source>
          <target state="translated">Sin embargo,el número de GPU disponibles para el tiempo de ejecución puede cambiar durante la inicialización del tiempo de ejecución debido a que se marcan ciertos dispositivos como no visibles o se configuran múltiples dispositivos lógicos.</target>
        </trans-unit>
        <trans-unit id="f330c6ff1769454cb3a71f75c7d58d68fb24630a" translate="yes" xml:space="preserve">
          <source>However, when adding new features, one may want to unittest it before the forward compatibility window expires. This context manager enables such tests. For example:</source>
          <target state="translated">Sin embargo,cuando se añaden nuevas características,uno puede querer probarlas antes de que expire la ventana de compatibilidad.Este gestor de contexto permite tales pruebas.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="f0583a3e5e448e8509f2cf39238e0ea21adde84e" translate="yes" xml:space="preserve">
          <source>Hyper parameters</source>
          <target state="translated">Hiper parámetros</target>
        </trans-unit>
        <trans-unit id="8c1ccbcd79a014503a1fc750addadaf475655020" translate="yes" xml:space="preserve">
          <source>Hyper parameters can be overwritten through user code:</source>
          <target state="translated">Los hiperparámetros pueden ser sobrescritos a través del código de usuario:</target>
        </trans-unit>
        <trans-unit id="dfe3cc7ab7e1d07c07d6f364735a8a458edbcaf8" translate="yes" xml:space="preserve">
          <source>Hyperbolic tangent activation function.</source>
          <target state="translated">Función de activación de la tangente hiperbólica.</target>
        </trans-unit>
        <trans-unit id="a15138d06876fc00149292405bf57e4204d00bbe" translate="yes" xml:space="preserve">
          <source>Hyperparameters</source>
          <target state="translated">Hyperparameters</target>
        </trans-unit>
        <trans-unit id="11ed6513569e71d14e0b5bbc27bbc91abe780c3c" translate="yes" xml:space="preserve">
          <source>Hyperparameters can be overwritten through user code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d739908e6b1d9515c7de084c3e63bb329523667" translate="yes" xml:space="preserve">
          <source>I.e. if we have (y1, y2, ..., y_M) = f(x1, x2, ..., x_N), then, g is (dL/dx1, dL/dx2, ..., dL/dx_N) = g(x1, x2, ..., x_N, dL/dy1, dL/dy2, ..., dL/dy_M),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caae1c164e99fd3cee75315d0e4ac958059c8bec" translate="yes" xml:space="preserve">
          <source>I.e. returns: &lt;code&gt;output = (x - mean) / (sqrt(var) + epsilon) * gamma + beta&lt;/code&gt;</source>
          <target state="translated">Es decir, devuelve: &lt;code&gt;output = (x - mean) / (sqrt(var) + epsilon) * gamma + beta&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ebc94333451747193def37a773f19cfc358efe8b" translate="yes" xml:space="preserve">
          <source>I.e., \(y = -x\).</source>
          <target state="translated">Es decir,\n(y=-x\).</target>
        </trans-unit>
        <trans-unit id="d175ea7778bab88b107391a5a5e9565e50febd2b" translate="yes" xml:space="preserve">
          <source>I.e., \(y = 1 / \sqrt{x}\).</source>
          <target state="translated">Es decir...</target>
        </trans-unit>
        <trans-unit id="3c2e39388106824c1d86c17eb18e27d101f691e9" translate="yes" xml:space="preserve">
          <source>I.e., \(y = 1 / x\).</source>
          <target state="translated">Es decir...</target>
        </trans-unit>
        <trans-unit id="311b2c8a6cdecac50bdfa3324556c4c9ed69923b" translate="yes" xml:space="preserve">
          <source>I.e., \(y = \log_e (1 + x)\).</source>
          <target state="translated">Es decir,\(y=\log_e (1+x)\N).</target>
        </trans-unit>
        <trans-unit id="aa71ce7ff4ae1b412d0ee6bf849a4d32aa4d9b69" translate="yes" xml:space="preserve">
          <source>I.e., \(y = \log_e x\).</source>
          <target state="translated">Es decir,\ ~-(y=\ ~ \ ~ \ ~-x=logaritmo).</target>
        </trans-unit>
        <trans-unit id="8fbd8a894d77699447894ea0b5205e8c3734a34e" translate="yes" xml:space="preserve">
          <source>I.e., \(y = \sqrt{x} = x^{1/2}\).</source>
          <target state="translated">Es decir...</target>
        </trans-unit>
        <trans-unit id="86e7c2902521071ed978a52a237380dc3ce4ceb1" translate="yes" xml:space="preserve">
          <source>I.e., \(y = x * x = x^2\).</source>
          <target state="translated">Es decir,\ ~-(y=x*x=x^2\).</target>
        </trans-unit>
        <trans-unit id="568335e65a798d6ef3d2eab1d09d072f51075401" translate="yes" xml:space="preserve">
          <source>I.e., the size of the outermost dimension of the tensor.</source>
          <target state="translated">Es decir,el tamaño de la dimensión más exterior del tensor.</target>
        </trans-unit>
        <trans-unit id="6299f86715c93d989aa9695775a3b9287f113675" translate="yes" xml:space="preserve">
          <source>IFFT</source>
          <target state="translated">IFFT</target>
        </trans-unit>
        <trans-unit id="022dd53bc823f3ac17a82c70736b4706025937f5" translate="yes" xml:space="preserve">
          <source>IFFT2D</source>
          <target state="translated">IFFT2D</target>
        </trans-unit>
        <trans-unit id="fc55a7fb0443a8e9116055588513b592013129a2" translate="yes" xml:space="preserve">
          <source>IFFT3D</source>
          <target state="translated">IFFT3D</target>
        </trans-unit>
        <trans-unit id="e8e744aedc2c7c5589c77a5398c1f0d6581e556f" translate="yes" xml:space="preserve">
          <source>IMDB sentiment classification dataset.</source>
          <target state="translated">Conjunto de datos de clasificación de sentimientos del IMDB.</target>
        </trans-unit>
        <trans-unit id="cd887c07fd5e921ac521a8f68bba0d58f4244bf2" translate="yes" xml:space="preserve">
          <source>IMPORTANT: Depending on the &lt;a href=&quot;../../../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; implementation being used, and whether eager execution is enabled, &lt;code&gt;fn&lt;/code&gt; may be called one or more times (once for each replica).</source>
          <target state="translated">IMPORTANTE: Dependiendo de la implementaci&amp;oacute;n de &lt;a href=&quot;../../../../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; que&lt;/a&gt; se utilice y de si la ejecuci&amp;oacute;n ansiosa est&amp;aacute; habilitada, se puede llamar a &lt;code&gt;fn&lt;/code&gt; una o m&amp;aacute;s veces (una vez para cada r&amp;eacute;plica).</target>
        </trans-unit>
        <trans-unit id="2ed0fee938570d32f30307cc8d274895cf578884" translate="yes" xml:space="preserve">
          <source>IMPORTANT: Depending on the &lt;a href=&quot;../../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; implementation being used, and whether eager execution is enabled, &lt;code&gt;fn&lt;/code&gt; may be called one or more times (once for each replica).</source>
          <target state="translated">IMPORTANTE: Dependiendo de la implementaci&amp;oacute;n de &lt;a href=&quot;../../../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; que&lt;/a&gt; se utilice y de si la ejecuci&amp;oacute;n ansiosa est&amp;aacute; habilitada, se puede llamar a &lt;code&gt;fn&lt;/code&gt; una o m&amp;aacute;s veces (una vez para cada r&amp;eacute;plica).</target>
        </trans-unit>
        <trans-unit id="a0b212e63aab3a82a290c7dc71cb4e212928f7d0" translate="yes" xml:space="preserve">
          <source>IMPORTANT: Depending on the implementation of &lt;a href=&quot;../../../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; and whether eager execution is enabled, &lt;code&gt;fn&lt;/code&gt; may be called one or more times ( once for each replica).</source>
          <target state="translated">IMPORTANTE: Dependiendo de la implementaci&amp;oacute;n de &lt;a href=&quot;../../../../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt; y de si la ejecuci&amp;oacute;n ansiosa est&amp;aacute; habilitada, se puede llamar a &lt;code&gt;fn&lt;/code&gt; una o m&amp;aacute;s veces (una vez para cada r&amp;eacute;plica).</target>
        </trans-unit>
        <trans-unit id="a856b464d5ae55c9c4b023a3135a60ea8e61e4aa" translate="yes" xml:space="preserve">
          <source>IMPORTANT: Depending on the implementation of &lt;a href=&quot;../../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; and whether eager execution is enabled, &lt;code&gt;fn&lt;/code&gt; may be called one or more times ( once for each replica).</source>
          <target state="translated">IMPORTANTE: Dependiendo de la implementaci&amp;oacute;n de &lt;a href=&quot;../../../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt; y de si la ejecuci&amp;oacute;n ansiosa est&amp;aacute; habilitada, se puede llamar a &lt;code&gt;fn&lt;/code&gt; una o m&amp;aacute;s veces (una vez para cada r&amp;eacute;plica).</target>
        </trans-unit>
        <trans-unit id="115e1c114d9f3681f99e56d6543c4b81c3fc3d32" translate="yes" xml:space="preserve">
          <source>IMPORTANT: Depending on the implementation of &lt;a href=&quot;../strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; and whether eager execution is enabled, &lt;code&gt;fn&lt;/code&gt; may be called one or more times ( once for each replica).</source>
          <target state="translated">IMPORTANTE: Dependiendo de la implementaci&amp;oacute;n de &lt;a href=&quot;../strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt; y de si la ejecuci&amp;oacute;n ansiosa est&amp;aacute; habilitada, se puede llamar a &lt;code&gt;fn&lt;/code&gt; una o m&amp;aacute;s veces (una vez para cada r&amp;eacute;plica).</target>
        </trans-unit>
        <trans-unit id="89f04e8da8a966a33aa44bfaa2ea3036d7113c48" translate="yes" xml:space="preserve">
          <source>IMPORTANT: Depending on the implementation of &lt;a href=&quot;strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; and whether eager execution is enabled, &lt;code&gt;fn&lt;/code&gt; may be called one or more times ( once for each replica).</source>
          <target state="translated">IMPORTANTE: Dependiendo de la implementaci&amp;oacute;n de &lt;a href=&quot;strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt; y de si la ejecuci&amp;oacute;n ansiosa est&amp;aacute; habilitada, se puede llamar a &lt;code&gt;fn&lt;/code&gt; una o m&amp;aacute;s veces (una vez para cada r&amp;eacute;plica).</target>
        </trans-unit>
        <trans-unit id="3af46570ffb6dae63862cdf22039cbe1fe550b02" translate="yes" xml:space="preserve">
          <source>IMPORTANT: The &lt;a href=&quot;../../../../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; returned by &lt;code&gt;dataset_fn&lt;/code&gt; should have a per-replica batch size, unlike &lt;code&gt;experimental_distribute_dataset&lt;/code&gt;, which uses the global batch size. This may be computed using &lt;code&gt;input_context.get_per_replica_batch_size&lt;/code&gt;.</source>
          <target state="translated">IMPORTANTE: El &lt;a href=&quot;../../../../data/dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; &lt;/a&gt; devuelto por &lt;code&gt;dataset_fn&lt;/code&gt; debe tener un tama&amp;ntilde;o de lote por r&amp;eacute;plica, a diferencia de &lt;code&gt;experimental_distribute_dataset&lt;/code&gt; , que usa el tama&amp;ntilde;o de lote global. Esto se puede calcular usando &lt;code&gt;input_context.get_per_replica_batch_size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="387e6943d94be6545861c405c7eedd2b318559f0" translate="yes" xml:space="preserve">
          <source>IMPORTANT: The &lt;a href=&quot;../../../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; returned by &lt;code&gt;dataset_fn&lt;/code&gt; should have a per-replica batch size, unlike &lt;code&gt;experimental_distribute_dataset&lt;/code&gt;, which uses the global batch size. This may be computed using &lt;code&gt;input_context.get_per_replica_batch_size&lt;/code&gt;.</source>
          <target state="translated">IMPORTANTE: El &lt;a href=&quot;../../../data/dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; &lt;/a&gt; devuelto por &lt;code&gt;dataset_fn&lt;/code&gt; debe tener un tama&amp;ntilde;o de lote por r&amp;eacute;plica, a diferencia de &lt;code&gt;experimental_distribute_dataset&lt;/code&gt; , que usa el tama&amp;ntilde;o de lote global. Esto se puede calcular usando &lt;code&gt;input_context.get_per_replica_batch_size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="371527ec937092bce8c5302761968a912dfa40b4" translate="yes" xml:space="preserve">
          <source>IMPORTANT: The &lt;a href=&quot;../../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; returned by &lt;code&gt;dataset_fn&lt;/code&gt; should have a per-replica batch size, unlike &lt;code&gt;experimental_distribute_dataset&lt;/code&gt;, which uses the global batch size. This may be computed using &lt;code&gt;input_context.get_per_replica_batch_size&lt;/code&gt;.</source>
          <target state="translated">IMPORTANTE: El &lt;a href=&quot;../../data/dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; &lt;/a&gt; devuelto por &lt;code&gt;dataset_fn&lt;/code&gt; debe tener un tama&amp;ntilde;o de lote por r&amp;eacute;plica, a diferencia de &lt;code&gt;experimental_distribute_dataset&lt;/code&gt; , que usa el tama&amp;ntilde;o de lote global. Esto se puede calcular usando &lt;code&gt;input_context.get_per_replica_batch_size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ad1bd30c735d96ef3bf70ea7676440f0a17a75f" translate="yes" xml:space="preserve">
          <source>IMPORTANT: The &lt;a href=&quot;../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; returned by &lt;code&gt;dataset_fn&lt;/code&gt; should have a per-replica batch size, unlike &lt;code&gt;experimental_distribute_dataset&lt;/code&gt;, which uses the global batch size. This may be computed using &lt;code&gt;input_context.get_per_replica_batch_size&lt;/code&gt;.</source>
          <target state="translated">IMPORTANTE: El &lt;a href=&quot;../data/dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; &lt;/a&gt; devuelto por &lt;code&gt;dataset_fn&lt;/code&gt; debe tener un tama&amp;ntilde;o de lote por r&amp;eacute;plica, a diferencia de &lt;code&gt;experimental_distribute_dataset&lt;/code&gt; , que usa el tama&amp;ntilde;o de lote global. Esto se puede calcular usando &lt;code&gt;input_context.get_per_replica_batch_size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6a0418b361073a5e7f1934efa7924dff3340f39" translate="yes" xml:space="preserve">
          <source>IMPORTANT: The ordering of communications must be identical in all replicas.</source>
          <target state="translated">IMPORTANTE:El orden de las comunicaciones debe ser idéntico en todas las réplicas.</target>
        </trans-unit>
        <trans-unit id="94ef35d6e06d69b9a685928876f94b41c52dc1b8" translate="yes" xml:space="preserve">
          <source>INT8 precision and calibration with pre-built engines</source>
          <target state="translated">La precisión y la calibración del INT8 con motores preconstruidos</target>
        </trans-unit>
        <trans-unit id="02f4e09badaa8dec60af1a67b17355e9f8784a58" translate="yes" xml:space="preserve">
          <source>IRFFT</source>
          <target state="translated">IRFFT</target>
        </trans-unit>
        <trans-unit id="cd7b29bbdbb4febdf272a0721f00f37ac64b2660" translate="yes" xml:space="preserve">
          <source>IRFFT2D</source>
          <target state="translated">IRFFT2D</target>
        </trans-unit>
        <trans-unit id="505b56d0dfad67f6287be15698ed8d2d0a478343" translate="yes" xml:space="preserve">
          <source>IRFFT3D</source>
          <target state="translated">IRFFT3D</target>
        </trans-unit>
        <trans-unit id="b7fb9aff273f4e7c1abf394ced0a28207f4c3ff0" translate="yes" xml:space="preserve">
          <source>Id of the logical core to which the tensor will be assigned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e5a975b6add84fd53e3710a9ceac15eb06663b7" translate="yes" xml:space="preserve">
          <source>Identity</source>
          <target state="translated">Identity</target>
        </trans-unit>
        <trans-unit id="d80b904d270ef375a1087a947ac36d152e92b4cb" translate="yes" xml:space="preserve">
          <source>Identity op for gradient debugging.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcb6f3d33c4ea39559275c930a1a34976ca902d4" translate="yes" xml:space="preserve">
          <source>Identity transformation that models performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a76eeb09e71e8d2d0f23e62506c812d22c2249b1" translate="yes" xml:space="preserve">
          <source>IdentityN</source>
          <target state="translated">IdentityN</target>
        </trans-unit>
        <trans-unit id="e4b9406c08cb428e87ba5ea8a378f561e51f4001" translate="yes" xml:space="preserve">
          <source>IdentityReader</source>
          <target state="translated">IdentityReader</target>
        </trans-unit>
        <trans-unit id="a0979d88b1fbcd35635c010eeafb5d1b3fed8a90" translate="yes" xml:space="preserve">
          <source>IdentityReaderV2</source>
          <target state="translated">IdentityReaderV2</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="c1c674b793716e07ef9b792eb875da397416ebb5" translate="yes" xml:space="preserve">
          <source>If &quot;ortho&quot;, orthonormal inverse DCT4 is performed, if it is None, a regular dct4 followed by scaling of &lt;code&gt;1/frame_length&lt;/code&gt; is performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b472357b902f890e4087773a365cdaed808b715" translate="yes" xml:space="preserve">
          <source>If &quot;shape&quot; is None, the resulting tensor proto represents the numpy array precisely.</source>
          <target state="translated">Si la &quot;forma&quot; es Ninguna,el prototipo tensorial resultante representa el conjunto numérico con precisión.</target>
        </trans-unit>
        <trans-unit id="94418d02e3456ba7719cd5581956e1dd1bf97adf" translate="yes" xml:space="preserve">
          <source>If &quot;values&quot; is a python scalar or a python list, make_tensor_proto first convert it to numpy ndarray. If dtype is None, the conversion tries its best to infer the right numpy data type. Otherwise, the resulting numpy array has a compatible data type with the given dtype.</source>
          <target state="translated">Si &quot;valores&quot; es un escalar de pitón o una lista de pitón,make_tensor_proto lo convierte primero en numpy ndarray.Si dtype es None,la conversión hace lo posible por inferir el tipo de datos numpy correcto.De lo contrario,la matriz numpy resultante tiene un tipo de datos compatible con el dtype dado.</target>
        </trans-unit>
        <trans-unit id="ce8cd0fc85fc9a1e3f9b8136172f9b19c9148972" translate="yes" xml:space="preserve">
          <source>If 'graph_def' is not a graph_pb2.GraphDef proto.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abc290220c1d811dd5249ce87700169b77049924" translate="yes" xml:space="preserve">
          <source>If 3-D, the shape is &lt;code&gt;[height, width, channels]&lt;/code&gt;, and the Tensor represents one image. If 4-D, the shape is &lt;code&gt;[batch_size, height, width, channels]&lt;/code&gt;, and the Tensor represents &lt;code&gt;batch_size&lt;/code&gt; images.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1d182960fbca1d39b731de95605b52d11d64a48" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;0 &amp;lt; min &amp;lt; max&lt;/code&gt;: &lt;code&gt;min_adj = 0&lt;/code&gt; and &lt;code&gt;max_adj = max - min&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2291e4d4d0493fe7acb48d2007a3752b8f7b2d33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is block circulant, with block sizes &lt;code&gt;N0, N1&lt;/code&gt; (&lt;code&gt;N0 * N1 = N&lt;/code&gt;): &lt;code&gt;A&lt;/code&gt; has a block circulant structure, composed of &lt;code&gt;N0 x N0&lt;/code&gt; blocks, with each block an &lt;code&gt;N1 x N1&lt;/code&gt; circulant matrix.</source>
          <target state="translated">Si &lt;code&gt;A&lt;/code&gt; es un bloque circulante, con tama&amp;ntilde;os de bloque &lt;code&gt;N0, N1&lt;/code&gt; ( &lt;code&gt;N0 * N1 = N&lt;/code&gt; ): &lt;code&gt;A&lt;/code&gt; tiene una estructura de bloque circulante, compuesta por &lt;code&gt;N0 x N0&lt;/code&gt; bloques, con cada bloque una matriz circulante &lt;code&gt;N1 x N1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3f8efbf3d9e6147ecaa064f2b05f3a2250d33f3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is nested block circulant, with block sizes &lt;code&gt;N0, N1, N2&lt;/code&gt; (&lt;code&gt;N0 * N1 * N2 = N&lt;/code&gt;): &lt;code&gt;A&lt;/code&gt; has a block structure, composed of &lt;code&gt;N0 x N0&lt;/code&gt; blocks, with each block an &lt;code&gt;N1 x N1&lt;/code&gt; block circulant matrix.</source>
          <target state="translated">Si &lt;code&gt;A&lt;/code&gt; es un bloque circulante anidado, con tama&amp;ntilde;os de bloque &lt;code&gt;N0, N1, N2&lt;/code&gt; ( &lt;code&gt;N0 * N1 * N2 = N&lt;/code&gt; ): &lt;code&gt;A&lt;/code&gt; tiene una estructura de bloque, compuesta por &lt;code&gt;N0 x N0&lt;/code&gt; bloques, con cada bloque una matriz circulante de bloques &lt;code&gt;N1 x N1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be595307418539e13ef1fb9321c103ad2f7818c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;False&lt;/code&gt; (default) raise an error if there are no variables in the graph. Otherwise, construct the saver anyway and make it a no-op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76019b2232667e78369e47c4fc4d6fef16616868" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;False&lt;/code&gt;, allows the variable to be initialized with a value of unknown shape. If &lt;code&gt;True&lt;/code&gt;, the default, the shape of &lt;code&gt;initial_value&lt;/code&gt; must be known.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ce446f25db0af92e41fafc3bf4dab8c93e6763a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;False&lt;/code&gt;, raises an error if any of the threads are still alive after &lt;code&gt;stop_grace_period_secs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12c5ee09ddeadea58c00f27a5fe9253ffe07db54" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;False&lt;/code&gt;, yields the whole batch as returned by the &lt;code&gt;model_fn&lt;/code&gt; instead of decomposing the batch into individual elements. This is useful if &lt;code&gt;model_fn&lt;/code&gt; returns some tensors whose first dimension is not equal to the batch size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25587966a8e2f216b6da2cdce4060125a4291eb7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;H.shape = [N0, N1, N2]&lt;/code&gt;, (&lt;code&gt;N0 * N1 * N2 = N&lt;/code&gt;): Loosely speaking, matrix multiplication is equal to the action of a Fourier multiplier: &lt;code&gt;A u = IDFT3[ H DFT3[u] ]&lt;/code&gt;. Precisely speaking, given &lt;code&gt;[N, R]&lt;/code&gt; matrix &lt;code&gt;u&lt;/code&gt;, let &lt;code&gt;DFT3[u]&lt;/code&gt; be the &lt;code&gt;[N0, N1, N2, R]&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; defined by re-shaping &lt;code&gt;u&lt;/code&gt; to &lt;code&gt;[N0, N1, N2, R]&lt;/code&gt; and taking a three dimensional DFT across the first three dimensions. Let &lt;code&gt;IDFT3&lt;/code&gt; be the inverse of &lt;code&gt;DFT3&lt;/code&gt;. Matrix multiplication may be expressed columnwise:</source>
          <target state="translated">Si &lt;code&gt;H.shape = [N0, N1, N2]&lt;/code&gt; , ( &lt;code&gt;N0 * N1 * N2 = N&lt;/code&gt; ): En t&amp;eacute;rminos generales, la multiplicaci&amp;oacute;n de matrices es igual a la acci&amp;oacute;n de un multiplicador de Fourier: &lt;code&gt;A u = IDFT3[ H DFT3[u] ]&lt;/code&gt; . Hablando con precisi&amp;oacute;n, dada &lt;code&gt;[N, R]&lt;/code&gt; matriz &lt;code&gt;u&lt;/code&gt; , sea &lt;code&gt;DFT3[u]&lt;/code&gt; el &lt;code&gt;Tensor&lt;/code&gt; &lt;code&gt;[N0, N1, N2, R]&lt;/code&gt; definido al remodelar &lt;code&gt;u&lt;/code&gt; a &lt;code&gt;[N0, N1, N2, R]&lt;/code&gt; y tomar una DFT en las primeras tres dimensiones. Sea &lt;code&gt;IDFT3&lt;/code&gt; la inversa de &lt;code&gt;DFT3&lt;/code&gt; . La multiplicaci&amp;oacute;n de matrices se puede expresar en columnas:</target>
        </trans-unit>
        <trans-unit id="7e381afea75d47e56f3608744fb4bdb4a6e5cfdf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;H.shape = [N0, N1]&lt;/code&gt;, (&lt;code&gt;N0 * N1 = N&lt;/code&gt;): Loosely speaking, matrix multiplication is equal to the action of a Fourier multiplier: &lt;code&gt;A u = IDFT2[ H DFT2[u] ]&lt;/code&gt;. Precisely speaking, given &lt;code&gt;[N, R]&lt;/code&gt; matrix &lt;code&gt;u&lt;/code&gt;, let &lt;code&gt;DFT2[u]&lt;/code&gt; be the &lt;code&gt;[N0, N1, R]&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; defined by re-shaping &lt;code&gt;u&lt;/code&gt; to &lt;code&gt;[N0, N1, R]&lt;/code&gt; and taking a two dimensional DFT across the first two dimensions. Let &lt;code&gt;IDFT2&lt;/code&gt; be the inverse of &lt;code&gt;DFT2&lt;/code&gt;. Matrix multiplication may be expressed columnwise:</source>
          <target state="translated">Si &lt;code&gt;H.shape = [N0, N1]&lt;/code&gt; , ( &lt;code&gt;N0 * N1 = N&lt;/code&gt; ): Hablando libremente, la multiplicaci&amp;oacute;n de matrices es igual a la acci&amp;oacute;n de un multiplicador de Fourier: &lt;code&gt;A u = IDFT2[ H DFT2[u] ]&lt;/code&gt; . Hablando con precisi&amp;oacute;n, dada &lt;code&gt;[N, R]&lt;/code&gt; matriz &lt;code&gt;u&lt;/code&gt; , sea &lt;code&gt;DFT2[u]&lt;/code&gt; el &lt;code&gt;Tensor&lt;/code&gt; &lt;code&gt;[N0, N1, R]&lt;/code&gt; definido al remodelar &lt;code&gt;u&lt;/code&gt; a &lt;code&gt;[N0, N1, R]&lt;/code&gt; y tomar una DFT bidimensional en la primera dos dimensiones. Sea &lt;code&gt;IDFT2&lt;/code&gt; la inversa de &lt;code&gt;DFT2&lt;/code&gt; . La multiplicaci&amp;oacute;n de matrices se puede expresar en columnas:</target>
        </trans-unit>
        <trans-unit id="4bbcbab5946b02f4bd8339afde5bc909bf23760f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;L&lt;/code&gt; is non-singular, solves and determinants are available. Solves/determinants both involve a solve/determinant of a &lt;code&gt;K x K&lt;/code&gt; system. In the event that L and D are self-adjoint positive-definite, and U = V, this can be done using a Cholesky factorization. The user should set the &lt;code&gt;is_X&lt;/code&gt; matrix property hints, which will trigger the appropriate code path.</source>
          <target state="translated">Si &lt;code&gt;L&lt;/code&gt; no es singular, las soluciones y los determinantes est&amp;aacute;n disponibles. Las soluciones / determinantes implican una soluci&amp;oacute;n / determinante de un sistema &lt;code&gt;K x K&lt;/code&gt; .En el caso de que L y D sean autoadjuntos positivos definidos, y U = V, esto se puede hacer usando una factorizaci&amp;oacute;n de Cholesky. El usuario debe establecer las &lt;code&gt;is_X&lt;/code&gt; propiedad de la matriz is_X , que activar&amp;aacute;n la ruta del c&amp;oacute;digo correspondiente.</target>
        </trans-unit>
        <trans-unit id="9426460040356d10df11f6a515a1e8a979f481d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;M = N&lt;/code&gt;, determinants and solves are done using the matrix determinant lemma and Woodbury identities, and thus require L and D to be non-singular.</source>
          <target state="translated">Si &lt;code&gt;M = N&lt;/code&gt; , los determinantes y las soluciones se realizan utilizando el lema del determinante de la matriz y las identidades de Woodbury y, por lo tanto, se requiere que L y D no sean singulares.</target>
        </trans-unit>
        <trans-unit id="ad6839f42ef3ffc050c2206365782e56e109f3df" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;M=N&lt;/code&gt;, &lt;code&gt;operator.determinant()&lt;/code&gt; is &lt;code&gt;O(N^3)&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;M=N&lt;/code&gt; , el determinante del &lt;code&gt;operator.determinant()&lt;/code&gt; es &lt;code&gt;O(N^3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d2680f7f302962db3beec63891212a96a0cde62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;M=N&lt;/code&gt;, &lt;code&gt;operator.solve(x)&lt;/code&gt; is &lt;code&gt;O(N^3 * R)&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;M=N&lt;/code&gt; , &lt;code&gt;operator.solve(x)&lt;/code&gt; es &lt;code&gt;O(N^3 * R)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="135f5e4b5839b28e49cfbf03c1f2e3688968e292" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;None&lt;/code&gt;, this column's graph operations will fail for out-of-range inputs. Otherwise, this value must be in the range &lt;code&gt;[0, num_buckets)&lt;/code&gt;, and will replace out-of-range inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef95464404d2b393bbdf4fc6ab3d0ee4bd75e4aa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SLICED&lt;/code&gt;, &lt;code&gt;input_fn&lt;/code&gt; is only invoked once on host 0 and the tensors are broadcasted to all other replicas. Unlike per_host_input_for_training=BROADCAST, each replica will only get a slice of the data instead of a whole copy. If &lt;code&gt;PER_HOST_V1&lt;/code&gt;, the behaviour is determined by per_host_input_for_training.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e41171d0e9385cb32976695c17de0293dfc81335" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is smaller than &lt;code&gt;type&lt;/code&gt;, the operator requires that the rightmost dimension be equal to sizeof(&lt;code&gt;type&lt;/code&gt;)/sizeof(&lt;code&gt;T&lt;/code&gt;). The shape then goes from [..., sizeof(&lt;code&gt;type&lt;/code&gt;)/sizeof(&lt;code&gt;T&lt;/code&gt;)] to [...].</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es menor que &lt;code&gt;type&lt;/code&gt; , el operador requiere que la dimensi&amp;oacute;n m&amp;aacute;s a la derecha sea igual a sizeof ( &lt;code&gt;type&lt;/code&gt; ) / sizeof ( &lt;code&gt;T&lt;/code&gt; ). Luego, la forma va de [..., tama&amp;ntilde;o de ( &lt;code&gt;type&lt;/code&gt; ) / tama&amp;ntilde;o de ( &lt;code&gt;T&lt;/code&gt; )] a [...].</target>
        </trans-unit>
        <trans-unit id="f079c69e69a4356b0afc3a68a04e8a9df020a45f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt; also add the variable to the graph collection &lt;code&gt;GraphKeys.TRAINABLE_VARIABLES&lt;/code&gt; (see &lt;a href=&quot;../../../variable&quot;&gt;&lt;code&gt;tf.Variable&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4ea3bdb19c685aaba0fdcffcc4245ede4dfe76e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt; also add the variable to the graph collection &lt;code&gt;GraphKeys.TRAINABLE_VARIABLES&lt;/code&gt; (see &lt;a href=&quot;../../variable&quot;&gt;&lt;code&gt;tf.Variable&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a01f60da247392cdad0c9e7a8e6ffe0d9121cf14" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt; ignores threads that remain running after a grace period when joining threads via the coordinator, instead of raising a RuntimeError.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="946aecac475452eb0ed096696a58e4ebd59858f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt; then left and right singular vectors will be computed and returned in &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt;, respectively. Otherwise, only the singular values will be computed, which can be significantly faster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a21cfe2fdb7abc2b66d47b4c832133c76184e58" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt; use Nesterov Momentum. See (Sutskever et al., 2013). This implementation always computes gradients at the value of the variable(s) passed to the optimizer. Using Nesterov Momentum makes the variable(s) track the values called &lt;code&gt;theta_t + mu*v_t&lt;/code&gt; in the paper. This implementation is an approximation of the original formula, valid for high values of momentum. It will compute the &quot;adjusted gradient&quot; in NAG by assuming that the new gradient will be estimated by the current average gradient plus the product of momentum and the change in the average gradient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86237982c3c43c35aa2590c7e6ebaefaedebe548" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt; use locks for update operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94436823001587bebe4bff18b8f99b1bbfb1c438" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is conjugated and transposed before multiplication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a642a7ec441e51ecf27e357c6a9696cb5e000375" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is transposed before multiplication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ddf60234d5af08780027290ae88b8168ae65fce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is treated as a sparse matrix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52ec93076c6b1fffbc6ade7b8f68a02b7f68971d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is treated as a sparse matrix. Notice, this &lt;strong&gt;does not support &lt;a href=&quot;../../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;, it just makes optimizations that assume most values in &lt;code&gt;a&lt;/code&gt; are zero. See &lt;a href=&quot;../../sparse/sparse_dense_matmul&quot;&gt;&lt;code&gt;tf.sparse.sparse_dense_matmul&lt;/code&gt;&lt;/a&gt; for some support for &lt;a href=&quot;../../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt; multiplication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1697ff3ee8a41dc246673fdb0bd9e9711e59c23" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is treated as a sparse matrix. Notice, this &lt;strong&gt;does not support &lt;a href=&quot;../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;, it just makes optimizations that assume most values in &lt;code&gt;a&lt;/code&gt; are zero. See &lt;a href=&quot;../sparse/sparse_dense_matmul&quot;&gt;&lt;code&gt;tf.sparse.sparse_dense_matmul&lt;/code&gt;&lt;/a&gt; for some support for &lt;a href=&quot;../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt; multiplication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1c9b8fad2ab98bd05073e40df3f5a02c810f953" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is treated as a sparse matrix. Notice, this &lt;strong&gt;does not support &lt;a href=&quot;sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;, it just makes optimizations that assume most values in &lt;code&gt;a&lt;/code&gt; are zero. See &lt;a href=&quot;sparse/sparse_dense_matmul&quot;&gt;&lt;code&gt;tf.sparse.sparse_dense_matmul&lt;/code&gt;&lt;/a&gt; for some support for &lt;a href=&quot;sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt; multiplication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fad0a3980be272448053a98b2a7116e7f60c91f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; is conjugated and transposed before multiplication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ad4472b4b3225d0732d75b312044bfcf48b0406" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; is transposed before multiplication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="126790682ab49a5c3034dfafbd64f261a4ad3a9d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; is treated as a sparse matrix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cf6a577f44625697505a42af18c8b69cd849768" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; is treated as a sparse matrix. Notice, this &lt;strong&gt;does not support &lt;a href=&quot;../../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;, it just makes optimizations that assume most values in &lt;code&gt;a&lt;/code&gt; are zero. See &lt;a href=&quot;../../sparse/sparse_dense_matmul&quot;&gt;&lt;code&gt;tf.sparse.sparse_dense_matmul&lt;/code&gt;&lt;/a&gt; for some support for &lt;a href=&quot;../../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt; multiplication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ec845c050d819112e3b46bf32f89021852b963a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; is treated as a sparse matrix. Notice, this &lt;strong&gt;does not support &lt;a href=&quot;../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;, it just makes optimizations that assume most values in &lt;code&gt;a&lt;/code&gt; are zero. See &lt;a href=&quot;../sparse/sparse_dense_matmul&quot;&gt;&lt;code&gt;tf.sparse.sparse_dense_matmul&lt;/code&gt;&lt;/a&gt; for some support for &lt;a href=&quot;../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt; multiplication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6d14d22c43ea44883e43139147e76fb5ad9623b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; is treated as a sparse matrix. Notice, this &lt;strong&gt;does not support &lt;a href=&quot;sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;, it just makes optimizations that assume most values in &lt;code&gt;a&lt;/code&gt; are zero. See &lt;a href=&quot;sparse/sparse_dense_matmul&quot;&gt;&lt;code&gt;tf.sparse.sparse_dense_matmul&lt;/code&gt;&lt;/a&gt; for some support for &lt;a href=&quot;sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt; multiplication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="222a09a0e7fe887672fd52c4d3f159ce40c5fb29" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;rhs&lt;/code&gt; is conjugated before solving.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ee0c3e2e6c4ac6e6797a5a36bf9ecf84d41c2a9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;rhs&lt;/code&gt; is transposed before solving (has no effect if the shape of rhs is [..., M]).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="233ae30a7f5e91029f31b27ee857d509b29f2bd2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, GradientTapes automatically watch uses of this variable. Defaults to &lt;code&gt;True&lt;/code&gt;, unless &lt;code&gt;synchronization&lt;/code&gt; is set to &lt;code&gt;ON_READ&lt;/code&gt;, in which case it defaults to &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0afa1955aa77eeb749a18ccebe78b8eeaccc2307" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, allows restoring parameters from a checkpoint where the variables have a different shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="601907c4d4c0839c609aedb534e7cdab5256c862" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, also adds the variable to the graph collection &lt;code&gt;GraphKeys.TRAINABLE_VARIABLES&lt;/code&gt;. This collection is used as the default list of variables to use by the &lt;code&gt;Optimizer&lt;/code&gt; classes. Defaults to &lt;code&gt;True&lt;/code&gt;, unless &lt;code&gt;synchronization&lt;/code&gt; is set to &lt;code&gt;ON_READ&lt;/code&gt;, in which case it defaults to &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="337cb0d0d34855011c664db8787f193704be415a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, and the batch size does not evenly divide the input dataset size, the final smaller batch will be dropped. Defaults to &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db81e1cd0261358201cfc92220de12fd4f7d7ec2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, clip the input before casting (if necessary).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08c017b75b4c5c09adcc12047e395b03c28e54e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, defer adding the save and restore ops to the &lt;code&gt;build()&lt;/code&gt; call. In that case &lt;code&gt;build()&lt;/code&gt; should be called before finalizing the graph or using the saver.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="535bc3ef8bbf4f69fb7a9e1d93a9c142b1ce157b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, for &lt;code&gt;PER_HOST_V1&lt;/code&gt;, the &lt;code&gt;input_fn&lt;/code&gt; is invoked once on each host, and the number of hosts must be smaller or equal to the number of replicas. For PER_HOST_V2, the &lt;code&gt;input_fn&lt;/code&gt; is invoked once for each host (if the number of hosts is less than the number of replicas) or replica (if the number of replicas is less than the number of hosts. With the per-core input pipeline configuration, it is invoked once for each core. With a global batch size &lt;code&gt;train_batch_size&lt;/code&gt; in &lt;code&gt;TPUEstimator&lt;/code&gt; constructor, the batch size for each shard is &lt;code&gt;train_batch_size&lt;/code&gt; // #hosts in the &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;PER_HOST_V1&lt;/code&gt; mode. In &lt;code&gt;PER_HOST_V2&lt;/code&gt; mode, it is &lt;code&gt;train_batch_size&lt;/code&gt; // #cores. In &lt;code&gt;BROADCAST&lt;/code&gt; mode, &lt;code&gt;input_fn&lt;/code&gt; is only invoked once on host 0 and the tensors are broadcasted to all other replicas. The batch size equals to &lt;code&gt;train_batch_size&lt;/code&gt;. With the per-core input pipeline configuration, the shard batch size is also &lt;code&gt;train_batch_size&lt;/code&gt; // #cores. Note: per_host_input_for_training==PER_SHARD_V1 only supports mode.TRAIN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aef50b292b594a6da14b09ab9760986efee383b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, it will take care of initialization and recovery the underlying TensorFlow session. If &lt;code&gt;False&lt;/code&gt;, it will wait on a chief to initialize or recover the TensorFlow session.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15f6b2b84877ffa96ce2cbae90c18e832c6f120f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, loss and metric results are returned as a dict, with each key being the name of the metric. If &lt;code&gt;False&lt;/code&gt;, they are returned as a list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa358cb3159f218d18da7d37c8763834650bf5be" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, perform exclusive cumprod.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3b84bbb819fc7e0f87eb08a15090a3df3ad9ab9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, perform exclusive cumsum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66ec1c96eb14414e0c3909fcc072eace78950c80" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, perform exclusive cumulative log-sum-exp.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3abf56f37d62111bf5ebd198630f4ea32ea9ada1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, performs the cumulative log-sum-exp in the reverse direction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="318211393bec4a40ac0da76a23ca5015e45c8c8c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, reading performance will be improved at the cost of non-deterministic ordering. If &lt;code&gt;False&lt;/code&gt;, the order of elements produced is deterministic prior to shuffling (elements are still randomized if &lt;code&gt;shuffle=True&lt;/code&gt;. Note that if the seed is set, then order of elements after shuffling is deterministic). Defaults to &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8bb62dc74d88b8edaeb47f43964e47a5b518e53" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, save the GraphDebugInfo to a separate file, which in the same directory of filename and with &lt;code&gt;_debug&lt;/code&gt; added before the file extend.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf43d23f0ecd7bdfeb8cb8e4485edfa32ad1b03c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, save the GraphDebugInfo to a separate file, which in the same directory of filename and with &lt;code&gt;_debug&lt;/code&gt; added before the file extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10baa9814ddfe2f402edcc6e487d3d143fa6aa42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, save the GraphDebugInfo to a separate file, which in the same directory of save_path and with &lt;code&gt;_debug&lt;/code&gt; added before the file extension. This is only enabled when &lt;code&gt;write_meta_graph&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4f90c2fb6fb2ab19be5872f2da029643e688f02" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, shard the checkpoints, one per device.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46d0c23c1b4c7f7cadb0bffb6e4cbfd1627119d5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, the TensorArray will be colocated on the same device as the Tensor used on its first write (write operations include &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;unstack&lt;/code&gt;, and &lt;code&gt;split&lt;/code&gt;). If &lt;code&gt;False&lt;/code&gt;, the TensorArray will be placed on the device determined by the device context available during its initialization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8363894bad226438c506c5e40b7faccc3671fdb4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, the metrics returned will be only for this batch. If &lt;code&gt;False&lt;/code&gt;, the metrics will be statefully accumulated across batches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aa06177b2b04511f6d7ed4e6e71f5849438d5e3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, use locking during the assignment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d87a800a10420bfc89f6cb43f1131e20ba5d176" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, use locking during the operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b927ef95a6c43e52135bc483aa864c92121f05e6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, we create an auxiliary name scope with the scope. If &lt;code&gt;False&lt;/code&gt;, we don't create it. Note that the argument is not inherited, and it only takes effect for once when creating. You should only use it for re-entering a premade variable scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fcc0fa67fe23a49a5d74cb9655d9b3cb4f63ad8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, will create a scalar variable to scale the attention scores.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92385bcfeb82ed0fc98270c8ee3478c21cbd2b7b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, will create a variable to scale the attention scores.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="149c7fd8624dc8d2ba3ca596d6014d881674a0a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, will write relative paths to the checkpoint state file. This is needed if the user wants to copy the checkpoint directory and reload from the copied directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db8d9750c81e42e1484a51545102b5ed2e5301a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, writes the &lt;code&gt;MetaGraphDef&lt;/code&gt; as an ASCII proto.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53f2411ed105fdc9115bbd2f5c44470569e72920" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, writes the graph as an ASCII proto.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="673940925e4bc982f03f7524775bd28a417c9a4e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, writes the meta_graph as an ASCII proto.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b23962326191d9b25f9cdcce5f98485e099e80d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, zero debias moving-averages that are initialized with tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29d6ce24d2935a15c7b87ceecd4d7f07ec4715cd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are unexpectedly close at all elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="080af896ac284ed3da9331039d890d8b9e9a6b6e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is an invalid types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76a2c5482f070a2a6296eb33a6b159ce01fd5df8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is determined statically to have &lt;code&gt;rank &amp;lt; 2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64972012cfa9f1bb68627595da20410a52e6b063" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is sparse and &lt;code&gt;b&lt;/code&gt; is dense.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c7a904e6acee7cc058932afbbd9186b0a891454" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;adjoint_a == false&lt;/code&gt;: &lt;code&gt;A&lt;/code&gt; should be sorted in lexicographically increasing order. Use &lt;a href=&quot;reorder&quot;&gt;&lt;code&gt;sparse.reorder&lt;/code&gt;&lt;/a&gt; if you're not sure.</source>
          <target state="translated">Si &lt;code&gt;adjoint_a == false&lt;/code&gt; : &lt;code&gt;A&lt;/code&gt; debe ordenarse en orden lexicogr&amp;aacute;ficamente creciente. Utilice &lt;a href=&quot;reorder&quot;&gt; &lt;code&gt;sparse.reorder&lt;/code&gt; &lt;/a&gt; si no est&amp;aacute; seguro.</target>
        </trans-unit>
        <trans-unit id="07af4a9ac21faf4286799bc8a4a85745861cc3f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;adjoint_a == true&lt;/code&gt;: &lt;code&gt;A&lt;/code&gt; should be sorted in order of increasing dimension 1 (i.e., &quot;column major&quot; order instead of &quot;row major&quot; order).</source>
          <target state="translated">Si &lt;code&gt;adjoint_a == true&lt;/code&gt; : &lt;code&gt;A&lt;/code&gt; debe ordenarse en orden de dimensi&amp;oacute;n creciente 1 (es decir, orden de &quot;columna principal&quot; en lugar de orden de &quot;fila principal&quot;).</target>
        </trans-unit>
        <trans-unit id="bcbc484ef4b22bd434aebfe0c60fc098a6f45998" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;all_model_checkpoint_timestamps&lt;/code&gt; was provided but its length does not match &lt;code&gt;all_model_checkpoint_paths&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="110ff3780b3515c9d733eede8bbe4c3bc9825cee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;all_reduce&lt;/code&gt; is called in any replica, it must be called in all replicas. The nested structure and &lt;code&gt;Tensor&lt;/code&gt; shapes must be identical in all replicas.</source>
          <target state="translated">Si se llama a &lt;code&gt;all_reduce&lt;/code&gt; en cualquier r&amp;eacute;plica, se debe llamar en todas las r&amp;eacute;plicas. La estructura anidada y las formas del &lt;code&gt;Tensor&lt;/code&gt; deben ser id&amp;eacute;nticas en todas las r&amp;eacute;plicas.</target>
        </trans-unit>
        <trans-unit id="17b9b3019bf6883d5abf33ab706045e5053f610a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;allow_smaller_final_batch&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, a smaller batch value than &lt;code&gt;batch_size&lt;/code&gt; is returned when the queue is closed and there are not enough elements to fill the batch, otherwise the pending elements are discarded. In addition, all output tensors' static shapes, as accessed via the &lt;code&gt;shape&lt;/code&gt; property will have a first &lt;code&gt;Dimension&lt;/code&gt; value of &lt;code&gt;None&lt;/code&gt;, and operations that depend on fixed batch_size would fail.</source>
          <target state="translated">Si &lt;code&gt;allow_smaller_final_batch&lt;/code&gt; es &lt;code&gt;True&lt;/code&gt; , se devuelve un valor de lote menor que &lt;code&gt;batch_size&lt;/code&gt; cuando la cola est&amp;aacute; cerrada y no hay suficientes elementos para llenar el lote; de ​​lo contrario, los elementos pendientes se descartan. Adem&amp;aacute;s, todas las formas est&amp;aacute;ticas de los tensores de salida, a las que se acceda a trav&amp;eacute;s de la propiedad de &lt;code&gt;shape&lt;/code&gt; , tendr&amp;aacute;n un primer valor de &lt;code&gt;Dimension&lt;/code&gt; de &lt;code&gt;None&lt;/code&gt; , y las operaciones que dependan de un tama&amp;ntilde;o de lote fijo fallar&amp;iacute;an.</target>
        </trans-unit>
        <trans-unit id="7780a6b8fb5ede22db5a5df81a148367147b9033" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;alpha&lt;/code&gt; &amp;gt; 1.0, proportionally increases the number of filters in each layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a4fea5dc80e9ef14ab6ba19796973e718278379" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;alpha&lt;/code&gt; &amp;lt; 1.0, proportionally decreases the number of filters in each layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f53e0917886b19aa677a91e75faea069c634a903" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;alpha&lt;/code&gt; = 1, default number of filters from the paper are used at each layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd7fbda9d4e5df2aaf326a8208be66bf6fd7816b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;as_ref&lt;/code&gt; is true, the function must return a &lt;code&gt;Tensor&lt;/code&gt; reference, such as a &lt;code&gt;Variable&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;as_ref&lt;/code&gt; es verdadero, la funci&amp;oacute;n debe devolver una referencia de &lt;code&gt;Tensor&lt;/code&gt; , como una &lt;code&gt;Variable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebdc4f6453f07fa10351f671954a8d9cfc7adb0f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis == 0&lt;/code&gt; then the i'th tensor in &lt;code&gt;output&lt;/code&gt; is the slice &lt;code&gt;value[i, :, :, :]&lt;/code&gt; and each tensor in &lt;code&gt;output&lt;/code&gt; will have shape &lt;code&gt;(B, C, D)&lt;/code&gt;. (Note that the dimension unpacked along is gone, unlike &lt;code&gt;split&lt;/code&gt;).</source>
          <target state="translated">Si el &lt;code&gt;axis == 0&lt;/code&gt; entonces el i-&amp;eacute;simo tensor en la &lt;code&gt;output&lt;/code&gt; es el &lt;code&gt;value[i, :, :, :]&lt;/code&gt; corte [i,:,:,:] y cada tensor en la &lt;code&gt;output&lt;/code&gt; tendr&amp;aacute; forma &lt;code&gt;(B, C, D)&lt;/code&gt; . (Tenga en cuenta que la dimensi&amp;oacute;n descomprimida desapareci&amp;oacute;, a diferencia de la &lt;code&gt;split&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="88a0b065f0f00041a252be5ef4e010c2b3761be1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis == 1&lt;/code&gt; then the i'th tensor in &lt;code&gt;output&lt;/code&gt; is the slice &lt;code&gt;value[:, i, :, :]&lt;/code&gt; and each tensor in &lt;code&gt;output&lt;/code&gt; will have shape &lt;code&gt;(A, C, D)&lt;/code&gt;. Etc.</source>
          <target state="translated">Si el &lt;code&gt;axis == 1&lt;/code&gt; entonces el i-&amp;eacute;simo tensor en la &lt;code&gt;output&lt;/code&gt; es el &lt;code&gt;value[:, i, :, :]&lt;/code&gt; corte [:, i,:,:] y cada tensor en la &lt;code&gt;output&lt;/code&gt; tendr&amp;aacute; forma &lt;code&gt;(A, C, D)&lt;/code&gt; . Etc.</target>
        </trans-unit>
        <trans-unit id="82c15a867116f27864f6d455e86bfd0be8b87837" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; has no entries, all dimensions are reduced, and a tensor with a single element is returned.</source>
          <target state="translated">Si el &lt;code&gt;axis&lt;/code&gt; no tiene entradas, todas las dimensiones se reducen y se devuelve un tensor con un solo elemento.</target>
        </trans-unit>
        <trans-unit id="9a8ec21ac4d58f6a8479a92f2f74cef6e393ea5c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; has no entries, all dimensions are reduced, and a tensor with a single element is returned. Additionally, the axes can be negative, similar to the indexing rules in Python.</source>
          <target state="translated">Si el &lt;code&gt;axis&lt;/code&gt; no tiene entradas, todas las dimensiones se reducen y se devuelve un tensor con un solo elemento. Adem&amp;aacute;s, los ejes pueden ser negativos, similar a las reglas de indexaci&amp;oacute;n en Python.</target>
        </trans-unit>
        <trans-unit id="e616056a6e0ccb8800df513352231e77e4264ea6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; (the default), the input is considered a vector and a single vector norm is computed over the entire set of values in the tensor, i.e. &lt;code&gt;norm(tensor, ord=ord)&lt;/code&gt; is equivalent to &lt;code&gt;norm(reshape(tensor, [-1]), ord=ord)&lt;/code&gt;. If &lt;code&gt;axis&lt;/code&gt; is a Python integer, the input is considered a batch of vectors, and &lt;code&gt;axis&lt;/code&gt; determines the axis in &lt;code&gt;tensor&lt;/code&gt; over which to compute vector norms. If &lt;code&gt;axis&lt;/code&gt; is a 2-tuple of Python integers it is considered a batch of matrices and &lt;code&gt;axis&lt;/code&gt; determines the axes in &lt;code&gt;tensor&lt;/code&gt; over which to compute a matrix norm. Negative indices are supported. Example: If you are passing a tensor that can be either a matrix or a batch of matrices at runtime, pass &lt;code&gt;axis=[-2,-1]&lt;/code&gt; instead of &lt;code&gt;axis=None&lt;/code&gt; to make sure that matrix norms are computed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c3c0b53459dfc2bb4beb0a0adb6072980b26e14" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is None, all dimensions are reduced, and a tensor with a single element is returned.</source>
          <target state="translated">Si el &lt;code&gt;axis&lt;/code&gt; es Ninguno, todas las dimensiones se reducen y se devuelve un tensor con un solo elemento.</target>
        </trans-unit>
        <trans-unit id="ac361bdaf1da22febee0c7b1b9dcb906feac6283" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is not specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a8f7fa2efde73fc9bf0b0a2fab7a317d0c8657d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is out of bounds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ab6e2ed9ca8b4fd5956248951445d47d21eba68" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is out of range &lt;code&gt;[-(D+1), D]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40347027eb7341be1932ae7ecf56cb946b07b101" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is out of the range [-(R+1), R+1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6786f976b5b7018002f788d4d5b77f161184adfa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is out of the range [-R, R).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4602049d19408d9325e5ff8f12f74035055b93a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;backward_layer&lt;/code&gt; has mismatched properties compared to &lt;code&gt;layer&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;backward_layer&lt;/code&gt; tiene propiedades que no coinciden en comparaci&amp;oacute;n con la &lt;code&gt;layer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1210be14982a956118b83d39f36a2c3bc225338" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;batch_shape&lt;/code&gt; initialization arg is &lt;code&gt;None&lt;/code&gt;:</source>
          <target state="translated">Si la inicializaci&amp;oacute;n de &lt;code&gt;batch_shape&lt;/code&gt; arg es &lt;code&gt;None&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0b34f5f9c6902112fe4d7b168dfca4894759e293" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;batch_shape&lt;/code&gt; initialization arg is provided, and static checks cannot rule out the need to broadcast:</source>
          <target state="translated">Si se proporciona un &lt;code&gt;batch_shape&lt;/code&gt; inicializaci&amp;oacute;n de batch_shape , y las comprobaciones est&amp;aacute;ticas no pueden descartar la necesidad de transmitir:</target>
        </trans-unit>
        <trans-unit id="40f813420f57b9339e0284fe5e7d670f07e9a1e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;batch_shape&lt;/code&gt; is determined statically to not be 1-D, or negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="750b252479a4a7304dd25d5ac4c741266f546400" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;boundaries&lt;/code&gt; is not a sorted list or tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f327c86c6539bbf453fac30f2d63b53e09b0f775" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;branch_fns&lt;/code&gt; is a list but does not contain 2-tuples or callables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea26f65ae79b93de117abe34d6db208470fe3a9b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;branch_fns&lt;/code&gt; is not a list/dictionary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e0014fe3e6f4ed6ff2b3d6fdd0d4f70bafb4a1a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;by_name&lt;/code&gt; is False weights are loaded based on the network's topology. This means the architecture should be the same as when the weights were saved. Note that layers that don't have weights are not taken into account in the topological ordering, so adding or removing layers is fine as long as they don't have weights.</source>
          <target state="translated">Si &lt;code&gt;by_name&lt;/code&gt; es False, los pesos se cargan seg&amp;uacute;n la topolog&amp;iacute;a de la red. Esto significa que la arquitectura debe ser la misma que cuando se guardaron los pesos. Tenga en cuenta que las capas que no tienen pesos no se tienen en cuenta en el orden topol&amp;oacute;gico, por lo que agregar o eliminar capas est&amp;aacute; bien siempre que no tengan pesos.</target>
        </trans-unit>
        <trans-unit id="15a8bafdca0abb98187bac49dd0616a9d631c410" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;by_name&lt;/code&gt; is True, weights are loaded into layers only if they share the same name. This is useful for fine-tuning or transfer-learning models where some of the layers have changed.</source>
          <target state="translated">Si &lt;code&gt;by_name&lt;/code&gt; es True, los pesos se cargan en capas solo si comparten el mismo nombre. Esto es &amp;uacute;til para modelos de ajuste fino o aprendizaje por transferencia donde algunas de las capas han cambiado.</target>
        </trans-unit>
        <trans-unit id="845594347374dd00bfd7e659fdc63e7e3d5b4f06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bytes_or_text&lt;/code&gt; is not a binary or unicode string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eec2900c2fb0f0251b678a361ecad074ba0af19" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cancel_pending_enqueues&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, all pending requests will also be canceled.</source>
          <target state="translated">Si &lt;code&gt;cancel_pending_enqueues&lt;/code&gt; es &lt;code&gt;True&lt;/code&gt; , todas las solicitudes pendientes tambi&amp;eacute;n se cancelar&amp;aacute;n.</target>
        </trans-unit>
        <trans-unit id="0da424a258741377ad7f1b3412ace95e1b7e087b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;categorical_column&lt;/code&gt; is not CategoricalColumn type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cb637aa705c546a113e41afd5c758c47dd8f823" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cell&lt;/code&gt; is not an instance of RNNCell, or &lt;code&gt;loop_fn&lt;/code&gt; is not a &lt;code&gt;callable&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d8fa2cfd25e1b41a79e7e3b6b4253739977bfe6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cell&lt;/code&gt; is not an instance of RNNCell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c005314f14b9be4b12102c1d51d0d8b497fafda" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cell_fw&lt;/code&gt; or &lt;code&gt;cell_bw&lt;/code&gt; is not an instance of &lt;code&gt;RNNCell&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d24f152ba9fe436f35ebbbc28f22afb95d7ac755" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ckpt_dir_or_file&lt;/code&gt; resolves to a directory with multiple checkpoints, reader for the latest checkpoint is returned.</source>
          <target state="translated">Si &lt;code&gt;ckpt_dir_or_file&lt;/code&gt; se resuelve en un directorio con varios puntos de control, se devuelve el lector del &amp;uacute;ltimo punto de control.</target>
        </trans-unit>
        <trans-unit id="d2998b18d77ff28c7539e06d755706c8cf0700ef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ckpt_dir_or_file&lt;/code&gt; resolves to a directory with no checkpoints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20bd49990b5cf72ae3b08662dd38487aaacb7b14" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;class_id&lt;/code&gt; is specified, we calculate precision by considering only the entries in the batch for which &lt;code&gt;class_id&lt;/code&gt; is above the threshold and/or in the top-k highest predictions, and computing the fraction of them for which &lt;code&gt;class_id&lt;/code&gt; is indeed a correct label.</source>
          <target state="translated">Si se especifica &lt;code&gt;class_id&lt;/code&gt; , calculamos la precisi&amp;oacute;n considerando solo las entradas en el lote para las que &lt;code&gt;class_id&lt;/code&gt; est&amp;aacute; por encima del umbral y / o en las predicciones m&amp;aacute;s altas de los k top, y calculamos la fracci&amp;oacute;n de ellas para la cual &lt;code&gt;class_id&lt;/code&gt; es de hecho una etiqueta correcta.</target>
        </trans-unit>
        <trans-unit id="594da24c877b56fce6dcc330d36e921550f67631" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;class_id&lt;/code&gt; is specified, we calculate precision by considering only the entries in the batch for which &lt;code&gt;class_id&lt;/code&gt; is in the top-k highest &lt;code&gt;predictions&lt;/code&gt;, and computing the fraction of them for which &lt;code&gt;class_id&lt;/code&gt; is indeed a correct label. If &lt;code&gt;class_id&lt;/code&gt; is not specified, we'll calculate precision as how often on average a class among the top-k classes with the highest predicted values of a batch entry is correct and can be found in the label for that entry.</source>
          <target state="translated">Si se especifica &lt;code&gt;class_id&lt;/code&gt; , calculamos la precisi&amp;oacute;n considerando solo las entradas en el lote para las que &lt;code&gt;class_id&lt;/code&gt; est&amp;aacute; en las primeras k &lt;code&gt;predictions&lt;/code&gt; m&amp;aacute;s altas , y calculando la fracci&amp;oacute;n de ellas para las que &lt;code&gt;class_id&lt;/code&gt; es de hecho una etiqueta correcta. Si no se especifica &lt;code&gt;class_id&lt;/code&gt; , calcularemos la precisi&amp;oacute;n como la frecuencia promedio con la que una clase entre las clases top-k con los valores pronosticados m&amp;aacute;s altos de una entrada de lote es correcta y se puede encontrar en la etiqueta de esa entrada.</target>
        </trans-unit>
        <trans-unit id="a2fed35668157bd216f9480f06ebfb465420b146" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;class_id&lt;/code&gt; is specified, we calculate recall by considering only the entries in the batch for which &lt;code&gt;class_id&lt;/code&gt; is in the label, and computing the fraction of them for which &lt;code&gt;class_id&lt;/code&gt; is above the threshold and/or in the top-k predictions.</source>
          <target state="translated">Si se especifica &lt;code&gt;class_id&lt;/code&gt; , calculamos la recuperaci&amp;oacute;n considerando solo las entradas en el lote para las que &lt;code&gt;class_id&lt;/code&gt; est&amp;aacute; en la etiqueta y calculando la fracci&amp;oacute;n de ellas para la cual &lt;code&gt;class_id&lt;/code&gt; est&amp;aacute; por encima del umbral y / o en las predicciones top-k.</target>
        </trans-unit>
        <trans-unit id="0598665208e329d2285f13959a4c8a0be2108783" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;class_id&lt;/code&gt; is specified, we calculate recall by considering only the entries in the batch for which &lt;code&gt;class_id&lt;/code&gt; is in the label, and computing the fraction of them for which &lt;code&gt;class_id&lt;/code&gt; is in the top-k &lt;code&gt;predictions&lt;/code&gt;. If &lt;code&gt;class_id&lt;/code&gt; is not specified, we'll calculate recall as how often on average a class among the labels of a batch entry is in the top-k &lt;code&gt;predictions&lt;/code&gt;.</source>
          <target state="translated">Si se especifica &lt;code&gt;class_id&lt;/code&gt; , calculamos la recuperaci&amp;oacute;n considerando solo las entradas en el lote para las que &lt;code&gt;class_id&lt;/code&gt; est&amp;aacute; en la etiqueta y calculando la fracci&amp;oacute;n de ellas para las que &lt;code&gt;class_id&lt;/code&gt; est&amp;aacute; en las &lt;code&gt;predictions&lt;/code&gt; top-k . Si no se especifica &lt;code&gt;class_id&lt;/code&gt; , calcularemos la recuperaci&amp;oacute;n como la frecuencia promedio con la que una clase entre las etiquetas de una entrada de lote se encuentra en las &lt;code&gt;predictions&lt;/code&gt; top-k .</target>
        </trans-unit>
        <trans-unit id="8ed0b9e3e88d8fb4c9485f67ff031b4dbc5fc2f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;clip_norm &amp;gt; global_norm&lt;/code&gt; then the entries in &lt;code&gt;t_list&lt;/code&gt; remain as they are, otherwise they're all shrunk by the global ratio.</source>
          <target state="translated">Si &lt;code&gt;clip_norm &amp;gt; global_norm&lt;/code&gt; , las entradas en &lt;code&gt;t_list&lt;/code&gt; permanecen como est&amp;aacute;n; de lo contrario, todas se reducen seg&amp;uacute;n la proporci&amp;oacute;n global.</target>
        </trans-unit>
        <trans-unit id="7e9530f81d1e38f5cf65209f508156d9b6769612" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cluster&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, and &lt;code&gt;ps_tasks&lt;/code&gt; is 0, the returned function is a no-op. Otherwise, the value of &lt;code&gt;ps_tasks&lt;/code&gt; is derived from &lt;code&gt;cluster&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;cluster&lt;/code&gt; es &lt;code&gt;None&lt;/code&gt; y &lt;code&gt;ps_tasks&lt;/code&gt; es 0, la funci&amp;oacute;n devuelta es no operativa. De lo contrario, el valor de &lt;code&gt;ps_tasks&lt;/code&gt; se deriva de &lt;code&gt;cluster&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6d7bf46850010a12ccc4b12b47b4fc474e27898" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cluster&lt;/code&gt; is not a dictionary mapping strings to lists of strings, and not a &lt;a href=&quot;clusterdef&quot;&gt;&lt;code&gt;tf.train.ClusterDef&lt;/code&gt;&lt;/a&gt; protobuf.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39cf1c8eecb1ef7b4ac070aaa23d0ecfa7f82a3b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;combiner&lt;/code&gt; is not one of {&quot;mean&quot;, &quot;sqrtn&quot;, &quot;sum&quot;}.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="065bbd8103d747b51b68745d23b95f48f33acad0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;condition&lt;/code&gt; evaluates to false, print the list of tensors in &lt;code&gt;data&lt;/code&gt;. &lt;code&gt;summarize&lt;/code&gt; determines how many entries of the tensors to print.</source>
          <target state="translated">Si la &lt;code&gt;condition&lt;/code&gt; eval&amp;uacute;a como falsa, imprima la lista de tensores en los &lt;code&gt;data&lt;/code&gt; . &lt;code&gt;summarize&lt;/code&gt; determina cu&amp;aacute;ntas entradas de los tensores imprimir.</target>
        </trans-unit>
        <trans-unit id="dc7c3e5a0b26f7d25559f77e68ccbfaa5c98f33a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;condition&lt;/code&gt; is a vector and &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are higher rank matrices, then it chooses which row (outer dimension) to copy from &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. If &lt;code&gt;condition&lt;/code&gt; has the same shape as &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, then it chooses which element to copy from &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;condition&lt;/code&gt; es un vector y &lt;code&gt;x&lt;/code&gt; y &lt;code&gt;y&lt;/code&gt; son mayores matrices de rango, entonces se elige qu&amp;eacute; fila (dimensi&amp;oacute;n externa) para copiar de &lt;code&gt;x&lt;/code&gt; y &lt;code&gt;y&lt;/code&gt; . Si la &lt;code&gt;condition&lt;/code&gt; tiene la misma forma que &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; , entonces elige qu&amp;eacute; elemento copiar de &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="852f5ef307e7bc28b2850a54f24a33882b85de2d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;control_inputs&lt;/code&gt; is not a list of &lt;code&gt;Operation&lt;/code&gt; or &lt;code&gt;Tensor&lt;/code&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc07b7d3b7d37ada7c331d72e2d06fb75d39fe59" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;core_assignment&lt;/code&gt; is not a rank 3 numpy array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85cf61e910d69324c4a7ef790c66d6a2dfd03048" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ctc_merge_repeated&lt;/code&gt; is set False, then deep within the CTC calculation, repeated non-blank labels will not be merged and are interpreted as individual labels. This is a simplified (non-standard) version of CTC.</source>
          <target state="translated">Si &lt;code&gt;ctc_merge_repeated&lt;/code&gt; se establece en False, en el fondo del c&amp;aacute;lculo de CTC, las etiquetas repetidas que no est&amp;eacute;n en blanco no se fusionar&amp;aacute;n y se interpretar&amp;aacute;n como etiquetas individuales. &amp;Eacute;sta es una versi&amp;oacute;n simplificada (no est&amp;aacute;ndar) de CTC.</target>
        </trans-unit>
        <trans-unit id="47f2aad48c2d0f196f9ea6e64ee4554117907144" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cycle&lt;/code&gt; is True then a multiple of &lt;code&gt;decay_steps&lt;/code&gt; is used, the first one that is bigger than &lt;code&gt;global_steps&lt;/code&gt;.</source>
          <target state="translated">Si el &lt;code&gt;cycle&lt;/code&gt; es Verdadero, entonces se usa un m&amp;uacute;ltiplo de &lt;code&gt;decay_steps&lt;/code&gt; , el primero que es mayor que &lt;code&gt;global_steps&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e96124e7a04b42a83269b91d81e7e32583e381c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cycle&lt;/code&gt; is True then a multiple of &lt;code&gt;decay_steps&lt;/code&gt; is used, the first one that is bigger than &lt;code&gt;step&lt;/code&gt;.</source>
          <target state="translated">Si el &lt;code&gt;cycle&lt;/code&gt; es Verdadero, entonces se usa un m&amp;uacute;ltiplo de &lt;code&gt;decay_steps&lt;/code&gt; , el primero que es mayor que &lt;code&gt;step&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed08d044f4ced3eb43b5b5b9c435daedbc9bccbf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;: &lt;code&gt;(batch, channels, cropped_rows, cropped_cols)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;data_format&lt;/code&gt; es &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt; : &lt;code&gt;(batch, channels, cropped_rows, cropped_cols)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c5b04849f3239ff7f2aed6311abff3cbd6b35af1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;: &lt;code&gt;(batch, channels, dim1, dim2, dim3)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;data_format&lt;/code&gt; es &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt; : &lt;code&gt;(batch, channels, dim1, dim2, dim3)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f34c9b34734b9df20fbf8e979f546c9c4cc5baf4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;: &lt;code&gt;(batch, channels, padded_rows, padded_cols)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;data_format&lt;/code&gt; es &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt; : &lt;code&gt;(batch, channels, padded_rows, padded_cols)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="18824f32ee3435a0aaf0ab5c308c42f192295a0b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;: &lt;code&gt;(batch, channels, rows, cols)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;data_format&lt;/code&gt; es &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt; : &lt;code&gt;(batch, channels, rows, cols)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d97ca997b91aa66ba4112051e89b9fd1d11e0319" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;: &lt;code&gt;(batch, channels, upsampled_dim1, upsampled_dim2, upsampled_dim3)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;data_format&lt;/code&gt; es &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt; : &lt;code&gt;(batch, channels, upsampled_dim1, upsampled_dim2, upsampled_dim3)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e6ed1bb95109cbf4e1521d123414f77ee773a64c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;: &lt;code&gt;(batch, channels, upsampled_rows, upsampled_cols)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;data_format&lt;/code&gt; es &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt; : &lt;code&gt;(batch, channels, upsampled_rows, upsampled_cols)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4b398a294c2ee1defa640c1a2420cb9d283d80b8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;: &lt;code&gt;(batch, depth, first_axis_to_crop, second_axis_to_crop, third_axis_to_crop)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;data_format&lt;/code&gt; es &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt; : &lt;code&gt;(batch, depth, first_axis_to_crop, second_axis_to_crop, third_axis_to_crop)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cfcc85522ec5786f0f0111cb911348fd3d60aa41" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;: &lt;code&gt;(batch, depth, first_axis_to_pad, second_axis_to_pad, third_axis_to_pad)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;data_format&lt;/code&gt; es &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt; : &lt;code&gt;(batch, depth, first_axis_to_pad, second_axis_to_pad, third_axis_to_pad)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5b26f95b56877033c8096f8c21ee90b92dfad7a9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;: &lt;code&gt;(batch, depth, first_cropped_axis, second_cropped_axis, third_cropped_axis)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;data_format&lt;/code&gt; es &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt; : &lt;code&gt;(batch, depth, first_cropped_axis, second_cropped_axis, third_cropped_axis)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="40a4fb20ae2e104be54b9c38059d00d6af133ad2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;: &lt;code&gt;(batch, depth, first_padded_axis, second_padded_axis, third_axis_to_pad)&lt;/code&gt;</source>
          <target state="translated">Si el &lt;code&gt;data_format&lt;/code&gt; es &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt; : &lt;code&gt;(batch, depth, first_padded_axis, second_padded_axis, third_axis_to_pad)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="13dbf77e04457c4f4f2d2b1bf44035da08c15b02" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;: &lt;code&gt;(batch_size, channels, cropped_rows, cropped_cols)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16c3b7ad97b58254a0f880dcb00666665f89ea7c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;: &lt;code&gt;(batch_size, channels, dim1, dim2, dim3)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fb7c8889c720e09fcfeff626a329d774fcc3a0b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;: &lt;code&gt;(batch_size, channels, padded_rows, padded_cols)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e50baf564ca14e56683795ce398dfeea230ae434" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;: &lt;code&gt;(batch_size, channels, rows, cols)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9212d130a38e7aa9a9cc4c3069720d3b8a25dbdf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;: &lt;code&gt;(batch_size, channels, upsampled_dim1, upsampled_dim2, upsampled_dim3)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c965d4cefe52be58f4541312fd3e5d23c6fe18f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;: &lt;code&gt;(batch_size, channels, upsampled_rows, upsampled_cols)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e386532c5fd8c2d8fa779b964ec07b7f0be40ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;: &lt;code&gt;(batch_size, depth, first_axis_to_crop, second_axis_to_crop, third_axis_to_crop)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba4f67f214014ed4451c10d24c0e147e61468aaf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data_format&lt;/code&gt; is &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;: &lt;code&gt;(batch_size, depth, first_axis_to_pad, second_axis_to_pad, third_axis_to_pad)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
