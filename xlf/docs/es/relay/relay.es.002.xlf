<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="relay">
    <body>
      <group id="relay">
        <trans-unit id="330b3e499c3450d42634b5702213e434b7a82a41" translate="yes" xml:space="preserve">
          <source>Routes are responsible for defining the entry points into a Relay application. But in order to understand why routes are necessary, we must first understand the difference between GraphQL queries and fragments.</source>
          <target state="translated">Las rutas son responsables de definir los puntos de entrada en una aplicación de retransmisión.Pero para entender por qué las rutas son necesarias,primero debemos entender la diferencia entre las consultas de GraphQL y los fragmentos.</target>
        </trans-unit>
        <trans-unit id="ae0f139d125aa65c3494e803bdab2bfc2845048a" translate="yes" xml:space="preserve">
          <source>Routes can declare a set of parameter names that are required to be supplied to the constructor. This is also a convenient place to document the set of valid parameters.</source>
          <target state="translated">Las rutas pueden declarar un conjunto de nombres de parámetros que deben ser suministrados al constructor.Este es también un lugar conveniente para documentar el conjunto de parámetros válidos.</target>
        </trans-unit>
        <trans-unit id="e5ec9f7b8ea16c97f062b9386937889c5390bd89" translate="yes" xml:space="preserve">
          <source>Routes can use &lt;code&gt;prepareParams&lt;/code&gt; to provide default parameters, or pass through, convert or suppress passed-in parameters.</source>
          <target state="translated">Las rutas pueden usar &lt;code&gt;prepareParams&lt;/code&gt; para proporcionar par&amp;aacute;metros predeterminados, o pasar, convertir o suprimir par&amp;aacute;metros pasados.</target>
        </trans-unit>
        <trans-unit id="a04e20b09d66a6ec94b9fd8e8520062229d58d02" translate="yes" xml:space="preserve">
          <source>Routes must declare a set of query roots using &lt;code&gt;Relay.QL&lt;/code&gt;. These queries will automatically compose a matching fragment named &lt;code&gt;queryName&lt;/code&gt; on the Relay container used with this route on a &lt;strong&gt;Relay.RootContainer&lt;/strong&gt;.</source>
          <target state="translated">Las rutas deben declarar un conjunto de ra&amp;iacute;ces de consulta mediante &lt;code&gt;Relay.QL&lt;/code&gt; . Estas consultas compondr&amp;aacute;n autom&amp;aacute;ticamente un fragmento coincidente llamado &lt;code&gt;queryName&lt;/code&gt; en el contenedor Relay usado con esta ruta en un &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="fd81fc06977ad2c7156abd14b5b9caa0f8c40fc2" translate="yes" xml:space="preserve">
          <source>Routes must define a string name.</source>
          <target state="translated">Las rutas deben definir un nombre de cadena.</target>
        </trans-unit>
        <trans-unit id="380338bdec53655cfe9114fa55d7fe1d8bdbb27d" translate="yes" xml:space="preserve">
          <source>Routes no longer need to know anything about the query root in Relay Modern. Relay components can be rendered anywhere wrapped in a &lt;code&gt;QueryRenderer&lt;/code&gt;. This should bring more flexibility around picking routing frameworks.</source>
          <target state="translated">Las rutas ya no necesitan saber nada sobre la ra&amp;iacute;z de la consulta en Relay Modern. Los componentes de retransmisi&amp;oacute;n se pueden representar en cualquier lugar envueltos en un &lt;code&gt;QueryRenderer&lt;/code&gt; . Esto deber&amp;iacute;a aportar m&amp;aacute;s flexibilidad a la hora de elegir marcos de enrutamiento.</target>
        </trans-unit>
        <trans-unit id="7d15dd1bec2e055c5b177c9f869305ae6c54c9bb" translate="yes" xml:space="preserve">
          <source>Routing</source>
          <target state="translated">Routing</target>
        </trans-unit>
        <trans-unit id="15f12d3d79029156026af15a57e839303e093597" translate="yes" xml:space="preserve">
          <source>Run the Relay Compiler after making changes to any GraphQL in your Relay application. It may be helpful to add it as a &lt;code&gt;yarn script&lt;/code&gt;. Add an entry to &lt;code&gt;&quot;scripts&quot;&lt;/code&gt; in your package.json file.</source>
          <target state="translated">Ejecute el Relay Compiler despu&amp;eacute;s de realizar cambios en cualquier GraphQL en su aplicaci&amp;oacute;n Relay. Puede ser &amp;uacute;til agregarlo como un &lt;code&gt;yarn script&lt;/code&gt; . Agregue una entrada a &lt;code&gt;&quot;scripts&quot;&lt;/code&gt; en su archivo package.json.</target>
        </trans-unit>
        <trans-unit id="3c5a064ba8a60e5ab65def399ab519978d73b564" translate="yes" xml:space="preserve">
          <source>Runtime Architecture</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5230ecdf4e78f0dd162281a0a78c6cdc853cbe8" translate="yes" xml:space="preserve">
          <source>Schema</source>
          <target state="translated">Schema</target>
        </trans-unit>
        <trans-unit id="1f0e625b220c0a58aba2033abe91bfe01285293e" translate="yes" xml:space="preserve">
          <source>Schema JSON</source>
          <target state="translated">Esquema JSON</target>
        </trans-unit>
        <trans-unit id="114b03b7a51c1001385ac516c6fa621d46453f66" translate="yes" xml:space="preserve">
          <source>Second, any subscriptions that do have overlapping data IDs are re-read, and the new/previous results are compared. If the result has not changed, the subscription is ignored (this can occur if a field of a record changed that is not relevant to the subscription's selector), otherwise processing continues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e32d234cf8a398d348341552d4472b71aa02309" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;interfaces-relay-mutation-request&quot;&gt;RelayMutationRequest&lt;/a&gt; for methods available on the argument object.</source>
          <target state="translated">Consulte &lt;a href=&quot;interfaces-relay-mutation-request&quot;&gt;RelayMutationRequest&lt;/a&gt; para conocer los m&amp;eacute;todos disponibles en el objeto de argumento.</target>
        </trans-unit>
        <trans-unit id="ba186dff4700bd97150240f3ab29c29fbc1b7fc5" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;interfaces-relay-query-request&quot;&gt;RelayQueryRequest&lt;/a&gt; for methods available on the argument objects.</source>
          <target state="translated">Consulte &lt;a href=&quot;interfaces-relay-query-request&quot;&gt;RelayQueryRequest&lt;/a&gt; para conocer los m&amp;eacute;todos disponibles en los objetos de argumento.</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">Ver también</target>
        </trans-unit>
        <trans-unit id="0ebcd737a1bf60dbd1447977c888467e35a467a0" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#constructor&quot;&gt;GraphQLMutation &amp;gt; Constructor&lt;/a&gt;</source>
          <target state="translated">Vea tambi&amp;eacute;n: &lt;a href=&quot;#constructor&quot;&gt;GraphQLMutation&amp;gt; Constructor&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eb08c52e72850acd0139ed4cb2152c144c9e58eb" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#getconfigs-abstract-method&quot;&gt;Relay.Mutation::getConfigs()&lt;/a&gt;</source>
          <target state="translated">Ver tambi&amp;eacute;n: &lt;a href=&quot;#getconfigs-abstract-method&quot;&gt;Relay.Mutation :: getConfigs ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="51b02cf1878520658c9b88fe67978bf776e01dd9" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;api-reference-relay-mutation#getcollisionkey&quot;&gt;Relay.Mutation::getCollisionKey()&lt;/a&gt;</source>
          <target state="translated">Ver tambi&amp;eacute;n: &lt;a href=&quot;api-reference-relay-mutation#getcollisionkey&quot;&gt;Relay.Mutation :: getCollisionKey ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8665daeb214113b0a6222a07deb324960005a817" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;api-reference-relay-mutation#getconfigs-abstract-method&quot;&gt;Relay.Mutation::getConfigs()&lt;/a&gt;</source>
          <target state="translated">Ver tambi&amp;eacute;n: &lt;a href=&quot;api-reference-relay-mutation#getconfigs-abstract-method&quot;&gt;Relay.Mutation :: getConfigs ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9701bc69d708978bae12176bd6d6b49b6310b158" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-containers#relay-containers&quot;&gt;Containers &amp;gt; Relay Containers&lt;/a&gt;</source>
          <target state="translated">Ver tambi&amp;eacute;n: &lt;a href=&quot;guides-containers#relay-containers&quot;&gt;Contenedores&amp;gt; Contenedores de rel&amp;eacute;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f63708739a0519c20cb04d22aed0623da8910a3b" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-containers#requesting-different-data&quot;&gt;Containers &amp;gt; Requesting Different Data&lt;/a&gt;, &lt;a href=&quot;guides-ready-state&quot;&gt;Ready State&lt;/a&gt;</source>
          <target state="translated">Consulte tambi&amp;eacute;n: &lt;a href=&quot;guides-containers#requesting-different-data&quot;&gt;Contenedores&amp;gt; Solicitud de datos diferentes&lt;/a&gt; , &lt;a href=&quot;guides-ready-state&quot;&gt;estado listo&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fb81a25d0442cce928322c7171025b8b9f41ba2d" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#fragment-variables&quot;&gt;Mutations &amp;gt; Fragment variables&lt;/a&gt;</source>
          <target state="translated">Ver tambi&amp;eacute;n: &lt;a href=&quot;guides-mutations#fragment-variables&quot;&gt;Mutaciones&amp;gt; Variables de fragmentos&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="252cc9e75017b1ba4bc6a1cab81814c7c5e7b9c1" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#fragment-variables&quot;&gt;Mutations &amp;gt; Fragment variables&lt;/a&gt; and &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;Mutations &amp;gt; Optimistic updates&lt;/a&gt;</source>
          <target state="translated">Ver tambi&amp;eacute;n: &lt;a href=&quot;guides-mutations#fragment-variables&quot;&gt;Mutaciones&amp;gt; Variables de fragmentos&lt;/a&gt; y &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;mutaciones&amp;gt; Actualizaciones optimistas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c325d76133ada9407e339b00806d08a492686a72" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#mutator-configuration&quot;&gt;Mutations &amp;gt; Mutator configuration&lt;/a&gt;</source>
          <target state="translated">Ver tambi&amp;eacute;n: &lt;a href=&quot;guides-mutations#mutator-configuration&quot;&gt;Mutaciones&amp;gt; Configuraci&amp;oacute;n del mutador&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec1a4ead3e670cf9b7225817b2d5536e60b9dfc8" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;Mutations &amp;gt; Optimistic Updates&lt;/a&gt;</source>
          <target state="translated">Ver tambi&amp;eacute;n: &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;Mutaciones&amp;gt; Actualizaciones optimistas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f91e5359d2e437a1fabed213a7400919e36a4e8f" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;Mutations &amp;gt; Optimistic updates&lt;/a&gt;</source>
          <target state="translated">Ver tambi&amp;eacute;n: &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;Mutaciones&amp;gt; Actualizaciones optimistas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6a14ec07edd61e594362c3ba2c69cd02521e8cd7" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#the-fat-query&quot;&gt;Mutations &amp;gt; The fat query&lt;/a&gt;</source>
          <target state="translated">Ver tambi&amp;eacute;n: &lt;a href=&quot;guides-mutations#the-fat-query&quot;&gt;Mutaciones&amp;gt; La consulta de grasa&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3c9e106abf2efb7313ca2aef582895208bb3b4a9" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-ready-state&quot;&gt;Ready State&lt;/a&gt;</source>
          <target state="translated">Ver tambi&amp;eacute;n: &lt;a href=&quot;guides-ready-state&quot;&gt;Estado listo&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3d33a51e631c54521d230f0b77c33a0ffcb95a9e" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#component-and-route&quot;&gt;Root Container &amp;gt; Component and Route&lt;/a&gt;</source>
          <target state="translated">Consulte tambi&amp;eacute;n: &lt;a href=&quot;guides-root-container#component-and-route&quot;&gt;Contenedor ra&amp;iacute;z&amp;gt; Componente y ruta&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6ba9c7676225015beb8fcd0dc8154429cc521b19" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#force-fetching&quot;&gt;Root Container &amp;gt; Force Fetching&lt;/a&gt;</source>
          <target state="translated">V&amp;eacute;ase tambi&amp;eacute;n: &lt;a href=&quot;guides-root-container#force-fetching&quot;&gt;Contenedor ra&amp;iacute;z&amp;gt; Obtenci&amp;oacute;n forzada&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2d475a6214b773e645b11e09318c20c3c31900a2" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#renderfailure&quot;&gt;Root Container &amp;gt; renderFailure&lt;/a&gt;</source>
          <target state="translated">V&amp;eacute;ase tambi&amp;eacute;n: &lt;a href=&quot;guides-root-container#renderfailure&quot;&gt;Contenedor ra&amp;iacute;z&amp;gt; renderFailure&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="592bf7ec077fdbfb9bb08cfe9e7520a4dc086e1c" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#renderfetched&quot;&gt;Root Container &amp;gt; renderFetched&lt;/a&gt;</source>
          <target state="translated">V&amp;eacute;ase tambi&amp;eacute;n: &lt;a href=&quot;guides-root-container#renderfetched&quot;&gt;Contenedor ra&amp;iacute;z&amp;gt; renderFetched&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6a187f3307739f3f97bdae9d053fcff505ffdeb1" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#renderloading&quot;&gt;Root Container &amp;gt; renderLoading&lt;/a&gt;</source>
          <target state="translated">V&amp;eacute;ase tambi&amp;eacute;n: &lt;a href=&quot;guides-root-container#renderloading&quot;&gt;Contenedor ra&amp;iacute;z&amp;gt; renderLoading&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2fcf798559587d9befe424605fcb71c2af445685" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-routes&quot;&gt;Routes&lt;/a&gt;</source>
          <target state="translated">Ver tambi&amp;eacute;n: &lt;a href=&quot;guides-routes&quot;&gt;Rutas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2ebcb2b8f4a703f0b6653cd4eb5e389d3a9e4f41" translate="yes" xml:space="preserve">
          <source>See our relay-compiler section in our &lt;a href=&quot;installation-and-setup#set-up-relay-compiler&quot;&gt;Installation and Setup guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac40c2c295e0947fa5d231ce927c5f063044cb9e" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;api-reference-relay-proptypes&quot;&gt;PropTypes API reference&lt;/a&gt;.</source>
          <target state="translated">Consulte la &lt;a href=&quot;api-reference-relay-proptypes&quot;&gt;referencia de la API de PropTypes&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="db3136f0089c09e6cfa1ecac38be1bb1698a01e9" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;api-reference-relay-ql&quot;&gt;Relay.QL API reference&lt;/a&gt;.</source>
          <target state="translated">Consulte la &lt;a href=&quot;api-reference-relay-ql&quot;&gt;referencia de la API de Relay.QL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="46ebdef898489cac49931005986e50860c184084" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;api-reference-relay-store&quot;&gt;Store API reference&lt;/a&gt;.</source>
          <target state="translated">Consulta la &lt;a href=&quot;api-reference-relay-store&quot;&gt;referencia de la API de&lt;/a&gt; la tienda .</target>
        </trans-unit>
        <trans-unit id="5e868bde5bb210d570e0bf68dfd4f714decc2503" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;fragment-container#passing-arguments-to-a-fragment&quot;&gt;Fragment Container docs&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4011d8e185ce992ad373c12339d3c386a366a9d9" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;guides-mutations&quot;&gt;Mutations Guide&lt;/a&gt;.</source>
          <target state="translated">Consulte la &lt;a href=&quot;guides-mutations&quot;&gt;Gu&amp;iacute;a de mutaciones&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="85e710dc6095fa7ec6992d17389697e3d05b22af" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;guides-network-layer&quot;&gt;Network Layer Guide&lt;/a&gt;.</source>
          <target state="translated">Consulte la &lt;a href=&quot;guides-network-layer&quot;&gt;Gu&amp;iacute;a de capa de red&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f586115c09169458b9424f28db540ede9b2d7ddf" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;guides-root-container&quot;&gt;RootContainer Guide&lt;/a&gt;.</source>
          <target state="translated">Consulte la &lt;a href=&quot;guides-root-container&quot;&gt;Gu&amp;iacute;a de RootContainer&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c7e49836605664cff515afd9b044294d9e1deeee" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;guides-routes&quot;&gt;Routes Guide&lt;/a&gt;.</source>
          <target state="translated">Consulte la &lt;a href=&quot;guides-routes&quot;&gt;Gu&amp;iacute;a de rutas&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="076a9d109c3f1a2389e316e443efa40d8f78df54" translate="yes" xml:space="preserve">
          <source>Server Error</source>
          <target state="translated">Error del servidor</target>
        </trans-unit>
        <trans-unit id="6b17482f3f882455ee584aa25321c5bdac980242" translate="yes" xml:space="preserve">
          <source>Set up babel-plugin-relay</source>
          <target state="translated">Establecer el relé de babel-plugin</target>
        </trans-unit>
        <trans-unit id="8a05cf798da4421d2bd58da023c7f3fb287cd45f" translate="yes" xml:space="preserve">
          <source>Set up relay-compiler</source>
          <target state="translated">Configurar el retransmisor-compilador</target>
        </trans-unit>
        <trans-unit id="f72f8a571d6e8bf5eec6f1a2a44a50aeba5d7932" translate="yes" xml:space="preserve">
          <source>Setting up Relay Compiler</source>
          <target state="translated">Configurando el Compilador de Relevos</target>
        </trans-unit>
        <trans-unit id="4d8e8804be8f7d9838f29acdb1972f43499e72bb" translate="yes" xml:space="preserve">
          <source>Setting up babel-plugin-relay</source>
          <target state="translated">Estableciendo el relé de babel-plugin</target>
        </trans-unit>
        <trans-unit id="abeed86f05bd23992570bff235c3a5eea268d38d" translate="yes" xml:space="preserve">
          <source>Show More</source>
          <target state="translated">Mostrar más</target>
        </trans-unit>
        <trans-unit id="c0d8810501ac79b3d67791d7c14301a445bdcd5c" translate="yes" xml:space="preserve">
          <source>Similar to how a React component's &lt;code&gt;render&lt;/code&gt; method does not directly modify native views, Relay containers do not directly fetch data. Instead, containers declare a &lt;em&gt;specification&lt;/em&gt; of the data needed to render. Relay guarantees that this data is available &lt;em&gt;before&lt;/em&gt; rendering.</source>
          <target state="translated">De manera similar a c&amp;oacute;mo el m&amp;eacute;todo de &lt;code&gt;render&lt;/code&gt; izado de un componente React no modifica directamente las vistas nativas, los contenedores Relay no obtienen datos directamente. En cambio, los contenedores declaran una &lt;em&gt;especificaci&amp;oacute;n&lt;/em&gt; de los datos necesarios para renderizar. Relay garantiza que estos datos est&amp;aacute;n disponibles &lt;em&gt;antes de la&lt;/em&gt; renderizaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c15fa4b758d35cc97d9959bcc45edd294156d605" translate="yes" xml:space="preserve">
          <source>Simple Example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88286b84c7253d721eb28be982c48ae3b8c8564f" translate="yes" xml:space="preserve">
          <source>Simpler Mutation API</source>
          <target state="translated">Simplificación de la mutación API</target>
        </trans-unit>
        <trans-unit id="38b269b106dd0853215c15032c144a95de107505" translate="yes" xml:space="preserve">
          <source>Since Relay containers define fragments and not queries, they can be easily embedded in multiple contexts. Like React components, Relay containers are highly reusable.</source>
          <target state="translated">Dado que los contenedores de relevo definen fragmentos y no consultas,se pueden incrustar fácilmente en múltiples contextos.Al igual que los componentes de React,los contenedores de relé son altamente reutilizables.</target>
        </trans-unit>
        <trans-unit id="eed3231995e285304e7921a2b3b7268f678be407" translate="yes" xml:space="preserve">
          <source>Since one game can have many hiding spots, we need to create a connection that we can use to link them together.</source>
          <target state="translated">Ya que un juego puede tener muchos escondites,necesitamos crear una conexión que podamos usar para unirlos.</target>
        </trans-unit>
        <trans-unit id="1bc4c3be89589c1b9cbd3e1e89f801487097b78c" translate="yes" xml:space="preserve">
          <source>Smaller Bundle Size</source>
          <target state="translated">El tamaño del paquete más pequeño</target>
        </trans-unit>
        <trans-unit id="eae26374639c4e0cc2a093a378a0ac3891ecab5b" translate="yes" xml:space="preserve">
          <source>So far we looked at the lower-level aspects of data-fetching and saw how various familiar concepts translate to GraphQL. Next, let's step back and look at some higher-level concerns that product developers often face around data-fetching:</source>
          <target state="translated">Hasta ahora hemos mirado los aspectos de nivel inferior de la búsqueda de datos y vimos cómo varios conceptos familiares se traducen a GraphQL.A continuación,vamos a dar un paso atrás y mirar algunas preocupaciones de alto nivel que los desarrolladores de productos a menudo se enfrentan en torno a la búsqueda de datos:</target>
        </trans-unit>
        <trans-unit id="d0fc3a75755e472cad5df2903a8721c7c36d0bc7" translate="yes" xml:space="preserve">
          <source>So far we're just using GraphQL as a more efficient version of typical REST approaches. Note two important benefits in the GraphQL version:</source>
          <target state="translated">Hasta ahora sólo estamos usando GraphQL como una versión más eficiente de los típicos enfoques REST.Note dos importantes beneficios en la versión de GraphQL:</target>
        </trans-unit>
        <trans-unit id="d2a06967c509756a257c5cfbc8a853322fb784a3" translate="yes" xml:space="preserve">
          <source>So far we've looked at the process of querying data and keeping views up to date, but we haven't looked at writes. In GraphQL, writes are called &lt;strong&gt;mutations&lt;/strong&gt;. We can think of them as queries with side effects. Here's an example of calling a mutation that might mark a given story as being liked by the current user:</source>
          <target state="translated">Hasta ahora, hemos analizado el proceso de consultar datos y mantener las vistas actualizadas, pero no hemos analizado las escrituras. En GraphQL, las escrituras se denominan &lt;strong&gt;mutaciones&lt;/strong&gt; . Podemos pensar en ellos como consultas con efectos secundarios. A continuaci&amp;oacute;n, se muestra un ejemplo de c&amp;oacute;mo llamar a una mutaci&amp;oacute;n que podr&amp;iacute;a marcar una historia determinada como del agrado del usuario actual:</target>
        </trans-unit>
        <trans-unit id="5fb4c3d88d69385cf7a448a7c57e653bef0ce88f" translate="yes" xml:space="preserve">
          <source>So far, we've covered two pieces that each contribute to declaring data:</source>
          <target state="translated">Hasta ahora,hemos cubierto dos piezas que contribuyen cada una a declarar datos:</target>
        </trans-unit>
        <trans-unit id="647475236d1bc60d884c2b35b08e1b42225bc0f4" translate="yes" xml:space="preserve">
          <source>So for our &lt;code&gt;introduceShip&lt;/code&gt; mutation, we create two types: &lt;code&gt;IntroduceShipInput&lt;/code&gt; and &lt;code&gt;IntroduceShipPayload&lt;/code&gt;:</source>
          <target state="translated">Entonces, para nuestra mutaci&amp;oacute;n &lt;code&gt;introduceShip&lt;/code&gt; , creamos dos tipos: &lt;code&gt;IntroduceShipInput&lt;/code&gt; y &lt;code&gt;IntroduceShipPayload&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9b153876a947507c9e895bf7e190b67952746372" translate="yes" xml:space="preserve">
          <source>So how do we use this cache? Let's look at two operations: writing to the cache when a response is received, and reading from the cache to determine if a query can be fulfilled locally (the equivalent to &lt;code&gt;_cache.has(key)&lt;/code&gt; above, but for a graph).</source>
          <target state="translated">Entonces, &amp;iquest;c&amp;oacute;mo usamos este cach&amp;eacute;? Veamos dos operaciones: escribir en la cach&amp;eacute; cuando se recibe una respuesta y leer de la cach&amp;eacute; para determinar si una consulta se puede cumplir localmente (el equivalente a &lt;code&gt;_cache.has(key)&lt;/code&gt; anterior, pero para un gr&amp;aacute;fico).</target>
        </trans-unit>
        <trans-unit id="ecc4d54395356b7b485a16f80a383e1e01836248" translate="yes" xml:space="preserve">
          <source>So now we know the ID of the Rebels in our system. We can now refetch them:</source>
          <target state="translated">Así que ahora sabemos la identificación de los rebeldes en nuestro sistema.Ahora podemos volver a buscarlos:</target>
        </trans-unit>
        <trans-unit id="6a920cd8724dc921d9d4f9bdbe2e23494f550470" translate="yes" xml:space="preserve">
          <source>So on the first query for ships, GraphQL told us there was a next page, but on the next one, it told us we'd reached the end of the connection.</source>
          <target state="translated">Así que en la primera búsqueda de naves,GraphQL nos dijo que había una página siguiente,pero en la siguiente,nos dijo que habíamos llegado al final de la conexión.</target>
        </trans-unit>
        <trans-unit id="7d3d5c6eef5a80a3513fea5675a4ae9df60ad431" translate="yes" xml:space="preserve">
          <source>Some fields - especially those for paginated data - can require post-processing on the client in order to merge previously fetched data with new information. Relay Modern supports custom field handlers that can be used to process these fields to work with various pagination patterns and other use cases.</source>
          <target state="translated">Algunos campos,especialmente los de datos paginados,pueden requerir un post-procesamiento en el cliente para fusionar los datos previamente obtenidos con la nueva información.Relay Modern soporta manejadores de campo personalizados que pueden utilizarse para procesar estos campos para trabajar con varios patrones de paginación y otros casos de uso.</target>
        </trans-unit>
        <trans-unit id="adccc4f5e80b41c5617710fc459b4ed3934af747" translate="yes" xml:space="preserve">
          <source>Sometimes a parent needs to override the default variables of a child component. Imagine that we want to render &lt;code&gt;Child&lt;/code&gt; above with a photo size of 128 instead of the default 64. To do this, we have to ensure that both the fragment &lt;em&gt;and&lt;/em&gt; the container know about the custom variable. To set a custom variable in the &lt;em&gt;query&lt;/em&gt;, use the second argument to &lt;code&gt;getFragment&lt;/code&gt;:</source>
          <target state="translated">A veces, un padre necesita anular las variables predeterminadas de un componente hijo. Imagine que queremos renderizar &lt;code&gt;Child&lt;/code&gt; arriba con un tama&amp;ntilde;o de foto de 128 en lugar del predeterminado 64. Para hacer esto, tenemos que asegurarnos de que tanto el fragmento &lt;em&gt;como&lt;/em&gt; el contenedor conocen la variable personalizada. Para establecer una variable personalizada en la &lt;em&gt;consulta&lt;/em&gt; , use el segundo argumento para &lt;code&gt;getFragment&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e660d20bf684b576ae81f9c3a877a8d530b581ed" translate="yes" xml:space="preserve">
          <source>Source files</source>
          <target state="translated">Archivos de origen</target>
        </trans-unit>
        <trans-unit id="2d309b4d42e0ad4602d00da88f45cac2d3d11a5e" translate="yes" xml:space="preserve">
          <source>Specify the data dependencies of a `Relay.Container` as GraphQL fragments.</source>
          <target state="translated">Especificar las dependencias de datos de un &quot;Contenedor de Retransmisión&quot; como fragmentos de GraphQL.</target>
        </trans-unit>
        <trans-unit id="21f0a8e08151b2997828c63fbaffbc197295bb3a" translate="yes" xml:space="preserve">
          <source>Specify the mutation field in a `Relay.Mutation`.</source>
          <target state="translated">Especifica el campo de la mutación en un &quot;Relevo.Mutación&quot;.</target>
        </trans-unit>
        <trans-unit id="02293aef0bd0213bc1be111d67f416c9ddf1ebdf" translate="yes" xml:space="preserve">
          <source>Specify the queries of a `Relay.Route`.</source>
          <target state="translated">Especifica las preguntas de una &quot;Ruta de retransmisión&quot;.</target>
        </trans-unit>
        <trans-unit id="82c2f41708c8462a6d94834b8d39a6c652c2ac2b" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;filters&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="066b54007a4c37add5703334fe870041528f5a58" translate="yes" xml:space="preserve">
          <source>Specifying just the &lt;code&gt;key&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c5f40f02b986c2adaf7800c3005c0afdbaaab33" translate="yes" xml:space="preserve">
          <source>Start converting your components and mutations to use the Relay Modern APIs from the &lt;code&gt;'react-relay/compat'&lt;/code&gt; module (&lt;code&gt;createFragmentContainer&lt;/code&gt;, &lt;code&gt;createRefetchContainer&lt;/code&gt;, &lt;code&gt;createPaginationContainer&lt;/code&gt;, &lt;code&gt;commitMutation&lt;/code&gt;). It will be easier to go from the leaf components up. The &lt;a href=&quot;https://github.com/relayjs/relay-codemod&quot;&gt;conversion scripts&lt;/a&gt; should make this step less tedious.</source>
          <target state="translated">Comience a convertir sus componentes y mutaciones para usar las API de Relay Modern desde el m&amp;oacute;dulo &lt;code&gt;'react-relay/compat'&lt;/code&gt; ( &lt;code&gt;createFragmentContainer&lt;/code&gt; , &lt;code&gt;createRefetchContainer&lt;/code&gt; , &lt;code&gt;createPaginationContainer&lt;/code&gt; , &lt;code&gt;commitMutation&lt;/code&gt; ). Ser&amp;aacute; m&amp;aacute;s f&amp;aacute;cil pasar de los componentes de la hoja hacia arriba. Los &lt;a href=&quot;https://github.com/relayjs/relay-codemod&quot;&gt;scripts de conversi&amp;oacute;n&lt;/a&gt; deber&amp;iacute;an hacer que este paso sea menos tedioso.</target>
        </trans-unit>
        <trans-unit id="6a5813201a4580fe5f1fbb25f1a522d4d505bf2d" translate="yes" xml:space="preserve">
          <source>Static Methods</source>
          <target state="translated">Métodos estáticos</target>
        </trans-unit>
        <trans-unit id="49ff3956bbd054bfbc63e2eabd2a1088f21e282f" translate="yes" xml:space="preserve">
          <source>Step 0: Install Relay v1.0</source>
          <target state="translated">Paso 0:Instalar el Relé v1.0</target>
        </trans-unit>
        <trans-unit id="95c2707d7e8702851af5473310f89fd4c5bfea2a" translate="yes" xml:space="preserve">
          <source>Step 1: Incrementally convert to Relay Compat</source>
          <target state="translated">Paso 1:Convertirse de forma incremental a Compatador de Relevos</target>
        </trans-unit>
        <trans-unit id="d071bae177457e9183feaf0fc474e9686b0260a4" translate="yes" xml:space="preserve">
          <source>Step 2: Introduce &amp;lt;QueryRenderer&amp;gt;</source>
          <target state="translated">Paso 2: Presente &amp;lt;QueryRenderer&amp;gt;</target>
        </trans-unit>
        <trans-unit id="8176e519a1495162afbc0b02a0cc285793d9b9e6" translate="yes" xml:space="preserve">
          <source>Step 3: Introduce Relay Modern runtime</source>
          <target state="translated">Paso 3:Introducir el tiempo de ejecución de Relevos Modernos</target>
        </trans-unit>
        <trans-unit id="5465ead3d787f346532f42480c386d4eba31fbae" translate="yes" xml:space="preserve">
          <source>Step 4: Clean up by replacing Relay Compat with Relay Modern.</source>
          <target state="translated">Paso 4:Limpiar reemplazando el Relé Compat con el Relé Moderno.</target>
        </trans-unit>
        <trans-unit id="0d8a7046c8d39d9cbd86abcdfb704b161a601f9e" translate="yes" xml:space="preserve">
          <source>Store</source>
          <target state="translated">Store</target>
        </trans-unit>
        <trans-unit id="aec0a8c625d33f2410286cd7972018e4c401dd0d" translate="yes" xml:space="preserve">
          <source>Store Operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e017d4c10eaa0f64c98ad2b1e9b9a9d85ad4822" translate="yes" xml:space="preserve">
          <source>Structure around mutations to make them predictable.</source>
          <target state="translated">Estructura alrededor de las mutaciones para hacerlas predecibles.</target>
        </trans-unit>
        <trans-unit id="5697fd85adbd13bf85f28712f9a136e80cc8067e" translate="yes" xml:space="preserve">
          <source>Subscriptions</source>
          <target state="translated">Subscriptions</target>
        </trans-unit>
        <trans-unit id="501433bf93135f5b327aa2f2f9a8b9652febd9e8" translate="yes" xml:space="preserve">
          <source>Support for live queries where supported by the network/server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13a5b46568a2ea322aa7b25ac8f48a520783301a" translate="yes" xml:space="preserve">
          <source>Supported in both compat and modern mode. When using the pagination container, Relay expects the connection field to be annotated with &lt;code&gt;@connection&lt;/code&gt; directive, for more detailed information and example, please go to &lt;a href=&quot;pagination-container#connection-directive&quot;&gt;&lt;code&gt;PaginationContainer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Compatible tanto en modo compat como en modo moderno. Al usar el contenedor de paginaci&amp;oacute;n, Relay espera que el campo de conexi&amp;oacute;n est&amp;eacute; anotado con la directiva &lt;code&gt;@connection&lt;/code&gt; , para obtener informaci&amp;oacute;n m&amp;aacute;s detallada y un ejemplo, vaya a &lt;a href=&quot;pagination-container#connection-directive&quot;&gt; &lt;code&gt;PaginationContainer&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3ff1be67feaa88d4848ce4702f24046558ce5b24" translate="yes" xml:space="preserve">
          <source>Supported in classic, compat and modern mode. Detailed usage is explained in &lt;a href=&quot;api-reference-relay-ql#array-fields&quot;&gt;&lt;code&gt;Relay.QL&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Soportado en modo cl&amp;aacute;sico, compat y moderno. El uso detallado se explica en &lt;a href=&quot;api-reference-relay-ql#array-fields&quot;&gt; &lt;code&gt;Relay.QL&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="65d6a8d5361414a2749b7b32500d3781b01e64c3" translate="yes" xml:space="preserve">
          <source>Sweet! Let's keep going and get the next four!</source>
          <target state="translated">¡Genial! ¡Sigamos adelante y consigamos los siguientes cuatro!</target>
        </trans-unit>
        <trans-unit id="28e2c6a12e1af3dcd74179eb09b97b7b134beae3" translate="yes" xml:space="preserve">
          <source>Switch the &lt;code&gt;'react-relay/compat'&lt;/code&gt; references in your app to &lt;code&gt;'react-relay'&lt;/code&gt;. This is more of a clean-up step that prevents your app from pulling in unnecessary &lt;code&gt;'react-relay/classic'&lt;/code&gt; code.</source>
          <target state="translated">Cambie las referencias &lt;code&gt;'react-relay/compat'&lt;/code&gt; en su aplicaci&amp;oacute;n a &lt;code&gt;'react-relay'&lt;/code&gt; . Este es m&amp;aacute;s un paso de limpieza que evita que su aplicaci&amp;oacute;n extraiga un c&amp;oacute;digo &lt;code&gt;'react-relay/classic'&lt;/code&gt; innecesario .</target>
        </trans-unit>
        <trans-unit id="c64e9942fb642977fbd70ec197abeadd198f3103" translate="yes" xml:space="preserve">
          <source>Table of Contents:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21d278837034557e7a9b46210d42d6e7b8075142" translate="yes" xml:space="preserve">
          <source>Terminology</source>
          <target state="translated">Terminology</target>
        </trans-unit>
        <trans-unit id="3965436aa1e25eb8c1a80de5c7180c888af16646" translate="yes" xml:space="preserve">
          <source>That input argument should contain a (string) &quot;clientMutationId&quot; property for the purposes of reconciling requests and responses (automatically added by the &lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; API).</source>
          <target state="translated">Ese argumento de entrada debe contener una propiedad (cadena) &quot;clientMutationId&quot; con el fin de conciliar solicitudes y respuestas (agregadas autom&amp;aacute;ticamente por la API &lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="56c0a2575be8f36ad7f5d4d04acffdd56aaaf9ea" translate="yes" xml:space="preserve">
          <source>That used the &lt;code&gt;first&lt;/code&gt; argument to &lt;code&gt;ships&lt;/code&gt; to slice the result set down to the first one. But what if we wanted to paginate through it? On each edge, a cursor will be exposed that we can use to paginate. Let's ask for the first two this time, and get the cursor as well:</source>
          <target state="translated">Eso us&amp;oacute; el &lt;code&gt;first&lt;/code&gt; argumento a los &lt;code&gt;ships&lt;/code&gt; para dividir el resultado establecido en el primero. Pero, &amp;iquest;y si quisi&amp;eacute;ramos paginarlo? En cada borde, se expondr&amp;aacute; un cursor que podemos usar para paginar. Preguntemos por los dos primeros esta vez, y obtengamos tambi&amp;eacute;n el cursor:</target>
        </trans-unit>
        <trans-unit id="cdaffd6461c67e56056afce77a9bd307eee56aef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Node&lt;/code&gt; interface and &lt;code&gt;node&lt;/code&gt; field assume globally unique IDs for this refetching. A system without globally unique IDs can usually synthesize them by combining the type with the type-specific ID, which is what was done in this example.</source>
          <target state="translated">El &lt;code&gt;Node&lt;/code&gt; de interfaz y &lt;code&gt;node&lt;/code&gt; campo asumen identificadores &amp;uacute;nicos globales de este re-cargar. Un sistema sin ID globalmente &amp;uacute;nicos normalmente puede sintetizarlos combinando el tipo con el ID espec&amp;iacute;fico del tipo, que es lo que se hizo en este ejemplo.</target>
        </trans-unit>
        <trans-unit id="4249e055d5de1ea8000faee39fa1425b4eb71404" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Node&lt;/code&gt; interface contains a single field, &lt;code&gt;id&lt;/code&gt;, which is a &lt;code&gt;ID!&lt;/code&gt;. The &lt;code&gt;node&lt;/code&gt; root field takes a single argument, a &lt;code&gt;ID!&lt;/code&gt;, and returns a &lt;code&gt;Node&lt;/code&gt;. These two work in concert to allow refetching; if we pass the &lt;code&gt;id&lt;/code&gt; returned in that field to the &lt;code&gt;node&lt;/code&gt; field, we get the object back.</source>
          <target state="translated">La interfaz de &lt;code&gt;Node&lt;/code&gt; contiene un solo campo, &lt;code&gt;id&lt;/code&gt; , que es un &lt;code&gt;ID!&lt;/code&gt; . El campo ra&amp;iacute;z del &lt;code&gt;node&lt;/code&gt; toma un solo argumento, &amp;iexcl;una &lt;code&gt;ID!&lt;/code&gt; y devuelve un &lt;code&gt;Node&lt;/code&gt; . Estos dos trabajan en conjunto para permitir la recuperaci&amp;oacute;n; si pasamos la &lt;code&gt;id&lt;/code&gt; entificaci&amp;oacute;n devuelta en ese campo al campo del &lt;code&gt;node&lt;/code&gt; , recuperamos el objeto.</target>
        </trans-unit>
        <trans-unit id="de66ff0a79b624dd454deb3e772e5fb7a040eb35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RecordProxy&lt;/code&gt; serves as an interface to mutate records:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b8b179aabf77ea5e811ea7880878bfdfa6368ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RecordSourceSelectorProxy&lt;/code&gt; is the type of the &lt;code&gt;store&lt;/code&gt; that &lt;a href=&quot;mutations#using-updater-and-optimisticupdater&quot;&gt;&lt;code&gt;updater&lt;/code&gt; functions&lt;/a&gt; receive as an argument. The following is the &lt;code&gt;RecordSourceSelectorProxy&lt;/code&gt; interface:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="858f5c2de227f30eaba7fc1f9d4f04ab2b8c2484" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RelayCompiler&lt;/code&gt; module is a helper class that demonstrates one way of combining these primitives. It takes IR transforms, and given IR definitions, constructs a CompilerContext from them, transforming them, and generating output artifacts intended for use with Relay runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a164901ca79b8b4a2a0866d3bc8b9028a8a90acb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Store&lt;/code&gt; is the source of truth for application data and provides the following core operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69b82e1269cd3f5440edfdd8ab8e1cb4218f2a3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;applyUpdate&lt;/code&gt; adds a mutation just like &lt;code&gt;update&lt;/code&gt;, but does not commit it. It returns a &lt;code&gt;RelayMutationTransaction&lt;/code&gt; that can be committed or rollbacked.</source>
          <target state="translated">El &lt;code&gt;applyUpdate&lt;/code&gt; a&amp;ntilde;ade una mutaci&amp;oacute;n al igual que &lt;code&gt;update&lt;/code&gt; , pero no lo cometen. Devuelve una &lt;code&gt;RelayMutationTransaction&lt;/code&gt; que se puede confirmar o deshacer.</target>
        </trans-unit>
        <trans-unit id="c8a27cee9d1d9abe2e77bcb0c575a4357ce66c14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;babel-relay-plugin&lt;/code&gt; must run before the &lt;code&gt;react-native&lt;/code&gt; Babel preset. Thus, in &lt;code&gt;.babelrc&lt;/code&gt;&lt;code&gt;&quot;react-native&quot;&lt;/code&gt; must come after &lt;code&gt;babelRelayPlugin&lt;/code&gt;.</source>
          <target state="translated">El &lt;code&gt;babel-relay-plugin&lt;/code&gt; debe ejecutarse antes que el ajuste preestablecido de Babel &lt;code&gt;react-native&lt;/code&gt; . Por lo tanto, en &lt;code&gt;.babelrc&lt;/code&gt; &lt;code&gt;&quot;react-native&quot;&lt;/code&gt; debe ir despu&amp;eacute;s de &lt;code&gt;babelRelayPlugin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf0346f82ced9502e9b07bb0b45a4c3bf97fc831" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;commitUpdate&lt;/code&gt; method is analogous to dispatching an action in Flux. Relay processes the mutation as follows:</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;commitUpdate&lt;/code&gt; es an&amp;aacute;logo a enviar una acci&amp;oacute;n en Flux. Relay procesa la mutaci&amp;oacute;n de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="1e1d2e828d0bd7ad1f6ddc74cb042c491b6885f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;graphql&lt;/code&gt; template tag provided by Relay serves as the mechanism to write queries, fragments, mutations or subscriptions in the &lt;a href=&quot;http://graphql.org/learn/&quot;&gt;GraphQL&lt;/a&gt; language. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5916376d8984ac32cb4ef4378494b52a513ccdde" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;react-relay&lt;/code&gt; npm module includes &lt;code&gt;react&lt;/code&gt; as a &lt;em&gt;peer dependency&lt;/em&gt;. Your app should specify React as a dependency explicitly.</source>
          <target state="translated">El m&amp;oacute;dulo npm &lt;code&gt;react-relay&lt;/code&gt; incluye &lt;code&gt;react&lt;/code&gt; como una &lt;em&gt;dependencia de pares&lt;/em&gt; . Su aplicaci&amp;oacute;n debe especificar React como una dependencia expl&amp;iacute;citamente.</target>
        </trans-unit>
        <trans-unit id="687a2b2e72c0944702e22c85dfb54906ee9cc4a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;relay-compiler&lt;/code&gt; script requires both the directory which holds your source files as well as a path to your GraphQL schema in either a .json or .graphql schema file.</source>
          <target state="translated">La secuencia de comandos del &lt;code&gt;relay-compiler&lt;/code&gt; requiere tanto el directorio que contiene sus archivos de origen como una ruta a su esquema GraphQL en un archivo de esquema .json o .graphql.</target>
        </trans-unit>
        <trans-unit id="09a465866585d4ac0fa1f3ec8871e9ae5a93fc4f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;renderFailure&lt;/code&gt; callback is called with two arguments: an &lt;code&gt;Error&lt;/code&gt; object and a function to retry the request. If the error was the result of a server error communicated in the server's response, the response payload is available for inspection on &lt;code&gt;error.source&lt;/code&gt;.</source>
          <target state="translated">La &lt;code&gt;renderFailure&lt;/code&gt; llamada renderFailure se llama con dos argumentos: un objeto &lt;code&gt;Error&lt;/code&gt; y una funci&amp;oacute;n para reintentar la solicitud. Si el error fue el resultado de un error del servidor comunicado en la respuesta del servidor, la carga &amp;uacute;til de respuesta est&amp;aacute; disponible para su inspecci&amp;oacute;n en &lt;code&gt;error.source&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fec68a6615738a8b02b918d7e606ef06cece0ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;renderFetched&lt;/code&gt; callback is always called with a &lt;code&gt;data&lt;/code&gt; argument, which is an object mapping from &lt;code&gt;propName&lt;/code&gt; to query data. It is expected that the &lt;code&gt;renderFetched&lt;/code&gt; callback renders the supplied &lt;code&gt;Component&lt;/code&gt; with them (e.g. using the &lt;a href=&quot;https://facebook.github.io/react/docs/jsx-spread.html&quot;&gt;JSX spread attributes feature&lt;/a&gt;).</source>
          <target state="translated">La &lt;code&gt;renderFetched&lt;/code&gt; llamada renderFetched siempre se llama con un argumento de &lt;code&gt;data&lt;/code&gt; , que es una asignaci&amp;oacute;n de objeto de &lt;code&gt;propName&lt;/code&gt; a los datos de la consulta. Se espera que la &lt;code&gt;renderFetched&lt;/code&gt; llamada renderFetched represente el &lt;code&gt;Component&lt;/code&gt; e suministrado con ellos (por ejemplo, utilizando la &lt;a href=&quot;https://facebook.github.io/react/docs/jsx-spread.html&quot;&gt;funci&amp;oacute;n de atributos de extensi&amp;oacute;n JSX&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="fc694dd64cc47d448a84516c45884dcebf08a20c" translate="yes" xml:space="preserve">
          <source>The API is overall simpler and more predictable.</source>
          <target state="translated">El API es en general más simple y más predecible.</target>
        </trans-unit>
        <trans-unit id="8e85966b9eda2ce8d0b649695a0687a896efc918" translate="yes" xml:space="preserve">
          <source>The Component resulting from &lt;code&gt;createFragmentContainer&lt;/code&gt; will receive the following &lt;code&gt;props&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf72a96b855224dd8974796498f53a592b116371" translate="yes" xml:space="preserve">
          <source>The Component resulting from &lt;code&gt;createPaginationContainer&lt;/code&gt; will receive the following &lt;code&gt;props&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4e8ac825308dd36be82a845d481fc8dfdffbd9f" translate="yes" xml:space="preserve">
          <source>The Component resulting from &lt;code&gt;createRefetchContainer&lt;/code&gt; will receive the following &lt;code&gt;props&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3270609e5596533f39e48f966bd5c2bc4660cc1" translate="yes" xml:space="preserve">
          <source>The DataID of the parent node that contains the connection. This argument is optional.</source>
          <target state="translated">El DataID del nodo padre que contiene la conexión.Este argumento es opcional.</target>
        </trans-unit>
        <trans-unit id="c4a8c9e60c4dd38c187162160297b7cec4fec7f9" translate="yes" xml:space="preserve">
          <source>The IDs we got back were base64 strings. IDs are designed to be opaque (the only thing that should be passed to the &lt;code&gt;id&lt;/code&gt; argument on &lt;code&gt;node&lt;/code&gt; is the unaltered result of querying &lt;code&gt;id&lt;/code&gt; on some object in the system), and base64ing a string is a useful convention in GraphQL to remind viewers that the string is an opaque identifier.</source>
          <target state="translated">Las identificaciones que obtuvimos fueron cadenas base64. Los identificadores est&amp;aacute;n dise&amp;ntilde;ados para ser opacos (lo &amp;uacute;nico que debe pasarse al argumento &lt;code&gt;id&lt;/code&gt; en el &lt;code&gt;node&lt;/code&gt; es el resultado inalterado de consultar el &lt;code&gt;id&lt;/code&gt; en alg&amp;uacute;n objeto en el sistema), y basar una cadena es una convenci&amp;oacute;n &amp;uacute;til en GraphQL para recordar a los espectadores que el cadena es un identificador opaco.</target>
        </trans-unit>
        <trans-unit id="7450121d3a10cfde0d27fedec5e7487c759f4cef" translate="yes" xml:space="preserve">
          <source>The Relay &quot;Environment&quot;</source>
          <target state="translated">El Relevo &quot;Medio Ambiente&quot;</target>
        </trans-unit>
        <trans-unit id="29a5b8d00ca84a6ecf522b93deabead7921f8457" translate="yes" xml:space="preserve">
          <source>The Relay &quot;Environment&quot; bundles together the configuration, cache storage, and network-handling that Relay needs in order to operate.</source>
          <target state="translated">El &quot;entorno&quot; del relé reúne la configuración,el almacenamiento en caché y el manejo de la red que el relé necesita para funcionar.</target>
        </trans-unit>
        <trans-unit id="04d65a89a2e8d48fa93bad9ecd0dc074fc69e421" translate="yes" xml:space="preserve">
          <source>The Relay &amp;quot;Environment&amp;quot;</source>
          <target state="translated">El &quot;entorno&quot; del rel&amp;eacute;</target>
        </trans-unit>
        <trans-unit id="ee388b82ec2168b63f7ecfa7840c723aabafb1e3" translate="yes" xml:space="preserve">
          <source>The Relay &lt;code&gt;Store&lt;/code&gt; provides an API for dispatching mutations to the server.</source>
          <target state="translated">Relay &lt;code&gt;Store&lt;/code&gt; proporciona una API para enviar mutaciones al servidor.</target>
        </trans-unit>
        <trans-unit id="8f70d28e27ab15f03147076b8dda3030c0a0078e" translate="yes" xml:space="preserve">
          <source>The Relay Classic and Relay Compat modes produce generated content inline and may catch and log any detected GraphQL validation errors, leaving those errors to be thrown at runtime.</source>
          <target state="translated">Los modos Relay Classic y Relay Compat producen contenido generado en línea y pueden captar y registrar cualquier error de validación de GraphQL detectado,dejando que esos errores sean lanzados en tiempo de ejecución.</target>
        </trans-unit>
        <trans-unit id="77da780670013088b3893d46cce4bc75359e000f" translate="yes" xml:space="preserve">
          <source>The Relay Compiler fully supports client-side schema extensions, which allows you to extend the server schema by defining additional GraphQL types and fields on the client. Relay expects the client schema to be located in your &lt;code&gt;--src&lt;/code&gt; directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c019c5395f2cd9ca47232f5e8ed64fa398b7ada0" translate="yes" xml:space="preserve">
          <source>The Relay Compiler is responsible for generating code as part of a build step which can then be referenced at runtime. By building the query ahead of time, the Relay's runtime is not responsible for generating a query string, and various optimizations can be performed on the query that could be too expensive at runtime (for example, fields that are duplicated in the query can be merged during the build step, to improve efficiency of processing the GraphQL response).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b710564e5046fb16b4d54484e5bd00a02c1c71b3" translate="yes" xml:space="preserve">
          <source>The Relay Compiler is responsible for generating code as part of a build step which, at runtime, can be used statically. By building the query ahead of time, the client's JS runtime is not responsible for generating a query string, and fields that are duplicated in the query can be merged during the build step, to improve parsing efficiency. If you have the ability to persist queries to your server, the compiler's code generation process provides a convenient time to convert a query or mutation's text into a unique identifier, which greatly reduces the upload bytes required.</source>
          <target state="translated">El Compilador de Relevos es responsable de generar código como parte de un paso de construcción que,en tiempo de ejecución,puede ser usado estáticamente.Al construir la consulta con antelación,el tiempo de ejecución JS del cliente no es responsable de generar una cadena de consulta,y los campos que están duplicados en la consulta pueden ser fusionados durante el paso de construcción,para mejorar la eficiencia del análisis sintáctico.Si tiene la capacidad de persistir las consultas a su servidor,el proceso de generación de código del compilador proporciona un tiempo conveniente para convertir el texto de una consulta o mutación en un identificador único,lo que reduce en gran medida los bytes de carga necesarios.</target>
        </trans-unit>
        <trans-unit id="63623a8a89bd3ad461c1fe2298a373e6892186d0" translate="yes" xml:space="preserve">
          <source>The Relay Modern Core adds support for client schema extensions. These allow Relay to conveniently store some extra information with data fetched from the server and be rendered like any other field fetched from the server. This should be able to replace some use cases that previously required a Flux/Redux store on the side.</source>
          <target state="translated">El Relay Modern Core añade soporte para extensiones de esquemas de clientes.Estas permiten a Relay almacenar convenientemente alguna información extra con datos obtenidos del servidor y ser renderizados como cualquier otro campo obtenido del servidor.Esto debería ser capaz de reemplazar algunos casos de uso que anteriormente requerían un almacenamiento de Flux/Redux en el lateral.</target>
        </trans-unit>
        <trans-unit id="d7d5ac1a62f052029edc67e6900f799b310cde67" translate="yes" xml:space="preserve">
          <source>The Relay Modern packages distributed on NPM use the widely-supported ES5 version of JavaScript to support as many browser environments as possible.</source>
          <target state="translated">Los paquetes Relay Modern distribuidos en NPM utilizan la versión ES5 de JavaScript,ampliamente soportada,para soportar el mayor número de entornos de navegación posible.</target>
        </trans-unit>
        <trans-unit id="3f35b4d76fe696a95341841f45e165e3b0c6aad8" translate="yes" xml:space="preserve">
          <source>The Relay Network Layer</source>
          <target state="translated">La Capa de la Red de Relevos</target>
        </trans-unit>
        <trans-unit id="6ac0bfad74e5d02ff492fbabe1206cbc172f8a94" translate="yes" xml:space="preserve">
          <source>The Relay Store can be used to programmatically update client-side data inside &lt;a href=&quot;mutations#using-updater-and-optimisticupdater&quot;&gt;&lt;code&gt;updater&lt;/code&gt; functions&lt;/a&gt;. The following is a reference of the Relay Store interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d750d1085b7a107c9c036e90d472c451b5fb59af" translate="yes" xml:space="preserve">
          <source>The Relay runtime bundle is roughly 20% of the size of Relay Classic.</source>
          <target state="translated">El paquete de tiempo de ejecución del relevo es aproximadamente el 20% del tamaño del Relevo Clásico.</target>
        </trans-unit>
        <trans-unit id="d69ab39bff551c52cbb39536496919006e7104d5" translate="yes" xml:space="preserve">
          <source>The Relay runtime is a full-featured GraphQL client that is designed for high performance even on low-end mobile devices and is capable of scaling to large, complex apps. The runtime API is not intended to be used directly in product code, but rather to provide a foundation for building higher-level product APIs such as React/Relay. This foundation includes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2170027015b9ca88c5f922e040a93d95772d2c0" translate="yes" xml:space="preserve">
          <source>The Relay store can be mutated programatically in advanced edge cases when optimistic updates need more granular control. The following API methods are useful for mutating your connections and fragments.</source>
          <target state="translated">El almacén de Relevos puede mutar programáticamente en casos de borde avanzado cuando las actualizaciones optimistas necesitan más control granular.Los siguientes métodos de la API son útiles para mutar sus conexiones y fragmentos.</target>
        </trans-unit>
        <trans-unit id="0adc8d247f24c64744fe2ba30ece6da8fd08a649" translate="yes" xml:space="preserve">
          <source>The author of this story also commented on it &amp;mdash; quite common. Now imagine that some other view fetches new information about the author, and her profile photo has changed to a new URI. Here's the &lt;em&gt;only&lt;/em&gt; part of our cached data that changes:</source>
          <target state="translated">El autor de esta historia tambi&amp;eacute;n lo coment&amp;oacute;, bastante com&amp;uacute;n. Ahora imagine que otra vista obtiene nueva informaci&amp;oacute;n sobre el autor y su foto de perfil ha cambiado a un nuevo URI. Aqu&amp;iacute; est&amp;aacute; la &lt;em&gt;&amp;uacute;nica&lt;/em&gt; parte de nuestros datos en cach&amp;eacute; que cambia:</target>
        </trans-unit>
        <trans-unit id="980a4b6788111d51d4fd5d3c6e5054ad267e5ae0" translate="yes" xml:space="preserve">
          <source>The best way to get started right now is to take a look at how these three parts come together to form a working example. The tutorial on the next page will lead you through an example application, using the &lt;a href=&quot;https://github.com/facebook/relay-starter-kit&quot;&gt;Relay Starter Kit&lt;/a&gt;, to give you an idea of how you can start using Relay on yours.</source>
          <target state="translated">La mejor manera de comenzar ahora mismo es observar c&amp;oacute;mo se unen estas tres partes para formar un ejemplo pr&amp;aacute;ctico. El tutorial de la p&amp;aacute;gina siguiente lo guiar&amp;aacute; a trav&amp;eacute;s de una aplicaci&amp;oacute;n de ejemplo, utilizando el &lt;a href=&quot;https://github.com/facebook/relay-starter-kit&quot;&gt;kit de&lt;/a&gt; inicio de Relay, para darle una idea de c&amp;oacute;mo puede comenzar a usar Relay en el suyo.</target>
        </trans-unit>
        <trans-unit id="5bc022d566f4b68dd38c73222756f331714be645" translate="yes" xml:space="preserve">
          <source>The client and server are decoupled: the client specifies the data needed instead of &lt;em&gt;relying on&lt;/em&gt; the server endpoint to return the correct data.</source>
          <target state="translated">El cliente y el servidor est&amp;aacute;n desacoplados: el cliente especifica los datos necesarios en lugar de &lt;em&gt;depender&lt;/em&gt; del punto final del servidor para devolver los datos correctos.</target>
        </trans-unit>
        <trans-unit id="859e2dd0a260c19654088e28b4f5cf103b3156ab" translate="yes" xml:space="preserve">
          <source>The compiler is a set of modules designed to extract GraphQL documents from across a codebase, transform/optimize them, and generate build artifacts. Examples of common types of artifacts include optimized GraphQL to persist to your server, runtime representations of the queries for use with GraphQL clients such as the Relay runtime, or generated source code for use with GraphQL frameworks for compiled languages (Java/Swift/etc).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa42964754dbecedd42dff5df9fe665b9c4e7306" translate="yes" xml:space="preserve">
          <source>The compiler module is composed of a set of core building blocks as well as a helper that packages them together in an easy to use API. Some of the main data types and modules in the compiler are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00a902f03306b6ea1e1e2818025625742f4e212c" translate="yes" xml:space="preserve">
          <source>The component-based approach of React Router v4 does not readily allow for aggregating the data requirements for nested routes, and as such does not readily permit an approach that will avoid request waterfalls from nesting &lt;code&gt;QueryRenderer&lt;/code&gt; components.</source>
          <target state="translated">El enfoque basado en componentes de React Router v4 no permite agregar f&amp;aacute;cilmente los requisitos de datos para rutas anidadas y, como tal, no permite f&amp;aacute;cilmente un enfoque que evite las cascadas de solicitudes de los componentes &lt;code&gt;QueryRenderer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7298679167473c58332d417e6d2bd4de9988163d" translate="yes" xml:space="preserve">
          <source>The container &amp;mdash; named &lt;code&gt;Relay(ProfilePicture)&lt;/code&gt; for debugging &amp;mdash; will retrieve the response for each GraphQL fragment from the local store.</source>
          <target state="translated">El contenedor, llamado &lt;code&gt;Relay(ProfilePicture)&lt;/code&gt; para depuraci&amp;oacute;n, recuperar&amp;aacute; la respuesta para cada fragmento de GraphQL de la tienda local.</target>
        </trans-unit>
        <trans-unit id="d147ef4301d6fa557024d99f96f08a499bbc3a4a" translate="yes" xml:space="preserve">
          <source>The container passes the results of each fragment (along with the other props) to the &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; component.</source>
          <target state="translated">El contenedor pasa los resultados de cada fragmento (junto con los dem&amp;aacute;s accesorios) al componente &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="268b06824cede0c427a01e0d80dbe18daf1354c3" translate="yes" xml:space="preserve">
          <source>The default implementation is as follows:</source>
          <target state="translated">La aplicación por defecto es la siguiente:</target>
        </trans-unit>
        <trans-unit id="bf32b3124e1516fba4edb1784393b843530e0823" translate="yes" xml:space="preserve">
          <source>The defaults we specify here will become available to our fragment builders:</source>
          <target state="translated">Los valores predeterminados que especificamos aquí estarán disponibles para nuestros constructores de fragmentos:</target>
        </trans-unit>
        <trans-unit id="fe89d1880c282b0f84f7ad747dcf711ed35e9199" translate="yes" xml:space="preserve">
          <source>The easiest way to get started for now is with the &lt;a href=&quot;https://github.com/relayjs/relay-starter-kit&quot;&gt;Relay Starter Kit&lt;/a&gt; - this includes an example schema file and configures the &lt;a href=&quot;https://www.npmjs.com/package/babel-relay-plugin&quot;&gt;&lt;code&gt;babel-relay-plugin&lt;/code&gt;&lt;/a&gt; npm module to transpile queries.</source>
          <target state="translated">La forma m&amp;aacute;s f&amp;aacute;cil de comenzar por ahora es con el &lt;a href=&quot;https://github.com/relayjs/relay-starter-kit&quot;&gt;Relay Starter Kit&lt;/a&gt; , que incluye un archivo de esquema de ejemplo y configura el m&amp;oacute;dulo npm &lt;a href=&quot;https://www.npmjs.com/package/babel-relay-plugin&quot;&gt; &lt;code&gt;babel-relay-plugin&lt;/code&gt; &lt;/a&gt; para transpilar consultas.</target>
        </trans-unit>
        <trans-unit id="0041bb913fb29f03cef5bab2b320b6add29c71a8" translate="yes" xml:space="preserve">
          <source>The example above did not configure a &lt;code&gt;handlerProvider&lt;/code&gt;, which means that a default one will be provided. Relay Modern comes with a built-in handler that augment the core with special functionality for handling connections (which is not a standard GraphQL feature, but a set of pagination conventions used at Facebook, specified in detail in the &lt;a href=&quot;https://relay.dev/graphql/connections.htm&quot;&gt;Relay Cursor Connections Specification&lt;/a&gt;, and well-supported by Relay itself).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef9027831057a9dfdeaac970a51f94ff44007267" translate="yes" xml:space="preserve">
          <source>The example above did not configure a &lt;code&gt;handlerProvider&lt;/code&gt;, which means that a default one will be provided. Relay Modern comes with a couple of built-in handlers that augment the core with special functionality for handling connections (which is not a standard GraphQL feature, but a set of pagination conventions used at Facebook, specified in detail in the &lt;a href=&quot;graphql-connections&quot;&gt;Relay Cursor Connections Specification&lt;/a&gt;, and well-supported by Relay itself) and the &lt;code&gt;viewer&lt;/code&gt; field (again, not a standard GraphQL schema feature, but one which has been conventionally used extensively within Facebook).</source>
          <target state="translated">El ejemplo anterior no configur&amp;oacute; un &lt;code&gt;handlerProvider&lt;/code&gt; , lo que significa que se proporcionar&amp;aacute; uno predeterminado. Relay Modern viene con un par de controladores integrados que aumentan el n&amp;uacute;cleo con una funcionalidad especial para manejar conexiones (que no es una caracter&amp;iacute;stica est&amp;aacute;ndar de GraphQL, sino un conjunto de convenciones de paginaci&amp;oacute;n utilizadas en Facebook, especificadas en detalle en la &lt;a href=&quot;graphql-connections&quot;&gt;Especificaci&amp;oacute;n de conexiones de cursor de retransmisi&amp;oacute;n)&lt;/a&gt; . y bien respaldado por el propio Relay) y el campo del &lt;code&gt;viewer&lt;/code&gt; (de nuevo, no es una funci&amp;oacute;n de esquema GraphQL est&amp;aacute;ndar, pero una que se ha utilizado de forma convencional y extensiva en Facebook).</target>
        </trans-unit>
        <trans-unit id="4657e52da9059d7f3c2e9423e8542337bf25d573" translate="yes" xml:space="preserve">
          <source>The example above is very similar to the classic container API, but in the modern API we can just pass the &lt;code&gt;graphql&lt;/code&gt; template literal directly as the second argument. Relay will infer the prop name from the fragment name according to the fragment naming convention &lt;code&gt;&amp;lt;FileName&amp;gt;_&amp;lt;propName&amp;gt;&lt;/code&gt;. The example below is equivalent to the one above:</source>
          <target state="translated">El ejemplo anterior es muy similar a la API de contenedor cl&amp;aacute;sica, pero en la API moderna podemos simplemente pasar el literal de la plantilla &lt;code&gt;graphql&lt;/code&gt; directamente como segundo argumento. Relay inferir&amp;aacute; el nombre de la propiedad a partir del nombre del fragmento de acuerdo con la convenci&amp;oacute;n de nomenclatura de fragmentos &lt;code&gt;&amp;lt;FileName&amp;gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; . El siguiente ejemplo es equivalente al anterior:</target>
        </trans-unit>
        <trans-unit id="1d30073e8f5f3cb9668f92d3d480a82b915306f9" translate="yes" xml:space="preserve">
          <source>The fat query</source>
          <target state="translated">La pregunta de la grasa</target>
        </trans-unit>
        <trans-unit id="9eb6dbc6b6ef5c5d8b4847ee0b1b967260b02889" translate="yes" xml:space="preserve">
          <source>The field name in the response that contains the DataID of the deleted node</source>
          <target state="translated">El nombre del campo en la respuesta que contiene el DataID del nodo eliminado</target>
        </trans-unit>
        <trans-unit id="3ca688eaa1e1f955641e421703e810ed047c2005" translate="yes" xml:space="preserve">
          <source>The field name in the response that contains the DataID of the removed node, or the path to the node removed from the connection</source>
          <target state="translated">El nombre del campo en la respuesta que contiene el DataID del nodo eliminado,o la ruta del nodo eliminado de la conexión</target>
        </trans-unit>
        <trans-unit id="ba191931e9ab489b27a9f33f746bef212888dc1a" translate="yes" xml:space="preserve">
          <source>The field name in the response that represents the connection</source>
          <target state="translated">El nombre del campo en la respuesta que representa la conexión</target>
        </trans-unit>
        <trans-unit id="a1b90e077151b889c8402ab5f53851a0ff440462" translate="yes" xml:space="preserve">
          <source>The field name in the response that represents the newly created edge</source>
          <target state="translated">El nombre del campo en la respuesta que representa el borde recién creado</target>
        </trans-unit>
        <trans-unit id="f9886e317b707740faab57f9ea8a72831a041943" translate="yes" xml:space="preserve">
          <source>The field name in the response that represents the parent of the connection</source>
          <target state="translated">El nombre del campo en la respuesta que representa el padre de la conexión</target>
        </trans-unit>
        <trans-unit id="9edac1a03bde2552ba82cb38e1a432234c65b349" translate="yes" xml:space="preserve">
          <source>The final data declaration is equivalent to the following plain GraphQL:</source>
          <target state="translated">La declaración final de datos es equivalente al siguiente GraphQL simple:</target>
        </trans-unit>
        <trans-unit id="cfe19d046a9f42c5d948f0aa018690d7ab173c0c" translate="yes" xml:space="preserve">
          <source>The first query was for a list of stories:</source>
          <target state="translated">La primera consulta fue para una lista de historias:</target>
        </trans-unit>
        <trans-unit id="097faf4942075ea29d235eddd8bf227710e8b427" translate="yes" xml:space="preserve">
          <source>The function returns a &lt;code&gt;Disposable&lt;/code&gt; on which you could call &lt;code&gt;dispose()&lt;/code&gt; to cancel the refetch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74925f12cc72e89c1f9fb2151f85c26276ebca60" translate="yes" xml:space="preserve">
          <source>The function returns a &lt;code&gt;Promise&lt;/code&gt; that resolves with an object containing data obtained from the query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84ecd22bdcea1bdfd0329a697bfab6ff7e6e06a6" translate="yes" xml:space="preserve">
          <source>The high-level flow of data through the compiler is represented in the following diagram:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d313c5be837c1f0e863c8d541edf651d250cb38" translate="yes" xml:space="preserve">
          <source>The initial set of variable values available to this component's fragments.</source>
          <target state="translated">El conjunto inicial de valores variables disponibles para los fragmentos de este componente.</target>
        </trans-unit>
        <trans-unit id="f7e74d01f7e6ff80db2700d9894a53e56b4a4d76" translate="yes" xml:space="preserve">
          <source>The most-used function is &lt;a href=&quot;#createcontainer-static-method&quot;&gt;&lt;code&gt;createContainer()&lt;/code&gt;&lt;/a&gt; which wraps components with data declarations.</source>
          <target state="translated">La funci&amp;oacute;n m&amp;aacute;s utilizada es &lt;a href=&quot;#createcontainer-static-method&quot;&gt; &lt;code&gt;createContainer()&lt;/code&gt; &lt;/a&gt; que envuelve componentes con declaraciones de datos.</target>
        </trans-unit>
        <trans-unit id="6618aeb6f5361bcac94a3181ad8b6a8339b0abc1" translate="yes" xml:space="preserve">
          <source>The mutation should take a single argument named &quot;input&quot;.</source>
          <target state="translated">La mutación debe tomar un solo argumento llamado &quot;input&quot;.</target>
        </trans-unit>
        <trans-unit id="a3c29d0940ced0048c0feb3200ee57be78138845" translate="yes" xml:space="preserve">
          <source>The new Relay Modern core is more light-weight and significantly faster than the previous version. It is redesigned to work with static queries, which allow us to push more work to build/compilation time. The Modern core is much smaller as a result of removing a lot of the complex features required for dynamic queries. The new core is also an order of magnitude faster in processing the response with an optimized parsing instruction set that is generated at build time. We no longer keep around tracking information needed for dynamic query generation, which drastically reduces the memory overhead of using Relay. This means more memory is left for making the UI feel responsive. Relay Modern also supports persisted queries, reducing the upload size of the request from the full query text to a simple id.</source>
          <target state="translated">El nuevo núcleo de Relay Modern es más ligero y significativamente más rápido que la versión anterior.Está rediseñado para trabajar con consultas estáticas,lo que nos permite empujar más trabajo al tiempo de construcción/compilación.El núcleo Moderno es mucho más pequeño como resultado de la eliminación de muchas de las complejas características requeridas para las consultas dinámicas.El nuevo núcleo es también un orden de magnitud más rápido en el procesamiento de la respuesta con un conjunto de instrucciones de análisis optimizado que se genera en el tiempo de construcción.Ya no nos mantenemos alrededor de la información de seguimiento necesaria para la generación de consultas dinámicas,lo que reduce drásticamente la sobrecarga de memoria del uso del Relé.Esto significa que queda más memoria para hacer que la interfaz de usuario se sienta sensible.Relay Modern también soporta consultas persistentes,reduciendo el tamaño de la carga de la solicitud del texto completo de la consulta a un simple id.</target>
        </trans-unit>
        <trans-unit id="bfe2b2be8025972db06fd439006437e8dca5cc49" translate="yes" xml:space="preserve">
          <source>The next logical approach is to use &lt;code&gt;render()&lt;/code&gt; as the means of initiating data-fetching. We could simply render the application once, see what data it needed, fetch that data, and render again. This sounds great, but the problem is that &lt;em&gt;components use data to figure out what to render!&lt;/em&gt; In other words, this would force data-fetching to be staged: first render the root and see what data it needs, then render its children and see what they need, all the way down the tree. If each stage incurs network request, rendering would require slow, serial roundtrips. We needed a way to determine all the data needs up-front or &lt;em&gt;statically&lt;/em&gt;.</source>
          <target state="translated">El siguiente enfoque l&amp;oacute;gico es utilizar &lt;code&gt;render()&lt;/code&gt; como medio para iniciar la b&amp;uacute;squeda de datos. Podr&amp;iacute;amos simplemente renderizar la aplicaci&amp;oacute;n una vez, ver qu&amp;eacute; datos necesitaba, recuperar esos datos y volver a renderizar. Esto suena genial, pero el problema es que los &lt;em&gt;componentes usan datos para descubrir qu&amp;eacute; renderizar.&lt;/em&gt; En otras palabras, esto obligar&amp;iacute;a a realizar la b&amp;uacute;squeda de datos: primero renderice la ra&amp;iacute;z y vea qu&amp;eacute; datos necesita, luego renderice sus hijos y vea lo que necesitan, hasta el final del &amp;aacute;rbol. Si cada etapa incurre en una solicitud de red, la renderizaci&amp;oacute;n requerir&amp;iacute;a viajes de ida y vuelta en serie lentos. Necesit&amp;aacute;bamos una forma de determinar todas las necesidades de datos por adelantado o de &lt;em&gt;forma est&amp;aacute;tica&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5b53cde5515b59c4d3a0131621b4782b7479a272" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;config&lt;/code&gt; parameter can be used to configure a &lt;code&gt;RANGE_ADD&lt;/code&gt; or other type of mutation, as per the &lt;code&gt;Relay.Mutation&lt;/code&gt; API. This tells Relay how to process the response.</source>
          <target state="translated">El par&amp;aacute;metro de &lt;code&gt;config&lt;/code&gt; uraci&amp;oacute;n opcional se puede utilizar para configurar un &lt;code&gt;RANGE_ADD&lt;/code&gt; u otro tipo de mutaci&amp;oacute;n, seg&amp;uacute;n la API &lt;code&gt;Relay.Mutation&lt;/code&gt; . Esto le dice a Relay c&amp;oacute;mo procesar la respuesta.</target>
        </trans-unit>
        <trans-unit id="3043696978b404d79349bb97fe99dc6847323bfb" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;config&lt;/code&gt; parameter can be used to configure a &lt;code&gt;RANGE_ADD&lt;/code&gt; or other type of mutation, similar to the &lt;code&gt;Relay.Mutation&lt;/code&gt; API.</source>
          <target state="translated">El par&amp;aacute;metro de &lt;code&gt;config&lt;/code&gt; uraci&amp;oacute;n opcional se puede utilizar para configurar un &lt;code&gt;RANGE_ADD&lt;/code&gt; u otro tipo de mutaci&amp;oacute;n, similar a la API &lt;code&gt;Relay.Mutation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a65fc26cbbecf69c5a0fe03882c96f57450485e1" translate="yes" xml:space="preserve">
          <source>The options listed above are not exhaustive. If you are aware of other routing solutions that work well with Relay Modern, &lt;a href=&quot;https://github.com/facebook/relay/issues/new&quot;&gt;please let us know&lt;/a&gt;.</source>
          <target state="translated">Las opciones enumeradas anteriormente no son exhaustivas. Si conoce otras soluciones de enrutamiento que funcionan bien con Relay Modern, &lt;a href=&quot;https://github.com/facebook/relay/issues/new&quot;&gt;h&amp;aacute;ganoslo saber&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e4e5487396fd07e7501191686f068ec10dba2a30" translate="yes" xml:space="preserve">
          <source>The pagination container expects the connection field to be annotated with a &lt;code&gt;@connection(key: ...)&lt;/code&gt; directive, where the &lt;code&gt;key&lt;/code&gt; is expected to be a unique identifier under the parent field type &lt;code&gt;User&lt;/code&gt;. A good practice could be &lt;code&gt;&amp;lt;ComponentName&amp;gt;_&amp;lt;fieldName | fieldAlias&amp;gt;&lt;/code&gt;. By default, Relay generates storage key based on the user-supplied &lt;code&gt;key&lt;/code&gt; and all non-filter variables of the field. Relay also provides an advanced feature &lt;code&gt;@connection(key: 'FriendsList_friends', filters:['orderBy', ...])&lt;/code&gt; that allows you to explicitly specify which variables should be used to generate the storage key. Particularly, if you write &lt;code&gt;@connection(key: ..., filters:[])&lt;/code&gt;, Relay will ignore all the variables.</source>
          <target state="translated">El contenedor de paginaci&amp;oacute;n espera que el campo de conexi&amp;oacute;n se anote con una &lt;code&gt;@connection(key: ...)&lt;/code&gt; , donde se espera que la &lt;code&gt;key&lt;/code&gt; sea ​​un identificador &amp;uacute;nico bajo el tipo de campo principal &lt;code&gt;User&lt;/code&gt; . Una buena pr&amp;aacute;ctica podr&amp;iacute;a ser &lt;code&gt;&amp;lt;ComponentName&amp;gt;_&amp;lt;fieldName | fieldAlias&amp;gt;&lt;/code&gt; . De forma predeterminada, Relay genera una clave de almacenamiento basada en la &lt;code&gt;key&lt;/code&gt; proporcionada por el usuario y todas las variables del campo sin filtro. Relay tambi&amp;eacute;n proporciona una funci&amp;oacute;n avanzada &lt;code&gt;@connection(key: 'FriendsList_friends', filters:['orderBy', ...])&lt;/code&gt; que le permite especificar expl&amp;iacute;citamente qu&amp;eacute; variables deben usarse para generar la clave de almacenamiento. En particular, si escribe &lt;code&gt;@connection(key: ..., filters:[])&lt;/code&gt; , Relay ignorar&amp;aacute; todas las variables.</target>
        </trans-unit>
        <trans-unit id="c30fe4d3ed3c530120fea7a2dc37c47a35768d8b" translate="yes" xml:space="preserve">
          <source>The plugin needs to understand your schema - &lt;code&gt;schemaData&lt;/code&gt; in the above snippet. There are two ways to get this information, depending on the GraphQL implementation.</source>
          <target state="translated">El complemento debe comprender su esquema: &lt;code&gt;schemaData&lt;/code&gt; en el fragmento anterior. Hay dos formas de obtener esta informaci&amp;oacute;n, seg&amp;uacute;n la implementaci&amp;oacute;n de GraphQL.</target>
        </trans-unit>
        <trans-unit id="486acc4ff0b4938f682801c80ee8b2d7dd1df93e" translate="yes" xml:space="preserve">
          <source>The premise of the example is that we want to use GraphQL to query for information about ships and factions in the original Star Wars trilogy.</source>
          <target state="translated">La premisa del ejemplo es que queremos usar GraphQL para buscar información sobre naves y facciones en la trilogía original de La Guerra de las Galaxias.</target>
        </trans-unit>
        <trans-unit id="1d83274a567a8154b4431388aa9d20ca339eaa3b" translate="yes" xml:space="preserve">
          <source>The primary way to declare data requirements is via &lt;code&gt;Relay.Container&lt;/code&gt; &amp;mdash; a higher-order React component that lets React components encode their data requirements.</source>
          <target state="translated">La forma principal de declarar los requisitos de datos es a trav&amp;eacute;s de &lt;code&gt;Relay.Container&lt;/code&gt; , un componente de React de orden superior que permite a los componentes de React codificar sus requisitos de datos.</target>
        </trans-unit>
        <trans-unit id="808db6b1b18bc85b64f9d26f1bddf44bf5968046" translate="yes" xml:space="preserve">
          <source>The primary way to declare data requirements is via &lt;code&gt;createFragmentContainer&lt;/code&gt; &amp;mdash; a higher-order React component that lets React components encode their data requirements.</source>
          <target state="translated">La forma principal de declarar los requisitos de datos es a trav&amp;eacute;s de &lt;code&gt;createFragmentContainer&lt;/code&gt; , un componente de React de orden superior que permite a los componentes de React codificar sus requisitos de datos.</target>
        </trans-unit>
        <trans-unit id="444774c5f652cc1826eed622e4a92e2c3f0e2e4b" translate="yes" xml:space="preserve">
          <source>The properties and methods listed below can be accessed on &lt;code&gt;this.props.relay&lt;/code&gt; from the wrapped React component.</source>
          <target state="translated">Se puede acceder a las propiedades y m&amp;eacute;todos enumerados a continuaci&amp;oacute;n en &lt;code&gt;this.props.relay&lt;/code&gt; desde el componente React envuelto.</target>
        </trans-unit>
        <trans-unit id="e0742e86024158a29e56877db07e441903db2b90" translate="yes" xml:space="preserve">
          <source>The purpose of the &lt;code&gt;@connection&lt;/code&gt; directive is to allow Relay to uniquely identify different connections under a parent type. The &lt;code&gt;@connection&lt;/code&gt; directive takes 2 arguments that help identify the connection:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9c7cfc24fbe1b8654256e17573b27f7600de24e" translate="yes" xml:space="preserve">
          <source>The query and response are traversed together, extracting the results into &lt;code&gt;Record&lt;/code&gt; objects which are added to a fresh &lt;code&gt;RecordSource&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fb555f6bd692507da566c1e62919372415cf8fc" translate="yes" xml:space="preserve">
          <source>The query is fetched from the network.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="595d44efe5adb2587c5aa09916b466fe64246e19" translate="yes" xml:space="preserve">
          <source>The query should request &quot;clientMutationId&quot; as a subselection.</source>
          <target state="translated">La consulta debe pedir &quot;clientMutationId&quot; como una subselección.</target>
        </trans-unit>
        <trans-unit id="fcd6ab3548bb5d3b4f5a6f857ba30959f05237cb" translate="yes" xml:space="preserve">
          <source>The reasoning is that if &lt;code&gt;babel-plugin-relay&lt;/code&gt; does not run before the &lt;code&gt;es2015-template-literals&lt;/code&gt; transform, it will not transform the Relay.QL template literals correctly. Also in Babel 6, you can&amp;rsquo;t control plugin order. So in React Native, where plugins in &lt;code&gt;.babelrc&lt;/code&gt; are loaded before the projects &lt;code&gt;.babelrc&lt;/code&gt;, it&amp;rsquo;s impossible to use the Babel Relay Plugin without overriding the entire transform list.</source>
          <target state="translated">El razonamiento es que si &lt;code&gt;babel-plugin-relay&lt;/code&gt; no se ejecuta antes de la &lt;code&gt;es2015-template-literals&lt;/code&gt; , no transformar&amp;aacute; correctamente los literales de la plantilla Relay.QL. Adem&amp;aacute;s, en Babel 6, no puede controlar el orden de los complementos. Entonces, en React Native, donde los complementos en &lt;code&gt;.babelrc&lt;/code&gt; se cargan antes que los proyectos &lt;code&gt;.babelrc&lt;/code&gt; , es imposible usar el complemento Babel Relay sin anular toda la lista de transformaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e29f8bf44ff95dd21005f2f7bb6eccf4ec45e350" translate="yes" xml:space="preserve">
          <source>The result of using the &lt;code&gt;graphql&lt;/code&gt; template tag is a &lt;code&gt;GraphQLTaggedNode&lt;/code&gt;; a runtime representation of the GraphQL document which can be used to define &lt;a href=&quot;query-renderer&quot;&gt;Query Renderers&lt;/a&gt;, &lt;a href=&quot;fragment-container&quot;&gt;Fragment Containers&lt;/a&gt;, &lt;a href=&quot;refetch-container&quot;&gt;Refetch Containers&lt;/a&gt;, &lt;a href=&quot;pagination-container&quot;&gt;Pagination Containers&lt;/a&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7803dad9067c5d50b3b4bf3ebacbfaade89ec277" translate="yes" xml:space="preserve">
          <source>The runtime automatically removes cached data that is no longer referenced, helping to reduce memory usage.</source>
          <target state="translated">El tiempo de ejecución elimina automáticamente los datos almacenados en caché que ya no están referenciados,lo que ayuda a reducir el uso de la memoria.</target>
        </trans-unit>
        <trans-unit id="7502725bdbb2c17f80ff460d7924092be097b33c" translate="yes" xml:space="preserve">
          <source>The schema described below will be used to demonstrate the functionality that a GraphQL server used by Relay should implement. The two core types are a faction and a ship in the Star Wars universe, where a faction has many ships associated with it. The schema below is the output of the GraphQL.js &lt;a href=&quot;https://github.com/graphql/graphql-js/blob/master/src/utilities/schemaPrinter.js&quot;&gt;&lt;code&gt;schemaPrinter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El esquema que se describe a continuaci&amp;oacute;n se utilizar&amp;aacute; para demostrar la funcionalidad que debe implementar un servidor GraphQL utilizado por Relay. Los dos tipos principales son una facci&amp;oacute;n y una nave en el universo de Star Wars, donde una facci&amp;oacute;n tiene muchas naves asociadas. El siguiente esquema es la salida de GraphQL.js &lt;a href=&quot;https://github.com/graphql/graphql-js/blob/master/src/utilities/schemaPrinter.js&quot;&gt; &lt;code&gt;schemaPrinter&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d1f4549e3c6f019d48ff8e76296ba821ef51f0c7" translate="yes" xml:space="preserve">
          <source>The second query refetched the information for one of those stories:</source>
          <target state="translated">La segunda consulta reestableció la información para una de esas historias:</target>
        </trans-unit>
        <trans-unit id="c7be7ec56f48de687831bf1d2b8ec095a4494b09" translate="yes" xml:space="preserve">
          <source>The set of IR documents forms a CompilerContext, which is then transformed and optimized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1ce127879727af2e2de7fc1ce77bce3c4f43c30" translate="yes" xml:space="preserve">
          <source>The solution to caching GraphQL is to normalize the hierarchical response into a flat collection of &lt;strong&gt;records&lt;/strong&gt;. Relay implements this cache as a map from IDs to records. Each record is a map from field names to field values. Records may also link to other records (allowing it to describe a cyclic graph), and these links are stored as a special value type that references back into the top-level map. With this approach each server record is stored &lt;em&gt;once&lt;/em&gt; regardless of how it is fetched.</source>
          <target state="translated">La soluci&amp;oacute;n para almacenar en cach&amp;eacute; GraphQL es normalizar la respuesta jer&amp;aacute;rquica en una colecci&amp;oacute;n plana de &lt;strong&gt;registros&lt;/strong&gt; . Relay implementa este cach&amp;eacute; como un mapa de ID a registros. Cada registro es un mapa de nombres de campo a valores de campo. Los registros tambi&amp;eacute;n pueden vincularse a otros registros (lo que le permite describir un gr&amp;aacute;fico c&amp;iacute;clico), y estos v&amp;iacute;nculos se almacenan como un tipo de valor especial que hace referencia al mapa de nivel superior. Con este enfoque, cada registro de servidor se almacena &lt;em&gt;una vez,&lt;/em&gt; independientemente de c&amp;oacute;mo se obtenga.</target>
        </trans-unit>
        <trans-unit id="2238db3c2972a72399f41299cdb2bb500270de90" translate="yes" xml:space="preserve">
          <source>The term &amp;lsquo;variables&amp;rsquo; here refers to the input to the server-side mutation, &lt;strong&gt;not&lt;/strong&gt; to the variables made available to this mutation's fragment builders.</source>
          <target state="translated">El t&amp;eacute;rmino 'variables' aqu&amp;iacute; se refiere a la entrada a la mutaci&amp;oacute;n del lado del servidor, &lt;strong&gt;no&lt;/strong&gt; a las variables disponibles para los constructores de fragmentos de esta mutaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="595203acdb212fda1237b7e11b4700b733a663ad" translate="yes" xml:space="preserve">
          <source>The three core assumptions that Relay makes about a GraphQL server are that it provides:</source>
          <target state="translated">Los tres supuestos básicos que Relevo hace sobre un servidor GraphQL son que proporciona:</target>
        </trans-unit>
        <trans-unit id="80a872fa92f56ed5c31e04d7d32ff502b8f3fab1" translate="yes" xml:space="preserve">
          <source>The two methods differ in that instead of sending a query that includes only fields missing from the client, &lt;code&gt;forceFetch&lt;/code&gt; sends a request to refetch each and every fragment. This ensures that the props for the component are freshly fetched from the server.</source>
          <target state="translated">Los dos m&amp;eacute;todos difieren en que en lugar de enviar una consulta que incluye solo los campos que faltan en el cliente, &lt;code&gt;forceFetch&lt;/code&gt; env&amp;iacute;a una solicitud para recuperar todos y cada uno de los fragmentos. Esto asegura que los accesorios para el componente se obtengan recientemente del servidor.</target>
        </trans-unit>
        <trans-unit id="1c4c5b50dcdfa847760bbbedcf52cb8e2ff536e6" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;photo&lt;/code&gt; field has changed; and therefore the record &lt;code&gt;2&lt;/code&gt; has also changed. And that's it. Nothing else in the &lt;em&gt;cache&lt;/em&gt; is affected. But clearly our &lt;em&gt;view&lt;/em&gt; needs to reflect the update: both instances of the author in the UI (as story author and comment author) need to show the new photo.</source>
          <target state="translated">El valor del campo de la &lt;code&gt;photo&lt;/code&gt; ha cambiado; y por lo tanto el registro &lt;code&gt;2&lt;/code&gt; tambi&amp;eacute;n ha cambiado. Y eso es. Nada m&amp;aacute;s en la &lt;em&gt;cach&amp;eacute;&lt;/em&gt; se ve afectado. Pero claramente nuestra &lt;em&gt;vista&lt;/em&gt; debe reflejar la actualizaci&amp;oacute;n: ambas instancias del autor en la interfaz de usuario (como autor de la historia y autor del comentario) deben mostrar la nueva foto.</target>
        </trans-unit>
        <trans-unit id="1232b961ddf31ef587aaa3e408f8aa3d44030a8f" translate="yes" xml:space="preserve">
          <source>Then after making edits to your application files, just run &lt;code&gt;yarn run relay&lt;/code&gt; to generate new files, or &lt;code&gt;yarn run relay -- --watch&lt;/code&gt; to run the compiler as a long-lived process which automatically generates new files whenever you save.</source>
          <target state="translated">Luego, despu&amp;eacute;s de realizar ediciones en los archivos de su aplicaci&amp;oacute;n, simplemente ejecute &lt;code&gt;yarn run relay&lt;/code&gt; para generar nuevos archivos, o &lt;code&gt;yarn run relay -- --watch&lt;/code&gt; para ejecutar el compilador como un proceso de larga duraci&amp;oacute;n que genera autom&amp;aacute;ticamente nuevos archivos cada vez que guarda.</target>
        </trans-unit>
        <trans-unit id="ef73d50cc222b2377dc0c600080db66496266f2f" translate="yes" xml:space="preserve">
          <source>Then after making edits to your application files, run &lt;code&gt;relay-compiler --src ./src --schema path/schema.graphql&lt;/code&gt; to generate new files, or &lt;code&gt;relay-compiler --src ./src --schema path/schema.graphql --watch&lt;/code&gt; to run the compiler as a long-lived process which automatically generates new files whenever you save.</source>
          <target state="translated">Luego, despu&amp;eacute;s de realizar modificaciones en los archivos de su aplicaci&amp;oacute;n, ejecute &lt;code&gt;relay-compiler --src ./src --schema path/schema.graphql&lt;/code&gt; para generar nuevos archivos, o &lt;code&gt;relay-compiler --src ./src --schema path/schema.graphql --watch&lt;/code&gt; para ejecutar el compilador como un proceso de larga duraci&amp;oacute;n que genera autom&amp;aacute;ticamente nuevos archivos cada vez que guarda.</target>
        </trans-unit>
        <trans-unit id="57a1f5033c269a68bc8794dc199b363a5c20cf8b" translate="yes" xml:space="preserve">
          <source>Then run &lt;code&gt;yarn run relay&lt;/code&gt; as set up before.</source>
          <target state="translated">Luego ejecute el &lt;code&gt;yarn run relay&lt;/code&gt; pasada de hilo como se configur&amp;oacute; anteriormente.</target>
        </trans-unit>
        <trans-unit id="45b952755c02df6dff5e78f4c86d5e7d04e71f78" translate="yes" xml:space="preserve">
          <source>Then, add &lt;code&gt;&quot;relay&quot;&lt;/code&gt; to the list of plugins in your .babelrc file. For example:</source>
          <target state="translated">Luego, agregue &lt;code&gt;&quot;relay&quot;&lt;/code&gt; a la lista de complementos en su archivo .babelrc. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="fa043b2e7bb17a1863151534669a087d81a912d9" translate="yes" xml:space="preserve">
          <source>There are a variety of solutions for keeping views up to date with a flattened cache. The approach that Relay takes is to maintain a mapping from each UI view to the set of IDs it references. In this case, the story view would subscribe to updates on the story (&lt;code&gt;1&lt;/code&gt;), the author (&lt;code&gt;2&lt;/code&gt;), and the comments (&lt;code&gt;3&lt;/code&gt; and any others). When writing data into the cache, Relay tracks which IDs are affected and notifies &lt;em&gt;only&lt;/em&gt; the views that are subscribed to those IDs. The affected views re-render, and unaffected views opt-out of re-rendering for better performance (Relay provides a safe but effective default &lt;code&gt;shouldComponentUpdate&lt;/code&gt;). Without this strategy, every view would re-render for even the tiniest change.</source>
          <target state="translated">Hay una variedad de soluciones para mantener las vistas actualizadas con un cach&amp;eacute; plano. El enfoque que toma Relay es mantener una asignaci&amp;oacute;n de cada vista de la interfaz de usuario al conjunto de ID a los que hace referencia. En este caso, la vista de la historia se suscribir&amp;aacute; a las actualizaciones de la historia ( &lt;code&gt;1&lt;/code&gt; ), el autor ( &lt;code&gt;2&lt;/code&gt; ) y los comentarios ( &lt;code&gt;3&lt;/code&gt; y cualquier otro). Al escribir datos en la cach&amp;eacute;, Relay rastrea qu&amp;eacute; ID se ven afectados y notifica &lt;em&gt;solo&lt;/em&gt; las vistas que est&amp;aacute;n suscritas a esos ID. Las vistas afectadas se vuelven a renderizar, y las vistas no afectadas optan por no volver a renderizar para un mejor rendimiento (Relay proporciona un &lt;code&gt;shouldComponentUpdate&lt;/code&gt; predeterminado seguro pero efectivo ). Sin esta estrategia, cada vista se volver&amp;iacute;a a renderizar incluso con el m&amp;aacute;s m&amp;iacute;nimo cambio.</target>
        </trans-unit>
        <trans-unit id="19964f32b18bdaa18426e6241372ad8f6c37030a" translate="yes" xml:space="preserve">
          <source>There is currently only one supported way to set the initial value of a variable dynamically: using global variables defined on the query that includes the fragment (or via &lt;code&gt;variables&lt;/code&gt; on the &lt;code&gt;QueryRenderer&lt;/code&gt;).</source>
          <target state="translated">Actualmente, solo hay una forma admitida de establecer el valor inicial de una variable de forma din&amp;aacute;mica: utilizando variables globales definidas en la consulta que incluye el fragmento (o mediante &lt;code&gt;variables&lt;/code&gt; en &lt;code&gt;QueryRenderer&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9d42709663369aca59bb9f2ca4e4c05e806c0bb6" translate="yes" xml:space="preserve">
          <source>Therefore a typical data flow is as follows - note that this flow is managed automatically by higher-level APIs such as React/Relay. First a component will lookup the results of a selector against a record source (e.g. the store's canonical source):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7009a3cd68807292f00dff361667a386bda72fff" translate="yes" xml:space="preserve">
          <source>Therefore, a normalized response cache for GraphQL requires processing payloads and queries in parallel. For example, the &lt;code&gt;photo&lt;/code&gt; field from above might be cached with a generated field name such as &lt;code&gt;photo_size(32)&lt;/code&gt; in order to uniquely identify the field and its argument values.</source>
          <target state="translated">Por lo tanto, una memoria cach&amp;eacute; de respuesta normalizada para GraphQL requiere procesar cargas &amp;uacute;tiles y consultas en paralelo. Por ejemplo, el campo de &lt;code&gt;photo&lt;/code&gt; de arriba podr&amp;iacute;a almacenarse en cach&amp;eacute; con un nombre de campo generado como &lt;code&gt;photo_size(32)&lt;/code&gt; para identificar de forma &amp;uacute;nica el campo y sus valores de argumento.</target>
        </trans-unit>
        <trans-unit id="046164a952e067900ed0105204b38b9650fcea6c" translate="yes" xml:space="preserve">
          <source>These are the methods and properties that the container will provide as &lt;code&gt;this.props.relay&lt;/code&gt; in the plain React component.</source>
          <target state="translated">Estos son los m&amp;eacute;todos y propiedades que el contenedor proporcionar&amp;aacute; como &lt;code&gt;this.props.relay&lt;/code&gt; en el componente React simple.</target>
        </trans-unit>
        <trans-unit id="5c8268547e740fb58d6875a6309af54d22de03e8" translate="yes" xml:space="preserve">
          <source>These features can be used in a couple of common scenarios: logging the client state for later inspection or interactively poking around the store from your browser's debugger.</source>
          <target state="translated">Estas características pueden utilizarse en un par de escenarios comunes:registrar el estado del cliente para una inspección posterior o buscar interactivamente en la tienda desde el depurador de su navegador.</target>
        </trans-unit>
        <trans-unit id="1195afffc2435cbe5e7dac1ec74b6de7550b1719" translate="yes" xml:space="preserve">
          <source>Thinking In Relay</source>
          <target state="translated">Pensando en el relevo</target>
        </trans-unit>
        <trans-unit id="9e48341865426d82a3f397c5e1d57bc38bb5c5ba" translate="yes" xml:space="preserve">
          <source>Thinking in GraphQL</source>
          <target state="translated">Pensando en GraphQL</target>
        </trans-unit>
        <trans-unit id="587e48e73d1fbcb3548410dad36aa1874f0eaaf5" translate="yes" xml:space="preserve">
          <source>This callback prop is called as the various events of data resolution occur.</source>
          <target state="translated">Este apoyo de retrollamada se llama como los varios eventos de resolución de datos que ocurren.</target>
        </trans-unit>
        <trans-unit id="83089afd24bef13575f73fb96b2667f2399b79e8" translate="yes" xml:space="preserve">
          <source>This callback prop is called as the various events of data resolution occurs.</source>
          <target state="translated">Este apoyo de retrollamada se llama como los varios eventos de resolución de datos que ocurren.</target>
        </trans-unit>
        <trans-unit id="a79b5038ef8c2e765648d6ba19aa3760d3f3486d" translate="yes" xml:space="preserve">
          <source>This can be upgraded by conditionally rendering a &lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt; which will load the data once it is rendered. The code overhead of doing this is dramatically reduced with the new API.</source>
          <target state="translated">Esto se puede actualizar renderizando condicionalmente un &lt;a href=&quot;query-renderer&quot;&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;/a&gt; que cargar&amp;aacute; los datos una vez que se rendericen. La sobrecarga de c&amp;oacute;digo de hacer esto se reduce dr&amp;aacute;sticamente con la nueva API.</target>
        </trans-unit>
        <trans-unit id="6aa6b4ce32c479ca8e376d46b66428bac2d82d69" translate="yes" xml:space="preserve">
          <source>This can be upgraded by using a &lt;a href=&quot;refetch-container&quot;&gt;&lt;code&gt;RefetchContainer&lt;/code&gt;&lt;/a&gt; which allows you to specify the exact query to use to fetch the new data.</source>
          <target state="translated">Esto se puede actualizar utilizando un &lt;a href=&quot;refetch-container&quot;&gt; &lt;code&gt;RefetchContainer&lt;/code&gt; &lt;/a&gt; que le permite especificar la consulta exacta que se utilizar&amp;aacute; para obtener los nuevos datos.</target>
        </trans-unit>
        <trans-unit id="0fa24150c2aafefe95a09ecc07832206180f13d5" translate="yes" xml:space="preserve">
          <source>This causes a generated file to appear in &lt;code&gt;./__generated__/MyComponent.graphql&lt;/code&gt;, with both runtime artifacts (which help to read and write from the Relay Store) and &lt;a href=&quot;https://flow.org/&quot;&gt;Flow types&lt;/a&gt; to help you write type-safe code.</source>
          <target state="translated">Esto hace que un archivo generado aparezca en &lt;code&gt;./__generated__/MyComponent.graphql&lt;/code&gt; , con artefactos en tiempo de ejecuci&amp;oacute;n (que ayudan a leer y escribir desde Relay Store) y &lt;a href=&quot;https://flow.org/&quot;&gt;tipos de flujo&lt;/a&gt; para ayudarlo a escribir c&amp;oacute;digo seguro.</target>
        </trans-unit>
        <trans-unit id="a9ea7bef6484a7c1cbe254ffda535079f7700daf" translate="yes" xml:space="preserve">
          <source>This document, together with &lt;a href=&quot;runtime-architecture&quot;&gt;Runtime Architecture&lt;/a&gt; and &lt;a href=&quot;compiler-architecture&quot;&gt;Compiler Architecture&lt;/a&gt;, describes the high-level architecture of Relay &quot;Modern&quot;. The intended audience includes developers interested in contributing to Relay, developers hoping to utilize the building blocks of Relay to create higher-level APIs, and anyone interested in understanding more about Relay internals. For developers wanting to learn more about &lt;em&gt;using&lt;/em&gt; Relay to build products, the other sections might be more helpful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74dbf4caec721ba1ccc2a6b88d7ee594184d8bbc" translate="yes" xml:space="preserve">
          <source>This example demonstrates all three of these assumptions.</source>
          <target state="translated">Este ejemplo demuestra estos tres supuestos.</target>
        </trans-unit>
        <trans-unit id="9479e9ba5c11bcfea7c69c38843fdeb8dbbdfea5" translate="yes" xml:space="preserve">
          <source>This example is not comprehensive, but it is designed to quickly introduce these core assumptions, to provide some context before diving into the more detailed specification of the library.</source>
          <target state="translated">Este ejemplo no es exhaustivo,pero está diseñado para introducir rápidamente estos supuestos básicos,para proporcionar algún contexto antes de sumergirse en la especificación más detallada de la biblioteca.</target>
        </trans-unit>
        <trans-unit id="f185525936893aacea00cf71a3224c86985f3df6" translate="yes" xml:space="preserve">
          <source>This fat query looks like any other GraphQL query, with one important distinction. We know some of these fields to be non-scalar (like &lt;code&gt;friendEdge&lt;/code&gt; and &lt;code&gt;friends&lt;/code&gt;) but notice that we have not named any of their children by way of a subquery. In this way, we indicate to Relay that &lt;em&gt;anything&lt;/em&gt; under those non-scalar fields may change as a result of this mutation.</source>
          <target state="translated">Esta consulta amplia se parece a cualquier otra consulta GraphQL, con una distinci&amp;oacute;n importante. Sabemos que algunos de estos campos no son escalares (como &lt;code&gt;friendEdge&lt;/code&gt; y &lt;code&gt;friends&lt;/code&gt; ), pero notamos que no hemos nombrado a ninguno de sus hijos mediante una subconsulta. De esta manera, le indicamos a Relay que &lt;em&gt;cualquier cosa&lt;/em&gt; debajo de esos campos no escalares puede cambiar como resultado de esta mutaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="81b1261e20f66bafeb445251ddc3d3efb2158432" translate="yes" xml:space="preserve">
          <source>This fresh &lt;code&gt;RecordSource&lt;/code&gt; would then be published to the store:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61564f3549d718187ddfeb22e3808eafa802c07e" translate="yes" xml:space="preserve">
          <source>This gets converted into a &quot;lazy&quot; require of a generated file:</source>
          <target state="translated">Esto se convierte en un requerimiento &quot;perezoso&quot; de un archivo generado:</target>
        </trans-unit>
        <trans-unit id="ea59f490525a696053dec758108ce2a68882aa64" translate="yes" xml:space="preserve">
          <source>This gets converted into an immediately-invoked function:</source>
          <target state="translated">Esto se convierte en una función inmediatamente invocada:</target>
        </trans-unit>
        <trans-unit id="01abddd8ac86ef6eb75568464191008b4ca72daa" translate="yes" xml:space="preserve">
          <source>This installs the bin script &lt;code&gt;relay-compiler&lt;/code&gt; in your node_modules folder. It's recommended to run this from a yarn/npm script by adding a script to your &lt;code&gt;package.json&lt;/code&gt; file:</source>
          <target state="translated">Esto instala el &lt;code&gt;relay-compiler&lt;/code&gt; script bin en su carpeta node_modules. Se recomienda ejecutar esto desde un script yarn / npm agregando un script a su archivo &lt;code&gt;package.json&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="11a6b3482924983de73327e990f1793b755a9291" translate="yes" xml:space="preserve">
          <source>This is a specialization of the general-purpose refetch container that is tailored for the common scenario of paginating through a collection of items by fetching successively more pages of data. See &lt;a href=&quot;pagination-container&quot;&gt;&lt;code&gt;createPaginationContainer&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">Se trata de una especializaci&amp;oacute;n del contenedor de recuperaci&amp;oacute;n de uso general que se adapta al escenario com&amp;uacute;n de paginaci&amp;oacute;n a trav&amp;eacute;s de una colecci&amp;oacute;n de elementos obteniendo sucesivamente m&amp;aacute;s p&amp;aacute;ginas de datos. Consulte &lt;a href=&quot;pagination-container&quot;&gt; &lt;code&gt;createPaginationContainer&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="d4db8c43d3a16c260f2c767a658dfa356471e9a7" translate="yes" xml:space="preserve">
          <source>This is an array of events received so far (see &lt;code&gt;ReadyStateEvent&lt;/code&gt; below).</source>
          <target state="translated">Esta es una matriz de eventos recibidos hasta ahora (consulte &lt;code&gt;ReadyStateEvent&lt;/code&gt; a continuaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="4d0129df19cfd202bd9745fb3f722df875299901" translate="yes" xml:space="preserve">
          <source>This is an instance of &lt;code&gt;Error&lt;/code&gt; if there is a failure. Otherwise, this is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Esta es una instancia de &lt;code&gt;Error&lt;/code&gt; si hay una falla. De lo contrario, esto es &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69752386ee76a26381a40e623b5c2ca8480c36c2" translate="yes" xml:space="preserve">
          <source>This is only a simple example: in reality the cache must handle one-to-many associations and pagination (among other things).</source>
          <target state="translated">Este es sólo un ejemplo simple:en realidad el caché debe manejar asociaciones y paginación de uno a muchos (entre otras cosas).</target>
        </trans-unit>
        <trans-unit id="7b3c087bb51f2da841015c33dcb71977fe0212c4" translate="yes" xml:space="preserve">
          <source>This is the general constructor for creating &lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; instances with optional &lt;code&gt;files&lt;/code&gt;, &lt;code&gt;callbacks&lt;/code&gt; and &lt;code&gt;collisionKey&lt;/code&gt; arguments.</source>
          <target state="translated">Este es el constructor general para crear instancias de &lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; con &lt;code&gt;files&lt;/code&gt; opcionales , &lt;code&gt;callbacks&lt;/code&gt; y argumentos &lt;code&gt;collisionKey&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab97009210eccb9f3d5c90eae312fb3cfd66a060" translate="yes" xml:space="preserve">
          <source>This is the lowest level of abstraction at which product code may deal with mutations in Relay, and it corresponds to the mutation operation (&quot;a write followed by a fetch&quot;) described in &lt;a href=&quot;https://facebook.github.io/relay/graphql/mutations.htm&quot;&gt;the GraphQL Specification&lt;/a&gt;. You specify the mutation, the inputs, and the query.</source>
          <target state="translated">Este es el nivel m&amp;aacute;s bajo de abstracci&amp;oacute;n en el que el c&amp;oacute;digo de producto puede lidiar con mutaciones en Relay y corresponde a la operaci&amp;oacute;n de mutaci&amp;oacute;n (&quot;una escritura seguida de una b&amp;uacute;squeda&quot;) descrita en &lt;a href=&quot;https://facebook.github.io/relay/graphql/mutations.htm&quot;&gt;la Especificaci&amp;oacute;n GraphQL&lt;/a&gt; . Usted especifica la mutaci&amp;oacute;n, las entradas y la consulta.</target>
        </trans-unit>
        <trans-unit id="71da35a87d2df91e0c17e3a05dce16632307fd68" translate="yes" xml:space="preserve">
          <source>This is true when &lt;em&gt;all&lt;/em&gt; data requirements are ready for rendering.</source>
          <target state="translated">Esto es cierto cuando &lt;em&gt;todos&lt;/em&gt; los requisitos de datos est&amp;aacute;n listos para renderizarse.</target>
        </trans-unit>
        <trans-unit id="bb078cd30db73d188c6edca1d054b3822d3838fd" translate="yes" xml:space="preserve">
          <source>This is true when the subset of data required for rendering is ready.</source>
          <target state="translated">Esto es así cuando el subconjunto de datos necesarios para la representación está listo.</target>
        </trans-unit>
        <trans-unit id="12c08d7a8f7eb77071004758dca7ab969bb7d7cb" translate="yes" xml:space="preserve">
          <source>This is where GraphQL comes into play. Components specify one or multiple GraphQL fragments for some of their props describing their data requirements. Each GraphQL fragment has a unique name within an application which allows us to determine the query needed to fetch the full query tree in a build step and load all the required data in a single network request efficiently at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40d6df25c7774cfef7c19fa68f7bcd72dbf71d40" translate="yes" xml:space="preserve">
          <source>This may be helpful to reduce redundant fragments when dealing with nested or recursive data within a single Component.</source>
          <target state="translated">Esto puede ser útil para reducir los fragmentos redundantes cuando se trata de datos anidados o recursivos dentro de un solo Componente.</target>
        </trans-unit>
        <trans-unit id="7d2596643eab3080985621c3e255ffe66dd1fb15" translate="yes" xml:space="preserve">
          <source>This method can optionally return a promise in order to facilitate proper error propagation.</source>
          <target state="translated">Este método puede opcionalmente devolver una promesa para facilitar la correcta propagación de los errores.</target>
        </trans-unit>
        <trans-unit id="a5a0085a036246ce072609380ef834dd25b9e599" translate="yes" xml:space="preserve">
          <source>This method is also called after the partial set of variables from &lt;code&gt;setVariables&lt;/code&gt; has been applied. The variables returned are used to populate the fragments.</source>
          <target state="translated">Este m&amp;eacute;todo tambi&amp;eacute;n se llama despu&amp;eacute;s de que se haya aplicado el conjunto parcial de variables de &lt;code&gt;setVariables&lt;/code&gt; . Las variables devueltas se utilizan para completar los fragmentos.</target>
        </trans-unit>
        <trans-unit id="0603bfcf101a33a1c1eed64335628df20ea3aa9c" translate="yes" xml:space="preserve">
          <source>This method receives an array of queries (instead of a single query) in order to facilitate batching queries to improve network efficiency.</source>
          <target state="translated">Este método recibe una serie de consultas (en lugar de una sola consulta)a fin de facilitar las consultas por lotes para mejorar la eficiencia de la red.</target>
        </trans-unit>
        <trans-unit id="a87ccc42db63f2f52eeae29ff4feceb34933d42f" translate="yes" xml:space="preserve">
          <source>This should be upgraded to use a &lt;a href=&quot;pagination-container&quot;&gt;&lt;code&gt;PaginationContainer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esto deber&amp;iacute;a actualizarse para usar un &lt;a href=&quot;pagination-container&quot;&gt; &lt;code&gt;PaginationContainer&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a7bf020a941d10f70ab32528d56d8597a05d0895" translate="yes" xml:space="preserve">
          <source>This snippet configures &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; to render &lt;code&gt;ProfilePicture&lt;/code&gt; within a &lt;code&gt;ScrollView&lt;/code&gt; component as soon as data is ready.</source>
          <target state="translated">Este fragmento configura &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; para representar &lt;code&gt;ProfilePicture&lt;/code&gt; dentro de un componente &lt;code&gt;ScrollView&lt;/code&gt; tan pronto como los datos &lt;strong&gt;est&amp;eacute;n&lt;/strong&gt; listos.</target>
        </trans-unit>
        <trans-unit id="70500d59ecc10d7cea4a148a7386cb41d2c4d0f0" translate="yes" xml:space="preserve">
          <source>This snippet configures &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; to render the &quot;Loading...&quot; text whenever it needs to fetch data.</source>
          <target state="translated">Este fragmento configura &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; para que &lt;strong&gt;muestre&lt;/strong&gt; el texto &quot;Cargando ...&quot; siempre que necesite obtener datos.</target>
        </trans-unit>
        <trans-unit id="00b1b28bd3be2fa7e76055fd5d3f672dc5d7fda8" translate="yes" xml:space="preserve">
          <source>This will create a series of &lt;code&gt;__generated__&lt;/code&gt; directories that are co-located with the corresponding files containing &lt;code&gt;graphql&lt;/code&gt; tags.</source>
          <target state="translated">Esto crear&amp;aacute; una serie de directorios &lt;code&gt;__generated__&lt;/code&gt; que se ubicar&amp;aacute;n junto con los archivos correspondientes que contienen etiquetas &lt;code&gt;graphql&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a737ccc7b583949623cef676beba937c7dc28a69" translate="yes" xml:space="preserve">
          <source>This will inform &lt;code&gt;Relay.QL&lt;/code&gt; that this particular field is an array. This will also allow you to use a plural name for the fragment (i.e. &lt;code&gt;bars&lt;/code&gt; instead of &lt;code&gt;bar&lt;/code&gt;).</source>
          <target state="translated">Esto informar&amp;aacute; a &lt;code&gt;Relay.QL&lt;/code&gt; que este campo en particular es una matriz. Esto tambi&amp;eacute;n le permitir&amp;aacute; usar un nombre en plural para el fragmento (es decir, &lt;code&gt;bars&lt;/code&gt; lugar de &lt;code&gt;bar&lt;/code&gt; ra ).</target>
        </trans-unit>
        <trans-unit id="2dcccc952811069ad73564d196e2e6f3b0ec664d" translate="yes" xml:space="preserve">
          <source>This would produce three generated files, and two &lt;code&gt;__generated__&lt;/code&gt; directories:</source>
          <target state="translated">Esto producir&amp;iacute;a tres archivos generados y dos directorios &lt;code&gt;__generated__&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0e7c9a4f20eb8494e45f8c514abfa27440507df5" translate="yes" xml:space="preserve">
          <source>To add a new paginating relay container</source>
          <target state="translated">Para añadir un nuevo contenedor de relevo de paginación</target>
        </trans-unit>
        <trans-unit id="4afe3d419de5a0a7685601e4998733289b1a991a" translate="yes" xml:space="preserve">
          <source>To add a new relay container</source>
          <target state="translated">Para añadir un nuevo contenedor de retransmisión</target>
        </trans-unit>
        <trans-unit id="da88d2c6beb30dbb3f7e5c35d288e84155365752" translate="yes" xml:space="preserve">
          <source>To add a new relay container that has changing data requirements</source>
          <target state="translated">Para añadir un nuevo contenedor de retransmisión que tiene requisitos de datos cambiantes</target>
        </trans-unit>
        <trans-unit id="b78283d8fe106afc67ec588e2762311c4df0a3bd" translate="yes" xml:space="preserve">
          <source>To add a new root for relay components</source>
          <target state="translated">Para añadir una nueva raíz para los componentes del relé</target>
        </trans-unit>
        <trans-unit id="2cb466b85716cc24434b2a68c68d7668bbaceabb" translate="yes" xml:space="preserve">
          <source>To call this method on the underlying component, first provide a &lt;code&gt;componentRef&lt;/code&gt; function to the Relay container. This differs from providing a &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt;&lt;code&gt;ref&lt;/code&gt;&lt;/a&gt; function which would provide a reference to the Relay container itself, not the underlying React Component.</source>
          <target state="translated">Para llamar a este m&amp;eacute;todo en el componente subyacente, primero proporcione una funci&amp;oacute;n &lt;code&gt;componentRef&lt;/code&gt; al contenedor Relay. Esto difiere de proporcionar una funci&amp;oacute;n de &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt; &lt;code&gt;ref&lt;/code&gt; erencia&lt;/a&gt; que proporcionar&amp;iacute;a una referencia al contenedor Relay en s&amp;iacute;, no al componente React subyacente.</target>
        </trans-unit>
        <trans-unit id="65aa58a75ec1e39e9166d34dcff5d186dbe23e3a" translate="yes" xml:space="preserve">
          <source>To commit a mutation</source>
          <target state="translated">Para cometer una mutación</target>
        </trans-unit>
        <trans-unit id="89b06193bd6c9ce7d1f792c95362915c77c9675f" translate="yes" xml:space="preserve">
          <source>To create an environment instance in Relay Modern, use the &lt;code&gt;RelayModernEnvironment&lt;/code&gt; class:</source>
          <target state="translated">Para crear una instancia de entorno en Relay Modern, use la clase &lt;code&gt;RelayModernEnvironment&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="79a86851c1fad2bbe848185a0d8955e026baa0f4" translate="yes" xml:space="preserve">
          <source>To enable &lt;a href=&quot;relay-compat&quot;&gt;compatibility mode&lt;/a&gt;, &lt;code&gt;relay-compiler&lt;/code&gt; enforces a simple naming convention for your queries. Queries must be named as &lt;code&gt;&amp;lt;FileName&amp;gt;&amp;lt;OperationType&amp;gt;&lt;/code&gt;, where &quot;&amp;lt;OperationType&amp;gt;&quot; is one of &quot;Query&quot;, &quot;Mutation&quot;, or &quot;Subscription&quot;. The query above is named &lt;code&gt;ExampleQuery&lt;/code&gt; so should be placed in &lt;code&gt;Example.js&lt;/code&gt;.</source>
          <target state="translated">Para habilitar el &lt;a href=&quot;relay-compat&quot;&gt;modo de compatibilidad&lt;/a&gt; , &lt;code&gt;relay-compiler&lt;/code&gt; aplica una convenci&amp;oacute;n de nomenclatura simple para sus consultas. Las consultas deben denominarse &lt;code&gt;&amp;lt;FileName&amp;gt;&amp;lt;OperationType&amp;gt;&lt;/code&gt; , donde &quot;&amp;lt;OperationType&amp;gt;&quot; es uno de &quot;Consulta&quot;, &quot;Mutaci&amp;oacute;n&quot; o &quot;Suscripci&amp;oacute;n&quot;. La consulta anterior se llama &lt;code&gt;ExampleQuery&lt;/code&gt; , por lo que debe colocarse en &lt;code&gt;Example.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03ec37246eca3b43ea7ac7f76a27cbf7c5cb3d8b" translate="yes" xml:space="preserve">
          <source>To execute this code, Relay needs access to the schema - which can be too large to bundle inside the application. Instead, these &lt;code&gt;Relay.QL&lt;/code&gt; template expressions are transpiled into JavaScript descriptions via the &lt;code&gt;babel-relay-plugin&lt;/code&gt;. This schema information allows Relay to understand things like the types of field arguments, which fields are connections or lists, and how to efficiently refetch records from the server.</source>
          <target state="translated">Para ejecutar este c&amp;oacute;digo, Relay necesita acceso al esquema, que puede ser demasiado grande para agruparse dentro de la aplicaci&amp;oacute;n. En su lugar, estas &lt;code&gt;Relay.QL&lt;/code&gt; plantilla de Relay.QL se transpilan en descripciones de JavaScript a trav&amp;eacute;s del &lt;code&gt;babel-relay-plugin&lt;/code&gt; . Esta informaci&amp;oacute;n de esquema permite a Relay comprender cosas como los tipos de argumentos de campo, qu&amp;eacute; campos son conexiones o listas y c&amp;oacute;mo recuperar registros del servidor de manera eficiente.</target>
        </trans-unit>
        <trans-unit id="6be87ed7f838f24ecfdb363ea58800de8f9dfbc1" translate="yes" xml:space="preserve">
          <source>To force fetch a component</source>
          <target state="translated">Para forzar la obtención de un componente</target>
        </trans-unit>
        <trans-unit id="e7e54aa101836df2ce7d5415960a239df67598f0" translate="yes" xml:space="preserve">
          <source>To get started building Relay applications, you will need three things:</source>
          <target state="translated">Para empezar a construir aplicaciones de relevo,necesitarás tres cosas:</target>
        </trans-unit>
        <trans-unit id="45fa77bbc0446347a81f6d5b23fa090e9c9d6856" translate="yes" xml:space="preserve">
          <source>To improve perceived responsiveness, you may wish to perform an &quot;optimistic update&quot;, in which the client immediately updates to reflect the anticipated new value even before the response from the server has come back. The simplest way to do this is by providing an &lt;code&gt;optimisticResponse&lt;/code&gt; and adding it to the &lt;code&gt;config&lt;/code&gt; that we pass into &lt;code&gt;commitMutation&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cf9a932987c095688d86461efe0eedbdc22d8b7" translate="yes" xml:space="preserve">
          <source>To improve perceived responsiveness, you may wish to perform an &quot;optimistic update&quot;, in which the client immediately updates to reflect the anticipated new value even before the response from the server has come back. We do this by providing an &lt;code&gt;optimisticResponse&lt;/code&gt; and adding it to the &lt;code&gt;config&lt;/code&gt; that we pass into &lt;code&gt;commitMutation&lt;/code&gt;:</source>
          <target state="translated">Para mejorar la capacidad de respuesta percibida, es posible que desee realizar una &quot;actualizaci&amp;oacute;n optimista&quot;, en la que el cliente se actualiza inmediatamente para reflejar el nuevo valor anticipado incluso antes de que haya regresado la respuesta del servidor. Hacemos esto proporcionando una &lt;code&gt;commitMutation&lt;/code&gt; &lt;code&gt;optimisticResponse&lt;/code&gt; y agreg&amp;aacute;ndola a la &lt;code&gt;config&lt;/code&gt; uraci&amp;oacute;n que pasamos a commitMutation :</target>
        </trans-unit>
        <trans-unit id="bebfedde59ec9253c14e34d042772cb6d964fce0" translate="yes" xml:space="preserve">
          <source>To paginate through a connection</source>
          <target state="translated">Para paginar a través de una conexión</target>
        </trans-unit>
        <trans-unit id="b6033100545414ff9dedc545a14635be362e73ed" translate="yes" xml:space="preserve">
          <source>To read from the cache we can walk a query and resolve each field. But wait: that sounds &lt;em&gt;exactly&lt;/em&gt; like what a GraphQL server does when it processes a query. And it is! Reading from the cache is a special case of an executor where a) there's no need for user-defined field functions because all results come from a fixed data structure and b) results are always synchronous &amp;mdash; we either have the data cached or we don't.</source>
          <target state="translated">Para leer desde la cach&amp;eacute; podemos recorrer una consulta y resolver cada campo. Pero espere: eso suena &lt;em&gt;exactamente&lt;/em&gt; como lo que hace un servidor GraphQL cuando procesa una consulta. &amp;iexcl;Y es! La lectura del cach&amp;eacute; es un caso especial de un ejecutor donde a) no hay necesidad de funciones de campo definidas por el usuario porque todos los resultados provienen de una estructura de datos fija yb) los resultados son siempre sincr&amp;oacute;nicos: o tenemos los datos en cach&amp;eacute; o no t.</target>
        </trans-unit>
        <trans-unit id="e168ce7f96f9f96537f762eb07d59ca6c422e92d" translate="yes" xml:space="preserve">
          <source>To start, let's build the plain React version of a &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; component that displays the user's profile photo and a slider to adjust the photo's size.</source>
          <target state="translated">Para empezar, creemos la versi&amp;oacute;n simple de React de un componente &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; que muestra la foto de perfil del usuario y un control deslizante para ajustar el tama&amp;ntilde;o de la foto.</target>
        </trans-unit>
        <trans-unit id="fccbd6622bb8847d0929fc4851e9ea2b575ead73" translate="yes" xml:space="preserve">
          <source>To start, let's build the plain React version of a &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; component that displays the text and completion status of a &lt;code&gt;Todo&lt;/code&gt;.</source>
          <target state="translated">Para comenzar, construyamos la versi&amp;oacute;n React simple de un componente &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; que muestra el texto y el estado de finalizaci&amp;oacute;n de un &lt;code&gt;Todo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ac483e211ecf7cd1ac9ea59c0478cde75088452" translate="yes" xml:space="preserve">
          <source>To start, let's build the plain React version of a hypothetical &lt;code&gt;&amp;lt;TodoItem /&amp;gt;&lt;/code&gt; component that displays the text and completion status of a &lt;code&gt;Todo&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11ddeec9a3447606ae9ab043cf0ed78d26a53e7b" translate="yes" xml:space="preserve">
          <source>To update a variable for my component</source>
          <target state="translated">Para actualizar una variable de mi componente</target>
        </trans-unit>
        <trans-unit id="3f1189857789cd58adacaebeec728b8e0afcce44" translate="yes" xml:space="preserve">
          <source>To use the Relay Compiler, you need either a .graphql or .json GraphQL schema file, describing your GraphQL server's API. Typically these files are local representations of a server source of truth and are not edited directly. For example, we might have a &lt;code&gt;schema.graphql&lt;/code&gt; like:</source>
          <target state="translated">Para usar el Relay Compiler, necesita un archivo de esquema GraphQL .graphql o .json, que describa la API de su servidor GraphQL. Normalmente, estos archivos son representaciones locales de una fuente de verdad del servidor y no se editan directamente. Por ejemplo, podr&amp;iacute;amos tener un &lt;code&gt;schema.graphql&lt;/code&gt; como:</target>
        </trans-unit>
        <trans-unit id="9be854f285feec3a5f3620acb9820d1d2c32fbd0" translate="yes" xml:space="preserve">
          <source>To use these pieces to construct a full-fledged GraphQL query that we can send to the server to fetch data, we need to use the &lt;strong&gt;Relay.RootContainer&lt;/strong&gt;.</source>
          <target state="translated">Para usar estas piezas para construir una consulta GraphQL completa que podamos enviar al servidor para obtener datos, necesitamos usar &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="0cef4df4d340703594fc301669e90430e959441b" translate="yes" xml:space="preserve">
          <source>Transforms</source>
          <target state="translated">Transforms</target>
        </trans-unit>
        <trans-unit id="2701a94c0eb55cbd958a87dff3e959673ff1bf53" translate="yes" xml:space="preserve">
          <source>Tutorial</source>
          <target state="translated">Tutorial</target>
        </trans-unit>
        <trans-unit id="7634bede4230d278e0e78179b1dcae8473d4d33a" translate="yes" xml:space="preserve">
          <source>Types for working with queries and their results include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f77a5658e80339ebafab29498f8ee4b43724b2e0" translate="yes" xml:space="preserve">
          <source>Typical Relay Classic code:</source>
          <target state="translated">Típico código de Relevo Clásico:</target>
        </trans-unit>
        <trans-unit id="95e39abda529007d77cea645d9c98a79ceba0779" translate="yes" xml:space="preserve">
          <source>Typical old code:</source>
          <target state="translated">Típico código antiguo:</target>
        </trans-unit>
        <trans-unit id="5ea4501b4b61baf5dd246de000e69cf2c83ec128" translate="yes" xml:space="preserve">
          <source>Typically you will not need to import your generated definitions. The &lt;a href=&quot;babel-plugin-relay&quot;&gt;Relay Babel plugin&lt;/a&gt; will convert the &lt;code&gt;graphql&lt;/code&gt; literals to &lt;code&gt;require()&lt;/code&gt; the generated files.</source>
          <target state="translated">Por lo general, no necesitar&amp;aacute; importar las definiciones generadas. El &lt;a href=&quot;babel-plugin-relay&quot;&gt;complemento Relay Babel&lt;/a&gt; convertir&amp;aacute; los literales &lt;code&gt;graphql&lt;/code&gt; para &lt;code&gt;require()&lt;/code&gt; los archivos generados.</target>
        </trans-unit>
        <trans-unit id="fe82c32a588b217dd555d86acd7cd881dee1801f" translate="yes" xml:space="preserve">
          <source>Typically you will not need to import your generated definitions. The &lt;a href=&quot;installation-and-setup#setup-babel-plugin-relay&quot;&gt;Relay Babel plugin&lt;/a&gt; will then convert the &lt;code&gt;graphql&lt;/code&gt; literals in your code into &lt;code&gt;require()&lt;/code&gt; calls for the generated files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43a4e34531ca0764965880501d0f8c89a74d18d5" translate="yes" xml:space="preserve">
          <source>Underneath the hood, the default network layer uses &lt;code&gt;fetch&lt;/code&gt; (&lt;a href=&quot;https://fetch.spec.whatwg.org&quot;&gt;Living Standard&lt;/a&gt;). The constructor for &lt;code&gt;Relay.DefaultNetworkLayer&lt;/code&gt; takes an optional second argument that accepts any valid initialization property that &lt;code&gt;fetch&lt;/code&gt; accepts.</source>
          <target state="translated">Debajo del cap&amp;oacute;, la capa de red predeterminada usa &lt;code&gt;fetch&lt;/code&gt; ( &lt;a href=&quot;https://fetch.spec.whatwg.org&quot;&gt;Living Standard&lt;/a&gt; ). El constructor de &lt;code&gt;Relay.DefaultNetworkLayer&lt;/code&gt; toma un segundo argumento opcional que acepta cualquier propiedad de inicializaci&amp;oacute;n v&amp;aacute;lida que acepta &lt;code&gt;fetch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2498fd787926326020b483e3523f960c30e4f9d" translate="yes" xml:space="preserve">
          <source>Unlike queries, failed requests for mutations are not automatically retried.</source>
          <target state="translated">A diferencia de las consultas,las solicitudes fallidas de mutaciones no se vuelven a probar automáticamente.</target>
        </trans-unit>
        <trans-unit id="fa7f90794261c83159eb4a91e2dfe23661dee9e6" translate="yes" xml:space="preserve">
          <source>Up until this point we have only interacted with the GraphQL endpoint to perform queries that fetch data. In this guide, you will learn how to use Relay to perform mutations &amp;ndash; operations that consist of writes to the data store followed by a fetch of any changed fields.</source>
          <target state="translated">Hasta este punto, solo hemos interactuado con el punto final GraphQL para realizar consultas que obtienen datos. En esta gu&amp;iacute;a, aprender&amp;aacute; a utilizar Relay para realizar mutaciones, operaciones que consisten en escrituras en el almac&amp;eacute;n de datos seguidas de la recuperaci&amp;oacute;n de los campos modificados.</target>
        </trans-unit>
        <trans-unit id="706a52f4ea94115123954122a8c78690d8a63036" translate="yes" xml:space="preserve">
          <source>Updater Configs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2d05363c2e81a266183ca6ef8b7bd0bdbd8b278" translate="yes" xml:space="preserve">
          <source>Updates the records associated with a mutable record, transversing the source by field name and an object representing pre-defined argument values.</source>
          <target state="translated">Actualiza los registros asociados a un registro mutable,cruzando la fuente por el nombre del campo y un objeto que representa los valores de los argumentos predefinidos.</target>
        </trans-unit>
        <trans-unit id="77357ed1c74dd26c490773b79c9c64db80714ee8" translate="yes" xml:space="preserve">
          <source>Updates the value of a mutable record's attribute given by the field name and an object representing pre-defined argument values.</source>
          <target state="translated">Actualiza el valor del atributo de un registro mutable dado por el nombre de campo y un objeto que representa valores de argumento predefinidos.</target>
        </trans-unit>
        <trans-unit id="130a5ea1f38180314e9b7e8d2e0c0f8791af7800" translate="yes" xml:space="preserve">
          <source>Updating the client on each response</source>
          <target state="translated">Actualizando al cliente en cada respuesta</target>
        </trans-unit>
        <trans-unit id="9c5f928161eaee0e6b37f9f04f9b99fffe3258b5" translate="yes" xml:space="preserve">
          <source>Updating the client optimistically</source>
          <target state="translated">Actualizando el cliente con optimismo</target>
        </trans-unit>
        <trans-unit id="683610f0bd36453d03467df7a76f50661ef6f8ac" translate="yes" xml:space="preserve">
          <source>Updating the local cache after receiving query/mutation responses.</source>
          <target state="translated">Actualización de la memoria caché local después de recibir las respuestas a la consulta/mutación.</target>
        </trans-unit>
        <trans-unit id="5cbc715352505bf09eed712fc8faa91711d9dd6f" translate="yes" xml:space="preserve">
          <source>Updating the store programatically (advanced)</source>
          <target state="translated">Actualizando la tienda programáticamente (avanzado)</target>
        </trans-unit>
        <trans-unit id="b03854fc017532ee497460390d8d2a3a98701a8a" translate="yes" xml:space="preserve">
          <source>Upgrade to react-relay v1.0.0</source>
          <target state="translated">Actualizar a react-relay v1.0.0</target>
        </trans-unit>
        <trans-unit id="6f683dd933be22f58cc623c7fb6049182ce19997" translate="yes" xml:space="preserve">
          <source>Upgrading setVariables</source>
          <target state="translated">Actualización del setVariables</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="64cfd0b3a8ed6125a106524eb46cf6330e091d8e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;commitLocalUpdate&lt;/code&gt; when you need to update the local store without necessarily executing a mutation (such as in the case of debounced operations). The function takes in a Relay &lt;code&gt;environment&lt;/code&gt; and an &lt;code&gt;updater&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9443a1d180d1993141d5ed99d3c993a96f971b4c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;commitMutation&lt;/code&gt; to create and execute mutations. &lt;code&gt;commitMutation&lt;/code&gt; has the following signature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="855b7cdc9a7b7eedbbade3460ffda75d84c0215a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;introspectionQuery&lt;/code&gt; to generate a Schema JSON for the Babel Relay Plugin, and use &lt;code&gt;printSchema&lt;/code&gt; to generate a user readable type system shorthand:</source>
          <target state="translated">Use &lt;code&gt;introspectionQuery&lt;/code&gt; para generar un JSON de esquema para el complemento Babel Relay y use &lt;code&gt;printSchema&lt;/code&gt; para generar una abreviatura del sistema de tipo legible por el usuario:</target>
        </trans-unit>
        <trans-unit id="9c04ab0245abf53d950383b659bb519121fdf39c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;graphql&lt;/code&gt;</source>
          <target state="translated">Usando &lt;code&gt;graphql&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc3790d0260968db930a9c68e2f92f666400ec99" translate="yes" xml:space="preserve">
          <source>Using Other GraphQL Implementations</source>
          <target state="translated">Usando otras implementaciones de GraphQL</target>
        </trans-unit>
        <trans-unit id="ce363e86e1227248ffe7c0ac61d5dfa9beb38f62" translate="yes" xml:space="preserve">
          <source>Using The Cache</source>
          <target state="translated">Usando el caché</target>
        </trans-unit>
        <trans-unit id="7cc52f33aee5330befcd51c2b80f9fac7ea6a7af" translate="yes" xml:space="preserve">
          <source>Using during conversion in &quot;&lt;a href=&quot;relay-compat&quot;&gt;compatibility mode&lt;/a&gt;&quot;</source>
          <target state="translated">Uso durante la conversi&amp;oacute;n en &quot; &lt;a href=&quot;relay-compat&quot;&gt;modo de compatibilidad&lt;/a&gt; &quot;</target>
        </trans-unit>
        <trans-unit id="410e9ae9e9ce0fe0fb15689548590810d66caa99" translate="yes" xml:space="preserve">
          <source>Using updater and optimisticUpdater</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ca24372752ba964092860cbbff37a07dae71dd0" translate="yes" xml:space="preserve">
          <source>Using with Relay Classic</source>
          <target state="translated">Usando con el Relevo Clásico</target>
        </trans-unit>
        <trans-unit id="9ea691c61eebccf391fb8820180c4ca2beda5321" translate="yes" xml:space="preserve">
          <source>View composition is &lt;em&gt;exactly&lt;/em&gt; what you're used to &amp;mdash; Relay containers are just standard React components. Here's the &lt;code&gt;&amp;lt;TodoList /&amp;gt;&lt;/code&gt; component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f72b74b27018bdf2391222dafa0211db62f72ce0" translate="yes" xml:space="preserve">
          <source>View composition is &lt;em&gt;exactly&lt;/em&gt; what you're used to &amp;mdash; Relay containers are standard React components. Here's the &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">Ver la composici&amp;oacute;n es &lt;em&gt;exactamente a&lt;/em&gt; lo que est&amp;aacute; acostumbrado: los contenedores de retransmisi&amp;oacute;n son componentes est&amp;aacute;ndar de React. Aqu&amp;iacute; est&amp;aacute; el componente &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ff6f9fbff154a814e972c078a22c3cc9628815cf" translate="yes" xml:space="preserve">
          <source>View composition is &lt;em&gt;exactly&lt;/em&gt; what you're used to &amp;mdash; Relay containers are standard React components. Here's the &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">Ver la composici&amp;oacute;n es &lt;em&gt;exactamente a&lt;/em&gt; lo que est&amp;aacute; acostumbrado: los contenedores de retransmisi&amp;oacute;n son componentes est&amp;aacute;ndar de React. Aqu&amp;iacute; est&amp;aacute; el componente &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1ebbd92b690622c06c90cfb9515becf2b5c48808" translate="yes" xml:space="preserve">
          <source>Warm up</source>
          <target state="translated">Calienta.</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="ee4e2bfd72b7c80e3c41f3483341254dd5afffff" translate="yes" xml:space="preserve">
          <source>We built a few scripts to help you with the conversion process. Check them out at &lt;a href=&quot;https://github.com/relayjs/relay-codemod&quot;&gt;https://github.com/relayjs/relay-codemod&lt;/a&gt;.</source>
          <target state="translated">Creamos algunos scripts para ayudarlo con el proceso de conversi&amp;oacute;n. &amp;Eacute;chales un vistazo en &lt;a href=&quot;https://github.com/relayjs/relay-codemod&quot;&gt;https://github.com/relayjs/relay-codemod&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5940197c590089a53a146cb165e633452c87b60e" translate="yes" xml:space="preserve">
          <source>We can change this behavior by supplying the &lt;code&gt;renderLoading&lt;/code&gt; prop:</source>
          <target state="translated">Podemos cambiar este comportamiento proporcionando el prop &lt;code&gt;renderLoading&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="99418ef7bda442472813dd7c77c28063f221dc1b" translate="yes" xml:space="preserve">
          <source>We can create a &lt;code&gt;./src/clientSchema.graphql&lt;/code&gt; and define a new type called &lt;code&gt;Setting&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09384c922b7bcbae85b63823d4facb25583f0ebf" translate="yes" xml:space="preserve">
          <source>We can give Relay instructions in the form of a &lt;code&gt;configs&lt;/code&gt; array on how to use the response from each mutation to update the client-side store. We do this by configuring the mutation with one or more of the following config types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0025d01a256751edcecba66775aa9098e4c29a78" translate="yes" xml:space="preserve">
          <source>We can give Relay instructions in the form of a config array on how to use the response from each mutation to update the client-side store. We do this by configuring the mutation with one or more of the following mutation types:</source>
          <target state="translated">Podemos dar instrucciones de retransmisión en forma de matriz de configuración sobre cómo usar la respuesta de cada mutación para actualizar el almacén del lado del cliente.Lo hacemos configurando la mutación con uno o más de los siguientes tipos de mutación:</target>
        </trans-unit>
        <trans-unit id="8b225a6bc0d167f8b54e806d442a842dc3c15baa" translate="yes" xml:space="preserve">
          <source>We can then extend existing server types in the client schema &lt;code&gt;./src/clientSchema.graphql&lt;/code&gt; with our new &lt;code&gt;Setting&lt;/code&gt; type, like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d988256976c56fbd9f26524c8c8f2411a181121" translate="yes" xml:space="preserve">
          <source>We declare our mutations' data dependencies here, just as we would with a container. This is particularly useful to ensure that a set of fields we might want to use in this mutation's optimistic response have been fetched.</source>
          <target state="translated">Declaramos las dependencias de datos de nuestras mutaciones aquí,como lo haríamos con un contenedor.Esto es particularmente útil para asegurar que un conjunto de campos que podríamos querer usar en la respuesta optimista de esta mutación se han obtenido.</target>
        </trans-unit>
        <trans-unit id="b7466fdf0dcdc8961e68874158874a25c24afe7b" translate="yes" xml:space="preserve">
          <source>We need a place to hide our treasure, a way to check hiding spots for treasure, and a way to track our turns remaining. For the purposes of this tutorial, we'll hide these data in memory.</source>
          <target state="translated">Necesitamos un lugar para esconder nuestro tesoro,una forma de comprobar los escondites del tesoro,y una forma de rastrear los turnos que nos quedan.Para los propósitos de este tutorial,esconderemos estos datos en la memoria.</target>
        </trans-unit>
        <trans-unit id="65874d3946f2b63af172cee5a5b310c785e00be9" translate="yes" xml:space="preserve">
          <source>We need to give Relay instructions on how to use the response payload from each mutation to update the client-side store. We do this by configuring the mutation with one or more of the following mutation types:</source>
          <target state="translated">Necesitamos dar instrucciones al Relevo sobre cómo usar la carga de respuesta de cada mutación para actualizar la tienda del lado del cliente.Lo hacemos configurando la mutación con uno o más de los siguientes tipos de mutación:</target>
        </trans-unit>
        <trans-unit id="8cbe01efa489ff5ceee170b9e46b9663c23a0b77" translate="yes" xml:space="preserve">
          <source>We ultimately settled on static methods; components would effectively return a query-tree, separate from the view-tree, describing their data dependencies. Relay could then use this query-tree to fetch all the information needed in a single stage and use it to render the components. The problem was finding an appropriate mechanism to describe the query-tree, and a way to efficiently fetch it from the server (i.e. in a single network request). This is the perfect use-case for GraphQL because it provides a syntax for &lt;em&gt;describing data-dependencies as data&lt;/em&gt;, without dictating any particular API. Note that Promises and Observables are often suggested as alternatives, but they represent &lt;em&gt;opaque commands&lt;/em&gt; and preclude various optimizations such as query batching.</source>
          <target state="translated">Finalmente, nos decidimos por m&amp;eacute;todos est&amp;aacute;ticos; Los componentes devolver&amp;iacute;an efectivamente un &amp;aacute;rbol de consultas, separado del &amp;aacute;rbol de vistas, describiendo sus dependencias de datos. Relay podr&amp;iacute;a entonces usar este &amp;aacute;rbol de consultas para obtener toda la informaci&amp;oacute;n necesaria en una sola etapa y usarla para representar los componentes. El problema fue encontrar un mecanismo apropiado para describir el &amp;aacute;rbol de consultas y una forma de obtenerlo de manera eficiente del servidor (es decir, en una sola solicitud de red). Este es el caso de uso perfecto para GraphQL porque proporciona una sintaxis para &lt;em&gt;describir las dependencias de datos como datos&lt;/em&gt; , sin dictar ninguna API en particular. Tenga en cuenta que las promesas y los observables a menudo se sugieren como alternativas, pero representan &lt;em&gt;comandos opacos&lt;/em&gt; y excluyen varias optimizaciones, como el procesamiento por lotes de consultas.</target>
        </trans-unit>
        <trans-unit id="69182ca2dfd5971872156968dd68015b5e288405" translate="yes" xml:space="preserve">
          <source>We'll now see different &lt;code&gt;likeCount&lt;/code&gt;s depending on how the story is accessed. A view that uses the first query will see an outdated count, while a view using the second query will see the updated count.</source>
          <target state="translated">Ahora veremos diferentes &lt;code&gt;likeCount&lt;/code&gt; s dependiendo de c&amp;oacute;mo se acceda a la historia. Una vista que usa la primera consulta ver&amp;aacute; un recuento desactualizado, mientras que una vista que usa la segunda consulta ver&amp;aacute; el recuento actualizado.</target>
        </trans-unit>
        <trans-unit id="4a34c41bd9be871dd6a4b7a07724bb519fe92e77" translate="yes" xml:space="preserve">
          <source>We're almost ready to let Relay fulfill the data requirements for these components and render them. However, there is one problem. In order to actually fetch data with GraphQL, we need a query root. For example, we need to ground the &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; fragment in a concrete node of type &lt;code&gt;User&lt;/code&gt;.</source>
          <target state="translated">Estamos casi listos para permitir que Relay cumpla con los requisitos de datos para estos componentes y los procese. Sin embargo, existe un problema. Para obtener datos con GraphQL, necesitamos una ra&amp;iacute;z de consulta. Por ejemplo, necesitamos conectar a tierra el fragmento &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; en un nodo concreto de tipo &lt;code&gt;User&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f379242619731bf12c214370913f902c9dc56b87" translate="yes" xml:space="preserve">
          <source>We've found that it's common for the GraphQL schema to differ slightly or even substantially from the form in which data is stored on disk. Put simply: there isn't always a 1:1 correspondence between data changes in your underlying &lt;em&gt;data storage&lt;/em&gt; (disk) and data changes in your &lt;em&gt;product-visible schema&lt;/em&gt; (GraphQL). The perfect example of this is privacy: returning a user-facing field such as &lt;code&gt;age&lt;/code&gt; might require accessing numerous records in our data-storage layer to determine if the active user is even allowed to &lt;em&gt;see&lt;/em&gt; that &lt;code&gt;age&lt;/code&gt; (Are we friends? Is my age shared? Did I block you? etc.).</source>
          <target state="translated">Hemos descubierto que es com&amp;uacute;n que el esquema GraphQL difiera levemente o incluso sustancialmente de la forma en que se almacenan los datos en el disco. En pocas palabras: no siempre hay una correspondencia 1: 1 entre los cambios de datos en su &lt;em&gt;almacenamiento de datos&lt;/em&gt; subyacente (disco) y los cambios de datos en su &lt;em&gt;esquema de producto visible&lt;/em&gt; (GraphQL). El ejemplo perfecto de esto es la privacidad: devolver un campo de cara al usuario, como la &lt;code&gt;age&lt;/code&gt; puede requerir acceder a numerosos registros en nuestra capa de almacenamiento de datos para determinar si el usuario activo puede &lt;em&gt;ver&lt;/em&gt; esa &lt;code&gt;age&lt;/code&gt; (&amp;iquest;Somos amigos? &amp;iquest;Mi edad es compartida? ? Te bloque&amp;eacute;? Etc.).</target>
        </trans-unit>
        <trans-unit id="908ef03db4345c18068bb287000ab8108652ad6f" translate="yes" xml:space="preserve">
          <source>We've found that typical approaches to data-fetching &amp;mdash; with imperative APIs &amp;mdash; force developers to deal with too much of this non-essential complexity. For example, consider &lt;em&gt;optimistic UI updates&lt;/em&gt;. This is a way of giving the user feedback while waiting for a server response. The logic of &lt;em&gt;what&lt;/em&gt; to do can be quite clear: when the user clicks &quot;like&quot;, mark the story as being liked and send the request to the server. But the implementation is often much more complex. Imperative approaches require us to implement all of those steps: reach into the UI and toggle the button, initiate a network request, retry it if necessary, show an error if it fails (and untoggle the button), etc. The same goes for data-fetching: specifying &lt;em&gt;what&lt;/em&gt; data we need often dictates &lt;em&gt;how&lt;/em&gt; and &lt;em&gt;when&lt;/em&gt; it is fetched. Next, we'll explore our approach to solving these concerns with &lt;strong&gt;Relay&lt;/strong&gt;.</source>
          <target state="translated">Hemos descubierto que los enfoques t&amp;iacute;picos para la obtenci&amp;oacute;n de datos, con API imperativas, obligan a los desarrolladores a lidiar con demasiada complejidad no esencial. Por ejemplo, considere las &lt;em&gt;actualizaciones optimistas de la interfaz de usuario&lt;/em&gt; . Esta es una forma de proporcionar comentarios al usuario mientras espera una respuesta del servidor. La l&amp;oacute;gica de &lt;em&gt;qu&amp;eacute;&lt;/em&gt; hacer puede ser bastante clara: cuando el usuario hace clic en &quot;Me gusta&quot;, marca la historia como Me gusta y env&amp;iacute;a la solicitud al servidor. Pero la implementaci&amp;oacute;n suele ser mucho m&amp;aacute;s compleja. Los enfoques imperativos requieren que implementemos todos esos pasos: acceder a la interfaz de usuario y alternar el bot&amp;oacute;n, iniciar una solicitud de red, volver a intentarlo si es necesario, mostrar un error si falla (y alternar el bot&amp;oacute;n), etc. Lo mismo ocurre con los datos -captura: especificando &lt;em&gt;qu&amp;eacute; &lt;/em&gt; datos necesitamos a menudo dicta&lt;em&gt;c&amp;oacute;mo&lt;/em&gt; y &lt;em&gt;cu&amp;aacute;ndo&lt;/em&gt;se busca. A continuaci&amp;oacute;n, exploraremos nuestro enfoque para resolver estas inquietudes con &lt;strong&gt;Relay&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c57df462a7e454e5b5d9c9c3be330abf92758a69" translate="yes" xml:space="preserve">
          <source>We've seen that Relay containers ensure that GraphQL fragments are fetched &lt;em&gt;before&lt;/em&gt; the component is rendered. But containers also provide another benefit that isn't immediately obvious: &lt;strong&gt;data masking&lt;/strong&gt;. Relay only allows components to access data they specifically ask for in &lt;code&gt;fragments&lt;/code&gt; &amp;mdash; nothing more. So if one component queries for a Story's &lt;code&gt;text&lt;/code&gt;, and another for its &lt;code&gt;author&lt;/code&gt;, each can see &lt;em&gt;only&lt;/em&gt; the field that they asked for. In fact, components can't even see the data requested by their &lt;em&gt;children&lt;/em&gt;: that would also break encapsulation.</source>
          <target state="translated">Hemos visto que los contenedores de retransmisi&amp;oacute;n garantizan que los fragmentos de GraphQL se recuperen &lt;em&gt;antes de&lt;/em&gt; que se procese el componente. Pero los contenedores tambi&amp;eacute;n brindan otro beneficio que no es obvio de inmediato: &lt;strong&gt;el enmascaramiento de datos&lt;/strong&gt; . Relay solo permite que los componentes accedan a los datos que solicitan espec&amp;iacute;ficamente en &lt;code&gt;fragments&lt;/code&gt; , nada m&amp;aacute;s. Entonces, si un componente consulta por el &lt;code&gt;text&lt;/code&gt; o de una historia y otro por su &lt;code&gt;author&lt;/code&gt; , cada uno puede ver &lt;em&gt;solo&lt;/em&gt; el campo que solicit&amp;oacute;. De hecho, los componentes ni siquiera pueden ver los datos solicitados por sus &lt;em&gt;hijos&lt;/em&gt; : eso tambi&amp;eacute;n romper&amp;iacute;a la encapsulaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e1d701dcb15b88a66be26dfbe21cdfc47c48bde8" translate="yes" xml:space="preserve">
          <source>We've seen that Relay containers ensure that GraphQL fragments are fetched &lt;em&gt;before&lt;/em&gt; the component is rendered. But containers also provide another benefit that isn't immediately obvious: &lt;strong&gt;data masking&lt;/strong&gt;. Relay only allows components to access data they specifically ask for in GraphQL fragments &amp;mdash; nothing more. So if one component queries for a Story's &lt;code&gt;text&lt;/code&gt;, and another for its &lt;code&gt;author&lt;/code&gt;, each can see &lt;em&gt;only&lt;/em&gt; the field that they asked for. In fact, components can't even see the data requested by their &lt;em&gt;children&lt;/em&gt;: that would also break encapsulation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deaef06798309bf42fff99bdd598051728c38f5a" translate="yes" xml:space="preserve">
          <source>What we have written here is a mock database interface. We can imagine hooking this up to a real database, but for now let's move on.</source>
          <target state="translated">Lo que hemos escrito aquí es un simulacro de interfaz de base de datos.Podemos imaginarnos conectar esto a una base de datos real,pero por ahora sigamos adelante.</target>
        </trans-unit>
        <trans-unit id="73a39c3a3d88bd8125f710502d024ae93180062d" translate="yes" xml:space="preserve">
          <source>What works with what? Relay Compat (&lt;code&gt;'react-relay/compat'&lt;/code&gt;) is the most flexible. Compat components and mutations can be used by everything. Compat components can also have any kind of children.</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; funciona con qu&amp;eacute;? Relay Compat ( &lt;code&gt;'react-relay/compat'&lt;/code&gt; ) es el m&amp;aacute;s flexible. Los componentes compatibles y las mutaciones pueden ser utilizados por todo. Los componentes de Compat tambi&amp;eacute;n pueden tener cualquier tipo de hijos.</target>
        </trans-unit>
        <trans-unit id="0a097138ac94d8bfbf69d6920577e2b751982a49" translate="yes" xml:space="preserve">
          <source>When &quot;force fetching&quot;, this is true if &lt;code&gt;ready&lt;/code&gt; is true as a result of data being available on the client before the server request has completed.</source>
          <target state="translated">Cuando se &quot;fuerza la recuperaci&amp;oacute;n&quot;, esto es cierto si &lt;code&gt;ready&lt;/code&gt; es verdadero como resultado de que los datos est&amp;aacute;n disponibles en el cliente antes de que se complete la solicitud del servidor.</target>
        </trans-unit>
        <trans-unit id="ec3ad126a1399587ee94fd174e76b0fbd442a34b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;forceFetch&lt;/code&gt; is true and &lt;code&gt;renderFetched&lt;/code&gt; is called as a result of available client data, &lt;code&gt;renderFetched&lt;/code&gt; is called with a second argument that has a &lt;code&gt;stale&lt;/code&gt; boolean property. The &lt;code&gt;stale&lt;/code&gt; property is true if &lt;code&gt;renderFetched&lt;/code&gt; is called before the forced server request completes.</source>
          <target state="translated">Cuando &lt;code&gt;forceFetch&lt;/code&gt; es verdadero y se llama a &lt;code&gt;renderFetched&lt;/code&gt; como resultado de los datos disponibles del cliente, se llama a &lt;code&gt;renderFetched&lt;/code&gt; con un segundo argumento que tiene una propiedad booleana &lt;code&gt;stale&lt;/code&gt; . La propiedad &lt;code&gt;stale&lt;/code&gt; es verdadera si se llama a &lt;code&gt;renderFetched&lt;/code&gt; antes de que se complete la solicitud forzada del servidor.</target>
        </trans-unit>
        <trans-unit id="eb41ea6dee1bf1db385774c4f83f62a51389acc5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;forceFetch&lt;/code&gt; is true, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; will always send a request to the server. However, if all the data required to render is also available on the client, &lt;code&gt;renderFetched&lt;/code&gt; may still be called before the server request completes.</source>
          <target state="translated">Cuando &lt;code&gt;forceFetch&lt;/code&gt; es verdadero, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; siempre enviar&amp;aacute; una solicitud al servidor. Sin embargo, si todos los datos necesarios para renderizar tambi&amp;eacute;n est&amp;aacute;n disponibles en el cliente, a&amp;uacute;n se puede llamar a &lt;code&gt;renderFetched&lt;/code&gt; antes de que se complete la solicitud del servidor.</target>
        </trans-unit>
        <trans-unit id="5e40c2b8419bc5119b554a06ad55e52a926e319f" translate="yes" xml:space="preserve">
          <source>When Relay fulfills data, the &lt;code&gt;onReadyStateChange&lt;/code&gt; callback is called one or more times with an object that describes the current &quot;ready state&quot;. This object has the following properties:</source>
          <target state="translated">Cuando Relay completa los datos, la &lt;code&gt;onReadyStateChange&lt;/code&gt; llamada onReadyStateChange se llama una o m&amp;aacute;s veces con un objeto que describe el &quot;estado listo&quot; actual. Este objeto tiene las siguientes propiedades:</target>
        </trans-unit>
        <trans-unit id="32bb09505d79ce543a4f26cb9022780cf39a8205" translate="yes" xml:space="preserve">
          <source>When all data necessary to render becomes available, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; will render the supplied &lt;code&gt;Component&lt;/code&gt; by default. However, we can change this behavior by supplying a callback to the &lt;code&gt;renderFetched&lt;/code&gt; prop:</source>
          <target state="translated">Cuando todos los datos necesarios para renderizar est&amp;eacute;n disponibles, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; renderizar&amp;aacute; el &lt;code&gt;Component&lt;/code&gt; e suministrado por defecto. Sin embargo, podemos cambiar este comportamiento proporcionando una devoluci&amp;oacute;n de llamada a la propiedad &lt;code&gt;renderFetched&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e8c530641aad6dea0ce0a725ecb86984b969f2e6" translate="yes" xml:space="preserve">
          <source>When all data requirements are fulfilled, &lt;code&gt;renderFetched&lt;/code&gt; is called to render the view. This callback is expected to spread &lt;code&gt;data&lt;/code&gt; into the supplied &lt;code&gt;Container&lt;/code&gt; when rendering it.</source>
          <target state="translated">Cuando se cumplen todos los requisitos de datos, se llama a &lt;code&gt;renderFetched&lt;/code&gt; para representar la vista. Se espera que esta devoluci&amp;oacute;n de llamada difunda los &lt;code&gt;data&lt;/code&gt; en el &lt;code&gt;Container&lt;/code&gt; proporcionado al representarlo.</target>
        </trans-unit>
        <trans-unit id="f5e881d6a25c5fe2f25b897803df81640312440a" translate="yes" xml:space="preserve">
          <source>When compiling code for production deployment, the plugin can be configured to immediately throw upon encountering a validation problem. The plugin can be further customized for different environments with the following options:</source>
          <target state="translated">Al compilar el código para el despliegue de la producción,el plugin puede ser configurado para lanzar inmediatamente al encontrar un problema de validación.El plugin se puede personalizar aún más para diferentes entornos con las siguientes opciones:</target>
        </trans-unit>
        <trans-unit id="fef005c4b23cdf975a02dadd67a2264bb2944197" translate="yes" xml:space="preserve">
          <source>When data requirements failed to be fulfilled, &lt;code&gt;renderFailure&lt;/code&gt; is called to render the view.</source>
          <target state="translated">Cuando los requisitos de datos no se cumplen, se llama a &lt;code&gt;renderFailure&lt;/code&gt; para representar la vista.</target>
        </trans-unit>
        <trans-unit id="fe6cbba9204bbe45970c08910fca16574ce8a0cc" translate="yes" xml:space="preserve">
          <source>When data requirements have yet to be fulfilled, &lt;code&gt;renderLoading&lt;/code&gt; is called to render the view. If this returns &lt;code&gt;undefined&lt;/code&gt;, the previously rendered view (or nothing if there is no previous view) is rendered.</source>
          <target state="translated">Cuando los requisitos de datos a&amp;uacute;n no se han cumplido, se llama a &lt;code&gt;renderLoading&lt;/code&gt; para representar la vista. Si devuelve &lt;code&gt;undefined&lt;/code&gt; , se procesa la vista renderizada anteriormente (o nada si no hay una vista previa).</target>
        </trans-unit>
        <trans-unit id="9fd4594d265309e3ea2f8851c4e096213978657c" translate="yes" xml:space="preserve">
          <source>When defining a fragment for use with a Fragment container, you can use the &lt;code&gt;@relay(plural: true)&lt;/code&gt; directive to indicate that container expects the prop for that fragment to be a list of items instead of a single item. A query or parent that spreads a &lt;code&gt;@relay(plural: true)&lt;/code&gt; fragment should do so within a plural field (ie a field backed by a &lt;a href=&quot;http://graphql.org/learn/schema/#lists-and-non-null&quot;&gt;GraphQL list&lt;/a&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="619aba17233daa1e1d7ee5e3869b79e1331126b3" translate="yes" xml:space="preserve">
          <source>When defining a fragment, you can use the &lt;a href=&quot;graphql-in-relay#argumentdefinitions&quot;&gt;&lt;code&gt;@argumentDefinitions&lt;/code&gt;&lt;/a&gt; directive to specify any arguments, with potentially default values, that the fragment expects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48fe499e8a7f1e23dc6dcd982b4f071176b969ff" translate="yes" xml:space="preserve">
          <source>When designing a fat query, consider &lt;em&gt;all&lt;/em&gt; of the data that might change as a result of the mutation &amp;ndash; not just the data currently in use by your application. We don't need to worry about overfetching; this query is never executed without first intersecting it with a &amp;lsquo;tracked query&amp;rsquo; of the data our application actually needs. If we omit fields in the fat query, we might observe data inconsistencies in the future when we add views with new data dependencies, or add new data dependencies to existing views.</source>
          <target state="translated">Al dise&amp;ntilde;ar una consulta amplia, tenga en cuenta &lt;em&gt;todos&lt;/em&gt; los datos que podr&amp;iacute;an cambiar como resultado de la mutaci&amp;oacute;n, no solo los datos actualmente en uso por su aplicaci&amp;oacute;n. No tenemos que preocuparnos por la captaci&amp;oacute;n excesiva; esta consulta nunca se ejecuta sin primero cruzarla con una 'consulta rastreada' de los datos que nuestra aplicaci&amp;oacute;n realmente necesita. Si omitimos campos en la consulta fat, podr&amp;iacute;amos observar inconsistencias de datos en el futuro cuando agreguemos vistas con nuevas dependencias de datos, o agreguemos nuevas dependencias de datos a vistas existentes.</target>
        </trans-unit>
        <trans-unit id="8d515b89284c6ce31950922a449ba18618a553f6" translate="yes" xml:space="preserve">
          <source>When incrementally converting a Relay Classic app to Relay Modern, &lt;code&gt;graphql&lt;/code&gt; literals can be translated to be usable by &lt;em&gt;both&lt;/em&gt; runtimes if configured to use compatibility mode:</source>
          <target state="translated">Al convertir de forma incremental una aplicaci&amp;oacute;n Relay Classic a Relay Modern, los literales &lt;code&gt;graphql&lt;/code&gt; se pueden traducir para que sean utilizables por &lt;em&gt;ambos&lt;/em&gt; tiempos de ejecuci&amp;oacute;n si se configuran para usar el modo de compatibilidad:</target>
        </trans-unit>
        <trans-unit id="902c49b06415e9d418fef8488cdcaad88a9be3b5" translate="yes" xml:space="preserve">
          <source>When it sends queries, it will automatically fail requests after a 15 second timeout. Also, failed requests are automatically retried twice, with a 1 second delay and a 3 second delay, respectively.</source>
          <target state="translated">Cuando envía consultas,automáticamente fallará las solicitudes después de un tiempo de espera de 15 segundos.Además,las solicitudes fallidas se vuelven a intentar automáticamente dos veces,con un retraso de 1 segundo y 3 segundos,respectivamente.</target>
        </trans-unit>
        <trans-unit id="c328250268c48757d266a5578f320e2cd118ae4e" translate="yes" xml:space="preserve">
          <source>When not nesting routes with Relay data dependencies, such as when using flat routes, it is sufficient to just render a &lt;code&gt;QueryRenderer&lt;/code&gt; for the parts of your application that require Relay data. You can also use the options below that integrate your routes with their data dependencies.</source>
          <target state="translated">Cuando no se anidan rutas con dependencias de datos de Relay, como cuando se utilizan rutas planas, es suficiente con representar un &lt;code&gt;QueryRenderer&lt;/code&gt; para las partes de su aplicaci&amp;oacute;n que requieren datos de Relay. Tambi&amp;eacute;n puede utilizar las siguientes opciones que integran sus rutas con sus dependencias de datos.</target>
        </trans-unit>
        <trans-unit id="c958feb46013f0ddcda8fd3772356651d46f8e8a" translate="yes" xml:space="preserve">
          <source>When problems arise developers would need an insight into Relay's store. Relay provides a couple of tools to inspect the store and its records programmatically and visually.</source>
          <target state="translated">Cuando surgen problemas,los desarrolladores necesitarían una visión de la tienda de Relay.Relay proporciona un par de herramientas para inspeccionar la tienda y sus registros de forma programada y visual.</target>
        </trans-unit>
        <trans-unit id="5d9ce00224dd61a4d32a2854970285a45cfbec29" translate="yes" xml:space="preserve">
          <source>When the &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; above is rendered, Relay will construct a query and send it to the GraphQL server. As soon as all required data has been fetched, &lt;code&gt;ProfilePicture&lt;/code&gt; will be rendered. Props with fragments will contain data that was fetched from the server.</source>
          <target state="translated">Cuando se renderiza el &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; anterior, Relay construir&amp;aacute; una consulta y la enviar&amp;aacute; al servidor GraphQL. Tan pronto como se hayan obtenido todos los datos necesarios, se procesar&amp;aacute; &lt;code&gt;ProfilePicture&lt;/code&gt; . Los accesorios con fragmentos contendr&amp;aacute;n datos que se obtuvieron del servidor.</target>
        </trans-unit>
        <trans-unit id="c67a5c120de0df00997c004e146051bbad946df1" translate="yes" xml:space="preserve">
          <source>When the server response is received, one of the callbacks is invoked:</source>
          <target state="translated">Cuando se recibe la respuesta del servidor,se invoca una de las devoluciones de llamada:</target>
        </trans-unit>
        <trans-unit id="cea8475e3aa555845df5b9bb69835f08e0fe8ca8" translate="yes" xml:space="preserve">
          <source>When the transaction is committed and the response is received from the server, one of the callbacks is invoked: - &lt;code&gt;onSuccess&lt;/code&gt; is called if the mutation succeeded. - &lt;code&gt;onFailure&lt;/code&gt; is called if the mutation failed.</source>
          <target state="translated">Cuando se confirma la transacci&amp;oacute;n y se recibe la respuesta del servidor, se invoca una de las devoluciones de llamada: - Se llama a &lt;code&gt;onSuccess&lt;/code&gt; si la mutaci&amp;oacute;n tuvo &amp;eacute;xito. - Se llama a &lt;code&gt;onFailure&lt;/code&gt; si la mutaci&amp;oacute;n fall&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="15eef2fb6be75cc68d0e3ddb99ea3d827fbcd3d5" translate="yes" xml:space="preserve">
          <source>When this response is normalized, Relay can detect that this result overlaps with existing data based on its &lt;code&gt;id&lt;/code&gt;. Rather than create a new record, Relay will update the existing &lt;code&gt;123&lt;/code&gt; record. The new &lt;code&gt;likeCount&lt;/code&gt; is therefore available to &lt;em&gt;both&lt;/em&gt; queries, as well as any other query that might reference this story.</source>
          <target state="translated">Cuando esta respuesta se normaliza, Relay puede detectar que este resultado se superpone con los datos existentes en funci&amp;oacute;n de su &lt;code&gt;id&lt;/code&gt; . En lugar de crear un nuevo registro, Relay actualizar&amp;aacute; el registro &lt;code&gt;123&lt;/code&gt; existente . Por lo tanto, el nuevo &lt;code&gt;likeCount&lt;/code&gt; est&amp;aacute; disponible para &lt;em&gt;ambas&lt;/em&gt; consultas, as&amp;iacute; como para cualquier otra consulta que pueda hacer referencia a esta historia.</target>
        </trans-unit>
        <trans-unit id="30790e3c432f6503a40e8e00ea839d4b3685867b" translate="yes" xml:space="preserve">
          <source>When upgrading an existing Relay app, replace all &lt;code&gt;require('react-relay')&lt;/code&gt; with &lt;code&gt;require('react-relay/classic')&lt;/code&gt; to continue to import the Relay Classic API.</source>
          <target state="translated">Al actualizar una aplicaci&amp;oacute;n Relay existente, reemplace todo &lt;code&gt;require('react-relay')&lt;/code&gt; por &lt;code&gt;require('react-relay/classic')&lt;/code&gt; para continuar importando la API Relay Classic.</target>
        </trans-unit>
        <trans-unit id="880864fa4e14c5e5caab7b10626e640aee6def2a" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt;, the restrictions on queries from Relay Classic are removed: queries may contain multiple root fields that use arbitrary arguments and return singular or plural values. The &lt;code&gt;viewer&lt;/code&gt; root field is now optional.</source>
          <target state="translated">Cuando se utiliza &lt;a href=&quot;query-renderer&quot;&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;/a&gt; , se eliminan las restricciones sobre las consultas de Relay Classic: las consultas pueden contener varios campos ra&amp;iacute;z que utilizan argumentos arbitrarios y devuelven valores singulares o plurales. El campo ra&amp;iacute;z del &lt;code&gt;viewer&lt;/code&gt; ahora es opcional.</target>
        </trans-unit>
        <trans-unit id="eec48adcf595a6ca86caad379b181d97a2f010ca" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;pagination-container&quot;&gt;Pagination Container&lt;/a&gt;, Relay expects connection fields to be annotated with a &lt;code&gt;@connection&lt;/code&gt; directive. For more detailed information and an example, check out the &lt;a href=&quot;pagination-container#connection&quot;&gt;docs on using &lt;code&gt;@connection&lt;/code&gt; inside a Pagination Container&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdabb7b5c56a4bc287f21143e07d2eb721a2af6c" translate="yes" xml:space="preserve">
          <source>When you provide these functions, this is roughly what happens during the mutation request:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="384e273feee00773d8ac2cb8c10110ccc823425a" translate="yes" xml:space="preserve">
          <source>Whenever Relay is fulfilling data requirements, it can be useful to know when certain events occur. For example, we might want to record how long it takes for data to be available, or we might want to log errors to the server. These events are available on most Relay APIs via the &lt;code&gt;onReadyStateChange&lt;/code&gt; callback.</source>
          <target state="translated">Siempre que Relay cumpla con los requisitos de datos, puede ser &amp;uacute;til saber cu&amp;aacute;ndo ocurren ciertos eventos. Por ejemplo, es posible que queramos registrar cu&amp;aacute;nto tiempo tardan los datos en estar disponibles o que queramos registrar errores en el servidor. Estos eventos est&amp;aacute;n disponibles en la mayor&amp;iacute;a de las API de retransmisi&amp;oacute;n a trav&amp;eacute;s de la &lt;code&gt;onReadyStateChange&lt;/code&gt; llamada onReadyStateChange .</target>
        </trans-unit>
        <trans-unit id="e8cd144d9041c40f96f66e2aa651ea3465a4503f" translate="yes" xml:space="preserve">
          <source>Wherever the inverse grammar serves you better, you can use &lt;code&gt;@skip(if: ...)&lt;/code&gt; instead of &lt;code&gt;@include(if: ...)&lt;/code&gt;.</source>
          <target state="translated">Donde sea que la gram&amp;aacute;tica inversa le sirva mejor, puede usar &lt;code&gt;@skip(if: ...)&lt;/code&gt; lugar de &lt;code&gt;@include(if: ...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f3e2838c0630aa2c4914a0c2d4e6ea23e0c95ac" translate="yes" xml:space="preserve">
          <source>Whether the request was aborted.</source>
          <target state="translated">Si la petición fue abortada.</target>
        </trans-unit>
        <trans-unit id="422efd22184fb3e6c495b98266ee159c3842165d" translate="yes" xml:space="preserve">
          <source>While typically Relay only provides the data for fields explicitly requested by a component's fragment, &lt;code&gt;@relay(mask: false)&lt;/code&gt; can be added to a fragment spread to not mask that data, recursively including the data from the fields of the referenced fragment.</source>
          <target state="translated">Si bien normalmente Relay solo proporciona los datos para los campos solicitados expl&amp;iacute;citamente por el fragmento de un componente, &lt;code&gt;@relay(mask: false)&lt;/code&gt; se puede agregar a una extensi&amp;oacute;n de fragmento para no enmascarar esos datos, incluyendo recursivamente los datos de los campos del fragmento referenciado.</target>
        </trans-unit>
        <trans-unit id="ff506c81a21b554c2790ef2e5a963a42aff57850" translate="yes" xml:space="preserve">
          <source>While you type queries as follows:</source>
          <target state="translated">Mientras escribes las preguntas de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="0b57cc238bcb966947c54d303e25a36f527aba7b" translate="yes" xml:space="preserve">
          <source>While you type queries as:</source>
          <target state="translated">Mientras escribes las preguntas como:</target>
        </trans-unit>
        <trans-unit id="223f6c68b8dfddbadc2aa76589625320726b0252" translate="yes" xml:space="preserve">
          <source>Will cause a generated file to appear in &lt;code&gt;./__generated__/MyComponent.graphql&lt;/code&gt;, with both runtime artifacts (which help to read and write from the Relay Store) and &lt;a href=&quot;https://flow.org/&quot;&gt;Flow types&lt;/a&gt; to help you write type-safe code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d32def387eb6db627a1048487211194f68d2887" translate="yes" xml:space="preserve">
          <source>With GraphQL it is very common for the results of multiple queries to overlap. However, our response cache from the previous section doesn't account for this overlap &amp;mdash; it caches based on distinct queries. For example, if we issue a query to fetch stories:</source>
          <target state="translated">Con GraphQL es muy com&amp;uacute;n que los resultados de m&amp;uacute;ltiples consultas se superpongan. Sin embargo, nuestra memoria cach&amp;eacute; de respuestas de la secci&amp;oacute;n anterior no tiene en cuenta esta superposici&amp;oacute;n; se almacena en memoria cach&amp;eacute; seg&amp;uacute;n distintas consultas. Por ejemplo, si emitimos una consulta para buscar historias:</target>
        </trans-unit>
        <trans-unit id="326b4ac13e70484638c8e2c275bb7155ff73eafd" translate="yes" xml:space="preserve">
          <source>With a normalized response cache, a record would be created for each story in the list. The &lt;code&gt;stories&lt;/code&gt; field would store links to each of these records.</source>
          <target state="translated">Con una memoria cach&amp;eacute; de respuesta normalizada, se crear&amp;iacute;a un registro para cada historia en la lista. El campo de &lt;code&gt;stories&lt;/code&gt; almacenar&amp;iacute;a enlaces a cada uno de estos registros.</target>
        </trans-unit>
        <trans-unit id="9443a9eb3d5ff45b05255468c9ca88197b385e42" translate="yes" xml:space="preserve">
          <source>With some additional configuration, the &lt;code&gt;&quot;relay&quot;&lt;/code&gt; babel plugin can also translate Relay Classic &lt;code&gt;Relay.QL&lt;/code&gt; literals. Most importantly, include a reference to your GraphQL Schema as either a json file or graphql schema file.</source>
          <target state="translated">Con alguna configuraci&amp;oacute;n adicional, el complemento de babel &lt;code&gt;&quot;relay&quot;&lt;/code&gt; tambi&amp;eacute;n puede traducir literales Relay Classic &lt;code&gt;Relay.QL&lt;/code&gt; . Lo m&amp;aacute;s importante es que incluya una referencia a su esquema GraphQL como un archivo json o un archivo de esquema graphql.</target>
        </trans-unit>
        <trans-unit id="b4fdf6745c6472ea632228aac1bf14006ef03d88" translate="yes" xml:space="preserve">
          <source>With the queries out of the way, let's start in on our only mutation: the one that spends a turn by checking a spot for treasure. Here, we define the input to the mutation (the id of a spot to check for treasure) and a list of all of the possible fields that the client might want updates about after the mutation has taken place. Finally, we implement a method that performs the underlying mutation.</source>
          <target state="translated">Con las preguntas fuera del camino,comencemos con nuestra única mutación:la que pasa un turno revisando un lugar en busca de un tesoro.Aquí,definimos la entrada de la mutación (la identificación de un lugar para buscar el tesoro)y una lista de todos los campos posibles sobre los que el cliente podría querer actualizaciones después de que la mutación haya tenido lugar.Finalmente,implementamos un método que realiza la mutación subyacente.</target>
        </trans-unit>
        <trans-unit id="7ddd9cfe22f7c960a4c67535583b19ffb8497a42" translate="yes" xml:space="preserve">
          <source>With this input and payload, we can issue the following mutation:</source>
          <target state="translated">Con esta entrada y carga útil,podemos emitir la siguiente mutación:</target>
        </trans-unit>
        <trans-unit id="dce3644542cd9fbd082b44d7cadd316ad1975d62" translate="yes" xml:space="preserve">
          <source>With typical approaches to data-fetching we found that it was common for two components to have &lt;em&gt;implicit dependencies&lt;/em&gt;. For example &lt;code&gt;&amp;lt;StoryHeader /&amp;gt;&lt;/code&gt; might use some data without directly ensuring that the data was fetched. This data would often be fetched by some other part of the system, such as &lt;code&gt;&amp;lt;Story /&amp;gt;&lt;/code&gt;. Then when we changed &lt;code&gt;&amp;lt;Story /&amp;gt;&lt;/code&gt; and removed that data-fetching logic, &lt;code&gt;&amp;lt;StoryHeader /&amp;gt;&lt;/code&gt; would suddenly and inexplicably break. These types of bugs are not always immediately apparent, especially in larger applications developed by larger teams. Manual and automated testing can only help so much: this is exactly the type of systematic problem that is better solved by a framework.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e36e32aeb9398daa0c7117970d61b1237b724a3" translate="yes" xml:space="preserve">
          <source>With typical approaches to data-fetching we found that it was common for two components to have &lt;em&gt;implicit dependencies&lt;/em&gt;. For example &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; might use some data without directly ensuring that the data was fetched. This data would often be fetched by some other part of the system, such as &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt;. Then when we changed &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; and removed that data-fetching logic, &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; would suddenly and inexplicably break. These types of bugs are not always immediately apparent, especially in larger applications developed by larger teams. Manual and automated testing can only help so much: this is exactly the type of systematic problem that is better solved by a framework.</source>
          <target state="translated">Con los enfoques t&amp;iacute;picos para la b&amp;uacute;squeda de datos, encontramos que era com&amp;uacute;n que dos componentes tuvieran &lt;em&gt;dependencias impl&amp;iacute;citas&lt;/em&gt; . Por ejemplo, &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; podr&amp;iacute;a usar algunos datos sin asegurarse directamente de que se obtuvieron. A menudo, esta informaci&amp;oacute;n puede ser obtenida por alguna otra parte del sistema, como &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; . Luego, cuando cambiamos &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; y eliminamos esa l&amp;oacute;gica de b&amp;uacute;squeda de datos, &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; se romp&amp;iacute;a repentina e inexplicablemente. Estos tipos de errores no siempre son evidentes de inmediato, especialmente en aplicaciones m&amp;aacute;s grandes desarrolladas por equipos m&amp;aacute;s grandes. Las pruebas manuales y automatizadas solo pueden ayudar hasta cierto punto: este es exactamente el tipo de problema sistem&amp;aacute;tico que se resuelve mejor con un marco.</target>
        </trans-unit>
        <trans-unit id="d7a484140f5f9f7f5427e1f2c44dbfc1d3ad9eea" translate="yes" xml:space="preserve">
          <source>Workflow</source>
          <target state="translated">Workflow</target>
        </trans-unit>
        <trans-unit id="5c338a274513fe1f278459839f0c78f7e6b91728" translate="yes" xml:space="preserve">
          <source>Writing the game</source>
          <target state="translated">Escribiendo el juego</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="1696149c59259541ba3a1d3a3c3c107fc68c94e9" translate="yes" xml:space="preserve">
          <source>Yes*</source>
          <target state="translated">Yes*</target>
        </trans-unit>
        <trans-unit id="d38ce88b105c03a9bcdfa9b0ae57cef87a38afbe" translate="yes" xml:space="preserve">
          <source>You can also pass variables to the mutation's fragment builder from the outer fragment that contains it.</source>
          <target state="translated">También puede pasar variables al constructor del fragmento de la mutación desde el fragmento exterior que la contiene.</target>
        </trans-unit>
        <trans-unit id="2a3a0a2cf926b5e31314761fde4d2b924ad01e95" translate="yes" xml:space="preserve">
          <source>You can conditionally include or skip a field based on the value of a boolean variable.</source>
          <target state="translated">Puedes incluir o saltar condicionalmente un campo basado en el valor de una variable booleana.</target>
        </trans-unit>
        <trans-unit id="e39e4e019fcddf87d5963ed450c0a585f3ac5a5c" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;code&gt;InteractionManager&lt;/code&gt; on the &lt;a href=&quot;http://facebook.github.io/react-native/docs/interactionmanager.html&quot;&gt;React Native API docs&lt;/a&gt;.</source>
          <target state="translated">Puede leer m&amp;aacute;s sobre &lt;code&gt;InteractionManager&lt;/code&gt; en los &lt;a href=&quot;http://facebook.github.io/react-native/docs/interactionmanager.html&quot;&gt;documentos de la API React Native&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1db4f1b561c182f757185de947874831706c7c3d" translate="yes" xml:space="preserve">
          <source>You can read more about the API &lt;a href=&quot;interfaces-relay-network-layer&quot;&gt;RelayNetworkLayer&lt;/a&gt; interface.</source>
          <target state="translated">Puede leer m&amp;aacute;s sobre la interfaz API &lt;a href=&quot;interfaces-relay-network-layer&quot;&gt;RelayNetworkLayer&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d3732e8bd7b74351797baa672d29727cc8e4b2f3" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;fetchQuery&lt;/code&gt; function to imperatively make GraphQL Requests. This is useful for cases where you want to make requests outside of React but still utilize the Relay store and network layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42ec8ab0bbfcf6ce2aa1efbd2295912061dec672" translate="yes" xml:space="preserve">
          <source>You don't have to mimic the entire response payload. Here, we've punted on the like sentence, since it's difficult to localize on the client side. When the server responds, Relay will treat its payload as the source of truth, but in the meantime, the optimistic response will be applied right away, allowing the people who use our product to enjoy instant feedback after having taken an action.</source>
          <target state="translated">No tienes que imitar toda la carga de respuesta.Aquí,hemos castigado la misma frase,ya que es difícil de localizar en el lado del cliente.Cuando el servidor responda,Relay tratará su carga útil como la fuente de la verdad,pero mientras tanto,la respuesta optimista se aplicará de inmediato,permitiendo a las personas que utilizan nuestro producto disfrutar de una retroalimentación instantánea después de haber tomado una acción.</target>
        </trans-unit>
        <trans-unit id="db948a53ed55bdbbd4fa17526586780dad70f601" translate="yes" xml:space="preserve">
          <source>You have to implement your own cache strategy. A simple solution is to use &lt;code&gt;QueryResponseCache&lt;/code&gt; (an in-memory cache):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1ae915d1a8b7fa12f92488b10423d30b2ad84e5" translate="yes" xml:space="preserve">
          <source>You will need to Configure your &lt;a href=&quot;networklayer&quot;&gt;Network&lt;/a&gt; to handle subscriptions. The below example uses &lt;a href=&quot;https://github.com/apollographql/subscriptions-transport-ws&quot;&gt;subscriptions-transport-ws&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13eb998680ecc627ba04d1e2c348b212888c8f5b" translate="yes" xml:space="preserve">
          <source>[1] Note that GraphQL itself does not impose this constraint, and Relay Runtime may also be used for schemas that do not conform to it. For example, both systems can be used to query a single denormalized table. However, many of the features that Relay Runtime provides, such as caching and normalization, work best when the data is represented as a normalized graph with stable identities for discrete pieces of information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dd3288de30464c56940d838b494bb246d25a587" translate="yes" xml:space="preserve">
          <source>an edge representing the new friend will be added to the viewer's &lt;code&gt;friends&lt;/code&gt; connection</source>
          <target state="translated">se agregar&amp;aacute; un borde que representa al nuevo amigo a la conexi&amp;oacute;n de &lt;code&gt;friends&lt;/code&gt; del espectador</target>
        </trans-unit>
        <trans-unit id="33f0663df214f396a65e31c63ea1758c4a24ba18" translate="yes" xml:space="preserve">
          <source>an edge representing the viewer will be added to the new friend's &lt;code&gt;friends&lt;/code&gt; connection</source>
          <target state="translated">se agregar&amp;aacute; un borde que representa al espectador a la conexi&amp;oacute;n de &lt;code&gt;friends&lt;/code&gt; del nuevo amigo</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="6a5703deebcf0535c19b19c1b0a27e8341e2ab4d" translate="yes" xml:space="preserve">
          <source>and then later refetch one of the stories whose &lt;code&gt;likeCount&lt;/code&gt; has since been incremented:</source>
          <target state="translated">y luego vuelva a buscar una de las historias cuyo &lt;code&gt;likeCount&lt;/code&gt; se ha incrementado desde entonces:</target>
        </trans-unit>
        <trans-unit id="6abe6d9392071037cb6a695b9da8b68f203db531" translate="yes" xml:space="preserve">
          <source>and we get back</source>
          <target state="translated">y volvemos</target>
        </trans-unit>
        <trans-unit id="b74745ac136841f9501637f3fac7d913abeecf5d" translate="yes" xml:space="preserve">
          <source>and we'll get this result:</source>
          <target state="translated">y obtendremos este resultado:</target>
        </trans-unit>
        <trans-unit id="f30392ad1d35a35355bcc5ff5b7ab1c4aa4b6b4d" translate="yes" xml:space="preserve">
          <source>applyOptimistic</source>
          <target state="translated">applyOptimistic</target>
        </trans-unit>
        <trans-unit id="481baa434ed8570c01e3d78b4a058c1cea4ffea5" translate="yes" xml:space="preserve">
          <source>applyUpdate (static method)</source>
          <target state="translated">applyUpdate (método estático)</target>
        </trans-unit>
        <trans-unit id="e0d9b66d001ce91f916cb04de6514301d4191e1e" translate="yes" xml:space="preserve">
          <source>babel-plugin-relay</source>
          <target state="translated">babel-plugin-relay</target>
        </trans-unit>
        <trans-unit id="804dd7a640e28824ae34b133455831c85cafaa66" translate="yes" xml:space="preserve">
          <source>both people's friend count will increment</source>
          <target state="translated">el número de amigos de ambas personas aumentará</target>
        </trans-unit>
        <trans-unit id="4015b57a143aec5156fd1444a017a32137a3fd0f" translate="yes" xml:space="preserve">
          <source>commit</source>
          <target state="translated">commit</target>
        </trans-unit>
        <trans-unit id="ef1bbfb7f634722c33aa4d7f3c325a4a29ea88d1" translate="yes" xml:space="preserve">
          <source>commitUpdate (static method)</source>
          <target state="translated">commitUpdate (método estático)</target>
        </trans-unit>
        <trans-unit id="8a1c1339801686eb9bf9a9ac5b4719b8c8b8fc9b" translate="yes" xml:space="preserve">
          <source>constructor</source>
          <target state="translated">constructor</target>
        </trans-unit>
        <trans-unit id="4b45c519aa27393b323501edc492900dac1e0a96" translate="yes" xml:space="preserve">
          <source>create (static method)</source>
          <target state="translated">crear (método estático)</target>
        </trans-unit>
        <trans-unit id="db646ca2b7d259a49537f70fff30ff3c2c3c18c5" translate="yes" xml:space="preserve">
          <source>createContainer (static method)</source>
          <target state="translated">createContainer (método estático)</target>
        </trans-unit>
        <trans-unit id="2b28d0e79db5f9b1637a6d02fd886e0beb0a2a87" translate="yes" xml:space="preserve">
          <source>createWithFiles (static method)</source>
          <target state="translated">createWithFiles (método estático)</target>
        </trans-unit>
        <trans-unit id="42cdc1d74453884d8861396360329db1f2583a19" translate="yes" xml:space="preserve">
          <source>fetchQuery</source>
          <target state="translated">fetchQuery</target>
        </trans-unit>
        <trans-unit id="da32c19d5a974ead91be2f8fa59b4a9c03db9888" translate="yes" xml:space="preserve">
          <source>forceFetch</source>
          <target state="translated">forceFetch</target>
        </trans-unit>
        <trans-unit id="446ce95fe1412056ff2efb4a2eddeb9b14b5b57b" translate="yes" xml:space="preserve">
          <source>fragments</source>
          <target state="translated">fragments</target>
        </trans-unit>
        <trans-unit id="348bf71ffb0d4407dbcecd15dd012e9ca4e50ec6" translate="yes" xml:space="preserve">
          <source>fragments (static property)</source>
          <target state="translated">fragmentos (propiedad estática)</target>
        </trans-unit>
        <trans-unit id="c7051a4ed355bcc5e03ff249da8ad3c8d98795de" translate="yes" xml:space="preserve">
          <source>getCollisionKey</source>
          <target state="translated">getCollisionKey</target>
        </trans-unit>
        <trans-unit id="9b9964fe7f200e2d2d723f2ce25c45e685f31c1a" translate="yes" xml:space="preserve">
          <source>getConfigs (abstract method)</source>
          <target state="translated">getConfigs (método abstracto)</target>
        </trans-unit>
        <trans-unit id="1af4f339fc74cdc2a2f63e9dec4d5c78820395ab" translate="yes" xml:space="preserve">
          <source>getDataID(): &lt;a href=&quot;https://github.com/facebook/relay/blob/d0310d69012bba615dacf614319bcf47ee2a0f3f/packages/relay-runtime/ARCHITECTURE.md&quot;&gt;DataID&lt;/a&gt;</source>
          <target state="translated">getDataID (): &lt;a href=&quot;https://github.com/facebook/relay/blob/d0310d69012bba615dacf614319bcf47ee2a0f3f/packages/relay-runtime/ARCHITECTURE.md&quot;&gt;DataID&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0405ea062abe8cd4a0d287f9154a09079dc4bb4d" translate="yes" xml:space="preserve">
          <source>getDebugName</source>
          <target state="translated">getDebugName</target>
        </trans-unit>
        <trans-unit id="327b4db9411eb5735cd4d613988bd27603d51f28" translate="yes" xml:space="preserve">
          <source>getFatQuery (abstract method)</source>
          <target state="translated">getFatQuery (método abstracto)</target>
        </trans-unit>
        <trans-unit id="97f9623a23d5717ffebb67278d55b1afd1ffd725" translate="yes" xml:space="preserve">
          <source>getFiles</source>
          <target state="translated">getFiles</target>
        </trans-unit>
        <trans-unit id="1778700a36f50cd423696eb753bb860799ac9b24" translate="yes" xml:space="preserve">
          <source>getFragment</source>
          <target state="translated">getFragment</target>
        </trans-unit>
        <trans-unit id="d7c3b79969b5a91a9a376dcbffb251e4515b3ce9" translate="yes" xml:space="preserve">
          <source>getFragment (static method)</source>
          <target state="translated">getFragment (método estático)</target>
        </trans-unit>
        <trans-unit id="e8166bd4ce0d5f8fe076afeb9c45240cc7d5f2b5" translate="yes" xml:space="preserve">
          <source>getID</source>
          <target state="translated">getID</target>
        </trans-unit>
        <trans-unit id="a73db9be39fc73bb1d8a15f030515c436d5a3453" translate="yes" xml:space="preserve">
          <source>getLinkedRecord(name: string, args?: ?Variables): ?RecordProxy</source>
          <target state="translated">getLinkedRecord(name:string,args?:?Variables):?RecordProxy</target>
        </trans-unit>
        <trans-unit id="88377de01a531764c854a5d87458832e26bb6d7d" translate="yes" xml:space="preserve">
          <source>getLinkedRecords(name: string, args?: ?Variables): ?Array&amp;lt;?RecordProxy&amp;gt;</source>
          <target state="translated">getLinkedRecords (nombre: cadena, argumentos ?:? Variables):? Array &amp;lt;? RecordProxy&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d7fde427ab020029d422a06dc9a3f3cf60a0f286" translate="yes" xml:space="preserve">
          <source>getMutation (abstract method)</source>
          <target state="translated">getMutation (método abstracto)</target>
        </trans-unit>
        <trans-unit id="c3d4160e6945293e656522a92a11fe8535c041eb" translate="yes" xml:space="preserve">
          <source>getOptimisticConfigs</source>
          <target state="translated">getOptimisticConfigs</target>
        </trans-unit>
        <trans-unit id="e35ed410633190979352fe6ee6d4d885c8a18598" translate="yes" xml:space="preserve">
          <source>getOptimisticResponse</source>
          <target state="translated">getOptimisticResponse</target>
        </trans-unit>
        <trans-unit id="6bd679f8ef0f8733bd010559ff42cbedeb5983bf" translate="yes" xml:space="preserve">
          <source>getOrCreateLinkedRecord(name: string, typeName: string, args?: ?Variables ): RecordProxy</source>
          <target state="translated">getOrCreateLinkedRecord(name:string,typeName:string,args?:?Variables ):RecordProxy</target>
        </trans-unit>
        <trans-unit id="759956d4899d707dd6a33742489f969212a28756" translate="yes" xml:space="preserve">
          <source>getPendingTransactions</source>
          <target state="translated">getPendingTransactions</target>
        </trans-unit>
        <trans-unit id="5531a9db2f3b83555a0eff0afe4a7b4598c8f0de" translate="yes" xml:space="preserve">
          <source>getQueryString</source>
          <target state="translated">getQueryString</target>
        </trans-unit>
        <trans-unit id="5b70bfc75fe69a0ac1b8cf3046235fbb64e40599" translate="yes" xml:space="preserve">
          <source>getRootField(fieldName: string): ?RecordProxy</source>
          <target state="translated">getRootField(fieldName:string):?RecordProxy</target>
        </trans-unit>
        <trans-unit id="ab14bf198ad6c14dda7ba6cd7afe5b74fddbdc2e" translate="yes" xml:space="preserve">
          <source>getSource(): &lt;a href=&quot;https://github.com/facebook/relay/blob/d0310d69012bba615dacf614319bcf47ee2a0f3f/packages/relay-runtime/ARCHITECTURE.md&quot;&gt;RecordSource&lt;/a&gt;</source>
          <target state="translated">getSource (): &lt;a href=&quot;https://github.com/facebook/relay/blob/d0310d69012bba615dacf614319bcf47ee2a0f3f/packages/relay-runtime/ARCHITECTURE.md&quot;&gt;RecordSource&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="264cb99bbdb88c3a503a7cd09445ab43ad54af52" translate="yes" xml:space="preserve">
          <source>getType(): RelayQLType</source>
          <target state="translated">getType():RelayQLType</target>
        </trans-unit>
        <trans-unit id="f5807036ab312a725491c64183d61cf7b9babe1d" translate="yes" xml:space="preserve">
          <source>getValue(name: string, args?: ?Variables): mixed</source>
          <target state="translated">getValue(name:string,args?:?Variables):mixto</target>
        </trans-unit>
        <trans-unit id="43f55a80a8e191422ce37e5ebd8264867fc6316d" translate="yes" xml:space="preserve">
          <source>getVariables</source>
          <target state="translated">getVariables</target>
        </trans-unit>
        <trans-unit id="4349f8288befeff38404853658acf2b002ad2746" translate="yes" xml:space="preserve">
          <source>getVariables (abstract method)</source>
          <target state="translated">getVariables (método abstracto)</target>
        </trans-unit>
        <trans-unit id="3cfab35ae11b2420cf0d4e4900fa11d44d7f4976" translate="yes" xml:space="preserve">
          <source>gives us</source>
          <target state="translated">nos da</target>
        </trans-unit>
        <trans-unit id="9fdcc7f29c59e6f9abaaab32c0a1a15b1b78226b" translate="yes" xml:space="preserve">
          <source>graphql</source>
          <target state="translated">graphql</target>
        </trans-unit>
        <trans-unit id="dde2cfc8d1d2de804008dfc4836831a0eccb8444" translate="yes" xml:space="preserve">
          <source>hasOptimisticUpdate</source>
          <target state="translated">hasOptimisticUpdate</target>
        </trans-unit>
        <trans-unit id="a205cb3bee524195c2fdce6610a417b6853a4c32" translate="yes" xml:space="preserve">
          <source>initialVariables</source>
          <target state="translated">initialVariables</target>
        </trans-unit>
        <trans-unit id="4bfbc265fe484eac76b0500e386617d6cf0e573e" translate="yes" xml:space="preserve">
          <source>initialVariables (static property)</source>
          <target state="translated">Variables iniciales (propiedad estática)</target>
        </trans-unit>
        <trans-unit id="04dcd4fb3277dbb1127599ff7d32d5684b6a02dc" translate="yes" xml:space="preserve">
          <source>injectNetworkLayer (static method)</source>
          <target state="translated">injectNetworkLayer (método estático)</target>
        </trans-unit>
        <trans-unit id="0a776c5ca0800d03ca78f47f75e9eb834365d304" translate="yes" xml:space="preserve">
          <source>injectTaskScheduler (static method)</source>
          <target state="translated">injectTaskScheduler (método estático)</target>
        </trans-unit>
        <trans-unit id="bc813ae20708b8a347a4d53fb6e91311ea7bb33d" translate="yes" xml:space="preserve">
          <source>isContainer (static method)</source>
          <target state="translated">isContenedor (método estático)</target>
        </trans-unit>
        <trans-unit id="c53397edd355fc4e2d006653db94583eef513e6f" translate="yes" xml:space="preserve">
          <source>onReadyStateChange</source>
          <target state="translated">onReadyStateChange</target>
        </trans-unit>
        <trans-unit id="fb05074bc118e549bee00caf3b25aeedd2a23fb9" translate="yes" xml:space="preserve">
          <source>or: &lt;code&gt;this.props.relay.refetch({}, {}, callback, {force: true})&lt;/code&gt; in a Refetch Container</source>
          <target state="translated">o: &lt;code&gt;this.props.relay.refetch({}, {}, callback, {force: true})&lt;/code&gt; en un contenedor de recuperaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="00525d7718b6def384814a704d781fd95161b685" translate="yes" xml:space="preserve">
          <source>paramDefinitions (static property)</source>
          <target state="translated">paramDefiniciones (propiedad estática)</target>
        </trans-unit>
        <trans-unit id="ab47b8a712d90d33736ca95a21ffd78e2edcbc43" translate="yes" xml:space="preserve">
          <source>pendingVariables</source>
          <target state="translated">pendingVariables</target>
        </trans-unit>
        <trans-unit id="46070ca5b7bac4a677b32597aa968e6707fb2947" translate="yes" xml:space="preserve">
          <source>prepareParams (static property)</source>
          <target state="translated">prepareParams (propiedad estática)</target>
        </trans-unit>
        <trans-unit id="4c8dd8321c7f8e03d9a33e3aac495748a5310da1" translate="yes" xml:space="preserve">
          <source>prepareVariables</source>
          <target state="translated">prepareVariables</target>
        </trans-unit>
        <trans-unit id="6399eda44b9a365d9ef2884378c34b3d150ac371" translate="yes" xml:space="preserve">
          <source>prepareVariables (static property)</source>
          <target state="translated">PrepararVariables (propiedad estática)</target>
        </trans-unit>
        <trans-unit id="d32d93402de4dcb749f059cba43572aa23bd03dc" translate="yes" xml:space="preserve">
          <source>queries (static property)</source>
          <target state="translated">consultas (propiedad estática)</target>
        </trans-unit>
        <trans-unit id="9dc632a4888b695f2a771b203d0887d10714caef" translate="yes" xml:space="preserve">
          <source>react-relay/classic</source>
          <target state="translated">react-relay/classic</target>
        </trans-unit>
        <trans-unit id="37eca5751d1f6d7dfe5688efc6d86da3dd09c16f" translate="yes" xml:space="preserve">
          <source>render</source>
          <target state="translated">render</target>
        </trans-unit>
        <trans-unit id="62f23262fcec4cdc5eb17faabb63e059d6950930" translate="yes" xml:space="preserve">
          <source>renderFailure</source>
          <target state="translated">renderFailure</target>
        </trans-unit>
        <trans-unit id="2afd39a75e88681d175b8553ff1dce06613384a5" translate="yes" xml:space="preserve">
          <source>renderFetched</source>
          <target state="translated">renderFetched</target>
        </trans-unit>
        <trans-unit id="5e3932629379610ab259e44527d32162c9392f0b" translate="yes" xml:space="preserve">
          <source>renderLoading</source>
          <target state="translated">renderLoading</target>
        </trans-unit>
        <trans-unit id="414e681ebabcd2f23de1f32468992b9c81c5f909" translate="yes" xml:space="preserve">
          <source>returns</source>
          <target state="translated">returns</target>
        </trans-unit>
        <trans-unit id="ff3a6f3b41f1c1e00b77429034bc912cfa7dd364" translate="yes" xml:space="preserve">
          <source>rollback</source>
          <target state="translated">rollback</target>
        </trans-unit>
        <trans-unit id="fc166eb81361ff31179cd3c83da3bfe088b851d3" translate="yes" xml:space="preserve">
          <source>route</source>
          <target state="translated">route</target>
        </trans-unit>
        <trans-unit id="e1d71ee40db65de4abc60e598cad15a41923e787" translate="yes" xml:space="preserve">
          <source>routeName (static property)</source>
          <target state="translated">routeName (propiedad estática)</target>
        </trans-unit>
        <trans-unit id="9f1125a04ebb1449bdd323a60a2950db5accfb80" translate="yes" xml:space="preserve">
          <source>sendMutation</source>
          <target state="translated">sendMutation</target>
        </trans-unit>
        <trans-unit id="435568d9e02408d6788ecdc6be513d72ccc6cb61" translate="yes" xml:space="preserve">
          <source>sendQueries</source>
          <target state="translated">sendQueries</target>
        </trans-unit>
        <trans-unit id="2880123c67d1aaedb821f0f247cd4c6c4345aab8" translate="yes" xml:space="preserve">
          <source>setLinkedRecord(record: RecordProxy, name: string, args?: ?Variables): RecordProxy</source>
          <target state="translated">setLinkedRecord(record:RecordProxy,name:string,args?:?Variables):RecordProxy</target>
        </trans-unit>
        <trans-unit id="7dc0722d5b1e977d588c3edf8515b019e788c174" translate="yes" xml:space="preserve">
          <source>setLinkedRecords(records: Array&amp;lt;?RecordProxy&amp;gt;, name: string, args?: ?Variables ): RecordProxy</source>
          <target state="translated">setLinkedRecords (registros: Array &amp;lt;? RecordProxy&amp;gt;, nombre: cadena, args ?:? Variables): RecordProxy</target>
        </trans-unit>
        <trans-unit id="9a58f84fd8486e41fd7dcfc4d34aa90c06019e22" translate="yes" xml:space="preserve">
          <source>setValue(value: mixed, name: string, args?: ?Variables): RecordProxy</source>
          <target state="translated">setValue(valor:mixto,nombre:cadena,args?:?Variables):RecordProxy</target>
        </trans-unit>
        <trans-unit id="5548ee17e1e709bc17eb0b6bc474907bee14447b" translate="yes" xml:space="preserve">
          <source>setVariables</source>
          <target state="translated">setVariables</target>
        </trans-unit>
        <trans-unit id="ae2633f3722560d2ad1ff74c21f50ef81ea6b153" translate="yes" xml:space="preserve">
          <source>shouldComponentUpdate</source>
          <target state="translated">shouldComponentUpdate</target>
        </trans-unit>
        <trans-unit id="8a14711da8b864c0b88fb3fe7e873c0b2894566e" translate="yes" xml:space="preserve">
          <source>supports</source>
          <target state="translated">supports</target>
        </trans-unit>
        <trans-unit id="09e391d372ecf222949d736538e76db78674604a" translate="yes" xml:space="preserve">
          <source>the viewer's friendship status with the requester will change</source>
          <target state="translated">el estado de amistad del espectador con el solicitante cambiará</target>
        </trans-unit>
        <trans-unit id="bc5af2310c7f15770a4ed0028648ce367e3e2ec0" translate="yes" xml:space="preserve">
          <source>variables</source>
          <target state="translated">variables</target>
        </trans-unit>
        <trans-unit id="87a0de569c57d54d8721ab12b504cc0797b8a57b" translate="yes" xml:space="preserve">
          <source>with these params:</source>
          <target state="translated">con estos parches:</target>
        </trans-unit>
        <trans-unit id="edb0f5b1f639a3886e3180c47fe86c3a6a263842" translate="yes" xml:space="preserve">
          <source>yields</source>
          <target state="translated">yields</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
