<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="relay">
    <body>
      <group id="relay">
        <trans-unit id="f9287b3fad8f092d74f4ec6aadb5a29cf9ba2e63" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2013&amp;ndash;present Facebook Inc.</source>
          <target state="translated">&amp;copy; 2013 &amp;ndash; presente Facebook Inc.</target>
        </trans-unit>
        <trans-unit id="ac2bb4599b07dd7b4cea35d8e273b367c0b66305" translate="yes" xml:space="preserve">
          <source>* Modern API doesn't support mutation fragments. You might have to inline the mutation fragments from your legacy mutation in the fragment of the component.</source>
          <target state="translated">* La API moderna no admite fragmentos de mutaci&amp;oacute;n. Es posible que deba alinear los fragmentos de mutaci&amp;oacute;n de su mutaci&amp;oacute;n heredada en el fragmento del componente.</target>
        </trans-unit>
        <trans-unit id="c225bfc176636425ea153120adefbee642d75cea" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;fragment-container&quot;&gt;&lt;code&gt;createFragmentContainer&lt;/code&gt;&lt;/a&gt; returns a basic container that cannot fetch additional data beyond what is declared in its fragment(s). Relay Modern also provides more advanced containers for dynamic use cases (which were previously handled in Relay Classic via &lt;code&gt;setVariables&lt;/code&gt;):</source>
          <target state="translated">&lt;a href=&quot;fragment-container&quot;&gt; &lt;code&gt;createFragmentContainer&lt;/code&gt; &lt;/a&gt; devuelve un contenedor b&amp;aacute;sico que no puede obtener datos adicionales m&amp;aacute;s all&amp;aacute; de lo declarado en su (s) fragmento (s). Relay Modern tambi&amp;eacute;n proporciona contenedores m&amp;aacute;s avanzados para casos de uso din&amp;aacute;micos (que anteriormente se manejaban en Relay Classic a trav&amp;eacute;s de &lt;code&gt;setVariables&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="77688ea0d1fdf22bab3df470e72bfe7de6cb4724" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://chrome.google.com/webstore/detail/relay-devtools/oppikflppfjfdpjimpdadhelffjpciba&quot;&gt;Chrome Extension&lt;/a&gt; creates a Relay tab in the developer tools interface for debugging apps in Chrome</source>
          <target state="translated">&lt;a href=&quot;https://chrome.google.com/webstore/detail/relay-devtools/oppikflppfjfdpjimpdadhelffjpciba&quot;&gt;La extensi&amp;oacute;n de Chrome&lt;/a&gt; crea una pesta&amp;ntilde;a de retransmisi&amp;oacute;n en la interfaz de herramientas de desarrollador para depurar aplicaciones en Chrome</target>
        </trans-unit>
        <trans-unit id="fad91719b9218a6ae11551221b84fc32086535ed" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt; allows views to be defined as components where every component is responsible for rendering a part of the UI. Composing other components is how to build complex UIs. Each React component doesn't need to know the inner workings of the composed components.</source>
          <target state="translated">&lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt; permite que las vistas se definan como componentes donde cada componente es responsable de representar una parte de la interfaz de usuario. La composici&amp;oacute;n de otros componentes es c&amp;oacute;mo construir interfaces de usuario complejas. Cada componente de React no necesita conocer el funcionamiento interno de los componentes compuestos.</target>
        </trans-unit>
        <trans-unit id="a1980b0d9659b15299523fce23afa9e64733250c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/relayjs/relay-debugger/tree/master/react-native-shell&quot;&gt;Electron App&lt;/a&gt; that connects to React Native apps running Relay</source>
          <target state="translated">&lt;a href=&quot;https://github.com/relayjs/relay-debugger/tree/master/react-native-shell&quot;&gt;Aplicaci&amp;oacute;n Electron&lt;/a&gt; que se conecta a las aplicaciones React Native que ejecutan Relay</target>
        </trans-unit>
        <trans-unit id="0f80ef8cc2241c7509e6613ced8779935dc25b6f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt; manages the execution of the GraphQL query. It sends the query with given variables, parses the response, saves the data to the internal cache, and finally renders the view.</source>
          <target state="translated">&lt;a href=&quot;query-renderer&quot;&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;/a&gt; gestiona la ejecuci&amp;oacute;n de la consulta GraphQL. Env&amp;iacute;a la consulta con las variables dadas, analiza la respuesta, guarda los datos en la cach&amp;eacute; interna y finalmente representa la vista.</target>
        </trans-unit>
        <trans-unit id="cfac86ab065f686a94d7eabf085884e964606374" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;refetch-container&quot;&gt;&lt;code&gt;createRefetchContainer&lt;/code&gt;&lt;/a&gt; is a variation of &lt;code&gt;createFragmentContainer&lt;/code&gt; that addresses the &quot;see more&quot; use case, where a subset of data is rendered initially and then additional data is fetched on demand. Refetch containers initially fetch data for their fragments just like fragment containers, but also offer a &lt;code&gt;refetch()&lt;/code&gt; method by which additional data can be fetched, or the container can be re-rendered to read data using different variables.</source>
          <target state="translated">&lt;a href=&quot;refetch-container&quot;&gt; &lt;code&gt;createRefetchContainer&lt;/code&gt; &lt;/a&gt; es una variaci&amp;oacute;n de &lt;code&gt;createFragmentContainer&lt;/code&gt; que aborda el caso de uso de &quot;ver m&amp;aacute;s&quot;, donde un subconjunto de datos se procesa inicialmente y luego se obtienen datos adicionales a pedido. Los contenedores Refetch inicialmente obtienen datos para sus fragmentos al igual que los contenedores de fragmentos, pero tambi&amp;eacute;n ofrecen unm&amp;eacute;todo &lt;code&gt;refetch()&lt;/code&gt; mediante el cual se pueden recuperar datos adicionales, o el contenedor se puede volver a renderizar para leer datos usando diferentes variables.</target>
        </trans-unit>
        <trans-unit id="f6f0afa9606f188df5aa2880a96f0796da66589e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;relay-compat&quot;&gt;Compat mode&lt;/a&gt; allows the Relay Modern APIs to be incrementally adopted in an existing Relay app. This approach enables the following features compared to Relay Classic:</source>
          <target state="translated">&lt;a href=&quot;relay-compat&quot;&gt;El modo Compat&lt;/a&gt; permite que las API de Relay Modern se adopten de forma incremental en una aplicaci&amp;oacute;n Relay existente. Este enfoque habilita las siguientes caracter&amp;iacute;sticas en comparaci&amp;oacute;n con Relay Classic:</target>
        </trans-unit>
        <trans-unit id="3cc7b1d6acf9a6a36373b7d2788a819c007a696a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; receives a &lt;code&gt;user&lt;/code&gt; prop with plain JavaScript data - objects, arrays, strings - and renders as usual.</source>
          <target state="translated">&lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; recibe un accesorio de &lt;code&gt;user&lt;/code&gt; con datos simples de JavaScript (objetos, matrices, cadenas) y se procesa como de costumbre.</target>
        </trans-unit>
        <trans-unit id="115b4c121f9af58bd42ac1ea726c7c948a8dafc5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@connection&lt;/code&gt; directive</source>
          <target state="translated">&lt;code&gt;@connection&lt;/code&gt; Directiva @connection</target>
        </trans-unit>
        <trans-unit id="b5d3bbc3f0308d432f9237679fd4198f106ffc51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COLLISION_COMMIT_FAILED&lt;/code&gt; &amp;mdash; Transaction was queued for commit but another transaction with the same collision key failed. All transactions in the collision queue, including this one, have been failed. Transaction can be recommitted or rolled back.</source>
          <target state="translated">&lt;code&gt;COLLISION_COMMIT_FAILED&lt;/code&gt; : la transacci&amp;oacute;n se puso en cola para confirmarse, pero otra transacci&amp;oacute;n con la misma clave de colisi&amp;oacute;n fall&amp;oacute;. Todas las transacciones en la cola de colisi&amp;oacute;n, incluida esta, han fallado. La transacci&amp;oacute;n se puede volver a comprometer o deshacer.</target>
        </trans-unit>
        <trans-unit id="8093d07e77e9be3790d54f76445c918f46849774" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COMMITTING&lt;/code&gt; &amp;mdash; Transaction is waiting for the server to respond.</source>
          <target state="translated">&lt;code&gt;COMMITTING&lt;/code&gt; : la transacci&amp;oacute;n est&amp;aacute; esperando que el servidor responda.</target>
        </trans-unit>
        <trans-unit id="72fc89ccfca88827066da906d579a404ab74ce01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COMMIT_FAILED&lt;/code&gt; &amp;mdash; Transaction was sent to the server for comitting but failed.</source>
          <target state="translated">&lt;code&gt;COMMIT_FAILED&lt;/code&gt; : la transacci&amp;oacute;n se envi&amp;oacute; al servidor para su confirmaci&amp;oacute;n, pero fall&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="3ea90f9f79de8b7da5c3c317bc9a5b13f75106bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COMMIT_QUEUED&lt;/code&gt; &amp;mdash; Transaction was committed but another transaction with the same collision key is pending, so the transaction has been queued to send to the server.</source>
          <target state="translated">&lt;code&gt;COMMIT_QUEUED&lt;/code&gt; : la transacci&amp;oacute;n se confirm&amp;oacute; pero hay otra transacci&amp;oacute;n pendiente con la misma clave de colisi&amp;oacute;n, por lo que la transacci&amp;oacute;n se ha puesto en cola para enviarse al servidor.</target>
        </trans-unit>
        <trans-unit id="1f3d026fc6b13bd99ef80b56496208f62a08c9dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Component&lt;/code&gt; Relay container that defines fragments and the view to render.</source>
          <target state="translated">&lt;code&gt;Component&lt;/code&gt; Contenedor de retransmisi&amp;oacute;n de componentes que define los fragmentos y la vista a renderizar.</target>
        </trans-unit>
        <trans-unit id="bfead01c2b218e3cb68f309d9651d5634bcc584a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Container&lt;/code&gt; Relay container that defines fragments and the view to render.</source>
          <target state="translated">&lt;code&gt;Container&lt;/code&gt; Relay contenedor que define los fragmentos y la vista a renderizar.</target>
        </trans-unit>
        <trans-unit id="d52ff52d23e6ad23c71ab30789b670011882899f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PaginationContainer&lt;/code&gt; is designed to simplify the workflow of loading more items in a list -- in many cases, we don't want to fetch all the data at once but lazily load more data. It relies on a GraphQL server exposing connections in a standardized way. For a detailed spec, please check out &lt;a href=&quot;https://facebook.github.io/relay/graphql/connections.htm&quot;&gt;this page&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;PaginationContainer&lt;/code&gt; est&amp;aacute; dise&amp;ntilde;ado para simplificar el flujo de trabajo de cargar m&amp;aacute;s elementos en una lista; en muchos casos, no queremos recuperar todos los datos a la vez, sino cargar m&amp;aacute;s datos de forma perezosa. Se basa en un servidor GraphQL que expone las conexiones de forma estandarizada. Para obtener una especificaci&amp;oacute;n detallada, consulte &lt;a href=&quot;https://facebook.github.io/relay/graphql/connections.htm&quot;&gt;esta p&amp;aacute;gina&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c5406da34447a5b22b7d56f6fce92e419b505424" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;QueryRenderer&lt;/code&gt; is the root of a Relay tree. It takes a query, fetches the data and calls the &lt;code&gt;render&lt;/code&gt; callback with the data.</source>
          <target state="translated">&lt;code&gt;QueryRenderer&lt;/code&gt; es la ra&amp;iacute;z de un &amp;aacute;rbol de retransmisi&amp;oacute;n. Toma una consulta, recupera los datos y llama a la devoluci&amp;oacute;n de llamada de &lt;code&gt;render&lt;/code&gt; con los datos.</target>
        </trans-unit>
        <trans-unit id="593061a9841e95181922e32bf061e078ec44605a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;QueryRenderer&lt;/code&gt; supports rendering small amounts of data directly, instead of requiring a container to access data. &lt;a href=&quot;fragment-container&quot;&gt;Containers&lt;/a&gt; are optional and can be used as your application grows in size and complexity.</source>
          <target state="translated">&lt;code&gt;QueryRenderer&lt;/code&gt; admite la representaci&amp;oacute;n de peque&amp;ntilde;as cantidades de datos directamente, en lugar de requerir un contenedor para acceder a los datos. &lt;a href=&quot;fragment-container&quot;&gt;Los contenedores&lt;/a&gt; son opcionales y se pueden usar a medida que su aplicaci&amp;oacute;n crece en tama&amp;ntilde;o y complejidad.</target>
        </trans-unit>
        <trans-unit id="5dcadb6bea3b3b49c5e438342092e725abab0a3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; doesn't provide any bells and whistles such as fat queries or tracked queries (that is, automatic synthesis at runtime of the mutation query to be sent to the server), instead having the user define a static and explicit query. Restricting yourself to the low-level API is a useful preparatory step that will help you ready your codebase for migration to the new static Relay core. In the meantime, if you want those dynamic features, you can opt in to the higher-level &lt;code&gt;Relay.Mutation&lt;/code&gt; API.</source>
          <target state="translated">&lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; . Restringirse a la API de bajo nivel es un paso preparatorio &amp;uacute;til que lo ayudar&amp;aacute; a preparar su base de c&amp;oacute;digo para la migraci&amp;oacute;n al nuevo n&amp;uacute;cleo de Relay est&amp;aacute;tico. Mientras tanto, si desea esas funciones din&amp;aacute;micas, puede optar por la API &lt;code&gt;Relay.Mutation&lt;/code&gt; de nivel superior .</target>
        </trans-unit>
        <trans-unit id="b9dbe21f8c1dda099d24350958022ccc0bb3f410" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; is a low-level API for modeling a GraphQL mutation.</source>
          <target state="translated">&lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; es una API de bajo nivel para modelar una mutaci&amp;oacute;n GraphQL.</target>
        </trans-unit>
        <trans-unit id="127b1aff45435298c344787323bda31e37d71df8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Relay.QL&lt;/code&gt; objects are used by the following APIs:</source>
          <target state="translated">&lt;code&gt;Relay.QL&lt;/code&gt; objetos Relay.QL son utilizados por las siguientes API:</target>
        </trans-unit>
        <trans-unit id="7e9cc4a6100437d109392de9c4dd32579e5bef54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Relay.Renderer&lt;/code&gt; can then orchestrate the fetching of the queries; diffing them against cached data, fetching any missing information, updating the cache, and finally rendering &lt;code&gt;StoryContainer&lt;/code&gt; once the data is available. The default is to render nothing while data is fetching, but the loading view can be customized via the &lt;code&gt;render&lt;/code&gt; prop. Just as React allows developers to render views without directly manipulating the underlying view, Relay and &lt;code&gt;Relay.Renderer&lt;/code&gt; remove the need to directly communicate with the network.</source>
          <target state="translated">&lt;code&gt;Relay.Renderer&lt;/code&gt; puede entonces orquestar la b&amp;uacute;squeda de las consultas; compar&amp;aacute;ndolos con los datos almacenados en cach&amp;eacute;, &lt;code&gt;StoryContainer&lt;/code&gt; la informaci&amp;oacute;n que falta, actualizando el cach&amp;eacute; y finalmente renderizando StoryContainer una vez que los datos est&amp;aacute;n disponibles. El valor predeterminado es no representar nada mientras se recuperan los datos, pero la vista de carga se puede personalizar a trav&amp;eacute;s del accesorio de &lt;code&gt;render&lt;/code&gt; . As&amp;iacute; como React permite a los desarrolladores renderizar vistas sin manipular directamente la vista subyacente, Relay y &lt;code&gt;Relay.Renderer&lt;/code&gt; eliminan la necesidad de comunicarse directamente con la red.</target>
        </trans-unit>
        <trans-unit id="af18c48993c9562a944639b49a29f4455950bbaf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Relay&lt;/code&gt; is the entry point to the Relay library. If you're using one of the prebuilt packages it's available as a global; if you're using CommonJS modules you can &lt;code&gt;require()&lt;/code&gt; it.</source>
          <target state="translated">&lt;code&gt;Relay&lt;/code&gt; es el punto de entrada a la biblioteca Relay. Si est&amp;aacute; utilizando uno de los paquetes predise&amp;ntilde;ados, est&amp;aacute; disponible como global; si est&amp;aacute; utilizando m&amp;oacute;dulos CommonJS, puede &lt;code&gt;require()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c66e5b2f381152669b034d6f6167ad8cf6ed012" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RelayContainer&lt;/code&gt; is a higher-order React component that lets a React component encode its data requirements.</source>
          <target state="translated">&lt;code&gt;RelayContainer&lt;/code&gt; es un componente React de orden superior que permite que un componente React codifique sus requisitos de datos.</target>
        </trans-unit>
        <trans-unit id="df2d84ab4a50cd1673857a423e00806293940147" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RelayMutationRequest&lt;/code&gt; encapsulates a mutation that Relay needs to send to the server. They are made available to network layers via the &lt;code&gt;sendMutation&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;RelayMutationRequest&lt;/code&gt; encapsula una mutaci&amp;oacute;n que Relay necesita enviar al servidor. Se ponen a disposici&amp;oacute;n de las capas de red mediante el m&amp;eacute;todo &lt;code&gt;sendMutation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e4dc52a29a31a839078a5cad953c9628f74f0f0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RelayMutationTransaction.getStatus&lt;/code&gt; can return one of the following strings:</source>
          <target state="translated">&lt;code&gt;RelayMutationTransaction.getStatus&lt;/code&gt; puede devolver una de las siguientes cadenas:</target>
        </trans-unit>
        <trans-unit id="242d9ea8a1f2fba8d773760a8233ecf37bf7b5f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RelayQueryRequest&lt;/code&gt; encapsulates a query that Relay needs to send to the server. They are made available to network layers via the &lt;code&gt;sendQueries&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;RelayQueryRequest&lt;/code&gt; encapsula una consulta que Relay necesita enviar al servidor. Est&amp;aacute;n disponibles para las capas de red a trav&amp;eacute;s del m&amp;eacute;todo &lt;code&gt;sendQueries&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df62ea345a45d0a5fabcd2fdbf901148c6e5a8b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNCOMMITTED&lt;/code&gt; &amp;mdash; Transaction hasn't yet been sent to the server. Transaction can be committed or rolled back.</source>
          <target state="translated">&lt;code&gt;UNCOMMITTED&lt;/code&gt; : la transacci&amp;oacute;n a&amp;uacute;n no se ha enviado al servidor. La transacci&amp;oacute;n se puede confirmar o deshacer.</target>
        </trans-unit>
        <trans-unit id="50a52e374bfb1a67a3f6d2363ba22492f2e2e80d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;configs&lt;/code&gt;: an array containing the different optimisticUpdater/updater configurations. It provides a convenient way to specify the &lt;code&gt;updater&lt;/code&gt; behavior.</source>
          <target state="translated">&lt;code&gt;configs&lt;/code&gt; : una matriz que contiene las diferentes configuraciones optimisticUpdater / Updater. Proporciona una forma conveniente de especificar el comportamiento del &lt;code&gt;updater&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cc60f97e29bfb6ea62a807eae2cc5e7a17f3eb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;configs&lt;/code&gt;: an array containing the updater configurations. It is the same as &lt;a href=&quot;mutations#configs&quot;&gt;&lt;code&gt;configs&lt;/code&gt;&lt;/a&gt; in &lt;code&gt;commitMutation&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;configs&lt;/code&gt; : una matriz que contiene las configuraciones del actualizador. Es lo mismo que &lt;a href=&quot;mutations#configs&quot;&gt; &lt;code&gt;configs&lt;/code&gt; &lt;/a&gt; en &lt;code&gt;commitMutation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9394dd3d6a30c68a04fbce9521aacc5342c5da92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;connectionInfo: Array&amp;lt;{key: string, filters?: Variables, rangeBehavior:
string}&amp;gt;&lt;/code&gt;: An array of objects containing a connection key, an object containing optional filters, and a range behavior depending on what behavior we expect (append, prepend, or ignore).</source>
          <target state="translated">&lt;code&gt;connectionInfo: Array&amp;lt;{key: string, filters?: Variables, rangeBehavior: string}&amp;gt;&lt;/code&gt; : una matriz de objetos que contiene una clave de conexi&amp;oacute;n, un objeto que contiene filtros opcionales y un comportamiento de rango seg&amp;uacute;n el comportamiento que esperamos (a&amp;ntilde;adir, anteponer, o ignorar).</target>
        </trans-unit>
        <trans-unit id="43c66a2069ec0b2d4be35833e1ae8977d9b93edf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;connectionKeys: Array&amp;lt;{key: string, filters?: Variables}&amp;gt;&lt;/code&gt;: An array of objects containing a connection key and optionally filters.</source>
          <target state="translated">&lt;code&gt;connectionKeys: Array&amp;lt;{key: string, filters?: Variables}&amp;gt;&lt;/code&gt; : Una matriz de objetos que contiene una clave de conexi&amp;oacute;n y, opcionalmente, filtros.</target>
        </trans-unit>
        <trans-unit id="d19b3e482db84864f686a4ee3759da01773329b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deletedIDFieldName: string | Array&amp;lt;string&amp;gt;&lt;/code&gt;: The field name in the response that contains the DataID of the removed node, or the path to the node removed from the connection</source>
          <target state="translated">&lt;code&gt;deletedIDFieldName: string | Array&amp;lt;string&amp;gt;&lt;/code&gt; : el nombre del campo en la respuesta que contiene el DataID del nodo eliminado, o la ruta al nodo eliminado de la conexi&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="e977f6b2b4f562aa7af31b00751819ad50d520ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deletedIDFieldName: string&lt;/code&gt;: The field name in the response that contains the DataID of the deleted node</source>
          <target state="translated">&lt;code&gt;deletedIDFieldName: string&lt;/code&gt; : el nombre del campo en la respuesta que contiene el DataID del nodo eliminado</target>
        </trans-unit>
        <trans-unit id="22bd764f98c24605fee21c6e86534a102d352d4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;edgeName: string&lt;/code&gt;: The field name in the response that represents the newly created edge</source>
          <target state="translated">&lt;code&gt;edgeName: string&lt;/code&gt; : el nombre del campo en la respuesta que representa el borde reci&amp;eacute;n creado</target>
        </trans-unit>
        <trans-unit id="b7ab967dc3d9dac41042965f33de5bbacae6b0e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;environment&lt;/code&gt; An instance of `Relay.Environment` or any object that implements the `RelayEnvironment` interface.</source>
          <target state="translated">&lt;code&gt;environment&lt;/code&gt; Una instancia de `Relay.Environment` o cualquier objeto que implemente la interfaz` RelayEnvironment`.</target>
        </trans-unit>
        <trans-unit id="6a65d389a718020e07ebee40da7bdd44c16a4420" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filters&lt;/code&gt;: An object containing GraphQL calls e.g. &lt;code&gt;const filters = {'orderby': 'chronological'};&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;filters&lt;/code&gt; : un objeto que contiene llamadas GraphQL, por ejemplo, &lt;code&gt;const filters = {'orderby': 'chronological'};&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41eb5ef20bb9fe4e11e5a7ba243c250838991a3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forceFetch&lt;/code&gt; Whether to send a server request regardless of data available on the client.</source>
          <target state="translated">&lt;code&gt;forceFetch&lt;/code&gt; Si se debe enviar una solicitud al servidor independientemente de los datos disponibles en el cliente.</target>
        </trans-unit>
        <trans-unit id="d556d0cc8a6f2287f3af67eacd90ec1629094411" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forceFetch&lt;/code&gt; can be called with an empty set of partial variables, meaning it can trigger a refresh of the currently rendered set of data.</source>
          <target state="translated">&lt;code&gt;forceFetch&lt;/code&gt; se puede llamar con un conjunto vac&amp;iacute;o de variables parciales, lo que significa que puede activar una actualizaci&amp;oacute;n del conjunto de datos actualmente renderizado.</target>
        </trans-unit>
        <trans-unit id="7c4e5ec515c48d1d775f76f1e41f31d520e97786" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forceFetch&lt;/code&gt; is similar to &lt;code&gt;setVariables&lt;/code&gt; because it is also used to change the data requirements by altering &lt;code&gt;variables&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;forceFetch&lt;/code&gt; es similar a &lt;code&gt;setVariables&lt;/code&gt; porque tambi&amp;eacute;n se usa para cambiar los requisitos de datos al alterar las &lt;code&gt;variables&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78c6f70e52f47838301be68f3a7fc35ddbd14be0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fragments&lt;/code&gt; Declare the component's data requirements using fragments.</source>
          <target state="translated">&lt;code&gt;fragments&lt;/code&gt; Declare los requisitos de datos del componente utilizando fragmentos.</target>
        </trans-unit>
        <trans-unit id="ffcebb96656094f38726e63b34eb65150f50c9ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getFragment(name[, vars])&lt;/code&gt; Get a reference to a container fragment for inclusion in a parent fragment.</source>
          <target state="translated">&lt;code&gt;getFragment(name[, vars])&lt;/code&gt; Obtiene una referencia a un fragmento de contenedor para incluirlo en un fragmento principal.</target>
        </trans-unit>
        <trans-unit id="4d2af946a8f787de1546269d02d1783ad16d7ce4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;initialVariables&lt;/code&gt; The initial set of variable values available to this component's fragments.</source>
          <target state="translated">&lt;code&gt;initialVariables&lt;/code&gt; El conjunto inicial de valores de variable disponibles para los fragmentos de este componente.</target>
        </trans-unit>
        <trans-unit id="563c728f73a72af11f9bfebcd489b1605c4ad5b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutation&lt;/code&gt;: the &lt;code&gt;graphql&lt;/code&gt; tagged mutation query.</source>
          <target state="translated">&lt;code&gt;mutation&lt;/code&gt; : la consulta de mutaci&amp;oacute;n con etiqueta &lt;code&gt;graphql&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6a934fa0ef96a565381122a89d9aee1a4fba9dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onCompleted&lt;/code&gt;: a callback function executed when the subscription is closed by the peer without error.</source>
          <target state="translated">&lt;code&gt;onCompleted&lt;/code&gt; : una funci&amp;oacute;n de devoluci&amp;oacute;n de llamada que se ejecuta cuando el par cierra la suscripci&amp;oacute;n sin errores.</target>
        </trans-unit>
        <trans-unit id="a715680a7bcdc7a8e18cff64218bee6c4c5f714a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onCompleted&lt;/code&gt;: a callback function executed with the 'raw' response and errors from the server after the in-memory Relay store is updated with the &lt;code&gt;updater&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;onCompleted&lt;/code&gt; : una funci&amp;oacute;n de devoluci&amp;oacute;n de llamada ejecutada con la respuesta 'sin procesar' y los errores del servidor despu&amp;eacute;s de que el almac&amp;eacute;n de retransmisi&amp;oacute;n en memoria se actualice con el &lt;code&gt;updater&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e17c27700518dd0a0d9e3907f0ead05f610d8e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onError&lt;/code&gt;: a callback function executed when Relay encounters an error.</source>
          <target state="translated">&lt;code&gt;onError&lt;/code&gt; : una funci&amp;oacute;n de devoluci&amp;oacute;n de llamada que se ejecuta cuando Relay encuentra un error.</target>
        </trans-unit>
        <trans-unit id="5632405e91380cb8466949662b4346c6b8f63bac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onError&lt;/code&gt;: a callback function executed when Relay or the server encounters an error processing the subscription.</source>
          <target state="translated">&lt;code&gt;onError&lt;/code&gt; : una funci&amp;oacute;n de devoluci&amp;oacute;n de llamada que se ejecuta cuando Relay o el servidor encuentran un error al procesar la suscripci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="13f38fe85bb18ed69b3110347c91c063ca63f296" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onFailure&lt;/code&gt; is called if the mutation failed.</source>
          <target state="translated">&lt;code&gt;onFailure&lt;/code&gt; se llama si la mutaci&amp;oacute;n fall&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="34b282489eb2fc659bf8f182ecccfa58a4f98bbf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onNext&lt;/code&gt;: a callback function executed each time a response is received from the server, with the raw GraphQL response payload.</source>
          <target state="translated">&lt;code&gt;onNext&lt;/code&gt; : una funci&amp;oacute;n de devoluci&amp;oacute;n de llamada que se ejecuta cada vez que se recibe una respuesta del servidor, con la carga &amp;uacute;til de respuesta GraphQL sin procesar.</target>
        </trans-unit>
        <trans-unit id="b0c18e8b6186d7338bef8b15b59ec6ca63cd0225" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onSuccess&lt;/code&gt; is called if the mutation succeeded.</source>
          <target state="translated">&lt;code&gt;onSuccess&lt;/code&gt; Se llama a onSuccess si la mutaci&amp;oacute;n tuvo &amp;eacute;xito.</target>
        </trans-unit>
        <trans-unit id="5a1dc36be8e9a3f9069b3ce5c93735b18dee1d9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;optimisticResponse&lt;/code&gt;: an object conforming to the mutation's response type definition. If provided, the optimistic response will be normalized to the proxy store before &lt;code&gt;optimisticUpdater&lt;/code&gt; is executed. We suggest you provide an &lt;code&gt;optimisticResponse&lt;/code&gt; for two benefits:</source>
          <target state="translated">&lt;code&gt;optimisticResponse&lt;/code&gt; : un objeto que se ajusta a la definici&amp;oacute;n del tipo de respuesta de la mutaci&amp;oacute;n. Si se proporciona, la respuesta optimista se normalizar&amp;aacute; en el almac&amp;eacute;n proxy antes de que se ejecute &lt;code&gt;optimisticUpdater&lt;/code&gt; . Le sugerimos que proporcione una &lt;code&gt;optimisticResponse&lt;/code&gt; para dos beneficios:</target>
        </trans-unit>
        <trans-unit id="ace8dc4f2ade074a4518666a5d5ce3fc892c20c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;optimisticUpdater&lt;/code&gt;: a function that takes in a proxy of the in-memory Relay store. In this function, the client defines 'how to' update the store through the proxy in an imperative way.</source>
          <target state="translated">&lt;code&gt;optimisticUpdater&lt;/code&gt; : una funci&amp;oacute;n que toma un proxy del almac&amp;eacute;n de retransmisi&amp;oacute;n en memoria. En esta funci&amp;oacute;n, el cliente define 'c&amp;oacute;mo' actualizar la tienda a trav&amp;eacute;s del proxy de forma imperativa.</target>
        </trans-unit>
        <trans-unit id="b45ed0f29925a557b65dfee5d20499e8f93783ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parentID: string&lt;/code&gt;: The DataID of the parent node that contains the connection.</source>
          <target state="translated">&lt;code&gt;parentID: string&lt;/code&gt; : el DataID del nodo principal que contiene la conexi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="90d6f234e369d7056e4a4a384ce4d56b75c66508" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pathToConnection: Array&amp;lt;string&amp;gt;&lt;/code&gt;: An array containing the field names between the parent and the connection, including the parent and the connection.</source>
          <target state="translated">&lt;code&gt;pathToConnection: Array&amp;lt;string&amp;gt;&lt;/code&gt; : una matriz que contiene los nombres de campo entre el padre y la conexi&amp;oacute;n, incluido el padre y la conexi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ca3a99f863b6d6006d89f122d91acd2466426ca1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pendingVariables&lt;/code&gt; contains the set of variables that are being used to fetch the new props, i.e. when &lt;code&gt;this.props.relay.setVariables()&lt;/code&gt; or &lt;code&gt;this.props.relay.forceFetch()&lt;/code&gt; are called and the corresponding request is in flight.</source>
          <target state="translated">&lt;code&gt;pendingVariables&lt;/code&gt; contiene el conjunto de variables que se est&amp;aacute;n utilizando para obtener los nuevos accesorios, es decir, cuando se &lt;code&gt;this.props.relay.setVariables()&lt;/code&gt; o &lt;code&gt;this.props.relay.forceFetch()&lt;/code&gt; y la solicitud correspondiente est&amp;aacute; en curso .</target>
        </trans-unit>
        <trans-unit id="5294d02523abdadc7890c4089fd2d771e0103adf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prepareVariables&lt;/code&gt; A method to modify the variables based on the runtime environment or previous variable values.</source>
          <target state="translated">&lt;code&gt;prepareVariables&lt;/code&gt; Un m&amp;eacute;todo para modificar las variables seg&amp;uacute;n el entorno de ejecuci&amp;oacute;n o los valores de las variables anteriores.</target>
        </trans-unit>
        <trans-unit id="85e836212ec7a6f4cf39b03986865be121a0bbd5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;queryConfig&lt;/code&gt; `QueryConfig` or `Relay.Route` that defines the query roots.</source>
          <target state="translated">&lt;code&gt;queryConfig&lt;/code&gt; `QueryConfig` o` Relay.Route` que define las ra&amp;iacute;ces de la consulta.</target>
        </trans-unit>
        <trans-unit id="32d83449d21fcdf971b3e1c1d76474fe6f62d3af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refetchVariables&lt;/code&gt; is either a bag of variables or a function that takes in the previous fragment variables and returns new variables.</source>
          <target state="translated">&lt;code&gt;refetchVariables&lt;/code&gt; es una bolsa de variables o una funci&amp;oacute;n que toma las variables de fragmentos anteriores y devuelve nuevas variables.</target>
        </trans-unit>
        <trans-unit id="4ae4f5a5447be2154beefea2867a35b518a781d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;render&lt;/code&gt; Called to render when data requirements are being fulfilled.</source>
          <target state="translated">&lt;code&gt;render&lt;/code&gt; Se llama para renderizar cuando se cumplen los requisitos de datos.</target>
        </trans-unit>
        <trans-unit id="55e1260e99e337d383bed6b4b9c2df2228a1e749" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;renderFailure&lt;/code&gt; Called to render when data failed to be fulfilled.</source>
          <target state="translated">&lt;code&gt;renderFailure&lt;/code&gt; Llamado para renderizar cuando los datos no se cumplieron.</target>
        </trans-unit>
        <trans-unit id="a6131b3d70611a404b4ea7dd80f5758c5105f7c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;renderFetched&lt;/code&gt; Called to render when data requirements are fulfilled.</source>
          <target state="translated">&lt;code&gt;renderFetched&lt;/code&gt; Se llama para renderizar cuando se cumplen los requisitos de datos.</target>
        </trans-unit>
        <trans-unit id="1901f50529efd372e2c626214284f332709348a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;renderLoading&lt;/code&gt; Called to render when data requirements are being fulfilled.</source>
          <target state="translated">&lt;code&gt;renderLoading&lt;/code&gt; Se llama para renderizar cuando se cumplen los requisitos de datos.</target>
        </trans-unit>
        <trans-unit id="b0fe2435dec450eee6998923c41267267d40d7d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;renderVariables&lt;/code&gt; is an optional param that tells Relay which variables to use at when the component is re-rendered after fetching. Without this, the &lt;code&gt;refetchVariables&lt;/code&gt; will be used. You might use this for more advanced usage, for example, to implement pagination, where you would fetch an additional page with variables like &lt;code&gt;{first: 5, after: '...'}&lt;/code&gt;, but you would then render the full collection with &lt;code&gt;{first: 10}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;renderVariables&lt;/code&gt; es un par&amp;aacute;metro opcional que le dice a Relay qu&amp;eacute; variables usar cuando el componente se vuelve a renderizar despu&amp;eacute;s de obtenerlo. Sin esto, se utilizar&amp;aacute; &lt;code&gt;refetchVariables&lt;/code&gt; . Puede usar esto para un uso m&amp;aacute;s avanzado, por ejemplo, para implementar la paginaci&amp;oacute;n, donde buscar&amp;iacute;a una p&amp;aacute;gina adicional con variables como &lt;code&gt;{first: 5, after: '...'}&lt;/code&gt; , pero luego renderizar&amp;iacute;a la colecci&amp;oacute;n completa con &lt;code&gt;{first: 10}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cef4511de2692e7e2831022f07230dabf3496cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;route&lt;/code&gt; Route that defines the query roots.</source>
          <target state="translated">&lt;code&gt;route&lt;/code&gt; Ruta que define las ra&amp;iacute;ces de la consulta.</target>
        </trans-unit>
        <trans-unit id="de20a20a67577265acad0e1c8760490f6ae7d671" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setVariables&lt;/code&gt; does not immediately mutate &lt;code&gt;variables&lt;/code&gt;, but creates a pending state transition. &lt;code&gt;variables&lt;/code&gt; will continue returning the previous values until &lt;code&gt;this.props&lt;/code&gt; has been populated with data that fulfills the new variable values.</source>
          <target state="translated">&lt;code&gt;setVariables&lt;/code&gt; no muta &lt;code&gt;variables&lt;/code&gt; inmediatamente , sino que crea una transici&amp;oacute;n de estado pendiente. &lt;code&gt;variables&lt;/code&gt; continuar&amp;aacute;n devolviendo los valores anteriores hasta que &lt;code&gt;this.props&lt;/code&gt; se haya llenado con datos que cumplan con los nuevos valores de las variables.</target>
        </trans-unit>
        <trans-unit id="943d019e3b13e343df13a6484ab6136c7156b4e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shouldComponentUpdate&lt;/code&gt; Optionally override RelayContainer's default implementation of `shouldComponentUpdate`.</source>
          <target state="translated">&lt;code&gt;shouldComponentUpdate&lt;/code&gt; Opcionalmente anula la implementaci&amp;oacute;n predeterminada de RelayContainer de `shouldComponentUpdate`.</target>
        </trans-unit>
        <trans-unit id="c12be4a70a038cd4741cb2b9e30195491469abee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static Container: ReactPropTypeValidator&lt;/code&gt; A prop type validator asserting that a prop is a valid Relay container.</source>
          <target state="translated">&lt;code&gt;static Container: ReactPropTypeValidator&lt;/code&gt; Un validador de tipo de prop que afirma que un prop es un contenedor de retransmisi&amp;oacute;n v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="3b4467abcecc2f5f6147438c2f223473973407a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static QueryConfig: ReactPropTypeValidator&lt;/code&gt; A prop type validator asserting that a prop is a valid route.</source>
          <target state="translated">&lt;code&gt;static QueryConfig: ReactPropTypeValidator&lt;/code&gt; Un validador de tipo prop que afirma que un prop es una ruta v&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="40e983f1da84aaeb0774f71c8242e17b35be1f2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static applyUpdate(mutation, callbacks)&lt;/code&gt; Adds a MutationTransaction to the queue without committing it.</source>
          <target state="translated">&lt;code&gt;static applyUpdate(mutation, callbacks)&lt;/code&gt; Agrega una MutationTransaction a la cola sin confirmarla.</target>
        </trans-unit>
        <trans-unit id="b4d03961b864a4ab573535d598407abfc411cce4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static commitUpdate(mutation, callbacks)&lt;/code&gt; Initiate processing of a mutation.</source>
          <target state="translated">&lt;code&gt;static commitUpdate(mutation, callbacks)&lt;/code&gt; Iniciar el procesamiento de una mutaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9eebf1a07ed283d2bbed2b968ffb38df36fad9ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static create(mutation, variables, environment)&lt;/code&gt; Create a static mutation</source>
          <target state="translated">&lt;code&gt;static create(mutation, variables, environment)&lt;/code&gt; Crea una mutaci&amp;oacute;n est&amp;aacute;tica</target>
        </trans-unit>
        <trans-unit id="658d18c4b39964f6d9e02a8d4f13d6ca5179a919" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static createContainer(Component, ContainerConfig)&lt;/code&gt; Creates a Relay Container.</source>
          <target state="translated">&lt;code&gt;static createContainer(Component, ContainerConfig)&lt;/code&gt; Crea un contenedor de retransmisiones.</target>
        </trans-unit>
        <trans-unit id="ac50a770322cba5b662ec0bbf60235d57453db96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static createWithFiles(mutation, variables, files, environment)&lt;/code&gt; Create a static mutation that accepts a &quot;files&quot; object</source>
          <target state="translated">&lt;code&gt;static createWithFiles(mutation, variables, files, environment)&lt;/code&gt; Crea una mutaci&amp;oacute;n est&amp;aacute;tica que acepta un objeto &quot;archivos&quot;</target>
        </trans-unit>
        <trans-unit id="a985a4f33765191da82de5eb97d6c665b299a3b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static fragments&lt;/code&gt; Declare this mutation's data dependencies here</source>
          <target state="translated">&lt;code&gt;static fragments&lt;/code&gt; Declare aqu&amp;iacute; las dependencias de datos de esta mutaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="a1697fb2f2da73763242483e979b5b34e6797e53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static initialVariables&lt;/code&gt; A default set of variables to make available to this mutation's fragment builders</source>
          <target state="translated">&lt;code&gt;static initialVariables&lt;/code&gt; Un conjunto predeterminado de variables para poner a disposici&amp;oacute;n de los constructores de fragmentos de esta mutaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="9ac61312fa144b893336d3bbdf88826d0034494e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static injectNetworkLayer(networkLayer)&lt;/code&gt; Customize how queries and mutations are sent to the server.</source>
          <target state="translated">&lt;code&gt;static injectNetworkLayer(networkLayer)&lt;/code&gt; Personalice c&amp;oacute;mo se env&amp;iacute;an las consultas y mutaciones al servidor.</target>
        </trans-unit>
        <trans-unit id="49b31e2fd0ee618819eb9668ad9fab057dc448c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static injectTaskScheduler(scheduler)&lt;/code&gt; Configure when Relay processing occurs.</source>
          <target state="translated">&lt;code&gt;static injectTaskScheduler(scheduler)&lt;/code&gt; Configure cu&amp;aacute;ndo se produce el procesamiento de retransmisi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="3e8afe33d507124df2cb20b712a24c4d395ceeb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static isContainer(Component)&lt;/code&gt; Determine if a given object is a Relay.Container.</source>
          <target state="translated">&lt;code&gt;static isContainer(Component)&lt;/code&gt; Determina si un objeto dado es un Relay.Container.</target>
        </trans-unit>
        <trans-unit id="7938dae1f9d2455348151916c16933ea1c4109f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static paramDefinitions&lt;/code&gt; Declare the expected parameters.</source>
          <target state="translated">&lt;code&gt;static paramDefinitions&lt;/code&gt; Declara los par&amp;aacute;metros esperados.</target>
        </trans-unit>
        <trans-unit id="047db3ec3d910088d59dd144e9064188d5d64b54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static prepareParams&lt;/code&gt; Declare additional parameters or conversion for parameters.</source>
          <target state="translated">&lt;code&gt;static prepareParams&lt;/code&gt; Declara par&amp;aacute;metros adicionales o conversi&amp;oacute;n de par&amp;aacute;metros.</target>
        </trans-unit>
        <trans-unit id="4b2b9762a4218dc52cee63114d0eee0ed5d04c5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static prepareVariables&lt;/code&gt; A method to modify the variables based on the runtime environment, previous variables, or the meta route</source>
          <target state="translated">&lt;code&gt;static prepareVariables&lt;/code&gt; Un m&amp;eacute;todo para modificar las variables seg&amp;uacute;n el entorno de ejecuci&amp;oacute;n, las variables anteriores o la meta ruta</target>
        </trans-unit>
        <trans-unit id="2b49e3d2f4dae0d69deb0f6c24085a44cc8a3c5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static queries&lt;/code&gt; Declare the set of query roots.</source>
          <target state="translated">&lt;code&gt;static queries&lt;/code&gt; Declaran el conjunto de ra&amp;iacute;ces de consultas.</target>
        </trans-unit>
        <trans-unit id="0c43ab95deb00b1e6ba46964ae86ac05d717b874" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static routeName&lt;/code&gt; Declare the name of this route class.</source>
          <target state="translated">&lt;code&gt;static routeName&lt;/code&gt; Declare el nombre de esta clase de ruta.</target>
        </trans-unit>
        <trans-unit id="91acf728df7357ed2ba9977f2e4aae1aa271198d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subscription&lt;/code&gt;: the &lt;code&gt;graphql&lt;/code&gt; tagged subscription query.</source>
          <target state="translated">&lt;code&gt;subscription&lt;/code&gt; : la consulta de suscripci&amp;oacute;n etiquetada por &lt;code&gt;graphql&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12ff8bacf233237929ba38ec484648a655ad7959" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.props.relay.setVariables&lt;/code&gt; can be called to update a subset or all of the variables at the same time. In return, Relay will use the new variables to attempt to fulfill the new fragment. This may involve sending a request to the server if data is not already available on the client.</source>
          <target state="translated">&lt;code&gt;this.props.relay.setVariables&lt;/code&gt; se puede llamar para actualizar un subconjunto o todas las variables al mismo tiempo. A cambio, Relay utilizar&amp;aacute; las nuevas variables para intentar completar el nuevo fragmento. Esto puede implicar enviar una solicitud al servidor si los datos a&amp;uacute;n no est&amp;aacute;n disponibles en el cliente.</target>
        </trans-unit>
        <trans-unit id="c005f6461f75206bcbc927906f1de20a4cf2e450" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.props.relay&lt;/code&gt; exports the following API to execute the refetch query:</source>
          <target state="translated">&lt;code&gt;this.props.relay&lt;/code&gt; exporta la siguiente API para ejecutar la consulta de recuperaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="7d9577972a7c4a8c614b22a037eaeff82248e3f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.props.relay&lt;/code&gt; exposes the following APIs:</source>
          <target state="translated">&lt;code&gt;this.props.relay&lt;/code&gt; expone las siguientes API:</target>
        </trans-unit>
        <trans-unit id="3d07b37e84a778ceb1461d9bbc1f056984d50a27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.props.setVariables&lt;/code&gt; from the old API does not have a direct equivalent in the new API. A big reason for this change is that the new core no longer tracks how to refetch any specific sub-tree from the query. This makes the new core a lot faster, but requires explicit queries for how to fetch new data. Check out these four different scenarios:</source>
          <target state="translated">&lt;code&gt;this.props.setVariables&lt;/code&gt; de la antigua API no tiene un equivalente directo en la nueva API. Una gran raz&amp;oacute;n para este cambio es que el nuevo n&amp;uacute;cleo ya no rastrea c&amp;oacute;mo recuperar ning&amp;uacute;n sub&amp;aacute;rbol espec&amp;iacute;fico de la consulta. Esto hace que el nuevo n&amp;uacute;cleo sea mucho m&amp;aacute;s r&amp;aacute;pido, pero requiere consultas expl&amp;iacute;citas sobre c&amp;oacute;mo obtener nuevos datos. Vea estos cuatro escenarios diferentes:</target>
        </trans-unit>
        <trans-unit id="25ab1a5db284767b82e6bbe83b1d6bb7782d76cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;updater&lt;/code&gt;: a function that updates the in-memory Relay store based on the &lt;strong&gt;real&lt;/strong&gt; server response. When the server response comes back, Relay first reverts any changes introduced by &lt;code&gt;optimisticUpdater&lt;/code&gt; or &lt;code&gt;optimisticResponse&lt;/code&gt; and then applies the &lt;code&gt;updater&lt;/code&gt; to the store.</source>
          <target state="translated">&lt;code&gt;updater&lt;/code&gt; : una funci&amp;oacute;n que actualiza el almac&amp;eacute;n de rel&amp;eacute;s en memoria en funci&amp;oacute;n de la respuesta del servidor &lt;strong&gt;real&lt;/strong&gt; . Cuando vuelve la respuesta del servidor, Relay primero revierte cualquier cambio introducido por &lt;code&gt;optimisticUpdater&lt;/code&gt; o &lt;code&gt;optimisticResponse&lt;/code&gt; y luego aplica el &lt;code&gt;updater&lt;/code&gt; a la tienda.</target>
        </trans-unit>
        <trans-unit id="9e752995a456f07b23c9c5955036c90c0eaa7d48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;updater&lt;/code&gt;: an optional function that can supply custom logic for updating the in-memory Relay store based on the server response.</source>
          <target state="translated">&lt;code&gt;updater&lt;/code&gt; : una funci&amp;oacute;n opcional que puede proporcionar l&amp;oacute;gica personalizada para actualizar el almac&amp;eacute;n de rel&amp;eacute;s en memoria seg&amp;uacute;n la respuesta del servidor.</target>
        </trans-unit>
        <trans-unit id="ed67a9853586c7a825bf549e62d6668d890318cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;variables&lt;/code&gt; contains the set of variables that was used to fetch the current set of props.</source>
          <target state="translated">&lt;code&gt;variables&lt;/code&gt; contiene el conjunto de variables que se utiliz&amp;oacute; para recuperar el conjunto actual de accesorios.</target>
        </trans-unit>
        <trans-unit id="7e388933696fbe367df975da86d5ab73799cb8d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;variables&lt;/code&gt;: an object that contains the variables needed for the mutation.</source>
          <target state="translated">&lt;code&gt;variables&lt;/code&gt; : un objeto que contiene las variables necesarias para la mutaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6e219c17510eb13b16577519ca778d9468c7499a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;variables&lt;/code&gt;: an object that contains the variables needed for the subscription.</source>
          <target state="translated">&lt;code&gt;variables&lt;/code&gt; : un objeto que contiene las variables necesarias para la suscripci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a3d9fd11099be9837becddb07ecac412bfe16922" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;code&gt;babel-relay-plugin&lt;/code&gt; is deprecated. Use &lt;a href=&quot;babel-plugin-relay#using-with-relay-classic&quot;&gt;&lt;code&gt;babel-plugin-relay&lt;/code&gt;&lt;/a&gt; with Relay Classic.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;babel-relay-plugin&lt;/code&gt; est&amp;aacute; en desuso. Utilice &lt;a href=&quot;babel-plugin-relay#using-with-relay-classic&quot;&gt; &lt;code&gt;babel-plugin-relay&lt;/code&gt; &lt;/a&gt; con Relay Classic.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="885b12f18c1ce790e1ceb37bdac14666bf969046" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Container Specification&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Especificaci&amp;oacute;n del contenedor&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2dc48bdb0f1a664344b42c6cc9f80bf54c93c0af" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Methods&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Methods&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="372322cdb4339a090833f173c5459433d9f3a2a3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Properties and Methods&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Propiedades y m&amp;eacute;todos&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2e24a7da3b4c78d1c9bb8ad4a5672d259fcf1c7d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Properties&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Properties&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b288f7cf5165d63b23f3a477f7c62696473947e3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Props&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Props&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c13abeef99d46d6cc5a5891d80bde92ef26cfbac" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Static Methods&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;M&amp;eacute;todos est&amp;aacute;ticos&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f0677ff5e5e4c313a098291e00353714c69a25eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/graphcool/graphql-up&quot;&gt;graphql-up&lt;/a&gt;&lt;/strong&gt; on &lt;a href=&quot;https://www.npmjs.com/package/graphql-up&quot;&gt;npm&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/graphcool/graphql-up&quot;&gt;graphql-up&lt;/a&gt;&lt;/strong&gt; en&lt;a href=&quot;https://www.npmjs.com/package/graphql-up&quot;&gt; npm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1a854faa5d5c2fb2a3f2a62f519c3dae0ea44c47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/express-graphql&quot;&gt;express-graphql&lt;/a&gt;&lt;/strong&gt; on &lt;a href=&quot;https://www.npmjs.com/package/express-graphql&quot;&gt;npm&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/express-graphql&quot;&gt;express-graphql&lt;/a&gt;&lt;/strong&gt; en&lt;a href=&quot;https://www.npmjs.com/package/express-graphql&quot;&gt; npm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6882e7b1150b43a134cd9463ab13037397e9d8a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;graphql-js&lt;/a&gt;&lt;/strong&gt; on &lt;a href=&quot;https://www.npmjs.com/package/graphql&quot;&gt;npm&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;graphql-js&lt;/a&gt;&lt;/strong&gt; en&lt;a href=&quot;https://www.npmjs.com/package/graphql&quot;&gt; npm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4615a7abdf175713f1dd713a45e9b36b49db0dd8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/graphql-relay-js&quot;&gt;graphql-relay-js&lt;/a&gt;&lt;/strong&gt; on &lt;a href=&quot;https://www.npmjs.com/package/graphql-relay&quot;&gt;npm&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/graphql-relay-js&quot;&gt;graphql-relay-js&lt;/a&gt;&lt;/strong&gt; en&lt;a href=&quot;https://www.npmjs.com/package/graphql-relay&quot;&gt; npm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="57698c2dcaa9317f5b6564784890d536ca0db31a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://www.graph.cool/&quot;&gt;Graphcool&lt;/a&gt;&lt;/strong&gt; (&lt;a href=&quot;https://www.graph.cool/docs/quickstart/&quot;&gt;Quickstart tutorial&lt;/a&gt;)</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://www.graph.cool/&quot;&gt;Graphcool&lt;/a&gt;&lt;/strong&gt; (&lt;a href=&quot;https://www.graph.cool/docs/quickstart/&quot;&gt; tutorial de &lt;/a&gt;&lt;strong&gt;inicio&lt;/strong&gt; r&amp;aacute;pido )</target>
        </trans-unit>
        <trans-unit id="3ff63fe8231293f18f4614046a48a3f375957330" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; An optimistic update may only be applied once.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; una actualizaci&amp;oacute;n optimista solo se puede aplicar una vez.</target>
        </trans-unit>
        <trans-unit id="5a6c17b257e2cfbdb037b374e043ded0a3a0687b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Equivalent &lt;code&gt;applyUpdate&lt;/code&gt; and &lt;code&gt;commitUpdate&lt;/code&gt; methods are also provided on the &lt;code&gt;this.props.relay&lt;/code&gt; prop that is passed to components by &lt;code&gt;Relay.Container&lt;/code&gt;. These dispatch mutations in the context of the currently active &lt;code&gt;Relay.Environment&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; Equivalente &lt;code&gt;applyUpdate&lt;/code&gt; y &lt;code&gt;commitUpdate&lt;/code&gt; m&amp;eacute;todos tambi&amp;eacute;n se proporcionan en el &lt;code&gt;this.props.relay&lt;/code&gt; prop que se pasa a los componentes por &lt;code&gt;Relay.Container&lt;/code&gt; . Estas mutaciones de env&amp;iacute;o en el contexto del &lt;code&gt;Relay.Environment&lt;/code&gt; actualmente activo .</target>
        </trans-unit>
        <trans-unit id="3d08f9d41d143a0795971f924c815549c54cd145" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.Container&lt;/strong&gt; lets components declare fragments.</source>
          <target state="translated">&lt;strong&gt;Relay.Container&lt;/strong&gt; permite que los componentes declaren fragmentos.</target>
        </trans-unit>
        <trans-unit id="90f9832c4e0fd7965e487450fd253cb3d30e8335" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.Renderer&lt;/strong&gt; is a replacement for &lt;code&gt;Relay.RootContainer&lt;/code&gt; that composes a &lt;code&gt;Relay.ReadyStateRenderer&lt;/code&gt; and performs data fetching for a given &lt;code&gt;queryConfig&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Relay.Renderer&lt;/strong&gt; es un reemplazo de &lt;code&gt;Relay.RootContainer&lt;/code&gt; que compone un &lt;code&gt;Relay.ReadyStateRenderer&lt;/code&gt; y realiza la b&amp;uacute;squeda de datos para una &lt;code&gt;queryConfig&lt;/code&gt; determinada .</target>
        </trans-unit>
        <trans-unit id="4e196f3c49ca550a94a96a6bd405ee5ae569ab33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; accepts three optional callbacks as props that give us more fine-grained control over the render behavior.</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; acepta tres devoluciones de llamada opcionales como accesorios que nos brindan un control m&amp;aacute;s detallado sobre el comportamiento de renderizado.</target>
        </trans-unit>
        <trans-unit id="39c403bfc5a5ae739fbb717b4e88e8b5cb484d46" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; also supports the &lt;code&gt;onReadyStateChange&lt;/code&gt; prop which lets us receive fine-grained events as they occur while fulfilling the data requirements.</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; tambi&amp;eacute;n admite la funci&amp;oacute;n &lt;code&gt;onReadyStateChange&lt;/code&gt; que nos permite recibir eventos detallados a medida que ocurren mientras se cumplen los requisitos de datos.</target>
        </trans-unit>
        <trans-unit id="3d6f9d2435421026549fceef7e0844d153a49bfa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; is a React component that attempts to fulfill the data required in order to render an instance of &lt;code&gt;Component&lt;/code&gt; for a given &lt;code&gt;route&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; es un componente de React que intenta cumplir con los datos necesarios para representar una instancia de &lt;code&gt;Component&lt;/code&gt; para una &lt;code&gt;route&lt;/code&gt; determinada .</target>
        </trans-unit>
        <trans-unit id="a2469cd762b58409f3e67b96bf307621bbbfad9c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; is a React component that, given a &lt;code&gt;Component&lt;/code&gt; and a &lt;code&gt;route&lt;/code&gt;, attempts to fulfill the data required in order to render an instance of &lt;code&gt;Component&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; es un componente de React que, dado un &lt;code&gt;Component&lt;/code&gt; e y una &lt;code&gt;route&lt;/code&gt; , intenta cumplir con los datos requeridos para representar una instancia de &lt;code&gt;Component&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3a1abc25b49b43dce645669aa17f103661474d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; renders the loading state whenever it cannot immediately fulfill data needed to render. This often happens on the initial render, but it can also happen if either &lt;code&gt;Component&lt;/code&gt; or &lt;code&gt;route&lt;/code&gt; changes.</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; representa el estado de carga siempre que no pueda cumplir inmediatamente con los datos necesarios para procesar. Esto sucede a menudo en el renderizado inicial, pero tambi&amp;eacute;n puede suceder si el &lt;code&gt;Component&lt;/code&gt; o la &lt;code&gt;route&lt;/code&gt; cambian.</target>
        </trans-unit>
        <trans-unit id="81df685053c0d0bd1d2397325ab50c0f55f7ca06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.Route&lt;/strong&gt; lets us declare query roots.</source>
          <target state="translated">&lt;strong&gt;Relay.Route&lt;/strong&gt; nos permite declarar las ra&amp;iacute;ces de la consulta.</target>
        </trans-unit>
        <trans-unit id="d333726339af1440c557b36d8dd062e5747d248a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;QueryRenderer&lt;/code&gt; is a React component, so it can be rendered anywhere that a React component can be rendered, not just at the top level. A &lt;code&gt;QueryRenderer&lt;/code&gt; can be rendered &lt;em&gt;within&lt;/em&gt; other Relay components, for example to lazily fetch additional data for a popover. However, a &lt;code&gt;QueryRenderer&lt;/code&gt; will not start loading its data until it is mounted, so nested &lt;code&gt;QueryRenderer&lt;/code&gt; components can lead to avoidable request waterfalls if used unnecessarily.</source>
          <target state="translated">Un &lt;code&gt;QueryRenderer&lt;/code&gt; es un componente de React, por lo que puede renderizarse en cualquier lugar donde se pueda renderizar un componente de React, no solo en el nivel superior. Un &lt;code&gt;QueryRenderer&lt;/code&gt; se puede representar &lt;em&gt;dentro de&lt;/em&gt; otros componentes de Relay, por ejemplo, para obtener datos adicionales de forma perezosa para un popover. Sin embargo, un &lt;code&gt;QueryRenderer&lt;/code&gt; no comenzar&amp;aacute; a cargar sus datos hasta que est&amp;eacute; montado, por &lt;code&gt;QueryRenderer&lt;/code&gt; componentes de QueryRenderer anidados pueden generar cascadas de solicitudes evitables si se usan innecesariamente.</target>
        </trans-unit>
        <trans-unit id="27c70649f28d5c13e5a545686407c1d433b45c24" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;REQUIRED_CHILDREN&lt;/code&gt; config is used to append additional children to the mutation query. You may need to use this, for example, to fetch fields on a new object created by the mutation (and which Relay would normally not attempt to fetch because it has not previously fetched anything for that object).</source>
          <target state="translated">Se usa una configuraci&amp;oacute;n &lt;code&gt;REQUIRED_CHILDREN&lt;/code&gt; para agregar hijos adicionales a la consulta de mutaci&amp;oacute;n. Es posible que deba usar esto, por ejemplo, para recuperar campos en un nuevo objeto creado por la mutaci&amp;oacute;n (y que Relay normalmente no intentar&amp;iacute;a recuperar porque no ha obtenido previamente nada para ese objeto).</target>
        </trans-unit>
        <trans-unit id="b0405a3f3745cc21b6e57c41715133d0cedd35b4" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;RefetchContainer&lt;/code&gt; first renders like a regular &lt;a href=&quot;fragment-container&quot;&gt;&lt;code&gt;FragmentContainer&lt;/code&gt;&lt;/a&gt;, but has the option to execute a new query with different variables and render the response of that query instead when the request comes back.</source>
          <target state="translated">Un &lt;code&gt;RefetchContainer&lt;/code&gt; primero se procesa como un &lt;a href=&quot;fragment-container&quot;&gt; &lt;code&gt;FragmentContainer&lt;/code&gt; &lt;/a&gt; normal , pero tiene la opci&amp;oacute;n de ejecutar una nueva consulta con diferentes variables y generar la respuesta de esa consulta cuando la solicitud regresa.</target>
        </trans-unit>
        <trans-unit id="0b6b1500d0098058dc174f969740040bdd6fdf14" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;renderLoading&lt;/code&gt; callback can simulate the default behavior by returning &lt;code&gt;undefined&lt;/code&gt;. Notice that this is different from a &lt;code&gt;renderLoading&lt;/code&gt; callback that returns &lt;code&gt;null&lt;/code&gt;, which would render nothing whenever data is loading, even if there was a previous view rendered.</source>
          <target state="translated">Una &lt;code&gt;renderLoading&lt;/code&gt; llamada renderLoading puede simular el comportamiento predeterminado devolviendo &lt;code&gt;undefined&lt;/code&gt; . Tenga en cuenta que esto es diferente de una &lt;code&gt;renderLoading&lt;/code&gt; llamada renderLoading que devuelve un &lt;code&gt;null&lt;/code&gt; , que no representar&amp;iacute;a nada siempre que se carguen datos, incluso si hubo una vista anterior representada.</target>
        </trans-unit>
        <trans-unit id="59bd5b6c5b1f4d50bad57e4bae0c86bf7e63ff03" translate="yes" xml:space="preserve">
          <source>A Complete Example</source>
          <target state="translated">Un ejemplo completo</target>
        </trans-unit>
        <trans-unit id="584bb673c7430dcef36b698acb079dd72be2262f" translate="yes" xml:space="preserve">
          <source>A GraphQL Schema</source>
          <target state="translated">Un esquema GraphQL</target>
        </trans-unit>
        <trans-unit id="b1a1d3fc840a0a6e5e8ca2b278d7769c45a98c33" translate="yes" xml:space="preserve">
          <source>A GraphQL Server</source>
          <target state="translated">Un servidor GraphQL</target>
        </trans-unit>
        <trans-unit id="a7ee882612fb64b227df291f19a923de85574e53" translate="yes" xml:space="preserve">
          <source>A GraphQL schema describes your data model, and provides a GraphQL server with an associated set of resolve methods that know how to fetch data. We will use &lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;graphql-js&lt;/a&gt; and &lt;a href=&quot;https://github.com/graphql/graphql-relay-js&quot;&gt;graphql-relay-js&lt;/a&gt; to build our schema.</source>
          <target state="translated">Un esquema GraphQL describe su modelo de datos y proporciona un servidor GraphQL con un conjunto asociado de m&amp;eacute;todos de resoluci&amp;oacute;n que saben c&amp;oacute;mo obtener datos. Usaremos &lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;graphql-js&lt;/a&gt; y &lt;a href=&quot;https://github.com/graphql/graphql-relay-js&quot;&gt;graphql-relay-js&lt;/a&gt; para construir nuestro esquema.</target>
        </trans-unit>
        <trans-unit id="5f6d86fdd10ea1168eecc22cdc48b9e22a21ad2d" translate="yes" xml:space="preserve">
          <source>A complete example</source>
          <target state="translated">Un ejemplo completo</target>
        </trans-unit>
        <trans-unit id="1b0ee223956194b51488ec093f18ce49cf32ed77" translate="yes" xml:space="preserve">
          <source>A description of how to page through connections.</source>
          <target state="translated">Una descripción de cómo buscar a través de las conexiones.</target>
        </trans-unit>
        <trans-unit id="97b03c635c48a56b721c11e955de7b0b12f2ab52" translate="yes" xml:space="preserve">
          <source>A description of your data model with an associated set of resolve methods that know how to fetch any data your application could ever need.</source>
          <target state="translated">Una descripción de su modelo de datos con un conjunto asociado de métodos de resolución que saben cómo obtener cualquier dato que su aplicación pueda necesitar.</target>
        </trans-unit>
        <trans-unit id="cab997b4cd24ec902e4b83aaf3bf43dce9ec7836" translate="yes" xml:space="preserve">
          <source>A faction has many ships in the Star Wars universe. Relay contains functionality to make manipulating one-to-many relationships easy, using a standardized way of expressing these one-to-many relationships. This standard connection model offers ways of slicing and paginating through the connection.</source>
          <target state="translated">Una facción tiene muchas naves en el universo de Star Wars.El relé contiene una funcionalidad para facilitar la manipulación de las relaciones de uno a muchos,usando una forma estandarizada de expresar estas relaciones de uno a muchos.Este modelo de conexión estándar ofrece formas de cortar y paginar a través de la conexión.</target>
        </trans-unit>
        <trans-unit id="ac6dbe38242ad9f607665dc6e4fa2db4283cdd16" translate="yes" xml:space="preserve">
          <source>A map between a &lt;code&gt;fieldName&lt;/code&gt; in the response and one or more DataIDs in the store.</source>
          <target state="translated">Un mapa entre un &lt;code&gt;fieldName&lt;/code&gt; en la respuesta y uno o m&amp;aacute;s DataID en la tienda.</target>
        </trans-unit>
        <trans-unit id="6d94fea08321dcd17e29b42a404746fc50da107f" translate="yes" xml:space="preserve">
          <source>A map between printed, dot-separated GraphQL calls &lt;em&gt;in alphabetical order&lt;/em&gt; and the behavior we want Relay to exhibit when adding the new edge to connections under the influence of those calls or a function accepting an array of connection arguments, returning that behavior.</source>
          <target state="translated">Un mapa entre las llamadas GraphQL impresas y separadas por puntos &lt;em&gt;en orden alfab&amp;eacute;tico&lt;/em&gt; y el comportamiento que queremos que muestre Relay al agregar el nuevo borde a las conexiones bajo la influencia de esas llamadas o una funci&amp;oacute;n que acepta una matriz de argumentos de conexi&amp;oacute;n, devolviendo ese comportamiento.</target>
        </trans-unit>
        <trans-unit id="1cccdfbe7fde630bea189ab2f8f17ca043aff9a4" translate="yes" xml:space="preserve">
          <source>A mechanism for refetching an object.</source>
          <target state="translated">Un mecanismo para volver a buscar un objeto.</target>
        </trans-unit>
        <trans-unit id="dd1a050f9a41554bdba5570ef7cbd29c8928f1fa" translate="yes" xml:space="preserve">
          <source>A naming convention of &lt;code&gt;&amp;lt;FileName&amp;gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; for fragments is advised. This restriction is required while migrating from classic to modern APIs to allow for cross-compatibility.</source>
          <target state="translated">Se recomienda una convenci&amp;oacute;n de nomenclatura de &lt;code&gt;&amp;lt;FileName&amp;gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; para los fragmentos. Esta restricci&amp;oacute;n es necesaria al migrar de API cl&amp;aacute;sicas a modernas para permitir la compatibilidad cruzada.</target>
        </trans-unit>
        <trans-unit id="b4223851fbff0df13ddb07d4c23c59818ab413eb" translate="yes" xml:space="preserve">
          <source>A normalized cache ensures that the &lt;em&gt;cache&lt;/em&gt; is consistent. But what about our views? Ideally, our React views would always reflect the current information from the cache.</source>
          <target state="translated">Una cach&amp;eacute; normalizada asegura que la &lt;em&gt;cach&amp;eacute;&lt;/em&gt; sea ​​consistente. Pero, &amp;iquest;qu&amp;eacute; pasa con nuestras opiniones? Idealmente, nuestras vistas de React siempre reflejar&amp;iacute;an la informaci&amp;oacute;n actual del cach&amp;eacute;.</target>
        </trans-unit>
        <trans-unit id="921546babe023949163725db08488e51b22729dc" translate="yes" xml:space="preserve">
          <source>A number of more detailed usage examples can be found &lt;a href=&quot;https://github.com/facebook/relay/blob/master/packages/react-relay/classic/mutation/__tests__/RelayGraphQLMutation-test.js&quot;&gt;in the test suite&lt;/a&gt;.</source>
          <target state="translated">En &lt;a href=&quot;https://github.com/facebook/relay/blob/master/packages/react-relay/classic/mutation/__tests__/RelayGraphQLMutation-test.js&quot;&gt;el conjunto de pruebas&lt;/a&gt; se pueden encontrar varios ejemplos de uso m&amp;aacute;s detallados .</target>
        </trans-unit>
        <trans-unit id="7bf37966659d061a8f053bad6bab73f29aaece2b" translate="yes" xml:space="preserve">
          <source>A parent component will pass in a reference to some &lt;code&gt;User&lt;/code&gt; &quot;record&quot;.</source>
          <target state="translated">Un componente principal pasar&amp;aacute; una referencia a alg&amp;uacute;n &quot;registro&quot; de &lt;code&gt;User&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3024b82cc133bf6a9ef4feda5d9be663e786bae2" translate="yes" xml:space="preserve">
          <source>A polyfilled environment for Relay using &lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt; to support older browsers might look like:</source>
          <target state="translated">Un entorno con relleno m&amp;uacute;ltiple para Relay que usa &lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt; para admitir navegadores m&amp;aacute;s antiguos podr&amp;iacute;a verse as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="61d2ab53d28c9ffa3a83c917db0c7132ab0ec11a" translate="yes" xml:space="preserve">
          <source>A reference for translating between the Relay Classic and Relay Modern APIs.</source>
          <target state="translated">Una referencia para traducir entre las API de Relay Classic y Relay Modern.</target>
        </trans-unit>
        <trans-unit id="0b8683fbbd3c98251a45756a2f2f8175837a100c" translate="yes" xml:space="preserve">
          <source>A simple database</source>
          <target state="translated">Una simple base de datos</target>
        </trans-unit>
        <trans-unit id="40cf8919ea34c404a49fa4a02115691af647ed4f" translate="yes" xml:space="preserve">
          <source>A simple example</source>
          <target state="translated">Un simple ejemplo</target>
        </trans-unit>
        <trans-unit id="dd8ebc46434f8d14a177b5c72d5934bab414bb47" translate="yes" xml:space="preserve">
          <source>A simpler, more predictable mutation API. The restrictions on mutation queries from Relay Classic are also removed: mutation queries are static, fields can be arbitrarily nested, and may use arbitrary arguments.</source>
          <target state="translated">Un API de mutación más simple y predecible.También se han eliminado las restricciones de las consultas de mutación de Relay Classic:las consultas de mutación son estáticas,los campos pueden anidarse arbitrariamente y pueden utilizar argumentos arbitrarios.</target>
        </trans-unit>
        <trans-unit id="789d37a7cd03e8b6bdc2af935f5617d2f61be663" translate="yes" xml:space="preserve">
          <source>A standard response is to &quot;just use immutable data structures&quot; &amp;mdash; but let's see what would happen if we did:</source>
          <target state="translated">Una respuesta est&amp;aacute;ndar es &quot;simplemente usar estructuras de datos inmutables&quot;, pero veamos qu&amp;eacute; pasar&amp;iacute;a si lo hici&amp;eacute;ramos:</target>
        </trans-unit>
        <trans-unit id="e5e4cf2d26ffa89b62883fa16b09362f316c9090" translate="yes" xml:space="preserve">
          <source>A summary of the improvements and new features in Relay Modern.</source>
          <target state="translated">Un resumen de las mejoras y nuevas características del Relevo Moderno.</target>
        </trans-unit>
        <trans-unit id="95da6cd41846ca1d215d52c18cb18c520fe5b668" translate="yes" xml:space="preserve">
          <source>A working copy of the treasure hunt can be found in the &lt;a href=&quot;https://github.com/relayjs/relay-examples&quot;&gt;relay-examples&lt;/a&gt; repository.</source>
          <target state="translated">Se puede encontrar una copia de trabajo de la b&amp;uacute;squeda del tesoro en el repositorio de &lt;a href=&quot;https://github.com/relayjs/relay-examples&quot;&gt;ejemplos de retransmisi&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1aec4806edaa35984901f978cbb068b50698edb4" translate="yes" xml:space="preserve">
          <source>API Cheatsheet</source>
          <target state="translated">Hoja de trucos de la API</target>
        </trans-unit>
        <trans-unit id="2c3de2092b0a547759dcfed154c12293c6bfa562" translate="yes" xml:space="preserve">
          <source>API and Runtime</source>
          <target state="translated">API y Runtime</target>
        </trans-unit>
        <trans-unit id="42949c00e99b70b6ffba23e406246cfa31564e49" translate="yes" xml:space="preserve">
          <source>Achieving View Consistency</source>
          <target state="translated">Lograr la consistencia de la vista</target>
        </trans-unit>
        <trans-unit id="81f2d6f8bacd029d8646faa85a14672311eb28b5" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;&quot;relay&quot;&lt;/code&gt; to the list of plugins your .babelrc file. See &lt;a href=&quot;babel-plugin-relay&quot;&gt;the docs&lt;/a&gt; if upgrading an existing Relay app.</source>
          <target state="translated">Agregue &lt;code&gt;&quot;relay&quot;&lt;/code&gt; a la lista de complementos de su archivo .babelrc. Consulte &lt;a href=&quot;babel-plugin-relay&quot;&gt;los documentos&lt;/a&gt; si actualiza una aplicaci&amp;oacute;n Relay existente.</target>
        </trans-unit>
        <trans-unit id="0a60bf5aa8ddfd89ba31ac71650847ae24721ce0" translate="yes" xml:space="preserve">
          <source>Add the variable to the queries that use the fragment and pass it in when fetching the query. For this it can be useful to have a module with a collection of variables for your product.</source>
          <target state="translated">Añade la variable a las consultas que utilizan el fragmento y pásala cuando se obtiene la consulta.Para ello puede ser útil tener un módulo con una colección de variables para su producto.</target>
        </trans-unit>
        <trans-unit id="0a4d555b6a81430095f4070dee6163a543de304b" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;handlerProvider&lt;/code&gt;</source>
          <target state="translated">Agregar un &lt;code&gt;handlerProvider&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c313de6babf318503fdf433e2471023cd78a727c" translate="yes" xml:space="preserve">
          <source>Additional Options</source>
          <target state="translated">Opciones adicionales</target>
        </trans-unit>
        <trans-unit id="94c2eff0e92e7480eb248740c04ee58edd887616" translate="yes" xml:space="preserve">
          <source>Additionally, you need a directory containing &lt;code&gt;.js&lt;/code&gt; files that use the &lt;code&gt;graphql&lt;/code&gt; tag to describe GraphQL queries and fragments. Let's call this &lt;code&gt;./src&lt;/code&gt;.</source>
          <target state="translated">Adem&amp;aacute;s, necesita un directorio que contenga archivos &lt;code&gt;.js&lt;/code&gt; que usen la etiqueta &lt;code&gt;graphql&lt;/code&gt; para describir las consultas y los fragmentos de GraphQL. Llamemos a esto &lt;code&gt;./src&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7c13cb060f72ef8e06bc9f0779c54871d13ff35" translate="yes" xml:space="preserve">
          <source>Advanced Mutation Example</source>
          <target state="translated">Ejemplo de mutación avanzada</target>
        </trans-unit>
        <trans-unit id="5126940d744a6dff391a643edf858b06f00785ed" translate="yes" xml:space="preserve">
          <source>Advanced usage</source>
          <target state="translated">Uso avanzado</target>
        </trans-unit>
        <trans-unit id="78bdcba5217f6a92239c4e8dde28377bb7815364" translate="yes" xml:space="preserve">
          <source>After initially fetching this story our cache might be as follows. Note that the story and comment both link to the same record as &lt;code&gt;author&lt;/code&gt;:</source>
          <target state="translated">Despu&amp;eacute;s de buscar inicialmente esta historia, nuestro cach&amp;eacute; podr&amp;iacute;a ser el siguiente. Tenga en cuenta que la historia y el comentario est&amp;aacute;n vinculados al mismo registro que el &lt;code&gt;author&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cefb28e5c89ebf89740e7f56f62c4e404d2462a6" translate="yes" xml:space="preserve">
          <source>All data is fetched in a single round trip.</source>
          <target state="translated">Todos los datos se obtienen en un solo viaje de ida y vuelta.</target>
        </trans-unit>
        <trans-unit id="40454335b535c042b908582ab2dd06293106ac63" translate="yes" xml:space="preserve">
          <source>All of the mutations we've performed so far have waited on a response from the server before updating the client-side store. Relay offers us a chance to craft an optimistic response of the same shape based on what we expect the server's response to be in the event of a successful mutation.</source>
          <target state="translated">Todas las mutaciones que hemos realizado hasta ahora han esperado una respuesta del servidor antes de actualizar la tienda del lado del cliente.El relé nos ofrece la oportunidad de crear una respuesta optimista de la misma forma basada en lo que esperamos que sea la respuesta del servidor en caso de una mutación exitosa.</target>
        </trans-unit>
        <trans-unit id="6e5ef228d93a867965453c9210e08a5fc6427932" translate="yes" xml:space="preserve">
          <source>Alternatively a &lt;a href=&quot;refetch-container&quot;&gt;&lt;code&gt;RefetchContainer&lt;/code&gt;&lt;/a&gt; can also be used.</source>
          <target state="translated">Alternativamente, tambi&amp;eacute;n se puede utilizar un &lt;a href=&quot;refetch-container&quot;&gt; &lt;code&gt;RefetchContainer&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3cb1f93043bd5b1e4766b2a5f1a916dfbf98f41c" translate="yes" xml:space="preserve">
          <source>Alternatively, you can install &lt;code&gt;relay-compiler&lt;/code&gt; globally so you can access it directly:</source>
          <target state="translated">Alternativamente, puede instalar &lt;code&gt;relay-compiler&lt;/code&gt; globalmente para poder acceder a &amp;eacute;l directamente:</target>
        </trans-unit>
        <trans-unit id="4e7be8aae845923a0feac81e1f7b4b0b1b6931db" translate="yes" xml:space="preserve">
          <source>Although the response is hierarchical, we'll cache it by flattening all the records. Here is an example of how Relay would cache this query response:</source>
          <target state="translated">Aunque la respuesta es jerárquica,la almacenaremos aplanando todos los registros.Aquí hay un ejemplo de cómo el Relevo almacenaría en caché esta respuesta de consulta:</target>
        </trans-unit>
        <trans-unit id="c6ec18663142d1b37b9759d8f91cf8ac740a2752" translate="yes" xml:space="preserve">
          <source>An area we've gotten a lot of questions on was mutations and their configs. Relay Modern introduces a new mutation API that allows records and fields to be updated in a more direct manner.</source>
          <target state="translated">Un área sobre la que hemos recibido muchas preguntas fue sobre las mutaciones y sus configuraciones.Relay Modern introduce una nueva mutación API que permite que los registros y campos se actualicen de una manera más directa.</target>
        </trans-unit>
        <trans-unit id="16a242bdcfab9509fa528a20336ea8be61d5d155" translate="yes" xml:space="preserve">
          <source>An array containing the field names between the parent and the connection, including the parent and the connection</source>
          <target state="translated">Una matriz que contiene los nombres de los campos entre el padre y la conexión,incluyendo el padre y la conexión</target>
        </trans-unit>
        <trans-unit id="ab5c749afdc7ed704bf1427839cff1f6c54727ed" translate="yes" xml:space="preserve">
          <source>An example using &lt;code&gt;fetch&lt;/code&gt; looks like this:</source>
          <target state="translated">Un ejemplo que usa &lt;code&gt;fetch&lt;/code&gt; se ve as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="ecb9a82e766e01fb5997898864c15b00f3207e54" translate="yes" xml:space="preserve">
          <source>An instance of a &lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt; encapsulates an in-memory cache of GraphQL data and a network layer that provides access to your GraphQL server. The Environment object is typically not used by developers directly, instead it is passed to each &lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt;, which uses the environment to access, modify, and fetch data. Within a container, the current environment can be accessed via &lt;code&gt;this.props.relay.environment&lt;/code&gt;. This is most commonly used to &lt;a href=&quot;mutations&quot;&gt;execute a mutation&lt;/a&gt;.</source>
          <target state="translated">Una instancia de un &lt;a href=&quot;relay-environment&quot;&gt;entorno de retransmisi&amp;oacute;n&lt;/a&gt; encapsula un cach&amp;eacute; en memoria de datos GraphQL y una capa de red que proporciona acceso a su servidor GraphQL. Normalmente, los desarrolladores no utilizan el objeto Environment directamente, sino que se pasa a cada &lt;a href=&quot;query-renderer&quot;&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;/a&gt; , que utiliza el entorno para acceder, modificar y recuperar datos. Dentro de un contenedor, se puede acceder al entorno actual a trav&amp;eacute;s de &lt;code&gt;this.props.relay.environment&lt;/code&gt; . Esto se usa m&amp;aacute;s com&amp;uacute;nmente para &lt;a href=&quot;mutations&quot;&gt;ejecutar una mutaci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6dd9dc1929b158a9c5ea7752c056cc104664b1ef" translate="yes" xml:space="preserve">
          <source>An object that conforms to the &lt;code&gt;Relay.Environment&lt;/code&gt; interface, such as &lt;code&gt;Relay.Store&lt;/code&gt;.</source>
          <target state="translated">Un objeto que se ajusta a la interfaz &lt;code&gt;Relay.Environment&lt;/code&gt; , como &lt;code&gt;Relay.Store&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac7cf5ea35aac5de7114e6afc02d20f82b3316f0" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;onReadyStateChange&lt;/code&gt; callback can be supplied to respond to the events involved with the data fulfillment.</source>
          <target state="translated">Se puede proporcionar una devoluci&amp;oacute;n de llamada &lt;code&gt;onReadyStateChange&lt;/code&gt; opcional para responder a los eventos relacionados con el cumplimiento de datos.</target>
        </trans-unit>
        <trans-unit id="7303f03f73c25d8e0d64d93962d92858e7741e4b" translate="yes" xml:space="preserve">
          <source>And here's a possible response:</source>
          <target state="translated">Y aquí hay una posible respuesta:</target>
        </trans-unit>
        <trans-unit id="369fe458331664a040bf70efbb8b99da198958aa" translate="yes" xml:space="preserve">
          <source>And this fragment can then be used to define the Story container:</source>
          <target state="translated">Y este fragmento puede ser usado para definir el contenedor de la Historia:</target>
        </trans-unit>
        <trans-unit id="605ea43af6ae69ff62a257b6fd0223b045c71edf" translate="yes" xml:space="preserve">
          <source>Any field in the payload that can be correlated by DataID with one or more records in the client-side store will be merged with the record(s) in the store.</source>
          <target state="translated">Cualquier campo de la carga útil que pueda ser correlacionado por DataID con uno o más registros de la tienda del lado del cliente se fusionará con el/los registro(s)de la tienda.</target>
        </trans-unit>
        <trans-unit id="cfe1cdd7971ecdf1250f379fc5280623f121ecd7" translate="yes" xml:space="preserve">
          <source>Any props that we pass to the constructor of a mutation will become available to its instance methods as &lt;code&gt;this.props&lt;/code&gt;. Like in components used within Relay containers, props for which a corresponding fragment has been defined will be populated by Relay with query data:</source>
          <target state="translated">Cualquier accesorio que le pasemos al constructor de una mutaci&amp;oacute;n estar&amp;aacute; disponible para sus m&amp;eacute;todos de instancia como &lt;code&gt;this.props&lt;/code&gt; . Al igual que en los componentes utilizados dentro de los contenedores de Relay, Relay completar&amp;aacute; los accesorios para los que se ha definido un fragmento correspondiente con datos de consulta:</target>
        </trans-unit>
        <trans-unit id="2c3c3b69096651daf12db619c2e7045eb0884046" translate="yes" xml:space="preserve">
          <source>Any server can be taught to load a schema and speak GraphQL. Our &lt;a href=&quot;https://github.com/relayjs/relay-examples&quot;&gt;examples&lt;/a&gt; use Express.</source>
          <target state="translated">A cualquier servidor se le puede ense&amp;ntilde;ar a cargar un esquema y hablar GraphQL. Nuestros &lt;a href=&quot;https://github.com/relayjs/relay-examples&quot;&gt;ejemplos&lt;/a&gt; usan Express.</target>
        </trans-unit>
        <trans-unit id="8a830514fbc11a8668a4369e6666ef8944337af6" translate="yes" xml:space="preserve">
          <source>Applications must supply a &lt;a href=&quot;network-layer&quot;&gt;Network Layer&lt;/a&gt; when creating an instance of a Relay Environment. The network layer is an object conforming to a simple interface through which Relay can execute queries, mutations, and subscriptions. Essentially, this object teaches Relay how to talk to your GraphQL server.</source>
          <target state="translated">Las aplicaciones deben proporcionar una &lt;a href=&quot;network-layer&quot;&gt;capa de red&lt;/a&gt; al crear una instancia de un entorno de retransmisi&amp;oacute;n. La capa de red es un objeto que se ajusta a una interfaz simple a trav&amp;eacute;s de la cual Relay puede ejecutar consultas, mutaciones y suscripciones. B&amp;aacute;sicamente, este objeto le ense&amp;ntilde;a a Relay c&amp;oacute;mo comunicarse con su servidor GraphQL.</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="dd4d4251ad9eea93ba8b6656973531a29f150428" translate="yes" xml:space="preserve">
          <source>Array fields</source>
          <target state="translated">Campos de la matriz</target>
        </trans-unit>
        <trans-unit id="f3aab73669ac6dc9de81f7b41eeb64591c4e0ee7" translate="yes" xml:space="preserve">
          <source>As an example, we can log each mutation that is sent to the server as follows:</source>
          <target state="translated">Como ejemplo,podemos registrar cada mutación que se envía al servidor de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="93df315a58852563161dbb62a33b18e1c4b63051" translate="yes" xml:space="preserve">
          <source>As we've learned, Relay containers declare data requirements as GraphQL fragments. This means that, for example, &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; can be embedded not only in &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt;, but any container that fetches a field of type &lt;code&gt;User&lt;/code&gt;.</source>
          <target state="translated">Como hemos aprendido, los contenedores Relay declaran los requisitos de datos como fragmentos GraphQL. Esto significa que, por ejemplo, &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; se puede incrustar no solo en &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; , sino en cualquier contenedor que obtenga un campo de tipo &lt;code&gt;User&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="923622cbd0c4bbb9c49d319a01f53817606d02a1" translate="yes" xml:space="preserve">
          <source>As we've learned, Relay fragment containers declare data requirements as GraphQL fragments. We're almost ready to let Relay fulfill the data requirements for these components and render them. However, there is one problem. In order to actually fetch data with GraphQL, we need a query root. For example, we need to ground the &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; fragment in a GraphQL query.</source>
          <target state="translated">Como hemos aprendido, los contenedores de fragmentos de retransmisi&amp;oacute;n declaran los requisitos de datos como fragmentos de GraphQL. Estamos casi listos para permitir que Relay cumpla con los requisitos de datos para estos componentes y los represente. Sin embargo, existe un problema. Para obtener datos con GraphQL, necesitamos una ra&amp;iacute;z de consulta. Por ejemplo, necesitamos conectar el fragmento &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; en una consulta GraphQL.</target>
        </trans-unit>
        <trans-unit id="6a71de49f031297e07457bef14ae0f8572e55b44" translate="yes" xml:space="preserve">
          <source>At this point, you can delete everything up until &lt;code&gt;queryType&lt;/code&gt; in &lt;code&gt;./data/schema.js&lt;/code&gt;.</source>
          <target state="translated">En este punto, puede eliminar todo hasta &lt;code&gt;queryType&lt;/code&gt; en &lt;code&gt;./data/schema.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="207aae1b1d93e0ae663b416c543d4e3848a98ef0" translate="yes" xml:space="preserve">
          <source>Authoring a schema</source>
          <target state="translated">La autoría de un esquema</target>
        </trans-unit>
        <trans-unit id="3eb220f88ae787a8eafb5d737da557d0ab6ff6ca" translate="yes" xml:space="preserve">
          <source>Babel Relay Plugin</source>
          <target state="translated">Babel Relay Plugin</target>
        </trans-unit>
        <trans-unit id="0351d5a9ef82b115e9ed00101cebdddfe0dbad30" translate="yes" xml:space="preserve">
          <source>Base React Component</source>
          <target state="translated">Componente de reacción de la base</target>
        </trans-unit>
        <trans-unit id="a6551059bdb95efc2dfbc4b7c2ce6ccc9fcd0365" translate="yes" xml:space="preserve">
          <source>Before going any further, we need to serialize our executable schema to JSON for use by the Relay.QL transpiler, then start up the server. From the command line:</source>
          <target state="translated">Antes de seguir adelante,necesitamos serializar nuestro esquema ejecutable a JSON para ser usado por el transpilador Relay.QL,y luego iniciar el servidor.Desde la línea de comandos:</target>
        </trans-unit>
        <trans-unit id="97cecb9e6bdc8256a26df17eef65a9b41e163cee" translate="yes" xml:space="preserve">
          <source>Before taking a deep dive into the mutations API, let's look at a complete example. Here, we subclass &lt;code&gt;Relay.Mutation&lt;/code&gt; to create a custom mutation that we can use to like a story.</source>
          <target state="translated">Antes de profundizar en la API de mutaciones, veamos un ejemplo completo. Aqu&amp;iacute;, subclasificamos &lt;code&gt;Relay.Mutation&lt;/code&gt; para crear una mutaci&amp;oacute;n personalizada que podamos usar para dar me gusta a una historia.</target>
        </trans-unit>
        <trans-unit id="949c7a85f6d836f247f0195b7eaa99f0c336e992" translate="yes" xml:space="preserve">
          <source>Behaviors can be one of &lt;code&gt;'append'&lt;/code&gt;, &lt;code&gt;'ignore'&lt;/code&gt;, &lt;code&gt;'prepend'&lt;/code&gt;, &lt;code&gt;'refetch'&lt;/code&gt;, or &lt;code&gt;'remove'&lt;/code&gt;.</source>
          <target state="translated">Los comportamientos pueden ser &lt;code&gt;'append'&lt;/code&gt; , &lt;code&gt;'ignore'&lt;/code&gt; , &lt;code&gt;'prepend'&lt;/code&gt; , &lt;code&gt;'refetch'&lt;/code&gt; o &lt;code&gt;'remove'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a13e0d17d14c44107ca60ab513e5d71d5662c000" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;Faction&lt;/code&gt; and &lt;code&gt;Ship&lt;/code&gt; have identifiers that we can use to refetch them. We expose this capability to Relay through the &lt;code&gt;Node&lt;/code&gt; interface and the &lt;code&gt;node&lt;/code&gt; field on the root query type.</source>
          <target state="translated">Tanto la &lt;code&gt;Faction&lt;/code&gt; como el &lt;code&gt;Ship&lt;/code&gt; tienen identificadores que podemos usar para recuperarlos. Exponemos esta capacidad a Relay a trav&amp;eacute;s de la interfaz de &lt;code&gt;Node&lt;/code&gt; y el campo de &lt;code&gt;node&lt;/code&gt; en el tipo de consulta ra&amp;iacute;z.</target>
        </trans-unit>
        <trans-unit id="3148373f94223f76742328ea5464dd9f30817fe7" translate="yes" xml:space="preserve">
          <source>But now, we can also create routes for arbitrary user IDs. For example, if we wanted to construct a route that fetched data for a user defined by the &lt;code&gt;userID&lt;/code&gt; query parameter, we might use:</source>
          <target state="translated">Pero ahora, tambi&amp;eacute;n podemos crear rutas para ID de usuario arbitrarios. Por ejemplo, si quisi&amp;eacute;ramos construir una ruta que obtuviera datos para un usuario definido por el par&amp;aacute;metro de consulta &lt;code&gt;userID&lt;/code&gt; , podr&amp;iacute;amos usar:</target>
        </trans-unit>
        <trans-unit id="1862f3355eff810374142f7e656f80df21c55213" translate="yes" xml:space="preserve">
          <source>By convention, mutations are named as verbs, their inputs are the name with &quot;Input&quot; appended at the end, and they return an object that is the name with &quot;Payload&quot; appended.</source>
          <target state="translated">Por convención,las mutaciones se nombran como verbos,sus entradas son el nombre con &quot;Input&quot; adjunto al final,y devuelven un objeto que es el nombre con &quot;Payload&quot; adjunto.</target>
        </trans-unit>
        <trans-unit id="178b930518b904dbc5bd0f441c18fc870aac28c3" translate="yes" xml:space="preserve">
          <source>By default, Relay assumes that GraphQL is served at &lt;code&gt;/graphql&lt;/code&gt; relative to the origin where our application is served. This can be re-configured by injecting a custom instantiation of the default network layer.</source>
          <target state="translated">De forma predeterminada, Relay asume que GraphQL se sirve en &lt;code&gt;/graphql&lt;/code&gt; en relaci&amp;oacute;n con el origen donde se sirve nuestra aplicaci&amp;oacute;n. Esto se puede volver a configurar inyectando una instanciaci&amp;oacute;n personalizada de la capa de red predeterminada.</target>
        </trans-unit>
        <trans-unit id="c01482f7fe504d2a5e3cc944236d88811dd8d351" translate="yes" xml:space="preserve">
          <source>By default, nothing is rendered while loading data for the initial render. If a previous set of &lt;code&gt;Component&lt;/code&gt; and &lt;code&gt;route&lt;/code&gt; were fulfilled and rendered, the default behavior is to continue rendering the previous view.</source>
          <target state="translated">De forma predeterminada, no se procesa nada mientras se cargan datos para el procesamiento inicial. Si se cumpli&amp;oacute; y renderiz&amp;oacute; un conjunto anterior de &lt;code&gt;Component&lt;/code&gt; e y &lt;code&gt;route&lt;/code&gt; , el comportamiento predeterminado es continuar renderizando la vista anterior.</target>
        </trans-unit>
        <trans-unit id="4375c1481c81a0b6d8e08ac19523704d5d4da90b" translate="yes" xml:space="preserve">
          <source>Cache Consistency</source>
          <target state="translated">Consistencia de la memoria caché</target>
        </trans-unit>
        <trans-unit id="14776554d5693e023c3ac7a5a65e4a5058537dfe" translate="yes" xml:space="preserve">
          <source>Cache Updates</source>
          <target state="translated">actualizaciones de la caché</target>
        </trans-unit>
        <trans-unit id="eed1812845bba88a7ea96dc0731ed87a6365fcc0" translate="yes" xml:space="preserve">
          <source>Caching A Graph</source>
          <target state="translated">Caching A Graph</target>
        </trans-unit>
        <trans-unit id="c3fbd240479228aa26381115ef997022e9773856" translate="yes" xml:space="preserve">
          <source>Call this to optimistically apply an update to the store.</source>
          <target state="translated">Llama a esto para aplicar con optimismo una actualización a la tienda.</target>
        </trans-unit>
        <trans-unit id="ef28016b715246d53e3c0aef32bef448a5df1961" translate="yes" xml:space="preserve">
          <source>Call this to send the mutation to the server.</source>
          <target state="translated">Llama a esto para enviar la mutación al servidor.</target>
        </trans-unit>
        <trans-unit id="36653c1ff08edcb50e3d0e9893272cf6219ebfe7" translate="yes" xml:space="preserve">
          <source>Callers must provide an appropriate &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;variables&lt;/code&gt;. As per the GraphQL Relay Specification:</source>
          <target state="translated">Las personas que llaman deben proporcionar una &lt;code&gt;query&lt;/code&gt; y &lt;code&gt;variables&lt;/code&gt; adecuadas . Seg&amp;uacute;n la especificaci&amp;oacute;n de retransmisi&amp;oacute;n GraphQL:</target>
        </trans-unit>
        <trans-unit id="ec585c24a23bd7001c34d954b9fe9b0796cec5f2" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;hasOptimisticUpdate&lt;/code&gt; with a record from &lt;code&gt;this.props&lt;/code&gt; will return whether that given record is affected by an optimistic mutation. It allows the component to render local optimistic changes differently from data that has successfully synchronized with the server.</source>
          <target state="translated">Llamar a &lt;code&gt;hasOptimisticUpdate&lt;/code&gt; con un registro de &lt;code&gt;this.props&lt;/code&gt; devolver&amp;aacute; si ese registro dado se ve afectado por una mutaci&amp;oacute;n optimista. Permite que el componente represente cambios optimistas locales de manera diferente a los datos que se han sincronizado correctamente con el servidor.</target>
        </trans-unit>
        <trans-unit id="7e92933047a9a8b8023050178520d6236fd1d0bd" translate="yes" xml:space="preserve">
          <source>Calling Component Instance Methods</source>
          <target state="translated">Llamando a los métodos de instancia de componentes</target>
        </trans-unit>
        <trans-unit id="539001ff0ade75c366a1d2f2ae990718f2b4bd9b" translate="yes" xml:space="preserve">
          <source>Can QueryRenderer using Classic Environment (&lt;code&gt;Store&lt;/code&gt; in &lt;code&gt;react-relay/classic&lt;/code&gt;) use:</source>
          <target state="translated">&amp;iquest;Puede QueryRenderer usar Classic Environment ( &lt;code&gt;Store&lt;/code&gt; in &lt;code&gt;react-relay/classic&lt;/code&gt; ) usar:</target>
        </trans-unit>
        <trans-unit id="4aacaa8308c0d89cb19bc6280f172bcb3027eef8" translate="yes" xml:space="preserve">
          <source>Can QueryRenderer using Modern Environment use:</source>
          <target state="translated">Puede QueryRenderer usando el uso del Medio Ambiente Moderno:</target>
        </trans-unit>
        <trans-unit id="1003218887eb40c1f0a58bc7b7505d15f23175bf" translate="yes" xml:space="preserve">
          <source>Can React Classic Component use:</source>
          <target state="translated">Puede reaccionar al uso del componente clásico:</target>
        </trans-unit>
        <trans-unit id="84238b1b418a17b213190530f83d669483ad4f99" translate="yes" xml:space="preserve">
          <source>Can React Compat Component use:</source>
          <target state="translated">Puede reaccionar al uso del componente Compat:</target>
        </trans-unit>
        <trans-unit id="1c53c8d6a82f41f51bcb44a951f6d42bbd674773" translate="yes" xml:space="preserve">
          <source>Can React Modern Component use:</source>
          <target state="translated">Puede reaccionar al uso de componentes modernos:</target>
        </trans-unit>
        <trans-unit id="ce811e756a396388182f7a8551a77979cea636ea" translate="yes" xml:space="preserve">
          <source>Can RelayRootContainer use:</source>
          <target state="translated">Puede utilizar el RelayRootContainer:</target>
        </trans-unit>
        <trans-unit id="918e312c8dc15e096c8aa60a584cd24fb9b592cd" translate="yes" xml:space="preserve">
          <source>Changing Arguments</source>
          <target state="translated">Cambiando los argumentos</target>
        </trans-unit>
        <trans-unit id="51cdd39226322d9d0efb448c0d03eb64cb6c777d" translate="yes" xml:space="preserve">
          <source>Changing one thing in a system can have a ripple effect that causes other things to change in turn. Imagine a mutation that we can use to accept a friend request. This can have wide implications:</source>
          <target state="translated">Cambiar una cosa en un sistema puede tener un efecto dominó que causa que otras cosas cambien a su vez.Imagina una mutación que podemos usar para aceptar una petición de amistad.Esto puede tener amplias implicaciones:</target>
        </trans-unit>
        <trans-unit id="bb73c6b849ccfd7df64b939d3890bbba8b94e10a" translate="yes" xml:space="preserve">
          <source>Classic Component</source>
          <target state="translated">Componente clásico</target>
        </trans-unit>
        <trans-unit id="9e402ea82ec577f1a7b994361d91b4f9ac1cf510" translate="yes" xml:space="preserve">
          <source>Classic Mutation</source>
          <target state="translated">Mutación clásica</target>
        </trans-unit>
        <trans-unit id="76be385c076bd3cf6a0e76bbefee914b22199f01" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;&amp;lt;RelayRootContainer&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Cl&amp;aacute;sico: &lt;code&gt;&amp;lt;RelayRootContainer&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9450d4893299b4475b958954ce614f6339c011c9" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;Relay.createContainer&lt;/code&gt;</source>
          <target state="translated">Cl&amp;aacute;sico: &lt;code&gt;Relay.createContainer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fdacd86df881f947250264b6f74153f74ca2e17b" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;this.props.relay.commitUpdate(mutation...)&lt;/code&gt;</source>
          <target state="translated">Cl&amp;aacute;sico: &lt;code&gt;this.props.relay.commitUpdate(mutation...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4496ce0ff60c519ddb23c737b94a8c3d0f8fae44" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;this.props.relay.forceFetch()&lt;/code&gt;</source>
          <target state="translated">Cl&amp;aacute;sico: &lt;code&gt;this.props.relay.forceFetch()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4718307cda6ad09eb778eec75ee2c5f20cd45961" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;this.props.relay.setVariable({count: prevCount + pageSize}...)&lt;/code&gt;</source>
          <target state="translated">Cl&amp;aacute;sico: &lt;code&gt;this.props.relay.setVariable({count: prevCount + pageSize}...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a88cd760542eea1905cd9d8225750e276c483cde" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;this.props.relay.setVariable({foo: bar}...)&lt;/code&gt;</source>
          <target state="translated">Cl&amp;aacute;sico: &lt;code&gt;this.props.relay.setVariable({foo: bar}...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6f5633b3ae0188027fabbde415e0f3fcc71e6c3" translate="yes" xml:space="preserve">
          <source>Client Caching</source>
          <target state="translated">Caching de clientes</target>
        </trans-unit>
        <trans-unit id="d4d64d5c478ea7fd0df7b8579f158dc6ea90455b" translate="yes" xml:space="preserve">
          <source>Client Schema Extensions (Experimental)</source>
          <target state="translated">Extensiones del esquema del cliente (Experimental)</target>
        </trans-unit>
        <trans-unit id="a359c7ebffb6706034dbf0f013aa73bcc550292c" translate="yes" xml:space="preserve">
          <source>Comparing Relay Classic and Relay Modern</source>
          <target state="translated">Comparando el Relevo Clásico y el Relevo Moderno</target>
        </trans-unit>
        <trans-unit id="c54dbbae41b051460dcc8e3c9aa6f310af3f2775" translate="yes" xml:space="preserve">
          <source>Compat Component</source>
          <target state="translated">Componente de Compat</target>
        </trans-unit>
        <trans-unit id="2171ca54b3db409d7e88bfa689ea2ab5583955c6" translate="yes" xml:space="preserve">
          <source>Compat Mode</source>
          <target state="translated">Modo de compás</target>
        </trans-unit>
        <trans-unit id="ef1a53514cc801546fdbf4bd01e2b4b764618f78" translate="yes" xml:space="preserve">
          <source>Compat Mutation</source>
          <target state="translated">Mutación de Compat</target>
        </trans-unit>
        <trans-unit id="7ae7318a99d95f75927a3ae6b936e04d175cc04e" translate="yes" xml:space="preserve">
          <source>Compatibility Cheatsheet</source>
          <target state="translated">Ficha de compatibilidad</target>
        </trans-unit>
        <trans-unit id="6d9f235cb9c7c65f0cf0b1b0814cadde6d86abcb" translate="yes" xml:space="preserve">
          <source>Compatibility Mode</source>
          <target state="translated">Modo de compatibilidad</target>
        </trans-unit>
        <trans-unit id="89e9d1be17321688f8d0501eb1a3bf2c6ca26c3e" translate="yes" xml:space="preserve">
          <source>Complete details on how the server should behave are available in the &lt;a href=&quot;https://facebook.github.io/relay/graphql/connections.htm&quot;&gt;GraphQL Cursor Connections&lt;/a&gt; spec.</source>
          <target state="translated">Los detalles completos sobre c&amp;oacute;mo debe comportarse el servidor est&amp;aacute;n disponibles en la especificaci&amp;oacute;n &lt;a href=&quot;https://facebook.github.io/relay/graphql/connections.htm&quot;&gt;GraphQL Cursor Connections&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="29619ae00dc1b1f13f0d8573c5ca62184c0a6a94" translate="yes" xml:space="preserve">
          <source>Complete details on how the server should behave are available in the &lt;a href=&quot;https://facebook.github.io/relay/graphql/mutations.htm&quot;&gt;GraphQL Input Object Mutations&lt;/a&gt; spec.</source>
          <target state="translated">Los detalles completos sobre c&amp;oacute;mo debe comportarse el servidor est&amp;aacute;n disponibles en la &lt;a href=&quot;https://facebook.github.io/relay/graphql/mutations.htm&quot;&gt;especificaci&amp;oacute;n GraphQL Input Object Mutations&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dd80bd3e0728573910ceff942d6bf05bb7333573" translate="yes" xml:space="preserve">
          <source>Complete details on how the server should behave are available in the &lt;a href=&quot;https://facebook.github.io/relay/graphql/objectidentification.htm&quot;&gt;GraphQL Object Identification&lt;/a&gt; spec.</source>
          <target state="translated">Los detalles completos sobre c&amp;oacute;mo debe comportarse el servidor est&amp;aacute;n disponibles en la especificaci&amp;oacute;n de &lt;a href=&quot;https://facebook.github.io/relay/graphql/objectidentification.htm&quot;&gt;identificaci&amp;oacute;n de objetos GraphQL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c92c529e0731c57efd7550480196484040b33c3e" translate="yes" xml:space="preserve">
          <source>Component</source>
          <target state="translated">Component</target>
        </trans-unit>
        <trans-unit id="725a4ffad64df11f9defa669f85ec107f9dc492d" translate="yes" xml:space="preserve">
          <source>Component and Route</source>
          <target state="translated">Componente y ruta</target>
        </trans-unit>
        <trans-unit id="94c5c072cfb48e6d9ea12f613a057a202a5c287b" translate="yes" xml:space="preserve">
          <source>Components can change their data requirements by using &lt;code&gt;setVariables&lt;/code&gt; to request an update to the current set of &lt;code&gt;variables&lt;/code&gt;.</source>
          <target state="translated">Los componentes pueden cambiar sus requisitos de datos utilizando &lt;code&gt;setVariables&lt;/code&gt; para solicitar una actualizaci&amp;oacute;n del conjunto actual de &lt;code&gt;variables&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31ae8b82fb482703d4497f95cafdbd464174a12e" translate="yes" xml:space="preserve">
          <source>Components can inspect pending mutations on any record (i.e. data made available in props with a corresponding fragment). Calling &lt;code&gt;getPendingTransactions&lt;/code&gt; with a record will return a list of the pending mutation transactions that affect that particular record.</source>
          <target state="translated">Los componentes pueden inspeccionar mutaciones pendientes en cualquier registro (es decir, datos disponibles en accesorios con un fragmento correspondiente). Llamar a &lt;code&gt;getPendingTransactions&lt;/code&gt; con un registro devolver&amp;aacute; una lista de las transacciones de mutaci&amp;oacute;n pendientes que afectan ese registro en particular.</target>
        </trans-unit>
        <trans-unit id="deee480cd52fae7c121c1d7b8b86ecda66617156" translate="yes" xml:space="preserve">
          <source>Composing Fragments</source>
          <target state="translated">Composición de los fragmentos</target>
        </trans-unit>
        <trans-unit id="2a321a9ac4f3111d95368aba4e87b1917d75348e" translate="yes" xml:space="preserve">
          <source>Composing Views - It's Plain React</source>
          <target state="translated">Composición de puntos de vista-Es una simple reacción</target>
        </trans-unit>
        <trans-unit id="723e2c15fe85b32b7d864e21eb29e93116b04e14" translate="yes" xml:space="preserve">
          <source>Composing child component fragments in a parent fragment.</source>
          <target state="translated">Composición de los fragmentos de los componentes de los niños en un fragmento de los padres.</target>
        </trans-unit>
        <trans-unit id="f82641d3cbab73b5e585b20db3196f350cb839d5" translate="yes" xml:space="preserve">
          <source>Composing fragments defined as local variables.</source>
          <target state="translated">Componiendo fragmentos definidos como variables locales.</target>
        </trans-unit>
        <trans-unit id="114b9abd3f0b27b8a9b5084318c5af838acdb163" translate="yes" xml:space="preserve">
          <source>Composing the data descriptions.</source>
          <target state="translated">Componer las descripciones de los datos.</target>
        </trans-unit>
        <trans-unit id="59d6b2067a223146a5ead92a4c5fe072d43c9a1e" translate="yes" xml:space="preserve">
          <source>Composing the fragments of child components is discussed in detail in the &lt;a href=&quot;guides-containers&quot;&gt;Containers Guide&lt;/a&gt;, but here's a quick example:</source>
          <target state="translated">La composici&amp;oacute;n de los fragmentos de componentes secundarios se analiza en detalle en la &lt;a href=&quot;guides-containers&quot;&gt;Gu&amp;iacute;a de contenedores&lt;/a&gt; , pero aqu&amp;iacute; hay un ejemplo r&amp;aacute;pido:</target>
        </trans-unit>
        <trans-unit id="a7b041783bd841c2982c635611a14b9b0478fc32" translate="yes" xml:space="preserve">
          <source>Composing the view logic, and</source>
          <target state="translated">Componer la lógica de la vista,y</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="9d60520748b88da0348eeb8f6543f6f98cdbd262" translate="yes" xml:space="preserve">
          <source>Conditional fields</source>
          <target state="translated">Campos condicionales</target>
        </trans-unit>
        <trans-unit id="6355cff1e61b5cd688cec493b080516655b2ac6a" translate="yes" xml:space="preserve">
          <source>Configs</source>
          <target state="translated">Configs</target>
        </trans-unit>
        <trans-unit id="6512ee1541e9a6c52d5bf7cf465332e8df25ea3c" translate="yes" xml:space="preserve">
          <source>Connection</source>
          <target state="translated">Connection</target>
        </trans-unit>
        <trans-unit id="81ea0a30d213381b26e05bce9c491003535b147a" translate="yes" xml:space="preserve">
          <source>Consider an input with a server-defined placeholder text and an imperative method to focus the input node:</source>
          <target state="translated">Considere una entrada con un texto de marcador de posición definido por el servidor y un método imperativo para enfocar el nodo de entrada:</target>
        </trans-unit>
        <trans-unit id="1956d506ca97255f5713770475161b61eb6cde73" translate="yes" xml:space="preserve">
          <source>Consider rendering the text and comments of a story along with the corresponding author names and photos. Here's the GraphQL query:</source>
          <target state="translated">Considere la posibilidad de presentar el texto y los comentarios de una historia junto con los nombres de los autores y las fotos correspondientes.Aquí está la consulta de GraphQL:</target>
        </trans-unit>
        <trans-unit id="e6443af99d2f470f50affd5057bf48db2d09dae4" translate="yes" xml:space="preserve">
          <source>Container</source>
          <target state="translated">Container</target>
        </trans-unit>
        <trans-unit id="0d5a8d03518c194626d6e3e124e7de20c17a7fe5" translate="yes" xml:space="preserve">
          <source>Container Composition</source>
          <target state="translated">Composición del contenedor</target>
        </trans-unit>
        <trans-unit id="b625b62c69e181700306e0871c20a6c94eaa2510" translate="yes" xml:space="preserve">
          <source>Container Specification</source>
          <target state="translated">Especificación del contenedor</target>
        </trans-unit>
        <trans-unit id="dfe33c87ae0783b9497dae2f22418a5e90385aa4" translate="yes" xml:space="preserve">
          <source>Container.getFragment()</source>
          <target state="translated">Container.getFragment()</target>
        </trans-unit>
        <trans-unit id="e040a458f46532a90ec69fa0b4bfc33ba151c98b" translate="yes" xml:space="preserve">
          <source>Containers</source>
          <target state="translated">Containers</target>
        </trans-unit>
        <trans-unit id="4b51306faf49817c8299a221a2777da9319cb8d3" translate="yes" xml:space="preserve">
          <source>Containers are Higher-Order Components</source>
          <target state="translated">Los contenedores son componentes de orden superior</target>
        </trans-unit>
        <trans-unit id="46e795775ec1e8e3e71a6a5641d35b084e19a5a9" translate="yes" xml:space="preserve">
          <source>Containers can define a &lt;code&gt;prepareVariables&lt;/code&gt; method which provides the opportunity to modify the variables that are available to fragments. The new variables can be generated based on the previous variables (or the &lt;code&gt;initialVariables&lt;/code&gt; if no previous ones exist) in addition to the runtime environment.</source>
          <target state="translated">Los contenedores pueden definir un m&amp;eacute;todo &lt;code&gt;prepareVariables&lt;/code&gt; que brinda la oportunidad de modificar las variables que est&amp;aacute;n disponibles para los fragmentos. Las nuevas variables se pueden generar en funci&amp;oacute;n de las variables anteriores (o las &lt;code&gt;initialVariables&lt;/code&gt; si no existen) adem&amp;aacute;s del entorno de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ad0eb4a22e44d99ae045c52ec3f202dc664a29f9" translate="yes" xml:space="preserve">
          <source>Containers declare data requirements on &lt;code&gt;fragments&lt;/code&gt; using GraphQL fragments.</source>
          <target state="translated">Los contenedores declaran los requisitos de datos sobre &lt;code&gt;fragments&lt;/code&gt; utilizan fragmentos de GraphQL.</target>
        </trans-unit>
        <trans-unit id="8928f5de2a918d60f1bbb5d72e6a68cb7502e86a" translate="yes" xml:space="preserve">
          <source>Convenience method that wraps the constructor, passing some default parameters and returning an instance.</source>
          <target state="translated">Método conveniente que envuelve al constructor,pasando algunos parámetros por defecto y devolviendo una instancia.</target>
        </trans-unit>
        <trans-unit id="dd226f43ba5c8ff842931a3ca2796d7c444510a9" translate="yes" xml:space="preserve">
          <source>Conversion Playbook</source>
          <target state="translated">Libro de jugadas de conversión</target>
        </trans-unit>
        <trans-unit id="aca075e23eed144339279d097d6fa88dc0718ec3" translate="yes" xml:space="preserve">
          <source>Conversion Scripts</source>
          <target state="translated">Guiones de conversión</target>
        </trans-unit>
        <trans-unit id="e93c185376ad3e3749d528694597be4eb780596d" translate="yes" xml:space="preserve">
          <source>Create a mutation instance using the &lt;code&gt;new&lt;/code&gt; keyword, optionally passing it some props. Note that &lt;code&gt;this.props&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; available inside the constructor function, but are set for all the methods mentioned below (&lt;code&gt;getCollisionKey&lt;/code&gt;, &lt;code&gt;getOptimisticResponse&lt;/code&gt;, etc). This restriction is due to the fact that mutation props may depend on data from the RelayEnvironment, which isn't known until the mutation is applied with &lt;code&gt;applyUpdate&lt;/code&gt; or &lt;code&gt;commitUpdate&lt;/code&gt;.</source>
          <target state="translated">Cree una instancia de mutaci&amp;oacute;n usando la &lt;code&gt;new&lt;/code&gt; palabra clave, opcionalmente pas&amp;aacute;ndole algunos accesorios. Tenga en cuenta que &lt;code&gt;this.props&lt;/code&gt; &lt;em&gt;no&lt;/em&gt; est&amp;aacute; disponible dentro de la funci&amp;oacute;n del constructor, pero est&amp;aacute; configurado para todos los m&amp;eacute;todos mencionados a continuaci&amp;oacute;n ( &lt;code&gt;getCollisionKey&lt;/code&gt; , &lt;code&gt;getOptimisticResponse&lt;/code&gt; , etc.). Esta restricci&amp;oacute;n se debe al hecho de que los accesorios de mutaci&amp;oacute;n pueden depender de los datos de RelayEnvironment, que no se conocen hasta que se aplica la mutaci&amp;oacute;n con &lt;code&gt;applyUpdate&lt;/code&gt; o &lt;code&gt;commitUpdate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70fb5b0ec1a182be6e0a0d9950900f7bbb367668" translate="yes" xml:space="preserve">
          <source>Create a route instance using the &lt;code&gt;new&lt;/code&gt; keyword, optionally passing it some params.</source>
          <target state="translated">Cree una instancia de ruta utilizando la &lt;code&gt;new&lt;/code&gt; palabra clave, pas&amp;aacute;ndole opcionalmente algunos par&amp;aacute;metros.</target>
        </trans-unit>
        <trans-unit id="22330ce575ca322006e65a1cba21c0878bcce956" translate="yes" xml:space="preserve">
          <source>Creates a new Relay Container - see the &lt;a href=&quot;guides-containers&quot;&gt;Container Guide&lt;/a&gt; for more details and examples.</source>
          <target state="translated">Crea un nuevo contenedor de retransmisiones; consulte la &lt;a href=&quot;guides-containers&quot;&gt;Gu&amp;iacute;a de contenedores&lt;/a&gt; para obtener m&amp;aacute;s detalles y ejemplos.</target>
        </trans-unit>
        <trans-unit id="cc084a8dfcc6a7bce1de7aefac278e961edc50ea" translate="yes" xml:space="preserve">
          <source>Currently the easiest way to create a network layer is via a helper from the &lt;code&gt;relay-runtime&lt;/code&gt; package:</source>
          <target state="translated">Actualmente, la forma m&amp;aacute;s sencilla de crear una capa de red es mediante un ayudante del paquete &lt;code&gt;relay-runtime&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="461be9b9f59ebf2cd3bfe288b44d41bb20a992dc" translate="yes" xml:space="preserve">
          <source>Custom HTTP headers can be configured by providing a &lt;code&gt;headers&lt;/code&gt; object:</source>
          <target state="translated">Los encabezados HTTP personalizados se pueden configurar proporcionando un objeto de &lt;code&gt;headers&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e441c87bb7618c55b15a3915a29a65fc20c0d1cd" translate="yes" xml:space="preserve">
          <source>Custom Network Layers</source>
          <target state="translated">Capas de red personalizadas</target>
        </trans-unit>
        <trans-unit id="c604943e72b71d4741cddde2419706b8dc35d372" translate="yes" xml:space="preserve">
          <source>Custom Routing and More</source>
          <target state="translated">Rutas personalizadas y más</target>
        </trans-unit>
        <trans-unit id="3fe80ac6912200b4e6e928a52d6c87fd5c777197" translate="yes" xml:space="preserve">
          <source>Custom network layers must conform to the following &lt;a href=&quot;interfaces-relay-network-layer&quot;&gt;RelayNetworkLayer&lt;/a&gt; interface. Although the default network layer is an instantiable class that accepts some configuration, this is not a requirement of an injected network layer.</source>
          <target state="translated">Las capas de red personalizadas deben cumplir con la siguiente interfaz &lt;a href=&quot;interfaces-relay-network-layer&quot;&gt;RelayNetworkLayer&lt;/a&gt; . Aunque la capa de red predeterminada es una clase instanciable que acepta alguna configuraci&amp;oacute;n, esto no es un requisito de una capa de red inyectada.</target>
        </trans-unit>
        <trans-unit id="342f49485ae8bc8e1ade62ea93e337457051f472" translate="yes" xml:space="preserve">
          <source>Custom network layers that must conform to the &lt;code&gt;RelayNetworkLayer&lt;/code&gt; interface.</source>
          <target state="translated">Capas de red personalizadas que deben ajustarse a la interfaz &lt;code&gt;RelayNetworkLayer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74c9c9c8ea99084415bd2064a41ac8fc43148678" translate="yes" xml:space="preserve">
          <source>Data Components aka Containers</source>
          <target state="translated">Componentes de datos,también conocidos como contenedores</target>
        </trans-unit>
        <trans-unit id="682fde2c24e47bc1edbae33948606de2438e015b" translate="yes" xml:space="preserve">
          <source>Data Dependencies With GraphQL</source>
          <target state="translated">Dependencias de datos con GraphQL</target>
        </trans-unit>
        <trans-unit id="b8344c50bb3999d69b17cd5abd2f78e4f029419a" translate="yes" xml:space="preserve">
          <source>Data Masking</source>
          <target state="translated">Enmascaramiento de datos</target>
        </trans-unit>
        <trans-unit id="7054bcb2316977418a434163d17919c53dc34953" translate="yes" xml:space="preserve">
          <source>Data fetched as a result of a &lt;code&gt;REQUIRED_CHILDREN&lt;/code&gt; config is not written into the client store, but you can add code that processes it in the &lt;code&gt;onSuccess&lt;/code&gt; callback that you pass into &lt;code&gt;commitUpdate()&lt;/code&gt;:</source>
          <target state="translated">Los datos obtenidos como resultado de una configuraci&amp;oacute;n &lt;code&gt;REQUIRED_CHILDREN&lt;/code&gt; no se escriben en la tienda del cliente, pero puede agregar c&amp;oacute;digo que los procese en la &lt;code&gt;onSuccess&lt;/code&gt; llamada onSuccess que pasa a &lt;code&gt;commitUpdate()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="af0a7349a2e7fc64dce9051e92bfe24510a15ba4" translate="yes" xml:space="preserve">
          <source>Data-Fetching APIs</source>
          <target state="translated">API de obtención de datos</target>
        </trans-unit>
        <trans-unit id="303a7cb486f5bdd65204f79dab8db7f52fcbe4b2" translate="yes" xml:space="preserve">
          <source>Data/View Consistency</source>
          <target state="translated">Consistencia de datos/visualización</target>
        </trans-unit>
        <trans-unit id="895b27c88016513d278a0ce3dc0663fae3829d58" translate="yes" xml:space="preserve">
          <source>Debugging</source>
          <target state="translated">Debugging</target>
        </trans-unit>
        <trans-unit id="ed85a15e615bc7cc2aa9ef71ae94ad5fcb7456cf" translate="yes" xml:space="preserve">
          <source>Debugging Programmatically</source>
          <target state="translated">Depuración programada</target>
        </trans-unit>
        <trans-unit id="45cae91f4ddfa0491f43cb639f9ed34ee522658d" translate="yes" xml:space="preserve">
          <source>Debugging Visually</source>
          <target state="translated">Depuración visual</target>
        </trans-unit>
        <trans-unit id="f33d59090001ed2c388b4cc1db43054af86f06dd" translate="yes" xml:space="preserve">
          <source>Default Network Layer</source>
          <target state="translated">Capa de red por defecto</target>
        </trans-unit>
        <trans-unit id="20f0fc44b4326d9865c55f56d274d841f7d0587e" translate="yes" xml:space="preserve">
          <source>DefaultNetworkLayer (static property)</source>
          <target state="translated">DefaultNetworkLayer (propiedad estática)</target>
        </trans-unit>
        <trans-unit id="af5bf36afc63e00856e220e9305692ac4cae2b78" translate="yes" xml:space="preserve">
          <source>Design a fat query that covers every possible field that could change:</source>
          <target state="translated">Diseñe una consulta gorda que cubra todos los campos posibles que puedan cambiar:</target>
        </trans-unit>
        <trans-unit id="28c82071e940360118b0611d5c912a71c32a0100" translate="yes" xml:space="preserve">
          <source>Directives</source>
          <target state="translated">Directives</target>
        </trans-unit>
        <trans-unit id="ef7942184e9ad574a626b6cd3619cdb041e9c029" translate="yes" xml:space="preserve">
          <source>During this migration, use the &lt;a href=&quot;relay-compat&quot;&gt;Relay Compat&lt;/a&gt; tools and APIs to work with both Relay Classic and Relay Modern.</source>
          <target state="translated">Durante esta migraci&amp;oacute;n, use las herramientas y las API de &lt;a href=&quot;relay-compat&quot;&gt;Relay Compat&lt;/a&gt; para trabajar con Relay Classic y Relay Modern.</target>
        </trans-unit>
        <trans-unit id="7c5b3fea8b3510ceda05e64bba7877572b147261" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;RelayMutationTransaction&lt;/code&gt; has methods to check the status of the mutation and provide ways to rollback or resend the mutation as needed.</source>
          <target state="translated">Cada &lt;code&gt;RelayMutationTransaction&lt;/code&gt; tiene m&amp;eacute;todos para verificar el estado de la mutaci&amp;oacute;n y proporcionar formas de deshacer o reenviar la mutaci&amp;oacute;n seg&amp;uacute;n sea necesario.</target>
        </trans-unit>
        <trans-unit id="bd362bb1462055d845230a17457c0b8e8d86a3b8" translate="yes" xml:space="preserve">
          <source>Either an instance of &lt;code&gt;Relay.Route&lt;/code&gt; or an object with the &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;queries&lt;/code&gt;, and optionally the &lt;code&gt;params&lt;/code&gt; properties.</source>
          <target state="translated">Ya sea una instancia de &lt;code&gt;Relay.Route&lt;/code&gt; o un objeto con el &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;queries&lt;/code&gt; y, opcionalmente, las propiedades &lt;code&gt;params&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d443a1185575c125d61e0af393b044d7b06ef572" translate="yes" xml:space="preserve">
          <source>Environment</source>
          <target state="translated">Environment</target>
        </trans-unit>
        <trans-unit id="b887632c87cffc81f6686f76c25016e576fb2182" translate="yes" xml:space="preserve">
          <source>Even though we have access to the &lt;code&gt;data&lt;/code&gt; object in &lt;code&gt;renderFetched&lt;/code&gt;, the actual data is intentionally opaque. This prevents the &lt;code&gt;renderFetched&lt;/code&gt; from creating an implicit dependency on the fragments declared by &lt;code&gt;Component&lt;/code&gt;.</source>
          <target state="translated">Aunque tenemos acceso al objeto de &lt;code&gt;data&lt;/code&gt; en &lt;code&gt;renderFetched&lt;/code&gt; , los datos reales son intencionalmente opacos. Esto evita que &lt;code&gt;renderFetched&lt;/code&gt; cree una dependencia impl&amp;iacute;cita en los fragmentos declarados por &lt;code&gt;Component&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="47edfe63fdfee7ee20d0d17ccd2198d126f5e61d" translate="yes" xml:space="preserve">
          <source>Examples on how to migrate &lt;code&gt;this.props.setVariables&lt;/code&gt; calls from the old API.</source>
          <target state="translated">Ejemplos sobre c&amp;oacute;mo migrar llamadas &lt;code&gt;this.props.setVariables&lt;/code&gt; desde la API antigua.</target>
        </trans-unit>
        <trans-unit id="dba94b198da2fb33fd23ea18f305f3d0a3ec1059" translate="yes" xml:space="preserve">
          <source>Extensible Core</source>
          <target state="translated">Núcleo extensible</target>
        </trans-unit>
        <trans-unit id="2dd50f5706aa755699729587eac1b10f1cff5f0e" translate="yes" xml:space="preserve">
          <source>FIELDS_CHANGE</source>
          <target state="translated">FIELDS_CHANGE</target>
        </trans-unit>
        <trans-unit id="48bf3bbfe2cde9b89a0197b2bfecef97b15ae5d4" translate="yes" xml:space="preserve">
          <source>Fetching Data</source>
          <target state="translated">Obtención de datos</target>
        </trans-unit>
        <trans-unit id="9fa4dbe72754c9ca8a7a48295981890f655e2aba" translate="yes" xml:space="preserve">
          <source>Fetching Data For a View</source>
          <target state="translated">Buscando datos para una vista</target>
        </trans-unit>
        <trans-unit id="ec6417097316a1a14f3a999d488c8c77877598bd" translate="yes" xml:space="preserve">
          <source>Fetching Data from the Server</source>
          <target state="translated">Obtención de datos del servidor</target>
        </trans-unit>
        <trans-unit id="a342eda81c049d657e5bd1f80671b4b62b62acba" translate="yes" xml:space="preserve">
          <source>Fetching all the data for a view hierarchy.</source>
          <target state="translated">Obteniendo todos los datos para una jerarquía de vistas.</target>
        </trans-unit>
        <trans-unit id="448b955ee10782eac37b116fa4e7872f8363dbf4" translate="yes" xml:space="preserve">
          <source>Fewer Requirements around Routing</source>
          <target state="translated">Menos requisitos para el enrutamiento</target>
        </trans-unit>
        <trans-unit id="6c0e1cc40fccace9c870f52b415d915d429a858c" translate="yes" xml:space="preserve">
          <source>Finally, let's tie it all together in &lt;code&gt;./js/components/App.js&lt;/code&gt;:</source>
          <target state="translated">Finalmente, &lt;code&gt;./js/components/App.js&lt;/code&gt; todo en ./js/components/App.js :</target>
        </trans-unit>
        <trans-unit id="794475575e8e8e88251415839f49042175570f60" translate="yes" xml:space="preserve">
          <source>Finally, we construct our schema (whose starting query type is the query type we defined above) and export it.</source>
          <target state="translated">Finalmente,construimos nuestro esquema (cuyo tipo de consulta inicial es el tipo de consulta que definimos anteriormente)y lo exportamos.</target>
        </trans-unit>
        <trans-unit id="f5d8e52e096ba49348c23c94d52fb5128a53fc82" translate="yes" xml:space="preserve">
          <source>Finds or creates a single record associated with a mutable record. This is a shortcut to &lt;code&gt;RelayRecordProxy.getLinkedRecord&lt;/code&gt; with &lt;code&gt;RelayRecordProxy.setLinkedRecord&lt;/code&gt; should the associated record be non-existant.</source>
          <target state="translated">Busca o crea un solo registro asociado con un registro mutable. Este es un acceso directo a &lt;code&gt;RelayRecordProxy.getLinkedRecord&lt;/code&gt; con &lt;code&gt;RelayRecordProxy.setLinkedRecord&lt;/code&gt; en caso de que el registro asociado no exista.</target>
        </trans-unit>
        <trans-unit id="d4726e1215a3598f0b285dcd1fdabf31356a5b5b" translate="yes" xml:space="preserve">
          <source>First, install the plugin (typically as a &lt;code&gt;devDependency&lt;/code&gt;):</source>
          <target state="translated">Primero, instale el complemento (generalmente como &lt;code&gt;devDependency&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="9ee7304a030b3188f69053199e1aa24d2c7e6c40" translate="yes" xml:space="preserve">
          <source>First, let's take a look at the &lt;code&gt;environment&lt;/code&gt; input. To perform the mutation on the correct &lt;code&gt;environment&lt;/code&gt; with the relevant data, it's a good idea to use the &lt;code&gt;environment&lt;/code&gt; used to render the components. It's accessible at &lt;code&gt;this.props.relay.environment&lt;/code&gt; from the component.</source>
          <target state="translated">Primero, echemos un vistazo a la entrada del &lt;code&gt;environment&lt;/code&gt; . Para realizar la mutaci&amp;oacute;n en el &lt;code&gt;environment&lt;/code&gt; correcto con los datos relevantes, es una buena idea utilizar el &lt;code&gt;environment&lt;/code&gt; utilizado para representar los componentes. Es accesible en &lt;code&gt;this.props.relay.environment&lt;/code&gt; desde el componente.</target>
        </trans-unit>
        <trans-unit id="a3aab624101e00feee75c13777205ffcca8d11b0" translate="yes" xml:space="preserve">
          <source>First, you need &lt;a href=&quot;https://facebook.github.io/watchman&quot;&gt;watchman&lt;/a&gt; installed:</source>
          <target state="translated">Primero, necesita &lt;a href=&quot;https://facebook.github.io/watchman&quot;&gt;vigilante&lt;/a&gt; instalado:</target>
        </trans-unit>
        <trans-unit id="0a54de1cc9f2aff2bed1cf76593938b1ded20fcf" translate="yes" xml:space="preserve">
          <source>Flat Routes</source>
          <target state="translated">Rutas planas</target>
        </trans-unit>
        <trans-unit id="995180ea866af99054ca25768d4bd2ff5d5c8968" translate="yes" xml:space="preserve">
          <source>Flow Type Generation</source>
          <target state="translated">Generación del tipo de flujo</target>
        </trans-unit>
        <trans-unit id="c46edacfc204a583603ecb9b72b53c55f60dbc6a" translate="yes" xml:space="preserve">
          <source>For a complete example of how to load a &lt;code&gt;schema.js&lt;/code&gt; file, run the introspection query to get schema information, and save it to a JSON file, check out the &lt;a href=&quot;https://github.com/relayjs/relay-starter-kit/blob/master/scripts/updateSchema.js&quot;&gt;starter kit&lt;/a&gt;.</source>
          <target state="translated">Para obtener un ejemplo completo de c&amp;oacute;mo cargar un archivo &lt;code&gt;schema.js&lt;/code&gt; , ejecute la consulta de introspecci&amp;oacute;n para obtener informaci&amp;oacute;n del esquema y gu&amp;aacute;rdelo en un archivo JSON, consulte el &lt;a href=&quot;https://github.com/relayjs/relay-starter-kit/blob/master/scripts/updateSchema.js&quot;&gt;kit de inicio&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cfe4ba012b2b664f6e8a52e5430ca8b838d37291" translate="yes" xml:space="preserve">
          <source>For a simple application that's already a nice improvement.</source>
          <target state="translated">Por una simple aplicación que ya es una buena mejora.</target>
        </trans-unit>
        <trans-unit id="96c534ed5280cce92d6b2b0550da3496f193200e" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;rangeBehaviors&lt;/code&gt; could be written this way:</source>
          <target state="translated">Por ejemplo, &lt;code&gt;rangeBehaviors&lt;/code&gt; se podr&amp;iacute;a escribir de esta manera:</target>
        </trans-unit>
        <trans-unit id="4999f2258aff41aa7c828698a3d72fe291b86eb2" translate="yes" xml:space="preserve">
          <source>For example, a network layer can be a simple object that conforms to the interface:</source>
          <target state="translated">Por ejemplo,una capa de red puede ser un simple objeto que se ajusta a la interfaz:</target>
        </trans-unit>
        <trans-unit id="8ffcdf17f2ad817cd3da93a900284bc63c193056" translate="yes" xml:space="preserve">
          <source>For example, given the two files:</source>
          <target state="translated">Por ejemplo,dados los dos archivos:</target>
        </trans-unit>
        <trans-unit id="12bad1fdad02e0f5d5569bcccc232e7c8357d9c5" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;currentDate&lt;/code&gt; is set in &lt;code&gt;QueryRenderer&lt;/code&gt;&lt;code&gt;variables&lt;/code&gt;, then $currentDate may be referenced in any fragment included in the &lt;code&gt;QueryRenderer&lt;/code&gt;&lt;code&gt;query&lt;/code&gt;.</source>
          <target state="translated">Por ejemplo, si &lt;code&gt;currentDate&lt;/code&gt; se establece en &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;code&gt;variables&lt;/code&gt; QueryRenderer , entonces se puede hacer referencia a $ currentDate en cualquier fragmento incluido en la &lt;code&gt;query&lt;/code&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1178c99ccfd9629da7c347f69a733ccb2674242f" translate="yes" xml:space="preserve">
          <source>For examples of more complex optimistic updates, including adding and removing from a list, see the &lt;a href=&quot;https://github.com/relayjs/relay-examples/tree/master/todo&quot;&gt;Relay Modern Todo example app&lt;/a&gt;.</source>
          <target state="translated">Para ver ejemplos de actualizaciones optimistas m&amp;aacute;s complejas, incluida la adici&amp;oacute;n y eliminaci&amp;oacute;n de una lista, consulte la &lt;a href=&quot;https://github.com/relayjs/relay-examples/tree/master/todo&quot;&gt;aplicaci&amp;oacute;n de ejemplo Relay Modern Todo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a82abfdd90416cbeaffe64d3e50d78377188efce" translate="yes" xml:space="preserve">
          <source>For more complex use-cases, you may wish to perform custom logic to update Relay's in-memory cache when each subscription response is received. To do so, pass an &lt;code&gt;updater&lt;/code&gt; function:</source>
          <target state="translated">Para casos de uso m&amp;aacute;s complejos, es posible que desee realizar una l&amp;oacute;gica personalizada para actualizar el cach&amp;eacute; en memoria de Relay cuando se recibe cada respuesta de suscripci&amp;oacute;n. Para hacerlo, pase una funci&amp;oacute;n de &lt;code&gt;updater&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2ac9b5543bc0f49df0cfb3a851760d47fc555d44" translate="yes" xml:space="preserve">
          <source>For more complicated mutations, &lt;code&gt;optimisticUpdater&lt;/code&gt; and &lt;code&gt;updater&lt;/code&gt; can be the same function.</source>
          <target state="translated">Para mutaciones m&amp;aacute;s complicadas, &lt;code&gt;optimisticUpdater&lt;/code&gt; y &lt;code&gt;updater&lt;/code&gt; pueden tener la misma funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1137480158b92303f1522341248742d418f8a480" translate="yes" xml:space="preserve">
          <source>For more details on creating a Network, see the &lt;a href=&quot;network-layer&quot;&gt;NetworkLayer guide&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s detalles sobre la creaci&amp;oacute;n de una red, consulte la &lt;a href=&quot;network-layer&quot;&gt;gu&amp;iacute;a NetworkLayer&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cf88bc6b3b6a4c187092ec351a5b1077c1d26272" translate="yes" xml:space="preserve">
          <source>For new Relay apps or existing apps that have been fully converted to the Compat API, the Relay Modern runtime can be enabled to activate even more features. In addition to those described above, this includes:</source>
          <target state="translated">En el caso de las nuevas aplicaciones de Relay o de las aplicaciones existentes que se han convertido completamente a la API de Compat,se puede activar el tiempo de ejecución de Relay Modern para activar aún más funciones.Además de las descritas anteriormente,esto incluye:</target>
        </trans-unit>
        <trans-unit id="18fbf073a81951774f334f655935c2dac6e6377a" translate="yes" xml:space="preserve">
          <source>Force Fetching</source>
          <target state="translated">La atracción de la fuerza</target>
        </trans-unit>
        <trans-unit id="96bbe9b850cec5fbab27d61fde4b1fa63d06e24d" translate="yes" xml:space="preserve">
          <source>Force Fetching with Data from the Client</source>
          <target state="translated">La búsqueda de la fuerza con los datos del cliente</target>
        </trans-unit>
        <trans-unit id="bbba84135de6b052c2210e74e0cc5b2a9d359ddb" translate="yes" xml:space="preserve">
          <source>Found</source>
          <target state="translated">Found</target>
        </trans-unit>
        <trans-unit id="365b08de44008517ff803d0c36a644ac290dba44" translate="yes" xml:space="preserve">
          <source>Found offers integration with Relay Modern and Relay Classic via &lt;a href=&quot;https://github.com/4Catalyzer/found-relay&quot;&gt;Found Relay&lt;/a&gt;. Found Relay runs queries for matched routes in parallel, and supports fetching Relay data in parallel with downloading async bundles from code splitting when using Relay Modern.</source>
          <target state="translated">Found ofrece integraci&amp;oacute;n con Relay Modern y Relay Classic a trav&amp;eacute;s de &lt;a href=&quot;https://github.com/4Catalyzer/found-relay&quot;&gt;Found Relay&lt;/a&gt; . Found Relay ejecuta consultas para rutas coincidentes en paralelo y admite la obtenci&amp;oacute;n de datos de Relay en paralelo con la descarga de paquetes as&amp;iacute;ncronos de la divisi&amp;oacute;n de c&amp;oacute;digo cuando se usa Relay Modern.</target>
        </trans-unit>
        <trans-unit id="e58abca7c5abd6b02071e05687c03305e61f7adb" translate="yes" xml:space="preserve">
          <source>Fragment Composition</source>
          <target state="translated">Composición de los fragmentos</target>
        </trans-unit>
        <trans-unit id="4c9b8ee7dc2184d0aab89be194eb15b57be40cef" translate="yes" xml:space="preserve">
          <source>Fragment composition is achieved via ES6 template string interpolation and &lt;code&gt;getFragment&lt;/code&gt;:</source>
          <target state="translated">La composici&amp;oacute;n de los fragmentos se logra mediante la interpolaci&amp;oacute;n de cadenas de plantillas de ES6 y &lt;code&gt;getFragment&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="99eb0c4810611d5c803d75a7ca10220fd2d2cfea" translate="yes" xml:space="preserve">
          <source>Fragment composition works similarly &amp;mdash; a parent container's fragment composes the fragment for each of its children. In this case, &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; needs to fetch information about the &lt;code&gt;User&lt;/code&gt; that is required by &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">La composici&amp;oacute;n de fragmentos funciona de manera similar: el fragmento de un contenedor padre compone el fragmento para cada uno de sus hijos. En este caso, &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; necesita obtener informaci&amp;oacute;n sobre el &lt;code&gt;User&lt;/code&gt; requerida por &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4c1ec38ec0f0411751ca1a7fa59d2e3f75e878a" translate="yes" xml:space="preserve">
          <source>Fragment composition works similarly &amp;mdash; a parent container's fragment composes the fragment for each of its children. In this case, &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; needs to fetch information about the &lt;code&gt;Todo&lt;/code&gt;s that are required by &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">La composici&amp;oacute;n de fragmentos funciona de manera similar: el fragmento de un contenedor padre compone el fragmento para cada uno de sus hijos. En este caso, &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; necesita obtener informaci&amp;oacute;n sobre los &lt;code&gt;Todo&lt;/code&gt; que son requeridos por &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a7eb65ef2204b222cba330bf9518e103ffff4a9" translate="yes" xml:space="preserve">
          <source>Fragment variables</source>
          <target state="translated">Las variables de los fragmentos</target>
        </trans-unit>
        <trans-unit id="6c4797fcf380c1ad929a06c044c27ce633b8a89b" translate="yes" xml:space="preserve">
          <source>FragmentContainer</source>
          <target state="translated">FragmentContainer</target>
        </trans-unit>
        <trans-unit id="e8e4adae3ec551af9e8edf80d04fd880f87f33b9" translate="yes" xml:space="preserve">
          <source>Fragments can be composed in one of two ways:</source>
          <target state="translated">Los fragmentos pueden estar compuestos de una de dos maneras:</target>
        </trans-unit>
        <trans-unit id="1ec5c60b97bf9a572f6951db4d37f812151af82e" translate="yes" xml:space="preserve">
          <source>Fragments can be embedded within other fragments or queries. For example, the above fragment could be used to fetch user &lt;code&gt;123&lt;/code&gt;'s profile photo:</source>
          <target state="translated">Los fragmentos se pueden incrustar dentro de otros fragmentos o consultas. Por ejemplo, el fragmento anterior podr&amp;iacute;a usarse para obtener la foto de perfil del usuario &lt;code&gt;123&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5749ddc88402f36f29ad8ff8b7fc5a5626b02527" translate="yes" xml:space="preserve">
          <source>Fragments may also compose other fragments that are assigned to local variables:</source>
          <target state="translated">Los fragmentos también pueden componer otros fragmentos que se asignan a variables locales:</target>
        </trans-unit>
        <trans-unit id="5b32b8542e4c8854b05455c0b114c2bdced713ad" translate="yes" xml:space="preserve">
          <source>Garbage Collection</source>
          <target state="translated">Recolección de basura</target>
        </trans-unit>
        <trans-unit id="13e8bde6a75cc8bafc18233096a72b0f6248985e" translate="yes" xml:space="preserve">
          <source>General-purpose tools for building a GraphQL schema using JavaScript</source>
          <target state="translated">Herramientas de propósito general para construir un esquema GraphQL usando JavaScript</target>
        </trans-unit>
        <trans-unit id="2b67d1eb9affe329c622f0576365f0ee268cf097" translate="yes" xml:space="preserve">
          <source>Gets a fragment reference for use in a parent's query fragment.</source>
          <target state="translated">Obtiene una referencia del fragmento para su uso en un fragmento de consulta de un padre.</target>
        </trans-unit>
        <trans-unit id="efadaa65e42a5128618d6d70d6e5f16a32ea9213" translate="yes" xml:space="preserve">
          <source>Gets a reference to a child container's fragment for inclusion in a parent fragment.</source>
          <target state="translated">Consigue una referencia al fragmento de un contenedor de un niño para su inclusión en un fragmento de un padre.</target>
        </trans-unit>
        <trans-unit id="bab08a8b8e5697e21edf5ba8471a6d2976e052d5" translate="yes" xml:space="preserve">
          <source>Gets a string name used to refer to this request for printing debug output.</source>
          <target state="translated">Obtiene un nombre de cadena usado para referirse a esta solicitud de impresión de salida de depuración.</target>
        </trans-unit>
        <trans-unit id="c66f9fff87afddb71ece32a2129c20b745b3303d" translate="yes" xml:space="preserve">
          <source>Gets a string representation of the GraphQL mutation.</source>
          <target state="translated">Obtiene una representación en cadena de la mutación GraphQL.</target>
        </trans-unit>
        <trans-unit id="f2fb6164e4d92fdf7bb9de20c1488df58f14ec49" translate="yes" xml:space="preserve">
          <source>Gets a string representation of the GraphQL query.</source>
          <target state="translated">Obtiene una representación en cadena de la consulta GraphQL.</target>
        </trans-unit>
        <trans-unit id="abe1bcf50d4649b6cc620e50d25b565688c7d9a1" translate="yes" xml:space="preserve">
          <source>Gets a unique identifier for this mutation. These identifiers are useful for assigning response payloads to their corresponding mutations when sent in a single GraphQL request.</source>
          <target state="translated">Consigue un identificador único para esta mutación.Estos identificadores son útiles para asignar cargas de respuesta a sus correspondientes mutaciones cuando se envían en una única solicitud GraphQL.</target>
        </trans-unit>
        <trans-unit id="96e072f6fa8b2d20b9da83302dbda948494674bf" translate="yes" xml:space="preserve">
          <source>Gets a unique identifier for this query. These identifiers are useful for assigning response payloads to their corresponding queries when sent in a single GraphQL request.</source>
          <target state="translated">Consigue un identificador único para esta consulta.Estos identificadores son útiles para asignar cargas de respuesta a sus consultas correspondientes cuando se envían en una única solicitud GraphQL.</target>
        </trans-unit>
        <trans-unit id="5406c8eaf62c01411092558cd572b43c5b89bfa6" translate="yes" xml:space="preserve">
          <source>Gets an optional map from name to File objects.</source>
          <target state="translated">Obtiene un mapa opcional del nombre a los objetos del archivo.</target>
        </trans-unit>
        <trans-unit id="118b9b0bfba623072bfed30c4a7c6d4b769ead2a" translate="yes" xml:space="preserve">
          <source>Gets the variables used by the mutation. These variables should be serialized and send in the GraphQL request.</source>
          <target state="translated">Obtiene las variables utilizadas por la mutación.Estas variables deben ser serializadas y enviar la solicitud de GraphQL.</target>
        </trans-unit>
        <trans-unit id="5f68839c1e374f581aaccfdd2584db85f5d5531a" translate="yes" xml:space="preserve">
          <source>Gets the variables used by the query. These variables should be serialized and sent in the GraphQL request.</source>
          <target state="translated">Obtiene las variables utilizadas por la consulta.Estas variables deben ser serializadas y enviadas en la solicitud de GraphQL.</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">Empezando</target>
        </trans-unit>
        <trans-unit id="76e7a3a3f9c225fe820ba7e9cff10ea2a73b79a1" translate="yes" xml:space="preserve">
          <source>Getting started</source>
          <target state="translated">Empezando...</target>
        </trans-unit>
        <trans-unit id="8b19260759d77673b9a877795f157d4044253944" translate="yes" xml:space="preserve">
          <source>Given a connection, one or more DataIDs in the response payload, and a path between the parent and the connection, Relay will remove the node(s) from the connection but leave the associated record(s) in the store.</source>
          <target state="translated">Dada una conexión,uno o más DataIDs en la carga de respuesta,y una ruta entre el padre y la conexión,el Relevo eliminará el/los nodo(s)de la conexión pero dejará el/los registro(s)asociado(s)en el almacén.</target>
        </trans-unit>
        <trans-unit id="e48271c6488ce169319e6996a17416ab8db56489" translate="yes" xml:space="preserve">
          <source>Given a deletedIDFieldName, Relay will remove the node(s) from the connection.</source>
          <target state="translated">Si se le da un nombre de campo ID eliminado,el relé eliminará el nodo o los nodos de la conexión.</target>
        </trans-unit>
        <trans-unit id="47de81551f168ce6aed9196d0adf126b977177b6" translate="yes" xml:space="preserve">
          <source>Given a parent, a connection, and one or more DataIDs in the response payload, Relay will remove the node(s) from the connection and delete the associated record(s) from the store.</source>
          <target state="translated">Si se le da un padre,una conexión y uno o más DataID en la carga de respuesta,el Relevo eliminará el/los nodo(s)de la conexión y borrará el/los registro(s)asociado(s)de la tienda.</target>
        </trans-unit>
        <trans-unit id="a51dc0bfb8bd3ee42a7194ed76f6218686158817" translate="yes" xml:space="preserve">
          <source>Given a parent, a connection, and the name of the newly created edge in the response payload Relay will add the node to the store and attach it to the connection according to the range behavior specified.</source>
          <target state="translated">Si se le da un padre,una conexión,y el nombre del borde recién creado en la carga útil de respuesta Relé añadirá el nodo a la tienda y lo adjuntará a la conexión de acuerdo con el comportamiento de rango especificado.</target>
        </trans-unit>
        <trans-unit id="524a22d3cb952e409df0e138141726ed755fe115" translate="yes" xml:space="preserve">
          <source>Given a parent, connectionKeys, one or more DataIDs in the response payload, and a path between the parent and the connection, Relay will remove the node(s) from the connection but leave the associated record(s) in the store.</source>
          <target state="translated">Si se le da un padre,las ConnectionKeys,uno o más DataIDs en la carga de respuesta,y una ruta entre el padre y la conexión,el Relevo eliminará el nodo o nodos de la conexión pero dejará el registro o registros asociados en el almacén.</target>
        </trans-unit>
        <trans-unit id="6c8602a6c8072fdb24f4522613cbc2f7cfcca2ed" translate="yes" xml:space="preserve">
          <source>Given a parent, information about the connection, and the name of the newly created edge in the response payload Relay will add the node to the store and attach it to the connection according to the range behavior(s) specified in the connectionInfo.</source>
          <target state="translated">Si se le da un padre,la información sobre la conexión y el nombre del borde recién creado en la carga útil de respuesta Relevador añadirá el nodo al almacén y lo adjuntará a la conexión de acuerdo con el comportamiento de rango especificado en la información de conexión.</target>
        </trans-unit>
        <trans-unit id="1d0fa81ee1013085b7d63ff166408f30527ff41a" translate="yes" xml:space="preserve">
          <source>Given the plain React component and a GraphQL fragment, we can now define a &lt;code&gt;Container&lt;/code&gt; to tell Relay about this component's data requirements. Let's look at the code first and then see what's happening:</source>
          <target state="translated">Dado el componente React simple y un fragmento GraphQL, ahora podemos definir un &lt;code&gt;Container&lt;/code&gt; para informar a Relay sobre los requisitos de datos de este componente. Veamos primero el c&amp;oacute;digo y luego veamos qu&amp;eacute; est&amp;aacute; sucediendo:</target>
        </trans-unit>
        <trans-unit id="3e96a8e96d952292ce981325cfa1fcff52e52c7e" translate="yes" xml:space="preserve">
          <source>Given these real-world constraints, the approach in GraphQL is for clients to query for things that may change after a mutation. But what exactly do we put in that query? During the development of Relay we explored several ideas &amp;mdash; let's look at them briefly in order to understand why Relay uses the approach that it does:</source>
          <target state="translated">Dadas estas limitaciones del mundo real, el enfoque en GraphQL es que los clientes consulten cosas que pueden cambiar despu&amp;eacute;s de una mutaci&amp;oacute;n. Pero, &amp;iquest;qu&amp;eacute; ponemos exactamente en esa consulta? Durante el desarrollo de Relay, exploramos varias ideas; ve&amp;aacute;moslas brevemente para comprender por qu&amp;eacute; Relay utiliza el enfoque que utiliza:</target>
        </trans-unit>
        <trans-unit id="e4eb1ab683c392399fa825b2dea3b7e5f8189912" translate="yes" xml:space="preserve">
          <source>GraphQL</source>
          <target state="translated">GraphQL</target>
        </trans-unit>
        <trans-unit id="d1104d2d1c77df98433b7b7cb498cfbba782bab4" translate="yes" xml:space="preserve">
          <source>GraphQL Relay Specification</source>
          <target state="translated">Especificación del relé de GraphQL</target>
        </trans-unit>
        <trans-unit id="2462160d86cfb1c5d092d0aa517b3b680333ccb3" translate="yes" xml:space="preserve">
          <source>GraphQL Schema</source>
          <target state="translated">Esquema GraphQL</target>
        </trans-unit>
        <trans-unit id="37f3b6a18cf42e1932e52d60a342d388f522602a" translate="yes" xml:space="preserve">
          <source>GraphQL Subscriptions &amp;amp; Live Queries</source>
          <target state="translated">Suscripciones a GraphQL y consultas en vivo</target>
        </trans-unit>
        <trans-unit id="6884fbda0403c3eb6a361b276df83698590e1779" translate="yes" xml:space="preserve">
          <source>GraphQL is designed to support a wide range of data access patterns. In order to understand the structure of an application's data, Relay requires that you follow certain conventions when defining your schema. These are documented in the &lt;a href=&quot;graphql-relay-specification&quot;&gt;GraphQL Relay Specification&lt;/a&gt;.</source>
          <target state="translated">GraphQL est&amp;aacute; dise&amp;ntilde;ado para admitir una amplia gama de patrones de acceso a datos. Para comprender la estructura de los datos de una aplicaci&amp;oacute;n, Relay requiere que siga ciertas convenciones al definir su esquema. Estos est&amp;aacute;n documentados en la &lt;a href=&quot;graphql-relay-specification&quot;&gt;Especificaci&amp;oacute;n de retransmisi&amp;oacute;n GraphQL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="55711b09c6616aea30b39a64a358b0d9490999c3" translate="yes" xml:space="preserve">
          <source>GraphQL presents new ways for clients to fetch data by focusing on the needs of product developers and client applications. It provides a way for developers to specify the precise data needed for a view and enables a client to fetch that data in a single network request. Compared to traditional approaches such as REST, GraphQL helps applications to fetch data more efficiently (compared to resource-oriented REST approaches) and avoid duplication of server logic (which can occur with custom endpoints). Furthermore, GraphQL helps developers to decouple product code and server logic. For example, a product can fetch more or less information without requiring a change to every relevant server endpoint. It's a great way to fetch data.</source>
          <target state="translated">GraphQL presenta nuevas formas para que los clientes obtengan datos centrándose en las necesidades de los desarrolladores de productos y las aplicaciones de los clientes.Proporciona una forma para que los desarrolladores especifiquen los datos precisos que se necesitan para una vista y permite a un cliente obtener esos datos en una sola solicitud de red.En comparación con los enfoques tradicionales como REST,GraphQL ayuda a las aplicaciones a obtener datos de manera más eficiente (en comparación con los enfoques REST orientados a los recursos)y a evitar la duplicación de la lógica del servidor (que puede ocurrir con los puntos finales personalizados).Además,GraphQL ayuda a los desarrolladores a disociar el código del producto y la lógica del servidor.Por ejemplo,un producto puede obtener más o menos información sin necesidad de cambiar cada uno de los puntos finales del servidor relevantes.Es una excelente manera de obtener datos.</target>
        </trans-unit>
        <trans-unit id="cd5d1ec7247a2826222f29ae64e2e192abb30c33" translate="yes" xml:space="preserve">
          <source>GraphQL provides a powerful tool for building efficient, decoupled client applications. Relay builds on this functionality to provide a framework for &lt;strong&gt;declarative data-fetching&lt;/strong&gt;. By separating &lt;em&gt;what&lt;/em&gt; data to fetch from &lt;em&gt;how&lt;/em&gt; it is fetched, Relay helps developers build applications that are robust, transparent, and performant by default. It's a great complement to the component-centric way of thinking championed by React. While each of these technologies &amp;mdash; React, Relay, and GraphQL &amp;mdash; are powerful on their own, the combination is a &lt;strong&gt;UI platform&lt;/strong&gt; that allows us to &lt;em&gt;move fast&lt;/em&gt; and &lt;em&gt;ship high-quality apps at scale&lt;/em&gt;.</source>
          <target state="translated">GraphQL proporciona una poderosa herramienta para crear aplicaciones cliente eficientes y desacopladas. Relay se basa en esta funcionalidad para proporcionar un marco para la &lt;strong&gt;obtenci&amp;oacute;n de datos declarativos&lt;/strong&gt; . Al separar &lt;em&gt;lo que&lt;/em&gt; los datos para ir a buscar a &lt;em&gt;la forma en&lt;/em&gt; que se capta, rel&amp;eacute; ayuda a los desarrolladores crear aplicaciones que son robustos, transparente y performant por defecto. Es un gran complemento para la forma de pensar centrada en componentes promovida por React. Si bien cada una de estas tecnolog&amp;iacute;as (React, Relay y GraphQL) son poderosas por s&amp;iacute; mismas, la combinaci&amp;oacute;n es una &lt;strong&gt;plataforma de interfaz de usuario&lt;/strong&gt; que nos permite &lt;em&gt;movernos r&amp;aacute;pido&lt;/em&gt; y &lt;em&gt;enviar aplicaciones de alta calidad a escala&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1745637b6e7ac2208886e0fe73413f315dc1d52e" translate="yes" xml:space="preserve">
          <source>Here's a basic implementation of &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; that ignores styling in order to highlight the functionality:</source>
          <target state="translated">Aqu&amp;iacute; hay una implementaci&amp;oacute;n b&amp;aacute;sica de &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; que ignora el estilo para resaltar la funcionalidad:</target>
        </trans-unit>
        <trans-unit id="c7acba2d971e69e956adf8a6ecc2371b0bf96df3" translate="yes" xml:space="preserve">
          <source>Here's a basic implementation of &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; that ignores styling in order to highlight the functionality:</source>
          <target state="translated">Aqu&amp;iacute; hay una implementaci&amp;oacute;n b&amp;aacute;sica de &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; que ignora el estilo para resaltar la funcionalidad:</target>
        </trans-unit>
        <trans-unit id="dbbbbf44b31cd11738f96ef61375f12e9722988b" translate="yes" xml:space="preserve">
          <source>Here's an example of this mutation in use by a &lt;code&gt;LikeButton&lt;/code&gt; component:</source>
          <target state="translated">Aqu&amp;iacute; hay un ejemplo de esta mutaci&amp;oacute;n en uso por un componente &lt;code&gt;LikeButton&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="385d7c0cfbb336e0125f7ea51dde1cd3078887da" translate="yes" xml:space="preserve">
          <source>Here's an example query that fetches a story's text and its author's name:</source>
          <target state="translated">Aquí hay un ejemplo de consulta que busca el texto de una historia y el nombre de su autor:</target>
        </trans-unit>
        <trans-unit id="0694e515f41dabfcc348f2df0677999ef99af1ea" translate="yes" xml:space="preserve">
          <source>Here's what happens when the container is rendered:</source>
          <target state="translated">Esto es lo que sucede cuando el contenedor se desecha:</target>
        </trans-unit>
        <trans-unit id="2284d040f5091f510de37a154536196310f9c02d" translate="yes" xml:space="preserve">
          <source>Hint</source>
          <target state="translated">Hint</target>
        </trans-unit>
        <trans-unit id="05531ed7907681dd3a6ac4e94e82348c1af49264" translate="yes" xml:space="preserve">
          <source>Historically, Relay started out internally at Facebook as a routing framework. However, Relay no longer makes any assumptions about routing, and works with a variety of routing options.</source>
          <target state="translated">Históricamente,Relay comenzó internamente en Facebook como un marco de enrutamiento.Sin embargo,Relay ya no hace ninguna suposición sobre el enrutamiento,y trabaja con una variedad de opciones de enrutamiento.</target>
        </trans-unit>
        <trans-unit id="f96c9aa85d59b7983b33495b149e7fee5f7bf418" translate="yes" xml:space="preserve">
          <source>Hm. There were no more ships; guess there were only five in the system for the rebels. It would have been nice to know that we'd reached the end of the connection, without having to do another round trip in order to verify that. The connection model exposes this capability with a type called &lt;code&gt;PageInfo&lt;/code&gt;. So let's issue the two queries that got us ships again, but this time ask for &lt;code&gt;hasNextPage&lt;/code&gt;:</source>
          <target state="translated">Hm. No hab&amp;iacute;a m&amp;aacute;s barcos; Supongo que solo hab&amp;iacute;a cinco en el sistema para los rebeldes. Hubiera sido bueno saber que hab&amp;iacute;amos llegado al final de la conexi&amp;oacute;n, sin tener que hacer otro viaje de ida y vuelta para verificarlo. El modelo de conexi&amp;oacute;n expone esta capacidad con un tipo llamado &lt;code&gt;PageInfo&lt;/code&gt; . As&amp;iacute; que &lt;code&gt;hasNextPage&lt;/code&gt; las dos consultas que nos consiguieron env&amp;iacute;os de nuevo, pero esta vez pidamos hasNextPage :</target>
        </trans-unit>
        <trans-unit id="c2d977e2354e1f199b20eba8fe4202828b60baf5" translate="yes" xml:space="preserve">
          <source>However components using the Relay Modern API (&lt;code&gt;'react-relay'&lt;/code&gt;) and the Relay Classic API (&lt;code&gt;'react-relay/classic'&lt;/code&gt;) cannot be used with each other.</source>
          <target state="translated">Sin embargo, los componentes que utilizan la API Relay Modern ( &lt;code&gt;'react-relay'&lt;/code&gt; ) y la API Relay Classic ( &lt;code&gt;'react-relay/classic'&lt;/code&gt; ) no se pueden usar entre s&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="8f6bd5564a2d8d3eed39f5285b27795de9e86379" translate="yes" xml:space="preserve">
          <source>However the Relay Compiler also automatically generates flow types, as &lt;a href=&quot;https://flow.org/en/docs/types/comments/&quot;&gt;type comments&lt;/a&gt;. To import the types:</source>
          <target state="translated">Sin embargo, el Relay Compiler tambi&amp;eacute;n genera autom&amp;aacute;ticamente tipos de flujo, como &lt;a href=&quot;https://flow.org/en/docs/types/comments/&quot;&gt;comentarios de tipo&lt;/a&gt; . Para importar los tipos:</target>
        </trans-unit>
        <trans-unit id="10b177310affbe7aa4dd35d3f040c504f1597c28" translate="yes" xml:space="preserve">
          <source>However, Relay Modern expects modern JavaScript global types (&lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Promise&lt;/code&gt;, &lt;code&gt;Object.assign&lt;/code&gt;) to be defined. If you support older browsers and devices which may not yet provide these natively, consider including a global polyfill in your bundled application, such as &lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt; or &lt;a href=&quot;https://babeljs.io/docs/usage/polyfill/&quot;&gt;babel-polyfill&lt;/a&gt;.</source>
          <target state="translated">Sin embargo, Relay Modern espera que se definan los tipos globales de JavaScript modernos ( &lt;code&gt;Map&lt;/code&gt; , &lt;code&gt;Set&lt;/code&gt; , &lt;code&gt;Promise&lt;/code&gt; , &lt;code&gt;Object.assign&lt;/code&gt; ). Si admite navegadores y dispositivos m&amp;aacute;s antiguos que es posible que a&amp;uacute;n no los proporcionen de forma nativa, considere incluir un polyfill global en su aplicaci&amp;oacute;n incluida, como &lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt; o &lt;a href=&quot;https://babeljs.io/docs/usage/polyfill/&quot;&gt;babel-polyfill&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="44a07f8e11c88d99ebfa0ba8926d9d2bf8daec90" translate="yes" xml:space="preserve">
          <source>However, the fragment could also fetch each of user &lt;code&gt;123&lt;/code&gt;'s friends' profile photos:</source>
          <target state="translated">Sin embargo, el fragmento tambi&amp;eacute;n podr&amp;iacute;a recuperar cada una de las fotos de perfil de los amigos del usuario &lt;code&gt;123&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bd69a4732fe12702d5ff5838852eb29e4a9e2e02" translate="yes" xml:space="preserve">
          <source>Idea</source>
          <target state="translated">Idea</target>
        </trans-unit>
        <trans-unit id="3bd280c6059870c93a4668954d90f25f6c6ff4e2" translate="yes" xml:space="preserve">
          <source>If a &quot;force fetch&quot; occurs and there is insufficient data on the client, the same behavior as &lt;strong&gt;Fetching Data from the Server&lt;/strong&gt; can be expected. However, if a &quot;force fetch&quot; occurs and there &lt;em&gt;is&lt;/em&gt; sufficient data on the client to render, we can expect the following behavior:</source>
          <target state="translated">Si se produce una &quot;b&amp;uacute;squeda forzada&quot; y no hay datos suficientes en el cliente, se puede esperar el mismo comportamiento que &lt;strong&gt;Obtenci&amp;oacute;n de datos del servidor&lt;/strong&gt; . Sin embargo, si una &quot;fuerza fetch&quot; se produce y no &lt;em&gt;es&lt;/em&gt; suficientes datos sobre el cliente para rendir, podemos esperar el siguiente comportamiento:</target>
        </trans-unit>
        <trans-unit id="7ed138709fbda62e44a180d5f323c654e6cc766a" translate="yes" xml:space="preserve">
          <source>If a fragment uses variables that are determined at runtime, &lt;a href=&quot;#note-determining-variable-values-at-runtime&quot;&gt;see below&lt;/a&gt;.</source>
          <target state="translated">Si un fragmento utiliza variables determinadas en tiempo de ejecuci&amp;oacute;n, &lt;a href=&quot;#note-determining-variable-values-at-runtime&quot;&gt;consulte a continuaci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c5dc5ba510b8cc7e8340243c616a8461f6de45a" translate="yes" xml:space="preserve">
          <source>If a server request results in a failure to load data, we can expect the following behavior:</source>
          <target state="translated">Si una solicitud de servidor resulta en una falla en la carga de datos,podemos esperar el siguiente comportamiento:</target>
        </trans-unit>
        <trans-unit id="500f13b73830f97ef3d0785c40a8e9be8e6865fb" translate="yes" xml:space="preserve">
          <source>If an error occurs that prevents &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; from fetching the data required for rendering &lt;code&gt;Component&lt;/code&gt;, nothing will be rendered by default. Error handling behavior can be configured by supplying a callback to the &lt;code&gt;renderFailure&lt;/code&gt; prop:</source>
          <target state="translated">Si ocurre un error que impide que &lt;strong&gt;Relay.RootContainer obtenga&lt;/strong&gt; los datos necesarios para renderizar &lt;code&gt;Component&lt;/code&gt; , no se renderizar&amp;aacute; nada por defecto. El comportamiento de manejo de errores se puede configurar proporcionando una devoluci&amp;oacute;n de llamada a la propiedad &lt;code&gt;renderFailure&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e4eb5b8214d4c82b80af57f3c1c0471dea0d3c7b" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;Component&lt;/code&gt; or &lt;code&gt;route&lt;/code&gt; ever changes, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; will immediately start attempting to fulfill the new data requirements.</source>
          <target state="translated">Si alguna vez cambia el &lt;code&gt;Component&lt;/code&gt; o la &lt;code&gt;route&lt;/code&gt; , &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; comenzar&amp;aacute; inmediatamente a intentar cumplir con los nuevos requisitos de datos.</target>
        </trans-unit>
        <trans-unit id="e7c4473f87af75e4695d24734fbf44e9808a4049" translate="yes" xml:space="preserve">
          <source>If insufficient data on the client leads Relay to send a server request for more data, we can expect the following behavior:</source>
          <target state="translated">Si la insuficiencia de datos sobre el cliente lleva a Relay a enviar una solicitud al servidor para obtener más datos,podemos esperar el siguiente comportamiento:</target>
        </trans-unit>
        <trans-unit id="e7125117da9f12ab4891151c4ede73bbfc431ad0" translate="yes" xml:space="preserve">
          <source>If no request is in flight pendingVariables is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Si no hay ninguna solicitud pendiente, la variable es &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e94ccf62b4c7fbeeff1884ed8210524c0aaf3f8f" translate="yes" xml:space="preserve">
          <source>If not supplied, a unique collision key is derived (meaning that the created mutation will be independent and not collide with any other).</source>
          <target state="translated">Si no se suministra,se deriva una clave de colisión única (lo que significa que la mutación creada será independiente y no colisionará con ninguna otra).</target>
        </trans-unit>
        <trans-unit id="9f1093c79885887f1a46e11c2dbc9de6bfd2239c" translate="yes" xml:space="preserve">
          <source>If sufficient data is available on the client such that Relay does not need to send a server request, we can expect the following behavior:</source>
          <target state="translated">Si se dispone de suficientes datos sobre el cliente de tal manera que el Relevo no necesite enviar una solicitud al servidor,podemos esperar el siguiente comportamiento:</target>
        </trans-unit>
        <trans-unit id="1753e3219d9e6a6f6bf62bc19a7f313caa79226f" translate="yes" xml:space="preserve">
          <source>If supplied and set to true, a request for data will always be made to the server regardless of whether data on the client is available already.</source>
          <target state="translated">Si se suministra y se establece como verdadero,siempre se hará una solicitud de datos al servidor,independientemente de si los datos del cliente ya están disponibles.</target>
        </trans-unit>
        <trans-unit id="b8cb57719ab0a4774595aab7b466840e3a324de3" translate="yes" xml:space="preserve">
          <source>If supplied and set to true, a request for data will always be made to the server regardless of whether data on the client is available to immediately fulfill the data requirements.</source>
          <target state="translated">Si se suministra y se establece como verdadero,siempre se hará una solicitud de datos al servidor,independientemente de si los datos del cliente están disponibles para cumplir inmediatamente con los requisitos de datos.</target>
        </trans-unit>
        <trans-unit id="9652265c2b29a20de6e20099f7748481a1d4b122" translate="yes" xml:space="preserve">
          <source>If the Relay part of an application is some widget or single view as part of a larger application, you don't need any routing. You can just render a &lt;code&gt;QueryRenderer&lt;/code&gt; somewhere on the page to fetch and render the data you need there. This option is simple and should be used when sufficient.</source>
          <target state="translated">Si la parte de retransmisi&amp;oacute;n de una aplicaci&amp;oacute;n es un widget o una vista &amp;uacute;nica como parte de una aplicaci&amp;oacute;n m&amp;aacute;s grande, no necesita ning&amp;uacute;n enrutamiento. Puede representar un &lt;code&gt;QueryRenderer&lt;/code&gt; en alg&amp;uacute;n lugar de la p&amp;aacute;gina para obtener y representar los datos que necesita all&amp;iacute;. Esta opci&amp;oacute;n es simple y debe usarse cuando sea suficiente.</target>
        </trans-unit>
        <trans-unit id="9c687f957f6123e9a6702a53723c6fbcdd75a426" translate="yes" xml:space="preserve">
          <source>If the callback returns &lt;code&gt;undefined&lt;/code&gt;, the previously rendered view (or nothing if there is no previous view) is rendered (e.g. when transitioning from one &lt;code&gt;queryConfig&lt;/code&gt; to another).</source>
          <target state="translated">Si la devoluci&amp;oacute;n de llamada devuelve &lt;code&gt;undefined&lt;/code&gt; , la vista renderizada anteriormente (o nada si no hay una vista previa) se renderiza (por ejemplo, al pasar de una &lt;code&gt;queryConfig&lt;/code&gt; a otra).</target>
        </trans-unit>
        <trans-unit id="fa97f983a844f15bf5a18032a6bd22f04fd47eea" translate="yes" xml:space="preserve">
          <source>If the component doesn't actually use &lt;code&gt;setVariables()&lt;/code&gt;, and just uses &lt;code&gt;initialVariables&lt;/code&gt; to share values between JS and GraphQL, there are two alternative approaches:</source>
          <target state="translated">Si el componente no usa realmente &lt;code&gt;setVariables()&lt;/code&gt; y solo usa &lt;code&gt;initialVariables&lt;/code&gt; para compartir valores entre JS y GraphQL, existen dos enfoques alternativos:</target>
        </trans-unit>
        <trans-unit id="6f707589cc2da01315091844b3b383efdccb634c" translate="yes" xml:space="preserve">
          <source>If the mutation defines an optimistic payload - a set of data to apply locally while waiting for the server response - Relay applies this change and updates any affected React components (note that optimistic updates do not overwrite known server data in the cache).</source>
          <target state="translated">Si la mutación define una carga útil optimista-un conjunto de datos para aplicar localmente mientras se espera la respuesta del servidor-el Relevo aplica este cambio y actualiza cualquier componente de React afectado (tenga en cuenta que las actualizaciones optimistas no sobrescriben los datos conocidos del servidor en la caché).</target>
        </trans-unit>
        <trans-unit id="9d815af768aaeea304d01b0f060f4bcc34f6f6e5" translate="yes" xml:space="preserve">
          <source>If the mutation would not 'collide' (overlap) with other pending mutations - as specified by its &lt;code&gt;getCollisionKey&lt;/code&gt; implementation - it is sent to the server. If it would conflict, it is enqueued until conflicting mutations have completed.</source>
          <target state="translated">Si la mutaci&amp;oacute;n no 'choca' (se superpone) con otras mutaciones pendientes, seg&amp;uacute;n lo especificado por su implementaci&amp;oacute;n &lt;code&gt;getCollisionKey&lt;/code&gt; , se env&amp;iacute;a al servidor. Si entra en conflicto, se pone en cola hasta que se hayan completado las mutaciones en conflicto.</target>
        </trans-unit>
        <trans-unit id="e86698a9dbbdbb49974d25aeca449ae1fbb9e654" translate="yes" xml:space="preserve">
          <source>If the render callback is not supplied, the default behavior is to render the container if data is available, the existing view if one exists, or nothing.</source>
          <target state="translated">Si no se suministra la devolución de llamada de renderizado,el comportamiento por defecto es renderizar el contenedor si hay datos disponibles,la vista existente si existe,o nada.</target>
        </trans-unit>
        <trans-unit id="1a73cc6d4c2d46fb79932c374ed9da299d065e97" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; suffix, the &lt;code&gt;data&lt;/code&gt; prop name will be used:</source>
          <target state="translated">Si no hay un sufijo &lt;code&gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; , se utilizar&amp;aacute; el nombre de la propiedad de &lt;code&gt;data&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="62768ad0f3d9c4db4330d79d61d8599e64fd7a9c" translate="yes" xml:space="preserve">
          <source>If we do the same thing with the Empire, we'll find that it returns a different ID, and we can refetch it as well:</source>
          <target state="translated">Si hacemos lo mismo con el Imperio,descubriremos que devuelve una identificación diferente,y podemos volver a buscarla también:</target>
        </trans-unit>
        <trans-unit id="62f00a1501647642fb670b9befaa1fb2d5b19d8f" translate="yes" xml:space="preserve">
          <source>If we provide to a mutation a method that conforms to the signature described above, it will be given the opportunity to modify the fragment builders' variables, based on the previous variables (or the &lt;code&gt;initialVariables&lt;/code&gt; if no previous ones exist), the meta route, and the runtime environment. Whatever variables this method returns will become available to this mutation's fragment builders.</source>
          <target state="translated">Si proporcionamos a una mutaci&amp;oacute;n un m&amp;eacute;todo que se ajuste a la firma descrita anteriormente, se le dar&amp;aacute; la oportunidad de modificar las variables de los constructores de fragmentos, en base a las variables anteriores (o las variables &lt;code&gt;initialVariables&lt;/code&gt; si no existen), la meta ruta, y el entorno de ejecuci&amp;oacute;n. Cualquier variable que devuelva este m&amp;eacute;todo estar&amp;aacute; disponible para los constructores de fragmentos de esta mutaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="29d042cd073944a1316b1c84fe494fc214ee7caa" translate="yes" xml:space="preserve">
          <source>If we replace &lt;code&gt;2&lt;/code&gt; with a new immutable record, we'll also get a new immutable instance of the cache object. However, records &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; are untouched. Because the data is normalized, we can't tell that &lt;code&gt;story&lt;/code&gt;'s contents have changed just by looking at the &lt;code&gt;story&lt;/code&gt; record alone.</source>
          <target state="translated">Si reemplazamos &lt;code&gt;2&lt;/code&gt; con un nuevo registro inmutable, tambi&amp;eacute;n obtendremos una nueva instancia inmutable del objeto de cach&amp;eacute;. Sin embargo, los registros &lt;code&gt;1&lt;/code&gt; y &lt;code&gt;3&lt;/code&gt; no se modifican. Debido a que los datos est&amp;aacute;n normalizados, no podemos decir que el contenido de la &lt;code&gt;story&lt;/code&gt; ha cambiado con solo mirar el registro de la &lt;code&gt;story&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3442e671845ad2d6f63d621dcbdd2a0032b009d1" translate="yes" xml:space="preserve">
          <source>If we wanted to create an instance of this route for arbitrary users, we can subclass the &lt;code&gt;Relay.Route&lt;/code&gt; abstract class. &lt;code&gt;Relay.Route&lt;/code&gt; makes it easy to define a set of queries and required parameters to be re-used multiple times:</source>
          <target state="translated">Si quisi&amp;eacute;ramos crear una instancia de esta ruta para usuarios arbitrarios, podemos crear una subclase de la clase abstracta &lt;code&gt;Relay.Route&lt;/code&gt; . &lt;code&gt;Relay.Route&lt;/code&gt; facilita la definici&amp;oacute;n de un conjunto de consultas y par&amp;aacute;metros necesarios para ser reutilizados varias veces:</target>
        </trans-unit>
        <trans-unit id="4b62113e72e08231a01f5d4a07e448ee27964d21" translate="yes" xml:space="preserve">
          <source>If you find you need to do something unique (like generate types that conform to an older version of flow, or to parse non-javascript source files), you can build your own version of the Compiler by swapping in your own &lt;code&gt;FileWriter&lt;/code&gt; and &lt;code&gt;ASTCache&lt;/code&gt;, or by adding on an additional &lt;code&gt;IRTransform&lt;/code&gt;. Note, the internal APIs of the &lt;code&gt;RelayCompiler&lt;/code&gt; are under constant iteration, so rolling your own version may lead to incompatibilities with future releases.</source>
          <target state="translated">Si encuentra que necesita hacer algo &amp;uacute;nico (como generar tipos que se ajusten a una versi&amp;oacute;n anterior de flujo o analizar archivos fuente que no sean de JavaScript), puede crear su propia versi&amp;oacute;n del compilador intercambiando su propio &lt;code&gt;FileWriter&lt;/code&gt; y &lt;code&gt;ASTCache&lt;/code&gt; , o agregando un &lt;code&gt;IRTransform&lt;/code&gt; adicional . Tenga en cuenta que las API internas de &lt;code&gt;RelayCompiler&lt;/code&gt; est&amp;aacute;n en constante iteraci&amp;oacute;n, por lo que lanzar su propia versi&amp;oacute;n puede generar incompatibilidades con versiones futuras.</target>
        </trans-unit>
        <trans-unit id="7224441b6f15886cd449f3742b23181788ee9b99" translate="yes" xml:space="preserve">
          <source>If you wish to provide your own &lt;code&gt;handlerProvider&lt;/code&gt;, you can do so:</source>
          <target state="translated">Si desea proporcionar su propio &lt;code&gt;handlerProvider&lt;/code&gt; , puede hacerlo:</target>
        </trans-unit>
        <trans-unit id="49a21b30f5b3a1b121343f35b747fe542d51dbf3" translate="yes" xml:space="preserve">
          <source>If you're using &lt;code&gt;createRefetchContainer&lt;/code&gt; then your &lt;code&gt;refetch&lt;/code&gt; method may also update these variables to render with new values.</source>
          <target state="translated">Si est&amp;aacute; utilizando &lt;code&gt;createRefetchContainer&lt;/code&gt; , su m&amp;eacute;todo de &lt;code&gt;refetch&lt;/code&gt; tambi&amp;eacute;n puede actualizar estas variables para representar con nuevos valores.</target>
        </trans-unit>
        <trans-unit id="0ccc0940cec44b44c366f2d98c395662eb2f306c" translate="yes" xml:space="preserve">
          <source>If you're using a different GraphQL server implementation, we recommend adapting the above example to load the schema from your GraphQL server (e.g. via an HTTP request) and then save the result as JSON.</source>
          <target state="translated">Si está utilizando una implementación diferente del servidor GraphQL,le recomendamos que adapte el ejemplo anterior para cargar el esquema desde su servidor GraphQL (por ejemplo,a través de una solicitud HTTP)y luego guardar el resultado como JSON.</target>
        </trans-unit>
        <trans-unit id="2e76567f0db1f25cdaed090474feff64180bb110" translate="yes" xml:space="preserve">
          <source>Imagine we have a simple application that fetches a list of stories, and some details about each one. Here's how that might look in resource-oriented REST:</source>
          <target state="translated">Imagina que tenemos una simple aplicación que obtiene una lista de historias,y algunos detalles sobre cada una de ellas.Así es como se vería en el REST orientado a los recursos:</target>
        </trans-unit>
        <trans-unit id="448e3d99f5bde0fa9efac34be83b204ae98c345a" translate="yes" xml:space="preserve">
          <source>Implement this method in cases where the mutator configuration needed to handle the optimistic response needs to be different than the one that handles the server response.</source>
          <target state="translated">Implementar este método en los casos en que la configuración del mutador necesaria para manejar la respuesta optimista debe ser diferente de la que maneja la respuesta del servidor.</target>
        </trans-unit>
        <trans-unit id="62181f13d4fff5bed161f01ef77d8db655301bec" translate="yes" xml:space="preserve">
          <source>Implement this method to craft an optimistic response having the same shape as the server response payload. This optimistic response will be used to preemptively update the client cache before the server returns, giving the impression that the mutation completed instantaneously.</source>
          <target state="translated">Implementar este método para crear una respuesta optimista que tenga la misma forma que la carga de respuesta del servidor.Esta respuesta optimista se utilizará para actualizar preventivamente el caché del cliente antes de que regrese el servidor,dando la impresión de que la mutación se completó instantáneamente.</target>
        </trans-unit>
        <trans-unit id="24bc32f306fba32d2cbf91f2cd1999f36a16435a" translate="yes" xml:space="preserve">
          <source>Implement this method to return a collision key. Relay will send any mutations having the same collision key to the server serially and in-order.</source>
          <target state="translated">Implementar este método para devolver una llave de colisión.El relé enviará cualquier mutación que tenga la misma clave de colisión al servidor en serie y en orden.</target>
        </trans-unit>
        <trans-unit id="1e3fee95e387e2e4175f4c37de616bb736c7491c" translate="yes" xml:space="preserve">
          <source>Implement this method to return a map of &lt;code&gt;File&lt;/code&gt; objects to upload as part of a mutation.</source>
          <target state="translated">Implemente este m&amp;eacute;todo para devolver un mapa de objetos &lt;code&gt;File&lt;/code&gt; para cargar como parte de una mutaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="48d0a56a8bcb298a554f5516aac54d6f77d81acd" translate="yes" xml:space="preserve">
          <source>Implement this method to return true when the supplied options are supported by this network layer. This is used to declare which features the network layer supports.</source>
          <target state="translated">Implementar este método para que vuelva a ser cierto cuando las opciones suministradas sean soportadas por esta capa de red.Esto se utiliza para declarar qué características soporta la capa de red.</target>
        </trans-unit>
        <trans-unit id="b153e451079dd8470ac1e1681b4c8e4668b52b86" translate="yes" xml:space="preserve">
          <source>Implement this method to send mutations to the server. When the server response is obtained, this method must either call &lt;code&gt;mutationRequest.resolve&lt;/code&gt; with the response data, or &lt;code&gt;mutationRequest.reject&lt;/code&gt; with an &lt;code&gt;Error&lt;/code&gt; object.</source>
          <target state="translated">Implemente este m&amp;eacute;todo para enviar mutaciones al servidor. Cuando se obtiene la respuesta del servidor, este m&amp;eacute;todo debe llamar a &lt;code&gt;mutationRequest.resolve&lt;/code&gt; con los datos de respuesta, o &lt;code&gt;mutationRequest.reject&lt;/code&gt; con un objeto &lt;code&gt;Error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d31efc29644775c604543b99db2b73a14120012" translate="yes" xml:space="preserve">
          <source>Implement this method to send queries to the server. For each query request, when the server response is received, this method must either call &lt;code&gt;resolve&lt;/code&gt; with the response data, or &lt;code&gt;reject&lt;/code&gt; with an &lt;code&gt;Error&lt;/code&gt; object.</source>
          <target state="translated">Implemente este m&amp;eacute;todo para enviar consultas al servidor. Para cada solicitud de consulta, cuando se recibe la respuesta del servidor, este m&amp;eacute;todo debe llamar a &lt;code&gt;resolve&lt;/code&gt; con los datos de respuesta o &lt;code&gt;reject&lt;/code&gt; con un objeto &lt;code&gt;Error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1774e52d0e556763970083c582a2823556fad1d9" translate="yes" xml:space="preserve">
          <source>Implement this required method to design a &amp;lsquo;fat query&amp;rsquo; &amp;ndash; one that represents every field in your data model that could change as a result of this mutation.</source>
          <target state="translated">Implemente este m&amp;eacute;todo necesario para dise&amp;ntilde;ar una 'consulta amplia', una que represente todos los campos de su modelo de datos que podr&amp;iacute;an cambiar como resultado de esta mutaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="55c82c1ede81ef7c75eb0f5ad805b7c8131bec8a" translate="yes" xml:space="preserve">
          <source>Implement this required method to give Relay instructions on how to use the response payload from each mutation to update the client-side store.</source>
          <target state="translated">Implementar este método necesario para dar instrucciones al Relevo sobre cómo utilizar la carga de respuesta de cada mutación para actualizar el almacén del lado del cliente.</target>
        </trans-unit>
        <trans-unit id="17378e1f66fb4d758998ffc792b8f969174e1a87" translate="yes" xml:space="preserve">
          <source>Implement this required method to prepare variables to be used as input to the mutation.</source>
          <target state="translated">Aplicar este método necesario para preparar las variables que se utilizarán como insumo de la mutación.</target>
        </trans-unit>
        <trans-unit id="e0d5783849893b65928056a3e01f878a4ebb371a" translate="yes" xml:space="preserve">
          <source>Implement this required method to return a GraphQL mutation operation that represents the mutation to be performed.</source>
          <target state="translated">Implementar este método necesario para devolver una operación de mutación GraphQL que represente la mutación a realizar.</target>
        </trans-unit>
        <trans-unit id="d8c789b0ff99a369ebb08eda75d64a2002a8918e" translate="yes" xml:space="preserve">
          <source>Importing generated definitions</source>
          <target state="translated">Importación de definiciones generadas</target>
        </trans-unit>
        <trans-unit id="a8c0b4ec0c84b678651530ba2d81f9beb98a2561" translate="yes" xml:space="preserve">
          <source>In GraphQL, &lt;strong&gt;queries&lt;/strong&gt; declare fields that exist on the root query type. For example, the following query might fetch the name of the user with an &lt;code&gt;id&lt;/code&gt; of &lt;code&gt;123&lt;/code&gt;:</source>
          <target state="translated">En GraphQL, las &lt;strong&gt;consultas&lt;/strong&gt; declaran campos que existen en el tipo de consulta ra&amp;iacute;z. Por ejemplo, la siguiente consulta podr&amp;iacute;a obtener el nombre del usuario con un &lt;code&gt;id&lt;/code&gt; de &lt;code&gt;123&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="42cc08262fb0bb543ca0770499256c848ef63cb2" translate="yes" xml:space="preserve">
          <source>In React Native, we can schedule Relay processing so as to avoid interrupting touch gestures as follows:</source>
          <target state="translated">En React Native,podemos programar el procesamiento de los Relevos para evitar interrumpir los gestos de tacto de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="a5187bfb626e29a7807af4b6499d8505f13e32b2" translate="yes" xml:space="preserve">
          <source>In React, rendering a view requires two inputs: the &lt;em&gt;component&lt;/em&gt; to render, and a &lt;em&gt;root&lt;/em&gt; DOM (UI) node to render into. Rendering Relay containers is similar: we need a &lt;em&gt;container&lt;/em&gt; to render, and a &lt;em&gt;root&lt;/em&gt; in the graph from which to start our query. We also must ensure that the queries for the container are executed and may want to show a loading indicator while data is being fetched. Similar to &lt;code&gt;ReactDOM.render(component, domNode)&lt;/code&gt;, Relay provides &lt;code&gt;&amp;lt;Relay.Renderer Container={...} queryConfig={...}&amp;gt;&lt;/code&gt; for this purpose. The container is the item to render, and the queryConfig provides queries that specify &lt;em&gt;which&lt;/em&gt; item to fetch. Here's how we might render &lt;code&gt;&amp;lt;StoryContainer&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">En React, renderizar una vista requiere dos entradas: el &lt;em&gt;componente&lt;/em&gt; para renderizar y un nodo &lt;em&gt;ra&amp;iacute;z&lt;/em&gt; DOM (UI) para renderizar. La representaci&amp;oacute;n de contenedores de Relay es similar: necesitamos un &lt;em&gt;contenedor&lt;/em&gt; para renderizar y una &lt;em&gt;ra&amp;iacute;z&lt;/em&gt; en el gr&amp;aacute;fico desde la cual comenzar nuestra consulta. Tambi&amp;eacute;n debemos asegurarnos de que las consultas para el contenedor se ejecuten y es posible que deseemos mostrar un indicador de carga mientras se obtienen los datos. Similar a &lt;code&gt;ReactDOM.render(component, domNode)&lt;/code&gt; , Relay proporciona &lt;code&gt;&amp;lt;Relay.Renderer Container={...} queryConfig={...}&amp;gt;&lt;/code&gt; para este prop&amp;oacute;sito. El contenedor es el elemento a representar y queryConfig proporciona consultas que especifican &lt;em&gt;qu&amp;eacute;&lt;/em&gt; elemento buscar. As&amp;iacute; es como podr&amp;iacute;amos renderizar &lt;code&gt;&amp;lt;StoryContainer&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4f9d43e8de662b43a98bf53a133be5a295724798" translate="yes" xml:space="preserve">
          <source>In Relay, data dependencies are described using &lt;a href=&quot;https://github.com/facebook/graphql&quot;&gt;GraphQL&lt;/a&gt;. For &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt;, the dependency can be expressed as follows. Note that this exactly matches the shape that the component expected for the &lt;code&gt;user&lt;/code&gt; prop.</source>
          <target state="translated">En Relay, las dependencias de datos se describen mediante &lt;a href=&quot;https://github.com/facebook/graphql&quot;&gt;GraphQL&lt;/a&gt; . Para &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; , la dependencia se puede expresar de la siguiente manera. Tenga en cuenta que esto coincide exactamente con la forma que esperaba el componente para el accesorio del &lt;code&gt;user&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1084307d05023abf80689279ae0f77b70f810919" translate="yes" xml:space="preserve">
          <source>In Relay, data dependencies are described using &lt;a href=&quot;https://github.com/facebook/graphql&quot;&gt;GraphQL&lt;/a&gt;. For &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt;, the dependency can be expressed as follows. Note that this exactly matches the shape that the component expected for the &lt;code&gt;item&lt;/code&gt; prop.</source>
          <target state="translated">En Relay, las dependencias de datos se describen mediante &lt;a href=&quot;https://github.com/facebook/graphql&quot;&gt;GraphQL&lt;/a&gt; . Para &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; , la dependencia se puede expresar de la siguiente manera. Tenga en cuenta que esto coincide exactamente con la forma que esperaba el componente para el accesorio del &lt;code&gt;item&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8218e7619ef161652f44088010026d35f36055e0" translate="yes" xml:space="preserve">
          <source>In Relay, the root of a query is defined by a &lt;strong&gt;QueryRenderer&lt;/strong&gt; so check out that section for more details.</source>
          <target state="translated">En Relay, la ra&amp;iacute;z de una consulta la define un &lt;strong&gt;QueryRenderer,&lt;/strong&gt; as&amp;iacute; que consulte esa secci&amp;oacute;n para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="30d65c55146011871e1262a4566a24588803dc0d" translate="yes" xml:space="preserve">
          <source>In Relay, the root of a query is defined by a &lt;strong&gt;Route&lt;/strong&gt;. Continue to learn about Relay routes.</source>
          <target state="translated">En Relay, la ra&amp;iacute;z de una consulta se define mediante una &lt;strong&gt;ruta&lt;/strong&gt; . Contin&amp;uacute;e aprendiendo sobre las rutas de retransmisi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c21389450ed39ca7f4877ce1712aa3326324e6a9" translate="yes" xml:space="preserve">
          <source>In a resource-oriented REST system, we can maintain a &lt;strong&gt;response cache&lt;/strong&gt; based on URIs:</source>
          <target state="translated">En un sistema REST orientado a recursos, podemos mantener una &lt;strong&gt;cach&amp;eacute; de respuesta&lt;/strong&gt; basada en URI:</target>
        </trans-unit>
        <trans-unit id="ddc4813b133487bd46b76268444d4db66fd4598c" translate="yes" xml:space="preserve">
          <source>In a simple mutation, you only need &lt;code&gt;mutation&lt;/code&gt; and &lt;code&gt;variables&lt;/code&gt;:</source>
          <target state="translated">En una mutaci&amp;oacute;n simple, solo necesita &lt;code&gt;mutation&lt;/code&gt; y &lt;code&gt;variables&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="753db9b3fed6b02e90a81f5ecfd3b20ecf1201c5" translate="yes" xml:space="preserve">
          <source>In a simple subscription, you only need &lt;code&gt;subscription&lt;/code&gt; and &lt;code&gt;variables&lt;/code&gt;. This is appropriate when you are only changing the properties of existing records that can be identified by their &lt;code&gt;id&lt;/code&gt;:</source>
          <target state="translated">En una suscripci&amp;oacute;n simple, solo necesita &lt;code&gt;subscription&lt;/code&gt; y &lt;code&gt;variables&lt;/code&gt; . Esto es apropiado cuando solo est&amp;aacute; cambiando las propiedades de registros existentes que se pueden identificar por su &lt;code&gt;id&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2d35beb84697160944c091bfc4ea7475ddba8bba" translate="yes" xml:space="preserve">
          <source>In addition to the bin script, the &lt;code&gt;relay-compiler&lt;/code&gt; package also &lt;a href=&quot;https://github.com/facebook/relay/blob/master/packages/relay-compiler/RelayCompilerPublic.js&quot;&gt;exports library code&lt;/a&gt; which you may use to create more complex configurations for the compiler, or to extend the compiler with your own custom output.</source>
          <target state="translated">Adem&amp;aacute;s del script bin, el paquete del &lt;code&gt;relay-compiler&lt;/code&gt; tambi&amp;eacute;n &lt;a href=&quot;https://github.com/facebook/relay/blob/master/packages/relay-compiler/RelayCompilerPublic.js&quot;&gt;exporta el c&amp;oacute;digo de la biblioteca&lt;/a&gt; que puede usar para crear configuraciones m&amp;aacute;s complejas para el compilador o para ampliar el compilador con su propia salida personalizada.</target>
        </trans-unit>
        <trans-unit id="1ee7cb663ba30043049419a3987f32bf98b8e3b6" translate="yes" xml:space="preserve">
          <source>In order to incrementally convert an existing codebase, we will need to use the Relay Modern API while continuing to use the Relay Classic runtime until all components are converted.</source>
          <target state="translated">Para convertir de forma incremental una base de código existente,necesitaremos usar la API de Relay Modern mientras seguimos usando el tiempo de ejecución de Relay Classic hasta que todos los componentes sean convertidos.</target>
        </trans-unit>
        <trans-unit id="b06055f46a51395cce09c8715fc83f412863f99f" translate="yes" xml:space="preserve">
          <source>In order to know how to access your GraphQL server, Relay Modern requires developers to provide an object implementing the &lt;code&gt;NetworkLayer&lt;/code&gt; interface when creating an instance of a &lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt;. The environment uses this network layer to execute queries, mutations, and (if your server supports them) subscriptions. This allows developers to use whatever transport (HTTP, WebSockets, etc) and authentication is most appropriate for their application, decoupling the environment from the particulars of each application's network configuration.</source>
          <target state="translated">Para saber c&amp;oacute;mo acceder a su servidor GraphQL, Relay Modern requiere que los desarrolladores proporcionen un objeto que implemente la interfaz &lt;code&gt;NetworkLayer&lt;/code&gt; al crear una instancia de un &lt;a href=&quot;relay-environment&quot;&gt;entorno de retransmisi&amp;oacute;n&lt;/a&gt; . El entorno utiliza esta capa de red para ejecutar consultas, mutaciones y (si su servidor las admite) suscripciones. Esto permite a los desarrolladores utilizar cualquier transporte (HTTP, WebSockets, etc.) y la autenticaci&amp;oacute;n m&amp;aacute;s apropiada para su aplicaci&amp;oacute;n, desacoplando el entorno de los detalles de la configuraci&amp;oacute;n de red de cada aplicaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="3a7aba64216b1cd4d2d2e3ad530a1f3188fad50d" translate="yes" xml:space="preserve">
          <source>In order to resolve a fragment into an array of objects you have to use the &lt;code&gt;@relay(plural: true)&lt;/code&gt; directive.</source>
          <target state="translated">Para resolver un fragmento en una matriz de objetos, debe usar la &lt;code&gt;@relay(plural: true)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6f38813eb9d2dd5b73b9500e984665cfcbc9419" translate="yes" xml:space="preserve">
          <source>In our experience, the overwhelming majority of products want one specific behavior: fetch &lt;em&gt;all&lt;/em&gt; the data for a view hierarchy while displaying a loading indicator, and then render the &lt;em&gt;entire&lt;/em&gt; view once the data is ready.</source>
          <target state="translated">En nuestra experiencia, la inmensa mayor&amp;iacute;a de los productos quieren un comportamiento espec&amp;iacute;fico: recuperar &lt;em&gt;todos&lt;/em&gt; los datos para una jerarqu&amp;iacute;a de vistas mientras se muestra un indicador de carga y luego renderizar la vista &lt;em&gt;completa&lt;/em&gt; una vez que los datos est&amp;aacute;n listos.</target>
        </trans-unit>
        <trans-unit id="6a8da0b71c4c64aea6ae6834a91b9401918c3e7e" translate="yes" xml:space="preserve">
          <source>In that last example, think of &lt;code&gt;$format&lt;/code&gt; and &lt;code&gt;variables.format&lt;/code&gt; as the same value.</source>
          <target state="translated">En ese &amp;uacute;ltimo ejemplo, piense en &lt;code&gt;$format&lt;/code&gt; y &lt;code&gt;variables.format&lt;/code&gt; como el mismo valor.</target>
        </trans-unit>
        <trans-unit id="3888fb491d2876bafea276807002a772ce2740fc" translate="yes" xml:space="preserve">
          <source>In the diagram above:</source>
          <target state="translated">En el diagrama de arriba:</target>
        </trans-unit>
        <trans-unit id="fafabc5dfb7d6fbb341fd52614abab0575f4bf79" translate="yes" xml:space="preserve">
          <source>In the example below, the &lt;code&gt;user&lt;/code&gt; prop will include the data for &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt; fields wherever &lt;code&gt;...Component_internUser&lt;/code&gt; is included, instead of Relay's normal behavior to mask those fields.</source>
          <target state="translated">En el siguiente ejemplo, la propiedad del &lt;code&gt;user&lt;/code&gt; incluir&amp;aacute; los datos para los campos de &lt;code&gt;id&lt;/code&gt; entificaci&amp;oacute;n y &lt;code&gt;name&lt;/code&gt; siempre que se incluya &lt;code&gt;...Component_internUser&lt;/code&gt; , en lugar del comportamiento normal de Relay para enmascarar esos campos.</target>
        </trans-unit>
        <trans-unit id="b3b357ad1aa217f6b814380c122b67ca81691203" translate="yes" xml:space="preserve">
          <source>In the future, advanced capabilities in Relay may be dependent on the network layer being able to support certain features.</source>
          <target state="translated">En el futuro,las capacidades avanzadas de Relay pueden depender de que la capa de red sea capaz de soportar ciertas características.</target>
        </trans-unit>
        <trans-unit id="db9e71215ab64e7c01402f6a78301e1bc8b38923" translate="yes" xml:space="preserve">
          <source>In this article we'll explore what it means to build a GraphQL client framework and how this compares to clients for more traditional REST systems. Along the way we'll look at the design decisions behind Relay and see that it's not just a GraphQL client but also a framework for &lt;em&gt;declarative data-fetching&lt;/em&gt;. Let's start at the beginning and fetch some data!</source>
          <target state="translated">En este art&amp;iacute;culo exploraremos lo que significa construir un marco de cliente GraphQL y c&amp;oacute;mo se compara con los clientes de sistemas REST m&amp;aacute;s tradicionales. En el camino, veremos las decisiones de dise&amp;ntilde;o detr&amp;aacute;s de Relay y veremos que no es solo un cliente GraphQL sino tambi&amp;eacute;n un marco para la obtenci&amp;oacute;n de &lt;em&gt;datos declarativos&lt;/em&gt; . &amp;iexcl;Empecemos por el principio y busquemos algunos datos!</target>
        </trans-unit>
        <trans-unit id="88a02e183add9d1c24413aa47baf530897708969" translate="yes" xml:space="preserve">
          <source>In this example the Route should be initialized with a &lt;code&gt;userID&lt;/code&gt; which gets passed on to the query. That &lt;code&gt;userID&lt;/code&gt; variable will automatically be passed down to the top-level container and can be used there if needed. Further the top-level RelayContainer is expected to have a &lt;code&gt;user&lt;/code&gt; fragment with the fields to be queried.</source>
          <target state="translated">En este ejemplo, la ruta debe inicializarse con un &lt;code&gt;userID&lt;/code&gt; que se pasa a la consulta. Esa variable de &lt;code&gt;userID&lt;/code&gt; pasar&amp;aacute; autom&amp;aacute;ticamente al contenedor de nivel superior y se puede usar all&amp;iacute; si es necesario. Adem&amp;aacute;s, se espera que el RelayContainer de nivel superior tenga un fragmento de &lt;code&gt;user&lt;/code&gt; con los campos a consultar.</target>
        </trans-unit>
        <trans-unit id="8e65c0999502b8d880342481e43745e86b87bd15" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;profilePicture(size: 50)&lt;/code&gt; will be fetched for the intial render.</source>
          <target state="translated">En este ejemplo, &lt;code&gt;profilePicture(size: 50)&lt;/code&gt; buscar&amp;aacute; para el render inicial.</target>
        </trans-unit>
        <trans-unit id="b029685528e8da2f8ce2cf427c32ff8fbbf0ee00" translate="yes" xml:space="preserve">
          <source>In this example, create an inspector object based on the same source as passed into your &lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt;. Later you can use this inspector object to inspect records. Inspector is only available in the development build.</source>
          <target state="translated">En este ejemplo, cree un objeto inspector basado en la misma fuente que se pas&amp;oacute; a su &lt;a href=&quot;relay-environment&quot;&gt;entorno de retransmisi&amp;oacute;n&lt;/a&gt; . Posteriormente, puede utilizar este objeto inspector para inspeccionar registros. Inspector solo est&amp;aacute; disponible en la versi&amp;oacute;n de desarrollo.</target>
        </trans-unit>
        <trans-unit id="4e1907e8aedfd3075f12c9bb08511b6424b05151" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;width&lt;/code&gt; of the rendered image will always correspond to the &lt;code&gt;$size&lt;/code&gt; variable used to fetch the current version of &lt;code&gt;profilePicture.uri&lt;/code&gt;.</source>
          <target state="translated">En este ejemplo, el &lt;code&gt;width&lt;/code&gt; de la imagen renderizada siempre corresponder&amp;aacute; a la variable &lt;code&gt;$size&lt;/code&gt; utilizada para obtener la versi&amp;oacute;n actual de &lt;code&gt;profilePicture.uri&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86e6e74d266fdaa434ba59fe220a17114ef82453" translate="yes" xml:space="preserve">
          <source>In this example, the fields associated with the &lt;code&gt;ship&lt;/code&gt; fragment will be made available on &lt;code&gt;this.props.ship&lt;/code&gt;.</source>
          <target state="translated">En este ejemplo, los campos asociados con el fragmento de &lt;code&gt;ship&lt;/code&gt; estar&amp;aacute;n disponibles en &lt;code&gt;this.props.ship&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="85172d5db32fabb64291c47b382ebcc9097ed293" translate="yes" xml:space="preserve">
          <source>In this example, whenever &lt;code&gt;Parent&lt;/code&gt; is fetched, &lt;code&gt;Child&lt;/code&gt;'s fragment will also be fetched. When rendering, &lt;code&gt;&amp;lt;Parent&amp;gt;&lt;/code&gt; will only have access to the &lt;code&gt;props.foo.id&lt;/code&gt; field; data from the child fragment will be &lt;a href=&quot;http://facebook.github.io/relay/docs/thinking-in-relay.html#data-masking&quot;&gt;&lt;em&gt;masked&lt;/em&gt;&lt;/a&gt;. By default, &lt;code&gt;childFragment&lt;/code&gt; will use its corresponding initial variables. Relay will fetch &lt;code&gt;photo(size: 64)&lt;/code&gt;. When &lt;code&gt;&amp;lt;Child&amp;gt;&lt;/code&gt; is rendered it will also make the initial variables available as &lt;code&gt;props.relay.variables = {size: 64}&lt;/code&gt;.</source>
          <target state="translated">En este ejemplo, siempre que se recupere el &lt;code&gt;Parent&lt;/code&gt; , tambi&amp;eacute;n se obtendr&amp;aacute; el fragmento del &lt;code&gt;Child&lt;/code&gt; . Al renderizar, &lt;code&gt;&amp;lt;Parent&amp;gt;&lt;/code&gt; solo tendr&amp;aacute; acceso al campo &lt;code&gt;props.foo.id&lt;/code&gt; ; se &lt;a href=&quot;http://facebook.github.io/relay/docs/thinking-in-relay.html#data-masking&quot;&gt;&lt;em&gt;enmascarar&amp;aacute;n los&lt;/em&gt;&lt;/a&gt; datos del fragmento secundario . De forma predeterminada, &lt;code&gt;childFragment&lt;/code&gt; utilizar&amp;aacute; sus correspondientes variables iniciales. El rel&amp;eacute; buscar&amp;aacute; una &lt;code&gt;photo(size: 64)&lt;/code&gt; . Cuando se renderiza &lt;code&gt;&amp;lt;Child&amp;gt;&lt;/code&gt; , tambi&amp;eacute;n har&amp;aacute; que las variables iniciales est&amp;eacute;n disponibles como &lt;code&gt;props.relay.variables = {size: 64}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79f26e8bd2ce0d98aed5c314fad80d4d64f729d8" translate="yes" xml:space="preserve">
          <source>In this example, whenever a picture with a new size is being loaded a spinner is displayed instead of the picture.</source>
          <target state="translated">En este ejemplo,cada vez que se carga una imagen con un nuevo tamaño,se muestra un girador en lugar de la imagen.</target>
        </trans-unit>
        <trans-unit id="11c9642bf0d68f60f8223631d67d9ed8e587f204" translate="yes" xml:space="preserve">
          <source>In this particular example, the only field that the &lt;code&gt;LikeButton&lt;/code&gt; cares about is &lt;code&gt;viewerDoesLike&lt;/code&gt;. That field will form part of the tracked query that Relay will intersect with the fat query of &lt;code&gt;LikeStoryMutation&lt;/code&gt; to determine what fields to request as part of the server's response payload for the mutation. Another component elsewhere in the application might be interested in the likers count, or the like sentence. Since those fields will automatically be added to Relay's tracked query, the &lt;code&gt;LikeButton&lt;/code&gt; need not worry about requesting them explicitly.</source>
          <target state="translated">En este ejemplo particular, el &amp;uacute;nico campo que el &lt;code&gt;LikeButton&lt;/code&gt; le importa es &lt;code&gt;viewerDoesLike&lt;/code&gt; . Ese campo formar&amp;aacute; parte de la consulta rastreada que Relay cruzar&amp;aacute; con la consulta &lt;code&gt;LikeStoryMutation&lt;/code&gt; de LikeStoryMutation para determinar qu&amp;eacute; campos solicitar como parte de la carga &amp;uacute;til de respuesta del servidor para la mutaci&amp;oacute;n. Otro componente en otra parte de la aplicaci&amp;oacute;n podr&amp;iacute;a estar interesado en el recuento de me gusta o en una oraci&amp;oacute;n similar. Dado que esos campos se agregar&amp;aacute;n autom&amp;aacute;ticamente a la consulta de seguimiento de Relay, &lt;code&gt;LikeButton&lt;/code&gt; no necesita preocuparse por solicitarlos expl&amp;iacute;citamente.</target>
        </trans-unit>
        <trans-unit id="877c9e959c13a50bd6cd2c0684ab7d5def3e1397" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will build a game using GraphQL mutations. The goal of the game is to find a hidden treasure in a grid of 9 squares. We will give players three tries to find the treasure. This should give us an end-to-end look at Relay &amp;ndash; from the GraphQL schema on the server, to the React application on the client.</source>
          <target state="translated">En este tutorial, crearemos un juego usando mutaciones GraphQL. El objetivo del juego es encontrar un tesoro escondido en una cuadr&amp;iacute;cula de 9 cuadrados. Daremos a los jugadores tres intentos para encontrar el tesoro. Esto deber&amp;iacute;a darnos una visi&amp;oacute;n de principio a fin de Relay, desde el esquema GraphQL en el servidor hasta la aplicaci&amp;oacute;n React en el cliente.</target>
        </trans-unit>
        <trans-unit id="c1f61deb9bd75956e5146dd965f4efa1acf76ef5" translate="yes" xml:space="preserve">
          <source>Incrementally modernize your Relay Classic app in these steps:</source>
          <target state="translated">Moderniza tu aplicación Relay Classic en estos pasos:</target>
        </trans-unit>
        <trans-unit id="0e8c879968a7b304e9792c15d95365ae89d2aa45" translate="yes" xml:space="preserve">
          <source>Injectable Custom Field Handlers</source>
          <target state="translated">Manipuladores de campo personalizados inyectables</target>
        </trans-unit>
        <trans-unit id="e69c600fe29f0ed75880fd3b696888c254caf34f" translate="yes" xml:space="preserve">
          <source>Inline Fragments</source>
          <target state="translated">Fragmentos en línea</target>
        </trans-unit>
        <trans-unit id="1889c37693175c0225de5e6837f2ed3f9f529fe3" translate="yes" xml:space="preserve">
          <source>Inline the value in the GraphQL query, potentially annotating with a GraphQL comment (i.e. &lt;code&gt;# PAGE_SIZE&lt;/code&gt;).</source>
          <target state="translated">Inserte el valor en la consulta GraphQL, anot&amp;aacute;ndolo potencialmente con un comentario GraphQL (es decir, &lt;code&gt;# PAGE_SIZE&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0de09ec0beb82594d04ee09d8aeb812d06a3d58b" translate="yes" xml:space="preserve">
          <source>Install the latest version of Relay from the &lt;a href=&quot;relay-modern&quot;&gt;getting started guide&lt;/a&gt;.</source>
          <target state="translated">Instale la &amp;uacute;ltima versi&amp;oacute;n de Relay de la &lt;a href=&quot;relay-modern&quot;&gt;gu&amp;iacute;a de introducci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6603c8ba1e08fe9cd6b6dad35da64e9d939e1d23" translate="yes" xml:space="preserve">
          <source>Integration options are available for open-source routing libraries that can instead fetch data for nested routes in parallel. In many of these cases, using a batching network layer can bring additional benefits in avoiding sending multiple HTTP requests.</source>
          <target state="translated">Existen opciones de integración para las bibliotecas de rutas de código abierto que pueden,en cambio,obtener datos de rutas anidadas en paralelo.En muchos de estos casos,el uso de una capa de red por lotes puede aportar beneficios adicionales al evitar el envío de múltiples solicitudes HTTP.</target>
        </trans-unit>
        <trans-unit id="ba3a36612e2c9eeb3ee746032e0c52004c3b84f8" translate="yes" xml:space="preserve">
          <source>Integration with Relay Classic for React Router v2 or v3 is available via &lt;a href=&quot;https://github.com/relay-tools/react-router-relay&quot;&gt;&lt;code&gt;react-router-relay&lt;/code&gt;&lt;/a&gt;, which will aggregate the queries for matched routes, and request data for all routes in parallel.</source>
          <target state="translated">La integraci&amp;oacute;n con Relay Classic para React Router v2 o v3 est&amp;aacute; disponible a trav&amp;eacute;s de &lt;a href=&quot;https://github.com/relay-tools/react-router-relay&quot;&gt; &lt;code&gt;react-router-relay&lt;/code&gt; &lt;/a&gt; , que agregar&amp;aacute; las consultas para rutas coincidentes y solicitar&amp;aacute; datos para todas las rutas en paralelo.</target>
        </trans-unit>
        <trans-unit id="ca6f57623e58b4619d24d2a4a11fc39e22aace3a" translate="yes" xml:space="preserve">
          <source>Introduction to Relay Modern</source>
          <target state="translated">Introducción al Relevo Moderno</target>
        </trans-unit>
        <trans-unit id="cdaf67797686a7d4a210975b6064cb3ac3259374" translate="yes" xml:space="preserve">
          <source>It is also assumed that the reader is already familiar with &lt;a href=&quot;https://en.wikipedia.org/wiki/Star_Wars&quot;&gt;Star Wars&lt;/a&gt;; if not, the 1977 version of Star Wars is a good place to start, though the 1997 Special Edition will serve for the purposes of this document.</source>
          <target state="translated">Tambi&amp;eacute;n se supone que el lector ya est&amp;aacute; familiarizado con &lt;a href=&quot;https://en.wikipedia.org/wiki/Star_Wars&quot;&gt;Star Wars&lt;/a&gt; ; de lo contrario, la versi&amp;oacute;n de 1977 de Star Wars es un buen lugar para comenzar, aunque la Edici&amp;oacute;n Especial de 1997 servir&amp;aacute; para los prop&amp;oacute;sitos de este documento.</target>
        </trans-unit>
        <trans-unit id="df2797c242fbac686a5646e3f8d0990c4c69631c" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is already familiar with GraphQL; if not, the README for &lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;GraphQL.js&lt;/a&gt; is a good place to start.</source>
          <target state="translated">Se supone que el lector ya est&amp;aacute; familiarizado con GraphQL; si no, el &lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;archivo&lt;/a&gt; README para GraphQL.js es un buen lugar para comenzar.</target>
        </trans-unit>
        <trans-unit id="efecd775937b634754af4f65cbef5c8b4a7d96ba" translate="yes" xml:space="preserve">
          <source>It returns a &lt;code&gt;Disposable&lt;/code&gt; on which you could call &lt;code&gt;dispose()&lt;/code&gt; to cancel the refetch.</source>
          <target state="translated">Devuelve un &lt;code&gt;Disposable&lt;/code&gt; en el que puede llamar a &lt;code&gt;dispose()&lt;/code&gt; para cancelar la recuperaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="196589ac6e2b21bbd604e37c3b6f49f22ed50655" translate="yes" xml:space="preserve">
          <source>JavaScript environment requirements</source>
          <target state="translated">Requisitos del entorno de JavaScript</target>
        </trans-unit>
        <trans-unit id="0b490a2df160ed0c71b8320c42d90d77b3406679" translate="yes" xml:space="preserve">
          <source>JavaScript helpers for defining connections between data, and mutations, in a way that smoothly integrates with Relay.</source>
          <target state="translated">Ayudantes de JavaScript para definir las conexiones entre los datos y las mutaciones,de forma que se integren sin problemas con el Relevo.</target>
        </trans-unit>
        <trans-unit id="3763226e2b043a56c9ba7559341b0774c3ea862d" translate="yes" xml:space="preserve">
          <source>Keep in mind that it is typically considered an &lt;strong&gt;anti-pattern&lt;/strong&gt; to create a single fragment shared across many containers. Abusing this directive could result in over-fetching in your application.</source>
          <target state="translated">Tenga en cuenta que, por lo general, se considera un &lt;strong&gt;antipatr&amp;oacute;n&lt;/strong&gt; crear un solo fragmento compartido en muchos contenedores. Abusar de esta directiva podr&amp;iacute;a resultar en una b&amp;uacute;squeda excesiva en su aplicaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="25fe5a3c2698d53807ead685c86822cf47cc3073" translate="yes" xml:space="preserve">
          <source>Learn how to use &lt;code&gt;onReadyStateChange&lt;/code&gt; in our next guide, &lt;a href=&quot;guides-ready-state&quot;&gt;Ready State&lt;/a&gt;.</source>
          <target state="translated">Aprenda a usar &lt;code&gt;onReadyStateChange&lt;/code&gt; en nuestra pr&amp;oacute;xima gu&amp;iacute;a, &lt;a href=&quot;guides-ready-state&quot;&gt;Ready State&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4a4f4fc8ca8973cbce4f7744b6aee5bccdaab0f6" translate="yes" xml:space="preserve">
          <source>Let's associate the mutation we just created with the root mutation type:</source>
          <target state="translated">Asociemos la mutación que acabamos de crear con el tipo de mutación de la raíz:</target>
        </trans-unit>
        <trans-unit id="f8acb98279c7a33b14354f6c3ef2bfe03f2deca1" translate="yes" xml:space="preserve">
          <source>Let's craft an optimistic response for the &lt;code&gt;LikeStoryMutation&lt;/code&gt; example above:</source>
          <target state="translated">&lt;code&gt;LikeStoryMutation&lt;/code&gt; una respuesta optimista para el ejemplo de LikeStoryMutation anterior:</target>
        </trans-unit>
        <trans-unit id="ba32433c3c054db31c3adabcaef06296860fad94" translate="yes" xml:space="preserve">
          <source>Let's explore how this works via a &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; component that composes the &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; from above.</source>
          <target state="translated">Exploremos c&amp;oacute;mo funciona esto a trav&amp;eacute;s de un componente &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; que compone &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; desde arriba.</target>
        </trans-unit>
        <trans-unit id="89835a8e4dc90be9c02f2fb3d5af523e7de7cee2" translate="yes" xml:space="preserve">
          <source>Let's explore how this works via a &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; component that composes the &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; from above.</source>
          <target state="translated">&lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; c&amp;oacute;mo funciona esto a trav&amp;eacute;s de un componente &amp;lt;TodoList&amp;gt; que compone el &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; desde arriba.</target>
        </trans-unit>
        <trans-unit id="8eb1ff4062deba895e97692f949a6733e97ad5f6" translate="yes" xml:space="preserve">
          <source>Let's look at some product use-cases to understand how we incorporated these ideas into Relay. We'll assume a basic familiarity with React.</source>
          <target state="translated">Veamos algunos casos de uso de productos para entender cómo incorporamos estas ideas en el Relevo.Asumiremos una familiaridad básica con React.</target>
        </trans-unit>
        <trans-unit id="839d4a2135069fbb40df14cc776556712d98fa6a" translate="yes" xml:space="preserve">
          <source>Let's open up the starter kit's schema, and replace the database imports with the ones we just created:</source>
          <target state="translated">Abramos el esquema del kit de inicio,y reemplacemos las importaciones de la base de datos con las que acabamos de crear:</target>
        </trans-unit>
        <trans-unit id="a72ca83abcd8602717039b5f64a5b5a2b89c81e1" translate="yes" xml:space="preserve">
          <source>Let's see this in action, and query for the ID of the rebels:</source>
          <target state="translated">Veamos esto en acción,y busquemos la identificación de los rebeldes:</target>
        </trans-unit>
        <trans-unit id="c673a2bcf682f78fa812bcbefa0360994ed37548" translate="yes" xml:space="preserve">
          <source>Let's start a project using the &lt;a href=&quot;https://github.com/relayjs/relay-starter-kit&quot;&gt;Relay Starter Kit&lt;/a&gt; as a base.</source>
          <target state="translated">Comencemos un proyecto usando el &lt;a href=&quot;https://github.com/relayjs/relay-starter-kit&quot;&gt;kit&lt;/a&gt; de inicio de rel&amp;eacute; como base.</target>
        </trans-unit>
        <trans-unit id="a71dc4b410048806e0d1bbd75c4e909652f2f534" translate="yes" xml:space="preserve">
          <source>Let's take the rebels, and ask for their first ship:</source>
          <target state="translated">Tomemos a los rebeldes y pidamos su primera nave:</target>
        </trans-unit>
        <trans-unit id="510f4b78cd5f8fbd49c14a5834839d1ab18bb893" translate="yes" xml:space="preserve">
          <source>Let's tweak the file &lt;code&gt;./js/routes/AppHomeRoute.js&lt;/code&gt; to anchor our game to the &lt;code&gt;game&lt;/code&gt; root field of the schema:</source>
          <target state="translated">Vamos a modificar el archivo &lt;code&gt;./js/routes/AppHomeRoute.js&lt;/code&gt; para anclar nuestro juego para el &lt;code&gt;game&lt;/code&gt; campo de la ra&amp;iacute;z del esquema:</target>
        </trans-unit>
        <trans-unit id="cc5b2a062f05dd148b4ef24c76639416ebcc59f3" translate="yes" xml:space="preserve">
          <source>Licensed under the BSD License.</source>
          <target state="translated">Licenciado bajo la Licencia BSD.</target>
        </trans-unit>
        <trans-unit id="8882f419c30a0460f51c5ec6edaf87949c2d7459" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;updater&lt;/code&gt;, there is no need to provide &lt;code&gt;optimisticUpdater&lt;/code&gt; for simple mutations (field change).</source>
          <target state="translated">Al igual que el &lt;code&gt;updater&lt;/code&gt; , no es necesario proporcionar &lt;code&gt;optimisticUpdater&lt;/code&gt; para mutaciones simples (cambio de campo).</target>
        </trans-unit>
        <trans-unit id="35b9502f3f76f952801534521de9830a54b15a16" translate="yes" xml:space="preserve">
          <source>Like it can be done with &lt;a href=&quot;guides-containers&quot;&gt;Relay containers&lt;/a&gt;, we can prepare variables for use by our mutation's fragment builders, based on the previous variables and the runtime environment.</source>
          <target state="translated">Al igual que se puede hacer con los &lt;a href=&quot;guides-containers&quot;&gt;contenedores Relay&lt;/a&gt; , podemos preparar variables para que las usen los constructores de fragmentos de nuestra mutaci&amp;oacute;n, en funci&amp;oacute;n de las variables anteriores y el entorno de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="3715b94c23f4ec20e0da2f29449a3c4646b3d581" translate="yes" xml:space="preserve">
          <source>Like most of the Relay APIs, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; attempts to resolve data using the client store before sending a request to the server. If we instead wanted to force a server request even if data is available on the client, we could use the &lt;code&gt;forceFetch&lt;/code&gt; boolean prop.</source>
          <target state="translated">Como la mayor&amp;iacute;a de las API de retransmisi&amp;oacute;n, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; intenta resolver los datos utilizando el almac&amp;eacute;n del cliente antes de enviar una solicitud al servidor. Si, en cambio, quisi&amp;eacute;ramos forzar una solicitud del servidor incluso si los datos est&amp;aacute;n disponibles en el cliente, podr&amp;iacute;amos usar la &lt;code&gt;forceFetch&lt;/code&gt; booleana forceFetch .</target>
        </trans-unit>
        <trans-unit id="f856144ecb9d05326c6d97badc1a9b834b075ac1" translate="yes" xml:space="preserve">
          <source>Like the GraphQL URI, the timeout and retry behavior can be configured:</source>
          <target state="translated">Al igual que la URI de GraphQL,el comportamiento de tiempo de espera y reintento puede ser configurado:</target>
        </trans-unit>
        <trans-unit id="48a466fb1a66e2ac77ce3c14782794ae94365211" translate="yes" xml:space="preserve">
          <source>Managing asynchronous state transitions and coordinating concurrent requests.</source>
          <target state="translated">Gestionando las transiciones de estado asíncrono y coordinando las solicitudes simultáneas.</target>
        </trans-unit>
        <trans-unit id="52b2066f0ecc6504fa0d1683e70c5884d55a8b13" translate="yes" xml:space="preserve">
          <source>Managing errors.</source>
          <target state="translated">Gestionando los errores.</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="9973640b391cb4b42f93e3afba3395c46f6a7823" translate="yes" xml:space="preserve">
          <source>Migrating a Relay Classic app to Relay Modern doesn't require rewriting from scratch. Instead, convert one component at a time to the Relay Modern API while continuing to have a working app. Once all components have been converted, the smaller and faster Relay Modern runtime can be used.</source>
          <target state="translated">Migrar una aplicación de Relay Classic a Relay Modern no requiere reescribirla desde cero.En su lugar,convierte un componente a la vez a la API de Relay Modern mientras sigue teniendo una aplicación en funcionamiento.Una vez que se hayan convertido todos los componentes,se puede utilizar el tiempo de ejecución de Relay Modern,que es más pequeño y más rápido.</target>
        </trans-unit>
        <trans-unit id="a496d014360b49f4df7da034a0313b6a98aa03a1" translate="yes" xml:space="preserve">
          <source>Migrating a Relay Classic app to Relay Modern doesn't require rewriting from scratch. Instead, you can convert one component at a time to the Relay Modern API while continuing to have a working app. Once all components have been converted, the smaller and faster Relay Modern runtime can be used.</source>
          <target state="translated">Migrar una aplicación de Relay Classic a Relay Modern no requiere reescribirla desde cero.En su lugar,puedes convertir un componente a la vez a la API de Relay Modern mientras sigues teniendo una aplicación en funcionamiento.Una vez que se hayan convertido todos los componentes,se puede utilizar el tiempo de ejecución de Relay Modern,que es más pequeño y más rápido.</target>
        </trans-unit>
        <trans-unit id="89ca9763c43ac3c5a6b549a8936812ce36f490d5" translate="yes" xml:space="preserve">
          <source>Migrating to Relay Modern</source>
          <target state="translated">Migrando al Relevo Moderno</target>
        </trans-unit>
        <trans-unit id="a2d0fdbac2d058cc7df5b6a959221d8c7b0c5956" translate="yes" xml:space="preserve">
          <source>Modern &lt;code&gt;createRefetchContainer&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;createRefetchContainer&lt;/code&gt; moderno</target>
        </trans-unit>
        <trans-unit id="04ddebd72b3485cb649586cd882bbc4a0abdd841" translate="yes" xml:space="preserve">
          <source>Modern &lt;code&gt;this.props.relay.loadMore(pageSize...)&lt;/code&gt; in a Pagination Container</source>
          <target state="translated">Modern &lt;code&gt;this.props.relay.loadMore(pageSize...)&lt;/code&gt; en un contenedor de paginaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="eb7d95f729e7a3975428e61ddb5eb7d7241b4fd9" translate="yes" xml:space="preserve">
          <source>Modern Component</source>
          <target state="translated">Componente moderno</target>
        </trans-unit>
        <trans-unit id="43dee33213cedaefc62f54e39a529109b27d00fd" translate="yes" xml:space="preserve">
          <source>Modern Mutation</source>
          <target state="translated">Mutación moderna</target>
        </trans-unit>
        <trans-unit id="f4c44d48df48d618739f0b3ad40791ec870c9181" translate="yes" xml:space="preserve">
          <source>Modern Runtime</source>
          <target state="translated">Modern Runtime</target>
        </trans-unit>
        <trans-unit id="d9c1afdc6ae257e230b98cd64d31e69e21611588" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;&amp;lt;QueryRenderer&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Moderno: &lt;code&gt;&amp;lt;QueryRenderer&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a5e6e8b97a1927e12c72c467f5aebd11a8b3d28" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;commitMutation(this.props.relay.environment, {mutation...})&lt;/code&gt;</source>
          <target state="translated">Moderno: &lt;code&gt;commitMutation(this.props.relay.environment, {mutation...})&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="08b3c5d91eb7d6d9c801374dc1e47b603bba9b4b" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;createFragmentContainer&lt;/code&gt;</source>
          <target state="translated">Moderno: &lt;code&gt;createFragmentContainer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f02b7506a9375f3a261dab66ee915f347b72fd85" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;createPaginationContainer&lt;/code&gt;</source>
          <target state="translated">Moderno: &lt;code&gt;createPaginationContainer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c48a2a55168fdc7ce4613937fb203cff48a67840" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;this.props.relay.refetch({foo: bar}...&lt;/code&gt; in a Refetch Container</source>
          <target state="translated">Moderno: &lt;code&gt;this.props.relay.refetch({foo: bar}...&lt;/code&gt; en un contenedor de recuperaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="189e341013a3594080b144a6999f9577b74abee9" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;this.props.relay.refetchConnection(...)&lt;/code&gt; in a Pagination Container</source>
          <target state="translated">Moderno: &lt;code&gt;this.props.relay.refetchConnection(...)&lt;/code&gt; en un contenedor de paginaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="b11a8c01d122a0561a2dbd1098a225c3e43e4308" translate="yes" xml:space="preserve">
          <source>Most applications will create a single Environment instance and use it throughout. In specific situations, however, you may want to create multiple environments for different purposes. For example, you may create a new environment instance whenever the user logs in or out in order to prevent data for different users being cached together. Similarly, a server rendered application may create a new environment instance per request, so that each request gets its own cache and user data does not overlap. Alternatively, you might have multiple products or features within a larger application, and you want each one to have product-specific network-handling or caching.</source>
          <target state="translated">La mayoría de las aplicaciones crearán una única instancia de Medio Ambiente y la usarán en todo momento.En situaciones específicas,sin embargo,puede que quieras crear múltiples entornos para diferentes propósitos.Por ejemplo,se puede crear una nueva instancia de entorno siempre que el usuario inicie o termine su sesión,a fin de evitar que los datos de diferentes usuarios se almacenen en la memoria caché juntos.Del mismo modo,una aplicación renderizada por el servidor puede crear una nueva instancia de entorno por cada solicitud,de modo que cada solicitud obtenga su propia memoria caché y los datos de los usuarios no se superpongan.Otra posibilidad es que se tengan múltiples productos o características dentro de una aplicación más grande,y que se desee que cada uno de ellos tenga un manejo de red o un almacenamiento en caché específico para cada producto.</target>
        </trans-unit>
        <trans-unit id="01c289d32b7203303850eb1c7dd2fdae6842ce3a" translate="yes" xml:space="preserve">
          <source>Must be a valid &lt;code&gt;RelayContainer&lt;/code&gt;. Relay will attempt to fulfill its data requirements before rendering it.</source>
          <target state="translated">Debe ser un &lt;code&gt;RelayContainer&lt;/code&gt; v&amp;aacute;lido . Relay intentar&amp;aacute; cumplir con sus requisitos de datos antes de renderizarlo.</target>
        </trans-unit>
        <trans-unit id="13bcc5c25bae00735d267b69807a37eb90d90472" translate="yes" xml:space="preserve">
          <source>Mutation</source>
          <target state="translated">Mutation</target>
        </trans-unit>
        <trans-unit id="c55f198bc8c7844e5e05f72964532f5dace071a0" translate="yes" xml:space="preserve">
          <source>Mutation props</source>
          <target state="translated">Los accesorios de la mutación...</target>
        </trans-unit>
        <trans-unit id="00a7fb731451c41a484b7591ece27f55c474ec0e" translate="yes" xml:space="preserve">
          <source>Mutations</source>
          <target state="translated">Mutations</target>
        </trans-unit>
        <trans-unit id="731fdeead88e01d93d0976eb789d77d6c8ba6428" translate="yes" xml:space="preserve">
          <source>Mutator configuration</source>
          <target state="translated">Configuración del mutante</target>
        </trans-unit>
        <trans-unit id="aeecae05e67a82b3d9ddc32f18bafb250167d7b8" translate="yes" xml:space="preserve">
          <source>NODE_DELETE</source>
          <target state="translated">NODE_DELETE</target>
        </trans-unit>
        <trans-unit id="bef32b44309c819256ef91505f3ce46153114806" translate="yes" xml:space="preserve">
          <source>Nested Routes</source>
          <target state="translated">Rutas anidadas</target>
        </trans-unit>
        <trans-unit id="67269d974acb388f118a96d5b0eb90541c783c5f" translate="yes" xml:space="preserve">
          <source>Nested routes with Relay data dependencies introduce an additional complication. While it's possible to render a &lt;code&gt;QueryRenderer&lt;/code&gt; per route, doing so will lead to request waterfalls in the general case where parent routes do not render their child routes until the data for those parent routes are available. This generally leads to an unnecessary additional delay in loading the data for the page, but may be acceptable for small applications or for applications with shallow route trees.</source>
          <target state="translated">Las rutas anidadas con dependencias de datos de retransmisi&amp;oacute;n introducen una complicaci&amp;oacute;n adicional. Si bien es posible representar un &lt;code&gt;QueryRenderer&lt;/code&gt; por ruta, hacerlo conducir&amp;aacute; a solicitar cascadas en el caso general en el que las rutas principales no representan sus rutas secundarias hasta que los datos de esas rutas principales est&amp;eacute;n disponibles. Esto generalmente conduce a un retraso adicional innecesario en la carga de los datos de la p&amp;aacute;gina, pero puede ser aceptable para aplicaciones peque&amp;ntilde;as o para aplicaciones con &amp;aacute;rboles de ruta poco profundos.</target>
        </trans-unit>
        <trans-unit id="72e403f095e27b7f00c62a3bd59aa377165b5a4c" translate="yes" xml:space="preserve">
          <source>Network Layer</source>
          <target state="translated">Capa de red</target>
        </trans-unit>
        <trans-unit id="87869155f5f3484fd0f094292d35a709172baa8a" translate="yes" xml:space="preserve">
          <source>Network layer</source>
          <target state="translated">Capa de red</target>
        </trans-unit>
        <trans-unit id="f41f095614dba0f32736c3af7fc6b7b54e8b4b7f" translate="yes" xml:space="preserve">
          <source>Never mutate &lt;code&gt;this.props.relay.variables&lt;/code&gt; directly as it will not trigger data to be fetched properly. Treat &lt;code&gt;this.props.relay.variables&lt;/code&gt; as if it were immutable, just like props.</source>
          <target state="translated">Nunca &lt;code&gt;this.props.relay.variables&lt;/code&gt; directamente, ya que no activar&amp;aacute; la obtenci&amp;oacute;n de datos correctamente. Trate &lt;code&gt;this.props.relay.variables&lt;/code&gt; como si fuera inmutable, al igual que los accesorios.</target>
        </trans-unit>
        <trans-unit id="a945aa9cbd03a748373e539cadd72f60595b9951" translate="yes" xml:space="preserve">
          <source>New in Relay Modern</source>
          <target state="translated">Lo nuevo en Relay Modern</target>
        </trans-unit>
        <trans-unit id="34d3ac7ad9c7ff0b33bb48c822077feedfac1008" translate="yes" xml:space="preserve">
          <source>Next, install the compiler (typically as a &lt;code&gt;devDependency&lt;/code&gt;):</source>
          <target state="translated">A continuaci&amp;oacute;n, instale el compilador (normalmente como &lt;code&gt;devDependency&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="b11d6766a232735ae2588359ce0e697727bb4a84" translate="yes" xml:space="preserve">
          <source>Next, let's create a file in &lt;code&gt;./js/mutations/CheckHidingSpotForTreasureMutation.js&lt;/code&gt; and create subclass of &lt;code&gt;Relay.Mutation&lt;/code&gt; called &lt;code&gt;CheckHidingSpotForTreasureMutation&lt;/code&gt; to hold our mutation implementation:</source>
          <target state="translated">A continuaci&amp;oacute;n, &lt;code&gt;./js/mutations/CheckHidingSpotForTreasureMutation.js&lt;/code&gt; un archivo en ./js/mutations/CheckHidingSpotForTreasureMutation.js y creemos una subclase de &lt;code&gt;Relay.Mutation&lt;/code&gt; llamada &lt;code&gt;CheckHidingSpotForTreasureMutation&lt;/code&gt; para mantener nuestra implementaci&amp;oacute;n de mutaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="8d0415201da41a689310dea9dfd9de53cb8630b3" translate="yes" xml:space="preserve">
          <source>Next, let's define a node interface and type. We only need to provide a way for Relay to map from an object to the GraphQL type associated with that object, and from a global ID to the object it points to:</source>
          <target state="translated">A continuación,definamos una interfaz y un tipo de nodo.Sólo tenemos que proporcionar una forma para que Relé se mapee desde un objeto al tipo de GraphQL asociado a ese objeto,y desde un ID global al objeto al que apunta:</target>
        </trans-unit>
        <trans-unit id="adc67eef09450d30c9ae37eeb2376e191eb49c0d" translate="yes" xml:space="preserve">
          <source>Next, let's define our game and hiding spot types, and the fields that are available on each.</source>
          <target state="translated">A continuación,definamos nuestros tipos de juego y de escondite,y los campos que están disponibles en cada uno.</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="5b3016b7b65c75156425ea4affe66b9292dbd049" translate="yes" xml:space="preserve">
          <source>No Routing</source>
          <target state="translated">No hay rutas</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="ded70becacd440a8a5293ee572a86c4c58319833" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;ready&lt;/code&gt; and &lt;code&gt;done&lt;/code&gt; will continue to be false.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;ready&lt;/code&gt; y &lt;code&gt;done&lt;/code&gt; seguir&amp;aacute; siendo falso.</target>
        </trans-unit>
        <trans-unit id="7c2002c29e0fca7efc2e3f32bc61fca5000503d9" translate="yes" xml:space="preserve">
          <source>Note that it is &lt;em&gt;highly&lt;/em&gt; recommended that &lt;code&gt;Relay.Container&lt;/code&gt;s define their own fragments and avoid sharing inline &lt;code&gt;var fragment = Relay.QL...&lt;/code&gt; values between containers or files. If you find yourself wanting to share inline fragments, it's likely a sign that it's time to refactor and introduce a new container.</source>
          <target state="translated">Tenga en cuenta que se &lt;em&gt;recomienda&lt;/em&gt; encarecidamente que &lt;code&gt;Relay.Container&lt;/code&gt; s defina sus propios fragmentos y evite compartir valores &lt;code&gt;var fragment = Relay.QL...&lt;/code&gt; entre contenedores o archivos. Si desea compartir fragmentos en l&amp;iacute;nea, es probable que sea una se&amp;ntilde;al de que es hora de refactorizar e introducir un nuevo contenedor.</target>
        </trans-unit>
        <trans-unit id="6251d7c444bd5ea65a8e620b067b7ace419f0985" translate="yes" xml:space="preserve">
          <source>Note that this approach requires &lt;em&gt;n+1&lt;/em&gt; requests to the server: 1 to fetch the list, and &lt;em&gt;n&lt;/em&gt; to fetch each item. With GraphQL we can fetch the same data in a single network request to the server (without creating a custom endpoint that we'd then have to maintain):</source>
          <target state="translated">Tenga en cuenta que este enfoque requiere &lt;em&gt;n + 1&lt;/em&gt; solicitudes al servidor: 1 para obtener la lista y &lt;em&gt;n&lt;/em&gt; para obtener cada elemento. Con GraphQL podemos obtener los mismos datos en una sola solicitud de red al servidor (sin crear un punto final personalizado que luego tendr&amp;iacute;amos que mantener):</target>
        </trans-unit>
        <trans-unit id="41a9a091d399394a5944c5c0a394fb244440e004" translate="yes" xml:space="preserve">
          <source>Note that this is a basic example to help you get started. This example could be extended with additional features such as request/response caching (enabled e.g. when &lt;code&gt;cacheConfig.force&lt;/code&gt; is false) and uploading form data for mutations (the &lt;code&gt;uploadables&lt;/code&gt; parameter).</source>
          <target state="translated">Tenga en cuenta que este es un ejemplo b&amp;aacute;sico que le ayudar&amp;aacute; a empezar. Este ejemplo podr&amp;iacute;a ampliarse con funciones adicionales como el almacenamiento en cach&amp;eacute; de solicitudes / respuestas (habilitado, por ejemplo, cuando &lt;code&gt;cacheConfig.force&lt;/code&gt; es falso) y la carga de datos de formularios para mutaciones (el par&amp;aacute;metro &lt;code&gt;uploadables&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="18e979539b69c286787704dcc6ebc81753f2b6c9" translate="yes" xml:space="preserve">
          <source>Note that this normalized cache structure allows overlapping results to be cached without duplication. Each record is stored once regardless of how it is fetched. Let's return to the earlier example of inconsistent data and see how this cache helps in that scenario.</source>
          <target state="translated">Obsérvese que esta estructura de caché normalizada permite que los resultados superpuestos se almacenen en caché sin duplicación.Cada registro se almacena una vez,independientemente de cómo se obtenga.Volvamos al ejemplo anterior de datos inconsistentes y veamos cómo esta caché ayuda en ese escenario.</target>
        </trans-unit>
        <trans-unit id="6a3998469edc7ffa18da69953898b4c848c54481" translate="yes" xml:space="preserve">
          <source>Note that this solution will also work for &lt;em&gt;writes&lt;/em&gt;: any update to the cache will notify the affected views, and writes are just another thing that updates the cache.</source>
          <target state="translated">Tenga en cuenta que esta soluci&amp;oacute;n tambi&amp;eacute;n funcionar&amp;aacute; para &lt;em&gt;escrituras&lt;/em&gt; : cualquier actualizaci&amp;oacute;n de la cach&amp;eacute; notificar&amp;aacute; las vistas afectadas, y las escrituras son solo otra cosa que actualiza la cach&amp;eacute;.</target>
        </trans-unit>
        <trans-unit id="ac8054c10594bdd95e89a5e8a8673034de9d793b" translate="yes" xml:space="preserve">
          <source>Note that when composing fragments, the type of the composed fragment must match the field on the parent in which it is embedded. For example, it wouldn't make sense to embed a fragment of type &lt;code&gt;Story&lt;/code&gt; into a parent's field of type &lt;code&gt;User&lt;/code&gt;. Relay and GraphQL will provide helpful error messages if you get this wrong (and if they aren't helpful, let us know!).</source>
          <target state="translated">Tenga en cuenta que al componer fragmentos, el tipo de fragmento compuesto debe coincidir con el campo del padre en el que est&amp;aacute; incrustado. Por ejemplo, no tendr&amp;iacute;a sentido incrustar un fragmento de tipo &lt;code&gt;Story&lt;/code&gt; en el campo principal de tipo &lt;code&gt;User&lt;/code&gt; . Relay y GraphQL proporcionar&amp;aacute;n mensajes de error &amp;uacute;tiles si se equivoca (y si no son &amp;uacute;tiles, &amp;iexcl;av&amp;iacute;senos!).</target>
        </trans-unit>
        <trans-unit id="0cb3b8bd044c603524ff2409189dcccf98b3f39b" translate="yes" xml:space="preserve">
          <source>Note: Determining variable values at runtime</source>
          <target state="translated">Nota:Determinar los valores de las variables en tiempo de ejecución</target>
        </trans-unit>
        <trans-unit id="6eb6c807aac98e74096f64d7f8585ee557b93a39" translate="yes" xml:space="preserve">
          <source>Note: In most cases, it is possible to rely on the default singleton instance of the environment, which is exposed as &lt;code&gt;Relay.Store&lt;/code&gt;.</source>
          <target state="translated">Nota: En la mayor&amp;iacute;a de los casos, es posible confiar en la instancia singleton predeterminada del entorno, que se expone como &lt;code&gt;Relay.Store&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06bd725e4a6c3e529d4b86297fa0d602b821e04c" translate="yes" xml:space="preserve">
          <source>Note: This method may only be called once per instance.</source>
          <target state="translated">Nota:Este método sólo puede ser llamado una vez por instancia.</target>
        </trans-unit>
        <trans-unit id="a0e48b33fadd08f907218ada431ccb61eb2d094e" translate="yes" xml:space="preserve">
          <source>Notice that it immediately executes the next task. Relay manages the order of tasks to ensure a proper order of operations - the scheduler can't skip or reorder tasks, only decide when to execute the next one.</source>
          <target state="translated">Note que ejecuta inmediatamente la siguiente tarea.El relé gestiona el orden de las tareas para asegurar un orden adecuado de las operaciones-el programador no puede saltarse o reordenar las tareas,sólo decidir cuándo ejecutar la siguiente.</target>
        </trans-unit>
        <trans-unit id="c79f05d35d0a7eb36506bd3ab33a1f2773cfa554" translate="yes" xml:space="preserve">
          <source>Notice that the cursor is a base64 string. That's the pattern from earlier: the server is reminding us that this is an opaque string. We can pass this string back to the server as the &lt;code&gt;after&lt;/code&gt; argument to the &lt;code&gt;ships&lt;/code&gt; field, which will let us ask for the next three ships after the last one in the previous result:</source>
          <target state="translated">Observe que el cursor es una cadena base64. Ese es el patr&amp;oacute;n de antes: el servidor nos recuerda que esta es una cadena opaca. Podemos pasar esta cadena de nuevo al servidor como argumento &lt;code&gt;after&lt;/code&gt; al campo de &lt;code&gt;ships&lt;/code&gt; , que nos permitir&amp;aacute; preguntar por los siguientes tres barcos despu&amp;eacute;s del &amp;uacute;ltimo en el resultado anterior:</target>
        </trans-unit>
        <trans-unit id="3aca59c767d5ed557222dbb5b8557469ae3a4a7f" translate="yes" xml:space="preserve">
          <source>Notice that we're querying for data that &lt;em&gt;may&lt;/em&gt; have changed as a result of the mutation. An obvious question is: why can't the server just tell us what changed? The answer is: it's complicated. GraphQL abstracts over &lt;em&gt;any&lt;/em&gt; data storage layer (or an aggregation of multiple sources), and works with any programming language. Furthermore, the goal of GraphQL is to provide data in a form that is useful to product developers building a view.</source>
          <target state="translated">Tenga en cuenta que estamos buscando datos que &lt;em&gt;pueden&lt;/em&gt; haber cambiado como resultado de la mutaci&amp;oacute;n. Una pregunta obvia es: &amp;iquest;por qu&amp;eacute; el servidor no puede simplemente decirnos qu&amp;eacute; cambi&amp;oacute;? La respuesta es: es complicado. GraphQL abstrae &lt;em&gt;cualquier&lt;/em&gt; capa de almacenamiento de datos (o una agregaci&amp;oacute;n de m&amp;uacute;ltiples fuentes) y funciona con cualquier lenguaje de programaci&amp;oacute;n. Adem&amp;aacute;s, el objetivo de GraphQL es proporcionar datos en una forma que sea &amp;uacute;til para los desarrolladores de productos que crean una vista.</target>
        </trans-unit>
        <trans-unit id="056ee5771da852e979294339f6d61f3371dc9784" translate="yes" xml:space="preserve">
          <source>Now Relay will both fetch the larger photo size &lt;em&gt;and&lt;/em&gt;&lt;code&gt;Child&lt;/code&gt; will know to render it.</source>
          <target state="translated">Ahora, Relay obtendr&amp;aacute; el tama&amp;ntilde;o de foto m&amp;aacute;s grande &lt;em&gt;y el &lt;/em&gt; &lt;code&gt;Child&lt;/code&gt; sabr&amp;aacute; renderizarlo.</target>
        </trans-unit>
        <trans-unit id="359fab9a105cb172833a57b904a4f78ae21bf6b3" translate="yes" xml:space="preserve">
          <source>Now Relay will fetch the photo with size 128 - but the &lt;code&gt;Child&lt;/code&gt; container won't magically know about this variable. We have to tell it by passing the variable value as a prop:</source>
          <target state="translated">Ahora Relay buscar&amp;aacute; la foto con tama&amp;ntilde;o 128, pero el contenedor &lt;code&gt;Child&lt;/code&gt; no sabr&amp;aacute; m&amp;aacute;gicamente sobre esta variable. Tenemos que decirlo pasando el valor de la variable como prop:</target>
        </trans-unit>
        <trans-unit id="8f4ea81858f10f7f357b3da216fb14eb06c577cc" translate="yes" xml:space="preserve">
          <source>Now let's associate these types with the root query type.</source>
          <target state="translated">Ahora vamos a asociar estos tipos con el tipo de consulta de la raíz.</target>
        </trans-unit>
        <trans-unit id="ee5dbc563862c37bd2eddab0d2faa5a3c1303875" translate="yes" xml:space="preserve">
          <source>Now let's take a closer look at the &lt;code&gt;config&lt;/code&gt;:</source>
          <target state="translated">Ahora echemos un vistazo m&amp;aacute;s de cerca a la &lt;code&gt;config&lt;/code&gt; uraci&amp;oacute;n :</target>
        </trans-unit>
        <trans-unit id="c63c75c8f04bcbaded3abd8323247dbc014c15ac" translate="yes" xml:space="preserve">
          <source>Now that we've gone through this tutorial, let's dive into what it means to build a GraphQL client framework and how this compares to clients for more traditional REST systems.</source>
          <target state="translated">Ahora que hemos repasado este tutorial,vamos a sumergirnos en lo que significa construir un marco de clientes GraphQL y cómo se compara con los clientes de los sistemas REST más tradicionales.</target>
        </trans-unit>
        <trans-unit id="3c8e0a4e6791c0f1c68af7b94cb67e9dddbecd93" translate="yes" xml:space="preserve">
          <source>Now we can instantiate a &lt;code&gt;ProfileRoute&lt;/code&gt; that fetches data for user &lt;code&gt;123&lt;/code&gt;:</source>
          <target state="translated">Ahora podemos crear una instancia de &lt;code&gt;ProfileRoute&lt;/code&gt; que obtenga datos para el usuario &lt;code&gt;123&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d3cbdecefa56176a7edca66548a54ce86a3ed688" translate="yes" xml:space="preserve">
          <source>Now, requests for previously cached data can be answered immediately without making a network request. This is a practical approach to improving the perceived performance of an application. However, this method of caching can cause problems with data consistency.</source>
          <target state="translated">Ahora,las solicitudes de datos previamente almacenados en la memoria caché pueden ser respondidas inmediatamente sin hacer una solicitud de red.Este es un enfoque práctico para mejorar el rendimiento percibido de una aplicación.Sin embargo,este método de almacenamiento en caché puede causar problemas de consistencia de los datos.</target>
        </trans-unit>
        <trans-unit id="c7d436121cc7de83cd8afcc9e5b08145f88e3d72" translate="yes" xml:space="preserve">
          <source>Object Identification</source>
          <target state="translated">Identificación de objetos</target>
        </trans-unit>
        <trans-unit id="509d0e819f7363f119680482f06c06df5503cfc0" translate="yes" xml:space="preserve">
          <source>On the Relay Container the prop &lt;code&gt;bars&lt;/code&gt; will be an array instead of an object.</source>
          <target state="translated">En el Relay Container, las &lt;code&gt;bars&lt;/code&gt; apoyo ser&amp;aacute;n una matriz en lugar de un objeto.</target>
        </trans-unit>
        <trans-unit id="258ab7d6dd3b683b7bd3f1f1a9e4c26dc064e05d" translate="yes" xml:space="preserve">
          <source>On the other hand, GraphQL &lt;strong&gt;fragments&lt;/strong&gt; declare fields that exist on any arbitrary type. For example, the following fragment fetches the profile picture URI for &lt;em&gt;some&lt;/em&gt;&lt;code&gt;User&lt;/code&gt;.</source>
          <target state="translated">Por otro lado, los &lt;strong&gt;fragmentos&lt;/strong&gt; GraphQL declaran campos que existen en cualquier tipo arbitrario. Por ejemplo, el siguiente fragmento recupera el URI de la imagen de perfil de &lt;em&gt;alg&amp;uacute;n &lt;/em&gt; &lt;code&gt;User&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e77ad76d86248c3f5b3430ab7a50cf954c824781" translate="yes" xml:space="preserve">
          <source>Once a few or all of your views are using &lt;code&gt;QueryRenderer&lt;/code&gt;, &lt;code&gt;Store&lt;/code&gt; from &lt;code&gt;'react-relay/classic'&lt;/code&gt; could be replaced with a &lt;code&gt;RelayModernEnvironment&lt;/code&gt;. Keep in mind that &lt;code&gt;RelayModernEnvironment&lt;/code&gt; and &lt;code&gt;Store&lt;/code&gt; do not share any data. You might want to hold off on this step until views that have significant data overlap can be switched over at the same time. This step is what unlocks the perf wins for your app. Apps using the &lt;code&gt;RelayModernEnvironment&lt;/code&gt; get to send persisted query IDs instead of the full query strings to the server, as well as much more optimized data normalizing and processing.</source>
          <target state="translated">Una vez que algunas o todas sus vistas est&amp;eacute;n usando &lt;code&gt;QueryRenderer&lt;/code&gt; , &lt;code&gt;Store&lt;/code&gt; from &lt;code&gt;'react-relay/classic'&lt;/code&gt; podr&amp;iacute;a reemplazarse con un &lt;code&gt;RelayModernEnvironment&lt;/code&gt; . Tenga en cuenta que &lt;code&gt;RelayModernEnvironment&lt;/code&gt; y &lt;code&gt;Store&lt;/code&gt; no comparten ning&amp;uacute;n dato. Es posible que desee retrasar este paso hasta que las vistas que tienen una superposici&amp;oacute;n de datos significativa se puedan cambiar al mismo tiempo. Este paso es lo que desbloquea las ganancias de rendimiento para su aplicaci&amp;oacute;n. Las aplicaciones que utilizan &lt;code&gt;RelayModernEnvironment&lt;/code&gt; pueden enviar ID de consultas persistentes en lugar de las cadenas de consulta completas al servidor, as&amp;iacute; como una normalizaci&amp;oacute;n y procesamiento de datos mucho m&amp;aacute;s optimizados.</target>
        </trans-unit>
        <trans-unit id="aa26441141ed7039f7d3b90dda06bb5985300871" translate="yes" xml:space="preserve">
          <source>Once all the components and mutations have been converted to use the Relay Modern APIs, convert to using &lt;code&gt;QueryRenderer&lt;/code&gt; instead of using &lt;code&gt;Relay.Renderer&lt;/code&gt; or &lt;code&gt;Relay.RootContainer&lt;/code&gt;. You may supply &lt;code&gt;Store&lt;/code&gt; from &lt;code&gt;'react-relay/classic'&lt;/code&gt; as the &lt;code&gt;environment&lt;/code&gt; for most cases.</source>
          <target state="translated">Una vez que todos los componentes y mutaciones se hayan convertido para usar las API de Relay Modern, &lt;code&gt;QueryRenderer&lt;/code&gt; para usar QueryRenderer en lugar de usar &lt;code&gt;Relay.Renderer&lt;/code&gt; o &lt;code&gt;Relay.RootContainer&lt;/code&gt; . Puede proporcionar &lt;code&gt;Store&lt;/code&gt; desde &lt;code&gt;'react-relay/classic'&lt;/code&gt; como &lt;code&gt;environment&lt;/code&gt; en la mayor&amp;iacute;a de los casos.</target>
        </trans-unit>
        <trans-unit id="526a2470452cfa759c69b07a4cdac3145513395b" translate="yes" xml:space="preserve">
          <source>Once with &lt;code&gt;error&lt;/code&gt; set to an &lt;code&gt;Error&lt;/code&gt; object.</source>
          <target state="translated">Una vez con el &lt;code&gt;error&lt;/code&gt; establecido en un objeto &lt;code&gt;Error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d30a28f0a20b5fda3d127c2ba900c1393a0c802c" translate="yes" xml:space="preserve">
          <source>Once with &lt;code&gt;ready&lt;/code&gt; and &lt;code&gt;done&lt;/code&gt; set to true, but &lt;code&gt;stale&lt;/code&gt; set to false.</source>
          <target state="translated">Una vez con &lt;code&gt;ready&lt;/code&gt; y &lt;code&gt;done&lt;/code&gt; establecido en verdadero, pero &lt;code&gt;stale&lt;/code&gt; establecido en falso.</target>
        </trans-unit>
        <trans-unit id="c510443cbc7ffd35f869abc94218360943f66d9e" translate="yes" xml:space="preserve">
          <source>Once with &lt;code&gt;ready&lt;/code&gt; and &lt;code&gt;done&lt;/code&gt; set to true.</source>
          <target state="translated">Una vez que &lt;code&gt;ready&lt;/code&gt; y &lt;code&gt;done&lt;/code&gt; establezca el valor verdadero.</target>
        </trans-unit>
        <trans-unit id="9b048c01bc7fa82617b39cb08502f943e54b8d4a" translate="yes" xml:space="preserve">
          <source>Once with &lt;code&gt;ready&lt;/code&gt; set to false.</source>
          <target state="translated">Una vez con &lt;code&gt;ready&lt;/code&gt; establecido en falso.</target>
        </trans-unit>
        <trans-unit id="fe545c0159939d91c25a89db650c07bece33f470" translate="yes" xml:space="preserve">
          <source>Once with &lt;code&gt;ready&lt;/code&gt;, &lt;code&gt;done&lt;/code&gt;, and &lt;code&gt;stale&lt;/code&gt; set to true.</source>
          <target state="translated">Una vez que &lt;code&gt;ready&lt;/code&gt; , &lt;code&gt;done&lt;/code&gt; y &lt;code&gt;stale&lt;/code&gt; configurado en verdadero.</target>
        </trans-unit>
        <trans-unit id="c8f5f6a359004092335c67ac77552d54cac29a5a" translate="yes" xml:space="preserve">
          <source>Once you have an environment, you can pass it in to your &lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt; instance, or into mutations via the &lt;code&gt;commitUpdate&lt;/code&gt; function (see &quot;&lt;a href=&quot;mutations&quot;&gt;Mutations&lt;/a&gt;&quot;).</source>
          <target state="translated">Una vez que tenga un entorno, puede pasarlo a su instancia de &lt;a href=&quot;query-renderer&quot;&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;/a&gt; , o en mutaciones a trav&amp;eacute;s de la funci&amp;oacute;n &lt;code&gt;commitUpdate&lt;/code&gt; (ver &quot; &lt;a href=&quot;mutations&quot;&gt;Mutaciones&lt;/a&gt; &quot;).</target>
        </trans-unit>
        <trans-unit id="3445237f2d0762c974ff895551ac18ecb7b0fd39" translate="yes" xml:space="preserve">
          <source>One of the big ideas behind the new API is that execution can be made a lot more efficient by moving work ahead-of-time: from the runtime of the app to the build-time. As such, changes to GraphQL fragments require a build step to regenerate a set of artifacts. More on &lt;a href=&quot;relay-compiler&quot;&gt;the Relay Compiler&lt;/a&gt;.</source>
          <target state="translated">Una de las grandes ideas detr&amp;aacute;s de la nueva API es que la ejecuci&amp;oacute;n se puede hacer mucho m&amp;aacute;s eficiente adelantando el trabajo: desde el tiempo de ejecuci&amp;oacute;n de la aplicaci&amp;oacute;n hasta el tiempo de compilaci&amp;oacute;n. Como tal, los cambios en los fragmentos de GraphQL requieren un paso de compilaci&amp;oacute;n para regenerar un conjunto de artefactos. M&amp;aacute;s sobre &lt;a href=&quot;relay-compiler&quot;&gt;el compilador de retransmisiones&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ad501b8fa6c8a155c72db2494b37eb05a27af8e5" translate="yes" xml:space="preserve">
          <source>One solution is to have a root component fetch the data for all its children. However, this would introduce coupling: every change to a component would require changing &lt;em&gt;any&lt;/em&gt; root component that might render it, and often some components between it and the root. This coupling could mean a greater chance for bugs and slow the pace of development. Ultimately, this approach doesn't take advantage of React's component model. The natural place for specifying data-dependencies was in &lt;em&gt;components&lt;/em&gt;.</source>
          <target state="translated">Una soluci&amp;oacute;n es que un componente ra&amp;iacute;z obtenga los datos de todos sus elementos secundarios. Sin embargo, esto introducir&amp;iacute;a acoplamiento: cada cambio en un componente requerir&amp;iacute;a cambiar &lt;em&gt;cualquier&lt;/em&gt; componente ra&amp;iacute;z que pudiera representarlo y, a menudo, algunos componentes entre &amp;eacute;l y la ra&amp;iacute;z. Este acoplamiento podr&amp;iacute;a significar una mayor probabilidad de errores y ralentizar el ritmo de desarrollo. En &amp;uacute;ltima instancia, este enfoque no aprovecha el modelo de componentes de React. El lugar natural para especificar las dependencias de datos eran los &lt;em&gt;componentes&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6b5a7ba3ecdf80b9b9c9285e7c15e081d2c4cfd9" translate="yes" xml:space="preserve">
          <source>One thing is left in the example above &amp;mdash; implementing &lt;code&gt;setSize()&lt;/code&gt;, which should change the photo's size when the slider values changes. In addition to passing the results of each query to the component, Relay also provides a &lt;code&gt;relay&lt;/code&gt; prop that has Relay-specific methods and metadata. These include &lt;code&gt;variables&lt;/code&gt; &amp;mdash; the active variables used to fetch the current &lt;code&gt;props&lt;/code&gt; &amp;mdash; and &lt;code&gt;setVariables()&lt;/code&gt; &amp;mdash; a callback that can be used to request data for different variable values.</source>
          <target state="translated">En el ejemplo anterior queda una cosa: implementar &lt;code&gt;setSize()&lt;/code&gt; , que deber&amp;iacute;a cambiar el tama&amp;ntilde;o de la foto cuando cambien los valores del control deslizante. Adem&amp;aacute;s de pasar los resultados de cada consulta al componente, Relay tambi&amp;eacute;n proporciona un accesorio de &lt;code&gt;relay&lt;/code&gt; que tiene m&amp;eacute;todos y metadatos espec&amp;iacute;ficos de Relay. Estos incluyen &lt;code&gt;variables&lt;/code&gt; , las variables activas que se usan para obtener los &lt;code&gt;props&lt;/code&gt; actuales , y &lt;code&gt;setVariables()&lt;/code&gt; , una devoluci&amp;oacute;n de llamada que se puede usar para solicitar datos para diferentes valores de variable.</target>
        </trans-unit>
        <trans-unit id="43ec0f0f8cb785cd4021b95098b6011da01043b4" translate="yes" xml:space="preserve">
          <source>Only fields specified by these fragments will be populated in &lt;code&gt;this.props&lt;/code&gt; when the component is rendered. This ensures that there are no implicit dependencies from a component on its parent component or any child components.</source>
          <target state="translated">Solo los campos especificados por estos fragmentos se completar&amp;aacute;n en &lt;code&gt;this.props&lt;/code&gt; cuando se procese el componente. Esto asegura que no haya dependencias impl&amp;iacute;citas de un componente en su componente principal o en cualquier componente secundario.</target>
        </trans-unit>
        <trans-unit id="544901021486ff794813761281a30a85a9ea2561" translate="yes" xml:space="preserve">
          <source>Optimistic updates</source>
          <target state="translated">Actualizaciones optimistas</target>
        </trans-unit>
        <trans-unit id="75e97d82c2ab23fae3c5ae0de671aad8aaab254b" translate="yes" xml:space="preserve">
          <source>Optimistically updating the UI while waiting for the server to respond to mutations.</source>
          <target state="translated">Actualizando de forma optimista la interfaz de usuario mientras se espera a que el servidor responda a las mutaciones.</target>
        </trans-unit>
        <trans-unit id="a30573ebcc5462272b8ba6828cf0b15e88284677" translate="yes" xml:space="preserve">
          <source>Option 1: Re-fetch everything that the app has ever queried. Even though only a small subset of this data will actually change, we'll still have to wait for the server to execute the &lt;em&gt;entire&lt;/em&gt; query, wait to download the results, and wait to process them again. This is very inefficient.</source>
          <target state="translated">Opci&amp;oacute;n 1: Vuelva a buscar todo lo que la aplicaci&amp;oacute;n haya consultado. Aunque solo un peque&amp;ntilde;o subconjunto de estos datos realmente cambiar&amp;aacute;, todav&amp;iacute;a tendremos que esperar a que el servidor ejecute la consulta &lt;em&gt;completa&lt;/em&gt; , esperar a descargar los resultados y esperar a procesarlos nuevamente. Esto es muy ineficiente.</target>
        </trans-unit>
        <trans-unit id="7c7f0ed28de8faafd0afd103f17d025324ed7cc5" translate="yes" xml:space="preserve">
          <source>Option 2: Re-fetch only the queries required by actively rendered views. This is a slight improvement over option 1. However, cached data that &lt;em&gt;isn't&lt;/em&gt; currently being viewed won't be updated. Unless this data is somehow marked as stale or evicted from the cache subsequent queries will read outdated information.</source>
          <target state="translated">Opci&amp;oacute;n 2: Recupere solo las consultas requeridas por las vistas renderizadas activamente. Esta es una ligera mejora con respecto a la opci&amp;oacute;n 1. Sin embargo, los datos almacenados en cach&amp;eacute; que &lt;em&gt;no&lt;/em&gt; se ven actualmente no se actualizar&amp;aacute;n. A menos que estos datos se marquen de alguna manera como obsoletos o se eliminen de la memoria cach&amp;eacute;, las consultas posteriores leer&amp;aacute;n informaci&amp;oacute;n desactualizada.</target>
        </trans-unit>
        <trans-unit id="1fc54acb388aaf56464909787927f5c9cc6c305b" translate="yes" xml:space="preserve">
          <source>Option 3: Re-fetch a fixed list of fields that &lt;em&gt;may&lt;/em&gt; change after the mutation. We'll call this list a &lt;strong&gt;fat query&lt;/strong&gt;. We found this to also be inefficient because typical applications only render a subset of the fat query, but this approach would require fetching all of those fields.</source>
          <target state="translated">Opci&amp;oacute;n 3: recuperar una lista fija de campos que &lt;em&gt;pueden&lt;/em&gt; cambiar despu&amp;eacute;s de la mutaci&amp;oacute;n. Llamaremos a esta lista una &lt;strong&gt;consulta gruesa&lt;/strong&gt; . Descubrimos que esto tambi&amp;eacute;n es ineficiente porque las aplicaciones t&amp;iacute;picas solo procesan un subconjunto de la consulta fat, pero este enfoque requerir&amp;iacute;a obtener todos esos campos.</target>
        </trans-unit>
        <trans-unit id="4be11d572e3b53b4fc22dae76efc2d670f4be4bb" translate="yes" xml:space="preserve">
          <source>Option 4 (Relay): Re-fetch the intersection of what may change (the fat query) and the data in the cache. In addition to the cache of data Relay also remembers the queries used to fetch each item. These are called &lt;strong&gt;tracked queries&lt;/strong&gt;. By intersecting the tracked and fat queries, Relay can query exactly the set of information the application needs to update and nothing more.</source>
          <target state="translated">Opci&amp;oacute;n 4 (retransmisi&amp;oacute;n): vuelva a buscar la intersecci&amp;oacute;n de lo que puede cambiar (la consulta fat) y los datos en la cach&amp;eacute;. Adem&amp;aacute;s de la cach&amp;eacute; de datos, Relay tambi&amp;eacute;n recuerda las consultas utilizadas para buscar cada elemento. Se denominan &lt;strong&gt;consultas de seguimiento&lt;/strong&gt; . Al cruzar las consultas rastreadas y pesadas, Relay puede consultar exactamente el conjunto de informaci&amp;oacute;n que la aplicaci&amp;oacute;n necesita actualizar y nada m&amp;aacute;s.</target>
        </trans-unit>
        <trans-unit id="6718713de12ca02e84822e47bd7f3094f39d3c0a" translate="yes" xml:space="preserve">
          <source>Optionally install globally</source>
          <target state="translated">Opcionalmente instalar globalmente</target>
        </trans-unit>
        <trans-unit id="b30829da1c673e16f6adae2f5da589d2b2d65970" translate="yes" xml:space="preserve">
          <source>Optionally, follow up with a call to &lt;code&gt;commit()&lt;/code&gt; to send the mutation to the server.</source>
          <target state="translated">Opcionalmente, haga un seguimiento con una llamada a &lt;code&gt;commit()&lt;/code&gt; para enviar la mutaci&amp;oacute;n al servidor.</target>
        </trans-unit>
        <trans-unit id="3a603142c92a8b820560fb3bf1b12553420c3f4e" translate="yes" xml:space="preserve">
          <source>Optionally, precede with a call to &lt;code&gt;applyOptimistic()&lt;/code&gt; to apply an update optimistically to the store.</source>
          <target state="translated">Opcionalmente, preceda con una llamada a &lt;code&gt;applyOptimistic()&lt;/code&gt; para aplicar una actualizaci&amp;oacute;n de manera optimista a la tienda.</target>
        </trans-unit>
        <trans-unit id="ae17e1897a8cc791f789d5b34d32406b1c727d64" translate="yes" xml:space="preserve">
          <source>Or this way, with the same results:</source>
          <target state="translated">O de esta manera,con los mismos resultados:</target>
        </trans-unit>
        <trans-unit id="50300a6866222e559def812f5df571c9176ba61e" translate="yes" xml:space="preserve">
          <source>Overrides the &lt;a href=&quot;#defaultnetworklayer-static-property&quot;&gt;DefaultNetworkLayer&lt;/a&gt;.</source>
          <target state="translated">Reemplaza el &lt;a href=&quot;#defaultnetworklayer-static-property&quot;&gt;DefaultNetworkLayer&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fd55d4fdc76dc273300987b3c56489168f507c74" translate="yes" xml:space="preserve">
          <source>Overriding Fragment Variables</source>
          <target state="translated">Anulando las variables de los fragmentos</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="100325b8d6de92dc6ff09cd2c078133755bf274f" translate="yes" xml:space="preserve">
          <source>Pagination</source>
          <target state="translated">Pagination</target>
        </trans-unit>
        <trans-unit id="1847eac49f0862bab8cf4f3614ad739655005e7f" translate="yes" xml:space="preserve">
          <source>Pagination Container</source>
          <target state="translated">Contenedor de paginación</target>
        </trans-unit>
        <trans-unit id="66cd194918cca0919b19b5c19a6632d8edf7c051" translate="yes" xml:space="preserve">
          <source>PaginationContainer</source>
          <target state="translated">PaginationContainer</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="5a9a81786a3cd10e92834a3ac1d48bcd7f39e6e3" translate="yes" xml:space="preserve">
          <source>Please note that the &lt;code&gt;&quot;relay&quot;&lt;/code&gt; plugin should run before other plugins or presets to ensure the &lt;code&gt;graphql&lt;/code&gt; template literals are correctly transformed. See Babel's &lt;a href=&quot;https://babeljs.io/docs/plugins/#plugin-preset-ordering&quot;&gt;documentation on this topic&lt;/a&gt;.</source>
          <target state="translated">Tenga en cuenta que el complemento &lt;code&gt;&quot;relay&quot;&lt;/code&gt; debe ejecutarse antes que otros complementos o ajustes preestablecidos para garantizar que los literales de la plantilla &lt;code&gt;graphql&lt;/code&gt; se transformen correctamente. Consulte la &lt;a href=&quot;https://babeljs.io/docs/plugins/#plugin-preset-ordering&quot;&gt;documentaci&amp;oacute;n&lt;/a&gt; de Babel sobre este tema .</target>
        </trans-unit>
        <trans-unit id="02a0a62fe61678e8a433343395761ce593ca76c7" translate="yes" xml:space="preserve">
          <source>Please note that this replaces the &lt;a href=&quot;guides-babel-plugin&quot;&gt;older Babel Relay plugin&lt;/a&gt;. It is not necessary to include both plugins.</source>
          <target state="translated">Tenga en cuenta que esto reemplaza al &lt;a href=&quot;guides-babel-plugin&quot;&gt;antiguo complemento Babel Relay&lt;/a&gt; . No es necesario incluir ambos complementos.</target>
        </trans-unit>
        <trans-unit id="c6a15b9b600a39666d059f44d5e217d0eadd28f6" translate="yes" xml:space="preserve">
          <source>Populating The Cache</source>
          <target state="translated">Poblar el caché</target>
        </trans-unit>
        <trans-unit id="9ef1894fd67a6660f9dc545b85fdd7563a957682" translate="yes" xml:space="preserve">
          <source>Populating the cache involves walking a hierarchical GraphQL response and creating or updating normalized cache records. At first it may seem that the response alone is sufficient to process the response, but in fact this is only true for very simple queries. Consider &lt;code&gt;user(id: &quot;456&quot;) { photo(size: 32) { uri } }&lt;/code&gt; &amp;mdash; how should we store &lt;code&gt;photo&lt;/code&gt;? Using &lt;code&gt;photo&lt;/code&gt; as the field name in the cache won't work because a different query might fetch the same field but with different argument values (e.g. &lt;code&gt;photo(size: 64) {...}&lt;/code&gt;). A similar issue occurs with pagination. If we fetch the 11th to 20th stories with &lt;code&gt;stories(first: 10, offset: 10)&lt;/code&gt;, these new results should be &lt;em&gt;appended&lt;/em&gt; to the existing list.</source>
          <target state="translated">Llenar la cach&amp;eacute; implica recorrer una respuesta GraphQL jer&amp;aacute;rquica y crear o actualizar registros de cach&amp;eacute; normalizados. Al principio puede parecer que la respuesta por s&amp;iacute; sola es suficiente para procesar la respuesta, pero de hecho esto solo es cierto para consultas muy simples. Considere el &lt;code&gt;user(id: &quot;456&quot;) { photo(size: 32) { uri } }&lt;/code&gt; - &amp;iquest;c&amp;oacute;mo debemos almacenar la &lt;code&gt;photo&lt;/code&gt; ? El uso de &lt;code&gt;photo&lt;/code&gt; como nombre de campo en la cach&amp;eacute; no funcionar&amp;aacute; porque una consulta diferente puede obtener el mismo campo pero con diferentes valores de argumento (por ejemplo, &lt;code&gt;photo(size: 64) {...}&lt;/code&gt; ). Un problema similar ocurre con la paginaci&amp;oacute;n. Si buscamos las historias 11 a 20 con &lt;code&gt;stories(first: 10, offset: 10)&lt;/code&gt; , estos nuevos resultados deben &lt;em&gt;agregarse&lt;/em&gt; a la lista existente.</target>
        </trans-unit>
        <trans-unit id="178213e972c712d32c9b754e0fae0660405a3262" translate="yes" xml:space="preserve">
          <source>Processing the schema</source>
          <target state="translated">Procesamiento del esquema</target>
        </trans-unit>
        <trans-unit id="9fb705d5e8095ddb73ff47bd5a3af904d3ea97b5" translate="yes" xml:space="preserve">
          <source>PropTypes</source>
          <target state="translated">PropTypes</target>
        </trans-unit>
        <trans-unit id="bc6c88db2f0703a9e2461a4a8060ccf1cb881998" translate="yes" xml:space="preserve">
          <source>Properties</source>
          <target state="translated">Properties</target>
        </trans-unit>
        <trans-unit id="1100c030f3dc539b64e7700624cabb080430dd57" translate="yes" xml:space="preserve">
          <source>Properties and Methods</source>
          <target state="translated">Propiedades y métodos</target>
        </trans-unit>
        <trans-unit id="e5561bc237fb41709bb2e8b651d704c1664ae03e" translate="yes" xml:space="preserve">
          <source>Props</source>
          <target state="translated">Props</target>
        </trans-unit>
        <trans-unit id="32bb9f0eed56ead65c951dc161935d4389c8dfcc" translate="yes" xml:space="preserve">
          <source>QL</source>
          <target state="translated">QL</target>
        </trans-unit>
        <trans-unit id="0fa0f7a77beffe015e3dbe50d9707a0cef073bae" translate="yes" xml:space="preserve">
          <source>Queries vs. Fragments</source>
          <target state="translated">Consultas vs.Fragmentos</target>
        </trans-unit>
        <trans-unit id="715a8fe94c1d42fc9dfbb4b5057bd51288856fd1" translate="yes" xml:space="preserve">
          <source>Query Naming Convention</source>
          <target state="translated">Convención sobre la denominación de las consultas</target>
        </trans-unit>
        <trans-unit id="0f4abb2dc94c20672b1e17a54e1138df9766d152" translate="yes" xml:space="preserve">
          <source>Query Renderer</source>
          <target state="translated">Query Renderer</target>
        </trans-unit>
        <trans-unit id="64c6ced3f69ca25be02a6b4eb81804275f87ea3e" translate="yes" xml:space="preserve">
          <source>QueryConfig</source>
          <target state="translated">QueryConfig</target>
        </trans-unit>
        <trans-unit id="92ed502ab1f6d9e04d58803b1ef2281c76306e49" translate="yes" xml:space="preserve">
          <source>QueryRenderer</source>
          <target state="translated">QueryRenderer</target>
        </trans-unit>
        <trans-unit id="004b0b56745c5867ceb6c95eccae46bc9634eca6" translate="yes" xml:space="preserve">
          <source>Queuing mutations to avoid race conditions.</source>
          <target state="translated">Mutaciones de cola para evitar las condiciones de la raza.</target>
        </trans-unit>
        <trans-unit id="455083cac2ae96eabe3895762b6080aa09e6afa4" translate="yes" xml:space="preserve">
          <source>Quick Start</source>
          <target state="translated">Inicio rápido</target>
        </trans-unit>
        <trans-unit id="c22fa04a8b6a77a7856984111524e39134e2d44d" translate="yes" xml:space="preserve">
          <source>RANGE_ADD</source>
          <target state="translated">RANGE_ADD</target>
        </trans-unit>
        <trans-unit id="a5c0b5daae0eddce515d43e69bbf8ebe6c085aa7" translate="yes" xml:space="preserve">
          <source>RANGE_DELETE</source>
          <target state="translated">RANGE_DELETE</target>
        </trans-unit>
        <trans-unit id="65b00e2a3b97ba71c6979a03111363ff814865c1" translate="yes" xml:space="preserve">
          <source>REQUIRED_CHILDREN</source>
          <target state="translated">REQUIRED_CHILDREN</target>
        </trans-unit>
        <trans-unit id="5ca02c4d8d1e211afacc19bb40a490a44ae66f21" translate="yes" xml:space="preserve">
          <source>React Native Configuration</source>
          <target state="translated">Reaccionar Configuración nativa</target>
        </trans-unit>
        <trans-unit id="55a38b3edc3904e22c3fddf2b60febe07b47d508" translate="yes" xml:space="preserve">
          <source>React Router</source>
          <target state="translated">Reacciona el router</target>
        </trans-unit>
        <trans-unit id="6bb70948dc19f1bb32a259898fca2dfd714e7448" translate="yes" xml:space="preserve">
          <source>React and Relay support creating arbitrarily complex applications through &lt;em&gt;composition&lt;/em&gt;. Larger components can be created by composing smaller components, helping us to create modular, robust applications. There are two aspects to composing components in Relay:</source>
          <target state="translated">React y Relay admiten la creaci&amp;oacute;n de aplicaciones arbitrariamente complejas a trav&amp;eacute;s de la &lt;em&gt;composici&amp;oacute;n&lt;/em&gt; . Se pueden crear componentes m&amp;aacute;s grandes componiendo componentes m&amp;aacute;s peque&amp;ntilde;os, lo que nos ayuda a crear aplicaciones modulares y robustas. Hay dos aspectos para componer componentes en Relay:</target>
        </trans-unit>
        <trans-unit id="1b75cb8007be8e88622c14d5835273832c1645c5" translate="yes" xml:space="preserve">
          <source>React component classes may have methods, often accessed via &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt;refs&lt;/a&gt;. Since Relay composes these component instances in a container, you need to use the &lt;code&gt;componentRef&lt;/code&gt; prop to access them:</source>
          <target state="translated">Las clases de componentes de React pueden tener m&amp;eacute;todos, a los que a menudo se accede a trav&amp;eacute;s de &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt;referencias&lt;/a&gt; . Dado que Relay compone estas instancias de componentes en un contenedor, debe usar la propiedad &lt;code&gt;componentRef&lt;/code&gt; para acceder a ellas:</target>
        </trans-unit>
        <trans-unit id="4414b37377cdce419545fa9b20f3ee40db7ae79f" translate="yes" xml:space="preserve">
          <source>Reading From Cache</source>
          <target state="translated">Lectura de la memoria caché</target>
        </trans-unit>
        <trans-unit id="65ef251f859a908e6a35bac8ecaf436651601f86" translate="yes" xml:space="preserve">
          <source>Reads the value of an attribute on a record by the field name and an object representing pre-defined argument values.</source>
          <target state="translated">Lee el valor de un atributo de un registro por el nombre de campo y un objeto que representa valores de argumento predefinidos.</target>
        </trans-unit>
        <trans-unit id="e3c57930509c5101e93fa1b560decb910e955968" translate="yes" xml:space="preserve">
          <source>Ready State</source>
          <target state="translated">Estado Listo</target>
        </trans-unit>
        <trans-unit id="e276b1dc6fd5b2e2feab8b52644788511fadacad" translate="yes" xml:space="preserve">
          <source>Ready State Change</source>
          <target state="translated">Cambio de estado listo</target>
        </trans-unit>
        <trans-unit id="db1c784524e1b54011a95823026161f7c8517fe0" translate="yes" xml:space="preserve">
          <source>Reference</source>
          <target state="translated">Reference</target>
        </trans-unit>
        <trans-unit id="a3c412dd10a0e8cb0c1899aa86989fec9f2b0413" translate="yes" xml:space="preserve">
          <source>RefetchContainer</source>
          <target state="translated">RefetchContainer</target>
        </trans-unit>
        <trans-unit id="638e5005315e0cabef699577f78933ca4cc7db6a" translate="yes" xml:space="preserve">
          <source>Refetching Data (aka &quot;See More&quot;)</source>
          <target state="translated">Recopilación de datos (alias &quot;Ver más&quot;)</target>
        </trans-unit>
        <trans-unit id="47f437a4450523abebb9b8a6327af806c6dfe250" translate="yes" xml:space="preserve">
          <source>Related APIs</source>
          <target state="translated">APIs relacionadas</target>
        </trans-unit>
        <trans-unit id="9f537f977fa2ecd1f91ff057ce1667e98ab04729" translate="yes" xml:space="preserve">
          <source>Relay</source>
          <target state="translated">Relay</target>
        </trans-unit>
        <trans-unit id="88dd507e8359bb2fd7a7702cfdc9ffaecb218c8a" translate="yes" xml:space="preserve">
          <source>Relay Classic API</source>
          <target state="translated">Relevo Clásico API</target>
        </trans-unit>
        <trans-unit id="d6764a98d68a0f585f067a880fb7f047e42e5295" translate="yes" xml:space="preserve">
          <source>Relay Classic Guides</source>
          <target state="translated">Guías clásicas de relevos</target>
        </trans-unit>
        <trans-unit id="aef721f4de8f071bed34bec165e9e8e9422d904c" translate="yes" xml:space="preserve">
          <source>Relay Classic Interfaces</source>
          <target state="translated">Interfaces clásicas de retransmisión</target>
        </trans-unit>
        <trans-unit id="8ee884f2695bfbad6a7a6dae4d48bf3348965934" translate="yes" xml:space="preserve">
          <source>Relay Compat</source>
          <target state="translated">Compatriota de relevos</target>
        </trans-unit>
        <trans-unit id="c546e3c1729605fb70a2db1deb7870608f3445c7" translate="yes" xml:space="preserve">
          <source>Relay Compat is part of &lt;code&gt;'react-relay'&lt;/code&gt; which allows you to do exactly this, providing an identical API to Relay Modern, while allowing interoperability with both runtimes.</source>
          <target state="translated">Relay Compat es parte de &lt;code&gt;'react-relay'&lt;/code&gt; que le permite hacer exactamente esto, proporcionando una API id&amp;eacute;ntica a Relay Modern, al tiempo que permite la interoperabilidad con ambos tiempos de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ddef7758830f719ed90adce373f8f83b9acf721d" translate="yes" xml:space="preserve">
          <source>Relay Compiler</source>
          <target state="translated">Compilador de Relevos</target>
        </trans-unit>
        <trans-unit id="be2b89d58206687eafd6b5f1f94bb37fb0baa8fb" translate="yes" xml:space="preserve">
          <source>Relay Containers</source>
          <target state="translated">Contenedores de retransmisión</target>
        </trans-unit>
        <trans-unit id="e0d9a631ef93e7ccb54370c0af336f421599b386" translate="yes" xml:space="preserve">
          <source>Relay DevTools is tool designed to help developers inspect their Relay state and understand how store changes overtime. Relay DevTools ships in two ways:</source>
          <target state="translated">Relay DevTools es una herramienta diseñada para ayudar a los desarrolladores a inspeccionar su estado de Relay y a entender cómo el almacén cambia con el tiempo.Relay DevTools se envía de dos maneras:</target>
        </trans-unit>
        <trans-unit id="426c398ee54f1b774dac3a903f0125ae20a5c9e6" translate="yes" xml:space="preserve">
          <source>Relay Documentation</source>
          <target state="translated">Documentación de retransmisión</target>
        </trans-unit>
        <trans-unit id="1443cd7ff63d89730c443bd7786d90a6df7d1998" translate="yes" xml:space="preserve">
          <source>Relay Environment</source>
          <target state="translated">Ambiente de relevos</target>
        </trans-unit>
        <trans-unit id="d699ddf70a567d16a64d34cd746d0cc2172e4ec9" translate="yes" xml:space="preserve">
          <source>Relay Modern</source>
          <target state="translated">Relevo Moderno</target>
        </trans-unit>
        <trans-unit id="125aa7abbb0a0bc142817f98c7e32cd828f1f474" translate="yes" xml:space="preserve">
          <source>Relay Modern comes with automatic Flow type generation for the fragments used in Relay containers based on the GraphQL schema. Using these Flow types can help make an application less error-prone, by ensuring all possible &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; cases are considered even if they don't happen frequently.</source>
          <target state="translated">Relay Modern viene con generaci&amp;oacute;n autom&amp;aacute;tica de tipo de flujo para los fragmentos usados ​​en los contenedores de Relay basados ​​en el esquema GraphQL. El uso de estos tipos de flujo puede ayudar a que una aplicaci&amp;oacute;n sea menos propensa a errores, al garantizar que se consideren todos los posibles casos &lt;code&gt;null&lt;/code&gt; o &lt;code&gt;undefined&lt;/code&gt; incluso si no ocurren con frecuencia.</target>
        </trans-unit>
        <trans-unit id="fe351802f53838c0d3ff7ec944643ab9992b7020" translate="yes" xml:space="preserve">
          <source>Relay Modern containers combine standard React components with a description of their data requirements, expressed as one or more GraphQL fragments. Each container is itself a standard React component that can be rendered using the standard React API (e.g. &lt;code&gt;&amp;lt;YourComponent prop={...} /&amp;gt;&lt;/code&gt;). When rendered, a container will read the data for its fragment from the Relay cache. As the fragment data changes - for example due to a mutation, subscription, or updated query response - the container will automatically re-render the component.</source>
          <target state="translated">Los contenedores Relay Modern combinan componentes React est&amp;aacute;ndar con una descripci&amp;oacute;n de sus requisitos de datos, expresados ​​como uno o m&amp;aacute;s fragmentos GraphQL. Cada contenedor es en s&amp;iacute; mismo un componente React est&amp;aacute;ndar que se puede renderizar usando la API React est&amp;aacute;ndar (por ejemplo, &lt;code&gt;&amp;lt;YourComponent prop={...} /&amp;gt;&lt;/code&gt; ). Cuando se procesa, un contenedor leer&amp;aacute; los datos de su fragmento del cach&amp;eacute; de retransmisi&amp;oacute;n. A medida que cambian los datos del fragmento, por ejemplo, debido a una mutaci&amp;oacute;n, suscripci&amp;oacute;n o respuesta de consulta actualizada, el contenedor volver&amp;aacute; a representar autom&amp;aacute;ticamente el componente.</target>
        </trans-unit>
        <trans-unit id="b783df53e509475b97db41df7f512b5cdf7adf0d" translate="yes" xml:space="preserve">
          <source>Relay Modern enables a variety of new features. Some are available via the Compat API, while others require upgrading fully to the Modern runtime. See &lt;a href=&quot;new-in-relay-modern&quot;&gt;what's new in Relay Modern&lt;/a&gt; for more details.</source>
          <target state="translated">Relay Modern habilita una variedad de caracter&amp;iacute;sticas nuevas. Algunos est&amp;aacute;n disponibles a trav&amp;eacute;s de Compat API, mientras que otros requieren una actualizaci&amp;oacute;n completa al tiempo de ejecuci&amp;oacute;n moderno. Vea &lt;a href=&quot;new-in-relay-modern&quot;&gt;las novedades de Relay Modern&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="02ee7840306dae496dace1fe86750e32e8b8c807" translate="yes" xml:space="preserve">
          <source>Relay Modern is a new version of Relay designed from the ground up to be easier to use, more extensible and, most of all, able to improve performance on mobile devices. Relay Modern accomplishes this with static queries and ahead-of-time code generation.</source>
          <target state="translated">Relay Modern es una nueva versión de Relay diseñada desde cero para ser más fácil de usar,más extensible y,sobre todo,capaz de mejorar el rendimiento en los dispositivos móviles.Relay Modern logra esto con consultas estáticas y generación de código anticipado.</target>
        </trans-unit>
        <trans-unit id="451008aa294b51a951e1a6a9073f36b4296c782c" translate="yes" xml:space="preserve">
          <source>Relay Modern requires a Babel plugin to convert GraphQL to runtime artifacts:</source>
          <target state="translated">Relay Modern requiere un plugin Babel para convertir GraphQL en artefactos de tiempo de ejecución:</target>
        </trans-unit>
        <trans-unit id="0d2944c329394a1cfc563059eabe3a8681e7e2bc" translate="yes" xml:space="preserve">
          <source>Relay Modern supports GraphQL Subscriptions, using the imperative update API to allow modifications to the store whenever a payload is received. It also features experimental support for GraphQL Live Queries via polling.</source>
          <target state="translated">Relay Modern apoya las suscripciones de GraphQL,utilizando la actualización imperativa de la API para permitir modificaciones en la tienda cada vez que se recibe una carga útil.También cuenta con soporte experimental para las Consultas en vivo de GraphQL a través de encuestas.</target>
        </trans-unit>
        <trans-unit id="372f8f866ff79038477865a8b1e68cc2436d4212" translate="yes" xml:space="preserve">
          <source>Relay Modern supports the following directives</source>
          <target state="translated">Relay Modern apoya las siguientes directivas</target>
        </trans-unit>
        <trans-unit id="4fcb24b9dcd43c8532db4d056e1af150670c742a" translate="yes" xml:space="preserve">
          <source>Relay Modern uses the Relay Compiler to convert &lt;code&gt;graphql&lt;/code&gt; literals into generated files that live alongside your source files.</source>
          <target state="translated">Relay Modern usa Relay Compiler para convertir literales &lt;code&gt;graphql&lt;/code&gt; en archivos generados que viven junto a sus archivos fuente.</target>
        </trans-unit>
        <trans-unit id="604519e05335c47d085692b3d5c93c6c0cf24a81" translate="yes" xml:space="preserve">
          <source>Relay Modern's ahead-of-time compilation requires the new Relay Compiler:</source>
          <target state="translated">La compilación anticipada de Relay Modern requiere el nuevo Compilador de Relevos:</target>
        </trans-unit>
        <trans-unit id="d344ad7e0e46f9326c5126f3f06dc4800f23f6c8" translate="yes" xml:space="preserve">
          <source>Relay Modern's core is essentially an un-opinionated store for GraphQL data. It can be used independent of rendering views using React and can be extended to be used with other frameworks.</source>
          <target state="translated">El núcleo de Relay Modern es esencialmente un almacén sin opinar para los datos de GraphQL.Puede ser usado independientemente de las vistas de renderizado usando React y puede ser extendido para ser usado con otros marcos.</target>
        </trans-unit>
        <trans-unit id="881bc62d6225c769dfa7c14c7288aba40be25da2" translate="yes" xml:space="preserve">
          <source>Relay Specification</source>
          <target state="translated">Especificación del relé</target>
        </trans-unit>
        <trans-unit id="48799f13f2ac51d5720b5a4e683e4a8844cdd877" translate="yes" xml:space="preserve">
          <source>Relay allows developers to annotate their React components with data dependencies by creating &lt;strong&gt;containers&lt;/strong&gt;. These are regular React components that wrap the originals. A key design constraint is that React components are meant to be reusable, so Relay containers must be too. For example, a &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; component might implement a view for rendering any &lt;code&gt;Story&lt;/code&gt; item. The actual story to render would be determined by the data passed to the component: &lt;code&gt;&amp;lt;Story story={ ... } /&amp;gt;&lt;/code&gt;. The equivalent in GraphQL are &lt;strong&gt;fragments&lt;/strong&gt;: named query snippets that specify what data to fetch &lt;em&gt;for an object of a given type&lt;/em&gt;. We might describe the data needed by &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; as follows:</source>
          <target state="translated">Relay permite a los desarrolladores anotar sus componentes React con dependencias de datos creando &lt;strong&gt;contenedores&lt;/strong&gt; . Estos son componentes regulares de React que envuelven los originales. Una restricci&amp;oacute;n de dise&amp;ntilde;o clave es que los componentes de React est&amp;aacute;n destinados a ser reutilizables, por lo que los contenedores de Relay tambi&amp;eacute;n deben serlo. Por ejemplo, un componente &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; podr&amp;iacute;a implementar una vista para representar cualquier elemento de &lt;code&gt;Story&lt;/code&gt; . La historia real a renderizar estar&amp;iacute;a determinada por los datos pasados ​​al componente: &lt;code&gt;&amp;lt;Story story={ ... } /&amp;gt;&lt;/code&gt; . Los equivalentes en GraphQL son &lt;strong&gt;fragmentos&lt;/strong&gt; : &lt;strong&gt;fragmentos de&lt;/strong&gt; consulta con nombre que especifican qu&amp;eacute; datos buscar &lt;em&gt;para un objeto de un tipo determinado&lt;/em&gt; . Podr&amp;iacute;amos describir los datos que necesita &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="254c939fb761720339a3dd3ad863697bebf60c3f" translate="yes" xml:space="preserve">
          <source>Relay also goes further: it uses opaque identifiers on &lt;code&gt;props&lt;/code&gt; to validate that we've explicitly fetched the data for a component before rendering it. If &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; renders &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; but forgets to include its fragment, Relay will warn that the data for &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; is missing. In fact, Relay will warn &lt;em&gt;even if&lt;/em&gt; some other component happened to fetch the same data required by &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt;. This warning tells us that although things &lt;em&gt;might&lt;/em&gt; work now they're highly likely to break later.</source>
          <target state="translated">Relay tambi&amp;eacute;n va m&amp;aacute;s all&amp;aacute;: utiliza identificadores opacos en los &lt;code&gt;props&lt;/code&gt; para validar que hemos obtenido expl&amp;iacute;citamente los datos de un componente antes de renderizarlo. Si &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; muestra &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; pero se olvida de incluir su fragmento, Relay advertir&amp;aacute; que faltan los datos de &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; . De hecho, Relay advertir&amp;aacute; &lt;em&gt;incluso si&lt;/em&gt; alg&amp;uacute;n otro componente &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; los mismos datos requeridos por &amp;lt;StoryHeader&amp;gt; . Esta advertencia nos dice que aunque las cosas &lt;em&gt;podr&amp;iacute;an&lt;/em&gt; funcionar ahora, es muy probable que se rompan m&amp;aacute;s tarde.</target>
        </trans-unit>
        <trans-unit id="c212579d453e98cbd0a4dcbacffef8088e5ab28f" translate="yes" xml:space="preserve">
          <source>Relay also lets us completely replace the default network layer.</source>
          <target state="translated">La retransmisión también nos permite reemplazar completamente la capa de red por defecto.</target>
        </trans-unit>
        <trans-unit id="f200764a518868ca3b31ea98a1353b5d9f2dd1fc" translate="yes" xml:space="preserve">
          <source>Relay can be thought of as two parts which work together: an API for building data-driven components and a runtime which fetches and stores data from GraphQL to populate your app. Relay Modern brings both a new API and a new runtime.</source>
          <target state="translated">La retransmisión puede pensarse como dos partes que funcionan juntas:una API para construir componentes basados en datos y un tiempo de ejecución que recupera y almacena datos de GraphQL para poblar su aplicación.Relay Modern trae una nueva API y un nuevo tiempo de ejecución.</target>
        </trans-unit>
        <trans-unit id="edc443fe11fe9992f4eb82855f77153b4705147b" translate="yes" xml:space="preserve">
          <source>Relay containers are created using &lt;code&gt;Relay.createContainer&lt;/code&gt;.</source>
          <target state="translated">Los contenedores de retransmisi&amp;oacute;n se crean utilizando &lt;code&gt;Relay.createContainer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2748ac007f286936a91fb67b3ca6e11462a7fe21" translate="yes" xml:space="preserve">
          <source>Relay containers are higher-order components &amp;mdash; &lt;code&gt;Relay.createContainer&lt;/code&gt; is a function that takes a React component as input and returns a new component as output. This means that the container can manage data fetching and resolution logic without interfering with the &lt;code&gt;state&lt;/code&gt; of the inner component.</source>
          <target state="translated">Los contenedores de rel&amp;eacute; son componentes de orden superior: &lt;code&gt;Relay.createContainer&lt;/code&gt; es una funci&amp;oacute;n que toma un componente React como entrada y devuelve un nuevo componente como salida. Esto significa que el contenedor puede gestionar la obtenci&amp;oacute;n de datos y la l&amp;oacute;gica de resoluci&amp;oacute;n sin interferir con el &lt;code&gt;state&lt;/code&gt; del componente interno.</target>
        </trans-unit>
        <trans-unit id="1c357d13b1cce8a1c46ccc30afeeb5fd2f902c5a" translate="yes" xml:space="preserve">
          <source>Relay containers provide a static &lt;code&gt;getFragment()&lt;/code&gt; method that returns a reference to that component's fragment:</source>
          <target state="translated">Los contenedores de retransmisi&amp;oacute;n proporcionan un m&amp;eacute;todo &lt;code&gt;getFragment()&lt;/code&gt; est&amp;aacute;tico que devuelve una referencia al fragmento de ese componente:</target>
        </trans-unit>
        <trans-unit id="5a410cc37e6396592aa37827cec122428cb2d984" translate="yes" xml:space="preserve">
          <source>Relay couples React with GraphQL and develops the idea of encapsulation further. It allows components to specify what data they need and the Relay framework provides the data. This makes the data needs of inner components opaque and allows composition of those needs. Thinking about what data an app needs becomes localized to the component making it easier to reason about what fields are needed or no longer needed.</source>
          <target state="translated">Las parejas de relés reaccionan con GraphQL y desarrollan la idea de encapsulación más allá.Permite que los componentes especifiquen qué datos necesitan y el marco del relé proporciona los datos.Esto hace que las necesidades de datos de los componentes internos sean opacas y permite la composición de esas necesidades.Pensar qué datos necesita una aplicación se convierte en algo localizado en el componente,lo que facilita el razonamiento sobre qué campos se necesitan o ya no se necesitan.</target>
        </trans-unit>
        <trans-unit id="934fd827600b774b11b92dcf9269d690870fb9bb" translate="yes" xml:space="preserve">
          <source>Relay ensures that this data is available before the component is rendered.</source>
          <target state="translated">El relé asegura que estos datos estén disponibles antes de que el componente sea renderizado.</target>
        </trans-unit>
        <trans-unit id="b556a8542493c85c6ab714e7efdb1e48fb0c7ece" translate="yes" xml:space="preserve">
          <source>Relay exposes the following APIs to create subscriptions.</source>
          <target state="translated">La retransmisión expone las siguientes API para crear suscripciones.</target>
        </trans-unit>
        <trans-unit id="8076714ed2f663c62d9c70223ceef029bffc6fc4" translate="yes" xml:space="preserve">
          <source>Relay exposes the following APIs to perform mutations.</source>
          <target state="translated">El relé expone a los siguientes API para realizar mutaciones.</target>
        </trans-unit>
        <trans-unit id="9a9f6b192104115130a465f5d1b347425625bd6d" translate="yes" xml:space="preserve">
          <source>Relay fragments, mutations, and queries must be specified using ES6 template literals tagged with &lt;code&gt;Relay.QL&lt;/code&gt;. For example:</source>
          <target state="translated">Los fragmentos de retransmisi&amp;oacute;n, las mutaciones y las consultas deben especificarse utilizando literales de plantilla ES6 etiquetados con &lt;code&gt;Relay.QL&lt;/code&gt; . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="f94ab02e4b36f1c69a9b192786b3451a5578f530" translate="yes" xml:space="preserve">
          <source>Relay has a network layer abstraction that separates mutations and queries from the actual machinery that sends requests to the GraphQL server. This gives us the flexibility to configure or even completely replace the default network layer via injection.</source>
          <target state="translated">El relé tiene una abstracción de la capa de red que separa las mutaciones y las consultas de la maquinaria real que envía las solicitudes al servidor GraphQL.Esto nos da la flexibilidad de configurar o incluso sustituir completamente la capa de red por defecto a través de la inyección.</target>
        </trans-unit>
        <trans-unit id="3e093a4c47e1f292b6f2a4693a9f28a6e839881f" translate="yes" xml:space="preserve">
          <source>Relay implements several variations of &lt;strong&gt;query traversal&lt;/strong&gt;: operations that walk a query alongside some other data such as the cache or a response payload. For example, when a query is fetched Relay performs a &quot;diff&quot; traversal to determine what fields are missing (much like React diffs virtual DOM trees). This can reduce the amount of data fetched in many common cases and even allow Relay to avoid network requests at all when queries are fully cached.</source>
          <target state="translated">Relay implementa varias variaciones del &lt;strong&gt;recorrido&lt;/strong&gt; de &lt;strong&gt;consultas&lt;/strong&gt; : operaciones que recorren una consulta junto con otros datos, como la memoria cach&amp;eacute; o una carga &amp;uacute;til de respuesta. Por ejemplo, cuando se recupera una consulta, Relay realiza un recorrido &quot;diferencial&quot; para determinar qu&amp;eacute; campos faltan (al igual que React diffs &amp;aacute;rboles DOM virtuales). Esto puede reducir la cantidad de datos recuperados en muchos casos comunes e incluso permitir que Relay evite las solicitudes de red cuando las consultas est&amp;aacute;n completamente almacenadas en cach&amp;eacute;.</target>
        </trans-unit>
        <trans-unit id="1f7225f6558a177e37be9ba84410fe63b32cde06" translate="yes" xml:space="preserve">
          <source>Relay introduces two new classes of objects: &lt;code&gt;RelayContainer&lt;/code&gt; and &lt;code&gt;Relay.Route&lt;/code&gt;. &lt;code&gt;Relay.PropTypes&lt;/code&gt; provides prop validators used to assert that props are of these types.</source>
          <target state="translated">Relay presenta dos nuevas clases de objetos: &lt;code&gt;RelayContainer&lt;/code&gt; y &lt;code&gt;Relay.Route&lt;/code&gt; . &lt;code&gt;Relay.PropTypes&lt;/code&gt; proporciona validadores de accesorios que se utilizan para afirmar que los accesorios son de este tipo.</target>
        </trans-unit>
        <trans-unit id="97f52c1bbd17e02a2c6367d7476a6ac21c258276" translate="yes" xml:space="preserve">
          <source>Relay is pre-configured to use a default network layer that works with &lt;a href=&quot;https://github.com/graphql/express-graphql&quot;&gt;express-graphql&lt;/a&gt;. This default network layer is exposed via &lt;code&gt;Relay.DefaultNetworkLayer&lt;/code&gt;.</source>
          <target state="translated">Relay est&amp;aacute; preconfigurado para usar una capa de red predeterminada que funciona con &lt;a href=&quot;https://github.com/graphql/express-graphql&quot;&gt;express-graphql&lt;/a&gt; . Esta capa de red predeterminada se expone a trav&amp;eacute;s de &lt;code&gt;Relay.DefaultNetworkLayer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54171fd2fa20a9c4bec1be11d3879a92bfa7df55" translate="yes" xml:space="preserve">
          <source>Relay makes use of GraphQL mutations; operations that enable us to mutate data on the client and server. To create a mutation for use in our app, we subclass &lt;code&gt;Relay.Mutation&lt;/code&gt; and implement, at minimum, the four abstract methods listed below.</source>
          <target state="translated">Relay hace uso de mutaciones GraphQL; operaciones que nos permiten mutar datos en el cliente y el servidor. Para crear una mutaci&amp;oacute;n para usar en nuestra aplicaci&amp;oacute;n, subclasemos &lt;code&gt;Relay.Mutation&lt;/code&gt; e implementamos, como m&amp;iacute;nimo, los cuatro m&amp;eacute;todos abstractos que se enumeran a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8dd31c1805e052611332ba16c37162381a4a626a" translate="yes" xml:space="preserve">
          <source>Relay routes don't really implement any URL routing specific logic or work with History API. In the future we will maybe rename RelayRoute to be something more like RelayQueryRoots or RelayQueryConfig.</source>
          <target state="translated">Las rutas de retransmisión no implementan realmente ninguna lógica específica de enrutamiento de URL ni funcionan con la API de Historial.En el futuro tal vez cambiemos el nombre de RelayRoute a algo más parecido a RelayQueryRoots o RelayQueryConfig.</target>
        </trans-unit>
        <trans-unit id="589e99096a0b6781ff51073c2234321dc486a027" translate="yes" xml:space="preserve">
          <source>Relay routes don't really implement any URL routing specific logic or work with History API. In the future we will maybe rename RelayRoute to be something more like RelayQueryRoots or RelayQueryConfig. For more information around why Relay doesn't provide URL-routing features, and suggestions for such solutions, see &lt;a href=&quot;https://medium.com/@cpojer/relay-and-routing-36b5439bad9&quot;&gt;this post&lt;/a&gt;.</source>
          <target state="translated">Las rutas de retransmisi&amp;oacute;n realmente no implementan ninguna l&amp;oacute;gica espec&amp;iacute;fica de enrutamiento de URL ni funcionan con la API de historial. En el futuro, quiz&amp;aacute;s cambiemos el nombre de RelayRoute para que sea algo m&amp;aacute;s como RelayQueryRoots o RelayQueryConfig. Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre por qu&amp;eacute; Relay no proporciona funciones de enrutamiento de URL y sugerencias para tales soluciones, consulte &lt;a href=&quot;https://medium.com/@cpojer/relay-and-routing-36b5439bad9&quot;&gt;esta publicaci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ef480060aa47ef1a958a5c003bdd30a4e3354405" translate="yes" xml:space="preserve">
          <source>Relay speaks to GraphQL servers through a network layer. The &lt;a href=&quot;guides-network-layer&quot;&gt;network layer&lt;/a&gt; that ships with Relay is compatible with express-graphql out of the box, and will continue to evolve as we add new features to the transport.</source>
          <target state="translated">Relay habla con los servidores GraphQL a trav&amp;eacute;s de una capa de red. La &lt;a href=&quot;guides-network-layer&quot;&gt;capa de red&lt;/a&gt; que se env&amp;iacute;a con Relay es compatible con express-graphql lista para usar y continuar&amp;aacute; evolucionando a medida que agreguemos nuevas funciones al transporte.</target>
        </trans-unit>
        <trans-unit id="256546be326de4c5533a50332088277d259f1856" translate="yes" xml:space="preserve">
          <source>Relay updates the component whenever the underlying data has changed.</source>
          <target state="translated">El relé actualiza el componente cuando los datos subyacentes han cambiado.</target>
        </trans-unit>
        <trans-unit id="7f2f7458912547fdfa17a726b3bd42f898c10724" translate="yes" xml:space="preserve">
          <source>Relay uses a &lt;strong&gt;Babel&lt;/strong&gt; plugin to convert &lt;code&gt;graphql&lt;/code&gt; literals into requires of the code generated by Relay Compiler.</source>
          <target state="translated">Relay utiliza un complemento de &lt;strong&gt;Babel&lt;/strong&gt; para convertir literales &lt;code&gt;graphql&lt;/code&gt; en requisitos del c&amp;oacute;digo generado por Relay Compiler.</target>
        </trans-unit>
        <trans-unit id="9cbd2a4fac093602e7724812345c1426293f1cd9" translate="yes" xml:space="preserve">
          <source>Relay uses a &lt;strong&gt;babel&lt;/strong&gt; plugin to convert from &lt;code&gt;Relay.QL&lt;/code&gt; string templates to JavaScript code that describes each query and includes data from the GraphQL schema.</source>
          <target state="translated">Relay utiliza un complemento de &lt;strong&gt;babel&lt;/strong&gt; para convertir las plantillas de cadenas de &lt;code&gt;Relay.QL&lt;/code&gt; en c&amp;oacute;digo JavaScript que describe cada consulta e incluye datos del esquema GraphQL.</target>
        </trans-unit>
        <trans-unit id="5ab5569c1247a6342fa21f23bd4fe7b1d8d672c4" translate="yes" xml:space="preserve">
          <source>Relay uses a common pattern for mutations, where they are root fields on the mutation type with a single argument, &lt;code&gt;input&lt;/code&gt;, and where the input and output both contain a client mutation identifier used to reconcile requests and responses.</source>
          <target state="translated">Relay utiliza un patr&amp;oacute;n com&amp;uacute;n para las mutaciones, donde son campos ra&amp;iacute;z en el tipo de mutaci&amp;oacute;n con un solo argumento, &lt;code&gt;input&lt;/code&gt; , y donde la entrada y la salida contienen un identificador de mutaci&amp;oacute;n del cliente que se utiliza para conciliar solicitudes y respuestas.</target>
        </trans-unit>
        <trans-unit id="dd4a65f25979a2d6ac22ff73e832b56882a6731f" translate="yes" xml:space="preserve">
          <source>Relay uses all of this functionality to build out abstractions around connections, to make these easy to work with efficiently without having to manually manage cursors on the client.</source>
          <target state="translated">Relay utiliza toda esta funcionalidad para construir abstracciones alrededor de las conexiones,para hacerlas fáciles de trabajar eficientemente sin tener que manejar manualmente los cursores en el cliente.</target>
        </trans-unit>
        <trans-unit id="7215a332ba837f6189ba19038b406a179e835435" translate="yes" xml:space="preserve">
          <source>Relay uses routes to define entry points into a Relay application.</source>
          <target state="translated">Relevo utiliza rutas para definir los puntos de entrada en una aplicación de Relevo.</target>
        </trans-unit>
        <trans-unit id="e84f12bb76c08fcf1ebc1d56caf39b1024a1f70b" translate="yes" xml:space="preserve">
          <source>Relay v1.0 introduces the Relay Modern API:</source>
          <target state="translated">Relay v1.0 introduce el Relay Modern API:</target>
        </trans-unit>
        <trans-unit id="7c3c5e271e633d2cf5f26344b18759ea44b95380" translate="yes" xml:space="preserve">
          <source>Relay wraps its core processing functions inside lightweight tasks, which by default are executed immediately (i.e. synchronously). In order to customize &lt;em&gt;when&lt;/em&gt; these tasks are run - for example to avoid interrupting an animation during a touch gesture - applications can provide a custom scheduling function.</source>
          <target state="translated">Relay envuelve sus funciones centrales de procesamiento dentro de tareas ligeras, que por defecto se ejecutan inmediatamente (es decir, sincr&amp;oacute;nicamente). Para personalizar &lt;em&gt;cu&amp;aacute;ndo&lt;/em&gt; se ejecutan estas tareas, por ejemplo, para evitar interrumpir una animaci&amp;oacute;n durante un gesto t&amp;aacute;ctil, las aplicaciones pueden proporcionar una funci&amp;oacute;n de programaci&amp;oacute;n personalizada.</target>
        </trans-unit>
        <trans-unit id="576baa5c970e0023c6b7f930fc5b22d07e80b876" translate="yes" xml:space="preserve">
          <source>Relay's approach to data-fetching is heavily inspired by our experience with React. In particular, React breaks complex interfaces into reusable &lt;strong&gt;components&lt;/strong&gt;, allowing developers to reason about discrete units of an application in isolation, and reducing the coupling between disparate parts of an application. Even more important is that these components are &lt;strong&gt;declarative&lt;/strong&gt;: they allow developers to specify &lt;em&gt;what&lt;/em&gt; the UI should look like for a given state, and not have to worry about &lt;em&gt;how&lt;/em&gt; to show that UI. Unlike previous approaches that used imperative commands to manipulate native views (e.g. the DOM), React uses a UI description to automatically determine the necessary commands.</source>
          <target state="translated">El enfoque de Relay para la b&amp;uacute;squeda de datos est&amp;aacute; fuertemente inspirado en nuestra experiencia con React. En particular, React divide interfaces complejas en &lt;strong&gt;componentes&lt;/strong&gt; reutilizables , lo que permite a los desarrolladores razonar sobre unidades discretas de una aplicaci&amp;oacute;n de forma aislada y reduce el acoplamiento entre partes dispares de una aplicaci&amp;oacute;n. A&amp;uacute;n m&amp;aacute;s importante es que estos componentes son &lt;strong&gt;declarativos&lt;/strong&gt; : permiten a los desarrolladores especificar &lt;em&gt;c&amp;oacute;mo&lt;/em&gt; deber&amp;iacute;a verse la interfaz de usuario para un estado determinado y no tener que preocuparse por &lt;em&gt;c&amp;oacute;mo&lt;/em&gt; mostrar esa interfaz de usuario. A diferencia de los enfoques anteriores que usaban comandos imperativos para manipular vistas nativas (por ejemplo, el DOM), React usa una descripci&amp;oacute;n de la interfaz de usuario para determinar autom&amp;aacute;ticamente los comandos necesarios.</target>
        </trans-unit>
        <trans-unit id="6b33d0db31f7976b67c0c833688c3f1a2f3ed1a7" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation</source>
          <target state="translated">Relay.GraphQLMutation</target>
        </trans-unit>
        <trans-unit id="1dd1eeecd4591e6fc51ed50ccec4372072ef5f58" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation#applyOptimistic()</source>
          <target state="translated">Relay.GraphQLMutation#applyOptimistic()</target>
        </trans-unit>
        <trans-unit id="778c7e41e609c680486529c141869bd60529ad4f" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation#commit()</source>
          <target state="translated">Relay.GraphQLMutation#commit()</target>
        </trans-unit>
        <trans-unit id="3dd83b3b4baca74ae215635dc8057361bd27c698" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation#constructor()</source>
          <target state="translated">Relay.GraphQLMutation#constructor()</target>
        </trans-unit>
        <trans-unit id="c60b9c934ff71ffb2a3ed3d72c60871bbe0e468e" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation#rollback()</source>
          <target state="translated">Relay.GraphQLMutation#rollback()</target>
        </trans-unit>
        <trans-unit id="3340870222c54d4e58da2c45216a0f9201d39a18" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation.create()</source>
          <target state="translated">Relay.GraphQLMutation.create()</target>
        </trans-unit>
        <trans-unit id="a23c2d405f689b19dfd1fd7c28df5c48a68add1e" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation.createWithFiles()</source>
          <target state="translated">Relay.GraphQLMutation.createWithFiles()</target>
        </trans-unit>
        <trans-unit id="03551f79ebf3cd05d7c2ceaa3bea55c92b64e6d0" translate="yes" xml:space="preserve">
          <source>Relay.Mutation</source>
          <target state="translated">Relay.Mutation</target>
        </trans-unit>
        <trans-unit id="3ba32adda774e85164beb595e60d2e216978176e" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#constructor()</source>
          <target state="translated">Relay.Mutation#constructor()</target>
        </trans-unit>
        <trans-unit id="04100c1f256b9742428fc3ccbb91ce26474f7916" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getCollisionKey()</source>
          <target state="translated">Relay.Mutation#getCollisionKey()</target>
        </trans-unit>
        <trans-unit id="6239b4b0c4bd148ddc88ff80a2414323538280f1" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getConfigs()</source>
          <target state="translated">Relay.Mutation#getConfigs()</target>
        </trans-unit>
        <trans-unit id="ef63d6cc19f0b592de123cd60ec1e1b1998d6f17" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getFatQuery()</source>
          <target state="translated">Relay.Mutation#getFatQuery()</target>
        </trans-unit>
        <trans-unit id="712207e70740181f3ab2120dc0f2bcc301c5f54e" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getFiles()</source>
          <target state="translated">Relay.Mutation#getFiles()</target>
        </trans-unit>
        <trans-unit id="e97a189b3ae9338d83696e14598b587f01455562" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getMutation()</source>
          <target state="translated">Relay.Mutation#getMutation()</target>
        </trans-unit>
        <trans-unit id="9ef4e47c4ce8d138fc8484b73b762f8325ab6d50" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getOptimisticConfigs()</source>
          <target state="translated">Relay.Mutation#getOptimisticConfigs()</target>
        </trans-unit>
        <trans-unit id="9c72c0ca95feabd409adccf873cc396f84f49fa7" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getOptimisticResponse()</source>
          <target state="translated">Relay.Mutation#getOptimisticResponse()</target>
        </trans-unit>
        <trans-unit id="0407ffada104593511af47973fbf4f161321629f" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getVariables()</source>
          <target state="translated">Relay.Mutation#getVariables()</target>
        </trans-unit>
        <trans-unit id="25241731d9b8a5e3bb893a8a7166ea0d07b29738" translate="yes" xml:space="preserve">
          <source>Relay.Mutation.fragments</source>
          <target state="translated">Relay.Mutation.fragments</target>
        </trans-unit>
        <trans-unit id="b7852fe98838e6fc1d72feab70dfa349933b9a4f" translate="yes" xml:space="preserve">
          <source>Relay.Mutation.getFragment()</source>
          <target state="translated">Relay.Mutation.getFragment()</target>
        </trans-unit>
        <trans-unit id="d9618c47616902c437879ab1fb98a8eb932feeeb" translate="yes" xml:space="preserve">
          <source>Relay.Mutation.initialVariables</source>
          <target state="translated">Relay.Mutation.initialVariables</target>
        </trans-unit>
        <trans-unit id="88607afefb79afbc0a5c6c2204c3c59784086c6d" translate="yes" xml:space="preserve">
          <source>Relay.Mutation.prepareVariables</source>
          <target state="translated">Relay.Mutation.prepareVariables</target>
        </trans-unit>
        <trans-unit id="15cdd01f7f3228bf705c67fcca4cc7376e38847b" translate="yes" xml:space="preserve">
          <source>Relay.PropTypes</source>
          <target state="translated">Relay.PropTypes</target>
        </trans-unit>
        <trans-unit id="0af8bcf2b06b250091c5a6a9f45a93a8ec335270" translate="yes" xml:space="preserve">
          <source>Relay.PropTypes.QueryConfig: ReactPropTypeValidator</source>
          <target state="translated">Relevo.PropTypes.QueryConfig:ReactPropTypeValidator</target>
        </trans-unit>
        <trans-unit id="991536fff9faf615e80c1b42bfda61b3395074a1" translate="yes" xml:space="preserve">
          <source>Relay.QL</source>
          <target state="translated">Relay.QL</target>
        </trans-unit>
        <trans-unit id="e66127f684a064c2b23590835fd5fc4afce5e3bc" translate="yes" xml:space="preserve">
          <source>Relay.Renderer</source>
          <target state="translated">Relay.Renderer</target>
        </trans-unit>
        <trans-unit id="1e64d297283159c1fd5f3c0f4f7f2590f52aeaf0" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#Container</source>
          <target state="translated">Relay.Renderer#Container</target>
        </trans-unit>
        <trans-unit id="0f68d914b2de005998fdb01ba1b1095a495e227d" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#environment</source>
          <target state="translated">Relay.Renderer#environment</target>
        </trans-unit>
        <trans-unit id="8e4cc916528c14e528833e3f79df2da75fd53acb" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#forceFetch</source>
          <target state="translated">Relay.Renderer#forceFetch</target>
        </trans-unit>
        <trans-unit id="bf0a7bc1a436c9a32f0f42831033b65d5cfbaf43" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#onReadyStateChange</source>
          <target state="translated">Relay.Renderer#onReadyStateChange</target>
        </trans-unit>
        <trans-unit id="9c4d750f130c80ae940ddef73d72538928767978" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#queryConfig</source>
          <target state="translated">Relay.Renderer#queryConfig</target>
        </trans-unit>
        <trans-unit id="ff227ea702919a6f75cb559ade588c7d11c20c78" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#render</source>
          <target state="translated">Relay.Renderer#render</target>
        </trans-unit>
        <trans-unit id="2761fdabd570b4cb3fdee157bed2ad5cb9ae4930" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer</source>
          <target state="translated">Relay.RootContainer</target>
        </trans-unit>
        <trans-unit id="543cce18705fbddda91e09c015e6da78c821e550" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#Component</source>
          <target state="translated">Relay.RootContainer#Component</target>
        </trans-unit>
        <trans-unit id="4c1d8599b11aa80027feab65c33b5f34aece2fe8" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#forceFetch</source>
          <target state="translated">Relay.RootContainer#forceFetch</target>
        </trans-unit>
        <trans-unit id="69120820a45037f7a9e51a705842b61000d0ac96" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#onReadyStateChange</source>
          <target state="translated">Relay.RootContainer#onReadyStateChange</target>
        </trans-unit>
        <trans-unit id="0b9faeb15a496f220a6b405a981a20f8ef453965" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#renderFailure</source>
          <target state="translated">Relay.RootContainer#renderFailure</target>
        </trans-unit>
        <trans-unit id="7bd3ce353967f7aff355ff3522f40b703a8bd047" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#renderFetched</source>
          <target state="translated">Relay.RootContainer#renderFetched</target>
        </trans-unit>
        <trans-unit id="8e6dba1eefc9476de73a3eb76f6a4bb45f2d9827" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#renderLoading</source>
          <target state="translated">Relay.RootContainer#renderLoading</target>
        </trans-unit>
        <trans-unit id="a9647a1d13d1b00fb81a049cb69e0f50d9005610" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#route</source>
          <target state="translated">Relay.RootContainer#route</target>
        </trans-unit>
        <trans-unit id="2163890d6b8486ab713e8307739f1fc8ffdc4051" translate="yes" xml:space="preserve">
          <source>Relay.Route</source>
          <target state="translated">Relay.Route</target>
        </trans-unit>
        <trans-unit id="ec4ec0225d1b12f051db712106148d8b26db80c7" translate="yes" xml:space="preserve">
          <source>Relay.Route#constructor()</source>
          <target state="translated">Relay.Route#constructor()</target>
        </trans-unit>
        <trans-unit id="933d2afe910e8eed75954f1ef8511fc9c8104ede" translate="yes" xml:space="preserve">
          <source>Relay.Route.paramDefinitions</source>
          <target state="translated">Relay.Route.paramDefinitions</target>
        </trans-unit>
        <trans-unit id="be2c5425ec7dbd5886d4716f82a79360b73375a7" translate="yes" xml:space="preserve">
          <source>Relay.Route.prepareParams</source>
          <target state="translated">Relay.Route.prepareParams</target>
        </trans-unit>
        <trans-unit id="632587b7cd190cd1537600ee207e20b1ff9030d5" translate="yes" xml:space="preserve">
          <source>Relay.Route.queries</source>
          <target state="translated">Relay.Route.queries</target>
        </trans-unit>
        <trans-unit id="90af1f420232cc590b9eb96c3c9344d637dded41" translate="yes" xml:space="preserve">
          <source>Relay.Route.routeName</source>
          <target state="translated">Relay.Route.routeName</target>
        </trans-unit>
        <trans-unit id="596c88b6dd79bb8e709c7b945308e399ac2abc3a" translate="yes" xml:space="preserve">
          <source>Relay.Store</source>
          <target state="translated">Relay.Store</target>
        </trans-unit>
        <trans-unit id="1ca8451821663a9beeafb5041c9c0bfdf4aff046" translate="yes" xml:space="preserve">
          <source>Relay.Store.applyUpdate()</source>
          <target state="translated">Relay.Store.applyUpdate()</target>
        </trans-unit>
        <trans-unit id="23f95eef5a8ff15d45d59ef33e2757420f465ed8" translate="yes" xml:space="preserve">
          <source>Relay.Store.commitUpdate()</source>
          <target state="translated">Relay.Store.commitUpdate()</target>
        </trans-unit>
        <trans-unit id="5435b8d8380c04f42e516eb3bd9326e46359b1b6" translate="yes" xml:space="preserve">
          <source>Relay.createContainer()</source>
          <target state="translated">Relay.createContainer()</target>
        </trans-unit>
        <trans-unit id="12f5066f2601943d9aac424bb916a7d3e8a44732" translate="yes" xml:space="preserve">
          <source>Relay.injectNetworkLayer()</source>
          <target state="translated">Relay.injectNetworkLayer()</target>
        </trans-unit>
        <trans-unit id="1a735b56a61cab41febb27320e2f243ed493b94f" translate="yes" xml:space="preserve">
          <source>Relay.injectTaskScheduler()</source>
          <target state="translated">Relay.injectTaskScheduler()</target>
        </trans-unit>
        <trans-unit id="309387769d52bfb1d6f330d2a6e3ecd71ecb41e1" translate="yes" xml:space="preserve">
          <source>Relay.isContainer()</source>
          <target state="translated">Relay.isContainer()</target>
        </trans-unit>
        <trans-unit id="c772f86aadb639ca41aafc4ec6f52aaae43e0acf" translate="yes" xml:space="preserve">
          <source>RelayContainer</source>
          <target state="translated">RelayContainer</target>
        </trans-unit>
        <trans-unit id="76e743848043959a7f2bfa720b5616417bb798e1" translate="yes" xml:space="preserve">
          <source>RelayContainer implements a conservative default &lt;code&gt;shouldComponentUpdate&lt;/code&gt; that returns &lt;code&gt;false&lt;/code&gt; if no fragment props have changed and all other props are equal scalar values. This may block updates to components that receive data via context. To ensure an update in this case override the default behavior by specifying a &lt;code&gt;shouldComponentUpdate&lt;/code&gt; function.</source>
          <target state="translated">RelayContainer implementa un &lt;code&gt;shouldComponentUpdate&lt;/code&gt; predeterminado conservador que devuelve &lt;code&gt;false&lt;/code&gt; si no ha cambiado ning&amp;uacute;n accesorio de fragmento y todos los dem&amp;aacute;s accesorios tienen valores escalares iguales. Esto puede bloquear las actualizaciones de los componentes que reciben datos a trav&amp;eacute;s del contexto. Para garantizar una actualizaci&amp;oacute;n en este caso, anule el comportamiento predeterminado especificando una funci&amp;oacute;n &lt;code&gt;shouldComponentUpdate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83d048709f5073df975dc9c425226f037d2ced9a" translate="yes" xml:space="preserve">
          <source>RelayContainer#forceFetch()</source>
          <target state="translated">RelayContainer#forceFetch()</target>
        </trans-unit>
        <trans-unit id="12306a7598448404edb2c73ef03ebd3b1459df33" translate="yes" xml:space="preserve">
          <source>RelayContainer#fragments</source>
          <target state="translated">RelayContainer#fragments</target>
        </trans-unit>
        <trans-unit id="fa4bac3fc05c361b8142cf895c4dec7b9136e491" translate="yes" xml:space="preserve">
          <source>RelayContainer#getFragment()</source>
          <target state="translated">RelayContainer#getFragment()</target>
        </trans-unit>
        <trans-unit id="0f0d5c6a56d86ccbcf94f9197715dbb511dcccda" translate="yes" xml:space="preserve">
          <source>RelayContainer#getPendingTransactions()</source>
          <target state="translated">RelayContainer#getPendingTransactions()</target>
        </trans-unit>
        <trans-unit id="3583e47f56ed32f6527e40cae51e9cd4226d6b8a" translate="yes" xml:space="preserve">
          <source>RelayContainer#hasOptimisticUpdate()</source>
          <target state="translated">RelayContainer#hasOptimisticUpdate()</target>
        </trans-unit>
        <trans-unit id="f6baca904aa4a3f9af8b6cef6a7995ee09553ec3" translate="yes" xml:space="preserve">
          <source>RelayContainer#initialVariables</source>
          <target state="translated">RelayContainer#initialVariables</target>
        </trans-unit>
        <trans-unit id="67aea36b1c5b679f64f0d153f256c81a818ebe83" translate="yes" xml:space="preserve">
          <source>RelayContainer#pendingVariables</source>
          <target state="translated">RelayContainer#pendingVariables</target>
        </trans-unit>
        <trans-unit id="9cce83d93b864bd7fad1aa07826c61d9a6ef284e" translate="yes" xml:space="preserve">
          <source>RelayContainer#prepareVariables</source>
          <target state="translated">RelayContainer#prepareVariables</target>
        </trans-unit>
        <trans-unit id="ef93161b93af5f5e98d21bb920dbacc9ffd1f25e" translate="yes" xml:space="preserve">
          <source>RelayContainer#route</source>
          <target state="translated">RelayContainer#route</target>
        </trans-unit>
        <trans-unit id="707b6138cca39388519379f5f0473ddd29369f7f" translate="yes" xml:space="preserve">
          <source>RelayContainer#setVariables()</source>
          <target state="translated">RelayContainer#setVariables()</target>
        </trans-unit>
        <trans-unit id="13dc088a9a8f1b885a4b30d133ebfc79f65f8a56" translate="yes" xml:space="preserve">
          <source>RelayContainer#shouldComponentUpdate</source>
          <target state="translated">RelayContainer#shouldComponentUpdate</target>
        </trans-unit>
        <trans-unit id="562b0d971d42af3b685406a662899de6e23e0ff8" translate="yes" xml:space="preserve">
          <source>RelayContainer#variables</source>
          <target state="translated">RelayContainer#variables</target>
        </trans-unit>
        <trans-unit id="cf0a077ddadfb043fbdeb8a931f05f97f9dec4db" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest</source>
          <target state="translated">RelayMutationRequest</target>
        </trans-unit>
        <trans-unit id="459733a291121fc4443f52543c52bf1ba049dc6a" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest#getDebugName()</source>
          <target state="translated">RelayMutationRequest#getDebugName()</target>
        </trans-unit>
        <trans-unit id="e6aac4071918a71d5a4437bcf00846a0803cb431" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest#getFiles()</source>
          <target state="translated">RelayMutationRequest#getFiles()</target>
        </trans-unit>
        <trans-unit id="98f8235cb1f82e31b63e4abc739976992bfb5247" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest#getID()</source>
          <target state="translated">RelayMutationRequest#getID()</target>
        </trans-unit>
        <trans-unit id="aced70c9403a7f1d9071b6bdae3bf77f17f27954" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest#getQueryString()</source>
          <target state="translated">RelayMutationRequest#getQueryString()</target>
        </trans-unit>
        <trans-unit id="f6fd4f67bc834b8917c668afd31ee438a325f452" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest#getVariables()</source>
          <target state="translated">RelayMutationRequest#getVariables()</target>
        </trans-unit>
        <trans-unit id="20f8806483b79b8a279be2b49be8c750a67cdb41" translate="yes" xml:space="preserve">
          <source>RelayNetworkLayer</source>
          <target state="translated">RelayNetworkLayer</target>
        </trans-unit>
        <trans-unit id="7f0a8ef7b7a43a9933addcbaef565eff07884834" translate="yes" xml:space="preserve">
          <source>RelayNetworkLayer#sendMutation()</source>
          <target state="translated">RelayNetworkLayer#sendMutation()</target>
        </trans-unit>
        <trans-unit id="67d40797657bd24a84a171e652a9bea818a15d96" translate="yes" xml:space="preserve">
          <source>RelayNetworkLayer#sendQueries()</source>
          <target state="translated">RelayNetworkLayer#sendQueries()</target>
        </trans-unit>
        <trans-unit id="eacde2e3a9c41d29b2ee433848dfea8232a5d22a" translate="yes" xml:space="preserve">
          <source>RelayNetworkLayer#supports()</source>
          <target state="translated">RelayNetworkLayer#supports()</target>
        </trans-unit>
        <trans-unit id="5113dd07f144f50d7677810b044a345b89e66e0e" translate="yes" xml:space="preserve">
          <source>RelayQueryRequest</source>
          <target state="translated">RelayQueryRequest</target>
        </trans-unit>
        <trans-unit id="4a9c272793946b8bdd3a09cdfbde6dc8574faf62" translate="yes" xml:space="preserve">
          <source>RelayQueryRequest#getDebugName()</source>
          <target state="translated">RelayQueryRequest#getDebugName()</target>
        </trans-unit>
        <trans-unit id="481aa62146f5343b4ba1062802709201d6d4d7af" translate="yes" xml:space="preserve">
          <source>RelayQueryRequest#getID()</source>
          <target state="translated">RelayQueryRequest#getID()</target>
        </trans-unit>
        <trans-unit id="0f467922406404a5eac2d6f11b736b9d66633025" translate="yes" xml:space="preserve">
          <source>RelayQueryRequest#getQueryString()</source>
          <target state="translated">RelayQueryRequest#getQueryString()</target>
        </trans-unit>
        <trans-unit id="981023af3724c0e925cbc3f99f867f132178c714" translate="yes" xml:space="preserve">
          <source>RelayQueryRequest#getVariables()</source>
          <target state="translated">RelayQueryRequest#getVariables()</target>
        </trans-unit>
        <trans-unit id="8324e4ecabe765d0034c56fc8f4c857ecfa3e2ae" translate="yes" xml:space="preserve">
          <source>RelayRecordProxy</source>
          <target state="translated">RelayRecordProxy</target>
        </trans-unit>
        <trans-unit id="69b9a9d8ad89e9af43d214607d3ff0018325568c" translate="yes" xml:space="preserve">
          <source>RelayRecordStore</source>
          <target state="translated">RelayRecordStore</target>
        </trans-unit>
        <trans-unit id="8aa27a7e83012be706218f33db1f656ebf3d0b47" translate="yes" xml:space="preserve">
          <source>Render Callbacks</source>
          <target state="translated">Renderizar las llamadas</target>
        </trans-unit>
        <trans-unit id="e066e80468f5234a1001137061731ae39a651ab5" translate="yes" xml:space="preserve">
          <source>Rendering</source>
          <target state="translated">Rendering</target>
        </trans-unit>
        <trans-unit id="db86b99e5c8c7fa5281608698558232d5c55e13b" translate="yes" xml:space="preserve">
          <source>Rendering Containers</source>
          <target state="translated">Recipientes de reciclaje</target>
        </trans-unit>
        <trans-unit id="af597671c6dcfa1df34e2e38251238001351c84d" translate="yes" xml:space="preserve">
          <source>Repeatedly refetching information from the server can get quite slow. For example, navigating from the list of stories, to a list item, and back to the list of stories means we have to refetch the whole list. We'll solve this with the standard solution: &lt;em&gt;caching&lt;/em&gt;.</source>
          <target state="translated">Recuperar informaci&amp;oacute;n repetidamente del servidor puede resultar bastante lento. Por ejemplo, navegar desde la lista de historias hasta un elemento de la lista y volver a la lista de historias significa que tenemos que volver a buscar la lista completa. Resolveremos esto con la soluci&amp;oacute;n est&amp;aacute;ndar: el &lt;em&gt;almacenamiento en cach&amp;eacute;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3341adcc90aa2cf65b0ed4f78d46fafd5dfc9cd5" translate="yes" xml:space="preserve">
          <source>Requesting Different Data</source>
          <target state="translated">Solicitud de datos diferentes</target>
        </trans-unit>
        <trans-unit id="b092a39c824d57357df89b0ece2eb1e4c9834cca" translate="yes" xml:space="preserve">
          <source>Require the Relay Compat API from &lt;code&gt;'react-relay/compat'&lt;/code&gt; and use it as you would Relay Modern. The components using Relay Compat can be referred to by both other Relay Modern and Relay Classic components.</source>
          <target state="translated">Requiere la API Relay Compat de &lt;code&gt;'react-relay/compat'&lt;/code&gt; y &amp;uacute;sala como lo har&amp;iacute;as con Relay Modern. Los componentes que utilizan Relay Compat pueden ser referidos por otros componentes Relay Modern y Relay Classic.</target>
        </trans-unit>
        <trans-unit id="61ac8791c7043a10705ecb741c56abf9848abf0a" translate="yes" xml:space="preserve">
          <source>Resolving Data from the Client</source>
          <target state="translated">Resolver los datos del cliente</target>
        </trans-unit>
        <trans-unit id="3281bf767244e09b6483581e4d93f748c54eb136" translate="yes" xml:space="preserve">
          <source>Response-caching can also be applied to GraphQL. A basic approach would work similarly to the REST version. The text of the query itself can be used as a cache key:</source>
          <target state="translated">El almacenamiento de respuestas también puede aplicarse a GraphQL.Un enfoque básico funcionaría de manera similar a la versión REST.El texto de la consulta en sí puede ser usado como una clave de caché:</target>
        </trans-unit>
        <trans-unit id="81554eb7c1007a0bac823cb3e3ca325777b63f97" translate="yes" xml:space="preserve">
          <source>Retrieves record(s) associated with the given record, transversing the source by field name and an object representing pre-defined argument values.</source>
          <target state="translated">Recupera registro(s)asociado(s)con el registro dado,cruzando la fuente por el nombre del campo y un objeto que representa los valores de los argumentos predefinidos.</target>
        </trans-unit>
        <trans-unit id="e013c79a69f7fdde5c1472633a22316f0ef0ef72" translate="yes" xml:space="preserve">
          <source>Retrying failed requests.</source>
          <target state="translated">Reintentar las solicitudes fallidas.</target>
        </trans-unit>
        <trans-unit id="56de3c3d136f4071d757cabe4b6ed2c52a5dad01" translate="yes" xml:space="preserve">
          <source>Returns a proxy class for manipulating records from a record source, for example a query, mutation, or the store.</source>
          <target state="translated">Devuelve una clase de proxy para manipular registros de una fuente de registro,por ejemplo una consulta,una mutación o el almacén.</target>
        </trans-unit>
        <trans-unit id="91f8449d9fa8e9ef7aa99597a20ab0dcfe5b332a" translate="yes" xml:space="preserve">
          <source>Returns a read-only view of the store's internal RecordSource that holds all records.</source>
          <target state="translated">Devuelve una vista de sólo lectura del RecordSource interno de la tienda que contiene todos los registros.</target>
        </trans-unit>
        <trans-unit id="6a9d68c06d14e4ad8d6a81f1e355b118c27b1408" translate="yes" xml:space="preserve">
          <source>Returns the GraphQL type name for a given record.</source>
          <target state="translated">Devuelve el nombre de tipo GraphQL para un registro determinado.</target>
        </trans-unit>
        <trans-unit id="384ac89b24069cf234b54ff56b3d6d5c565f33c7" translate="yes" xml:space="preserve">
          <source>Returns the globally unique identifier string for a record.</source>
          <target state="translated">Devuelve la cadena de identificación global única de un registro.</target>
        </trans-unit>
        <trans-unit id="7d0eb64e469d72e6ccf94d6d96498f73ad0e6f27" translate="yes" xml:space="preserve">
          <source>Reusable fragments to compose within the above use cases.</source>
          <target state="translated">Fragmentos reutilizables para componer dentro de los casos de uso anteriores.</target>
        </trans-unit>
        <trans-unit id="72e1985969f053f8609f492cf63340c5c4f7f3fc" translate="yes" xml:space="preserve">
          <source>Rolls back an optimistic mutation.</source>
          <target state="translated">Retrocede una mutación optimista.</target>
        </trans-unit>
        <trans-unit id="0dfddbb0a122d3a2969eb11e085210ba893e7399" translate="yes" xml:space="preserve">
          <source>Root Container</source>
          <target state="translated">Contenedor de Raíz</target>
        </trans-unit>
        <trans-unit id="1bf5197778bc12b8d4edfe1a0c2de1ced169d30b" translate="yes" xml:space="preserve">
          <source>RootContainer</source>
          <target state="translated">RootContainer</target>
        </trans-unit>
        <trans-unit id="4999528efe0f94f8f66b1dc05aad8ebaaae7b2be" translate="yes" xml:space="preserve">
          <source>Route</source>
          <target state="translated">Route</target>
        </trans-unit>
        <trans-unit id="52c021a7e89ad4e72cef6096b3c6424e78876574" translate="yes" xml:space="preserve">
          <source>Route is useful in providing the context which a component is being rendered in. It includes information about the &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;params&lt;/code&gt;, and &lt;code&gt;queries&lt;/code&gt; of the current route.</source>
          <target state="translated">La ruta es &amp;uacute;til para proporcionar el contexto en el que se representa un componente. Incluye informaci&amp;oacute;n sobre el &lt;code&gt;name&lt;/code&gt; , los &lt;code&gt;params&lt;/code&gt; y las &lt;code&gt;queries&lt;/code&gt; de la ruta actual.</target>
        </trans-unit>
        <trans-unit id="03730e58401ef5d9e79d1f674df0a5f9cf756e33" translate="yes" xml:space="preserve">
          <source>Routes</source>
          <target state="translated">Routes</target>
        </trans-unit>
        <trans-unit id="0bd75f049435ac9bea4df8ce63749bdcfaaef9e4" translate="yes" xml:space="preserve">
          <source>Routes and Queries</source>
          <target state="translated">Rutas y consultas</target>
        </trans-unit>
        <trans-unit id="a476715db16204d7e6fb7743a314ee35337241d4" translate="yes" xml:space="preserve">
          <source>Routes are now optional: &lt;code&gt;QueryRenderer&lt;/code&gt; can be used without defining a route. More in the &lt;a href=&quot;routing&quot;&gt;routing guide&lt;/a&gt;.</source>
          <target state="translated">Las rutas ahora son opcionales: &lt;code&gt;QueryRenderer&lt;/code&gt; se puede usar sin definir una ruta. M&amp;aacute;s en la &lt;a href=&quot;routing&quot;&gt;gu&amp;iacute;a de enrutamiento&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ca283153940483bc802b34b41123871d483749c7" translate="yes" xml:space="preserve">
          <source>Routes are objects that define a set of root queries and input parameters. Here is a simple route that might be used to render user &lt;code&gt;123&lt;/code&gt;'s profile:</source>
          <target state="translated">Las rutas son objetos que definen un conjunto de consultas ra&amp;iacute;z y par&amp;aacute;metros de entrada. Aqu&amp;iacute; hay una ruta simple que podr&amp;iacute;a usarse para representar el perfil del usuario &lt;code&gt;123&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="330b3e499c3450d42634b5702213e434b7a82a41" translate="yes" xml:space="preserve">
          <source>Routes are responsible for defining the entry points into a Relay application. But in order to understand why routes are necessary, we must first understand the difference between GraphQL queries and fragments.</source>
          <target state="translated">Las rutas son responsables de definir los puntos de entrada en una aplicación de retransmisión.Pero para entender por qué las rutas son necesarias,primero debemos entender la diferencia entre las consultas de GraphQL y los fragmentos.</target>
        </trans-unit>
        <trans-unit id="ae0f139d125aa65c3494e803bdab2bfc2845048a" translate="yes" xml:space="preserve">
          <source>Routes can declare a set of parameter names that are required to be supplied to the constructor. This is also a convenient place to document the set of valid parameters.</source>
          <target state="translated">Las rutas pueden declarar un conjunto de nombres de parámetros que deben ser suministrados al constructor.Este es también un lugar conveniente para documentar el conjunto de parámetros válidos.</target>
        </trans-unit>
        <trans-unit id="e5ec9f7b8ea16c97f062b9386937889c5390bd89" translate="yes" xml:space="preserve">
          <source>Routes can use &lt;code&gt;prepareParams&lt;/code&gt; to provide default parameters, or pass through, convert or suppress passed-in parameters.</source>
          <target state="translated">Las rutas pueden usar &lt;code&gt;prepareParams&lt;/code&gt; para proporcionar par&amp;aacute;metros predeterminados, o pasar, convertir o suprimir par&amp;aacute;metros pasados.</target>
        </trans-unit>
        <trans-unit id="a04e20b09d66a6ec94b9fd8e8520062229d58d02" translate="yes" xml:space="preserve">
          <source>Routes must declare a set of query roots using &lt;code&gt;Relay.QL&lt;/code&gt;. These queries will automatically compose a matching fragment named &lt;code&gt;queryName&lt;/code&gt; on the Relay container used with this route on a &lt;strong&gt;Relay.RootContainer&lt;/strong&gt;.</source>
          <target state="translated">Las rutas deben declarar un conjunto de ra&amp;iacute;ces de consulta mediante &lt;code&gt;Relay.QL&lt;/code&gt; . Estas consultas compondr&amp;aacute;n autom&amp;aacute;ticamente un fragmento coincidente llamado &lt;code&gt;queryName&lt;/code&gt; en el contenedor Relay usado con esta ruta en un &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="fd81fc06977ad2c7156abd14b5b9caa0f8c40fc2" translate="yes" xml:space="preserve">
          <source>Routes must define a string name.</source>
          <target state="translated">Las rutas deben definir un nombre de cadena.</target>
        </trans-unit>
        <trans-unit id="380338bdec53655cfe9114fa55d7fe1d8bdbb27d" translate="yes" xml:space="preserve">
          <source>Routes no longer need to know anything about the query root in Relay Modern. Relay components can be rendered anywhere wrapped in a &lt;code&gt;QueryRenderer&lt;/code&gt;. This should bring more flexibility around picking routing frameworks.</source>
          <target state="translated">Las rutas ya no necesitan saber nada sobre la ra&amp;iacute;z de la consulta en Relay Modern. Los componentes de retransmisi&amp;oacute;n se pueden representar en cualquier lugar envueltos en un &lt;code&gt;QueryRenderer&lt;/code&gt; . Esto deber&amp;iacute;a aportar m&amp;aacute;s flexibilidad a la hora de elegir marcos de enrutamiento.</target>
        </trans-unit>
        <trans-unit id="7d15dd1bec2e055c5b177c9f869305ae6c54c9bb" translate="yes" xml:space="preserve">
          <source>Routing</source>
          <target state="translated">Routing</target>
        </trans-unit>
        <trans-unit id="15f12d3d79029156026af15a57e839303e093597" translate="yes" xml:space="preserve">
          <source>Run the Relay Compiler after making changes to any GraphQL in your Relay application. It may be helpful to add it as a &lt;code&gt;yarn script&lt;/code&gt;. Add an entry to &lt;code&gt;&quot;scripts&quot;&lt;/code&gt; in your package.json file.</source>
          <target state="translated">Ejecute el Relay Compiler despu&amp;eacute;s de realizar cambios en cualquier GraphQL en su aplicaci&amp;oacute;n Relay. Puede ser &amp;uacute;til agregarlo como un &lt;code&gt;yarn script&lt;/code&gt; . Agregue una entrada a &lt;code&gt;&quot;scripts&quot;&lt;/code&gt; en su archivo package.json.</target>
        </trans-unit>
        <trans-unit id="b5230ecdf4e78f0dd162281a0a78c6cdc853cbe8" translate="yes" xml:space="preserve">
          <source>Schema</source>
          <target state="translated">Schema</target>
        </trans-unit>
        <trans-unit id="1f0e625b220c0a58aba2033abe91bfe01285293e" translate="yes" xml:space="preserve">
          <source>Schema JSON</source>
          <target state="translated">Esquema JSON</target>
        </trans-unit>
        <trans-unit id="3e32d234cf8a398d348341552d4472b71aa02309" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;interfaces-relay-mutation-request&quot;&gt;RelayMutationRequest&lt;/a&gt; for methods available on the argument object.</source>
          <target state="translated">Consulte &lt;a href=&quot;interfaces-relay-mutation-request&quot;&gt;RelayMutationRequest&lt;/a&gt; para conocer los m&amp;eacute;todos disponibles en el objeto de argumento.</target>
        </trans-unit>
        <trans-unit id="ba186dff4700bd97150240f3ab29c29fbc1b7fc5" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;interfaces-relay-query-request&quot;&gt;RelayQueryRequest&lt;/a&gt; for methods available on the argument objects.</source>
          <target state="translated">Consulte &lt;a href=&quot;interfaces-relay-query-request&quot;&gt;RelayQueryRequest&lt;/a&gt; para conocer los m&amp;eacute;todos disponibles en los objetos de argumento.</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">Ver también</target>
        </trans-unit>
        <trans-unit id="0ebcd737a1bf60dbd1447977c888467e35a467a0" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#constructor&quot;&gt;GraphQLMutation &amp;gt; Constructor&lt;/a&gt;</source>
          <target state="translated">Vea tambi&amp;eacute;n: &lt;a href=&quot;#constructor&quot;&gt;GraphQLMutation&amp;gt; Constructor&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eb08c52e72850acd0139ed4cb2152c144c9e58eb" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#getconfigs-abstract-method&quot;&gt;Relay.Mutation::getConfigs()&lt;/a&gt;</source>
          <target state="translated">Ver tambi&amp;eacute;n: &lt;a href=&quot;#getconfigs-abstract-method&quot;&gt;Relay.Mutation :: getConfigs ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="51b02cf1878520658c9b88fe67978bf776e01dd9" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;api-reference-relay-mutation#getcollisionkey&quot;&gt;Relay.Mutation::getCollisionKey()&lt;/a&gt;</source>
          <target state="translated">Ver tambi&amp;eacute;n: &lt;a href=&quot;api-reference-relay-mutation#getcollisionkey&quot;&gt;Relay.Mutation :: getCollisionKey ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8665daeb214113b0a6222a07deb324960005a817" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;api-reference-relay-mutation#getconfigs-abstract-method&quot;&gt;Relay.Mutation::getConfigs()&lt;/a&gt;</source>
          <target state="translated">Ver tambi&amp;eacute;n: &lt;a href=&quot;api-reference-relay-mutation#getconfigs-abstract-method&quot;&gt;Relay.Mutation :: getConfigs ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9701bc69d708978bae12176bd6d6b49b6310b158" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-containers#relay-containers&quot;&gt;Containers &amp;gt; Relay Containers&lt;/a&gt;</source>
          <target state="translated">Ver tambi&amp;eacute;n: &lt;a href=&quot;guides-containers#relay-containers&quot;&gt;Contenedores&amp;gt; Contenedores de rel&amp;eacute;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f63708739a0519c20cb04d22aed0623da8910a3b" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-containers#requesting-different-data&quot;&gt;Containers &amp;gt; Requesting Different Data&lt;/a&gt;, &lt;a href=&quot;guides-ready-state&quot;&gt;Ready State&lt;/a&gt;</source>
          <target state="translated">Consulte tambi&amp;eacute;n: &lt;a href=&quot;guides-containers#requesting-different-data&quot;&gt;Contenedores&amp;gt; Solicitud de datos diferentes&lt;/a&gt; , &lt;a href=&quot;guides-ready-state&quot;&gt;estado listo&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fb81a25d0442cce928322c7171025b8b9f41ba2d" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#fragment-variables&quot;&gt;Mutations &amp;gt; Fragment variables&lt;/a&gt;</source>
          <target state="translated">Ver tambi&amp;eacute;n: &lt;a href=&quot;guides-mutations#fragment-variables&quot;&gt;Mutaciones&amp;gt; Variables de fragmentos&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="252cc9e75017b1ba4bc6a1cab81814c7c5e7b9c1" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#fragment-variables&quot;&gt;Mutations &amp;gt; Fragment variables&lt;/a&gt; and &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;Mutations &amp;gt; Optimistic updates&lt;/a&gt;</source>
          <target state="translated">Ver tambi&amp;eacute;n: &lt;a href=&quot;guides-mutations#fragment-variables&quot;&gt;Mutaciones&amp;gt; Variables de fragmentos&lt;/a&gt; y &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;mutaciones&amp;gt; Actualizaciones optimistas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c325d76133ada9407e339b00806d08a492686a72" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#mutator-configuration&quot;&gt;Mutations &amp;gt; Mutator configuration&lt;/a&gt;</source>
          <target state="translated">Ver tambi&amp;eacute;n: &lt;a href=&quot;guides-mutations#mutator-configuration&quot;&gt;Mutaciones&amp;gt; Configuraci&amp;oacute;n del mutador&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec1a4ead3e670cf9b7225817b2d5536e60b9dfc8" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;Mutations &amp;gt; Optimistic Updates&lt;/a&gt;</source>
          <target state="translated">Ver tambi&amp;eacute;n: &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;Mutaciones&amp;gt; Actualizaciones optimistas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f91e5359d2e437a1fabed213a7400919e36a4e8f" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;Mutations &amp;gt; Optimistic updates&lt;/a&gt;</source>
          <target state="translated">Ver tambi&amp;eacute;n: &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;Mutaciones&amp;gt; Actualizaciones optimistas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6a14ec07edd61e594362c3ba2c69cd02521e8cd7" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#the-fat-query&quot;&gt;Mutations &amp;gt; The fat query&lt;/a&gt;</source>
          <target state="translated">Ver tambi&amp;eacute;n: &lt;a href=&quot;guides-mutations#the-fat-query&quot;&gt;Mutaciones&amp;gt; La consulta de grasa&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3c9e106abf2efb7313ca2aef582895208bb3b4a9" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-ready-state&quot;&gt;Ready State&lt;/a&gt;</source>
          <target state="translated">Ver tambi&amp;eacute;n: &lt;a href=&quot;guides-ready-state&quot;&gt;Estado listo&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3d33a51e631c54521d230f0b77c33a0ffcb95a9e" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#component-and-route&quot;&gt;Root Container &amp;gt; Component and Route&lt;/a&gt;</source>
          <target state="translated">Consulte tambi&amp;eacute;n: &lt;a href=&quot;guides-root-container#component-and-route&quot;&gt;Contenedor ra&amp;iacute;z&amp;gt; Componente y ruta&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6ba9c7676225015beb8fcd0dc8154429cc521b19" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#force-fetching&quot;&gt;Root Container &amp;gt; Force Fetching&lt;/a&gt;</source>
          <target state="translated">V&amp;eacute;ase tambi&amp;eacute;n: &lt;a href=&quot;guides-root-container#force-fetching&quot;&gt;Contenedor ra&amp;iacute;z&amp;gt; Obtenci&amp;oacute;n forzada&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2d475a6214b773e645b11e09318c20c3c31900a2" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#renderfailure&quot;&gt;Root Container &amp;gt; renderFailure&lt;/a&gt;</source>
          <target state="translated">V&amp;eacute;ase tambi&amp;eacute;n: &lt;a href=&quot;guides-root-container#renderfailure&quot;&gt;Contenedor ra&amp;iacute;z&amp;gt; renderFailure&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="592bf7ec077fdbfb9bb08cfe9e7520a4dc086e1c" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#renderfetched&quot;&gt;Root Container &amp;gt; renderFetched&lt;/a&gt;</source>
          <target state="translated">V&amp;eacute;ase tambi&amp;eacute;n: &lt;a href=&quot;guides-root-container#renderfetched&quot;&gt;Contenedor ra&amp;iacute;z&amp;gt; renderFetched&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6a187f3307739f3f97bdae9d053fcff505ffdeb1" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#renderloading&quot;&gt;Root Container &amp;gt; renderLoading&lt;/a&gt;</source>
          <target state="translated">V&amp;eacute;ase tambi&amp;eacute;n: &lt;a href=&quot;guides-root-container#renderloading&quot;&gt;Contenedor ra&amp;iacute;z&amp;gt; renderLoading&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2fcf798559587d9befe424605fcb71c2af445685" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-routes&quot;&gt;Routes&lt;/a&gt;</source>
          <target state="translated">Ver tambi&amp;eacute;n: &lt;a href=&quot;guides-routes&quot;&gt;Rutas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ac40c2c295e0947fa5d231ce927c5f063044cb9e" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;api-reference-relay-proptypes&quot;&gt;PropTypes API reference&lt;/a&gt;.</source>
          <target state="translated">Consulte la &lt;a href=&quot;api-reference-relay-proptypes&quot;&gt;referencia de la API de PropTypes&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="db3136f0089c09e6cfa1ecac38be1bb1698a01e9" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;api-reference-relay-ql&quot;&gt;Relay.QL API reference&lt;/a&gt;.</source>
          <target state="translated">Consulte la &lt;a href=&quot;api-reference-relay-ql&quot;&gt;referencia de la API de Relay.QL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="46ebdef898489cac49931005986e50860c184084" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;api-reference-relay-store&quot;&gt;Store API reference&lt;/a&gt;.</source>
          <target state="translated">Consulta la &lt;a href=&quot;api-reference-relay-store&quot;&gt;referencia de la API de&lt;/a&gt; la tienda .</target>
        </trans-unit>
        <trans-unit id="4011d8e185ce992ad373c12339d3c386a366a9d9" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;guides-mutations&quot;&gt;Mutations Guide&lt;/a&gt;.</source>
          <target state="translated">Consulte la &lt;a href=&quot;guides-mutations&quot;&gt;Gu&amp;iacute;a de mutaciones&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="85e710dc6095fa7ec6992d17389697e3d05b22af" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;guides-network-layer&quot;&gt;Network Layer Guide&lt;/a&gt;.</source>
          <target state="translated">Consulte la &lt;a href=&quot;guides-network-layer&quot;&gt;Gu&amp;iacute;a de capa de red&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f586115c09169458b9424f28db540ede9b2d7ddf" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;guides-root-container&quot;&gt;RootContainer Guide&lt;/a&gt;.</source>
          <target state="translated">Consulte la &lt;a href=&quot;guides-root-container&quot;&gt;Gu&amp;iacute;a de RootContainer&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c7e49836605664cff515afd9b044294d9e1deeee" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;guides-routes&quot;&gt;Routes Guide&lt;/a&gt;.</source>
          <target state="translated">Consulte la &lt;a href=&quot;guides-routes&quot;&gt;Gu&amp;iacute;a de rutas&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="076a9d109c3f1a2389e316e443efa40d8f78df54" translate="yes" xml:space="preserve">
          <source>Server Error</source>
          <target state="translated">Error del servidor</target>
        </trans-unit>
        <trans-unit id="6b17482f3f882455ee584aa25321c5bdac980242" translate="yes" xml:space="preserve">
          <source>Set up babel-plugin-relay</source>
          <target state="translated">Establecer el relé de babel-plugin</target>
        </trans-unit>
        <trans-unit id="8a05cf798da4421d2bd58da023c7f3fb287cd45f" translate="yes" xml:space="preserve">
          <source>Set up relay-compiler</source>
          <target state="translated">Configurar el retransmisor-compilador</target>
        </trans-unit>
        <trans-unit id="f72f8a571d6e8bf5eec6f1a2a44a50aeba5d7932" translate="yes" xml:space="preserve">
          <source>Setting up Relay Compiler</source>
          <target state="translated">Configurando el Compilador de Relevos</target>
        </trans-unit>
        <trans-unit id="4d8e8804be8f7d9838f29acdb1972f43499e72bb" translate="yes" xml:space="preserve">
          <source>Setting up babel-plugin-relay</source>
          <target state="translated">Estableciendo el relé de babel-plugin</target>
        </trans-unit>
        <trans-unit id="abeed86f05bd23992570bff235c3a5eea268d38d" translate="yes" xml:space="preserve">
          <source>Show More</source>
          <target state="translated">Mostrar más</target>
        </trans-unit>
        <trans-unit id="c0d8810501ac79b3d67791d7c14301a445bdcd5c" translate="yes" xml:space="preserve">
          <source>Similar to how a React component's &lt;code&gt;render&lt;/code&gt; method does not directly modify native views, Relay containers do not directly fetch data. Instead, containers declare a &lt;em&gt;specification&lt;/em&gt; of the data needed to render. Relay guarantees that this data is available &lt;em&gt;before&lt;/em&gt; rendering.</source>
          <target state="translated">De manera similar a c&amp;oacute;mo el m&amp;eacute;todo de &lt;code&gt;render&lt;/code&gt; izado de un componente React no modifica directamente las vistas nativas, los contenedores Relay no obtienen datos directamente. En cambio, los contenedores declaran una &lt;em&gt;especificaci&amp;oacute;n&lt;/em&gt; de los datos necesarios para renderizar. Relay garantiza que estos datos est&amp;aacute;n disponibles &lt;em&gt;antes de la&lt;/em&gt; renderizaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="88286b84c7253d721eb28be982c48ae3b8c8564f" translate="yes" xml:space="preserve">
          <source>Simpler Mutation API</source>
          <target state="translated">Simplificación de la mutación API</target>
        </trans-unit>
        <trans-unit id="38b269b106dd0853215c15032c144a95de107505" translate="yes" xml:space="preserve">
          <source>Since Relay containers define fragments and not queries, they can be easily embedded in multiple contexts. Like React components, Relay containers are highly reusable.</source>
          <target state="translated">Dado que los contenedores de relevo definen fragmentos y no consultas,se pueden incrustar fácilmente en múltiples contextos.Al igual que los componentes de React,los contenedores de relé son altamente reutilizables.</target>
        </trans-unit>
        <trans-unit id="eed3231995e285304e7921a2b3b7268f678be407" translate="yes" xml:space="preserve">
          <source>Since one game can have many hiding spots, we need to create a connection that we can use to link them together.</source>
          <target state="translated">Ya que un juego puede tener muchos escondites,necesitamos crear una conexión que podamos usar para unirlos.</target>
        </trans-unit>
        <trans-unit id="1bc4c3be89589c1b9cbd3e1e89f801487097b78c" translate="yes" xml:space="preserve">
          <source>Smaller Bundle Size</source>
          <target state="translated">El tamaño del paquete más pequeño</target>
        </trans-unit>
        <trans-unit id="eae26374639c4e0cc2a093a378a0ac3891ecab5b" translate="yes" xml:space="preserve">
          <source>So far we looked at the lower-level aspects of data-fetching and saw how various familiar concepts translate to GraphQL. Next, let's step back and look at some higher-level concerns that product developers often face around data-fetching:</source>
          <target state="translated">Hasta ahora hemos mirado los aspectos de nivel inferior de la búsqueda de datos y vimos cómo varios conceptos familiares se traducen a GraphQL.A continuación,vamos a dar un paso atrás y mirar algunas preocupaciones de alto nivel que los desarrolladores de productos a menudo se enfrentan en torno a la búsqueda de datos:</target>
        </trans-unit>
        <trans-unit id="d0fc3a75755e472cad5df2903a8721c7c36d0bc7" translate="yes" xml:space="preserve">
          <source>So far we're just using GraphQL as a more efficient version of typical REST approaches. Note two important benefits in the GraphQL version:</source>
          <target state="translated">Hasta ahora sólo estamos usando GraphQL como una versión más eficiente de los típicos enfoques REST.Note dos importantes beneficios en la versión de GraphQL:</target>
        </trans-unit>
        <trans-unit id="d2a06967c509756a257c5cfbc8a853322fb784a3" translate="yes" xml:space="preserve">
          <source>So far we've looked at the process of querying data and keeping views up to date, but we haven't looked at writes. In GraphQL, writes are called &lt;strong&gt;mutations&lt;/strong&gt;. We can think of them as queries with side effects. Here's an example of calling a mutation that might mark a given story as being liked by the current user:</source>
          <target state="translated">Hasta ahora, hemos analizado el proceso de consultar datos y mantener las vistas actualizadas, pero no hemos analizado las escrituras. En GraphQL, las escrituras se denominan &lt;strong&gt;mutaciones&lt;/strong&gt; . Podemos pensar en ellos como consultas con efectos secundarios. A continuaci&amp;oacute;n, se muestra un ejemplo de c&amp;oacute;mo llamar a una mutaci&amp;oacute;n que podr&amp;iacute;a marcar una historia determinada como del agrado del usuario actual:</target>
        </trans-unit>
        <trans-unit id="5fb4c3d88d69385cf7a448a7c57e653bef0ce88f" translate="yes" xml:space="preserve">
          <source>So far, we've covered two pieces that each contribute to declaring data:</source>
          <target state="translated">Hasta ahora,hemos cubierto dos piezas que contribuyen cada una a declarar datos:</target>
        </trans-unit>
        <trans-unit id="647475236d1bc60d884c2b35b08e1b42225bc0f4" translate="yes" xml:space="preserve">
          <source>So for our &lt;code&gt;introduceShip&lt;/code&gt; mutation, we create two types: &lt;code&gt;IntroduceShipInput&lt;/code&gt; and &lt;code&gt;IntroduceShipPayload&lt;/code&gt;:</source>
          <target state="translated">Entonces, para nuestra mutaci&amp;oacute;n &lt;code&gt;introduceShip&lt;/code&gt; , creamos dos tipos: &lt;code&gt;IntroduceShipInput&lt;/code&gt; y &lt;code&gt;IntroduceShipPayload&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9b153876a947507c9e895bf7e190b67952746372" translate="yes" xml:space="preserve">
          <source>So how do we use this cache? Let's look at two operations: writing to the cache when a response is received, and reading from the cache to determine if a query can be fulfilled locally (the equivalent to &lt;code&gt;_cache.has(key)&lt;/code&gt; above, but for a graph).</source>
          <target state="translated">Entonces, &amp;iquest;c&amp;oacute;mo usamos este cach&amp;eacute;? Veamos dos operaciones: escribir en la cach&amp;eacute; cuando se recibe una respuesta y leer de la cach&amp;eacute; para determinar si una consulta se puede cumplir localmente (el equivalente a &lt;code&gt;_cache.has(key)&lt;/code&gt; anterior, pero para un gr&amp;aacute;fico).</target>
        </trans-unit>
        <trans-unit id="ecc4d54395356b7b485a16f80a383e1e01836248" translate="yes" xml:space="preserve">
          <source>So now we know the ID of the Rebels in our system. We can now refetch them:</source>
          <target state="translated">Así que ahora sabemos la identificación de los rebeldes en nuestro sistema.Ahora podemos volver a buscarlos:</target>
        </trans-unit>
        <trans-unit id="6a920cd8724dc921d9d4f9bdbe2e23494f550470" translate="yes" xml:space="preserve">
          <source>So on the first query for ships, GraphQL told us there was a next page, but on the next one, it told us we'd reached the end of the connection.</source>
          <target state="translated">Así que en la primera búsqueda de naves,GraphQL nos dijo que había una página siguiente,pero en la siguiente,nos dijo que habíamos llegado al final de la conexión.</target>
        </trans-unit>
        <trans-unit id="7d3d5c6eef5a80a3513fea5675a4ae9df60ad431" translate="yes" xml:space="preserve">
          <source>Some fields - especially those for paginated data - can require post-processing on the client in order to merge previously fetched data with new information. Relay Modern supports custom field handlers that can be used to process these fields to work with various pagination patterns and other use cases.</source>
          <target state="translated">Algunos campos,especialmente los de datos paginados,pueden requerir un post-procesamiento en el cliente para fusionar los datos previamente obtenidos con la nueva información.Relay Modern soporta manejadores de campo personalizados que pueden utilizarse para procesar estos campos para trabajar con varios patrones de paginación y otros casos de uso.</target>
        </trans-unit>
        <trans-unit id="adccc4f5e80b41c5617710fc459b4ed3934af747" translate="yes" xml:space="preserve">
          <source>Sometimes a parent needs to override the default variables of a child component. Imagine that we want to render &lt;code&gt;Child&lt;/code&gt; above with a photo size of 128 instead of the default 64. To do this, we have to ensure that both the fragment &lt;em&gt;and&lt;/em&gt; the container know about the custom variable. To set a custom variable in the &lt;em&gt;query&lt;/em&gt;, use the second argument to &lt;code&gt;getFragment&lt;/code&gt;:</source>
          <target state="translated">A veces, un padre necesita anular las variables predeterminadas de un componente hijo. Imagine que queremos renderizar &lt;code&gt;Child&lt;/code&gt; arriba con un tama&amp;ntilde;o de foto de 128 en lugar del predeterminado 64. Para hacer esto, tenemos que asegurarnos de que tanto el fragmento &lt;em&gt;como&lt;/em&gt; el contenedor conocen la variable personalizada. Para establecer una variable personalizada en la &lt;em&gt;consulta&lt;/em&gt; , use el segundo argumento para &lt;code&gt;getFragment&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e660d20bf684b576ae81f9c3a877a8d530b581ed" translate="yes" xml:space="preserve">
          <source>Source files</source>
          <target state="translated">Archivos de origen</target>
        </trans-unit>
        <trans-unit id="2d309b4d42e0ad4602d00da88f45cac2d3d11a5e" translate="yes" xml:space="preserve">
          <source>Specify the data dependencies of a `Relay.Container` as GraphQL fragments.</source>
          <target state="translated">Especificar las dependencias de datos de un &quot;Contenedor de Retransmisión&quot; como fragmentos de GraphQL.</target>
        </trans-unit>
        <trans-unit id="21f0a8e08151b2997828c63fbaffbc197295bb3a" translate="yes" xml:space="preserve">
          <source>Specify the mutation field in a `Relay.Mutation`.</source>
          <target state="translated">Especifica el campo de la mutación en un &quot;Relevo.Mutación&quot;.</target>
        </trans-unit>
        <trans-unit id="02293aef0bd0213bc1be111d67f416c9ddf1ebdf" translate="yes" xml:space="preserve">
          <source>Specify the queries of a `Relay.Route`.</source>
          <target state="translated">Especifica las preguntas de una &quot;Ruta de retransmisión&quot;.</target>
        </trans-unit>
        <trans-unit id="8c5f40f02b986c2adaf7800c3005c0afdbaaab33" translate="yes" xml:space="preserve">
          <source>Start converting your components and mutations to use the Relay Modern APIs from the &lt;code&gt;'react-relay/compat'&lt;/code&gt; module (&lt;code&gt;createFragmentContainer&lt;/code&gt;, &lt;code&gt;createRefetchContainer&lt;/code&gt;, &lt;code&gt;createPaginationContainer&lt;/code&gt;, &lt;code&gt;commitMutation&lt;/code&gt;). It will be easier to go from the leaf components up. The &lt;a href=&quot;https://github.com/relayjs/relay-codemod&quot;&gt;conversion scripts&lt;/a&gt; should make this step less tedious.</source>
          <target state="translated">Comience a convertir sus componentes y mutaciones para usar las API de Relay Modern desde el m&amp;oacute;dulo &lt;code&gt;'react-relay/compat'&lt;/code&gt; ( &lt;code&gt;createFragmentContainer&lt;/code&gt; , &lt;code&gt;createRefetchContainer&lt;/code&gt; , &lt;code&gt;createPaginationContainer&lt;/code&gt; , &lt;code&gt;commitMutation&lt;/code&gt; ). Ser&amp;aacute; m&amp;aacute;s f&amp;aacute;cil pasar de los componentes de la hoja hacia arriba. Los &lt;a href=&quot;https://github.com/relayjs/relay-codemod&quot;&gt;scripts de conversi&amp;oacute;n&lt;/a&gt; deber&amp;iacute;an hacer que este paso sea menos tedioso.</target>
        </trans-unit>
        <trans-unit id="6a5813201a4580fe5f1fbb25f1a522d4d505bf2d" translate="yes" xml:space="preserve">
          <source>Static Methods</source>
          <target state="translated">Métodos estáticos</target>
        </trans-unit>
        <trans-unit id="49ff3956bbd054bfbc63e2eabd2a1088f21e282f" translate="yes" xml:space="preserve">
          <source>Step 0: Install Relay v1.0</source>
          <target state="translated">Paso 0:Instalar el Relé v1.0</target>
        </trans-unit>
        <trans-unit id="95c2707d7e8702851af5473310f89fd4c5bfea2a" translate="yes" xml:space="preserve">
          <source>Step 1: Incrementally convert to Relay Compat</source>
          <target state="translated">Paso 1:Convertirse de forma incremental a Compatador de Relevos</target>
        </trans-unit>
        <trans-unit id="d071bae177457e9183feaf0fc474e9686b0260a4" translate="yes" xml:space="preserve">
          <source>Step 2: Introduce &amp;lt;QueryRenderer&amp;gt;</source>
          <target state="translated">Paso 2: Presente &amp;lt;QueryRenderer&amp;gt;</target>
        </trans-unit>
        <trans-unit id="8176e519a1495162afbc0b02a0cc285793d9b9e6" translate="yes" xml:space="preserve">
          <source>Step 3: Introduce Relay Modern runtime</source>
          <target state="translated">Paso 3:Introducir el tiempo de ejecución de Relevos Modernos</target>
        </trans-unit>
        <trans-unit id="5465ead3d787f346532f42480c386d4eba31fbae" translate="yes" xml:space="preserve">
          <source>Step 4: Clean up by replacing Relay Compat with Relay Modern.</source>
          <target state="translated">Paso 4:Limpiar reemplazando el Relé Compat con el Relé Moderno.</target>
        </trans-unit>
        <trans-unit id="0d8a7046c8d39d9cbd86abcdfb704b161a601f9e" translate="yes" xml:space="preserve">
          <source>Store</source>
          <target state="translated">Store</target>
        </trans-unit>
        <trans-unit id="2e017d4c10eaa0f64c98ad2b1e9b9a9d85ad4822" translate="yes" xml:space="preserve">
          <source>Structure around mutations to make them predictable.</source>
          <target state="translated">Estructura alrededor de las mutaciones para hacerlas predecibles.</target>
        </trans-unit>
        <trans-unit id="5697fd85adbd13bf85f28712f9a136e80cc8067e" translate="yes" xml:space="preserve">
          <source>Subscriptions</source>
          <target state="translated">Subscriptions</target>
        </trans-unit>
        <trans-unit id="13a5b46568a2ea322aa7b25ac8f48a520783301a" translate="yes" xml:space="preserve">
          <source>Supported in both compat and modern mode. When using the pagination container, Relay expects the connection field to be annotated with &lt;code&gt;@connection&lt;/code&gt; directive, for more detailed information and example, please go to &lt;a href=&quot;pagination-container#connection-directive&quot;&gt;&lt;code&gt;PaginationContainer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Compatible tanto en modo compat como en modo moderno. Al usar el contenedor de paginaci&amp;oacute;n, Relay espera que el campo de conexi&amp;oacute;n est&amp;eacute; anotado con la directiva &lt;code&gt;@connection&lt;/code&gt; , para obtener informaci&amp;oacute;n m&amp;aacute;s detallada y un ejemplo, vaya a &lt;a href=&quot;pagination-container#connection-directive&quot;&gt; &lt;code&gt;PaginationContainer&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3ff1be67feaa88d4848ce4702f24046558ce5b24" translate="yes" xml:space="preserve">
          <source>Supported in classic, compat and modern mode. Detailed usage is explained in &lt;a href=&quot;api-reference-relay-ql#array-fields&quot;&gt;&lt;code&gt;Relay.QL&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Soportado en modo cl&amp;aacute;sico, compat y moderno. El uso detallado se explica en &lt;a href=&quot;api-reference-relay-ql#array-fields&quot;&gt; &lt;code&gt;Relay.QL&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="65d6a8d5361414a2749b7b32500d3781b01e64c3" translate="yes" xml:space="preserve">
          <source>Sweet! Let's keep going and get the next four!</source>
          <target state="translated">¡Genial! ¡Sigamos adelante y consigamos los siguientes cuatro!</target>
        </trans-unit>
        <trans-unit id="28e2c6a12e1af3dcd74179eb09b97b7b134beae3" translate="yes" xml:space="preserve">
          <source>Switch the &lt;code&gt;'react-relay/compat'&lt;/code&gt; references in your app to &lt;code&gt;'react-relay'&lt;/code&gt;. This is more of a clean-up step that prevents your app from pulling in unnecessary &lt;code&gt;'react-relay/classic'&lt;/code&gt; code.</source>
          <target state="translated">Cambie las referencias &lt;code&gt;'react-relay/compat'&lt;/code&gt; en su aplicaci&amp;oacute;n a &lt;code&gt;'react-relay'&lt;/code&gt; . Este es m&amp;aacute;s un paso de limpieza que evita que su aplicaci&amp;oacute;n extraiga un c&amp;oacute;digo &lt;code&gt;'react-relay/classic'&lt;/code&gt; innecesario .</target>
        </trans-unit>
        <trans-unit id="21d278837034557e7a9b46210d42d6e7b8075142" translate="yes" xml:space="preserve">
          <source>Terminology</source>
          <target state="translated">Terminology</target>
        </trans-unit>
        <trans-unit id="3965436aa1e25eb8c1a80de5c7180c888af16646" translate="yes" xml:space="preserve">
          <source>That input argument should contain a (string) &quot;clientMutationId&quot; property for the purposes of reconciling requests and responses (automatically added by the &lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; API).</source>
          <target state="translated">Ese argumento de entrada debe contener una propiedad (cadena) &quot;clientMutationId&quot; con el fin de conciliar solicitudes y respuestas (agregadas autom&amp;aacute;ticamente por la API &lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="56c0a2575be8f36ad7f5d4d04acffdd56aaaf9ea" translate="yes" xml:space="preserve">
          <source>That used the &lt;code&gt;first&lt;/code&gt; argument to &lt;code&gt;ships&lt;/code&gt; to slice the result set down to the first one. But what if we wanted to paginate through it? On each edge, a cursor will be exposed that we can use to paginate. Let's ask for the first two this time, and get the cursor as well:</source>
          <target state="translated">Eso us&amp;oacute; el &lt;code&gt;first&lt;/code&gt; argumento a los &lt;code&gt;ships&lt;/code&gt; para dividir el resultado establecido en el primero. Pero, &amp;iquest;y si quisi&amp;eacute;ramos paginarlo? En cada borde, se expondr&amp;aacute; un cursor que podemos usar para paginar. Preguntemos por los dos primeros esta vez, y obtengamos tambi&amp;eacute;n el cursor:</target>
        </trans-unit>
        <trans-unit id="cdaffd6461c67e56056afce77a9bd307eee56aef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Node&lt;/code&gt; interface and &lt;code&gt;node&lt;/code&gt; field assume globally unique IDs for this refetching. A system without globally unique IDs can usually synthesize them by combining the type with the type-specific ID, which is what was done in this example.</source>
          <target state="translated">El &lt;code&gt;Node&lt;/code&gt; de interfaz y &lt;code&gt;node&lt;/code&gt; campo asumen identificadores &amp;uacute;nicos globales de este re-cargar. Un sistema sin ID globalmente &amp;uacute;nicos normalmente puede sintetizarlos combinando el tipo con el ID espec&amp;iacute;fico del tipo, que es lo que se hizo en este ejemplo.</target>
        </trans-unit>
        <trans-unit id="4249e055d5de1ea8000faee39fa1425b4eb71404" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Node&lt;/code&gt; interface contains a single field, &lt;code&gt;id&lt;/code&gt;, which is a &lt;code&gt;ID!&lt;/code&gt;. The &lt;code&gt;node&lt;/code&gt; root field takes a single argument, a &lt;code&gt;ID!&lt;/code&gt;, and returns a &lt;code&gt;Node&lt;/code&gt;. These two work in concert to allow refetching; if we pass the &lt;code&gt;id&lt;/code&gt; returned in that field to the &lt;code&gt;node&lt;/code&gt; field, we get the object back.</source>
          <target state="translated">La interfaz de &lt;code&gt;Node&lt;/code&gt; contiene un solo campo, &lt;code&gt;id&lt;/code&gt; , que es un &lt;code&gt;ID!&lt;/code&gt; . El campo ra&amp;iacute;z del &lt;code&gt;node&lt;/code&gt; toma un solo argumento, &amp;iexcl;una &lt;code&gt;ID!&lt;/code&gt; y devuelve un &lt;code&gt;Node&lt;/code&gt; . Estos dos trabajan en conjunto para permitir la recuperaci&amp;oacute;n; si pasamos la &lt;code&gt;id&lt;/code&gt; entificaci&amp;oacute;n devuelta en ese campo al campo del &lt;code&gt;node&lt;/code&gt; , recuperamos el objeto.</target>
        </trans-unit>
        <trans-unit id="69b82e1269cd3f5440edfdd8ab8e1cb4218f2a3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;applyUpdate&lt;/code&gt; adds a mutation just like &lt;code&gt;update&lt;/code&gt;, but does not commit it. It returns a &lt;code&gt;RelayMutationTransaction&lt;/code&gt; that can be committed or rollbacked.</source>
          <target state="translated">El &lt;code&gt;applyUpdate&lt;/code&gt; a&amp;ntilde;ade una mutaci&amp;oacute;n al igual que &lt;code&gt;update&lt;/code&gt; , pero no lo cometen. Devuelve una &lt;code&gt;RelayMutationTransaction&lt;/code&gt; que se puede confirmar o deshacer.</target>
        </trans-unit>
        <trans-unit id="c8a27cee9d1d9abe2e77bcb0c575a4357ce66c14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;babel-relay-plugin&lt;/code&gt; must run before the &lt;code&gt;react-native&lt;/code&gt; Babel preset. Thus, in &lt;code&gt;.babelrc&lt;/code&gt;&lt;code&gt;&quot;react-native&quot;&lt;/code&gt; must come after &lt;code&gt;babelRelayPlugin&lt;/code&gt;.</source>
          <target state="translated">El &lt;code&gt;babel-relay-plugin&lt;/code&gt; debe ejecutarse antes que el ajuste preestablecido de Babel &lt;code&gt;react-native&lt;/code&gt; . Por lo tanto, en &lt;code&gt;.babelrc&lt;/code&gt; &lt;code&gt;&quot;react-native&quot;&lt;/code&gt; debe ir despu&amp;eacute;s de &lt;code&gt;babelRelayPlugin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf0346f82ced9502e9b07bb0b45a4c3bf97fc831" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;commitUpdate&lt;/code&gt; method is analogous to dispatching an action in Flux. Relay processes the mutation as follows:</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;commitUpdate&lt;/code&gt; es an&amp;aacute;logo a enviar una acci&amp;oacute;n en Flux. Relay procesa la mutaci&amp;oacute;n de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="5916376d8984ac32cb4ef4378494b52a513ccdde" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;react-relay&lt;/code&gt; npm module includes &lt;code&gt;react&lt;/code&gt; as a &lt;em&gt;peer dependency&lt;/em&gt;. Your app should specify React as a dependency explicitly.</source>
          <target state="translated">El m&amp;oacute;dulo npm &lt;code&gt;react-relay&lt;/code&gt; incluye &lt;code&gt;react&lt;/code&gt; como una &lt;em&gt;dependencia de pares&lt;/em&gt; . Su aplicaci&amp;oacute;n debe especificar React como una dependencia expl&amp;iacute;citamente.</target>
        </trans-unit>
        <trans-unit id="687a2b2e72c0944702e22c85dfb54906ee9cc4a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;relay-compiler&lt;/code&gt; script requires both the directory which holds your source files as well as a path to your GraphQL schema in either a .json or .graphql schema file.</source>
          <target state="translated">La secuencia de comandos del &lt;code&gt;relay-compiler&lt;/code&gt; requiere tanto el directorio que contiene sus archivos de origen como una ruta a su esquema GraphQL en un archivo de esquema .json o .graphql.</target>
        </trans-unit>
        <trans-unit id="09a465866585d4ac0fa1f3ec8871e9ae5a93fc4f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;renderFailure&lt;/code&gt; callback is called with two arguments: an &lt;code&gt;Error&lt;/code&gt; object and a function to retry the request. If the error was the result of a server error communicated in the server's response, the response payload is available for inspection on &lt;code&gt;error.source&lt;/code&gt;.</source>
          <target state="translated">La &lt;code&gt;renderFailure&lt;/code&gt; llamada renderFailure se llama con dos argumentos: un objeto &lt;code&gt;Error&lt;/code&gt; y una funci&amp;oacute;n para reintentar la solicitud. Si el error fue el resultado de un error del servidor comunicado en la respuesta del servidor, la carga &amp;uacute;til de respuesta est&amp;aacute; disponible para su inspecci&amp;oacute;n en &lt;code&gt;error.source&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fec68a6615738a8b02b918d7e606ef06cece0ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;renderFetched&lt;/code&gt; callback is always called with a &lt;code&gt;data&lt;/code&gt; argument, which is an object mapping from &lt;code&gt;propName&lt;/code&gt; to query data. It is expected that the &lt;code&gt;renderFetched&lt;/code&gt; callback renders the supplied &lt;code&gt;Component&lt;/code&gt; with them (e.g. using the &lt;a href=&quot;https://facebook.github.io/react/docs/jsx-spread.html&quot;&gt;JSX spread attributes feature&lt;/a&gt;).</source>
          <target state="translated">La &lt;code&gt;renderFetched&lt;/code&gt; llamada renderFetched siempre se llama con un argumento de &lt;code&gt;data&lt;/code&gt; , que es una asignaci&amp;oacute;n de objeto de &lt;code&gt;propName&lt;/code&gt; a los datos de la consulta. Se espera que la &lt;code&gt;renderFetched&lt;/code&gt; llamada renderFetched represente el &lt;code&gt;Component&lt;/code&gt; e suministrado con ellos (por ejemplo, utilizando la &lt;a href=&quot;https://facebook.github.io/react/docs/jsx-spread.html&quot;&gt;funci&amp;oacute;n de atributos de extensi&amp;oacute;n JSX&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="fc694dd64cc47d448a84516c45884dcebf08a20c" translate="yes" xml:space="preserve">
          <source>The API is overall simpler and more predictable.</source>
          <target state="translated">El API es en general más simple y más predecible.</target>
        </trans-unit>
        <trans-unit id="a3270609e5596533f39e48f966bd5c2bc4660cc1" translate="yes" xml:space="preserve">
          <source>The DataID of the parent node that contains the connection. This argument is optional.</source>
          <target state="translated">El DataID del nodo padre que contiene la conexión.Este argumento es opcional.</target>
        </trans-unit>
        <trans-unit id="c4a8c9e60c4dd38c187162160297b7cec4fec7f9" translate="yes" xml:space="preserve">
          <source>The IDs we got back were base64 strings. IDs are designed to be opaque (the only thing that should be passed to the &lt;code&gt;id&lt;/code&gt; argument on &lt;code&gt;node&lt;/code&gt; is the unaltered result of querying &lt;code&gt;id&lt;/code&gt; on some object in the system), and base64ing a string is a useful convention in GraphQL to remind viewers that the string is an opaque identifier.</source>
          <target state="translated">Las identificaciones que obtuvimos fueron cadenas base64. Los identificadores est&amp;aacute;n dise&amp;ntilde;ados para ser opacos (lo &amp;uacute;nico que debe pasarse al argumento &lt;code&gt;id&lt;/code&gt; en el &lt;code&gt;node&lt;/code&gt; es el resultado inalterado de consultar el &lt;code&gt;id&lt;/code&gt; en alg&amp;uacute;n objeto en el sistema), y basar una cadena es una convenci&amp;oacute;n &amp;uacute;til en GraphQL para recordar a los espectadores que el cadena es un identificador opaco.</target>
        </trans-unit>
        <trans-unit id="7450121d3a10cfde0d27fedec5e7487c759f4cef" translate="yes" xml:space="preserve">
          <source>The Relay &quot;Environment&quot;</source>
          <target state="translated">El Relevo &quot;Medio Ambiente&quot;</target>
        </trans-unit>
        <trans-unit id="29a5b8d00ca84a6ecf522b93deabead7921f8457" translate="yes" xml:space="preserve">
          <source>The Relay &quot;Environment&quot; bundles together the configuration, cache storage, and network-handling that Relay needs in order to operate.</source>
          <target state="translated">El &quot;entorno&quot; del relé reúne la configuración,el almacenamiento en caché y el manejo de la red que el relé necesita para funcionar.</target>
        </trans-unit>
        <trans-unit id="04d65a89a2e8d48fa93bad9ecd0dc074fc69e421" translate="yes" xml:space="preserve">
          <source>The Relay &amp;quot;Environment&amp;quot;</source>
          <target state="translated">El &quot;entorno&quot; del rel&amp;eacute;</target>
        </trans-unit>
        <trans-unit id="ee388b82ec2168b63f7ecfa7840c723aabafb1e3" translate="yes" xml:space="preserve">
          <source>The Relay &lt;code&gt;Store&lt;/code&gt; provides an API for dispatching mutations to the server.</source>
          <target state="translated">Relay &lt;code&gt;Store&lt;/code&gt; proporciona una API para enviar mutaciones al servidor.</target>
        </trans-unit>
        <trans-unit id="8f70d28e27ab15f03147076b8dda3030c0a0078e" translate="yes" xml:space="preserve">
          <source>The Relay Classic and Relay Compat modes produce generated content inline and may catch and log any detected GraphQL validation errors, leaving those errors to be thrown at runtime.</source>
          <target state="translated">Los modos Relay Classic y Relay Compat producen contenido generado en línea y pueden captar y registrar cualquier error de validación de GraphQL detectado,dejando que esos errores sean lanzados en tiempo de ejecución.</target>
        </trans-unit>
        <trans-unit id="b710564e5046fb16b4d54484e5bd00a02c1c71b3" translate="yes" xml:space="preserve">
          <source>The Relay Compiler is responsible for generating code as part of a build step which, at runtime, can be used statically. By building the query ahead of time, the client's JS runtime is not responsible for generating a query string, and fields that are duplicated in the query can be merged during the build step, to improve parsing efficiency. If you have the ability to persist queries to your server, the compiler's code generation process provides a convenient time to convert a query or mutation's text into a unique identifier, which greatly reduces the upload bytes required.</source>
          <target state="translated">El Compilador de Relevos es responsable de generar código como parte de un paso de construcción que,en tiempo de ejecución,puede ser usado estáticamente.Al construir la consulta con antelación,el tiempo de ejecución JS del cliente no es responsable de generar una cadena de consulta,y los campos que están duplicados en la consulta pueden ser fusionados durante el paso de construcción,para mejorar la eficiencia del análisis sintáctico.Si tiene la capacidad de persistir las consultas a su servidor,el proceso de generación de código del compilador proporciona un tiempo conveniente para convertir el texto de una consulta o mutación en un identificador único,lo que reduce en gran medida los bytes de carga necesarios.</target>
        </trans-unit>
        <trans-unit id="63623a8a89bd3ad461c1fe2298a373e6892186d0" translate="yes" xml:space="preserve">
          <source>The Relay Modern Core adds support for client schema extensions. These allow Relay to conveniently store some extra information with data fetched from the server and be rendered like any other field fetched from the server. This should be able to replace some use cases that previously required a Flux/Redux store on the side.</source>
          <target state="translated">El Relay Modern Core añade soporte para extensiones de esquemas de clientes.Estas permiten a Relay almacenar convenientemente alguna información extra con datos obtenidos del servidor y ser renderizados como cualquier otro campo obtenido del servidor.Esto debería ser capaz de reemplazar algunos casos de uso que anteriormente requerían un almacenamiento de Flux/Redux en el lateral.</target>
        </trans-unit>
        <trans-unit id="d7d5ac1a62f052029edc67e6900f799b310cde67" translate="yes" xml:space="preserve">
          <source>The Relay Modern packages distributed on NPM use the widely-supported ES5 version of JavaScript to support as many browser environments as possible.</source>
          <target state="translated">Los paquetes Relay Modern distribuidos en NPM utilizan la versión ES5 de JavaScript,ampliamente soportada,para soportar el mayor número de entornos de navegación posible.</target>
        </trans-unit>
        <trans-unit id="3f35b4d76fe696a95341841f45e165e3b0c6aad8" translate="yes" xml:space="preserve">
          <source>The Relay Network Layer</source>
          <target state="translated">La Capa de la Red de Relevos</target>
        </trans-unit>
        <trans-unit id="d750d1085b7a107c9c036e90d472c451b5fb59af" translate="yes" xml:space="preserve">
          <source>The Relay runtime bundle is roughly 20% of the size of Relay Classic.</source>
          <target state="translated">El paquete de tiempo de ejecución del relevo es aproximadamente el 20% del tamaño del Relevo Clásico.</target>
        </trans-unit>
        <trans-unit id="a2170027015b9ca88c5f922e040a93d95772d2c0" translate="yes" xml:space="preserve">
          <source>The Relay store can be mutated programatically in advanced edge cases when optimistic updates need more granular control. The following API methods are useful for mutating your connections and fragments.</source>
          <target state="translated">El almacén de Relevos puede mutar programáticamente en casos de borde avanzado cuando las actualizaciones optimistas necesitan más control granular.Los siguientes métodos de la API son útiles para mutar sus conexiones y fragmentos.</target>
        </trans-unit>
        <trans-unit id="0adc8d247f24c64744fe2ba30ece6da8fd08a649" translate="yes" xml:space="preserve">
          <source>The author of this story also commented on it &amp;mdash; quite common. Now imagine that some other view fetches new information about the author, and her profile photo has changed to a new URI. Here's the &lt;em&gt;only&lt;/em&gt; part of our cached data that changes:</source>
          <target state="translated">El autor de esta historia tambi&amp;eacute;n lo coment&amp;oacute;, bastante com&amp;uacute;n. Ahora imagine que otra vista obtiene nueva informaci&amp;oacute;n sobre el autor y su foto de perfil ha cambiado a un nuevo URI. Aqu&amp;iacute; est&amp;aacute; la &lt;em&gt;&amp;uacute;nica&lt;/em&gt; parte de nuestros datos en cach&amp;eacute; que cambia:</target>
        </trans-unit>
        <trans-unit id="980a4b6788111d51d4fd5d3c6e5054ad267e5ae0" translate="yes" xml:space="preserve">
          <source>The best way to get started right now is to take a look at how these three parts come together to form a working example. The tutorial on the next page will lead you through an example application, using the &lt;a href=&quot;https://github.com/facebook/relay-starter-kit&quot;&gt;Relay Starter Kit&lt;/a&gt;, to give you an idea of how you can start using Relay on yours.</source>
          <target state="translated">La mejor manera de comenzar ahora mismo es observar c&amp;oacute;mo se unen estas tres partes para formar un ejemplo pr&amp;aacute;ctico. El tutorial de la p&amp;aacute;gina siguiente lo guiar&amp;aacute; a trav&amp;eacute;s de una aplicaci&amp;oacute;n de ejemplo, utilizando el &lt;a href=&quot;https://github.com/facebook/relay-starter-kit&quot;&gt;kit de&lt;/a&gt; inicio de Relay, para darle una idea de c&amp;oacute;mo puede comenzar a usar Relay en el suyo.</target>
        </trans-unit>
        <trans-unit id="5bc022d566f4b68dd38c73222756f331714be645" translate="yes" xml:space="preserve">
          <source>The client and server are decoupled: the client specifies the data needed instead of &lt;em&gt;relying on&lt;/em&gt; the server endpoint to return the correct data.</source>
          <target state="translated">El cliente y el servidor est&amp;aacute;n desacoplados: el cliente especifica los datos necesarios en lugar de &lt;em&gt;depender&lt;/em&gt; del punto final del servidor para devolver los datos correctos.</target>
        </trans-unit>
        <trans-unit id="00a902f03306b6ea1e1e2818025625742f4e212c" translate="yes" xml:space="preserve">
          <source>The component-based approach of React Router v4 does not readily allow for aggregating the data requirements for nested routes, and as such does not readily permit an approach that will avoid request waterfalls from nesting &lt;code&gt;QueryRenderer&lt;/code&gt; components.</source>
          <target state="translated">El enfoque basado en componentes de React Router v4 no permite agregar f&amp;aacute;cilmente los requisitos de datos para rutas anidadas y, como tal, no permite f&amp;aacute;cilmente un enfoque que evite las cascadas de solicitudes de los componentes &lt;code&gt;QueryRenderer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7298679167473c58332d417e6d2bd4de9988163d" translate="yes" xml:space="preserve">
          <source>The container &amp;mdash; named &lt;code&gt;Relay(ProfilePicture)&lt;/code&gt; for debugging &amp;mdash; will retrieve the response for each GraphQL fragment from the local store.</source>
          <target state="translated">El contenedor, llamado &lt;code&gt;Relay(ProfilePicture)&lt;/code&gt; para depuraci&amp;oacute;n, recuperar&amp;aacute; la respuesta para cada fragmento de GraphQL de la tienda local.</target>
        </trans-unit>
        <trans-unit id="d147ef4301d6fa557024d99f96f08a499bbc3a4a" translate="yes" xml:space="preserve">
          <source>The container passes the results of each fragment (along with the other props) to the &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; component.</source>
          <target state="translated">El contenedor pasa los resultados de cada fragmento (junto con los dem&amp;aacute;s accesorios) al componente &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="268b06824cede0c427a01e0d80dbe18daf1354c3" translate="yes" xml:space="preserve">
          <source>The default implementation is as follows:</source>
          <target state="translated">La aplicación por defecto es la siguiente:</target>
        </trans-unit>
        <trans-unit id="bf32b3124e1516fba4edb1784393b843530e0823" translate="yes" xml:space="preserve">
          <source>The defaults we specify here will become available to our fragment builders:</source>
          <target state="translated">Los valores predeterminados que especificamos aquí estarán disponibles para nuestros constructores de fragmentos:</target>
        </trans-unit>
        <trans-unit id="fe89d1880c282b0f84f7ad747dcf711ed35e9199" translate="yes" xml:space="preserve">
          <source>The easiest way to get started for now is with the &lt;a href=&quot;https://github.com/relayjs/relay-starter-kit&quot;&gt;Relay Starter Kit&lt;/a&gt; - this includes an example schema file and configures the &lt;a href=&quot;https://www.npmjs.com/package/babel-relay-plugin&quot;&gt;&lt;code&gt;babel-relay-plugin&lt;/code&gt;&lt;/a&gt; npm module to transpile queries.</source>
          <target state="translated">La forma m&amp;aacute;s f&amp;aacute;cil de comenzar por ahora es con el &lt;a href=&quot;https://github.com/relayjs/relay-starter-kit&quot;&gt;Relay Starter Kit&lt;/a&gt; , que incluye un archivo de esquema de ejemplo y configura el m&amp;oacute;dulo npm &lt;a href=&quot;https://www.npmjs.com/package/babel-relay-plugin&quot;&gt; &lt;code&gt;babel-relay-plugin&lt;/code&gt; &lt;/a&gt; para transpilar consultas.</target>
        </trans-unit>
        <trans-unit id="ef9027831057a9dfdeaac970a51f94ff44007267" translate="yes" xml:space="preserve">
          <source>The example above did not configure a &lt;code&gt;handlerProvider&lt;/code&gt;, which means that a default one will be provided. Relay Modern comes with a couple of built-in handlers that augment the core with special functionality for handling connections (which is not a standard GraphQL feature, but a set of pagination conventions used at Facebook, specified in detail in the &lt;a href=&quot;graphql-connections&quot;&gt;Relay Cursor Connections Specification&lt;/a&gt;, and well-supported by Relay itself) and the &lt;code&gt;viewer&lt;/code&gt; field (again, not a standard GraphQL schema feature, but one which has been conventionally used extensively within Facebook).</source>
          <target state="translated">El ejemplo anterior no configur&amp;oacute; un &lt;code&gt;handlerProvider&lt;/code&gt; , lo que significa que se proporcionar&amp;aacute; uno predeterminado. Relay Modern viene con un par de controladores integrados que aumentan el n&amp;uacute;cleo con una funcionalidad especial para manejar conexiones (que no es una caracter&amp;iacute;stica est&amp;aacute;ndar de GraphQL, sino un conjunto de convenciones de paginaci&amp;oacute;n utilizadas en Facebook, especificadas en detalle en la &lt;a href=&quot;graphql-connections&quot;&gt;Especificaci&amp;oacute;n de conexiones de cursor de retransmisi&amp;oacute;n)&lt;/a&gt; . y bien respaldado por el propio Relay) y el campo del &lt;code&gt;viewer&lt;/code&gt; (de nuevo, no es una funci&amp;oacute;n de esquema GraphQL est&amp;aacute;ndar, pero una que se ha utilizado de forma convencional y extensiva en Facebook).</target>
        </trans-unit>
        <trans-unit id="4657e52da9059d7f3c2e9423e8542337bf25d573" translate="yes" xml:space="preserve">
          <source>The example above is very similar to the classic container API, but in the modern API we can just pass the &lt;code&gt;graphql&lt;/code&gt; template literal directly as the second argument. Relay will infer the prop name from the fragment name according to the fragment naming convention &lt;code&gt;&amp;lt;FileName&amp;gt;_&amp;lt;propName&amp;gt;&lt;/code&gt;. The example below is equivalent to the one above:</source>
          <target state="translated">El ejemplo anterior es muy similar a la API de contenedor cl&amp;aacute;sica, pero en la API moderna podemos simplemente pasar el literal de la plantilla &lt;code&gt;graphql&lt;/code&gt; directamente como segundo argumento. Relay inferir&amp;aacute; el nombre de la propiedad a partir del nombre del fragmento de acuerdo con la convenci&amp;oacute;n de nomenclatura de fragmentos &lt;code&gt;&amp;lt;FileName&amp;gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; . El siguiente ejemplo es equivalente al anterior:</target>
        </trans-unit>
        <trans-unit id="1d30073e8f5f3cb9668f92d3d480a82b915306f9" translate="yes" xml:space="preserve">
          <source>The fat query</source>
          <target state="translated">La pregunta de la grasa</target>
        </trans-unit>
        <trans-unit id="9eb6dbc6b6ef5c5d8b4847ee0b1b967260b02889" translate="yes" xml:space="preserve">
          <source>The field name in the response that contains the DataID of the deleted node</source>
          <target state="translated">El nombre del campo en la respuesta que contiene el DataID del nodo eliminado</target>
        </trans-unit>
        <trans-unit id="3ca688eaa1e1f955641e421703e810ed047c2005" translate="yes" xml:space="preserve">
          <source>The field name in the response that contains the DataID of the removed node, or the path to the node removed from the connection</source>
          <target state="translated">El nombre del campo en la respuesta que contiene el DataID del nodo eliminado,o la ruta del nodo eliminado de la conexión</target>
        </trans-unit>
        <trans-unit id="ba191931e9ab489b27a9f33f746bef212888dc1a" translate="yes" xml:space="preserve">
          <source>The field name in the response that represents the connection</source>
          <target state="translated">El nombre del campo en la respuesta que representa la conexión</target>
        </trans-unit>
        <trans-unit id="a1b90e077151b889c8402ab5f53851a0ff440462" translate="yes" xml:space="preserve">
          <source>The field name in the response that represents the newly created edge</source>
          <target state="translated">El nombre del campo en la respuesta que representa el borde recién creado</target>
        </trans-unit>
        <trans-unit id="f9886e317b707740faab57f9ea8a72831a041943" translate="yes" xml:space="preserve">
          <source>The field name in the response that represents the parent of the connection</source>
          <target state="translated">El nombre del campo en la respuesta que representa el padre de la conexión</target>
        </trans-unit>
        <trans-unit id="9edac1a03bde2552ba82cb38e1a432234c65b349" translate="yes" xml:space="preserve">
          <source>The final data declaration is equivalent to the following plain GraphQL:</source>
          <target state="translated">La declaración final de datos es equivalente al siguiente GraphQL simple:</target>
        </trans-unit>
        <trans-unit id="cfe19d046a9f42c5d948f0aa018690d7ab173c0c" translate="yes" xml:space="preserve">
          <source>The first query was for a list of stories:</source>
          <target state="translated">La primera consulta fue para una lista de historias:</target>
        </trans-unit>
        <trans-unit id="0d313c5be837c1f0e863c8d541edf651d250cb38" translate="yes" xml:space="preserve">
          <source>The initial set of variable values available to this component's fragments.</source>
          <target state="translated">El conjunto inicial de valores variables disponibles para los fragmentos de este componente.</target>
        </trans-unit>
        <trans-unit id="f7e74d01f7e6ff80db2700d9894a53e56b4a4d76" translate="yes" xml:space="preserve">
          <source>The most-used function is &lt;a href=&quot;#createcontainer-static-method&quot;&gt;&lt;code&gt;createContainer()&lt;/code&gt;&lt;/a&gt; which wraps components with data declarations.</source>
          <target state="translated">La funci&amp;oacute;n m&amp;aacute;s utilizada es &lt;a href=&quot;#createcontainer-static-method&quot;&gt; &lt;code&gt;createContainer()&lt;/code&gt; &lt;/a&gt; que envuelve componentes con declaraciones de datos.</target>
        </trans-unit>
        <trans-unit id="6618aeb6f5361bcac94a3181ad8b6a8339b0abc1" translate="yes" xml:space="preserve">
          <source>The mutation should take a single argument named &quot;input&quot;.</source>
          <target state="translated">La mutación debe tomar un solo argumento llamado &quot;input&quot;.</target>
        </trans-unit>
        <trans-unit id="a3c29d0940ced0048c0feb3200ee57be78138845" translate="yes" xml:space="preserve">
          <source>The new Relay Modern core is more light-weight and significantly faster than the previous version. It is redesigned to work with static queries, which allow us to push more work to build/compilation time. The Modern core is much smaller as a result of removing a lot of the complex features required for dynamic queries. The new core is also an order of magnitude faster in processing the response with an optimized parsing instruction set that is generated at build time. We no longer keep around tracking information needed for dynamic query generation, which drastically reduces the memory overhead of using Relay. This means more memory is left for making the UI feel responsive. Relay Modern also supports persisted queries, reducing the upload size of the request from the full query text to a simple id.</source>
          <target state="translated">El nuevo núcleo de Relay Modern es más ligero y significativamente más rápido que la versión anterior.Está rediseñado para trabajar con consultas estáticas,lo que nos permite empujar más trabajo al tiempo de construcción/compilación.El núcleo Moderno es mucho más pequeño como resultado de la eliminación de muchas de las complejas características requeridas para las consultas dinámicas.El nuevo núcleo es también un orden de magnitud más rápido en el procesamiento de la respuesta con un conjunto de instrucciones de análisis optimizado que se genera en el tiempo de construcción.Ya no nos mantenemos alrededor de la información de seguimiento necesaria para la generación de consultas dinámicas,lo que reduce drásticamente la sobrecarga de memoria del uso del Relé.Esto significa que queda más memoria para hacer que la interfaz de usuario se sienta sensible.Relay Modern también soporta consultas persistentes,reduciendo el tamaño de la carga de la solicitud del texto completo de la consulta a un simple id.</target>
        </trans-unit>
        <trans-unit id="bfe2b2be8025972db06fd439006437e8dca5cc49" translate="yes" xml:space="preserve">
          <source>The next logical approach is to use &lt;code&gt;render()&lt;/code&gt; as the means of initiating data-fetching. We could simply render the application once, see what data it needed, fetch that data, and render again. This sounds great, but the problem is that &lt;em&gt;components use data to figure out what to render!&lt;/em&gt; In other words, this would force data-fetching to be staged: first render the root and see what data it needs, then render its children and see what they need, all the way down the tree. If each stage incurs network request, rendering would require slow, serial roundtrips. We needed a way to determine all the data needs up-front or &lt;em&gt;statically&lt;/em&gt;.</source>
          <target state="translated">El siguiente enfoque l&amp;oacute;gico es utilizar &lt;code&gt;render()&lt;/code&gt; como medio para iniciar la b&amp;uacute;squeda de datos. Podr&amp;iacute;amos simplemente renderizar la aplicaci&amp;oacute;n una vez, ver qu&amp;eacute; datos necesitaba, recuperar esos datos y volver a renderizar. Esto suena genial, pero el problema es que los &lt;em&gt;componentes usan datos para descubrir qu&amp;eacute; renderizar.&lt;/em&gt; En otras palabras, esto obligar&amp;iacute;a a realizar la b&amp;uacute;squeda de datos: primero renderice la ra&amp;iacute;z y vea qu&amp;eacute; datos necesita, luego renderice sus hijos y vea lo que necesitan, hasta el final del &amp;aacute;rbol. Si cada etapa incurre en una solicitud de red, la renderizaci&amp;oacute;n requerir&amp;iacute;a viajes de ida y vuelta en serie lentos. Necesit&amp;aacute;bamos una forma de determinar todas las necesidades de datos por adelantado o de &lt;em&gt;forma est&amp;aacute;tica&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5b53cde5515b59c4d3a0131621b4782b7479a272" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;config&lt;/code&gt; parameter can be used to configure a &lt;code&gt;RANGE_ADD&lt;/code&gt; or other type of mutation, as per the &lt;code&gt;Relay.Mutation&lt;/code&gt; API. This tells Relay how to process the response.</source>
          <target state="translated">El par&amp;aacute;metro de &lt;code&gt;config&lt;/code&gt; uraci&amp;oacute;n opcional se puede utilizar para configurar un &lt;code&gt;RANGE_ADD&lt;/code&gt; u otro tipo de mutaci&amp;oacute;n, seg&amp;uacute;n la API &lt;code&gt;Relay.Mutation&lt;/code&gt; . Esto le dice a Relay c&amp;oacute;mo procesar la respuesta.</target>
        </trans-unit>
        <trans-unit id="3043696978b404d79349bb97fe99dc6847323bfb" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;config&lt;/code&gt; parameter can be used to configure a &lt;code&gt;RANGE_ADD&lt;/code&gt; or other type of mutation, similar to the &lt;code&gt;Relay.Mutation&lt;/code&gt; API.</source>
          <target state="translated">El par&amp;aacute;metro de &lt;code&gt;config&lt;/code&gt; uraci&amp;oacute;n opcional se puede utilizar para configurar un &lt;code&gt;RANGE_ADD&lt;/code&gt; u otro tipo de mutaci&amp;oacute;n, similar a la API &lt;code&gt;Relay.Mutation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a65fc26cbbecf69c5a0fe03882c96f57450485e1" translate="yes" xml:space="preserve">
          <source>The options listed above are not exhaustive. If you are aware of other routing solutions that work well with Relay Modern, &lt;a href=&quot;https://github.com/facebook/relay/issues/new&quot;&gt;please let us know&lt;/a&gt;.</source>
          <target state="translated">Las opciones enumeradas anteriormente no son exhaustivas. Si conoce otras soluciones de enrutamiento que funcionan bien con Relay Modern, &lt;a href=&quot;https://github.com/facebook/relay/issues/new&quot;&gt;h&amp;aacute;ganoslo saber&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e4e5487396fd07e7501191686f068ec10dba2a30" translate="yes" xml:space="preserve">
          <source>The pagination container expects the connection field to be annotated with a &lt;code&gt;@connection(key: ...)&lt;/code&gt; directive, where the &lt;code&gt;key&lt;/code&gt; is expected to be a unique identifier under the parent field type &lt;code&gt;User&lt;/code&gt;. A good practice could be &lt;code&gt;&amp;lt;ComponentName&amp;gt;_&amp;lt;fieldName | fieldAlias&amp;gt;&lt;/code&gt;. By default, Relay generates storage key based on the user-supplied &lt;code&gt;key&lt;/code&gt; and all non-filter variables of the field. Relay also provides an advanced feature &lt;code&gt;@connection(key: 'FriendsList_friends', filters:['orderBy', ...])&lt;/code&gt; that allows you to explicitly specify which variables should be used to generate the storage key. Particularly, if you write &lt;code&gt;@connection(key: ..., filters:[])&lt;/code&gt;, Relay will ignore all the variables.</source>
          <target state="translated">El contenedor de paginaci&amp;oacute;n espera que el campo de conexi&amp;oacute;n se anote con una &lt;code&gt;@connection(key: ...)&lt;/code&gt; , donde se espera que la &lt;code&gt;key&lt;/code&gt; sea ​​un identificador &amp;uacute;nico bajo el tipo de campo principal &lt;code&gt;User&lt;/code&gt; . Una buena pr&amp;aacute;ctica podr&amp;iacute;a ser &lt;code&gt;&amp;lt;ComponentName&amp;gt;_&amp;lt;fieldName | fieldAlias&amp;gt;&lt;/code&gt; . De forma predeterminada, Relay genera una clave de almacenamiento basada en la &lt;code&gt;key&lt;/code&gt; proporcionada por el usuario y todas las variables del campo sin filtro. Relay tambi&amp;eacute;n proporciona una funci&amp;oacute;n avanzada &lt;code&gt;@connection(key: 'FriendsList_friends', filters:['orderBy', ...])&lt;/code&gt; que le permite especificar expl&amp;iacute;citamente qu&amp;eacute; variables deben usarse para generar la clave de almacenamiento. En particular, si escribe &lt;code&gt;@connection(key: ..., filters:[])&lt;/code&gt; , Relay ignorar&amp;aacute; todas las variables.</target>
        </trans-unit>
        <trans-unit id="c30fe4d3ed3c530120fea7a2dc37c47a35768d8b" translate="yes" xml:space="preserve">
          <source>The plugin needs to understand your schema - &lt;code&gt;schemaData&lt;/code&gt; in the above snippet. There are two ways to get this information, depending on the GraphQL implementation.</source>
          <target state="translated">El complemento debe comprender su esquema: &lt;code&gt;schemaData&lt;/code&gt; en el fragmento anterior. Hay dos formas de obtener esta informaci&amp;oacute;n, seg&amp;uacute;n la implementaci&amp;oacute;n de GraphQL.</target>
        </trans-unit>
        <trans-unit id="486acc4ff0b4938f682801c80ee8b2d7dd1df93e" translate="yes" xml:space="preserve">
          <source>The premise of the example is that we want to use GraphQL to query for information about ships and factions in the original Star Wars trilogy.</source>
          <target state="translated">La premisa del ejemplo es que queremos usar GraphQL para buscar información sobre naves y facciones en la trilogía original de La Guerra de las Galaxias.</target>
        </trans-unit>
        <trans-unit id="1d83274a567a8154b4431388aa9d20ca339eaa3b" translate="yes" xml:space="preserve">
          <source>The primary way to declare data requirements is via &lt;code&gt;Relay.Container&lt;/code&gt; &amp;mdash; a higher-order React component that lets React components encode their data requirements.</source>
          <target state="translated">La forma principal de declarar los requisitos de datos es a trav&amp;eacute;s de &lt;code&gt;Relay.Container&lt;/code&gt; , un componente de React de orden superior que permite a los componentes de React codificar sus requisitos de datos.</target>
        </trans-unit>
        <trans-unit id="808db6b1b18bc85b64f9d26f1bddf44bf5968046" translate="yes" xml:space="preserve">
          <source>The primary way to declare data requirements is via &lt;code&gt;createFragmentContainer&lt;/code&gt; &amp;mdash; a higher-order React component that lets React components encode their data requirements.</source>
          <target state="translated">La forma principal de declarar los requisitos de datos es a trav&amp;eacute;s de &lt;code&gt;createFragmentContainer&lt;/code&gt; , un componente de React de orden superior que permite a los componentes de React codificar sus requisitos de datos.</target>
        </trans-unit>
        <trans-unit id="444774c5f652cc1826eed622e4a92e2c3f0e2e4b" translate="yes" xml:space="preserve">
          <source>The properties and methods listed below can be accessed on &lt;code&gt;this.props.relay&lt;/code&gt; from the wrapped React component.</source>
          <target state="translated">Se puede acceder a las propiedades y m&amp;eacute;todos enumerados a continuaci&amp;oacute;n en &lt;code&gt;this.props.relay&lt;/code&gt; desde el componente React envuelto.</target>
        </trans-unit>
        <trans-unit id="595d44efe5adb2587c5aa09916b466fe64246e19" translate="yes" xml:space="preserve">
          <source>The query should request &quot;clientMutationId&quot; as a subselection.</source>
          <target state="translated">La consulta debe pedir &quot;clientMutationId&quot; como una subselección.</target>
        </trans-unit>
        <trans-unit id="fcd6ab3548bb5d3b4f5a6f857ba30959f05237cb" translate="yes" xml:space="preserve">
          <source>The reasoning is that if &lt;code&gt;babel-plugin-relay&lt;/code&gt; does not run before the &lt;code&gt;es2015-template-literals&lt;/code&gt; transform, it will not transform the Relay.QL template literals correctly. Also in Babel 6, you can&amp;rsquo;t control plugin order. So in React Native, where plugins in &lt;code&gt;.babelrc&lt;/code&gt; are loaded before the projects &lt;code&gt;.babelrc&lt;/code&gt;, it&amp;rsquo;s impossible to use the Babel Relay Plugin without overriding the entire transform list.</source>
          <target state="translated">El razonamiento es que si &lt;code&gt;babel-plugin-relay&lt;/code&gt; no se ejecuta antes de la &lt;code&gt;es2015-template-literals&lt;/code&gt; , no transformar&amp;aacute; correctamente los literales de la plantilla Relay.QL. Adem&amp;aacute;s, en Babel 6, no puede controlar el orden de los complementos. Entonces, en React Native, donde los complementos en &lt;code&gt;.babelrc&lt;/code&gt; se cargan antes que los proyectos &lt;code&gt;.babelrc&lt;/code&gt; , es imposible usar el complemento Babel Relay sin anular toda la lista de transformaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7803dad9067c5d50b3b4bf3ebacbfaade89ec277" translate="yes" xml:space="preserve">
          <source>The runtime automatically removes cached data that is no longer referenced, helping to reduce memory usage.</source>
          <target state="translated">El tiempo de ejecución elimina automáticamente los datos almacenados en caché que ya no están referenciados,lo que ayuda a reducir el uso de la memoria.</target>
        </trans-unit>
        <trans-unit id="7502725bdbb2c17f80ff460d7924092be097b33c" translate="yes" xml:space="preserve">
          <source>The schema described below will be used to demonstrate the functionality that a GraphQL server used by Relay should implement. The two core types are a faction and a ship in the Star Wars universe, where a faction has many ships associated with it. The schema below is the output of the GraphQL.js &lt;a href=&quot;https://github.com/graphql/graphql-js/blob/master/src/utilities/schemaPrinter.js&quot;&gt;&lt;code&gt;schemaPrinter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El esquema que se describe a continuaci&amp;oacute;n se utilizar&amp;aacute; para demostrar la funcionalidad que debe implementar un servidor GraphQL utilizado por Relay. Los dos tipos principales son una facci&amp;oacute;n y una nave en el universo de Star Wars, donde una facci&amp;oacute;n tiene muchas naves asociadas. El siguiente esquema es la salida de GraphQL.js &lt;a href=&quot;https://github.com/graphql/graphql-js/blob/master/src/utilities/schemaPrinter.js&quot;&gt; &lt;code&gt;schemaPrinter&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d1f4549e3c6f019d48ff8e76296ba821ef51f0c7" translate="yes" xml:space="preserve">
          <source>The second query refetched the information for one of those stories:</source>
          <target state="translated">La segunda consulta reestableció la información para una de esas historias:</target>
        </trans-unit>
        <trans-unit id="e1ce127879727af2e2de7fc1ce77bce3c4f43c30" translate="yes" xml:space="preserve">
          <source>The solution to caching GraphQL is to normalize the hierarchical response into a flat collection of &lt;strong&gt;records&lt;/strong&gt;. Relay implements this cache as a map from IDs to records. Each record is a map from field names to field values. Records may also link to other records (allowing it to describe a cyclic graph), and these links are stored as a special value type that references back into the top-level map. With this approach each server record is stored &lt;em&gt;once&lt;/em&gt; regardless of how it is fetched.</source>
          <target state="translated">La soluci&amp;oacute;n para almacenar en cach&amp;eacute; GraphQL es normalizar la respuesta jer&amp;aacute;rquica en una colecci&amp;oacute;n plana de &lt;strong&gt;registros&lt;/strong&gt; . Relay implementa este cach&amp;eacute; como un mapa de ID a registros. Cada registro es un mapa de nombres de campo a valores de campo. Los registros tambi&amp;eacute;n pueden vincularse a otros registros (lo que le permite describir un gr&amp;aacute;fico c&amp;iacute;clico), y estos v&amp;iacute;nculos se almacenan como un tipo de valor especial que hace referencia al mapa de nivel superior. Con este enfoque, cada registro de servidor se almacena &lt;em&gt;una vez,&lt;/em&gt; independientemente de c&amp;oacute;mo se obtenga.</target>
        </trans-unit>
        <trans-unit id="2238db3c2972a72399f41299cdb2bb500270de90" translate="yes" xml:space="preserve">
          <source>The term &amp;lsquo;variables&amp;rsquo; here refers to the input to the server-side mutation, &lt;strong&gt;not&lt;/strong&gt; to the variables made available to this mutation's fragment builders.</source>
          <target state="translated">El t&amp;eacute;rmino 'variables' aqu&amp;iacute; se refiere a la entrada a la mutaci&amp;oacute;n del lado del servidor, &lt;strong&gt;no&lt;/strong&gt; a las variables disponibles para los constructores de fragmentos de esta mutaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="595203acdb212fda1237b7e11b4700b733a663ad" translate="yes" xml:space="preserve">
          <source>The three core assumptions that Relay makes about a GraphQL server are that it provides:</source>
          <target state="translated">Los tres supuestos básicos que Relevo hace sobre un servidor GraphQL son que proporciona:</target>
        </trans-unit>
        <trans-unit id="80a872fa92f56ed5c31e04d7d32ff502b8f3fab1" translate="yes" xml:space="preserve">
          <source>The two methods differ in that instead of sending a query that includes only fields missing from the client, &lt;code&gt;forceFetch&lt;/code&gt; sends a request to refetch each and every fragment. This ensures that the props for the component are freshly fetched from the server.</source>
          <target state="translated">Los dos m&amp;eacute;todos difieren en que en lugar de enviar una consulta que incluye solo los campos que faltan en el cliente, &lt;code&gt;forceFetch&lt;/code&gt; env&amp;iacute;a una solicitud para recuperar todos y cada uno de los fragmentos. Esto asegura que los accesorios para el componente se obtengan recientemente del servidor.</target>
        </trans-unit>
        <trans-unit id="1c4c5b50dcdfa847760bbbedcf52cb8e2ff536e6" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;photo&lt;/code&gt; field has changed; and therefore the record &lt;code&gt;2&lt;/code&gt; has also changed. And that's it. Nothing else in the &lt;em&gt;cache&lt;/em&gt; is affected. But clearly our &lt;em&gt;view&lt;/em&gt; needs to reflect the update: both instances of the author in the UI (as story author and comment author) need to show the new photo.</source>
          <target state="translated">El valor del campo de la &lt;code&gt;photo&lt;/code&gt; ha cambiado; y por lo tanto el registro &lt;code&gt;2&lt;/code&gt; tambi&amp;eacute;n ha cambiado. Y eso es. Nada m&amp;aacute;s en la &lt;em&gt;cach&amp;eacute;&lt;/em&gt; se ve afectado. Pero claramente nuestra &lt;em&gt;vista&lt;/em&gt; debe reflejar la actualizaci&amp;oacute;n: ambas instancias del autor en la interfaz de usuario (como autor de la historia y autor del comentario) deben mostrar la nueva foto.</target>
        </trans-unit>
        <trans-unit id="1232b961ddf31ef587aaa3e408f8aa3d44030a8f" translate="yes" xml:space="preserve">
          <source>Then after making edits to your application files, just run &lt;code&gt;yarn run relay&lt;/code&gt; to generate new files, or &lt;code&gt;yarn run relay -- --watch&lt;/code&gt; to run the compiler as a long-lived process which automatically generates new files whenever you save.</source>
          <target state="translated">Luego, despu&amp;eacute;s de realizar ediciones en los archivos de su aplicaci&amp;oacute;n, simplemente ejecute &lt;code&gt;yarn run relay&lt;/code&gt; para generar nuevos archivos, o &lt;code&gt;yarn run relay -- --watch&lt;/code&gt; para ejecutar el compilador como un proceso de larga duraci&amp;oacute;n que genera autom&amp;aacute;ticamente nuevos archivos cada vez que guarda.</target>
        </trans-unit>
        <trans-unit id="ef73d50cc222b2377dc0c600080db66496266f2f" translate="yes" xml:space="preserve">
          <source>Then after making edits to your application files, run &lt;code&gt;relay-compiler --src ./src --schema path/schema.graphql&lt;/code&gt; to generate new files, or &lt;code&gt;relay-compiler --src ./src --schema path/schema.graphql --watch&lt;/code&gt; to run the compiler as a long-lived process which automatically generates new files whenever you save.</source>
          <target state="translated">Luego, despu&amp;eacute;s de realizar modificaciones en los archivos de su aplicaci&amp;oacute;n, ejecute &lt;code&gt;relay-compiler --src ./src --schema path/schema.graphql&lt;/code&gt; para generar nuevos archivos, o &lt;code&gt;relay-compiler --src ./src --schema path/schema.graphql --watch&lt;/code&gt; para ejecutar el compilador como un proceso de larga duraci&amp;oacute;n que genera autom&amp;aacute;ticamente nuevos archivos cada vez que guarda.</target>
        </trans-unit>
        <trans-unit id="57a1f5033c269a68bc8794dc199b363a5c20cf8b" translate="yes" xml:space="preserve">
          <source>Then run &lt;code&gt;yarn run relay&lt;/code&gt; as set up before.</source>
          <target state="translated">Luego ejecute el &lt;code&gt;yarn run relay&lt;/code&gt; pasada de hilo como se configur&amp;oacute; anteriormente.</target>
        </trans-unit>
        <trans-unit id="45b952755c02df6dff5e78f4c86d5e7d04e71f78" translate="yes" xml:space="preserve">
          <source>Then, add &lt;code&gt;&quot;relay&quot;&lt;/code&gt; to the list of plugins in your .babelrc file. For example:</source>
          <target state="translated">Luego, agregue &lt;code&gt;&quot;relay&quot;&lt;/code&gt; a la lista de complementos en su archivo .babelrc. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="fa043b2e7bb17a1863151534669a087d81a912d9" translate="yes" xml:space="preserve">
          <source>There are a variety of solutions for keeping views up to date with a flattened cache. The approach that Relay takes is to maintain a mapping from each UI view to the set of IDs it references. In this case, the story view would subscribe to updates on the story (&lt;code&gt;1&lt;/code&gt;), the author (&lt;code&gt;2&lt;/code&gt;), and the comments (&lt;code&gt;3&lt;/code&gt; and any others). When writing data into the cache, Relay tracks which IDs are affected and notifies &lt;em&gt;only&lt;/em&gt; the views that are subscribed to those IDs. The affected views re-render, and unaffected views opt-out of re-rendering for better performance (Relay provides a safe but effective default &lt;code&gt;shouldComponentUpdate&lt;/code&gt;). Without this strategy, every view would re-render for even the tiniest change.</source>
          <target state="translated">Hay una variedad de soluciones para mantener las vistas actualizadas con un cach&amp;eacute; plano. El enfoque que toma Relay es mantener una asignaci&amp;oacute;n de cada vista de la interfaz de usuario al conjunto de ID a los que hace referencia. En este caso, la vista de la historia se suscribir&amp;aacute; a las actualizaciones de la historia ( &lt;code&gt;1&lt;/code&gt; ), el autor ( &lt;code&gt;2&lt;/code&gt; ) y los comentarios ( &lt;code&gt;3&lt;/code&gt; y cualquier otro). Al escribir datos en la cach&amp;eacute;, Relay rastrea qu&amp;eacute; ID se ven afectados y notifica &lt;em&gt;solo&lt;/em&gt; las vistas que est&amp;aacute;n suscritas a esos ID. Las vistas afectadas se vuelven a renderizar, y las vistas no afectadas optan por no volver a renderizar para un mejor rendimiento (Relay proporciona un &lt;code&gt;shouldComponentUpdate&lt;/code&gt; predeterminado seguro pero efectivo ). Sin esta estrategia, cada vista se volver&amp;iacute;a a renderizar incluso con el m&amp;aacute;s m&amp;iacute;nimo cambio.</target>
        </trans-unit>
        <trans-unit id="19964f32b18bdaa18426e6241372ad8f6c37030a" translate="yes" xml:space="preserve">
          <source>There is currently only one supported way to set the initial value of a variable dynamically: using global variables defined on the query that includes the fragment (or via &lt;code&gt;variables&lt;/code&gt; on the &lt;code&gt;QueryRenderer&lt;/code&gt;).</source>
          <target state="translated">Actualmente, solo hay una forma admitida de establecer el valor inicial de una variable de forma din&amp;aacute;mica: utilizando variables globales definidas en la consulta que incluye el fragmento (o mediante &lt;code&gt;variables&lt;/code&gt; en &lt;code&gt;QueryRenderer&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7009a3cd68807292f00dff361667a386bda72fff" translate="yes" xml:space="preserve">
          <source>Therefore, a normalized response cache for GraphQL requires processing payloads and queries in parallel. For example, the &lt;code&gt;photo&lt;/code&gt; field from above might be cached with a generated field name such as &lt;code&gt;photo_size(32)&lt;/code&gt; in order to uniquely identify the field and its argument values.</source>
          <target state="translated">Por lo tanto, una memoria cach&amp;eacute; de respuesta normalizada para GraphQL requiere procesar cargas &amp;uacute;tiles y consultas en paralelo. Por ejemplo, el campo de &lt;code&gt;photo&lt;/code&gt; de arriba podr&amp;iacute;a almacenarse en cach&amp;eacute; con un nombre de campo generado como &lt;code&gt;photo_size(32)&lt;/code&gt; para identificar de forma &amp;uacute;nica el campo y sus valores de argumento.</target>
        </trans-unit>
        <trans-unit id="046164a952e067900ed0105204b38b9650fcea6c" translate="yes" xml:space="preserve">
          <source>These are the methods and properties that the container will provide as &lt;code&gt;this.props.relay&lt;/code&gt; in the plain React component.</source>
          <target state="translated">Estos son los m&amp;eacute;todos y propiedades que el contenedor proporcionar&amp;aacute; como &lt;code&gt;this.props.relay&lt;/code&gt; en el componente React simple.</target>
        </trans-unit>
        <trans-unit id="5c8268547e740fb58d6875a6309af54d22de03e8" translate="yes" xml:space="preserve">
          <source>These features can be used in a couple of common scenarios: logging the client state for later inspection or interactively poking around the store from your browser's debugger.</source>
          <target state="translated">Estas características pueden utilizarse en un par de escenarios comunes:registrar el estado del cliente para una inspección posterior o buscar interactivamente en la tienda desde el depurador de su navegador.</target>
        </trans-unit>
        <trans-unit id="1195afffc2435cbe5e7dac1ec74b6de7550b1719" translate="yes" xml:space="preserve">
          <source>Thinking In Relay</source>
          <target state="translated">Pensando en el relevo</target>
        </trans-unit>
        <trans-unit id="9e48341865426d82a3f397c5e1d57bc38bb5c5ba" translate="yes" xml:space="preserve">
          <source>Thinking in GraphQL</source>
          <target state="translated">Pensando en GraphQL</target>
        </trans-unit>
        <trans-unit id="587e48e73d1fbcb3548410dad36aa1874f0eaaf5" translate="yes" xml:space="preserve">
          <source>This callback prop is called as the various events of data resolution occur.</source>
          <target state="translated">Este apoyo de retrollamada se llama como los varios eventos de resolución de datos que ocurren.</target>
        </trans-unit>
        <trans-unit id="83089afd24bef13575f73fb96b2667f2399b79e8" translate="yes" xml:space="preserve">
          <source>This callback prop is called as the various events of data resolution occurs.</source>
          <target state="translated">Este apoyo de retrollamada se llama como los varios eventos de resolución de datos que ocurren.</target>
        </trans-unit>
        <trans-unit id="a79b5038ef8c2e765648d6ba19aa3760d3f3486d" translate="yes" xml:space="preserve">
          <source>This can be upgraded by conditionally rendering a &lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt; which will load the data once it is rendered. The code overhead of doing this is dramatically reduced with the new API.</source>
          <target state="translated">Esto se puede actualizar renderizando condicionalmente un &lt;a href=&quot;query-renderer&quot;&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;/a&gt; que cargar&amp;aacute; los datos una vez que se rendericen. La sobrecarga de c&amp;oacute;digo de hacer esto se reduce dr&amp;aacute;sticamente con la nueva API.</target>
        </trans-unit>
        <trans-unit id="6aa6b4ce32c479ca8e376d46b66428bac2d82d69" translate="yes" xml:space="preserve">
          <source>This can be upgraded by using a &lt;a href=&quot;refetch-container&quot;&gt;&lt;code&gt;RefetchContainer&lt;/code&gt;&lt;/a&gt; which allows you to specify the exact query to use to fetch the new data.</source>
          <target state="translated">Esto se puede actualizar utilizando un &lt;a href=&quot;refetch-container&quot;&gt; &lt;code&gt;RefetchContainer&lt;/code&gt; &lt;/a&gt; que le permite especificar la consulta exacta que se utilizar&amp;aacute; para obtener los nuevos datos.</target>
        </trans-unit>
        <trans-unit id="0fa24150c2aafefe95a09ecc07832206180f13d5" translate="yes" xml:space="preserve">
          <source>This causes a generated file to appear in &lt;code&gt;./__generated__/MyComponent.graphql&lt;/code&gt;, with both runtime artifacts (which help to read and write from the Relay Store) and &lt;a href=&quot;https://flow.org/&quot;&gt;Flow types&lt;/a&gt; to help you write type-safe code.</source>
          <target state="translated">Esto hace que un archivo generado aparezca en &lt;code&gt;./__generated__/MyComponent.graphql&lt;/code&gt; , con artefactos en tiempo de ejecuci&amp;oacute;n (que ayudan a leer y escribir desde Relay Store) y &lt;a href=&quot;https://flow.org/&quot;&gt;tipos de flujo&lt;/a&gt; para ayudarlo a escribir c&amp;oacute;digo seguro.</target>
        </trans-unit>
        <trans-unit id="74dbf4caec721ba1ccc2a6b88d7ee594184d8bbc" translate="yes" xml:space="preserve">
          <source>This example demonstrates all three of these assumptions.</source>
          <target state="translated">Este ejemplo demuestra estos tres supuestos.</target>
        </trans-unit>
        <trans-unit id="9479e9ba5c11bcfea7c69c38843fdeb8dbbdfea5" translate="yes" xml:space="preserve">
          <source>This example is not comprehensive, but it is designed to quickly introduce these core assumptions, to provide some context before diving into the more detailed specification of the library.</source>
          <target state="translated">Este ejemplo no es exhaustivo,pero está diseñado para introducir rápidamente estos supuestos básicos,para proporcionar algún contexto antes de sumergirse en la especificación más detallada de la biblioteca.</target>
        </trans-unit>
        <trans-unit id="f185525936893aacea00cf71a3224c86985f3df6" translate="yes" xml:space="preserve">
          <source>This fat query looks like any other GraphQL query, with one important distinction. We know some of these fields to be non-scalar (like &lt;code&gt;friendEdge&lt;/code&gt; and &lt;code&gt;friends&lt;/code&gt;) but notice that we have not named any of their children by way of a subquery. In this way, we indicate to Relay that &lt;em&gt;anything&lt;/em&gt; under those non-scalar fields may change as a result of this mutation.</source>
          <target state="translated">Esta consulta amplia se parece a cualquier otra consulta GraphQL, con una distinci&amp;oacute;n importante. Sabemos que algunos de estos campos no son escalares (como &lt;code&gt;friendEdge&lt;/code&gt; y &lt;code&gt;friends&lt;/code&gt; ), pero notamos que no hemos nombrado a ninguno de sus hijos mediante una subconsulta. De esta manera, le indicamos a Relay que &lt;em&gt;cualquier cosa&lt;/em&gt; debajo de esos campos no escalares puede cambiar como resultado de esta mutaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="61564f3549d718187ddfeb22e3808eafa802c07e" translate="yes" xml:space="preserve">
          <source>This gets converted into a &quot;lazy&quot; require of a generated file:</source>
          <target state="translated">Esto se convierte en un requerimiento &quot;perezoso&quot; de un archivo generado:</target>
        </trans-unit>
        <trans-unit id="ea59f490525a696053dec758108ce2a68882aa64" translate="yes" xml:space="preserve">
          <source>This gets converted into an immediately-invoked function:</source>
          <target state="translated">Esto se convierte en una función inmediatamente invocada:</target>
        </trans-unit>
        <trans-unit id="01abddd8ac86ef6eb75568464191008b4ca72daa" translate="yes" xml:space="preserve">
          <source>This installs the bin script &lt;code&gt;relay-compiler&lt;/code&gt; in your node_modules folder. It's recommended to run this from a yarn/npm script by adding a script to your &lt;code&gt;package.json&lt;/code&gt; file:</source>
          <target state="translated">Esto instala el &lt;code&gt;relay-compiler&lt;/code&gt; script bin en su carpeta node_modules. Se recomienda ejecutar esto desde un script yarn / npm agregando un script a su archivo &lt;code&gt;package.json&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="11a6b3482924983de73327e990f1793b755a9291" translate="yes" xml:space="preserve">
          <source>This is a specialization of the general-purpose refetch container that is tailored for the common scenario of paginating through a collection of items by fetching successively more pages of data. See &lt;a href=&quot;pagination-container&quot;&gt;&lt;code&gt;createPaginationContainer&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">Se trata de una especializaci&amp;oacute;n del contenedor de recuperaci&amp;oacute;n de uso general que se adapta al escenario com&amp;uacute;n de paginaci&amp;oacute;n a trav&amp;eacute;s de una colecci&amp;oacute;n de elementos obteniendo sucesivamente m&amp;aacute;s p&amp;aacute;ginas de datos. Consulte &lt;a href=&quot;pagination-container&quot;&gt; &lt;code&gt;createPaginationContainer&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="d4db8c43d3a16c260f2c767a658dfa356471e9a7" translate="yes" xml:space="preserve">
          <source>This is an array of events received so far (see &lt;code&gt;ReadyStateEvent&lt;/code&gt; below).</source>
          <target state="translated">Esta es una matriz de eventos recibidos hasta ahora (consulte &lt;code&gt;ReadyStateEvent&lt;/code&gt; a continuaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="4d0129df19cfd202bd9745fb3f722df875299901" translate="yes" xml:space="preserve">
          <source>This is an instance of &lt;code&gt;Error&lt;/code&gt; if there is a failure. Otherwise, this is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Esta es una instancia de &lt;code&gt;Error&lt;/code&gt; si hay una falla. De lo contrario, esto es &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69752386ee76a26381a40e623b5c2ca8480c36c2" translate="yes" xml:space="preserve">
          <source>This is only a simple example: in reality the cache must handle one-to-many associations and pagination (among other things).</source>
          <target state="translated">Este es sólo un ejemplo simple:en realidad el caché debe manejar asociaciones y paginación de uno a muchos (entre otras cosas).</target>
        </trans-unit>
        <trans-unit id="7b3c087bb51f2da841015c33dcb71977fe0212c4" translate="yes" xml:space="preserve">
          <source>This is the general constructor for creating &lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; instances with optional &lt;code&gt;files&lt;/code&gt;, &lt;code&gt;callbacks&lt;/code&gt; and &lt;code&gt;collisionKey&lt;/code&gt; arguments.</source>
          <target state="translated">Este es el constructor general para crear instancias de &lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; con &lt;code&gt;files&lt;/code&gt; opcionales , &lt;code&gt;callbacks&lt;/code&gt; y argumentos &lt;code&gt;collisionKey&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab97009210eccb9f3d5c90eae312fb3cfd66a060" translate="yes" xml:space="preserve">
          <source>This is the lowest level of abstraction at which product code may deal with mutations in Relay, and it corresponds to the mutation operation (&quot;a write followed by a fetch&quot;) described in &lt;a href=&quot;https://facebook.github.io/relay/graphql/mutations.htm&quot;&gt;the GraphQL Specification&lt;/a&gt;. You specify the mutation, the inputs, and the query.</source>
          <target state="translated">Este es el nivel m&amp;aacute;s bajo de abstracci&amp;oacute;n en el que el c&amp;oacute;digo de producto puede lidiar con mutaciones en Relay y corresponde a la operaci&amp;oacute;n de mutaci&amp;oacute;n (&quot;una escritura seguida de una b&amp;uacute;squeda&quot;) descrita en &lt;a href=&quot;https://facebook.github.io/relay/graphql/mutations.htm&quot;&gt;la Especificaci&amp;oacute;n GraphQL&lt;/a&gt; . Usted especifica la mutaci&amp;oacute;n, las entradas y la consulta.</target>
        </trans-unit>
        <trans-unit id="71da35a87d2df91e0c17e3a05dce16632307fd68" translate="yes" xml:space="preserve">
          <source>This is true when &lt;em&gt;all&lt;/em&gt; data requirements are ready for rendering.</source>
          <target state="translated">Esto es cierto cuando &lt;em&gt;todos&lt;/em&gt; los requisitos de datos est&amp;aacute;n listos para renderizarse.</target>
        </trans-unit>
        <trans-unit id="bb078cd30db73d188c6edca1d054b3822d3838fd" translate="yes" xml:space="preserve">
          <source>This is true when the subset of data required for rendering is ready.</source>
          <target state="translated">Esto es así cuando el subconjunto de datos necesarios para la representación está listo.</target>
        </trans-unit>
        <trans-unit id="40d6df25c7774cfef7c19fa68f7bcd72dbf71d40" translate="yes" xml:space="preserve">
          <source>This may be helpful to reduce redundant fragments when dealing with nested or recursive data within a single Component.</source>
          <target state="translated">Esto puede ser útil para reducir los fragmentos redundantes cuando se trata de datos anidados o recursivos dentro de un solo Componente.</target>
        </trans-unit>
        <trans-unit id="7d2596643eab3080985621c3e255ffe66dd1fb15" translate="yes" xml:space="preserve">
          <source>This method can optionally return a promise in order to facilitate proper error propagation.</source>
          <target state="translated">Este método puede opcionalmente devolver una promesa para facilitar la correcta propagación de los errores.</target>
        </trans-unit>
        <trans-unit id="a5a0085a036246ce072609380ef834dd25b9e599" translate="yes" xml:space="preserve">
          <source>This method is also called after the partial set of variables from &lt;code&gt;setVariables&lt;/code&gt; has been applied. The variables returned are used to populate the fragments.</source>
          <target state="translated">Este m&amp;eacute;todo tambi&amp;eacute;n se llama despu&amp;eacute;s de que se haya aplicado el conjunto parcial de variables de &lt;code&gt;setVariables&lt;/code&gt; . Las variables devueltas se utilizan para completar los fragmentos.</target>
        </trans-unit>
        <trans-unit id="0603bfcf101a33a1c1eed64335628df20ea3aa9c" translate="yes" xml:space="preserve">
          <source>This method receives an array of queries (instead of a single query) in order to facilitate batching queries to improve network efficiency.</source>
          <target state="translated">Este método recibe una serie de consultas (en lugar de una sola consulta)a fin de facilitar las consultas por lotes para mejorar la eficiencia de la red.</target>
        </trans-unit>
        <trans-unit id="a87ccc42db63f2f52eeae29ff4feceb34933d42f" translate="yes" xml:space="preserve">
          <source>This should be upgraded to use a &lt;a href=&quot;pagination-container&quot;&gt;&lt;code&gt;PaginationContainer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esto deber&amp;iacute;a actualizarse para usar un &lt;a href=&quot;pagination-container&quot;&gt; &lt;code&gt;PaginationContainer&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a7bf020a941d10f70ab32528d56d8597a05d0895" translate="yes" xml:space="preserve">
          <source>This snippet configures &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; to render &lt;code&gt;ProfilePicture&lt;/code&gt; within a &lt;code&gt;ScrollView&lt;/code&gt; component as soon as data is ready.</source>
          <target state="translated">Este fragmento configura &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; para representar &lt;code&gt;ProfilePicture&lt;/code&gt; dentro de un componente &lt;code&gt;ScrollView&lt;/code&gt; tan pronto como los datos &lt;strong&gt;est&amp;eacute;n&lt;/strong&gt; listos.</target>
        </trans-unit>
        <trans-unit id="70500d59ecc10d7cea4a148a7386cb41d2c4d0f0" translate="yes" xml:space="preserve">
          <source>This snippet configures &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; to render the &quot;Loading...&quot; text whenever it needs to fetch data.</source>
          <target state="translated">Este fragmento configura &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; para que &lt;strong&gt;muestre&lt;/strong&gt; el texto &quot;Cargando ...&quot; siempre que necesite obtener datos.</target>
        </trans-unit>
        <trans-unit id="00b1b28bd3be2fa7e76055fd5d3f672dc5d7fda8" translate="yes" xml:space="preserve">
          <source>This will create a series of &lt;code&gt;__generated__&lt;/code&gt; directories that are co-located with the corresponding files containing &lt;code&gt;graphql&lt;/code&gt; tags.</source>
          <target state="translated">Esto crear&amp;aacute; una serie de directorios &lt;code&gt;__generated__&lt;/code&gt; que se ubicar&amp;aacute;n junto con los archivos correspondientes que contienen etiquetas &lt;code&gt;graphql&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a737ccc7b583949623cef676beba937c7dc28a69" translate="yes" xml:space="preserve">
          <source>This will inform &lt;code&gt;Relay.QL&lt;/code&gt; that this particular field is an array. This will also allow you to use a plural name for the fragment (i.e. &lt;code&gt;bars&lt;/code&gt; instead of &lt;code&gt;bar&lt;/code&gt;).</source>
          <target state="translated">Esto informar&amp;aacute; a &lt;code&gt;Relay.QL&lt;/code&gt; que este campo en particular es una matriz. Esto tambi&amp;eacute;n le permitir&amp;aacute; usar un nombre en plural para el fragmento (es decir, &lt;code&gt;bars&lt;/code&gt; lugar de &lt;code&gt;bar&lt;/code&gt; ra ).</target>
        </trans-unit>
        <trans-unit id="2dcccc952811069ad73564d196e2e6f3b0ec664d" translate="yes" xml:space="preserve">
          <source>This would produce three generated files, and two &lt;code&gt;__generated__&lt;/code&gt; directories:</source>
          <target state="translated">Esto producir&amp;iacute;a tres archivos generados y dos directorios &lt;code&gt;__generated__&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0e7c9a4f20eb8494e45f8c514abfa27440507df5" translate="yes" xml:space="preserve">
          <source>To add a new paginating relay container</source>
          <target state="translated">Para añadir un nuevo contenedor de relevo de paginación</target>
        </trans-unit>
        <trans-unit id="4afe3d419de5a0a7685601e4998733289b1a991a" translate="yes" xml:space="preserve">
          <source>To add a new relay container</source>
          <target state="translated">Para añadir un nuevo contenedor de retransmisión</target>
        </trans-unit>
        <trans-unit id="da88d2c6beb30dbb3f7e5c35d288e84155365752" translate="yes" xml:space="preserve">
          <source>To add a new relay container that has changing data requirements</source>
          <target state="translated">Para añadir un nuevo contenedor de retransmisión que tiene requisitos de datos cambiantes</target>
        </trans-unit>
        <trans-unit id="b78283d8fe106afc67ec588e2762311c4df0a3bd" translate="yes" xml:space="preserve">
          <source>To add a new root for relay components</source>
          <target state="translated">Para añadir una nueva raíz para los componentes del relé</target>
        </trans-unit>
        <trans-unit id="2cb466b85716cc24434b2a68c68d7668bbaceabb" translate="yes" xml:space="preserve">
          <source>To call this method on the underlying component, first provide a &lt;code&gt;componentRef&lt;/code&gt; function to the Relay container. This differs from providing a &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt;&lt;code&gt;ref&lt;/code&gt;&lt;/a&gt; function which would provide a reference to the Relay container itself, not the underlying React Component.</source>
          <target state="translated">Para llamar a este m&amp;eacute;todo en el componente subyacente, primero proporcione una funci&amp;oacute;n &lt;code&gt;componentRef&lt;/code&gt; al contenedor Relay. Esto difiere de proporcionar una funci&amp;oacute;n de &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt; &lt;code&gt;ref&lt;/code&gt; erencia&lt;/a&gt; que proporcionar&amp;iacute;a una referencia al contenedor Relay en s&amp;iacute;, no al componente React subyacente.</target>
        </trans-unit>
        <trans-unit id="65aa58a75ec1e39e9166d34dcff5d186dbe23e3a" translate="yes" xml:space="preserve">
          <source>To commit a mutation</source>
          <target state="translated">Para cometer una mutación</target>
        </trans-unit>
        <trans-unit id="89b06193bd6c9ce7d1f792c95362915c77c9675f" translate="yes" xml:space="preserve">
          <source>To create an environment instance in Relay Modern, use the &lt;code&gt;RelayModernEnvironment&lt;/code&gt; class:</source>
          <target state="translated">Para crear una instancia de entorno en Relay Modern, use la clase &lt;code&gt;RelayModernEnvironment&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="79a86851c1fad2bbe848185a0d8955e026baa0f4" translate="yes" xml:space="preserve">
          <source>To enable &lt;a href=&quot;relay-compat&quot;&gt;compatibility mode&lt;/a&gt;, &lt;code&gt;relay-compiler&lt;/code&gt; enforces a simple naming convention for your queries. Queries must be named as &lt;code&gt;&amp;lt;FileName&amp;gt;&amp;lt;OperationType&amp;gt;&lt;/code&gt;, where &quot;&amp;lt;OperationType&amp;gt;&quot; is one of &quot;Query&quot;, &quot;Mutation&quot;, or &quot;Subscription&quot;. The query above is named &lt;code&gt;ExampleQuery&lt;/code&gt; so should be placed in &lt;code&gt;Example.js&lt;/code&gt;.</source>
          <target state="translated">Para habilitar el &lt;a href=&quot;relay-compat&quot;&gt;modo de compatibilidad&lt;/a&gt; , &lt;code&gt;relay-compiler&lt;/code&gt; aplica una convenci&amp;oacute;n de nomenclatura simple para sus consultas. Las consultas deben denominarse &lt;code&gt;&amp;lt;FileName&amp;gt;&amp;lt;OperationType&amp;gt;&lt;/code&gt; , donde &quot;&amp;lt;OperationType&amp;gt;&quot; es uno de &quot;Consulta&quot;, &quot;Mutaci&amp;oacute;n&quot; o &quot;Suscripci&amp;oacute;n&quot;. La consulta anterior se llama &lt;code&gt;ExampleQuery&lt;/code&gt; , por lo que debe colocarse en &lt;code&gt;Example.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03ec37246eca3b43ea7ac7f76a27cbf7c5cb3d8b" translate="yes" xml:space="preserve">
          <source>To execute this code, Relay needs access to the schema - which can be too large to bundle inside the application. Instead, these &lt;code&gt;Relay.QL&lt;/code&gt; template expressions are transpiled into JavaScript descriptions via the &lt;code&gt;babel-relay-plugin&lt;/code&gt;. This schema information allows Relay to understand things like the types of field arguments, which fields are connections or lists, and how to efficiently refetch records from the server.</source>
          <target state="translated">Para ejecutar este c&amp;oacute;digo, Relay necesita acceso al esquema, que puede ser demasiado grande para agruparse dentro de la aplicaci&amp;oacute;n. En su lugar, estas &lt;code&gt;Relay.QL&lt;/code&gt; plantilla de Relay.QL se transpilan en descripciones de JavaScript a trav&amp;eacute;s del &lt;code&gt;babel-relay-plugin&lt;/code&gt; . Esta informaci&amp;oacute;n de esquema permite a Relay comprender cosas como los tipos de argumentos de campo, qu&amp;eacute; campos son conexiones o listas y c&amp;oacute;mo recuperar registros del servidor de manera eficiente.</target>
        </trans-unit>
        <trans-unit id="6be87ed7f838f24ecfdb363ea58800de8f9dfbc1" translate="yes" xml:space="preserve">
          <source>To force fetch a component</source>
          <target state="translated">Para forzar la obtención de un componente</target>
        </trans-unit>
        <trans-unit id="e7e54aa101836df2ce7d5415960a239df67598f0" translate="yes" xml:space="preserve">
          <source>To get started building Relay applications, you will need three things:</source>
          <target state="translated">Para empezar a construir aplicaciones de relevo,necesitarás tres cosas:</target>
        </trans-unit>
        <trans-unit id="2cf9a932987c095688d86461efe0eedbdc22d8b7" translate="yes" xml:space="preserve">
          <source>To improve perceived responsiveness, you may wish to perform an &quot;optimistic update&quot;, in which the client immediately updates to reflect the anticipated new value even before the response from the server has come back. We do this by providing an &lt;code&gt;optimisticResponse&lt;/code&gt; and adding it to the &lt;code&gt;config&lt;/code&gt; that we pass into &lt;code&gt;commitMutation&lt;/code&gt;:</source>
          <target state="translated">Para mejorar la capacidad de respuesta percibida, es posible que desee realizar una &quot;actualizaci&amp;oacute;n optimista&quot;, en la que el cliente se actualiza inmediatamente para reflejar el nuevo valor anticipado incluso antes de que haya regresado la respuesta del servidor. Hacemos esto proporcionando una &lt;code&gt;commitMutation&lt;/code&gt; &lt;code&gt;optimisticResponse&lt;/code&gt; y agreg&amp;aacute;ndola a la &lt;code&gt;config&lt;/code&gt; uraci&amp;oacute;n que pasamos a commitMutation :</target>
        </trans-unit>
        <trans-unit id="bebfedde59ec9253c14e34d042772cb6d964fce0" translate="yes" xml:space="preserve">
          <source>To paginate through a connection</source>
          <target state="translated">Para paginar a través de una conexión</target>
        </trans-unit>
        <trans-unit id="b6033100545414ff9dedc545a14635be362e73ed" translate="yes" xml:space="preserve">
          <source>To read from the cache we can walk a query and resolve each field. But wait: that sounds &lt;em&gt;exactly&lt;/em&gt; like what a GraphQL server does when it processes a query. And it is! Reading from the cache is a special case of an executor where a) there's no need for user-defined field functions because all results come from a fixed data structure and b) results are always synchronous &amp;mdash; we either have the data cached or we don't.</source>
          <target state="translated">Para leer desde la cach&amp;eacute; podemos recorrer una consulta y resolver cada campo. Pero espere: eso suena &lt;em&gt;exactamente&lt;/em&gt; como lo que hace un servidor GraphQL cuando procesa una consulta. &amp;iexcl;Y es! La lectura del cach&amp;eacute; es un caso especial de un ejecutor donde a) no hay necesidad de funciones de campo definidas por el usuario porque todos los resultados provienen de una estructura de datos fija yb) los resultados son siempre sincr&amp;oacute;nicos: o tenemos los datos en cach&amp;eacute; o no t.</target>
        </trans-unit>
        <trans-unit id="e168ce7f96f9f96537f762eb07d59ca6c422e92d" translate="yes" xml:space="preserve">
          <source>To start, let's build the plain React version of a &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; component that displays the user's profile photo and a slider to adjust the photo's size.</source>
          <target state="translated">Para empezar, creemos la versi&amp;oacute;n simple de React de un componente &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; que muestra la foto de perfil del usuario y un control deslizante para ajustar el tama&amp;ntilde;o de la foto.</target>
        </trans-unit>
        <trans-unit id="fccbd6622bb8847d0929fc4851e9ea2b575ead73" translate="yes" xml:space="preserve">
          <source>To start, let's build the plain React version of a &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; component that displays the text and completion status of a &lt;code&gt;Todo&lt;/code&gt;.</source>
          <target state="translated">Para comenzar, construyamos la versi&amp;oacute;n React simple de un componente &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; que muestra el texto y el estado de finalizaci&amp;oacute;n de un &lt;code&gt;Todo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11ddeec9a3447606ae9ab043cf0ed78d26a53e7b" translate="yes" xml:space="preserve">
          <source>To update a variable for my component</source>
          <target state="translated">Para actualizar una variable de mi componente</target>
        </trans-unit>
        <trans-unit id="3f1189857789cd58adacaebeec728b8e0afcce44" translate="yes" xml:space="preserve">
          <source>To use the Relay Compiler, you need either a .graphql or .json GraphQL schema file, describing your GraphQL server's API. Typically these files are local representations of a server source of truth and are not edited directly. For example, we might have a &lt;code&gt;schema.graphql&lt;/code&gt; like:</source>
          <target state="translated">Para usar el Relay Compiler, necesita un archivo de esquema GraphQL .graphql o .json, que describa la API de su servidor GraphQL. Normalmente, estos archivos son representaciones locales de una fuente de verdad del servidor y no se editan directamente. Por ejemplo, podr&amp;iacute;amos tener un &lt;code&gt;schema.graphql&lt;/code&gt; como:</target>
        </trans-unit>
        <trans-unit id="9be854f285feec3a5f3620acb9820d1d2c32fbd0" translate="yes" xml:space="preserve">
          <source>To use these pieces to construct a full-fledged GraphQL query that we can send to the server to fetch data, we need to use the &lt;strong&gt;Relay.RootContainer&lt;/strong&gt;.</source>
          <target state="translated">Para usar estas piezas para construir una consulta GraphQL completa que podamos enviar al servidor para obtener datos, necesitamos usar &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="2701a94c0eb55cbd958a87dff3e959673ff1bf53" translate="yes" xml:space="preserve">
          <source>Tutorial</source>
          <target state="translated">Tutorial</target>
        </trans-unit>
        <trans-unit id="f77a5658e80339ebafab29498f8ee4b43724b2e0" translate="yes" xml:space="preserve">
          <source>Typical Relay Classic code:</source>
          <target state="translated">Típico código de Relevo Clásico:</target>
        </trans-unit>
        <trans-unit id="95e39abda529007d77cea645d9c98a79ceba0779" translate="yes" xml:space="preserve">
          <source>Typical old code:</source>
          <target state="translated">Típico código antiguo:</target>
        </trans-unit>
        <trans-unit id="5ea4501b4b61baf5dd246de000e69cf2c83ec128" translate="yes" xml:space="preserve">
          <source>Typically you will not need to import your generated definitions. The &lt;a href=&quot;babel-plugin-relay&quot;&gt;Relay Babel plugin&lt;/a&gt; will convert the &lt;code&gt;graphql&lt;/code&gt; literals to &lt;code&gt;require()&lt;/code&gt; the generated files.</source>
          <target state="translated">Por lo general, no necesitar&amp;aacute; importar las definiciones generadas. El &lt;a href=&quot;babel-plugin-relay&quot;&gt;complemento Relay Babel&lt;/a&gt; convertir&amp;aacute; los literales &lt;code&gt;graphql&lt;/code&gt; para &lt;code&gt;require()&lt;/code&gt; los archivos generados.</target>
        </trans-unit>
        <trans-unit id="43a4e34531ca0764965880501d0f8c89a74d18d5" translate="yes" xml:space="preserve">
          <source>Underneath the hood, the default network layer uses &lt;code&gt;fetch&lt;/code&gt; (&lt;a href=&quot;https://fetch.spec.whatwg.org&quot;&gt;Living Standard&lt;/a&gt;). The constructor for &lt;code&gt;Relay.DefaultNetworkLayer&lt;/code&gt; takes an optional second argument that accepts any valid initialization property that &lt;code&gt;fetch&lt;/code&gt; accepts.</source>
          <target state="translated">Debajo del cap&amp;oacute;, la capa de red predeterminada usa &lt;code&gt;fetch&lt;/code&gt; ( &lt;a href=&quot;https://fetch.spec.whatwg.org&quot;&gt;Living Standard&lt;/a&gt; ). El constructor de &lt;code&gt;Relay.DefaultNetworkLayer&lt;/code&gt; toma un segundo argumento opcional que acepta cualquier propiedad de inicializaci&amp;oacute;n v&amp;aacute;lida que acepta &lt;code&gt;fetch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2498fd787926326020b483e3523f960c30e4f9d" translate="yes" xml:space="preserve">
          <source>Unlike queries, failed requests for mutations are not automatically retried.</source>
          <target state="translated">A diferencia de las consultas,las solicitudes fallidas de mutaciones no se vuelven a probar automáticamente.</target>
        </trans-unit>
        <trans-unit id="fa7f90794261c83159eb4a91e2dfe23661dee9e6" translate="yes" xml:space="preserve">
          <source>Up until this point we have only interacted with the GraphQL endpoint to perform queries that fetch data. In this guide, you will learn how to use Relay to perform mutations &amp;ndash; operations that consist of writes to the data store followed by a fetch of any changed fields.</source>
          <target state="translated">Hasta este punto, solo hemos interactuado con el punto final GraphQL para realizar consultas que obtienen datos. En esta gu&amp;iacute;a, aprender&amp;aacute; a utilizar Relay para realizar mutaciones, operaciones que consisten en escrituras en el almac&amp;eacute;n de datos seguidas de la recuperaci&amp;oacute;n de los campos modificados.</target>
        </trans-unit>
        <trans-unit id="f2d05363c2e81a266183ca6ef8b7bd0bdbd8b278" translate="yes" xml:space="preserve">
          <source>Updates the records associated with a mutable record, transversing the source by field name and an object representing pre-defined argument values.</source>
          <target state="translated">Actualiza los registros asociados a un registro mutable,cruzando la fuente por el nombre del campo y un objeto que representa los valores de los argumentos predefinidos.</target>
        </trans-unit>
        <trans-unit id="77357ed1c74dd26c490773b79c9c64db80714ee8" translate="yes" xml:space="preserve">
          <source>Updates the value of a mutable record's attribute given by the field name and an object representing pre-defined argument values.</source>
          <target state="translated">Actualiza el valor del atributo de un registro mutable dado por el nombre de campo y un objeto que representa valores de argumento predefinidos.</target>
        </trans-unit>
        <trans-unit id="130a5ea1f38180314e9b7e8d2e0c0f8791af7800" translate="yes" xml:space="preserve">
          <source>Updating the client on each response</source>
          <target state="translated">Actualizando al cliente en cada respuesta</target>
        </trans-unit>
        <trans-unit id="9c5f928161eaee0e6b37f9f04f9b99fffe3258b5" translate="yes" xml:space="preserve">
          <source>Updating the client optimistically</source>
          <target state="translated">Actualizando el cliente con optimismo</target>
        </trans-unit>
        <trans-unit id="683610f0bd36453d03467df7a76f50661ef6f8ac" translate="yes" xml:space="preserve">
          <source>Updating the local cache after receiving query/mutation responses.</source>
          <target state="translated">Actualización de la memoria caché local después de recibir las respuestas a la consulta/mutación.</target>
        </trans-unit>
        <trans-unit id="5cbc715352505bf09eed712fc8faa91711d9dd6f" translate="yes" xml:space="preserve">
          <source>Updating the store programatically (advanced)</source>
          <target state="translated">Actualizando la tienda programáticamente (avanzado)</target>
        </trans-unit>
        <trans-unit id="b03854fc017532ee497460390d8d2a3a98701a8a" translate="yes" xml:space="preserve">
          <source>Upgrade to react-relay v1.0.0</source>
          <target state="translated">Actualizar a react-relay v1.0.0</target>
        </trans-unit>
        <trans-unit id="6f683dd933be22f58cc623c7fb6049182ce19997" translate="yes" xml:space="preserve">
          <source>Upgrading setVariables</source>
          <target state="translated">Actualización del setVariables</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="855b7cdc9a7b7eedbbade3460ffda75d84c0215a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;introspectionQuery&lt;/code&gt; to generate a Schema JSON for the Babel Relay Plugin, and use &lt;code&gt;printSchema&lt;/code&gt; to generate a user readable type system shorthand:</source>
          <target state="translated">Use &lt;code&gt;introspectionQuery&lt;/code&gt; para generar un JSON de esquema para el complemento Babel Relay y use &lt;code&gt;printSchema&lt;/code&gt; para generar una abreviatura del sistema de tipo legible por el usuario:</target>
        </trans-unit>
        <trans-unit id="9c04ab0245abf53d950383b659bb519121fdf39c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;graphql&lt;/code&gt;</source>
          <target state="translated">Usando &lt;code&gt;graphql&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc3790d0260968db930a9c68e2f92f666400ec99" translate="yes" xml:space="preserve">
          <source>Using Other GraphQL Implementations</source>
          <target state="translated">Usando otras implementaciones de GraphQL</target>
        </trans-unit>
        <trans-unit id="ce363e86e1227248ffe7c0ac61d5dfa9beb38f62" translate="yes" xml:space="preserve">
          <source>Using The Cache</source>
          <target state="translated">Usando el caché</target>
        </trans-unit>
        <trans-unit id="7cc52f33aee5330befcd51c2b80f9fac7ea6a7af" translate="yes" xml:space="preserve">
          <source>Using during conversion in &quot;&lt;a href=&quot;relay-compat&quot;&gt;compatibility mode&lt;/a&gt;&quot;</source>
          <target state="translated">Uso durante la conversi&amp;oacute;n en &quot; &lt;a href=&quot;relay-compat&quot;&gt;modo de compatibilidad&lt;/a&gt; &quot;</target>
        </trans-unit>
        <trans-unit id="4ca24372752ba964092860cbbff37a07dae71dd0" translate="yes" xml:space="preserve">
          <source>Using with Relay Classic</source>
          <target state="translated">Usando con el Relevo Clásico</target>
        </trans-unit>
        <trans-unit id="f72b74b27018bdf2391222dafa0211db62f72ce0" translate="yes" xml:space="preserve">
          <source>View composition is &lt;em&gt;exactly&lt;/em&gt; what you're used to &amp;mdash; Relay containers are standard React components. Here's the &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">Ver la composici&amp;oacute;n es &lt;em&gt;exactamente a&lt;/em&gt; lo que est&amp;aacute; acostumbrado: los contenedores de retransmisi&amp;oacute;n son componentes est&amp;aacute;ndar de React. Aqu&amp;iacute; est&amp;aacute; el componente &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ff6f9fbff154a814e972c078a22c3cc9628815cf" translate="yes" xml:space="preserve">
          <source>View composition is &lt;em&gt;exactly&lt;/em&gt; what you're used to &amp;mdash; Relay containers are standard React components. Here's the &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">Ver la composici&amp;oacute;n es &lt;em&gt;exactamente a&lt;/em&gt; lo que est&amp;aacute; acostumbrado: los contenedores de retransmisi&amp;oacute;n son componentes est&amp;aacute;ndar de React. Aqu&amp;iacute; est&amp;aacute; el componente &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1ebbd92b690622c06c90cfb9515becf2b5c48808" translate="yes" xml:space="preserve">
          <source>Warm up</source>
          <target state="translated">Calienta.</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="ee4e2bfd72b7c80e3c41f3483341254dd5afffff" translate="yes" xml:space="preserve">
          <source>We built a few scripts to help you with the conversion process. Check them out at &lt;a href=&quot;https://github.com/relayjs/relay-codemod&quot;&gt;https://github.com/relayjs/relay-codemod&lt;/a&gt;.</source>
          <target state="translated">Creamos algunos scripts para ayudarlo con el proceso de conversi&amp;oacute;n. &amp;Eacute;chales un vistazo en &lt;a href=&quot;https://github.com/relayjs/relay-codemod&quot;&gt;https://github.com/relayjs/relay-codemod&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5940197c590089a53a146cb165e633452c87b60e" translate="yes" xml:space="preserve">
          <source>We can change this behavior by supplying the &lt;code&gt;renderLoading&lt;/code&gt; prop:</source>
          <target state="translated">Podemos cambiar este comportamiento proporcionando el prop &lt;code&gt;renderLoading&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0025d01a256751edcecba66775aa9098e4c29a78" translate="yes" xml:space="preserve">
          <source>We can give Relay instructions in the form of a config array on how to use the response from each mutation to update the client-side store. We do this by configuring the mutation with one or more of the following mutation types:</source>
          <target state="translated">Podemos dar instrucciones de retransmisión en forma de matriz de configuración sobre cómo usar la respuesta de cada mutación para actualizar el almacén del lado del cliente.Lo hacemos configurando la mutación con uno o más de los siguientes tipos de mutación:</target>
        </trans-unit>
        <trans-unit id="8d988256976c56fbd9f26524c8c8f2411a181121" translate="yes" xml:space="preserve">
          <source>We declare our mutations' data dependencies here, just as we would with a container. This is particularly useful to ensure that a set of fields we might want to use in this mutation's optimistic response have been fetched.</source>
          <target state="translated">Declaramos las dependencias de datos de nuestras mutaciones aquí,como lo haríamos con un contenedor.Esto es particularmente útil para asegurar que un conjunto de campos que podríamos querer usar en la respuesta optimista de esta mutación se han obtenido.</target>
        </trans-unit>
        <trans-unit id="b7466fdf0dcdc8961e68874158874a25c24afe7b" translate="yes" xml:space="preserve">
          <source>We need a place to hide our treasure, a way to check hiding spots for treasure, and a way to track our turns remaining. For the purposes of this tutorial, we'll hide these data in memory.</source>
          <target state="translated">Necesitamos un lugar para esconder nuestro tesoro,una forma de comprobar los escondites del tesoro,y una forma de rastrear los turnos que nos quedan.Para los propósitos de este tutorial,esconderemos estos datos en la memoria.</target>
        </trans-unit>
        <trans-unit id="65874d3946f2b63af172cee5a5b310c785e00be9" translate="yes" xml:space="preserve">
          <source>We need to give Relay instructions on how to use the response payload from each mutation to update the client-side store. We do this by configuring the mutation with one or more of the following mutation types:</source>
          <target state="translated">Necesitamos dar instrucciones al Relevo sobre cómo usar la carga de respuesta de cada mutación para actualizar la tienda del lado del cliente.Lo hacemos configurando la mutación con uno o más de los siguientes tipos de mutación:</target>
        </trans-unit>
        <trans-unit id="8cbe01efa489ff5ceee170b9e46b9663c23a0b77" translate="yes" xml:space="preserve">
          <source>We ultimately settled on static methods; components would effectively return a query-tree, separate from the view-tree, describing their data dependencies. Relay could then use this query-tree to fetch all the information needed in a single stage and use it to render the components. The problem was finding an appropriate mechanism to describe the query-tree, and a way to efficiently fetch it from the server (i.e. in a single network request). This is the perfect use-case for GraphQL because it provides a syntax for &lt;em&gt;describing data-dependencies as data&lt;/em&gt;, without dictating any particular API. Note that Promises and Observables are often suggested as alternatives, but they represent &lt;em&gt;opaque commands&lt;/em&gt; and preclude various optimizations such as query batching.</source>
          <target state="translated">Finalmente, nos decidimos por m&amp;eacute;todos est&amp;aacute;ticos; Los componentes devolver&amp;iacute;an efectivamente un &amp;aacute;rbol de consultas, separado del &amp;aacute;rbol de vistas, describiendo sus dependencias de datos. Relay podr&amp;iacute;a entonces usar este &amp;aacute;rbol de consultas para obtener toda la informaci&amp;oacute;n necesaria en una sola etapa y usarla para representar los componentes. El problema fue encontrar un mecanismo apropiado para describir el &amp;aacute;rbol de consultas y una forma de obtenerlo de manera eficiente del servidor (es decir, en una sola solicitud de red). Este es el caso de uso perfecto para GraphQL porque proporciona una sintaxis para &lt;em&gt;describir las dependencias de datos como datos&lt;/em&gt; , sin dictar ninguna API en particular. Tenga en cuenta que las promesas y los observables a menudo se sugieren como alternativas, pero representan &lt;em&gt;comandos opacos&lt;/em&gt; y excluyen varias optimizaciones, como el procesamiento por lotes de consultas.</target>
        </trans-unit>
        <trans-unit id="69182ca2dfd5971872156968dd68015b5e288405" translate="yes" xml:space="preserve">
          <source>We'll now see different &lt;code&gt;likeCount&lt;/code&gt;s depending on how the story is accessed. A view that uses the first query will see an outdated count, while a view using the second query will see the updated count.</source>
          <target state="translated">Ahora veremos diferentes &lt;code&gt;likeCount&lt;/code&gt; s dependiendo de c&amp;oacute;mo se acceda a la historia. Una vista que usa la primera consulta ver&amp;aacute; un recuento desactualizado, mientras que una vista que usa la segunda consulta ver&amp;aacute; el recuento actualizado.</target>
        </trans-unit>
        <trans-unit id="4a34c41bd9be871dd6a4b7a07724bb519fe92e77" translate="yes" xml:space="preserve">
          <source>We're almost ready to let Relay fulfill the data requirements for these components and render them. However, there is one problem. In order to actually fetch data with GraphQL, we need a query root. For example, we need to ground the &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; fragment in a concrete node of type &lt;code&gt;User&lt;/code&gt;.</source>
          <target state="translated">Estamos casi listos para permitir que Relay cumpla con los requisitos de datos para estos componentes y los procese. Sin embargo, existe un problema. Para obtener datos con GraphQL, necesitamos una ra&amp;iacute;z de consulta. Por ejemplo, necesitamos conectar a tierra el fragmento &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; en un nodo concreto de tipo &lt;code&gt;User&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f379242619731bf12c214370913f902c9dc56b87" translate="yes" xml:space="preserve">
          <source>We've found that it's common for the GraphQL schema to differ slightly or even substantially from the form in which data is stored on disk. Put simply: there isn't always a 1:1 correspondence between data changes in your underlying &lt;em&gt;data storage&lt;/em&gt; (disk) and data changes in your &lt;em&gt;product-visible schema&lt;/em&gt; (GraphQL). The perfect example of this is privacy: returning a user-facing field such as &lt;code&gt;age&lt;/code&gt; might require accessing numerous records in our data-storage layer to determine if the active user is even allowed to &lt;em&gt;see&lt;/em&gt; that &lt;code&gt;age&lt;/code&gt; (Are we friends? Is my age shared? Did I block you? etc.).</source>
          <target state="translated">Hemos descubierto que es com&amp;uacute;n que el esquema GraphQL difiera levemente o incluso sustancialmente de la forma en que se almacenan los datos en el disco. En pocas palabras: no siempre hay una correspondencia 1: 1 entre los cambios de datos en su &lt;em&gt;almacenamiento de datos&lt;/em&gt; subyacente (disco) y los cambios de datos en su &lt;em&gt;esquema de producto visible&lt;/em&gt; (GraphQL). El ejemplo perfecto de esto es la privacidad: devolver un campo de cara al usuario, como la &lt;code&gt;age&lt;/code&gt; puede requerir acceder a numerosos registros en nuestra capa de almacenamiento de datos para determinar si el usuario activo puede &lt;em&gt;ver&lt;/em&gt; esa &lt;code&gt;age&lt;/code&gt; (&amp;iquest;Somos amigos? &amp;iquest;Mi edad es compartida? ? Te bloque&amp;eacute;? Etc.).</target>
        </trans-unit>
        <trans-unit id="908ef03db4345c18068bb287000ab8108652ad6f" translate="yes" xml:space="preserve">
          <source>We've found that typical approaches to data-fetching &amp;mdash; with imperative APIs &amp;mdash; force developers to deal with too much of this non-essential complexity. For example, consider &lt;em&gt;optimistic UI updates&lt;/em&gt;. This is a way of giving the user feedback while waiting for a server response. The logic of &lt;em&gt;what&lt;/em&gt; to do can be quite clear: when the user clicks &quot;like&quot;, mark the story as being liked and send the request to the server. But the implementation is often much more complex. Imperative approaches require us to implement all of those steps: reach into the UI and toggle the button, initiate a network request, retry it if necessary, show an error if it fails (and untoggle the button), etc. The same goes for data-fetching: specifying &lt;em&gt;what&lt;/em&gt; data we need often dictates &lt;em&gt;how&lt;/em&gt; and &lt;em&gt;when&lt;/em&gt; it is fetched. Next, we'll explore our approach to solving these concerns with &lt;strong&gt;Relay&lt;/strong&gt;.</source>
          <target state="translated">Hemos descubierto que los enfoques t&amp;iacute;picos para la obtenci&amp;oacute;n de datos, con API imperativas, obligan a los desarrolladores a lidiar con demasiada complejidad no esencial. Por ejemplo, considere las &lt;em&gt;actualizaciones optimistas de la interfaz de usuario&lt;/em&gt; . Esta es una forma de proporcionar comentarios al usuario mientras espera una respuesta del servidor. La l&amp;oacute;gica de &lt;em&gt;qu&amp;eacute;&lt;/em&gt; hacer puede ser bastante clara: cuando el usuario hace clic en &quot;Me gusta&quot;, marca la historia como Me gusta y env&amp;iacute;a la solicitud al servidor. Pero la implementaci&amp;oacute;n suele ser mucho m&amp;aacute;s compleja. Los enfoques imperativos requieren que implementemos todos esos pasos: acceder a la interfaz de usuario y alternar el bot&amp;oacute;n, iniciar una solicitud de red, volver a intentarlo si es necesario, mostrar un error si falla (y alternar el bot&amp;oacute;n), etc. Lo mismo ocurre con los datos -captura: especificando &lt;em&gt;qu&amp;eacute; &lt;/em&gt; datos necesitamos a menudo dicta&lt;em&gt;c&amp;oacute;mo&lt;/em&gt; y &lt;em&gt;cu&amp;aacute;ndo&lt;/em&gt;se busca. A continuaci&amp;oacute;n, exploraremos nuestro enfoque para resolver estas inquietudes con &lt;strong&gt;Relay&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c57df462a7e454e5b5d9c9c3be330abf92758a69" translate="yes" xml:space="preserve">
          <source>We've seen that Relay containers ensure that GraphQL fragments are fetched &lt;em&gt;before&lt;/em&gt; the component is rendered. But containers also provide another benefit that isn't immediately obvious: &lt;strong&gt;data masking&lt;/strong&gt;. Relay only allows components to access data they specifically ask for in &lt;code&gt;fragments&lt;/code&gt; &amp;mdash; nothing more. So if one component queries for a Story's &lt;code&gt;text&lt;/code&gt;, and another for its &lt;code&gt;author&lt;/code&gt;, each can see &lt;em&gt;only&lt;/em&gt; the field that they asked for. In fact, components can't even see the data requested by their &lt;em&gt;children&lt;/em&gt;: that would also break encapsulation.</source>
          <target state="translated">Hemos visto que los contenedores de retransmisi&amp;oacute;n garantizan que los fragmentos de GraphQL se recuperen &lt;em&gt;antes de&lt;/em&gt; que se procese el componente. Pero los contenedores tambi&amp;eacute;n brindan otro beneficio que no es obvio de inmediato: &lt;strong&gt;el enmascaramiento de datos&lt;/strong&gt; . Relay solo permite que los componentes accedan a los datos que solicitan espec&amp;iacute;ficamente en &lt;code&gt;fragments&lt;/code&gt; , nada m&amp;aacute;s. Entonces, si un componente consulta por el &lt;code&gt;text&lt;/code&gt; o de una historia y otro por su &lt;code&gt;author&lt;/code&gt; , cada uno puede ver &lt;em&gt;solo&lt;/em&gt; el campo que solicit&amp;oacute;. De hecho, los componentes ni siquiera pueden ver los datos solicitados por sus &lt;em&gt;hijos&lt;/em&gt; : eso tambi&amp;eacute;n romper&amp;iacute;a la encapsulaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="deaef06798309bf42fff99bdd598051728c38f5a" translate="yes" xml:space="preserve">
          <source>What we have written here is a mock database interface. We can imagine hooking this up to a real database, but for now let's move on.</source>
          <target state="translated">Lo que hemos escrito aquí es un simulacro de interfaz de base de datos.Podemos imaginarnos conectar esto a una base de datos real,pero por ahora sigamos adelante.</target>
        </trans-unit>
        <trans-unit id="73a39c3a3d88bd8125f710502d024ae93180062d" translate="yes" xml:space="preserve">
          <source>What works with what? Relay Compat (&lt;code&gt;'react-relay/compat'&lt;/code&gt;) is the most flexible. Compat components and mutations can be used by everything. Compat components can also have any kind of children.</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; funciona con qu&amp;eacute;? Relay Compat ( &lt;code&gt;'react-relay/compat'&lt;/code&gt; ) es el m&amp;aacute;s flexible. Los componentes compatibles y las mutaciones pueden ser utilizados por todo. Los componentes de Compat tambi&amp;eacute;n pueden tener cualquier tipo de hijos.</target>
        </trans-unit>
        <trans-unit id="0a097138ac94d8bfbf69d6920577e2b751982a49" translate="yes" xml:space="preserve">
          <source>When &quot;force fetching&quot;, this is true if &lt;code&gt;ready&lt;/code&gt; is true as a result of data being available on the client before the server request has completed.</source>
          <target state="translated">Cuando se &quot;fuerza la recuperaci&amp;oacute;n&quot;, esto es cierto si &lt;code&gt;ready&lt;/code&gt; es verdadero como resultado de que los datos est&amp;aacute;n disponibles en el cliente antes de que se complete la solicitud del servidor.</target>
        </trans-unit>
        <trans-unit id="ec3ad126a1399587ee94fd174e76b0fbd442a34b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;forceFetch&lt;/code&gt; is true and &lt;code&gt;renderFetched&lt;/code&gt; is called as a result of available client data, &lt;code&gt;renderFetched&lt;/code&gt; is called with a second argument that has a &lt;code&gt;stale&lt;/code&gt; boolean property. The &lt;code&gt;stale&lt;/code&gt; property is true if &lt;code&gt;renderFetched&lt;/code&gt; is called before the forced server request completes.</source>
          <target state="translated">Cuando &lt;code&gt;forceFetch&lt;/code&gt; es verdadero y se llama a &lt;code&gt;renderFetched&lt;/code&gt; como resultado de los datos disponibles del cliente, se llama a &lt;code&gt;renderFetched&lt;/code&gt; con un segundo argumento que tiene una propiedad booleana &lt;code&gt;stale&lt;/code&gt; . La propiedad &lt;code&gt;stale&lt;/code&gt; es verdadera si se llama a &lt;code&gt;renderFetched&lt;/code&gt; antes de que se complete la solicitud forzada del servidor.</target>
        </trans-unit>
        <trans-unit id="eb41ea6dee1bf1db385774c4f83f62a51389acc5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;forceFetch&lt;/code&gt; is true, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; will always send a request to the server. However, if all the data required to render is also available on the client, &lt;code&gt;renderFetched&lt;/code&gt; may still be called before the server request completes.</source>
          <target state="translated">Cuando &lt;code&gt;forceFetch&lt;/code&gt; es verdadero, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; siempre enviar&amp;aacute; una solicitud al servidor. Sin embargo, si todos los datos necesarios para renderizar tambi&amp;eacute;n est&amp;aacute;n disponibles en el cliente, a&amp;uacute;n se puede llamar a &lt;code&gt;renderFetched&lt;/code&gt; antes de que se complete la solicitud del servidor.</target>
        </trans-unit>
        <trans-unit id="5e40c2b8419bc5119b554a06ad55e52a926e319f" translate="yes" xml:space="preserve">
          <source>When Relay fulfills data, the &lt;code&gt;onReadyStateChange&lt;/code&gt; callback is called one or more times with an object that describes the current &quot;ready state&quot;. This object has the following properties:</source>
          <target state="translated">Cuando Relay completa los datos, la &lt;code&gt;onReadyStateChange&lt;/code&gt; llamada onReadyStateChange se llama una o m&amp;aacute;s veces con un objeto que describe el &quot;estado listo&quot; actual. Este objeto tiene las siguientes propiedades:</target>
        </trans-unit>
        <trans-unit id="32bb09505d79ce543a4f26cb9022780cf39a8205" translate="yes" xml:space="preserve">
          <source>When all data necessary to render becomes available, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; will render the supplied &lt;code&gt;Component&lt;/code&gt; by default. However, we can change this behavior by supplying a callback to the &lt;code&gt;renderFetched&lt;/code&gt; prop:</source>
          <target state="translated">Cuando todos los datos necesarios para renderizar est&amp;eacute;n disponibles, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; renderizar&amp;aacute; el &lt;code&gt;Component&lt;/code&gt; e suministrado por defecto. Sin embargo, podemos cambiar este comportamiento proporcionando una devoluci&amp;oacute;n de llamada a la propiedad &lt;code&gt;renderFetched&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e8c530641aad6dea0ce0a725ecb86984b969f2e6" translate="yes" xml:space="preserve">
          <source>When all data requirements are fulfilled, &lt;code&gt;renderFetched&lt;/code&gt; is called to render the view. This callback is expected to spread &lt;code&gt;data&lt;/code&gt; into the supplied &lt;code&gt;Container&lt;/code&gt; when rendering it.</source>
          <target state="translated">Cuando se cumplen todos los requisitos de datos, se llama a &lt;code&gt;renderFetched&lt;/code&gt; para representar la vista. Se espera que esta devoluci&amp;oacute;n de llamada difunda los &lt;code&gt;data&lt;/code&gt; en el &lt;code&gt;Container&lt;/code&gt; proporcionado al representarlo.</target>
        </trans-unit>
        <trans-unit id="f5e881d6a25c5fe2f25b897803df81640312440a" translate="yes" xml:space="preserve">
          <source>When compiling code for production deployment, the plugin can be configured to immediately throw upon encountering a validation problem. The plugin can be further customized for different environments with the following options:</source>
          <target state="translated">Al compilar el código para el despliegue de la producción,el plugin puede ser configurado para lanzar inmediatamente al encontrar un problema de validación.El plugin se puede personalizar aún más para diferentes entornos con las siguientes opciones:</target>
        </trans-unit>
        <trans-unit id="fef005c4b23cdf975a02dadd67a2264bb2944197" translate="yes" xml:space="preserve">
          <source>When data requirements failed to be fulfilled, &lt;code&gt;renderFailure&lt;/code&gt; is called to render the view.</source>
          <target state="translated">Cuando los requisitos de datos no se cumplen, se llama a &lt;code&gt;renderFailure&lt;/code&gt; para representar la vista.</target>
        </trans-unit>
        <trans-unit id="fe6cbba9204bbe45970c08910fca16574ce8a0cc" translate="yes" xml:space="preserve">
          <source>When data requirements have yet to be fulfilled, &lt;code&gt;renderLoading&lt;/code&gt; is called to render the view. If this returns &lt;code&gt;undefined&lt;/code&gt;, the previously rendered view (or nothing if there is no previous view) is rendered.</source>
          <target state="translated">Cuando los requisitos de datos a&amp;uacute;n no se han cumplido, se llama a &lt;code&gt;renderLoading&lt;/code&gt; para representar la vista. Si devuelve &lt;code&gt;undefined&lt;/code&gt; , se procesa la vista renderizada anteriormente (o nada si no hay una vista previa).</target>
        </trans-unit>
        <trans-unit id="48fe499e8a7f1e23dc6dcd982b4f071176b969ff" translate="yes" xml:space="preserve">
          <source>When designing a fat query, consider &lt;em&gt;all&lt;/em&gt; of the data that might change as a result of the mutation &amp;ndash; not just the data currently in use by your application. We don't need to worry about overfetching; this query is never executed without first intersecting it with a &amp;lsquo;tracked query&amp;rsquo; of the data our application actually needs. If we omit fields in the fat query, we might observe data inconsistencies in the future when we add views with new data dependencies, or add new data dependencies to existing views.</source>
          <target state="translated">Al dise&amp;ntilde;ar una consulta amplia, tenga en cuenta &lt;em&gt;todos&lt;/em&gt; los datos que podr&amp;iacute;an cambiar como resultado de la mutaci&amp;oacute;n, no solo los datos actualmente en uso por su aplicaci&amp;oacute;n. No tenemos que preocuparnos por la captaci&amp;oacute;n excesiva; esta consulta nunca se ejecuta sin primero cruzarla con una 'consulta rastreada' de los datos que nuestra aplicaci&amp;oacute;n realmente necesita. Si omitimos campos en la consulta fat, podr&amp;iacute;amos observar inconsistencias de datos en el futuro cuando agreguemos vistas con nuevas dependencias de datos, o agreguemos nuevas dependencias de datos a vistas existentes.</target>
        </trans-unit>
        <trans-unit id="8d515b89284c6ce31950922a449ba18618a553f6" translate="yes" xml:space="preserve">
          <source>When incrementally converting a Relay Classic app to Relay Modern, &lt;code&gt;graphql&lt;/code&gt; literals can be translated to be usable by &lt;em&gt;both&lt;/em&gt; runtimes if configured to use compatibility mode:</source>
          <target state="translated">Al convertir de forma incremental una aplicaci&amp;oacute;n Relay Classic a Relay Modern, los literales &lt;code&gt;graphql&lt;/code&gt; se pueden traducir para que sean utilizables por &lt;em&gt;ambos&lt;/em&gt; tiempos de ejecuci&amp;oacute;n si se configuran para usar el modo de compatibilidad:</target>
        </trans-unit>
        <trans-unit id="902c49b06415e9d418fef8488cdcaad88a9be3b5" translate="yes" xml:space="preserve">
          <source>When it sends queries, it will automatically fail requests after a 15 second timeout. Also, failed requests are automatically retried twice, with a 1 second delay and a 3 second delay, respectively.</source>
          <target state="translated">Cuando envía consultas,automáticamente fallará las solicitudes después de un tiempo de espera de 15 segundos.Además,las solicitudes fallidas se vuelven a intentar automáticamente dos veces,con un retraso de 1 segundo y 3 segundos,respectivamente.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
