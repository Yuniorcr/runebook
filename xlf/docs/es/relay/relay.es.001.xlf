<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="relay">
    <body>
      <group id="relay">
        <trans-unit id="f9287b3fad8f092d74f4ec6aadb5a29cf9ba2e63" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2013&amp;ndash;present Facebook Inc.</source>
          <target state="translated">&amp;copy; 2013 &amp;ndash; presente Facebook Inc.</target>
        </trans-unit>
        <trans-unit id="62a57a41103550669d926f2e0d40ca12b0b6a458" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2020&amp;ndash;present Facebook Inc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c885f04e75b4bbf0d9edbb67f250e651d298c71" translate="yes" xml:space="preserve">
          <source>(subsequent sections explain how these types are used in practice):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac2bb4599b07dd7b4cea35d8e273b367c0b66305" translate="yes" xml:space="preserve">
          <source>* Modern API doesn't support mutation fragments. You might have to inline the mutation fragments from your legacy mutation in the fragment of the component.</source>
          <target state="translated">* La API moderna no admite fragmentos de mutaci&amp;oacute;n. Es posible que deba alinear los fragmentos de mutaci&amp;oacute;n de su mutaci&amp;oacute;n heredada en el fragmento del componente.</target>
        </trans-unit>
        <trans-unit id="3c78bed46629a737d7ec7580861338032fb6f8d8" translate="yes" xml:space="preserve">
          <source>...which calls the callbacks for any &lt;code&gt;subscribe()&lt;/code&gt;-ers whose results have changed. Each subscription is checked as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c225bfc176636425ea153120adefbee642d75cea" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;fragment-container&quot;&gt;&lt;code&gt;createFragmentContainer&lt;/code&gt;&lt;/a&gt; returns a basic container that cannot fetch additional data beyond what is declared in its fragment(s). Relay Modern also provides more advanced containers for dynamic use cases (which were previously handled in Relay Classic via &lt;code&gt;setVariables&lt;/code&gt;):</source>
          <target state="translated">&lt;a href=&quot;fragment-container&quot;&gt; &lt;code&gt;createFragmentContainer&lt;/code&gt; &lt;/a&gt; devuelve un contenedor b&amp;aacute;sico que no puede obtener datos adicionales m&amp;aacute;s all&amp;aacute; de lo declarado en su (s) fragmento (s). Relay Modern tambi&amp;eacute;n proporciona contenedores m&amp;aacute;s avanzados para casos de uso din&amp;aacute;micos (que anteriormente se manejaban en Relay Classic a trav&amp;eacute;s de &lt;code&gt;setVariables&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="77688ea0d1fdf22bab3df470e72bfe7de6cb4724" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://chrome.google.com/webstore/detail/relay-devtools/oppikflppfjfdpjimpdadhelffjpciba&quot;&gt;Chrome Extension&lt;/a&gt; creates a Relay tab in the developer tools interface for debugging apps in Chrome</source>
          <target state="translated">&lt;a href=&quot;https://chrome.google.com/webstore/detail/relay-devtools/oppikflppfjfdpjimpdadhelffjpciba&quot;&gt;La extensi&amp;oacute;n de Chrome&lt;/a&gt; crea una pesta&amp;ntilde;a de retransmisi&amp;oacute;n en la interfaz de herramientas de desarrollador para depurar aplicaciones en Chrome</target>
        </trans-unit>
        <trans-unit id="fad91719b9218a6ae11551221b84fc32086535ed" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt; allows views to be defined as components where every component is responsible for rendering a part of the UI. Composing other components is how to build complex UIs. Each React component doesn't need to know the inner workings of the composed components.</source>
          <target state="translated">&lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt; permite que las vistas se definan como componentes donde cada componente es responsable de representar una parte de la interfaz de usuario. La composici&amp;oacute;n de otros componentes es c&amp;oacute;mo construir interfaces de usuario complejas. Cada componente de React no necesita conocer el funcionamiento interno de los componentes compuestos.</target>
        </trans-unit>
        <trans-unit id="a1980b0d9659b15299523fce23afa9e64733250c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/relayjs/relay-debugger/tree/master/react-native-shell&quot;&gt;Electron App&lt;/a&gt; that connects to React Native apps running Relay</source>
          <target state="translated">&lt;a href=&quot;https://github.com/relayjs/relay-debugger/tree/master/react-native-shell&quot;&gt;Aplicaci&amp;oacute;n Electron&lt;/a&gt; que se conecta a las aplicaciones React Native que ejecutan Relay</target>
        </trans-unit>
        <trans-unit id="0f80ef8cc2241c7509e6613ced8779935dc25b6f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt; manages the execution of the GraphQL query. It sends the query with given variables, parses the response, saves the data to the internal cache, and finally renders the view.</source>
          <target state="translated">&lt;a href=&quot;query-renderer&quot;&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;/a&gt; gestiona la ejecuci&amp;oacute;n de la consulta GraphQL. Env&amp;iacute;a la consulta con las variables dadas, analiza la respuesta, guarda los datos en la cach&amp;eacute; interna y finalmente representa la vista.</target>
        </trans-unit>
        <trans-unit id="cfac86ab065f686a94d7eabf085884e964606374" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;refetch-container&quot;&gt;&lt;code&gt;createRefetchContainer&lt;/code&gt;&lt;/a&gt; is a variation of &lt;code&gt;createFragmentContainer&lt;/code&gt; that addresses the &quot;see more&quot; use case, where a subset of data is rendered initially and then additional data is fetched on demand. Refetch containers initially fetch data for their fragments just like fragment containers, but also offer a &lt;code&gt;refetch()&lt;/code&gt; method by which additional data can be fetched, or the container can be re-rendered to read data using different variables.</source>
          <target state="translated">&lt;a href=&quot;refetch-container&quot;&gt; &lt;code&gt;createRefetchContainer&lt;/code&gt; &lt;/a&gt; es una variaci&amp;oacute;n de &lt;code&gt;createFragmentContainer&lt;/code&gt; que aborda el caso de uso de &quot;ver m&amp;aacute;s&quot;, donde un subconjunto de datos se procesa inicialmente y luego se obtienen datos adicionales a pedido. Los contenedores Refetch inicialmente obtienen datos para sus fragmentos al igual que los contenedores de fragmentos, pero tambi&amp;eacute;n ofrecen unm&amp;eacute;todo &lt;code&gt;refetch()&lt;/code&gt; mediante el cual se pueden recuperar datos adicionales, o el contenedor se puede volver a renderizar para leer datos usando diferentes variables.</target>
        </trans-unit>
        <trans-unit id="f6f0afa9606f188df5aa2880a96f0796da66589e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;relay-compat&quot;&gt;Compat mode&lt;/a&gt; allows the Relay Modern APIs to be incrementally adopted in an existing Relay app. This approach enables the following features compared to Relay Classic:</source>
          <target state="translated">&lt;a href=&quot;relay-compat&quot;&gt;El modo Compat&lt;/a&gt; permite que las API de Relay Modern se adopten de forma incremental en una aplicaci&amp;oacute;n Relay existente. Este enfoque habilita las siguientes caracter&amp;iacute;sticas en comparaci&amp;oacute;n con Relay Classic:</target>
        </trans-unit>
        <trans-unit id="3cc7b1d6acf9a6a36373b7d2788a819c007a696a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; receives a &lt;code&gt;user&lt;/code&gt; prop with plain JavaScript data - objects, arrays, strings - and renders as usual.</source>
          <target state="translated">&lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; recibe un accesorio de &lt;code&gt;user&lt;/code&gt; con datos simples de JavaScript (objetos, matrices, cadenas) y se procesa como de costumbre.</target>
        </trans-unit>
        <trans-unit id="540f04ea4575b6b8ef0b102ef7464ad435fbcfde" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@argumentDefinitions&lt;/code&gt; is a directive used to specify arguments taken by a fragment. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c1b1f1da3ceb037a205f174a8917520d0d4ffd9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@arguments&lt;/code&gt; is a directive used to pass arguments to a fragment that was defined using &lt;a href=&quot;#argumentdefinitions&quot;&gt;&lt;code&gt;@argumentDefinitions&lt;/code&gt;&lt;/a&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="115b4c121f9af58bd42ac1ea726c7c948a8dafc5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@connection&lt;/code&gt; directive</source>
          <target state="translated">&lt;code&gt;@connection&lt;/code&gt; Directiva @connection</target>
        </trans-unit>
        <trans-unit id="1bc35103d12ff175f274fc790197926805195584" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@relay(mask: false)&lt;/code&gt; can be used to prevent data masking; when including a fragment and annotating it with &lt;code&gt;@relay(mask: false)&lt;/code&gt;, its data will be available directly to the parent instead of being masked for a different container.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5d3bbc3f0308d432f9237679fd4198f106ffc51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COLLISION_COMMIT_FAILED&lt;/code&gt; &amp;mdash; Transaction was queued for commit but another transaction with the same collision key failed. All transactions in the collision queue, including this one, have been failed. Transaction can be recommitted or rolled back.</source>
          <target state="translated">&lt;code&gt;COLLISION_COMMIT_FAILED&lt;/code&gt; : la transacci&amp;oacute;n se puso en cola para confirmarse, pero otra transacci&amp;oacute;n con la misma clave de colisi&amp;oacute;n fall&amp;oacute;. Todas las transacciones en la cola de colisi&amp;oacute;n, incluida esta, han fallado. La transacci&amp;oacute;n se puede volver a comprometer o deshacer.</target>
        </trans-unit>
        <trans-unit id="8093d07e77e9be3790d54f76445c918f46849774" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COMMITTING&lt;/code&gt; &amp;mdash; Transaction is waiting for the server to respond.</source>
          <target state="translated">&lt;code&gt;COMMITTING&lt;/code&gt; : la transacci&amp;oacute;n est&amp;aacute; esperando que el servidor responda.</target>
        </trans-unit>
        <trans-unit id="72fc89ccfca88827066da906d579a404ab74ce01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COMMIT_FAILED&lt;/code&gt; &amp;mdash; Transaction was sent to the server for comitting but failed.</source>
          <target state="translated">&lt;code&gt;COMMIT_FAILED&lt;/code&gt; : la transacci&amp;oacute;n se envi&amp;oacute; al servidor para su confirmaci&amp;oacute;n, pero fall&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="3ea90f9f79de8b7da5c3c317bc9a5b13f75106bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COMMIT_QUEUED&lt;/code&gt; &amp;mdash; Transaction was committed but another transaction with the same collision key is pending, so the transaction has been queued to send to the server.</source>
          <target state="translated">&lt;code&gt;COMMIT_QUEUED&lt;/code&gt; : la transacci&amp;oacute;n se confirm&amp;oacute; pero hay otra transacci&amp;oacute;n pendiente con la misma clave de colisi&amp;oacute;n, por lo que la transacci&amp;oacute;n se ha puesto en cola para enviarse al servidor.</target>
        </trans-unit>
        <trans-unit id="d35b1de34e23cc42d8709b3e3b9f29da3640030e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CompilerContext&lt;/code&gt;: an immutable representation of a corpus of GraphQL documents. It contains the schema and a mapping of document names to document representations (as IR, see above).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f3d026fc6b13bd99ef80b56496208f62a08c9dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Component&lt;/code&gt; Relay container that defines fragments and the view to render.</source>
          <target state="translated">&lt;code&gt;Component&lt;/code&gt; Contenedor de retransmisi&amp;oacute;n de componentes que define los fragmentos y la vista a renderizar.</target>
        </trans-unit>
        <trans-unit id="7e0e496215e40a981e6b2de27c4b054fef09ee84" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ConnectionHandler&lt;/code&gt; is a utility module exposed by &lt;code&gt;relay-runtime&lt;/code&gt; that aids in the manipulation of connections. &lt;code&gt;ConnectionHandler&lt;/code&gt; exposes the following interface:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfead01c2b218e3cb68f309d9651d5634bcc584a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Container&lt;/code&gt; Relay container that defines fragments and the view to render.</source>
          <target state="translated">&lt;code&gt;Container&lt;/code&gt; Relay contenedor que define los fragmentos y la vista a renderizar.</target>
        </trans-unit>
        <trans-unit id="6e013f788fda8dc5f1f6d2035114dc14dbf0b578" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DataID&lt;/code&gt; (type): A globally unique or client-generated identifier for a record, stored as a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce201c06fa6c11d5f36ef9be515d40d9178e1a3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Environment&lt;/code&gt; (type): Represents an encapsulated environment combining a &lt;code&gt;Store&lt;/code&gt; and &lt;code&gt;Network&lt;/code&gt;, providing a high-level API for interacting with both. This is the main public API of &lt;code&gt;RelayRuntime&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e3ea2f8d9422eb5a55274a578df6f8f2c6bd0ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FlattenTransform&lt;/code&gt;: Reduces extraneous levels of indirection in a query, inlining fields from anonymous fragments wherever they match the parent type. This can be beneficial when generating code to read the results of a query or process query results, as it reduces duplicate field processing. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8491c1573884a469fe6759e485e0a2a6e275e8c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;GenerateRequisiteFieldTransform&lt;/code&gt;: This optional, Relay-specific transform inserts &lt;code&gt;id&lt;/code&gt; fields for globally identifiable objects and &lt;code&gt;__typename&lt;/code&gt; fields wherever the type cannot be statically determined (e.g. for unions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfa5e3950beed71919f93e9725e12ccd2524ec5d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IR&lt;/code&gt; (Intermediate Representation): an (effectively immutable) representation of a GraphQL document (query, fragment, field, etc) as a tree structure, including type information from a schema. Compared to the standard GraphQL AST (produced by e.g. &lt;code&gt;graphql-js&lt;/code&gt;) the main difference is that it encodes more of the semantics of GraphQL. For example, conditional branches (&lt;code&gt;@include&lt;/code&gt; and &lt;code&gt;@skip&lt;/code&gt;) are represented directly, making it easier to target optimizations for these directives (One such optimization is to merge sibling fields with the same condition, potentially reducing the number of conditionals that must be evaluated at runtime).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80030d53df3c7d765455bf7613659bf4eb278701" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Network&lt;/code&gt; (type): Provides methods for fetching query data from and executing mutations against an external data source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d52ff52d23e6ad23c71ab30789b670011882899f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PaginationContainer&lt;/code&gt; is designed to simplify the workflow of loading more items in a list -- in many cases, we don't want to fetch all the data at once but lazily load more data. It relies on a GraphQL server exposing connections in a standardized way. For a detailed spec, please check out &lt;a href=&quot;https://facebook.github.io/relay/graphql/connections.htm&quot;&gt;this page&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;PaginationContainer&lt;/code&gt; est&amp;aacute; dise&amp;ntilde;ado para simplificar el flujo de trabajo de cargar m&amp;aacute;s elementos en una lista; en muchos casos, no queremos recuperar todos los datos a la vez, sino cargar m&amp;aacute;s datos de forma perezosa. Se basa en un servidor GraphQL que expone las conexiones de forma estandarizada. Para obtener una especificaci&amp;oacute;n detallada, consulte &lt;a href=&quot;https://facebook.github.io/relay/graphql/connections.htm&quot;&gt;esta p&amp;aacute;gina&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="36a682fa10b4ab6dd0259f5b624dca4803e8ff33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Parser&lt;/code&gt;: Converts a GraphQL schema and raw GraphQL text into typed IR objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f603ad3da9b9bbbb0030816e3352c33635f9a1f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Printer&lt;/code&gt;: a function that accepts IR and converts it to a GraphQL string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5406da34447a5b22b7d56f6fce92e419b505424" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;QueryRenderer&lt;/code&gt; is the root of a Relay tree. It takes a query, fetches the data and calls the &lt;code&gt;render&lt;/code&gt; callback with the data.</source>
          <target state="translated">&lt;code&gt;QueryRenderer&lt;/code&gt; es la ra&amp;iacute;z de un &amp;aacute;rbol de retransmisi&amp;oacute;n. Toma una consulta, recupera los datos y llama a la devoluci&amp;oacute;n de llamada de &lt;code&gt;render&lt;/code&gt; con los datos.</target>
        </trans-unit>
        <trans-unit id="593061a9841e95181922e32bf061e078ec44605a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;QueryRenderer&lt;/code&gt; supports rendering small amounts of data directly, instead of requiring a container to access data. &lt;a href=&quot;fragment-container&quot;&gt;Containers&lt;/a&gt; are optional and can be used as your application grows in size and complexity.</source>
          <target state="translated">&lt;code&gt;QueryRenderer&lt;/code&gt; admite la representaci&amp;oacute;n de peque&amp;ntilde;as cantidades de datos directamente, en lugar de requerir un contenedor para acceder a los datos. &lt;a href=&quot;fragment-container&quot;&gt;Los contenedores&lt;/a&gt; son opcionales y se pueden usar a medida que su aplicaci&amp;oacute;n crece en tama&amp;ntilde;o y complejidad.</target>
        </trans-unit>
        <trans-unit id="99e84e643c97bf62b99096002ffcdeabf9974b27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;QueryRenderer&lt;/code&gt; will then fetch the data and render &lt;code&gt;StoryContainer&lt;/code&gt; once the data is available. Just as React allows developers to render views without directly manipulating the underlying view, Relay removes the need to directly communicate with the network.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa5389da6f3012b6c1290dfc4aabb66ac37a4a88" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Record&lt;/code&gt; (type): A representation of a distinct data entity with an identity, type, and fields. Note that the actual runtime representation is opaque to the system: all accesses to &lt;code&gt;Record&lt;/code&gt; objects (including record creation) is mediated through the &lt;code&gt;RelayModernRecord&lt;/code&gt; module. This allows the representation itself to be changed in a single place (e.g. to use &lt;code&gt;Map&lt;/code&gt;s or a custom class). It is important that other code does not assume that &lt;code&gt;Record&lt;/code&gt;s will always be plain objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c286a93f7d02b418c79e236a3f655909cd0828b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RecordSource&lt;/code&gt; (type): A collection of records keyed by their data ID, used both to represent the cache and updates to it. For example the store's record cache is a &lt;code&gt;RecordSource&lt;/code&gt; and the results of queries/mutations/subscriptions are normalized into &lt;code&gt;RecordSource&lt;/code&gt;s that are published to a store. Sources also define methods for asynchronously loading records in order to (eventually) support offline use-cases. Currently the only implementation of this interface is &lt;code&gt;RelayInMemoryRecordSource&lt;/code&gt;; future implementations may add support for loading records from disk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dcadb6bea3b3b49c5e438342092e725abab0a3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; doesn't provide any bells and whistles such as fat queries or tracked queries (that is, automatic synthesis at runtime of the mutation query to be sent to the server), instead having the user define a static and explicit query. Restricting yourself to the low-level API is a useful preparatory step that will help you ready your codebase for migration to the new static Relay core. In the meantime, if you want those dynamic features, you can opt in to the higher-level &lt;code&gt;Relay.Mutation&lt;/code&gt; API.</source>
          <target state="translated">&lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; . Restringirse a la API de bajo nivel es un paso preparatorio &amp;uacute;til que lo ayudar&amp;aacute; a preparar su base de c&amp;oacute;digo para la migraci&amp;oacute;n al nuevo n&amp;uacute;cleo de Relay est&amp;aacute;tico. Mientras tanto, si desea esas funciones din&amp;aacute;micas, puede optar por la API &lt;code&gt;Relay.Mutation&lt;/code&gt; de nivel superior .</target>
        </trans-unit>
        <trans-unit id="b9dbe21f8c1dda099d24350958022ccc0bb3f410" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; is a low-level API for modeling a GraphQL mutation.</source>
          <target state="translated">&lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; es una API de bajo nivel para modelar una mutaci&amp;oacute;n GraphQL.</target>
        </trans-unit>
        <trans-unit id="127b1aff45435298c344787323bda31e37d71df8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Relay.QL&lt;/code&gt; objects are used by the following APIs:</source>
          <target state="translated">&lt;code&gt;Relay.QL&lt;/code&gt; objetos Relay.QL son utilizados por las siguientes API:</target>
        </trans-unit>
        <trans-unit id="7e9cc4a6100437d109392de9c4dd32579e5bef54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Relay.Renderer&lt;/code&gt; can then orchestrate the fetching of the queries; diffing them against cached data, fetching any missing information, updating the cache, and finally rendering &lt;code&gt;StoryContainer&lt;/code&gt; once the data is available. The default is to render nothing while data is fetching, but the loading view can be customized via the &lt;code&gt;render&lt;/code&gt; prop. Just as React allows developers to render views without directly manipulating the underlying view, Relay and &lt;code&gt;Relay.Renderer&lt;/code&gt; remove the need to directly communicate with the network.</source>
          <target state="translated">&lt;code&gt;Relay.Renderer&lt;/code&gt; puede entonces orquestar la b&amp;uacute;squeda de las consultas; compar&amp;aacute;ndolos con los datos almacenados en cach&amp;eacute;, &lt;code&gt;StoryContainer&lt;/code&gt; la informaci&amp;oacute;n que falta, actualizando el cach&amp;eacute; y finalmente renderizando StoryContainer una vez que los datos est&amp;aacute;n disponibles. El valor predeterminado es no representar nada mientras se recuperan los datos, pero la vista de carga se puede personalizar a trav&amp;eacute;s del accesorio de &lt;code&gt;render&lt;/code&gt; . As&amp;iacute; como React permite a los desarrolladores renderizar vistas sin manipular directamente la vista subyacente, Relay y &lt;code&gt;Relay.Renderer&lt;/code&gt; eliminan la necesidad de comunicarse directamente con la red.</target>
        </trans-unit>
        <trans-unit id="af18c48993c9562a944639b49a29f4455950bbaf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Relay&lt;/code&gt; is the entry point to the Relay library. If you're using one of the prebuilt packages it's available as a global; if you're using CommonJS modules you can &lt;code&gt;require()&lt;/code&gt; it.</source>
          <target state="translated">&lt;code&gt;Relay&lt;/code&gt; es el punto de entrada a la biblioteca Relay. Si est&amp;aacute; utilizando uno de los paquetes predise&amp;ntilde;ados, est&amp;aacute; disponible como global; si est&amp;aacute; utilizando m&amp;oacute;dulos CommonJS, puede &lt;code&gt;require()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c66e5b2f381152669b034d6f6167ad8cf6ed012" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RelayContainer&lt;/code&gt; is a higher-order React component that lets a React component encode its data requirements.</source>
          <target state="translated">&lt;code&gt;RelayContainer&lt;/code&gt; es un componente React de orden superior que permite que un componente React codifique sus requisitos de datos.</target>
        </trans-unit>
        <trans-unit id="df2d84ab4a50cd1673857a423e00806293940147" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RelayMutationRequest&lt;/code&gt; encapsulates a mutation that Relay needs to send to the server. They are made available to network layers via the &lt;code&gt;sendMutation&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;RelayMutationRequest&lt;/code&gt; encapsula una mutaci&amp;oacute;n que Relay necesita enviar al servidor. Se ponen a disposici&amp;oacute;n de las capas de red mediante el m&amp;eacute;todo &lt;code&gt;sendMutation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e4dc52a29a31a839078a5cad953c9628f74f0f0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RelayMutationTransaction.getStatus&lt;/code&gt; can return one of the following strings:</source>
          <target state="translated">&lt;code&gt;RelayMutationTransaction.getStatus&lt;/code&gt; puede devolver una de las siguientes cadenas:</target>
        </trans-unit>
        <trans-unit id="242d9ea8a1f2fba8d773760a8233ecf37bf7b5f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RelayQueryRequest&lt;/code&gt; encapsulates a query that Relay needs to send to the server. They are made available to network layers via the &lt;code&gt;sendQueries&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;RelayQueryRequest&lt;/code&gt; encapsula una consulta que Relay necesita enviar al servidor. Est&amp;aacute;n disponibles para las capas de red a trav&amp;eacute;s del m&amp;eacute;todo &lt;code&gt;sendQueries&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa983dda38587dddabcba1aaf5a70bd38e50d1c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Selector&lt;/code&gt; (type): A selector defines the starting point for a traversal into the graph for the purposes of targeting a subgraph, combining a GraphQL fragment, variables, and the Data ID for the root object from which traversal should progress. Intuitively, this &quot;selects&quot; a portion of the object graph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af3c71166345fc66296a2fcfde6e211df573f098" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SkipRedundantNodeTransform&lt;/code&gt;: A more advanced version of flattening, this eliminates more complex cases of field duplication such as when a field is fetched both unconditionally and conditionally, or is fetched by two different sub-fragments. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fba6d300e8d2beebd7043543022bbc6158c521d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Snapshot&lt;/code&gt; (type): The (immutable) results of executing a &lt;code&gt;Selector&lt;/code&gt; at a given point in time. This includes the selector itself, the results of executing it, and a list of the Data IDs from which data was retrieved (useful in determining when these results might change).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd6f9d1898c7f71f61996e47d31e4669e9f6ea00" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Store&lt;/code&gt; (type): The source of truth for an instance of &lt;code&gt;RelayRuntime&lt;/code&gt;, holding the canonical set of records in the form of a &lt;code&gt;RecordSource&lt;/code&gt; (though this is not required). Currently the only implementation is &lt;code&gt;RelayModernStore&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6953a65cec76dd55ffb8686c4013c2fe83a10320" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Transform&lt;/code&gt;: a &quot;map&quot;-like function that accepts a &lt;code&gt;CompilerContext&lt;/code&gt; as input and returns a new, modified context as output. Examples below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df62ea345a45d0a5fabcd2fdbf901148c6e5a8b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNCOMMITTED&lt;/code&gt; &amp;mdash; Transaction hasn't yet been sent to the server. Transaction can be committed or rolled back.</source>
          <target state="translated">&lt;code&gt;UNCOMMITTED&lt;/code&gt; : la transacci&amp;oacute;n a&amp;uacute;n no se ha enviado al servidor. La transacci&amp;oacute;n se puede confirmar o deshacer.</target>
        </trans-unit>
        <trans-unit id="251d369c69abccbd72c957636015d12c5ab2df7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cacheConfig?&lt;/code&gt;: Optional object containing a set of cache configuration options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44015182f39e2d46ef207ac1787ea9eab09b8733" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cacheConfig?&lt;/code&gt;: Optional object containing a set of cache configuration options, i.e. &lt;code&gt;force: true&lt;/code&gt; requires the fetch to be issued regardless of the state of any configured response cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1e2ffe769d943340c0e937aef710727a6236ec6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cacheConfig?&lt;/code&gt;: Optional object containing a set of cache configuration options, i.e. &lt;code&gt;force: true&lt;/code&gt; requires the fetch to be issued regardless of the state of any configured response cache. See &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/relay-runtime/lib/util/RelayRuntimeTypes.d.ts#L22-L35&quot;&gt;the types&lt;/a&gt; for more &lt;code&gt;cacheConfig&lt;/code&gt; options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90c165e6157296f7bcc1ff33984b3b1b9a2c82c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;callback&lt;/code&gt;: Function called when the new page has been fetched. If an error occurred during refetch, this function will receive that error as an argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a549ab3ecb985d7c1e6a0bcdb2975890cf8213e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;callback&lt;/code&gt;: Function to be called after the refetch has completed. If an error occurred during refetch, this function will receive that error as an argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ddb9c091b2339b506a0b25d46c1b43d0aec3f3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;component&lt;/code&gt;: The React Component &lt;em&gt;class&lt;/em&gt; of the component requiring the fragment data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d84b6d9b41c57662dbad63044ec256b7ffeb4679" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;config&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;config&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="06f15b2aa1dd0d5d58698483052939daa832e202" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;configs&lt;/code&gt;: Array containing objects describing &lt;code&gt;optimisticUpdater&lt;/code&gt;/&lt;code&gt;updater&lt;/code&gt; configurations. &lt;code&gt;configs&lt;/code&gt; provides a convenient way to specify the &lt;code&gt;updater&lt;/code&gt; behavior without having to write an &lt;code&gt;updater&lt;/code&gt; function. See our section on &lt;a href=&quot;#updater-configs&quot;&gt;Updater Configs&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50a52e374bfb1a67a3f6d2363ba22492f2e2e80d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;configs&lt;/code&gt;: an array containing the different optimisticUpdater/updater configurations. It provides a convenient way to specify the &lt;code&gt;updater&lt;/code&gt; behavior.</source>
          <target state="translated">&lt;code&gt;configs&lt;/code&gt; : una matriz que contiene las diferentes configuraciones optimisticUpdater / Updater. Proporciona una forma conveniente de especificar el comportamiento del &lt;code&gt;updater&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cc60f97e29bfb6ea62a807eae2cc5e7a17f3eb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;configs&lt;/code&gt;: an array containing the updater configurations. It is the same as &lt;a href=&quot;mutations#configs&quot;&gt;&lt;code&gt;configs&lt;/code&gt;&lt;/a&gt; in &lt;code&gt;commitMutation&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;configs&lt;/code&gt; : una matriz que contiene las configuraciones del actualizador. Es lo mismo que &lt;a href=&quot;mutations#configs&quot;&gt; &lt;code&gt;configs&lt;/code&gt; &lt;/a&gt; en &lt;code&gt;commitMutation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62ed1b32bc4ea099a4726b7185046d66828e634b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;configs&lt;/code&gt;: an array containing the updater configurations. It is the same as &lt;a href=&quot;mutations#updater-configs&quot;&gt;&lt;code&gt;configs&lt;/code&gt;&lt;/a&gt; in &lt;code&gt;commitMutation&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="007117b0cb1510ebdd6ccffcf08576a3c37cde5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;connectionConfig&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;connectionConfig&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="9394dd3d6a30c68a04fbce9521aacc5342c5da92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;connectionInfo: Array&amp;lt;{key: string, filters?: Variables, rangeBehavior:
string}&amp;gt;&lt;/code&gt;: An array of objects containing a connection key, an object containing optional filters, and a range behavior depending on what behavior we expect (append, prepend, or ignore).</source>
          <target state="translated">&lt;code&gt;connectionInfo: Array&amp;lt;{key: string, filters?: Variables, rangeBehavior: string}&amp;gt;&lt;/code&gt; : una matriz de objetos que contiene una clave de conexi&amp;oacute;n, un objeto que contiene filtros opcionales y un comportamiento de rango seg&amp;uacute;n el comportamiento que esperamos (a&amp;ntilde;adir, anteponer, o ignorar).</target>
        </trans-unit>
        <trans-unit id="43c66a2069ec0b2d4be35833e1ae8977d9b93edf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;connectionKeys: Array&amp;lt;{key: string, filters?: Variables}&amp;gt;&lt;/code&gt;: An array of objects containing a connection key and optionally filters.</source>
          <target state="translated">&lt;code&gt;connectionKeys: Array&amp;lt;{key: string, filters?: Variables}&amp;gt;&lt;/code&gt; : Una matriz de objetos que contiene una clave de conexi&amp;oacute;n y, opcionalmente, filtros.</target>
        </trans-unit>
        <trans-unit id="3d66112758b5fe7d9ec709917fc9645fa7ce2017" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;createFragmentContainer&lt;/code&gt; has the following signature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38957bb815ee45a69777b60c1f154618685af8ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;createPaginationContainer&lt;/code&gt; has the following signature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3466a399b65ec8fadadd39718cdbdde5b6b2fc57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;createRefetchContainer&lt;/code&gt; has the following signature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d19b3e482db84864f686a4ee3759da01773329b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deletedIDFieldName: string | Array&amp;lt;string&amp;gt;&lt;/code&gt;: The field name in the response that contains the DataID of the removed node, or the path to the node removed from the connection</source>
          <target state="translated">&lt;code&gt;deletedIDFieldName: string | Array&amp;lt;string&amp;gt;&lt;/code&gt; : el nombre del campo en la respuesta que contiene el DataID del nodo eliminado, o la ruta al nodo eliminado de la conexi&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="876617472fa789679ebf9a0b7c9f1eb24f355aa8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deletedIDFieldName: string | Array&amp;lt;string&amp;gt;&lt;/code&gt;: The field name in the response that contains the DataID or DataIDs of the removed node or nodes, or the path to the node or nodes removed from the connection</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e977f6b2b4f562aa7af31b00751819ad50d520ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deletedIDFieldName: string&lt;/code&gt;: The field name in the response that contains the DataID of the deleted node</source>
          <target state="translated">&lt;code&gt;deletedIDFieldName: string&lt;/code&gt; : el nombre del campo en la respuesta que contiene el DataID del nodo eliminado</target>
        </trans-unit>
        <trans-unit id="bf1fd5c8652f9301a307527a2205d4d2b4a75a34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deletedIDFieldName: string&lt;/code&gt;: The field name in the response that contains the DataID or DataIDs of the deleted node or nodes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="999f3fdfc8dda2a0f3aa0796444cc77a3d69202e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;direction&lt;/code&gt;: Either &quot;forward&quot; to indicate forward pagination using after/first, or &quot;backward&quot; to indicate backwards pagination using before/last. If not provided, Relay will infer the direction based on the provided &lt;code&gt;@connection&lt;/code&gt; directive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22bd764f98c24605fee21c6e86534a102d352d4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;edgeName: string&lt;/code&gt;: The field name in the response that represents the newly created edge</source>
          <target state="translated">&lt;code&gt;edgeName: string&lt;/code&gt; : el nombre del campo en la respuesta que representa el borde reci&amp;eacute;n creado</target>
        </trans-unit>
        <trans-unit id="b7ab967dc3d9dac41042965f33de5bbacae6b0e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;environment&lt;/code&gt; An instance of `Relay.Environment` or any object that implements the `RelayEnvironment` interface.</source>
          <target state="translated">&lt;code&gt;environment&lt;/code&gt; Una instancia de `Relay.Environment` o cualquier objeto que implemente la interfaz` RelayEnvironment`.</target>
        </trans-unit>
        <trans-unit id="934fc584b2cbd07fff4713741be349d8db57ed53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;environment&lt;/code&gt;: The &lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c04830e6cd3cb5a81acacd5ef47ab3c8d851603a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;environment&lt;/code&gt;: The &lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt;. &lt;strong&gt;Note:&lt;/strong&gt; To ensure the mutation is performed on the correct &lt;code&gt;environment&lt;/code&gt;, it's recommended to use the environment available within components (from &lt;code&gt;this.props.relay.environment&lt;/code&gt;), instead of referencing a global environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c42e0b6673753c1ecd9043bed1858fc0974cabb9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;environment&lt;/code&gt;: The current &lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="516a6ee32a7083dc25663e4b1b51d53113bbfc43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;error&lt;/code&gt;: Error will be defined if an error has occurred while fetching the query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="933f09a28ce1c93df86693d7ec2e3b4c3c2c539a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fetchPolicy&lt;/code&gt;: If the data is already present in the store, using the &lt;code&gt;'store-or-network'&lt;/code&gt; option will use that data without making an additional network request. Using the &lt;code&gt;'network-only'&lt;/code&gt; option, which is the default behavior, will ignore any data present in the store and make a network request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="094d53375b81243f7e2c05c1de339c8e282ff5d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fetchPolicy?&lt;/code&gt;: Optional prop to indicate if data already present in the store should be used to render immediately and updated from the network afterwards using the &lt;code&gt;store-and-network&lt;/code&gt; key. Using the &lt;code&gt;network-only&lt;/code&gt; key, which is the default behavior, ignores data already present in the store and waits for the network results to come back.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2b9d698f04dcb6c9b4de74dbaccc7db4327ebbe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filters&lt;/code&gt;: &lt;strong&gt;Optional&lt;/strong&gt; Array of strings that belong to the set of argument variables defined for the connection field (e.g. &lt;code&gt;orderBy&lt;/code&gt;, &lt;code&gt;searchTerm&lt;/code&gt;, etc). The values for the variables specified in this array will be used alongside the user-supplied &lt;code&gt;key&lt;/code&gt; to uniquely identify a connection. If &lt;code&gt;filters&lt;/code&gt; is not provided, by default Relay will use the set of all of the arguments the connection field takes, excluding pagination specific arguments (i.e. &lt;code&gt;first&lt;/code&gt;/&lt;code&gt;last&lt;/code&gt;, &lt;code&gt;after&lt;/code&gt;/&lt;code&gt;before&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a65d389a718020e07ebee40da7bdd44c16a4420" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filters&lt;/code&gt;: An object containing GraphQL calls e.g. &lt;code&gt;const filters = {'orderby': 'chronological'};&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;filters&lt;/code&gt; : un objeto que contiene llamadas GraphQL, por ejemplo, &lt;code&gt;const filters = {'orderby': 'chronological'};&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="499b17304b2bef431abd97d0542599af80ca0ff3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;force&lt;/code&gt;: If the &lt;a href=&quot;network-layer&quot;&gt;Network Layer&lt;/a&gt; has been configured with a cache, this option forces a refetch even if the data for this query and variables is already available in the cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41eb5ef20bb9fe4e11e5a7ba243c250838991a3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forceFetch&lt;/code&gt; Whether to send a server request regardless of data available on the client.</source>
          <target state="translated">&lt;code&gt;forceFetch&lt;/code&gt; Si se debe enviar una solicitud al servidor independientemente de los datos disponibles en el cliente.</target>
        </trans-unit>
        <trans-unit id="d556d0cc8a6f2287f3af67eacd90ec1629094411" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forceFetch&lt;/code&gt; can be called with an empty set of partial variables, meaning it can trigger a refresh of the currently rendered set of data.</source>
          <target state="translated">&lt;code&gt;forceFetch&lt;/code&gt; se puede llamar con un conjunto vac&amp;iacute;o de variables parciales, lo que significa que puede activar una actualizaci&amp;oacute;n del conjunto de datos actualmente renderizado.</target>
        </trans-unit>
        <trans-unit id="7c4e5ec515c48d1d775f76f1e41f31d520e97786" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forceFetch&lt;/code&gt; is similar to &lt;code&gt;setVariables&lt;/code&gt; because it is also used to change the data requirements by altering &lt;code&gt;variables&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;forceFetch&lt;/code&gt; es similar a &lt;code&gt;setVariables&lt;/code&gt; porque tambi&amp;eacute;n se usa para cambiar los requisitos de datos al alterar las &lt;code&gt;variables&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="690e2c556d1d75133f45a6c4a69283c5b06e6d4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fragmentSpec&lt;/code&gt;: Specifies the data requirements for the Component via a GraphQL fragment. It is expected that one of the fragments specified here will contain a &lt;a href=&quot;#connection&quot;&gt;&lt;code&gt;@connection&lt;/code&gt;&lt;/a&gt; for pagination. The required data will be available on the component as props that match the shape of the provided fragment. &lt;code&gt;fragmentSpec&lt;/code&gt; should be an object whose keys are prop names and values are &lt;code&gt;graphql&lt;/code&gt; tagged fragments. Each key specified in this object will correspond to a prop available to the resulting Component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ebe3bc29a0cf52244f436e5b9f683f8e5e726a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fragmentSpec&lt;/code&gt;: Specifies the data requirements for the Component via a GraphQL fragment. The required data will be available on the component as props that match the shape of the provided fragment. &lt;code&gt;fragmentSpec&lt;/code&gt; should be an object whose keys are prop names and values are &lt;code&gt;graphql&lt;/code&gt; tagged fragments. Each key specified in this object will correspond to a prop available to the resulting Component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78c6f70e52f47838301be68f3a7fc35ddbd14be0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fragments&lt;/code&gt; Declare the component's data requirements using fragments.</source>
          <target state="translated">&lt;code&gt;fragments&lt;/code&gt; Declare los requisitos de datos del componente utilizando fragmentos.</target>
        </trans-unit>
        <trans-unit id="f347d7322bb64c982a8914c374d1d9989d23caa9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getConnectionFromProps&lt;/code&gt;: Function that should indicate which connection to paginate over, given the fragment props (i.e. the props corresponding to the &lt;code&gt;fragmentSpec&lt;/code&gt;). This is necessary in most cases because the Relay can't automatically tell which connection you mean to paginate over (a container might fetch multiple fragments and connections, but can only paginate one of them). If not provided, Relay will try infer the correct connection to paginate over based on the provided &lt;code&gt;@connection&lt;/code&gt; directive. See our &lt;a href=&quot;#pagination-example&quot;&gt;example&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffcebb96656094f38726e63b34eb65150f50c9ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getFragment(name[, vars])&lt;/code&gt; Get a reference to a container fragment for inclusion in a parent fragment.</source>
          <target state="translated">&lt;code&gt;getFragment(name[, vars])&lt;/code&gt; Obtiene una referencia a un fragmento de contenedor para incluirlo en un fragmento principal.</target>
        </trans-unit>
        <trans-unit id="cff5af6182f7fb8ef3f8ecccc18f0ba0cbe50adf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getFragmentVariables&lt;/code&gt;: Function that should return the bag of variables to use for reading out the data from the store when re-rendering the component. This function takes the previous set of variables passed to the pagination &lt;code&gt;query&lt;/code&gt;, and the number of elements that have been fetched in total so far. Specifically, this indicates which variables to use when reading out the data from the local data store &lt;em&gt;after&lt;/em&gt; the new pagination &lt;code&gt;query&lt;/code&gt; has been fetched. If not specified, Relay will default to using all of the previous variables and using the total count for the &lt;code&gt;count&lt;/code&gt; variable. This option is analogous to &lt;a href=&quot;refetch-container#refetch&quot;&gt;&lt;code&gt;renderVariables&lt;/code&gt;&lt;/a&gt; in the Refetch Container. See our &lt;a href=&quot;#pagination-example&quot;&gt;example&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="626651fb7fc8a336ea351887a559499388854ca0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getVariables&lt;/code&gt;: Function that should return the variables to pass to the pagination &lt;code&gt;query&lt;/code&gt; when fetching it from the server, given the current &lt;code&gt;props&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;cursor&lt;/code&gt;. You may set whatever variables here, as well as modify the defaults to use for after/first/before/last arguments. See our &lt;a href=&quot;#pagination-example&quot;&gt;example&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a5a41dfd716e53597f64c88977873298358ac32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hasMore&lt;/code&gt; is a function available on the &lt;code&gt;relay&lt;/code&gt;&lt;a href=&quot;#available-props&quot;&gt;prop&lt;/a&gt;. This function indicates whether there are more pages to fetch from the server or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1035c3f8ef8bea7423860896c5ab932f003bfcca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hasMore&lt;/code&gt;: See &lt;code&gt;hasMore&lt;/code&gt;&lt;a href=&quot;#hasmore&quot;&gt;docs&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d2af946a8f787de1546269d02d1783ad16d7ce4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;initialVariables&lt;/code&gt; The initial set of variable values available to this component's fragments.</source>
          <target state="translated">&lt;code&gt;initialVariables&lt;/code&gt; El conjunto inicial de valores de variable disponibles para los fragmentos de este componente.</target>
        </trans-unit>
        <trans-unit id="b0b6cb762b7bc1dde73e00ccfd867874ca46a854" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isLoading&lt;/code&gt; is a function available on the &lt;code&gt;relay&lt;/code&gt;&lt;a href=&quot;#available-props&quot;&gt;prop&lt;/a&gt;. This function indicates if a previous call to &lt;a href=&quot;#loadmore&quot;&gt;&lt;code&gt;loadMore()&lt;/code&gt;&lt;/a&gt; is still pending. This is convenient for avoiding duplicate load calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3cf1633778c794a6d5137a6fc7ee91e9dc015a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isLoading&lt;/code&gt;: See &lt;code&gt;isLoading&lt;/code&gt;&lt;a href=&quot;#isloading&quot;&gt;docs&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f96bf65801e1e45617b0b7293698801c726cb5a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;key&lt;/code&gt;: &lt;strong&gt;Required&lt;/strong&gt; String that serves as a unique identifier for the connection under the parent field type. A good practice could be &lt;code&gt;&amp;lt;ComponentName&amp;gt;_&amp;lt;fieldName | fieldAlias&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="699706e765e60007f25a7dad7551d2b11ce95c76" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;loadMore&lt;/code&gt; is a function available on the &lt;code&gt;relay&lt;/code&gt;&lt;a href=&quot;#available-props&quot;&gt;prop&lt;/a&gt;. You can call &lt;code&gt;loadMore()&lt;/code&gt; to fetch more items from the server based on the &lt;code&gt;connectionConfig&lt;/code&gt; provided to the container. This will return null if there are no more items to fetch, otherwise it will fetch more items and return a Disposable that can be used to cancel the fetch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fe3cacb8f804fae55fb785b3fe1234cd03400a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;loadMore&lt;/code&gt;: See &lt;code&gt;loadMore&lt;/code&gt;&lt;a href=&quot;#loadmore&quot;&gt;docs&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76264748ee4f7e2b85f5ec429b655faa6e2afb7a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lookup(selector: Selector): Snapshot&lt;/code&gt;: Reads the results of a selector from the store, returning the value given the data currently in the store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40b36321c1572c121ad403c4633eda3e50781805" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutation&lt;/code&gt;: The &lt;code&gt;graphql&lt;/code&gt; tagged mutation query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="563c728f73a72af11f9bfebcd489b1605c4ad5b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutation&lt;/code&gt;: the &lt;code&gt;graphql&lt;/code&gt; tagged mutation query.</source>
          <target state="translated">&lt;code&gt;mutation&lt;/code&gt; : la consulta de mutaci&amp;oacute;n con etiqueta &lt;code&gt;graphql&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8757e61c041c5769ac4b56cae5108d1ce8243f0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;notify(): void&lt;/code&gt;: Calls any &lt;code&gt;subscribe()&lt;/code&gt;-ers whose results have changed due to intervening &lt;code&gt;publish()&lt;/code&gt;-es. Separating &lt;code&gt;publish()&lt;/code&gt; and &lt;code&gt;notify()&lt;/code&gt; allows for multiple payloads to be published before performing any downstream update logic (such as rendering).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bfa68e762b718f3167374497af4ce681b706e47" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onCompleted&lt;/code&gt;: Callback function executed when the request is completed and the in-memory Relay store is updated with the &lt;code&gt;updater&lt;/code&gt; function. Takes a &lt;code&gt;response&lt;/code&gt; object, which is the updated response from the store, and &lt;code&gt;errors&lt;/code&gt;, an array containing any errors from the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6a934fa0ef96a565381122a89d9aee1a4fba9dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onCompleted&lt;/code&gt;: a callback function executed when the subscription is closed by the peer without error.</source>
          <target state="translated">&lt;code&gt;onCompleted&lt;/code&gt; : una funci&amp;oacute;n de devoluci&amp;oacute;n de llamada que se ejecuta cuando el par cierra la suscripci&amp;oacute;n sin errores.</target>
        </trans-unit>
        <trans-unit id="a715680a7bcdc7a8e18cff64218bee6c4c5f714a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onCompleted&lt;/code&gt;: a callback function executed with the 'raw' response and errors from the server after the in-memory Relay store is updated with the &lt;code&gt;updater&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;onCompleted&lt;/code&gt; : una funci&amp;oacute;n de devoluci&amp;oacute;n de llamada ejecutada con la respuesta 'sin procesar' y los errores del servidor despu&amp;eacute;s de que el almac&amp;eacute;n de retransmisi&amp;oacute;n en memoria se actualice con el &lt;code&gt;updater&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c178dbfaff171f363cbc5ee015a82adb2c39a56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onError&lt;/code&gt;: Callback function executed if Relay encounters an error during the request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e17c27700518dd0a0d9e3907f0ead05f610d8e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onError&lt;/code&gt;: a callback function executed when Relay encounters an error.</source>
          <target state="translated">&lt;code&gt;onError&lt;/code&gt; : una funci&amp;oacute;n de devoluci&amp;oacute;n de llamada que se ejecuta cuando Relay encuentra un error.</target>
        </trans-unit>
        <trans-unit id="5632405e91380cb8466949662b4346c6b8f63bac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onError&lt;/code&gt;: a callback function executed when Relay or the server encounters an error processing the subscription.</source>
          <target state="translated">&lt;code&gt;onError&lt;/code&gt; : una funci&amp;oacute;n de devoluci&amp;oacute;n de llamada que se ejecuta cuando Relay o el servidor encuentran un error al procesar la suscripci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="13f38fe85bb18ed69b3110347c91c063ca63f296" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onFailure&lt;/code&gt; is called if the mutation failed.</source>
          <target state="translated">&lt;code&gt;onFailure&lt;/code&gt; se llama si la mutaci&amp;oacute;n fall&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="34b282489eb2fc659bf8f182ecccfa58a4f98bbf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onNext&lt;/code&gt;: a callback function executed each time a response is received from the server, with the raw GraphQL response payload.</source>
          <target state="translated">&lt;code&gt;onNext&lt;/code&gt; : una funci&amp;oacute;n de devoluci&amp;oacute;n de llamada que se ejecuta cada vez que se recibe una respuesta del servidor, con la carga &amp;uacute;til de respuesta GraphQL sin procesar.</target>
        </trans-unit>
        <trans-unit id="b0c18e8b6186d7338bef8b15b59ec6ca63cd0225" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onSuccess&lt;/code&gt; is called if the mutation succeeded.</source>
          <target state="translated">&lt;code&gt;onSuccess&lt;/code&gt; Se llama a onSuccess si la mutaci&amp;oacute;n tuvo &amp;eacute;xito.</target>
        </trans-unit>
        <trans-unit id="f106ec445789577b27b8a00bf7ea0a1de269df16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;optimisticResponse&lt;/code&gt;: Object containing the data to optimistically update the local in-memory store, i.e. immediately, before the mutation request has completed. This object must have the same shape as the mutation's response type, as defined by the GraphQL schema. If provided, Relay will use the &lt;code&gt;optimisticResponse&lt;/code&gt; data to update the fields on the relevant records in the local data store, &lt;em&gt;before&lt;/em&gt;&lt;code&gt;optimisticUpdater&lt;/code&gt; is executed. If an error occurs during the mutation request, the optimistic update will be rolled back.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a1dc36be8e9a3f9069b3ce5c93735b18dee1d9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;optimisticResponse&lt;/code&gt;: an object conforming to the mutation's response type definition. If provided, the optimistic response will be normalized to the proxy store before &lt;code&gt;optimisticUpdater&lt;/code&gt; is executed. We suggest you provide an &lt;code&gt;optimisticResponse&lt;/code&gt; for two benefits:</source>
          <target state="translated">&lt;code&gt;optimisticResponse&lt;/code&gt; : un objeto que se ajusta a la definici&amp;oacute;n del tipo de respuesta de la mutaci&amp;oacute;n. Si se proporciona, la respuesta optimista se normalizar&amp;aacute; en el almac&amp;eacute;n proxy antes de que se ejecute &lt;code&gt;optimisticUpdater&lt;/code&gt; . Le sugerimos que proporcione una &lt;code&gt;optimisticResponse&lt;/code&gt; para dos beneficios:</target>
        </trans-unit>
        <trans-unit id="bbad0ba283ad50214764ae5e67837a37a21bb012" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;optimisticUpdater&lt;/code&gt;: Function used to optimistically update the local in-memory store, i.e. immediately, before the mutation request has completed. If an error occurs during the mutation request, the optimistic update will be rolled back. This function takes a &lt;code&gt;store&lt;/code&gt;, which is a proxy of the in-memory &lt;a href=&quot;relay-store&quot;&gt;Relay Store&lt;/a&gt;. In this function, the client defines 'how to' update the local data via the &lt;code&gt;store&lt;/code&gt; instance. For details on how to use the &lt;code&gt;store&lt;/code&gt;, please refer to our &lt;a href=&quot;relay-store&quot;&gt;Relay Store API Reference&lt;/a&gt;. &lt;strong&gt;Please note:&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ace8dc4f2ade074a4518666a5d5ce3fc892c20c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;optimisticUpdater&lt;/code&gt;: a function that takes in a proxy of the in-memory Relay store. In this function, the client defines 'how to' update the store through the proxy in an imperative way.</source>
          <target state="translated">&lt;code&gt;optimisticUpdater&lt;/code&gt; : una funci&amp;oacute;n que toma un proxy del almac&amp;eacute;n de retransmisi&amp;oacute;n en memoria. En esta funci&amp;oacute;n, el cliente define 'c&amp;oacute;mo' actualizar la tienda a trav&amp;eacute;s del proxy de forma imperativa.</target>
        </trans-unit>
        <trans-unit id="5c56eae08c5039c703ead5297dcb43b136ebc215" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options&lt;/code&gt;: Optional object containing set of options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f1ee884cdcbedfd5023f2b423e04d3d21c8d4a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pageSize&lt;/code&gt;: The number of &lt;strong&gt;additional&lt;/strong&gt; items to fetch (not the total).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b45ed0f29925a557b65dfee5d20499e8f93783ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parentID: string&lt;/code&gt;: The DataID of the parent node that contains the connection.</source>
          <target state="translated">&lt;code&gt;parentID: string&lt;/code&gt; : el DataID del nodo principal que contiene la conexi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="90d6f234e369d7056e4a4a384ce4d56b75c66508" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pathToConnection: Array&amp;lt;string&amp;gt;&lt;/code&gt;: An array containing the field names between the parent and the connection, including the parent and the connection.</source>
          <target state="translated">&lt;code&gt;pathToConnection: Array&amp;lt;string&amp;gt;&lt;/code&gt; : una matriz que contiene los nombres de campo entre el padre y la conexi&amp;oacute;n, incluido el padre y la conexi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ca3a99f863b6d6006d89f122d91acd2466426ca1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pendingVariables&lt;/code&gt; contains the set of variables that are being used to fetch the new props, i.e. when &lt;code&gt;this.props.relay.setVariables()&lt;/code&gt; or &lt;code&gt;this.props.relay.forceFetch()&lt;/code&gt; are called and the corresponding request is in flight.</source>
          <target state="translated">&lt;code&gt;pendingVariables&lt;/code&gt; contiene el conjunto de variables que se est&amp;aacute;n utilizando para obtener los nuevos accesorios, es decir, cuando se &lt;code&gt;this.props.relay.setVariables()&lt;/code&gt; o &lt;code&gt;this.props.relay.forceFetch()&lt;/code&gt; y la solicitud correspondiente est&amp;aacute; en curso .</target>
        </trans-unit>
        <trans-unit id="5294d02523abdadc7890c4089fd2d771e0103adf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prepareVariables&lt;/code&gt; A method to modify the variables based on the runtime environment or previous variable values.</source>
          <target state="translated">&lt;code&gt;prepareVariables&lt;/code&gt; Un m&amp;eacute;todo para modificar las variables seg&amp;uacute;n el entorno de ejecuci&amp;oacute;n o los valores de las variables anteriores.</target>
        </trans-unit>
        <trans-unit id="27da47c52c7e5a8a5a90e5286ef17b4aff5e91dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;props&lt;/code&gt;: Object containing data obtained from the query; the shape of this object will match the shape of the query. If this object is not defined, it means that the data is still being fetched.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d5f419565d76e695cd1691d3b10750a870140ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;publish(source: RecordSource): void&lt;/code&gt;: Update the store with new information. All updates to the store are expressed in this form, including the results of queries/mutation/subscriptions as well as optimistic mutation updates. All of those operations internally create a new &lt;code&gt;RecordSource&lt;/code&gt; instance and ultimately publish it to the store. Note that &lt;code&gt;publish()&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; immediately update any &lt;code&gt;subscribe()&lt;/code&gt;-ers. Internally, the store compares the new &lt;code&gt;RecordSource&lt;/code&gt; with its internal source, updating it as necessary:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dddbd60d4182ffffea94bf3a02f0ae852dd10463" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;query&lt;/code&gt;: A &lt;code&gt;graphql&lt;/code&gt; tagged query to be used as the pagination query to fetch more data upon calling &lt;a href=&quot;#loadmore&quot;&gt;&lt;code&gt;loadMore&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7736ddcb416c3d04d04b11455e591b874d6eeb31" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;query&lt;/code&gt;: The &lt;code&gt;graphql&lt;/code&gt; tagged query. &lt;strong&gt;Note:&lt;/strong&gt;&lt;code&gt;relay-compiler&lt;/code&gt; enforces the query to be named as &lt;code&gt;&amp;lt;FileName&amp;gt;Query&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="676a2960bbec143afaff222f0801213498fb3f55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;query&lt;/code&gt;: The &lt;code&gt;graphql&lt;/code&gt; tagged query. &lt;strong&gt;Note:&lt;/strong&gt;&lt;code&gt;relay-compiler&lt;/code&gt; enforces the query to be named as &lt;code&gt;&amp;lt;FileName&amp;gt;Query&lt;/code&gt;. Optional, if not provided, an empty &lt;code&gt;props&lt;/code&gt; object is passed to the &lt;code&gt;render&lt;/code&gt; callback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85e836212ec7a6f4cf39b03986865be121a0bbd5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;queryConfig&lt;/code&gt; `QueryConfig` or `Relay.Route` that defines the query roots.</source>
          <target state="translated">&lt;code&gt;queryConfig&lt;/code&gt; `QueryConfig` o` Relay.Route` que define las ra&amp;iacute;ces de la consulta.</target>
        </trans-unit>
        <trans-unit id="660ec684b77a45a8bf1e84dae51a6cda4f520d7c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refetch&lt;/code&gt; has the following signature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58466669d85d4a95720a5f7d66d78440d31839cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refetch&lt;/code&gt; is a function available on the &lt;code&gt;relay&lt;/code&gt;&lt;a href=&quot;#available-props&quot;&gt;prop&lt;/a&gt; which can be used to execute the &lt;code&gt;refetchQuery&lt;/code&gt; and potentially re-render the component with the newly fetched data. Specifically, upon fetching the &lt;code&gt;refetchQuery&lt;/code&gt;, its result will be normalized into the store, and any relevant subscriptions associated with the changed records will be fired, causing relevant components to re-render.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac65c56250fa7ff709fdc7de7fca9f97dfd96bfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refetch&lt;/code&gt;: See &lt;code&gt;refetch&lt;/code&gt;&lt;a href=&quot;#refetch&quot;&gt;docs&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76ca6f4f7119df5fafa685e8fb3699107703e078" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refetchConnection&lt;/code&gt; is a function available on the &lt;code&gt;relay&lt;/code&gt;&lt;a href=&quot;#available-props&quot;&gt;prop&lt;/a&gt;. You can call &lt;code&gt;refetchConnection&lt;/code&gt; to restart pagination on a connection from scratch, with optionally a completely new set of variables to pass to the pagination &lt;code&gt;query&lt;/code&gt;. This is useful for example if you are paginating over a collection based on a userID and the userID changes, you'd want to start paginating over the new collection for the new user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ef81b21678260e29c69b60a2bcfd25a86847861" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refetchConnection&lt;/code&gt;: See &lt;code&gt;refetchConnection&lt;/code&gt;&lt;a href=&quot;#refetchconnection&quot;&gt;docs&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10676cecd666f761ab642682bd7775c74b16d502" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refetchQuery&lt;/code&gt;: A &lt;code&gt;graphql&lt;/code&gt; tagged query to be fetched upon calling &lt;a href=&quot;#refetch&quot;&gt;&lt;code&gt;props.relay.refetch&lt;/code&gt;&lt;/a&gt;. As with any query, upon fetching this query, its result will be normalized into the store, any relevant subscriptions associated with the changed records will be fired, and subscribed components will re-render.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32d83449d21fcdf971b3e1c1d76474fe6f62d3af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refetchVariables&lt;/code&gt; is either a bag of variables or a function that takes in the previous fragment variables and returns new variables.</source>
          <target state="translated">&lt;code&gt;refetchVariables&lt;/code&gt; es una bolsa de variables o una funci&amp;oacute;n que toma las variables de fragmentos anteriores y devuelve nuevas variables.</target>
        </trans-unit>
        <trans-unit id="d29742cf5cf442b9264eba2a1008fd847c52bb3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refetchVariables&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;refetchVariables&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="82c4436a668f413322c65f8837cdeba1c55ebf58" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refetchVariables&lt;/code&gt;: A potentially new bag of variables to pass to the pagination &lt;code&gt;query&lt;/code&gt; when fetching it from the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eccac01b26009021b9b8585de4682fa623cd62b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;relay&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;relay&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="4ae4f5a5447be2154beefea2867a35b518a781d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;render&lt;/code&gt; Called to render when data requirements are being fulfilled.</source>
          <target state="translated">&lt;code&gt;render&lt;/code&gt; Se llama para renderizar cuando se cumplen los requisitos de datos.</target>
        </trans-unit>
        <trans-unit id="3a3d4b8d0af15655fd443916c3671fd28e5c8260" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;render&lt;/code&gt;: Function of type &lt;code&gt;({error, props, retry}) =&amp;gt; React.Node&lt;/code&gt;. The output of this function will be rendered by the &lt;code&gt;QueryRenderer&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55e1260e99e337d383bed6b4b9c2df2228a1e749" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;renderFailure&lt;/code&gt; Called to render when data failed to be fulfilled.</source>
          <target state="translated">&lt;code&gt;renderFailure&lt;/code&gt; Llamado para renderizar cuando los datos no se cumplieron.</target>
        </trans-unit>
        <trans-unit id="a6131b3d70611a404b4ea7dd80f5758c5105f7c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;renderFetched&lt;/code&gt; Called to render when data requirements are fulfilled.</source>
          <target state="translated">&lt;code&gt;renderFetched&lt;/code&gt; Se llama para renderizar cuando se cumplen los requisitos de datos.</target>
        </trans-unit>
        <trans-unit id="1901f50529efd372e2c626214284f332709348a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;renderLoading&lt;/code&gt; Called to render when data requirements are being fulfilled.</source>
          <target state="translated">&lt;code&gt;renderLoading&lt;/code&gt; Se llama para renderizar cuando se cumplen los requisitos de datos.</target>
        </trans-unit>
        <trans-unit id="b0fe2435dec450eee6998923c41267267d40d7d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;renderVariables&lt;/code&gt; is an optional param that tells Relay which variables to use at when the component is re-rendered after fetching. Without this, the &lt;code&gt;refetchVariables&lt;/code&gt; will be used. You might use this for more advanced usage, for example, to implement pagination, where you would fetch an additional page with variables like &lt;code&gt;{first: 5, after: '...'}&lt;/code&gt;, but you would then render the full collection with &lt;code&gt;{first: 10}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;renderVariables&lt;/code&gt; es un par&amp;aacute;metro opcional que le dice a Relay qu&amp;eacute; variables usar cuando el componente se vuelve a renderizar despu&amp;eacute;s de obtenerlo. Sin esto, se utilizar&amp;aacute; &lt;code&gt;refetchVariables&lt;/code&gt; . Puede usar esto para un uso m&amp;aacute;s avanzado, por ejemplo, para implementar la paginaci&amp;oacute;n, donde buscar&amp;iacute;a una p&amp;aacute;gina adicional con variables como &lt;code&gt;{first: 5, after: '...'}&lt;/code&gt; , pero luego renderizar&amp;iacute;a la colecci&amp;oacute;n completa con &lt;code&gt;{first: 10}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d435346ad63d7a3c79570642e3436876c685e77c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;renderVariables&lt;/code&gt;: Optional bag of variables that indicate which variables to use for reading out the data from the store when re-rendering the component. Specifically, this indicates which variables to use when querying the data from the local data store &lt;em&gt;after&lt;/em&gt; the new query has been fetched. If not specified, the &lt;code&gt;refetchVariables&lt;/code&gt; will be used. This is useful when the data you need to render in your component doesn't necessarily match the data you queried the server for. For example, to implement pagination, you would fetch a page with variables like &lt;code&gt;{first: 5, after: '&amp;lt;cursor&amp;gt;'}&lt;/code&gt;, but you might want to render the full collection with &lt;code&gt;{first: 10}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8a7275c94b7363157c7bfb49920e6d9a95cf6ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;retain(selector: Selector): Disposable&lt;/code&gt;: Ensure that all the records necessary to fulfill the given selector are retained in-memory. The records will not be eligible for garbage collection until the returned reference is disposed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6d78182a7d6ce562110f2264694e37c53c96b2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;retry&lt;/code&gt;: Reload the data. It is null if &lt;code&gt;query&lt;/code&gt; was not provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cef4511de2692e7e2831022f07230dabf3496cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;route&lt;/code&gt; Route that defines the query roots.</source>
          <target state="translated">&lt;code&gt;route&lt;/code&gt; Ruta que define las ra&amp;iacute;ces de la consulta.</target>
        </trans-unit>
        <trans-unit id="de20a20a67577265acad0e1c8760490f6ae7d671" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setVariables&lt;/code&gt; does not immediately mutate &lt;code&gt;variables&lt;/code&gt;, but creates a pending state transition. &lt;code&gt;variables&lt;/code&gt; will continue returning the previous values until &lt;code&gt;this.props&lt;/code&gt; has been populated with data that fulfills the new variable values.</source>
          <target state="translated">&lt;code&gt;setVariables&lt;/code&gt; no muta &lt;code&gt;variables&lt;/code&gt; inmediatamente , sino que crea una transici&amp;oacute;n de estado pendiente. &lt;code&gt;variables&lt;/code&gt; continuar&amp;aacute;n devolviendo los valores anteriores hasta que &lt;code&gt;this.props&lt;/code&gt; se haya llenado con datos que cumplan con los nuevos valores de las variables.</target>
        </trans-unit>
        <trans-unit id="943d019e3b13e343df13a6484ab6136c7156b4e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shouldComponentUpdate&lt;/code&gt; Optionally override RelayContainer's default implementation of `shouldComponentUpdate`.</source>
          <target state="translated">&lt;code&gt;shouldComponentUpdate&lt;/code&gt; Opcionalmente anula la implementaci&amp;oacute;n predeterminada de RelayContainer de `shouldComponentUpdate`.</target>
        </trans-unit>
        <trans-unit id="c12be4a70a038cd4741cb2b9e30195491469abee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static Container: ReactPropTypeValidator&lt;/code&gt; A prop type validator asserting that a prop is a valid Relay container.</source>
          <target state="translated">&lt;code&gt;static Container: ReactPropTypeValidator&lt;/code&gt; Un validador de tipo de prop que afirma que un prop es un contenedor de retransmisi&amp;oacute;n v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="3b4467abcecc2f5f6147438c2f223473973407a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static QueryConfig: ReactPropTypeValidator&lt;/code&gt; A prop type validator asserting that a prop is a valid route.</source>
          <target state="translated">&lt;code&gt;static QueryConfig: ReactPropTypeValidator&lt;/code&gt; Un validador de tipo prop que afirma que un prop es una ruta v&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="40e983f1da84aaeb0774f71c8242e17b35be1f2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static applyUpdate(mutation, callbacks)&lt;/code&gt; Adds a MutationTransaction to the queue without committing it.</source>
          <target state="translated">&lt;code&gt;static applyUpdate(mutation, callbacks)&lt;/code&gt; Agrega una MutationTransaction a la cola sin confirmarla.</target>
        </trans-unit>
        <trans-unit id="b4d03961b864a4ab573535d598407abfc411cce4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static commitUpdate(mutation, callbacks)&lt;/code&gt; Initiate processing of a mutation.</source>
          <target state="translated">&lt;code&gt;static commitUpdate(mutation, callbacks)&lt;/code&gt; Iniciar el procesamiento de una mutaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9eebf1a07ed283d2bbed2b968ffb38df36fad9ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static create(mutation, variables, environment)&lt;/code&gt; Create a static mutation</source>
          <target state="translated">&lt;code&gt;static create(mutation, variables, environment)&lt;/code&gt; Crea una mutaci&amp;oacute;n est&amp;aacute;tica</target>
        </trans-unit>
        <trans-unit id="658d18c4b39964f6d9e02a8d4f13d6ca5179a919" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static createContainer(Component, ContainerConfig)&lt;/code&gt; Creates a Relay Container.</source>
          <target state="translated">&lt;code&gt;static createContainer(Component, ContainerConfig)&lt;/code&gt; Crea un contenedor de retransmisiones.</target>
        </trans-unit>
        <trans-unit id="ac50a770322cba5b662ec0bbf60235d57453db96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static createWithFiles(mutation, variables, files, environment)&lt;/code&gt; Create a static mutation that accepts a &quot;files&quot; object</source>
          <target state="translated">&lt;code&gt;static createWithFiles(mutation, variables, files, environment)&lt;/code&gt; Crea una mutaci&amp;oacute;n est&amp;aacute;tica que acepta un objeto &quot;archivos&quot;</target>
        </trans-unit>
        <trans-unit id="a985a4f33765191da82de5eb97d6c665b299a3b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static fragments&lt;/code&gt; Declare this mutation's data dependencies here</source>
          <target state="translated">&lt;code&gt;static fragments&lt;/code&gt; Declare aqu&amp;iacute; las dependencias de datos de esta mutaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="a1697fb2f2da73763242483e979b5b34e6797e53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static initialVariables&lt;/code&gt; A default set of variables to make available to this mutation's fragment builders</source>
          <target state="translated">&lt;code&gt;static initialVariables&lt;/code&gt; Un conjunto predeterminado de variables para poner a disposici&amp;oacute;n de los constructores de fragmentos de esta mutaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="9ac61312fa144b893336d3bbdf88826d0034494e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static injectNetworkLayer(networkLayer)&lt;/code&gt; Customize how queries and mutations are sent to the server.</source>
          <target state="translated">&lt;code&gt;static injectNetworkLayer(networkLayer)&lt;/code&gt; Personalice c&amp;oacute;mo se env&amp;iacute;an las consultas y mutaciones al servidor.</target>
        </trans-unit>
        <trans-unit id="49b31e2fd0ee618819eb9668ad9fab057dc448c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static injectTaskScheduler(scheduler)&lt;/code&gt; Configure when Relay processing occurs.</source>
          <target state="translated">&lt;code&gt;static injectTaskScheduler(scheduler)&lt;/code&gt; Configure cu&amp;aacute;ndo se produce el procesamiento de retransmisi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="3e8afe33d507124df2cb20b712a24c4d395ceeb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static isContainer(Component)&lt;/code&gt; Determine if a given object is a Relay.Container.</source>
          <target state="translated">&lt;code&gt;static isContainer(Component)&lt;/code&gt; Determina si un objeto dado es un Relay.Container.</target>
        </trans-unit>
        <trans-unit id="7938dae1f9d2455348151916c16933ea1c4109f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static paramDefinitions&lt;/code&gt; Declare the expected parameters.</source>
          <target state="translated">&lt;code&gt;static paramDefinitions&lt;/code&gt; Declara los par&amp;aacute;metros esperados.</target>
        </trans-unit>
        <trans-unit id="047db3ec3d910088d59dd144e9064188d5d64b54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static prepareParams&lt;/code&gt; Declare additional parameters or conversion for parameters.</source>
          <target state="translated">&lt;code&gt;static prepareParams&lt;/code&gt; Declara par&amp;aacute;metros adicionales o conversi&amp;oacute;n de par&amp;aacute;metros.</target>
        </trans-unit>
        <trans-unit id="4b2b9762a4218dc52cee63114d0eee0ed5d04c5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static prepareVariables&lt;/code&gt; A method to modify the variables based on the runtime environment, previous variables, or the meta route</source>
          <target state="translated">&lt;code&gt;static prepareVariables&lt;/code&gt; Un m&amp;eacute;todo para modificar las variables seg&amp;uacute;n el entorno de ejecuci&amp;oacute;n, las variables anteriores o la meta ruta</target>
        </trans-unit>
        <trans-unit id="2b49e3d2f4dae0d69deb0f6c24085a44cc8a3c5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static queries&lt;/code&gt; Declare the set of query roots.</source>
          <target state="translated">&lt;code&gt;static queries&lt;/code&gt; Declaran el conjunto de ra&amp;iacute;ces de consultas.</target>
        </trans-unit>
        <trans-unit id="0c43ab95deb00b1e6ba46964ae86ac05d717b874" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static routeName&lt;/code&gt; Declare the name of this route class.</source>
          <target state="translated">&lt;code&gt;static routeName&lt;/code&gt; Declare el nombre de esta clase de ruta.</target>
        </trans-unit>
        <trans-unit id="4d2883724190fe655277a940ee21fbf4028c5557" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subscribe(snapshot: Snapshot, callback: (snapshot: Snapshot) =&amp;gt; void): Disposable&lt;/code&gt;: Subscribe to changes to the results of a selector. The callback is called when data has been published to the store that would cause the results of the snapshot's selector to change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91acf728df7357ed2ba9977f2e4aae1aa271198d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subscription&lt;/code&gt;: the &lt;code&gt;graphql&lt;/code&gt; tagged subscription query.</source>
          <target state="translated">&lt;code&gt;subscription&lt;/code&gt; : la consulta de suscripci&amp;oacute;n etiquetada por &lt;code&gt;graphql&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12ff8bacf233237929ba38ec484648a655ad7959" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.props.relay.setVariables&lt;/code&gt; can be called to update a subset or all of the variables at the same time. In return, Relay will use the new variables to attempt to fulfill the new fragment. This may involve sending a request to the server if data is not already available on the client.</source>
          <target state="translated">&lt;code&gt;this.props.relay.setVariables&lt;/code&gt; se puede llamar para actualizar un subconjunto o todas las variables al mismo tiempo. A cambio, Relay utilizar&amp;aacute; las nuevas variables para intentar completar el nuevo fragmento. Esto puede implicar enviar una solicitud al servidor si los datos a&amp;uacute;n no est&amp;aacute;n disponibles en el cliente.</target>
        </trans-unit>
        <trans-unit id="c005f6461f75206bcbc927906f1de20a4cf2e450" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.props.relay&lt;/code&gt; exports the following API to execute the refetch query:</source>
          <target state="translated">&lt;code&gt;this.props.relay&lt;/code&gt; exporta la siguiente API para ejecutar la consulta de recuperaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="7d9577972a7c4a8c614b22a037eaeff82248e3f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.props.relay&lt;/code&gt; exposes the following APIs:</source>
          <target state="translated">&lt;code&gt;this.props.relay&lt;/code&gt; expone las siguientes API:</target>
        </trans-unit>
        <trans-unit id="3d07b37e84a778ceb1461d9bbc1f056984d50a27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.props.setVariables&lt;/code&gt; from the old API does not have a direct equivalent in the new API. A big reason for this change is that the new core no longer tracks how to refetch any specific sub-tree from the query. This makes the new core a lot faster, but requires explicit queries for how to fetch new data. Check out these four different scenarios:</source>
          <target state="translated">&lt;code&gt;this.props.setVariables&lt;/code&gt; de la antigua API no tiene un equivalente directo en la nueva API. Una gran raz&amp;oacute;n para este cambio es que el nuevo n&amp;uacute;cleo ya no rastrea c&amp;oacute;mo recuperar ning&amp;uacute;n sub&amp;aacute;rbol espec&amp;iacute;fico de la consulta. Esto hace que el nuevo n&amp;uacute;cleo sea mucho m&amp;aacute;s r&amp;aacute;pido, pero requiere consultas expl&amp;iacute;citas sobre c&amp;oacute;mo obtener nuevos datos. Vea estos cuatro escenarios diferentes:</target>
        </trans-unit>
        <trans-unit id="63392efb72105686affa5267c72c15150a57d7b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;totalCount&lt;/code&gt;: The total number of elements to fetch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3ba6c9e4640fb1b2e64f085573522ecee404aff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;updater&lt;/code&gt; and &lt;code&gt;optimisticUpdater&lt;/code&gt; are functions that you can pass to a &lt;code&gt;commitMutation&lt;/code&gt; call when you need full control over how to update the local data store, either optimistically, or based on a server response. Often times, both of these can be the same function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="259e28d5505528a6b53e6871c75fe6204e8b732e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;updater&lt;/code&gt;: Function used to update the local in-memory store based on the &lt;strong&gt;real&lt;/strong&gt; server response from the mutation. If &lt;code&gt;updater&lt;/code&gt; is not provided, by default, Relay will know to automatically update the fields on the records referenced in the mutation response; however, you should pass an &lt;code&gt;updater&lt;/code&gt; if you need to make more complicated updates than just updating fields (e.g. deleting records or adding items to collections). When the server response comes back, Relay first reverts any changes introduced by &lt;code&gt;optimisticUpdater&lt;/code&gt; or &lt;code&gt;optimisticResponse&lt;/code&gt; and will then execute &lt;code&gt;updater&lt;/code&gt;. This function takes a &lt;code&gt;store&lt;/code&gt;, which is a proxy of the in-memory &lt;a href=&quot;relay-store&quot;&gt;Relay Store&lt;/a&gt;. In this function, the client defines 'how to' update the local data based on the server response via the &lt;code&gt;store&lt;/code&gt; instance. For details on how to use the &lt;code&gt;store&lt;/code&gt;, please refer to our &lt;a href=&quot;relay-store&quot;&gt;Relay Store API Reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25ab1a5db284767b82e6bbe83b1d6bb7782d76cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;updater&lt;/code&gt;: a function that updates the in-memory Relay store based on the &lt;strong&gt;real&lt;/strong&gt; server response. When the server response comes back, Relay first reverts any changes introduced by &lt;code&gt;optimisticUpdater&lt;/code&gt; or &lt;code&gt;optimisticResponse&lt;/code&gt; and then applies the &lt;code&gt;updater&lt;/code&gt; to the store.</source>
          <target state="translated">&lt;code&gt;updater&lt;/code&gt; : una funci&amp;oacute;n que actualiza el almac&amp;eacute;n de rel&amp;eacute;s en memoria en funci&amp;oacute;n de la respuesta del servidor &lt;strong&gt;real&lt;/strong&gt; . Cuando vuelve la respuesta del servidor, Relay primero revierte cualquier cambio introducido por &lt;code&gt;optimisticUpdater&lt;/code&gt; o &lt;code&gt;optimisticResponse&lt;/code&gt; y luego aplica el &lt;code&gt;updater&lt;/code&gt; a la tienda.</target>
        </trans-unit>
        <trans-unit id="9e752995a456f07b23c9c5955036c90c0eaa7d48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;updater&lt;/code&gt;: an optional function that can supply custom logic for updating the in-memory Relay store based on the server response.</source>
          <target state="translated">&lt;code&gt;updater&lt;/code&gt; : una funci&amp;oacute;n opcional que puede proporcionar l&amp;oacute;gica personalizada para actualizar el almac&amp;eacute;n de rel&amp;eacute;s en memoria seg&amp;uacute;n la respuesta del servidor.</target>
        </trans-unit>
        <trans-unit id="ed67a9853586c7a825bf549e62d6668d890318cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;variables&lt;/code&gt; contains the set of variables that was used to fetch the current set of props.</source>
          <target state="translated">&lt;code&gt;variables&lt;/code&gt; contiene el conjunto de variables que se utiliz&amp;oacute; para recuperar el conjunto actual de accesorios.</target>
        </trans-unit>
        <trans-unit id="90132fff5a43a587dfddbf62f547768d85225cbc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;variables&lt;/code&gt;: Object containing set of variables to pass to the GraphQL query, i.e. a mapping from variable name to value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b2d4dca964b4002488e5ba0931c7fdd0e1843a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;variables&lt;/code&gt;: Object containing set of variables to pass to the GraphQL query, i.e. a mapping from variable name to value. &lt;strong&gt;Note:&lt;/strong&gt; If a new set of variables is passed, the &lt;code&gt;QueryRenderer&lt;/code&gt; will re-fetch the query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0475335b0b11da8a5bdf97828dbf873aa0e03035" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;variables&lt;/code&gt;: Object containing the variables needed for the mutation. For example, if the mutation defines an &lt;code&gt;$input&lt;/code&gt; variable, this object should contain an &lt;code&gt;input&lt;/code&gt; key, whose shape must match the shape of the data expected by the mutation as defined by the GraphQL schema.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e388933696fbe367df975da86d5ab73799cb8d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;variables&lt;/code&gt;: an object that contains the variables needed for the mutation.</source>
          <target state="translated">&lt;code&gt;variables&lt;/code&gt; : un objeto que contiene las variables necesarias para la mutaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6e219c17510eb13b16577519ca778d9468c7499a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;variables&lt;/code&gt;: an object that contains the variables needed for the subscription.</source>
          <target state="translated">&lt;code&gt;variables&lt;/code&gt; : un objeto que contiene las variables necesarias para la suscripci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a3d9fd11099be9837becddb07ecac412bfe16922" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;code&gt;babel-relay-plugin&lt;/code&gt; is deprecated. Use &lt;a href=&quot;babel-plugin-relay#using-with-relay-classic&quot;&gt;&lt;code&gt;babel-plugin-relay&lt;/code&gt;&lt;/a&gt; with Relay Classic.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;babel-relay-plugin&lt;/code&gt; est&amp;aacute; en desuso. Utilice &lt;a href=&quot;babel-plugin-relay#using-with-relay-classic&quot;&gt; &lt;code&gt;babel-plugin-relay&lt;/code&gt; &lt;/a&gt; con Relay Classic.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="885b12f18c1ce790e1ceb37bdac14666bf969046" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Container Specification&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Especificaci&amp;oacute;n del contenedor&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2dc48bdb0f1a664344b42c6cc9f80bf54c93c0af" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Methods&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Methods&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="372322cdb4339a090833f173c5459433d9f3a2a3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Properties and Methods&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Propiedades y m&amp;eacute;todos&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2e24a7da3b4c78d1c9bb8ad4a5672d259fcf1c7d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Properties&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Properties&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b288f7cf5165d63b23f3a477f7c62696473947e3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Props&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Props&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c13abeef99d46d6cc5a5891d80bde92ef26cfbac" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Static Methods&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;M&amp;eacute;todos est&amp;aacute;ticos&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f0677ff5e5e4c313a098291e00353714c69a25eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/graphcool/graphql-up&quot;&gt;graphql-up&lt;/a&gt;&lt;/strong&gt; on &lt;a href=&quot;https://www.npmjs.com/package/graphql-up&quot;&gt;npm&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/graphcool/graphql-up&quot;&gt;graphql-up&lt;/a&gt;&lt;/strong&gt; en&lt;a href=&quot;https://www.npmjs.com/package/graphql-up&quot;&gt; npm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1a854faa5d5c2fb2a3f2a62f519c3dae0ea44c47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/express-graphql&quot;&gt;express-graphql&lt;/a&gt;&lt;/strong&gt; on &lt;a href=&quot;https://www.npmjs.com/package/express-graphql&quot;&gt;npm&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/express-graphql&quot;&gt;express-graphql&lt;/a&gt;&lt;/strong&gt; en&lt;a href=&quot;https://www.npmjs.com/package/express-graphql&quot;&gt; npm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6882e7b1150b43a134cd9463ab13037397e9d8a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;graphql-js&lt;/a&gt;&lt;/strong&gt; on &lt;a href=&quot;https://www.npmjs.com/package/graphql&quot;&gt;npm&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;graphql-js&lt;/a&gt;&lt;/strong&gt; en&lt;a href=&quot;https://www.npmjs.com/package/graphql&quot;&gt; npm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4615a7abdf175713f1dd713a45e9b36b49db0dd8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/graphql-relay-js&quot;&gt;graphql-relay-js&lt;/a&gt;&lt;/strong&gt; on &lt;a href=&quot;https://www.npmjs.com/package/graphql-relay&quot;&gt;npm&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/graphql-relay-js&quot;&gt;graphql-relay-js&lt;/a&gt;&lt;/strong&gt; en&lt;a href=&quot;https://www.npmjs.com/package/graphql-relay&quot;&gt; npm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0cf00569ac1dc01caeaaea97e38c45c13b4f2663" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/relay-tools/react-relay-network-modern&quot;&gt;react-relay-network-modern&lt;/a&gt;&lt;/strong&gt; on &lt;a href=&quot;https://www.npmjs.com/package/react-relay-network-modern&quot;&gt;npm&lt;/a&gt; - is a Network Layer for Relay Modern which has built-in highly customizable middlewares for commonly used scenarios: batching query requests, caching, authentication, request retrying, logging. Moreover, you may write your own middlewares with custom logic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57698c2dcaa9317f5b6564784890d536ca0db31a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://www.graph.cool/&quot;&gt;Graphcool&lt;/a&gt;&lt;/strong&gt; (&lt;a href=&quot;https://www.graph.cool/docs/quickstart/&quot;&gt;Quickstart tutorial&lt;/a&gt;)</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://www.graph.cool/&quot;&gt;Graphcool&lt;/a&gt;&lt;/strong&gt; (&lt;a href=&quot;https://www.graph.cool/docs/quickstart/&quot;&gt; tutorial de &lt;/a&gt;&lt;strong&gt;inicio&lt;/strong&gt; r&amp;aacute;pido )</target>
        </trans-unit>
        <trans-unit id="3ff63fe8231293f18f4614046a48a3f375957330" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; An optimistic update may only be applied once.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; una actualizaci&amp;oacute;n optimista solo se puede aplicar una vez.</target>
        </trans-unit>
        <trans-unit id="5a6c17b257e2cfbdb037b374e043ded0a3a0687b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Equivalent &lt;code&gt;applyUpdate&lt;/code&gt; and &lt;code&gt;commitUpdate&lt;/code&gt; methods are also provided on the &lt;code&gt;this.props.relay&lt;/code&gt; prop that is passed to components by &lt;code&gt;Relay.Container&lt;/code&gt;. These dispatch mutations in the context of the currently active &lt;code&gt;Relay.Environment&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; Equivalente &lt;code&gt;applyUpdate&lt;/code&gt; y &lt;code&gt;commitUpdate&lt;/code&gt; m&amp;eacute;todos tambi&amp;eacute;n se proporcionan en el &lt;code&gt;this.props.relay&lt;/code&gt; prop que se pasa a los componentes por &lt;code&gt;Relay.Container&lt;/code&gt; . Estas mutaciones de env&amp;iacute;o en el contexto del &lt;code&gt;Relay.Environment&lt;/code&gt; actualmente activo .</target>
        </trans-unit>
        <trans-unit id="9ddd68157613fe72f3a31d973424adc5689fd03d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The relay-compiler will maintain any directives supported by your server (such as &lt;code&gt;@include&lt;/code&gt; or &lt;code&gt;@skip&lt;/code&gt;) so they remain part of the request to the GraphQL server and won't alter generated runtime artifacts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9339553ac0cb3d1045417a0b2b8896e539d03c5a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;code&gt;refetch&lt;/code&gt; is meant to be used for changing variables in the component's fragment. Specifically, in order for &lt;em&gt;this&lt;/em&gt; component to re-render, it must be subscribed to changes in the records affected by this query. If the fragment for the component doesn't use variables, the component won't be subscribed to changes to new records that might be fetched by this query. A common example of this is using &lt;code&gt;refetch&lt;/code&gt; to fetch a new node and re-render the component with the data for the new node; in this case the fragment needs to use a variable for the node's id, otherwise the component won't pick up the changes for the new node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fce6daad416ee7ed28c950cdb80e05140a6ea38d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;code&gt;relay-compiler&lt;/code&gt; enforces fragments to be named as &lt;code&gt;&amp;lt;FileName&amp;gt;_&amp;lt;propName&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cab013d8e57c0158f4b400d4d762529e18b3a5a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: this will not remove it from any connection it might be in. If you want to remove a node from a connection, take a look at &lt;a href=&quot;#RANGE_DELETE&quot;&gt;RANGE_DELETE&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0b283c8b5fe80a6754d48027d166c1b33cf5b5d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;React/Relay:&lt;/strong&gt; A high-level &lt;em&gt;product API&lt;/em&gt; that integrates the Relay Runtime with React. This is the primary public interface to Relay for most product developers, featuring APIs to fetch the data for a query or define data dependencies for reusable components (aka containers).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efdd8302b44cc971aea46ff3458176ce0281a174" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay Compiler:&lt;/strong&gt; A GraphQL to GraphQL optimizing &lt;em&gt;compiler&lt;/em&gt;, providing general utilities for transforming and optimizing queries as well as generating build artifacts. A novel feature of the compiler is that it facilitates experimentation with new GraphQL features - in the form of custom directives - by making it easy to translate code using these directives into standard, spec-compliant GraphQL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4b7a80e6d04a3ccce4e25ffec6090751cc2e7f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay Runtime:&lt;/strong&gt; A full-featured, high-performance GraphQL &lt;em&gt;runtime&lt;/em&gt; that can be used to build higher-level client APIs. The runtime features a normalized object cache, optimized &quot;write&quot; and &quot;read&quot; operations, a generic abstraction for incrementally fetching field data (such as for pagination), garbage collection for removing unreferenced cache entries, optimistic mutations with arbitrary logic, support for building subscriptions and live queries, and more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d08f9d41d143a0795971f924c815549c54cd145" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.Container&lt;/strong&gt; lets components declare fragments.</source>
          <target state="translated">&lt;strong&gt;Relay.Container&lt;/strong&gt; permite que los componentes declaren fragmentos.</target>
        </trans-unit>
        <trans-unit id="90f9832c4e0fd7965e487450fd253cb3d30e8335" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.Renderer&lt;/strong&gt; is a replacement for &lt;code&gt;Relay.RootContainer&lt;/code&gt; that composes a &lt;code&gt;Relay.ReadyStateRenderer&lt;/code&gt; and performs data fetching for a given &lt;code&gt;queryConfig&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Relay.Renderer&lt;/strong&gt; es un reemplazo de &lt;code&gt;Relay.RootContainer&lt;/code&gt; que compone un &lt;code&gt;Relay.ReadyStateRenderer&lt;/code&gt; y realiza la b&amp;uacute;squeda de datos para una &lt;code&gt;queryConfig&lt;/code&gt; determinada .</target>
        </trans-unit>
        <trans-unit id="4e196f3c49ca550a94a96a6bd405ee5ae569ab33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; accepts three optional callbacks as props that give us more fine-grained control over the render behavior.</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; acepta tres devoluciones de llamada opcionales como accesorios que nos brindan un control m&amp;aacute;s detallado sobre el comportamiento de renderizado.</target>
        </trans-unit>
        <trans-unit id="39c403bfc5a5ae739fbb717b4e88e8b5cb484d46" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; also supports the &lt;code&gt;onReadyStateChange&lt;/code&gt; prop which lets us receive fine-grained events as they occur while fulfilling the data requirements.</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; tambi&amp;eacute;n admite la funci&amp;oacute;n &lt;code&gt;onReadyStateChange&lt;/code&gt; que nos permite recibir eventos detallados a medida que ocurren mientras se cumplen los requisitos de datos.</target>
        </trans-unit>
        <trans-unit id="3d6f9d2435421026549fceef7e0844d153a49bfa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; is a React component that attempts to fulfill the data required in order to render an instance of &lt;code&gt;Component&lt;/code&gt; for a given &lt;code&gt;route&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; es un componente de React que intenta cumplir con los datos necesarios para representar una instancia de &lt;code&gt;Component&lt;/code&gt; para una &lt;code&gt;route&lt;/code&gt; determinada .</target>
        </trans-unit>
        <trans-unit id="a2469cd762b58409f3e67b96bf307621bbbfad9c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; is a React component that, given a &lt;code&gt;Component&lt;/code&gt; and a &lt;code&gt;route&lt;/code&gt;, attempts to fulfill the data required in order to render an instance of &lt;code&gt;Component&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; es un componente de React que, dado un &lt;code&gt;Component&lt;/code&gt; e y una &lt;code&gt;route&lt;/code&gt; , intenta cumplir con los datos requeridos para representar una instancia de &lt;code&gt;Component&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3a1abc25b49b43dce645669aa17f103661474d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; renders the loading state whenever it cannot immediately fulfill data needed to render. This often happens on the initial render, but it can also happen if either &lt;code&gt;Component&lt;/code&gt; or &lt;code&gt;route&lt;/code&gt; changes.</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; representa el estado de carga siempre que no pueda cumplir inmediatamente con los datos necesarios para procesar. Esto sucede a menudo en el renderizado inicial, pero tambi&amp;eacute;n puede suceder si el &lt;code&gt;Component&lt;/code&gt; o la &lt;code&gt;route&lt;/code&gt; cambian.</target>
        </trans-unit>
        <trans-unit id="81df685053c0d0bd1d2397325ab50c0f55f7ca06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.Route&lt;/strong&gt; lets us declare query roots.</source>
          <target state="translated">&lt;strong&gt;Relay.Route&lt;/strong&gt; nos permite declarar las ra&amp;iacute;ces de la consulta.</target>
        </trans-unit>
        <trans-unit id="c9948e83f56c83dcc4c3f5e36e015ebfe88bc455" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;QueryRenderer&lt;/code&gt; is a React Component at the root of a Relay component tree. It takes a query, fetches the given query, and uses the &lt;code&gt;render&lt;/code&gt; prop to render the resulting data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d333726339af1440c557b36d8dd062e5747d248a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;QueryRenderer&lt;/code&gt; is a React component, so it can be rendered anywhere that a React component can be rendered, not just at the top level. A &lt;code&gt;QueryRenderer&lt;/code&gt; can be rendered &lt;em&gt;within&lt;/em&gt; other Relay components, for example to lazily fetch additional data for a popover. However, a &lt;code&gt;QueryRenderer&lt;/code&gt; will not start loading its data until it is mounted, so nested &lt;code&gt;QueryRenderer&lt;/code&gt; components can lead to avoidable request waterfalls if used unnecessarily.</source>
          <target state="translated">Un &lt;code&gt;QueryRenderer&lt;/code&gt; es un componente de React, por lo que puede renderizarse en cualquier lugar donde se pueda renderizar un componente de React, no solo en el nivel superior. Un &lt;code&gt;QueryRenderer&lt;/code&gt; se puede representar &lt;em&gt;dentro de&lt;/em&gt; otros componentes de Relay, por ejemplo, para obtener datos adicionales de forma perezosa para un popover. Sin embargo, un &lt;code&gt;QueryRenderer&lt;/code&gt; no comenzar&amp;aacute; a cargar sus datos hasta que est&amp;eacute; montado, por &lt;code&gt;QueryRenderer&lt;/code&gt; componentes de QueryRenderer anidados pueden generar cascadas de solicitudes evitables si se usan innecesariamente.</target>
        </trans-unit>
        <trans-unit id="27c70649f28d5c13e5a545686407c1d433b45c24" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;REQUIRED_CHILDREN&lt;/code&gt; config is used to append additional children to the mutation query. You may need to use this, for example, to fetch fields on a new object created by the mutation (and which Relay would normally not attempt to fetch because it has not previously fetched anything for that object).</source>
          <target state="translated">Se usa una configuraci&amp;oacute;n &lt;code&gt;REQUIRED_CHILDREN&lt;/code&gt; para agregar hijos adicionales a la consulta de mutaci&amp;oacute;n. Es posible que deba usar esto, por ejemplo, para recuperar campos en un nuevo objeto creado por la mutaci&amp;oacute;n (y que Relay normalmente no intentar&amp;iacute;a recuperar porque no ha obtenido previamente nada para ese objeto).</target>
        </trans-unit>
        <trans-unit id="b0405a3f3745cc21b6e57c41715133d0cedd35b4" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;RefetchContainer&lt;/code&gt; first renders like a regular &lt;a href=&quot;fragment-container&quot;&gt;&lt;code&gt;FragmentContainer&lt;/code&gt;&lt;/a&gt;, but has the option to execute a new query with different variables and render the response of that query instead when the request comes back.</source>
          <target state="translated">Un &lt;code&gt;RefetchContainer&lt;/code&gt; primero se procesa como un &lt;a href=&quot;fragment-container&quot;&gt; &lt;code&gt;FragmentContainer&lt;/code&gt; &lt;/a&gt; normal , pero tiene la opci&amp;oacute;n de ejecutar una nueva consulta con diferentes variables y generar la respuesta de esa consulta cuando la solicitud regresa.</target>
        </trans-unit>
        <trans-unit id="0b6b1500d0098058dc174f969740040bdd6fdf14" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;renderLoading&lt;/code&gt; callback can simulate the default behavior by returning &lt;code&gt;undefined&lt;/code&gt;. Notice that this is different from a &lt;code&gt;renderLoading&lt;/code&gt; callback that returns &lt;code&gt;null&lt;/code&gt;, which would render nothing whenever data is loading, even if there was a previous view rendered.</source>
          <target state="translated">Una &lt;code&gt;renderLoading&lt;/code&gt; llamada renderLoading puede simular el comportamiento predeterminado devolviendo &lt;code&gt;undefined&lt;/code&gt; . Tenga en cuenta que esto es diferente de una &lt;code&gt;renderLoading&lt;/code&gt; llamada renderLoading que devuelve un &lt;code&gt;null&lt;/code&gt; , que no representar&amp;iacute;a nada siempre que se carguen datos, incluso si hubo una vista anterior representada.</target>
        </trans-unit>
        <trans-unit id="59bd5b6c5b1f4d50bad57e4bae0c86bf7e63ff03" translate="yes" xml:space="preserve">
          <source>A Complete Example</source>
          <target state="translated">Un ejemplo completo</target>
        </trans-unit>
        <trans-unit id="961bc4600b75e68461ede605310ceced00dd4863" translate="yes" xml:space="preserve">
          <source>A Fragment Container is a &lt;a href=&quot;https://reactjs.org/docs/higher-order-components.html&quot;&gt;higher-order component&lt;/a&gt; that allows components to specify their data requirements. A container does not directly fetch data, but instead declares a &lt;em&gt;specification&lt;/em&gt; of the data needed for rendering, and then Relay will guarantee that this data is available &lt;em&gt;before&lt;/em&gt; rendering occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="584bb673c7430dcef36b698acb079dd72be2262f" translate="yes" xml:space="preserve">
          <source>A GraphQL Schema</source>
          <target state="translated">Un esquema GraphQL</target>
        </trans-unit>
        <trans-unit id="b1a1d3fc840a0a6e5e8ca2b278d7769c45a98c33" translate="yes" xml:space="preserve">
          <source>A GraphQL Server</source>
          <target state="translated">Un servidor GraphQL</target>
        </trans-unit>
        <trans-unit id="a7ee882612fb64b227df291f19a923de85574e53" translate="yes" xml:space="preserve">
          <source>A GraphQL schema describes your data model, and provides a GraphQL server with an associated set of resolve methods that know how to fetch data. We will use &lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;graphql-js&lt;/a&gt; and &lt;a href=&quot;https://github.com/graphql/graphql-relay-js&quot;&gt;graphql-relay-js&lt;/a&gt; to build our schema.</source>
          <target state="translated">Un esquema GraphQL describe su modelo de datos y proporciona un servidor GraphQL con un conjunto asociado de m&amp;eacute;todos de resoluci&amp;oacute;n que saben c&amp;oacute;mo obtener datos. Usaremos &lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;graphql-js&lt;/a&gt; y &lt;a href=&quot;https://github.com/graphql/graphql-relay-js&quot;&gt;graphql-relay-js&lt;/a&gt; para construir nuestro esquema.</target>
        </trans-unit>
        <trans-unit id="48b78b689c15abba06f0159436cde03009fad264" translate="yes" xml:space="preserve">
          <source>A Refetch Container is also a &lt;a href=&quot;https://reactjs.org/docs/higher-order-components.html&quot;&gt;higher-order component&lt;/a&gt; that works like a regular &lt;a href=&quot;fragment-container&quot;&gt;Fragment Container&lt;/a&gt;, but provides the additional ability to fetch a new GraphQL query with different variables and re-render the component with the new result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc6cdf397779ac0008665fa5d7d262a02b419170" translate="yes" xml:space="preserve">
          <source>A bag of variables to pass to the &lt;code&gt;refetchQuery&lt;/code&gt; when fetching it from the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f6d86fdd10ea1168eecc22cdc48b9e22a21ad2d" translate="yes" xml:space="preserve">
          <source>A complete example</source>
          <target state="translated">Un ejemplo completo</target>
        </trans-unit>
        <trans-unit id="1b0ee223956194b51488ec093f18ce49cf32ed77" translate="yes" xml:space="preserve">
          <source>A description of how to page through connections.</source>
          <target state="translated">Una descripción de cómo buscar a través de las conexiones.</target>
        </trans-unit>
        <trans-unit id="97b03c635c48a56b721c11e955de7b0b12f2ab52" translate="yes" xml:space="preserve">
          <source>A description of your data model with an associated set of resolve methods that know how to fetch any data your application could ever need.</source>
          <target state="translated">Una descripción de su modelo de datos con un conjunto asociado de métodos de resolución que saben cómo obtener cualquier dato que su aplicación pueda necesitar.</target>
        </trans-unit>
        <trans-unit id="cab997b4cd24ec902e4b83aaf3bf43dce9ec7836" translate="yes" xml:space="preserve">
          <source>A faction has many ships in the Star Wars universe. Relay contains functionality to make manipulating one-to-many relationships easy, using a standardized way of expressing these one-to-many relationships. This standard connection model offers ways of slicing and paginating through the connection.</source>
          <target state="translated">Una facción tiene muchas naves en el universo de Star Wars.El relé contiene una funcionalidad para facilitar la manipulación de las relaciones de uno a muchos,usando una forma estandarizada de expresar estas relaciones de uno a muchos.Este modelo de conexión estándar ofrece formas de cortar y paginar a través de la conexión.</target>
        </trans-unit>
        <trans-unit id="af85210772abecb804d78217a7325698b05fe83e" translate="yes" xml:space="preserve">
          <source>A generic mechanism for intercepting data prior to publishing it to the cache and either synthesizing new data or merging new and existing data together (which among other things enables the creation of a variety of pagination schemes).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac6dbe38242ad9f607665dc6e4fa2db4283cdd16" translate="yes" xml:space="preserve">
          <source>A map between a &lt;code&gt;fieldName&lt;/code&gt; in the response and one or more DataIDs in the store.</source>
          <target state="translated">Un mapa entre un &lt;code&gt;fieldName&lt;/code&gt; en la respuesta y uno o m&amp;aacute;s DataID en la tienda.</target>
        </trans-unit>
        <trans-unit id="6d94fea08321dcd17e29b42a404746fc50da107f" translate="yes" xml:space="preserve">
          <source>A map between printed, dot-separated GraphQL calls &lt;em&gt;in alphabetical order&lt;/em&gt; and the behavior we want Relay to exhibit when adding the new edge to connections under the influence of those calls or a function accepting an array of connection arguments, returning that behavior.</source>
          <target state="translated">Un mapa entre las llamadas GraphQL impresas y separadas por puntos &lt;em&gt;en orden alfab&amp;eacute;tico&lt;/em&gt; y el comportamiento que queremos que muestre Relay al agregar el nuevo borde a las conexiones bajo la influencia de esas llamadas o una funci&amp;oacute;n que acepta una matriz de argumentos de conexi&amp;oacute;n, devolviendo ese comportamiento.</target>
        </trans-unit>
        <trans-unit id="df6534fbc976a915dd2ab9e7fdb121c13f0a1f35" translate="yes" xml:space="preserve">
          <source>A mechanism for reading data from the cache and subscribing for updates when these results change due to a mutation, subscription update, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cccdfbe7fde630bea189ab2f8f17ca043aff9a4" translate="yes" xml:space="preserve">
          <source>A mechanism for refetching an object.</source>
          <target state="translated">Un mecanismo para volver a buscar un objeto.</target>
        </trans-unit>
        <trans-unit id="dd1a050f9a41554bdba5570ef7cbd29c8928f1fa" translate="yes" xml:space="preserve">
          <source>A naming convention of &lt;code&gt;&amp;lt;FileName&amp;gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; for fragments is advised. This restriction is required while migrating from classic to modern APIs to allow for cross-compatibility.</source>
          <target state="translated">Se recomienda una convenci&amp;oacute;n de nomenclatura de &lt;code&gt;&amp;lt;FileName&amp;gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; para los fragmentos. Esta restricci&amp;oacute;n es necesaria al migrar de API cl&amp;aacute;sicas a modernas para permitir la compatibilidad cruzada.</target>
        </trans-unit>
        <trans-unit id="b4223851fbff0df13ddb07d4c23c59818ab413eb" translate="yes" xml:space="preserve">
          <source>A normalized cache ensures that the &lt;em&gt;cache&lt;/em&gt; is consistent. But what about our views? Ideally, our React views would always reflect the current information from the cache.</source>
          <target state="translated">Una cach&amp;eacute; normalizada asegura que la &lt;em&gt;cach&amp;eacute;&lt;/em&gt; sea ​​consistente. Pero, &amp;iquest;qu&amp;eacute; pasa con nuestras opiniones? Idealmente, nuestras vistas de React siempre reflejar&amp;iacute;an la informaci&amp;oacute;n actual del cach&amp;eacute;.</target>
        </trans-unit>
        <trans-unit id="ae22c4f42331ba6c74de6dc551bc9f18b6a1ae62" translate="yes" xml:space="preserve">
          <source>A normalized, in-memory object graph/cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="921546babe023949163725db08488e51b22729dc" translate="yes" xml:space="preserve">
          <source>A number of more detailed usage examples can be found &lt;a href=&quot;https://github.com/facebook/relay/blob/master/packages/react-relay/classic/mutation/__tests__/RelayGraphQLMutation-test.js&quot;&gt;in the test suite&lt;/a&gt;.</source>
          <target state="translated">En &lt;a href=&quot;https://github.com/facebook/relay/blob/master/packages/react-relay/classic/mutation/__tests__/RelayGraphQLMutation-test.js&quot;&gt;el conjunto de pruebas&lt;/a&gt; se pueden encontrar varios ejemplos de uso m&amp;aacute;s detallados .</target>
        </trans-unit>
        <trans-unit id="7bf37966659d061a8f053bad6bab73f29aaece2b" translate="yes" xml:space="preserve">
          <source>A parent component will pass in a reference to some &lt;code&gt;User&lt;/code&gt; &quot;record&quot;.</source>
          <target state="translated">Un componente principal pasar&amp;aacute; una referencia a alg&amp;uacute;n &quot;registro&quot; de &lt;code&gt;User&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3024b82cc133bf6a9ef4feda5d9be663e786bae2" translate="yes" xml:space="preserve">
          <source>A polyfilled environment for Relay using &lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt; to support older browsers might look like:</source>
          <target state="translated">Un entorno con relleno m&amp;uacute;ltiple para Relay que usa &lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt; para admitir navegadores m&amp;aacute;s antiguos podr&amp;iacute;a verse as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="d9c2b7e55915b27a1958903b288baadab9b9ebc4" translate="yes" xml:space="preserve">
          <source>A query like the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61d2ab53d28c9ffa3a83c917db0c7132ab0ec11a" translate="yes" xml:space="preserve">
          <source>A reference for translating between the Relay Classic and Relay Modern APIs.</source>
          <target state="translated">Una referencia para traducir entre las API de Relay Classic y Relay Modern.</target>
        </trans-unit>
        <trans-unit id="0b8683fbbd3c98251a45756a2f2f8175837a100c" translate="yes" xml:space="preserve">
          <source>A simple database</source>
          <target state="translated">Una simple base de datos</target>
        </trans-unit>
        <trans-unit id="40cf8919ea34c404a49fa4a02115691af647ed4f" translate="yes" xml:space="preserve">
          <source>A simple example</source>
          <target state="translated">Un simple ejemplo</target>
        </trans-unit>
        <trans-unit id="dd8ebc46434f8d14a177b5c72d5934bab414bb47" translate="yes" xml:space="preserve">
          <source>A simpler, more predictable mutation API. The restrictions on mutation queries from Relay Classic are also removed: mutation queries are static, fields can be arbitrarily nested, and may use arbitrary arguments.</source>
          <target state="translated">Un API de mutación más simple y predecible.También se han eliminado las restricciones de las consultas de mutación de Relay Classic:las consultas de mutación son estáticas,los campos pueden anidarse arbitrariamente y pueden utilizar argumentos arbitrarios.</target>
        </trans-unit>
        <trans-unit id="789d37a7cd03e8b6bdc2af935f5617d2f61be663" translate="yes" xml:space="preserve">
          <source>A standard response is to &quot;just use immutable data structures&quot; &amp;mdash; but let's see what would happen if we did:</source>
          <target state="translated">Una respuesta est&amp;aacute;ndar es &quot;simplemente usar estructuras de datos inmutables&quot;, pero veamos qu&amp;eacute; pasar&amp;iacute;a si lo hici&amp;eacute;ramos:</target>
        </trans-unit>
        <trans-unit id="e5e4cf2d26ffa89b62883fa16b09362f316c9090" translate="yes" xml:space="preserve">
          <source>A summary of the improvements and new features in Relay Modern.</source>
          <target state="translated">Un resumen de las mejoras y nuevas características del Relevo Moderno.</target>
        </trans-unit>
        <trans-unit id="95da6cd41846ca1d215d52c18cb18c520fe5b668" translate="yes" xml:space="preserve">
          <source>A working copy of the treasure hunt can be found in the &lt;a href=&quot;https://github.com/relayjs/relay-examples&quot;&gt;relay-examples&lt;/a&gt; repository.</source>
          <target state="translated">Se puede encontrar una copia de trabajo de la b&amp;uacute;squeda del tesoro en el repositorio de &lt;a href=&quot;https://github.com/relayjs/relay-examples&quot;&gt;ejemplos de retransmisi&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1aec4806edaa35984901f978cbb068b50698edb4" translate="yes" xml:space="preserve">
          <source>API Cheatsheet</source>
          <target state="translated">Hoja de trucos de la API</target>
        </trans-unit>
        <trans-unit id="2c3de2092b0a547759dcfed154c12293c6bfa562" translate="yes" xml:space="preserve">
          <source>API and Runtime</source>
          <target state="translated">API y Runtime</target>
        </trans-unit>
        <trans-unit id="30decd745bda6efb9c328a25620c92f31665d9ed" translate="yes" xml:space="preserve">
          <source>Accessing a plain connection field like this is the same as other regular field:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42949c00e99b70b6ffba23e406246cfa31564e49" translate="yes" xml:space="preserve">
          <source>Achieving View Consistency</source>
          <target state="translated">Lograr la consistencia de la vista</target>
        </trans-unit>
        <trans-unit id="81f2d6f8bacd029d8646faa85a14672311eb28b5" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;&quot;relay&quot;&lt;/code&gt; to the list of plugins your .babelrc file. See &lt;a href=&quot;babel-plugin-relay&quot;&gt;the docs&lt;/a&gt; if upgrading an existing Relay app.</source>
          <target state="translated">Agregue &lt;code&gt;&quot;relay&quot;&lt;/code&gt; a la lista de complementos de su archivo .babelrc. Consulte &lt;a href=&quot;babel-plugin-relay&quot;&gt;los documentos&lt;/a&gt; si actualiza una aplicaci&amp;oacute;n Relay existente.</target>
        </trans-unit>
        <trans-unit id="0a60bf5aa8ddfd89ba31ac71650847ae24721ce0" translate="yes" xml:space="preserve">
          <source>Add the variable to the queries that use the fragment and pass it in when fetching the query. For this it can be useful to have a module with a collection of variables for your product.</source>
          <target state="translated">Añade la variable a las consultas que utilizan el fragmento y pásala cuando se obtiene la consulta.Para ello puede ser útil tener un módulo con una colección de variables para su producto.</target>
        </trans-unit>
        <trans-unit id="0a4d555b6a81430095f4070dee6163a543de304b" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;handlerProvider&lt;/code&gt;</source>
          <target state="translated">Agregar un &lt;code&gt;handlerProvider&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c313de6babf318503fdf433e2471023cd78a727c" translate="yes" xml:space="preserve">
          <source>Additional Options</source>
          <target state="translated">Opciones adicionales</target>
        </trans-unit>
        <trans-unit id="94c2eff0e92e7480eb248740c04ee58edd887616" translate="yes" xml:space="preserve">
          <source>Additionally, you need a directory containing &lt;code&gt;.js&lt;/code&gt; files that use the &lt;code&gt;graphql&lt;/code&gt; tag to describe GraphQL queries and fragments. Let's call this &lt;code&gt;./src&lt;/code&gt;.</source>
          <target state="translated">Adem&amp;aacute;s, necesita un directorio que contenga archivos &lt;code&gt;.js&lt;/code&gt; que usen la etiqueta &lt;code&gt;graphql&lt;/code&gt; para describir las consultas y los fragmentos de GraphQL. Llamemos a esto &lt;code&gt;./src&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7c13cb060f72ef8e06bc9f0779c54871d13ff35" translate="yes" xml:space="preserve">
          <source>Advanced Mutation Example</source>
          <target state="translated">Ejemplo de mutación avanzada</target>
        </trans-unit>
        <trans-unit id="5126940d744a6dff391a643edf858b06f00785ed" translate="yes" xml:space="preserve">
          <source>Advanced usage</source>
          <target state="translated">Uso avanzado</target>
        </trans-unit>
        <trans-unit id="65b03cca363991c35ae10c0088f588b27ac28625" translate="yes" xml:space="preserve">
          <source>After global invalidation, any query that is checked before refetching it will be considered stale:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78bdcba5217f6a92239c4e8dde28377bb7815364" translate="yes" xml:space="preserve">
          <source>After initially fetching this story our cache might be as follows. Note that the story and comment both link to the same record as &lt;code&gt;author&lt;/code&gt;:</source>
          <target state="translated">Despu&amp;eacute;s de buscar inicialmente esta historia, nuestro cach&amp;eacute; podr&amp;iacute;a ser el siguiente. Tenga en cuenta que la historia y el comentario est&amp;aacute;n vinculados al mismo registro que el &lt;code&gt;author&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f2dd7e26249b6d8637a717ed4d6b92305ed4d8d7" translate="yes" xml:space="preserve">
          <source>After invalidating a record, any query that references the invalidated record and that is checked before refetching it will be considered stale:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20d5e5845a458c2e48e4a1e3d9fcce05c093f36b" translate="yes" xml:space="preserve">
          <source>After the network comes back, if any optimistic update was applied, it will be rolled back.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cefb28e5c89ebf89740e7f56f62c4e404d2462a6" translate="yes" xml:space="preserve">
          <source>All data is fetched in a single round trip.</source>
          <target state="translated">Todos los datos se obtienen en un solo viaje de ida y vuelta.</target>
        </trans-unit>
        <trans-unit id="40454335b535c042b908582ab2dd06293106ac63" translate="yes" xml:space="preserve">
          <source>All of the mutations we've performed so far have waited on a response from the server before updating the client-side store. Relay offers us a chance to craft an optimistic response of the same shape based on what we expect the server's response to be in the event of a successful mutation.</source>
          <target state="translated">Todas las mutaciones que hemos realizado hasta ahora han esperado una respuesta del servidor antes de actualizar la tienda del lado del cliente.El relé nos ofrece la oportunidad de crear una respuesta optimista de la misma forma basada en lo que esperamos que sea la respuesta del servidor en caso de una mutación exitosa.</target>
        </trans-unit>
        <trans-unit id="6e5ef228d93a867965453c9210e08a5fc6427932" translate="yes" xml:space="preserve">
          <source>Alternatively a &lt;a href=&quot;refetch-container&quot;&gt;&lt;code&gt;RefetchContainer&lt;/code&gt;&lt;/a&gt; can also be used.</source>
          <target state="translated">Alternativamente, tambi&amp;eacute;n se puede utilizar un &lt;a href=&quot;refetch-container&quot;&gt; &lt;code&gt;RefetchContainer&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3cb1f93043bd5b1e4766b2a5f1a916dfbf98f41c" translate="yes" xml:space="preserve">
          <source>Alternatively, you can install &lt;code&gt;relay-compiler&lt;/code&gt; globally so you can access it directly:</source>
          <target state="translated">Alternativamente, puede instalar &lt;code&gt;relay-compiler&lt;/code&gt; globalmente para poder acceder a &amp;eacute;l directamente:</target>
        </trans-unit>
        <trans-unit id="4e7be8aae845923a0feac81e1f7b4b0b1b6931db" translate="yes" xml:space="preserve">
          <source>Although the response is hierarchical, we'll cache it by flattening all the records. Here is an example of how Relay would cache this query response:</source>
          <target state="translated">Aunque la respuesta es jerárquica,la almacenaremos aplanando todos los registros.Aquí hay un ejemplo de cómo el Relevo almacenaría en caché esta respuesta de consulta:</target>
        </trans-unit>
        <trans-unit id="c6ec18663142d1b37b9759d8f91cf8ac740a2752" translate="yes" xml:space="preserve">
          <source>An area we've gotten a lot of questions on was mutations and their configs. Relay Modern introduces a new mutation API that allows records and fields to be updated in a more direct manner.</source>
          <target state="translated">Un área sobre la que hemos recibido muchas preguntas fue sobre las mutaciones y sus configuraciones.Relay Modern introduce una nueva mutación API que permite que los registros y campos se actualicen de una manera más directa.</target>
        </trans-unit>
        <trans-unit id="16a242bdcfab9509fa528a20336ea8be61d5d155" translate="yes" xml:space="preserve">
          <source>An array containing the field names between the parent and the connection, including the parent and the connection</source>
          <target state="translated">Una matriz que contiene los nombres de los campos entre el padre y la conexión,incluyendo el padre y la conexión</target>
        </trans-unit>
        <trans-unit id="ab5c749afdc7ed704bf1427839cff1f6c54727ed" translate="yes" xml:space="preserve">
          <source>An example using &lt;code&gt;fetch&lt;/code&gt; looks like this:</source>
          <target state="translated">Un ejemplo que usa &lt;code&gt;fetch&lt;/code&gt; se ve as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="ecb9a82e766e01fb5997898864c15b00f3207e54" translate="yes" xml:space="preserve">
          <source>An instance of a &lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt; encapsulates an in-memory cache of GraphQL data and a network layer that provides access to your GraphQL server. The Environment object is typically not used by developers directly, instead it is passed to each &lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt;, which uses the environment to access, modify, and fetch data. Within a container, the current environment can be accessed via &lt;code&gt;this.props.relay.environment&lt;/code&gt;. This is most commonly used to &lt;a href=&quot;mutations&quot;&gt;execute a mutation&lt;/a&gt;.</source>
          <target state="translated">Una instancia de un &lt;a href=&quot;relay-environment&quot;&gt;entorno de retransmisi&amp;oacute;n&lt;/a&gt; encapsula un cach&amp;eacute; en memoria de datos GraphQL y una capa de red que proporciona acceso a su servidor GraphQL. Normalmente, los desarrolladores no utilizan el objeto Environment directamente, sino que se pasa a cada &lt;a href=&quot;query-renderer&quot;&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;/a&gt; , que utiliza el entorno para acceder, modificar y recuperar datos. Dentro de un contenedor, se puede acceder al entorno actual a trav&amp;eacute;s de &lt;code&gt;this.props.relay.environment&lt;/code&gt; . Esto se usa m&amp;aacute;s com&amp;uacute;nmente para &lt;a href=&quot;mutations&quot;&gt;ejecutar una mutaci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6dd9dc1929b158a9c5ea7752c056cc104664b1ef" translate="yes" xml:space="preserve">
          <source>An object that conforms to the &lt;code&gt;Relay.Environment&lt;/code&gt; interface, such as &lt;code&gt;Relay.Store&lt;/code&gt;.</source>
          <target state="translated">Un objeto que se ajusta a la interfaz &lt;code&gt;Relay.Environment&lt;/code&gt; , como &lt;code&gt;Relay.Store&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31091cd5447f1a5facd7ba679b86a188b803a23a" translate="yes" xml:space="preserve">
          <source>An optimized &quot;write&quot; operation for updating the cache with the results of queries/mutations/subscriptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac7cf5ea35aac5de7114e6afc02d20f82b3316f0" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;onReadyStateChange&lt;/code&gt; callback can be supplied to respond to the events involved with the data fulfillment.</source>
          <target state="translated">Se puede proporcionar una devoluci&amp;oacute;n de llamada &lt;code&gt;onReadyStateChange&lt;/code&gt; opcional para responder a los eventos relacionados con el cumplimiento de datos.</target>
        </trans-unit>
        <trans-unit id="7303f03f73c25d8e0d64d93962d92858e7741e4b" translate="yes" xml:space="preserve">
          <source>And here's a possible response:</source>
          <target state="translated">Y aquí hay una posible respuesta:</target>
        </trans-unit>
        <trans-unit id="369fe458331664a040bf70efbb8b99da198958aa" translate="yes" xml:space="preserve">
          <source>And this fragment can then be used to define the Story container:</source>
          <target state="translated">Y este fragmento puede ser usado para definir el contenedor de la Historia:</target>
        </trans-unit>
        <trans-unit id="4dfa35597a4d927f5cbf51a45486138efe15e61b" translate="yes" xml:space="preserve">
          <source>Another way to enable optimistic updates is via the &lt;code&gt;optimisticUpdater&lt;/code&gt;, which can be used for more complicated update scenarios. Using &lt;code&gt;optimisticUpdater&lt;/code&gt; is covered in the section &lt;a href=&quot;#using-updater-and-optimisticupdater&quot;&gt;below&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="880246192858f60438eac48b83d096fc7d5b0a5d" translate="yes" xml:space="preserve">
          <source>Any arguments defined inside &lt;code&gt;@argumentDefinitions&lt;/code&gt; will be local variables available inside the fragment's scope. However, a fragment can also reference global variables that were defined in the root query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="605ea43af6ae69ff62a257b6fd0223b045c71edf" translate="yes" xml:space="preserve">
          <source>Any field in the payload that can be correlated by DataID with one or more records in the client-side store will be merged with the record(s) in the store.</source>
          <target state="translated">Cualquier campo de la carga útil que pueda ser correlacionado por DataID con uno o más registros de la tienda del lado del cliente se fusionará con el/los registro(s)de la tienda.</target>
        </trans-unit>
        <trans-unit id="0fefe11020485e10d8f3308edf7710a3715bb28f" translate="yes" xml:space="preserve">
          <source>Any fields specified in the client schema, can be fetched from the &lt;a href=&quot;relay-store&quot;&gt;Relay Store&lt;/a&gt;, by selecting it in a query or fragment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfe1cdd7971ecdf1250f379fc5280623f121ecd7" translate="yes" xml:space="preserve">
          <source>Any props that we pass to the constructor of a mutation will become available to its instance methods as &lt;code&gt;this.props&lt;/code&gt;. Like in components used within Relay containers, props for which a corresponding fragment has been defined will be populated by Relay with query data:</source>
          <target state="translated">Cualquier accesorio que le pasemos al constructor de una mutaci&amp;oacute;n estar&amp;aacute; disponible para sus m&amp;eacute;todos de instancia como &lt;code&gt;this.props&lt;/code&gt; . Al igual que en los componentes utilizados dentro de los contenedores de Relay, Relay completar&amp;aacute; los accesorios para los que se ha definido un fragmento correspondiente con datos de consulta:</target>
        </trans-unit>
        <trans-unit id="2c3c3b69096651daf12db619c2e7045eb0884046" translate="yes" xml:space="preserve">
          <source>Any server can be taught to load a schema and speak GraphQL. Our &lt;a href=&quot;https://github.com/relayjs/relay-examples&quot;&gt;examples&lt;/a&gt; use Express.</source>
          <target state="translated">A cualquier servidor se le puede ense&amp;ntilde;ar a cargar un esquema y hablar GraphQL. Nuestros &lt;a href=&quot;https://github.com/relayjs/relay-examples&quot;&gt;ejemplos&lt;/a&gt; usan Express.</target>
        </trans-unit>
        <trans-unit id="8a830514fbc11a8668a4369e6666ef8944337af6" translate="yes" xml:space="preserve">
          <source>Applications must supply a &lt;a href=&quot;network-layer&quot;&gt;Network Layer&lt;/a&gt; when creating an instance of a Relay Environment. The network layer is an object conforming to a simple interface through which Relay can execute queries, mutations, and subscriptions. Essentially, this object teaches Relay how to talk to your GraphQL server.</source>
          <target state="translated">Las aplicaciones deben proporcionar una &lt;a href=&quot;network-layer&quot;&gt;capa de red&lt;/a&gt; al crear una instancia de un entorno de retransmisi&amp;oacute;n. La capa de red es un objeto que se ajusta a una interfaz simple a trav&amp;eacute;s de la cual Relay puede ejecutar consultas, mutaciones y suscripciones. B&amp;aacute;sicamente, este objeto le ense&amp;ntilde;a a Relay c&amp;oacute;mo comunicarse con su servidor GraphQL.</target>
        </trans-unit>
        <trans-unit id="b73a641a18b041c9d0f67faadd8eeb909c673be7" translate="yes" xml:space="preserve">
          <source>Applied to a fragment definition, &lt;code&gt;@relay(mask: false)&lt;/code&gt; changes the generated Flow types to be better usable when the fragment is included with the same directive. The Flow types will no longer be exact objects and no longer contain internal marker fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77cbe978decf7e18ac53e8ff64911f09e83509bc" translate="yes" xml:space="preserve">
          <source>Architecture Overview</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="a0478ca5f4c068ca3ac12f9474f6a15865ce9053" translate="yes" xml:space="preserve">
          <source>Arguments:</source>
          <target state="translated">Arguments:</target>
        </trans-unit>
        <trans-unit id="dd4d4251ad9eea93ba8b6656973531a29f150428" translate="yes" xml:space="preserve">
          <source>Array fields</source>
          <target state="translated">Campos de la matriz</target>
        </trans-unit>
        <trans-unit id="db828dbd3d02709c19e5c4f2577f94833837f6ee" translate="yes" xml:space="preserve">
          <source>As React components, &lt;code&gt;QueryRenderer&lt;/code&gt;s can be rendered anywhere that a React component can be rendered, i.e. not just at the top level but &lt;em&gt;within&lt;/em&gt; other components or containers; for example, to lazily fetch additional data for a popover.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3aab73669ac6dc9de81f7b41eeb64591c4e0ee7" translate="yes" xml:space="preserve">
          <source>As an example, we can log each mutation that is sent to the server as follows:</source>
          <target state="translated">Como ejemplo,podemos registrar cada mutación que se envía al servidor de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="93df315a58852563161dbb62a33b18e1c4b63051" translate="yes" xml:space="preserve">
          <source>As we've learned, Relay containers declare data requirements as GraphQL fragments. This means that, for example, &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; can be embedded not only in &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt;, but any container that fetches a field of type &lt;code&gt;User&lt;/code&gt;.</source>
          <target state="translated">Como hemos aprendido, los contenedores Relay declaran los requisitos de datos como fragmentos GraphQL. Esto significa que, por ejemplo, &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; se puede incrustar no solo en &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; , sino en cualquier contenedor que obtenga un campo de tipo &lt;code&gt;User&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="923622cbd0c4bbb9c49d319a01f53817606d02a1" translate="yes" xml:space="preserve">
          <source>As we've learned, Relay fragment containers declare data requirements as GraphQL fragments. We're almost ready to let Relay fulfill the data requirements for these components and render them. However, there is one problem. In order to actually fetch data with GraphQL, we need a query root. For example, we need to ground the &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; fragment in a GraphQL query.</source>
          <target state="translated">Como hemos aprendido, los contenedores de fragmentos de retransmisi&amp;oacute;n declaran los requisitos de datos como fragmentos de GraphQL. Estamos casi listos para permitir que Relay cumpla con los requisitos de datos para estos componentes y los represente. Sin embargo, existe un problema. Para obtener datos con GraphQL, necesitamos una ra&amp;iacute;z de consulta. Por ejemplo, necesitamos conectar el fragmento &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; en una consulta GraphQL.</target>
        </trans-unit>
        <trans-unit id="aca9c86fb3d13923d8fed77382029e60cce8b3f9" translate="yes" xml:space="preserve">
          <source>As we've learned, Relay fragment containers only declare data requirements as GraphQL fragments. In order to actually fetch and render the specified data, we need to use a &lt;code&gt;QueryRenderer&lt;/code&gt; component to render a root query and any fragment containers included within. Please refer to our &lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt; docs for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a71de49f031297e07457bef14ae0f8572e55b44" translate="yes" xml:space="preserve">
          <source>At this point, you can delete everything up until &lt;code&gt;queryType&lt;/code&gt; in &lt;code&gt;./data/schema.js&lt;/code&gt;.</source>
          <target state="translated">En este punto, puede eliminar todo hasta &lt;code&gt;queryType&lt;/code&gt; en &lt;code&gt;./data/schema.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="207aae1b1d93e0ae663b416c543d4e3848a98ef0" translate="yes" xml:space="preserve">
          <source>Authoring a schema</source>
          <target state="translated">La autoría de un esquema</target>
        </trans-unit>
        <trans-unit id="f959176d994ae939a23354811509dadf3863fa24" translate="yes" xml:space="preserve">
          <source>Available Props</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb220f88ae787a8eafb5d737da557d0ab6ff6ca" translate="yes" xml:space="preserve">
          <source>Babel Relay Plugin</source>
          <target state="translated">Babel Relay Plugin</target>
        </trans-unit>
        <trans-unit id="0351d5a9ef82b115e9ed00101cebdddfe0dbad30" translate="yes" xml:space="preserve">
          <source>Base React Component</source>
          <target state="translated">Componente de reacción de la base</target>
        </trans-unit>
        <trans-unit id="a6551059bdb95efc2dfbc4b7c2ce6ccc9fcd0365" translate="yes" xml:space="preserve">
          <source>Before going any further, we need to serialize our executable schema to JSON for use by the Relay.QL transpiler, then start up the server. From the command line:</source>
          <target state="translated">Antes de seguir adelante,necesitamos serializar nuestro esquema ejecutable a JSON para ser usado por el transpilador Relay.QL,y luego iniciar el servidor.Desde la línea de comandos:</target>
        </trans-unit>
        <trans-unit id="97cecb9e6bdc8256a26df17eef65a9b41e163cee" translate="yes" xml:space="preserve">
          <source>Before taking a deep dive into the mutations API, let's look at a complete example. Here, we subclass &lt;code&gt;Relay.Mutation&lt;/code&gt; to create a custom mutation that we can use to like a story.</source>
          <target state="translated">Antes de profundizar en la API de mutaciones, veamos un ejemplo completo. Aqu&amp;iacute;, subclasificamos &lt;code&gt;Relay.Mutation&lt;/code&gt; para crear una mutaci&amp;oacute;n personalizada que podamos usar para dar me gusta a una historia.</target>
        </trans-unit>
        <trans-unit id="949c7a85f6d836f247f0195b7eaa99f0c336e992" translate="yes" xml:space="preserve">
          <source>Behaviors can be one of &lt;code&gt;'append'&lt;/code&gt;, &lt;code&gt;'ignore'&lt;/code&gt;, &lt;code&gt;'prepend'&lt;/code&gt;, &lt;code&gt;'refetch'&lt;/code&gt;, or &lt;code&gt;'remove'&lt;/code&gt;.</source>
          <target state="translated">Los comportamientos pueden ser &lt;code&gt;'append'&lt;/code&gt; , &lt;code&gt;'ignore'&lt;/code&gt; , &lt;code&gt;'prepend'&lt;/code&gt; , &lt;code&gt;'refetch'&lt;/code&gt; o &lt;code&gt;'remove'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a13e0d17d14c44107ca60ab513e5d71d5662c000" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;Faction&lt;/code&gt; and &lt;code&gt;Ship&lt;/code&gt; have identifiers that we can use to refetch them. We expose this capability to Relay through the &lt;code&gt;Node&lt;/code&gt; interface and the &lt;code&gt;node&lt;/code&gt; field on the root query type.</source>
          <target state="translated">Tanto la &lt;code&gt;Faction&lt;/code&gt; como el &lt;code&gt;Ship&lt;/code&gt; tienen identificadores que podemos usar para recuperarlos. Exponemos esta capacidad a Relay a trav&amp;eacute;s de la interfaz de &lt;code&gt;Node&lt;/code&gt; y el campo de &lt;code&gt;node&lt;/code&gt; en el tipo de consulta ra&amp;iacute;z.</target>
        </trans-unit>
        <trans-unit id="3148373f94223f76742328ea5464dd9f30817fe7" translate="yes" xml:space="preserve">
          <source>But now, we can also create routes for arbitrary user IDs. For example, if we wanted to construct a route that fetched data for a user defined by the &lt;code&gt;userID&lt;/code&gt; query parameter, we might use:</source>
          <target state="translated">Pero ahora, tambi&amp;eacute;n podemos crear rutas para ID de usuario arbitrarios. Por ejemplo, si quisi&amp;eacute;ramos construir una ruta que obtuviera datos para un usuario definido por el par&amp;aacute;metro de consulta &lt;code&gt;userID&lt;/code&gt; , podr&amp;iacute;amos usar:</target>
        </trans-unit>
        <trans-unit id="1862f3355eff810374142f7e656f80df21c55213" translate="yes" xml:space="preserve">
          <source>By convention, mutations are named as verbs, their inputs are the name with &quot;Input&quot; appended at the end, and they return an object that is the name with &quot;Payload&quot; appended.</source>
          <target state="translated">Por convención,las mutaciones se nombran como verbos,sus entradas son el nombre con &quot;Input&quot; adjunto al final,y devuelven un objeto que es el nombre con &quot;Payload&quot; adjunto.</target>
        </trans-unit>
        <trans-unit id="178b930518b904dbc5bd0f441c18fc870aac28c3" translate="yes" xml:space="preserve">
          <source>By default, Relay assumes that GraphQL is served at &lt;code&gt;/graphql&lt;/code&gt; relative to the origin where our application is served. This can be re-configured by injecting a custom instantiation of the default network layer.</source>
          <target state="translated">De forma predeterminada, Relay asume que GraphQL se sirve en &lt;code&gt;/graphql&lt;/code&gt; en relaci&amp;oacute;n con el origen donde se sirve nuestra aplicaci&amp;oacute;n. Esto se puede volver a configurar inyectando una instanciaci&amp;oacute;n personalizada de la capa de red predeterminada.</target>
        </trans-unit>
        <trans-unit id="cb2b20c497e96eb4a4f4f36c0d7cc25608d4e73c" translate="yes" xml:space="preserve">
          <source>By default, Relay will only expose the data for fields explicitly requested by a &lt;a href=&quot;fragment-container#createfragmentcontainer&quot;&gt;component's fragment&lt;/a&gt;, which is known as &lt;a href=&quot;thinking-in-relay#data-masking&quot;&gt;data masking&lt;/a&gt;. Fragment data is unmasked for use in React components by &lt;code&gt;createFragmentContainer&lt;/code&gt;. However, you may want to use fragment data in non-React functions that are called from React.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c01482f7fe504d2a5e3cc944236d88811dd8d351" translate="yes" xml:space="preserve">
          <source>By default, nothing is rendered while loading data for the initial render. If a previous set of &lt;code&gt;Component&lt;/code&gt; and &lt;code&gt;route&lt;/code&gt; were fulfilled and rendered, the default behavior is to continue rendering the previous view.</source>
          <target state="translated">De forma predeterminada, no se procesa nada mientras se cargan datos para el procesamiento inicial. Si se cumpli&amp;oacute; y renderiz&amp;oacute; un conjunto anterior de &lt;code&gt;Component&lt;/code&gt; e y &lt;code&gt;route&lt;/code&gt; , el comportamiento predeterminado es continuar renderizando la vista anterior.</target>
        </trans-unit>
        <trans-unit id="4375c1481c81a0b6d8e08ac19523704d5d4da90b" translate="yes" xml:space="preserve">
          <source>Cache Consistency</source>
          <target state="translated">Consistencia de la memoria caché</target>
        </trans-unit>
        <trans-unit id="14776554d5693e023c3ac7a5a65e4a5058537dfe" translate="yes" xml:space="preserve">
          <source>Cache Updates</source>
          <target state="translated">actualizaciones de la caché</target>
        </trans-unit>
        <trans-unit id="60790f7c84170a8b87051d7e857118ffeb0465ee" translate="yes" xml:space="preserve">
          <source>Caching</source>
          <target state="translated">Caching</target>
        </trans-unit>
        <trans-unit id="eed1812845bba88a7ea96dc0731ed87a6365fcc0" translate="yes" xml:space="preserve">
          <source>Caching A Graph</source>
          <target state="translated">Caching A Graph</target>
        </trans-unit>
        <trans-unit id="c3fbd240479228aa26381115ef997022e9773856" translate="yes" xml:space="preserve">
          <source>Call this to optimistically apply an update to the store.</source>
          <target state="translated">Llama a esto para aplicar con optimismo una actualización a la tienda.</target>
        </trans-unit>
        <trans-unit id="ef28016b715246d53e3c0aef32bef448a5df1961" translate="yes" xml:space="preserve">
          <source>Call this to send the mutation to the server.</source>
          <target state="translated">Llama a esto para enviar la mutación al servidor.</target>
        </trans-unit>
        <trans-unit id="36653c1ff08edcb50e3d0e9893272cf6219ebfe7" translate="yes" xml:space="preserve">
          <source>Callers must provide an appropriate &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;variables&lt;/code&gt;. As per the GraphQL Relay Specification:</source>
          <target state="translated">Las personas que llaman deben proporcionar una &lt;code&gt;query&lt;/code&gt; y &lt;code&gt;variables&lt;/code&gt; adecuadas . Seg&amp;uacute;n la especificaci&amp;oacute;n de retransmisi&amp;oacute;n GraphQL:</target>
        </trans-unit>
        <trans-unit id="ec585c24a23bd7001c34d954b9fe9b0796cec5f2" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;hasOptimisticUpdate&lt;/code&gt; with a record from &lt;code&gt;this.props&lt;/code&gt; will return whether that given record is affected by an optimistic mutation. It allows the component to render local optimistic changes differently from data that has successfully synchronized with the server.</source>
          <target state="translated">Llamar a &lt;code&gt;hasOptimisticUpdate&lt;/code&gt; con un registro de &lt;code&gt;this.props&lt;/code&gt; devolver&amp;aacute; si ese registro dado se ve afectado por una mutaci&amp;oacute;n optimista. Permite que el componente represente cambios optimistas locales de manera diferente a los datos que se han sincronizado correctamente con el servidor.</target>
        </trans-unit>
        <trans-unit id="7e92933047a9a8b8023050178520d6236fd1d0bd" translate="yes" xml:space="preserve">
          <source>Calling Component Instance Methods</source>
          <target state="translated">Llamando a los métodos de instancia de componentes</target>
        </trans-unit>
        <trans-unit id="539001ff0ade75c366a1d2f2ae990718f2b4bd9b" translate="yes" xml:space="preserve">
          <source>Can QueryRenderer using Classic Environment (&lt;code&gt;Store&lt;/code&gt; in &lt;code&gt;react-relay/classic&lt;/code&gt;) use:</source>
          <target state="translated">&amp;iquest;Puede QueryRenderer usar Classic Environment ( &lt;code&gt;Store&lt;/code&gt; in &lt;code&gt;react-relay/classic&lt;/code&gt; ) usar:</target>
        </trans-unit>
        <trans-unit id="4aacaa8308c0d89cb19bc6280f172bcb3027eef8" translate="yes" xml:space="preserve">
          <source>Can QueryRenderer using Modern Environment use:</source>
          <target state="translated">Puede QueryRenderer usando el uso del Medio Ambiente Moderno:</target>
        </trans-unit>
        <trans-unit id="1003218887eb40c1f0a58bc7b7505d15f23175bf" translate="yes" xml:space="preserve">
          <source>Can React Classic Component use:</source>
          <target state="translated">Puede reaccionar al uso del componente clásico:</target>
        </trans-unit>
        <trans-unit id="84238b1b418a17b213190530f83d669483ad4f99" translate="yes" xml:space="preserve">
          <source>Can React Compat Component use:</source>
          <target state="translated">Puede reaccionar al uso del componente Compat:</target>
        </trans-unit>
        <trans-unit id="1c53c8d6a82f41f51bcb44a951f6d42bbd674773" translate="yes" xml:space="preserve">
          <source>Can React Modern Component use:</source>
          <target state="translated">Puede reaccionar al uso de componentes modernos:</target>
        </trans-unit>
        <trans-unit id="ce811e756a396388182f7a8551a77979cea636ea" translate="yes" xml:space="preserve">
          <source>Can RelayRootContainer use:</source>
          <target state="translated">Puede utilizar el RelayRootContainer:</target>
        </trans-unit>
        <trans-unit id="918e312c8dc15e096c8aa60a584cd24fb9b592cd" translate="yes" xml:space="preserve">
          <source>Changing Arguments</source>
          <target state="translated">Cambiando los argumentos</target>
        </trans-unit>
        <trans-unit id="51cdd39226322d9d0efb448c0d03eb64cb6c777d" translate="yes" xml:space="preserve">
          <source>Changing one thing in a system can have a ripple effect that causes other things to change in turn. Imagine a mutation that we can use to accept a friend request. This can have wide implications:</source>
          <target state="translated">Cambiar una cosa en un sistema puede tener un efecto dominó que causa que otras cosas cambien a su vez.Imagina una mutación que podemos usar para aceptar una petición de amistad.Esto puede tener amplias implicaciones:</target>
        </trans-unit>
        <trans-unit id="bb73c6b849ccfd7df64b939d3890bbba8b94e10a" translate="yes" xml:space="preserve">
          <source>Classic Component</source>
          <target state="translated">Componente clásico</target>
        </trans-unit>
        <trans-unit id="9e402ea82ec577f1a7b994361d91b4f9ac1cf510" translate="yes" xml:space="preserve">
          <source>Classic Mutation</source>
          <target state="translated">Mutación clásica</target>
        </trans-unit>
        <trans-unit id="76be385c076bd3cf6a0e76bbefee914b22199f01" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;&amp;lt;RelayRootContainer&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Cl&amp;aacute;sico: &lt;code&gt;&amp;lt;RelayRootContainer&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9450d4893299b4475b958954ce614f6339c011c9" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;Relay.createContainer&lt;/code&gt;</source>
          <target state="translated">Cl&amp;aacute;sico: &lt;code&gt;Relay.createContainer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fdacd86df881f947250264b6f74153f74ca2e17b" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;this.props.relay.commitUpdate(mutation...)&lt;/code&gt;</source>
          <target state="translated">Cl&amp;aacute;sico: &lt;code&gt;this.props.relay.commitUpdate(mutation...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4496ce0ff60c519ddb23c737b94a8c3d0f8fae44" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;this.props.relay.forceFetch()&lt;/code&gt;</source>
          <target state="translated">Cl&amp;aacute;sico: &lt;code&gt;this.props.relay.forceFetch()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4718307cda6ad09eb778eec75ee2c5f20cd45961" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;this.props.relay.setVariable({count: prevCount + pageSize}...)&lt;/code&gt;</source>
          <target state="translated">Cl&amp;aacute;sico: &lt;code&gt;this.props.relay.setVariable({count: prevCount + pageSize}...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a88cd760542eea1905cd9d8225750e276c483cde" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;this.props.relay.setVariable({foo: bar}...)&lt;/code&gt;</source>
          <target state="translated">Cl&amp;aacute;sico: &lt;code&gt;this.props.relay.setVariable({foo: bar}...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6f5633b3ae0188027fabbde415e0f3fcc71e6c3" translate="yes" xml:space="preserve">
          <source>Client Caching</source>
          <target state="translated">Caching de clientes</target>
        </trans-unit>
        <trans-unit id="d4d64d5c478ea7fd0df7b8579f158dc6ea90455b" translate="yes" xml:space="preserve">
          <source>Client Schema Extensions (Experimental)</source>
          <target state="translated">Extensiones del esquema del cliente (Experimental)</target>
        </trans-unit>
        <trans-unit id="825764a68e0dc6e933619f703142c815e2415444" translate="yes" xml:space="preserve">
          <source>Client schema extensions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37d72336fa3d155eac5f2b8f6e5f8d2e326546c2" translate="yes" xml:space="preserve">
          <source>Committing Local Updates</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a359c7ebffb6706034dbf0f013aa73bcc550292c" translate="yes" xml:space="preserve">
          <source>Comparing Relay Classic and Relay Modern</source>
          <target state="translated">Comparando el Relevo Clásico y el Relevo Moderno</target>
        </trans-unit>
        <trans-unit id="fb10d488b2ce3717647b6821e5a1c02381aeca3a" translate="yes" xml:space="preserve">
          <source>Comparison to Classic Relay</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c54dbbae41b051460dcc8e3c9aa6f310af3f2775" translate="yes" xml:space="preserve">
          <source>Compat Component</source>
          <target state="translated">Componente de Compat</target>
        </trans-unit>
        <trans-unit id="2171ca54b3db409d7e88bfa689ea2ab5583955c6" translate="yes" xml:space="preserve">
          <source>Compat Mode</source>
          <target state="translated">Modo de compás</target>
        </trans-unit>
        <trans-unit id="ef1a53514cc801546fdbf4bd01e2b4b764618f78" translate="yes" xml:space="preserve">
          <source>Compat Mutation</source>
          <target state="translated">Mutación de Compat</target>
        </trans-unit>
        <trans-unit id="7ae7318a99d95f75927a3ae6b936e04d175cc04e" translate="yes" xml:space="preserve">
          <source>Compatibility Cheatsheet</source>
          <target state="translated">Ficha de compatibilidad</target>
        </trans-unit>
        <trans-unit id="6d9f235cb9c7c65f0cf0b1b0814cadde6d86abcb" translate="yes" xml:space="preserve">
          <source>Compatibility Mode</source>
          <target state="translated">Modo de compatibilidad</target>
        </trans-unit>
        <trans-unit id="e2e7a6441928ea51ba685ebeb68d5198d58d0008" translate="yes" xml:space="preserve">
          <source>Compiler Architecture</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89e9d1be17321688f8d0501eb1a3bf2c6ca26c3e" translate="yes" xml:space="preserve">
          <source>Complete details on how the server should behave are available in the &lt;a href=&quot;https://facebook.github.io/relay/graphql/connections.htm&quot;&gt;GraphQL Cursor Connections&lt;/a&gt; spec.</source>
          <target state="translated">Los detalles completos sobre c&amp;oacute;mo debe comportarse el servidor est&amp;aacute;n disponibles en la especificaci&amp;oacute;n &lt;a href=&quot;https://facebook.github.io/relay/graphql/connections.htm&quot;&gt;GraphQL Cursor Connections&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="29619ae00dc1b1f13f0d8573c5ca62184c0a6a94" translate="yes" xml:space="preserve">
          <source>Complete details on how the server should behave are available in the &lt;a href=&quot;https://facebook.github.io/relay/graphql/mutations.htm&quot;&gt;GraphQL Input Object Mutations&lt;/a&gt; spec.</source>
          <target state="translated">Los detalles completos sobre c&amp;oacute;mo debe comportarse el servidor est&amp;aacute;n disponibles en la &lt;a href=&quot;https://facebook.github.io/relay/graphql/mutations.htm&quot;&gt;especificaci&amp;oacute;n GraphQL Input Object Mutations&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dd80bd3e0728573910ceff942d6bf05bb7333573" translate="yes" xml:space="preserve">
          <source>Complete details on how the server should behave are available in the &lt;a href=&quot;https://facebook.github.io/relay/graphql/objectidentification.htm&quot;&gt;GraphQL Object Identification&lt;/a&gt; spec.</source>
          <target state="translated">Los detalles completos sobre c&amp;oacute;mo debe comportarse el servidor est&amp;aacute;n disponibles en la especificaci&amp;oacute;n de &lt;a href=&quot;https://facebook.github.io/relay/graphql/objectidentification.htm&quot;&gt;identificaci&amp;oacute;n de objetos GraphQL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c92c529e0731c57efd7550480196484040b33c3e" translate="yes" xml:space="preserve">
          <source>Component</source>
          <target state="translated">Component</target>
        </trans-unit>
        <trans-unit id="725a4ffad64df11f9defa669f85ec107f9dc492d" translate="yes" xml:space="preserve">
          <source>Component and Route</source>
          <target state="translated">Componente y ruta</target>
        </trans-unit>
        <trans-unit id="94c5c072cfb48e6d9ea12f613a057a202a5c287b" translate="yes" xml:space="preserve">
          <source>Components can change their data requirements by using &lt;code&gt;setVariables&lt;/code&gt; to request an update to the current set of &lt;code&gt;variables&lt;/code&gt;.</source>
          <target state="translated">Los componentes pueden cambiar sus requisitos de datos utilizando &lt;code&gt;setVariables&lt;/code&gt; para solicitar una actualizaci&amp;oacute;n del conjunto actual de &lt;code&gt;variables&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31ae8b82fb482703d4497f95cafdbd464174a12e" translate="yes" xml:space="preserve">
          <source>Components can inspect pending mutations on any record (i.e. data made available in props with a corresponding fragment). Calling &lt;code&gt;getPendingTransactions&lt;/code&gt; with a record will return a list of the pending mutation transactions that affect that particular record.</source>
          <target state="translated">Los componentes pueden inspeccionar mutaciones pendientes en cualquier registro (es decir, datos disponibles en accesorios con un fragmento correspondiente). Llamar a &lt;code&gt;getPendingTransactions&lt;/code&gt; con un registro devolver&amp;aacute; una lista de las transacciones de mutaci&amp;oacute;n pendientes que afectan ese registro en particular.</target>
        </trans-unit>
        <trans-unit id="deee480cd52fae7c121c1d7b8b86ecda66617156" translate="yes" xml:space="preserve">
          <source>Composing Fragments</source>
          <target state="translated">Composición de los fragmentos</target>
        </trans-unit>
        <trans-unit id="0c70e5846878a796dcb7c94e3f0ca5de9a047eee" translate="yes" xml:space="preserve">
          <source>Composing Views</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a321a9ac4f3111d95368aba4e87b1917d75348e" translate="yes" xml:space="preserve">
          <source>Composing Views - It's Plain React</source>
          <target state="translated">Composición de puntos de vista-Es una simple reacción</target>
        </trans-unit>
        <trans-unit id="723e2c15fe85b32b7d864e21eb29e93116b04e14" translate="yes" xml:space="preserve">
          <source>Composing child component fragments in a parent fragment.</source>
          <target state="translated">Composición de los fragmentos de los componentes de los niños en un fragmento de los padres.</target>
        </trans-unit>
        <trans-unit id="f82641d3cbab73b5e585b20db3196f350cb839d5" translate="yes" xml:space="preserve">
          <source>Composing fragments defined as local variables.</source>
          <target state="translated">Componiendo fragmentos definidos como variables locales.</target>
        </trans-unit>
        <trans-unit id="114b9abd3f0b27b8a9b5084318c5af838acdb163" translate="yes" xml:space="preserve">
          <source>Composing the data descriptions.</source>
          <target state="translated">Componer las descripciones de los datos.</target>
        </trans-unit>
        <trans-unit id="59d6b2067a223146a5ead92a4c5fe072d43c9a1e" translate="yes" xml:space="preserve">
          <source>Composing the fragments of child components is discussed in detail in the &lt;a href=&quot;guides-containers&quot;&gt;Containers Guide&lt;/a&gt;, but here's a quick example:</source>
          <target state="translated">La composici&amp;oacute;n de los fragmentos de componentes secundarios se analiza en detalle en la &lt;a href=&quot;guides-containers&quot;&gt;Gu&amp;iacute;a de contenedores&lt;/a&gt; , pero aqu&amp;iacute; hay un ejemplo r&amp;aacute;pido:</target>
        </trans-unit>
        <trans-unit id="a7b041783bd841c2982c635611a14b9b0478fc32" translate="yes" xml:space="preserve">
          <source>Composing the view logic, and</source>
          <target state="translated">Componer la lógica de la vista,y</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="9d60520748b88da0348eeb8f6543f6f98cdbd262" translate="yes" xml:space="preserve">
          <source>Conditional fields</source>
          <target state="translated">Campos condicionales</target>
        </trans-unit>
        <trans-unit id="6355cff1e61b5cd688cec493b080516655b2ac6a" translate="yes" xml:space="preserve">
          <source>Configs</source>
          <target state="translated">Configs</target>
        </trans-unit>
        <trans-unit id="2de632b51a33bf8e3ed45599633fb58061f6d4dc" translate="yes" xml:space="preserve">
          <source>Configure Network</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6512ee1541e9a6c52d5bf7cf465332e8df25ea3c" translate="yes" xml:space="preserve">
          <source>Connection</source>
          <target state="translated">Connection</target>
        </trans-unit>
        <trans-unit id="2d3d0c339708a6485641055e4d0d9e905ec021cc" translate="yes" xml:space="preserve">
          <source>ConnectionHandler</source>
          <target state="translated">ConnectionHandler</target>
        </trans-unit>
        <trans-unit id="81ea0a30d213381b26e05bce9c491003535b147a" translate="yes" xml:space="preserve">
          <source>Consider an input with a server-defined placeholder text and an imperative method to focus the input node:</source>
          <target state="translated">Considere una entrada con un texto de marcador de posición definido por el servidor y un método imperativo para enfocar el nodo de entrada:</target>
        </trans-unit>
        <trans-unit id="1956d506ca97255f5713770475161b61eb6cde73" translate="yes" xml:space="preserve">
          <source>Consider rendering the text and comments of a story along with the corresponding author names and photos. Here's the GraphQL query:</source>
          <target state="translated">Considere la posibilidad de presentar el texto y los comentarios de una historia junto con los nombres de los autores y las fotos correspondientes.Aquí está la consulta de GraphQL:</target>
        </trans-unit>
        <trans-unit id="e6443af99d2f470f50affd5057bf48db2d09dae4" translate="yes" xml:space="preserve">
          <source>Container</source>
          <target state="translated">Container</target>
        </trans-unit>
        <trans-unit id="0d5a8d03518c194626d6e3e124e7de20c17a7fe5" translate="yes" xml:space="preserve">
          <source>Container Composition</source>
          <target state="translated">Composición del contenedor</target>
        </trans-unit>
        <trans-unit id="b625b62c69e181700306e0871c20a6c94eaa2510" translate="yes" xml:space="preserve">
          <source>Container Specification</source>
          <target state="translated">Especificación del contenedor</target>
        </trans-unit>
        <trans-unit id="dfe33c87ae0783b9497dae2f22418a5e90385aa4" translate="yes" xml:space="preserve">
          <source>Container.getFragment()</source>
          <target state="translated">Container.getFragment()</target>
        </trans-unit>
        <trans-unit id="e040a458f46532a90ec69fa0b4bfc33ba151c98b" translate="yes" xml:space="preserve">
          <source>Containers</source>
          <target state="translated">Containers</target>
        </trans-unit>
        <trans-unit id="4b51306faf49817c8299a221a2777da9319cb8d3" translate="yes" xml:space="preserve">
          <source>Containers are Higher-Order Components</source>
          <target state="translated">Los contenedores son componentes de orden superior</target>
        </trans-unit>
        <trans-unit id="46e795775ec1e8e3e71a6a5641d35b084e19a5a9" translate="yes" xml:space="preserve">
          <source>Containers can define a &lt;code&gt;prepareVariables&lt;/code&gt; method which provides the opportunity to modify the variables that are available to fragments. The new variables can be generated based on the previous variables (or the &lt;code&gt;initialVariables&lt;/code&gt; if no previous ones exist) in addition to the runtime environment.</source>
          <target state="translated">Los contenedores pueden definir un m&amp;eacute;todo &lt;code&gt;prepareVariables&lt;/code&gt; que brinda la oportunidad de modificar las variables que est&amp;aacute;n disponibles para los fragmentos. Las nuevas variables se pueden generar en funci&amp;oacute;n de las variables anteriores (o las &lt;code&gt;initialVariables&lt;/code&gt; si no existen) adem&amp;aacute;s del entorno de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ad0eb4a22e44d99ae045c52ec3f202dc664a29f9" translate="yes" xml:space="preserve">
          <source>Containers declare data requirements on &lt;code&gt;fragments&lt;/code&gt; using GraphQL fragments.</source>
          <target state="translated">Los contenedores declaran los requisitos de datos sobre &lt;code&gt;fragments&lt;/code&gt; utilizan fragmentos de GraphQL.</target>
        </trans-unit>
        <trans-unit id="8928f5de2a918d60f1bbb5d72e6a68cb7502e86a" translate="yes" xml:space="preserve">
          <source>Convenience method that wraps the constructor, passing some default parameters and returning an instance.</source>
          <target state="translated">Método conveniente que envuelve al constructor,pasando algunos parámetros por defecto y devolviendo una instancia.</target>
        </trans-unit>
        <trans-unit id="dd226f43ba5c8ff842931a3ca2796d7c444510a9" translate="yes" xml:space="preserve">
          <source>Conversion Playbook</source>
          <target state="translated">Libro de jugadas de conversión</target>
        </trans-unit>
        <trans-unit id="aca075e23eed144339279d097d6fa88dc0718ec3" translate="yes" xml:space="preserve">
          <source>Conversion Scripts</source>
          <target state="translated">Guiones de conversión</target>
        </trans-unit>
        <trans-unit id="bc6e3a410aa372c2487ec123aa51c13c61ba9355" translate="yes" xml:space="preserve">
          <source>Core Modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06ee6cde901e483137128dd1aaa541e9ba1b4f92" translate="yes" xml:space="preserve">
          <source>Core primitives for building offline/persisted caching.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b3852c7992c04bd7a1c305779c938fba2763c16" translate="yes" xml:space="preserve">
          <source>Core primitives to enable subscriptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e93c185376ad3e3749d528694597be4eb780596d" translate="yes" xml:space="preserve">
          <source>Create a mutation instance using the &lt;code&gt;new&lt;/code&gt; keyword, optionally passing it some props. Note that &lt;code&gt;this.props&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; available inside the constructor function, but are set for all the methods mentioned below (&lt;code&gt;getCollisionKey&lt;/code&gt;, &lt;code&gt;getOptimisticResponse&lt;/code&gt;, etc). This restriction is due to the fact that mutation props may depend on data from the RelayEnvironment, which isn't known until the mutation is applied with &lt;code&gt;applyUpdate&lt;/code&gt; or &lt;code&gt;commitUpdate&lt;/code&gt;.</source>
          <target state="translated">Cree una instancia de mutaci&amp;oacute;n usando la &lt;code&gt;new&lt;/code&gt; palabra clave, opcionalmente pas&amp;aacute;ndole algunos accesorios. Tenga en cuenta que &lt;code&gt;this.props&lt;/code&gt; &lt;em&gt;no&lt;/em&gt; est&amp;aacute; disponible dentro de la funci&amp;oacute;n del constructor, pero est&amp;aacute; configurado para todos los m&amp;eacute;todos mencionados a continuaci&amp;oacute;n ( &lt;code&gt;getCollisionKey&lt;/code&gt; , &lt;code&gt;getOptimisticResponse&lt;/code&gt; , etc.). Esta restricci&amp;oacute;n se debe al hecho de que los accesorios de mutaci&amp;oacute;n pueden depender de los datos de RelayEnvironment, que no se conocen hasta que se aplica la mutaci&amp;oacute;n con &lt;code&gt;applyUpdate&lt;/code&gt; o &lt;code&gt;commitUpdate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70fb5b0ec1a182be6e0a0d9950900f7bbb367668" translate="yes" xml:space="preserve">
          <source>Create a route instance using the &lt;code&gt;new&lt;/code&gt; keyword, optionally passing it some params.</source>
          <target state="translated">Cree una instancia de ruta utilizando la &lt;code&gt;new&lt;/code&gt; palabra clave, pas&amp;aacute;ndole opcionalmente algunos par&amp;aacute;metros.</target>
        </trans-unit>
        <trans-unit id="22330ce575ca322006e65a1cba21c0878bcce956" translate="yes" xml:space="preserve">
          <source>Creates a new Relay Container - see the &lt;a href=&quot;guides-containers&quot;&gt;Container Guide&lt;/a&gt; for more details and examples.</source>
          <target state="translated">Crea un nuevo contenedor de retransmisiones; consulte la &lt;a href=&quot;guides-containers&quot;&gt;Gu&amp;iacute;a de contenedores&lt;/a&gt; para obtener m&amp;aacute;s detalles y ejemplos.</target>
        </trans-unit>
        <trans-unit id="59d477c173081caca582f697a308e90dad49d280" translate="yes" xml:space="preserve">
          <source>Creates a new record in the store given a &lt;code&gt;dataID&lt;/code&gt; and the &lt;code&gt;typeName&lt;/code&gt; as defined by the GraphQL schema. Returns a &lt;a href=&quot;#recordproxy&quot;&gt;&lt;code&gt;RecordProxy&lt;/code&gt;&lt;/a&gt; which serves as an interface to mutate the newly created record.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21efb0843ee16f4a18b237b51a057d09100b1064" translate="yes" xml:space="preserve">
          <source>Creates an edge given a &lt;a href=&quot;#recordsourceselectorproxy&quot;&gt;&lt;code&gt;store&lt;/code&gt;&lt;/a&gt;, a connection, the edge type, and a record that holds that connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc084a8dfcc6a7bce1de7aefac278e961edc50ea" translate="yes" xml:space="preserve">
          <source>Currently the easiest way to create a network layer is via a helper from the &lt;code&gt;relay-runtime&lt;/code&gt; package:</source>
          <target state="translated">Actualmente, la forma m&amp;aacute;s sencilla de crear una capa de red es mediante un ayudante del paquete &lt;code&gt;relay-runtime&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="461be9b9f59ebf2cd3bfe288b44d41bb20a992dc" translate="yes" xml:space="preserve">
          <source>Custom HTTP headers can be configured by providing a &lt;code&gt;headers&lt;/code&gt; object:</source>
          <target state="translated">Los encabezados HTTP personalizados se pueden configurar proporcionando un objeto de &lt;code&gt;headers&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e441c87bb7618c55b15a3915a29a65fc20c0d1cd" translate="yes" xml:space="preserve">
          <source>Custom Network Layers</source>
          <target state="translated">Capas de red personalizadas</target>
        </trans-unit>
        <trans-unit id="c604943e72b71d4741cddde2419706b8dc35d372" translate="yes" xml:space="preserve">
          <source>Custom Routing and More</source>
          <target state="translated">Rutas personalizadas y más</target>
        </trans-unit>
        <trans-unit id="3fe80ac6912200b4e6e928a52d6c87fd5c777197" translate="yes" xml:space="preserve">
          <source>Custom network layers must conform to the following &lt;a href=&quot;interfaces-relay-network-layer&quot;&gt;RelayNetworkLayer&lt;/a&gt; interface. Although the default network layer is an instantiable class that accepts some configuration, this is not a requirement of an injected network layer.</source>
          <target state="translated">Las capas de red personalizadas deben cumplir con la siguiente interfaz &lt;a href=&quot;interfaces-relay-network-layer&quot;&gt;RelayNetworkLayer&lt;/a&gt; . Aunque la capa de red predeterminada es una clase instanciable que acepta alguna configuraci&amp;oacute;n, esto no es un requisito de una capa de red inyectada.</target>
        </trans-unit>
        <trans-unit id="342f49485ae8bc8e1ade62ea93e337457051f472" translate="yes" xml:space="preserve">
          <source>Custom network layers that must conform to the &lt;code&gt;RelayNetworkLayer&lt;/code&gt; interface.</source>
          <target state="translated">Capas de red personalizadas que deben ajustarse a la interfaz &lt;code&gt;RelayNetworkLayer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e195dc960c4de2f5938ab244ca476e61a3b512b" translate="yes" xml:space="preserve">
          <source>Custom open-source implementations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74c9c9c8ea99084415bd2064a41ac8fc43148678" translate="yes" xml:space="preserve">
          <source>Data Components aka Containers</source>
          <target state="translated">Componentes de datos,también conocidos como contenedores</target>
        </trans-unit>
        <trans-unit id="682fde2c24e47bc1edbae33948606de2438e015b" translate="yes" xml:space="preserve">
          <source>Data Dependencies With GraphQL</source>
          <target state="translated">Dependencias de datos con GraphQL</target>
        </trans-unit>
        <trans-unit id="d3ef9a304a148420eba3a55c129f2235b1f9e1ec" translate="yes" xml:space="preserve">
          <source>Data Flow</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8344c50bb3999d69b17cd5abd2f78e4f029419a" translate="yes" xml:space="preserve">
          <source>Data Masking</source>
          <target state="translated">Enmascaramiento de datos</target>
        </trans-unit>
        <trans-unit id="9f570bdcfd6b031f335934a6700ab99601783168" translate="yes" xml:space="preserve">
          <source>Data Model</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c18842877f84be9bb3ae10673c4e60242f22c160" translate="yes" xml:space="preserve">
          <source>Data Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1e75bbe26916d6856acc894895802461b7a14ea" translate="yes" xml:space="preserve">
          <source>Data Types &amp;amp; Modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7054bcb2316977418a434163d17919c53dc34953" translate="yes" xml:space="preserve">
          <source>Data fetched as a result of a &lt;code&gt;REQUIRED_CHILDREN&lt;/code&gt; config is not written into the client store, but you can add code that processes it in the &lt;code&gt;onSuccess&lt;/code&gt; callback that you pass into &lt;code&gt;commitUpdate()&lt;/code&gt;:</source>
          <target state="translated">Los datos obtenidos como resultado de una configuraci&amp;oacute;n &lt;code&gt;REQUIRED_CHILDREN&lt;/code&gt; no se escriben en la tienda del cliente, pero puede agregar c&amp;oacute;digo que los procese en la &lt;code&gt;onSuccess&lt;/code&gt; llamada onSuccess que pasa a &lt;code&gt;commitUpdate()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="af0a7349a2e7fc64dce9051e92bfe24510a15ba4" translate="yes" xml:space="preserve">
          <source>Data-Fetching APIs</source>
          <target state="translated">API de obtención de datos</target>
        </trans-unit>
        <trans-unit id="303a7cb486f5bdd65204f79dab8db7f52fcbe4b2" translate="yes" xml:space="preserve">
          <source>Data/View Consistency</source>
          <target state="translated">Consistencia de datos/visualización</target>
        </trans-unit>
        <trans-unit id="895b27c88016513d278a0ce3dc0663fae3829d58" translate="yes" xml:space="preserve">
          <source>Debugging</source>
          <target state="translated">Debugging</target>
        </trans-unit>
        <trans-unit id="ed85a15e615bc7cc2aa9ef71ae94ad5fcb7456cf" translate="yes" xml:space="preserve">
          <source>Debugging Programmatically</source>
          <target state="translated">Depuración programada</target>
        </trans-unit>
        <trans-unit id="45cae91f4ddfa0491f43cb639f9ed34ee522658d" translate="yes" xml:space="preserve">
          <source>Debugging Visually</source>
          <target state="translated">Depuración visual</target>
        </trans-unit>
        <trans-unit id="f33d59090001ed2c388b4cc1db43054af86f06dd" translate="yes" xml:space="preserve">
          <source>Default Network Layer</source>
          <target state="translated">Capa de red por defecto</target>
        </trans-unit>
        <trans-unit id="20f0fc44b4326d9865c55f56d274d841f7d0587e" translate="yes" xml:space="preserve">
          <source>DefaultNetworkLayer (static property)</source>
          <target state="translated">DefaultNetworkLayer (propiedad estática)</target>
        </trans-unit>
        <trans-unit id="cc401fba47cbe2915424897d3b03537f262c5e09" translate="yes" xml:space="preserve">
          <source>Defining Containers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c761cb3b3af168784bb525eb6cc8bdda8deb1143" translate="yes" xml:space="preserve">
          <source>Deletes a record from the store given its &lt;code&gt;dataID&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af5bf36afc63e00856e220e9305692ac4cae2b78" translate="yes" xml:space="preserve">
          <source>Design a fat query that covers every possible field that could change:</source>
          <target state="translated">Diseñe una consulta gorda que cubra todos los campos posibles que puedan cambiar:</target>
        </trans-unit>
        <trans-unit id="28c82071e940360118b0611d5c912a71c32a0100" translate="yes" xml:space="preserve">
          <source>Directives</source>
          <target state="translated">Directives</target>
        </trans-unit>
        <trans-unit id="ef7942184e9ad574a626b6cd3619cdb041e9c029" translate="yes" xml:space="preserve">
          <source>During this migration, use the &lt;a href=&quot;relay-compat&quot;&gt;Relay Compat&lt;/a&gt; tools and APIs to work with both Relay Classic and Relay Modern.</source>
          <target state="translated">Durante esta migraci&amp;oacute;n, use las herramientas y las API de &lt;a href=&quot;relay-compat&quot;&gt;Relay Compat&lt;/a&gt; para trabajar con Relay Classic y Relay Modern.</target>
        </trans-unit>
        <trans-unit id="7c5b3fea8b3510ceda05e64bba7877572b147261" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;RelayMutationTransaction&lt;/code&gt; has methods to check the status of the mutation and provide ways to rollback or resend the mutation as needed.</source>
          <target state="translated">Cada &lt;code&gt;RelayMutationTransaction&lt;/code&gt; tiene m&amp;eacute;todos para verificar el estado de la mutaci&amp;oacute;n y proporcionar formas de deshacer o reenviar la mutaci&amp;oacute;n seg&amp;uacute;n sea necesario.</target>
        </trans-unit>
        <trans-unit id="fbce231c1e8a474ca4ecbc6efb0b7e9a89704719" translate="yes" xml:space="preserve">
          <source>Edge creation and insertion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd362bb1462055d845230a17457c0b8e8d86a3b8" translate="yes" xml:space="preserve">
          <source>Either an instance of &lt;code&gt;Relay.Route&lt;/code&gt; or an object with the &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;queries&lt;/code&gt;, and optionally the &lt;code&gt;params&lt;/code&gt; properties.</source>
          <target state="translated">Ya sea una instancia de &lt;code&gt;Relay.Route&lt;/code&gt; o un objeto con el &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;queries&lt;/code&gt; y, opcionalmente, las propiedades &lt;code&gt;params&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d443a1185575c125d61e0af393b044d7b06ef572" translate="yes" xml:space="preserve">
          <source>Environment</source>
          <target state="translated">Environment</target>
        </trans-unit>
        <trans-unit id="b887632c87cffc81f6686f76c25016e576fb2182" translate="yes" xml:space="preserve">
          <source>Even though we have access to the &lt;code&gt;data&lt;/code&gt; object in &lt;code&gt;renderFetched&lt;/code&gt;, the actual data is intentionally opaque. This prevents the &lt;code&gt;renderFetched&lt;/code&gt; from creating an implicit dependency on the fragments declared by &lt;code&gt;Component&lt;/code&gt;.</source>
          <target state="translated">Aunque tenemos acceso al objeto de &lt;code&gt;data&lt;/code&gt; en &lt;code&gt;renderFetched&lt;/code&gt; , los datos reales son intencionalmente opacos. Esto evita que &lt;code&gt;renderFetched&lt;/code&gt; cree una dependencia impl&amp;iacute;cita en los fragmentos declarados por &lt;code&gt;Component&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="ee6ee8c5dded943d0aabd760c567c92f2ee1cb72" translate="yes" xml:space="preserve">
          <source>Example Data Flow: Fetching Query Data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54a85f686c00fd7f5967d3cbaebf03180ef14d5b" translate="yes" xml:space="preserve">
          <source>Example Data Flow: Reading and Observing the Store</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b92abde2e68af5a3c565dacca8e8cfd97caced5" translate="yes" xml:space="preserve">
          <source>Example of a simple mutation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="47edfe63fdfee7ee20d0d17ccd2198d126f5e61d" translate="yes" xml:space="preserve">
          <source>Examples on how to migrate &lt;code&gt;this.props.setVariables&lt;/code&gt; calls from the old API.</source>
          <target state="translated">Ejemplos sobre c&amp;oacute;mo migrar llamadas &lt;code&gt;this.props.setVariables&lt;/code&gt; desde la API antigua.</target>
        </trans-unit>
        <trans-unit id="dba94b198da2fb33fd23ea18f305f3d0a3ec1059" translate="yes" xml:space="preserve">
          <source>Extensible Core</source>
          <target state="translated">Núcleo extensible</target>
        </trans-unit>
        <trans-unit id="2dd50f5706aa755699729587eac1b10f1cff5f0e" translate="yes" xml:space="preserve">
          <source>FIELDS_CHANGE</source>
          <target state="translated">FIELDS_CHANGE</target>
        </trans-unit>
        <trans-unit id="48bf3bbfe2cde9b89a0197b2bfecef97b15ae5d4" translate="yes" xml:space="preserve">
          <source>Fetching Data</source>
          <target state="translated">Obtención de datos</target>
        </trans-unit>
        <trans-unit id="9fa4dbe72754c9ca8a7a48295981890f655e2aba" translate="yes" xml:space="preserve">
          <source>Fetching Data For a View</source>
          <target state="translated">Buscando datos para una vista</target>
        </trans-unit>
        <trans-unit id="ec6417097316a1a14f3a999d488c8c77877598bd" translate="yes" xml:space="preserve">
          <source>Fetching Data from the Server</source>
          <target state="translated">Obtención de datos del servidor</target>
        </trans-unit>
        <trans-unit id="a342eda81c049d657e5bd1f80671b4b62b62acba" translate="yes" xml:space="preserve">
          <source>Fetching all the data for a view hierarchy.</source>
          <target state="translated">Obteniendo todos los datos para una jerarquía de vistas.</target>
        </trans-unit>
        <trans-unit id="448b955ee10782eac37b116fa4e7872f8363dbf4" translate="yes" xml:space="preserve">
          <source>Fewer Requirements around Routing</source>
          <target state="translated">Menos requisitos para el enrutamiento</target>
        </trans-unit>
        <trans-unit id="90c0db66830e63b9ba0686e057e6915aaf66921d" translate="yes" xml:space="preserve">
          <source>Finally, GraphQL is printed (e.g. to files, saved to a database, etc) and any artifacts are generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c0e1cc40fccace9c870f52b415d915d429a858c" translate="yes" xml:space="preserve">
          <source>Finally, let's tie it all together in &lt;code&gt;./js/components/App.js&lt;/code&gt;:</source>
          <target state="translated">Finalmente, &lt;code&gt;./js/components/App.js&lt;/code&gt; todo en ./js/components/App.js :</target>
        </trans-unit>
        <trans-unit id="81320abd4244f533456ecdb31fa9235954b4c027" translate="yes" xml:space="preserve">
          <source>Finally, subscriptions whose data actually changed are notified via their callback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="794475575e8e8e88251415839f49042175570f60" translate="yes" xml:space="preserve">
          <source>Finally, we construct our schema (whose starting query type is the query type we defined above) and export it.</source>
          <target state="translated">Finalmente,construimos nuestro esquema (cuyo tipo de consulta inicial es el tipo de consulta que definimos anteriormente)y lo exportamos.</target>
        </trans-unit>
        <trans-unit id="f5d8e52e096ba49348c23c94d52fb5128a53fc82" translate="yes" xml:space="preserve">
          <source>Finds or creates a single record associated with a mutable record. This is a shortcut to &lt;code&gt;RelayRecordProxy.getLinkedRecord&lt;/code&gt; with &lt;code&gt;RelayRecordProxy.setLinkedRecord&lt;/code&gt; should the associated record be non-existant.</source>
          <target state="translated">Busca o crea un solo registro asociado con un registro mutable. Este es un acceso directo a &lt;code&gt;RelayRecordProxy.getLinkedRecord&lt;/code&gt; con &lt;code&gt;RelayRecordProxy.setLinkedRecord&lt;/code&gt; en caso de que el registro asociado no exista.</target>
        </trans-unit>
        <trans-unit id="d4726e1215a3598f0b285dcd1fdabf31356a5b5b" translate="yes" xml:space="preserve">
          <source>First, install the plugin (typically as a &lt;code&gt;devDependency&lt;/code&gt;):</source>
          <target state="translated">Primero, instale el complemento (generalmente como &lt;code&gt;devDependency&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="37434c70c94c9bba372cffd8d1a31c930d66efb8" translate="yes" xml:space="preserve">
          <source>First, let's take a look at a plain connection:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ee7304a030b3188f69053199e1aa24d2c7e6c40" translate="yes" xml:space="preserve">
          <source>First, let's take a look at the &lt;code&gt;environment&lt;/code&gt; input. To perform the mutation on the correct &lt;code&gt;environment&lt;/code&gt; with the relevant data, it's a good idea to use the &lt;code&gt;environment&lt;/code&gt; used to render the components. It's accessible at &lt;code&gt;this.props.relay.environment&lt;/code&gt; from the component.</source>
          <target state="translated">Primero, echemos un vistazo a la entrada del &lt;code&gt;environment&lt;/code&gt; . Para realizar la mutaci&amp;oacute;n en el &lt;code&gt;environment&lt;/code&gt; correcto con los datos relevantes, es una buena idea utilizar el &lt;code&gt;environment&lt;/code&gt; utilizado para representar los componentes. Es accesible en &lt;code&gt;this.props.relay.environment&lt;/code&gt; desde el componente.</target>
        </trans-unit>
        <trans-unit id="c30bc0a2078d4d797890b53dd71501499ca6f601" translate="yes" xml:space="preserve">
          <source>First, the list of data IDs that have changed since the last &lt;code&gt;notify()&lt;/code&gt; is compared against data IDs listed in the subscription's latest &lt;code&gt;Snapshot&lt;/code&gt;. If there is no overlap, the subscription's results cannot possibly have changed (if you imagine the graph visually, there is no overlap between the part of the graph that changed and the part that is selected). In this case the subscription is ignored, otherwise processing continues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3aab624101e00feee75c13777205ffcca8d11b0" translate="yes" xml:space="preserve">
          <source>First, you need &lt;a href=&quot;https://facebook.github.io/watchman&quot;&gt;watchman&lt;/a&gt; installed:</source>
          <target state="translated">Primero, necesita &lt;a href=&quot;https://facebook.github.io/watchman&quot;&gt;vigilante&lt;/a&gt; instalado:</target>
        </trans-unit>
        <trans-unit id="0a54de1cc9f2aff2bed1cf76593938b1ded20fcf" translate="yes" xml:space="preserve">
          <source>Flat Routes</source>
          <target state="translated">Rutas planas</target>
        </trans-unit>
        <trans-unit id="995180ea866af99054ca25768d4bd2ff5d5c8968" translate="yes" xml:space="preserve">
          <source>Flow Type Generation</source>
          <target state="translated">Generación del tipo de flujo</target>
        </trans-unit>
        <trans-unit id="6d01829e4505f8d6171af1d3b3cae8dab5a6ee84" translate="yes" xml:space="preserve">
          <source>Following our &lt;code&gt;TodoList_list&lt;/code&gt; example, we would pass arguments to the fragment like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c46edacfc204a583603ecb9b72b53c55f60dbc6a" translate="yes" xml:space="preserve">
          <source>For a complete example of how to load a &lt;code&gt;schema.js&lt;/code&gt; file, run the introspection query to get schema information, and save it to a JSON file, check out the &lt;a href=&quot;https://github.com/relayjs/relay-starter-kit/blob/master/scripts/updateSchema.js&quot;&gt;starter kit&lt;/a&gt;.</source>
          <target state="translated">Para obtener un ejemplo completo de c&amp;oacute;mo cargar un archivo &lt;code&gt;schema.js&lt;/code&gt; , ejecute la consulta de introspecci&amp;oacute;n para obtener informaci&amp;oacute;n del esquema y gu&amp;aacute;rdelo en un archivo JSON, consulte el &lt;a href=&quot;https://github.com/relayjs/relay-starter-kit/blob/master/scripts/updateSchema.js&quot;&gt;kit de inicio&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cfe4ba012b2b664f6e8a52e5430ca8b838d37291" translate="yes" xml:space="preserve">
          <source>For a simple application that's already a nice improvement.</source>
          <target state="translated">Por una simple aplicación que ya es una buena mejora.</target>
        </trans-unit>
        <trans-unit id="c72ede783eff4e07fb8b68b24df1f1f2ee6802eb" translate="yes" xml:space="preserve">
          <source>For connections like the above, &lt;code&gt;ConnectionHandler&lt;/code&gt; helps us find the record:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="889156520813e19bcd7a5e0e8e569875e2029955" translate="yes" xml:space="preserve">
          <source>For details on how to interact with the Relay Store, please refer to our Relay Store &lt;a href=&quot;relay-store&quot;&gt;docs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96c534ed5280cce92d6b2b0550da3496f193200e" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;rangeBehaviors&lt;/code&gt; could be written this way:</source>
          <target state="translated">Por ejemplo, &lt;code&gt;rangeBehaviors&lt;/code&gt; se podr&amp;iacute;a escribir de esta manera:</target>
        </trans-unit>
        <trans-unit id="4999f2258aff41aa7c828698a3d72fe291b86eb2" translate="yes" xml:space="preserve">
          <source>For example, a network layer can be a simple object that conforms to the interface:</source>
          <target state="translated">Por ejemplo,una capa de red puede ser un simple objeto que se ajusta a la interfaz:</target>
        </trans-unit>
        <trans-unit id="2aa5827894bb94d499f20a1d29faefe22d07cad1" translate="yes" xml:space="preserve">
          <source>For example, a user and their address might be represented as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5650972e3a1efbfc7e79658033f2f192552c13cb" translate="yes" xml:space="preserve">
          <source>For example, assuming the server schema &lt;code&gt;./schema.graphql&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ffcdf17f2ad817cd3da93a900284bc63c193056" translate="yes" xml:space="preserve">
          <source>For example, given the two files:</source>
          <target state="translated">Por ejemplo,dados los dos archivos:</target>
        </trans-unit>
        <trans-unit id="12bad1fdad02e0f5d5569bcccc232e7c8357d9c5" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;currentDate&lt;/code&gt; is set in &lt;code&gt;QueryRenderer&lt;/code&gt;&lt;code&gt;variables&lt;/code&gt;, then $currentDate may be referenced in any fragment included in the &lt;code&gt;QueryRenderer&lt;/code&gt;&lt;code&gt;query&lt;/code&gt;.</source>
          <target state="translated">Por ejemplo, si &lt;code&gt;currentDate&lt;/code&gt; se establece en &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;code&gt;variables&lt;/code&gt; QueryRenderer , entonces se puede hacer referencia a $ currentDate en cualquier fragmento incluido en la &lt;code&gt;query&lt;/code&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="384dd94e051eb1541d94fe85b1aa65cfc4b8720e" translate="yes" xml:space="preserve">
          <source>For example, let's redefine our &lt;code&gt;TodoList_list&lt;/code&gt; fragment to take some arguments using &lt;code&gt;@argumentDefinitions&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1178c99ccfd9629da7c347f69a733ccb2674242f" translate="yes" xml:space="preserve">
          <source>For examples of more complex optimistic updates, including adding and removing from a list, see the &lt;a href=&quot;https://github.com/relayjs/relay-examples/tree/master/todo&quot;&gt;Relay Modern Todo example app&lt;/a&gt;.</source>
          <target state="translated">Para ver ejemplos de actualizaciones optimistas m&amp;aacute;s complejas, incluida la adici&amp;oacute;n y eliminaci&amp;oacute;n de una lista, consulte la &lt;a href=&quot;https://github.com/relayjs/relay-examples/tree/master/todo&quot;&gt;aplicaci&amp;oacute;n de ejemplo Relay Modern Todo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a82abfdd90416cbeaffe64d3e50d78377188efce" translate="yes" xml:space="preserve">
          <source>For more complex use-cases, you may wish to perform custom logic to update Relay's in-memory cache when each subscription response is received. To do so, pass an &lt;code&gt;updater&lt;/code&gt; function:</source>
          <target state="translated">Para casos de uso m&amp;aacute;s complejos, es posible que desee realizar una l&amp;oacute;gica personalizada para actualizar el cach&amp;eacute; en memoria de Relay cuando se recibe cada respuesta de suscripci&amp;oacute;n. Para hacerlo, pase una funci&amp;oacute;n de &lt;code&gt;updater&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2ac9b5543bc0f49df0cfb3a851760d47fc555d44" translate="yes" xml:space="preserve">
          <source>For more complicated mutations, &lt;code&gt;optimisticUpdater&lt;/code&gt; and &lt;code&gt;updater&lt;/code&gt; can be the same function.</source>
          <target state="translated">Para mutaciones m&amp;aacute;s complicadas, &lt;code&gt;optimisticUpdater&lt;/code&gt; y &lt;code&gt;updater&lt;/code&gt; pueden tener la misma funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1137480158b92303f1522341248742d418f8a480" translate="yes" xml:space="preserve">
          <source>For more details on creating a Network, see the &lt;a href=&quot;network-layer&quot;&gt;NetworkLayer guide&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s detalles sobre la creaci&amp;oacute;n de una red, consulte la &lt;a href=&quot;network-layer&quot;&gt;gu&amp;iacute;a NetworkLayer&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a8624a85744c6bfa958d4ffba2ebcba068cf3d0" translate="yes" xml:space="preserve">
          <source>For more details, refer to the &lt;a href=&quot;local-state-management&quot;&gt;Local state management section&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1d4a5435c3cb6cdfd5a8c58ab671072ab888ff3" translate="yes" xml:space="preserve">
          <source>For more details, refer to the &lt;a href=&quot;persisted-queries&quot;&gt;Persisted Queries section&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf88bc6b3b6a4c187092ec351a5b1077c1d26272" translate="yes" xml:space="preserve">
          <source>For new Relay apps or existing apps that have been fully converted to the Compat API, the Relay Modern runtime can be enabled to activate even more features. In addition to those described above, this includes:</source>
          <target state="translated">En el caso de las nuevas aplicaciones de Relay o de las aplicaciones existentes que se han convertido completamente a la API de Compat,se puede activar el tiempo de ejecución de Relay Modern para activar aún más funciones.Además de las descritas anteriormente,esto incluye:</target>
        </trans-unit>
        <trans-unit id="d800dc29a67ae0f7e1c89e3fa88acf537112a2a4" translate="yes" xml:space="preserve">
          <source>For users of classic Relay, note that the runtime makes as few assumptions as possible about GraphQL. Compared to earlier versions of Relay there is no concept of routes, there are no limitations on mutation input arguments or side-effects, arbitrary root fields just work, etc. At present, the main restriction from classic Relay that remains is the use of the &lt;code&gt;Node&lt;/code&gt; interface and &lt;code&gt;id&lt;/code&gt; field for object identification. However there is no fundamental reason that this restriction can't be relaxed (there is a single place in the codebase where object identity is determined), and we welcome feedback from the community about ways to support customizable object identity without negatively impacting performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18fbf073a81951774f334f655935c2dac6e6377a" translate="yes" xml:space="preserve">
          <source>Force Fetching</source>
          <target state="translated">La atracción de la fuerza</target>
        </trans-unit>
        <trans-unit id="96bbe9b850cec5fbab27d61fde4b1fa63d06e24d" translate="yes" xml:space="preserve">
          <source>Force Fetching with Data from the Client</source>
          <target state="translated">La búsqueda de la fuerza con los datos del cliente</target>
        </trans-unit>
        <trans-unit id="bbba84135de6b052c2210e74e0cc5b2a9d359ddb" translate="yes" xml:space="preserve">
          <source>Found</source>
          <target state="translated">Found</target>
        </trans-unit>
        <trans-unit id="365b08de44008517ff803d0c36a644ac290dba44" translate="yes" xml:space="preserve">
          <source>Found offers integration with Relay Modern and Relay Classic via &lt;a href=&quot;https://github.com/4Catalyzer/found-relay&quot;&gt;Found Relay&lt;/a&gt;. Found Relay runs queries for matched routes in parallel, and supports fetching Relay data in parallel with downloading async bundles from code splitting when using Relay Modern.</source>
          <target state="translated">Found ofrece integraci&amp;oacute;n con Relay Modern y Relay Classic a trav&amp;eacute;s de &lt;a href=&quot;https://github.com/4Catalyzer/found-relay&quot;&gt;Found Relay&lt;/a&gt; . Found Relay ejecuta consultas para rutas coincidentes en paralelo y admite la obtenci&amp;oacute;n de datos de Relay en paralelo con la descarga de paquetes as&amp;iacute;ncronos de la divisi&amp;oacute;n de c&amp;oacute;digo cuando se usa Relay Modern.</target>
        </trans-unit>
        <trans-unit id="e58abca7c5abd6b02071e05687c03305e61f7adb" translate="yes" xml:space="preserve">
          <source>Fragment Composition</source>
          <target state="translated">Composición de los fragmentos</target>
        </trans-unit>
        <trans-unit id="44548256a4fe02219452b999f31774df4d7788f3" translate="yes" xml:space="preserve">
          <source>Fragment Container</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c9b8ee7dc2184d0aab89be194eb15b57be40cef" translate="yes" xml:space="preserve">
          <source>Fragment composition is achieved via ES6 template string interpolation and &lt;code&gt;getFragment&lt;/code&gt;:</source>
          <target state="translated">La composici&amp;oacute;n de los fragmentos se logra mediante la interpolaci&amp;oacute;n de cadenas de plantillas de ES6 y &lt;code&gt;getFragment&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="99eb0c4810611d5c803d75a7ca10220fd2d2cfea" translate="yes" xml:space="preserve">
          <source>Fragment composition works similarly &amp;mdash; a parent container's fragment composes the fragment for each of its children. In this case, &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; needs to fetch information about the &lt;code&gt;User&lt;/code&gt; that is required by &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">La composici&amp;oacute;n de fragmentos funciona de manera similar: el fragmento de un contenedor padre compone el fragmento para cada uno de sus hijos. En este caso, &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; necesita obtener informaci&amp;oacute;n sobre el &lt;code&gt;User&lt;/code&gt; requerida por &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2f68d40663d52153573dd0abe042e691b281b53" translate="yes" xml:space="preserve">
          <source>Fragment composition works similarly &amp;mdash; a parent container's fragment composes the fragment for each of its children. In this case, &lt;code&gt;&amp;lt;TodoList /&amp;gt;&lt;/code&gt; needs to fetch information about the &lt;code&gt;Todo&lt;/code&gt;s that are required by &lt;code&gt;&amp;lt;TodoItem /&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4c1ec38ec0f0411751ca1a7fa59d2e3f75e878a" translate="yes" xml:space="preserve">
          <source>Fragment composition works similarly &amp;mdash; a parent container's fragment composes the fragment for each of its children. In this case, &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; needs to fetch information about the &lt;code&gt;Todo&lt;/code&gt;s that are required by &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">La composici&amp;oacute;n de fragmentos funciona de manera similar: el fragmento de un contenedor padre compone el fragmento para cada uno de sus hijos. En este caso, &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; necesita obtener informaci&amp;oacute;n sobre los &lt;code&gt;Todo&lt;/code&gt; que son requeridos por &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a7eb65ef2204b222cba330bf9518e103ffff4a9" translate="yes" xml:space="preserve">
          <source>Fragment variables</source>
          <target state="translated">Las variables de los fragmentos</target>
        </trans-unit>
        <trans-unit id="6c4797fcf380c1ad929a06c044c27ce633b8a89b" translate="yes" xml:space="preserve">
          <source>FragmentContainer</source>
          <target state="translated">FragmentContainer</target>
        </trans-unit>
        <trans-unit id="e8e4adae3ec551af9e8edf80d04fd880f87f33b9" translate="yes" xml:space="preserve">
          <source>Fragments can be composed in one of two ways:</source>
          <target state="translated">Los fragmentos pueden estar compuestos de una de dos maneras:</target>
        </trans-unit>
        <trans-unit id="1ec5c60b97bf9a572f6951db4d37f812151af82e" translate="yes" xml:space="preserve">
          <source>Fragments can be embedded within other fragments or queries. For example, the above fragment could be used to fetch user &lt;code&gt;123&lt;/code&gt;'s profile photo:</source>
          <target state="translated">Los fragmentos se pueden incrustar dentro de otros fragmentos o consultas. Por ejemplo, el fragmento anterior podr&amp;iacute;a usarse para obtener la foto de perfil del usuario &lt;code&gt;123&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5749ddc88402f36f29ad8ff8b7fc5a5626b02527" translate="yes" xml:space="preserve">
          <source>Fragments may also compose other fragments that are assigned to local variables:</source>
          <target state="translated">Los fragmentos también pueden componer otros fragmentos que se asignan a variables locales:</target>
        </trans-unit>
        <trans-unit id="5b32b8542e4c8854b05455c0b114c2bdced713ad" translate="yes" xml:space="preserve">
          <source>Garbage Collection</source>
          <target state="translated">Recolección de basura</target>
        </trans-unit>
        <trans-unit id="202728ddee5584ce607f4aab869a3630ba743b82" translate="yes" xml:space="preserve">
          <source>Garbage collection to evict entries from the cache when they can no longer be referenced by any view.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13e8bde6a75cc8bafc18233096a72b0f6248985e" translate="yes" xml:space="preserve">
          <source>General-purpose tools for building a GraphQL schema using JavaScript</source>
          <target state="translated">Herramientas de propósito general para construir un esquema GraphQL usando JavaScript</target>
        </trans-unit>
        <trans-unit id="2b67d1eb9affe329c622f0576365f0ee268cf097" translate="yes" xml:space="preserve">
          <source>Gets a fragment reference for use in a parent's query fragment.</source>
          <target state="translated">Obtiene una referencia del fragmento para su uso en un fragmento de consulta de un padre.</target>
        </trans-unit>
        <trans-unit id="efadaa65e42a5128618d6d70d6e5f16a32ea9213" translate="yes" xml:space="preserve">
          <source>Gets a reference to a child container's fragment for inclusion in a parent fragment.</source>
          <target state="translated">Consigue una referencia al fragmento de un contenedor de un niño para su inclusión en un fragmento de un padre.</target>
        </trans-unit>
        <trans-unit id="bab08a8b8e5697e21edf5ba8471a6d2976e052d5" translate="yes" xml:space="preserve">
          <source>Gets a string name used to refer to this request for printing debug output.</source>
          <target state="translated">Obtiene un nombre de cadena usado para referirse a esta solicitud de impresión de salida de depuración.</target>
        </trans-unit>
        <trans-unit id="c66f9fff87afddb71ece32a2129c20b745b3303d" translate="yes" xml:space="preserve">
          <source>Gets a string representation of the GraphQL mutation.</source>
          <target state="translated">Obtiene una representación en cadena de la mutación GraphQL.</target>
        </trans-unit>
        <trans-unit id="f2fb6164e4d92fdf7bb9de20c1488df58f14ec49" translate="yes" xml:space="preserve">
          <source>Gets a string representation of the GraphQL query.</source>
          <target state="translated">Obtiene una representación en cadena de la consulta GraphQL.</target>
        </trans-unit>
        <trans-unit id="abe1bcf50d4649b6cc620e50d25b565688c7d9a1" translate="yes" xml:space="preserve">
          <source>Gets a unique identifier for this mutation. These identifiers are useful for assigning response payloads to their corresponding mutations when sent in a single GraphQL request.</source>
          <target state="translated">Consigue un identificador único para esta mutación.Estos identificadores son útiles para asignar cargas de respuesta a sus correspondientes mutaciones cuando se envían en una única solicitud GraphQL.</target>
        </trans-unit>
        <trans-unit id="96e072f6fa8b2d20b9da83302dbda948494674bf" translate="yes" xml:space="preserve">
          <source>Gets a unique identifier for this query. These identifiers are useful for assigning response payloads to their corresponding queries when sent in a single GraphQL request.</source>
          <target state="translated">Consigue un identificador único para esta consulta.Estos identificadores son útiles para asignar cargas de respuesta a sus consultas correspondientes cuando se envían en una única solicitud GraphQL.</target>
        </trans-unit>
        <trans-unit id="5406c8eaf62c01411092558cd572b43c5b89bfa6" translate="yes" xml:space="preserve">
          <source>Gets an optional map from name to File objects.</source>
          <target state="translated">Obtiene un mapa opcional del nombre a los objetos del archivo.</target>
        </trans-unit>
        <trans-unit id="1daf2e35612607247d326239b96ef7bd4c0deb13" translate="yes" xml:space="preserve">
          <source>Gets the type of the current record, as defined by the GraphQL schema.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ee3ecb0267703f60ff46d5ccfae9291bc39b826" translate="yes" xml:space="preserve">
          <source>Gets the value of a field in the current record given the field name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="118b9b0bfba623072bfed30c4a7c6d4b769ead2a" translate="yes" xml:space="preserve">
          <source>Gets the variables used by the mutation. These variables should be serialized and send in the GraphQL request.</source>
          <target state="translated">Obtiene las variables utilizadas por la mutación.Estas variables deben ser serializadas y enviar la solicitud de GraphQL.</target>
        </trans-unit>
        <trans-unit id="5f68839c1e374f581aaccfdd2584db85f5d5531a" translate="yes" xml:space="preserve">
          <source>Gets the variables used by the query. These variables should be serialized and sent in the GraphQL request.</source>
          <target state="translated">Obtiene las variables utilizadas por la consulta.Estas variables deben ser serializadas y enviadas en la solicitud de GraphQL.</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">Empezando</target>
        </trans-unit>
        <trans-unit id="76e7a3a3f9c225fe820ba7e9cff10ea2a73b79a1" translate="yes" xml:space="preserve">
          <source>Getting started</source>
          <target state="translated">Empezando...</target>
        </trans-unit>
        <trans-unit id="c50a651b10d01a7deafc80b4e09d60a50246f2f1" translate="yes" xml:space="preserve">
          <source>Given a &lt;code&gt;deletedIDFieldName&lt;/code&gt;, Relay will remove the node(s) from the store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d609f05a6d3bf2ce92708edc4808c22e3566e07f" translate="yes" xml:space="preserve">
          <source>Given a connection, deletes any edges whose id matches the given id.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d379af210d311a7a256db3fa6fe039dcbf2cbd54" translate="yes" xml:space="preserve">
          <source>Given a connection, inserts the edge at the beginning of the connection, or before the specified &lt;code&gt;cursor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bffc05ebf924c05ffda3d323c9605a38ad10f80" translate="yes" xml:space="preserve">
          <source>Given a connection, inserts the edge at the end of the connection, or after the specified &lt;code&gt;cursor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b19260759d77673b9a877795f157d4044253944" translate="yes" xml:space="preserve">
          <source>Given a connection, one or more DataIDs in the response payload, and a path between the parent and the connection, Relay will remove the node(s) from the connection but leave the associated record(s) in the store.</source>
          <target state="translated">Dada una conexión,uno o más DataIDs en la carga de respuesta,y una ruta entre el padre y la conexión,el Relevo eliminará el/los nodo(s)de la conexión pero dejará el/los registro(s)asociado(s)en el almacén.</target>
        </trans-unit>
        <trans-unit id="e48271c6488ce169319e6996a17416ab8db56489" translate="yes" xml:space="preserve">
          <source>Given a deletedIDFieldName, Relay will remove the node(s) from the connection.</source>
          <target state="translated">Si se le da un nombre de campo ID eliminado,el relé eliminará el nodo o los nodos de la conexión.</target>
        </trans-unit>
        <trans-unit id="720b1124168e2fcea493421f01efb6519477f619" translate="yes" xml:space="preserve">
          <source>Given a parent, &lt;code&gt;connectionKeys&lt;/code&gt;, one or more DataIDs in the response payload, and a path between the parent and the connection, Relay will remove the node(s) from the connection but leave the associated record(s) in the store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47de81551f168ce6aed9196d0adf126b977177b6" translate="yes" xml:space="preserve">
          <source>Given a parent, a connection, and one or more DataIDs in the response payload, Relay will remove the node(s) from the connection and delete the associated record(s) from the store.</source>
          <target state="translated">Si se le da un padre,una conexión y uno o más DataID en la carga de respuesta,el Relevo eliminará el/los nodo(s)de la conexión y borrará el/los registro(s)asociado(s)de la tienda.</target>
        </trans-unit>
        <trans-unit id="a51dc0bfb8bd3ee42a7194ed76f6218686158817" translate="yes" xml:space="preserve">
          <source>Given a parent, a connection, and the name of the newly created edge in the response payload Relay will add the node to the store and attach it to the connection according to the range behavior specified.</source>
          <target state="translated">Si se le da un padre,una conexión,y el nombre del borde recién creado en la carga útil de respuesta Relé añadirá el nodo a la tienda y lo adjuntará a la conexión de acuerdo con el comportamiento de rango especificado.</target>
        </trans-unit>
        <trans-unit id="524a22d3cb952e409df0e138141726ed755fe115" translate="yes" xml:space="preserve">
          <source>Given a parent, connectionKeys, one or more DataIDs in the response payload, and a path between the parent and the connection, Relay will remove the node(s) from the connection but leave the associated record(s) in the store.</source>
          <target state="translated">Si se le da un padre,las ConnectionKeys,uno o más DataIDs en la carga de respuesta,y una ruta entre el padre y la conexión,el Relevo eliminará el nodo o nodos de la conexión pero dejará el registro o registros asociados en el almacén.</target>
        </trans-unit>
        <trans-unit id="6c8602a6c8072fdb24f4522613cbc2f7cfcca2ed" translate="yes" xml:space="preserve">
          <source>Given a parent, information about the connection, and the name of the newly created edge in the response payload Relay will add the node to the store and attach it to the connection according to the range behavior(s) specified in the connectionInfo.</source>
          <target state="translated">Si se le da un padre,la información sobre la conexión y el nombre del borde recién creado en la carga útil de respuesta Relevador añadirá el nodo al almacén y lo adjuntará a la conexión de acuerdo con el comportamiento de rango especificado en la información de conexión.</target>
        </trans-unit>
        <trans-unit id="a9b1b0a91341253151fdb0d5e41db14af5ba2ef3" translate="yes" xml:space="preserve">
          <source>Given a record and a connection key, and optionally a set of filters, &lt;code&gt;getConnection&lt;/code&gt; retrieves a &lt;a href=&quot;#recordproxy&quot;&gt;&lt;code&gt;RecordProxy&lt;/code&gt;&lt;/a&gt; that represents a connection that was annotated with a &lt;code&gt;@connection&lt;/code&gt; directive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5933a7dc46c436f13a884a4a3f5f844894c6ee04" translate="yes" xml:space="preserve">
          <source>Given the GraphQL document:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d0fa81ee1013085b7d63ff166408f30527ff41a" translate="yes" xml:space="preserve">
          <source>Given the plain React component and a GraphQL fragment, we can now define a &lt;code&gt;Container&lt;/code&gt; to tell Relay about this component's data requirements. Let's look at the code first and then see what's happening:</source>
          <target state="translated">Dado el componente React simple y un fragmento GraphQL, ahora podemos definir un &lt;code&gt;Container&lt;/code&gt; para informar a Relay sobre los requisitos de datos de este componente. Veamos primero el c&amp;oacute;digo y luego veamos qu&amp;eacute; est&amp;aacute; sucediendo:</target>
        </trans-unit>
        <trans-unit id="78d8c89827c5602fc6d1d40331d005ddbc42de59" translate="yes" xml:space="preserve">
          <source>Given the plain React component and a GraphQL fragment, we can now define a Fragment Container to specify this component's data requirements. Let's look at the code first and then see what's happening:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e96a8e96d952292ce981325cfa1fcff52e52c7e" translate="yes" xml:space="preserve">
          <source>Given these real-world constraints, the approach in GraphQL is for clients to query for things that may change after a mutation. But what exactly do we put in that query? During the development of Relay we explored several ideas &amp;mdash; let's look at them briefly in order to understand why Relay uses the approach that it does:</source>
          <target state="translated">Dadas estas limitaciones del mundo real, el enfoque en GraphQL es que los clientes consulten cosas que pueden cambiar despu&amp;eacute;s de una mutaci&amp;oacute;n. Pero, &amp;iquest;qu&amp;eacute; ponemos exactamente en esa consulta? Durante el desarrollo de Relay, exploramos varias ideas; ve&amp;aacute;moslas brevemente para comprender por qu&amp;eacute; Relay utiliza el enfoque que utiliza:</target>
        </trans-unit>
        <trans-unit id="5c41e44eb6db12a7dd58862cf6f3cc1584c314eb" translate="yes" xml:space="preserve">
          <source>Globally invalidates the Relay store. This will cause any data that was written to the store before invalidation occurred to be considered stale, and will be considered to require refetch the next time a query is checked with &lt;code&gt;environment.check()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4eb1ab683c392399fa825b2dea3b7e5f8189912" translate="yes" xml:space="preserve">
          <source>GraphQL</source>
          <target state="translated">GraphQL</target>
        </trans-unit>
        <trans-unit id="d1104d2d1c77df98433b7b7cb498cfbba782bab4" translate="yes" xml:space="preserve">
          <source>GraphQL Relay Specification</source>
          <target state="translated">Especificación del relé de GraphQL</target>
        </trans-unit>
        <trans-unit id="2462160d86cfb1c5d092d0aa517b3b680333ccb3" translate="yes" xml:space="preserve">
          <source>GraphQL Schema</source>
          <target state="translated">Esquema GraphQL</target>
        </trans-unit>
        <trans-unit id="37f3b6a18cf42e1932e52d60a342d388f522602a" translate="yes" xml:space="preserve">
          <source>GraphQL Subscriptions &amp;amp; Live Queries</source>
          <target state="translated">Suscripciones a GraphQL y consultas en vivo</target>
        </trans-unit>
        <trans-unit id="55705029d139bf2fb4343a8dd5d01c514bb24b08" translate="yes" xml:space="preserve">
          <source>GraphQL in Relay</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6884fbda0403c3eb6a361b276df83698590e1779" translate="yes" xml:space="preserve">
          <source>GraphQL is designed to support a wide range of data access patterns. In order to understand the structure of an application's data, Relay requires that you follow certain conventions when defining your schema. These are documented in the &lt;a href=&quot;graphql-relay-specification&quot;&gt;GraphQL Relay Specification&lt;/a&gt;.</source>
          <target state="translated">GraphQL est&amp;aacute; dise&amp;ntilde;ado para admitir una amplia gama de patrones de acceso a datos. Para comprender la estructura de los datos de una aplicaci&amp;oacute;n, Relay requiere que siga ciertas convenciones al definir su esquema. Estos est&amp;aacute;n documentados en la &lt;a href=&quot;graphql-relay-specification&quot;&gt;Especificaci&amp;oacute;n de retransmisi&amp;oacute;n GraphQL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="55711b09c6616aea30b39a64a358b0d9490999c3" translate="yes" xml:space="preserve">
          <source>GraphQL presents new ways for clients to fetch data by focusing on the needs of product developers and client applications. It provides a way for developers to specify the precise data needed for a view and enables a client to fetch that data in a single network request. Compared to traditional approaches such as REST, GraphQL helps applications to fetch data more efficiently (compared to resource-oriented REST approaches) and avoid duplication of server logic (which can occur with custom endpoints). Furthermore, GraphQL helps developers to decouple product code and server logic. For example, a product can fetch more or less information without requiring a change to every relevant server endpoint. It's a great way to fetch data.</source>
          <target state="translated">GraphQL presenta nuevas formas para que los clientes obtengan datos centrándose en las necesidades de los desarrolladores de productos y las aplicaciones de los clientes.Proporciona una forma para que los desarrolladores especifiquen los datos precisos que se necesitan para una vista y permite a un cliente obtener esos datos en una sola solicitud de red.En comparación con los enfoques tradicionales como REST,GraphQL ayuda a las aplicaciones a obtener datos de manera más eficiente (en comparación con los enfoques REST orientados a los recursos)y a evitar la duplicación de la lógica del servidor (que puede ocurrir con los puntos finales personalizados).Además,GraphQL ayuda a los desarrolladores a disociar el código del producto y la lógica del servidor.Por ejemplo,un producto puede obtener más o menos información sin necesidad de cambiar cada uno de los puntos finales del servidor relevantes.Es una excelente manera de obtener datos.</target>
        </trans-unit>
        <trans-unit id="cd5d1ec7247a2826222f29ae64e2e192abb30c33" translate="yes" xml:space="preserve">
          <source>GraphQL provides a powerful tool for building efficient, decoupled client applications. Relay builds on this functionality to provide a framework for &lt;strong&gt;declarative data-fetching&lt;/strong&gt;. By separating &lt;em&gt;what&lt;/em&gt; data to fetch from &lt;em&gt;how&lt;/em&gt; it is fetched, Relay helps developers build applications that are robust, transparent, and performant by default. It's a great complement to the component-centric way of thinking championed by React. While each of these technologies &amp;mdash; React, Relay, and GraphQL &amp;mdash; are powerful on their own, the combination is a &lt;strong&gt;UI platform&lt;/strong&gt; that allows us to &lt;em&gt;move fast&lt;/em&gt; and &lt;em&gt;ship high-quality apps at scale&lt;/em&gt;.</source>
          <target state="translated">GraphQL proporciona una poderosa herramienta para crear aplicaciones cliente eficientes y desacopladas. Relay se basa en esta funcionalidad para proporcionar un marco para la &lt;strong&gt;obtenci&amp;oacute;n de datos declarativos&lt;/strong&gt; . Al separar &lt;em&gt;lo que&lt;/em&gt; los datos para ir a buscar a &lt;em&gt;la forma en&lt;/em&gt; que se capta, rel&amp;eacute; ayuda a los desarrolladores crear aplicaciones que son robustos, transparente y performant por defecto. Es un gran complemento para la forma de pensar centrada en componentes promovida por React. Si bien cada una de estas tecnolog&amp;iacute;as (React, Relay y GraphQL) son poderosas por s&amp;iacute; mismas, la combinaci&amp;oacute;n es una &lt;strong&gt;plataforma de interfaz de usuario&lt;/strong&gt; que nos permite &lt;em&gt;movernos r&amp;aacute;pido&lt;/em&gt; y &lt;em&gt;enviar aplicaciones de alta calidad a escala&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fe79f455fe739b1f1e04461fc0dc38be9fbb5f79" translate="yes" xml:space="preserve">
          <source>GraphQL text is extracted from source files and &quot;parsed&quot; into an intermediate representation (IR) using information from the schema.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e541828d19d4a8e98d359b78f14f53ce50019b3d" translate="yes" xml:space="preserve">
          <source>Here are a few examples of some of the included transforms:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4de18940b97877b6ff77ae9e81b1c868cf154cdc" translate="yes" xml:space="preserve">
          <source>Here are a quick example of adding a todo item to a Todo list using this &lt;a href=&quot;https://github.com/relayjs/relay-examples/blob/master/todo/data/schema.graphql#L36&quot;&gt;example schema&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1745637b6e7ac2208886e0fe73413f315dc1d52e" translate="yes" xml:space="preserve">
          <source>Here's a basic implementation of &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; that ignores styling in order to highlight the functionality:</source>
          <target state="translated">Aqu&amp;iacute; hay una implementaci&amp;oacute;n b&amp;aacute;sica de &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; que ignora el estilo para resaltar la funcionalidad:</target>
        </trans-unit>
        <trans-unit id="622275495084316cce6011efe3c5533f0b505dd1" translate="yes" xml:space="preserve">
          <source>Here's a basic implementation of &lt;code&gt;&amp;lt;TodoItem /&amp;gt;&lt;/code&gt; that ignores styling in order to highlight the functionality:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7acba2d971e69e956adf8a6ecc2371b0bf96df3" translate="yes" xml:space="preserve">
          <source>Here's a basic implementation of &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; that ignores styling in order to highlight the functionality:</source>
          <target state="translated">Aqu&amp;iacute; hay una implementaci&amp;oacute;n b&amp;aacute;sica de &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; que ignora el estilo para resaltar la funcionalidad:</target>
        </trans-unit>
        <trans-unit id="dbbbbf44b31cd11738f96ef61375f12e9722988b" translate="yes" xml:space="preserve">
          <source>Here's an example of this mutation in use by a &lt;code&gt;LikeButton&lt;/code&gt; component:</source>
          <target state="translated">Aqu&amp;iacute; hay un ejemplo de esta mutaci&amp;oacute;n en uso por un componente &lt;code&gt;LikeButton&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="385d7c0cfbb336e0125f7ea51dde1cd3078887da" translate="yes" xml:space="preserve">
          <source>Here's an example query that fetches a story's text and its author's name:</source>
          <target state="translated">Aquí hay un ejemplo de consulta que busca el texto de una historia y el nombre de su autor:</target>
        </trans-unit>
        <trans-unit id="0694e515f41dabfcc348f2df0677999ef99af1ea" translate="yes" xml:space="preserve">
          <source>Here's what happens when the container is rendered:</source>
          <target state="translated">Esto es lo que sucede cuando el contenedor se desecha:</target>
        </trans-unit>
        <trans-unit id="2284d040f5091f510de37a154536196310f9c02d" translate="yes" xml:space="preserve">
          <source>Hint</source>
          <target state="translated">Hint</target>
        </trans-unit>
        <trans-unit id="05531ed7907681dd3a6ac4e94e82348c1af49264" translate="yes" xml:space="preserve">
          <source>Historically, Relay started out internally at Facebook as a routing framework. However, Relay no longer makes any assumptions about routing, and works with a variety of routing options.</source>
          <target state="translated">Históricamente,Relay comenzó internamente en Facebook como un marco de enrutamiento.Sin embargo,Relay ya no hace ninguna suposición sobre el enrutamiento,y trabaja con una variedad de opciones de enrutamiento.</target>
        </trans-unit>
        <trans-unit id="f96c9aa85d59b7983b33495b149e7fee5f7bf418" translate="yes" xml:space="preserve">
          <source>Hm. There were no more ships; guess there were only five in the system for the rebels. It would have been nice to know that we'd reached the end of the connection, without having to do another round trip in order to verify that. The connection model exposes this capability with a type called &lt;code&gt;PageInfo&lt;/code&gt;. So let's issue the two queries that got us ships again, but this time ask for &lt;code&gt;hasNextPage&lt;/code&gt;:</source>
          <target state="translated">Hm. No hab&amp;iacute;a m&amp;aacute;s barcos; Supongo que solo hab&amp;iacute;a cinco en el sistema para los rebeldes. Hubiera sido bueno saber que hab&amp;iacute;amos llegado al final de la conexi&amp;oacute;n, sin tener que hacer otro viaje de ida y vuelta para verificarlo. El modelo de conexi&amp;oacute;n expone esta capacidad con un tipo llamado &lt;code&gt;PageInfo&lt;/code&gt; . As&amp;iacute; que &lt;code&gt;hasNextPage&lt;/code&gt; las dos consultas que nos consiguieron env&amp;iacute;os de nuevo, pero esta vez pidamos hasNextPage :</target>
        </trans-unit>
        <trans-unit id="c2d977e2354e1f199b20eba8fe4202828b60baf5" translate="yes" xml:space="preserve">
          <source>However components using the Relay Modern API (&lt;code&gt;'react-relay'&lt;/code&gt;) and the Relay Classic API (&lt;code&gt;'react-relay/classic'&lt;/code&gt;) cannot be used with each other.</source>
          <target state="translated">Sin embargo, los componentes que utilizan la API Relay Modern ( &lt;code&gt;'react-relay'&lt;/code&gt; ) y la API Relay Classic ( &lt;code&gt;'react-relay/classic'&lt;/code&gt; ) no se pueden usar entre s&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="502eeb0d2871522e994df777d19577771dfe2094" translate="yes" xml:space="preserve">
          <source>However the Relay Compiler also automatically generates &lt;a href=&quot;https://flow.org&quot;&gt;Flow&lt;/a&gt; types as &lt;a href=&quot;https://flow.org/en/docs/types/comments/&quot;&gt;type comments&lt;/a&gt;. For example, you can import the generated Flow types like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f6bd5564a2d8d3eed39f5285b27795de9e86379" translate="yes" xml:space="preserve">
          <source>However the Relay Compiler also automatically generates flow types, as &lt;a href=&quot;https://flow.org/en/docs/types/comments/&quot;&gt;type comments&lt;/a&gt;. To import the types:</source>
          <target state="translated">Sin embargo, el Relay Compiler tambi&amp;eacute;n genera autom&amp;aacute;ticamente tipos de flujo, como &lt;a href=&quot;https://flow.org/en/docs/types/comments/&quot;&gt;comentarios de tipo&lt;/a&gt; . Para importar los tipos:</target>
        </trans-unit>
        <trans-unit id="10b177310affbe7aa4dd35d3f040c504f1597c28" translate="yes" xml:space="preserve">
          <source>However, Relay Modern expects modern JavaScript global types (&lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Promise&lt;/code&gt;, &lt;code&gt;Object.assign&lt;/code&gt;) to be defined. If you support older browsers and devices which may not yet provide these natively, consider including a global polyfill in your bundled application, such as &lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt; or &lt;a href=&quot;https://babeljs.io/docs/usage/polyfill/&quot;&gt;babel-polyfill&lt;/a&gt;.</source>
          <target state="translated">Sin embargo, Relay Modern espera que se definan los tipos globales de JavaScript modernos ( &lt;code&gt;Map&lt;/code&gt; , &lt;code&gt;Set&lt;/code&gt; , &lt;code&gt;Promise&lt;/code&gt; , &lt;code&gt;Object.assign&lt;/code&gt; ). Si admite navegadores y dispositivos m&amp;aacute;s antiguos que es posible que a&amp;uacute;n no los proporcionen de forma nativa, considere incluir un polyfill global en su aplicaci&amp;oacute;n incluida, como &lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt; o &lt;a href=&quot;https://babeljs.io/docs/usage/polyfill/&quot;&gt;babel-polyfill&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e508d49142051371922e56dda4689dd05e8567d5" translate="yes" xml:space="preserve">
          <source>However, a &lt;code&gt;QueryRenderer&lt;/code&gt; will not start loading its data until it is mounted, so nested &lt;code&gt;QueryRenderer&lt;/code&gt; components can lead to request waterfalls if used unnecessarily.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44a07f8e11c88d99ebfa0ba8926d9d2bf8daec90" translate="yes" xml:space="preserve">
          <source>However, the fragment could also fetch each of user &lt;code&gt;123&lt;/code&gt;'s friends' profile photos:</source>
          <target state="translated">Sin embargo, el fragmento tambi&amp;eacute;n podr&amp;iacute;a recuperar cada una de las fotos de perfil de los amigos del usuario &lt;code&gt;123&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a72518acd301cccb79e4d618aa2b5df43d443663" translate="yes" xml:space="preserve">
          <source>However, when &lt;a href=&quot;#createpaginationcontainer&quot;&gt;specifying connection fragments&lt;/a&gt; for a Pagination Container, it is expected that at least one of the fragments contains a &lt;a href=&quot;https://relay.dev/graphql/connections.htm&quot;&gt;GraphQL connection&lt;/a&gt; to paginate over, and that the connection field is annotated with a &lt;code&gt;@connection&lt;/code&gt; directive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd69a4732fe12702d5ff5838852eb29e4a9e2e02" translate="yes" xml:space="preserve">
          <source>Idea</source>
          <target state="translated">Idea</target>
        </trans-unit>
        <trans-unit id="0daab153956ffb0745c3d2cf4823ed87bf8cdc9f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;optimisticResponse&lt;/code&gt; is provided, Relay will use it to update the fields under the records as specified by the ids in the &lt;code&gt;optimisticResponse&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e63eef54ae07ad9832be86ae57e57b86e1543dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;optimisticUpdater&lt;/code&gt; is provided, Relay will execute it and update the store accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bd280c6059870c93a4668954d90f25f6c6ff4e2" translate="yes" xml:space="preserve">
          <source>If a &quot;force fetch&quot; occurs and there is insufficient data on the client, the same behavior as &lt;strong&gt;Fetching Data from the Server&lt;/strong&gt; can be expected. However, if a &quot;force fetch&quot; occurs and there &lt;em&gt;is&lt;/em&gt; sufficient data on the client to render, we can expect the following behavior:</source>
          <target state="translated">Si se produce una &quot;b&amp;uacute;squeda forzada&quot; y no hay datos suficientes en el cliente, se puede esperar el mismo comportamiento que &lt;strong&gt;Obtenci&amp;oacute;n de datos del servidor&lt;/strong&gt; . Sin embargo, si una &quot;fuerza fetch&quot; se produce y no &lt;em&gt;es&lt;/em&gt; suficientes datos sobre el cliente para rendir, podemos esperar el siguiente comportamiento:</target>
        </trans-unit>
        <trans-unit id="7ed138709fbda62e44a180d5f323c654e6cc766a" translate="yes" xml:space="preserve">
          <source>If a fragment uses variables that are determined at runtime, &lt;a href=&quot;#note-determining-variable-values-at-runtime&quot;&gt;see below&lt;/a&gt;.</source>
          <target state="translated">Si un fragmento utiliza variables determinadas en tiempo de ejecuci&amp;oacute;n, &lt;a href=&quot;#note-determining-variable-values-at-runtime&quot;&gt;consulte a continuaci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c5dc5ba510b8cc7e8340243c616a8461f6de45a" translate="yes" xml:space="preserve">
          <source>If a server request results in a failure to load data, we can expect the following behavior:</source>
          <target state="translated">Si una solicitud de servidor resulta en una falla en la carga de datos,podemos esperar el siguiente comportamiento:</target>
        </trans-unit>
        <trans-unit id="c11a40394f41454ad18de679c37d7363316ff63c" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;updater&lt;/code&gt; was provided, Relay will execute it and update the store accordingly. The server payload will be available to the &lt;code&gt;updater&lt;/code&gt; as a root field in the store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="500f13b73830f97ef3d0785c40a8e9be8e6865fb" translate="yes" xml:space="preserve">
          <source>If an error occurs that prevents &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; from fetching the data required for rendering &lt;code&gt;Component&lt;/code&gt;, nothing will be rendered by default. Error handling behavior can be configured by supplying a callback to the &lt;code&gt;renderFailure&lt;/code&gt; prop:</source>
          <target state="translated">Si ocurre un error que impide que &lt;strong&gt;Relay.RootContainer obtenga&lt;/strong&gt; los datos necesarios para renderizar &lt;code&gt;Component&lt;/code&gt; , no se renderizar&amp;aacute; nada por defecto. El comportamiento de manejo de errores se puede configurar proporcionando una devoluci&amp;oacute;n de llamada a la propiedad &lt;code&gt;renderFailure&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e4eb5b8214d4c82b80af57f3c1c0471dea0d3c7b" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;Component&lt;/code&gt; or &lt;code&gt;route&lt;/code&gt; ever changes, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; will immediately start attempting to fulfill the new data requirements.</source>
          <target state="translated">Si alguna vez cambia el &lt;code&gt;Component&lt;/code&gt; o la &lt;code&gt;route&lt;/code&gt; , &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; comenzar&amp;aacute; inmediatamente a intentar cumplir con los nuevos requisitos de datos.</target>
        </trans-unit>
        <trans-unit id="e7c4473f87af75e4695d24734fbf44e9808a4049" translate="yes" xml:space="preserve">
          <source>If insufficient data on the client leads Relay to send a server request for more data, we can expect the following behavior:</source>
          <target state="translated">Si la insuficiencia de datos sobre el cliente lleva a Relay a enviar una solicitud al servidor para obtener más datos,podemos esperar el siguiente comportamiento:</target>
        </trans-unit>
        <trans-unit id="e7125117da9f12ab4891151c4ede73bbfc431ad0" translate="yes" xml:space="preserve">
          <source>If no request is in flight pendingVariables is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Si no hay ninguna solicitud pendiente, la variable es &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e94ccf62b4c7fbeeff1884ed8210524c0aaf3f8f" translate="yes" xml:space="preserve">
          <source>If not supplied, a unique collision key is derived (meaning that the created mutation will be independent and not collide with any other).</source>
          <target state="translated">Si no se suministra,se deriva una clave de colisión única (lo que significa que la mutación creada será independiente y no colisionará con ninguna otra).</target>
        </trans-unit>
        <trans-unit id="9f1093c79885887f1a46e11c2dbc9de6bfd2239c" translate="yes" xml:space="preserve">
          <source>If sufficient data is available on the client such that Relay does not need to send a server request, we can expect the following behavior:</source>
          <target state="translated">Si se dispone de suficientes datos sobre el cliente de tal manera que el Relevo no necesite enviar una solicitud al servidor,podemos esperar el siguiente comportamiento:</target>
        </trans-unit>
        <trans-unit id="1753e3219d9e6a6f6bf62bc19a7f313caa79226f" translate="yes" xml:space="preserve">
          <source>If supplied and set to true, a request for data will always be made to the server regardless of whether data on the client is available already.</source>
          <target state="translated">Si se suministra y se establece como verdadero,siempre se hará una solicitud de datos al servidor,independientemente de si los datos del cliente ya están disponibles.</target>
        </trans-unit>
        <trans-unit id="b8cb57719ab0a4774595aab7b466840e3a324de3" translate="yes" xml:space="preserve">
          <source>If supplied and set to true, a request for data will always be made to the server regardless of whether data on the client is available to immediately fulfill the data requirements.</source>
          <target state="translated">Si se suministra y se establece como verdadero,siempre se hará una solicitud de datos al servidor,independientemente de si los datos del cliente están disponibles para cumplir inmediatamente con los requisitos de datos.</target>
        </trans-unit>
        <trans-unit id="9652265c2b29a20de6e20099f7748481a1d4b122" translate="yes" xml:space="preserve">
          <source>If the Relay part of an application is some widget or single view as part of a larger application, you don't need any routing. You can just render a &lt;code&gt;QueryRenderer&lt;/code&gt; somewhere on the page to fetch and render the data you need there. This option is simple and should be used when sufficient.</source>
          <target state="translated">Si la parte de retransmisi&amp;oacute;n de una aplicaci&amp;oacute;n es un widget o una vista &amp;uacute;nica como parte de una aplicaci&amp;oacute;n m&amp;aacute;s grande, no necesita ning&amp;uacute;n enrutamiento. Puede representar un &lt;code&gt;QueryRenderer&lt;/code&gt; en alg&amp;uacute;n lugar de la p&amp;aacute;gina para obtener y representar los datos que necesita all&amp;iacute;. Esta opci&amp;oacute;n es simple y debe usarse cuando sea suficiente.</target>
        </trans-unit>
        <trans-unit id="9c687f957f6123e9a6702a53723c6fbcdd75a426" translate="yes" xml:space="preserve">
          <source>If the callback returns &lt;code&gt;undefined&lt;/code&gt;, the previously rendered view (or nothing if there is no previous view) is rendered (e.g. when transitioning from one &lt;code&gt;queryConfig&lt;/code&gt; to another).</source>
          <target state="translated">Si la devoluci&amp;oacute;n de llamada devuelve &lt;code&gt;undefined&lt;/code&gt; , la vista renderizada anteriormente (o nada si no hay una vista previa) se renderiza (por ejemplo, al pasar de una &lt;code&gt;queryConfig&lt;/code&gt; a otra).</target>
        </trans-unit>
        <trans-unit id="fa97f983a844f15bf5a18032a6bd22f04fd47eea" translate="yes" xml:space="preserve">
          <source>If the component doesn't actually use &lt;code&gt;setVariables()&lt;/code&gt;, and just uses &lt;code&gt;initialVariables&lt;/code&gt; to share values between JS and GraphQL, there are two alternative approaches:</source>
          <target state="translated">Si el componente no usa realmente &lt;code&gt;setVariables()&lt;/code&gt; y solo usa &lt;code&gt;initialVariables&lt;/code&gt; para compartir valores entre JS y GraphQL, existen dos enfoques alternativos:</target>
        </trans-unit>
        <trans-unit id="6f707589cc2da01315091844b3b383efdccb634c" translate="yes" xml:space="preserve">
          <source>If the mutation defines an optimistic payload - a set of data to apply locally while waiting for the server response - Relay applies this change and updates any affected React components (note that optimistic updates do not overwrite known server data in the cache).</source>
          <target state="translated">Si la mutación define una carga útil optimista-un conjunto de datos para aplicar localmente mientras se espera la respuesta del servidor-el Relevo aplica este cambio y actualiza cualquier componente de React afectado (tenga en cuenta que las actualizaciones optimistas no sobrescriben los datos conocidos del servidor en la caché).</target>
        </trans-unit>
        <trans-unit id="9d815af768aaeea304d01b0f060f4bcc34f6f6e5" translate="yes" xml:space="preserve">
          <source>If the mutation would not 'collide' (overlap) with other pending mutations - as specified by its &lt;code&gt;getCollisionKey&lt;/code&gt; implementation - it is sent to the server. If it would conflict, it is enqueued until conflicting mutations have completed.</source>
          <target state="translated">Si la mutaci&amp;oacute;n no 'choca' (se superpone) con otras mutaciones pendientes, seg&amp;uacute;n lo especificado por su implementaci&amp;oacute;n &lt;code&gt;getCollisionKey&lt;/code&gt; , se env&amp;iacute;a al servidor. Si entra en conflicto, se pone en cola hasta que se hayan completado las mutaciones en conflicto.</target>
        </trans-unit>
        <trans-unit id="e86698a9dbbdbb49974d25aeca449ae1fbb9e654" translate="yes" xml:space="preserve">
          <source>If the render callback is not supplied, the default behavior is to render the container if data is available, the existing view if one exists, or nothing.</source>
          <target state="translated">Si no se suministra la devolución de llamada de renderizado,el comportamiento por defecto es renderizar el contenedor si hay datos disponibles,la vista existente si existe,o nada.</target>
        </trans-unit>
        <trans-unit id="1a73cc6d4c2d46fb79932c374ed9da299d065e97" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; suffix, the &lt;code&gt;data&lt;/code&gt; prop name will be used:</source>
          <target state="translated">Si no hay un sufijo &lt;code&gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; , se utilizar&amp;aacute; el nombre de la propiedad de &lt;code&gt;data&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="62768ad0f3d9c4db4330d79d61d8599e64fd7a9c" translate="yes" xml:space="preserve">
          <source>If we do the same thing with the Empire, we'll find that it returns a different ID, and we can refetch it as well:</source>
          <target state="translated">Si hacemos lo mismo con el Imperio,descubriremos que devuelve una identificación diferente,y podemos volver a buscarla también:</target>
        </trans-unit>
        <trans-unit id="62f00a1501647642fb670b9befaa1fb2d5b19d8f" translate="yes" xml:space="preserve">
          <source>If we provide to a mutation a method that conforms to the signature described above, it will be given the opportunity to modify the fragment builders' variables, based on the previous variables (or the &lt;code&gt;initialVariables&lt;/code&gt; if no previous ones exist), the meta route, and the runtime environment. Whatever variables this method returns will become available to this mutation's fragment builders.</source>
          <target state="translated">Si proporcionamos a una mutaci&amp;oacute;n un m&amp;eacute;todo que se ajuste a la firma descrita anteriormente, se le dar&amp;aacute; la oportunidad de modificar las variables de los constructores de fragmentos, en base a las variables anteriores (o las variables &lt;code&gt;initialVariables&lt;/code&gt; si no existen), la meta ruta, y el entorno de ejecuci&amp;oacute;n. Cualquier variable que devuelva este m&amp;eacute;todo estar&amp;aacute; disponible para los constructores de fragmentos de esta mutaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="29d042cd073944a1316b1c84fe494fc214ee7caa" translate="yes" xml:space="preserve">
          <source>If we replace &lt;code&gt;2&lt;/code&gt; with a new immutable record, we'll also get a new immutable instance of the cache object. However, records &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; are untouched. Because the data is normalized, we can't tell that &lt;code&gt;story&lt;/code&gt;'s contents have changed just by looking at the &lt;code&gt;story&lt;/code&gt; record alone.</source>
          <target state="translated">Si reemplazamos &lt;code&gt;2&lt;/code&gt; con un nuevo registro inmutable, tambi&amp;eacute;n obtendremos una nueva instancia inmutable del objeto de cach&amp;eacute;. Sin embargo, los registros &lt;code&gt;1&lt;/code&gt; y &lt;code&gt;3&lt;/code&gt; no se modifican. Debido a que los datos est&amp;aacute;n normalizados, no podemos decir que el contenido de la &lt;code&gt;story&lt;/code&gt; ha cambiado con solo mirar el registro de la &lt;code&gt;story&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3442e671845ad2d6f63d621dcbdd2a0032b009d1" translate="yes" xml:space="preserve">
          <source>If we wanted to create an instance of this route for arbitrary users, we can subclass the &lt;code&gt;Relay.Route&lt;/code&gt; abstract class. &lt;code&gt;Relay.Route&lt;/code&gt; makes it easy to define a set of queries and required parameters to be re-used multiple times:</source>
          <target state="translated">Si quisi&amp;eacute;ramos crear una instancia de esta ruta para usuarios arbitrarios, podemos crear una subclase de la clase abstracta &lt;code&gt;Relay.Route&lt;/code&gt; . &lt;code&gt;Relay.Route&lt;/code&gt; facilita la definici&amp;oacute;n de un conjunto de consultas y par&amp;aacute;metros necesarios para ser reutilizados varias veces:</target>
        </trans-unit>
        <trans-unit id="1e290d52905763c30ab6c18d70c7f5a099e17ab8" translate="yes" xml:space="preserve">
          <source>If you do decide to use an &lt;code&gt;optimisticUpdater&lt;/code&gt;, often times it can be the same function as &lt;code&gt;updater&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf233e85c6ba7e3a45e4100d4c2cae37e5ec06e0" translate="yes" xml:space="preserve">
          <source>If you find you need to do something unique (like generate types that conform to an older version of Flow, or to parse non-javascript source files), you can build your own version of the Compiler by swapping in your own &lt;code&gt;FileWriter&lt;/code&gt; and &lt;code&gt;ASTCache&lt;/code&gt;, or by adding on an additional &lt;code&gt;IRTransform&lt;/code&gt;. Note, the internal APIs of the &lt;code&gt;RelayCompiler&lt;/code&gt; are under constant iteration, so rolling your own version may lead to incompatibilities with future releases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b62113e72e08231a01f5d4a07e448ee27964d21" translate="yes" xml:space="preserve">
          <source>If you find you need to do something unique (like generate types that conform to an older version of flow, or to parse non-javascript source files), you can build your own version of the Compiler by swapping in your own &lt;code&gt;FileWriter&lt;/code&gt; and &lt;code&gt;ASTCache&lt;/code&gt;, or by adding on an additional &lt;code&gt;IRTransform&lt;/code&gt;. Note, the internal APIs of the &lt;code&gt;RelayCompiler&lt;/code&gt; are under constant iteration, so rolling your own version may lead to incompatibilities with future releases.</source>
          <target state="translated">Si encuentra que necesita hacer algo &amp;uacute;nico (como generar tipos que se ajusten a una versi&amp;oacute;n anterior de flujo o analizar archivos fuente que no sean de JavaScript), puede crear su propia versi&amp;oacute;n del compilador intercambiando su propio &lt;code&gt;FileWriter&lt;/code&gt; y &lt;code&gt;ASTCache&lt;/code&gt; , o agregando un &lt;code&gt;IRTransform&lt;/code&gt; adicional . Tenga en cuenta que las API internas de &lt;code&gt;RelayCompiler&lt;/code&gt; est&amp;aacute;n en constante iteraci&amp;oacute;n, por lo que lanzar su propia versi&amp;oacute;n puede generar incompatibilidades con versiones futuras.</target>
        </trans-unit>
        <trans-unit id="7224441b6f15886cd449f3742b23181788ee9b99" translate="yes" xml:space="preserve">
          <source>If you wish to provide your own &lt;code&gt;handlerProvider&lt;/code&gt;, you can do so:</source>
          <target state="translated">Si desea proporcionar su propio &lt;code&gt;handlerProvider&lt;/code&gt; , puede hacerlo:</target>
        </trans-unit>
        <trans-unit id="49a21b30f5b3a1b121343f35b747fe542d51dbf3" translate="yes" xml:space="preserve">
          <source>If you're using &lt;code&gt;createRefetchContainer&lt;/code&gt; then your &lt;code&gt;refetch&lt;/code&gt; method may also update these variables to render with new values.</source>
          <target state="translated">Si est&amp;aacute; utilizando &lt;code&gt;createRefetchContainer&lt;/code&gt; , su m&amp;eacute;todo de &lt;code&gt;refetch&lt;/code&gt; tambi&amp;eacute;n puede actualizar estas variables para representar con nuevos valores.</target>
        </trans-unit>
        <trans-unit id="0ccc0940cec44b44c366f2d98c395662eb2f306c" translate="yes" xml:space="preserve">
          <source>If you're using a different GraphQL server implementation, we recommend adapting the above example to load the schema from your GraphQL server (e.g. via an HTTP request) and then save the result as JSON.</source>
          <target state="translated">Si está utilizando una implementación diferente del servidor GraphQL,le recomendamos que adapte el ejemplo anterior para cargar el esquema desde su servidor GraphQL (por ejemplo,a través de una solicitud HTTP)y luego guardar el resultado como JSON.</target>
        </trans-unit>
        <trans-unit id="2e76567f0db1f25cdaed090474feff64180bb110" translate="yes" xml:space="preserve">
          <source>Imagine we have a simple application that fetches a list of stories, and some details about each one. Here's how that might look in resource-oriented REST:</source>
          <target state="translated">Imagina que tenemos una simple aplicación que obtiene una lista de historias,y algunos detalles sobre cada una de ellas.Así es como se vería en el REST orientado a los recursos:</target>
        </trans-unit>
        <trans-unit id="448e3d99f5bde0fa9efac34be83b204ae98c345a" translate="yes" xml:space="preserve">
          <source>Implement this method in cases where the mutator configuration needed to handle the optimistic response needs to be different than the one that handles the server response.</source>
          <target state="translated">Implementar este método en los casos en que la configuración del mutador necesaria para manejar la respuesta optimista debe ser diferente de la que maneja la respuesta del servidor.</target>
        </trans-unit>
        <trans-unit id="62181f13d4fff5bed161f01ef77d8db655301bec" translate="yes" xml:space="preserve">
          <source>Implement this method to craft an optimistic response having the same shape as the server response payload. This optimistic response will be used to preemptively update the client cache before the server returns, giving the impression that the mutation completed instantaneously.</source>
          <target state="translated">Implementar este método para crear una respuesta optimista que tenga la misma forma que la carga de respuesta del servidor.Esta respuesta optimista se utilizará para actualizar preventivamente el caché del cliente antes de que regrese el servidor,dando la impresión de que la mutación se completó instantáneamente.</target>
        </trans-unit>
        <trans-unit id="24bc32f306fba32d2cbf91f2cd1999f36a16435a" translate="yes" xml:space="preserve">
          <source>Implement this method to return a collision key. Relay will send any mutations having the same collision key to the server serially and in-order.</source>
          <target state="translated">Implementar este método para devolver una llave de colisión.El relé enviará cualquier mutación que tenga la misma clave de colisión al servidor en serie y en orden.</target>
        </trans-unit>
        <trans-unit id="1e3fee95e387e2e4175f4c37de616bb736c7491c" translate="yes" xml:space="preserve">
          <source>Implement this method to return a map of &lt;code&gt;File&lt;/code&gt; objects to upload as part of a mutation.</source>
          <target state="translated">Implemente este m&amp;eacute;todo para devolver un mapa de objetos &lt;code&gt;File&lt;/code&gt; para cargar como parte de una mutaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="48d0a56a8bcb298a554f5516aac54d6f77d81acd" translate="yes" xml:space="preserve">
          <source>Implement this method to return true when the supplied options are supported by this network layer. This is used to declare which features the network layer supports.</source>
          <target state="translated">Implementar este método para que vuelva a ser cierto cuando las opciones suministradas sean soportadas por esta capa de red.Esto se utiliza para declarar qué características soporta la capa de red.</target>
        </trans-unit>
        <trans-unit id="b153e451079dd8470ac1e1681b4c8e4668b52b86" translate="yes" xml:space="preserve">
          <source>Implement this method to send mutations to the server. When the server response is obtained, this method must either call &lt;code&gt;mutationRequest.resolve&lt;/code&gt; with the response data, or &lt;code&gt;mutationRequest.reject&lt;/code&gt; with an &lt;code&gt;Error&lt;/code&gt; object.</source>
          <target state="translated">Implemente este m&amp;eacute;todo para enviar mutaciones al servidor. Cuando se obtiene la respuesta del servidor, este m&amp;eacute;todo debe llamar a &lt;code&gt;mutationRequest.resolve&lt;/code&gt; con los datos de respuesta, o &lt;code&gt;mutationRequest.reject&lt;/code&gt; con un objeto &lt;code&gt;Error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d31efc29644775c604543b99db2b73a14120012" translate="yes" xml:space="preserve">
          <source>Implement this method to send queries to the server. For each query request, when the server response is received, this method must either call &lt;code&gt;resolve&lt;/code&gt; with the response data, or &lt;code&gt;reject&lt;/code&gt; with an &lt;code&gt;Error&lt;/code&gt; object.</source>
          <target state="translated">Implemente este m&amp;eacute;todo para enviar consultas al servidor. Para cada solicitud de consulta, cuando se recibe la respuesta del servidor, este m&amp;eacute;todo debe llamar a &lt;code&gt;resolve&lt;/code&gt; con los datos de respuesta o &lt;code&gt;reject&lt;/code&gt; con un objeto &lt;code&gt;Error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1774e52d0e556763970083c582a2823556fad1d9" translate="yes" xml:space="preserve">
          <source>Implement this required method to design a &amp;lsquo;fat query&amp;rsquo; &amp;ndash; one that represents every field in your data model that could change as a result of this mutation.</source>
          <target state="translated">Implemente este m&amp;eacute;todo necesario para dise&amp;ntilde;ar una 'consulta amplia', una que represente todos los campos de su modelo de datos que podr&amp;iacute;an cambiar como resultado de esta mutaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="55c82c1ede81ef7c75eb0f5ad805b7c8131bec8a" translate="yes" xml:space="preserve">
          <source>Implement this required method to give Relay instructions on how to use the response payload from each mutation to update the client-side store.</source>
          <target state="translated">Implementar este método necesario para dar instrucciones al Relevo sobre cómo utilizar la carga de respuesta de cada mutación para actualizar el almacén del lado del cliente.</target>
        </trans-unit>
        <trans-unit id="17378e1f66fb4d758998ffc792b8f969174e1a87" translate="yes" xml:space="preserve">
          <source>Implement this required method to prepare variables to be used as input to the mutation.</source>
          <target state="translated">Aplicar este método necesario para preparar las variables que se utilizarán como insumo de la mutación.</target>
        </trans-unit>
        <trans-unit id="e0d5783849893b65928056a3e01f878a4ebb371a" translate="yes" xml:space="preserve">
          <source>Implement this required method to return a GraphQL mutation operation that represents the mutation to be performed.</source>
          <target state="translated">Implementar este método necesario para devolver una operación de mutación GraphQL que represente la mutación a realizar.</target>
        </trans-unit>
        <trans-unit id="d8c789b0ff99a369ebb08eda75d64a2002a8918e" translate="yes" xml:space="preserve">
          <source>Importing generated definitions</source>
          <target state="translated">Importación de definiciones generadas</target>
        </trans-unit>
        <trans-unit id="a8c0b4ec0c84b678651530ba2d81f9beb98a2561" translate="yes" xml:space="preserve">
          <source>In GraphQL, &lt;strong&gt;queries&lt;/strong&gt; declare fields that exist on the root query type. For example, the following query might fetch the name of the user with an &lt;code&gt;id&lt;/code&gt; of &lt;code&gt;123&lt;/code&gt;:</source>
          <target state="translated">En GraphQL, las &lt;strong&gt;consultas&lt;/strong&gt; declaran campos que existen en el tipo de consulta ra&amp;iacute;z. Por ejemplo, la siguiente consulta podr&amp;iacute;a obtener el nombre del usuario con un &lt;code&gt;id&lt;/code&gt; de &lt;code&gt;123&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="42cc08262fb0bb543ca0770499256c848ef63cb2" translate="yes" xml:space="preserve">
          <source>In React Native, we can schedule Relay processing so as to avoid interrupting touch gestures as follows:</source>
          <target state="translated">En React Native,podemos programar el procesamiento de los Relevos para evitar interrumpir los gestos de tacto de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="8ebfcf2d8faf5ad639fc9d0514f8f7159330d866" translate="yes" xml:space="preserve">
          <source>In React, rendering a view requires two inputs: the &lt;em&gt;component&lt;/em&gt; to render, and a &lt;em&gt;root&lt;/em&gt; DOM (UI) node to render into. Rendering Relay containers is similar: we need a &lt;em&gt;container&lt;/em&gt; to render, and a &lt;em&gt;root&lt;/em&gt; in the graph from which to start our query. We also must ensure that the queries for the container are executed and may want to show a loading indicator while data is being fetched. Similar to &lt;code&gt;ReactDOM.render(component, domNode)&lt;/code&gt;, Relay provides &lt;code&gt;&amp;lt;QueryRenderer query={...} variables={...} render={...}&amp;gt;&lt;/code&gt; for this purpose. The &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;variables&lt;/code&gt; define what data to fetch and &lt;code&gt;render&lt;/code&gt; defines what to render. Here's how we might render &lt;code&gt;&amp;lt;StoryContainer&amp;gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5187bfb626e29a7807af4b6499d8505f13e32b2" translate="yes" xml:space="preserve">
          <source>In React, rendering a view requires two inputs: the &lt;em&gt;component&lt;/em&gt; to render, and a &lt;em&gt;root&lt;/em&gt; DOM (UI) node to render into. Rendering Relay containers is similar: we need a &lt;em&gt;container&lt;/em&gt; to render, and a &lt;em&gt;root&lt;/em&gt; in the graph from which to start our query. We also must ensure that the queries for the container are executed and may want to show a loading indicator while data is being fetched. Similar to &lt;code&gt;ReactDOM.render(component, domNode)&lt;/code&gt;, Relay provides &lt;code&gt;&amp;lt;Relay.Renderer Container={...} queryConfig={...}&amp;gt;&lt;/code&gt; for this purpose. The container is the item to render, and the queryConfig provides queries that specify &lt;em&gt;which&lt;/em&gt; item to fetch. Here's how we might render &lt;code&gt;&amp;lt;StoryContainer&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">En React, renderizar una vista requiere dos entradas: el &lt;em&gt;componente&lt;/em&gt; para renderizar y un nodo &lt;em&gt;ra&amp;iacute;z&lt;/em&gt; DOM (UI) para renderizar. La representaci&amp;oacute;n de contenedores de Relay es similar: necesitamos un &lt;em&gt;contenedor&lt;/em&gt; para renderizar y una &lt;em&gt;ra&amp;iacute;z&lt;/em&gt; en el gr&amp;aacute;fico desde la cual comenzar nuestra consulta. Tambi&amp;eacute;n debemos asegurarnos de que las consultas para el contenedor se ejecuten y es posible que deseemos mostrar un indicador de carga mientras se obtienen los datos. Similar a &lt;code&gt;ReactDOM.render(component, domNode)&lt;/code&gt; , Relay proporciona &lt;code&gt;&amp;lt;Relay.Renderer Container={...} queryConfig={...}&amp;gt;&lt;/code&gt; para este prop&amp;oacute;sito. El contenedor es el elemento a representar y queryConfig proporciona consultas que especifican &lt;em&gt;qu&amp;eacute;&lt;/em&gt; elemento buscar. As&amp;iacute; es como podr&amp;iacute;amos renderizar &lt;code&gt;&amp;lt;StoryContainer&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4f9d43e8de662b43a98bf53a133be5a295724798" translate="yes" xml:space="preserve">
          <source>In Relay, data dependencies are described using &lt;a href=&quot;https://github.com/facebook/graphql&quot;&gt;GraphQL&lt;/a&gt;. For &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt;, the dependency can be expressed as follows. Note that this exactly matches the shape that the component expected for the &lt;code&gt;user&lt;/code&gt; prop.</source>
          <target state="translated">En Relay, las dependencias de datos se describen mediante &lt;a href=&quot;https://github.com/facebook/graphql&quot;&gt;GraphQL&lt;/a&gt; . Para &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; , la dependencia se puede expresar de la siguiente manera. Tenga en cuenta que esto coincide exactamente con la forma que esperaba el componente para el accesorio del &lt;code&gt;user&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eba544839f5e404d357e1b726ac9db4aa7980297" translate="yes" xml:space="preserve">
          <source>In Relay, data dependencies are described using &lt;a href=&quot;https://github.com/facebook/graphql&quot;&gt;GraphQL&lt;/a&gt;. For &lt;code&gt;&amp;lt;TodoItem /&amp;gt;&lt;/code&gt;, the dependency can be expressed as follows. Note that this exactly matches the shape that the component expected for the &lt;code&gt;item&lt;/code&gt; prop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1084307d05023abf80689279ae0f77b70f810919" translate="yes" xml:space="preserve">
          <source>In Relay, data dependencies are described using &lt;a href=&quot;https://github.com/facebook/graphql&quot;&gt;GraphQL&lt;/a&gt;. For &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt;, the dependency can be expressed as follows. Note that this exactly matches the shape that the component expected for the &lt;code&gt;item&lt;/code&gt; prop.</source>
          <target state="translated">En Relay, las dependencias de datos se describen mediante &lt;a href=&quot;https://github.com/facebook/graphql&quot;&gt;GraphQL&lt;/a&gt; . Para &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; , la dependencia se puede expresar de la siguiente manera. Tenga en cuenta que esto coincide exactamente con la forma que esperaba el componente para el accesorio del &lt;code&gt;item&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8218e7619ef161652f44088010026d35f36055e0" translate="yes" xml:space="preserve">
          <source>In Relay, the root of a query is defined by a &lt;strong&gt;QueryRenderer&lt;/strong&gt; so check out that section for more details.</source>
          <target state="translated">En Relay, la ra&amp;iacute;z de una consulta la define un &lt;strong&gt;QueryRenderer,&lt;/strong&gt; as&amp;iacute; que consulte esa secci&amp;oacute;n para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="30d65c55146011871e1262a4566a24588803dc0d" translate="yes" xml:space="preserve">
          <source>In Relay, the root of a query is defined by a &lt;strong&gt;Route&lt;/strong&gt;. Continue to learn about Relay routes.</source>
          <target state="translated">En Relay, la ra&amp;iacute;z de una consulta se define mediante una &lt;strong&gt;ruta&lt;/strong&gt; . Contin&amp;uacute;e aprendiendo sobre las rutas de retransmisi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8403870f1b9487ea70facda9683cbaadf51f154c" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;pagination-container&quot;&gt;pagination container&lt;/a&gt;, we usually annotate the actual connection field with &lt;code&gt;@connection&lt;/code&gt; to tell Relay which part needs to be paginated:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c21389450ed39ca7f4877ce1712aa3326324e6a9" translate="yes" xml:space="preserve">
          <source>In a resource-oriented REST system, we can maintain a &lt;strong&gt;response cache&lt;/strong&gt; based on URIs:</source>
          <target state="translated">En un sistema REST orientado a recursos, podemos mantener una &lt;strong&gt;cach&amp;eacute; de respuesta&lt;/strong&gt; basada en URI:</target>
        </trans-unit>
        <trans-unit id="ddc4813b133487bd46b76268444d4db66fd4598c" translate="yes" xml:space="preserve">
          <source>In a simple mutation, you only need &lt;code&gt;mutation&lt;/code&gt; and &lt;code&gt;variables&lt;/code&gt;:</source>
          <target state="translated">En una mutaci&amp;oacute;n simple, solo necesita &lt;code&gt;mutation&lt;/code&gt; y &lt;code&gt;variables&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="753db9b3fed6b02e90a81f5ecfd3b20ecf1201c5" translate="yes" xml:space="preserve">
          <source>In a simple subscription, you only need &lt;code&gt;subscription&lt;/code&gt; and &lt;code&gt;variables&lt;/code&gt;. This is appropriate when you are only changing the properties of existing records that can be identified by their &lt;code&gt;id&lt;/code&gt;:</source>
          <target state="translated">En una suscripci&amp;oacute;n simple, solo necesita &lt;code&gt;subscription&lt;/code&gt; y &lt;code&gt;variables&lt;/code&gt; . Esto es apropiado cuando solo est&amp;aacute; cambiando las propiedades de registros existentes que se pueden identificar por su &lt;code&gt;id&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2d35beb84697160944c091bfc4ea7475ddba8bba" translate="yes" xml:space="preserve">
          <source>In addition to the bin script, the &lt;code&gt;relay-compiler&lt;/code&gt; package also &lt;a href=&quot;https://github.com/facebook/relay/blob/master/packages/relay-compiler/RelayCompilerPublic.js&quot;&gt;exports library code&lt;/a&gt; which you may use to create more complex configurations for the compiler, or to extend the compiler with your own custom output.</source>
          <target state="translated">Adem&amp;aacute;s del script bin, el paquete del &lt;code&gt;relay-compiler&lt;/code&gt; tambi&amp;eacute;n &lt;a href=&quot;https://github.com/facebook/relay/blob/master/packages/relay-compiler/RelayCompilerPublic.js&quot;&gt;exporta el c&amp;oacute;digo de la biblioteca&lt;/a&gt; que puede usar para crear configuraciones m&amp;aacute;s complejas para el compilador o para ampliar el compilador con su propia salida personalizada.</target>
        </trans-unit>
        <trans-unit id="d61a016e90e92a84f22e5f4a46d1a7c70ba615d3" translate="yes" xml:space="preserve">
          <source>In addition to the bin script, the &lt;code&gt;relay-compiler&lt;/code&gt; package also &lt;a href=&quot;https://github.com/facebook/relay/blob/master/packages/relay-compiler/index.js&quot;&gt;exports library code&lt;/a&gt; which you may use to create more complex configurations for the compiler, or to extend the compiler with your own custom output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ee7cb663ba30043049419a3987f32bf98b8e3b6" translate="yes" xml:space="preserve">
          <source>In order to incrementally convert an existing codebase, we will need to use the Relay Modern API while continuing to use the Relay Classic runtime until all components are converted.</source>
          <target state="translated">Para convertir de forma incremental una base de código existente,necesitaremos usar la API de Relay Modern mientras seguimos usando el tiempo de ejecución de Relay Classic hasta que todos los componentes sean convertidos.</target>
        </trans-unit>
        <trans-unit id="b06055f46a51395cce09c8715fc83f412863f99f" translate="yes" xml:space="preserve">
          <source>In order to know how to access your GraphQL server, Relay Modern requires developers to provide an object implementing the &lt;code&gt;NetworkLayer&lt;/code&gt; interface when creating an instance of a &lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt;. The environment uses this network layer to execute queries, mutations, and (if your server supports them) subscriptions. This allows developers to use whatever transport (HTTP, WebSockets, etc) and authentication is most appropriate for their application, decoupling the environment from the particulars of each application's network configuration.</source>
          <target state="translated">Para saber c&amp;oacute;mo acceder a su servidor GraphQL, Relay Modern requiere que los desarrolladores proporcionen un objeto que implemente la interfaz &lt;code&gt;NetworkLayer&lt;/code&gt; al crear una instancia de un &lt;a href=&quot;relay-environment&quot;&gt;entorno de retransmisi&amp;oacute;n&lt;/a&gt; . El entorno utiliza esta capa de red para ejecutar consultas, mutaciones y (si su servidor las admite) suscripciones. Esto permite a los desarrolladores utilizar cualquier transporte (HTTP, WebSockets, etc.) y la autenticaci&amp;oacute;n m&amp;aacute;s apropiada para su aplicaci&amp;oacute;n, desacoplando el entorno de los detalles de la configuraci&amp;oacute;n de red de cada aplicaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9751687b059f090db3539850209951869b6090c4" translate="yes" xml:space="preserve">
          <source>In order to pass arguments to a fragment that has &lt;code&gt;@argumentDefinitions&lt;/code&gt;, you need to use the &lt;a href=&quot;graphql-in-relay#arguments&quot;&gt;&lt;code&gt;@arguments&lt;/code&gt;&lt;/a&gt; directive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a7aba64216b1cd4d2d2e3ad530a1f3188fad50d" translate="yes" xml:space="preserve">
          <source>In order to resolve a fragment into an array of objects you have to use the &lt;code&gt;@relay(plural: true)&lt;/code&gt; directive.</source>
          <target state="translated">Para resolver un fragmento en una matriz de objetos, debe usar la &lt;code&gt;@relay(plural: true)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6f38813eb9d2dd5b73b9500e984665cfcbc9419" translate="yes" xml:space="preserve">
          <source>In our experience, the overwhelming majority of products want one specific behavior: fetch &lt;em&gt;all&lt;/em&gt; the data for a view hierarchy while displaying a loading indicator, and then render the &lt;em&gt;entire&lt;/em&gt; view once the data is ready.</source>
          <target state="translated">En nuestra experiencia, la inmensa mayor&amp;iacute;a de los productos quieren un comportamiento espec&amp;iacute;fico: recuperar &lt;em&gt;todos&lt;/em&gt; los datos para una jerarqu&amp;iacute;a de vistas mientras se muestra un indicador de carga y luego renderizar la vista &lt;em&gt;completa&lt;/em&gt; una vez que los datos est&amp;aacute;n listos.</target>
        </trans-unit>
        <trans-unit id="6a8da0b71c4c64aea6ae6834a91b9401918c3e7e" translate="yes" xml:space="preserve">
          <source>In that last example, think of &lt;code&gt;$format&lt;/code&gt; and &lt;code&gt;variables.format&lt;/code&gt; as the same value.</source>
          <target state="translated">En ese &amp;uacute;ltimo ejemplo, piense en &lt;code&gt;$format&lt;/code&gt; y &lt;code&gt;variables.format&lt;/code&gt; como el mismo valor.</target>
        </trans-unit>
        <trans-unit id="3888fb491d2876bafea276807002a772ce2740fc" translate="yes" xml:space="preserve">
          <source>In the diagram above:</source>
          <target state="translated">En el diagrama de arriba:</target>
        </trans-unit>
        <trans-unit id="fafabc5dfb7d6fbb341fd52614abab0575f4bf79" translate="yes" xml:space="preserve">
          <source>In the example below, the &lt;code&gt;user&lt;/code&gt; prop will include the data for &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt; fields wherever &lt;code&gt;...Component_internUser&lt;/code&gt; is included, instead of Relay's normal behavior to mask those fields.</source>
          <target state="translated">En el siguiente ejemplo, la propiedad del &lt;code&gt;user&lt;/code&gt; incluir&amp;aacute; los datos para los campos de &lt;code&gt;id&lt;/code&gt; entificaci&amp;oacute;n y &lt;code&gt;name&lt;/code&gt; siempre que se incluya &lt;code&gt;...Component_internUser&lt;/code&gt; , en lugar del comportamiento normal de Relay para enmascarar esos campos.</target>
        </trans-unit>
        <trans-unit id="ec241670d9655070dff253ce613242b187214f42" translate="yes" xml:space="preserve">
          <source>In the example below, the &lt;code&gt;user&lt;/code&gt; prop will include the data for &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt; fields wherever &lt;code&gt;...Component_internUser&lt;/code&gt; is included, instead of Relay's normal behavior to mask those fields:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4294ed53c4279bdd7158ab4d044dda1b52e51b3" translate="yes" xml:space="preserve">
          <source>In the example below, the function &lt;code&gt;processItemData&lt;/code&gt; is called from a React component. It requires an item object with a specific set of fields. All React components that use this function should spread the &lt;code&gt;processItemData_item&lt;/code&gt; fragment to ensure all of the correct item data is loaded for this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3b357ad1aa217f6b814380c122b67ca81691203" translate="yes" xml:space="preserve">
          <source>In the future, advanced capabilities in Relay may be dependent on the network layer being able to support certain features.</source>
          <target state="translated">En el futuro,las capacidades avanzadas de Relay pueden depender de que la capa de red sea capaz de soportar ciertas características.</target>
        </trans-unit>
        <trans-unit id="db9e71215ab64e7c01402f6a78301e1bc8b38923" translate="yes" xml:space="preserve">
          <source>In this article we'll explore what it means to build a GraphQL client framework and how this compares to clients for more traditional REST systems. Along the way we'll look at the design decisions behind Relay and see that it's not just a GraphQL client but also a framework for &lt;em&gt;declarative data-fetching&lt;/em&gt;. Let's start at the beginning and fetch some data!</source>
          <target state="translated">En este art&amp;iacute;culo exploraremos lo que significa construir un marco de cliente GraphQL y c&amp;oacute;mo se compara con los clientes de sistemas REST m&amp;aacute;s tradicionales. En el camino, veremos las decisiones de dise&amp;ntilde;o detr&amp;aacute;s de Relay y veremos que no es solo un cliente GraphQL sino tambi&amp;eacute;n un marco para la obtenci&amp;oacute;n de &lt;em&gt;datos declarativos&lt;/em&gt; . &amp;iexcl;Empecemos por el principio y busquemos algunos datos!</target>
        </trans-unit>
        <trans-unit id="88a02e183add9d1c24413aa47baf530897708969" translate="yes" xml:space="preserve">
          <source>In this example the Route should be initialized with a &lt;code&gt;userID&lt;/code&gt; which gets passed on to the query. That &lt;code&gt;userID&lt;/code&gt; variable will automatically be passed down to the top-level container and can be used there if needed. Further the top-level RelayContainer is expected to have a &lt;code&gt;user&lt;/code&gt; fragment with the fields to be queried.</source>
          <target state="translated">En este ejemplo, la ruta debe inicializarse con un &lt;code&gt;userID&lt;/code&gt; que se pasa a la consulta. Esa variable de &lt;code&gt;userID&lt;/code&gt; pasar&amp;aacute; autom&amp;aacute;ticamente al contenedor de nivel superior y se puede usar all&amp;iacute; si es necesario. Adem&amp;aacute;s, se espera que el RelayContainer de nivel superior tenga un fragmento de &lt;code&gt;user&lt;/code&gt; con los campos a consultar.</target>
        </trans-unit>
        <trans-unit id="fc3d9a2430b8dd6fdd1855b01aae967a1a86922c" translate="yes" xml:space="preserve">
          <source>In this example we are using a Refetch Container to fetch more stories in a story feed component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e65c0999502b8d880342481e43745e86b87bd15" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;profilePicture(size: 50)&lt;/code&gt; will be fetched for the intial render.</source>
          <target state="translated">En este ejemplo, &lt;code&gt;profilePicture(size: 50)&lt;/code&gt; buscar&amp;aacute; para el render inicial.</target>
        </trans-unit>
        <trans-unit id="b029685528e8da2f8ce2cf427c32ff8fbbf0ee00" translate="yes" xml:space="preserve">
          <source>In this example, create an inspector object based on the same source as passed into your &lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt;. Later you can use this inspector object to inspect records. Inspector is only available in the development build.</source>
          <target state="translated">En este ejemplo, cree un objeto inspector basado en la misma fuente que se pas&amp;oacute; a su &lt;a href=&quot;relay-environment&quot;&gt;entorno de retransmisi&amp;oacute;n&lt;/a&gt; . Posteriormente, puede utilizar este objeto inspector para inspeccionar registros. Inspector solo est&amp;aacute; disponible en la versi&amp;oacute;n de desarrollo.</target>
        </trans-unit>
        <trans-unit id="4e1907e8aedfd3075f12c9bb08511b6424b05151" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;width&lt;/code&gt; of the rendered image will always correspond to the &lt;code&gt;$size&lt;/code&gt; variable used to fetch the current version of &lt;code&gt;profilePicture.uri&lt;/code&gt;.</source>
          <target state="translated">En este ejemplo, el &lt;code&gt;width&lt;/code&gt; de la imagen renderizada siempre corresponder&amp;aacute; a la variable &lt;code&gt;$size&lt;/code&gt; utilizada para obtener la versi&amp;oacute;n actual de &lt;code&gt;profilePicture.uri&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86e6e74d266fdaa434ba59fe220a17114ef82453" translate="yes" xml:space="preserve">
          <source>In this example, the fields associated with the &lt;code&gt;ship&lt;/code&gt; fragment will be made available on &lt;code&gt;this.props.ship&lt;/code&gt;.</source>
          <target state="translated">En este ejemplo, los campos asociados con el fragmento de &lt;code&gt;ship&lt;/code&gt; estar&amp;aacute;n disponibles en &lt;code&gt;this.props.ship&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="85172d5db32fabb64291c47b382ebcc9097ed293" translate="yes" xml:space="preserve">
          <source>In this example, whenever &lt;code&gt;Parent&lt;/code&gt; is fetched, &lt;code&gt;Child&lt;/code&gt;'s fragment will also be fetched. When rendering, &lt;code&gt;&amp;lt;Parent&amp;gt;&lt;/code&gt; will only have access to the &lt;code&gt;props.foo.id&lt;/code&gt; field; data from the child fragment will be &lt;a href=&quot;http://facebook.github.io/relay/docs/thinking-in-relay.html#data-masking&quot;&gt;&lt;em&gt;masked&lt;/em&gt;&lt;/a&gt;. By default, &lt;code&gt;childFragment&lt;/code&gt; will use its corresponding initial variables. Relay will fetch &lt;code&gt;photo(size: 64)&lt;/code&gt;. When &lt;code&gt;&amp;lt;Child&amp;gt;&lt;/code&gt; is rendered it will also make the initial variables available as &lt;code&gt;props.relay.variables = {size: 64}&lt;/code&gt;.</source>
          <target state="translated">En este ejemplo, siempre que se recupere el &lt;code&gt;Parent&lt;/code&gt; , tambi&amp;eacute;n se obtendr&amp;aacute; el fragmento del &lt;code&gt;Child&lt;/code&gt; . Al renderizar, &lt;code&gt;&amp;lt;Parent&amp;gt;&lt;/code&gt; solo tendr&amp;aacute; acceso al campo &lt;code&gt;props.foo.id&lt;/code&gt; ; se &lt;a href=&quot;http://facebook.github.io/relay/docs/thinking-in-relay.html#data-masking&quot;&gt;&lt;em&gt;enmascarar&amp;aacute;n los&lt;/em&gt;&lt;/a&gt; datos del fragmento secundario . De forma predeterminada, &lt;code&gt;childFragment&lt;/code&gt; utilizar&amp;aacute; sus correspondientes variables iniciales. El rel&amp;eacute; buscar&amp;aacute; una &lt;code&gt;photo(size: 64)&lt;/code&gt; . Cuando se renderiza &lt;code&gt;&amp;lt;Child&amp;gt;&lt;/code&gt; , tambi&amp;eacute;n har&amp;aacute; que las variables iniciales est&amp;eacute;n disponibles como &lt;code&gt;props.relay.variables = {size: 64}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79f26e8bd2ce0d98aed5c314fad80d4d64f729d8" translate="yes" xml:space="preserve">
          <source>In this example, whenever a picture with a new size is being loaded a spinner is displayed instead of the picture.</source>
          <target state="translated">En este ejemplo,cada vez que se carga una imagen con un nuevo tamaño,se muestra un girador en lugar de la imagen.</target>
        </trans-unit>
        <trans-unit id="11c9642bf0d68f60f8223631d67d9ed8e587f204" translate="yes" xml:space="preserve">
          <source>In this particular example, the only field that the &lt;code&gt;LikeButton&lt;/code&gt; cares about is &lt;code&gt;viewerDoesLike&lt;/code&gt;. That field will form part of the tracked query that Relay will intersect with the fat query of &lt;code&gt;LikeStoryMutation&lt;/code&gt; to determine what fields to request as part of the server's response payload for the mutation. Another component elsewhere in the application might be interested in the likers count, or the like sentence. Since those fields will automatically be added to Relay's tracked query, the &lt;code&gt;LikeButton&lt;/code&gt; need not worry about requesting them explicitly.</source>
          <target state="translated">En este ejemplo particular, el &amp;uacute;nico campo que el &lt;code&gt;LikeButton&lt;/code&gt; le importa es &lt;code&gt;viewerDoesLike&lt;/code&gt; . Ese campo formar&amp;aacute; parte de la consulta rastreada que Relay cruzar&amp;aacute; con la consulta &lt;code&gt;LikeStoryMutation&lt;/code&gt; de LikeStoryMutation para determinar qu&amp;eacute; campos solicitar como parte de la carga &amp;uacute;til de respuesta del servidor para la mutaci&amp;oacute;n. Otro componente en otra parte de la aplicaci&amp;oacute;n podr&amp;iacute;a estar interesado en el recuento de me gusta o en una oraci&amp;oacute;n similar. Dado que esos campos se agregar&amp;aacute;n autom&amp;aacute;ticamente a la consulta de seguimiento de Relay, &lt;code&gt;LikeButton&lt;/code&gt; no necesita preocuparse por solicitarlos expl&amp;iacute;citamente.</target>
        </trans-unit>
        <trans-unit id="73de0e214eb1fe6fc2a92866867bd0a77a34d53e" translate="yes" xml:space="preserve">
          <source>In this simple example, let's assume we want to fetch the latest data for a &lt;code&gt;TodoItem&lt;/code&gt; from the server:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="877c9e959c13a50bd6cd2c0684ab7d5def3e1397" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will build a game using GraphQL mutations. The goal of the game is to find a hidden treasure in a grid of 9 squares. We will give players three tries to find the treasure. This should give us an end-to-end look at Relay &amp;ndash; from the GraphQL schema on the server, to the React application on the client.</source>
          <target state="translated">En este tutorial, crearemos un juego usando mutaciones GraphQL. El objetivo del juego es encontrar un tesoro escondido en una cuadr&amp;iacute;cula de 9 cuadrados. Daremos a los jugadores tres intentos para encontrar el tesoro. Esto deber&amp;iacute;a darnos una visi&amp;oacute;n de principio a fin de Relay, desde el esquema GraphQL en el servidor hasta la aplicaci&amp;oacute;n React en el cliente.</target>
        </trans-unit>
        <trans-unit id="c1f61deb9bd75956e5146dd965f4efa1acf76ef5" translate="yes" xml:space="preserve">
          <source>Incrementally modernize your Relay Classic app in these steps:</source>
          <target state="translated">Moderniza tu aplicación Relay Classic en estos pasos:</target>
        </trans-unit>
        <trans-unit id="0e8c879968a7b304e9792c15d95365ae89d2aa45" translate="yes" xml:space="preserve">
          <source>Injectable Custom Field Handlers</source>
          <target state="translated">Manipuladores de campo personalizados inyectables</target>
        </trans-unit>
        <trans-unit id="e69c600fe29f0ed75880fd3b696888c254caf34f" translate="yes" xml:space="preserve">
          <source>Inline Fragments</source>
          <target state="translated">Fragmentos en línea</target>
        </trans-unit>
        <trans-unit id="1889c37693175c0225de5e6837f2ed3f9f529fe3" translate="yes" xml:space="preserve">
          <source>Inline the value in the GraphQL query, potentially annotating with a GraphQL comment (i.e. &lt;code&gt;# PAGE_SIZE&lt;/code&gt;).</source>
          <target state="translated">Inserte el valor en la consulta GraphQL, anot&amp;aacute;ndolo potencialmente con un comentario GraphQL (es decir, &lt;code&gt;# PAGE_SIZE&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0de09ec0beb82594d04ee09d8aeb812d06a3d58b" translate="yes" xml:space="preserve">
          <source>Install the latest version of Relay from the &lt;a href=&quot;relay-modern&quot;&gt;getting started guide&lt;/a&gt;.</source>
          <target state="translated">Instale la &amp;uacute;ltima versi&amp;oacute;n de Relay de la &lt;a href=&quot;relay-modern&quot;&gt;gu&amp;iacute;a de introducci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6603c8ba1e08fe9cd6b6dad35da64e9d939e1d23" translate="yes" xml:space="preserve">
          <source>Integration options are available for open-source routing libraries that can instead fetch data for nested routes in parallel. In many of these cases, using a batching network layer can bring additional benefits in avoiding sending multiple HTTP requests.</source>
          <target state="translated">Existen opciones de integración para las bibliotecas de rutas de código abierto que pueden,en cambio,obtener datos de rutas anidadas en paralelo.En muchos de estos casos,el uso de una capa de red por lotes puede aportar beneficios adicionales al evitar el envío de múltiples solicitudes HTTP.</target>
        </trans-unit>
        <trans-unit id="ba3a36612e2c9eeb3ee746032e0c52004c3b84f8" translate="yes" xml:space="preserve">
          <source>Integration with Relay Classic for React Router v2 or v3 is available via &lt;a href=&quot;https://github.com/relay-tools/react-router-relay&quot;&gt;&lt;code&gt;react-router-relay&lt;/code&gt;&lt;/a&gt;, which will aggregate the queries for matched routes, and request data for all routes in parallel.</source>
          <target state="translated">La integraci&amp;oacute;n con Relay Classic para React Router v2 o v3 est&amp;aacute; disponible a trav&amp;eacute;s de &lt;a href=&quot;https://github.com/relay-tools/react-router-relay&quot;&gt; &lt;code&gt;react-router-relay&lt;/code&gt; &lt;/a&gt; , que agregar&amp;aacute; las consultas para rutas coincidentes y solicitar&amp;aacute; datos para todas las rutas en paralelo.</target>
        </trans-unit>
        <trans-unit id="5681686d7dd00f9ec2ed83d86065fe5a9aa47328" translate="yes" xml:space="preserve">
          <source>Introduction to Relay</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca6f57623e58b4619d24d2a4a11fc39e22aace3a" translate="yes" xml:space="preserve">
          <source>Introduction to Relay Modern</source>
          <target state="translated">Introducción al Relevo Moderno</target>
        </trans-unit>
        <trans-unit id="ede0b81585211d6b9897a8c1877bb4add0712d66" translate="yes" xml:space="preserve">
          <source>Invalidates the record. This will cause any query that references this record to be considered stale until the next time it is refetched, and will be considered to require a refetch the next time such a query is checked with &lt;code&gt;environment.check()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdaf67797686a7d4a210975b6064cb3ac3259374" translate="yes" xml:space="preserve">
          <source>It is also assumed that the reader is already familiar with &lt;a href=&quot;https://en.wikipedia.org/wiki/Star_Wars&quot;&gt;Star Wars&lt;/a&gt;; if not, the 1977 version of Star Wars is a good place to start, though the 1997 Special Edition will serve for the purposes of this document.</source>
          <target state="translated">Tambi&amp;eacute;n se supone que el lector ya est&amp;aacute; familiarizado con &lt;a href=&quot;https://en.wikipedia.org/wiki/Star_Wars&quot;&gt;Star Wars&lt;/a&gt; ; de lo contrario, la versi&amp;oacute;n de 1977 de Star Wars es un buen lugar para comenzar, aunque la Edici&amp;oacute;n Especial de 1997 servir&amp;aacute; para los prop&amp;oacute;sitos de este documento.</target>
        </trans-unit>
        <trans-unit id="df2797c242fbac686a5646e3f8d0990c4c69631c" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is already familiar with GraphQL; if not, the README for &lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;GraphQL.js&lt;/a&gt; is a good place to start.</source>
          <target state="translated">Se supone que el lector ya est&amp;aacute; familiarizado con GraphQL; si no, el &lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;archivo&lt;/a&gt; README para GraphQL.js es un buen lugar para comenzar.</target>
        </trans-unit>
        <trans-unit id="1c307b4b2396ebcfc67f090b9356192c30ee3e15" translate="yes" xml:space="preserve">
          <source>It is not recommended to use &lt;code&gt;@relay(mask: false)&lt;/code&gt;. Please instead consider using the &lt;code&gt;@inline&lt;/code&gt; fragment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00f22d6b7169a71e14f872d1e3e6975d4ba68fa7" translate="yes" xml:space="preserve">
          <source>It is usually preferable to just pass an &lt;code&gt;optimisticResponse&lt;/code&gt; option instead of an &lt;code&gt;optimisticUpdater&lt;/code&gt;, unless you need to perform updates on the local records that are more complicated than just updating fields (e.g. deleting records or adding items to collections).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efecd775937b634754af4f65cbef5c8b4a7d96ba" translate="yes" xml:space="preserve">
          <source>It returns a &lt;code&gt;Disposable&lt;/code&gt; on which you could call &lt;code&gt;dispose()&lt;/code&gt; to cancel the refetch.</source>
          <target state="translated">Devuelve un &lt;code&gt;Disposable&lt;/code&gt; en el que puede llamar a &lt;code&gt;dispose()&lt;/code&gt; para cancelar la recuperaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="196589ac6e2b21bbd604e37c3b6f49f22ed50655" translate="yes" xml:space="preserve">
          <source>JavaScript environment requirements</source>
          <target state="translated">Requisitos del entorno de JavaScript</target>
        </trans-unit>
        <trans-unit id="0b490a2df160ed0c71b8320c42d90d77b3406679" translate="yes" xml:space="preserve">
          <source>JavaScript helpers for defining connections between data, and mutations, in a way that smoothly integrates with Relay.</source>
          <target state="translated">Ayudantes de JavaScript para definir las conexiones entre los datos y las mutaciones,de forma que se integren sin problemas con el Relevo.</target>
        </trans-unit>
        <trans-unit id="3763226e2b043a56c9ba7559341b0774c3ea862d" translate="yes" xml:space="preserve">
          <source>Keep in mind that it is typically considered an &lt;strong&gt;anti-pattern&lt;/strong&gt; to create a single fragment shared across many containers. Abusing this directive could result in over-fetching in your application.</source>
          <target state="translated">Tenga en cuenta que, por lo general, se considera un &lt;strong&gt;antipatr&amp;oacute;n&lt;/strong&gt; crear un solo fragmento compartido en muchos contenedores. Abusar de esta directiva podr&amp;iacute;a resultar en una b&amp;uacute;squeda excesiva en su aplicaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="25fe5a3c2698d53807ead685c86822cf47cc3073" translate="yes" xml:space="preserve">
          <source>Learn how to use &lt;code&gt;onReadyStateChange&lt;/code&gt; in our next guide, &lt;a href=&quot;guides-ready-state&quot;&gt;Ready State&lt;/a&gt;.</source>
          <target state="translated">Aprenda a usar &lt;code&gt;onReadyStateChange&lt;/code&gt; en nuestra pr&amp;oacute;xima gu&amp;iacute;a, &lt;a href=&quot;guides-ready-state&quot;&gt;Ready State&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4a4f4fc8ca8973cbce4f7744b6aee5bccdaab0f6" translate="yes" xml:space="preserve">
          <source>Let's associate the mutation we just created with the root mutation type:</source>
          <target state="translated">Asociemos la mutación que acabamos de crear con el tipo de mutación de la raíz:</target>
        </trans-unit>
        <trans-unit id="f8acb98279c7a33b14354f6c3ef2bfe03f2deca1" translate="yes" xml:space="preserve">
          <source>Let's craft an optimistic response for the &lt;code&gt;LikeStoryMutation&lt;/code&gt; example above:</source>
          <target state="translated">&lt;code&gt;LikeStoryMutation&lt;/code&gt; una respuesta optimista para el ejemplo de LikeStoryMutation anterior:</target>
        </trans-unit>
        <trans-unit id="ba32433c3c054db31c3adabcaef06296860fad94" translate="yes" xml:space="preserve">
          <source>Let's explore how this works via a &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; component that composes the &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; from above.</source>
          <target state="translated">Exploremos c&amp;oacute;mo funciona esto a trav&amp;eacute;s de un componente &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; que compone &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; desde arriba.</target>
        </trans-unit>
        <trans-unit id="25a086b22a4ba22a2ce589d6573f5857d3b2c109" translate="yes" xml:space="preserve">
          <source>Let's explore how this works via a &lt;code&gt;&amp;lt;TodoList /&amp;gt;&lt;/code&gt; component that composes the &lt;code&gt;&amp;lt;TodoItem /&amp;gt;&lt;/code&gt; we defined above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89835a8e4dc90be9c02f2fb3d5af523e7de7cee2" translate="yes" xml:space="preserve">
          <source>Let's explore how this works via a &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; component that composes the &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; from above.</source>
          <target state="translated">&lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; c&amp;oacute;mo funciona esto a trav&amp;eacute;s de un componente &amp;lt;TodoList&amp;gt; que compone el &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; desde arriba.</target>
        </trans-unit>
        <trans-unit id="8eb1ff4062deba895e97692f949a6733e97ad5f6" translate="yes" xml:space="preserve">
          <source>Let's look at some product use-cases to understand how we incorporated these ideas into Relay. We'll assume a basic familiarity with React.</source>
          <target state="translated">Veamos algunos casos de uso de productos para entender cómo incorporamos estas ideas en el Relevo.Asumiremos una familiaridad básica con React.</target>
        </trans-unit>
        <trans-unit id="839d4a2135069fbb40df14cc776556712d98fa6a" translate="yes" xml:space="preserve">
          <source>Let's open up the starter kit's schema, and replace the database imports with the ones we just created:</source>
          <target state="translated">Abramos el esquema del kit de inicio,y reemplacemos las importaciones de la base de datos con las que acabamos de crear:</target>
        </trans-unit>
        <trans-unit id="a72ca83abcd8602717039b5f64a5b5a2b89c81e1" translate="yes" xml:space="preserve">
          <source>Let's see this in action, and query for the ID of the rebels:</source>
          <target state="translated">Veamos esto en acción,y busquemos la identificación de los rebeldes:</target>
        </trans-unit>
        <trans-unit id="c673a2bcf682f78fa812bcbefa0360994ed37548" translate="yes" xml:space="preserve">
          <source>Let's start a project using the &lt;a href=&quot;https://github.com/relayjs/relay-starter-kit&quot;&gt;Relay Starter Kit&lt;/a&gt; as a base.</source>
          <target state="translated">Comencemos un proyecto usando el &lt;a href=&quot;https://github.com/relayjs/relay-starter-kit&quot;&gt;kit&lt;/a&gt; de inicio de rel&amp;eacute; como base.</target>
        </trans-unit>
        <trans-unit id="a71dc4b410048806e0d1bbd75c4e909652f2f534" translate="yes" xml:space="preserve">
          <source>Let's take the rebels, and ask for their first ship:</source>
          <target state="translated">Tomemos a los rebeldes y pidamos su primera nave:</target>
        </trans-unit>
        <trans-unit id="510f4b78cd5f8fbd49c14a5834839d1ab18bb893" translate="yes" xml:space="preserve">
          <source>Let's tweak the file &lt;code&gt;./js/routes/AppHomeRoute.js&lt;/code&gt; to anchor our game to the &lt;code&gt;game&lt;/code&gt; root field of the schema:</source>
          <target state="translated">Vamos a modificar el archivo &lt;code&gt;./js/routes/AppHomeRoute.js&lt;/code&gt; para anclar nuestro juego para el &lt;code&gt;game&lt;/code&gt; campo de la ra&amp;iacute;z del esquema:</target>
        </trans-unit>
        <trans-unit id="cc5b2a062f05dd148b4ef24c76639416ebcc59f3" translate="yes" xml:space="preserve">
          <source>Licensed under the BSD License.</source>
          <target state="translated">Licenciado bajo la Licencia BSD.</target>
        </trans-unit>
        <trans-unit id="8882f419c30a0460f51c5ec6edaf87949c2d7459" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;updater&lt;/code&gt;, there is no need to provide &lt;code&gt;optimisticUpdater&lt;/code&gt; for simple mutations (field change).</source>
          <target state="translated">Al igual que el &lt;code&gt;updater&lt;/code&gt; , no es necesario proporcionar &lt;code&gt;optimisticUpdater&lt;/code&gt; para mutaciones simples (cambio de campo).</target>
        </trans-unit>
        <trans-unit id="35b9502f3f76f952801534521de9830a54b15a16" translate="yes" xml:space="preserve">
          <source>Like it can be done with &lt;a href=&quot;guides-containers&quot;&gt;Relay containers&lt;/a&gt;, we can prepare variables for use by our mutation's fragment builders, based on the previous variables and the runtime environment.</source>
          <target state="translated">Al igual que se puede hacer con los &lt;a href=&quot;guides-containers&quot;&gt;contenedores Relay&lt;/a&gt; , podemos preparar variables para que las usen los constructores de fragmentos de nuestra mutaci&amp;oacute;n, en funci&amp;oacute;n de las variables anteriores y el entorno de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="3715b94c23f4ec20e0da2f29449a3c4646b3d581" translate="yes" xml:space="preserve">
          <source>Like most of the Relay APIs, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; attempts to resolve data using the client store before sending a request to the server. If we instead wanted to force a server request even if data is available on the client, we could use the &lt;code&gt;forceFetch&lt;/code&gt; boolean prop.</source>
          <target state="translated">Como la mayor&amp;iacute;a de las API de retransmisi&amp;oacute;n, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; intenta resolver los datos utilizando el almac&amp;eacute;n del cliente antes de enviar una solicitud al servidor. Si, en cambio, quisi&amp;eacute;ramos forzar una solicitud del servidor incluso si los datos est&amp;aacute;n disponibles en el cliente, podr&amp;iacute;amos usar la &lt;code&gt;forceFetch&lt;/code&gt; booleana forceFetch .</target>
        </trans-unit>
        <trans-unit id="f856144ecb9d05326c6d97badc1a9b834b075ac1" translate="yes" xml:space="preserve">
          <source>Like the GraphQL URI, the timeout and retry behavior can be configured:</source>
          <target state="translated">Al igual que la URI de GraphQL,el comportamiento de tiempo de espera y reintento puede ser configurado:</target>
        </trans-unit>
        <trans-unit id="4bcca57dadd610f8dfd235a855de5feef290f38a" translate="yes" xml:space="preserve">
          <source>Loading more data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48a466fb1a66e2ac77ce3c14782794ae94365211" translate="yes" xml:space="preserve">
          <source>Managing asynchronous state transitions and coordinating concurrent requests.</source>
          <target state="translated">Gestionando las transiciones de estado asíncrono y coordinando las solicitudes simultáneas.</target>
        </trans-unit>
        <trans-unit id="52b2066f0ecc6504fa0d1683e70c5884d55a8b13" translate="yes" xml:space="preserve">
          <source>Managing errors.</source>
          <target state="translated">Gestionando los errores.</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="9973640b391cb4b42f93e3afba3395c46f6a7823" translate="yes" xml:space="preserve">
          <source>Migrating a Relay Classic app to Relay Modern doesn't require rewriting from scratch. Instead, convert one component at a time to the Relay Modern API while continuing to have a working app. Once all components have been converted, the smaller and faster Relay Modern runtime can be used.</source>
          <target state="translated">Migrar una aplicación de Relay Classic a Relay Modern no requiere reescribirla desde cero.En su lugar,convierte un componente a la vez a la API de Relay Modern mientras sigue teniendo una aplicación en funcionamiento.Una vez que se hayan convertido todos los componentes,se puede utilizar el tiempo de ejecución de Relay Modern,que es más pequeño y más rápido.</target>
        </trans-unit>
        <trans-unit id="a496d014360b49f4df7da034a0313b6a98aa03a1" translate="yes" xml:space="preserve">
          <source>Migrating a Relay Classic app to Relay Modern doesn't require rewriting from scratch. Instead, you can convert one component at a time to the Relay Modern API while continuing to have a working app. Once all components have been converted, the smaller and faster Relay Modern runtime can be used.</source>
          <target state="translated">Migrar una aplicación de Relay Classic a Relay Modern no requiere reescribirla desde cero.En su lugar,puedes convertir un componente a la vez a la API de Relay Modern mientras sigues teniendo una aplicación en funcionamiento.Una vez que se hayan convertido todos los componentes,se puede utilizar el tiempo de ejecución de Relay Modern,que es más pequeño y más rápido.</target>
        </trans-unit>
        <trans-unit id="89ca9763c43ac3c5a6b549a8936812ce36f490d5" translate="yes" xml:space="preserve">
          <source>Migrating to Relay Modern</source>
          <target state="translated">Migrando al Relevo Moderno</target>
        </trans-unit>
        <trans-unit id="a2d0fdbac2d058cc7df5b6a959221d8c7b0c5956" translate="yes" xml:space="preserve">
          <source>Modern &lt;code&gt;createRefetchContainer&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;createRefetchContainer&lt;/code&gt; moderno</target>
        </trans-unit>
        <trans-unit id="04ddebd72b3485cb649586cd882bbc4a0abdd841" translate="yes" xml:space="preserve">
          <source>Modern &lt;code&gt;this.props.relay.loadMore(pageSize...)&lt;/code&gt; in a Pagination Container</source>
          <target state="translated">Modern &lt;code&gt;this.props.relay.loadMore(pageSize...)&lt;/code&gt; en un contenedor de paginaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="eb7d95f729e7a3975428e61ddb5eb7d7241b4fd9" translate="yes" xml:space="preserve">
          <source>Modern Component</source>
          <target state="translated">Componente moderno</target>
        </trans-unit>
        <trans-unit id="43dee33213cedaefc62f54e39a529109b27d00fd" translate="yes" xml:space="preserve">
          <source>Modern Mutation</source>
          <target state="translated">Mutación moderna</target>
        </trans-unit>
        <trans-unit id="f4c44d48df48d618739f0b3ad40791ec870c9181" translate="yes" xml:space="preserve">
          <source>Modern Runtime</source>
          <target state="translated">Modern Runtime</target>
        </trans-unit>
        <trans-unit id="d9c1afdc6ae257e230b98cd64d31e69e21611588" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;&amp;lt;QueryRenderer&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Moderno: &lt;code&gt;&amp;lt;QueryRenderer&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a5e6e8b97a1927e12c72c467f5aebd11a8b3d28" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;commitMutation(this.props.relay.environment, {mutation...})&lt;/code&gt;</source>
          <target state="translated">Moderno: &lt;code&gt;commitMutation(this.props.relay.environment, {mutation...})&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="08b3c5d91eb7d6d9c801374dc1e47b603bba9b4b" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;createFragmentContainer&lt;/code&gt;</source>
          <target state="translated">Moderno: &lt;code&gt;createFragmentContainer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f02b7506a9375f3a261dab66ee915f347b72fd85" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;createPaginationContainer&lt;/code&gt;</source>
          <target state="translated">Moderno: &lt;code&gt;createPaginationContainer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c48a2a55168fdc7ce4613937fb203cff48a67840" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;this.props.relay.refetch({foo: bar}...&lt;/code&gt; in a Refetch Container</source>
          <target state="translated">Moderno: &lt;code&gt;this.props.relay.refetch({foo: bar}...&lt;/code&gt; en un contenedor de recuperaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="189e341013a3594080b144a6999f9577b74abee9" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;this.props.relay.refetchConnection(...)&lt;/code&gt; in a Pagination Container</source>
          <target state="translated">Moderno: &lt;code&gt;this.props.relay.refetchConnection(...)&lt;/code&gt; en un contenedor de paginaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="b11a8c01d122a0561a2dbd1098a225c3e43e4308" translate="yes" xml:space="preserve">
          <source>Most applications will create a single Environment instance and use it throughout. In specific situations, however, you may want to create multiple environments for different purposes. For example, you may create a new environment instance whenever the user logs in or out in order to prevent data for different users being cached together. Similarly, a server rendered application may create a new environment instance per request, so that each request gets its own cache and user data does not overlap. Alternatively, you might have multiple products or features within a larger application, and you want each one to have product-specific network-handling or caching.</source>
          <target state="translated">La mayoría de las aplicaciones crearán una única instancia de Medio Ambiente y la usarán en todo momento.En situaciones específicas,sin embargo,puede que quieras crear múltiples entornos para diferentes propósitos.Por ejemplo,se puede crear una nueva instancia de entorno siempre que el usuario inicie o termine su sesión,a fin de evitar que los datos de diferentes usuarios se almacenen en la memoria caché juntos.Del mismo modo,una aplicación renderizada por el servidor puede crear una nueva instancia de entorno por cada solicitud,de modo que cada solicitud obtenga su propia memoria caché y los datos de los usuarios no se superpongan.Otra posibilidad es que se tengan múltiples productos o características dentro de una aplicación más grande,y que se desee que cada uno de ellos tenga un manejo de red o un almacenamiento en caché específico para cada producto.</target>
        </trans-unit>
        <trans-unit id="01c289d32b7203303850eb1c7dd2fdae6842ce3a" translate="yes" xml:space="preserve">
          <source>Must be a valid &lt;code&gt;RelayContainer&lt;/code&gt;. Relay will attempt to fulfill its data requirements before rendering it.</source>
          <target state="translated">Debe ser un &lt;code&gt;RelayContainer&lt;/code&gt; v&amp;aacute;lido . Relay intentar&amp;aacute; cumplir con sus requisitos de datos antes de renderizarlo.</target>
        </trans-unit>
        <trans-unit id="7b7385bcbd1923e030dad3540db44e565ab25b47" translate="yes" xml:space="preserve">
          <source>Mutates the current record by copying the fields over from the passed in record &lt;code&gt;sourceRecord&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b750075e624836051694833f9672b6324629ee12" translate="yes" xml:space="preserve">
          <source>Mutates the current record by setting a new linked record on the given the field name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eadad1577753ee37f1c2b694617c261c6134b034" translate="yes" xml:space="preserve">
          <source>Mutates the current record by setting a new set of linked records on the given the field name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e494f6c0a48343de5c18f2dbf8649d300cc34c93" translate="yes" xml:space="preserve">
          <source>Mutates the current record by setting a new value on the specified field. Returns the mutated record.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13bcc5c25bae00735d267b69807a37eb90d90472" translate="yes" xml:space="preserve">
          <source>Mutation</source>
          <target state="translated">Mutation</target>
        </trans-unit>
        <trans-unit id="c55f198bc8c7844e5e05f72964532f5dace071a0" translate="yes" xml:space="preserve">
          <source>Mutation props</source>
          <target state="translated">Los accesorios de la mutación...</target>
        </trans-unit>
        <trans-unit id="00a7fb731451c41a484b7591ece27f55c474ec0e" translate="yes" xml:space="preserve">
          <source>Mutations</source>
          <target state="translated">Mutations</target>
        </trans-unit>
        <trans-unit id="9d2e9b27d80bdf1627930a58bb10705ab9b7d295" translate="yes" xml:space="preserve">
          <source>Mutations with optimistic updates and the ability to update the cache with arbitrary logic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="731fdeead88e01d93d0976eb789d77d6c8ba6428" translate="yes" xml:space="preserve">
          <source>Mutator configuration</source>
          <target state="translated">Configuración del mutante</target>
        </trans-unit>
        <trans-unit id="aeecae05e67a82b3d9ddc32f18bafb250167d7b8" translate="yes" xml:space="preserve">
          <source>NODE_DELETE</source>
          <target state="translated">NODE_DELETE</target>
        </trans-unit>
        <trans-unit id="bef32b44309c819256ef91505f3ce46153114806" translate="yes" xml:space="preserve">
          <source>Nested Routes</source>
          <target state="translated">Rutas anidadas</target>
        </trans-unit>
        <trans-unit id="67269d974acb388f118a96d5b0eb90541c783c5f" translate="yes" xml:space="preserve">
          <source>Nested routes with Relay data dependencies introduce an additional complication. While it's possible to render a &lt;code&gt;QueryRenderer&lt;/code&gt; per route, doing so will lead to request waterfalls in the general case where parent routes do not render their child routes until the data for those parent routes are available. This generally leads to an unnecessary additional delay in loading the data for the page, but may be acceptable for small applications or for applications with shallow route trees.</source>
          <target state="translated">Las rutas anidadas con dependencias de datos de retransmisi&amp;oacute;n introducen una complicaci&amp;oacute;n adicional. Si bien es posible representar un &lt;code&gt;QueryRenderer&lt;/code&gt; por ruta, hacerlo conducir&amp;aacute; a solicitar cascadas en el caso general en el que las rutas principales no representan sus rutas secundarias hasta que los datos de esas rutas principales est&amp;eacute;n disponibles. Esto generalmente conduce a un retraso adicional innecesario en la carga de los datos de la p&amp;aacute;gina, pero puede ser aceptable para aplicaciones peque&amp;ntilde;as o para aplicaciones con &amp;aacute;rboles de ruta poco profundos.</target>
        </trans-unit>
        <trans-unit id="72e403f095e27b7f00c62a3bd59aa377165b5a4c" translate="yes" xml:space="preserve">
          <source>Network Layer</source>
          <target state="translated">Capa de red</target>
        </trans-unit>
        <trans-unit id="87869155f5f3484fd0f094292d35a709172baa8a" translate="yes" xml:space="preserve">
          <source>Network layer</source>
          <target state="translated">Capa de red</target>
        </trans-unit>
        <trans-unit id="f41f095614dba0f32736c3af7fc6b7b54e8b4b7f" translate="yes" xml:space="preserve">
          <source>Never mutate &lt;code&gt;this.props.relay.variables&lt;/code&gt; directly as it will not trigger data to be fetched properly. Treat &lt;code&gt;this.props.relay.variables&lt;/code&gt; as if it were immutable, just like props.</source>
          <target state="translated">Nunca &lt;code&gt;this.props.relay.variables&lt;/code&gt; directamente, ya que no activar&amp;aacute; la obtenci&amp;oacute;n de datos correctamente. Trate &lt;code&gt;this.props.relay.variables&lt;/code&gt; como si fuera inmutable, al igual que los accesorios.</target>
        </trans-unit>
        <trans-unit id="a945aa9cbd03a748373e539cadd72f60595b9951" translate="yes" xml:space="preserve">
          <source>New in Relay Modern</source>
          <target state="translated">Lo nuevo en Relay Modern</target>
        </trans-unit>
        <trans-unit id="34d3ac7ad9c7ff0b33bb48c822077feedfac1008" translate="yes" xml:space="preserve">
          <source>Next, install the compiler (typically as a &lt;code&gt;devDependency&lt;/code&gt;):</source>
          <target state="translated">A continuaci&amp;oacute;n, instale el compilador (normalmente como &lt;code&gt;devDependency&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="0a3100d6aa2ad29924f0f56bdda1c226229ea566" translate="yes" xml:space="preserve">
          <source>Next, it will &lt;code&gt;subscribe()&lt;/code&gt; using this snapshot in order to be notified of any changes - see the above diagram for &lt;code&gt;publish()&lt;/code&gt; and &lt;code&gt;notify()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b11d6766a232735ae2588359ce0e697727bb4a84" translate="yes" xml:space="preserve">
          <source>Next, let's create a file in &lt;code&gt;./js/mutations/CheckHidingSpotForTreasureMutation.js&lt;/code&gt; and create subclass of &lt;code&gt;Relay.Mutation&lt;/code&gt; called &lt;code&gt;CheckHidingSpotForTreasureMutation&lt;/code&gt; to hold our mutation implementation:</source>
          <target state="translated">A continuaci&amp;oacute;n, &lt;code&gt;./js/mutations/CheckHidingSpotForTreasureMutation.js&lt;/code&gt; un archivo en ./js/mutations/CheckHidingSpotForTreasureMutation.js y creemos una subclase de &lt;code&gt;Relay.Mutation&lt;/code&gt; llamada &lt;code&gt;CheckHidingSpotForTreasureMutation&lt;/code&gt; para mantener nuestra implementaci&amp;oacute;n de mutaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="8d0415201da41a689310dea9dfd9de53cb8630b3" translate="yes" xml:space="preserve">
          <source>Next, let's define a node interface and type. We only need to provide a way for Relay to map from an object to the GraphQL type associated with that object, and from a global ID to the object it points to:</source>
          <target state="translated">A continuación,definamos una interfaz y un tipo de nodo.Sólo tenemos que proporcionar una forma para que Relé se mapee desde un objeto al tipo de GraphQL asociado a ese objeto,y desde un ID global al objeto al que apunta:</target>
        </trans-unit>
        <trans-unit id="adc67eef09450d30c9ae37eeb2376e191eb49c0d" translate="yes" xml:space="preserve">
          <source>Next, let's define our game and hiding spot types, and the fields that are available on each.</source>
          <target state="translated">A continuación,definamos nuestros tipos de juego y de escondite,y los campos que están disponibles en cada uno.</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="5b3016b7b65c75156425ea4affe66b9292dbd049" translate="yes" xml:space="preserve">
          <source>No Routing</source>
          <target state="translated">No hay rutas</target>
        </trans-unit>
        <trans-unit id="2daa1a58378d3c4f7ceb9d6531c197c5be4d948b" translate="yes" xml:space="preserve">
          <source>Non-React functions can also take advantage of data masking. A fragment can be defined with the &lt;code&gt;@inline&lt;/code&gt; directive and stored in a local variable. The non-React function can then &quot;unmask&quot; the data using the &lt;code&gt;readInlineData&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="8591e7ed2e6e97908da94c56b629b41aa4eb0746" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;graphql&lt;/code&gt; template tags are &lt;strong&gt;never executed at runtime&lt;/strong&gt;. Instead, they are compiled ahead of time by the &lt;a href=&quot;#relay-compiler&quot;&gt;Relay Compiler&lt;/a&gt; into generated artifacts that live alongside your source code, and which Relay requires to operate at runtime. The &lt;a href=&quot;installation-and-setup#setup-babel-plugin-relay&quot;&gt;Relay Babel plugin&lt;/a&gt; will then convert the &lt;code&gt;graphql&lt;/code&gt; literals in your code into &lt;code&gt;require()&lt;/code&gt; calls for the generated files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ded70becacd440a8a5293ee572a86c4c58319833" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;ready&lt;/code&gt; and &lt;code&gt;done&lt;/code&gt; will continue to be false.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;ready&lt;/code&gt; y &lt;code&gt;done&lt;/code&gt; seguir&amp;aacute; siendo falso.</target>
        </trans-unit>
        <trans-unit id="7c2002c29e0fca7efc2e3f32bc61fca5000503d9" translate="yes" xml:space="preserve">
          <source>Note that it is &lt;em&gt;highly&lt;/em&gt; recommended that &lt;code&gt;Relay.Container&lt;/code&gt;s define their own fragments and avoid sharing inline &lt;code&gt;var fragment = Relay.QL...&lt;/code&gt; values between containers or files. If you find yourself wanting to share inline fragments, it's likely a sign that it's time to refactor and introduce a new container.</source>
          <target state="translated">Tenga en cuenta que se &lt;em&gt;recomienda&lt;/em&gt; encarecidamente que &lt;code&gt;Relay.Container&lt;/code&gt; s defina sus propios fragmentos y evite compartir valores &lt;code&gt;var fragment = Relay.QL...&lt;/code&gt; entre contenedores o archivos. Si desea compartir fragmentos en l&amp;iacute;nea, es probable que sea una se&amp;ntilde;al de que es hora de refactorizar e introducir un nuevo contenedor.</target>
        </trans-unit>
        <trans-unit id="0e023c69475bbeb6872432af3864e74233382b71" translate="yes" xml:space="preserve">
          <source>Note that these modules are &lt;em&gt;loosely coupled&lt;/em&gt;. For example, the compiler emits representations of queries in a well-defined format that the runtime consumes (the &quot;Concrete&quot; node interfaces in &lt;code&gt;RelayConcreteNode&lt;/code&gt;), such that the compiler implementation can be swapped out if desired. React/Relay relies only on the well-documented public interface of the runtime, such that the actual implementation can be swapped out (in fact, we've upgraded the classic Relay core to also implement this same API). We hope that this loose coupling will allow the community to explore new use-cases such as the development of specialized product APIs using the Relay runtime or integrations of the runtime with view libraries other than React.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6251d7c444bd5ea65a8e620b067b7ace419f0985" translate="yes" xml:space="preserve">
          <source>Note that this approach requires &lt;em&gt;n+1&lt;/em&gt; requests to the server: 1 to fetch the list, and &lt;em&gt;n&lt;/em&gt; to fetch each item. With GraphQL we can fetch the same data in a single network request to the server (without creating a custom endpoint that we'd then have to maintain):</source>
          <target state="translated">Tenga en cuenta que este enfoque requiere &lt;em&gt;n + 1&lt;/em&gt; solicitudes al servidor: 1 para obtener la lista y &lt;em&gt;n&lt;/em&gt; para obtener cada elemento. Con GraphQL podemos obtener los mismos datos en una sola solicitud de red al servidor (sin crear un punto final personalizado que luego tendr&amp;iacute;amos que mantener):</target>
        </trans-unit>
        <trans-unit id="41a9a091d399394a5944c5c0a394fb244440e004" translate="yes" xml:space="preserve">
          <source>Note that this is a basic example to help you get started. This example could be extended with additional features such as request/response caching (enabled e.g. when &lt;code&gt;cacheConfig.force&lt;/code&gt; is false) and uploading form data for mutations (the &lt;code&gt;uploadables&lt;/code&gt; parameter).</source>
          <target state="translated">Tenga en cuenta que este es un ejemplo b&amp;aacute;sico que le ayudar&amp;aacute; a empezar. Este ejemplo podr&amp;iacute;a ampliarse con funciones adicionales como el almacenamiento en cach&amp;eacute; de solicitudes / respuestas (habilitado, por ejemplo, cuando &lt;code&gt;cacheConfig.force&lt;/code&gt; es falso) y la carga de datos de formularios para mutaciones (el par&amp;aacute;metro &lt;code&gt;uploadables&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="18e979539b69c286787704dcc6ebc81753f2b6c9" translate="yes" xml:space="preserve">
          <source>Note that this normalized cache structure allows overlapping results to be cached without duplication. Each record is stored once regardless of how it is fetched. Let's return to the earlier example of inconsistent data and see how this cache helps in that scenario.</source>
          <target state="translated">Obsérvese que esta estructura de caché normalizada permite que los resultados superpuestos se almacenen en caché sin duplicación.Cada registro se almacena una vez,independientemente de cómo se obtenga.Volvamos al ejemplo anterior de datos inconsistentes y veamos cómo esta caché ayuda en ese escenario.</target>
        </trans-unit>
        <trans-unit id="6a3998469edc7ffa18da69953898b4c848c54481" translate="yes" xml:space="preserve">
          <source>Note that this solution will also work for &lt;em&gt;writes&lt;/em&gt;: any update to the cache will notify the affected views, and writes are just another thing that updates the cache.</source>
          <target state="translated">Tenga en cuenta que esta soluci&amp;oacute;n tambi&amp;eacute;n funcionar&amp;aacute; para &lt;em&gt;escrituras&lt;/em&gt; : cualquier actualizaci&amp;oacute;n de la cach&amp;eacute; notificar&amp;aacute; las vistas afectadas, y las escrituras son solo otra cosa que actualiza la cach&amp;eacute;.</target>
        </trans-unit>
        <trans-unit id="ac8054c10594bdd95e89a5e8a8673034de9d793b" translate="yes" xml:space="preserve">
          <source>Note that when composing fragments, the type of the composed fragment must match the field on the parent in which it is embedded. For example, it wouldn't make sense to embed a fragment of type &lt;code&gt;Story&lt;/code&gt; into a parent's field of type &lt;code&gt;User&lt;/code&gt;. Relay and GraphQL will provide helpful error messages if you get this wrong (and if they aren't helpful, let us know!).</source>
          <target state="translated">Tenga en cuenta que al componer fragmentos, el tipo de fragmento compuesto debe coincidir con el campo del padre en el que est&amp;aacute; incrustado. Por ejemplo, no tendr&amp;iacute;a sentido incrustar un fragmento de tipo &lt;code&gt;Story&lt;/code&gt; en el campo principal de tipo &lt;code&gt;User&lt;/code&gt; . Relay y GraphQL proporcionar&amp;aacute;n mensajes de error &amp;uacute;tiles si se equivoca (y si no son &amp;uacute;tiles, &amp;iexcl;av&amp;iacute;senos!).</target>
        </trans-unit>
        <trans-unit id="0cb3b8bd044c603524ff2409189dcccf98b3f39b" translate="yes" xml:space="preserve">
          <source>Note: Determining variable values at runtime</source>
          <target state="translated">Nota:Determinar los valores de las variables en tiempo de ejecución</target>
        </trans-unit>
        <trans-unit id="6eb6c807aac98e74096f64d7f8585ee557b93a39" translate="yes" xml:space="preserve">
          <source>Note: In most cases, it is possible to rely on the default singleton instance of the environment, which is exposed as &lt;code&gt;Relay.Store&lt;/code&gt;.</source>
          <target state="translated">Nota: En la mayor&amp;iacute;a de los casos, es posible confiar en la instancia singleton predeterminada del entorno, que se expone como &lt;code&gt;Relay.Store&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06bd725e4a6c3e529d4b86297fa0d602b821e04c" translate="yes" xml:space="preserve">
          <source>Note: This method may only be called once per instance.</source>
          <target state="translated">Nota:Este método sólo puede ser llamado una vez por instancia.</target>
        </trans-unit>
        <trans-unit id="a0e48b33fadd08f907218ada431ccb61eb2d094e" translate="yes" xml:space="preserve">
          <source>Notice that it immediately executes the next task. Relay manages the order of tasks to ensure a proper order of operations - the scheduler can't skip or reorder tasks, only decide when to execute the next one.</source>
          <target state="translated">Note que ejecuta inmediatamente la siguiente tarea.El relé gestiona el orden de las tareas para asegurar un orden adecuado de las operaciones-el programador no puede saltarse o reordenar las tareas,sólo decidir cuándo ejecutar la siguiente.</target>
        </trans-unit>
        <trans-unit id="c79f05d35d0a7eb36506bd3ab33a1f2773cfa554" translate="yes" xml:space="preserve">
          <source>Notice that the cursor is a base64 string. That's the pattern from earlier: the server is reminding us that this is an opaque string. We can pass this string back to the server as the &lt;code&gt;after&lt;/code&gt; argument to the &lt;code&gt;ships&lt;/code&gt; field, which will let us ask for the next three ships after the last one in the previous result:</source>
          <target state="translated">Observe que el cursor es una cadena base64. Ese es el patr&amp;oacute;n de antes: el servidor nos recuerda que esta es una cadena opaca. Podemos pasar esta cadena de nuevo al servidor como argumento &lt;code&gt;after&lt;/code&gt; al campo de &lt;code&gt;ships&lt;/code&gt; , que nos permitir&amp;aacute; preguntar por los siguientes tres barcos despu&amp;eacute;s del &amp;uacute;ltimo en el resultado anterior:</target>
        </trans-unit>
        <trans-unit id="3aca59c767d5ed557222dbb5b8557469ae3a4a7f" translate="yes" xml:space="preserve">
          <source>Notice that we're querying for data that &lt;em&gt;may&lt;/em&gt; have changed as a result of the mutation. An obvious question is: why can't the server just tell us what changed? The answer is: it's complicated. GraphQL abstracts over &lt;em&gt;any&lt;/em&gt; data storage layer (or an aggregation of multiple sources), and works with any programming language. Furthermore, the goal of GraphQL is to provide data in a form that is useful to product developers building a view.</source>
          <target state="translated">Tenga en cuenta que estamos buscando datos que &lt;em&gt;pueden&lt;/em&gt; haber cambiado como resultado de la mutaci&amp;oacute;n. Una pregunta obvia es: &amp;iquest;por qu&amp;eacute; el servidor no puede simplemente decirnos qu&amp;eacute; cambi&amp;oacute;? La respuesta es: es complicado. GraphQL abstrae &lt;em&gt;cualquier&lt;/em&gt; capa de almacenamiento de datos (o una agregaci&amp;oacute;n de m&amp;uacute;ltiples fuentes) y funciona con cualquier lenguaje de programaci&amp;oacute;n. Adem&amp;aacute;s, el objetivo de GraphQL es proporcionar datos en una forma que sea &amp;uacute;til para los desarrolladores de productos que crean una vista.</target>
        </trans-unit>
        <trans-unit id="056ee5771da852e979294339f6d61f3371dc9784" translate="yes" xml:space="preserve">
          <source>Now Relay will both fetch the larger photo size &lt;em&gt;and&lt;/em&gt;&lt;code&gt;Child&lt;/code&gt; will know to render it.</source>
          <target state="translated">Ahora, Relay obtendr&amp;aacute; el tama&amp;ntilde;o de foto m&amp;aacute;s grande &lt;em&gt;y el &lt;/em&gt; &lt;code&gt;Child&lt;/code&gt; sabr&amp;aacute; renderizarlo.</target>
        </trans-unit>
        <trans-unit id="359fab9a105cb172833a57b904a4f78ae21bf6b3" translate="yes" xml:space="preserve">
          <source>Now Relay will fetch the photo with size 128 - but the &lt;code&gt;Child&lt;/code&gt; container won't magically know about this variable. We have to tell it by passing the variable value as a prop:</source>
          <target state="translated">Ahora Relay buscar&amp;aacute; la foto con tama&amp;ntilde;o 128, pero el contenedor &lt;code&gt;Child&lt;/code&gt; no sabr&amp;aacute; m&amp;aacute;gicamente sobre esta variable. Tenemos que decirlo pasando el valor de la variable como prop:</target>
        </trans-unit>
        <trans-unit id="8f4ea81858f10f7f357b3da216fb14eb06c577cc" translate="yes" xml:space="preserve">
          <source>Now let's associate these types with the root query type.</source>
          <target state="translated">Ahora vamos a asociar estos tipos con el tipo de consulta de la raíz.</target>
        </trans-unit>
        <trans-unit id="ee5dbc563862c37bd2eddab0d2faa5a3c1303875" translate="yes" xml:space="preserve">
          <source>Now let's take a closer look at the &lt;code&gt;config&lt;/code&gt;:</source>
          <target state="translated">Ahora echemos un vistazo m&amp;aacute;s de cerca a la &lt;code&gt;config&lt;/code&gt; uraci&amp;oacute;n :</target>
        </trans-unit>
        <trans-unit id="c63c75c8f04bcbaded3abd8323247dbc014c15ac" translate="yes" xml:space="preserve">
          <source>Now that we've gone through this tutorial, let's dive into what it means to build a GraphQL client framework and how this compares to clients for more traditional REST systems.</source>
          <target state="translated">Ahora que hemos repasado este tutorial,vamos a sumergirnos en lo que significa construir un marco de clientes GraphQL y cómo se compara con los clientes de los sistemas REST más tradicionales.</target>
        </trans-unit>
        <trans-unit id="3c8e0a4e6791c0f1c68af7b94cb67e9dddbecd93" translate="yes" xml:space="preserve">
          <source>Now we can instantiate a &lt;code&gt;ProfileRoute&lt;/code&gt; that fetches data for user &lt;code&gt;123&lt;/code&gt;:</source>
          <target state="translated">Ahora podemos crear una instancia de &lt;code&gt;ProfileRoute&lt;/code&gt; que obtenga datos para el usuario &lt;code&gt;123&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d3cbdecefa56176a7edca66548a54ce86a3ed688" translate="yes" xml:space="preserve">
          <source>Now, requests for previously cached data can be answered immediately without making a network request. This is a practical approach to improving the perceived performance of an application. However, this method of caching can cause problems with data consistency.</source>
          <target state="translated">Ahora,las solicitudes de datos previamente almacenados en la memoria caché pueden ser respondidas inmediatamente sin hacer una solicitud de red.Este es un enfoque práctico para mejorar el rendimiento percibido de una aplicación.Sin embargo,este método de almacenamiento en caché puede causar problemas de consistencia de los datos.</target>
        </trans-unit>
        <trans-unit id="c7d436121cc7de83cd8afcc9e5b08145f88e3d72" translate="yes" xml:space="preserve">
          <source>Object Identification</source>
          <target state="translated">Identificación de objetos</target>
        </trans-unit>
        <trans-unit id="509d0e819f7363f119680482f06c06df5503cfc0" translate="yes" xml:space="preserve">
          <source>On the Relay Container the prop &lt;code&gt;bars&lt;/code&gt; will be an array instead of an object.</source>
          <target state="translated">En el Relay Container, las &lt;code&gt;bars&lt;/code&gt; apoyo ser&amp;aacute;n una matriz en lugar de un objeto.</target>
        </trans-unit>
        <trans-unit id="258ab7d6dd3b683b7bd3f1f1a9e4c26dc064e05d" translate="yes" xml:space="preserve">
          <source>On the other hand, GraphQL &lt;strong&gt;fragments&lt;/strong&gt; declare fields that exist on any arbitrary type. For example, the following fragment fetches the profile picture URI for &lt;em&gt;some&lt;/em&gt;&lt;code&gt;User&lt;/code&gt;.</source>
          <target state="translated">Por otro lado, los &lt;strong&gt;fragmentos&lt;/strong&gt; GraphQL declaran campos que existen en cualquier tipo arbitrario. Por ejemplo, el siguiente fragmento recupera el URI de la imagen de perfil de &lt;em&gt;alg&amp;uacute;n &lt;/em&gt; &lt;code&gt;User&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e77ad76d86248c3f5b3430ab7a50cf954c824781" translate="yes" xml:space="preserve">
          <source>Once a few or all of your views are using &lt;code&gt;QueryRenderer&lt;/code&gt;, &lt;code&gt;Store&lt;/code&gt; from &lt;code&gt;'react-relay/classic'&lt;/code&gt; could be replaced with a &lt;code&gt;RelayModernEnvironment&lt;/code&gt;. Keep in mind that &lt;code&gt;RelayModernEnvironment&lt;/code&gt; and &lt;code&gt;Store&lt;/code&gt; do not share any data. You might want to hold off on this step until views that have significant data overlap can be switched over at the same time. This step is what unlocks the perf wins for your app. Apps using the &lt;code&gt;RelayModernEnvironment&lt;/code&gt; get to send persisted query IDs instead of the full query strings to the server, as well as much more optimized data normalizing and processing.</source>
          <target state="translated">Una vez que algunas o todas sus vistas est&amp;eacute;n usando &lt;code&gt;QueryRenderer&lt;/code&gt; , &lt;code&gt;Store&lt;/code&gt; from &lt;code&gt;'react-relay/classic'&lt;/code&gt; podr&amp;iacute;a reemplazarse con un &lt;code&gt;RelayModernEnvironment&lt;/code&gt; . Tenga en cuenta que &lt;code&gt;RelayModernEnvironment&lt;/code&gt; y &lt;code&gt;Store&lt;/code&gt; no comparten ning&amp;uacute;n dato. Es posible que desee retrasar este paso hasta que las vistas que tienen una superposici&amp;oacute;n de datos significativa se puedan cambiar al mismo tiempo. Este paso es lo que desbloquea las ganancias de rendimiento para su aplicaci&amp;oacute;n. Las aplicaciones que utilizan &lt;code&gt;RelayModernEnvironment&lt;/code&gt; pueden enviar ID de consultas persistentes en lugar de las cadenas de consulta completas al servidor, as&amp;iacute; como una normalizaci&amp;oacute;n y procesamiento de datos mucho m&amp;aacute;s optimizados.</target>
        </trans-unit>
        <trans-unit id="aa26441141ed7039f7d3b90dda06bb5985300871" translate="yes" xml:space="preserve">
          <source>Once all the components and mutations have been converted to use the Relay Modern APIs, convert to using &lt;code&gt;QueryRenderer&lt;/code&gt; instead of using &lt;code&gt;Relay.Renderer&lt;/code&gt; or &lt;code&gt;Relay.RootContainer&lt;/code&gt;. You may supply &lt;code&gt;Store&lt;/code&gt; from &lt;code&gt;'react-relay/classic'&lt;/code&gt; as the &lt;code&gt;environment&lt;/code&gt; for most cases.</source>
          <target state="translated">Una vez que todos los componentes y mutaciones se hayan convertido para usar las API de Relay Modern, &lt;code&gt;QueryRenderer&lt;/code&gt; para usar QueryRenderer en lugar de usar &lt;code&gt;Relay.Renderer&lt;/code&gt; o &lt;code&gt;Relay.RootContainer&lt;/code&gt; . Puede proporcionar &lt;code&gt;Store&lt;/code&gt; desde &lt;code&gt;'react-relay/classic'&lt;/code&gt; como &lt;code&gt;environment&lt;/code&gt; en la mayor&amp;iacute;a de los casos.</target>
        </trans-unit>
        <trans-unit id="526a2470452cfa759c69b07a4cdac3145513395b" translate="yes" xml:space="preserve">
          <source>Once with &lt;code&gt;error&lt;/code&gt; set to an &lt;code&gt;Error&lt;/code&gt; object.</source>
          <target state="translated">Una vez con el &lt;code&gt;error&lt;/code&gt; establecido en un objeto &lt;code&gt;Error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d30a28f0a20b5fda3d127c2ba900c1393a0c802c" translate="yes" xml:space="preserve">
          <source>Once with &lt;code&gt;ready&lt;/code&gt; and &lt;code&gt;done&lt;/code&gt; set to true, but &lt;code&gt;stale&lt;/code&gt; set to false.</source>
          <target state="translated">Una vez con &lt;code&gt;ready&lt;/code&gt; y &lt;code&gt;done&lt;/code&gt; establecido en verdadero, pero &lt;code&gt;stale&lt;/code&gt; establecido en falso.</target>
        </trans-unit>
        <trans-unit id="c510443cbc7ffd35f869abc94218360943f66d9e" translate="yes" xml:space="preserve">
          <source>Once with &lt;code&gt;ready&lt;/code&gt; and &lt;code&gt;done&lt;/code&gt; set to true.</source>
          <target state="translated">Una vez que &lt;code&gt;ready&lt;/code&gt; y &lt;code&gt;done&lt;/code&gt; establezca el valor verdadero.</target>
        </trans-unit>
        <trans-unit id="9b048c01bc7fa82617b39cb08502f943e54b8d4a" translate="yes" xml:space="preserve">
          <source>Once with &lt;code&gt;ready&lt;/code&gt; set to false.</source>
          <target state="translated">Una vez con &lt;code&gt;ready&lt;/code&gt; establecido en falso.</target>
        </trans-unit>
        <trans-unit id="fe545c0159939d91c25a89db650c07bece33f470" translate="yes" xml:space="preserve">
          <source>Once with &lt;code&gt;ready&lt;/code&gt;, &lt;code&gt;done&lt;/code&gt;, and &lt;code&gt;stale&lt;/code&gt; set to true.</source>
          <target state="translated">Una vez que &lt;code&gt;ready&lt;/code&gt; , &lt;code&gt;done&lt;/code&gt; y &lt;code&gt;stale&lt;/code&gt; configurado en verdadero.</target>
        </trans-unit>
        <trans-unit id="c8f5f6a359004092335c67ac77552d54cac29a5a" translate="yes" xml:space="preserve">
          <source>Once you have an environment, you can pass it in to your &lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt; instance, or into mutations via the &lt;code&gt;commitUpdate&lt;/code&gt; function (see &quot;&lt;a href=&quot;mutations&quot;&gt;Mutations&lt;/a&gt;&quot;).</source>
          <target state="translated">Una vez que tenga un entorno, puede pasarlo a su instancia de &lt;a href=&quot;query-renderer&quot;&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;/a&gt; , o en mutaciones a trav&amp;eacute;s de la funci&amp;oacute;n &lt;code&gt;commitUpdate&lt;/code&gt; (ver &quot; &lt;a href=&quot;mutations&quot;&gt;Mutaciones&lt;/a&gt; &quot;).</target>
        </trans-unit>
        <trans-unit id="3445237f2d0762c974ff895551ac18ecb7b0fd39" translate="yes" xml:space="preserve">
          <source>One of the big ideas behind the new API is that execution can be made a lot more efficient by moving work ahead-of-time: from the runtime of the app to the build-time. As such, changes to GraphQL fragments require a build step to regenerate a set of artifacts. More on &lt;a href=&quot;relay-compiler&quot;&gt;the Relay Compiler&lt;/a&gt;.</source>
          <target state="translated">Una de las grandes ideas detr&amp;aacute;s de la nueva API es que la ejecuci&amp;oacute;n se puede hacer mucho m&amp;aacute;s eficiente adelantando el trabajo: desde el tiempo de ejecuci&amp;oacute;n de la aplicaci&amp;oacute;n hasta el tiempo de compilaci&amp;oacute;n. Como tal, los cambios en los fragmentos de GraphQL requieren un paso de compilaci&amp;oacute;n para regenerar un conjunto de artefactos. M&amp;aacute;s sobre &lt;a href=&quot;relay-compiler&quot;&gt;el compilador de retransmisiones&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e9e3088ad7030f31124174e1ea72f79d6e9860c5" translate="yes" xml:space="preserve">
          <source>One of the main goals of the compiler is to provide a consistent platform for writing tools that transform or optimize GraphQL. This includes the ability to experiment with new directives by transforming them away at compile time. Transform functions should typically perform a single type of modification - it's expected that an app will have multiple transforms configured in the compiler instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad501b8fa6c8a155c72db2494b37eb05a27af8e5" translate="yes" xml:space="preserve">
          <source>One solution is to have a root component fetch the data for all its children. However, this would introduce coupling: every change to a component would require changing &lt;em&gt;any&lt;/em&gt; root component that might render it, and often some components between it and the root. This coupling could mean a greater chance for bugs and slow the pace of development. Ultimately, this approach doesn't take advantage of React's component model. The natural place for specifying data-dependencies was in &lt;em&gt;components&lt;/em&gt;.</source>
          <target state="translated">Una soluci&amp;oacute;n es que un componente ra&amp;iacute;z obtenga los datos de todos sus elementos secundarios. Sin embargo, esto introducir&amp;iacute;a acoplamiento: cada cambio en un componente requerir&amp;iacute;a cambiar &lt;em&gt;cualquier&lt;/em&gt; componente ra&amp;iacute;z que pudiera representarlo y, a menudo, algunos componentes entre &amp;eacute;l y la ra&amp;iacute;z. Este acoplamiento podr&amp;iacute;a significar una mayor probabilidad de errores y ralentizar el ritmo de desarrollo. En &amp;uacute;ltima instancia, este enfoque no aprovecha el modelo de componentes de React. El lugar natural para especificar las dependencias de datos eran los &lt;em&gt;componentes&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6b5a7ba3ecdf80b9b9c9285e7c15e081d2c4cfd9" translate="yes" xml:space="preserve">
          <source>One thing is left in the example above &amp;mdash; implementing &lt;code&gt;setSize()&lt;/code&gt;, which should change the photo's size when the slider values changes. In addition to passing the results of each query to the component, Relay also provides a &lt;code&gt;relay&lt;/code&gt; prop that has Relay-specific methods and metadata. These include &lt;code&gt;variables&lt;/code&gt; &amp;mdash; the active variables used to fetch the current &lt;code&gt;props&lt;/code&gt; &amp;mdash; and &lt;code&gt;setVariables()&lt;/code&gt; &amp;mdash; a callback that can be used to request data for different variable values.</source>
          <target state="translated">En el ejemplo anterior queda una cosa: implementar &lt;code&gt;setSize()&lt;/code&gt; , que deber&amp;iacute;a cambiar el tama&amp;ntilde;o de la foto cuando cambien los valores del control deslizante. Adem&amp;aacute;s de pasar los resultados de cada consulta al componente, Relay tambi&amp;eacute;n proporciona un accesorio de &lt;code&gt;relay&lt;/code&gt; que tiene m&amp;eacute;todos y metadatos espec&amp;iacute;ficos de Relay. Estos incluyen &lt;code&gt;variables&lt;/code&gt; , las variables activas que se usan para obtener los &lt;code&gt;props&lt;/code&gt; actuales , y &lt;code&gt;setVariables()&lt;/code&gt; , una devoluci&amp;oacute;n de llamada que se puede usar para solicitar datos para diferentes valores de variable.</target>
        </trans-unit>
        <trans-unit id="43ec0f0f8cb785cd4021b95098b6011da01043b4" translate="yes" xml:space="preserve">
          <source>Only fields specified by these fragments will be populated in &lt;code&gt;this.props&lt;/code&gt; when the component is rendered. This ensures that there are no implicit dependencies from a component on its parent component or any child components.</source>
          <target state="translated">Solo los campos especificados por estos fragmentos se completar&amp;aacute;n en &lt;code&gt;this.props&lt;/code&gt; cuando se procese el componente. Esto asegura que no haya dependencias impl&amp;iacute;citas de un componente en su componente principal o en cualquier componente secundario.</target>
        </trans-unit>
        <trans-unit id="cda4387bc6920d739a4c52a2c0a31c33103f5562" translate="yes" xml:space="preserve">
          <source>Optimistic Updates</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="544901021486ff794813761281a30a85a9ea2561" translate="yes" xml:space="preserve">
          <source>Optimistic updates</source>
          <target state="translated">Actualizaciones optimistas</target>
        </trans-unit>
        <trans-unit id="75e97d82c2ab23fae3c5ae0de671aad8aaab254b" translate="yes" xml:space="preserve">
          <source>Optimistically updating the UI while waiting for the server to respond to mutations.</source>
          <target state="translated">Actualizando de forma optimista la interfaz de usuario mientras se espera a que el servidor responda a las mutaciones.</target>
        </trans-unit>
        <trans-unit id="a30573ebcc5462272b8ba6828cf0b15e88284677" translate="yes" xml:space="preserve">
          <source>Option 1: Re-fetch everything that the app has ever queried. Even though only a small subset of this data will actually change, we'll still have to wait for the server to execute the &lt;em&gt;entire&lt;/em&gt; query, wait to download the results, and wait to process them again. This is very inefficient.</source>
          <target state="translated">Opci&amp;oacute;n 1: Vuelva a buscar todo lo que la aplicaci&amp;oacute;n haya consultado. Aunque solo un peque&amp;ntilde;o subconjunto de estos datos realmente cambiar&amp;aacute;, todav&amp;iacute;a tendremos que esperar a que el servidor ejecute la consulta &lt;em&gt;completa&lt;/em&gt; , esperar a descargar los resultados y esperar a procesarlos nuevamente. Esto es muy ineficiente.</target>
        </trans-unit>
        <trans-unit id="7c7f0ed28de8faafd0afd103f17d025324ed7cc5" translate="yes" xml:space="preserve">
          <source>Option 2: Re-fetch only the queries required by actively rendered views. This is a slight improvement over option 1. However, cached data that &lt;em&gt;isn't&lt;/em&gt; currently being viewed won't be updated. Unless this data is somehow marked as stale or evicted from the cache subsequent queries will read outdated information.</source>
          <target state="translated">Opci&amp;oacute;n 2: Recupere solo las consultas requeridas por las vistas renderizadas activamente. Esta es una ligera mejora con respecto a la opci&amp;oacute;n 1. Sin embargo, los datos almacenados en cach&amp;eacute; que &lt;em&gt;no&lt;/em&gt; se ven actualmente no se actualizar&amp;aacute;n. A menos que estos datos se marquen de alguna manera como obsoletos o se eliminen de la memoria cach&amp;eacute;, las consultas posteriores leer&amp;aacute;n informaci&amp;oacute;n desactualizada.</target>
        </trans-unit>
        <trans-unit id="1fc54acb388aaf56464909787927f5c9cc6c305b" translate="yes" xml:space="preserve">
          <source>Option 3: Re-fetch a fixed list of fields that &lt;em&gt;may&lt;/em&gt; change after the mutation. We'll call this list a &lt;strong&gt;fat query&lt;/strong&gt;. We found this to also be inefficient because typical applications only render a subset of the fat query, but this approach would require fetching all of those fields.</source>
          <target state="translated">Opci&amp;oacute;n 3: recuperar una lista fija de campos que &lt;em&gt;pueden&lt;/em&gt; cambiar despu&amp;eacute;s de la mutaci&amp;oacute;n. Llamaremos a esta lista una &lt;strong&gt;consulta gruesa&lt;/strong&gt; . Descubrimos que esto tambi&amp;eacute;n es ineficiente porque las aplicaciones t&amp;iacute;picas solo procesan un subconjunto de la consulta fat, pero este enfoque requerir&amp;iacute;a obtener todos esos campos.</target>
        </trans-unit>
        <trans-unit id="4be11d572e3b53b4fc22dae76efc2d670f4be4bb" translate="yes" xml:space="preserve">
          <source>Option 4 (Relay): Re-fetch the intersection of what may change (the fat query) and the data in the cache. In addition to the cache of data Relay also remembers the queries used to fetch each item. These are called &lt;strong&gt;tracked queries&lt;/strong&gt;. By intersecting the tracked and fat queries, Relay can query exactly the set of information the application needs to update and nothing more.</source>
          <target state="translated">Opci&amp;oacute;n 4 (retransmisi&amp;oacute;n): vuelva a buscar la intersecci&amp;oacute;n de lo que puede cambiar (la consulta fat) y los datos en la cach&amp;eacute;. Adem&amp;aacute;s de la cach&amp;eacute; de datos, Relay tambi&amp;eacute;n recuerda las consultas utilizadas para buscar cada elemento. Se denominan &lt;strong&gt;consultas de seguimiento&lt;/strong&gt; . Al cruzar las consultas rastreadas y pesadas, Relay puede consultar exactamente el conjunto de informaci&amp;oacute;n que la aplicaci&amp;oacute;n necesita actualizar y nada m&amp;aacute;s.</target>
        </trans-unit>
        <trans-unit id="6718713de12ca02e84822e47bd7f3094f39d3c0a" translate="yes" xml:space="preserve">
          <source>Optionally install globally</source>
          <target state="translated">Opcionalmente instalar globalmente</target>
        </trans-unit>
        <trans-unit id="b30829da1c673e16f6adae2f5da589d2b2d65970" translate="yes" xml:space="preserve">
          <source>Optionally, follow up with a call to &lt;code&gt;commit()&lt;/code&gt; to send the mutation to the server.</source>
          <target state="translated">Opcionalmente, haga un seguimiento con una llamada a &lt;code&gt;commit()&lt;/code&gt; para enviar la mutaci&amp;oacute;n al servidor.</target>
        </trans-unit>
        <trans-unit id="2495cf5d8b7fcd84a593bb8a6590867f01c41c54" translate="yes" xml:space="preserve">
          <source>Optionally, if the field takes arguments, you can pass a bag of &lt;code&gt;variables&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59edbb8c9de82b3a53b356bdf14020ccb99fbd8d" translate="yes" xml:space="preserve">
          <source>Optionally, if the linked record takes arguments, you can pass a bag of &lt;code&gt;variables&lt;/code&gt; as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a603142c92a8b820560fb3bf1b12553420c3f4e" translate="yes" xml:space="preserve">
          <source>Optionally, precede with a call to &lt;code&gt;applyOptimistic()&lt;/code&gt; to apply an update optimistically to the store.</source>
          <target state="translated">Opcionalmente, preceda con una llamada a &lt;code&gt;applyOptimistic()&lt;/code&gt; para aplicar una actualizaci&amp;oacute;n de manera optimista a la tienda.</target>
        </trans-unit>
        <trans-unit id="ae17e1897a8cc791f789d5b34d32406b1c727d64" translate="yes" xml:space="preserve">
          <source>Or this way, with the same results:</source>
          <target state="translated">O de esta manera,con los mismos resultados:</target>
        </trans-unit>
        <trans-unit id="fb12379af7dcaf01e91c059811ab5e2548a2134c" translate="yes" xml:space="preserve">
          <source>Or, a function that receives the previous set of variables used to query the data, and returns a new set of variables to pass to the &lt;code&gt;refetchQuery&lt;/code&gt; when fetching it from the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50300a6866222e559def812f5df571c9176ba61e" translate="yes" xml:space="preserve">
          <source>Overrides the &lt;a href=&quot;#defaultnetworklayer-static-property&quot;&gt;DefaultNetworkLayer&lt;/a&gt;.</source>
          <target state="translated">Reemplaza el &lt;a href=&quot;#defaultnetworklayer-static-property&quot;&gt;DefaultNetworkLayer&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fd55d4fdc76dc273300987b3c56489168f507c74" translate="yes" xml:space="preserve">
          <source>Overriding Fragment Variables</source>
          <target state="translated">Anulando las variables de los fragmentos</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="100325b8d6de92dc6ff09cd2c078133755bf274f" translate="yes" xml:space="preserve">
          <source>Pagination</source>
          <target state="translated">Pagination</target>
        </trans-unit>
        <trans-unit id="1847eac49f0862bab8cf4f3614ad739655005e7f" translate="yes" xml:space="preserve">
          <source>Pagination Container</source>
          <target state="translated">Contenedor de paginación</target>
        </trans-unit>
        <trans-unit id="0ca043a41b0b3d0ddc8649acdd7e8b58bdcfa73a" translate="yes" xml:space="preserve">
          <source>Pagination Container is also a &lt;a href=&quot;https://reactjs.org/docs/higher-order-components.html&quot;&gt;higher-order component&lt;/a&gt;, similar to a &lt;a href=&quot;fragment-container&quot;&gt;Fragment Container&lt;/a&gt;, that is designed to simplify the workflow of loading more items in a list &amp;mdash; in many cases, we don't want to fetch all the data at once but lazily load more data. It relies on a GraphQL server exposing connections in a standardized way. For a detailed spec, please check out &lt;a href=&quot;https://relay.dev/graphql/connections.htm&quot;&gt;this page&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b747c351b01284c892ae1864f74451400f8ded9b" translate="yes" xml:space="preserve">
          <source>Pagination Container works in a very similar way to the &lt;a href=&quot;fragment-container&quot;&gt;Fragment Container&lt;/a&gt; in that you also specify the data requirements for a component via GraphQL fragments in the &lt;code&gt;fragmentSpec&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41bdd858e1fe37bddb1f310d8bfca6222b7c844d" translate="yes" xml:space="preserve">
          <source>Pagination Example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66cd194918cca0919b19b5c19a6632d8edf7c051" translate="yes" xml:space="preserve">
          <source>PaginationContainer</source>
          <target state="translated">PaginationContainer</target>
        </trans-unit>
        <trans-unit id="aede896343f70495123a4970ce699b9a49ceb28f" translate="yes" xml:space="preserve">
          <source>Passing Arguments to a Fragment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="1037cd9d1a4502e08db2f7acc00d0bfad2fb05f5" translate="yes" xml:space="preserve">
          <source>Persisted queries can be enabled by instructing Relay Compiler to emit metadata about each query, mutation, and subscription into a JSON file. The generated file will contain a mapping of query identifiers to query text, which you can then save to your server. To enable persisted queries, use the &lt;code&gt;--persist-output&lt;/code&gt; flag to the compiler:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c55665b87f33041af7083942a79f605ac2526995" translate="yes" xml:space="preserve">
          <source>Persisting queries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a9a81786a3cd10e92834a3ac1d48bcd7f39e6e3" translate="yes" xml:space="preserve">
          <source>Please note that the &lt;code&gt;&quot;relay&quot;&lt;/code&gt; plugin should run before other plugins or presets to ensure the &lt;code&gt;graphql&lt;/code&gt; template literals are correctly transformed. See Babel's &lt;a href=&quot;https://babeljs.io/docs/plugins/#plugin-preset-ordering&quot;&gt;documentation on this topic&lt;/a&gt;.</source>
          <target state="translated">Tenga en cuenta que el complemento &lt;code&gt;&quot;relay&quot;&lt;/code&gt; debe ejecutarse antes que otros complementos o ajustes preestablecidos para garantizar que los literales de la plantilla &lt;code&gt;graphql&lt;/code&gt; se transformen correctamente. Consulte la &lt;a href=&quot;https://babeljs.io/docs/plugins/#plugin-preset-ordering&quot;&gt;documentaci&amp;oacute;n&lt;/a&gt; de Babel sobre este tema .</target>
        </trans-unit>
        <trans-unit id="02a0a62fe61678e8a433343395761ce593ca76c7" translate="yes" xml:space="preserve">
          <source>Please note that this replaces the &lt;a href=&quot;guides-babel-plugin&quot;&gt;older Babel Relay plugin&lt;/a&gt;. It is not necessary to include both plugins.</source>
          <target state="translated">Tenga en cuenta que esto reemplaza al &lt;a href=&quot;guides-babel-plugin&quot;&gt;antiguo complemento Babel Relay&lt;/a&gt; . No es necesario incluir ambos complementos.</target>
        </trans-unit>
        <trans-unit id="c6a15b9b600a39666d059f44d5e217d0eadd28f6" translate="yes" xml:space="preserve">
          <source>Populating The Cache</source>
          <target state="translated">Poblar el caché</target>
        </trans-unit>
        <trans-unit id="9ef1894fd67a6660f9dc545b85fdd7563a957682" translate="yes" xml:space="preserve">
          <source>Populating the cache involves walking a hierarchical GraphQL response and creating or updating normalized cache records. At first it may seem that the response alone is sufficient to process the response, but in fact this is only true for very simple queries. Consider &lt;code&gt;user(id: &quot;456&quot;) { photo(size: 32) { uri } }&lt;/code&gt; &amp;mdash; how should we store &lt;code&gt;photo&lt;/code&gt;? Using &lt;code&gt;photo&lt;/code&gt; as the field name in the cache won't work because a different query might fetch the same field but with different argument values (e.g. &lt;code&gt;photo(size: 64) {...}&lt;/code&gt;). A similar issue occurs with pagination. If we fetch the 11th to 20th stories with &lt;code&gt;stories(first: 10, offset: 10)&lt;/code&gt;, these new results should be &lt;em&gt;appended&lt;/em&gt; to the existing list.</source>
          <target state="translated">Llenar la cach&amp;eacute; implica recorrer una respuesta GraphQL jer&amp;aacute;rquica y crear o actualizar registros de cach&amp;eacute; normalizados. Al principio puede parecer que la respuesta por s&amp;iacute; sola es suficiente para procesar la respuesta, pero de hecho esto solo es cierto para consultas muy simples. Considere el &lt;code&gt;user(id: &quot;456&quot;) { photo(size: 32) { uri } }&lt;/code&gt; - &amp;iquest;c&amp;oacute;mo debemos almacenar la &lt;code&gt;photo&lt;/code&gt; ? El uso de &lt;code&gt;photo&lt;/code&gt; como nombre de campo en la cach&amp;eacute; no funcionar&amp;aacute; porque una consulta diferente puede obtener el mismo campo pero con diferentes valores de argumento (por ejemplo, &lt;code&gt;photo(size: 64) {...}&lt;/code&gt; ). Un problema similar ocurre con la paginaci&amp;oacute;n. Si buscamos las historias 11 a 20 con &lt;code&gt;stories(first: 10, offset: 10)&lt;/code&gt; , estos nuevos resultados deben &lt;em&gt;agregarse&lt;/em&gt; a la lista existente.</target>
        </trans-unit>
        <trans-unit id="178213e972c712d32c9b754e0fae0660405a3262" translate="yes" xml:space="preserve">
          <source>Processing the schema</source>
          <target state="translated">Procesamiento del esquema</target>
        </trans-unit>
        <trans-unit id="2765c8e15a74b74082d61d103e52529812b42ae8" translate="yes" xml:space="preserve">
          <source>Products access the store primarily via &lt;code&gt;lookup()&lt;/code&gt; and &lt;code&gt;subscribe()&lt;/code&gt;. Lookup reads the initial results of a fragment, and subscribe observes that result for any changes. Note that the output of &lt;code&gt;lookup()&lt;/code&gt; - a &lt;code&gt;Snapshot&lt;/code&gt; - is the input to &lt;code&gt;subscribe()&lt;/code&gt;. This is important because the snapshot contains important information that can be used to optimize the subscription - if &lt;code&gt;subscribe()&lt;/code&gt; accepted only a &lt;code&gt;Selector&lt;/code&gt;, it would have to re-read the results in order to know what to subscribe to, which is less efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fb705d5e8095ddb73ff47bd5a3af904d3ea97b5" translate="yes" xml:space="preserve">
          <source>PropTypes</source>
          <target state="translated">PropTypes</target>
        </trans-unit>
        <trans-unit id="bc6c88db2f0703a9e2461a4a8060ccf1cb881998" translate="yes" xml:space="preserve">
          <source>Properties</source>
          <target state="translated">Properties</target>
        </trans-unit>
        <trans-unit id="1100c030f3dc539b64e7700624cabb080430dd57" translate="yes" xml:space="preserve">
          <source>Properties and Methods</source>
          <target state="translated">Propiedades y métodos</target>
        </trans-unit>
        <trans-unit id="e5561bc237fb41709bb2e8b651d704c1664ae03e" translate="yes" xml:space="preserve">
          <source>Props</source>
          <target state="translated">Props</target>
        </trans-unit>
        <trans-unit id="f626c322addc21ad81e099b4b257742e4b44fa03" translate="yes" xml:space="preserve">
          <source>Publishing the results updates the store but does &lt;em&gt;not&lt;/em&gt; immediately notify any subscribers. This is accomplished by calling &lt;code&gt;notify()&lt;/code&gt;...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32bb9f0eed56ead65c951dc161935d4389c8dfcc" translate="yes" xml:space="preserve">
          <source>QL</source>
          <target state="translated">QL</target>
        </trans-unit>
        <trans-unit id="0fa0f7a77beffe015e3dbe50d9707a0cef073bae" translate="yes" xml:space="preserve">
          <source>Queries vs. Fragments</source>
          <target state="translated">Consultas vs.Fragmentos</target>
        </trans-unit>
        <trans-unit id="715a8fe94c1d42fc9dfbb4b5057bd51288856fd1" translate="yes" xml:space="preserve">
          <source>Query Naming Convention</source>
          <target state="translated">Convención sobre la denominación de las consultas</target>
        </trans-unit>
        <trans-unit id="0f4abb2dc94c20672b1e17a54e1138df9766d152" translate="yes" xml:space="preserve">
          <source>Query Renderer</source>
          <target state="translated">Query Renderer</target>
        </trans-unit>
        <trans-unit id="64c6ced3f69ca25be02a6b4eb81804275f87ea3e" translate="yes" xml:space="preserve">
          <source>QueryConfig</source>
          <target state="translated">QueryConfig</target>
        </trans-unit>
        <trans-unit id="92ed502ab1f6d9e04d58803b1ef2281c76306e49" translate="yes" xml:space="preserve">
          <source>QueryRenderer</source>
          <target state="translated">QueryRenderer</target>
        </trans-unit>
        <trans-unit id="004b0b56745c5867ceb6c95eccae46bc9634eca6" translate="yes" xml:space="preserve">
          <source>Queuing mutations to avoid race conditions.</source>
          <target state="translated">Mutaciones de cola para evitar las condiciones de la raza.</target>
        </trans-unit>
        <trans-unit id="455083cac2ae96eabe3895762b6080aa09e6afa4" translate="yes" xml:space="preserve">
          <source>Quick Start</source>
          <target state="translated">Inicio rápido</target>
        </trans-unit>
        <trans-unit id="c22fa04a8b6a77a7856984111524e39134e2d44d" translate="yes" xml:space="preserve">
          <source>RANGE_ADD</source>
          <target state="translated">RANGE_ADD</target>
        </trans-unit>
        <trans-unit id="a5c0b5daae0eddce515d43e69bbf8ebe6c085aa7" translate="yes" xml:space="preserve">
          <source>RANGE_DELETE</source>
          <target state="translated">RANGE_DELETE</target>
        </trans-unit>
        <trans-unit id="65b00e2a3b97ba71c6979a03111363ff814865c1" translate="yes" xml:space="preserve">
          <source>REQUIRED_CHILDREN</source>
          <target state="translated">REQUIRED_CHILDREN</target>
        </trans-unit>
        <trans-unit id="dd3cac660da0ea89c0136a235305fc5bdb24dcc3" translate="yes" xml:space="preserve">
          <source>React Component</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ca02c4d8d1e211afacc19bb40a490a44ae66f21" translate="yes" xml:space="preserve">
          <source>React Native Configuration</source>
          <target state="translated">Reaccionar Configuración nativa</target>
        </trans-unit>
        <trans-unit id="55a38b3edc3904e22c3fddf2b60febe07b47d508" translate="yes" xml:space="preserve">
          <source>React Router</source>
          <target state="translated">Reacciona el router</target>
        </trans-unit>
        <trans-unit id="0d4f22b3a7ca96ed45a6ce530b418585fac69067" translate="yes" xml:space="preserve">
          <source>React and Relay support creating arbitrarily complex applications through &lt;em&gt;composition&lt;/em&gt;. Larger components can be created by composing smaller components, helping us to create modular, robust applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bb70948dc19f1bb32a259898fca2dfd714e7448" translate="yes" xml:space="preserve">
          <source>React and Relay support creating arbitrarily complex applications through &lt;em&gt;composition&lt;/em&gt;. Larger components can be created by composing smaller components, helping us to create modular, robust applications. There are two aspects to composing components in Relay:</source>
          <target state="translated">React y Relay admiten la creaci&amp;oacute;n de aplicaciones arbitrariamente complejas a trav&amp;eacute;s de la &lt;em&gt;composici&amp;oacute;n&lt;/em&gt; . Se pueden crear componentes m&amp;aacute;s grandes componiendo componentes m&amp;aacute;s peque&amp;ntilde;os, lo que nos ayuda a crear aplicaciones modulares y robustas. Hay dos aspectos para componer componentes en Relay:</target>
        </trans-unit>
        <trans-unit id="1b75cb8007be8e88622c14d5835273832c1645c5" translate="yes" xml:space="preserve">
          <source>React component classes may have methods, often accessed via &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt;refs&lt;/a&gt;. Since Relay composes these component instances in a container, you need to use the &lt;code&gt;componentRef&lt;/code&gt; prop to access them:</source>
          <target state="translated">Las clases de componentes de React pueden tener m&amp;eacute;todos, a los que a menudo se accede a trav&amp;eacute;s de &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt;referencias&lt;/a&gt; . Dado que Relay compone estas instancias de componentes en un contenedor, debe usar la propiedad &lt;code&gt;componentRef&lt;/code&gt; para acceder a ellas:</target>
        </trans-unit>
        <trans-unit id="4414b37377cdce419545fa9b20f3ee40db7ae79f" translate="yes" xml:space="preserve">
          <source>Reading From Cache</source>
          <target state="translated">Lectura de la memoria caché</target>
        </trans-unit>
        <trans-unit id="65ef251f859a908e6a35bac8ecaf436651601f86" translate="yes" xml:space="preserve">
          <source>Reads the value of an attribute on a record by the field name and an object representing pre-defined argument values.</source>
          <target state="translated">Lee el valor de un atributo de un registro por el nombre de campo y un objeto que representa valores de argumento predefinidos.</target>
        </trans-unit>
        <trans-unit id="e3c57930509c5101e93fa1b560decb910e955968" translate="yes" xml:space="preserve">
          <source>Ready State</source>
          <target state="translated">Estado Listo</target>
        </trans-unit>
        <trans-unit id="e276b1dc6fd5b2e2feab8b52644788511fadacad" translate="yes" xml:space="preserve">
          <source>Ready State Change</source>
          <target state="translated">Cambio de estado listo</target>
        </trans-unit>
        <trans-unit id="e61f9d2b516c40c24af8003c73bb3ff7c6a828c5" translate="yes" xml:space="preserve">
          <source>RecordProxy</source>
          <target state="translated">RecordProxy</target>
        </trans-unit>
        <trans-unit id="240b0ea75b5e63f3dae5e35c084b7cb6df230fd2" translate="yes" xml:space="preserve">
          <source>RecordSourceSelectorProxy</source>
          <target state="translated">RecordSourceSelectorProxy</target>
        </trans-unit>
        <trans-unit id="8d339e7dedea41faa4ebfe2fcdc6d599b8f484b5" translate="yes" xml:space="preserve">
          <source>Records that are null in the published source are deleted (set to null) in the store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b363b61849ee47f18ae2be0f0d65a8808b2dfa9" translate="yes" xml:space="preserve">
          <source>Records that exist in both are merged into a new record (inputs unchanged), with the result added to the store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48b512c3d477cc494940cbc3511367f3bc8c1733" translate="yes" xml:space="preserve">
          <source>Records that exist only in the published source are added to the store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ff3c14aded3e6ad067ba4f314fd7efd64ebd5df" translate="yes" xml:space="preserve">
          <source>Records with a special sentinel value are removed from the store. This supports un-publishing optimistically created records.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db1c784524e1b54011a95823026161f7c8517fe0" translate="yes" xml:space="preserve">
          <source>Reference</source>
          <target state="translated">Reference</target>
        </trans-unit>
        <trans-unit id="5e8ed94444d1cf7d3d3d0307cd8aaf8c3d6040fc" translate="yes" xml:space="preserve">
          <source>Refetch Container</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3c412dd10a0e8cb0c1899aa86989fec9f2b0413" translate="yes" xml:space="preserve">
          <source>RefetchContainer</source>
          <target state="translated">RefetchContainer</target>
        </trans-unit>
        <trans-unit id="638e5005315e0cabef699577f78933ca4cc7db6a" translate="yes" xml:space="preserve">
          <source>Refetching Data (aka &quot;See More&quot;)</source>
          <target state="translated">Recopilación de datos (alias &quot;Ver más&quot;)</target>
        </trans-unit>
        <trans-unit id="c9bb21f0d54fefc21f3fe3cd21ff7bc0b0847f63" translate="yes" xml:space="preserve">
          <source>Refetching latest data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47f437a4450523abebb9b8a6327af806c6dfe250" translate="yes" xml:space="preserve">
          <source>Related APIs</source>
          <target state="translated">APIs relacionadas</target>
        </trans-unit>
        <trans-unit id="9f537f977fa2ecd1f91ff057ce1667e98ab04729" translate="yes" xml:space="preserve">
          <source>Relay</source>
          <target state="translated">Relay</target>
        </trans-unit>
        <trans-unit id="88dd507e8359bb2fd7a7702cfdc9ffaecb218c8a" translate="yes" xml:space="preserve">
          <source>Relay Classic API</source>
          <target state="translated">Relevo Clásico API</target>
        </trans-unit>
        <trans-unit id="d6764a98d68a0f585f067a880fb7f047e42e5295" translate="yes" xml:space="preserve">
          <source>Relay Classic Guides</source>
          <target state="translated">Guías clásicas de relevos</target>
        </trans-unit>
        <trans-unit id="aef721f4de8f071bed34bec165e9e8e9422d904c" translate="yes" xml:space="preserve">
          <source>Relay Classic Interfaces</source>
          <target state="translated">Interfaces clásicas de retransmisión</target>
        </trans-unit>
        <trans-unit id="8ee884f2695bfbad6a7a6dae4d48bf3348965934" translate="yes" xml:space="preserve">
          <source>Relay Compat</source>
          <target state="translated">Compatriota de relevos</target>
        </trans-unit>
        <trans-unit id="c546e3c1729605fb70a2db1deb7870608f3445c7" translate="yes" xml:space="preserve">
          <source>Relay Compat is part of &lt;code&gt;'react-relay'&lt;/code&gt; which allows you to do exactly this, providing an identical API to Relay Modern, while allowing interoperability with both runtimes.</source>
          <target state="translated">Relay Compat es parte de &lt;code&gt;'react-relay'&lt;/code&gt; que le permite hacer exactamente esto, proporcionando una API id&amp;eacute;ntica a Relay Modern, al tiempo que permite la interoperabilidad con ambos tiempos de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ddef7758830f719ed90adce373f8f83b9acf721d" translate="yes" xml:space="preserve">
          <source>Relay Compiler</source>
          <target state="translated">Compilador de Relevos</target>
        </trans-unit>
        <trans-unit id="9e9a58b9be4e5093877d58bb37e46ff2f5998988" translate="yes" xml:space="preserve">
          <source>Relay Compiler supports the use of &lt;strong&gt;persisted queries&lt;/strong&gt;, in which each version of a query is associated to a unique ID on the server and the runtime uploads only the persisted ID instead of the full query text. This has several benefits: it can significantly reduce the time to send a query (and the upload bytes) and enables &lt;em&gt;whitelisting&lt;/em&gt; of queries. For example, you may choose to disallow queries in text form and only allow queries that have been persisted (and that presumably have passed your internal code review process).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c34dd9f9f2001d5f2a7c52af35f1be4b138b177" translate="yes" xml:space="preserve">
          <source>Relay Compiler will then create the id =&amp;gt; query text mapping in the path you specify. You can then use this complete json file in your server side to map query ids to operation text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be2b89d58206687eafd6b5f1f94bb37fb0baa8fb" translate="yes" xml:space="preserve">
          <source>Relay Containers</source>
          <target state="translated">Contenedores de retransmisión</target>
        </trans-unit>
        <trans-unit id="e0d9a631ef93e7ccb54370c0af336f421599b386" translate="yes" xml:space="preserve">
          <source>Relay DevTools is tool designed to help developers inspect their Relay state and understand how store changes overtime. Relay DevTools ships in two ways:</source>
          <target state="translated">Relay DevTools es una herramienta diseñada para ayudar a los desarrolladores a inspeccionar su estado de Relay y a entender cómo el almacén cambia con el tiempo.Relay DevTools se envía de dos maneras:</target>
        </trans-unit>
        <trans-unit id="426c398ee54f1b774dac3a903f0125ae20a5c9e6" translate="yes" xml:space="preserve">
          <source>Relay Documentation</source>
          <target state="translated">Documentación de retransmisión</target>
        </trans-unit>
        <trans-unit id="1443cd7ff63d89730c443bd7786d90a6df7d1998" translate="yes" xml:space="preserve">
          <source>Relay Environment</source>
          <target state="translated">Ambiente de relevos</target>
        </trans-unit>
        <trans-unit id="d699ddf70a567d16a64d34cd746d0cc2172e4ec9" translate="yes" xml:space="preserve">
          <source>Relay Modern</source>
          <target state="translated">Relevo Moderno</target>
        </trans-unit>
        <trans-unit id="125aa7abbb0a0bc142817f98c7e32cd828f1f474" translate="yes" xml:space="preserve">
          <source>Relay Modern comes with automatic Flow type generation for the fragments used in Relay containers based on the GraphQL schema. Using these Flow types can help make an application less error-prone, by ensuring all possible &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; cases are considered even if they don't happen frequently.</source>
          <target state="translated">Relay Modern viene con generaci&amp;oacute;n autom&amp;aacute;tica de tipo de flujo para los fragmentos usados ​​en los contenedores de Relay basados ​​en el esquema GraphQL. El uso de estos tipos de flujo puede ayudar a que una aplicaci&amp;oacute;n sea menos propensa a errores, al garantizar que se consideren todos los posibles casos &lt;code&gt;null&lt;/code&gt; o &lt;code&gt;undefined&lt;/code&gt; incluso si no ocurren con frecuencia.</target>
        </trans-unit>
        <trans-unit id="fe351802f53838c0d3ff7ec944643ab9992b7020" translate="yes" xml:space="preserve">
          <source>Relay Modern containers combine standard React components with a description of their data requirements, expressed as one or more GraphQL fragments. Each container is itself a standard React component that can be rendered using the standard React API (e.g. &lt;code&gt;&amp;lt;YourComponent prop={...} /&amp;gt;&lt;/code&gt;). When rendered, a container will read the data for its fragment from the Relay cache. As the fragment data changes - for example due to a mutation, subscription, or updated query response - the container will automatically re-render the component.</source>
          <target state="translated">Los contenedores Relay Modern combinan componentes React est&amp;aacute;ndar con una descripci&amp;oacute;n de sus requisitos de datos, expresados ​​como uno o m&amp;aacute;s fragmentos GraphQL. Cada contenedor es en s&amp;iacute; mismo un componente React est&amp;aacute;ndar que se puede renderizar usando la API React est&amp;aacute;ndar (por ejemplo, &lt;code&gt;&amp;lt;YourComponent prop={...} /&amp;gt;&lt;/code&gt; ). Cuando se procesa, un contenedor leer&amp;aacute; los datos de su fragmento del cach&amp;eacute; de retransmisi&amp;oacute;n. A medida que cambian los datos del fragmento, por ejemplo, debido a una mutaci&amp;oacute;n, suscripci&amp;oacute;n o respuesta de consulta actualizada, el contenedor volver&amp;aacute; a representar autom&amp;aacute;ticamente el componente.</target>
        </trans-unit>
        <trans-unit id="b783df53e509475b97db41df7f512b5cdf7adf0d" translate="yes" xml:space="preserve">
          <source>Relay Modern enables a variety of new features. Some are available via the Compat API, while others require upgrading fully to the Modern runtime. See &lt;a href=&quot;new-in-relay-modern&quot;&gt;what's new in Relay Modern&lt;/a&gt; for more details.</source>
          <target state="translated">Relay Modern habilita una variedad de caracter&amp;iacute;sticas nuevas. Algunos est&amp;aacute;n disponibles a trav&amp;eacute;s de Compat API, mientras que otros requieren una actualizaci&amp;oacute;n completa al tiempo de ejecuci&amp;oacute;n moderno. Vea &lt;a href=&quot;new-in-relay-modern&quot;&gt;las novedades de Relay Modern&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="02ee7840306dae496dace1fe86750e32e8b8c807" translate="yes" xml:space="preserve">
          <source>Relay Modern is a new version of Relay designed from the ground up to be easier to use, more extensible and, most of all, able to improve performance on mobile devices. Relay Modern accomplishes this with static queries and ahead-of-time code generation.</source>
          <target state="translated">Relay Modern es una nueva versión de Relay diseñada desde cero para ser más fácil de usar,más extensible y,sobre todo,capaz de mejorar el rendimiento en los dispositivos móviles.Relay Modern logra esto con consultas estáticas y generación de código anticipado.</target>
        </trans-unit>
        <trans-unit id="45d888a1b92fa795f57aa8cf7b25c2d182f14c5c" translate="yes" xml:space="preserve">
          <source>Relay Modern is composed of three core modules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="451008aa294b51a951e1a6a9073f36b4296c782c" translate="yes" xml:space="preserve">
          <source>Relay Modern requires a Babel plugin to convert GraphQL to runtime artifacts:</source>
          <target state="translated">Relay Modern requiere un plugin Babel para convertir GraphQL en artefactos de tiempo de ejecución:</target>
        </trans-unit>
        <trans-unit id="0d2944c329394a1cfc563059eabe3a8681e7e2bc" translate="yes" xml:space="preserve">
          <source>Relay Modern supports GraphQL Subscriptions, using the imperative update API to allow modifications to the store whenever a payload is received. It also features experimental support for GraphQL Live Queries via polling.</source>
          <target state="translated">Relay Modern apoya las suscripciones de GraphQL,utilizando la actualización imperativa de la API para permitir modificaciones en la tienda cada vez que se recibe una carga útil.También cuenta con soporte experimental para las Consultas en vivo de GraphQL a través de encuestas.</target>
        </trans-unit>
        <trans-unit id="372f8f866ff79038477865a8b1e68cc2436d4212" translate="yes" xml:space="preserve">
          <source>Relay Modern supports the following directives</source>
          <target state="translated">Relay Modern apoya las siguientes directivas</target>
        </trans-unit>
        <trans-unit id="4fcb24b9dcd43c8532db4d056e1af150670c742a" translate="yes" xml:space="preserve">
          <source>Relay Modern uses the Relay Compiler to convert &lt;code&gt;graphql&lt;/code&gt; literals into generated files that live alongside your source files.</source>
          <target state="translated">Relay Modern usa Relay Compiler para convertir literales &lt;code&gt;graphql&lt;/code&gt; en archivos generados que viven junto a sus archivos fuente.</target>
        </trans-unit>
        <trans-unit id="604519e05335c47d085692b3d5c93c6c0cf24a81" translate="yes" xml:space="preserve">
          <source>Relay Modern's ahead-of-time compilation requires the new Relay Compiler:</source>
          <target state="translated">La compilación anticipada de Relay Modern requiere el nuevo Compilador de Relevos:</target>
        </trans-unit>
        <trans-unit id="d344ad7e0e46f9326c5126f3f06dc4800f23f6c8" translate="yes" xml:space="preserve">
          <source>Relay Modern's core is essentially an un-opinionated store for GraphQL data. It can be used independent of rendering views using React and can be extended to be used with other frameworks.</source>
          <target state="translated">El núcleo de Relay Modern es esencialmente un almacén sin opinar para los datos de GraphQL.Puede ser usado independientemente de las vistas de renderizado usando React y puede ser extendido para ser usado con otros marcos.</target>
        </trans-unit>
        <trans-unit id="e31b26fed868774cce2fc303006fb272761f29e5" translate="yes" xml:space="preserve">
          <source>Relay Runtime is designed for use with GraphQL schemas that describe &lt;strong&gt;object graphs&lt;/strong&gt; in which objects have a type, an identity, and a set of fields with values. Objects may reference each other, which is represented by fields whose values are one or more other objects in the graph [1]. To distinguish from JavaScript &lt;code&gt;Object&lt;/code&gt;s, these units of data are referred to as &lt;code&gt;Record&lt;/code&gt;s. Relay represents both its internal cache as well as query/mutation/etc results as a mapping of &lt;strong&gt;data ID&lt;/strong&gt;s to &lt;strong&gt;records&lt;/strong&gt;. The data ID is the unique (with respect to the cache) identifier for a record - it may be the value of an actual &lt;code&gt;id&lt;/code&gt; field or based on the path to the record from the nearest object with an &lt;code&gt;id&lt;/code&gt; (such path-based ids are called &lt;strong&gt;client ids&lt;/strong&gt;). Each &lt;code&gt;Record&lt;/code&gt; stores its data ID, type, and any fields that have been fetched. Multiple records are stored together as a &lt;code&gt;RecordSource&lt;/code&gt;: a mapping of data IDs to &lt;code&gt;Record&lt;/code&gt; instances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="881bc62d6225c769dfa7c14c7288aba40be25da2" translate="yes" xml:space="preserve">
          <source>Relay Specification</source>
          <target state="translated">Especificación del relé</target>
        </trans-unit>
        <trans-unit id="5d0eda024fc816c22ea59a24e3cd5865e39cffa0" translate="yes" xml:space="preserve">
          <source>Relay Store</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd195ecee5d7e7a6df1ecbbf4a909cee95b601b9" translate="yes" xml:space="preserve">
          <source>Relay allows developers to annotate their React components with data dependencies by creating &lt;strong&gt;containers&lt;/strong&gt;. These are regular React components that wrap the originals. A key design constraint is that React components are meant to be reusable, so Relay containers must be too. For example, a &lt;code&gt;&amp;lt;Story /&amp;gt;&lt;/code&gt; component might implement a view for rendering any &lt;code&gt;Story&lt;/code&gt; item. The actual story to render would be determined by the data passed to the component: &lt;code&gt;&amp;lt;Story story={ ... } /&amp;gt;&lt;/code&gt;. The equivalent in GraphQL are &lt;strong&gt;fragments&lt;/strong&gt;: named query snippets that specify what data to fetch &lt;em&gt;for an object of a given type&lt;/em&gt;. We might describe the data needed by &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48799f13f2ac51d5720b5a4e683e4a8844cdd877" translate="yes" xml:space="preserve">
          <source>Relay allows developers to annotate their React components with data dependencies by creating &lt;strong&gt;containers&lt;/strong&gt;. These are regular React components that wrap the originals. A key design constraint is that React components are meant to be reusable, so Relay containers must be too. For example, a &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; component might implement a view for rendering any &lt;code&gt;Story&lt;/code&gt; item. The actual story to render would be determined by the data passed to the component: &lt;code&gt;&amp;lt;Story story={ ... } /&amp;gt;&lt;/code&gt;. The equivalent in GraphQL are &lt;strong&gt;fragments&lt;/strong&gt;: named query snippets that specify what data to fetch &lt;em&gt;for an object of a given type&lt;/em&gt;. We might describe the data needed by &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; as follows:</source>
          <target state="translated">Relay permite a los desarrolladores anotar sus componentes React con dependencias de datos creando &lt;strong&gt;contenedores&lt;/strong&gt; . Estos son componentes regulares de React que envuelven los originales. Una restricci&amp;oacute;n de dise&amp;ntilde;o clave es que los componentes de React est&amp;aacute;n destinados a ser reutilizables, por lo que los contenedores de Relay tambi&amp;eacute;n deben serlo. Por ejemplo, un componente &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; podr&amp;iacute;a implementar una vista para representar cualquier elemento de &lt;code&gt;Story&lt;/code&gt; . La historia real a renderizar estar&amp;iacute;a determinada por los datos pasados ​​al componente: &lt;code&gt;&amp;lt;Story story={ ... } /&amp;gt;&lt;/code&gt; . Los equivalentes en GraphQL son &lt;strong&gt;fragmentos&lt;/strong&gt; : &lt;strong&gt;fragmentos de&lt;/strong&gt; consulta con nombre que especifican qu&amp;eacute; datos buscar &lt;em&gt;para un objeto de un tipo determinado&lt;/em&gt; . Podr&amp;iacute;amos describir los datos que necesita &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="76c99c886cf994dd48c328f17b234bd016edf810" translate="yes" xml:space="preserve">
          <source>Relay also goes further: it uses opaque identifiers on &lt;code&gt;props&lt;/code&gt; to validate that we've explicitly fetched the data for a component before rendering it. If &lt;code&gt;&amp;lt;Story /&amp;gt;&lt;/code&gt; renders &lt;code&gt;&amp;lt;StoryHeader /&amp;gt;&lt;/code&gt; but forgets to include its fragment, Relay will warn that the data for &lt;code&gt;&amp;lt;StoryHeader /&amp;gt;&lt;/code&gt; is missing. In fact, Relay will warn &lt;em&gt;even if&lt;/em&gt; some other component happened to fetch the same data required by &lt;code&gt;&amp;lt;StoryHeader /&amp;gt;&lt;/code&gt;. This warning tells us that although things &lt;em&gt;might&lt;/em&gt; work now they're highly likely to break later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="254c939fb761720339a3dd3ad863697bebf60c3f" translate="yes" xml:space="preserve">
          <source>Relay also goes further: it uses opaque identifiers on &lt;code&gt;props&lt;/code&gt; to validate that we've explicitly fetched the data for a component before rendering it. If &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; renders &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; but forgets to include its fragment, Relay will warn that the data for &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; is missing. In fact, Relay will warn &lt;em&gt;even if&lt;/em&gt; some other component happened to fetch the same data required by &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt;. This warning tells us that although things &lt;em&gt;might&lt;/em&gt; work now they're highly likely to break later.</source>
          <target state="translated">Relay tambi&amp;eacute;n va m&amp;aacute;s all&amp;aacute;: utiliza identificadores opacos en los &lt;code&gt;props&lt;/code&gt; para validar que hemos obtenido expl&amp;iacute;citamente los datos de un componente antes de renderizarlo. Si &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; muestra &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; pero se olvida de incluir su fragmento, Relay advertir&amp;aacute; que faltan los datos de &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; . De hecho, Relay advertir&amp;aacute; &lt;em&gt;incluso si&lt;/em&gt; alg&amp;uacute;n otro componente &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; los mismos datos requeridos por &amp;lt;StoryHeader&amp;gt; . Esta advertencia nos dice que aunque las cosas &lt;em&gt;podr&amp;iacute;an&lt;/em&gt; funcionar ahora, es muy probable que se rompan m&amp;aacute;s tarde.</target>
        </trans-unit>
        <trans-unit id="c212579d453e98cbd0a4dcbacffef8088e5ab28f" translate="yes" xml:space="preserve">
          <source>Relay also lets us completely replace the default network layer.</source>
          <target state="translated">La retransmisión también nos permite reemplazar completamente la capa de red por defecto.</target>
        </trans-unit>
        <trans-unit id="f200764a518868ca3b31ea98a1353b5d9f2dd1fc" translate="yes" xml:space="preserve">
          <source>Relay can be thought of as two parts which work together: an API for building data-driven components and a runtime which fetches and stores data from GraphQL to populate your app. Relay Modern brings both a new API and a new runtime.</source>
          <target state="translated">La retransmisión puede pensarse como dos partes que funcionan juntas:una API para construir componentes basados en datos y un tiempo de ejecución que recupera y almacena datos de GraphQL para poblar su aplicación.Relay Modern trae una nueva API y un nuevo tiempo de ejecución.</target>
        </trans-unit>
        <trans-unit id="edc443fe11fe9992f4eb82855f77153b4705147b" translate="yes" xml:space="preserve">
          <source>Relay containers are created using &lt;code&gt;Relay.createContainer&lt;/code&gt;.</source>
          <target state="translated">Los contenedores de retransmisi&amp;oacute;n se crean utilizando &lt;code&gt;Relay.createContainer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2748ac007f286936a91fb67b3ca6e11462a7fe21" translate="yes" xml:space="preserve">
          <source>Relay containers are higher-order components &amp;mdash; &lt;code&gt;Relay.createContainer&lt;/code&gt; is a function that takes a React component as input and returns a new component as output. This means that the container can manage data fetching and resolution logic without interfering with the &lt;code&gt;state&lt;/code&gt; of the inner component.</source>
          <target state="translated">Los contenedores de rel&amp;eacute; son componentes de orden superior: &lt;code&gt;Relay.createContainer&lt;/code&gt; es una funci&amp;oacute;n que toma un componente React como entrada y devuelve un nuevo componente como salida. Esto significa que el contenedor puede gestionar la obtenci&amp;oacute;n de datos y la l&amp;oacute;gica de resoluci&amp;oacute;n sin interferir con el &lt;code&gt;state&lt;/code&gt; del componente interno.</target>
        </trans-unit>
        <trans-unit id="1c357d13b1cce8a1c46ccc30afeeb5fd2f902c5a" translate="yes" xml:space="preserve">
          <source>Relay containers provide a static &lt;code&gt;getFragment()&lt;/code&gt; method that returns a reference to that component's fragment:</source>
          <target state="translated">Los contenedores de retransmisi&amp;oacute;n proporcionan un m&amp;eacute;todo &lt;code&gt;getFragment()&lt;/code&gt; est&amp;aacute;tico que devuelve una referencia al fragmento de ese componente:</target>
        </trans-unit>
        <trans-unit id="5a410cc37e6396592aa37827cec122428cb2d984" translate="yes" xml:space="preserve">
          <source>Relay couples React with GraphQL and develops the idea of encapsulation further. It allows components to specify what data they need and the Relay framework provides the data. This makes the data needs of inner components opaque and allows composition of those needs. Thinking about what data an app needs becomes localized to the component making it easier to reason about what fields are needed or no longer needed.</source>
          <target state="translated">Las parejas de relés reaccionan con GraphQL y desarrollan la idea de encapsulación más allá.Permite que los componentes especifiquen qué datos necesitan y el marco del relé proporciona los datos.Esto hace que las necesidades de datos de los componentes internos sean opacas y permite la composición de esas necesidades.Pensar qué datos necesita una aplicación se convierte en algo localizado en el componente,lo que facilita el razonamiento sobre qué campos se necesitan o ya no se necesitan.</target>
        </trans-unit>
        <trans-unit id="934fd827600b774b11b92dcf9269d690870fb9bb" translate="yes" xml:space="preserve">
          <source>Relay ensures that this data is available before the component is rendered.</source>
          <target state="translated">El relé asegura que estos datos estén disponibles antes de que el componente sea renderizado.</target>
        </trans-unit>
        <trans-unit id="b556a8542493c85c6ab714e7efdb1e48fb0c7ece" translate="yes" xml:space="preserve">
          <source>Relay exposes the following APIs to create subscriptions.</source>
          <target state="translated">La retransmisión expone las siguientes API para crear suscripciones.</target>
        </trans-unit>
        <trans-unit id="8076714ed2f663c62d9c70223ceef029bffc6fc4" translate="yes" xml:space="preserve">
          <source>Relay exposes the following APIs to perform mutations.</source>
          <target state="translated">El relé expone a los siguientes API para realizar mutaciones.</target>
        </trans-unit>
        <trans-unit id="9a9f6b192104115130a465f5d1b347425625bd6d" translate="yes" xml:space="preserve">
          <source>Relay fragments, mutations, and queries must be specified using ES6 template literals tagged with &lt;code&gt;Relay.QL&lt;/code&gt;. For example:</source>
          <target state="translated">Los fragmentos de retransmisi&amp;oacute;n, las mutaciones y las consultas deben especificarse utilizando literales de plantilla ES6 etiquetados con &lt;code&gt;Relay.QL&lt;/code&gt; . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="f94ab02e4b36f1c69a9b192786b3451a5578f530" translate="yes" xml:space="preserve">
          <source>Relay has a network layer abstraction that separates mutations and queries from the actual machinery that sends requests to the GraphQL server. This gives us the flexibility to configure or even completely replace the default network layer via injection.</source>
          <target state="translated">El relé tiene una abstracción de la capa de red que separa las mutaciones y las consultas de la maquinaria real que envía las solicitudes al servidor GraphQL.Esto nos da la flexibilidad de configurar o incluso sustituir completamente la capa de red por defecto a través de la inyección.</target>
        </trans-unit>
        <trans-unit id="3e093a4c47e1f292b6f2a4693a9f28a6e839881f" translate="yes" xml:space="preserve">
          <source>Relay implements several variations of &lt;strong&gt;query traversal&lt;/strong&gt;: operations that walk a query alongside some other data such as the cache or a response payload. For example, when a query is fetched Relay performs a &quot;diff&quot; traversal to determine what fields are missing (much like React diffs virtual DOM trees). This can reduce the amount of data fetched in many common cases and even allow Relay to avoid network requests at all when queries are fully cached.</source>
          <target state="translated">Relay implementa varias variaciones del &lt;strong&gt;recorrido&lt;/strong&gt; de &lt;strong&gt;consultas&lt;/strong&gt; : operaciones que recorren una consulta junto con otros datos, como la memoria cach&amp;eacute; o una carga &amp;uacute;til de respuesta. Por ejemplo, cuando se recupera una consulta, Relay realiza un recorrido &quot;diferencial&quot; para determinar qu&amp;eacute; campos faltan (al igual que React diffs &amp;aacute;rboles DOM virtuales). Esto puede reducir la cantidad de datos recuperados en muchos casos comunes e incluso permitir que Relay evite las solicitudes de red cuando las consultas est&amp;aacute;n completamente almacenadas en cach&amp;eacute;.</target>
        </trans-unit>
        <trans-unit id="1f7225f6558a177e37be9ba84410fe63b32cde06" translate="yes" xml:space="preserve">
          <source>Relay introduces two new classes of objects: &lt;code&gt;RelayContainer&lt;/code&gt; and &lt;code&gt;Relay.Route&lt;/code&gt;. &lt;code&gt;Relay.PropTypes&lt;/code&gt; provides prop validators used to assert that props are of these types.</source>
          <target state="translated">Relay presenta dos nuevas clases de objetos: &lt;code&gt;RelayContainer&lt;/code&gt; y &lt;code&gt;Relay.Route&lt;/code&gt; . &lt;code&gt;Relay.PropTypes&lt;/code&gt; proporciona validadores de accesorios que se utilizan para afirmar que los accesorios son de este tipo.</target>
        </trans-unit>
        <trans-unit id="2948c3c748b1764a34a269ea9919759693eaf027" translate="yes" xml:space="preserve">
          <source>Relay is a JavaScript framework for building data-driven React applications powered by GraphQL, designed from the ground up to be easy to use, extensible and, most of all, performant. Relay accomplishes this with static queries and ahead-of-time code generation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97f52c1bbd17e02a2c6367d7476a6ac21c258276" translate="yes" xml:space="preserve">
          <source>Relay is pre-configured to use a default network layer that works with &lt;a href=&quot;https://github.com/graphql/express-graphql&quot;&gt;express-graphql&lt;/a&gt;. This default network layer is exposed via &lt;code&gt;Relay.DefaultNetworkLayer&lt;/code&gt;.</source>
          <target state="translated">Relay est&amp;aacute; preconfigurado para usar una capa de red predeterminada que funciona con &lt;a href=&quot;https://github.com/graphql/express-graphql&quot;&gt;express-graphql&lt;/a&gt; . Esta capa de red predeterminada se expone a trav&amp;eacute;s de &lt;code&gt;Relay.DefaultNetworkLayer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54171fd2fa20a9c4bec1be11d3879a92bfa7df55" translate="yes" xml:space="preserve">
          <source>Relay makes use of GraphQL mutations; operations that enable us to mutate data on the client and server. To create a mutation for use in our app, we subclass &lt;code&gt;Relay.Mutation&lt;/code&gt; and implement, at minimum, the four abstract methods listed below.</source>
          <target state="translated">Relay hace uso de mutaciones GraphQL; operaciones que nos permiten mutar datos en el cliente y el servidor. Para crear una mutaci&amp;oacute;n para usar en nuestra aplicaci&amp;oacute;n, subclasemos &lt;code&gt;Relay.Mutation&lt;/code&gt; e implementamos, como m&amp;iacute;nimo, los cuatro m&amp;eacute;todos abstractos que se enumeran a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="973d2e671c894478b465827d5c3826264541eadd" translate="yes" xml:space="preserve">
          <source>Relay modern makes no assumptions about what to cache and will garbage collect any data that is no longer referenced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dd31c1805e052611332ba16c37162381a4a626a" translate="yes" xml:space="preserve">
          <source>Relay routes don't really implement any URL routing specific logic or work with History API. In the future we will maybe rename RelayRoute to be something more like RelayQueryRoots or RelayQueryConfig.</source>
          <target state="translated">Las rutas de retransmisión no implementan realmente ninguna lógica específica de enrutamiento de URL ni funcionan con la API de Historial.En el futuro tal vez cambiemos el nombre de RelayRoute a algo más parecido a RelayQueryRoots o RelayQueryConfig.</target>
        </trans-unit>
        <trans-unit id="589e99096a0b6781ff51073c2234321dc486a027" translate="yes" xml:space="preserve">
          <source>Relay routes don't really implement any URL routing specific logic or work with History API. In the future we will maybe rename RelayRoute to be something more like RelayQueryRoots or RelayQueryConfig. For more information around why Relay doesn't provide URL-routing features, and suggestions for such solutions, see &lt;a href=&quot;https://medium.com/@cpojer/relay-and-routing-36b5439bad9&quot;&gt;this post&lt;/a&gt;.</source>
          <target state="translated">Las rutas de retransmisi&amp;oacute;n realmente no implementan ninguna l&amp;oacute;gica espec&amp;iacute;fica de enrutamiento de URL ni funcionan con la API de historial. En el futuro, quiz&amp;aacute;s cambiemos el nombre de RelayRoute para que sea algo m&amp;aacute;s como RelayQueryRoots o RelayQueryConfig. Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre por qu&amp;eacute; Relay no proporciona funciones de enrutamiento de URL y sugerencias para tales soluciones, consulte &lt;a href=&quot;https://medium.com/@cpojer/relay-and-routing-36b5439bad9&quot;&gt;esta publicaci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ef480060aa47ef1a958a5c003bdd30a4e3354405" translate="yes" xml:space="preserve">
          <source>Relay speaks to GraphQL servers through a network layer. The &lt;a href=&quot;guides-network-layer&quot;&gt;network layer&lt;/a&gt; that ships with Relay is compatible with express-graphql out of the box, and will continue to evolve as we add new features to the transport.</source>
          <target state="translated">Relay habla con los servidores GraphQL a trav&amp;eacute;s de una capa de red. La &lt;a href=&quot;guides-network-layer&quot;&gt;capa de red&lt;/a&gt; que se env&amp;iacute;a con Relay es compatible con express-graphql lista para usar y continuar&amp;aacute; evolucionando a medida que agreguemos nuevas funciones al transporte.</target>
        </trans-unit>
        <trans-unit id="256546be326de4c5533a50332088277d259f1856" translate="yes" xml:space="preserve">
          <source>Relay updates the component whenever the underlying data has changed.</source>
          <target state="translated">El relé actualiza el componente cuando los datos subyacentes han cambiado.</target>
        </trans-unit>
        <trans-unit id="7f2f7458912547fdfa17a726b3bd42f898c10724" translate="yes" xml:space="preserve">
          <source>Relay uses a &lt;strong&gt;Babel&lt;/strong&gt; plugin to convert &lt;code&gt;graphql&lt;/code&gt; literals into requires of the code generated by Relay Compiler.</source>
          <target state="translated">Relay utiliza un complemento de &lt;strong&gt;Babel&lt;/strong&gt; para convertir literales &lt;code&gt;graphql&lt;/code&gt; en requisitos del c&amp;oacute;digo generado por Relay Compiler.</target>
        </trans-unit>
        <trans-unit id="9cbd2a4fac093602e7724812345c1426293f1cd9" translate="yes" xml:space="preserve">
          <source>Relay uses a &lt;strong&gt;babel&lt;/strong&gt; plugin to convert from &lt;code&gt;Relay.QL&lt;/code&gt; string templates to JavaScript code that describes each query and includes data from the GraphQL schema.</source>
          <target state="translated">Relay utiliza un complemento de &lt;strong&gt;babel&lt;/strong&gt; para convertir las plantillas de cadenas de &lt;code&gt;Relay.QL&lt;/code&gt; en c&amp;oacute;digo JavaScript que describe cada consulta e incluye datos del esquema GraphQL.</target>
        </trans-unit>
        <trans-unit id="5ab5569c1247a6342fa21f23bd4fe7b1d8d672c4" translate="yes" xml:space="preserve">
          <source>Relay uses a common pattern for mutations, where they are root fields on the mutation type with a single argument, &lt;code&gt;input&lt;/code&gt;, and where the input and output both contain a client mutation identifier used to reconcile requests and responses.</source>
          <target state="translated">Relay utiliza un patr&amp;oacute;n com&amp;uacute;n para las mutaciones, donde son campos ra&amp;iacute;z en el tipo de mutaci&amp;oacute;n con un solo argumento, &lt;code&gt;input&lt;/code&gt; , y donde la entrada y la salida contienen un identificador de mutaci&amp;oacute;n del cliente que se utiliza para conciliar solicitudes y respuestas.</target>
        </trans-unit>
        <trans-unit id="dd4a65f25979a2d6ac22ff73e832b56882a6731f" translate="yes" xml:space="preserve">
          <source>Relay uses all of this functionality to build out abstractions around connections, to make these easy to work with efficiently without having to manually manage cursors on the client.</source>
          <target state="translated">Relay utiliza toda esta funcionalidad para construir abstracciones alrededor de las conexiones,para hacerlas fáciles de trabajar eficientemente sin tener que manejar manualmente los cursores en el cliente.</target>
        </trans-unit>
        <trans-unit id="3dc783e9ac2c6bb867e37e0f714a2ddf7651506d" translate="yes" xml:space="preserve">
          <source>Relay uses directives to add additional information to GraphQL documents, which are used by the &lt;a href=&quot;#relay-compiler&quot;&gt;Relay Compiler&lt;/a&gt; to generate the appropriate runtime artifacts. These directives only appear in your application code and are removed from requests sent to your GraphQL server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7215a332ba837f6189ba19038b406a179e835435" translate="yes" xml:space="preserve">
          <source>Relay uses routes to define entry points into a Relay application.</source>
          <target state="translated">Relevo utiliza rutas para definir los puntos de entrada en una aplicación de Relevo.</target>
        </trans-unit>
        <trans-unit id="c47cadca2b04900115d6a0cc7ce416c63eeb2c11" translate="yes" xml:space="preserve">
          <source>Relay uses the Relay Compiler to convert &lt;a href=&quot;#graphql&quot;&gt;&lt;code&gt;graphql&lt;/code&gt;&lt;/a&gt; literals into generated files that live alongside your source files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e84f12bb76c08fcf1ebc1d56caf39b1024a1f70b" translate="yes" xml:space="preserve">
          <source>Relay v1.0 introduces the Relay Modern API:</source>
          <target state="translated">Relay v1.0 introduce el Relay Modern API:</target>
        </trans-unit>
        <trans-unit id="59061b6874678f961da16dff064bafb7cf4ff327" translate="yes" xml:space="preserve">
          <source>Relay will then automatically update the fields under the record corresponding to the ids in the response payload.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c3c5e271e633d2cf5f26344b18759ea44b95380" translate="yes" xml:space="preserve">
          <source>Relay wraps its core processing functions inside lightweight tasks, which by default are executed immediately (i.e. synchronously). In order to customize &lt;em&gt;when&lt;/em&gt; these tasks are run - for example to avoid interrupting an animation during a touch gesture - applications can provide a custom scheduling function.</source>
          <target state="translated">Relay envuelve sus funciones centrales de procesamiento dentro de tareas ligeras, que por defecto se ejecutan inmediatamente (es decir, sincr&amp;oacute;nicamente). Para personalizar &lt;em&gt;cu&amp;aacute;ndo&lt;/em&gt; se ejecutan estas tareas, por ejemplo, para evitar interrumpir una animaci&amp;oacute;n durante un gesto t&amp;aacute;ctil, las aplicaciones pueden proporcionar una funci&amp;oacute;n de programaci&amp;oacute;n personalizada.</target>
        </trans-unit>
        <trans-unit id="576baa5c970e0023c6b7f930fc5b22d07e80b876" translate="yes" xml:space="preserve">
          <source>Relay's approach to data-fetching is heavily inspired by our experience with React. In particular, React breaks complex interfaces into reusable &lt;strong&gt;components&lt;/strong&gt;, allowing developers to reason about discrete units of an application in isolation, and reducing the coupling between disparate parts of an application. Even more important is that these components are &lt;strong&gt;declarative&lt;/strong&gt;: they allow developers to specify &lt;em&gt;what&lt;/em&gt; the UI should look like for a given state, and not have to worry about &lt;em&gt;how&lt;/em&gt; to show that UI. Unlike previous approaches that used imperative commands to manipulate native views (e.g. the DOM), React uses a UI description to automatically determine the necessary commands.</source>
          <target state="translated">El enfoque de Relay para la b&amp;uacute;squeda de datos est&amp;aacute; fuertemente inspirado en nuestra experiencia con React. En particular, React divide interfaces complejas en &lt;strong&gt;componentes&lt;/strong&gt; reutilizables , lo que permite a los desarrolladores razonar sobre unidades discretas de una aplicaci&amp;oacute;n de forma aislada y reduce el acoplamiento entre partes dispares de una aplicaci&amp;oacute;n. A&amp;uacute;n m&amp;aacute;s importante es que estos componentes son &lt;strong&gt;declarativos&lt;/strong&gt; : permiten a los desarrolladores especificar &lt;em&gt;c&amp;oacute;mo&lt;/em&gt; deber&amp;iacute;a verse la interfaz de usuario para un estado determinado y no tener que preocuparse por &lt;em&gt;c&amp;oacute;mo&lt;/em&gt; mostrar esa interfaz de usuario. A diferencia de los enfoques anteriores que usaban comandos imperativos para manipular vistas nativas (por ejemplo, el DOM), React usa una descripci&amp;oacute;n de la interfaz de usuario para determinar autom&amp;aacute;ticamente los comandos necesarios.</target>
        </trans-unit>
        <trans-unit id="6b33d0db31f7976b67c0c833688c3f1a2f3ed1a7" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation</source>
          <target state="translated">Relay.GraphQLMutation</target>
        </trans-unit>
        <trans-unit id="1dd1eeecd4591e6fc51ed50ccec4372072ef5f58" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation#applyOptimistic()</source>
          <target state="translated">Relay.GraphQLMutation#applyOptimistic()</target>
        </trans-unit>
        <trans-unit id="778c7e41e609c680486529c141869bd60529ad4f" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation#commit()</source>
          <target state="translated">Relay.GraphQLMutation#commit()</target>
        </trans-unit>
        <trans-unit id="3dd83b3b4baca74ae215635dc8057361bd27c698" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation#constructor()</source>
          <target state="translated">Relay.GraphQLMutation#constructor()</target>
        </trans-unit>
        <trans-unit id="c60b9c934ff71ffb2a3ed3d72c60871bbe0e468e" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation#rollback()</source>
          <target state="translated">Relay.GraphQLMutation#rollback()</target>
        </trans-unit>
        <trans-unit id="3340870222c54d4e58da2c45216a0f9201d39a18" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation.create()</source>
          <target state="translated">Relay.GraphQLMutation.create()</target>
        </trans-unit>
        <trans-unit id="a23c2d405f689b19dfd1fd7c28df5c48a68add1e" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation.createWithFiles()</source>
          <target state="translated">Relay.GraphQLMutation.createWithFiles()</target>
        </trans-unit>
        <trans-unit id="03551f79ebf3cd05d7c2ceaa3bea55c92b64e6d0" translate="yes" xml:space="preserve">
          <source>Relay.Mutation</source>
          <target state="translated">Relay.Mutation</target>
        </trans-unit>
        <trans-unit id="3ba32adda774e85164beb595e60d2e216978176e" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#constructor()</source>
          <target state="translated">Relay.Mutation#constructor()</target>
        </trans-unit>
        <trans-unit id="04100c1f256b9742428fc3ccbb91ce26474f7916" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getCollisionKey()</source>
          <target state="translated">Relay.Mutation#getCollisionKey()</target>
        </trans-unit>
        <trans-unit id="6239b4b0c4bd148ddc88ff80a2414323538280f1" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getConfigs()</source>
          <target state="translated">Relay.Mutation#getConfigs()</target>
        </trans-unit>
        <trans-unit id="ef63d6cc19f0b592de123cd60ec1e1b1998d6f17" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getFatQuery()</source>
          <target state="translated">Relay.Mutation#getFatQuery()</target>
        </trans-unit>
        <trans-unit id="712207e70740181f3ab2120dc0f2bcc301c5f54e" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getFiles()</source>
          <target state="translated">Relay.Mutation#getFiles()</target>
        </trans-unit>
        <trans-unit id="e97a189b3ae9338d83696e14598b587f01455562" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getMutation()</source>
          <target state="translated">Relay.Mutation#getMutation()</target>
        </trans-unit>
        <trans-unit id="9ef4e47c4ce8d138fc8484b73b762f8325ab6d50" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getOptimisticConfigs()</source>
          <target state="translated">Relay.Mutation#getOptimisticConfigs()</target>
        </trans-unit>
        <trans-unit id="9c72c0ca95feabd409adccf873cc396f84f49fa7" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getOptimisticResponse()</source>
          <target state="translated">Relay.Mutation#getOptimisticResponse()</target>
        </trans-unit>
        <trans-unit id="0407ffada104593511af47973fbf4f161321629f" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getVariables()</source>
          <target state="translated">Relay.Mutation#getVariables()</target>
        </trans-unit>
        <trans-unit id="25241731d9b8a5e3bb893a8a7166ea0d07b29738" translate="yes" xml:space="preserve">
          <source>Relay.Mutation.fragments</source>
          <target state="translated">Relay.Mutation.fragments</target>
        </trans-unit>
        <trans-unit id="b7852fe98838e6fc1d72feab70dfa349933b9a4f" translate="yes" xml:space="preserve">
          <source>Relay.Mutation.getFragment()</source>
          <target state="translated">Relay.Mutation.getFragment()</target>
        </trans-unit>
        <trans-unit id="d9618c47616902c437879ab1fb98a8eb932feeeb" translate="yes" xml:space="preserve">
          <source>Relay.Mutation.initialVariables</source>
          <target state="translated">Relay.Mutation.initialVariables</target>
        </trans-unit>
        <trans-unit id="88607afefb79afbc0a5c6c2204c3c59784086c6d" translate="yes" xml:space="preserve">
          <source>Relay.Mutation.prepareVariables</source>
          <target state="translated">Relay.Mutation.prepareVariables</target>
        </trans-unit>
        <trans-unit id="15cdd01f7f3228bf705c67fcca4cc7376e38847b" translate="yes" xml:space="preserve">
          <source>Relay.PropTypes</source>
          <target state="translated">Relay.PropTypes</target>
        </trans-unit>
        <trans-unit id="0af8bcf2b06b250091c5a6a9f45a93a8ec335270" translate="yes" xml:space="preserve">
          <source>Relay.PropTypes.QueryConfig: ReactPropTypeValidator</source>
          <target state="translated">Relevo.PropTypes.QueryConfig:ReactPropTypeValidator</target>
        </trans-unit>
        <trans-unit id="991536fff9faf615e80c1b42bfda61b3395074a1" translate="yes" xml:space="preserve">
          <source>Relay.QL</source>
          <target state="translated">Relay.QL</target>
        </trans-unit>
        <trans-unit id="e66127f684a064c2b23590835fd5fc4afce5e3bc" translate="yes" xml:space="preserve">
          <source>Relay.Renderer</source>
          <target state="translated">Relay.Renderer</target>
        </trans-unit>
        <trans-unit id="1e64d297283159c1fd5f3c0f4f7f2590f52aeaf0" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#Container</source>
          <target state="translated">Relay.Renderer#Container</target>
        </trans-unit>
        <trans-unit id="0f68d914b2de005998fdb01ba1b1095a495e227d" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#environment</source>
          <target state="translated">Relay.Renderer#environment</target>
        </trans-unit>
        <trans-unit id="8e4cc916528c14e528833e3f79df2da75fd53acb" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#forceFetch</source>
          <target state="translated">Relay.Renderer#forceFetch</target>
        </trans-unit>
        <trans-unit id="bf0a7bc1a436c9a32f0f42831033b65d5cfbaf43" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#onReadyStateChange</source>
          <target state="translated">Relay.Renderer#onReadyStateChange</target>
        </trans-unit>
        <trans-unit id="9c4d750f130c80ae940ddef73d72538928767978" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#queryConfig</source>
          <target state="translated">Relay.Renderer#queryConfig</target>
        </trans-unit>
        <trans-unit id="ff227ea702919a6f75cb559ade588c7d11c20c78" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#render</source>
          <target state="translated">Relay.Renderer#render</target>
        </trans-unit>
        <trans-unit id="2761fdabd570b4cb3fdee157bed2ad5cb9ae4930" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer</source>
          <target state="translated">Relay.RootContainer</target>
        </trans-unit>
        <trans-unit id="543cce18705fbddda91e09c015e6da78c821e550" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#Component</source>
          <target state="translated">Relay.RootContainer#Component</target>
        </trans-unit>
        <trans-unit id="4c1d8599b11aa80027feab65c33b5f34aece2fe8" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#forceFetch</source>
          <target state="translated">Relay.RootContainer#forceFetch</target>
        </trans-unit>
        <trans-unit id="69120820a45037f7a9e51a705842b61000d0ac96" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#onReadyStateChange</source>
          <target state="translated">Relay.RootContainer#onReadyStateChange</target>
        </trans-unit>
        <trans-unit id="0b9faeb15a496f220a6b405a981a20f8ef453965" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#renderFailure</source>
          <target state="translated">Relay.RootContainer#renderFailure</target>
        </trans-unit>
        <trans-unit id="7bd3ce353967f7aff355ff3522f40b703a8bd047" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#renderFetched</source>
          <target state="translated">Relay.RootContainer#renderFetched</target>
        </trans-unit>
        <trans-unit id="8e6dba1eefc9476de73a3eb76f6a4bb45f2d9827" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#renderLoading</source>
          <target state="translated">Relay.RootContainer#renderLoading</target>
        </trans-unit>
        <trans-unit id="a9647a1d13d1b00fb81a049cb69e0f50d9005610" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#route</source>
          <target state="translated">Relay.RootContainer#route</target>
        </trans-unit>
        <trans-unit id="2163890d6b8486ab713e8307739f1fc8ffdc4051" translate="yes" xml:space="preserve">
          <source>Relay.Route</source>
          <target state="translated">Relay.Route</target>
        </trans-unit>
        <trans-unit id="ec4ec0225d1b12f051db712106148d8b26db80c7" translate="yes" xml:space="preserve">
          <source>Relay.Route#constructor()</source>
          <target state="translated">Relay.Route#constructor()</target>
        </trans-unit>
        <trans-unit id="933d2afe910e8eed75954f1ef8511fc9c8104ede" translate="yes" xml:space="preserve">
          <source>Relay.Route.paramDefinitions</source>
          <target state="translated">Relay.Route.paramDefinitions</target>
        </trans-unit>
        <trans-unit id="be2c5425ec7dbd5886d4716f82a79360b73375a7" translate="yes" xml:space="preserve">
          <source>Relay.Route.prepareParams</source>
          <target state="translated">Relay.Route.prepareParams</target>
        </trans-unit>
        <trans-unit id="632587b7cd190cd1537600ee207e20b1ff9030d5" translate="yes" xml:space="preserve">
          <source>Relay.Route.queries</source>
          <target state="translated">Relay.Route.queries</target>
        </trans-unit>
        <trans-unit id="90af1f420232cc590b9eb96c3c9344d637dded41" translate="yes" xml:space="preserve">
          <source>Relay.Route.routeName</source>
          <target state="translated">Relay.Route.routeName</target>
        </trans-unit>
        <trans-unit id="596c88b6dd79bb8e709c7b945308e399ac2abc3a" translate="yes" xml:space="preserve">
          <source>Relay.Store</source>
          <target state="translated">Relay.Store</target>
        </trans-unit>
        <trans-unit id="1ca8451821663a9beeafb5041c9c0bfdf4aff046" translate="yes" xml:space="preserve">
          <source>Relay.Store.applyUpdate()</source>
          <target state="translated">Relay.Store.applyUpdate()</target>
        </trans-unit>
        <trans-unit id="23f95eef5a8ff15d45d59ef33e2757420f465ed8" translate="yes" xml:space="preserve">
          <source>Relay.Store.commitUpdate()</source>
          <target state="translated">Relay.Store.commitUpdate()</target>
        </trans-unit>
        <trans-unit id="5435b8d8380c04f42e516eb3bd9326e46359b1b6" translate="yes" xml:space="preserve">
          <source>Relay.createContainer()</source>
          <target state="translated">Relay.createContainer()</target>
        </trans-unit>
        <trans-unit id="12f5066f2601943d9aac424bb916a7d3e8a44732" translate="yes" xml:space="preserve">
          <source>Relay.injectNetworkLayer()</source>
          <target state="translated">Relay.injectNetworkLayer()</target>
        </trans-unit>
        <trans-unit id="1a735b56a61cab41febb27320e2f243ed493b94f" translate="yes" xml:space="preserve">
          <source>Relay.injectTaskScheduler()</source>
          <target state="translated">Relay.injectTaskScheduler()</target>
        </trans-unit>
        <trans-unit id="309387769d52bfb1d6f330d2a6e3ecd71ecb41e1" translate="yes" xml:space="preserve">
          <source>Relay.isContainer()</source>
          <target state="translated">Relay.isContainer()</target>
        </trans-unit>
        <trans-unit id="c772f86aadb639ca41aafc4ec6f52aaae43e0acf" translate="yes" xml:space="preserve">
          <source>RelayContainer</source>
          <target state="translated">RelayContainer</target>
        </trans-unit>
        <trans-unit id="76e743848043959a7f2bfa720b5616417bb798e1" translate="yes" xml:space="preserve">
          <source>RelayContainer implements a conservative default &lt;code&gt;shouldComponentUpdate&lt;/code&gt; that returns &lt;code&gt;false&lt;/code&gt; if no fragment props have changed and all other props are equal scalar values. This may block updates to components that receive data via context. To ensure an update in this case override the default behavior by specifying a &lt;code&gt;shouldComponentUpdate&lt;/code&gt; function.</source>
          <target state="translated">RelayContainer implementa un &lt;code&gt;shouldComponentUpdate&lt;/code&gt; predeterminado conservador que devuelve &lt;code&gt;false&lt;/code&gt; si no ha cambiado ning&amp;uacute;n accesorio de fragmento y todos los dem&amp;aacute;s accesorios tienen valores escalares iguales. Esto puede bloquear las actualizaciones de los componentes que reciben datos a trav&amp;eacute;s del contexto. Para garantizar una actualizaci&amp;oacute;n en este caso, anule el comportamiento predeterminado especificando una funci&amp;oacute;n &lt;code&gt;shouldComponentUpdate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83d048709f5073df975dc9c425226f037d2ced9a" translate="yes" xml:space="preserve">
          <source>RelayContainer#forceFetch()</source>
          <target state="translated">RelayContainer#forceFetch()</target>
        </trans-unit>
        <trans-unit id="12306a7598448404edb2c73ef03ebd3b1459df33" translate="yes" xml:space="preserve">
          <source>RelayContainer#fragments</source>
          <target state="translated">RelayContainer#fragments</target>
        </trans-unit>
        <trans-unit id="fa4bac3fc05c361b8142cf895c4dec7b9136e491" translate="yes" xml:space="preserve">
          <source>RelayContainer#getFragment()</source>
          <target state="translated">RelayContainer#getFragment()</target>
        </trans-unit>
        <trans-unit id="0f0d5c6a56d86ccbcf94f9197715dbb511dcccda" translate="yes" xml:space="preserve">
          <source>RelayContainer#getPendingTransactions()</source>
          <target state="translated">RelayContainer#getPendingTransactions()</target>
        </trans-unit>
        <trans-unit id="3583e47f56ed32f6527e40cae51e9cd4226d6b8a" translate="yes" xml:space="preserve">
          <source>RelayContainer#hasOptimisticUpdate()</source>
          <target state="translated">RelayContainer#hasOptimisticUpdate()</target>
        </trans-unit>
        <trans-unit id="f6baca904aa4a3f9af8b6cef6a7995ee09553ec3" translate="yes" xml:space="preserve">
          <source>RelayContainer#initialVariables</source>
          <target state="translated">RelayContainer#initialVariables</target>
        </trans-unit>
        <trans-unit id="67aea36b1c5b679f64f0d153f256c81a818ebe83" translate="yes" xml:space="preserve">
          <source>RelayContainer#pendingVariables</source>
          <target state="translated">RelayContainer#pendingVariables</target>
        </trans-unit>
        <trans-unit id="9cce83d93b864bd7fad1aa07826c61d9a6ef284e" translate="yes" xml:space="preserve">
          <source>RelayContainer#prepareVariables</source>
          <target state="translated">RelayContainer#prepareVariables</target>
        </trans-unit>
        <trans-unit id="ef93161b93af5f5e98d21bb920dbacc9ffd1f25e" translate="yes" xml:space="preserve">
          <source>RelayContainer#route</source>
          <target state="translated">RelayContainer#route</target>
        </trans-unit>
        <trans-unit id="707b6138cca39388519379f5f0473ddd29369f7f" translate="yes" xml:space="preserve">
          <source>RelayContainer#setVariables()</source>
          <target state="translated">RelayContainer#setVariables()</target>
        </trans-unit>
        <trans-unit id="13dc088a9a8f1b885a4b30d133ebfc79f65f8a56" translate="yes" xml:space="preserve">
          <source>RelayContainer#shouldComponentUpdate</source>
          <target state="translated">RelayContainer#shouldComponentUpdate</target>
        </trans-unit>
        <trans-unit id="562b0d971d42af3b685406a662899de6e23e0ff8" translate="yes" xml:space="preserve">
          <source>RelayContainer#variables</source>
          <target state="translated">RelayContainer#variables</target>
        </trans-unit>
        <trans-unit id="cf0a077ddadfb043fbdeb8a931f05f97f9dec4db" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest</source>
          <target state="translated">RelayMutationRequest</target>
        </trans-unit>
        <trans-unit id="459733a291121fc4443f52543c52bf1ba049dc6a" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest#getDebugName()</source>
          <target state="translated">RelayMutationRequest#getDebugName()</target>
        </trans-unit>
        <trans-unit id="e6aac4071918a71d5a4437bcf00846a0803cb431" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest#getFiles()</source>
          <target state="translated">RelayMutationRequest#getFiles()</target>
        </trans-unit>
        <trans-unit id="98f8235cb1f82e31b63e4abc739976992bfb5247" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest#getID()</source>
          <target state="translated">RelayMutationRequest#getID()</target>
        </trans-unit>
        <trans-unit id="aced70c9403a7f1d9071b6bdae3bf77f17f27954" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest#getQueryString()</source>
          <target state="translated">RelayMutationRequest#getQueryString()</target>
        </trans-unit>
        <trans-unit id="f6fd4f67bc834b8917c668afd31ee438a325f452" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest#getVariables()</source>
          <target state="translated">RelayMutationRequest#getVariables()</target>
        </trans-unit>
        <trans-unit id="20f8806483b79b8a279be2b49be8c750a67cdb41" translate="yes" xml:space="preserve">
          <source>RelayNetworkLayer</source>
          <target state="translated">RelayNetworkLayer</target>
        </trans-unit>
        <trans-unit id="7f0a8ef7b7a43a9933addcbaef565eff07884834" translate="yes" xml:space="preserve">
          <source>RelayNetworkLayer#sendMutation()</source>
          <target state="translated">RelayNetworkLayer#sendMutation()</target>
        </trans-unit>
        <trans-unit id="67d40797657bd24a84a171e652a9bea818a15d96" translate="yes" xml:space="preserve">
          <source>RelayNetworkLayer#sendQueries()</source>
          <target state="translated">RelayNetworkLayer#sendQueries()</target>
        </trans-unit>
        <trans-unit id="eacde2e3a9c41d29b2ee433848dfea8232a5d22a" translate="yes" xml:space="preserve">
          <source>RelayNetworkLayer#supports()</source>
          <target state="translated">RelayNetworkLayer#supports()</target>
        </trans-unit>
        <trans-unit id="5113dd07f144f50d7677810b044a345b89e66e0e" translate="yes" xml:space="preserve">
          <source>RelayQueryRequest</source>
          <target state="translated">RelayQueryRequest</target>
        </trans-unit>
        <trans-unit id="4a9c272793946b8bdd3a09cdfbde6dc8574faf62" translate="yes" xml:space="preserve">
          <source>RelayQueryRequest#getDebugName()</source>
          <target state="translated">RelayQueryRequest#getDebugName()</target>
        </trans-unit>
        <trans-unit id="481aa62146f5343b4ba1062802709201d6d4d7af" translate="yes" xml:space="preserve">
          <source>RelayQueryRequest#getID()</source>
          <target state="translated">RelayQueryRequest#getID()</target>
        </trans-unit>
        <trans-unit id="0f467922406404a5eac2d6f11b736b9d66633025" translate="yes" xml:space="preserve">
          <source>RelayQueryRequest#getQueryString()</source>
          <target state="translated">RelayQueryRequest#getQueryString()</target>
        </trans-unit>
        <trans-unit id="981023af3724c0e925cbc3f99f867f132178c714" translate="yes" xml:space="preserve">
          <source>RelayQueryRequest#getVariables()</source>
          <target state="translated">RelayQueryRequest#getVariables()</target>
        </trans-unit>
        <trans-unit id="8324e4ecabe765d0034c56fc8f4c857ecfa3e2ae" translate="yes" xml:space="preserve">
          <source>RelayRecordProxy</source>
          <target state="translated">RelayRecordProxy</target>
        </trans-unit>
        <trans-unit id="69b9a9d8ad89e9af43d214607d3ff0018325568c" translate="yes" xml:space="preserve">
          <source>RelayRecordStore</source>
          <target state="translated">RelayRecordStore</target>
        </trans-unit>
        <trans-unit id="8aa27a7e83012be706218f33db1f656ebf3d0b47" translate="yes" xml:space="preserve">
          <source>Render Callbacks</source>
          <target state="translated">Renderizar las llamadas</target>
        </trans-unit>
        <trans-unit id="e066e80468f5234a1001137061731ae39a651ab5" translate="yes" xml:space="preserve">
          <source>Rendering</source>
          <target state="translated">Rendering</target>
        </trans-unit>
        <trans-unit id="db86b99e5c8c7fa5281608698558232d5c55e13b" translate="yes" xml:space="preserve">
          <source>Rendering Containers</source>
          <target state="translated">Recipientes de reciclaje</target>
        </trans-unit>
        <trans-unit id="af597671c6dcfa1df34e2e38251238001351c84d" translate="yes" xml:space="preserve">
          <source>Repeatedly refetching information from the server can get quite slow. For example, navigating from the list of stories, to a list item, and back to the list of stories means we have to refetch the whole list. We'll solve this with the standard solution: &lt;em&gt;caching&lt;/em&gt;.</source>
          <target state="translated">Recuperar informaci&amp;oacute;n repetidamente del servidor puede resultar bastante lento. Por ejemplo, navegar desde la lista de historias hasta un elemento de la lista y volver a la lista de historias significa que tenemos que volver a buscar la lista completa. Resolveremos esto con la soluci&amp;oacute;n est&amp;aacute;ndar: el &lt;em&gt;almacenamiento en cach&amp;eacute;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3341adcc90aa2cf65b0ed4f78d46fafd5dfc9cd5" translate="yes" xml:space="preserve">
          <source>Requesting Different Data</source>
          <target state="translated">Solicitud de datos diferentes</target>
        </trans-unit>
        <trans-unit id="b092a39c824d57357df89b0ece2eb1e4c9834cca" translate="yes" xml:space="preserve">
          <source>Require the Relay Compat API from &lt;code&gt;'react-relay/compat'&lt;/code&gt; and use it as you would Relay Modern. The components using Relay Compat can be referred to by both other Relay Modern and Relay Classic components.</source>
          <target state="translated">Requiere la API Relay Compat de &lt;code&gt;'react-relay/compat'&lt;/code&gt; y &amp;uacute;sala como lo har&amp;iacute;as con Relay Modern. Los componentes que utilizan Relay Compat pueden ser referidos por otros componentes Relay Modern y Relay Classic.</target>
        </trans-unit>
        <trans-unit id="61ac8791c7043a10705ecb741c56abf9848abf0a" translate="yes" xml:space="preserve">
          <source>Resolving Data from the Client</source>
          <target state="translated">Resolver los datos del cliente</target>
        </trans-unit>
        <trans-unit id="3281bf767244e09b6483581e4d93f748c54eb136" translate="yes" xml:space="preserve">
          <source>Response-caching can also be applied to GraphQL. A basic approach would work similarly to the REST version. The text of the query itself can be used as a cache key:</source>
          <target state="translated">El almacenamiento de respuestas también puede aplicarse a GraphQL.Un enfoque básico funcionaría de manera similar a la versión REST.El texto de la consulta en sí puede ser usado como una clave de caché:</target>
        </trans-unit>
        <trans-unit id="1daed2e622c367b716a7da87b2e2edd04d8d8e79" translate="yes" xml:space="preserve">
          <source>Retrieves a record associated with the current record given the field name, as defined by the GraphQL document. Returns a &lt;code&gt;RecordProxy&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a06b7b5f5bbad1dc68e21eaac11574c07de428a8" translate="yes" xml:space="preserve">
          <source>Retrieves a record from the store given its &lt;code&gt;dataID&lt;/code&gt;. Returns a &lt;a href=&quot;#recordproxy&quot;&gt;&lt;code&gt;RecordProxy&lt;/code&gt;&lt;/a&gt; which serves as an interface to mutate the record.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12402592aaf37a5d3ace23c3d09e0cda3355dad6" translate="yes" xml:space="preserve">
          <source>Retrieves a root field from the store given the &lt;code&gt;fieldName&lt;/code&gt;, as defined by the GraphQL document. Returns a &lt;a href=&quot;#recordproxy&quot;&gt;&lt;code&gt;RecordProxy&lt;/code&gt;&lt;/a&gt; which serves as an interface to mutate the record.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17061c12897cde333bc27d9d3b5b4885efbba0b0" translate="yes" xml:space="preserve">
          <source>Retrieves a root field that represents a collection from the store given the &lt;code&gt;fieldName&lt;/code&gt;, as defined by the GraphQL document. Returns an array of &lt;a href=&quot;#recordproxy&quot;&gt;&lt;code&gt;RecordProxies&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81554eb7c1007a0bac823cb3e3ca325777b63f97" translate="yes" xml:space="preserve">
          <source>Retrieves record(s) associated with the given record, transversing the source by field name and an object representing pre-defined argument values.</source>
          <target state="translated">Recupera registro(s)asociado(s)con el registro dado,cruzando la fuente por el nombre del campo y un objeto que representa los valores de los argumentos predefinidos.</target>
        </trans-unit>
        <trans-unit id="0df40cacc16f0f75e7289c7b00fb27121dcf4af7" translate="yes" xml:space="preserve">
          <source>Retrieves the a record associated with the current record given the field name, as defined by the GraphQL document. If the linked record does not exist, it will be created given the type name. Returns a &lt;code&gt;RecordProxy&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="379be92d54161c2f80dceac4cdce0230264cb208" translate="yes" xml:space="preserve">
          <source>Retrieves the set of records associated with the current record given the field name, as defined by the GraphQL document. Returns an array of &lt;code&gt;RecordProxies&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e013c79a69f7fdde5c1472633a22316f0ef0ef72" translate="yes" xml:space="preserve">
          <source>Retrying failed requests.</source>
          <target state="translated">Reintentar las solicitudes fallidas.</target>
        </trans-unit>
        <trans-unit id="4ed1a51e3c7c6cf43a3633b3e58f69e74b9dd263" translate="yes" xml:space="preserve">
          <source>Return Value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e358acbbc41f30837ea01e45fb712ceb42c930a" translate="yes" xml:space="preserve">
          <source>Returns a &lt;code&gt;Disposable&lt;/code&gt; on which you could call &lt;code&gt;dispose()&lt;/code&gt; to cancel the refetch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56de3c3d136f4071d757cabe4b6ed2c52a5dad01" translate="yes" xml:space="preserve">
          <source>Returns a proxy class for manipulating records from a record source, for example a query, mutation, or the store.</source>
          <target state="translated">Devuelve una clase de proxy para manipular registros de una fuente de registro,por ejemplo una consulta,una mutación o el almacén.</target>
        </trans-unit>
        <trans-unit id="91f8449d9fa8e9ef7aa99597a20ab0dcfe5b332a" translate="yes" xml:space="preserve">
          <source>Returns a read-only view of the store's internal RecordSource that holds all records.</source>
          <target state="translated">Devuelve una vista de sólo lectura del RecordSource interno de la tienda que contiene todos los registros.</target>
        </trans-unit>
        <trans-unit id="ddc37b98bab248dd41f22f1276390ce274609bd3" translate="yes" xml:space="preserve">
          <source>Returns the &lt;a href=&quot;#recordproxy&quot;&gt;&lt;code&gt;RecordProxy&lt;/code&gt;&lt;/a&gt; representing the root of the GraphQL document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a9d68c06d14e4ad8d6a81f1e355b118c27b1408" translate="yes" xml:space="preserve">
          <source>Returns the GraphQL type name for a given record.</source>
          <target state="translated">Devuelve el nombre de tipo GraphQL para un registro determinado.</target>
        </trans-unit>
        <trans-unit id="d43e7555e127344d4f989c546065e0799ff790bb" translate="yes" xml:space="preserve">
          <source>Returns the dataID of the current record.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="384ac89b24069cf234b54ff56b3d6d5c565f33c7" translate="yes" xml:space="preserve">
          <source>Returns the globally unique identifier string for a record.</source>
          <target state="translated">Devuelve la cadena de identificación global única de un registro.</target>
        </trans-unit>
        <trans-unit id="7d0eb64e469d72e6ccf94d6d96498f73ad0e6f27" translate="yes" xml:space="preserve">
          <source>Reusable fragments to compose within the above use cases.</source>
          <target state="translated">Fragmentos reutilizables para componer dentro de los casos de uso anteriores.</target>
        </trans-unit>
        <trans-unit id="72e1985969f053f8609f492cf63340c5c4f7f3fc" translate="yes" xml:space="preserve">
          <source>Rolls back an optimistic mutation.</source>
          <target state="translated">Retrocede una mutación optimista.</target>
        </trans-unit>
        <trans-unit id="0dfddbb0a122d3a2969eb11e085210ba893e7399" translate="yes" xml:space="preserve">
          <source>Root Container</source>
          <target state="translated">Contenedor de Raíz</target>
        </trans-unit>
        <trans-unit id="1bf5197778bc12b8d4edfe1a0c2de1ced169d30b" translate="yes" xml:space="preserve">
          <source>RootContainer</source>
          <target state="translated">RootContainer</target>
        </trans-unit>
        <trans-unit id="4999528efe0f94f8f66b1dc05aad8ebaaae7b2be" translate="yes" xml:space="preserve">
          <source>Route</source>
          <target state="translated">Route</target>
        </trans-unit>
        <trans-unit id="52c021a7e89ad4e72cef6096b3c6424e78876574" translate="yes" xml:space="preserve">
          <source>Route is useful in providing the context which a component is being rendered in. It includes information about the &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;params&lt;/code&gt;, and &lt;code&gt;queries&lt;/code&gt; of the current route.</source>
          <target state="translated">La ruta es &amp;uacute;til para proporcionar el contexto en el que se representa un componente. Incluye informaci&amp;oacute;n sobre el &lt;code&gt;name&lt;/code&gt; , los &lt;code&gt;params&lt;/code&gt; y las &lt;code&gt;queries&lt;/code&gt; de la ruta actual.</target>
        </trans-unit>
        <trans-unit id="03730e58401ef5d9e79d1f674df0a5f9cf756e33" translate="yes" xml:space="preserve">
          <source>Routes</source>
          <target state="translated">Routes</target>
        </trans-unit>
        <trans-unit id="0bd75f049435ac9bea4df8ce63749bdcfaaef9e4" translate="yes" xml:space="preserve">
          <source>Routes and Queries</source>
          <target state="translated">Rutas y consultas</target>
        </trans-unit>
        <trans-unit id="a476715db16204d7e6fb7743a314ee35337241d4" translate="yes" xml:space="preserve">
          <source>Routes are now optional: &lt;code&gt;QueryRenderer&lt;/code&gt; can be used without defining a route. More in the &lt;a href=&quot;routing&quot;&gt;routing guide&lt;/a&gt;.</source>
          <target state="translated">Las rutas ahora son opcionales: &lt;code&gt;QueryRenderer&lt;/code&gt; se puede usar sin definir una ruta. M&amp;aacute;s en la &lt;a href=&quot;routing&quot;&gt;gu&amp;iacute;a de enrutamiento&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ca283153940483bc802b34b41123871d483749c7" translate="yes" xml:space="preserve">
          <source>Routes are objects that define a set of root queries and input parameters. Here is a simple route that might be used to render user &lt;code&gt;123&lt;/code&gt;'s profile:</source>
          <target state="translated">Las rutas son objetos que definen un conjunto de consultas ra&amp;iacute;z y par&amp;aacute;metros de entrada. Aqu&amp;iacute; hay una ruta simple que podr&amp;iacute;a usarse para representar el perfil del usuario &lt;code&gt;123&lt;/code&gt; :</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
