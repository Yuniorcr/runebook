<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="ocaml">
    <body>
      <group id="ocaml">
        <trans-unit id="5ef10155ca428da06ee8b6867d58296ace73ef7f" translate="yes" xml:space="preserve">
          <source>Since OCaml 4.08, it is possible to mark components (such as value or type declarations) in signatures with &amp;ldquo;alerts&amp;rdquo; that will be reported when those components are referenced. This generalizes the notion of &amp;ldquo;deprecated&amp;rdquo; components which were previously reported as warning 3. Those alerts can be used for instance to report usage of unsafe features, or of features which are only available on some platforms, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fb784bd027538e4265b84b801b820609e843b9e" translate="yes" xml:space="preserve">
          <source>Since OCaml 4.09, the graphics library is distributed as an external package. Its new home is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47910afc78d4869690c0ed5c357621b1abf65b2a" translate="yes" xml:space="preserve">
          <source>Since OCaml version 4.02, the OCamlBrowser tool and the Labltk library are distributed separately from the OCaml compiler. The project is now hosted at &lt;a href=&quot;https://forge.ocamlcore.org/projects/labltk/&quot;&gt;https://forge.ocamlcore.org/projects/labltk/&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dd8aca1f9a01cb48e6026142ef6b38695861840" translate="yes" xml:space="preserve">
          <source>Since OCaml version 4.02, the OCamlBrowser tool and the Labltk library are distributed separately from the OCaml compiler. The project is now hosted at &lt;a href=&quot;https://github.com/garrigue/labltk&quot;&gt;https://github.com/garrigue/labltk&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85aeea25da4f851d04af97132f25d53038ece0d4" translate="yes" xml:space="preserve">
          <source>Since OCaml version 4.03, the ocamlbuild compilation manager is distributed separately from the OCaml compiler. The project is now hosted at &lt;a href=&quot;https://github.com/ocaml/ocamlbuild/&quot;&gt;https://github.com/ocaml/ocamlbuild/&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c42e6e2c2dc841c6813ede2648ca45d6e38f24" translate="yes" xml:space="preserve">
          <source>Since Ocaml 3.12, the keywords inherit!, val! and method! have the same semantics as inherit, val and method, but they additionally require the definition they introduce to be overriding. Namely, method! requires &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; to be already defined in this class, val! requires &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt; to be already defined in this class, and inherit! requires &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; to override some definitions. If no such overriding occurs, an error is signaled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b41b06211bb56a2cb0a28226137e946166598852" translate="yes" xml:space="preserve">
          <source>Since blocks are composed of several words, a block can potentially be sampled several times. If a block is sampled several times, then each of the callback is called once for each event of this block: the multiplicity is given in the &lt;code&gt;n_samples&lt;/code&gt; field of the &lt;code&gt;allocation&lt;/code&gt; structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="879e48e0d81c1920490f9453989dbafc873931d1" translate="yes" xml:space="preserve">
          <source>Since the fields x and y can only appear simultaneously in the first record type, OCaml infers that the type of project_and_rotate is first_record -&amp;gt; first_record.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11b5947847de732bcf3a69fffb2afbb29de82849" translate="yes" xml:space="preserve">
          <source>Since the functions have sufficiently few arguments, more specialised arguments will be added. After some simplification one obtains:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="607a6de4f0d6d6061a214efa4d56f36e0fd649f8" translate="yes" xml:space="preserve">
          <source>Since the type of None is 'a option and the function ref has type 'b -&amp;gt; 'b ref, a natural deduction for the type of store would be 'a option ref. However, the inferred type, '_weak1 option ref, is different. Type variables whose name starts with a _weak prefix like '_weak1 are weakly polymorphic type variables, sometimes shortened as weak type variables. A weak type variable is a placeholder for a single type that is currently unknown. Once the specific type t behind the placeholder type '_weak1 is known, all occurrences of '_weak1 will be replaced by t. For instance, we can define another option reference and store an int inside:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f454df85c0505167cc193264f5f21518fa34f8d9" translate="yes" xml:space="preserve">
          <source>Since the use of a return type often eliminates the need to name type parameters in the left-hand side of a type definition, one can replace them with anonymous types _ in that case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ecba5078a243b75e15bfb04595710b711f37d53" translate="yes" xml:space="preserve">
          <source>Since there is only one case in this pattern matching, it is safe to expand directly the argument r in a record pattern:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6388c54547c979489e38f3575180f088b92eef41" translate="yes" xml:space="preserve">
          <source>Since version 3.10, redefinitions of a visible instance variable with the same name do not create a new variable, but are merged, using the last value for initialization. They must have identical types and mutability. However, if an instance variable is hidden by omitting it from an interface, it will be kept distinct from other instance variables with the same name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc7b7e27599e0ea9a03712ac291946d71c69a826" translate="yes" xml:space="preserve">
          <source>Sine.</source>
          <target state="translated">Sine.</target>
        </trans-unit>
        <trans-unit id="49bb3c5b34d4f790f63a5f9bea42c5d394baa7d3" translate="yes" xml:space="preserve">
          <source>Sine. Argument is in radians.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="850e57a1ee5fae18b0892f2cbd53b13443f4e553" translate="yes" xml:space="preserve">
          <source>Size (in words) of the largest block in the free list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23aa6e811d60088ebfe23efb308861aa99dcc44c" translate="yes" xml:space="preserve">
          <source>Size in bytes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45cf1f454a042183408948a20c84cf3be2a96f7b" translate="yes" xml:space="preserve">
          <source>Size of &lt;code&gt;int&lt;/code&gt;, in bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d1eb5965b0e8500bb02fadfe8d12ee828f16ead" translate="yes" xml:space="preserve">
          <source>Size of &lt;code&gt;int&lt;/code&gt;, in bits. It is 31 (resp. 63) when using OCaml on a 32-bit (resp. 64-bit) platform. It may differ for other implementations, e.g. it can be 32 bits when compiling to JavaScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="811814293c14ee9d45359fd381dbd3619cdced86" translate="yes" xml:space="preserve">
          <source>Size of one word on the machine currently executing the OCaml program, in bits: 32 or 64.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f670099c33bb6a9695a8b24391cc3ee7a94ec07" translate="yes" xml:space="preserve">
          <source>Size of received buffer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a091b3f09d5cc7e72f0c3a89f2986c55176bed8" translate="yes" xml:space="preserve">
          <source>Size of send buffer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe888e70bfcbb275fa018e62ca6da8b998d3acd2" translate="yes" xml:space="preserve">
          <source>Slots are returned in the same order as &lt;code&gt;backtrace_slots&lt;/code&gt;: the slot at index &lt;code&gt;0&lt;/code&gt; is the most recent call, raise, or primitive, and subsequent slots represent callers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5ba5bd7b7fe69d79153223545822822aa2cdcaf" translate="yes" xml:space="preserve">
          <source>So far, we have described how to call C functions from OCaml. In this section, we show how C functions can call OCaml functions, either as callbacks (OCaml calls C which calls OCaml), or with the main program written in C.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93c6a1f183694628e37ced41591147bfc0da1908" translate="yes" xml:space="preserve">
          <source>Socket</source>
          <target state="translated">Socket</target>
        </trans-unit>
        <trans-unit id="2cfd29f9858165eacbb559bf3f07fe2ff6c6692a" translate="yes" xml:space="preserve">
          <source>Socket domain</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e98a4ed23c4c749f9fc8167cd3bde6181cd3ddb" translate="yes" xml:space="preserve">
          <source>Socket is already connected</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff89f748bc36cfa9b24752455509275ea67d6018" translate="yes" xml:space="preserve">
          <source>Socket is not connected</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba3a2f86cdfbc4d51c8dd0104aa25dd69c9ae5eb" translate="yes" xml:space="preserve">
          <source>Socket operation on non-socket</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3348447c0d2adbd99decc7a8738b6dea888ab6ca" translate="yes" xml:space="preserve">
          <source>Socket options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9ad407a2d95af30c4033ba9ae9c8dae9a728edf" translate="yes" xml:space="preserve">
          <source>Socket protocol number</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44977f379f1c02803857933034b64abf658f4fbb" translate="yes" xml:space="preserve">
          <source>Socket type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d0a063107fb2a5027e2f89664a6337ddcb70691" translate="yes" xml:space="preserve">
          <source>Socket type not supported</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="508c36b3241ae34627fb1cadebb1f27b16e0f61a" translate="yes" xml:space="preserve">
          <source>Sockets</source>
          <target state="translated">Sockets</target>
        </trans-unit>
        <trans-unit id="da7e8a5db4d27cd8e808680b636e1905c8ab337a" translate="yes" xml:space="preserve">
          <source>Software caused connection abort</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac38d3ac2b8f5582491bf72aa187e55579c2e9be" translate="yes" xml:space="preserve">
          <source>Some attributes are understood by the type-checker:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cfecef4a7de8587a8731429a921ca7d4dfb4fd2" translate="yes" xml:space="preserve">
          <source>Some constructors, such as the exception constructors Failure and Invalid_argument, take as parameter a string value holding a text message intended for the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65db1c59080316bcf74caa7e0683333457ad28c6" translate="yes" xml:space="preserve">
          <source>Some elements support only a subset of all @-tags. Tags that are not relevant to the documented element are simply ignored. For instance, all tags are ignored when documenting type constructors, record fields, and class inheritance clauses. Similarly, a @param tag on a class instance variable is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3e4e360257048c8ac9623c4484c27cbb25c848b" translate="yes" xml:space="preserve">
          <source>Some entity (typically an expression) the value of which is known by the compiler at compile time. Constantness may be explicit from the source code or inferred by the Flambda optimisers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4108bc1b80291fcd27aa85d3bc69508cd42011b" translate="yes" xml:space="preserve">
          <source>Some extension nodes are understood by the compiler itself:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac91f25bdfaca0fd0f24bc1c048bd2a822908634" translate="yes" xml:space="preserve">
          <source>Some functions are flagged as not tail-recursive. A tail-recursive function uses constant stack space, while a non-tail-recursive function uses stack space proportional to the length of its list argument, which can be a problem with very long lists. When the function takes several list arguments, an approximate formula giving stack usage (in some unspecified constant unit) is shown in parentheses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="415760abd20f9a3ddcb87f0308d37d8d1a8acca5" translate="yes" xml:space="preserve">
          <source>Some of the Flambda flags may be subject to change in future releases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8faaa28b910e81e493d1ec8c3ff366be796ccb5" translate="yes" xml:space="preserve">
          <source>Some possible reasons for failing to return a location are as follow:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="352a26fd5c9966e34dc532660aeee492db89a4c8" translate="yes" xml:space="preserve">
          <source>Some possible reasons for returning &lt;code&gt;None&lt;/code&gt; are as follow:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a491a5b9ff21fc1c712012884a3f6d5255eb641d" translate="yes" xml:space="preserve">
          <source>Some special expressions are available in method bodies for manipulating instance variables and duplicating self:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dd7671731908ef2e0dae4c0fec50f5db2c9e9ac" translate="yes" xml:space="preserve">
          <source>Some syntactic constructions are accepted during parsing and rejected during type checking. These syntactic constructions can therefore not be used directly in vanilla OCaml. However, -ppx rewriters and other external tools can exploit this parser leniency to extend the language with these new syntactic constructions by rewriting them to vanilla constructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b04e037b0385d924ca5dee88bb5daf574bbfe126" translate="yes" xml:space="preserve">
          <source>Some_val(v) returns the argument \var{x} of a value v of the form Some(x).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc75d8733433957f6ed3394f8f48aaaa13a230d6" translate="yes" xml:space="preserve">
          <source>Sort a floatarray in increasing order according to a comparison function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12b9742f0225797751f8d045f36f092bce5f2a25" translate="yes" xml:space="preserve">
          <source>Sort a floatarray in increasing order according to a comparison function. The comparison function must return 0 if its arguments compare as equal, a positive integer if the first is greater, and a negative integer if the first is smaller (see below for a complete specification). For example, &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt; is a suitable comparison function. After calling &lt;code&gt;sort&lt;/code&gt;, the array is sorted in place in increasing order. &lt;code&gt;sort&lt;/code&gt; is guaranteed to run in constant heap space and (at most) logarithmic stack space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="646c2222ce8e2809d04501367fe92adb8b901099" translate="yes" xml:space="preserve">
          <source>Sort a list in increasing order according to a comparison function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07dab5a7b6f2fcf6a121a862ed23192a82b64444" translate="yes" xml:space="preserve">
          <source>Sort a list in increasing order according to a comparison function. The comparison function must return 0 if its arguments compare as equal, a positive integer if the first is greater, and a negative integer if the first is smaller (see Array.sort for a complete specification). For example, &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt; is a suitable comparison function. The resulting list is sorted in increasing order. &lt;a href=&quot;list#VALsort&quot;&gt;&lt;code&gt;List.sort&lt;/code&gt;&lt;/a&gt; is guaranteed to run in constant heap space (in addition to the size of the result list) and logarithmic stack space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44e135c27126ac813e3015ef39e796c759b36f4b" translate="yes" xml:space="preserve">
          <source>Sort a list in increasing order according to a comparison function. The comparison function must return 0 if its arguments compare as equal, a positive integer if the first is greater, and a negative integer if the first is smaller (see Array.sort for a complete specification). For example, &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt; is a suitable comparison function. The resulting list is sorted in increasing order. &lt;a href=&quot;listlabels#VALsort&quot;&gt;&lt;code&gt;ListLabels.sort&lt;/code&gt;&lt;/a&gt; is guaranteed to run in constant heap space (in addition to the size of the result list) and logarithmic stack space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03d3137b9feb06bf6e9a2e8f8dca4845b6ea1be1" translate="yes" xml:space="preserve">
          <source>Sort a list in increasing order according to a comparison function. The comparison function must return 0 if its arguments compare as equal, a positive integer if the first is greater, and a negative integer if the first is smaller (see Array.sort for a complete specification). For example, &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt; is a suitable comparison function. The resulting list is sorted in increasing order. &lt;code&gt;List.sort&lt;/code&gt; is guaranteed to run in constant heap space (in addition to the size of the result list) and logarithmic stack space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58d97caa0b4ab44fd3739d173807df802d224d9e" translate="yes" xml:space="preserve">
          <source>Sort an array in increasing order according to a comparison function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4bce5c3631201bcc5ecaef3a611067df24b6202" translate="yes" xml:space="preserve">
          <source>Sort an array in increasing order according to a comparison function. The comparison function must return 0 if its arguments compare as equal, a positive integer if the first is greater, and a negative integer if the first is smaller (see below for a complete specification). For example, &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt; is a suitable comparison function, provided there are no floating-point NaN values in the data. After calling &lt;code&gt;sort&lt;/code&gt;, the array is sorted in place in increasing order. &lt;code&gt;sort&lt;/code&gt; is guaranteed to run in constant heap space and (at most) logarithmic stack space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b83d35f48bff1338b8ffef8c14c816e297c383b8" translate="yes" xml:space="preserve">
          <source>Sort an array in increasing order according to a comparison function. The comparison function must return 0 if its arguments compare as equal, a positive integer if the first is greater, and a negative integer if the first is smaller (see below for a complete specification). For example, &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt; is a suitable comparison function. After calling &lt;code&gt;Array.sort&lt;/code&gt;, the array is sorted in place in increasing order. &lt;code&gt;Array.sort&lt;/code&gt; is guaranteed to run in constant heap space and (at most) logarithmic stack space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bacc62ebcf0deeea3a374112083a2d9383b42ec" translate="yes" xml:space="preserve">
          <source>Sort an array in increasing order according to a comparison function. The comparison function must return 0 if its arguments compare as equal, a positive integer if the first is greater, and a negative integer if the first is smaller (see below for a complete specification). For example, &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt; is a suitable comparison function. After calling &lt;code&gt;sort&lt;/code&gt;, the array is sorted in place in increasing order. &lt;code&gt;sort&lt;/code&gt; is guaranteed to run in constant heap space and (at most) logarithmic stack space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01152a07b57f8764c6289151ce131fa414021b94" translate="yes" xml:space="preserve">
          <source>Sort files according to their dependencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a0c9ee78d00c49fdb36745d008f1df78dd6c77a" translate="yes" xml:space="preserve">
          <source>Sort the list of top-level modules before generating the documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="378e9e163b7eecefadb4415cae533096e336c4ab" translate="yes" xml:space="preserve">
          <source>Sorting</source>
          <target state="translated">Sorting</target>
        </trans-unit>
        <trans-unit id="ae89003b504fabd08ec3be7403f79794ab72855c" translate="yes" xml:space="preserve">
          <source>Spacetime</source>
          <target state="translated">Spacetime</target>
        </trans-unit>
        <trans-unit id="1f8cf16b7ea8f93bf5c99c3fb2607d56d944da70" translate="yes" xml:space="preserve">
          <source>Spacetime is currently only available for x86-64 targets and has only been tested on Linux systems (although it is expected to work on most modern Unix-like systems and provision has been made for running under Windows). It is expected that the set of supported platforms will be extended in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac584b81666b3bc3363ef560830c1cfe8b0e82d8" translate="yes" xml:space="preserve">
          <source>Spacetime is the name given to functionality within the OCaml compiler that provides for accurate profiling of the memory behaviour of a program. Using Spacetime it is possible to determine the source of memory leaks and excess memory allocation quickly and easily. Excess allocation slows programs down both by imposing a higher load on the garbage collector and reducing the cache locality of the program&amp;rsquo;s code. Spacetime provides full backtraces for every allocation that occurred on the OCaml heap during the lifetime of the program including those in C stubs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48a679b4fef93210c99c2867dca8b855aae9f079" translate="yes" xml:space="preserve">
          <source>Spacetime only analyses the memory behaviour of a program with respect to the OCaml heap allocators and garbage collector. It does not analyse allocation on the C heap. Spacetime does not affect the memory behaviour of a program being profiled with the exception of any change caused by the overhead of profiling (see section &lt;a href=&quot;#s%3Aspacetime-runtimeoverhead&quot;&gt;22.3&lt;/a&gt;)&amp;mdash;for example the program running slower might cause it to allocate less memory in total.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bfc66fca52f849b22836f519ac13502d262a97d" translate="yes" xml:space="preserve">
          <source>Spacetime-configured compilers run slower and occupy more memory than their counterparts. It is hoped this will be fixed in the future as part of improved cross compilation support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f3d7da024c878836fb44bec74f82a857945e099" translate="yes" xml:space="preserve">
          <source>Specialised argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36d1cca4de316b0f3ff4a4a7aea712ca5d0b8416" translate="yes" xml:space="preserve">
          <source>Specialised formatted input functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7ee5cdce5b5adc99a16107f8a0cbad11ccbdc8e" translate="yes" xml:space="preserve">
          <source>Specialized version of &lt;a href=&quot;bigarray#VALreshape&quot;&gt;&lt;code&gt;Bigarray.reshape&lt;/code&gt;&lt;/a&gt; for reshaping to one-dimensional arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c8e450d4639c979ec29c285647dd2fe5e10040b" translate="yes" xml:space="preserve">
          <source>Specialized version of &lt;a href=&quot;bigarray#VALreshape&quot;&gt;&lt;code&gt;Bigarray.reshape&lt;/code&gt;&lt;/a&gt; for reshaping to three-dimensional arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7be8395c98cd0223aab91f0599a991b4dc5afc58" translate="yes" xml:space="preserve">
          <source>Specialized version of &lt;a href=&quot;bigarray#VALreshape&quot;&gt;&lt;code&gt;Bigarray.reshape&lt;/code&gt;&lt;/a&gt; for reshaping to two-dimensional arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43c35773327940730b665961e4752362a3b5e73d" translate="yes" xml:space="preserve">
          <source>Specialized version of &lt;a href=&quot;bigarray#VALreshape&quot;&gt;&lt;code&gt;Bigarray.reshape&lt;/code&gt;&lt;/a&gt; for reshaping to zero-dimensional arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78b2052c026f21ce8899e084abfbef4c7c52450f" translate="yes" xml:space="preserve">
          <source>Specific annotations may be added in the format strings to give pretty-printing commands to the pretty-printing engine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2c3dd0891ac4b24b95fb75f329dbcf06edc414d" translate="yes" xml:space="preserve">
          <source>Specification of the comparison function: Let &lt;code&gt;a&lt;/code&gt; be the array and &lt;code&gt;cmp&lt;/code&gt; the comparison function. The following must be true for all &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;z&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="264268d95295992703c12c188ef6048251a383d4" translate="yes" xml:space="preserve">
          <source>Specification of the comparison function: Let &lt;code&gt;a&lt;/code&gt; be the array and &lt;code&gt;cmp&lt;/code&gt; the comparison function. The following must be true for all x, y, z in a :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c87398d6e8515ee08416522a6df16c4bee30fa5" translate="yes" xml:space="preserve">
          <source>Specification of the comparison function: Let &lt;code&gt;a&lt;/code&gt; be the floatarray and &lt;code&gt;cmp&lt;/code&gt; the comparison function. The following must be true for all &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;z&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d11d12414ac6591fc5217e352ba4806e18c81fbd" translate="yes" xml:space="preserve">
          <source>Specifies an additional string to be output with profiling information. By default, ocamlprof will annotate programs with comments of the form (* n *) where n is the counter value for a profiling point. With option -F s, the annotation will be (* sn *).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2ecbd64b6f63c8a41ad755311ef578f6fdd8a7a" translate="yes" xml:space="preserve">
          <source>Specifies an alternate dump file of profiling information to be read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78189676774d8a03ffec36cdd021f56d4ff85ad2" translate="yes" xml:space="preserve">
          <source>Specify Info directory entry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f53615fd58fe78d52627fd5cf11f02e0382fab5" translate="yes" xml:space="preserve">
          <source>Specify merge options between interfaces and implementations. (see section &lt;a href=&quot;#ss%3Aocamldoc-merge&quot;&gt;15.1.2&lt;/a&gt; for details). flags can be one or several of the following characters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="764c1c2ac8fdb8df6ca241276b753400dbadf23e" translate="yes" xml:space="preserve">
          <source>Specify merge options between interfaces and implementations. (see section &lt;a href=&quot;#ss%3Aocamldoc-merge&quot;&gt;16.1.2&lt;/a&gt; for details). flags can be one or several of the following characters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b2722d55e0ed667661be2e505491b3e2508aee" translate="yes" xml:space="preserve">
          <source>Specify odd parity instead of even.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9eb61307c6397dc068c4836d5615b32db4f1bce" translate="yes" xml:space="preserve">
          <source>Specify section of Info directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cf69310aaf4ba0ff88c8c11acbb5d9e874ea7a9" translate="yes" xml:space="preserve">
          <source>Specify the colors to use in the generated dot code. When generating module dependencies, ocamldoc uses different colors for modules, depending on the directories in which they reside. When generating types dependencies, ocamldoc uses different colors for types, depending on the modules in which they are defined. colors is a list of color names separated by &amp;rsquo;,&amp;rsquo;, as in Red,Blue,Green. The available colors are the ones supported by the dot tool.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1a04c4094800d4a25e3996a323a80970407a756" translate="yes" xml:space="preserve">
          <source>Specify the name of the output file produced by ocamllex. The default is the input file name with its extension replaced by .ml.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bf2268a91aceafedecc7a037c499f825f2acf2f" translate="yes" xml:space="preserve">
          <source>Specify the name of the output file produced by the compiler. The default output name is a.out under Unix and camlprog.exe under Windows. If the -a option is given, specify the name of the library produced. If the -pack option is given, specify the name of the packed object file produced. If the -output-obj option is given, specify the name of the output file produced. If the -c option is given, specify the name of the object file produced for the &lt;em&gt;next&lt;/em&gt; source file that appears on the command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d328a3d88738a8d3eadb3b8aefcee241c2d7a300" translate="yes" xml:space="preserve">
          <source>Specify the name of the output file produced by the linker. The default output name is a.out under Unix and camlprog.exe under Windows. If the -a option is given, specify the name of the library produced. If the -pack option is given, specify the name of the packed object file produced. If the -output-obj option is given, specify the name of the output file produced. If the -shared option is given, specify the name of plugin file produced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eac56ecb3edcec97524e457cb8e36bfda3addec2" translate="yes" xml:space="preserve">
          <source>Specify the name of the toplevel file produced by the linker. The default is a.out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49fbb0a75dfa6081ddf8737f80eeb75c46445512" translate="yes" xml:space="preserve">
          <source>Specify the type of the semantic attributes for the given symbols. This is mandatory for start symbols only. Other nonterminal symbols need not be given types by hand: these types will be inferred when running the output files through the OCaml compiler (unless the &lt;code&gt;-s&lt;/code&gt; option is in effect). The &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; part is an arbitrary OCaml type expression, except that all type constructor names must be fully qualified, as explained above for %token.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc0c554e640ae69ee83bf329f25eaa01f80aabef" translate="yes" xml:space="preserve">
          <source>Split a file name into directory name / base file name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ef2916d6063e59b7dc104bdabcd5daed75d687b" translate="yes" xml:space="preserve">
          <source>Split a file name into directory name / base file name. If &lt;code&gt;name&lt;/code&gt; is a valid file name, then &lt;code&gt;concat&amp;nbsp;(dirname&amp;nbsp;name)&amp;nbsp;(basename&amp;nbsp;name)&lt;/code&gt; returns a file name which is equivalent to &lt;code&gt;name&lt;/code&gt;. Moreover, after setting the current directory to &lt;code&gt;dirname&amp;nbsp;name&lt;/code&gt; (with &lt;a href=&quot;sys#VALchdir&quot;&gt;&lt;code&gt;Sys.chdir&lt;/code&gt;&lt;/a&gt;), references to &lt;code&gt;basename&amp;nbsp;name&lt;/code&gt; (which is a relative file name) designate the same file as &lt;code&gt;name&lt;/code&gt; before the call to &lt;a href=&quot;sys#VALchdir&quot;&gt;&lt;code&gt;Sys.chdir&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18a9705b01dc9c170d51771a987c403f46a25076" translate="yes" xml:space="preserve">
          <source>Splitting</source>
          <target state="translated">Splitting</target>
        </trans-unit>
        <trans-unit id="16df53085eea45d012180a01d9c65e4d69715793" translate="yes" xml:space="preserve">
          <source>Square root.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d3138eae7ebb469e62a43de3996f397bab11b30" translate="yes" xml:space="preserve">
          <source>Square root. The result &lt;code&gt;x&amp;nbsp;+&amp;nbsp;i.y&lt;/code&gt; is such that &lt;code&gt;x&amp;nbsp;&amp;gt;&amp;nbsp;0&lt;/code&gt; or &lt;code&gt;x&amp;nbsp;=&amp;nbsp;0&lt;/code&gt; and &lt;code&gt;y&amp;nbsp;&amp;gt;=&amp;nbsp;0&lt;/code&gt;. This function has a discontinuity along the negative real axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83e5a0d3d2ef19df258412a4d3ef3f9533b0c0c1" translate="yes" xml:space="preserve">
          <source>Stack</source>
          <target state="translated">Stack</target>
        </trans-unit>
        <trans-unit id="119f5ab8a4f65aecd72a4d4c15e7238c1dd30516" translate="yes" xml:space="preserve">
          <source>Standard labeled libraries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="508cfdd242a4dbc44b800a23c67d10428e2c6d2c" translate="yes" xml:space="preserve">
          <source>Standard library modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010b937250d8458f84df0333c058e6bbe6ee9a4c" translate="yes" xml:space="preserve">
          <source>Start and end of major GC cycle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4da9a8e1b11d834d3eab1b30b53670f8388f8aa" translate="yes" xml:space="preserve">
          <source>Start character (usually ctrl-Q).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="277ac8ecc15e2c9171fab8c17452880f42607be5" translate="yes" xml:space="preserve">
          <source>Start of major GC cycle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90e0161012dde2267255594a35194c6fbd832e5d" translate="yes" xml:space="preserve">
          <source>Start the sampling with the given parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19cc28c4f6b24df76b4178e0a8799f0454427c48" translate="yes" xml:space="preserve">
          <source>Start the sampling with the given parameters. Fails if sampling is already active.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f830a13dce8adcb0cabc74755c312cfc51e5017b" translate="yes" xml:space="preserve">
          <source>Starting with Objective Caml 3.00, it is possible to record the -custom option as well as the names of C libraries in an OCaml library file .cma or .cmxa. For instance, consider an OCaml library mylib.cma, built from the OCaml object files a.cmo and b.cmo, which reference C code in libmylib.a. If the library is built as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b91eda3d5a614d7d82dcfba7938bafd9738269ae" translate="yes" xml:space="preserve">
          <source>Starting with Objective Caml 3.03, an alternative to static linking of C code using the -custom code is provided. In this mode, the OCaml linker generates a pure bytecode executable (no embedded custom runtime system) that simply records the names of dynamically-loaded libraries containing the C code. The standard OCaml runtime system ocamlrun then loads dynamically these libraries, and resolves references to the required primitives, before executing the bytecode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f59cc0afb2e7a12e0dd36361604146e391913c8" translate="yes" xml:space="preserve">
          <source>Startup messages (loading the bytecode executable file, resolving shared libraries).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2086b21f8f49274138c38d476bee317a84a8aecc" translate="yes" xml:space="preserve">
          <source>Statistics</source>
          <target state="translated">Statistics</target>
        </trans-unit>
        <trans-unit id="29757350cc40a874924e4f8603f0be72611f1555" translate="yes" xml:space="preserve">
          <source>StdLabels</source>
          <target state="translated">StdLabels</target>
        </trans-unit>
        <trans-unit id="e4480faf0e810a556a7a3d6b1944ea9990b30303" translate="yes" xml:space="preserve">
          <source>Stdlib</source>
          <target state="translated">Stdlib</target>
        </trans-unit>
        <trans-unit id="9e253470c876ee6d5c720eb777aeb82d4c26e28f" translate="yes" xml:space="preserve">
          <source>Stop</source>
          <target state="translated">Stop</target>
        </trans-unit>
        <trans-unit id="cac94c65840b164f967c185720ce5d2d22fcd8fc" translate="yes" xml:space="preserve">
          <source>Stop character (usually ctrl-S).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd2d0badca0107bfe00c8bf707f6cbbc66e875ef" translate="yes" xml:space="preserve">
          <source>Stop compilation after the given compilation pass. The currently supported passes are: parsing, typing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acb0dcfd6906c0d9e5e828dfe6db5b7a0e08dae4" translate="yes" xml:space="preserve">
          <source>Stop execution for the given number of seconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba8848ffcb6b76a0d727951fcafac4b2adee910f" translate="yes" xml:space="preserve">
          <source>Stop execution for the given number of seconds. Like &lt;code&gt;sleep&lt;/code&gt;, but fractions of seconds are supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e31551b253bad775da861aa7e781e955c0170316" translate="yes" xml:space="preserve">
          <source>Stop interpreting keywords and call the function with all remaining arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f39332271b648b33b9216188c148ca185ccff4c" translate="yes" xml:space="preserve">
          <source>Stop interpreting keywords and call the function with each remaining argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54caba6c5e005665e19c471a9869196aa5fe758e" translate="yes" xml:space="preserve">
          <source>Stop the sampling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa8698fd09970a6af5ef2746988e8701f18facae" translate="yes" xml:space="preserve">
          <source>Stop the sampling. Fails if sampling is not active.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31ef85d3886324ac0daa432598f7f28c17c3ca8f" translate="yes" xml:space="preserve">
          <source>Stop tracing all functions traced so far.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cef2a78b119882569894c0a7f505f95f3af25ea" translate="yes" xml:space="preserve">
          <source>Stop tracing the given function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="159480ac5536641c98c16dc1a2fc1666f43ed18c" translate="yes" xml:space="preserve">
          <source>Store_double_field(v, n, d) stores the double precision floating-point number d in the n&lt;sup&gt;th&lt;/sup&gt; element of the array of floating-point numbers v.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba2305bf40cfd2ed7e52c98519e2076d13f1f2a8" translate="yes" xml:space="preserve">
          <source>Store_field (b, n, v) stores the value v in the field number n of value b, which must be a block (i.e. Is_block(b) must be true).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="382e914de22199d46f8d0ef5c5b6a457fd5f5f88" translate="yes" xml:space="preserve">
          <source>Store_field(b, n, v) stores the value v in the field number n of value b, which must be a structured block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dfe08d5f0fd501cb4cb5c9b5ab1306e28c9aaa5" translate="yes" xml:space="preserve">
          <source>Str</source>
          <target state="translated">Str</target>
        </trans-unit>
        <trans-unit id="df063869e11d7a9aa132cd4a984f7b5eb870d656" translate="yes" xml:space="preserve">
          <source>Stream</source>
          <target state="translated">Stream</target>
        </trans-unit>
        <trans-unit id="b48e1a50e3eb18053b14d5bfc02d99c1f824c681" translate="yes" xml:space="preserve">
          <source>Stream builders</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9712546075280428be043f28e86353de8b8e9c67" translate="yes" xml:space="preserve">
          <source>Stream iterator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1df93dbb42814b12d5b273e5758a6fac66a2de5" translate="yes" xml:space="preserve">
          <source>Stream socket</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb2e7e5cdfa180129198e529d8ea2621c317804f" translate="yes" xml:space="preserve">
          <source>Streams and parsers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3df63b7acb0522da685dad5fe84b81fdd7b25264" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="translated">String</target>
        </trans-unit>
        <trans-unit id="bb36019440cc173d127c3aae1c10a96090c6c585" translate="yes" xml:space="preserve">
          <source>String concatenation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d310b2b99cc668b17af0b02d5702685919572c5" translate="yes" xml:space="preserve">
          <source>String concatenation. Right-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c14d9fcd0e402fa5d59a8deada34328c2183ab1" translate="yes" xml:space="preserve">
          <source>String conversion functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8c67bee324dda8862ee44968e54400194cc2d63" translate="yes" xml:space="preserve">
          <source>String literals are delimited by &quot; (double quote) characters. The two double quotes enclose a sequence of either characters different from &quot; and \, or escape sequences from the table given above for character literals, or a Unicode character escape sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c7906868ba95400fc8a6d36abebe6392b45e269" translate="yes" xml:space="preserve">
          <source>String matching and searching</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="766f45c1227c8c7d13e31b3c8218c7c441dc99b1" translate="yes" xml:space="preserve">
          <source>String operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d5d12fe85ff3629c70f06fe2ccba98f2ef750ad" translate="yes" xml:space="preserve">
          <source>String operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e7ccab3bf9ed59fa3897eaea798c56c7684cd59" translate="yes" xml:space="preserve">
          <source>String operations. This module is intended to be used through &lt;a href=&quot;stdlabels&quot;&gt;&lt;code&gt;StdLabels&lt;/code&gt;&lt;/a&gt; which replaces &lt;a href=&quot;array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bytes&quot;&gt;&lt;code&gt;Bytes&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; with their labeled counterparts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dd53d6d05f395fe64d03b9c25a5955171c3d33f" translate="yes" xml:space="preserve">
          <source>String tags</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="398d9ddb73ee4947a6d92a53a3b99ed8de605451" translate="yes" xml:space="preserve">
          <source>String values are finite sequences of characters. The current implementation supports strings containing up to 2&lt;sup&gt;24&lt;/sup&gt; &amp;minus; 5 characters (16777211 characters); on 64-bit platforms, the limit is 2&lt;sup&gt;57&lt;/sup&gt; &amp;minus; 9.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34a998adbb8ec8935e29af4fede0169191c33176" translate="yes" xml:space="preserve">
          <source>StringLabels</source>
          <target state="translated">StringLabels</target>
        </trans-unit>
        <trans-unit id="f9ce9e410646789b1991a03fbd23ed1074dfa4df" translate="yes" xml:space="preserve">
          <source>String_tag</source>
          <target state="translated">String_tag</target>
        </trans-unit>
        <trans-unit id="2d498b782702d956bea922cd280afa2515d69410" translate="yes" xml:space="preserve">
          <source>String_val(v) returns a pointer to the first byte of the string v, with type char * or, when OCaml is configured with -force-safe-string, with type const char *. This pointer is a valid C string: there is a null byte after the last byte in the string. However, OCaml strings can contain embedded null bytes, which will confuse the usual C functions over strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="4783a53435e04475242288debdaae1f5d02699bf" translate="yes" xml:space="preserve">
          <source>Strings.</source>
          <target state="translated">Strings.</target>
        </trans-unit>
        <trans-unit id="060ca5b23f65b0299c216dd4e8511069f47054f4" translate="yes" xml:space="preserve">
          <source>Strip 8th bit on input characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c0e13fdadda30bb92194b7ff31353209f1c6453" translate="yes" xml:space="preserve">
          <source>Structural equality test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1420a8bfe553843800a5e0eeda6eeea10bcce063" translate="yes" xml:space="preserve">
          <source>Structural inequality test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="964f4aa676065898b1577b34f94afc2774c1ff8d" translate="yes" xml:space="preserve">
          <source>Structural ordering functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba988a59552bfb50a703210d543593242c424d01" translate="yes" xml:space="preserve">
          <source>Structural ordering functions. These functions coincide with the usual orderings over integers, characters, strings, byte sequences and floating-point numbers, and extend them to a total ordering over all types. The ordering is compatible with &lt;code&gt;(&amp;nbsp;=&amp;nbsp;)&lt;/code&gt;. As in the case of &lt;code&gt;(&amp;nbsp;=&amp;nbsp;)&lt;/code&gt;, mutable structures are compared by contents. Comparison between functional values raises &lt;code&gt;Invalid_argument&lt;/code&gt;. Comparison between cyclic structures may not terminate. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa1a6ce691e6d5ffdcd5ca0d0bf720c77435180e" translate="yes" xml:space="preserve">
          <source>Structure of entries in the &lt;code&gt;groups&lt;/code&gt; database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="598293f4d4d38fb64e25a27801c5bb777aed096f" translate="yes" xml:space="preserve">
          <source>Structure of entries in the &lt;code&gt;hosts&lt;/code&gt; database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7118c10fc2f1d94d9826bee980fe8f7908c0e0c" translate="yes" xml:space="preserve">
          <source>Structure of entries in the &lt;code&gt;passwd&lt;/code&gt; database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abf82e0dcc97048077ad807e874664a09c91e309" translate="yes" xml:space="preserve">
          <source>Structure of entries in the &lt;code&gt;protocols&lt;/code&gt; database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6c3d4928c346aafd5529fad82c13ccca99e8e53" translate="yes" xml:space="preserve">
          <source>Structure of entries in the &lt;code&gt;services&lt;/code&gt; database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2e5835f238715991fb675b2b1d62d25b388199e" translate="yes" xml:space="preserve">
          <source>Structures struct &amp;hellip; end are collections of definitions for value names, type names, exceptions, module names and module type names. The definitions are evaluated in the order in which they appear in the structure. The scopes of the bindings performed by the definitions extend to the end of the structure. As a consequence, a definition may refer to names bound by earlier definitions in the same structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5b58ce4dec6fe8562096a10da3109ac06c55815" translate="yes" xml:space="preserve">
          <source>Subtraction</source>
          <target state="translated">Subtraction</target>
        </trans-unit>
        <trans-unit id="85e16c85547da9b7ef56410541850d43ba4b72ba" translate="yes" xml:space="preserve">
          <source>Subtraction.</source>
          <target state="translated">Subtraction.</target>
        </trans-unit>
        <trans-unit id="f23d83765c27480ace90dc29b354fcb3af5074ca" translate="yes" xml:space="preserve">
          <source>Subtyping is never implicit. There are, however, two ways to perform subtyping. The most general construction is fully explicit: both the domain and the codomain of the type coercion must be given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="267236f12d087c344c732b17967129639c89c2dd" translate="yes" xml:space="preserve">
          <source>Successor.</source>
          <target state="translated">Successor.</target>
        </trans-unit>
        <trans-unit id="695eff1526e154751f93eceb9ecae7ae62843717" translate="yes" xml:space="preserve">
          <source>Successor. &lt;code&gt;Int32.succ&amp;nbsp;x&lt;/code&gt; is &lt;code&gt;Int32.add&amp;nbsp;x&amp;nbsp;Int32.one&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a88899200e53819e4fca75e68b1f2d7ef4f59f99" translate="yes" xml:space="preserve">
          <source>Successor. &lt;code&gt;Int64.succ&amp;nbsp;x&lt;/code&gt; is &lt;code&gt;Int64.add&amp;nbsp;x&amp;nbsp;Int64.one&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a33602394a98e9f181e6510ea20dbadc6f37f28" translate="yes" xml:space="preserve">
          <source>Successor. &lt;code&gt;Nativeint.succ&amp;nbsp;x&lt;/code&gt; is &lt;code&gt;Nativeint.add&amp;nbsp;x&amp;nbsp;Nativeint.one&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b03e8df028a515393350967ae4387f5ffddb3921" translate="yes" xml:space="preserve">
          <source>Such abbreviations may be used alone,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9a9a4018c6e87434fce0fcbcb6811297262044d" translate="yes" xml:space="preserve">
          <source>Such annotations of the form name: are called &lt;em&gt;labels&lt;/em&gt;. They are meant to document the code, allow more checking, and give more flexibility to function application. You can give such names to arguments in your programs, by prefixing them with a tilde ~.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afe84014593353fc3502a2dfb59069e9aa563fb9" translate="yes" xml:space="preserve">
          <source>Such comments can take three forms: &lt;em&gt;floating comments&lt;/em&gt;, &lt;em&gt;item comments&lt;/em&gt; and &lt;em&gt;label comments&lt;/em&gt;. Any comment starting with ** which does not match one of these forms will cause the compiler to emit warning 50.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25da4ed1a780e343dd3f4f8e9110f06bf0afad4e" translate="yes" xml:space="preserve">
          <source>Such conjunctive constraints may be unsatisfiable. In such a case the corresponding tag may not be used in a value of this type. This does not mean that the whole type is not valid: one can still use other available tags. Conjunctive constraints are mainly intended as output from the type checker. When they are used in source programs, unsolvable constraints may cause early failures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="608e778255c58bb721e1518cfabc05ef86956e7e" translate="yes" xml:space="preserve">
          <source>Such specifications are also inferred. Namely, when P is a path satisfying the above constraints,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20dbe04d5924d91567646631274eb2f545fc830d" translate="yes" xml:space="preserve">
          <source>Support libraries for the C part (-llib).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="345aca003e713e405c83d4690e078d5d7eeef4ce" translate="yes" xml:space="preserve">
          <source>Supported layouts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e58a2db5e9aa8c332609520b8b74074728fd429c" translate="yes" xml:space="preserve">
          <source>Suppress header in generated documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de50b1b14218cb87a2945d6e8e68eda23b7643ee" translate="yes" xml:space="preserve">
          <source>Suppress trailer in generated documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b699c4e85571d84428b248779bbe8ae1bbcbfbf" translate="yes" xml:space="preserve">
          <source>Suspend or restart reception or transmission of data on the given file descriptor, depending on the second argument: &lt;code&gt;TCOOFF&lt;/code&gt; suspends output, &lt;code&gt;TCOON&lt;/code&gt; restarts output, &lt;code&gt;TCIOFF&lt;/code&gt; transmits a STOP character to suspend input, and &lt;code&gt;TCION&lt;/code&gt; transmits a START character to restart input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f79bf2cca20cb87f53d54a2eae520b086d8ef01" translate="yes" xml:space="preserve">
          <source>Suspend the execution of the calling thread until at least one character or EOF is available for reading (&lt;code&gt;wait_read&lt;/code&gt;) or one character can be written without blocking (&lt;code&gt;wait_write&lt;/code&gt;) on the given Unix file descriptor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9e7e7483847182bf81440a5b48041aad821bf57" translate="yes" xml:space="preserve">
          <source>Suspend the execution of the calling thread until at least one character or EOF is available for reading (&lt;code&gt;wait_read&lt;/code&gt;) or one character can be written without blocking (&lt;code&gt;wait_write&lt;/code&gt;) on the given Unix file descriptor. Wait for at most the amount of time given as second argument (in seconds). Return &lt;code&gt;true&lt;/code&gt; if the file descriptor is ready for input/output and &lt;code&gt;false&lt;/code&gt; if the timeout expired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8346165cfb7a86989d05db06110a6d5d23ba4188" translate="yes" xml:space="preserve">
          <source>Suspend the execution of the calling thread until at least one character or EOF is available for reading (&lt;code&gt;wait_timed_read&lt;/code&gt;) or one character can be written without blocking (&lt;code&gt;wait_timed_write&lt;/code&gt;) on the given Unix file descriptor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90e544161b3e1ba0c206678d222617b4a3f53207" translate="yes" xml:space="preserve">
          <source>Suspend the execution of the calling thread until at least one character or EOF is available for reading (&lt;code&gt;wait_timed_read&lt;/code&gt;) or one character can be written without blocking (&lt;code&gt;wait_timed_write&lt;/code&gt;) on the given Unix file descriptor. Wait for at most the amount of time given as second argument (in seconds). Return &lt;code&gt;true&lt;/code&gt; if the file descriptor is ready for input/output and &lt;code&gt;false&lt;/code&gt; if the timeout expired. The same functionality can be achieved with &lt;a href=&quot;unix#VALselect&quot;&gt;&lt;code&gt;Unix.select&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd698dfe06d0932557c1eb650583aff1c0a8f274" translate="yes" xml:space="preserve">
          <source>Suspend the execution of the calling thread until input/output becomes possible on the given Unix file descriptors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89b43cd2f521875a54a83bde786aa4892b785359" translate="yes" xml:space="preserve">
          <source>Suspend the execution of the calling thread until input/output becomes possible on the given Unix file descriptors. The arguments and results have the same meaning as for &lt;code&gt;Unix.select&lt;/code&gt;. This function is not implemented yet under Win32.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5ee688ede72fd80011cbf7bc6580d8f7239f6ae" translate="yes" xml:space="preserve">
          <source>Suspending threads</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6174b4bb3312bb6b8d643916247f5c5c92a0cf44" translate="yes" xml:space="preserve">
          <source>Suspicious unused variable: unused variable that is bound with let or as, and doesn&amp;rsquo;t start with an underscore (_) character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11e58b2b3353eee96248693f8d563d3b5cd65b17" translate="yes" xml:space="preserve">
          <source>Suspicious-looking end-of-comment mark.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddf970710a96e309a4df7c47f666103b40de5ebd" translate="yes" xml:space="preserve">
          <source>Suspicious-looking start-of-comment mark.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f84ef531f9db996694ad09a8fdddbca1440577e" translate="yes" xml:space="preserve">
          <source>Symbol</source>
          <target state="translated">Symbol</target>
        </trans-unit>
        <trans-unit id="cb92d9d71dc582fcaac304377564d4e993a5d6c9" translate="yes" xml:space="preserve">
          <source>Symbol binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f08528b34287dbeb205e28df6f893eefe4bb6b5" translate="yes" xml:space="preserve">
          <source>Symbolic link</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1af7d6c34ea3d7825f1508a7baf71357f217a173" translate="yes" xml:space="preserve">
          <source>Symbolic links</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bf49d12b0b857b45245352554b4248820e1c127" translate="yes" xml:space="preserve">
          <source>Symbolic pretty-printing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fcc57bd9e40ddf977219a1819544a0cbcd1da68" translate="yes" xml:space="preserve">
          <source>Symbolic pretty-printing is pretty-printing using a symbolic formatter, i.e. a formatter that outputs symbolic pretty-printing items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c30177fee17f9de0bfd94e899114fd091110383c" translate="yes" xml:space="preserve">
          <source>Symbols from the class &lt;a href=&quot;lex#infix-symbol&quot;&gt;infix-symbol&lt;/a&gt;, as well as the keywords *, +, -, -., =, !=, &amp;lt;, &amp;gt;, or, ||, &amp;amp;, &amp;amp;&amp;amp;, :=, mod, land, lor, lxor, lsl, lsr, and asr can appear in infix position (between two expressions). Symbols from the class &lt;a href=&quot;lex#prefix-symbol&quot;&gt;prefix-symbol&lt;/a&gt;, as well as the keywords - and -. can appear in prefix position (in front of an expression).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b8e8468d047790eb587f1fdac4b8b2c2a97f950" translate="yes" xml:space="preserve">
          <source>Syntactically, building or matching constructors with such an inline record argument is similar to working with a unary constructor whose unique argument is a declared record type. A pattern can bind the inline record as a pseudo-value, but the record cannot escape the scope of the binding and can only be used with the dot-notation to extract or modify fields or to build new constructor values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7242fc4d74104da137f0225f7f32f3f67b1f6f68" translate="yes" xml:space="preserve">
          <source>Syntax of command lines: A keyword is a character string starting with a &lt;code&gt;-&lt;/code&gt;. An option is a keyword alone or followed by an argument. The types of keywords are: &lt;code&gt;Unit&lt;/code&gt;, &lt;code&gt;Bool&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Clear&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Set_string&lt;/code&gt;, &lt;code&gt;Int&lt;/code&gt;, &lt;code&gt;Set_int&lt;/code&gt;, &lt;code&gt;Float&lt;/code&gt;, &lt;code&gt;Set_float&lt;/code&gt;, &lt;code&gt;Tuple&lt;/code&gt;, &lt;code&gt;Symbol&lt;/code&gt;, &lt;code&gt;Rest&lt;/code&gt;, &lt;code&gt;Rest_all&lt;/code&gt; and &lt;code&gt;Expand&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92a7a4f198e3ad53204452742e2bcd85c8b76c8e" translate="yes" xml:space="preserve">
          <source>Syntax of command lines: A keyword is a character string starting with a &lt;code&gt;-&lt;/code&gt;. An option is a keyword alone or followed by an argument. The types of keywords are: &lt;code&gt;Unit&lt;/code&gt;, &lt;code&gt;Bool&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Clear&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Set_string&lt;/code&gt;, &lt;code&gt;Int&lt;/code&gt;, &lt;code&gt;Set_int&lt;/code&gt;, &lt;code&gt;Float&lt;/code&gt;, &lt;code&gt;Set_float&lt;/code&gt;, &lt;code&gt;Tuple&lt;/code&gt;, &lt;code&gt;Symbol&lt;/code&gt;, and &lt;code&gt;Rest&lt;/code&gt;. &lt;code&gt;Unit&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;Clear&lt;/code&gt; keywords take no argument. A &lt;code&gt;Rest&lt;/code&gt; keyword takes the remaining of the command line as arguments. Every other keyword takes the following word on the command line as argument. For compatibility with GNU getopt_long, &lt;code&gt;keyword=arg&lt;/code&gt; is also allowed. Arguments not preceded by a keyword are called anonymous arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eea5f6535cf1464538bf913c29432e06b44c8a00" translate="yes" xml:space="preserve">
          <source>Sys</source>
          <target state="translated">Sys</target>
        </trans-unit>
        <trans-unit id="8f7a8d4494a0d458d18524d29c3ede9485be05c9" translate="yes" xml:space="preserve">
          <source>Sys.argv is an array of strings containing the command-line parameters. Sys.argv.(1) is thus the first command-line parameter. The program above is compiled and executed with the following shell commands:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77b1ff317375845ec33475f1b5fb67e6cbb973f9" translate="yes" xml:space="preserve">
          <source>System interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="475b7fafddd719ea508a449badf45b0789ac88b8" translate="yes" xml:space="preserve">
          <source>System threads. This implementation builds on the OS-provided threads facilities: POSIX 1003.1c threads for Unix, and Win32 threads for Windows. When available, system threads support both bytecode and native-code programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99901e02a798f32cd5219f56e51ca3215b2961b1" translate="yes" xml:space="preserve">
          <source>System time for the children processes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34a877dc56d7b6f22f1f4507a6f98d13c327981d" translate="yes" xml:space="preserve">
          <source>System time for the process</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2c53d66948214258a26ca9ca845d7ac0c17f8e7" translate="yes" xml:space="preserve">
          <source>T</source>
          <target state="translated">T</target>
        </trans-unit>
        <trans-unit id="b3db3af9a0e0243f28ed20fcc3b1d5d1faaafbb6" translate="yes" xml:space="preserve">
          <source>TERM</source>
          <target state="translated">TERM</target>
        </trans-unit>
        <trans-unit id="c068ca8b042bac0232c1a1485f2405cfa98b7a00" translate="yes" xml:space="preserve">
          <source>Table cache</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88d5168e6958719b1f51075705e987c63433b18e" translate="yes" xml:space="preserve">
          <source>Tabulation boxes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="982963c1c41cbed8cab073724749592fe35c532b" translate="yes" xml:space="preserve">
          <source>Tag</source>
          <target state="translated">Tag</target>
        </trans-unit>
        <trans-unit id="70ebce0319098abe29a21e0fc7bf392fb3792b10" translate="yes" xml:space="preserve">
          <source>Tag specific operations occur any time a tag is opened or closed, At each occurrence, two kinds of operations are performed &lt;em&gt;tag-marking&lt;/em&gt; and &lt;em&gt;tag-printing&lt;/em&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21049d0d0e09867c94c7bfdcd7af965832440243" translate="yes" xml:space="preserve">
          <source>Tag-marking a semantic tag means calling the formatter specific function &lt;code&gt;mark_open_stag&lt;/code&gt; (resp. &lt;code&gt;mark_close_stag&lt;/code&gt;) with the name of the tag as argument: that tag-marking function can then return the 'tag-opening marker' (resp. `tag-closing marker') for direct output into the output device of the formatter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0850e7bae659968c87fcd011c8098d48caf5ca1" translate="yes" xml:space="preserve">
          <source>Tag-marking and tag-printing functions are user definable and can be set by calling &lt;a href=&quot;format#VALset_formatter_stag_functions&quot;&gt;&lt;code&gt;Format.set_formatter_stag_functions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f087082b531d3d70af061b2f9983efc04fdab93a" translate="yes" xml:space="preserve">
          <source>Tag-printing a semantic tag means calling the formatter specific function &lt;code&gt;print_open_stag&lt;/code&gt; (resp. &lt;code&gt;print_close_stag&lt;/code&gt;) with the name of the tag as argument: that tag-printing function can then print any regular material to the formatter (so that this material is enqueued as usual in the formatter queue for further line splitting computation).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d968d48d29a395bb82a38da27ee9373279edc48" translate="yes" xml:space="preserve">
          <source>Tag_val(v) returns the tag of the block v.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69680e9274247feaf41570c80b33d43c4f2d8bcd" translate="yes" xml:space="preserve">
          <source>Take one of the symbols as argument and call the function with the symbol</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d6b053ba3ae57bbab0f9ae23dd3906806ecb54b" translate="yes" xml:space="preserve">
          <source>Take several arguments according to the spec list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10762317d708b72b78e81e7071b82e94c42de1fc" translate="yes" xml:space="preserve">
          <source>Tangent.</source>
          <target state="translated">Tangent.</target>
        </trans-unit>
        <trans-unit id="780ae66c320e72eed30e1ed6d7739b9ecffb29da" translate="yes" xml:space="preserve">
          <source>Tangent. Argument is in radians.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8038dd5c0175f8f3d04e597ad2fbb9eac4f72a1c" translate="yes" xml:space="preserve">
          <source>Target ratio of floating garbage to major heap size for out-of-heap memory held by custom values located in the major heap. The GC speed is adjusted to try to use this much memory for dead values that are not yet collected. Expressed as a percentage of major heap size. The default value keeps the out-of-heap floating garbage about the same size as the in-heap overhead. Note: this only applies to values allocated with &lt;code&gt;caml_alloc_custom_mem&lt;/code&gt; (e.g. bigarrays). Default: 44.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf716ff6c41584311aebda3a608e1a8001afd716" translate="yes" xml:space="preserve">
          <source>Tell the debugger it is executed under Emacs. (See section &amp;zwj;&lt;a href=&quot;#s%3Ainf-debugger&quot;&gt;16.10&lt;/a&gt; for information on how to run the debugger under Emacs.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fe258cc46692204a632aee373f4075f030d57a7" translate="yes" xml:space="preserve">
          <source>Tell the debugger it is executed under Emacs. (See section &lt;a href=&quot;#s%3Ainf-debugger&quot;&gt;17.10&lt;/a&gt; for information on how to run the debugger under Emacs.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19b9145b33f4838c5f3973e7a6ea5d0f05c03b03" translate="yes" xml:space="preserve">
          <source>Tell whether the lexer buffer keeps track of position fields &lt;code&gt;lex_curr_p&lt;/code&gt; / &lt;code&gt;lex_start_p&lt;/code&gt;, as determined by the corresponding optional argument for functions that create lexer buffers (whose default value is &lt;code&gt;true&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7cd37004c27ae67bd613fe7aaf8dda4c2d384cf" translate="yes" xml:space="preserve">
          <source>Terminal interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df7e4a1d29e38609effa51863fd181383dbf7780" translate="yes" xml:space="preserve">
          <source>Terminal read from background process</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69f382ea876bbdcbdd4d90e629da7780e4617313" translate="yes" xml:space="preserve">
          <source>Terminal write from background process</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4813943164d0564fe70ad323f19653347b352115" translate="yes" xml:space="preserve">
          <source>Terminate prematurely the currently executing thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56b1260afe50cb577a901efc314311be666089c4" translate="yes" xml:space="preserve">
          <source>Terminate prematurely the thread whose handle is given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1edd80b3bab286216daf4e49c9f5cc789375f130" translate="yes" xml:space="preserve">
          <source>Terminate the calling process immediately, returning the given status code to the operating system: usually 0 to indicate no errors, and a small positive integer to indicate failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbcaba753b832dde4b1cb373e039bf131ee31f81" translate="yes" xml:space="preserve">
          <source>Terminate the calling process immediately, returning the given status code to the operating system: usually 0 to indicate no errors, and a small positive integer to indicate failure. Unlike &lt;a href=&quot;stdlib#VALexit&quot;&gt;&lt;code&gt;exit&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;unix#VAL_exit&quot;&gt;&lt;code&gt;Unix._exit&lt;/code&gt;&lt;/a&gt; performs no finalization whatsoever: functions registered with &lt;a href=&quot;stdlib#VALat_exit&quot;&gt;&lt;code&gt;at_exit&lt;/code&gt;&lt;/a&gt; are not called, input/output channels are not flushed, and the C run-time system is not finalized either.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26070bd7d4995159490297bd3d133957b3f011a9" translate="yes" xml:space="preserve">
          <source>Terminate the process, returning the given status code to the operating system: usually 0 to indicate no errors, and a small positive integer to indicate failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0574c95a3a93d600e83a6f17eb926a568c0f9796" translate="yes" xml:space="preserve">
          <source>Terminate the process, returning the given status code to the operating system: usually 0 to indicate no errors, and a small positive integer to indicate failure. All open output channels are flushed with &lt;code&gt;flush_all&lt;/code&gt;. An implicit &lt;code&gt;exit&amp;nbsp;0&lt;/code&gt; is performed each time a program terminates normally. An implicit &lt;code&gt;exit&amp;nbsp;2&lt;/code&gt; is performed if the program terminates early because of an uncaught exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ee85218866a19e0d9f6c52c176e4eaf9d0877b2" translate="yes" xml:space="preserve">
          <source>Termination</source>
          <target state="translated">Termination</target>
        </trans-unit>
        <trans-unit id="158a94f8a2ff46fde496827d38e93851db51f5cc" translate="yes" xml:space="preserve">
          <source>Termination (cannot be ignored)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb7a1f1e99b2c211113bd77cc5e7ef277a13ed74" translate="yes" xml:space="preserve">
          <source>Test &amp;ldquo;greater than or equal&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf55a085e33342b3081a9dd990d9070f808b5872" translate="yes" xml:space="preserve">
          <source>Test &amp;ldquo;greater than&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c0f5c5dfaba7d5a348d0be90ebda99ec96925bd" translate="yes" xml:space="preserve">
          <source>Test &amp;ldquo;less than or equal&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9023e669869c2a8e4df262bd37b076a1baa1f732" translate="yes" xml:space="preserve">
          <source>Test &amp;ldquo;less than&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4da88b01def945bdf24685deea788a8bc6d1da26" translate="yes" xml:space="preserve">
          <source>Test a region for other process locks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1787fedd7d2ced2ae48a3c3ae605449bb9a29103" translate="yes" xml:space="preserve">
          <source>Test if a file with the given name exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5d1af12b9f30270fd2ed2ad3dee29830b903b74" translate="yes" xml:space="preserve">
          <source>Test if two sets are disjoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1ac6c65bc9783f51306843b3f179afc02bc939b" translate="yes" xml:space="preserve">
          <source>Test whether a map is empty or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9521be20f61e3370ee61a403fa6f607a9a6420ea" translate="yes" xml:space="preserve">
          <source>Test whether a set is empty or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="862bb20b2924b0e1bad9177d10a2c297215a311c" translate="yes" xml:space="preserve">
          <source>Tests if the maximum number of pretty-printing boxes allowed have already been opened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4721ae7197912536ec105c3ffe10fe5fe1d70fa" translate="yes" xml:space="preserve">
          <source>That is, the fun expression above evaluates to a curried function with n arguments: after applying this function n times to the values v&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; v&lt;sub&gt;n&lt;/sub&gt;, the values will be matched in parallel against the patterns &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;. If the matching succeeds, the function returns the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; in an environment enriched by the bindings performed during the matchings. If the matching fails, the exception Match_failure is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75556997ae93b7cf1b53d4c2255859edf696d5cd" translate="yes" xml:space="preserve">
          <source>That is, to define a new generator, one must implement a module with the expected signature, and with the given generator class, providing the generate method as entry point to make the generator generates documentation for a given list of modules &amp;zwj;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb5dc7fe2f26372eda5226bac4a48e313d4e2b62" translate="yes" xml:space="preserve">
          <source>That is, to define a new generator, one must implement a module with the expected signature, and with the given generator class, providing the generate method as entry point to make the generator generates documentation for a given list of modules :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfe811707b86c6cce7b1af403f14e7f36cdc5d76" translate="yes" xml:space="preserve">
          <source>The &quot;release&quot; operation of a binary semaphore sets its value to 1, and &quot;acquire&quot; waits until the value is 1 and sets it to 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ed38f27c94cab8c8d12304ae06126526d04b8bb" translate="yes" xml:space="preserve">
          <source>The (type&lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;) syntax construction by itself does not make polymorphic the type variable it introduces, but it can be combined with explicit polymorphic annotations where needed. The above rule is provided as syntactic sugar to make this easier:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4991a041e774dadbe4b581939be63f5a7cbe4ea" translate="yes" xml:space="preserve">
          <source>The -no-stop option to ocamldoc causes the Stop special comments to be ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3147fca5c37d9a1563cc013c628673b530b03e57" translate="yes" xml:space="preserve">
          <source>The -opaque option, available since 4.04, disables cross-module optimization information for the currently compiled unit. When compiling .mli interface, using -opaque marks the compiled .cmi interface so that subsequent compilations of modules that depend on it will not rely on the corresponding .cmx file, nor warn if it is absent. When the native compiler compiles a .ml implementation, using -opaque generates a .cmx that does not contain any cross-module optimization information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="564904d19df6fc8011ad3d2bee2ea1a4e77ad2e7" translate="yes" xml:space="preserve">
          <source>The -output-obj option can also be used to obtain the C source file. More interestingly, the same option can also produce directly a shared library (.so file, .dll under Windows) that contains the OCaml code, the OCaml runtime system and any other static C code given to ocamlc (.o, .a, respectively, .obj, .lib). This use of -output-obj is very similar to a normal linking step, but instead of producing a main program that automatically runs the OCaml code, it produces a shared library that can run the OCaml code on demand. The three possible behaviors of -output-obj are selected according to the extension of the resulting file (given with -o).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b36f21e3b344b1468a19dcfe1a7ba5421f00dae" translate="yes" xml:space="preserve">
          <source>The -unbox-closures-factor command line flag, which takes an integer, may be used to adjust the point at which a function is deemed large enough to be ineligible for duplication. The benefit of duplication is scaled by the integer before being evaluated against the size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2209f3894b8163766592d29f0ebe68de13e2bfb" translate="yes" xml:space="preserve">
          <source>The .cmi and .cmo files produced by the compiler have the same base name as the source file. Hence, the compiled files always have their base name equal (modulo capitalization of the first letter) to the name of the module they describe (for .cmi files) or implement (for .cmo files).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b721260b32a59d156249128e83aba8efd5e1aba3" translate="yes" xml:space="preserve">
          <source>The .cmx object files being combined must have been compiled with the appropriate -for-pack option. In the example above, A.cmx, B.cmx and C.cmx must have been compiled with ocamlopt -for-pack P.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8d1d5867cdb0bfd731826d0c29b478c2ae3ed20" translate="yes" xml:space="preserve">
          <source>The 32-bit code generator for Intel/AMD x86 processors (i386 architecture) supports the following additional option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19cf8b2f632836f4f34c4d1b723f6f2c4408241e" translate="yes" xml:space="preserve">
          <source>The 32-bit integer -1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25bfbe3425f7612c84c4a60433757b0cd2caa725" translate="yes" xml:space="preserve">
          <source>The 32-bit integer 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adf5ef41fc3f6cfaf4d8f1db7abf1ec88c03da49" translate="yes" xml:space="preserve">
          <source>The 32-bit integer 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77b20c5219874b842e364037b79509517abba8bd" translate="yes" xml:space="preserve">
          <source>The 64-bit code generator for Intel/AMD x86 processors (amd64 architecture) supports the following additional options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="006eed8987b86bde9c7f054166d4c4843fab6c03" translate="yes" xml:space="preserve">
          <source>The 64-bit integer -1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="157479d5f01ffa68d3fe29e3a78c6d437b79bcf0" translate="yes" xml:space="preserve">
          <source>The 64-bit integer 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="629c9977446445c9cf7c1aa59f2924bbe702fd82" translate="yes" xml:space="preserve">
          <source>The 64-bit integer 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b95251b3f2b1a3e28a4b746eb2d6fd549aedfc0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt; syntactic class appearing in the (module&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;) type expression and in the annotated forms represents a subset of module types. This subset consists of named module types with optional constraints of a limited form: only non-parametrized types can be specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6682753740053ec4013bd76f06934bf2221ce480" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt; should describe when the element was deprecated, what to use as a replacement, and possibly the reason for deprecation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fcbebcee75dae7d24519bf68c433e5e177f48a5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;morelabels.set.make&quot;&gt;&lt;code&gt;MoreLabels.Set.Make&lt;/code&gt;&lt;/a&gt; functor constructs implementations for any type, given a &lt;code&gt;compare&lt;/code&gt; function. For instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde17ed2d9a66d67e67d6fe2b53d455fb37fc839" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;set.make&quot;&gt;&lt;code&gt;Set.Make&lt;/code&gt;&lt;/a&gt; functor constructs implementations for any type, given a &lt;code&gt;compare&lt;/code&gt; function. For instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4ed2561f30b1f4e9552cc537f7755aeeba34c0b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;0u&lt;/code&gt; prefix reads the input as an unsigned integer in the range &lt;code&gt;[0,&amp;nbsp;2*Int32.max_int+1]&lt;/code&gt;. If the input exceeds &lt;a href=&quot;int32#VALmax_int&quot;&gt;&lt;code&gt;Int32.max_int&lt;/code&gt;&lt;/a&gt; it is converted to the signed integer &lt;code&gt;Int32.min_int&amp;nbsp;+&amp;nbsp;input&amp;nbsp;-&amp;nbsp;Int32.max_int&amp;nbsp;-&amp;nbsp;1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23dffe6eb51ba2abaa4cfa566ea1b02078814e57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;0u&lt;/code&gt; prefix reads the input as an unsigned integer in the range &lt;code&gt;[0,&amp;nbsp;2*Int64.max_int+1]&lt;/code&gt;. If the input exceeds &lt;a href=&quot;int64#VALmax_int&quot;&gt;&lt;code&gt;Int64.max_int&lt;/code&gt;&lt;/a&gt; it is converted to the signed integer &lt;code&gt;Int64.min_int&amp;nbsp;+&amp;nbsp;input&amp;nbsp;-&amp;nbsp;Int64.max_int&amp;nbsp;-&amp;nbsp;1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bdf559646ed66e4c76c9311859fb36ebd722036" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;0u&lt;/code&gt; prefix reads the input as an unsigned integer in the range &lt;code&gt;[0,&amp;nbsp;2*Nativeint.max_int+1]&lt;/code&gt;. If the input exceeds &lt;a href=&quot;nativeint#VALmax_int&quot;&gt;&lt;code&gt;Nativeint.max_int&lt;/code&gt;&lt;/a&gt; it is converted to the signed integer &lt;code&gt;Int64.min_int&amp;nbsp;+&amp;nbsp;input&amp;nbsp;-&amp;nbsp;Nativeint.max_int&amp;nbsp;-&amp;nbsp;1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d37cd54b36382c9e5496e2092f5aaa8dc45ad01" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;0u&lt;/code&gt; prefix reads the input as an unsigned integer in the range &lt;code&gt;[0,&amp;nbsp;2*max_int+1]&lt;/code&gt;. If the input exceeds &lt;a href=&quot;stdlib#VALmax_int&quot;&gt;&lt;code&gt;max_int&lt;/code&gt;&lt;/a&gt; it is converted to the signed integer &lt;code&gt;min_int&amp;nbsp;+&amp;nbsp;input&amp;nbsp;-&amp;nbsp;max_int&amp;nbsp;-&amp;nbsp;1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61b166f6086faf0c742754df16fab62941896c59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Exit&lt;/code&gt; exception is not raised by any library function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="618dcafc239b4a1cd930e5a52c4ba8ab644cc7e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Exit&lt;/code&gt; exception is not raised by any library function. It is provided for use in your programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54bcc8ec2f507902da16600415bbcb8e20ed4f95" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;F_LOCK&lt;/code&gt; and &lt;code&gt;F_TLOCK&lt;/code&gt; commands attempts to put a write lock on the specified region. The &lt;code&gt;F_RLOCK&lt;/code&gt; and &lt;code&gt;F_TRLOCK&lt;/code&gt; commands attempts to put a read lock on the specified region. If one or several locks put by another process prevent the current process from acquiring the lock, &lt;code&gt;F_LOCK&lt;/code&gt; and &lt;code&gt;F_RLOCK&lt;/code&gt; block until these locks are removed, while &lt;code&gt;F_TLOCK&lt;/code&gt; and &lt;code&gt;F_TRLOCK&lt;/code&gt; fail immediately with an exception. The &lt;code&gt;F_ULOCK&lt;/code&gt; removes whatever locks the current process has on the specified region. Finally, the &lt;code&gt;F_TEST&lt;/code&gt; command tests whether a write lock can be acquired on the specified region, without actually putting a lock. It returns immediately if successful, or fails otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38136ee726cf908eb5522e7345bd976551936ebd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Format&lt;/code&gt; module is versatile enough to let you completely redefine the meaning of pretty-printing output: you may provide your own functions to define how to handle indentation, line splitting, and even printing of all the characters that have to be printed!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68315cad3ec5fa750806e2fcfa1b99271143dfe3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_&lt;/code&gt; (underscore) character can appear anywhere in the string and is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dcf95ffbbacb39e9db9049899df2d9baf6d087f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cloexec&lt;/code&gt; optional arguments and the &lt;code&gt;O_KEEPEXEC&lt;/code&gt; flag were introduced in OCaml 4.05. Earlier, the common practice was to create file descriptors in the default, ``keep-on-exec'' mode, then call &lt;code&gt;set_close_on_exec&lt;/code&gt; on those freshly-created file descriptors. This is not as safe as creating the file descriptor in ``close-on-exec'' mode because, in multithreaded programs, a window of vulnerability exists between the time when the file descriptor is created and the time &lt;code&gt;set_close_on_exec&lt;/code&gt; completes. If another thread spawns another program during this window, the descriptor will leak, as it is still in the ``keep-on-exec'' mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eb7c114770073f6910d08925899aa9381142883" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compare&lt;/code&gt; function can be used as the comparison function required by the &lt;a href=&quot;set.make&quot;&gt;&lt;code&gt;Set.Make&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;map.make&quot;&gt;&lt;code&gt;Map.Make&lt;/code&gt;&lt;/a&gt; functors, as well as the &lt;a href=&quot;list#VALsort&quot;&gt;&lt;code&gt;List.sort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;array#VALsort&quot;&gt;&lt;code&gt;Array.sort&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e2d6e8ecc1f534250d3b0fe9ad0f7fcb8f3fbb1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;equal&lt;/code&gt; relation must be able to work on a shallow copy of the values and give the same result as with the values themselves.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42475c29a84bb6547470710fd8e643615f2c721d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;f&lt;/code&gt; function can use all features of OCaml, including assignments that make the value reachable again. It can also loop forever (in this case, the other finalisation functions will not be called during the execution of f, unless it calls &lt;code&gt;finalise_release&lt;/code&gt;). It can call &lt;code&gt;finalise&lt;/code&gt; on &lt;code&gt;v&lt;/code&gt; or other values to register other functions or even itself. It can raise an exception; in this case the exception will interrupt whatever the program was doing when the function was called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b556f0336e223bedcd6066a8e647fbdbfaf3934e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flush&lt;/code&gt; function is called whenever the pretty-printer is flushed (via conversion &lt;code&gt;%!&lt;/code&gt;, or pretty-printing indications &lt;code&gt;@?&lt;/code&gt; or &lt;code&gt;@.&lt;/code&gt;, or using low level functions &lt;code&gt;print_flush&lt;/code&gt; or &lt;code&gt;print_newline&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27ca5eda4c43f08d46a2c695faa646d521db2882" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;out&lt;/code&gt; function performs all the pretty-printer string output. It is called with a string &lt;code&gt;s&lt;/code&gt;, a start position &lt;code&gt;p&lt;/code&gt;, and a number of characters &lt;code&gt;n&lt;/code&gt;; it is supposed to output characters &lt;code&gt;p&lt;/code&gt; to &lt;code&gt;p&amp;nbsp;+&amp;nbsp;n&amp;nbsp;-&amp;nbsp;1&lt;/code&gt; of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75d43060306ebfa6fa32ab493326575601269afa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;print_&lt;/code&gt; field of the record contains the tag-printing functions that are called at tag opening and tag closing time, to output regular material in the pretty-printer queue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="056af88ed3bcf5589ed5c7b7003c98a7067f4a6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;print_open_stag&lt;/code&gt; tag-printing function of the formatter is called with &lt;code&gt;t&lt;/code&gt; as argument; then the opening tag marker for &lt;code&gt;t&lt;/code&gt;, as given by &lt;code&gt;mark_open_stag&amp;nbsp;t&lt;/code&gt;, is written into the output device of the formatter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e08dda4298e3191068d142ddd263ae997f8088ec" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;eventlog_metadata&lt;/em&gt; file can be found at this path and copied in the same directory as the generated trace file. However, &lt;em&gt;babeltrace&lt;/em&gt; expects the file to be named metadata in order to process the trace. Thus, it will need to be renamed when copied to the trace&amp;rsquo;s directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f53775be5e375c4dc7ef58b639a6d408285df99f" translate="yes" xml:space="preserve">
          <source>The AMD64 code generator (64-bit versions of Intel Pentium and AMD Athlon) supports the following additional options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65568e29c592dc9019c9f674c81a29c684908ec4" translate="yes" xml:space="preserve">
          <source>The C code can then invoke OCaml functions using the callback mechanism (see section &amp;zwj;&lt;a href=&quot;#ss%3Ac-callbacks&quot;&gt;18.7.1&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb87a73c92ae01d9c7c4db3849eb48ff0818dc23" translate="yes" xml:space="preserve">
          <source>The C code can then invoke OCaml functions using the callback mechanism (see section &lt;a href=&quot;#ss%3Ac-callbacks&quot;&gt;20.7.1&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="876e3c62a7b0d3bf41a4b52452f9a2cbc0c89632" translate="yes" xml:space="preserve">
          <source>The C code can then recover the exception identifier using caml_named_value and pass it as first argument to the functions raise_constant, raise_with_arg, and raise_with_string (described in section &amp;zwj;&lt;a href=&quot;#ss%3Ac-exceptions&quot;&gt;18.4.5&lt;/a&gt;) to actually raise the exception. For example, here is a C function that raises the Error exception with the given argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e464c9797631ebce99ef6cccb7cb68c06035632" translate="yes" xml:space="preserve">
          <source>The C code can then recover the exception identifier using caml_named_value and pass it as first argument to the functions raise_constant, raise_with_arg, and raise_with_string (described in section &lt;a href=&quot;#ss%3Ac-exceptions&quot;&gt;20.4.5&lt;/a&gt;) to actually raise the exception. For example, here is a C function that raises the Error exception with the given argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa93c2abc45968f3784b93eb9dcd8bd6529c1ecd" translate="yes" xml:space="preserve">
          <source>The C part of the program must provide a main function, which will override the default main function provided by the OCaml runtime system. Execution will start in the user-defined main function just like for a regular C program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50e4f4eda019d6551e91347a8e71357c4a87e23b" translate="yes" xml:space="preserve">
          <source>The CAML macros use identifiers (local variables, type identifiers, structure tags) that start with caml__. Do not use any identifier starting with caml__ in your programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="947f7ca3d56e80606a767e9b12f1a9e600046008" translate="yes" xml:space="preserve">
          <source>The Flambda inlining heuristics, used whenever the compiler is configured for Flambda and -Oclassic was not specified, make inlining decisions at call sites. This helps in situations where the context is important. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d5b0d2b11b3ee57c6f9a2ae20c6f1a2b2492c1f" translate="yes" xml:space="preserve">
          <source>The Flambda mode is described in the next section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a8cbe3e5a223fda241e040fe66da36a6dedfca0" translate="yes" xml:space="preserve">
          <source>The Flambda optimisers classify expressions in order to determine whether an expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a55df8086c936ee6955c4d5f1e4e9c60c3a3b17" translate="yes" xml:space="preserve">
          <source>The Flambda optimisers provide a variety of command-line flags that may be used to control their behaviour. Detailed descriptions of each flag are given in the referenced sections. Those sections also describe any arguments which the particular flags take.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f41ece3d458792a5a112edf6fe3a0fc355449cf" translate="yes" xml:space="preserve">
          <source>The GADT type &lt;code&gt;'a&amp;nbsp;layout&lt;/code&gt; represents one of the two supported memory layouts: C-style or Fortran-style. Its constructors are re-exported as values below for backward-compatibility reasons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9592e7237389ee2174122cfd60652798cead6941" translate="yes" xml:space="preserve">
          <source>The GADT type &lt;code&gt;('a,&amp;nbsp;'b)&amp;nbsp;kind&lt;/code&gt; captures this association of an OCaml type &lt;code&gt;'a&lt;/code&gt; for values read or written in the Bigarray, and of an element kind &lt;code&gt;'b&lt;/code&gt; which represents the actual contents of the Bigarray. Its constructors list all possible associations of OCaml types with element kinds, and are re-exported below for backward-compatibility reasons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd7b721d0850765e0f33c133f4e389240cfc627b" translate="yes" xml:space="preserve">
          <source>The GC parameters are given as a &lt;code&gt;control&lt;/code&gt; record.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95efad48009e26c2e773fa9f3a23237febe8ef7a" translate="yes" xml:space="preserve">
          <source>The GC parameters are given as a &lt;code&gt;control&lt;/code&gt; record. Note that these parameters can also be initialised by setting the OCAMLRUNPARAM environment variable. See the documentation of &lt;code&gt;ocamlrun&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c85d7c1fb9f174f09ac7febf2cc5071806120427" translate="yes" xml:space="preserve">
          <source>The GC will call the finalisation functions in the order of deallocation. When several values become unreachable at the same time (i.e. during the same GC cycle), the finalisation functions will be called in the reverse order of the corresponding calls to &lt;code&gt;finalise&lt;/code&gt;. If &lt;code&gt;finalise&lt;/code&gt; is called in the same order as the values are allocated, that means each value is finalised before the values it depends upon. Of course, this becomes false if additional dependencies are introduced by assignments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7795741ff8b943ea1be2628f77110237f9e449f7" translate="yes" xml:space="preserve">
          <source>The HTML tags &amp;lt;b&amp;gt;..&amp;lt;/b&amp;gt;, &amp;lt;code&amp;gt;..&amp;lt;/code&amp;gt;, &amp;lt;i&amp;gt;..&amp;lt;/i&amp;gt;, &amp;lt;ul&amp;gt;..&amp;lt;/ul&amp;gt;, &amp;lt;ol&amp;gt;..&amp;lt;/ol&amp;gt;, &amp;lt;li&amp;gt;..&amp;lt;/li&amp;gt;, &amp;lt;center&amp;gt;..&amp;lt;/center&amp;gt; and &amp;lt;h[0-9]&amp;gt;..&amp;lt;/h[0-9]&amp;gt; can be used instead of, respectively, {b ..} , [..] , {i ..} , {ul ..} , {ol ..} , {li ..} , {C ..} and {[0-9] ..}.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0385ec9d501a25d53c3aad498dad447e84092fe" translate="yes" xml:space="preserve">
          <source>The IA32 code generator (Intel Pentium, AMD Athlon) supports the following additional option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d32d0bbbe468bebfac2e7c376f0e2c87a1ae0cea" translate="yes" xml:space="preserve">
          <source>The MD5 hash function is not cryptographically secure. Hence, this module should not be used for security-sensitive applications. More recent, stronger cryptographic primitives should be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f406da7037c42f4a4f464bf9db0658f383ecf08c" translate="yes" xml:space="preserve">
          <source>The OCaml Standard library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cd9888d4cc0302f8bc1d09fa4ef39df6a3ff2b8" translate="yes" xml:space="preserve">
          <source>The OCaml debugger has a simple on-line help system, which gives a brief description of each command and variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75b7f273467919c29f03470504af44cab3766154" translate="yes" xml:space="preserve">
          <source>The OCaml debugger is invoked by running the program ocamldebug with the name of the bytecode executable file as first argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13488dcd67078760c0511e807304bd3a788513ec" translate="yes" xml:space="preserve">
          <source>The OCaml debugger is started under Emacs by the command M-x camldebug, with argument the name of the executable file progname to debug. Communication with the debugger takes place in an Emacs buffer named *camldebug-progname*. The editing and history facilities of Shell mode are available for interacting with the debugger.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0701bb96dd9335c1a8b9cd5991613a9554bc96eb" translate="yes" xml:space="preserve">
          <source>The OCaml documentation and user&amp;rsquo;s manual is copyright &amp;copy; 2020 Institut National de Recherche en Informatique et en Automatique (INRIA).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="063309f868ad72cc8f639e2db6e77b695df7e9cb" translate="yes" xml:space="preserve">
          <source>The OCaml documentation and user&amp;rsquo;s manual is copyright &amp;copy; 2021 Institut National de Recherche en Informatique et en Automatique (INRIA).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1af4680eb3a182fd7749d661362740023609c59f" translate="yes" xml:space="preserve">
          <source>The OCaml documentation and user's manual is licensed under a &lt;a href=&quot;http://creativecommons.org/licenses/by-sa/4.0/&quot;&gt;Creative Commons Attribution-ShareAlike 4.0 International License&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf8bacefcbad184b18e85f7294594e9bb4eeae34" translate="yes" xml:space="preserve">
          <source>The OCaml documentation and user's manual is licensed under a &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/&quot;&gt;Creative Commons Attribution-ShareAlike 4.0 International License&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a12bf6d10452a673a4059a176328235b4073891" translate="yes" xml:space="preserve">
          <source>The OCaml notation for the type of a function with multiple arguments is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b300bbe66442808bbe9b55b3a38db2ca2b4dfb4" translate="yes" xml:space="preserve">
          <source>The OCaml run-time system is not reentrant: at any time, at most one thread can be executing OCaml code or C code that uses the OCaml run-time system. Technically, this is enforced by a &amp;ldquo;master lock&amp;rdquo; that any thread must hold while executing such code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e888d1165d4d21dea5f4e7b7872ca6fbab7bdab8" translate="yes" xml:space="preserve">
          <source>The OCaml runtime system comprises three main parts: the bytecode interpreter, the memory manager, and a set of C functions that implement the primitive operations. Some bytecode instructions are provided to call these C functions, designated by their offset in a table of functions (the table of primitives).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a9ec24fe8572105b571386cc4dee94c3a1b7683" translate="yes" xml:space="preserve">
          <source>The OCaml scanning facility is reminiscent of the corresponding C feature. However, it is also largely different, simpler, and yet more powerful: the formatted input functions are higher-order functionals and the parameter passing mechanism is just the regular function application not the variable assignment based mechanism which is typical for formatted input in imperative languages; the OCaml format strings also feature useful additions to easily define complex tokens; as expected within a functional programming language, the formatted input functions also support polymorphism, in particular arbitrary interaction with polymorphic user-defined scanners. Furthermore, the OCaml formatted input facility is fully type-checked at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abc31968fdf618dcf3aa38d81db7bcb91f6bbaf6" translate="yes" xml:space="preserve">
          <source>The OCaml system</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c00ea3211d757c3befa9662576a06b2a3d185969" translate="yes" xml:space="preserve">
          <source>The OCaml system computes both the value and the type for each phrase. Even function parameters need no explicit type declaration: the system infers their types from their usage in the function. Notice also that integers and floating-point numbers are distinct types, with distinct operators: + and * operate on integers, but +. and *. operate on floats.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="108a7dca000ccd9968ece57a159ab22379aec497" translate="yes" xml:space="preserve">
          <source>The OCaml system is copyright &amp;copy; 1996&amp;ndash;2020 Institut National de Recherche en Informatique et en Automatique (INRIA). INRIA holds all ownership rights to the OCaml system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be8f0d00e054bffe0a529a091f45121dddd7f60f" translate="yes" xml:space="preserve">
          <source>The OCaml system is copyright &amp;copy; 1996&amp;ndash;2021 Institut National de Recherche en Informatique et en Automatique (INRIA). INRIA holds all ownership rights to the OCaml system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e41ebd883056d903f296e46ca32d4e99959d066" translate="yes" xml:space="preserve">
          <source>The OCaml system is open source and can be freely redistributed. See the file LICENSE in the distribution for licensing information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a6d62f8ada2e0a3471af00a4f2d72e08bf53548" translate="yes" xml:space="preserve">
          <source>The OCaml system under Windows can be configured at build time in one of two modes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46e485e11802130ef8432b55f6c33406ef03529e" translate="yes" xml:space="preserve">
          <source>The OCaml type system checks that the type of the arguments and the specifiers are compatible. If you pass it an argument of a type that does not correspond to the format specifier, the compiler will display an error message:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b075ff3a2ce27b8853b8203828c331ee0dc266ff" translate="yes" xml:space="preserve">
          <source>The PowerPC code generator supports the following additional options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="595a52e6177f37e25c12ad26af16912ffc174450" translate="yes" xml:space="preserve">
          <source>The Windows API uses the UTF-16 encoding to support Unicode. The runtime system performs the necessary conversions so that the OCaml programmer only needs to deal with the OCaml encoding. C stubs that call Windows Unicode APIs need to use specific runtime functions to perform the necessary conversions in a compatible way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e58e4ef240f0b79192b60989a00c3560ae96550" translate="yes" xml:space="preserve">
          <source>The above class money reveals a problem that often occurs with binary methods. In order to interact with other objects of the same class, the representation of money objects must be revealed, using a method such as value. If we remove all binary methods (here plus and leq), the representation can easily be hidden inside objects by removing the method value as well. However, this is not possible as soon as some binary method requires access to the representation of objects of the same class (other than self).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c2b2bc28098b3a5ed96c8509e9d54181688aacc" translate="yes" xml:space="preserve">
          <source>The above considerations can usually be ignored if your lists are not longer than about 10000 elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1275e5b0fd632a0adb161ae45fd343dd0a7ed674" translate="yes" xml:space="preserve">
          <source>The above definition of functional_point is not equivalent to the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca1370db07df54b9210798f4a752f3703b356815" translate="yes" xml:space="preserve">
          <source>The above definition will only backup one level. The backup facility can be added to any class by using multiple inheritance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="044810ffbb768ce3b2056b4a6f6c69fc26ffde37" translate="yes" xml:space="preserve">
          <source>The above specification, inside a signature, only matches a module definition equal to &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;. Conversely, a type-level module alias can be matched by itself, or by any supertype of the type of the module it references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a4efe688ae0c8753fcbb050f0706980508ba0af" translate="yes" xml:space="preserve">
          <source>The above variant types were polymorphic, allowing further refinement. When writing type annotations, one will most often describe fixed variant types, that is types that cannot be refined. This is also the case for type abbreviations. Such types do not contain &amp;lt; or &amp;gt;, but just an enumeration of the tags and their associated types, just like in a normal datatype definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ef217485c89f7960da6716b91dd0fabc645656e" translate="yes" xml:space="preserve">
          <source>The abstract type &lt;code&gt;backtrace_slot&lt;/code&gt; represents a single slot of a backtrace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="739286bc505e97139a598fe8147fb7a3765c2deb" translate="yes" xml:space="preserve">
          <source>The abstract type &lt;code&gt;raw_backtrace&lt;/code&gt; stores a backtrace in a low-level format, instead of directly exposing them as string as the &lt;code&gt;get_backtrace()&lt;/code&gt; function does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af764d88af01f9903675386eab28fc1408ce8155" translate="yes" xml:space="preserve">
          <source>The abstract type of Internet addresses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="481d24b8ea9ec5881b68246c8998a8f47be76742" translate="yes" xml:space="preserve">
          <source>The abstract type of buffers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4026004092ed45c6dd9c41b6b253ecdb6f12e44c" translate="yes" xml:space="preserve">
          <source>The abstract type of file descriptors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="012fb3dc8bc487525d0af4de37a9ed3cffd39a71" translate="yes" xml:space="preserve">
          <source>The actions are arbitrary OCaml expressions. They are evaluated in a context where the identifiers defined by using the as construct are bound to subparts of the matched string. Additionally, lexbuf is bound to the current lexer buffer. Some typical uses for lexbuf, in conjunction with the operations on lexer buffers provided by the Lexing standard library module, are listed below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f24608a60c588712f36527d1438e6185c4caa81b" translate="yes" xml:space="preserve">
          <source>The advantage of those printers based on the %a specifier is that they can be composed together to create more complex printers step by step. We can define a combinator that can turn a printer for 'a type into a printer for 'a optional:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08b7a0d96acbf6b2533907cd2c43896611cce1c8" translate="yes" xml:space="preserve">
          <source>The aims of inlining are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e4b4f885867a255a22ab6931eddd051e8225ed9" translate="yes" xml:space="preserve">
          <source>The all-time favorite: a desk calculator. This program reads arithmetic expressions on standard input, one per line, and prints their values. Here is the grammar definition:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac2c39dacdc6a9be5743e68f1dd99fbde2e43c29" translate="yes" xml:space="preserve">
          <source>The allocation of the pair has been eliminated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bdf6e627c88ed40af03f752c75a521013dd60d7" translate="yes" xml:space="preserve">
          <source>The allocation of the pair within f has been removed. (Since the two closures for loop&amp;rsquo; and loop2&amp;rsquo; are constant they will also be lifted to toplevel with no runtime allocation penalty. This would also happen without having run the transformation to unbox specialise arguments.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2de0b011f578d5d6e9c61968919404fdcc2ece6" translate="yes" xml:space="preserve">
          <source>The alternative is of course to build the library without extra options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e2dd4f451a8dcf054a1812b560aca93e651aa0b" translate="yes" xml:space="preserve">
          <source>The amount of profiling information can be controlled through the -P option to ocamlcp or ocamloptp, followed by one or several letters indicating which parts of the program should be profiled:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ab3f2331e8b1749d459c0080607551039b5ae36" translate="yes" xml:space="preserve">
          <source>The annotation virtual here is only used to mention a method without providing its definition. Since we didn&amp;rsquo;t add the private annotation, this makes the method public, keeping the original definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f58bb108f6951aa34759425d8ee753adc0f3924e" translate="yes" xml:space="preserve">
          <source>The answer is that when confronted with multiple options, OCaml tries to use locally available information to disambiguate between the various fields and constructors. First, if the type of the record or variant is known, OCaml can pick unambiguously the corresponding field or constructor. For instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="611a6a75c3c1ff11eb7d3c599a9f649411be363a" translate="yes" xml:space="preserve">
          <source>The answer is twofold. One first aspect is that while being pretty efficient, the lack of static type information allows for less optimizations, and makes polymorphic variants slightly heavier than core language ones. However noticeable differences would only appear on huge data structures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e0ae228161936f806d34344dc59d7232112d71f" translate="yes" xml:space="preserve">
          <source>The argument f to iter is invariant so the function may be specialised:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3e5632dfa7a2b83bf829cdc816e3c1a87c98674" translate="yes" xml:space="preserve">
          <source>The argument of &lt;a href=&quot;sys#VALcommand&quot;&gt;&lt;code&gt;Sys.command&lt;/code&gt;&lt;/a&gt; is generally the name of a command followed by zero, one or several arguments, separated by whitespace. The given argument is interpreted by a shell: either the Windows shell &lt;code&gt;cmd.exe&lt;/code&gt; for the Win32 ports of OCaml, or the POSIX shell &lt;code&gt;sh&lt;/code&gt; for other ports. It can contain shell builtin commands such as &lt;code&gt;echo&lt;/code&gt;, and also special characters such as file redirections &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt;, which will be honored by the shell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c32b048d109d34646b19b7212d9e49b0e7c2fe1" translate="yes" xml:space="preserve">
          <source>The arguments following program are optional, and are passed as command-line arguments to the program being debugged. (See also the set arguments command.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adbf5b37a6462b0983b5bf9cd33bf85f4db819aa" translate="yes" xml:space="preserve">
          <source>The arguments of sum-type constructors can now be defined using the same syntax as records. Mutable and polymorphic fields are allowed. GADT syntax is supported. Attributes can be specified on individual fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82ce2f746abf0188689410ed58dc502e67dced4e" translate="yes" xml:space="preserve">
          <source>The arity (number of arguments) of a primitive is automatically determined from its OCaml type in the external declaration, by counting the number of function arrows in the type. For instance, input above has arity 4, and the input C function is called with four arguments. Similarly,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e00a28237987af7a41897bd91d033f1bf8d96517" translate="yes" xml:space="preserve">
          <source>The arity (number of arguments) of a primitive is automatically determined from its OCaml type in the external declaration, by counting the number of function arrows in the type. For instance, seek_in above has arity 2, and the caml_ml_seek_in C function is called with two arguments. Similarly,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ab01eca841b7f4d65b6116a30c2bd33e79dbb17" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;a&lt;/code&gt; must have exactly &lt;code&gt;N&lt;/code&gt; dimensions, and all coordinates must lie inside the array bounds, as described for &lt;code&gt;Genarray.get&lt;/code&gt;; otherwise, &lt;code&gt;Invalid_argument&lt;/code&gt; is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="868ea2ab054abe050c8bc298a300a68a34cb7e0b" translate="yes" xml:space="preserve">
          <source>The as construct is similar to &amp;ldquo;&lt;em&gt;groups&lt;/em&gt;&amp;rdquo; as provided by numerous regular expression packages. The type of these variables can be string, char, string option or char option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73177bb5797d8e28b73870b15973e78612bd93d2" translate="yes" xml:space="preserve">
          <source>The associated parser would be a function from &lt;code&gt;token&amp;nbsp;stream&lt;/code&gt; to, for instance, &lt;code&gt;int&lt;/code&gt;, and would have rules such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2420f95fc8ad57ab7c1da6f7e6377e30752e6e0e" translate="yes" xml:space="preserve">
          <source>The author of the element. One author per @author tag. There may be several @author tags for the same element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c7873377d2e12a00df000be90fb6b4a6087455b" translate="yes" xml:space="preserve">
          <source>The basic form for defining a module component is module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;=&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;, which evaluates &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt; and binds the result to the name &lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="842164f73b83f27f15ffe93e1ec98838de6e836b" translate="yes" xml:space="preserve">
          <source>The behavior is not defined if the hash table is modified by &lt;code&gt;f&lt;/code&gt; during the iteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7911b90c87825476ae85d935bdfc9f902a9f2ea" translate="yes" xml:space="preserve">
          <source>The behavior is not defined if the hash table is modified during the iteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2864aadac566232a3bcdc4cb624a8b2acaaa672" translate="yes" xml:space="preserve">
          <source>The behavior of other forms of letrec definitions is implementation-dependent. The current implementation also supports a certain class of recursive definitions of non-functional values, as explained in section &amp;zwj;&lt;a href=&quot;letrecvalues#s%3Aletrecvalues&quot;&gt;8.1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d6058839cd5d6f864ed769e103e1c4571b14c4b" translate="yes" xml:space="preserve">
          <source>The behavior of other forms of letrec definitions is implementation-dependent. The current implementation also supports a certain class of recursive definitions of non-functional values, as explained in section &lt;a href=&quot;letrecvalues#s%3Aletrecvalues&quot;&gt;8.1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ff67900c42b4aee958325c5f4f3657cfb01e905" translate="yes" xml:space="preserve">
          <source>The behavior of pretty-printing commands is unspecified if there is no open pretty-printing box. Each box opened by one of the &lt;code&gt;open_&lt;/code&gt; functions below must be closed using &lt;code&gt;close_box&lt;/code&gt; for proper formatting. Otherwise, some of the material printed in the boxes may not be output, or may be formatted incorrectly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="294b4ce3a6ec7d9526f89437cbfa0a62dbc20037" translate="yes" xml:space="preserve">
          <source>The behaviour depends on whether -Oclassic is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37716c4181d6f75c920bfc58fd4811b40988028e" translate="yes" xml:space="preserve">
          <source>The behaviour of the Flambda simplification pass means that certain unsafe operations, which may without Flambda or when using previous versions of the compiler be safe, must not be used. This specifically refers to functions found in the Obj module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eee0f3f481dbee307882214b9d43efeec2d8af62" translate="yes" xml:space="preserve">
          <source>The benefit of specialisation is assessed in a similar way as for inlining. Specialised argument information may mean that the body of the function being specialised can be simplified: the removed operations are accumulated into a benefit. This, together with the size of the duplicated (specialised) function declaration, is then assessed against the size of the call to the original function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b2c4a9ea1966c2159ce87a9dbf7fed0e3ab528e" translate="yes" xml:space="preserve">
          <source>The best way to set a file descriptor ``close-on-exec'' is to create it in this state. To this end, the &lt;code&gt;openfile&lt;/code&gt; function has &lt;code&gt;O_CLOEXEC&lt;/code&gt; and &lt;code&gt;O_KEEPEXEC&lt;/code&gt; flags to enforce ``close-on-exec'' mode or ``keep-on-exec'' mode, respectively. All other operations in the Unix module that create file descriptors have an optional argument &lt;code&gt;?cloexec:bool&lt;/code&gt; to indicate whether the file descriptor should be created in ``close-on-exec'' mode (by writing &lt;code&gt;~cloexec:true&lt;/code&gt;) or in ``keep-on-exec'' mode (by writing &lt;code&gt;~cloexec:false&lt;/code&gt;). For historical reasons, the default file descriptor creation mode is ``keep-on-exec'', if no &lt;code&gt;cloexec&lt;/code&gt; optional argument is given. This is not a safe default, hence it is highly recommended to pass explicit &lt;code&gt;cloexec&lt;/code&gt; arguments to operations that create file descriptors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86498a92f17f772fbb61c7717d965395dedb151e" translate="yes" xml:space="preserve">
          <source>The bigarray functionality may now be found in the standard library &lt;a href=&quot;libref/bigarray&quot;&gt;Bigarray module&lt;/a&gt;, except for the map_file function which is now part of the &lt;a href=&quot;libunix#c%3Aunix&quot;&gt;Unix library&lt;/a&gt;. The documentation has been integrated into the documentation for the standard library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c17f0e116811b46fb1a7e57d12263409833bc755" translate="yes" xml:space="preserve">
          <source>The bigarray library has now been integrated into OCaml&amp;rsquo;s standard library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6a6099570dff5141c480a3752e67d9450054231" translate="yes" xml:space="preserve">
          <source>The boolean 'and'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="353c4c988751affe11b91a3216ece019b7e4c283" translate="yes" xml:space="preserve">
          <source>The boolean 'and'. Evaluation is sequential, left-to-right: in &lt;code&gt;e1&amp;nbsp;&amp;amp;&amp;amp;&amp;nbsp;e2&lt;/code&gt;, &lt;code&gt;e1&lt;/code&gt; is evaluated first, and if it returns &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;e2&lt;/code&gt; is not evaluated at all. Right-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c5b81b1af0be4a909b4ff180ecd97e7f3ba74ce" translate="yes" xml:space="preserve">
          <source>The boolean 'or'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7978a7e64fa2a3b90ad7ad3cd09291d62fe4c55" translate="yes" xml:space="preserve">
          <source>The boolean 'or'. Evaluation is sequential, left-to-right: in &lt;code&gt;e1&amp;nbsp;||&amp;nbsp;e2&lt;/code&gt;, &lt;code&gt;e1&lt;/code&gt; is evaluated first, and if it returns &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;e2&lt;/code&gt; is not evaluated at all. Right-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57f592a468f9e49822816c7b0706ff6890f3319b" translate="yes" xml:space="preserve">
          <source>The boolean negation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3356fbfc82845f932c40854238e79297422bf18" translate="yes" xml:space="preserve">
          <source>The boolean operators &amp;amp; and or are deprecated synonyms for (respectively) &amp;amp;&amp;amp; and ||.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5f2def0fcadebd404f0b3e288cd99d54193864d" translate="yes" xml:space="preserve">
          <source>The bytecode compiler in custom runtime mode (ocamlc -custom) normally appends the bytecode to the executable file containing the custom runtime. This has two consequences. First, the final linking step must be performed by ocamlc. Second, the OCaml runtime library must be able to find the name of the executable file from the command-line arguments. When using caml_main(argv) as in section &amp;zwj;&lt;a href=&quot;#ss%3Amain-c&quot;&gt;18.7.4&lt;/a&gt;, this means that argv[0] or argv[1] must contain the executable file name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b049f36521b991b87ac5a40eab10383da5bcce8" translate="yes" xml:space="preserve">
          <source>The bytecode compiler in custom runtime mode (ocamlc -custom) normally appends the bytecode to the executable file containing the custom runtime. This has two consequences. First, the final linking step must be performed by ocamlc. Second, the OCaml runtime library must be able to find the name of the executable file from the command-line arguments. When using caml_main(argv) as in section &lt;a href=&quot;#ss%3Amain-c&quot;&gt;20.7.4&lt;/a&gt;, this means that argv[0] or argv[1] must contain the executable file name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae71aa32bd811f5994a5593dcd1cb87c5ea5d8e1" translate="yes" xml:space="preserve">
          <source>The bytecode executable myprog can then be launched as usual: myprogargs or /home/me/ocamlunixrun myprogargs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31c8711898f71d43a2b4ca33e6558e5b43e7cda7" translate="yes" xml:space="preserve">
          <source>The bytes representing a marshaled value are composed of a fixed-size header and a variable-sized data part, whose size can be determined from the header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6cf8ac9f4453cd731df08caa3e42856639d786a" translate="yes" xml:space="preserve">
          <source>The bytes representing a marshaled value are composed of a fixed-size header and a variable-sized data part, whose size can be determined from the header. &lt;a href=&quot;marshal#VALheader_size&quot;&gt;&lt;code&gt;Marshal.header_size&lt;/code&gt;&lt;/a&gt; is the size, in bytes, of the header. &lt;a href=&quot;marshal#VALdata_size&quot;&gt;&lt;code&gt;Marshal.data_size&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;nbsp;buff&amp;nbsp;ofs&lt;/code&gt; is the size, in bytes, of the data part, assuming a valid header is stored in &lt;code&gt;buff&lt;/code&gt; starting at position &lt;code&gt;ofs&lt;/code&gt;. Finally, &lt;a href=&quot;marshal#VALtotal_size&quot;&gt;&lt;code&gt;Marshal.total_size&lt;/code&gt;&lt;/a&gt;&lt;code&gt;buff&amp;nbsp;ofs&lt;/code&gt; is the total size, in bytes, of the marshaled value. Both &lt;a href=&quot;marshal#VALdata_size&quot;&gt;&lt;code&gt;Marshal.data_size&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;marshal#VALtotal_size&quot;&gt;&lt;code&gt;Marshal.total_size&lt;/code&gt;&lt;/a&gt; raise &lt;code&gt;Failure&lt;/code&gt; if &lt;code&gt;buff&lt;/code&gt;, &lt;code&gt;ofs&lt;/code&gt; does not contain a valid header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d1103a29f51d40271f1f9e57f4afef462874497" translate="yes" xml:space="preserve">
          <source>The call to caml_main initializes the OCaml runtime system, loads the bytecode (in the case of the bytecode compiler), and executes the initialization code of the OCaml program. Typically, this initialization code registers callback functions using Callback.register. Once the OCaml initialization code is complete, control returns to the C code that called caml_main.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a133408bb95ba502b3a3f1d4a608ee2cbee5abd" translate="yes" xml:space="preserve">
          <source>The call to print_int can indeed be inlined:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94ba4fe5d5732c256fe3a8bfe75e3f359200cfb9" translate="yes" xml:space="preserve">
          <source>The caller may not mutate &lt;code&gt;s&lt;/code&gt; while the string is borrowed (it has temporarily given up ownership). This affects concurrent programs, but also higher-order functions: if &lt;a href=&quot;string#VALlength&quot;&gt;&lt;code&gt;String.length&lt;/code&gt;&lt;/a&gt; returned a closure to be called later, &lt;code&gt;s&lt;/code&gt; should not be mutated until this closure is fully applied and returns ownership.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0f9579a2db02b7e2d6ea5033fac1d3e370d16d1" translate="yes" xml:space="preserve">
          <source>The callstack for the allocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="622bd19b67cd4c019f61e03bb878afac5759460b" translate="yes" xml:space="preserve">
          <source>The caml_startup function calls the uncaught exception handler (or enters the debugger, if running under ocamldebug) if an exception escapes from a top-level module initialiser. Such exceptions may be caught in the C code by instead using the caml_startup_exn function and testing the result using Is_exception_result (followed by Extract_exception if appropriate).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="264cb221ad2c5021cb06f4e90ab892974f6027b4" translate="yes" xml:space="preserve">
          <source>The caml_startup function must be called from the main C program in order to initialize the OCaml runtime and execute the OCaml initialization code. Just like caml_main, it takes one argv parameter containing the command-line parameters. Unlike caml_main, this argv parameter is used only to initialize Sys.argv, but not for finding the name of the executable file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2affb46e2f6bba633bb7602b97c665a41396ccad" translate="yes" xml:space="preserve">
          <source>The cases of a pattern matching (in the function, match and try constructs) can include guard expressions, which are arbitrary boolean expressions that must evaluate to true for the match case to be selected. Guards occur just before the -&amp;gt; token and are introduced by the when keyword:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c57a5996cc3de19dcd4e1eed39d89bc12a76cdf5" translate="yes" xml:space="preserve">
          <source>The change in code size is also estimated: morally speaking it should be the change in machine code size, but since that is not available to the inliner, an approximation is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca1b550469abfe316a8551222d7494a0d41f29ab" translate="yes" xml:space="preserve">
          <source>The class Odoc_html.Generator.html inherits from the class Odoc_html.info, containing a field tag_functions which is a list pairs composed of a custom tag (e.g. &quot;foo&quot;) and a function taking a text and returning HTML code (of type string). To handle a new tag bar, extend the current HTML generator and complete the tag_functions field:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="926c19980b2db5430ad107b75fe1458a4f3fbdcc" translate="yes" xml:space="preserve">
          <source>The class bank is the &lt;em&gt;real&lt;/em&gt; implementation of the bank account (it could have been inlined). This is the one that will be used for further extensions, refinements, etc. Conversely, the client will only be given the client view.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e75252ec56a2bb1491e257e9361045a0dd0b5821" translate="yes" xml:space="preserve">
          <source>The class colored_circle is a specialized version of class circle that requires the type of the center to unify with #colored_point, and adds a method color. Note that when specializing a parameterized class, the instance of type parameter must always be explicitly given. It is again written between [ and ].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79b45dbbed1c7c5a93e33df7a349eb52d30c016c" translate="yes" xml:space="preserve">
          <source>The class money could naturally carry another binary method. Here is a direct definition:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8da53bfa481f42c4800f57d82c95a21c851133c0" translate="yes" xml:space="preserve">
          <source>The class observer has a distinguished method notify that requires two arguments, a subject and an event to execute an action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df3bd4e2828bcd091f80465c81ab6f432a8b0a11" translate="yes" xml:space="preserve">
          <source>The class point below defines one instance variable x and two methods get_x and move. The initial value of the instance variable is 0. The variable x is declared mutable, so the method move can change its value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4593d18e4f9e303d386e01a8341f25ec6716bf22" translate="yes" xml:space="preserve">
          <source>The class point can also be abstracted over the initial values of the x coordinate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d631271177c3626e572631b72bb8a711d8d83fe5" translate="yes" xml:space="preserve">
          <source>The class subject remembers a list of observers in an instance variable, and has a distinguished method notify_observers to broadcast the message notify to all observers with a particular event e.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4100d907acfdcabf2433a494dd1a3e4d594e0d96" translate="yes" xml:space="preserve">
          <source>The class type expression &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;-&amp;gt;&lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt; is the type of class functions (functions from values to classes) that take as argument a value of type &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; and return as result a class of type &lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccb1b7cb0b9bf09c44c246b3d8b635b8df171c1b" translate="yes" xml:space="preserve">
          <source>The class type expression object [(&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;)] {&lt;a href=&quot;#class-field-spec&quot;&gt;class-field-spec&lt;/a&gt;} end is the type of a class body. It specifies its instance variables and methods. In this type, &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; is matched against the self type, therefore providing a name for the self type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54e83d883d9c89940ee922a012fe9586b0e83667" translate="yes" xml:space="preserve">
          <source>The class type parameters correspond to the ones of the class type and of the two type abbreviations defined by the class binding. They must be bound to actual types in the class definition using type constraints. So that the abbreviations are well-formed, type variables of the inferred type of the class must either be type parameters or be bound in the constraint clause.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5fa7a046792c2877d81d775912d2e5ba688e9f6" translate="yes" xml:space="preserve">
          <source>The closing tag marker, as given by &lt;code&gt;mark_close_stag&amp;nbsp;t&lt;/code&gt;, is written into the output device of the formatter; then the &lt;code&gt;print_close_stag&lt;/code&gt; tag-printing function of the formatter is called with &lt;code&gt;t&lt;/code&gt; as argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f5a0cc5c3693ff9428c3a313f5f025808cf9ecb" translate="yes" xml:space="preserve">
          <source>The code resulting from applying -O3 -unbox-closures to this code passes the free variables via function arguments in order to eliminate all closure allocation in this example (aside from any that might be performed inside printf).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a56e3d3e4c999f25e3f562df13ab73e9511528d5" translate="yes" xml:space="preserve">
          <source>The command line analysis is performed after loading the module containing the documentation generator, thus allowing command line options to be added to the list of existing ones. Adding an option can be done with the function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="713e03c7df6783cbf595d790dada27c89d701a1d" translate="yes" xml:space="preserve">
          <source>The command line arguments given to the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aeece9eee37cad413bcf22ebfdfa0c87857f155" translate="yes" xml:space="preserve">
          <source>The command line arguments given to the process. The first element is the command name used to invoke the program. The following elements are the command-line arguments given to the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="351afc02e66d69b38e7fb7bbf282c52d820d0b73" translate="yes" xml:space="preserve">
          <source>The command quit exits the debugger. You can also exit the debugger by typing an end-of-file character (usually ctrl-D).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e23e32f6685f8bb7b921c0aa6a10415254fe4726" translate="yes" xml:space="preserve">
          <source>The compare field can be set to custom_compare_default; this default comparison function simply raises Failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="400936dd851589bd58319e0915e19ac225ad000b" translate="yes" xml:space="preserve">
          <source>The compare field contains a pointer to a C function that is called whenever two custom blocks are compared using OCaml&amp;rsquo;s generic comparison operators (=, &amp;lt;&amp;gt;, &amp;lt;=, &amp;gt;=, &amp;lt;, &amp;gt; and compare). The C function should return 0 if the data contained in the two blocks are structurally equal, a negative integer if the data from the first block is less than the data from the second block, and a positive integer if the data from the first block is greater than the data from the second block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc7b967b6bfa6059a95a5177a3d4d949e36cefb7" translate="yes" xml:space="preserve">
          <source>The compare_ext field can be set to custom_compare_ext_default; this default comparison function simply raises Failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e507c128d533ecafbf0707e3311fd3954593733" translate="yes" xml:space="preserve">
          <source>The comparison function for 16-character digest, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt; and the implementation shared with &lt;a href=&quot;string#VALcompare&quot;&gt;&lt;code&gt;String.compare&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d93ed75e8c4197749446b6127b8c28c77f22cc5" translate="yes" xml:space="preserve">
          <source>The comparison function for 16-character digest, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt; and the implementation shared with &lt;a href=&quot;string#VALcompare&quot;&gt;&lt;code&gt;String.compare&lt;/code&gt;&lt;/a&gt;. Along with the type &lt;code&gt;t&lt;/code&gt;, this function &lt;code&gt;compare&lt;/code&gt; allows the module &lt;code&gt;Digest&lt;/code&gt; to be passed as argument to the functors &lt;a href=&quot;set.make&quot;&gt;&lt;code&gt;Set.Make&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;map.make&quot;&gt;&lt;code&gt;Map.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9f9a53259e71203663f8e69d67e5c99f6aeaf69" translate="yes" xml:space="preserve">
          <source>The comparison function for 32-bit integers, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52c057344f74f3ec299881602b4bac70c2781e4d" translate="yes" xml:space="preserve">
          <source>The comparison function for 32-bit integers, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;. Along with the type &lt;code&gt;t&lt;/code&gt;, this function &lt;code&gt;compare&lt;/code&gt; allows the module &lt;code&gt;Int32&lt;/code&gt; to be passed as argument to the functors &lt;a href=&quot;set.make&quot;&gt;&lt;code&gt;Set.Make&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;map.make&quot;&gt;&lt;code&gt;Map.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32ed748cfcec44e96e26180791258594924fa2f5" translate="yes" xml:space="preserve">
          <source>The comparison function for 64-bit integers, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d3cd3ac1cd893b13ee278ef969766aaeeb6d9d9" translate="yes" xml:space="preserve">
          <source>The comparison function for 64-bit integers, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;. Along with the type &lt;code&gt;t&lt;/code&gt;, this function &lt;code&gt;compare&lt;/code&gt; allows the module &lt;code&gt;Int64&lt;/code&gt; to be passed as argument to the functors &lt;a href=&quot;set.make&quot;&gt;&lt;code&gt;Set.Make&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;map.make&quot;&gt;&lt;code&gt;Map.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bea1fb4f967f6e930a0a3f1b6dd8b3d9440baccf" translate="yes" xml:space="preserve">
          <source>The comparison function for byte sequences, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0c8f9bc7e72b4041efc638ebe36bb3de869d339" translate="yes" xml:space="preserve">
          <source>The comparison function for byte sequences, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;. Along with the type &lt;code&gt;t&lt;/code&gt;, this function &lt;code&gt;compare&lt;/code&gt; allows the module &lt;code&gt;Bytes&lt;/code&gt; to be passed as argument to the functors &lt;a href=&quot;set.make&quot;&gt;&lt;code&gt;Set.Make&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;map.make&quot;&gt;&lt;code&gt;Map.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4248cb5972f6600877776ee5b7caa863058e709e" translate="yes" xml:space="preserve">
          <source>The comparison function for characters, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f1c4568057988fd6052ab54ff61953ad29435a0" translate="yes" xml:space="preserve">
          <source>The comparison function for characters, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;. Along with the type &lt;code&gt;t&lt;/code&gt;, this function &lt;code&gt;compare&lt;/code&gt; allows the module &lt;code&gt;Char&lt;/code&gt; to be passed as argument to the functors &lt;a href=&quot;set.make&quot;&gt;&lt;code&gt;Set.Make&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;map.make&quot;&gt;&lt;code&gt;Map.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c2863b10b77fa26a22a5fb611bbcda7b42b0bce" translate="yes" xml:space="preserve">
          <source>The comparison function for native integers, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13b4368747939c68aea788a4bc151e1321dcb60a" translate="yes" xml:space="preserve">
          <source>The comparison function for native integers, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;. Along with the type &lt;code&gt;t&lt;/code&gt;, this function &lt;code&gt;compare&lt;/code&gt; allows the module &lt;code&gt;Nativeint&lt;/code&gt; to be passed as argument to the functors &lt;a href=&quot;set.make&quot;&gt;&lt;code&gt;Set.Make&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;map.make&quot;&gt;&lt;code&gt;Map.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6d081b56d1fdbb9331b6bc0b8263048c0154295" translate="yes" xml:space="preserve">
          <source>The comparison function for strings, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73fb41656984243b49dbd382d60fab144a75f5a1" translate="yes" xml:space="preserve">
          <source>The comparison function for strings, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;. Along with the type &lt;code&gt;t&lt;/code&gt;, this function &lt;code&gt;compare&lt;/code&gt; allows the module &lt;code&gt;String&lt;/code&gt; to be passed as argument to the functors &lt;a href=&quot;set.make&quot;&gt;&lt;code&gt;Set.Make&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;map.make&quot;&gt;&lt;code&gt;Map.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf96782a960b80262c43276b69181745eee6a160" translate="yes" xml:space="preserve">
          <source>The compilation units loaded by this function are added to the &quot;allowed units&quot; list (see &lt;a href=&quot;dynlink#VALset_allowed_units&quot;&gt;&lt;code&gt;Dynlink.set_allowed_units&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f8562bc429c53a9ee1fb8567862cc87267a563b" translate="yes" xml:space="preserve">
          <source>The compilation units loaded by this function are not added to the &quot;allowed units&quot; list (see &lt;a href=&quot;dynlink#VALset_allowed_units&quot;&gt;&lt;code&gt;Dynlink.set_allowed_units&lt;/code&gt;&lt;/a&gt;) since they cannot be referenced from other compilation units.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="707933d508f6c3a7f70392088950a49fbd52b59f" translate="yes" xml:space="preserve">
          <source>The compiler aims to share constants lifted to toplevel such that there are no duplicate definitions. However if .cmx files are hidden from the compiler then maximal sharing may not be possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5839a1745e82e6942b420724963de7198ab2be1" translate="yes" xml:space="preserve">
          <source>The compiler always derives the module name by taking the capitalized base name of the source file (.ml or .mli file). That is, it strips the leading directory name, if any, as well as the .ml or .mli suffix; then, it set the first letter to uppercase, in order to comply with the requirement that module names must be capitalized. For instance, compiling the file mylib/misc.ml provides an implementation for the module named Misc. Other compilation units may refer to components defined in mylib/misc.ml under the names Misc.name; they can also do open Misc, then use unqualified names name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12a0d3bf4431d29fd5d6cebb56459fe2a6246977" translate="yes" xml:space="preserve">
          <source>The compiler can prove invariance of function arguments across multiple functions within a recursive group (although this has some limitations, as shown by the example below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3a13caf32a0850458a50504a9f9b67fbe141403" translate="yes" xml:space="preserve">
          <source>The compiler cannot currently detect invariance in cases such as the following.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c5469d71b4fc3737466081b4134fc0bcc32f1c5" translate="yes" xml:space="preserve">
          <source>The compiler command line can be modified &amp;ldquo;from the outside&amp;rdquo; with the following mechanisms. These are experimental and subject to change. They should be used only for experimental and development work, not in released packages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b6fd616c3d14b8722315aee0f9e2a79310b0ab4" translate="yes" xml:space="preserve">
          <source>The compiler distribution does not itself provide the facility for analysing Spacetime output files; this is left to external tools. The first such tool will appear in OPAM as a package called prof_spacetime. That tool will provide interactive graphical and terminal-based visualisation of the results of profiling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="431b5a10ae44ff4efacaa2847555e5ec57afda8d" translate="yes" xml:space="preserve">
          <source>The compiler distribution provides an &amp;ldquo;otherlibs&amp;rdquo; library called raw_spacetime_lib for decoding Spacetime files. This library provides facilities to read not only memory profiling information but also the full dynamic call graph of the profiled program which is written into Spacetime output files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36caea4a11df67f29a0533e03c9c03a280e97c4b" translate="yes" xml:space="preserve">
          <source>The compiler does not include the runtime system (nor a reference to it) in the generated program; it must be supplied separately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fb9134b61ba76fc9c4316c0291fbc13063e70af" translate="yes" xml:space="preserve">
          <source>The compiler is able to emit some information on its internal stages. It can output .cmt files for the implementation of the compilation unit and .cmti for signatures if the option -bin-annot is passed to it (see the description of -bin-annot below). Each such file contains a typed abstract syntax tree (AST), that is produced during the type checking procedure. This tree contains all available information about the location and the specific type of each term in the source file. The AST is partial if type checking was unsuccessful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48ebb88864057cd3c0c7e6531c5d37c29d605813" translate="yes" xml:space="preserve">
          <source>The compiler notes down that for the function iter&amp;rsquo;, the argument f is specialised to the constant closure print_int. This means that the body of iter&amp;rsquo; may be simplified:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65c5761f18846d3de8e8d4bc7344497dc351852c" translate="yes" xml:space="preserve">
          <source>The compiler produces this error when it tries to read a compiled interface file (.cmi file) that has the wrong structure. This means something went wrong when this .cmi file was written: the disk was full, the compiler was interrupted in the middle of the file creation, and so on. This error can also appear if a .cmi file is modified after its creation by the compiler. Fix: remove the corrupted .cmi file, and rebuild it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20b2d8ee46fbd0ec43648349d2f501735b50eb59" translate="yes" xml:space="preserve">
          <source>The complete OCaml distribution can be accessed via the &lt;a href=&quot;https://ocaml.org/&quot;&gt;ocaml.org website&lt;/a&gt;. This site contains a lot of additional information on OCaml.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="581d160324d6b1dcf6f5966e788655a0b8d7c61c" translate="yes" xml:space="preserve">
          <source>The complex number &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a94f375eaa7012dabdc57ca285225234540e0a33" translate="yes" xml:space="preserve">
          <source>The complex number &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b43370e6d1b0c376b1980b552194da8b6181987d" translate="yes" xml:space="preserve">
          <source>The complex number &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ad39316a87edf772e43a6c5b64a3e41e9c0e181" translate="yes" xml:space="preserve">
          <source>The concrete type describing the behavior associated with a keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79be6aae51e8c401b2476f5b4f2a107a9fdc32ef" translate="yes" xml:space="preserve">
          <source>The constant pi.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ad8c44fad65df83c02fac0ee5f9d77f6672d992" translate="yes" xml:space="preserve">
          <source>The constraint on self&amp;rsquo;s type is requiring a public move method, and this is sufficient to override private.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a279814e737c452af822699c5733e5455892c221" translate="yes" xml:space="preserve">
          <source>The constraints associated to each constructor can be recovered through pattern-matching. Namely, if the type of the scrutinee of a pattern-matching contains a locally abstract type, this type can be refined according to the constructor used. These extra constraints are only valid inside the corresponding branch of the pattern-matching. If a constructor has some existential variables, fresh locally abstract types are generated, and they must not escape the scope of this branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72a6619fc6d35a54f266cbb1b53bb99ad5b03227" translate="yes" xml:space="preserve">
          <source>The construct constraint'&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;=&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; allows the specification of type parameters. Any actual type argument corresponding to the type parameter &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; has to be an instance of &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; (more precisely, &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; and &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; are unified). Type variables of &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; can appear in the type equation and the type declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6dcf637d8dc6131f0b0eb619e7d7999e61b6d1b" translate="yes" xml:space="preserve">
          <source>The construct constraint&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; forces the two type expressions to be equal. This is typically used to specify type parameters: in this way, they can be bound to specific type expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e91937a9ebb9b2f875d8df7aec3ae920407278b6" translate="yes" xml:space="preserve">
          <source>The construct constraint&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; forces the two type expressions to be equals. This is typically used to specify type parameters: in that way they can be bound to specific type expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4111af28e88c74529d924590f2259579d7eddcd6" translate="yes" xml:space="preserve">
          <source>The construction moduletypeof&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt; expands to the module type (signature or functor type) inferred for the module expression &lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;. To make this module type reusable in many situations, it is intentionally not strengthened: abstract types and datatypes are not explicitly related with the types of the original module. For the same reason, module aliases in the inferred type are expanded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="760fdc00af3cbc0e13df9af8553cc7a286bca119" translate="yes" xml:space="preserve">
          <source>The constructor &lt;code&gt;()&lt;/code&gt; is included here so that it has a path, but it is not intended to be used in user-defined data types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3003c0bbe668e94ab79defd3f710132d87092a6" translate="yes" xml:space="preserve">
          <source>The constructors &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;true&lt;/code&gt; are included here so that they have paths, but they are not intended to be used in user-defined data types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16640eb9daf1519aa608d0b29675645a8a35f3cb" translate="yes" xml:space="preserve">
          <source>The content inside {%foo: ... %} is target-specific and will only be interpreted by the backend foo, and ignored by the others. The backends of the distribution are latex, html, texi and man. If no target is specified (syntax {% ... %}), latex is chosen by default. Custom generators may support their own target prefix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c5c2fffb0418b713216d4c77f75ee03f3710a80" translate="yes" xml:space="preserve">
          <source>The contents of custom blocks are not scanned by the garbage collector, and must therefore not contain any pointer inside the OCaml heap. In other terms, never store an OCaml value in a custom block, and do not use Field, Store_field nor caml_modify to access the data part of a custom block. Conversely, any C data structure (not containing heap pointers) can be stored in a custom block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="785642c4a4c006be73a07a4f7ec8afa9d91aa1ff" translate="yes" xml:space="preserve">
          <source>The conventional name for the current directory (e.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab0089cb61bfc166d7c15a2b68e795215831943d" translate="yes" xml:space="preserve">
          <source>The conventional name for the current directory (e.g. &lt;code&gt;.&lt;/code&gt; in Unix).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="545670a3a8b2e0fff49a5ac43c08636390916185" translate="yes" xml:space="preserve">
          <source>The conventional name for the parent of the current directory (e.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b950ea81536e7df7421680a6cf3781982072c75" translate="yes" xml:space="preserve">
          <source>The conventional name for the parent of the current directory (e.g. &lt;code&gt;..&lt;/code&gt; in Unix).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33e422b54f028d0f9f99ad979df276c42ced7356" translate="yes" xml:space="preserve">
          <source>The conversion characters and their meanings are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cb23e02c094574c60663d78adfeb6ade600463a" translate="yes" xml:space="preserve">
          <source>The corresponding C type must be intnat.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31b0b9138835461b550a52acf6e1102fcf625f54" translate="yes" xml:space="preserve">
          <source>The cost of a &lt;em&gt;primitive&lt;/em&gt;. Primitives encompass operations including arithmetic and memory access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2821dc95f75734aab94e295a923c218e0df1c9bf" translate="yes" xml:space="preserve">
          <source>The cost of a branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c804487a1287d7acc06a19d856642958b1444628" translate="yes" xml:space="preserve">
          <source>The cost of a direct function call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="534cefa77673c331e56e7d9f6dd6b1f2ed24344c" translate="yes" xml:space="preserve">
          <source>The cost of an allocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c86a389e7f94b0cbdc2d7b61509a2068780aa63" translate="yes" xml:space="preserve">
          <source>The cost of an indirect function call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ad4c2d03309e92f9ae01be1d5e41f51136f454b" translate="yes" xml:space="preserve">
          <source>The current default is next-fit, as the best-fit policy is new and not yet widely tested. We expect best-fit to become the default in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b8c08752945457971d1f3f4ac09df0af940d32a" translate="yes" xml:space="preserve">
          <source>The current implementation limits each variant type to have at most 246 non-constant constructors and 2&lt;sup&gt;30&lt;/sup&gt;&amp;minus;1 constant constructors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9a96ae8d528ab0d30d73879bd55f0ed974647fc" translate="yes" xml:space="preserve">
          <source>The current implementation places practically no restrictions on the length of string literals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8888fe7c320796681a86d9fc38d5331494f11ea4" translate="yes" xml:space="preserve">
          <source>The current implementation uses Heap Sort. It runs in constant stack space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa3296295a4df646c086eb4650f57f70f9f85c18" translate="yes" xml:space="preserve">
          <source>The current implementation uses Merge Sort. It runs in constant heap space and logarithmic stack space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5d51df06a97d47df008e45a13c0928311228904" translate="yes" xml:space="preserve">
          <source>The current implementation uses Merge Sort. It uses &lt;code&gt;n/2&lt;/code&gt; words of heap space, where &lt;code&gt;n&lt;/code&gt; is the length of the array. It is usually faster than the current implementation of &lt;a href=&quot;arraylabels#VALsort&quot;&gt;&lt;code&gt;ArrayLabels.sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d71af0bf722f0a317f82d7cfc36b49481534370f" translate="yes" xml:space="preserve">
          <source>The current implementation uses Merge Sort. It uses a temporary array of length &lt;code&gt;n/2&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the length of the array. It is usually faster than the current implementation of &lt;a href=&quot;array#VALsort&quot;&gt;&lt;code&gt;Array.sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6a650f05571190722115be821ddb0eec6d9c2b0" translate="yes" xml:space="preserve">
          <source>The current implementation uses Merge Sort. It uses a temporary array of length &lt;code&gt;n/2&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the length of the array. It is usually faster than the current implementation of &lt;a href=&quot;arraylabels#VALsort&quot;&gt;&lt;code&gt;ArrayLabels.sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdff8609298ac6203743f842126dd2f7ca872714" translate="yes" xml:space="preserve">
          <source>The current implementation uses Merge Sort. It uses a temporary floatarray of length &lt;code&gt;n/2&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the length of the floatarray. It is usually faster than the current implementation of &lt;a href=&quot;float.array#VALsort&quot;&gt;&lt;code&gt;Float.Array.sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43edd4f7fc431695c3b52aadd6a0a76eca47b353" translate="yes" xml:space="preserve">
          <source>The current implementation uses Merge Sort. It uses a temporary floatarray of length &lt;code&gt;n/2&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the length of the floatarray. It is usually faster than the current implementation of &lt;a href=&quot;float.arraylabels#VALsort&quot;&gt;&lt;code&gt;Float.ArrayLabels.sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b20647dbf18c92523a7fd6b83c3b58c9724e3e7a" translate="yes" xml:space="preserve">
          <source>The custom break is useful if you want to change which visible (non-whitespace) characters are printed in case of break or no break. For example, when printing a list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b24549afabe1745d997e15b64b4d2aae161436a" translate="yes" xml:space="preserve">
          <source>The data is considered by the garbage collector alive if all the full keys are alive and if the ephemeron is alive. When one of the keys is not considered alive anymore by the GC, the data is emptied from the ephemeron. The data could be alive for another reason and in that case the GC will not free it, but the ephemeron will not hold the data anymore.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac0854565c0cabc94cf88db7d79f91eea95e9a7c" translate="yes" xml:space="preserve">
          <source>The data part of a custom block v can be accessed via the pointer Data_custom_val(v). This pointer has type void * and should be cast to the actual type of the data stored in the custom block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8e6e6b562a36d00a364c6de4dc0a4ef30f6a91f" translate="yes" xml:space="preserve">
          <source>The debugger can print the current value of simple expressions. The expressions can involve program variables: all the identifiers that are in scope at the selected program point can be accessed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8c3dc260564ad64dea40270472823def2648071" translate="yes" xml:space="preserve">
          <source>The debugger communicate with the program being debugged through a Unix socket. You may need to change the socket name, for example if you need to run the debugger on a machine and your program on another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89cf1e71a9b9ce7771fbb1158aff4c5ec71b350f" translate="yes" xml:space="preserve">
          <source>The debugger execute the OCaml runtime ocamlrun on the program. Rarely useful; moreover it prevents the debugging of programs compiled in &amp;ldquo;custom runtime&amp;rdquo; mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8a4e05ea8e12b749680b25bf9ad4fb77bd551fb" translate="yes" xml:space="preserve">
          <source>The debugger is compatible with the Dynlink module. However, when an external module is not yet loaded, it is impossible to set a breakpoint in its code. In order to facilitate setting breakpoints in dynamically loaded code, the debugger stops the program each time new modules are loaded. This behavior can be disabled using the break_on_load variable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67085f47487648631c3de0d3b7f5a54b54f116e7" translate="yes" xml:space="preserve">
          <source>The debugger searches for source files and compiled interface files in a list of directories, the search path. The search path initially contains the current directory . and the standard library directory. The directory command adds directories to the path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d81bce2c8314b77a05e6061c8832d983f35d9089" translate="yes" xml:space="preserve">
          <source>The debugger starts executing the debugged program only when needed. This allows setting breakpoints or assigning debugger variables before execution starts. There are several ways to start execution:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c85faabbbf8e1f661bc7a77c9db172d2189ae3c" translate="yes" xml:space="preserve">
          <source>The declaration of a variant type lists all possible forms for values of that type. Each case is identified by a name, called a constructor, which serves both for constructing values of the variant type and inspecting them by pattern-matching. Constructor names are capitalized to distinguish them from variable names (which must start with a lowercase letter). For instance, here is a variant type for doing mixed arithmetic (integers and floats):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dc771c421fb48e91d66c641d430796a079c9f9c" translate="yes" xml:space="preserve">
          <source>The declarations of the built-in types and the components of module Stdlib are printed one by one in typewriter font, followed by a short comment. All library modules and the components they provide are indexed at the end of this report.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2765fb82c88da6a8123fcc1afb411e9f247fbfa9" translate="yes" xml:space="preserve">
          <source>The default representation. In the present version of OCaml, the default is the boxed representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74b33452fd1e9690245e62c43fa2151918346419" translate="yes" xml:space="preserve">
          <source>The default setting is &amp;rsquo;auto&amp;rsquo;, and the current heuristic checks that the TERM environment variable exists and is not empty or dumb, and that &amp;rsquo;isatty(stderr)&amp;rsquo; holds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08126df5b12a33c60b2609d1299988ea98c261cf" translate="yes" xml:space="preserve">
          <source>The default setting is -w +a-4-6-7-9-27-29-32..42-44-45-48-50-60. It is displayed by  -help. Note that warnings 5 and 10 are not always triggered, depending on the internals of the type checker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed097a6c98a3e8cb9832ea96755d5d9244c148bd" translate="yes" xml:space="preserve">
          <source>The default setting is -w +a-4-6-7-9-27-29-32..42-44-45-48-50-60. It is displayed by ocamlc -help. Note that warnings 5 and 10 are not always triggered, depending on the internals of the type checker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ab6f8a18cb9ae711fa680c3d32f93edfefbee98" translate="yes" xml:space="preserve">
          <source>The default setting is -w +a-4-6-7-9-27-29-32..42-44-45-48-50-60. It is displayed by ocamlopt -help. Note that warnings 5 and 10 are not always triggered, depending on the internals of the type checker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eff228cd3aa401186be612172c09c21427569b2" translate="yes" xml:space="preserve">
          <source>The default setting is -warn-error -a+31 (only warning 31 is fatal).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8b548e294caad0232bcef920b432423c497646b" translate="yes" xml:space="preserve">
          <source>The default setting is contextual.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4549da8d617844ebcd908e7e44273e838886bca2" translate="yes" xml:space="preserve">
          <source>The default settings (when not using -Oclassic) are for one round of optimisation using the following parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f4796a7bec8a2fd44bd0c64ad6daa008bf2c968" translate="yes" xml:space="preserve">
          <source>The default trace filename is caml-{PID}.eventlog, where {PID} is the process identifier of the traced program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56ba28d4eda458e2debd6c11d3035373c9678204" translate="yes" xml:space="preserve">
          <source>The definition val [mutable] &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; adds an instance variable &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt; whose initial value is the value of expression &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;. The flag mutable allows physical modification of this variable by methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a51442850ae9805c91c304fd05e9989dc50518ce" translate="yes" xml:space="preserve">
          <source>The deserialize field can be set to custom_deserialize_default to indicate that deserialization is not supported. In this case, do not register the struct custom_operations with the deserializer using register_custom_operations (see below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d06ebe0f4fedec527437bd502a65f8f670ba5db" translate="yes" xml:space="preserve">
          <source>The deserialize field contains a pointer to a C function that is called whenever a custom block with identifier identifier needs to be deserialized (un-marshaled) using the OCaml functions input_value or Marshal.from_.... This user-provided function is responsible for reading back the data written by the serialize operation, using the deserialize_... functions defined in &amp;lt;caml/intext.h&amp;gt; and listed below. It must then rebuild the data part of the custom block and store it at the pointer given as the dst argument. Finally, it returns the size in bytes of the data part of the custom block. This size must be identical to the wsize_32 result of the serialize operation if the architecture is 32 bits, or wsize_64 if the architecture is 64 bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e12a3fa498a55d5d0c412779070a2ed53e0f6b56" translate="yes" xml:space="preserve">
          <source>The deterministic automata generated by ocamllex are limited to at most 32767 transitions. The message above indicates that your lexer definition is too complex and overflows this limit. This is commonly caused by lexer definitions that have separate rules for each of the alphabetic keywords of the language, as in the following example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f264a27cdcd5df325cf7076559a44cc284c906a3" translate="yes" xml:space="preserve">
          <source>The deterministic automata generated by ocamllex maintain a table of positions inside the scanned lexer buffer. The size of this table is limited to at most 255 cells. This error should not show up in normal situations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3158707a3751ac6c5252dbe261969b8247c51cac" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;1.0&lt;/code&gt; and the smallest exactly representable floating-point number greater than &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2adcbc0a31dc0085a55ca93ed2f074bdee4bf581" translate="yes" xml:space="preserve">
          <source>The difference between open and include is that open simply provides short names for the components of the opened structure, without defining any components of the current structure, while include also adds definitions for the components of the included structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aa0efd021b346152ef35413cf1dcb66bfc3d8c0" translate="yes" xml:space="preserve">
          <source>The difficulty usually lies in defining instances of the pattern above by inheritance. This can be done in a natural and obvious manner in OCaml, as shown on the following example manipulating windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d9b6c0e1a7cefc1807aceddd0b3961bcb021ba5" translate="yes" xml:space="preserve">
          <source>The directory containing the OCaml standard library. (If OCAMLLIB is not set, CAMLLIB will be used instead.) Used to locate the ld.conf configuration file for dynamic loading (see section &amp;zwj;&lt;a href=&quot;#s%3Aocamlrun-dllpath&quot;&gt;11.3&lt;/a&gt;). If not set, default to the library directory specified when compiling OCaml.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c440f9c47d69da4fc51fae25d28e485866ceeae" translate="yes" xml:space="preserve">
          <source>The directory containing the OCaml standard library. (If OCAMLLIB is not set, CAMLLIB will be used instead.) Used to locate the ld.conf configuration file for dynamic loading (see section &lt;a href=&quot;#s%3Aocamlrun-dllpath&quot;&gt;11.3&lt;/a&gt;). If not set, default to the library directory specified when compiling OCaml.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84d3f5e5913ebfecb51ac69e325978cd0b7f44c0" translate="yes" xml:space="preserve">
          <source>The directory separator (e.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ff406baa499fe8d2e26970180e41618d3f08eae" translate="yes" xml:space="preserve">
          <source>The directory separator (e.g. &lt;code&gt;/&lt;/code&gt; in Unix).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cabc8641d53a500b754d86780ff17e145160ba34" translate="yes" xml:space="preserve">
          <source>The distinction between &lt;code&gt;bytes&lt;/code&gt; and &lt;code&gt;string&lt;/code&gt; was introduced in OCaml 4.02, and the &quot;unsafe-string&quot; compatibility mode was the default until OCaml 4.05. Starting with 4.06, the compatibility mode is opt-in; we intend to remove the option in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8186633942c846dfc9406083eb5c8a8657d3ebba" translate="yes" xml:space="preserve">
          <source>The domain of a coercion can often be omitted. For instance, one can define:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f7c83c21065a6dbadc8d2a47e55b23520a044b2" translate="yes" xml:space="preserve">
          <source>The dump file is written only if the program terminates normally (by calling exit or by falling through). It is not written if the program terminates with an uncaught exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73f7bba6640e6313fca9805d26493bd64599c1bc" translate="yes" xml:space="preserve">
          <source>The dynlink library supports type-safe dynamic loading and linking of bytecode object files (.cmo and .cma files) in a running bytecode program, or of native plugins (usually .cmxs files) in a running native program. Type safety is ensured by limiting the set of modules from the running program that the loaded object file can access, and checking that the running program and the loaded object file have been compiled against the same interfaces for these modules. In native code, there are also some compatibility checks on the implementations (to avoid errors with cross-module optimizations); it might be useful to hide .cmx files when building native plugins so that they remain independent of the implementation of modules in the main program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8d149e1bbd9086296a3979238c337a08c4d4c93" translate="yes" xml:space="preserve">
          <source>The easiest way to define a custom generator is the following this example, here extending the current HTML generator. We don&amp;rsquo;t have to know if this is the original HTML generator defined in ocamldoc or if it has been extended already by a previously loaded custom generator &amp;zwj;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfccb11647d7c3a22dd1b9fca91bf4419d42d590" translate="yes" xml:space="preserve">
          <source>The easiest way to define a custom generator is the following this example, here extending the current HTML generator. We don&amp;rsquo;t have to know if this is the original HTML generator defined in ocamldoc or if it has been extended already by a previously loaded custom generator :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58f055689b02c7748240c0805950d6c0e3a0e111" translate="yes" xml:space="preserve">
          <source>The elements are passed to &lt;code&gt;f&lt;/code&gt; in increasing order with respect to the ordering over the type of the elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6710aa8b225c8ca5f7b41012a718cf1001e66889" translate="yes" xml:space="preserve">
          <source>The else&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt; part can be omitted, in which case it defaults to else().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9282996444b9faf1c947138395efb723dd3e6881" translate="yes" xml:space="preserve">
          <source>The empty map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e51b0d5d7e271c88e867edd7cf3a56d6061ba51" translate="yes" xml:space="preserve">
          <source>The empty sequence, containing no elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ac903ee0be4b8d03c2629dea67dc51a5e1dc555" translate="yes" xml:space="preserve">
          <source>The empty set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcc5ac53238f78e7ccd13efd320b3aba2a2a43c4" translate="yes" xml:space="preserve">
          <source>The environment variable OCAML_COLOR is considered if -color is not provided. Its values are auto/always/never as above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc5a16c0802c0d6eab8dd39659b932cb9d3eeec2" translate="yes" xml:space="preserve">
          <source>The environment variable OCAML_ERROR_STYLE is considered if -error-style is not provided. Its values are short/contextual as above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7f093c02c802f297eef039f1f8ed6be219bfe78" translate="yes" xml:space="preserve">
          <source>The ephemerons complicate the notion of liveness of values, because it is not anymore an equivalence with the reachability from root value by usual pointers (not weak and not ephemerons). With ephemerons the notion of liveness is constructed by the least fixpoint of: A value is alive if:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f38c615e4885039a9f6a96adebc7d8b6a2703f76" translate="yes" xml:space="preserve">
          <source>The equal function for 16-character digest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4745822a26883aa3e079c90a04c121006a19e95e" translate="yes" xml:space="preserve">
          <source>The equal function for chars.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="975faf8015348dfd4f8f27ef557f89666b74bd4f" translate="yes" xml:space="preserve">
          <source>The equal function for floating-point numbers, compared using &lt;a href=&quot;float#VALcompare&quot;&gt;&lt;code&gt;Float.compare&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f25af14cf81fd197468c0aef6ee60036c040bc5" translate="yes" xml:space="preserve">
          <source>The equal function for int32s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43353326c31a51a2e1e40be3cfbc055a576f0c46" translate="yes" xml:space="preserve">
          <source>The equal function for int64s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9acc244879540dd60658943a5fc7d40212cd5702" translate="yes" xml:space="preserve">
          <source>The equal function for native ints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="287fd038b43c08ac15387236db89c8b9dfd89564" translate="yes" xml:space="preserve">
          <source>The equal function for strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a7926a9ee2ed830da3e6706d16691abddc39c2a" translate="yes" xml:space="preserve">
          <source>The equality function for byte sequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af06b8ab4789de98e0de35bd84609d867593cd6b" translate="yes" xml:space="preserve">
          <source>The equality predicate used to compare keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5b330b7afa938d8255dff04d36ee3805387cec6" translate="yes" xml:space="preserve">
          <source>The equivalent of -inline but used when speculative inlining starts at toplevel. See section &lt;a href=&quot;#ss%3Aflambda-speculation&quot;&gt;19.3.6&lt;/a&gt;. Not used in -Oclassic mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83858c6c1566ad5f65edb208e38dd2558053de52" translate="yes" xml:space="preserve">
          <source>The equivalent of -inline but used when speculative inlining starts at toplevel. See section &lt;a href=&quot;#ss%3Aflambda-speculation&quot;&gt;21.3.6&lt;/a&gt;. Not used in -Oclassic mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39ebc7f9bdd19cdd7a118ed9f1944b74ed8a6585" translate="yes" xml:space="preserve">
          <source>The error messages are almost identical to those of ocamlc. See section &amp;zwj;&lt;a href=&quot;comp#s%3Acomp-errors&quot;&gt;9.4&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94cdb8a214ed46b885c25876cd3600fef2503877" translate="yes" xml:space="preserve">
          <source>The error messages are almost identical to those of ocamlc. See section &lt;a href=&quot;comp#s%3Acomp-errors&quot;&gt;9.4&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f378c773556e60ceb5a7a9d15fb2d1a81df83d7" translate="yes" xml:space="preserve">
          <source>The evaluation of the body of a class only takes place at object creation time. Therefore, in the following example, the instance variable x is initialized to different values for two different objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="823e43ea0dd60b51d8777275d399ee78c608b08d" translate="yes" xml:space="preserve">
          <source>The exact definition of which free variables are captured in a closure is not specified and can vary between bytecode and native code (and according to optimization flags). In particular, a function value accessing a global reference may or may not include the reference in its closure. If it does, unmarshaling the corresponding closure will create a new reference, different from the global one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="367c1c92926004568a37375dcb37462e755ae202" translate="yes" xml:space="preserve">
          <source>The execution of a program is affected by certain information it receives when the debugger starts it, such as the command-line arguments to the program and its working directory. The debugger provides commands to specify this information (set arguments and cd). These commands must be used before program execution starts. If you try to change the arguments or the working directory after starting your program, the debugger will kill the program (after asking for confirmation).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="891519fb02f7659ffef41323f18ea6f26295ee67" translate="yes" xml:space="preserve">
          <source>The execution times (CPU times) of a process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea3566383d4d77e6af67a2d9e1c982e58d1aacae" translate="yes" xml:space="preserve">
          <source>The exhaustiveness check is aware of GADT constraints, and can automatically infer that some cases cannot happen. For instance, the following pattern matching is correctly seen as exhaustive (the Add case cannot happen).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="682f2afe18d27a6b2d5109af77f4241c373f09ce" translate="yes" xml:space="preserve">
          <source>The expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48d5ec0634b8a1782837ee8b1ca9761b0c8a2b02" translate="yes" xml:space="preserve">
          <source>The expression (&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;) evaluates to the same module as &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc9adc4308aa68c065cc84caf08fbc1ea795d7aa" translate="yes" xml:space="preserve">
          <source>The expression (&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;:&lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt;) checks that &lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt; matches the type of &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; (that is, that the implementation &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; meets the type specification &lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt;). The whole expression evaluates to the same class as &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;, except that all components not specified in &lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt; are hidden and can no longer be accessed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f1374da867ccabac7aad3663177813cdc0a9fa8" translate="yes" xml:space="preserve">
          <source>The expression (&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;) evaluates to the same module as &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fd1fd31681b7a2cf0269cba7eed69aec7e48ffe" translate="yes" xml:space="preserve">
          <source>The expression (&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;) checks that the type of &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt; is a subtype of &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;, that is, that all components specified in &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt; are implemented in &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;, and their implementation meets the requirements given in &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;. In other terms, it checks that the implementation &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt; meets the type specification &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;. The whole expression evaluates to the same module as &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;, except that all components not specified in &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt; are hidden and can no longer be accessed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bef2d23b52ee970fade1b06935e7b9ced9f528d5" translate="yes" xml:space="preserve">
          <source>The expression (module&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;:&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;) converts the module (structure or functor) denoted by module expression &lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt; to a value of the core language that encapsulates this module. The type of this core language value is (module&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;). The &lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt; annotation can be omitted if it can be inferred from the context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3d05c07c0894d4fd053f92bb2e5d69fce8d15a3" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;#&lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; invokes the method &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; of the object denoted by &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5fe9ec8f9aa27454f205256c37ed9a50e6170e6" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&amp;amp;&amp;amp;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; evaluates to true if both &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; evaluate to true; otherwise, it evaluates to false. The first component, &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, is evaluated first. The second component, &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;, is not evaluated if the first component evaluates to false. Hence, the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&amp;amp;&amp;amp;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; behaves exactly as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67be0419a621a610a2e5884430cdee8308e61e8d" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; ,&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; evaluates to the n-tuple of the values of expressions &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;. The evaluation order of the subexpressions is not specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f82e349965c8472e346c4996f8f13cfaa04ee8f5" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.(&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;) returns the value of element number &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; in the array denoted by &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;. The first element has number 0; the last element has number n&amp;minus;1, where n is the size of the array. The exception Invalid_argument is raised if the access is out of bounds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b86cf48755f90d38c3703b093a559d201d41505d" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.(&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;)&amp;lt;-&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt; modifies in-place the array denoted by &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, replacing element number &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; by the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;. The exception Invalid_argument is raised if the access is out of bounds. The value of the whole expression is ().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82e23d1a40c45b5cca334a602a3b8464c8cb5ac6" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt; evaluates &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to a record value, and returns the value associated to &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt; in this record value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fac0b26bb16a9c0e18d3fa3496db97765aa8519f" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&amp;lt;-&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; evaluates &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to a record value, which is then modified in-place by replacing the value associated to &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt; in this record by the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. This operation is permitted only if &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt; has been declared mutable in the definition of the record type. The whole expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&amp;lt;-&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; evaluates to the unit value ().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cd6fc3dc672a6d7077ed6957a582e1952b94590" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.[&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;] returns the value of character number &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; in the string denoted by &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;. The first character has number 0; the last character has number n&amp;minus;1, where n is the length of the string. The exception Invalid_argument is raised if the access is out of bounds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19a3eefaad7e437247b3bc6db656e1c074dfe4b0" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.[&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;]&amp;lt;-&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt; modifies in-place the string denoted by &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, replacing character number &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; by the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;. The exception Invalid_argument is raised if the access is out of bounds. The value of the whole expression is ().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54bc0bbda0902a87059f4ab52fd17c9a2c5cb0cd" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; evaluates &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; first, then &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;, and returns the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3309f1c657c39dcf14b482d1d2b52b485c6e1c1" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;||&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; evaluates to true if one of the expressions &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; evaluates to true; otherwise, it evaluates to false. The first component, &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, is evaluated first. The second component, &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;, is not evaluated if the first component evaluates to true. Hence, the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;||&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; behaves exactly as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="465cc162397700c3a7233e4d6be2e63f71fde0fe" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;(&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;) evaluates &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to a functor and &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; to a module, and applies the former to the latter. The type of &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; must match the type expected for the arguments of the functor &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e4e8d9bdc0d328e50497d061e05aaaa6759bfe6" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt; evaluates to the class bound to the name &lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt;. Similarly, the expression [&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;]&lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt; evaluates to the parametric class bound to the name &lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt;, in which type parameters have been instantiated respectively to &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88f78fb35dd0d933beef57fab438013880471ef8" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt; is equivalent to the class type bound to the name &lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt;. Similarly, the expression [&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;]&lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt; is equivalent to the parametric class type bound to the name &lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt;, in which type parameters have been instantiated to respectively &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bdccee9cf7f9a846ebb0d6ce9a9a4d063b0d4f4" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;(&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;) evaluates to the variant value whose constructor is &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;, and whose arguments are the values of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd2b0c9502549e5b50e4ab2002a089216e807b74" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; evaluates to the unary variant value whose constructor is &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;, and whose argument is the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. Similarly, the expression &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;(&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; ,&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;) evaluates to the n-ary variant value whose constructor is &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; and whose arguments are the values of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86658bc3c80f7feb554c6583c0fa9ad438f2d77f" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;&amp;lt;-&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; modifies in-place the current object by replacing the value associated to &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt; by the value of &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;. Of course, this instance variable must have been declared mutable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ac13a35707432acbcfeb9a3119c7ad181cc342a" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;names#modtype-path&quot;&gt;modtype-path&lt;/a&gt; is equivalent to the module type bound to the name &lt;a href=&quot;names#modtype-path&quot;&gt;modtype-path&lt;/a&gt;. The expression (&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;) denotes the same type as &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63b697cf7e46dafd21affd4bfc9ae60ca539fafc" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; evaluates to the module bound to the name &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="374fd1d5eec03fb1c40077ef206acff290b1b338" translate="yes" xml:space="preserve">
          <source>The expression [|&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip; ;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;|] evaluates to a n-element array, whose elements are initialized with the values of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; respectively. The order in which these expressions are evaluated is unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e45182f3efd80314e85a55d033c068a05794bdeb" translate="yes" xml:space="preserve">
          <source>The expression `&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; evaluates to the polymorphic variant value whose tag is &lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;, and whose argument is the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7801f0a175513fedc9db3b2ea095ee870659f32" translate="yes" xml:space="preserve">
          <source>The expression does not change the observable state of the world save for possibly affecting the state of the garbage collector by performing an allocation. Expressions that only have generative effects and whose results are unused may be eliminated by the compiler. However, unlike expressions with &amp;ldquo;no effects&amp;rdquo;, such expressions will never be eligible for duplication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06268c11c08cbf54ec4d6dfccb9fea053ea40756" translate="yes" xml:space="preserve">
          <source>The expression does not change the observable state of the world. For example, it must not write to any mutable storage, call arbitrary external functions or change control flow (e.g. by raising an exception). Note that allocation is &lt;em&gt;not&lt;/em&gt; classed as having &amp;ldquo;no effects&amp;rdquo; (see below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54674c43e48502affde9ef34390ab16ef7402518" translate="yes" xml:space="preserve">
          <source>The expression does not observe the effects (in the sense described above) of other expressions. For example, it must not read from any mutable storage or call arbitrary external functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66513182b7246bbaa2fec620bc98c1dc1505d3a1" translate="yes" xml:space="preserve">
          <source>The expression e in let x = e in e&amp;rsquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fafa3e808d29aa326f8219b2a729faf94bb92f2f" translate="yes" xml:space="preserve">
          <source>The expression forname=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;downto&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;do&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;done evaluates similarly, except that name is successively bound to the values n, n&amp;minus;1, &amp;hellip;, p+1, p. The loop body is never evaluated if n &amp;lt; p.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d57f96f2e7c598ac2e5a92cdba5ecd224f400d7" translate="yes" xml:space="preserve">
          <source>The expression forname=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;to&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;do&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;done first evaluates the expressions &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; (the boundaries) into integer values n and p. Then, the loop body &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt; is repeatedly evaluated in an environment where name is successively bound to the values n, n+1, &amp;hellip;, p&amp;minus;1, p. The loop body is never evaluated if n &amp;gt; p.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13ea45faff3269f614a52ad4b80de5d2a8ebf30f" translate="yes" xml:space="preserve">
          <source>The expression fun [[?]&lt;a href=&quot;lex#label-name&quot;&gt;label-name&lt;/a&gt;:] &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;-&amp;gt;&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; evaluates to a function from values to classes. When this function is applied to a value v, this value is matched against the pattern &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt; and the result is the result of the evaluation of &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; in the extended environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a2641611d76e3a4d8e4ffbce3daf0019fe517c9" translate="yes" xml:space="preserve">
          <source>The expression fun(type&lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;)-&amp;gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; introduces a type constructor named &lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt; which is considered abstract in the scope of the sub-expression, but then replaced by a fresh type variable. Note that contrary to what the syntax could suggest, the expression fun(type&lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;)-&amp;gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; itself does not suspend the evaluation of &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; as a regular abstraction would. The syntax has been chosen to fit nicely in the context of function declarations, where it is generally used. It is possible to freely mix regular function parameters with pseudo type parameters, as in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc2f0b7a211a145ce7e8a7301a70f0d4c7d342fe" translate="yes" xml:space="preserve">
          <source>The expression functor(&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;)-&amp;gt;&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt; evaluates to a functor that takes as argument modules of the type &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, binds &lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt; to these modules, evaluates &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt; in the extended environment, and returns the resulting modules as results. No restrictions are placed on the type of the functor argument; in particular, a functor may take another functor as argument (&amp;ldquo;higher-order&amp;rdquo; functor).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39045ca493f5041229a426581d36cb35d6454361" translate="yes" xml:space="preserve">
          <source>The expression if&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;then&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;else&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt; evaluates to the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; if &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; evaluates to the boolean true, and to the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt; if &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; evaluates to the boolean false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cee2fb74666dafe45945b12c3589890b3ad2f7a" translate="yes" xml:space="preserve">
          <source>The expression include&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt; in a structure re-exports in the current structure all definitions of the structure denoted by &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;. For instance, if you define a module S as below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5348485cb90b4b3e0999ac25862d4723d8c8e9d9" translate="yes" xml:space="preserve">
          <source>The expression include&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt; in a signature performs textual inclusion of the components of the signature denoted by &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;. It behaves as if the components of the included signature were copied at the location of the include. The &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt; argument must refer to a module type that is a signature, not a functor type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2aa219207ffe702cd009fe575887afe0cfda1d7" translate="yes" xml:space="preserve">
          <source>The expression is not evaluated this time; notice that &amp;ldquo;lazy_two evaluation&amp;rdquo; is not printed. The result of the initial computation is simply returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d11d633400d5e62d612a20b195ade3fd7ebb41b" translate="yes" xml:space="preserve">
          <source>The expression lazy&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; returns a value v of type Lazy.t that encapsulates the computation of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. The argument &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; is not evaluated at this point in the program. Instead, its evaluation will be performed the first time the function Lazy.force is applied to the value v, returning the actual value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. Subsequent applications of Lazy.force to v do not evaluate &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; again. Applications of Lazy.force may be implicit through pattern matching (see &amp;zwj;&lt;a href=&quot;patterns#sss%3Apat-lazy&quot;&gt;7.6&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bad5791aee2947a352057622227636c6db71ed9" translate="yes" xml:space="preserve">
          <source>The expression lazy&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; returns a value v of type Lazy.t that encapsulates the computation of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. The argument &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; is not evaluated at this point in the program. Instead, its evaluation will be performed the first time the function Lazy.force is applied to the value v, returning the actual value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. Subsequent applications of Lazy.force to v do not evaluate &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; again. Applications of Lazy.force may be implicit through pattern matching (see &lt;a href=&quot;patterns#sss%3Apat-lazy&quot;&gt;7.6&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d836be1d196aa1c9fd598fef8e21c88679d68ac4" translate="yes" xml:space="preserve">
          <source>The expression letmodule&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;=&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;in&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; locally binds the module expression &lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt; to the identifier &lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt; during the evaluation of the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. It then returns the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f314e61bf1988c22719a609f5831e22bbdc7dc32" translate="yes" xml:space="preserve">
          <source>The expression object&lt;a href=&quot;#class-body&quot;&gt;class-body&lt;/a&gt;end denotes a class body. This is the prototype for an object : it lists the instance variables and methods of an object of this class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d92cd34881d32ef8ac6eb5fb33636280b1183b9" translate="yes" xml:space="preserve">
          <source>The expression open&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; in a signature does not specify any components. It simply affects the parsing of the following items of the signature, allowing components of the module denoted by &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; to be referred to by their simple names name instead of path accesses &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.name. The scope of the open stops at the end of the signature expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3374b1493b2b2832203e28fc7202ca2b6bc44cc6" translate="yes" xml:space="preserve">
          <source>The expression open&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; in a structure does not define any components nor perform any bindings. It simply affects the parsing of the following items of the structure, allowing components of the module denoted by &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; to be referred to by their simple names name instead of path accesses &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.name. The scope of the open stops at the end of the structure expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d045a7e48acb78229180ba1f49811e331b9b826a" translate="yes" xml:space="preserve">
          <source>The expression while&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;do&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;done repeatedly evaluates &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; while &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; evaluates to true. The loop condition &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; is evaluated and tested at the beginning of each iteration. The whole while &amp;hellip; done expression evaluates to the unit value ().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7999e39ad27377cd7dc800aeafcf6be489d1e7a" translate="yes" xml:space="preserve">
          <source>The expression {&amp;lt;&lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip; ;&lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;&amp;gt;} evaluates to a copy of the current object in which the values of instance variables &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; have been replaced by the values of the corresponding expressions &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a02ea084f763d805328a3e7ce4d219962ddcb521" translate="yes" xml:space="preserve">
          <source>The expression {&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;with&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; [=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;] ; &amp;hellip; ;&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; [=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;] } builds a fresh record with fields &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; equal to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;, and all other fields having the same value as in the record &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. In other terms, it returns a shallow copy of the record &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;, except for the fields &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;, which are initialized to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;. As previously, single identifier &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; stands for &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;=&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;, a qualified identifier &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; stands for &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;=&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; and it is possible to add an optional type constraint on each field being updated with {&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;with&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip; ;&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;}.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81df39f38d8523b1217ede44454dadcb59a82246" translate="yes" xml:space="preserve">
          <source>The expression {&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; [=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;] ; &amp;hellip; ;&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; [=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;]} evaluates to the record value { field&lt;sub&gt;1&lt;/sub&gt; = v&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip;; field&lt;sub&gt;n&lt;/sub&gt; = v&lt;sub&gt;n&lt;/sub&gt; } where v&lt;sub&gt;i&lt;/sub&gt; is the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; for i = 1,&amp;hellip; , n. A single identifier &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; stands for &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;=&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;, and a qualified identifier &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; stands for &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;=&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;. The fields &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; must all belong to the same record type; each field of this record type must appear exactly once in the record expression, though they can appear in any order. The order in which &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; are evaluated is not specified. Optional type constraints can be added after each field {&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;;&amp;hellip; ;&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;} to force the type of &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; to be compatible with &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="770439db3ff36f7c9028cd337c7098117fa187ed" translate="yes" xml:space="preserve">
          <source>The expressions (&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;) and begin&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;end have the same value as &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. The two constructs are semantically equivalent, but it is good style to use begin &amp;hellip; end inside control structures:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9bf76fd4e9d4e7583a34999f67c07a62a02f933" translate="yes" xml:space="preserve">
          <source>The expressions Field(v, n), Byte(v, n) and Byte_u(v, n) are valid l-values. Hence, they can be assigned to, resulting in an in-place modification of value v. Assigning directly to Field(v, n) must be done with care to avoid confusing the garbage collector (see below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d39a1aaa7be45538447c135e96180858a54150e6" translate="yes" xml:space="preserve">
          <source>The expressions letopen&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;in&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; and &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.(&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;) are strictly equivalent. These constructions locally open the module referred to by the module path &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; in the respective scope of the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1d5d2150f39dd154ec68fa36cfff5333db652cf" translate="yes" xml:space="preserve">
          <source>The external function f is not available</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5f529de453636246288677488101d22e2108e01" translate="yes" xml:space="preserve">
          <source>The field width is composed of an optional integer literal indicating the maximal width of the token to read. For instance, &lt;code&gt;%6d&lt;/code&gt; reads an integer, having at most 6 decimal digits; &lt;code&gt;%4f&lt;/code&gt; reads a float with at most 4 characters; and &lt;code&gt;%8[\000-\255]&lt;/code&gt; returns the next 8 characters (or all the characters still available, if fewer than 8 characters are available in the input).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae52f5d3cbe515efd2a7aaa53a21566c409e073d" translate="yes" xml:space="preserve">
          <source>The file curses_stubs.c can be compiled with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="725c49463cca5a3ec4ded63dc37357ba481599db" translate="yes" xml:space="preserve">
          <source>The file custom.cmo is created and can be used this way &amp;zwj;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9cf1595a49bfb32957e71e1d6050587722d1094" translate="yes" xml:space="preserve">
          <source>The file custom.cmo is created and can be used this way :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="139f2d48257c0343c4b071f4794d59ad6e533fc9" translate="yes" xml:space="preserve">
          <source>The file that ocamlrun is trying to execute (e.g. the file given as first non-option argument to ocamlrun) either does not exist, or is not a valid executable bytecode file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9df79524971faf6930542e99bcb97fb7e6ed0d2f" translate="yes" xml:space="preserve">
          <source>The file that ocamlrun is trying to execute is not a valid executable bytecode file. Probably it has been truncated or mangled since created. Erase and rebuild it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1479d9789eb939b776377dc8d01919fe50c91085" translate="yes" xml:space="preserve">
          <source>The files that define the compilation units can be compiled separately using the ocamlc -c command (the -c option means &amp;ldquo;compile only, do not try to link&amp;rdquo;); this produces compiled interface files (with extension .cmi) and compiled object code files (with extension .cmo). When all units have been compiled, their .cmo files are linked together using the ocamlc command. For instance, the following commands compile and link a program composed of two compilation units Aux and Main:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="218142a8cd84298a616575dd3b1a7d204717b40e" translate="yes" xml:space="preserve">
          <source>The files you can use to define custom generators are installed in the ocamldoc sub-directory of the OCaml standard library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59dbb07f3aaa12eeacf11b0514d46f8f8f33f5ee" translate="yes" xml:space="preserve">
          <source>The finalize field contains a pointer to a C function that is called when the block becomes unreachable and is about to be reclaimed. The block is passed as first argument to the function. The finalize field can also be custom_finalize_default to indicate that no finalization function is associated with the block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db242e09b65549d74785bc5f6a999727dbb33d18" translate="yes" xml:space="preserve">
          <source>The first argument of Store_field and Store_double_field must be a variable declared by CAMLparam* or a parameter declared by CAMLlocal* to ensure that a garbage collection triggered by the evaluation of the other arguments will not invalidate the first argument after it is computed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="483025a84206923192f7c9762bbef7fe0c59cbd8" translate="yes" xml:space="preserve">
          <source>The first case is an exact variant type: all possible tags are known, with their associated types, and they can all be present. Its structure is fully known.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26e2eb8f32164f7d7049d034e263952e663d7410" translate="yes" xml:space="preserve">
          <source>The first case is simple: g is passed ~y and then ~x, but f expects ~x and then ~y. This is correctly handled if we know the type of g to be x:int -&amp;gt; y:int -&amp;gt; int in advance, but otherwise this causes the above type clash. The simplest workaround is to apply formal parameters in a standard order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ddf571ff45a432684168e808086b6b09e060a7b" translate="yes" xml:space="preserve">
          <source>The first declaration is incorrect, because the string literal &lt;code&gt;&quot;hello&quot;&lt;/code&gt; could be shared by the compiler with other parts of the program, and mutating &lt;code&gt;incorrect&lt;/code&gt; is a bug. You must always use the second version, which performs a copy and is thus correct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a8e55f0808e48aad9f2858718bff1a1afbe6952" translate="yes" xml:space="preserve">
          <source>The first form of attributes is attached with a postfix notation on &amp;ldquo;algebraic&amp;rdquo; categories:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c20d4143c725e414a8fe296ef743e273f408fd33" translate="yes" xml:space="preserve">
          <source>The first form of extension node is used for &amp;ldquo;algebraic&amp;rdquo; categories:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e06920ecf0cdfc759a972552119b98dac760381" translate="yes" xml:space="preserve">
          <source>The first non-option argument is taken to be the name of the file containing the executable bytecode. (That file is searched in the executable path as well as in the current directory.) The remaining arguments are passed to the OCaml program, in the string array Sys.argv. Element 0 of this array is the name of the bytecode executable file; elements 1 to n are the remaining arguments arg&lt;sub&gt;1&lt;/sub&gt; to arg&lt;sub&gt;n&lt;/sub&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b219d7a443ce004c101ae67774c3ff8d7838f69" translate="yes" xml:space="preserve">
          <source>The first two cases refer to a value identifier, either unqualified or qualified by the path to the structure that define it. * refers to the result just computed (typically, the value of a function application), and is valid only if the selected event is an &amp;ldquo;after&amp;rdquo; event (typically, a function application). $integer refer to a previously printed value. The remaining four forms select part of an expression: respectively, a record field, an array element, a string element, and the current contents of a reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2239d147af301ebf1848d9c3aed42b025297f0fd" translate="yes" xml:space="preserve">
          <source>The five classes of floating-point numbers, as determined by the &lt;a href=&quot;float#VALclassify_float&quot;&gt;&lt;code&gt;Float.classify_float&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5f4b14dbb83404562f202cb46321bbf598f23f0" translate="yes" xml:space="preserve">
          <source>The five classes of floating-point numbers, as determined by the &lt;a href=&quot;stdlib#VALclassify_float&quot;&gt;&lt;code&gt;classify_float&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="681b526c61bdcee2f004dd7b0da14d09277654dc" translate="yes" xml:space="preserve">
          <source>The flags -Oclassic, -O2 and -O3 are applied before all other flags, meaning that certain parameters may be overridden without having to specify every parameter usually invoked by the given optimisation level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41e4ad6689358b23fa1eb693a69c5cf4c073612a" translate="yes" xml:space="preserve">
          <source>The flags for &lt;a href=&quot;unix#VALrecv&quot;&gt;&lt;code&gt;Unix.recv&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;unix#VALrecvfrom&quot;&gt;&lt;code&gt;Unix.recvfrom&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;unix#VALsend&quot;&gt;&lt;code&gt;Unix.send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;unix#VALsendto&quot;&gt;&lt;code&gt;Unix.sendto&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fd4283b647a522a0c9037980c206ad3a14cfba5" translate="yes" xml:space="preserve">
          <source>The flags for &lt;a href=&quot;unixlabels#VALrecv&quot;&gt;&lt;code&gt;UnixLabels.recv&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;unixlabels#VALrecvfrom&quot;&gt;&lt;code&gt;UnixLabels.recvfrom&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;unixlabels#VALsend&quot;&gt;&lt;code&gt;UnixLabels.send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;unixlabels#VALsendto&quot;&gt;&lt;code&gt;UnixLabels.sendto&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e26b9a410e534dd152b1e84e847e91afe66a6921" translate="yes" xml:space="preserve">
          <source>The flags to &lt;a href=&quot;unix#VALopenfile&quot;&gt;&lt;code&gt;Unix.openfile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92926c8ba910a78b19eb9560e04391f617314f85" translate="yes" xml:space="preserve">
          <source>The flags to &lt;a href=&quot;unixlabels#VALopenfile&quot;&gt;&lt;code&gt;UnixLabels.openfile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da416c9b0c9ec887e3c9fed14c90d2a6cfe00274" translate="yes" xml:space="preserve">
          <source>The flags to the &lt;code&gt;Marshal.to_*&lt;/code&gt; functions below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8910a8a70e1456ec6a90eb77007ffc0da7c2187" translate="yes" xml:space="preserve">
          <source>The floating point 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ab9429d7283ec75f0e02bc07dcd3134a72594e2" translate="yes" xml:space="preserve">
          <source>The floating-point -1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f12a48f02e6b8cb1bc97e090aa405bfffaff9d2" translate="yes" xml:space="preserve">
          <source>The floating-point 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cf650e7443d1e286b4973d2572d41f2dd1c5a71" translate="yes" xml:space="preserve">
          <source>The following bindings for the most common debugger commands are available in the *camldebug-progname* buffer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa8fb8f6579c8a754f8160f2c545902f2c3649f3" translate="yes" xml:space="preserve">
          <source>The following built-in types and predefined exceptions are always defined in the compilation environment, but are not part of any module. As a consequence, they can only be referred by their short names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="741949c165a3e82c7b1f8762527481edfe04447a" translate="yes" xml:space="preserve">
          <source>The following character sequences are also keywords:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34ab75b655a01e99e773cf2e772887f93cd01533" translate="yes" xml:space="preserve">
          <source>The following characters are considered as blanks: space, horizontal tabulation, carriage return, line feed and form feed. Blanks are ignored, but they separate adjacent identifiers, literals and keywords that would otherwise be confused as one single identifier, literal or keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfd936c99ec75ec8467efb2fa73208d1cfd7da18" translate="yes" xml:space="preserve">
          <source>The following command-line options are recognized by ocamlc. The options -pack, -a, -c and -output-obj are mutually exclusive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fe55eff2fce3bd36f31017706fd97b0e53f6496" translate="yes" xml:space="preserve">
          <source>The following command-line options are recognized by ocamldep.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="885f4ff9e5ff4ddb2e7d9854020f77ada3553ef5" translate="yes" xml:space="preserve">
          <source>The following command-line options are recognized by ocamllex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba3896a823e9e144bf0d4b7e1f61010aad966b5f" translate="yes" xml:space="preserve">
          <source>The following command-line options are recognized by ocamlmktop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1edcf650050ceecdfe0b7ab459ca56279ebf0aae" translate="yes" xml:space="preserve">
          <source>The following command-line options are recognized by ocamlopt. The options -pack, -a, -shared, -c and -output-obj are mutually exclusive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f01e63f748272442f586e0dcde7deabec94a1be5" translate="yes" xml:space="preserve">
          <source>The following command-line options are recognized by ocamlrun.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df87076d9fe00726ba61eaa8293d8eef997abd39" translate="yes" xml:space="preserve">
          <source>The following command-line options are recognized by the ocaml command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8652df34978643d1ab214e3a8b1d14afa637e47" translate="yes" xml:space="preserve">
          <source>The following command-line options are recognized:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f87b7161534c08e8f8b2934a7a39ac4e75fe02aa" translate="yes" xml:space="preserve">
          <source>The following commands create the custom.cma file from files file&lt;sub&gt;1&lt;/sub&gt;.ml[i], ..., file&lt;sub&gt;n&lt;/sub&gt;.ml[i] &amp;zwj;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea03de4698c2ebdfac27067880c0104b3ab3bd1f" translate="yes" xml:space="preserve">
          <source>The following commands create the custom.cma file from files file&lt;sub&gt;1&lt;/sub&gt;.ml[i], ..., file&lt;sub&gt;n&lt;/sub&gt;.ml[i] :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ef4512268a1e60220a903be3d8066db5cafc567" translate="yes" xml:space="preserve">
          <source>The following commands display information on checkpoints and events:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d56705239611e41383cc5a0fc4c62ec9ece9f729" translate="yes" xml:space="preserve">
          <source>The following commands execute the program forward or backward, starting at the current time. The execution will stop either when specified by the command or when a breakpoint is encountered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa8b474e507be285882f655940a333fef3ed7e16" translate="yes" xml:space="preserve">
          <source>The following constants are treated like built-in constant constructors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f046204697990bb2d0f4cd47a0f626a4abb10376" translate="yes" xml:space="preserve">
          <source>The following directives control the toplevel behavior, load files in memory, and trace program execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e3f41e76fac899ccc6e7dc6bb71eadc7f7839bf" translate="yes" xml:space="preserve">
          <source>The following environment variables are also consulted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86dc8be3269b92b9232bc979a84ec53ac86636df" translate="yes" xml:space="preserve">
          <source>The following example illustrates how statically-allocated C and Fortran arrays can be made available to OCaml.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b95c269aef6e820286357345f289155493b43dd" translate="yes" xml:space="preserve">
          <source>The following example illustrates the assignment of integers and block tags to constructors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb54e0eb9f74bd676ad11ff69ff7bddb5206be2e" translate="yes" xml:space="preserve">
          <source>The following example of file toto.ml shows where to place comments in a .ml file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb214a3cbe4113b36d77da33d2aad1393c44f7c9" translate="yes" xml:space="preserve">
          <source>The following example shows the passing of a two-dimensional Bigarray to a C function and a Fortran function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28d8c0cb68d2ae92275d2ecc53225fa520b47419" translate="yes" xml:space="preserve">
          <source>The following example uses a private type abbreviation to define a module of nonnegative integers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3ae00605da64b105662093b0c38586124245f33" translate="yes" xml:space="preserve">
          <source>The following example, known as the subject/observer pattern, is often presented in the literature as a difficult inheritance problem with inter-connected classes. The general pattern amounts to the definition a pair of two classes that recursively interact with one another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe79f151ba4780648aa79dae8b08c42dcb70ffa0" translate="yes" xml:space="preserve">
          <source>The following functions are exposed to help write compatible C stubs. To use them, you need to include both &amp;lt;caml/misc.h&amp;gt; and &amp;lt;caml/osdeps.h&amp;gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="832fc1be181c5700f255f7f5cd917c79991599e3" translate="yes" xml:space="preserve">
          <source>The following functions are slightly more efficient than caml_alloc, but also much more difficult to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e63d19b6970bf278c78ca3c011faa62ed74f62ae" translate="yes" xml:space="preserve">
          <source>The following functions can be called from the semantic actions of lexer definitions (the ML code enclosed in braces that computes the value returned by lexing functions). They give access to the character string matched by the regular expression associated with the semantic action. These functions must be applied to the argument &lt;code&gt;lexbuf&lt;/code&gt;, which, in the code generated by &lt;code&gt;ocamllex&lt;/code&gt;, is bound to the lexer buffer passed to the parsing function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45f2a5408f593c266bc5b945e256185ab7faa225" translate="yes" xml:space="preserve">
          <source>The following functions implement the POSIX standard terminal interface. They provide control over asynchronous communication ports and pseudo-terminals. Refer to the &lt;code&gt;termios&lt;/code&gt; man page for a complete description.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04b159ad2babd8305b93430182e2074b26259f77" translate="yes" xml:space="preserve">
          <source>The following functions, defined in &amp;lt;caml/intext.h&amp;gt;, are provided to write and read back the contents of custom blocks in a portable way. Those functions handle endianness conversions when e.g. data is written on a little-endian machine and read back on a big-endian machine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4d76bd017aaace084c2fe4ba75e854a770052fa" translate="yes" xml:space="preserve">
          <source>The following idiom separates description and definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abdd18dbed9ebbfffd9a3d53fecf519fa1b39456" translate="yes" xml:space="preserve">
          <source>The following invariant holds for any file name &lt;code&gt;s&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da4c18672e8270bfb1a76f87b23a373991175930" translate="yes" xml:space="preserve">
          <source>The following language semantics apply specifically to constant float arrays. (By &amp;ldquo;constant float array&amp;rdquo; is meant an array consisting entirely of floating point numbers that are known at compile time. A common case is a literal such as [| 42.0; 43.0; |].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f8a143ee55050d3e9f8c912fc4c49000ef1b06a" translate="yes" xml:space="preserve">
          <source>The following options apply in conjunction with the -dot option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="166817d7c28936e2b423cdda7a6aa67512725a8e" translate="yes" xml:space="preserve">
          <source>The following options apply in conjunction with the -html option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ecf6b7625e3e537050eaf9dc3a7fa22f048e25b" translate="yes" xml:space="preserve">
          <source>The following options apply in conjunction with the -latex option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbc2ec126f36a5f0afa27f31d58d5bda45d9c06d" translate="yes" xml:space="preserve">
          <source>The following options apply in conjunction with the -man option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="051fe64a5d38a370f62ad07eadfb825faac6621f" translate="yes" xml:space="preserve">
          <source>The following options apply in conjunction with the -texi option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d4dbac485d984712c71b7a64c65bc9a132b2436" translate="yes" xml:space="preserve">
          <source>The following options are recognized by ocamlprof:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a846492c1f0c6319e8b3788beab792307a98121" translate="yes" xml:space="preserve">
          <source>The following options determine the format for the generated documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c2e53d36ec19399f7c32f9aac23861dbfe9cf9f" translate="yes" xml:space="preserve">
          <source>The following rules must be respected in order to avoid name clashes resulting in cross-reference errors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="097e045769a0dca8fade64c26d195db8b9414337" translate="yes" xml:space="preserve">
          <source>The following sample interface file foo.mli illustrates the placement rules for comments in .mli files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebfe702602d2495e52da52309ab1711b73354bb5" translate="yes" xml:space="preserve">
          <source>The following table gives the list of predefined @-tags, with their syntax and meaning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd8a8320baafd30cfa4602768ee2151691b2708f" translate="yes" xml:space="preserve">
          <source>The following table lists the precedence level of all operator classes from the highest to the lowest precedence. A few other syntactic constructions are also listed as references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e256f5eaf5d8b81e4043192160908c1bd8faea3" translate="yes" xml:space="preserve">
          <source>The following table summarize what OCaml types can be unboxed, and what C types should be used in correspondence:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef06aa8040c0f03b521f5cef891b934434387cc7" translate="yes" xml:space="preserve">
          <source>The following terminology is used in this chapter of the manual.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1699520402e7ac3828d5b8bcc342d6a427931baa" translate="yes" xml:space="preserve">
          <source>The following two functions are deprecated. Use module &lt;a href=&quot;marshal&quot;&gt;&lt;code&gt;Marshal&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b87aaa89310b1024b8a1a7a3d739748757473aea" translate="yes" xml:space="preserve">
          <source>The form exception&lt;a href=&quot;#constr-decl&quot;&gt;constr-decl&lt;/a&gt; generates a new exception, distinct from all other exceptions in the system. The form exception&lt;a href=&quot;names#constr-name&quot;&gt;constr-name&lt;/a&gt;=&lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; gives an alternate name to an existing exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="098fb8ce1b660c1d46d3db836e055890e6290a74" translate="yes" xml:space="preserve">
          <source>The form external&lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;=&lt;a href=&quot;intfc#external-declaration&quot;&gt;external-declaration&lt;/a&gt; is similar, except that it requires in addition the name to be implemented as the external function specified in &lt;a href=&quot;intfc#external-declaration&quot;&gt;external-declaration&lt;/a&gt; (see chapter &amp;zwj;&lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;18&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b37d1605c59154ddd022186be0bfed3eb3e2b35d" translate="yes" xml:space="preserve">
          <source>The form external&lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;=&lt;a href=&quot;intfc#external-declaration&quot;&gt;external-declaration&lt;/a&gt; is similar, except that it requires in addition the name to be implemented as the external function specified in &lt;a href=&quot;intfc#external-declaration&quot;&gt;external-declaration&lt;/a&gt; (see chapter &lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;20&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3184fd8520491af729727e8e58dedc4128114b17" translate="yes" xml:space="preserve">
          <source>The format of decimal floating-point numbers is &lt;code&gt;&amp;nbsp;[-]&amp;nbsp;dd.ddd&amp;nbsp;(e|E)&amp;nbsp;[+|-]&amp;nbsp;dd&amp;nbsp;&lt;/code&gt;, where &lt;code&gt;d&lt;/code&gt; stands for a decimal digit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7828f8d5d5c611bdddc6c78b6ef04afbcd5d417e" translate="yes" xml:space="preserve">
          <source>The format of hexadecimal floating-point numbers is &lt;code&gt;&amp;nbsp;[-]&amp;nbsp;0(x|X)&amp;nbsp;hh.hhh&amp;nbsp;(p|P)&amp;nbsp;[+|-]&amp;nbsp;dd&amp;nbsp;&lt;/code&gt;, where &lt;code&gt;h&lt;/code&gt; stands for an hexadecimal digit and &lt;code&gt;d&lt;/code&gt; for a decimal digit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="812ca11444f87b91a5c1a4d58c74d93fafa141dc" translate="yes" xml:space="preserve">
          <source>The format of lexer definitions is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="127323cd14f10ff976ce82741602642432da7e75" translate="yes" xml:space="preserve">
          <source>The format string &lt;code&gt;fmt&lt;/code&gt; is a character string which contains three types of objects: plain characters and conversion specifications as specified in the &lt;a href=&quot;printf&quot;&gt;&lt;code&gt;Printf&lt;/code&gt;&lt;/a&gt; module, and pretty-printing indications specific to the &lt;code&gt;Format&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98fb30c95542494775f06815271fe47f1e740e5d" translate="yes" xml:space="preserve">
          <source>The format string is a character string which contains three types of objects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66553eccbf80219caa1c3c646bc08b8b25b163d4" translate="yes" xml:space="preserve">
          <source>The format string is a character string which contains two types of objects: plain characters, which are simply copied to the output channel, and conversion specifications, each of which causes conversion and printing of arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fd14a172518628e19f32be0e91f3d86d102d1cd" translate="yes" xml:space="preserve">
          <source>The formatted input functions can read from any kind of input, including strings, files, or anything that can return characters. The more general source of characters is named a &lt;em&gt;formatted input channel&lt;/em&gt; (or &lt;em&gt; scanning buffer&lt;/em&gt;) and has type &lt;a href=&quot;scanf.scanning#TYPEin_channel&quot;&gt;&lt;code&gt;Scanf.Scanning.in_channel&lt;/code&gt;&lt;/a&gt;. The more general formatted input function reads from any scanning buffer and is named &lt;code&gt;bscanf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e23bc34a1d5333a784d920ce0ee827fd82d18c4c" translate="yes" xml:space="preserve">
          <source>The former alternative is more convenient for the final users of the library, however.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf9a1462b05ebbf56fca1e287e7b7e2870abd6cd" translate="yes" xml:space="preserve">
          <source>The former operator will sometimes fail to coerce an expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; from a type &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to a type &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; even if type &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; is a subtype of type &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;: in the current implementation it only expands two levels of type abbreviations containing objects and/or polymorphic variants, keeping only recursion when it is explicit in the class type (for objects). As an exception to the above algorithm, if both the inferred type of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; and &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt; are ground (&lt;em&gt;i.e.&lt;/em&gt; do not contain type variables), the former operator behaves as the latter one, taking the inferred type of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; as &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;. In case of failure with the former operator, the latter one should be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e62ce70c70537475c1b181d579e82b479775978d" translate="yes" xml:space="preserve">
          <source>The fprintf function is like printf except that it takes an output channel as the first argument. The %a specifier can be useful to define custom printer (for custom types). For instance, we can create a printing template that converts an integer argument to signed decimal:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d13a291c5fa3db94f06d27016206ff693957ed08" translate="yes" xml:space="preserve">
          <source>The front-end is a part of compiler-libs library. Programs that use the compiler-libs library should be built as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0136f8eadbf8d006e647f8e6e794a54dea870bab" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;scanf#VALunescaped&quot;&gt;&lt;code&gt;Scanf.unescaped&lt;/code&gt;&lt;/a&gt; is a left inverse of &lt;code&gt;escaped&lt;/code&gt;, i.e. &lt;code&gt;Scanf.unescaped&amp;nbsp;(escaped&amp;nbsp;s)&amp;nbsp;=&amp;nbsp;s&lt;/code&gt; for any string &lt;code&gt;s&lt;/code&gt; (unless &lt;code&gt;escaped&amp;nbsp;s&lt;/code&gt; fails).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4658f7d95c6ccb485b665c4a8fd77d14df445b99" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;caml_process_pending_actions&lt;/code&gt; from &amp;lt;caml/signals.h&amp;gt; executes any pending signal handlers and finalisers, Memprof callbacks, and requested minor and major garbage collections. In particular, it can raise asynchronous exceptions. It is recommended to call it regularly at safe points inside long-running non-blocking C code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0830c833940b33a13600b2fc8f3c6ec9ed72ba39" translate="yes" xml:space="preserve">
          <source>The function's output is specified by the following invariants:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cc5f117527b2b6ccf3cd9af7823b5af5628418b" translate="yes" xml:space="preserve">
          <source>The function's result is specified by the following invariants:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e123b1399cb46194a1cbce9625fdeb27b778403" translate="yes" xml:space="preserve">
          <source>The functions below are leftovers from an earlier, VM-based threading system. The &lt;a href=&quot;unix&quot;&gt;&lt;code&gt;Unix&lt;/code&gt;&lt;/a&gt; module provides equivalent functionality, in a more general and more standard-conformant manner. It is recommended to use &lt;a href=&quot;unix&quot;&gt;&lt;code&gt;Unix&lt;/code&gt;&lt;/a&gt; functions directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b16f05a4538c91ac60ba6969c4d9b5e686f1d91a" translate="yes" xml:space="preserve">
          <source>The functions from module &lt;a href=&quot;random.state&quot;&gt;&lt;code&gt;Random.State&lt;/code&gt;&lt;/a&gt; manipulate the current state of the random generator explicitly. This allows using one or several deterministic PRNGs, even in a multi-threaded program, without interference from other parts of the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbce52b776ac08f2366078197c98e1659ba43ad5" translate="yes" xml:space="preserve">
          <source>The functions in this module are thread safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="511113955645abe47f0e74cfd8701cd531b7acf8" translate="yes" xml:space="preserve">
          <source>The functions in this section append binary encodings of integers to buffers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="735840deef678499261950948d63f843f78e8b4b" translate="yes" xml:space="preserve">
          <source>The functions in this section binary encode and decode integers to and from byte sequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="692df968d9b76de8295f62a1cc39eca74e7c54e9" translate="yes" xml:space="preserve">
          <source>The functor Client may also be redefined when some new features of the account can be given to the client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23eb5fdacb362f1e019b7a5da5dbe8a3fbb9da5e" translate="yes" xml:space="preserve">
          <source>The functorial interface allows the use of specific comparison and hash functions, either for performance/security concerns, or because keys are not hashable/comparable with the polymorphic builtins.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9842cecf834f807f4e52659d4bb05e758d2b67ff" translate="yes" xml:space="preserve">
          <source>The general formatted input function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39ea5439ffc8a37ae7dfd624fd6123810662e231" translate="yes" xml:space="preserve">
          <source>The generated module defines one parsing function per entry point in the grammar. These functions have the same names as the entry points. Parsing functions take as arguments a lexical analyzer (a function from lexer buffers to tokens) and a lexer buffer, and return the semantic attribute of the corresponding entry point. Lexical analyzer functions are usually generated from a lexer specification by the ocamllex program. Lexer buffers are an abstract data type implemented in the standard library module Lexing. Tokens are values from the concrete type token, defined in the interface file grammar.mli produced by ocamlyacc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2263e6287694d2f2d32e4219ff36b6fad805902" translate="yes" xml:space="preserve">
          <source>The generated trace files are stored using the &lt;em&gt;Common Trace Format&lt;/em&gt;, which is a general purpose binary tracing format. A complete trace consists of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05828d489f6ac2387f6a65167157fb9f23021c22" translate="yes" xml:space="preserve">
          <source>The greatest representable 32-bit integer, 2&lt;sup&gt;31&lt;/sup&gt; - 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a404ad0913817fcb80ea923a9800ed75493e4170" translate="yes" xml:space="preserve">
          <source>The greatest representable 64-bit integer, 2&lt;sup&gt;63&lt;/sup&gt; - 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f471d57c7b55d66ee6fb3224ba15693e2e1e916" translate="yes" xml:space="preserve">
          <source>The greatest representable integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83953d60191eeb31cc3f9a4dc8dba81bf1560d9f" translate="yes" xml:space="preserve">
          <source>The greatest representable native integer, either 2&lt;sup&gt;31&lt;/sup&gt; - 1 on a 32-bit platform, or 2&lt;sup&gt;63&lt;/sup&gt; - 1 on a 64-bit platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e04fd04f5b90806f4bde8e56f9e1f7c424d03265" translate="yes" xml:space="preserve">
          <source>The hash field can be set to custom_hash_default, in which case the custom block is ignored during hash computation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1bdc212a7c36c7cbf75250ae2e9cd081ccee7eb" translate="yes" xml:space="preserve">
          <source>The hash field contains a pointer to a C function that is called whenever OCaml&amp;rsquo;s generic hash operator (see module &lt;a href=&quot;libref/hashtbl&quot;&gt;Hashtbl&lt;/a&gt;) is applied to a custom block. The C function can return an arbitrary integer representing the hash value of the data contained in the given custom block. The hash value must be compatible with the compare function, in the sense that two structurally equal data (that is, two custom blocks for which compare returns 0) must have the same hash value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3784686c2bcba80c99df973ccfa187b6dc78d6d0" translate="yes" xml:space="preserve">
          <source>The hash function for floating-point numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afd0450a8b37538d5ad7af752cb7dc24545ce1f7" translate="yes" xml:space="preserve">
          <source>The header and the trailer sections are OCaml code that is copied as is into file grammar.ml. Both sections are optional. The header goes at the beginning of the output file; it usually contains open directives and auxiliary functions required by the semantic actions of the rules. The trailer goes at the end of the output file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a49035078d6028cf4719edc4791d70f6385a46e" translate="yes" xml:space="preserve">
          <source>The header and trailer sections are arbitrary OCaml text enclosed in curly braces. Either or both can be omitted. If present, the header text is copied as is at the beginning of the output file and the trailer text at the end. Typically, the header section contains the open directives required by the actions, and possibly some auxiliary functions used in the actions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65fb09bbdabd2dfcd32a5c38a54fcbcdf3587281" translate="yes" xml:space="preserve">
          <source>The identifiers below are reserved as keywords, and cannot be employed otherwise:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3cdbac9abe023e77c0d5c1367f0671359c68a73" translate="yes" xml:space="preserve">
          <source>The implementation allows efficient sharing of large numerical arrays between OCaml code and C or Fortran numerical libraries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43b6a822ebb15a95c06ae979273df36acec6ea3c" translate="yes" xml:space="preserve">
          <source>The implementation is checked against the interface file x.mli (if it exists) as described in the manual for ocamlc (chapter &amp;zwj;&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37db43ed15e53d861a8a0109f7b167f500eef59c" translate="yes" xml:space="preserve">
          <source>The implementation is checked against the interface file x.mli (if it exists) as described in the manual for ocamlc (chapter &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0e6ef3c775c3e80317b4caf9ce4c73cd303a6bf" translate="yes" xml:space="preserve">
          <source>The include file &amp;lt;caml/bigarray.h&amp;gt; must be included in the C stub file. It declares the functions, constants and macros discussed below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="535f73d31ed740bfcbb9fa46992a794cf0b8e833" translate="yes" xml:space="preserve">
          <source>The information returned by the &lt;a href=&quot;unix#VALstat&quot;&gt;&lt;code&gt;Unix.stat&lt;/code&gt;&lt;/a&gt; calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dab77f7c802e91039a17f7a96119c9dc7d99b16" translate="yes" xml:space="preserve">
          <source>The information returned by the &lt;a href=&quot;unixlabels#VALstat&quot;&gt;&lt;code&gt;UnixLabels.stat&lt;/code&gt;&lt;/a&gt; calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="432250b262611d097e3c2e7a360d5606d16533ba" translate="yes" xml:space="preserve">
          <source>The inheritance construct inherit&lt;a href=&quot;#class-body-type&quot;&gt;class-body-type&lt;/a&gt; provides for inclusion of methods and instance variables from other class types. The instance variable and method types from &lt;a href=&quot;#class-body-type&quot;&gt;class-body-type&lt;/a&gt; are added into the current class type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a6f2342a82527fef9c1f1e57a822b49fe405407" translate="yes" xml:space="preserve">
          <source>The inheritance construct inherit&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; allows reusing methods and instance variables from other classes. The class expression &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; must evaluate to a class body. The instance variables, methods and initializers from this class body are added into the current class. The addition of a method will override any previously defined method of the same name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6a4c6ce7609b4fdb581947deed89b2c406dd7c0" translate="yes" xml:space="preserve">
          <source>The initial benefit value is then scaled by a factor that attempts to compensate for the fact that the current point in the code, if under some number of conditional branches, may be cold. (Flambda does not currently compute hot and cold paths.) The factor&amp;mdash;the estimated probability that the inliner really is on a &lt;em&gt;hot&lt;/em&gt; path&amp;mdash;is calculated as 1/(1 + f)&lt;sup&gt;d&lt;/sup&gt;, where f is set by -inline-branch-factor and d is the nesting depth of branches at the current point. As the inliner descends into more deeply-nested branches, the benefit of inlining thus lessens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="605d70d1e078307745dd48e9410e6df59a2d38ed" translate="yes" xml:space="preserve">
          <source>The initial size of the major heap (in words).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d19155151a59efc551f6b49f7c9952f00e4278ab" translate="yes" xml:space="preserve">
          <source>The inliner is directed using attributes. For non-recursive functions (and one-step unrolling of recursive functions, although @unroll is more clear for this purpose) the following are supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec62c15f868750119abec49b24817b3f70272bf1" translate="yes" xml:space="preserve">
          <source>The inliner may discover a call site to a recursive function where something is known about the arguments: for example, they may be equal to some other variables currently in scope. In this situation it may be beneficial to &lt;em&gt;specialise&lt;/em&gt; the function to those arguments. This is done by copying the declaration of the function (and any others involved in any same mutually-recursive declaration) and noting the extra information about the arguments. The arguments augmented by this information are known as &lt;em&gt;specialised arguments&lt;/em&gt;. In order to try to ensure that specialisation is not performed uselessly, arguments are only specialised if it can be shown that they are &lt;em&gt;invariant&lt;/em&gt;: in other words, during the execution of the recursive function(s) themselves, the arguments never change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c51b8b56bbf10eb40d95b1f8d06cf0bb2a8da17" translate="yes" xml:space="preserve">
          <source>The inliner will be able to consider inlining a call to a function in a first class module if it knows which particular function is going to be called. The presence of the first-class module record that wraps the set of functions in the module does not per se inhibit inlining.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f97af2287565035553d926928c75a2ecba69b6f2" translate="yes" xml:space="preserve">
          <source>The inlining depth starts at zero and is increased by one every time the inliner descends into another function. It is then decreased by one every time the inliner leaves such function. If the depth exceeds the value set by -inline-max-depth then speculation stops. This parameter is intended as a general backstop for situations where the inlining threshold does not control the search sufficiently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fef85946e0fcf5a71d076de458a459e1642b8d5" translate="yes" xml:space="preserve">
          <source>The input signature of the functor &lt;a href=&quot;hashtbl.make&quot;&gt;&lt;code&gt;Hashtbl.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06d18381a5748615e440710ac855b1a56b9c2889" translate="yes" xml:space="preserve">
          <source>The input signature of the functor &lt;a href=&quot;hashtbl.makeseeded&quot;&gt;&lt;code&gt;Hashtbl.MakeSeeded&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da597a43f328dc2efe7fbdb2804af861660747d2" translate="yes" xml:space="preserve">
          <source>The input signature of the functor &lt;a href=&quot;morelabels.hashtbl.make&quot;&gt;&lt;code&gt;MoreLabels.Hashtbl.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="370d3ad23a4b2f90badc6bea26dfa703f32c6590" translate="yes" xml:space="preserve">
          <source>The input signature of the functor &lt;a href=&quot;morelabels.hashtbl.makeseeded&quot;&gt;&lt;code&gt;MoreLabels.Hashtbl.MakeSeeded&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95c572128ac8d5e1df8128cf0a673f5f91f32169" translate="yes" xml:space="preserve">
          <source>The inside of documentation comments (**&amp;hellip;*) consists of free-form text with optional formatting annotations, followed by optional &lt;em&gt;tags&lt;/em&gt; giving more specific information about parameters, version, authors, &amp;hellip; The tags are distinguished by a leading @ character. Thus, a documentation comment has the following shape:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="148efbe2c3192ef6b3c2f5ce513345372f5ff8d7" translate="yes" xml:space="preserve">
          <source>The instance variables of a class are visible only in the body of the methods defined in the same class or a class that inherits from the class defining the instance variables. The expression &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt; evaluates to the value of the given instance variable. The expression &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;&amp;lt;-&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; assigns the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; to the instance variable &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;, which must be mutable. The whole expression &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;&amp;lt;-&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; evaluates to ().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1983ba3b3cbd666c6b286b10b7424eaa8d46d8e4" translate="yes" xml:space="preserve">
          <source>The instrumentation that afl-fuzz requires is not generated by default, and must be explicitly enabled, by passing the -afl-instrument option to ocamlopt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c38a45a391c534fde7023ac64ba050bd0bfc352" translate="yes" xml:space="preserve">
          <source>The instrumented runtime aims to provide insight into the runtime&amp;rsquo;s execution while maintaining a low overhead. However, this overhead may become more noticeable depending on how a program executes. The instrumented runtime currently puts a strong emphasis on tracing &lt;em&gt;garbage collection&lt;/em&gt; events. This means that programs with heavy garbage collection activity may be more susceptible to tracing induced performance penalties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c752c8999051d42387c90e33a51fa248e92151ee" translate="yes" xml:space="preserve">
          <source>The instrumented runtime can also be used with the OCaml bytecode interpreter. This can be done by either using the -runtime-variant=i flag when linking the program with ocamlc, or by running the generated bytecode through ocamlruni:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdd8c2054ca56fa61b478da767e7a87b2d4b4462" translate="yes" xml:space="preserve">
          <source>The instrumented runtime does not support the fork system call. A child process forked from an instrumented program will not be traced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83cc8fe30284169270dc9bfd2599a1edfd3403c6" translate="yes" xml:space="preserve">
          <source>The integer in a &lt;code&gt;width&lt;/code&gt; or &lt;code&gt;precision&lt;/code&gt; can also be specified as &lt;code&gt;*&lt;/code&gt;, in which case an extra integer argument is taken to specify the corresponding &lt;code&gt;width&lt;/code&gt; or &lt;code&gt;precision&lt;/code&gt;. This integer argument precedes immediately the argument to print. For instance, &lt;code&gt;%.*f&lt;/code&gt; prints a &lt;code&gt;float&lt;/code&gt; with as many fractional digits as the value of the argument given before the float.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b15dd3f5ba2129587d0969abe183388bad06fc4" translate="yes" xml:space="preserve">
          <source>The interface of a class can also be specified in a module signature, and used to restrict the inferred signature of a module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="105395de5f7d644b47550655e63b2ed02fcd3fdf" translate="yes" xml:space="preserve">
          <source>The keys and data of an ephemeron are said to be full if they point to a value, or empty if the value has never been set, has been unset, or was erased by the GC. In the function that accesses the keys or data these two states are represented by the &lt;code&gt;option&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6634b8f0a482d759792ec8ca2ac4ce6773a03e6f" translate="yes" xml:space="preserve">
          <source>The keyword as in that type binds the type variable 'a to the object type &amp;lt; .. &amp;gt;. Therefore, Oo.copy takes an object with any methods (represented by the ellipsis), and returns an object of the same type. The type of Oo.copy is different from type &amp;lt; .. &amp;gt; -&amp;gt; &amp;lt; .. &amp;gt; as each ellipsis represents a different set of methods. Ellipsis actually behaves as a type variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26d04af0b9de3d4d2a72eb74f835f5f6f6e937e3" translate="yes" xml:space="preserve">
          <source>The keywords - and -. can appear both as infix and prefix operators. When they appear as prefix operators, they are interpreted respectively as the functions (~-) and (~-.).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63ad31bd653530cc49e2890ef110e7033521237a" translate="yes" xml:space="preserve">
          <source>The kind of array elements is one of the following constants:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a967e2a530696f236a7ac2ee23ef626eeebebbd" translate="yes" xml:space="preserve">
          <source>The labeled version of this module can be used as described in the &lt;a href=&quot;stdlabels&quot;&gt;&lt;code&gt;StdLabels&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad467b38d8db4456aa825c50933b9ea245ee8d05" translate="yes" xml:space="preserve">
          <source>The language accepts external declarations with one or two flag strings in addition to the C function&amp;rsquo;s name. These flags are reserved for the implementation of the standard library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8cdc3190f510239fa37ad383f7499bbcfcecc73" translate="yes" xml:space="preserve">
          <source>The largest positive finite value of type &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b02fd4b3ae9e22d2aa52705a920bd39b960133e" translate="yes" xml:space="preserve">
          <source>The last two entries are valid for any n &amp;gt; 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="411f2ed0253bd263770b7a506015d3b73acb28b7" translate="yes" xml:space="preserve">
          <source>The latter is slightly more efficient, as it allows clients of the module to call directly the C function instead of going through the corresponding OCaml function. On the other hand, it should not be used in library modules if they have side-effects at toplevel, as this direct call interferes with the linker&amp;rsquo;s algorithm for removing unused modules from libraries at link-time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0d5230f60bcbec268122dc0a17e6710399bb6df" translate="yes" xml:space="preserve">
          <source>The lazy expression lazy_expr is forced only if the lazy_guard value yields true once computed. Indeed, a simple wildcard pattern (not lazy) never forces the lazy expression&amp;rsquo;s evaluation. However, a pattern with keyword lazy, even if it is wildcard, always forces the evaluation of the deferred computation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfa4f4b740be36ff7f795509d500d37f7af78f8b" translate="yes" xml:space="preserve">
          <source>The legacy bigarray library bundled with the compiler is a compatibility library with exactly the same interface as before, i.e. with map_file included.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c3cccf18cbaa6ce05baa77a874dea7a1d1ade41" translate="yes" xml:space="preserve">
          <source>The let and let rec constructs bind value names locally, as for the core language expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a230275b7985703b310f49dd04772a11ba7b81ae" translate="yes" xml:space="preserve">
          <source>The let and letrec constructs bind value names locally. The construct</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a7c897adf765ad531b54431abd748cbea11f170" translate="yes" xml:space="preserve">
          <source>The list is not empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e80da8bc0045d539fc55b1771c12707e1366c643" translate="yes" xml:space="preserve">
          <source>The list of options, each followed by the corresponding &lt;code&gt;doc&lt;/code&gt; string. Beware: options that have an empty &lt;code&gt;doc&lt;/code&gt; string will not be included in the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37a09eb76bbb9dc4b8871dbc8586b6f3b99c21f6" translate="yes" xml:space="preserve">
          <source>The list of possible syntactic class is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7119efad1f349c18d670dab6d20261e060049541" translate="yes" xml:space="preserve">
          <source>The loadingmode variable controls how the program is executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15f3b2280a23c9730e0ae9df7fd26ba354827556" translate="yes" xml:space="preserve">
          <source>The macros CAMLlocal1 to CAMLlocal5 declare and initialize one to five local variables of type value. The variable names are given as arguments to the macros. CAMLlocalN(x, n) declares and initializes a local variable of type value [n]. You can use several calls to these macros if you have more than 5 local variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aaef768b1af4841714c0865edff6a7e10553a66" translate="yes" xml:space="preserve">
          <source>The macros CAMLreturn, CAMLreturn0, and CAMLreturnT are used to replace the C keyword return. Every occurrence of return x must be replaced by CAMLreturn (x) if x has type value, or CAMLreturnT (t, x) (where t is the type of x); every occurrence of return without argument must be replaced by CAMLreturn0. If your C function is a procedure (i.e. if it returns void), you must insert CAMLreturn0 at the end (to replace C&amp;rsquo;s implicit return).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="885b3218ec0a809028025c650e9f6b490326927a" translate="yes" xml:space="preserve">
          <source>The main advantage of dynamic linking is that it preserves the platform-independence of bytecode executables. That is, the bytecode executable contains no machine code, and can therefore be compiled on platform A and executed on other platforms B, C, &amp;hellip;, as long as the required shared libraries are available on all these platforms. In contrast, executables generated by ocamlc -custom run only on the platform on which they were created, because they embark a custom-tailored runtime system specific to that platform. In addition, dynamic linking results in smaller executables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31c9f9893f98dd3b2cb21409e3d29c4b1dc69b68" translate="yes" xml:space="preserve">
          <source>The main differences between 'Bigarrays' and standard OCaml arrays are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fcf71e83dbbe5bf7b82af138897c5021410d4ef" translate="yes" xml:space="preserve">
          <source>The major GC speed is computed from this parameter. This is the memory that will be &quot;wasted&quot; because the GC does not immediately collect unreachable blocks. It is expressed as a percentage of the memory used for live data. The GC will work more (use more CPU time and collect blocks more eagerly) if &lt;code&gt;space_overhead&lt;/code&gt; is smaller. Default: 80.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ac087e4dec98a5d96dc10610c38149e487d9d82" translate="yes" xml:space="preserve">
          <source>The maximum depth of any speculative inlining search. See section &lt;a href=&quot;#ss%3Aflambda-speculation&quot;&gt;19.3.6&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30da6783cb2d914f60ad876ac28283601a269030" translate="yes" xml:space="preserve">
          <source>The maximum depth of any speculative inlining search. See section &lt;a href=&quot;#ss%3Aflambda-speculation&quot;&gt;21.3.6&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52589afb28fd3716e0f6369cc78e02af38779e60" translate="yes" xml:space="preserve">
          <source>The maximum depth of any unrolling of recursive functions during any speculative inlining search. See section &lt;a href=&quot;#ss%3Aflambda-speculation&quot;&gt;19.3.6&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14b6f2abfdc332a11cef59acff883ca20f69b025" translate="yes" xml:space="preserve">
          <source>The maximum depth of any unrolling of recursive functions during any speculative inlining search. See section &lt;a href=&quot;#ss%3Aflambda-speculation&quot;&gt;21.3.6&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6537d7fb4312afbfc14faa7b11bce9479277bccc" translate="yes" xml:space="preserve">
          <source>The maximum formatting depth is the maximum number of pretty-printing boxes simultaneously open.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa16112992d556366d6be6ead64cb5e2ddc5d021" translate="yes" xml:space="preserve">
          <source>The maximum size of the stack (in words). This is only relevant to the byte-code runtime, as the native code runtime uses the operating system's stack. Default: 1024k.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dcda863ccacea505bd2a294ce1ed4f2df1932a4" translate="yes" xml:space="preserve">
          <source>The meaning of format string type parameters is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="290889214c915b5911f3b92719bce41512c0c609" translate="yes" xml:space="preserve">
          <source>The memory layout of Bigarrays is entirely compatible with that of arrays in C and Fortran, allowing large arrays to be passed back and forth between OCaml code and C / Fortran code with no data copying at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db529abafebd1568315a8328ddaf314170689aa7" translate="yes" xml:space="preserve">
          <source>The memory management counters are returned in a &lt;code&gt;stat&lt;/code&gt; record.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4a3b03ef777eb26c6ae028dd5d106d607d702a8" translate="yes" xml:space="preserve">
          <source>The metadata file is available in the OCaml installation. Its location can be obtained using the following command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e072a2bbaafe77d3313822b37614800d154b59ef" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt; provides formatted input functions or &lt;em&gt;scanners&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98dc8a81338816e727b183ae8835ac70814be748" translate="yes" xml:space="preserve">
          <source>The module type expression functor(&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;)-&amp;gt;&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; is the type of functors (functions from modules to modules) that take as argument a module of type &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and return as result a module of type &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. The module type &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; can use the name &lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt; to refer to type components of the actual argument of the functor. If the type &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; does not depend on type components of &lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;, the module type expression can be simplified with the alternative short syntax &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;-&amp;gt;&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; . No restrictions are placed on the type of the functor argument; in particular, a functor may take another functor as argument (&amp;ldquo;higher-order&amp;rdquo; functor).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19e87897038acb2ea0b22d40eb32fcf01d0bb4bf" translate="yes" xml:space="preserve">
          <source>The most common usage of variant types is to describe recursive data structures. Consider for example the type of binary trees:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c5e4a5c67b4d7db566f82e81b3b0733b0a71933" translate="yes" xml:space="preserve">
          <source>The most user-friendly way to use the debugger is to run it under Emacs with the OCaml mode available through MELPA and also at &lt;a href=&quot;https://github.com/ocaml/caml-mode&quot;&gt;https://github.com/ocaml/caml-mode&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="969c39463cdd83094435d7ff5442eba358f5bbab" translate="yes" xml:space="preserve">
          <source>The most user-friendly way to use the debugger is to run it under Emacs. See the file emacs/README in the distribution for information on how to load the Emacs Lisp files for OCaml support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78aad986fb7a4eb2c56f1239f1a0ea9f7c757987" translate="yes" xml:space="preserve">
          <source>The motivation is that, by letting &amp;lsquo;ocamlopt&amp;lsquo; deal with boxing, it can often decide to suppress it entirely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e080b5bf8fc37b589b95288dd439c400c34b427b" translate="yes" xml:space="preserve">
          <source>The multiplier is k, M, or G, for multiplication by 2&lt;sup&gt;10&lt;/sup&gt;, 2&lt;sup&gt;20&lt;/sup&gt;, and 2&lt;sup&gt;30&lt;/sup&gt; respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5001d83b2b93aa689b354ed2086458f2935a047" translate="yes" xml:space="preserve">
          <source>The name of the file containing the executable currently running.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59eca0c39d17cb0f2108d6d77b193b119b04559b" translate="yes" xml:space="preserve">
          <source>The name of the file containing the executable currently running. This name may be absolute or relative to the current directory, depending on the platform and whether the program was compiled to bytecode or a native executable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf0030b90670a18e3de17304172d5e4c928be425" translate="yes" xml:space="preserve">
          <source>The name of the initial temporary directory: Under Unix, the value of the &lt;code&gt;TMPDIR&lt;/code&gt; environment variable, or &quot;/tmp&quot; if the variable is not set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c8b8d9700396ab187abf8b0e62dcd1c6f319473" translate="yes" xml:space="preserve">
          <source>The name of the initial temporary directory: Under Unix, the value of the &lt;code&gt;TMPDIR&lt;/code&gt; environment variable, or &quot;/tmp&quot; if the variable is not set. Under Windows, the value of the &lt;code&gt;TEMP&lt;/code&gt; environment variable, or &quot;.&quot; if the variable is not set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c9a52823f32936b8fa5faaa814adee980e5c3ce" translate="yes" xml:space="preserve">
          <source>The name of the temporary directory: Under Unix, the value of the &lt;code&gt;TMPDIR&lt;/code&gt; environment variable, or &quot;/tmp&quot; if the variable is not set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd4c9b92bb5cafc665608d7e7c71ee74b72bd3e4" translate="yes" xml:space="preserve">
          <source>The name of the temporary directory: Under Unix, the value of the &lt;code&gt;TMPDIR&lt;/code&gt; environment variable, or &quot;/tmp&quot; if the variable is not set. Under Windows, the value of the &lt;code&gt;TEMP&lt;/code&gt; environment variable, or &quot;.&quot; if the variable is not set. The temporary directory can be changed with &lt;a href=&quot;filename#VALset_temp_dir_name&quot;&gt;&lt;code&gt;Filename.set_temp_dir_name&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80a92c6fec8ac40ba4e0c4025b59dde0b751953a" translate="yes" xml:space="preserve">
          <source>The named file could not be found in the current directory, nor in the directories of the search path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="952b3090c265f73e61fb891aab443a8262a5704d" translate="yes" xml:space="preserve">
          <source>The named file could not be found in the current directory, nor in the directories of the search path. The filename is either a compiled interface file (.cmi file), or a compiled bytecode file (.cmo file). If filename has the format mod.cmi, this means you are trying to compile a file that references identifiers from module mod, but you have not yet compiled an interface for module mod. Fix: compile mod.mli or mod.ml first, to create the compiled interface mod.cmi.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2f02d60d1e116f8243f8229b3fd568a95c8a809" translate="yes" xml:space="preserve">
          <source>The names of the entry points must be valid identifiers for OCaml values (starting with a lowercase letter). Similarly, the arguments arg&lt;sub&gt;1&lt;/sub&gt;&amp;hellip; arg&lt;sub&gt;n&lt;/sub&gt; must be valid identifiers for OCaml. Each entry point becomes an OCaml function that takes n+1 arguments, the extra implicit last argument being of type Lexing.lexbuf. Characters are read from the Lexing.lexbuf argument and matched against the regular expressions provided in the rule, until a prefix of the input matches one of the rule. The corresponding action is then evaluated and returned as the result of the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5ca4780e331ea88692f3bab8f908b1e857d3545" translate="yes" xml:space="preserve">
          <source>The names of the two C functions must be given in the primitive declaration, as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2af38c50738eb4e1ac67f27fb83521c12f9da713" translate="yes" xml:space="preserve">
          <source>The native C character type under Windows is WCHAR, two bytes wide, while under Unix it is char, one byte wide. A type char_os is defined in &amp;lt;caml/misc.h&amp;gt; that stands for the concrete C character type of each platform. Strings in the platform encoding are of type char_os *.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="376053bbccd9cdcd8890b3fbdf88ead49637bae1" translate="yes" xml:space="preserve">
          <source>The native integer -1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ee1fc5518ff6fbf2992ed7e1ec40186e53f6653" translate="yes" xml:space="preserve">
          <source>The native integer 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bcc40875771e327d2f0e7c0fa203d846f93e6b4" translate="yes" xml:space="preserve">
          <source>The native integer 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c20da3e1fe2cd472edcbc03735391872edbfb80" translate="yes" xml:space="preserve">
          <source>The native-code compiler is only available on certain platforms. It produces code that runs faster than the bytecode produced by ocamlc, at the cost of increased compilation time and executable code size. Compatibility with the bytecode compiler is extremely high: the same source code should run identically when compiled with ocamlc and ocamlopt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e5e7155dfdf15208a1cbe9f526ab06c992a1a3c" translate="yes" xml:space="preserve">
          <source>The native-code compiler ocamlopt also supports the -output-obj option, causing it to output a C object file or a shared library containing the native code for all OCaml modules on the command-line, as well as the OCaml startup code. Initialization is performed by calling caml_startup (or caml_startup_exn) as in the case of the bytecode compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36be14bc239e78c132c193d0ff0e16beb22b0661" translate="yes" xml:space="preserve">
          <source>The native-code compiler performs a number of optimizations that the bytecode compiler does not perform, especially when the Flambda optimizer is active. In particular, the native-code compiler identifies and eliminates &amp;ldquo;dead code&amp;rdquo;, i.e. computations that do not contribute to the results of the program. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f90676a471e21697a3a109feb2073705f4c086a3" translate="yes" xml:space="preserve">
          <source>The next allocation can trigger a garbage collection. The garbage collector assumes that all structured blocks contain well-formed values. Newly created blocks contain random data, which generally do not represent well-formed values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33f94342d426b6ca7b5a6cd5848192a5418df90c" translate="yes" xml:space="preserve">
          <source>The next step is to compile and link the program with the instrumented runtime. This can be done by using the -runtime-variant flag:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbe1c650255dd39febc517d8d6e9ecf4a27a4e50" translate="yes" xml:space="preserve">
          <source>The notion of input channel for the &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt; module: those channels provide all the machinery necessary to read from any source of characters, including a &lt;a href=&quot;stdlib#TYPEin_channel&quot;&gt;&lt;code&gt;in_channel&lt;/code&gt;&lt;/a&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16542651eb8af79575740dab6d97e5baeedd8889" translate="yes" xml:space="preserve">
          <source>The notion of input channel for the &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt; module: those channels provide all the machinery necessary to read from any source of characters, including a &lt;a href=&quot;stdlib#TYPEin_channel&quot;&gt;&lt;code&gt;in_channel&lt;/code&gt;&lt;/a&gt; value. A Scanf.Scanning.in_channel value is also called a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc0369bec5d64b7e5ca44539b36eca9c14402a44" translate="yes" xml:space="preserve">
          <source>The num library implements integer arithmetic and rational arithmetic in arbitrary precision. It was split off the core OCaml distribution starting with the 4.06.0 release, and can now be found at &lt;a href=&quot;https://github.com/ocaml/num&quot;&gt;https://github.com/ocaml/num&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0976e8b95aee4f6b6b94a903578443416a16fd1d" translate="yes" xml:space="preserve">
          <source>The number of samples in this block (&amp;gt;= 1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80c5921664757a5de49c34516dd5a9044bf527fa" translate="yes" xml:space="preserve">
          <source>The object type c0 is an abbreviation for &amp;lt;m : 'a; n : int&amp;gt; as 'a. Consider now the type declaration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4798644a1b3b83b3464a016d6b7ad72bf5f4632" translate="yes" xml:space="preserve">
          <source>The object type c1 is an abbreviation for the type &amp;lt;m : 'a&amp;gt; as 'a. The coercion from an object of type c0 to an object of type c1 is correct:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e56b5bcc7c0be28d1a5ad641e4581f9a06b6925" translate="yes" xml:space="preserve">
          <source>The ocaml.alert or alert attribute serves two purposes: (i) to mark component with an alert to be triggered when the component is referenced, and (ii) to control which alert names are enabled. In the first form, the attribute takes an identifier possibly followed by a message. Here is an example of a value declaration marked with an alert:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="663c4b2feb0ff61316e473a7d7058b8a8ac77602" translate="yes" xml:space="preserve">
          <source>The ocamlc command has a command-line interface similar to the one of most C compilers. It accepts several types of arguments and processes them sequentially, after all options have been processed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ccd15521b1aa9660fdf126df14cf7897ed7444c" translate="yes" xml:space="preserve">
          <source>The ocamlcp and ocamloptp commands also accept all the options of the corresponding ocamlc or ocamlopt compiler, except the -pp (preprocessing) option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa91a0c172cde52b6822b93be7514538cd75d072" translate="yes" xml:space="preserve">
          <source>The ocamldep command scans a set of OCaml source files (.ml and .mli files) for references to external compilation units, and outputs dependency lines in a format suitable for the make utility. This ensures that make will compile the source files in the correct order, and recompile those files that need to when a source file is modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bc0cf38a6832c2cb08c4085b324377b241b03c6" translate="yes" xml:space="preserve">
          <source>The ocamllex command produces a lexical analyzer from a set of regular expressions with attached semantic actions, in the style of lex. Assuming the input file is lexer.mll, executing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="785a09dfb0b7bb6413c4e50f2cabd1b69c63c6b4" translate="yes" xml:space="preserve">
          <source>The ocamlmklib command facilitates the construction of libraries containing both OCaml code and C code, and usable both in static linking and dynamic linking modes. This command is available under Windows since Objective Caml 3.11 and under other operating systems since Objective Caml 3.03.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37782ee3b2232fe93bbe77ca370d4160e2021dd2" translate="yes" xml:space="preserve">
          <source>The ocamlmklib command takes three kinds of arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68dd5d1772fdc70b18042e2faf73bb6d263b83ef" translate="yes" xml:space="preserve">
          <source>The ocamlmktop command builds OCaml toplevels that contain user code preloaded at start-up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6831997e14580584458639904bb3e8b4303221cf" translate="yes" xml:space="preserve">
          <source>The ocamlmktop command takes as argument a set of .cmo and .cma files, and links them with the object files that implement the OCaml toplevel. The typical use is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab3cce8e0848dae6978b901dc63aa4ea6c79e945" translate="yes" xml:space="preserve">
          <source>The ocamlopt command has a command-line interface very close to that of ocamlc. It accepts the same types of arguments, and processes them sequentially, after all options have been processed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f43adb44cad300b255a2ab339a13959b026d322" translate="yes" xml:space="preserve">
          <source>The ocamlprof command produces a source listing of the program modules where execution counts have been inserted as comments. For instance,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7ea8af81e418a1edb4e459f8a9a2eab6da15605" translate="yes" xml:space="preserve">
          <source>The ocamlrun command comprises three main parts: the bytecode interpreter, that actually executes bytecode files; the memory allocator and garbage collector; and a set of C functions that implement primitive operations such as input/output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba3256951b99c851dcb6d71a9ee49e018d24d2bb" translate="yes" xml:space="preserve">
          <source>The ocamlrun command executes bytecode files produced by the linking phase of the ocamlc command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e1235caedb5ccfed4248d72a0e38e7bda7a4c82" translate="yes" xml:space="preserve">
          <source>The ocamlrun command searches shared libraries in the following directories, in the order indicated:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45cf460ec88bc5d152326aaf5ae83eb8df678857" translate="yes" xml:space="preserve">
          <source>The ocamlyacc command produces a parser from a context-free grammar specification with attached semantic actions, in the style of yacc. Assuming the input file is grammar.mly, executing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="028fe9d310df119de0ec84424c8896799e9e2f82" translate="yes" xml:space="preserve">
          <source>The ocamlyacc command recognizes the following options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c12a611ec5444a4dcbe094626c7878666edcceb" translate="yes" xml:space="preserve">
          <source>The only case we have reasonable confidence is safe is if the produced &lt;code&gt;bytes&lt;/code&gt; is shared -- used as an immutable byte sequence. This is possibly useful for incremental migration of low-level programs that manipulate immutable sequences of bytes (for example &lt;a href=&quot;marshal#VALfrom_bytes&quot;&gt;&lt;code&gt;Marshal.from_bytes&lt;/code&gt;&lt;/a&gt;) and previously used the &lt;code&gt;string&lt;/code&gt; type for this purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9599505a809ca09e4fab73b6902744c16bc81fdd" translate="yes" xml:space="preserve">
          <source>The only case where that transformation is not possible is if a given function call may raise distinct exceptions with the same constructor but different string values. In this case, you will have to check for specific string values. This is dangerous API design and it should be discouraged: it&amp;rsquo;s better to define more precise exception constructors than store useful information in strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cedfa4c8d920a307290831222d9cbd51790caf6" translate="yes" xml:space="preserve">
          <source>The only difference with the let construct described above is that the bindings of names to values performed by the pattern-matching are considered already performed when the expressions &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; are evaluated. That is, the expressions &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; can reference identifiers that are bound by one of the patterns &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;, and expect them to have the same value as in &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;, the body of the letrec construct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="774d89b5de623ddb891076997b98ef614701dff8" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;flags&lt;/code&gt; are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e89406e3e1bdda8e82d077bce710e73570e29fe" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;precision&lt;/code&gt; is a dot &lt;code&gt;.&lt;/code&gt; followed by an integer indicating how many digits follow the decimal point in the &lt;code&gt;%f&lt;/code&gt;, &lt;code&gt;%e&lt;/code&gt;, &lt;code&gt;%E&lt;/code&gt;, &lt;code&gt;%h&lt;/code&gt;, and &lt;code&gt;%H&lt;/code&gt; conversions or the maximum number of significant digits to appear for the &lt;code&gt;%F&lt;/code&gt;, &lt;code&gt;%g&lt;/code&gt; and &lt;code&gt;%G&lt;/code&gt; conversions. For instance, &lt;code&gt;%.4f&lt;/code&gt; prints a &lt;code&gt;float&lt;/code&gt; with 4 fractional digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5468298bc781912cae47e80a93f5f848cf36f0ca" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;random&lt;/code&gt; parameter (a boolean) controls whether the internal organization of the hash table is randomized at each execution of &lt;code&gt;Hashtbl.create&lt;/code&gt; or deterministic over all executions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af162af26700a86b364c7a2731480ce8c43ff2a7" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;width&lt;/code&gt; is an integer indicating the minimal width of the result. For instance, &lt;code&gt;%6d&lt;/code&gt; prints an integer, prefixing it with spaces to fill at least 6 characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18011c2fab12a66b7e7060c98020473e137bdb60" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;~&lt;/code&gt;&lt;code&gt;random&lt;/code&gt; parameter (a boolean) controls whether the internal organization of the hash table is randomized at each execution of &lt;code&gt;Hashtbl.create&lt;/code&gt; or deterministic over all executions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a984b2d5c22765574cbc75b87562636eb520c87c" translate="yes" xml:space="preserve">
          <source>The optional arguments &lt;code&gt;?stdin&lt;/code&gt; and &lt;code&gt;?stdout&lt;/code&gt; and &lt;code&gt;?stderr&lt;/code&gt; are file names used to redirect the standard input, the standard output, or the standard error of the command. If &lt;code&gt;~stdin:f&lt;/code&gt; is given, a redirection &lt;code&gt;&amp;lt;&amp;nbsp;f&lt;/code&gt; is performed and the standard input of the command reads from file &lt;code&gt;f&lt;/code&gt;. If &lt;code&gt;~stdout:f&lt;/code&gt; is given, a redirection &lt;code&gt;&amp;gt;&amp;nbsp;f&lt;/code&gt; is performed and the standard output of the command is written to file &lt;code&gt;f&lt;/code&gt;. If &lt;code&gt;~stderr:f&lt;/code&gt; is given, a redirection &lt;code&gt;2&amp;gt;&amp;nbsp;f&lt;/code&gt; is performed and the standard error of the command is written to file &lt;code&gt;f&lt;/code&gt;. If both &lt;code&gt;~stdout:f&lt;/code&gt; and &lt;code&gt;~stderr:f&lt;/code&gt; are given, with the exact same file name &lt;code&gt;f&lt;/code&gt;, a &lt;code&gt;2&amp;gt;&amp;amp;1&lt;/code&gt; redirection is performed so that the standard output and the standard error of the command are interleaved and redirected to the same file &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e256823745bc0b0bb3e5fba44ec11d079e0f250" translate="yes" xml:space="preserve">
          <source>The optional type equation =&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; makes the defined type equivalent to the type expression &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;: one can be substituted for the other during typing. If no type equation is given, a new type is generated: the defined type is incompatible with any other type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b981238dc55cab7ff8d05b1c6297d9f1f74dde9a" translate="yes" xml:space="preserve">
          <source>The optional type parameters are either one type variable '&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;, for type constructors with one parameter, or a list of type variables ('&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;,&amp;hellip;,'&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;), for type constructors with several parameters. Each type parameter may be prefixed by a variance constraint + (resp. -) indicating that the parameter is covariant (resp. contravariant), and an injectivity annotation ! indicating that the parameter can be deduced from the whole type. These type parameters can appear in the type expressions of the right-hand side of the definition, optionally restricted by a variance constraint ; &lt;em&gt;i.e.&lt;/em&gt; a covariant parameter may only appear on the right side of a functional arrow (more precisely, follow the left branch of an even number of arrows), and a contravariant parameter only the left side (left branch of an odd number of arrows). If the type has a representation or an equation, and the parameter is free (&lt;em&gt;i.e.&lt;/em&gt; not bound via a type constraint to a constructed type), its variance constraint is checked but subtyping &lt;em&gt;etc.&lt;/em&gt; will use the inferred variance of the parameter, which may be less restrictive; otherwise (&lt;em&gt;i.e.&lt;/em&gt; for abstract types or non-free parameters), the variance must be given explicitly, and the parameter is invariant if no variance is given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4236d000dcf5d91e24113385c5dda11fb81d860b" translate="yes" xml:space="preserve">
          <source>The optional type parameters are either one type variable '&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;, for type constructors with one parameter, or a list of type variables ('&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;,&amp;hellip;,'&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;), for type constructors with several parameters. Each type parameter may be prefixed by a variance constraint + (resp. -) indicating that the parameter is covariant (resp. contravariant). These type parameters can appear in the type expressions of the right-hand side of the definition, optionally restricted by a variance constraint ; &lt;em&gt;i.e.&lt;/em&gt; a covariant parameter may only appear on the right side of a functional arrow (more precisely, follow the left branch of an even number of arrows), and a contravariant parameter only the left side (left branch of an odd number of arrows). If the type has a representation or an equation, and the parameter is free (&lt;em&gt;i.e.&lt;/em&gt; not bound via a type constraint to a constructed type), its variance constraint is checked but subtyping &lt;em&gt;etc.&lt;/em&gt; will use the inferred variance of the parameter, which may be less restrictive; otherwise (&lt;em&gt;i.e.&lt;/em&gt; for abstract types or non-free parameters), the variance must be given explicitly, and the parameter is invariant if no variance is given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dca346bd513d4a4a22688d0f639db0a9deec76c9" translate="yes" xml:space="preserve">
          <source>The optional type representation describes the data structure representing the defined type, by giving the list of associated constructors (if it is a variant type) or associated fields (if it is a record type). If no type representation is given, nothing is assumed on the structure of the type besides what is stated in the optional type equation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c913082fd743d89983385840500d287f715d0b40" translate="yes" xml:space="preserve">
          <source>The order in which the .cmo files are given to ocamlc during the linking phase determines the order in which the module definitions occur. Hence, in the example above, Aux appears first and Main can refer to it, but Aux cannot refer to Main.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9875c6ba3859a4c01a0b128c6fb6274d60da0369" translate="yes" xml:space="preserve">
          <source>The order in which the bindings are passed to &lt;code&gt;f&lt;/code&gt; is unspecified. However, if the table contains several bindings for the same key, they are passed to &lt;code&gt;f&lt;/code&gt; in reverse order of introduction, that is, the most recent binding is passed first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0038d1e71d2d22bcc5fc3fc7481009a2bb18e7e5" translate="yes" xml:space="preserve">
          <source>The order in which the expressions &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;, &lt;a href=&quot;#argument&quot;&gt;argument&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;#argument&quot;&gt;argument&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; are evaluated is not specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63c6c1451d4aeaf3a047e06c6ffd102113e24f2b" translate="yes" xml:space="preserve">
          <source>The other caveat is that by default symbolic links are a privileged operation. Administrators will always need to be running elevated (or with UAC disabled) and by default normal user accounts need to be granted the SeCreateSymbolicLinkPrivilege via Local Security Policy (secpol.msc) or via Active Directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69042c37de15f706ea13e0d0d27fbaa418b8568a" translate="yes" xml:space="preserve">
          <source>The other form of function definition is introduced by the keyword fun:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ef7b523167e57b31abccd875bb07306286ad08a" translate="yes" xml:space="preserve">
          <source>The output buffer of a symbolic pretty-printer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64e2b5efa720054b9f0ac49507c8989cfb0711a0" translate="yes" xml:space="preserve">
          <source>The output elements are included in &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;l2&lt;/code&gt; in the same relative order as the corresponding input elements in &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="197edf84eebbfd7ce0d59bc84a2b213982ad8e53" translate="yes" xml:space="preserve">
          <source>The output of the linking phase is a file containing compiled bytecode that can be executed by the OCaml bytecode interpreter: the command named ocamlrun. If a.out is the name of the file produced by the linking phase, the command</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f86bd69d544011aefe916eee4af7cd635e073e0c" translate="yes" xml:space="preserve">
          <source>The output of the linking phase is a regular Unix or Windows executable file. It does not need ocamlrun to run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ce0fa21bd7ce51645890738324e05068fce2adc" translate="yes" xml:space="preserve">
          <source>The output signature of the functor &lt;a href=&quot;ephemeron.k1.make&quot;&gt;&lt;code&gt;Ephemeron.K1.Make&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ephemeron.k2.make&quot;&gt;&lt;code&gt;Ephemeron.K2.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b888b9c1ae97afb61ed88f6dcc91b6356987780" translate="yes" xml:space="preserve">
          <source>The output signature of the functor &lt;a href=&quot;ephemeron.k1.make&quot;&gt;&lt;code&gt;Ephemeron.K1.Make&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ephemeron.k2.make&quot;&gt;&lt;code&gt;Ephemeron.K2.Make&lt;/code&gt;&lt;/a&gt;. These hash tables are weak in the keys. If all the keys of a binding are alive the binding is kept, but if one of the keys of the binding is dead then the binding is removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6df4d9df08fab00830fd043eb96f7af5ace9c32e" translate="yes" xml:space="preserve">
          <source>The output signature of the functor &lt;a href=&quot;ephemeron.k1.makeseeded&quot;&gt;&lt;code&gt;Ephemeron.K1.MakeSeeded&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ephemeron.k2.makeseeded&quot;&gt;&lt;code&gt;Ephemeron.K2.MakeSeeded&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc4f49be3b37069506238985b68b76a704e8a12" translate="yes" xml:space="preserve">
          <source>The output signature of the functor &lt;a href=&quot;hashtbl.make&quot;&gt;&lt;code&gt;Hashtbl.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acd77c5116baf2558a8ee6e7372f7c8f987c6831" translate="yes" xml:space="preserve">
          <source>The output signature of the functor &lt;a href=&quot;hashtbl.makeseeded&quot;&gt;&lt;code&gt;Hashtbl.MakeSeeded&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ca70fc1f40276a7d1472b43e23f9229ebf89348" translate="yes" xml:space="preserve">
          <source>The output signature of the functor &lt;a href=&quot;morelabels.hashtbl.make&quot;&gt;&lt;code&gt;MoreLabels.Hashtbl.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f416a370c920a779662bea36d75e75022525b518" translate="yes" xml:space="preserve">
          <source>The output signature of the functor &lt;a href=&quot;morelabels.hashtbl.makeseeded&quot;&gt;&lt;code&gt;MoreLabels.Hashtbl.MakeSeeded&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffa1e6deb7c02cb5fb60673b1d37d74545f296d4" translate="yes" xml:space="preserve">
          <source>The output signature of the functor &lt;a href=&quot;weak.make&quot;&gt;&lt;code&gt;Weak.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="235dcfaccc10009cd349c37e2f6b3ea0f93a7b42" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;callstack_size&lt;/code&gt; is the length of the callstack recorded at every sample. Its default is &lt;code&gt;max_int&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e070830e786df33101debf41e042d4603dc7e8c" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;sampling_rate&lt;/code&gt; is the sampling rate in samples per word (including headers). Usually, with cheap callbacks, a rate of 1e-4 has no visible effect on performance, and 1e-3 causes the program to run a few percent slower</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49970203f15065fd920f5133460488f7c2c20b5b" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;tracker&lt;/code&gt; determines how to track sampled blocks over their lifetime in the minor and major heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09fbb96897f07cf55eb54e9bcb8824b504ac0830" translate="yes" xml:space="preserve">
          <source>The parameter patterns ~&lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt; and ~(&lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt; [:&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;]) are shorthands for respectively ~&lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt;:&lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt; and ~&lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt;:(&lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt; [:&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;]), and similarly for their optional counterparts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e5974a12a7d51f44c9175604dd69a6dc4db175f" translate="yes" xml:space="preserve">
          <source>The parameter x_init is, of course, visible in the whole body of the definition, including methods. For instance, the method get_offset in the class below returns the position of the object relative to its initial position.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e95fd7cf7f4ba7d41d47acfb96f75946ad23cd79" translate="yes" xml:space="preserve">
          <source>The parser also enters error recovery mode if one of the grammar actions raises the Parsing.Parse_error exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34d65af266245e845378220e5a545186f7764e3e" translate="yes" xml:space="preserve">
          <source>The pass analyses functions to determine which arguments are unused. Removal is effected by creating a wrapper function, which will be inlined at every direct call site, that accepts the original arguments and then discards the unused ones before calling the original function. As a consequence, this transformation may be detrimental if the original function is usually indirectly called, since such calls will now bounce through the wrapper. (The technique of &lt;em&gt;direct call surrogates&lt;/em&gt; used to reduce this penalty during unboxing of closure variables (see above) does not yet apply to the pass that removes unused arguments.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddb1f22a5bac6d00f359ad560b86fb3d4abcbdd7" translate="yes" xml:space="preserve">
          <source>The pattern 'c'..'d' is a shorthand for the pattern</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78a9eb434825f2c323017a519a3d60fa9f698c76" translate="yes" xml:space="preserve">
          <source>The pattern (&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;) matches the same values as &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;. A type constraint can appear in a parenthesized pattern, as in (&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;). This constraint forces the type of &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to be compatible with &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16ae7f98de1b36c58b45270ed0fb02b7e9c6764a" translate="yes" xml:space="preserve">
          <source>The pattern (module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;) matches a package with type &lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt; and binds it to &lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;. It is not allowed in toplevel let bindings. Again &lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt; can be omitted if it can be inferred from the enclosing pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f60d5e8c331afa9fe8e1e6db86c21aacdc85acef" translate="yes" xml:space="preserve">
          <source>The pattern &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; ,&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; matches n-tuples whose components match the patterns &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; through &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;. That is, the pattern matches the tuple values (v&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, v&lt;sub&gt;n&lt;/sub&gt;) such that &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; matches v&lt;sub&gt;i&lt;/sub&gt; for i = 1,&amp;hellip; , n.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6da6c23d8212831014d6c0f7d9fd644913b7199" translate="yes" xml:space="preserve">
          <source>The pattern &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;::&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; matches non-empty lists whose heads match &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, and whose tails match &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41348db0bf142801b4dc26e958764633a28f85d6" translate="yes" xml:space="preserve">
          <source>The pattern &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;as&lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt; matches the same values as &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;. If the matching against &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; is successful, the name &lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt; is bound to the matched value, in addition to the bindings performed by the matching against &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdceda5e76dc99dff62cfbffd34932860bd8932c" translate="yes" xml:space="preserve">
          <source>The pattern &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;|&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; represents the logical &amp;ldquo;or&amp;rdquo; of the two patterns &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. A value matches &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;|&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; if it matches &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; or &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. The two sub-patterns &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; must bind exactly the same identifiers to values having the same types. Matching is performed from left to right. More precisely, in case some value &amp;zwj;v matches &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;|&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;, the bindings performed are those of &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; when v matches &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;. Otherwise, value &amp;zwj;v matches &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; whose bindings are performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9299c9cb5135cc2b4bedfa03f575390c8ead0e50" translate="yes" xml:space="preserve">
          <source>The pattern &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;|&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; represents the logical &amp;ldquo;or&amp;rdquo; of the two patterns &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. A value matches &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;|&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; if it matches &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; or &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. The two sub-patterns &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; must bind exactly the same identifiers to values having the same types. Matching is performed from left to right. More precisely, in case some value v matches &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;|&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;, the bindings performed are those of &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; when v matches &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;. Otherwise, value v matches &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; whose bindings are performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00b0db5a51b1f1d5c7c59b426eaf70572b94fa7f" translate="yes" xml:space="preserve">
          <source>The pattern &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;(&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; ,&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;) matches all variants whose constructor is equal to &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;, and whose arguments match &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;. It is a type error if n is not the number of arguments expected by the constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d790d4519563bbe23e283cddeb381557179c1ed8" translate="yes" xml:space="preserve">
          <source>The pattern &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;_ matches all variants whose constructor is &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c4b162c77607f7f0c96e87989be66403257ce86" translate="yes" xml:space="preserve">
          <source>The pattern [&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip; ;&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;] matches lists of length n whose elements match &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip;&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;, respectively. This pattern behaves like &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:: &amp;hellip; ::&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;::[].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5be2296eeedc0ad28df110fb34fef15f60597b6f" translate="yes" xml:space="preserve">
          <source>The pattern [|&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip; ;&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;|] matches arrays of length n such that the i-th array element matches the pattern &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt;, for i = 1,&amp;hellip; , n.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1788df79d59202a4d26aad006675bcfb219b3e5f" translate="yes" xml:space="preserve">
          <source>The pattern `&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; matches all polymorphic variants whose tag is equal to &lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;, and whose argument matches &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d78189bca7a2a4a7c7d4b24d2ca0b9ace362515e" translate="yes" xml:space="preserve">
          <source>The pattern lazy&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt; matches a value v of type Lazy.t, provided &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt; matches the result of forcing v with Lazy.force. A successful match of a pattern containing lazy sub-patterns forces the corresponding parts of the value being matched, even those that imply no test such as lazy&lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt; or lazy_. Matching a value with a &lt;a href=&quot;expr#pattern-matching&quot;&gt;pattern-matching&lt;/a&gt; where some patterns contain lazy sub-patterns may imply forcing parts of the value, even when the pattern selected in the end has no lazy sub-pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16f7adce7fddea3b9b8f86106681f2bc5fc82ba6" translate="yes" xml:space="preserve">
          <source>The pattern {&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; [=&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;] ; &amp;hellip; ;&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; [=&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;] } matches records that define at least the fields &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; through &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;, and such that the value associated to &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; matches the pattern &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt;, for i = 1,&amp;hellip; , n. A single identifier &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; stands for &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;=&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; , and a single qualified identifier &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; stands for &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;=&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; . The record value can define more fields than &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip;&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;; the values associated to these extra fields are not taken into account for matching. Optionally, a record pattern can be terminated by ;_ to convey the fact that not all fields of the record type are listed in the record pattern and that it is intentional. Optional type constraints can be added field by field with {&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;;&amp;hellip; ;&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;=&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;} to force the type of &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; to be compatible with &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28c11f2884ea2e751e90db06b713059bf8743ce8" translate="yes" xml:space="preserve">
          <source>The pointer returned by caml_named_value is constant and can safely be cached in a C variable to avoid repeated name lookups. The value pointed to cannot be changed from C. However, it might change during garbage collection, so must always be recomputed at the point of use. Here is a more efficient variant of call_caml_f above that calls caml_named_value only once:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32e4ea607d04ac6fcfc5da2a4f99be29eb749147" translate="yes" xml:space="preserve">
          <source>The policy used for allocating in the major heap. Possible values are 0, 1 and 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0575e3a19290f6df5fdcaa47a106f8449112455" translate="yes" xml:space="preserve">
          <source>The polymorphic hash functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10931e6e8e695da4d6f07c1443d2547e5cf128cc" translate="yes" xml:space="preserve">
          <source>The polymorphism may be left implicit in public method specifications: any type variable which is not bound to a class parameter and does not appear elsewhere inside the class specification will be assumed to be universal, and made polymorphic in the resulting method type. Writing an explicit polymorphic type will disable this behaviour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46f55cdbce1c396ddb68caad025838e2c114c305" translate="yes" xml:space="preserve">
          <source>The precedence declarations are used in the following way to resolve reduce/reduce and shift/reduce conflicts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1442484d01949a40882f7fd1198334b88701ef0b" translate="yes" xml:space="preserve">
          <source>The pretty-printer must split the line at this point,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e659673f1b18fb1d82b63a1c55173f87e4ba3218" translate="yes" xml:space="preserve">
          <source>The pretty-printing engine uses the concepts of pretty-printing box and break hint to drive indentation and line splitting behavior of the pretty-printer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a53dbcb487f74a0958c713e69a144733631dbfe2" translate="yes" xml:space="preserve">
          <source>The pretty-printing functions output material that is delayed in the pretty-printer queue and stacks in order to compute proper line splitting. In contrast, basic I/O output functions write directly in their output device. As a consequence, the output of a basic I/O function may appear before the output of a pretty-printing function that has been called before. For instance, &lt;code&gt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Stdlib.print_string&amp;nbsp;&quot;&amp;lt;&quot;;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Format.print_string&amp;nbsp;&quot;PRETTY&quot;;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Stdlib.print_string&amp;nbsp;&quot;&amp;gt;&quot;;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Format.print_string&amp;nbsp;&quot;TEXT&quot;;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt; leads to output &lt;code&gt;&amp;lt;&amp;gt;PRETTYTEXT&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f51978ff177538bd6acc10bb07871f9792c046ef" translate="yes" xml:space="preserve">
          <source>The pretty-printing indication characters are introduced by a &lt;code&gt;@&lt;/code&gt; character, and their meanings are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="433dda59f28a1c16b7f6ad751b61d21f14015c15" translate="yes" xml:space="preserve">
          <source>The previous coercion problem can often be avoided by first defining the abbreviation, using a class type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb0dbd05eb51d23e1a522b80e905369b8eb83ac6" translate="yes" xml:space="preserve">
          <source>The printing function printer-name should have type Format.formatter-&amp;gt;t-&amp;gt;unit, where t is the type for the values to be printed, and should output its textual representation for the value of type t on the given formatter, using the functions provided by the Format library. For backward compatibility, printer-name can also have type t-&amp;gt;unit and should then output on the standard formatter, but this usage is deprecated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8883bf4f143303eb37a391cfe05fa314bafceca6" translate="yes" xml:space="preserve">
          <source>The problem here is that SET specifies the type element abstractly, so that the type equality between element in the result of the functor and t in its argument is forgotten. Consequently, WrongStringSet.element is not the same type as string, and the operations of WrongStringSet cannot be applied to strings. As demonstrated above, it is important that the type element in the signature SET be declared equal to Elt.t; unfortunately, this is impossible above since SET is defined in a context where Elt does not exist. To overcome this difficulty, OCaml provides a with type construct over signatures that allows enriching a signature with extra type equalities:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79d5207edef86d719b23b481fee7c2e0aa2b94e6" translate="yes" xml:space="preserve">
          <source>The problem here is that quantification was wrongly located: it is not the class we want to be polymorphic, but the fold method. This can be achieved by giving an explicitly polymorphic type in the method definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d28eba679c98023f0747aaf9581f0f01fc941cfe" translate="yes" xml:space="preserve">
          <source>The process terminated normally by &lt;code&gt;exit&lt;/code&gt;; the argument is the return code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="168ecaee8748c10e62b8f47e3dcea6c8cbd65579" translate="yes" xml:space="preserve">
          <source>The process was killed by a signal; the argument is the signal number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34eaa6addd6d491cf217fc8965c116ada2b0beed" translate="yes" xml:space="preserve">
          <source>The process was stopped by a signal; the argument is the signal number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c048c9cffeb4593d3904a5383fdb63616e02e942" translate="yes" xml:space="preserve">
          <source>The produced file has the executable bit set, and it manages to launch the bytecode interpreter by itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5147f68b7fbbbd5f93868579353c15f80510e07f" translate="yes" xml:space="preserve">
          <source>The program behaves exactly as if the following phrases were entered at top-level:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f6811b8d125d2cdaaeacc0a56ba7fbf8a7e5194" translate="yes" xml:space="preserve">
          <source>The program being executed contains a &amp;ldquo;stray&amp;rdquo; exception. That is, it raises an exception at some point, and this exception is never caught. This causes immediate termination of the program. The name of the exception is printed, along with its string, byte sequence, and integer arguments (arguments of more complex types are not correctly printed). To locate the context of the uncaught exception, compile the program with the -g option and either run it again under the ocamldebug debugger (see chapter &amp;zwj;&lt;a href=&quot;debugger#c%3Adebugger&quot;&gt;16&lt;/a&gt;), or run it with ocamlrun -b or with the OCAMLRUNPARAM environment variable set to b=1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f484a5296a71c426225e4ed54accc59929e24d8b" translate="yes" xml:space="preserve">
          <source>The program being executed contains a &amp;ldquo;stray&amp;rdquo; exception. That is, it raises an exception at some point, and this exception is never caught. This causes immediate termination of the program. The name of the exception is printed, along with its string, byte sequence, and integer arguments (arguments of more complex types are not correctly printed). To locate the context of the uncaught exception, compile the program with the -g option and either run it again under the ocamldebug debugger (see chapter &lt;a href=&quot;debugger#c%3Adebugger&quot;&gt;17&lt;/a&gt;), or run it with ocamlrun -b or with the OCAMLRUNPARAM environment variable set to b=1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b266af3c49a1ad66480fec482895593ef57dff7e" translate="yes" xml:space="preserve">
          <source>The program being executed requires more memory than available. Either the program builds excessively large data structures; or the program contains too many nested function calls, and the stack overflows. In some cases, your program is perfectly correct, it just requires more memory than your machine provides. In other cases, the &amp;ldquo;out of memory&amp;rdquo; message reveals an error in your program: non-terminating recursive function, allocation of an excessively large array, string or byte sequence, attempts to build an infinite list or other data structure, &amp;hellip;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a503f7e4a9e093239bc1734598a0ac0302624fc9" translate="yes" xml:space="preserve">
          <source>The program being profiled must exit normally or be caused to exit using the SIGINT signal (e.g. by pressing Ctrl+C). When the program exits files will be written in the directory that was the working directory when the program was started. One Spacetime file will be written for each process that was involved, indexed by process ID; there will normally only be one such. The Spacetime files may be substantial. The directory to which they are written may be overridden by setting the OCAML_SPACETIME_SNAPSHOT_DIR environment variable before the program is started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cc4a8046bc314aed242125f697f2a900a2c88e8" translate="yes" xml:space="preserve">
          <source>The program is run directly by the debugger. This is the default mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="869eb5aeb2fdd87b2a28ba89f60a8c2af784a6d6" translate="yes" xml:space="preserve">
          <source>The program will have to start event collection explicitly. Starting and stopping event collection programmatically can be done by calling Gc.eventlog_resume and Gc.eventlog_pause) from within the program. Refer to the &lt;a href=&quot;libref/gc&quot;&gt;Gc&lt;/a&gt; module documentation for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07c2399b10db28be424b9d95192597cf13943884" translate="yes" xml:space="preserve">
          <source>The projections from p may be replaced by uses of the variables x and y, potentially meaning that p becomes unused.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e07f245bb0c49e7a50bc84525e1cacf4689e631" translate="yes" xml:space="preserve">
          <source>The propagation can help to eliminate allocations in cases such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f79e766e028d6e095da9d529d5a9dfbe0498d920" translate="yes" xml:space="preserve">
          <source>The propagation performed by the simplification pass is also important for discovering which functions flow to indirect call sites. This can enable the transformation of such call sites into direct call sites, which makes them eligible for an inlining transformation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94c9da3eb2e38629000eda75e07fe34fd5562fd6" translate="yes" xml:space="preserve">
          <source>The reason for the error: unknown option, invalid or missing argument, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a43dbd7b9edc2247945720db7869546aded72b86" translate="yes" xml:space="preserve">
          <source>The reason is that at least one of the methods has a polymorphic type (here, the type of the value stored in the reference cell), thus either the class should be parametric, or the method type should be constrained to a monomorphic type. A monomorphic instance of the class could be defined by:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="072461fde3d0d8b6efbc5a6868695ccf66c6f021" translate="yes" xml:space="preserve">
          <source>The reason this is unsafe is because the simplification pass believes that fst a holds the value 42; and indeed it must, unless type soundness has been broken via unsafe operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c67a48b57781f36d335583c6c3fd5c675bbebd44" translate="yes" xml:space="preserve">
          <source>The recursive definition is guaranteed to behave as described above if the expressions &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; are function definitions (fun &amp;hellip; or function &amp;hellip;), and the patterns &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; are just value names, as in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21a0eac9c2ffe7244b1f04ef0b56b0358674bc2b" translate="yes" xml:space="preserve">
          <source>The registration causes the contents of the variable or memory location to be updated by the garbage collector whenever the value in such variable or location is moved within the OCaml heap. In the presence of threads care must be taken to ensure appropriate synchronisation with the OCaml runtime to avoid a race condition against the garbage collector when reading or writing the value. (See section &lt;a href=&quot;#ss%3Aparallel-execution-long-running-c-code&quot;&gt;18.12.2&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be50e5ba6751e078d213ea17d81f37abaeae3a78" translate="yes" xml:space="preserve">
          <source>The registration causes the contents of the variable or memory location to be updated by the garbage collector whenever the value in such variable or location is moved within the OCaml heap. In the presence of threads care must be taken to ensure appropriate synchronisation with the OCaml runtime to avoid a race condition against the garbage collector when reading or writing the value. (See section &lt;a href=&quot;#ss%3Aparallel-execution-long-running-c-code&quot;&gt;20.12.2&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e498792eb5a8e5a1f7711c5d76148d563e2627fe" translate="yes" xml:space="preserve">
          <source>The registration mechanism described above can also be used to communicate exception identifiers from OCaml to C. The OCaml code registers the exception by evaluating Callback.register_exceptionn exn, where n is an arbitrary name and exn is an exception value of the exception to register. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e412ad57efe185f94f3f66dee663594387b73ec" translate="yes" xml:space="preserve">
          <source>The regular expressions are in the style of lex, with a more OCaml-like syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca763eb3bdb448bf22bb32fc59cd71ec5db35a9f" translate="yes" xml:space="preserve">
          <source>The representation is chosen according to the following, in decreasing order of priority:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cb9b87429c5694aec26392deb0ded32f7bf6b82" translate="yes" xml:space="preserve">
          <source>The representation of marshaled values is not human-readable, and uses bytes that are not printable characters. Therefore, input and output channels used in conjunction with &lt;code&gt;Marshal.to_channel&lt;/code&gt; and &lt;code&gt;Marshal.from_channel&lt;/code&gt; must be opened in binary mode, using e.g. &lt;code&gt;open_out_bin&lt;/code&gt; or &lt;code&gt;open_in_bin&lt;/code&gt;; channels opened in text mode will cause unmarshaling errors on platforms where text channels behave differently than binary channels, e.g. Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b30fdf8a2c0fb75299c4dafd61caaf7a19cc1857" translate="yes" xml:space="preserve">
          <source>The rest of the binding is the same for both platforms:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44c9e601546b4f760808bdd19852d33ad5355c07" translate="yes" xml:space="preserve">
          <source>The restriction can also be performed during the definition of the structure, as in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc0357393d60a0f1fa7baa5274ba71a46d90f408" translate="yes" xml:space="preserve">
          <source>The resulting P.cmx object file has sub-modules P.Q, P.Q.A and P.B.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="540f70e6d81a40f7974a7c5702a14ef36eff5dc8" translate="yes" xml:space="preserve">
          <source>The resulting benefit value is known as the &lt;em&gt;estimated benefit&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f24d01c073b212c7b11b8ff5380c3e1f163e921d" translate="yes" xml:space="preserve">
          <source>The resulting program can then be traced by running it with the environment variable OCAML_EVENTLOG_ENABLED:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0936bfa6fa4fa6c80130298ea1d5af175d858507" translate="yes" xml:space="preserve">
          <source>The resulting trace contains only one event payload, namely a &lt;em&gt;flush&lt;/em&gt; event, indicating how much time was spent flushing the trace file to disk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ed3a555a7ebebf96c3208ad39f845704f68067a" translate="yes" xml:space="preserve">
          <source>The resulting trace will contain all events encountered during the program&amp;rsquo;s execution:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76a2e5fedee04aeb14150359846ceeb930560151" translate="yes" xml:space="preserve">
          <source>The results of calling &lt;a href=&quot;string#VALmake&quot;&gt;&lt;code&gt;String.make&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bytes#VALmake&quot;&gt;&lt;code&gt;Bytes.make&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bytes#VALcreate&quot;&gt;&lt;code&gt;Bytes.create&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;array#VALmake&quot;&gt;&lt;code&gt;Array.make&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;stdlib#VALref&quot;&gt;&lt;code&gt;ref&lt;/code&gt;&lt;/a&gt; are guaranteed to be heap-allocated and non-constant except when the length argument is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dab88c1cb3eef6aab0ce452f5d3a24ee29766571" translate="yes" xml:space="preserve">
          <source>The right way to solve this problem for optional parameters is to add a type annotation to the argument bump.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="021484aa4f766fbe935de88999e6cb6d7bb47d1e" translate="yes" xml:space="preserve">
          <source>The rules may contain the special symbol error to indicate resynchronization points, as in yacc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2425e4fb8fd4780c2506baebfe7345c64646daa" translate="yes" xml:space="preserve">
          <source>The run-time library for lexers generated by &lt;code&gt;ocamllex&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d4e630606c50faf5f2e5b24a4b0bf1a04b6c5db" translate="yes" xml:space="preserve">
          <source>The run-time library for parsers generated by &lt;code&gt;ocamlyacc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b06b765c6160900806a7c7c50af837787bf9890a" translate="yes" xml:space="preserve">
          <source>The runtime overhead imposed by Spacetime varies considerably depending on the particular program being profiled. The overhead may be as low as ten percent&amp;mdash;but more usually programs should be expected to run at perhaps a third or quarter of their normal speed. It is expected that this overhead will be reduced in future versions of the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ef99f2b64955164c9593d8e632198f04c1ea43d" translate="yes" xml:space="preserve">
          <source>The runtime representation of a function. This includes pointers to the code of the function together with the values of any variables that are used in the body of the function but actually defined outside of the function, in the enclosing scope. The values of such variables, collectively known as the &lt;em&gt;environment&lt;/em&gt;, are required because the function may be invoked from a place where the original bindings of such variables are no longer in scope. A group of possibly mutually-recursive functions defined using &lt;em&gt;let rec&lt;/em&gt; all share a single closure. (Note to developers: in the Flambda source code a &lt;em&gt;closure&lt;/em&gt; always corresponds to a single function; a &lt;em&gt;set of closures&lt;/em&gt; refers to a group of such.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09e0b17c8f9005f5c598030be2554c687ccaa24d" translate="yes" xml:space="preserve">
          <source>The same feature is provided for method definitions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f69459bd2efc915e393510bd7d020112db264859" translate="yes" xml:space="preserve">
          <source>The same goes for &lt;code&gt;set_double_field&lt;/code&gt; and &lt;code&gt;set_tag&lt;/code&gt;. However, for &lt;code&gt;set_tag&lt;/code&gt;, in the case of immutable blocks where the middle-end optimizers never see code that discriminates on their tag (for example records), the operation should be safe. Such uses are nonetheless discouraged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c251a3b5f6c58244053faab7ecc98ddabddcb4f0" translate="yes" xml:space="preserve">
          <source>The same ownership discipline that makes &lt;code&gt;unsafe_to_string&lt;/code&gt; correct applies to &lt;code&gt;unsafe_of_string&lt;/code&gt;: you may use it if you were the owner of the &lt;code&gt;string&lt;/code&gt; value, and you will own the return &lt;code&gt;bytes&lt;/code&gt; in the same mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ac338637d2a5fce3a9f3793f3f8813dc5e79b82" translate="yes" xml:space="preserve">
          <source>The same shortcut is available for enumerated lists, using &amp;rsquo;+&amp;rsquo; instead of &amp;rsquo;-&amp;rsquo;. Note that only one list can be defined by this shortcut in nested lists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a96000f19b19300268f15d1d76e944ef3a1ebf04" translate="yes" xml:space="preserve">
          <source>The same syntactic form is also used to attach attributes to labels and constructors in type declarations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c56f9cdc02f4eaf0671121f748c04b2b039e6299" translate="yes" xml:space="preserve">
          <source>The scanning indications introduce slight differences in the syntax of &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt; format strings, compared to those used for the &lt;a href=&quot;printf&quot;&gt;&lt;code&gt;Printf&lt;/code&gt;&lt;/a&gt; module. However, the scanning indications are similar to those used in the &lt;a href=&quot;format&quot;&gt;&lt;code&gt;Format&lt;/code&gt;&lt;/a&gt; module; hence, when producing formatted text to be scanned by &lt;a href=&quot;scanf#VALbscanf&quot;&gt;&lt;code&gt;Scanf.bscanf&lt;/code&gt;&lt;/a&gt;, it is wise to use printing functions from the &lt;a href=&quot;format&quot;&gt;&lt;code&gt;Format&lt;/code&gt;&lt;/a&gt; module (or, if you need to use functions from &lt;a href=&quot;printf&quot;&gt;&lt;code&gt;Printf&lt;/code&gt;&lt;/a&gt;, banish or carefully double check the format strings that contain &lt;code&gt;'@'&lt;/code&gt; characters).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d497c2d6e07b975e5682bc991cd842d916c5c070" translate="yes" xml:space="preserve">
          <source>The second case is an open variant type, describing a polymorphic variant value: it gives the list of all tags the value could take, with their associated types. This type is still compatible with a variant type containing more tags. A special case is the unknown type, which does not define any tag, and is compatible with any variant type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="206f431b57884a92787316f42c56f48556e1bebc" translate="yes" xml:space="preserve">
          <source>The second drawback of dynamic linking is that it complicates the construction of the library. The C compiler and linker flags to compile to position-independent code and build a shared library vary wildly between different Unix systems. Also, dynamic linking is not supported on all Unix systems, requiring a fall-back case to static linking in the Makefile for the library. The ocamlmklib command (see section &amp;zwj;&lt;a href=&quot;#s%3Aocamlmklib&quot;&gt;18.14&lt;/a&gt;) tries to hide some of these system dependencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4cd062edd42fc49d3c066f95872cdcd6b75a514" translate="yes" xml:space="preserve">
          <source>The second drawback of dynamic linking is that it complicates the construction of the library. The C compiler and linker flags to compile to position-independent code and build a shared library vary wildly between different Unix systems. Also, dynamic linking is not supported on all Unix systems, requiring a fall-back case to static linking in the Makefile for the library. The ocamlmklib command (see section &lt;a href=&quot;#s%3Aocamlmklib&quot;&gt;20.14&lt;/a&gt;) tries to hide some of these system dependencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1cce543693960e06654a40bc08d8813b14f9075" translate="yes" xml:space="preserve">
          <source>The second example is more subtle: while we intended the argument bump to be of type ?step:int -&amp;gt; int -&amp;gt; int, it is inferred as step:int -&amp;gt; int -&amp;gt; 'a. These two types being incompatible (internally normal and optional arguments are different), a type error occurs when applying bump_it to the real bump.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d4ee921aaa1ec3723cdbada30294d66c801a5b5" translate="yes" xml:space="preserve">
          <source>The second form of attributes are attached to &amp;ldquo;blocks&amp;rdquo; such as type declarations, class fields, etc:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bcf7cdc991e4c97ac21aa1c7ae7ff5801e85d37" translate="yes" xml:space="preserve">
          <source>The second major class of non-genericity is directly related to the problem of type inference for polymorphic functions. In some circumstances, the type inferred by OCaml might be not general enough to allow the definition of some recursive functions, in particular for recursive function acting on non-regular algebraic data type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddae56c7d78a1170cc9452541524e5c04728b654" translate="yes" xml:space="preserve">
          <source>The semantic tag handling functions specific to a formatter: &lt;code&gt;mark&lt;/code&gt; versions are the 'tag-marking' functions that associate a string marker to a tag in order for the pretty-printing engine to write those markers as 0 length tokens in the output device of the formatter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bff7da471def393c1b371feaa59a0379272afe47" translate="yes" xml:space="preserve">
          <source>The semantic tag handling functions specific to a formatter: &lt;code&gt;mark&lt;/code&gt; versions are the 'tag-marking' functions that associate a string marker to a tag in order for the pretty-printing engine to write those markers as 0 length tokens in the output device of the formatter. &lt;code&gt;print&lt;/code&gt; versions are the 'tag-printing' functions that can perform regular printing when a tag is closed or opened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b2c1fa893284068e8e146efa02bbd7bcc29fab2" translate="yes" xml:space="preserve">
          <source>The semantics is clear: match the scrutinee against the pattern, if it matches, test the guard, and if the guard passes, take the branch. In particular, consider the input (Const &amp;zwj;a, Const &amp;zwj;b), where a fails the test is_neutral &amp;zwj;a, while b passes the test is_neutral &amp;zwj;b. With the left-to-right semantics, the clause above is &lt;em&gt;not&lt;/em&gt; taken by its input: matching (Const &amp;zwj;a, Const &amp;zwj;b) against the or-pattern succeeds in the left branch, it returns the environment x &amp;zwj;-&amp;gt; &amp;zwj;a, and then the guard is_neutral &amp;zwj;a is tested and fails, the branch is not taken.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bcc6c39a05b6e4644ddb92b4ebfbec3f0bd5823" translate="yes" xml:space="preserve">
          <source>The semantics is clear: match the scrutinee against the pattern, if it matches, test the guard, and if the guard passes, take the branch. In particular, consider the input (Consta, Constb), where a fails the test is_neutrala, while b passes the test is_neutralb. With the left-to-right semantics, the clause above is &lt;em&gt;not&lt;/em&gt; taken by its input: matching (Consta, Constb) against the or-pattern succeeds in the left branch, it returns the environment x-&amp;gt;a, and then the guard is_neutrala is tested and fails, the branch is not taken.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a1ca7a03baad7716212210f3fc88fe09e15dd50" translate="yes" xml:space="preserve">
          <source>The semantics of or-patterns in OCaml is specified with a left-to-right bias: a value v matches the pattern p|q if it matches p or q, but if it matches both, the environment captured by the match is the environment captured by p, never the one captured by q.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1583a4f3236a4e29dfa43d51de455715358c04c" translate="yes" xml:space="preserve">
          <source>The semantics of string functions is defined in terms of indices and positions. These are depicted and described as follows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33bae5ab3c39edb36e6026c0e18053f2831c7697" translate="yes" xml:space="preserve">
          <source>The serialize field can be set to custom_serialize_default, in which case the Failure exception is raised when attempting to serialize the custom block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d40ce64ff61f966dff5d5f82bc2dc3bb7256bb8b" translate="yes" xml:space="preserve">
          <source>The serialize field contains a pointer to a C function that is called whenever the custom block needs to be serialized (marshaled) using the OCaml functions output_value or Marshal.to_.... For a custom block, those functions first write the identifier of the block (as given by the identifier field) to the output stream, then call the user-provided serialize function. That function is responsible for writing the data contained in the custom block, using the serialize_... functions defined in &amp;lt;caml/intext.h&amp;gt; and listed below. The user-provided serialize function must then store in its bsize_32 and bsize_64 parameters the sizes in bytes of the data part of the custom block on a 32-bit architecture and on a 64-bit architecture, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2942136b250ae1097e80c746ad490f52ed3542e" translate="yes" xml:space="preserve">
          <source>The set of command line flags relating to optimisation should typically be specified to be the same across an entire project. Flambda does not currently record the requested flags in the .cmx files. As such, inlining of functions from previously-compiled units will subject their code to the optimisation parameters of the unit currently being compiled, rather than those specified when they were previously compiled. It is hoped to rectify this deficiency in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75f7516c7000daca4e41898b962a62fb90ba554f" translate="yes" xml:space="preserve">
          <source>The set of output functions specific to a formatter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58f5c99c8953630f7d0eb9e43e64f07f7389a46f" translate="yes" xml:space="preserve">
          <source>The set of output functions specific to a formatter: the &lt;code&gt;out_string&lt;/code&gt; function performs all the pretty-printer string output. It is called with a string &lt;code&gt;s&lt;/code&gt;, a start position &lt;code&gt;p&lt;/code&gt;, and a number of characters &lt;code&gt;n&lt;/code&gt;; it is supposed to output characters &lt;code&gt;p&lt;/code&gt; to &lt;code&gt;p&amp;nbsp;+&amp;nbsp;n&amp;nbsp;-&amp;nbsp;1&lt;/code&gt; of &lt;code&gt;s&lt;/code&gt;., the &lt;code&gt;out_flush&lt;/code&gt; function flushes the pretty-printer output device., &lt;code&gt;out_newline&lt;/code&gt; is called to open a new line when the pretty-printer splits the line., the &lt;code&gt;out_spaces&lt;/code&gt; function outputs spaces when a break hint leads to spaces instead of a line split. It is called with the number of spaces to output., the &lt;code&gt;out_indent&lt;/code&gt; function performs new line indentation when the pretty-printer splits the line. It is called with the indentation value of the new line. By default: fields &lt;code&gt;out_string&lt;/code&gt; and &lt;code&gt;out_flush&lt;/code&gt; are output device specific; (e.g. &lt;a href=&quot;stdlib#VALoutput_string&quot;&gt;&lt;code&gt;output_string&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;stdlib#VALflush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; for a &lt;a href=&quot;stdlib#TYPEout_channel&quot;&gt;&lt;code&gt;out_channel&lt;/code&gt;&lt;/a&gt; device, or &lt;code&gt;Buffer.add_substring&lt;/code&gt; and &lt;a href=&quot;stdlib#VALignore&quot;&gt;&lt;code&gt;ignore&lt;/code&gt;&lt;/a&gt; for a &lt;code&gt;Buffer.t&lt;/code&gt; output device),, field &lt;code&gt;out_newline&lt;/code&gt; is equivalent to &lt;code&gt;out_string&amp;nbsp;&quot;\n&quot;&amp;nbsp;0&amp;nbsp;1&lt;/code&gt;;, fields &lt;code&gt;out_spaces&lt;/code&gt; and &lt;code&gt;out_indent&lt;/code&gt; are equivalent to &lt;code&gt;out_string&amp;nbsp;(String.make&amp;nbsp;n&amp;nbsp;'&amp;nbsp;')&amp;nbsp;0&amp;nbsp;n&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fe430d7f65b9a4115dd36213fde72e2766eb905" translate="yes" xml:space="preserve">
          <source>The short expressions are translated into calls to functions of the Bigarray module as described in the following table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ec3650bd7c2cf484db50a370f6c089d2295064a" translate="yes" xml:space="preserve">
          <source>The signature MYHASH then contains all the fields of the signature of the module Hashtbl (with strengthened type definitions), plus the new field replace. An implementation of this signature can be obtained easily by using the include construct again, but this time at the structure level:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70846c98b1e5f76d1a8eeae9357dba832f61e830" translate="yes" xml:space="preserve">
          <source>The simplification pass removes unused let bindings so long as their corresponding defining expressions have &amp;ldquo;no effects&amp;rdquo;. See the section &amp;ldquo;Treatment of effects&amp;rdquo; below for the precise definition of this term.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fef5e19c04ebce13dc54db7219bcb47397db9b0" translate="yes" xml:space="preserve">
          <source>The singleton sequence containing only the given element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4bcd7d574236ad63f44f94fc9e518268676361d" translate="yes" xml:space="preserve">
          <source>The size (in words) of the minor heap. Changing this parameter will trigger a minor collection. Default: 256k.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7507f679adbb7afe1b145bc75e44b72811c4382" translate="yes" xml:space="preserve">
          <source>The size in bits of a native integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85cc984ceaff2d2d3db71a0f154333bd58e0401c" translate="yes" xml:space="preserve">
          <source>The size in bits of a native integer. This is equal to &lt;code&gt;32&lt;/code&gt; on a 32-bit platform and to &lt;code&gt;64&lt;/code&gt; on a 64-bit platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64bd44d9e49c2e76cdcec87737e9935d12ee6bdc" translate="yes" xml:space="preserve">
          <source>The size of the block, in words, excluding the header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6050e441d76daaaf25b47ad3fafeab9c8db6155" translate="yes" xml:space="preserve">
          <source>The size of the window used by the major GC for smoothing out variations in its workload. This is an integer between 1 and 50. Default: 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e707fef1fa0d611c38a23a134e978234bf5dd431" translate="yes" xml:space="preserve">
          <source>The smallest positive, non-zero, non-denormalized value of type &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3b9782a5db6a027afd3f2671f6d34f2dca120c7" translate="yes" xml:space="preserve">
          <source>The smallest representable 32-bit integer, -2&lt;sup&gt;31&lt;/sup&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bcd225542d9f92f6251d4bb2d635ef483db75e2" translate="yes" xml:space="preserve">
          <source>The smallest representable 64-bit integer, -2&lt;sup&gt;63&lt;/sup&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e75cf5a86c7fa5d080ac26a1f47b98cef3adf163" translate="yes" xml:space="preserve">
          <source>The smallest representable integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7ad80500b883d3470a8546d7763368d6a139abd" translate="yes" xml:space="preserve">
          <source>The smallest representable native integer, either -2&lt;sup&gt;31&lt;/sup&gt; on a 32-bit platform, or -2&lt;sup&gt;63&lt;/sup&gt; on a 64-bit platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16618ca96c698ad7bfc1856d7b38af8d4e0524d6" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unix#VALgetsockopt&quot;&gt;&lt;code&gt;Unix.getsockopt&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unix#VALsetsockopt&quot;&gt;&lt;code&gt;Unix.setsockopt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67e810815e754c36f51190792dabe6b7f6d39fc1" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unix#VALgetsockopt&quot;&gt;&lt;code&gt;Unix.getsockopt&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unix#VALsetsockopt&quot;&gt;&lt;code&gt;Unix.setsockopt&lt;/code&gt;&lt;/a&gt;. These options have a boolean (&lt;code&gt;true&lt;/code&gt;/&lt;code&gt;false&lt;/code&gt;) value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6598491cb35302bb16af6b6c7a9e151f8e63d9b8" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unix#VALgetsockopt_float&quot;&gt;&lt;code&gt;Unix.getsockopt_float&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unix#VALsetsockopt_float&quot;&gt;&lt;code&gt;Unix.setsockopt_float&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2019ae655a591c32fb8f40c0b2ba647816b414ae" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unix#VALgetsockopt_float&quot;&gt;&lt;code&gt;Unix.getsockopt_float&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unix#VALsetsockopt_float&quot;&gt;&lt;code&gt;Unix.setsockopt_float&lt;/code&gt;&lt;/a&gt;. These options have a floating-point value representing a time in seconds. The value 0 means infinite timeout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e1595d080e9d78ca9f7ddffc0fd77da50d67b0c" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unix#VALgetsockopt_int&quot;&gt;&lt;code&gt;Unix.getsockopt_int&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unix#VALsetsockopt_int&quot;&gt;&lt;code&gt;Unix.setsockopt_int&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6570006f88037fbe57d746e9ffa8ebe2113c3daa" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unix#VALgetsockopt_int&quot;&gt;&lt;code&gt;Unix.getsockopt_int&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unix#VALsetsockopt_int&quot;&gt;&lt;code&gt;Unix.setsockopt_int&lt;/code&gt;&lt;/a&gt;. These options have an integer value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67cb053530374f0ae91755129be399861c2e62b8" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unix#VALgetsockopt_optint&quot;&gt;&lt;code&gt;Unix.getsockopt_optint&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unix#VALsetsockopt_optint&quot;&gt;&lt;code&gt;Unix.setsockopt_optint&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b02d9606ae3049641c3c0b7a49b93173582ba252" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unix#VALgetsockopt_optint&quot;&gt;&lt;code&gt;Unix.getsockopt_optint&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unix#VALsetsockopt_optint&quot;&gt;&lt;code&gt;Unix.setsockopt_optint&lt;/code&gt;&lt;/a&gt;. These options have a value of type &lt;code&gt;int&amp;nbsp;option&lt;/code&gt;, with &lt;code&gt;None&lt;/code&gt; meaning ``disabled''.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="773642dab704b446e24c880397ae53bf6b4f36e8" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unixlabels#VALgetsockopt&quot;&gt;&lt;code&gt;UnixLabels.getsockopt&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unixlabels#VALsetsockopt&quot;&gt;&lt;code&gt;UnixLabels.setsockopt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="127c95d87113564ad21001801dba75443274ac20" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unixlabels#VALgetsockopt&quot;&gt;&lt;code&gt;UnixLabels.getsockopt&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unixlabels#VALsetsockopt&quot;&gt;&lt;code&gt;UnixLabels.setsockopt&lt;/code&gt;&lt;/a&gt;. These options have a boolean (&lt;code&gt;true&lt;/code&gt;/&lt;code&gt;false&lt;/code&gt;) value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d121887ffb4d5fad74076fcd7a6ddb33c6b3f62" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unixlabels#VALgetsockopt_float&quot;&gt;&lt;code&gt;UnixLabels.getsockopt_float&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unixlabels#VALsetsockopt_float&quot;&gt;&lt;code&gt;UnixLabels.setsockopt_float&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03fad790fcf2b775879fa18d8ded24985ac1495f" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unixlabels#VALgetsockopt_float&quot;&gt;&lt;code&gt;UnixLabels.getsockopt_float&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unixlabels#VALsetsockopt_float&quot;&gt;&lt;code&gt;UnixLabels.setsockopt_float&lt;/code&gt;&lt;/a&gt;. These options have a floating-point value representing a time in seconds. The value 0 means infinite timeout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cd8b0a441c72f8156f95e88c710953c3fa2ced0" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unixlabels#VALgetsockopt_int&quot;&gt;&lt;code&gt;UnixLabels.getsockopt_int&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unixlabels#VALsetsockopt_int&quot;&gt;&lt;code&gt;UnixLabels.setsockopt_int&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af5931adebaf9a357ecb0df8a73e7c072f718e8d" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unixlabels#VALgetsockopt_int&quot;&gt;&lt;code&gt;UnixLabels.getsockopt_int&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unixlabels#VALsetsockopt_int&quot;&gt;&lt;code&gt;UnixLabels.setsockopt_int&lt;/code&gt;&lt;/a&gt;. These options have an integer value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="021f8090168584ea506e1a7f1144ad38a2016940" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unixlabels#VALgetsockopt_optint&quot;&gt;&lt;code&gt;UnixLabels.getsockopt_optint&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unixlabels#VALsetsockopt_optint&quot;&gt;&lt;code&gt;UnixLabels.setsockopt_optint&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56353b8785e40bfc0f8aeaadd9ecd6af851b7561" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unixlabels#VALgetsockopt_optint&quot;&gt;&lt;code&gt;UnixLabels.getsockopt_optint&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unixlabels#VALsetsockopt_optint&quot;&gt;&lt;code&gt;UnixLabels.setsockopt_optint&lt;/code&gt;&lt;/a&gt;. These options have a value of type &lt;code&gt;int&amp;nbsp;option&lt;/code&gt;, with &lt;code&gt;None&lt;/code&gt; meaning ``disabled''.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55d3d9fad514eda7c3e614c6496c099599e1e6e6" translate="yes" xml:space="preserve">
          <source>The solution of this conundrum is to use an explicitly polymorphic type annotation for the type 'a:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca3eb9c8c5023c43f9da6f2e55f310ac29817523" translate="yes" xml:space="preserve">
          <source>The sort function above does not modify its input list: it builds and returns a new list containing the same elements as the input list, in ascending order. There is actually no way in OCaml to modify a list in-place once it is built: we say that lists are &lt;em&gt;immutable&lt;/em&gt; data structures. Most OCaml data structures are immutable, but a few (most notably arrays) are &lt;em&gt;mutable&lt;/em&gt;, meaning that they can be modified in-place at any time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aef2817764bb52ac263b2fae2a148fec94730b6" translate="yes" xml:space="preserve">
          <source>The space character in format strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0c0e1ff4d5efd916e94aa7b9b072f20bb6cc011" translate="yes" xml:space="preserve">
          <source>The special comment (**/**) tells OCamldoc to discard elements placed after this comment, up to the end of the current class, class type, module or module type, or up to the next stop comment. For instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cebcc58b51afa7136699d267676f15d0e280a3f4" translate="yes" xml:space="preserve">
          <source>The special comment is not already associated to the previous element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5435aaea40f8385771bfff6ba0d166cd3c0eeccb" translate="yes" xml:space="preserve">
          <source>The special comment is not the first one of a toplevel module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06de91b2368326e2f06fbc6d38cdade544c2bc74" translate="yes" xml:space="preserve">
          <source>The specification exception&lt;a href=&quot;typedecl#constr-decl&quot;&gt;constr-decl&lt;/a&gt; in a signature requires the matching structure to provide an exception with the name and arguments specified in the definition, and makes the exception available to all users of the structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc96b351853386bb44b989f2d36255658c8e97cf" translate="yes" xml:space="preserve">
          <source>The specification of a method is written method [private] &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;:&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt;, where &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; is the name of the method and &lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt; its expected type, possibly polymorphic. The flag private indicates that the method cannot be accessed from outside the object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="816c127c5b84f64b52fb9fd685c1cb4ac8a4ea85" translate="yes" xml:space="preserve">
          <source>The standard error output for the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db78c9295b1256ee8e8a6b6086c5f3651f2fa1cd" translate="yes" xml:space="preserve">
          <source>The standard formatter to write to standard output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba48c9ea4ac16d1bd2010fb99db24330d34c33b1" translate="yes" xml:space="preserve">
          <source>The standard input for the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="375db9af8a0d4dc3c0ba86650eeff121048506df" translate="yes" xml:space="preserve">
          <source>The standard input notion for the &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="464e4c58fe500861730075b12f1fb6435b04534f" translate="yes" xml:space="preserve">
          <source>The standard input notion for the &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt; module. &lt;code&gt;Scanning.stdin&lt;/code&gt; is the &lt;a href=&quot;scanf.scanning#TYPEin_channel&quot;&gt;&lt;code&gt;Scanf.Scanning.in_channel&lt;/code&gt;&lt;/a&gt; formatted input channel attached to &lt;a href=&quot;stdlib#VALstdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aecb465e5714800c091e84c331cee9577b92a018" translate="yes" xml:space="preserve">
          <source>The standard library directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="defad1b44801f55e161dc009fb41cef1fe3ba956" translate="yes" xml:space="preserve">
          <source>The standard output for the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1326096be35fcaff4666a9f746f76c98f98925e" translate="yes" xml:space="preserve">
          <source>The str library provides high-level string processing functions, some based on regular expressions. It is intended to support the kind of file processing that is usually performed with scripting languages such as awk, perl or sed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d5110986ab904812febd54df3e70e3cfe974039" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;cmd&lt;/code&gt; is the command to call. The list &lt;code&gt;args&lt;/code&gt; is the list of arguments to pass to this command. It can be empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ea036aba8bc423b44bed368aa0538f1848ee618" translate="yes" xml:space="preserve">
          <source>The string buffer in which &lt;code&gt;str_formatter&lt;/code&gt; writes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a78fd29209652bbda7cca4022b56527d5c814fe" translate="yes" xml:space="preserve">
          <source>The struct custom_operations is defined in &amp;lt;caml/custom.h&amp;gt; and contains the following fields:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a298a05448f3ad20cfa9581c95c5d1288fc8e676" translate="yes" xml:space="preserve">
          <source>The syntactic class of constants comprises literals from the four base types (integers, floating-point numbers, characters, character strings), the integer variants, and constant constructors from both normal and polymorphic variants, as well as the special constants false, true, (), [], and [||], which behave like constant constructors, and beginend, which is equivalent to ().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a830f98dedde0a3c31b9928e1164ca27920971ea" translate="yes" xml:space="preserve">
          <source>The syntax for rules is as usual:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11b8e75b70b6bcdf9c144d7d28884193fb2da070" translate="yes" xml:space="preserve">
          <source>The syntax is exactly the same as for class expressions, but the result is a single object rather than a class. All the constructs described in the rest of this section also apply to immediate objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f75ce09e5843f380505e811b0272a865314bf4e9" translate="yes" xml:space="preserve">
          <source>The syntax of the language is given in BNF-like notation. Terminal symbols are set in typewriter font (likethis). Non-terminal symbols are set in italic font (likethat). Square brackets [&amp;hellip;] denote optional components. Curly brackets {&amp;hellip;} denotes zero, one or several repetitions of the enclosed components. Curly brackets with a trailing plus sign {&amp;hellip;}&lt;sup&gt;+&lt;/sup&gt; denote one or several repetitions of the enclosed components. Parentheses (&amp;hellip;) denote grouping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65737a98101a7097f4f09e81329b8761dd1cfb2a" translate="yes" xml:space="preserve">
          <source>The table below lists the symbols defined in the initial environment and their initial meaning. (See the description of the core library module Stdlib in chapter &amp;zwj;&lt;a href=&quot;core#c%3Acorelib&quot;&gt;22&lt;/a&gt; for more details). Their meaning may be changed at any time using let(&lt;a href=&quot;names#infix-op&quot;&gt;infix-op&lt;/a&gt;)name&lt;sub&gt;1&lt;/sub&gt;name&lt;sub&gt;2&lt;/sub&gt;= &amp;hellip;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa08323f8802e6d50ccec78b682ef7b93d7f7d1e" translate="yes" xml:space="preserve">
          <source>The table below lists the symbols defined in the initial environment and their initial meaning. (See the description of the core library module Stdlib in chapter &lt;a href=&quot;core#c%3Acorelib&quot;&gt;25&lt;/a&gt; for more details). Their meaning may be changed at any time using let(&lt;a href=&quot;names#infix-op&quot;&gt;infix-op&lt;/a&gt;)name&lt;sub&gt;1&lt;/sub&gt;name&lt;sub&gt;2&lt;/sub&gt;= &amp;hellip;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4265c38e98429479cc2782e5d12f7b2b292f3497" translate="yes" xml:space="preserve">
          <source>The table below shows the relative precedences and associativity of operators and non-closed constructions. The constructions with higher precedence come first. For infix and prefix symbols, we write &amp;ldquo;*&amp;hellip;&amp;rdquo; to mean &amp;ldquo;any symbol starting with *&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ca02ca74768b06f8e3e1c2b6d1dd2805e4d9dc1" translate="yes" xml:space="preserve">
          <source>The table below shows the relative precedences and associativity of operators and non-closed pattern constructions. The constructions with higher precedences come first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aaedd4906bf37d963daebc10f3ce2cae137d335" translate="yes" xml:space="preserve">
          <source>The table below shows the relative precedences and associativity of operators and non-closed type constructions. The constructions with higher precedences come first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="873780c573d904e6823105d70079b69ff6aa2a60" translate="yes" xml:space="preserve">
          <source>The tag-marking operation is the simpler tag specific operation: it simply writes a tag specific string into the output device of the formatter. Tag-marking does not interfere with line-splitting computation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e9b336647566103c9dc222eca78097e8e36a10d" translate="yes" xml:space="preserve">
          <source>The tag-printing operation is the more involved tag specific operation: it can print arbitrary material to the formatter. Tag-printing is tightly linked to the current pretty-printer operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc0467c82797c179e1082f88331fe596f582254d" translate="yes" xml:space="preserve">
          <source>The term type we have defined above is an &lt;em&gt;indexed&lt;/em&gt; type, where a type parameter reflects a property of the value contents. Another use of GADTs is &lt;em&gt;singleton&lt;/em&gt; types, where a GADT value represents exactly one type. This value can be used as runtime representation for this type, and a function receiving it can have a polytypic behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bff74d740aa663829cf4f77edbb8806d1bc466d0" translate="yes" xml:space="preserve">
          <source>The termination status of a process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0c71035b432f40f8ce6567e0659d0f94303a4bb" translate="yes" xml:space="preserve">
          <source>The termination status of a process. See module &lt;a href=&quot;sys&quot;&gt;&lt;code&gt;Sys&lt;/code&gt;&lt;/a&gt; for the definitions of the standard signal numbers. Note that they are not the numbers used by the OS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b998179643d8f25a6de4e2f828c6ab63197c25fd" translate="yes" xml:space="preserve">
          <source>The third case is a closed variant type. It gives information about all the possible tags and their associated types, and which tags are known to potentially appear in values. The exact variant type (first case) is just an abbreviation for a closed variant type where all possible tags are also potentially present.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72c73fe652e0c0e0cf068757abf72958b2266b30" translate="yes" xml:space="preserve">
          <source>The threads library allows concurrent programming in OCaml. It provides multiple threads of control (also called lightweight processes) that execute concurrently in the same memory space. Threads communicate by in-place modification of shared data structures, or by sending and receiving data on communication channels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee8a007db9b67f061741b11b1f8ef10fd7dfa6a8" translate="yes" xml:space="preserve">
          <source>The threads library is implemented by time-sharing on a single processor. It will not take advantage of multi-processor machines. Using this library will therefore never make programs run faster. However, many programs are easier to write when structured as several communicating processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27bdd6f835a65a4ddc9fd64736364ffb4476e344" translate="yes" xml:space="preserve">
          <source>The threads library is implemented on top of the threading facilities provided by the operating system: POSIX 1003.1c threads for Linux, MacOS, and other Unix-like systems; Win32 threads for Windows. Only one thread at a time is allowed to run OCaml code, hence opportunities for parallelism are limited to the parts of the program that run system or C library code. However, threads provide concurrency and can be used to structure programs as several communicating processes. Threads also efficiently support concurrent, overlapping I/O operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5a20efffaf644d1427994b098f56c7f31e6be5e" translate="yes" xml:space="preserve">
          <source>The three kinds of interval timers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b1f416d7e4aa2468aa653df39f4953c40bbd756" translate="yes" xml:space="preserve">
          <source>The three type parameters to &lt;code&gt;Genarray.t&lt;/code&gt; identify the array element kind and layout, as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27a8084722c0c59b716ab80edd05f2b005dea978" translate="yes" xml:space="preserve">
          <source>The toplevel system does not perform line editing, but it can easily be used in conjunction with an external line editor such as ledit, or rlwrap. An improved toplevel, utop, is also available. Another option is to use ocaml under Gnu Emacs, which gives the full editing power of Emacs (command run-caml from library inf-caml).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0efc25c223657f44333e6ed3dee74d2f834fa753" translate="yes" xml:space="preserve">
          <source>The total amount of memory allocated by the program since it was started is (in words) &lt;code&gt;minor_words&amp;nbsp;+&amp;nbsp;major_words&amp;nbsp;-&amp;nbsp;promoted_words&lt;/code&gt;. Multiply by the word size (4 on a 32-bit machine, 8 on a 64-bit machine) to get the number of bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4eb40ef4dc24c3e0ad0bdb73cac37d303dc7aee" translate="yes" xml:space="preserve">
          <source>The transformation is implemented by adding a new wrapper function in the manner of that used when unboxing specialised arguments. The closure variables are still free in the wrapper, but the intention is that when the wrapper is inlined at direct call sites, the relevant values are passed directly to the main function via the new specialised arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e984d305346aebd0ab69a424dfacb7e6aa1b981" translate="yes" xml:space="preserve">
          <source>The transformation is implemented by creating a wrapper function that accepts the original arguments. Meanwhile, the original function is renamed and extra arguments are added corresponding to the unboxed specialised arguments; this new function is called from the wrapper. The wrapper will then be inlined at direct call sites. Indeed, all call sites will be direct unless -unbox-closures is being used, since they will have been generated by the compiler when originally specialising the function. (In the case of -unbox-closures other functions may appear with specialised arguments; in this case there may be indirect calls and these will incur a small penalty owing to having to bounce through the wrapper. The technique of &lt;em&gt;direct call surrogates&lt;/em&gt; used for -unbox-closures is not used by the transformation to unbox specialised arguments.)</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
