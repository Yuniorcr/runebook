<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="ocaml">
    <body>
      <group id="ocaml">
        <trans-unit id="20b2d8ee46fbd0ec43648349d2f501735b50eb59" translate="yes" xml:space="preserve">
          <source>The complete OCaml distribution can be accessed via the &lt;a href=&quot;https://ocaml.org/&quot;&gt;ocaml.org website&lt;/a&gt;. This site contains a lot of additional information on OCaml.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="581d160324d6b1dcf6f5966e788655a0b8d7c61c" translate="yes" xml:space="preserve">
          <source>The complex number &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a94f375eaa7012dabdc57ca285225234540e0a33" translate="yes" xml:space="preserve">
          <source>The complex number &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b43370e6d1b0c376b1980b552194da8b6181987d" translate="yes" xml:space="preserve">
          <source>The complex number &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ad39316a87edf772e43a6c5b64a3e41e9c0e181" translate="yes" xml:space="preserve">
          <source>The concrete type describing the behavior associated with a keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79be6aae51e8c401b2476f5b4f2a107a9fdc32ef" translate="yes" xml:space="preserve">
          <source>The constant pi.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ad8c44fad65df83c02fac0ee5f9d77f6672d992" translate="yes" xml:space="preserve">
          <source>The constraint on self&amp;rsquo;s type is requiring a public move method, and this is sufficient to override private.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a279814e737c452af822699c5733e5455892c221" translate="yes" xml:space="preserve">
          <source>The constraints associated to each constructor can be recovered through pattern-matching. Namely, if the type of the scrutinee of a pattern-matching contains a locally abstract type, this type can be refined according to the constructor used. These extra constraints are only valid inside the corresponding branch of the pattern-matching. If a constructor has some existential variables, fresh locally abstract types are generated, and they must not escape the scope of this branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72a6619fc6d35a54f266cbb1b53bb99ad5b03227" translate="yes" xml:space="preserve">
          <source>The construct constraint'&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;=&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; allows the specification of type parameters. Any actual type argument corresponding to the type parameter &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; has to be an instance of &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; (more precisely, &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; and &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; are unified). Type variables of &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; can appear in the type equation and the type declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6dcf637d8dc6131f0b0eb619e7d7999e61b6d1b" translate="yes" xml:space="preserve">
          <source>The construct constraint&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; forces the two type expressions to be equal. This is typically used to specify type parameters: in this way, they can be bound to specific type expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e91937a9ebb9b2f875d8df7aec3ae920407278b6" translate="yes" xml:space="preserve">
          <source>The construct constraint&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; forces the two type expressions to be equals. This is typically used to specify type parameters: in that way they can be bound to specific type expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4111af28e88c74529d924590f2259579d7eddcd6" translate="yes" xml:space="preserve">
          <source>The construction moduletypeof&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt; expands to the module type (signature or functor type) inferred for the module expression &lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;. To make this module type reusable in many situations, it is intentionally not strengthened: abstract types and datatypes are not explicitly related with the types of the original module. For the same reason, module aliases in the inferred type are expanded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="760fdc00af3cbc0e13df9af8553cc7a286bca119" translate="yes" xml:space="preserve">
          <source>The constructor &lt;code&gt;()&lt;/code&gt; is included here so that it has a path, but it is not intended to be used in user-defined data types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3003c0bbe668e94ab79defd3f710132d87092a6" translate="yes" xml:space="preserve">
          <source>The constructors &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;true&lt;/code&gt; are included here so that they have paths, but they are not intended to be used in user-defined data types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16640eb9daf1519aa608d0b29675645a8a35f3cb" translate="yes" xml:space="preserve">
          <source>The content inside {%foo: ... %} is target-specific and will only be interpreted by the backend foo, and ignored by the others. The backends of the distribution are latex, html, texi and man. If no target is specified (syntax {% ... %}), latex is chosen by default. Custom generators may support their own target prefix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c5c2fffb0418b713216d4c77f75ee03f3710a80" translate="yes" xml:space="preserve">
          <source>The contents of custom blocks are not scanned by the garbage collector, and must therefore not contain any pointer inside the OCaml heap. In other terms, never store an OCaml value in a custom block, and do not use Field, Store_field nor caml_modify to access the data part of a custom block. Conversely, any C data structure (not containing heap pointers) can be stored in a custom block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="785642c4a4c006be73a07a4f7ec8afa9d91aa1ff" translate="yes" xml:space="preserve">
          <source>The conventional name for the current directory (e.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab0089cb61bfc166d7c15a2b68e795215831943d" translate="yes" xml:space="preserve">
          <source>The conventional name for the current directory (e.g. &lt;code&gt;.&lt;/code&gt; in Unix).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="545670a3a8b2e0fff49a5ac43c08636390916185" translate="yes" xml:space="preserve">
          <source>The conventional name for the parent of the current directory (e.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b950ea81536e7df7421680a6cf3781982072c75" translate="yes" xml:space="preserve">
          <source>The conventional name for the parent of the current directory (e.g. &lt;code&gt;..&lt;/code&gt; in Unix).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33e422b54f028d0f9f99ad979df276c42ced7356" translate="yes" xml:space="preserve">
          <source>The conversion characters and their meanings are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cb23e02c094574c60663d78adfeb6ade600463a" translate="yes" xml:space="preserve">
          <source>The corresponding C type must be intnat.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31b0b9138835461b550a52acf6e1102fcf625f54" translate="yes" xml:space="preserve">
          <source>The cost of a &lt;em&gt;primitive&lt;/em&gt;. Primitives encompass operations including arithmetic and memory access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2821dc95f75734aab94e295a923c218e0df1c9bf" translate="yes" xml:space="preserve">
          <source>The cost of a branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c804487a1287d7acc06a19d856642958b1444628" translate="yes" xml:space="preserve">
          <source>The cost of a direct function call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="534cefa77673c331e56e7d9f6dd6b1f2ed24344c" translate="yes" xml:space="preserve">
          <source>The cost of an allocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c86a389e7f94b0cbdc2d7b61509a2068780aa63" translate="yes" xml:space="preserve">
          <source>The cost of an indirect function call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ad4c2d03309e92f9ae01be1d5e41f51136f454b" translate="yes" xml:space="preserve">
          <source>The current default is next-fit, as the best-fit policy is new and not yet widely tested. We expect best-fit to become the default in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b8c08752945457971d1f3f4ac09df0af940d32a" translate="yes" xml:space="preserve">
          <source>The current implementation limits each variant type to have at most 246 non-constant constructors and 2&lt;sup&gt;30&lt;/sup&gt;&amp;minus;1 constant constructors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9a96ae8d528ab0d30d73879bd55f0ed974647fc" translate="yes" xml:space="preserve">
          <source>The current implementation places practically no restrictions on the length of string literals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8888fe7c320796681a86d9fc38d5331494f11ea4" translate="yes" xml:space="preserve">
          <source>The current implementation uses Heap Sort. It runs in constant stack space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa3296295a4df646c086eb4650f57f70f9f85c18" translate="yes" xml:space="preserve">
          <source>The current implementation uses Merge Sort. It runs in constant heap space and logarithmic stack space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5d51df06a97d47df008e45a13c0928311228904" translate="yes" xml:space="preserve">
          <source>The current implementation uses Merge Sort. It uses &lt;code&gt;n/2&lt;/code&gt; words of heap space, where &lt;code&gt;n&lt;/code&gt; is the length of the array. It is usually faster than the current implementation of &lt;a href=&quot;arraylabels#VALsort&quot;&gt;&lt;code&gt;ArrayLabels.sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d71af0bf722f0a317f82d7cfc36b49481534370f" translate="yes" xml:space="preserve">
          <source>The current implementation uses Merge Sort. It uses a temporary array of length &lt;code&gt;n/2&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the length of the array. It is usually faster than the current implementation of &lt;a href=&quot;array#VALsort&quot;&gt;&lt;code&gt;Array.sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdff8609298ac6203743f842126dd2f7ca872714" translate="yes" xml:space="preserve">
          <source>The current implementation uses Merge Sort. It uses a temporary floatarray of length &lt;code&gt;n/2&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the length of the floatarray. It is usually faster than the current implementation of &lt;a href=&quot;float.array#VALsort&quot;&gt;&lt;code&gt;Float.Array.sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b20647dbf18c92523a7fd6b83c3b58c9724e3e7a" translate="yes" xml:space="preserve">
          <source>The custom break is useful if you want to change which visible (non-whitespace) characters are printed in case of break or no break. For example, when printing a list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b24549afabe1745d997e15b64b4d2aae161436a" translate="yes" xml:space="preserve">
          <source>The data is considered by the garbage collector alive if all the full keys are alive and if the ephemeron is alive. When one of the keys is not considered alive anymore by the GC, the data is emptied from the ephemeron. The data could be alive for another reason and in that case the GC will not free it, but the ephemeron will not hold the data anymore.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac0854565c0cabc94cf88db7d79f91eea95e9a7c" translate="yes" xml:space="preserve">
          <source>The data part of a custom block v can be accessed via the pointer Data_custom_val(v). This pointer has type void * and should be cast to the actual type of the data stored in the custom block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8e6e6b562a36d00a364c6de4dc0a4ef30f6a91f" translate="yes" xml:space="preserve">
          <source>The debugger can print the current value of simple expressions. The expressions can involve program variables: all the identifiers that are in scope at the selected program point can be accessed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8c3dc260564ad64dea40270472823def2648071" translate="yes" xml:space="preserve">
          <source>The debugger communicate with the program being debugged through a Unix socket. You may need to change the socket name, for example if you need to run the debugger on a machine and your program on another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89cf1e71a9b9ce7771fbb1158aff4c5ec71b350f" translate="yes" xml:space="preserve">
          <source>The debugger execute the OCaml runtime ocamlrun on the program. Rarely useful; moreover it prevents the debugging of programs compiled in &amp;ldquo;custom runtime&amp;rdquo; mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8a4e05ea8e12b749680b25bf9ad4fb77bd551fb" translate="yes" xml:space="preserve">
          <source>The debugger is compatible with the Dynlink module. However, when an external module is not yet loaded, it is impossible to set a breakpoint in its code. In order to facilitate setting breakpoints in dynamically loaded code, the debugger stops the program each time new modules are loaded. This behavior can be disabled using the break_on_load variable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67085f47487648631c3de0d3b7f5a54b54f116e7" translate="yes" xml:space="preserve">
          <source>The debugger searches for source files and compiled interface files in a list of directories, the search path. The search path initially contains the current directory . and the standard library directory. The directory command adds directories to the path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d81bce2c8314b77a05e6061c8832d983f35d9089" translate="yes" xml:space="preserve">
          <source>The debugger starts executing the debugged program only when needed. This allows setting breakpoints or assigning debugger variables before execution starts. There are several ways to start execution:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c85faabbbf8e1f661bc7a77c9db172d2189ae3c" translate="yes" xml:space="preserve">
          <source>The declaration of a variant type lists all possible forms for values of that type. Each case is identified by a name, called a constructor, which serves both for constructing values of the variant type and inspecting them by pattern-matching. Constructor names are capitalized to distinguish them from variable names (which must start with a lowercase letter). For instance, here is a variant type for doing mixed arithmetic (integers and floats):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dc771c421fb48e91d66c641d430796a079c9f9c" translate="yes" xml:space="preserve">
          <source>The declarations of the built-in types and the components of module Stdlib are printed one by one in typewriter font, followed by a short comment. All library modules and the components they provide are indexed at the end of this report.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2765fb82c88da6a8123fcc1afb411e9f247fbfa9" translate="yes" xml:space="preserve">
          <source>The default representation. In the present version of OCaml, the default is the boxed representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74b33452fd1e9690245e62c43fa2151918346419" translate="yes" xml:space="preserve">
          <source>The default setting is &amp;rsquo;auto&amp;rsquo;, and the current heuristic checks that the TERM environment variable exists and is not empty or dumb, and that &amp;rsquo;isatty(stderr)&amp;rsquo; holds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08126df5b12a33c60b2609d1299988ea98c261cf" translate="yes" xml:space="preserve">
          <source>The default setting is -w +a-4-6-7-9-27-29-32..42-44-45-48-50-60. It is displayed by  -help. Note that warnings 5 and 10 are not always triggered, depending on the internals of the type checker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed097a6c98a3e8cb9832ea96755d5d9244c148bd" translate="yes" xml:space="preserve">
          <source>The default setting is -w +a-4-6-7-9-27-29-32..42-44-45-48-50-60. It is displayed by ocamlc -help. Note that warnings 5 and 10 are not always triggered, depending on the internals of the type checker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ab6f8a18cb9ae711fa680c3d32f93edfefbee98" translate="yes" xml:space="preserve">
          <source>The default setting is -w +a-4-6-7-9-27-29-32..42-44-45-48-50-60. It is displayed by ocamlopt -help. Note that warnings 5 and 10 are not always triggered, depending on the internals of the type checker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eff228cd3aa401186be612172c09c21427569b2" translate="yes" xml:space="preserve">
          <source>The default setting is -warn-error -a+31 (only warning 31 is fatal).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8b548e294caad0232bcef920b432423c497646b" translate="yes" xml:space="preserve">
          <source>The default setting is contextual.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4549da8d617844ebcd908e7e44273e838886bca2" translate="yes" xml:space="preserve">
          <source>The default settings (when not using -Oclassic) are for one round of optimisation using the following parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f4796a7bec8a2fd44bd0c64ad6daa008bf2c968" translate="yes" xml:space="preserve">
          <source>The default trace filename is caml-{PID}.eventlog, where {PID} is the process identifier of the traced program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56ba28d4eda458e2debd6c11d3035373c9678204" translate="yes" xml:space="preserve">
          <source>The definition val [mutable] &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; adds an instance variable &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt; whose initial value is the value of expression &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;. The flag mutable allows physical modification of this variable by methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a51442850ae9805c91c304fd05e9989dc50518ce" translate="yes" xml:space="preserve">
          <source>The deserialize field can be set to custom_deserialize_default to indicate that deserialization is not supported. In this case, do not register the struct custom_operations with the deserializer using register_custom_operations (see below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d06ebe0f4fedec527437bd502a65f8f670ba5db" translate="yes" xml:space="preserve">
          <source>The deserialize field contains a pointer to a C function that is called whenever a custom block with identifier identifier needs to be deserialized (un-marshaled) using the OCaml functions input_value or Marshal.from_.... This user-provided function is responsible for reading back the data written by the serialize operation, using the deserialize_... functions defined in &amp;lt;caml/intext.h&amp;gt; and listed below. It must then rebuild the data part of the custom block and store it at the pointer given as the dst argument. Finally, it returns the size in bytes of the data part of the custom block. This size must be identical to the wsize_32 result of the serialize operation if the architecture is 32 bits, or wsize_64 if the architecture is 64 bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e12a3fa498a55d5d0c412779070a2ed53e0f6b56" translate="yes" xml:space="preserve">
          <source>The deterministic automata generated by ocamllex are limited to at most 32767 transitions. The message above indicates that your lexer definition is too complex and overflows this limit. This is commonly caused by lexer definitions that have separate rules for each of the alphabetic keywords of the language, as in the following example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f264a27cdcd5df325cf7076559a44cc284c906a3" translate="yes" xml:space="preserve">
          <source>The deterministic automata generated by ocamllex maintain a table of positions inside the scanned lexer buffer. The size of this table is limited to at most 255 cells. This error should not show up in normal situations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3158707a3751ac6c5252dbe261969b8247c51cac" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;1.0&lt;/code&gt; and the smallest exactly representable floating-point number greater than &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2adcbc0a31dc0085a55ca93ed2f074bdee4bf581" translate="yes" xml:space="preserve">
          <source>The difference between open and include is that open simply provides short names for the components of the opened structure, without defining any components of the current structure, while include also adds definitions for the components of the included structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aa0efd021b346152ef35413cf1dcb66bfc3d8c0" translate="yes" xml:space="preserve">
          <source>The difficulty usually lies in defining instances of the pattern above by inheritance. This can be done in a natural and obvious manner in OCaml, as shown on the following example manipulating windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c440f9c47d69da4fc51fae25d28e485866ceeae" translate="yes" xml:space="preserve">
          <source>The directory containing the OCaml standard library. (If OCAMLLIB is not set, CAMLLIB will be used instead.) Used to locate the ld.conf configuration file for dynamic loading (see section &lt;a href=&quot;#s%3Aocamlrun-dllpath&quot;&gt;11.3&lt;/a&gt;). If not set, default to the library directory specified when compiling OCaml.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84d3f5e5913ebfecb51ac69e325978cd0b7f44c0" translate="yes" xml:space="preserve">
          <source>The directory separator (e.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ff406baa499fe8d2e26970180e41618d3f08eae" translate="yes" xml:space="preserve">
          <source>The directory separator (e.g. &lt;code&gt;/&lt;/code&gt; in Unix).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cabc8641d53a500b754d86780ff17e145160ba34" translate="yes" xml:space="preserve">
          <source>The distinction between &lt;code&gt;bytes&lt;/code&gt; and &lt;code&gt;string&lt;/code&gt; was introduced in OCaml 4.02, and the &quot;unsafe-string&quot; compatibility mode was the default until OCaml 4.05. Starting with 4.06, the compatibility mode is opt-in; we intend to remove the option in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8186633942c846dfc9406083eb5c8a8657d3ebba" translate="yes" xml:space="preserve">
          <source>The domain of a coercion can often be omitted. For instance, one can define:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f7c83c21065a6dbadc8d2a47e55b23520a044b2" translate="yes" xml:space="preserve">
          <source>The dump file is written only if the program terminates normally (by calling exit or by falling through). It is not written if the program terminates with an uncaught exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73f7bba6640e6313fca9805d26493bd64599c1bc" translate="yes" xml:space="preserve">
          <source>The dynlink library supports type-safe dynamic loading and linking of bytecode object files (.cmo and .cma files) in a running bytecode program, or of native plugins (usually .cmxs files) in a running native program. Type safety is ensured by limiting the set of modules from the running program that the loaded object file can access, and checking that the running program and the loaded object file have been compiled against the same interfaces for these modules. In native code, there are also some compatibility checks on the implementations (to avoid errors with cross-module optimizations); it might be useful to hide .cmx files when building native plugins so that they remain independent of the implementation of modules in the main program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfccb11647d7c3a22dd1b9fca91bf4419d42d590" translate="yes" xml:space="preserve">
          <source>The easiest way to define a custom generator is the following this example, here extending the current HTML generator. We don&amp;rsquo;t have to know if this is the original HTML generator defined in ocamldoc or if it has been extended already by a previously loaded custom generator :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58f055689b02c7748240c0805950d6c0e3a0e111" translate="yes" xml:space="preserve">
          <source>The elements are passed to &lt;code&gt;f&lt;/code&gt; in increasing order with respect to the ordering over the type of the elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6710aa8b225c8ca5f7b41012a718cf1001e66889" translate="yes" xml:space="preserve">
          <source>The else&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt; part can be omitted, in which case it defaults to else().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9282996444b9faf1c947138395efb723dd3e6881" translate="yes" xml:space="preserve">
          <source>The empty map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e51b0d5d7e271c88e867edd7cf3a56d6061ba51" translate="yes" xml:space="preserve">
          <source>The empty sequence, containing no elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ac903ee0be4b8d03c2629dea67dc51a5e1dc555" translate="yes" xml:space="preserve">
          <source>The empty set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcc5ac53238f78e7ccd13efd320b3aba2a2a43c4" translate="yes" xml:space="preserve">
          <source>The environment variable OCAML_COLOR is considered if -color is not provided. Its values are auto/always/never as above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc5a16c0802c0d6eab8dd39659b932cb9d3eeec2" translate="yes" xml:space="preserve">
          <source>The environment variable OCAML_ERROR_STYLE is considered if -error-style is not provided. Its values are short/contextual as above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7f093c02c802f297eef039f1f8ed6be219bfe78" translate="yes" xml:space="preserve">
          <source>The ephemerons complicate the notion of liveness of values, because it is not anymore an equivalence with the reachability from root value by usual pointers (not weak and not ephemerons). With ephemerons the notion of liveness is constructed by the least fixpoint of: A value is alive if:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f38c615e4885039a9f6a96adebc7d8b6a2703f76" translate="yes" xml:space="preserve">
          <source>The equal function for 16-character digest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4745822a26883aa3e079c90a04c121006a19e95e" translate="yes" xml:space="preserve">
          <source>The equal function for chars.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="975faf8015348dfd4f8f27ef557f89666b74bd4f" translate="yes" xml:space="preserve">
          <source>The equal function for floating-point numbers, compared using &lt;a href=&quot;float#VALcompare&quot;&gt;&lt;code&gt;Float.compare&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f25af14cf81fd197468c0aef6ee60036c040bc5" translate="yes" xml:space="preserve">
          <source>The equal function for int32s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43353326c31a51a2e1e40be3cfbc055a576f0c46" translate="yes" xml:space="preserve">
          <source>The equal function for int64s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9acc244879540dd60658943a5fc7d40212cd5702" translate="yes" xml:space="preserve">
          <source>The equal function for native ints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="287fd038b43c08ac15387236db89c8b9dfd89564" translate="yes" xml:space="preserve">
          <source>The equal function for strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a7926a9ee2ed830da3e6706d16691abddc39c2a" translate="yes" xml:space="preserve">
          <source>The equality function for byte sequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af06b8ab4789de98e0de35bd84609d867593cd6b" translate="yes" xml:space="preserve">
          <source>The equality predicate used to compare keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83858c6c1566ad5f65edb208e38dd2558053de52" translate="yes" xml:space="preserve">
          <source>The equivalent of -inline but used when speculative inlining starts at toplevel. See section &lt;a href=&quot;#ss%3Aflambda-speculation&quot;&gt;21.3.6&lt;/a&gt;. Not used in -Oclassic mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94cdb8a214ed46b885c25876cd3600fef2503877" translate="yes" xml:space="preserve">
          <source>The error messages are almost identical to those of ocamlc. See section &lt;a href=&quot;comp#s%3Acomp-errors&quot;&gt;9.4&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f378c773556e60ceb5a7a9d15fb2d1a81df83d7" translate="yes" xml:space="preserve">
          <source>The evaluation of the body of a class only takes place at object creation time. Therefore, in the following example, the instance variable x is initialized to different values for two different objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="823e43ea0dd60b51d8777275d399ee78c608b08d" translate="yes" xml:space="preserve">
          <source>The exact definition of which free variables are captured in a closure is not specified and can vary between bytecode and native code (and according to optimization flags). In particular, a function value accessing a global reference may or may not include the reference in its closure. If it does, unmarshaling the corresponding closure will create a new reference, different from the global one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="367c1c92926004568a37375dcb37462e755ae202" translate="yes" xml:space="preserve">
          <source>The execution of a program is affected by certain information it receives when the debugger starts it, such as the command-line arguments to the program and its working directory. The debugger provides commands to specify this information (set arguments and cd). These commands must be used before program execution starts. If you try to change the arguments or the working directory after starting your program, the debugger will kill the program (after asking for confirmation).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="891519fb02f7659ffef41323f18ea6f26295ee67" translate="yes" xml:space="preserve">
          <source>The execution times (CPU times) of a process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea3566383d4d77e6af67a2d9e1c982e58d1aacae" translate="yes" xml:space="preserve">
          <source>The exhaustiveness check is aware of GADT constraints, and can automatically infer that some cases cannot happen. For instance, the following pattern matching is correctly seen as exhaustive (the Add case cannot happen).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="682f2afe18d27a6b2d5109af77f4241c373f09ce" translate="yes" xml:space="preserve">
          <source>The expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48d5ec0634b8a1782837ee8b1ca9761b0c8a2b02" translate="yes" xml:space="preserve">
          <source>The expression (&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;) evaluates to the same module as &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc9adc4308aa68c065cc84caf08fbc1ea795d7aa" translate="yes" xml:space="preserve">
          <source>The expression (&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;:&lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt;) checks that &lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt; matches the type of &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; (that is, that the implementation &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; meets the type specification &lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt;). The whole expression evaluates to the same class as &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;, except that all components not specified in &lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt; are hidden and can no longer be accessed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f1374da867ccabac7aad3663177813cdc0a9fa8" translate="yes" xml:space="preserve">
          <source>The expression (&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;) evaluates to the same module as &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fd1fd31681b7a2cf0269cba7eed69aec7e48ffe" translate="yes" xml:space="preserve">
          <source>The expression (&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;) checks that the type of &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt; is a subtype of &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;, that is, that all components specified in &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt; are implemented in &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;, and their implementation meets the requirements given in &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;. In other terms, it checks that the implementation &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt; meets the type specification &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;. The whole expression evaluates to the same module as &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;, except that all components not specified in &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt; are hidden and can no longer be accessed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bef2d23b52ee970fade1b06935e7b9ced9f528d5" translate="yes" xml:space="preserve">
          <source>The expression (module&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;:&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;) converts the module (structure or functor) denoted by module expression &lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt; to a value of the core language that encapsulates this module. The type of this core language value is (module&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;). The &lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt; annotation can be omitted if it can be inferred from the context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3d05c07c0894d4fd053f92bb2e5d69fce8d15a3" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;#&lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; invokes the method &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; of the object denoted by &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5fe9ec8f9aa27454f205256c37ed9a50e6170e6" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&amp;amp;&amp;amp;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; evaluates to true if both &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; evaluate to true; otherwise, it evaluates to false. The first component, &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, is evaluated first. The second component, &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;, is not evaluated if the first component evaluates to false. Hence, the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&amp;amp;&amp;amp;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; behaves exactly as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67be0419a621a610a2e5884430cdee8308e61e8d" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; ,&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; evaluates to the n-tuple of the values of expressions &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;. The evaluation order of the subexpressions is not specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f82e349965c8472e346c4996f8f13cfaa04ee8f5" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.(&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;) returns the value of element number &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; in the array denoted by &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;. The first element has number 0; the last element has number n&amp;minus;1, where n is the size of the array. The exception Invalid_argument is raised if the access is out of bounds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b86cf48755f90d38c3703b093a559d201d41505d" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.(&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;)&amp;lt;-&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt; modifies in-place the array denoted by &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, replacing element number &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; by the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;. The exception Invalid_argument is raised if the access is out of bounds. The value of the whole expression is ().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82e23d1a40c45b5cca334a602a3b8464c8cb5ac6" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt; evaluates &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to a record value, and returns the value associated to &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt; in this record value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fac0b26bb16a9c0e18d3fa3496db97765aa8519f" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&amp;lt;-&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; evaluates &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to a record value, which is then modified in-place by replacing the value associated to &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt; in this record by the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. This operation is permitted only if &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt; has been declared mutable in the definition of the record type. The whole expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&amp;lt;-&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; evaluates to the unit value ().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cd6fc3dc672a6d7077ed6957a582e1952b94590" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.[&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;] returns the value of character number &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; in the string denoted by &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;. The first character has number 0; the last character has number n&amp;minus;1, where n is the length of the string. The exception Invalid_argument is raised if the access is out of bounds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19a3eefaad7e437247b3bc6db656e1c074dfe4b0" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.[&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;]&amp;lt;-&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt; modifies in-place the string denoted by &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, replacing character number &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; by the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;. The exception Invalid_argument is raised if the access is out of bounds. The value of the whole expression is ().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54bc0bbda0902a87059f4ab52fd17c9a2c5cb0cd" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; evaluates &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; first, then &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;, and returns the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3309f1c657c39dcf14b482d1d2b52b485c6e1c1" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;||&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; evaluates to true if one of the expressions &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; evaluates to true; otherwise, it evaluates to false. The first component, &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, is evaluated first. The second component, &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;, is not evaluated if the first component evaluates to true. Hence, the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;||&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; behaves exactly as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="465cc162397700c3a7233e4d6be2e63f71fde0fe" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;(&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;) evaluates &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to a functor and &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; to a module, and applies the former to the latter. The type of &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; must match the type expected for the arguments of the functor &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e4e8d9bdc0d328e50497d061e05aaaa6759bfe6" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt; evaluates to the class bound to the name &lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt;. Similarly, the expression [&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;]&lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt; evaluates to the parametric class bound to the name &lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt;, in which type parameters have been instantiated respectively to &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88f78fb35dd0d933beef57fab438013880471ef8" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt; is equivalent to the class type bound to the name &lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt;. Similarly, the expression [&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;]&lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt; is equivalent to the parametric class type bound to the name &lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt;, in which type parameters have been instantiated to respectively &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bdccee9cf7f9a846ebb0d6ce9a9a4d063b0d4f4" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;(&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;) evaluates to the variant value whose constructor is &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;, and whose arguments are the values of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd2b0c9502549e5b50e4ab2002a089216e807b74" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; evaluates to the unary variant value whose constructor is &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;, and whose argument is the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. Similarly, the expression &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;(&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; ,&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;) evaluates to the n-ary variant value whose constructor is &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; and whose arguments are the values of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86658bc3c80f7feb554c6583c0fa9ad438f2d77f" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;&amp;lt;-&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; modifies in-place the current object by replacing the value associated to &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt; by the value of &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;. Of course, this instance variable must have been declared mutable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ac13a35707432acbcfeb9a3119c7ad181cc342a" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;names#modtype-path&quot;&gt;modtype-path&lt;/a&gt; is equivalent to the module type bound to the name &lt;a href=&quot;names#modtype-path&quot;&gt;modtype-path&lt;/a&gt;. The expression (&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;) denotes the same type as &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63b697cf7e46dafd21affd4bfc9ae60ca539fafc" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; evaluates to the module bound to the name &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="374fd1d5eec03fb1c40077ef206acff290b1b338" translate="yes" xml:space="preserve">
          <source>The expression [|&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip; ;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;|] evaluates to a n-element array, whose elements are initialized with the values of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; respectively. The order in which these expressions are evaluated is unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e45182f3efd80314e85a55d033c068a05794bdeb" translate="yes" xml:space="preserve">
          <source>The expression `&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; evaluates to the polymorphic variant value whose tag is &lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;, and whose argument is the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7801f0a175513fedc9db3b2ea095ee870659f32" translate="yes" xml:space="preserve">
          <source>The expression does not change the observable state of the world save for possibly affecting the state of the garbage collector by performing an allocation. Expressions that only have generative effects and whose results are unused may be eliminated by the compiler. However, unlike expressions with &amp;ldquo;no effects&amp;rdquo;, such expressions will never be eligible for duplication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06268c11c08cbf54ec4d6dfccb9fea053ea40756" translate="yes" xml:space="preserve">
          <source>The expression does not change the observable state of the world. For example, it must not write to any mutable storage, call arbitrary external functions or change control flow (e.g. by raising an exception). Note that allocation is &lt;em&gt;not&lt;/em&gt; classed as having &amp;ldquo;no effects&amp;rdquo; (see below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54674c43e48502affde9ef34390ab16ef7402518" translate="yes" xml:space="preserve">
          <source>The expression does not observe the effects (in the sense described above) of other expressions. For example, it must not read from any mutable storage or call arbitrary external functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66513182b7246bbaa2fec620bc98c1dc1505d3a1" translate="yes" xml:space="preserve">
          <source>The expression e in let x = e in e&amp;rsquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fafa3e808d29aa326f8219b2a729faf94bb92f2f" translate="yes" xml:space="preserve">
          <source>The expression forname=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;downto&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;do&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;done evaluates similarly, except that name is successively bound to the values n, n&amp;minus;1, &amp;hellip;, p+1, p. The loop body is never evaluated if n &amp;lt; p.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d57f96f2e7c598ac2e5a92cdba5ecd224f400d7" translate="yes" xml:space="preserve">
          <source>The expression forname=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;to&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;do&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;done first evaluates the expressions &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; (the boundaries) into integer values n and p. Then, the loop body &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt; is repeatedly evaluated in an environment where name is successively bound to the values n, n+1, &amp;hellip;, p&amp;minus;1, p. The loop body is never evaluated if n &amp;gt; p.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13ea45faff3269f614a52ad4b80de5d2a8ebf30f" translate="yes" xml:space="preserve">
          <source>The expression fun [[?]&lt;a href=&quot;lex#label-name&quot;&gt;label-name&lt;/a&gt;:] &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;-&amp;gt;&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; evaluates to a function from values to classes. When this function is applied to a value v, this value is matched against the pattern &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt; and the result is the result of the evaluation of &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; in the extended environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a2641611d76e3a4d8e4ffbce3daf0019fe517c9" translate="yes" xml:space="preserve">
          <source>The expression fun(type&lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;)-&amp;gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; introduces a type constructor named &lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt; which is considered abstract in the scope of the sub-expression, but then replaced by a fresh type variable. Note that contrary to what the syntax could suggest, the expression fun(type&lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;)-&amp;gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; itself does not suspend the evaluation of &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; as a regular abstraction would. The syntax has been chosen to fit nicely in the context of function declarations, where it is generally used. It is possible to freely mix regular function parameters with pseudo type parameters, as in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc2f0b7a211a145ce7e8a7301a70f0d4c7d342fe" translate="yes" xml:space="preserve">
          <source>The expression functor(&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;)-&amp;gt;&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt; evaluates to a functor that takes as argument modules of the type &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, binds &lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt; to these modules, evaluates &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt; in the extended environment, and returns the resulting modules as results. No restrictions are placed on the type of the functor argument; in particular, a functor may take another functor as argument (&amp;ldquo;higher-order&amp;rdquo; functor).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39045ca493f5041229a426581d36cb35d6454361" translate="yes" xml:space="preserve">
          <source>The expression if&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;then&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;else&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt; evaluates to the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; if &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; evaluates to the boolean true, and to the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt; if &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; evaluates to the boolean false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cee2fb74666dafe45945b12c3589890b3ad2f7a" translate="yes" xml:space="preserve">
          <source>The expression include&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt; in a structure re-exports in the current structure all definitions of the structure denoted by &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;. For instance, if you define a module S as below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5348485cb90b4b3e0999ac25862d4723d8c8e9d9" translate="yes" xml:space="preserve">
          <source>The expression include&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt; in a signature performs textual inclusion of the components of the signature denoted by &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;. It behaves as if the components of the included signature were copied at the location of the include. The &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt; argument must refer to a module type that is a signature, not a functor type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2aa219207ffe702cd009fe575887afe0cfda1d7" translate="yes" xml:space="preserve">
          <source>The expression is not evaluated this time; notice that &amp;ldquo;lazy_two evaluation&amp;rdquo; is not printed. The result of the initial computation is simply returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bad5791aee2947a352057622227636c6db71ed9" translate="yes" xml:space="preserve">
          <source>The expression lazy&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; returns a value v of type Lazy.t that encapsulates the computation of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. The argument &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; is not evaluated at this point in the program. Instead, its evaluation will be performed the first time the function Lazy.force is applied to the value v, returning the actual value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. Subsequent applications of Lazy.force to v do not evaluate &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; again. Applications of Lazy.force may be implicit through pattern matching (see &lt;a href=&quot;patterns#sss%3Apat-lazy&quot;&gt;7.6&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d836be1d196aa1c9fd598fef8e21c88679d68ac4" translate="yes" xml:space="preserve">
          <source>The expression letmodule&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;=&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;in&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; locally binds the module expression &lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt; to the identifier &lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt; during the evaluation of the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. It then returns the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f314e61bf1988c22719a609f5831e22bbdc7dc32" translate="yes" xml:space="preserve">
          <source>The expression object&lt;a href=&quot;#class-body&quot;&gt;class-body&lt;/a&gt;end denotes a class body. This is the prototype for an object : it lists the instance variables and methods of an object of this class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d92cd34881d32ef8ac6eb5fb33636280b1183b9" translate="yes" xml:space="preserve">
          <source>The expression open&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; in a signature does not specify any components. It simply affects the parsing of the following items of the signature, allowing components of the module denoted by &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; to be referred to by their simple names name instead of path accesses &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.name. The scope of the open stops at the end of the signature expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3374b1493b2b2832203e28fc7202ca2b6bc44cc6" translate="yes" xml:space="preserve">
          <source>The expression open&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; in a structure does not define any components nor perform any bindings. It simply affects the parsing of the following items of the structure, allowing components of the module denoted by &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; to be referred to by their simple names name instead of path accesses &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.name. The scope of the open stops at the end of the structure expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d045a7e48acb78229180ba1f49811e331b9b826a" translate="yes" xml:space="preserve">
          <source>The expression while&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;do&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;done repeatedly evaluates &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; while &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; evaluates to true. The loop condition &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; is evaluated and tested at the beginning of each iteration. The whole while &amp;hellip; done expression evaluates to the unit value ().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7999e39ad27377cd7dc800aeafcf6be489d1e7a" translate="yes" xml:space="preserve">
          <source>The expression {&amp;lt;&lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip; ;&lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;&amp;gt;} evaluates to a copy of the current object in which the values of instance variables &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; have been replaced by the values of the corresponding expressions &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a02ea084f763d805328a3e7ce4d219962ddcb521" translate="yes" xml:space="preserve">
          <source>The expression {&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;with&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; [=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;] ; &amp;hellip; ;&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; [=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;] } builds a fresh record with fields &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; equal to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;, and all other fields having the same value as in the record &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. In other terms, it returns a shallow copy of the record &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;, except for the fields &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;, which are initialized to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;. As previously, single identifier &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; stands for &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;=&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;, a qualified identifier &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; stands for &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;=&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; and it is possible to add an optional type constraint on each field being updated with {&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;with&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip; ;&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;}.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81df39f38d8523b1217ede44454dadcb59a82246" translate="yes" xml:space="preserve">
          <source>The expression {&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; [=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;] ; &amp;hellip; ;&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; [=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;]} evaluates to the record value { field&lt;sub&gt;1&lt;/sub&gt; = v&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip;; field&lt;sub&gt;n&lt;/sub&gt; = v&lt;sub&gt;n&lt;/sub&gt; } where v&lt;sub&gt;i&lt;/sub&gt; is the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; for i = 1,&amp;hellip; , n. A single identifier &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; stands for &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;=&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;, and a qualified identifier &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; stands for &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;=&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;. The fields &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; must all belong to the same record type; each field of this record type must appear exactly once in the record expression, though they can appear in any order. The order in which &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; are evaluated is not specified. Optional type constraints can be added after each field {&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;;&amp;hellip; ;&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;} to force the type of &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; to be compatible with &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="770439db3ff36f7c9028cd337c7098117fa187ed" translate="yes" xml:space="preserve">
          <source>The expressions (&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;) and begin&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;end have the same value as &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. The two constructs are semantically equivalent, but it is good style to use begin &amp;hellip; end inside control structures:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9bf76fd4e9d4e7583a34999f67c07a62a02f933" translate="yes" xml:space="preserve">
          <source>The expressions Field(v, n), Byte(v, n) and Byte_u(v, n) are valid l-values. Hence, they can be assigned to, resulting in an in-place modification of value v. Assigning directly to Field(v, n) must be done with care to avoid confusing the garbage collector (see below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d39a1aaa7be45538447c135e96180858a54150e6" translate="yes" xml:space="preserve">
          <source>The expressions letopen&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;in&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; and &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.(&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;) are strictly equivalent. These constructions locally open the module referred to by the module path &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; in the respective scope of the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1d5d2150f39dd154ec68fa36cfff5333db652cf" translate="yes" xml:space="preserve">
          <source>The external function f is not available</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5f529de453636246288677488101d22e2108e01" translate="yes" xml:space="preserve">
          <source>The field width is composed of an optional integer literal indicating the maximal width of the token to read. For instance, &lt;code&gt;%6d&lt;/code&gt; reads an integer, having at most 6 decimal digits; &lt;code&gt;%4f&lt;/code&gt; reads a float with at most 4 characters; and &lt;code&gt;%8[\000-\255]&lt;/code&gt; returns the next 8 characters (or all the characters still available, if fewer than 8 characters are available in the input).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae52f5d3cbe515efd2a7aaa53a21566c409e073d" translate="yes" xml:space="preserve">
          <source>The file curses_stubs.c can be compiled with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9cf1595a49bfb32957e71e1d6050587722d1094" translate="yes" xml:space="preserve">
          <source>The file custom.cmo is created and can be used this way :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="139f2d48257c0343c4b071f4794d59ad6e533fc9" translate="yes" xml:space="preserve">
          <source>The file that ocamlrun is trying to execute (e.g. the file given as first non-option argument to ocamlrun) either does not exist, or is not a valid executable bytecode file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9df79524971faf6930542e99bcb97fb7e6ed0d2f" translate="yes" xml:space="preserve">
          <source>The file that ocamlrun is trying to execute is not a valid executable bytecode file. Probably it has been truncated or mangled since created. Erase and rebuild it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1479d9789eb939b776377dc8d01919fe50c91085" translate="yes" xml:space="preserve">
          <source>The files that define the compilation units can be compiled separately using the ocamlc -c command (the -c option means &amp;ldquo;compile only, do not try to link&amp;rdquo;); this produces compiled interface files (with extension .cmi) and compiled object code files (with extension .cmo). When all units have been compiled, their .cmo files are linked together using the ocamlc command. For instance, the following commands compile and link a program composed of two compilation units Aux and Main:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="218142a8cd84298a616575dd3b1a7d204717b40e" translate="yes" xml:space="preserve">
          <source>The files you can use to define custom generators are installed in the ocamldoc sub-directory of the OCaml standard library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59dbb07f3aaa12eeacf11b0514d46f8f8f33f5ee" translate="yes" xml:space="preserve">
          <source>The finalize field contains a pointer to a C function that is called when the block becomes unreachable and is about to be reclaimed. The block is passed as first argument to the function. The finalize field can also be custom_finalize_default to indicate that no finalization function is associated with the block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db242e09b65549d74785bc5f6a999727dbb33d18" translate="yes" xml:space="preserve">
          <source>The first argument of Store_field and Store_double_field must be a variable declared by CAMLparam* or a parameter declared by CAMLlocal* to ensure that a garbage collection triggered by the evaluation of the other arguments will not invalidate the first argument after it is computed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="483025a84206923192f7c9762bbef7fe0c59cbd8" translate="yes" xml:space="preserve">
          <source>The first case is an exact variant type: all possible tags are known, with their associated types, and they can all be present. Its structure is fully known.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26e2eb8f32164f7d7049d034e263952e663d7410" translate="yes" xml:space="preserve">
          <source>The first case is simple: g is passed ~y and then ~x, but f expects ~x and then ~y. This is correctly handled if we know the type of g to be x:int -&amp;gt; y:int -&amp;gt; int in advance, but otherwise this causes the above type clash. The simplest workaround is to apply formal parameters in a standard order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ddf571ff45a432684168e808086b6b09e060a7b" translate="yes" xml:space="preserve">
          <source>The first declaration is incorrect, because the string literal &lt;code&gt;&quot;hello&quot;&lt;/code&gt; could be shared by the compiler with other parts of the program, and mutating &lt;code&gt;incorrect&lt;/code&gt; is a bug. You must always use the second version, which performs a copy and is thus correct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a8e55f0808e48aad9f2858718bff1a1afbe6952" translate="yes" xml:space="preserve">
          <source>The first form of attributes is attached with a postfix notation on &amp;ldquo;algebraic&amp;rdquo; categories:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c20d4143c725e414a8fe296ef743e273f408fd33" translate="yes" xml:space="preserve">
          <source>The first form of extension node is used for &amp;ldquo;algebraic&amp;rdquo; categories:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e06920ecf0cdfc759a972552119b98dac760381" translate="yes" xml:space="preserve">
          <source>The first non-option argument is taken to be the name of the file containing the executable bytecode. (That file is searched in the executable path as well as in the current directory.) The remaining arguments are passed to the OCaml program, in the string array Sys.argv. Element 0 of this array is the name of the bytecode executable file; elements 1 to n are the remaining arguments arg&lt;sub&gt;1&lt;/sub&gt; to arg&lt;sub&gt;n&lt;/sub&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b219d7a443ce004c101ae67774c3ff8d7838f69" translate="yes" xml:space="preserve">
          <source>The first two cases refer to a value identifier, either unqualified or qualified by the path to the structure that define it. * refers to the result just computed (typically, the value of a function application), and is valid only if the selected event is an &amp;ldquo;after&amp;rdquo; event (typically, a function application). $integer refer to a previously printed value. The remaining four forms select part of an expression: respectively, a record field, an array element, a string element, and the current contents of a reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2239d147af301ebf1848d9c3aed42b025297f0fd" translate="yes" xml:space="preserve">
          <source>The five classes of floating-point numbers, as determined by the &lt;a href=&quot;float#VALclassify_float&quot;&gt;&lt;code&gt;Float.classify_float&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5f4b14dbb83404562f202cb46321bbf598f23f0" translate="yes" xml:space="preserve">
          <source>The five classes of floating-point numbers, as determined by the &lt;a href=&quot;stdlib#VALclassify_float&quot;&gt;&lt;code&gt;classify_float&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="681b526c61bdcee2f004dd7b0da14d09277654dc" translate="yes" xml:space="preserve">
          <source>The flags -Oclassic, -O2 and -O3 are applied before all other flags, meaning that certain parameters may be overridden without having to specify every parameter usually invoked by the given optimisation level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41e4ad6689358b23fa1eb693a69c5cf4c073612a" translate="yes" xml:space="preserve">
          <source>The flags for &lt;a href=&quot;unix#VALrecv&quot;&gt;&lt;code&gt;Unix.recv&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;unix#VALrecvfrom&quot;&gt;&lt;code&gt;Unix.recvfrom&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;unix#VALsend&quot;&gt;&lt;code&gt;Unix.send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;unix#VALsendto&quot;&gt;&lt;code&gt;Unix.sendto&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fd4283b647a522a0c9037980c206ad3a14cfba5" translate="yes" xml:space="preserve">
          <source>The flags for &lt;a href=&quot;unixlabels#VALrecv&quot;&gt;&lt;code&gt;UnixLabels.recv&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;unixlabels#VALrecvfrom&quot;&gt;&lt;code&gt;UnixLabels.recvfrom&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;unixlabels#VALsend&quot;&gt;&lt;code&gt;UnixLabels.send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;unixlabels#VALsendto&quot;&gt;&lt;code&gt;UnixLabels.sendto&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e26b9a410e534dd152b1e84e847e91afe66a6921" translate="yes" xml:space="preserve">
          <source>The flags to &lt;a href=&quot;unix#VALopenfile&quot;&gt;&lt;code&gt;Unix.openfile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92926c8ba910a78b19eb9560e04391f617314f85" translate="yes" xml:space="preserve">
          <source>The flags to &lt;a href=&quot;unixlabels#VALopenfile&quot;&gt;&lt;code&gt;UnixLabels.openfile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da416c9b0c9ec887e3c9fed14c90d2a6cfe00274" translate="yes" xml:space="preserve">
          <source>The flags to the &lt;code&gt;Marshal.to_*&lt;/code&gt; functions below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8910a8a70e1456ec6a90eb77007ffc0da7c2187" translate="yes" xml:space="preserve">
          <source>The floating point 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ab9429d7283ec75f0e02bc07dcd3134a72594e2" translate="yes" xml:space="preserve">
          <source>The floating-point -1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f12a48f02e6b8cb1bc97e090aa405bfffaff9d2" translate="yes" xml:space="preserve">
          <source>The floating-point 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cf650e7443d1e286b4973d2572d41f2dd1c5a71" translate="yes" xml:space="preserve">
          <source>The following bindings for the most common debugger commands are available in the *camldebug-progname* buffer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa8fb8f6579c8a754f8160f2c545902f2c3649f3" translate="yes" xml:space="preserve">
          <source>The following built-in types and predefined exceptions are always defined in the compilation environment, but are not part of any module. As a consequence, they can only be referred by their short names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="741949c165a3e82c7b1f8762527481edfe04447a" translate="yes" xml:space="preserve">
          <source>The following character sequences are also keywords:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34ab75b655a01e99e773cf2e772887f93cd01533" translate="yes" xml:space="preserve">
          <source>The following characters are considered as blanks: space, horizontal tabulation, carriage return, line feed and form feed. Blanks are ignored, but they separate adjacent identifiers, literals and keywords that would otherwise be confused as one single identifier, literal or keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfd936c99ec75ec8467efb2fa73208d1cfd7da18" translate="yes" xml:space="preserve">
          <source>The following command-line options are recognized by ocamlc. The options -pack, -a, -c and -output-obj are mutually exclusive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fe55eff2fce3bd36f31017706fd97b0e53f6496" translate="yes" xml:space="preserve">
          <source>The following command-line options are recognized by ocamldep.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="885f4ff9e5ff4ddb2e7d9854020f77ada3553ef5" translate="yes" xml:space="preserve">
          <source>The following command-line options are recognized by ocamllex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba3896a823e9e144bf0d4b7e1f61010aad966b5f" translate="yes" xml:space="preserve">
          <source>The following command-line options are recognized by ocamlmktop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1edcf650050ceecdfe0b7ab459ca56279ebf0aae" translate="yes" xml:space="preserve">
          <source>The following command-line options are recognized by ocamlopt. The options -pack, -a, -shared, -c and -output-obj are mutually exclusive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f01e63f748272442f586e0dcde7deabec94a1be5" translate="yes" xml:space="preserve">
          <source>The following command-line options are recognized by ocamlrun.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df87076d9fe00726ba61eaa8293d8eef997abd39" translate="yes" xml:space="preserve">
          <source>The following command-line options are recognized by the ocaml command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8652df34978643d1ab214e3a8b1d14afa637e47" translate="yes" xml:space="preserve">
          <source>The following command-line options are recognized:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea03de4698c2ebdfac27067880c0104b3ab3bd1f" translate="yes" xml:space="preserve">
          <source>The following commands create the custom.cma file from files file&lt;sub&gt;1&lt;/sub&gt;.ml[i], ..., file&lt;sub&gt;n&lt;/sub&gt;.ml[i] :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ef4512268a1e60220a903be3d8066db5cafc567" translate="yes" xml:space="preserve">
          <source>The following commands display information on checkpoints and events:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d56705239611e41383cc5a0fc4c62ec9ece9f729" translate="yes" xml:space="preserve">
          <source>The following commands execute the program forward or backward, starting at the current time. The execution will stop either when specified by the command or when a breakpoint is encountered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa8b474e507be285882f655940a333fef3ed7e16" translate="yes" xml:space="preserve">
          <source>The following constants are treated like built-in constant constructors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f046204697990bb2d0f4cd47a0f626a4abb10376" translate="yes" xml:space="preserve">
          <source>The following directives control the toplevel behavior, load files in memory, and trace program execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e3f41e76fac899ccc6e7dc6bb71eadc7f7839bf" translate="yes" xml:space="preserve">
          <source>The following environment variables are also consulted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86dc8be3269b92b9232bc979a84ec53ac86636df" translate="yes" xml:space="preserve">
          <source>The following example illustrates how statically-allocated C and Fortran arrays can be made available to OCaml.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b95c269aef6e820286357345f289155493b43dd" translate="yes" xml:space="preserve">
          <source>The following example illustrates the assignment of integers and block tags to constructors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb54e0eb9f74bd676ad11ff69ff7bddb5206be2e" translate="yes" xml:space="preserve">
          <source>The following example of file toto.ml shows where to place comments in a .ml file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb214a3cbe4113b36d77da33d2aad1393c44f7c9" translate="yes" xml:space="preserve">
          <source>The following example shows the passing of a two-dimensional Bigarray to a C function and a Fortran function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28d8c0cb68d2ae92275d2ecc53225fa520b47419" translate="yes" xml:space="preserve">
          <source>The following example uses a private type abbreviation to define a module of nonnegative integers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3ae00605da64b105662093b0c38586124245f33" translate="yes" xml:space="preserve">
          <source>The following example, known as the subject/observer pattern, is often presented in the literature as a difficult inheritance problem with inter-connected classes. The general pattern amounts to the definition a pair of two classes that recursively interact with one another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe79f151ba4780648aa79dae8b08c42dcb70ffa0" translate="yes" xml:space="preserve">
          <source>The following functions are exposed to help write compatible C stubs. To use them, you need to include both &amp;lt;caml/misc.h&amp;gt; and &amp;lt;caml/osdeps.h&amp;gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="832fc1be181c5700f255f7f5cd917c79991599e3" translate="yes" xml:space="preserve">
          <source>The following functions are slightly more efficient than caml_alloc, but also much more difficult to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e63d19b6970bf278c78ca3c011faa62ed74f62ae" translate="yes" xml:space="preserve">
          <source>The following functions can be called from the semantic actions of lexer definitions (the ML code enclosed in braces that computes the value returned by lexing functions). They give access to the character string matched by the regular expression associated with the semantic action. These functions must be applied to the argument &lt;code&gt;lexbuf&lt;/code&gt;, which, in the code generated by &lt;code&gt;ocamllex&lt;/code&gt;, is bound to the lexer buffer passed to the parsing function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45f2a5408f593c266bc5b945e256185ab7faa225" translate="yes" xml:space="preserve">
          <source>The following functions implement the POSIX standard terminal interface. They provide control over asynchronous communication ports and pseudo-terminals. Refer to the &lt;code&gt;termios&lt;/code&gt; man page for a complete description.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04b159ad2babd8305b93430182e2074b26259f77" translate="yes" xml:space="preserve">
          <source>The following functions, defined in &amp;lt;caml/intext.h&amp;gt;, are provided to write and read back the contents of custom blocks in a portable way. Those functions handle endianness conversions when e.g. data is written on a little-endian machine and read back on a big-endian machine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4d76bd017aaace084c2fe4ba75e854a770052fa" translate="yes" xml:space="preserve">
          <source>The following idiom separates description and definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abdd18dbed9ebbfffd9a3d53fecf519fa1b39456" translate="yes" xml:space="preserve">
          <source>The following invariant holds for any file name &lt;code&gt;s&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da4c18672e8270bfb1a76f87b23a373991175930" translate="yes" xml:space="preserve">
          <source>The following language semantics apply specifically to constant float arrays. (By &amp;ldquo;constant float array&amp;rdquo; is meant an array consisting entirely of floating point numbers that are known at compile time. A common case is a literal such as [| 42.0; 43.0; |].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f8a143ee55050d3e9f8c912fc4c49000ef1b06a" translate="yes" xml:space="preserve">
          <source>The following options apply in conjunction with the -dot option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="166817d7c28936e2b423cdda7a6aa67512725a8e" translate="yes" xml:space="preserve">
          <source>The following options apply in conjunction with the -html option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ecf6b7625e3e537050eaf9dc3a7fa22f048e25b" translate="yes" xml:space="preserve">
          <source>The following options apply in conjunction with the -latex option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbc2ec126f36a5f0afa27f31d58d5bda45d9c06d" translate="yes" xml:space="preserve">
          <source>The following options apply in conjunction with the -man option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="051fe64a5d38a370f62ad07eadfb825faac6621f" translate="yes" xml:space="preserve">
          <source>The following options apply in conjunction with the -texi option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d4dbac485d984712c71b7a64c65bc9a132b2436" translate="yes" xml:space="preserve">
          <source>The following options are recognized by ocamlprof:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a846492c1f0c6319e8b3788beab792307a98121" translate="yes" xml:space="preserve">
          <source>The following options determine the format for the generated documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c2e53d36ec19399f7c32f9aac23861dbfe9cf9f" translate="yes" xml:space="preserve">
          <source>The following rules must be respected in order to avoid name clashes resulting in cross-reference errors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="097e045769a0dca8fade64c26d195db8b9414337" translate="yes" xml:space="preserve">
          <source>The following sample interface file foo.mli illustrates the placement rules for comments in .mli files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebfe702602d2495e52da52309ab1711b73354bb5" translate="yes" xml:space="preserve">
          <source>The following table gives the list of predefined @-tags, with their syntax and meaning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd8a8320baafd30cfa4602768ee2151691b2708f" translate="yes" xml:space="preserve">
          <source>The following table lists the precedence level of all operator classes from the highest to the lowest precedence. A few other syntactic constructions are also listed as references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e256f5eaf5d8b81e4043192160908c1bd8faea3" translate="yes" xml:space="preserve">
          <source>The following table summarize what OCaml types can be unboxed, and what C types should be used in correspondence:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef06aa8040c0f03b521f5cef891b934434387cc7" translate="yes" xml:space="preserve">
          <source>The following terminology is used in this chapter of the manual.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1699520402e7ac3828d5b8bcc342d6a427931baa" translate="yes" xml:space="preserve">
          <source>The following two functions are deprecated. Use module &lt;a href=&quot;marshal&quot;&gt;&lt;code&gt;Marshal&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b87aaa89310b1024b8a1a7a3d739748757473aea" translate="yes" xml:space="preserve">
          <source>The form exception&lt;a href=&quot;#constr-decl&quot;&gt;constr-decl&lt;/a&gt; generates a new exception, distinct from all other exceptions in the system. The form exception&lt;a href=&quot;names#constr-name&quot;&gt;constr-name&lt;/a&gt;=&lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; gives an alternate name to an existing exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b37d1605c59154ddd022186be0bfed3eb3e2b35d" translate="yes" xml:space="preserve">
          <source>The form external&lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;=&lt;a href=&quot;intfc#external-declaration&quot;&gt;external-declaration&lt;/a&gt; is similar, except that it requires in addition the name to be implemented as the external function specified in &lt;a href=&quot;intfc#external-declaration&quot;&gt;external-declaration&lt;/a&gt; (see chapter &lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;20&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3184fd8520491af729727e8e58dedc4128114b17" translate="yes" xml:space="preserve">
          <source>The format of decimal floating-point numbers is &lt;code&gt;&amp;nbsp;[-]&amp;nbsp;dd.ddd&amp;nbsp;(e|E)&amp;nbsp;[+|-]&amp;nbsp;dd&amp;nbsp;&lt;/code&gt;, where &lt;code&gt;d&lt;/code&gt; stands for a decimal digit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7828f8d5d5c611bdddc6c78b6ef04afbcd5d417e" translate="yes" xml:space="preserve">
          <source>The format of hexadecimal floating-point numbers is &lt;code&gt;&amp;nbsp;[-]&amp;nbsp;0(x|X)&amp;nbsp;hh.hhh&amp;nbsp;(p|P)&amp;nbsp;[+|-]&amp;nbsp;dd&amp;nbsp;&lt;/code&gt;, where &lt;code&gt;h&lt;/code&gt; stands for an hexadecimal digit and &lt;code&gt;d&lt;/code&gt; for a decimal digit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="812ca11444f87b91a5c1a4d58c74d93fafa141dc" translate="yes" xml:space="preserve">
          <source>The format of lexer definitions is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="127323cd14f10ff976ce82741602642432da7e75" translate="yes" xml:space="preserve">
          <source>The format string &lt;code&gt;fmt&lt;/code&gt; is a character string which contains three types of objects: plain characters and conversion specifications as specified in the &lt;a href=&quot;printf&quot;&gt;&lt;code&gt;Printf&lt;/code&gt;&lt;/a&gt; module, and pretty-printing indications specific to the &lt;code&gt;Format&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98fb30c95542494775f06815271fe47f1e740e5d" translate="yes" xml:space="preserve">
          <source>The format string is a character string which contains three types of objects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66553eccbf80219caa1c3c646bc08b8b25b163d4" translate="yes" xml:space="preserve">
          <source>The format string is a character string which contains two types of objects: plain characters, which are simply copied to the output channel, and conversion specifications, each of which causes conversion and printing of arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fd14a172518628e19f32be0e91f3d86d102d1cd" translate="yes" xml:space="preserve">
          <source>The formatted input functions can read from any kind of input, including strings, files, or anything that can return characters. The more general source of characters is named a &lt;em&gt;formatted input channel&lt;/em&gt; (or &lt;em&gt; scanning buffer&lt;/em&gt;) and has type &lt;a href=&quot;scanf.scanning#TYPEin_channel&quot;&gt;&lt;code&gt;Scanf.Scanning.in_channel&lt;/code&gt;&lt;/a&gt;. The more general formatted input function reads from any scanning buffer and is named &lt;code&gt;bscanf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e23bc34a1d5333a784d920ce0ee827fd82d18c4c" translate="yes" xml:space="preserve">
          <source>The former alternative is more convenient for the final users of the library, however.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf9a1462b05ebbf56fca1e287e7b7e2870abd6cd" translate="yes" xml:space="preserve">
          <source>The former operator will sometimes fail to coerce an expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; from a type &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to a type &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; even if type &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; is a subtype of type &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;: in the current implementation it only expands two levels of type abbreviations containing objects and/or polymorphic variants, keeping only recursion when it is explicit in the class type (for objects). As an exception to the above algorithm, if both the inferred type of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; and &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt; are ground (&lt;em&gt;i.e.&lt;/em&gt; do not contain type variables), the former operator behaves as the latter one, taking the inferred type of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; as &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;. In case of failure with the former operator, the latter one should be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e62ce70c70537475c1b181d579e82b479775978d" translate="yes" xml:space="preserve">
          <source>The fprintf function is like printf except that it takes an output channel as the first argument. The %a specifier can be useful to define custom printer (for custom types). For instance, we can create a printing template that converts an integer argument to signed decimal:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d13a291c5fa3db94f06d27016206ff693957ed08" translate="yes" xml:space="preserve">
          <source>The front-end is a part of compiler-libs library. Programs that use the compiler-libs library should be built as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4658f7d95c6ccb485b665c4a8fd77d14df445b99" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;caml_process_pending_actions&lt;/code&gt; from &amp;lt;caml/signals.h&amp;gt; executes any pending signal handlers and finalisers, Memprof callbacks, and requested minor and major garbage collections. In particular, it can raise asynchronous exceptions. It is recommended to call it regularly at safe points inside long-running non-blocking C code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0830c833940b33a13600b2fc8f3c6ec9ed72ba39" translate="yes" xml:space="preserve">
          <source>The function's output is specified by the following invariants:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b16f05a4538c91ac60ba6969c4d9b5e686f1d91a" translate="yes" xml:space="preserve">
          <source>The functions from module &lt;a href=&quot;random.state&quot;&gt;&lt;code&gt;Random.State&lt;/code&gt;&lt;/a&gt; manipulate the current state of the random generator explicitly. This allows using one or several deterministic PRNGs, even in a multi-threaded program, without interference from other parts of the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbce52b776ac08f2366078197c98e1659ba43ad5" translate="yes" xml:space="preserve">
          <source>The functions in this module are thread safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="511113955645abe47f0e74cfd8701cd531b7acf8" translate="yes" xml:space="preserve">
          <source>The functions in this section append binary encodings of integers to buffers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="735840deef678499261950948d63f843f78e8b4b" translate="yes" xml:space="preserve">
          <source>The functions in this section binary encode and decode integers to and from byte sequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="692df968d9b76de8295f62a1cc39eca74e7c54e9" translate="yes" xml:space="preserve">
          <source>The functor Client may also be redefined when some new features of the account can be given to the client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23eb5fdacb362f1e019b7a5da5dbe8a3fbb9da5e" translate="yes" xml:space="preserve">
          <source>The functorial interface allows the use of specific comparison and hash functions, either for performance/security concerns, or because keys are not hashable/comparable with the polymorphic builtins.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9842cecf834f807f4e52659d4bb05e758d2b67ff" translate="yes" xml:space="preserve">
          <source>The general formatted input function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39ea5439ffc8a37ae7dfd624fd6123810662e231" translate="yes" xml:space="preserve">
          <source>The generated module defines one parsing function per entry point in the grammar. These functions have the same names as the entry points. Parsing functions take as arguments a lexical analyzer (a function from lexer buffers to tokens) and a lexer buffer, and return the semantic attribute of the corresponding entry point. Lexical analyzer functions are usually generated from a lexer specification by the ocamllex program. Lexer buffers are an abstract data type implemented in the standard library module Lexing. Tokens are values from the concrete type token, defined in the interface file grammar.mli produced by ocamlyacc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2263e6287694d2f2d32e4219ff36b6fad805902" translate="yes" xml:space="preserve">
          <source>The generated trace files are stored using the &lt;em&gt;Common Trace Format&lt;/em&gt;, which is a general purpose binary tracing format. A complete trace consists of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05828d489f6ac2387f6a65167157fb9f23021c22" translate="yes" xml:space="preserve">
          <source>The greatest representable 32-bit integer, 2&lt;sup&gt;31&lt;/sup&gt; - 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a404ad0913817fcb80ea923a9800ed75493e4170" translate="yes" xml:space="preserve">
          <source>The greatest representable 64-bit integer, 2&lt;sup&gt;63&lt;/sup&gt; - 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f471d57c7b55d66ee6fb3224ba15693e2e1e916" translate="yes" xml:space="preserve">
          <source>The greatest representable integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83953d60191eeb31cc3f9a4dc8dba81bf1560d9f" translate="yes" xml:space="preserve">
          <source>The greatest representable native integer, either 2&lt;sup&gt;31&lt;/sup&gt; - 1 on a 32-bit platform, or 2&lt;sup&gt;63&lt;/sup&gt; - 1 on a 64-bit platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e04fd04f5b90806f4bde8e56f9e1f7c424d03265" translate="yes" xml:space="preserve">
          <source>The hash field can be set to custom_hash_default, in which case the custom block is ignored during hash computation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1bdc212a7c36c7cbf75250ae2e9cd081ccee7eb" translate="yes" xml:space="preserve">
          <source>The hash field contains a pointer to a C function that is called whenever OCaml&amp;rsquo;s generic hash operator (see module &lt;a href=&quot;libref/hashtbl&quot;&gt;Hashtbl&lt;/a&gt;) is applied to a custom block. The C function can return an arbitrary integer representing the hash value of the data contained in the given custom block. The hash value must be compatible with the compare function, in the sense that two structurally equal data (that is, two custom blocks for which compare returns 0) must have the same hash value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3784686c2bcba80c99df973ccfa187b6dc78d6d0" translate="yes" xml:space="preserve">
          <source>The hash function for floating-point numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afd0450a8b37538d5ad7af752cb7dc24545ce1f7" translate="yes" xml:space="preserve">
          <source>The header and the trailer sections are OCaml code that is copied as is into file grammar.ml. Both sections are optional. The header goes at the beginning of the output file; it usually contains open directives and auxiliary functions required by the semantic actions of the rules. The trailer goes at the end of the output file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a49035078d6028cf4719edc4791d70f6385a46e" translate="yes" xml:space="preserve">
          <source>The header and trailer sections are arbitrary OCaml text enclosed in curly braces. Either or both can be omitted. If present, the header text is copied as is at the beginning of the output file and the trailer text at the end. Typically, the header section contains the open directives required by the actions, and possibly some auxiliary functions used in the actions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65fb09bbdabd2dfcd32a5c38a54fcbcdf3587281" translate="yes" xml:space="preserve">
          <source>The identifiers below are reserved as keywords, and cannot be employed otherwise:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3cdbac9abe023e77c0d5c1367f0671359c68a73" translate="yes" xml:space="preserve">
          <source>The implementation allows efficient sharing of large numerical arrays between OCaml code and C or Fortran numerical libraries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37db43ed15e53d861a8a0109f7b167f500eef59c" translate="yes" xml:space="preserve">
          <source>The implementation is checked against the interface file x.mli (if it exists) as described in the manual for ocamlc (chapter &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0e6ef3c775c3e80317b4caf9ce4c73cd303a6bf" translate="yes" xml:space="preserve">
          <source>The include file &amp;lt;caml/bigarray.h&amp;gt; must be included in the C stub file. It declares the functions, constants and macros discussed below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="535f73d31ed740bfcbb9fa46992a794cf0b8e833" translate="yes" xml:space="preserve">
          <source>The information returned by the &lt;a href=&quot;unix#VALstat&quot;&gt;&lt;code&gt;Unix.stat&lt;/code&gt;&lt;/a&gt; calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dab77f7c802e91039a17f7a96119c9dc7d99b16" translate="yes" xml:space="preserve">
          <source>The information returned by the &lt;a href=&quot;unixlabels#VALstat&quot;&gt;&lt;code&gt;UnixLabels.stat&lt;/code&gt;&lt;/a&gt; calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="432250b262611d097e3c2e7a360d5606d16533ba" translate="yes" xml:space="preserve">
          <source>The inheritance construct inherit&lt;a href=&quot;#class-body-type&quot;&gt;class-body-type&lt;/a&gt; provides for inclusion of methods and instance variables from other class types. The instance variable and method types from &lt;a href=&quot;#class-body-type&quot;&gt;class-body-type&lt;/a&gt; are added into the current class type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a6f2342a82527fef9c1f1e57a822b49fe405407" translate="yes" xml:space="preserve">
          <source>The inheritance construct inherit&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; allows reusing methods and instance variables from other classes. The class expression &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; must evaluate to a class body. The instance variables, methods and initializers from this class body are added into the current class. The addition of a method will override any previously defined method of the same name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6a4c6ce7609b4fdb581947deed89b2c406dd7c0" translate="yes" xml:space="preserve">
          <source>The initial benefit value is then scaled by a factor that attempts to compensate for the fact that the current point in the code, if under some number of conditional branches, may be cold. (Flambda does not currently compute hot and cold paths.) The factor&amp;mdash;the estimated probability that the inliner really is on a &lt;em&gt;hot&lt;/em&gt; path&amp;mdash;is calculated as 1/(1 + f)&lt;sup&gt;d&lt;/sup&gt;, where f is set by -inline-branch-factor and d is the nesting depth of branches at the current point. As the inliner descends into more deeply-nested branches, the benefit of inlining thus lessens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="605d70d1e078307745dd48e9410e6df59a2d38ed" translate="yes" xml:space="preserve">
          <source>The initial size of the major heap (in words).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d19155151a59efc551f6b49f7c9952f00e4278ab" translate="yes" xml:space="preserve">
          <source>The inliner is directed using attributes. For non-recursive functions (and one-step unrolling of recursive functions, although @unroll is more clear for this purpose) the following are supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec62c15f868750119abec49b24817b3f70272bf1" translate="yes" xml:space="preserve">
          <source>The inliner may discover a call site to a recursive function where something is known about the arguments: for example, they may be equal to some other variables currently in scope. In this situation it may be beneficial to &lt;em&gt;specialise&lt;/em&gt; the function to those arguments. This is done by copying the declaration of the function (and any others involved in any same mutually-recursive declaration) and noting the extra information about the arguments. The arguments augmented by this information are known as &lt;em&gt;specialised arguments&lt;/em&gt;. In order to try to ensure that specialisation is not performed uselessly, arguments are only specialised if it can be shown that they are &lt;em&gt;invariant&lt;/em&gt;: in other words, during the execution of the recursive function(s) themselves, the arguments never change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c51b8b56bbf10eb40d95b1f8d06cf0bb2a8da17" translate="yes" xml:space="preserve">
          <source>The inliner will be able to consider inlining a call to a function in a first class module if it knows which particular function is going to be called. The presence of the first-class module record that wraps the set of functions in the module does not per se inhibit inlining.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f97af2287565035553d926928c75a2ecba69b6f2" translate="yes" xml:space="preserve">
          <source>The inlining depth starts at zero and is increased by one every time the inliner descends into another function. It is then decreased by one every time the inliner leaves such function. If the depth exceeds the value set by -inline-max-depth then speculation stops. This parameter is intended as a general backstop for situations where the inlining threshold does not control the search sufficiently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fef85946e0fcf5a71d076de458a459e1642b8d5" translate="yes" xml:space="preserve">
          <source>The input signature of the functor &lt;a href=&quot;hashtbl.make&quot;&gt;&lt;code&gt;Hashtbl.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06d18381a5748615e440710ac855b1a56b9c2889" translate="yes" xml:space="preserve">
          <source>The input signature of the functor &lt;a href=&quot;hashtbl.makeseeded&quot;&gt;&lt;code&gt;Hashtbl.MakeSeeded&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95c572128ac8d5e1df8128cf0a673f5f91f32169" translate="yes" xml:space="preserve">
          <source>The inside of documentation comments (**&amp;hellip;*) consists of free-form text with optional formatting annotations, followed by optional &lt;em&gt;tags&lt;/em&gt; giving more specific information about parameters, version, authors, &amp;hellip; The tags are distinguished by a leading @ character. Thus, a documentation comment has the following shape:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="148efbe2c3192ef6b3c2f5ce513345372f5ff8d7" translate="yes" xml:space="preserve">
          <source>The instance variables of a class are visible only in the body of the methods defined in the same class or a class that inherits from the class defining the instance variables. The expression &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt; evaluates to the value of the given instance variable. The expression &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;&amp;lt;-&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; assigns the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; to the instance variable &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;, which must be mutable. The whole expression &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;&amp;lt;-&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; evaluates to ().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1983ba3b3cbd666c6b286b10b7424eaa8d46d8e4" translate="yes" xml:space="preserve">
          <source>The instrumentation that afl-fuzz requires is not generated by default, and must be explicitly enabled, by passing the -afl-instrument option to ocamlopt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c38a45a391c534fde7023ac64ba050bd0bfc352" translate="yes" xml:space="preserve">
          <source>The instrumented runtime aims to provide insight into the runtime&amp;rsquo;s execution while maintaining a low overhead. However, this overhead may become more noticeable depending on how a program executes. The instrumented runtime currently puts a strong emphasis on tracing &lt;em&gt;garbage collection&lt;/em&gt; events. This means that programs with heavy garbage collection activity may be more susceptible to tracing induced performance penalties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c752c8999051d42387c90e33a51fa248e92151ee" translate="yes" xml:space="preserve">
          <source>The instrumented runtime can also be used with the OCaml bytecode interpreter. This can be done by either using the -runtime-variant=i flag when linking the program with ocamlc, or by running the generated bytecode through ocamlruni:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdd8c2054ca56fa61b478da767e7a87b2d4b4462" translate="yes" xml:space="preserve">
          <source>The instrumented runtime does not support the fork system call. A child process forked from an instrumented program will not be traced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83cc8fe30284169270dc9bfd2599a1edfd3403c6" translate="yes" xml:space="preserve">
          <source>The integer in a &lt;code&gt;width&lt;/code&gt; or &lt;code&gt;precision&lt;/code&gt; can also be specified as &lt;code&gt;*&lt;/code&gt;, in which case an extra integer argument is taken to specify the corresponding &lt;code&gt;width&lt;/code&gt; or &lt;code&gt;precision&lt;/code&gt;. This integer argument precedes immediately the argument to print. For instance, &lt;code&gt;%.*f&lt;/code&gt; prints a &lt;code&gt;float&lt;/code&gt; with as many fractional digits as the value of the argument given before the float.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b15dd3f5ba2129587d0969abe183388bad06fc4" translate="yes" xml:space="preserve">
          <source>The interface of a class can also be specified in a module signature, and used to restrict the inferred signature of a module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="105395de5f7d644b47550655e63b2ed02fcd3fdf" translate="yes" xml:space="preserve">
          <source>The keys and data of an ephemeron are said to be full if they point to a value, or empty if the value has never been set, has been unset, or was erased by the GC. In the function that accesses the keys or data these two states are represented by the &lt;code&gt;option&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6634b8f0a482d759792ec8ca2ac4ce6773a03e6f" translate="yes" xml:space="preserve">
          <source>The keyword as in that type binds the type variable 'a to the object type &amp;lt; .. &amp;gt;. Therefore, Oo.copy takes an object with any methods (represented by the ellipsis), and returns an object of the same type. The type of Oo.copy is different from type &amp;lt; .. &amp;gt; -&amp;gt; &amp;lt; .. &amp;gt; as each ellipsis represents a different set of methods. Ellipsis actually behaves as a type variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26d04af0b9de3d4d2a72eb74f835f5f6f6e937e3" translate="yes" xml:space="preserve">
          <source>The keywords - and -. can appear both as infix and prefix operators. When they appear as prefix operators, they are interpreted respectively as the functions (~-) and (~-.).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63ad31bd653530cc49e2890ef110e7033521237a" translate="yes" xml:space="preserve">
          <source>The kind of array elements is one of the following constants:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad467b38d8db4456aa825c50933b9ea245ee8d05" translate="yes" xml:space="preserve">
          <source>The language accepts external declarations with one or two flag strings in addition to the C function&amp;rsquo;s name. These flags are reserved for the implementation of the standard library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8cdc3190f510239fa37ad383f7499bbcfcecc73" translate="yes" xml:space="preserve">
          <source>The largest positive finite value of type &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b02fd4b3ae9e22d2aa52705a920bd39b960133e" translate="yes" xml:space="preserve">
          <source>The last two entries are valid for any n &amp;gt; 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="411f2ed0253bd263770b7a506015d3b73acb28b7" translate="yes" xml:space="preserve">
          <source>The latter is slightly more efficient, as it allows clients of the module to call directly the C function instead of going through the corresponding OCaml function. On the other hand, it should not be used in library modules if they have side-effects at toplevel, as this direct call interferes with the linker&amp;rsquo;s algorithm for removing unused modules from libraries at link-time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0d5230f60bcbec268122dc0a17e6710399bb6df" translate="yes" xml:space="preserve">
          <source>The lazy expression lazy_expr is forced only if the lazy_guard value yields true once computed. Indeed, a simple wildcard pattern (not lazy) never forces the lazy expression&amp;rsquo;s evaluation. However, a pattern with keyword lazy, even if it is wildcard, always forces the evaluation of the deferred computation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfa4f4b740be36ff7f795509d500d37f7af78f8b" translate="yes" xml:space="preserve">
          <source>The legacy bigarray library bundled with the compiler is a compatibility library with exactly the same interface as before, i.e. with map_file included.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c3cccf18cbaa6ce05baa77a874dea7a1d1ade41" translate="yes" xml:space="preserve">
          <source>The let and let rec constructs bind value names locally, as for the core language expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a230275b7985703b310f49dd04772a11ba7b81ae" translate="yes" xml:space="preserve">
          <source>The let and letrec constructs bind value names locally. The construct</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a7c897adf765ad531b54431abd748cbea11f170" translate="yes" xml:space="preserve">
          <source>The list is not empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e80da8bc0045d539fc55b1771c12707e1366c643" translate="yes" xml:space="preserve">
          <source>The list of options, each followed by the corresponding &lt;code&gt;doc&lt;/code&gt; string. Beware: options that have an empty &lt;code&gt;doc&lt;/code&gt; string will not be included in the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37a09eb76bbb9dc4b8871dbc8586b6f3b99c21f6" translate="yes" xml:space="preserve">
          <source>The list of possible syntactic class is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7119efad1f349c18d670dab6d20261e060049541" translate="yes" xml:space="preserve">
          <source>The loadingmode variable controls how the program is executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15f3b2280a23c9730e0ae9df7fd26ba354827556" translate="yes" xml:space="preserve">
          <source>The macros CAMLlocal1 to CAMLlocal5 declare and initialize one to five local variables of type value. The variable names are given as arguments to the macros. CAMLlocalN(x, n) declares and initializes a local variable of type value [n]. You can use several calls to these macros if you have more than 5 local variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aaef768b1af4841714c0865edff6a7e10553a66" translate="yes" xml:space="preserve">
          <source>The macros CAMLreturn, CAMLreturn0, and CAMLreturnT are used to replace the C keyword return. Every occurrence of return x must be replaced by CAMLreturn (x) if x has type value, or CAMLreturnT (t, x) (where t is the type of x); every occurrence of return without argument must be replaced by CAMLreturn0. If your C function is a procedure (i.e. if it returns void), you must insert CAMLreturn0 at the end (to replace C&amp;rsquo;s implicit return).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="885b3218ec0a809028025c650e9f6b490326927a" translate="yes" xml:space="preserve">
          <source>The main advantage of dynamic linking is that it preserves the platform-independence of bytecode executables. That is, the bytecode executable contains no machine code, and can therefore be compiled on platform A and executed on other platforms B, C, &amp;hellip;, as long as the required shared libraries are available on all these platforms. In contrast, executables generated by ocamlc -custom run only on the platform on which they were created, because they embark a custom-tailored runtime system specific to that platform. In addition, dynamic linking results in smaller executables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31c9f9893f98dd3b2cb21409e3d29c4b1dc69b68" translate="yes" xml:space="preserve">
          <source>The main differences between 'Bigarrays' and standard OCaml arrays are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fcf71e83dbbe5bf7b82af138897c5021410d4ef" translate="yes" xml:space="preserve">
          <source>The major GC speed is computed from this parameter. This is the memory that will be &quot;wasted&quot; because the GC does not immediately collect unreachable blocks. It is expressed as a percentage of the memory used for live data. The GC will work more (use more CPU time and collect blocks more eagerly) if &lt;code&gt;space_overhead&lt;/code&gt; is smaller. Default: 80.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30da6783cb2d914f60ad876ac28283601a269030" translate="yes" xml:space="preserve">
          <source>The maximum depth of any speculative inlining search. See section &lt;a href=&quot;#ss%3Aflambda-speculation&quot;&gt;21.3.6&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14b6f2abfdc332a11cef59acff883ca20f69b025" translate="yes" xml:space="preserve">
          <source>The maximum depth of any unrolling of recursive functions during any speculative inlining search. See section &lt;a href=&quot;#ss%3Aflambda-speculation&quot;&gt;21.3.6&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6537d7fb4312afbfc14faa7b11bce9479277bccc" translate="yes" xml:space="preserve">
          <source>The maximum formatting depth is the maximum number of pretty-printing boxes simultaneously open.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa16112992d556366d6be6ead64cb5e2ddc5d021" translate="yes" xml:space="preserve">
          <source>The maximum size of the stack (in words). This is only relevant to the byte-code runtime, as the native code runtime uses the operating system's stack. Default: 1024k.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dcda863ccacea505bd2a294ce1ed4f2df1932a4" translate="yes" xml:space="preserve">
          <source>The meaning of format string type parameters is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="290889214c915b5911f3b92719bce41512c0c609" translate="yes" xml:space="preserve">
          <source>The memory layout of Bigarrays is entirely compatible with that of arrays in C and Fortran, allowing large arrays to be passed back and forth between OCaml code and C / Fortran code with no data copying at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db529abafebd1568315a8328ddaf314170689aa7" translate="yes" xml:space="preserve">
          <source>The memory management counters are returned in a &lt;code&gt;stat&lt;/code&gt; record.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4a3b03ef777eb26c6ae028dd5d106d607d702a8" translate="yes" xml:space="preserve">
          <source>The metadata file is available in the OCaml installation. Its location can be obtained using the following command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e072a2bbaafe77d3313822b37614800d154b59ef" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt; provides formatted input functions or &lt;em&gt;scanners&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98dc8a81338816e727b183ae8835ac70814be748" translate="yes" xml:space="preserve">
          <source>The module type expression functor(&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;)-&amp;gt;&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; is the type of functors (functions from modules to modules) that take as argument a module of type &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and return as result a module of type &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. The module type &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; can use the name &lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt; to refer to type components of the actual argument of the functor. If the type &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; does not depend on type components of &lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;, the module type expression can be simplified with the alternative short syntax &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;-&amp;gt;&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; . No restrictions are placed on the type of the functor argument; in particular, a functor may take another functor as argument (&amp;ldquo;higher-order&amp;rdquo; functor).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19e87897038acb2ea0b22d40eb32fcf01d0bb4bf" translate="yes" xml:space="preserve">
          <source>The most common usage of variant types is to describe recursive data structures. Consider for example the type of binary trees:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="969c39463cdd83094435d7ff5442eba358f5bbab" translate="yes" xml:space="preserve">
          <source>The most user-friendly way to use the debugger is to run it under Emacs. See the file emacs/README in the distribution for information on how to load the Emacs Lisp files for OCaml support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78aad986fb7a4eb2c56f1239f1a0ea9f7c757987" translate="yes" xml:space="preserve">
          <source>The motivation is that, by letting &amp;lsquo;ocamlopt&amp;lsquo; deal with boxing, it can often decide to suppress it entirely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e080b5bf8fc37b589b95288dd439c400c34b427b" translate="yes" xml:space="preserve">
          <source>The multiplier is k, M, or G, for multiplication by 2&lt;sup&gt;10&lt;/sup&gt;, 2&lt;sup&gt;20&lt;/sup&gt;, and 2&lt;sup&gt;30&lt;/sup&gt; respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5001d83b2b93aa689b354ed2086458f2935a047" translate="yes" xml:space="preserve">
          <source>The name of the file containing the executable currently running.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59eca0c39d17cb0f2108d6d77b193b119b04559b" translate="yes" xml:space="preserve">
          <source>The name of the file containing the executable currently running. This name may be absolute or relative to the current directory, depending on the platform and whether the program was compiled to bytecode or a native executable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf0030b90670a18e3de17304172d5e4c928be425" translate="yes" xml:space="preserve">
          <source>The name of the initial temporary directory: Under Unix, the value of the &lt;code&gt;TMPDIR&lt;/code&gt; environment variable, or &quot;/tmp&quot; if the variable is not set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c8b8d9700396ab187abf8b0e62dcd1c6f319473" translate="yes" xml:space="preserve">
          <source>The name of the initial temporary directory: Under Unix, the value of the &lt;code&gt;TMPDIR&lt;/code&gt; environment variable, or &quot;/tmp&quot; if the variable is not set. Under Windows, the value of the &lt;code&gt;TEMP&lt;/code&gt; environment variable, or &quot;.&quot; if the variable is not set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c9a52823f32936b8fa5faaa814adee980e5c3ce" translate="yes" xml:space="preserve">
          <source>The name of the temporary directory: Under Unix, the value of the &lt;code&gt;TMPDIR&lt;/code&gt; environment variable, or &quot;/tmp&quot; if the variable is not set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd4c9b92bb5cafc665608d7e7c71ee74b72bd3e4" translate="yes" xml:space="preserve">
          <source>The name of the temporary directory: Under Unix, the value of the &lt;code&gt;TMPDIR&lt;/code&gt; environment variable, or &quot;/tmp&quot; if the variable is not set. Under Windows, the value of the &lt;code&gt;TEMP&lt;/code&gt; environment variable, or &quot;.&quot; if the variable is not set. The temporary directory can be changed with &lt;a href=&quot;filename#VALset_temp_dir_name&quot;&gt;&lt;code&gt;Filename.set_temp_dir_name&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80a92c6fec8ac40ba4e0c4025b59dde0b751953a" translate="yes" xml:space="preserve">
          <source>The named file could not be found in the current directory, nor in the directories of the search path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="952b3090c265f73e61fb891aab443a8262a5704d" translate="yes" xml:space="preserve">
          <source>The named file could not be found in the current directory, nor in the directories of the search path. The filename is either a compiled interface file (.cmi file), or a compiled bytecode file (.cmo file). If filename has the format mod.cmi, this means you are trying to compile a file that references identifiers from module mod, but you have not yet compiled an interface for module mod. Fix: compile mod.mli or mod.ml first, to create the compiled interface mod.cmi.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2f02d60d1e116f8243f8229b3fd568a95c8a809" translate="yes" xml:space="preserve">
          <source>The names of the entry points must be valid identifiers for OCaml values (starting with a lowercase letter). Similarly, the arguments arg&lt;sub&gt;1&lt;/sub&gt;&amp;hellip; arg&lt;sub&gt;n&lt;/sub&gt; must be valid identifiers for OCaml. Each entry point becomes an OCaml function that takes n+1 arguments, the extra implicit last argument being of type Lexing.lexbuf. Characters are read from the Lexing.lexbuf argument and matched against the regular expressions provided in the rule, until a prefix of the input matches one of the rule. The corresponding action is then evaluated and returned as the result of the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5ca4780e331ea88692f3bab8f908b1e857d3545" translate="yes" xml:space="preserve">
          <source>The names of the two C functions must be given in the primitive declaration, as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2af38c50738eb4e1ac67f27fb83521c12f9da713" translate="yes" xml:space="preserve">
          <source>The native C character type under Windows is WCHAR, two bytes wide, while under Unix it is char, one byte wide. A type char_os is defined in &amp;lt;caml/misc.h&amp;gt; that stands for the concrete C character type of each platform. Strings in the platform encoding are of type char_os *.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="376053bbccd9cdcd8890b3fbdf88ead49637bae1" translate="yes" xml:space="preserve">
          <source>The native integer -1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ee1fc5518ff6fbf2992ed7e1ec40186e53f6653" translate="yes" xml:space="preserve">
          <source>The native integer 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bcc40875771e327d2f0e7c0fa203d846f93e6b4" translate="yes" xml:space="preserve">
          <source>The native integer 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c20da3e1fe2cd472edcbc03735391872edbfb80" translate="yes" xml:space="preserve">
          <source>The native-code compiler is only available on certain platforms. It produces code that runs faster than the bytecode produced by ocamlc, at the cost of increased compilation time and executable code size. Compatibility with the bytecode compiler is extremely high: the same source code should run identically when compiled with ocamlc and ocamlopt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e5e7155dfdf15208a1cbe9f526ab06c992a1a3c" translate="yes" xml:space="preserve">
          <source>The native-code compiler ocamlopt also supports the -output-obj option, causing it to output a C object file or a shared library containing the native code for all OCaml modules on the command-line, as well as the OCaml startup code. Initialization is performed by calling caml_startup (or caml_startup_exn) as in the case of the bytecode compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36be14bc239e78c132c193d0ff0e16beb22b0661" translate="yes" xml:space="preserve">
          <source>The native-code compiler performs a number of optimizations that the bytecode compiler does not perform, especially when the Flambda optimizer is active. In particular, the native-code compiler identifies and eliminates &amp;ldquo;dead code&amp;rdquo;, i.e. computations that do not contribute to the results of the program. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f90676a471e21697a3a109feb2073705f4c086a3" translate="yes" xml:space="preserve">
          <source>The next allocation can trigger a garbage collection. The garbage collector assumes that all structured blocks contain well-formed values. Newly created blocks contain random data, which generally do not represent well-formed values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33f94342d426b6ca7b5a6cd5848192a5418df90c" translate="yes" xml:space="preserve">
          <source>The next step is to compile and link the program with the instrumented runtime. This can be done by using the -runtime-variant flag:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbe1c650255dd39febc517d8d6e9ecf4a27a4e50" translate="yes" xml:space="preserve">
          <source>The notion of input channel for the &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt; module: those channels provide all the machinery necessary to read from any source of characters, including a &lt;a href=&quot;stdlib#TYPEin_channel&quot;&gt;&lt;code&gt;in_channel&lt;/code&gt;&lt;/a&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16542651eb8af79575740dab6d97e5baeedd8889" translate="yes" xml:space="preserve">
          <source>The notion of input channel for the &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt; module: those channels provide all the machinery necessary to read from any source of characters, including a &lt;a href=&quot;stdlib#TYPEin_channel&quot;&gt;&lt;code&gt;in_channel&lt;/code&gt;&lt;/a&gt; value. A Scanf.Scanning.in_channel value is also called a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc0369bec5d64b7e5ca44539b36eca9c14402a44" translate="yes" xml:space="preserve">
          <source>The num library implements integer arithmetic and rational arithmetic in arbitrary precision. It was split off the core OCaml distribution starting with the 4.06.0 release, and can now be found at &lt;a href=&quot;https://github.com/ocaml/num&quot;&gt;https://github.com/ocaml/num&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0976e8b95aee4f6b6b94a903578443416a16fd1d" translate="yes" xml:space="preserve">
          <source>The number of samples in this block (&amp;gt;= 1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80c5921664757a5de49c34516dd5a9044bf527fa" translate="yes" xml:space="preserve">
          <source>The object type c0 is an abbreviation for &amp;lt;m : 'a; n : int&amp;gt; as 'a. Consider now the type declaration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4798644a1b3b83b3464a016d6b7ad72bf5f4632" translate="yes" xml:space="preserve">
          <source>The object type c1 is an abbreviation for the type &amp;lt;m : 'a&amp;gt; as 'a. The coercion from an object of type c0 to an object of type c1 is correct:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e56b5bcc7c0be28d1a5ad641e4581f9a06b6925" translate="yes" xml:space="preserve">
          <source>The ocaml.alert or alert attribute serves two purposes: (i) to mark component with an alert to be triggered when the component is referenced, and (ii) to control which alert names are enabled. In the first form, the attribute takes an identifier possibly followed by a message. Here is an example of a value declaration marked with an alert:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="663c4b2feb0ff61316e473a7d7058b8a8ac77602" translate="yes" xml:space="preserve">
          <source>The ocamlc command has a command-line interface similar to the one of most C compilers. It accepts several types of arguments and processes them sequentially, after all options have been processed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ccd15521b1aa9660fdf126df14cf7897ed7444c" translate="yes" xml:space="preserve">
          <source>The ocamlcp and ocamloptp commands also accept all the options of the corresponding ocamlc or ocamlopt compiler, except the -pp (preprocessing) option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa91a0c172cde52b6822b93be7514538cd75d072" translate="yes" xml:space="preserve">
          <source>The ocamldep command scans a set of OCaml source files (.ml and .mli files) for references to external compilation units, and outputs dependency lines in a format suitable for the make utility. This ensures that make will compile the source files in the correct order, and recompile those files that need to when a source file is modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bc0cf38a6832c2cb08c4085b324377b241b03c6" translate="yes" xml:space="preserve">
          <source>The ocamllex command produces a lexical analyzer from a set of regular expressions with attached semantic actions, in the style of lex. Assuming the input file is lexer.mll, executing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="785a09dfb0b7bb6413c4e50f2cabd1b69c63c6b4" translate="yes" xml:space="preserve">
          <source>The ocamlmklib command facilitates the construction of libraries containing both OCaml code and C code, and usable both in static linking and dynamic linking modes. This command is available under Windows since Objective Caml 3.11 and under other operating systems since Objective Caml 3.03.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37782ee3b2232fe93bbe77ca370d4160e2021dd2" translate="yes" xml:space="preserve">
          <source>The ocamlmklib command takes three kinds of arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68dd5d1772fdc70b18042e2faf73bb6d263b83ef" translate="yes" xml:space="preserve">
          <source>The ocamlmktop command builds OCaml toplevels that contain user code preloaded at start-up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6831997e14580584458639904bb3e8b4303221cf" translate="yes" xml:space="preserve">
          <source>The ocamlmktop command takes as argument a set of .cmo and .cma files, and links them with the object files that implement the OCaml toplevel. The typical use is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab3cce8e0848dae6978b901dc63aa4ea6c79e945" translate="yes" xml:space="preserve">
          <source>The ocamlopt command has a command-line interface very close to that of ocamlc. It accepts the same types of arguments, and processes them sequentially, after all options have been processed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f43adb44cad300b255a2ab339a13959b026d322" translate="yes" xml:space="preserve">
          <source>The ocamlprof command produces a source listing of the program modules where execution counts have been inserted as comments. For instance,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7ea8af81e418a1edb4e459f8a9a2eab6da15605" translate="yes" xml:space="preserve">
          <source>The ocamlrun command comprises three main parts: the bytecode interpreter, that actually executes bytecode files; the memory allocator and garbage collector; and a set of C functions that implement primitive operations such as input/output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba3256951b99c851dcb6d71a9ee49e018d24d2bb" translate="yes" xml:space="preserve">
          <source>The ocamlrun command executes bytecode files produced by the linking phase of the ocamlc command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e1235caedb5ccfed4248d72a0e38e7bda7a4c82" translate="yes" xml:space="preserve">
          <source>The ocamlrun command searches shared libraries in the following directories, in the order indicated:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45cf460ec88bc5d152326aaf5ae83eb8df678857" translate="yes" xml:space="preserve">
          <source>The ocamlyacc command produces a parser from a context-free grammar specification with attached semantic actions, in the style of yacc. Assuming the input file is grammar.mly, executing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="028fe9d310df119de0ec84424c8896799e9e2f82" translate="yes" xml:space="preserve">
          <source>The ocamlyacc command recognizes the following options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c12a611ec5444a4dcbe094626c7878666edcceb" translate="yes" xml:space="preserve">
          <source>The only case we have reasonable confidence is safe is if the produced &lt;code&gt;bytes&lt;/code&gt; is shared -- used as an immutable byte sequence. This is possibly useful for incremental migration of low-level programs that manipulate immutable sequences of bytes (for example &lt;a href=&quot;marshal#VALfrom_bytes&quot;&gt;&lt;code&gt;Marshal.from_bytes&lt;/code&gt;&lt;/a&gt;) and previously used the &lt;code&gt;string&lt;/code&gt; type for this purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9599505a809ca09e4fab73b6902744c16bc81fdd" translate="yes" xml:space="preserve">
          <source>The only case where that transformation is not possible is if a given function call may raise distinct exceptions with the same constructor but different string values. In this case, you will have to check for specific string values. This is dangerous API design and it should be discouraged: it&amp;rsquo;s better to define more precise exception constructors than store useful information in strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cedfa4c8d920a307290831222d9cbd51790caf6" translate="yes" xml:space="preserve">
          <source>The only difference with the let construct described above is that the bindings of names to values performed by the pattern-matching are considered already performed when the expressions &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; are evaluated. That is, the expressions &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; can reference identifiers that are bound by one of the patterns &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;, and expect them to have the same value as in &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;, the body of the letrec construct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="774d89b5de623ddb891076997b98ef614701dff8" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;flags&lt;/code&gt; are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e89406e3e1bdda8e82d077bce710e73570e29fe" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;precision&lt;/code&gt; is a dot &lt;code&gt;.&lt;/code&gt; followed by an integer indicating how many digits follow the decimal point in the &lt;code&gt;%f&lt;/code&gt;, &lt;code&gt;%e&lt;/code&gt;, &lt;code&gt;%E&lt;/code&gt;, &lt;code&gt;%h&lt;/code&gt;, and &lt;code&gt;%H&lt;/code&gt; conversions or the maximum number of significant digits to appear for the &lt;code&gt;%F&lt;/code&gt;, &lt;code&gt;%g&lt;/code&gt; and &lt;code&gt;%G&lt;/code&gt; conversions. For instance, &lt;code&gt;%.4f&lt;/code&gt; prints a &lt;code&gt;float&lt;/code&gt; with 4 fractional digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5468298bc781912cae47e80a93f5f848cf36f0ca" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;random&lt;/code&gt; parameter (a boolean) controls whether the internal organization of the hash table is randomized at each execution of &lt;code&gt;Hashtbl.create&lt;/code&gt; or deterministic over all executions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af162af26700a86b364c7a2731480ce8c43ff2a7" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;width&lt;/code&gt; is an integer indicating the minimal width of the result. For instance, &lt;code&gt;%6d&lt;/code&gt; prints an integer, prefixing it with spaces to fill at least 6 characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a984b2d5c22765574cbc75b87562636eb520c87c" translate="yes" xml:space="preserve">
          <source>The optional arguments &lt;code&gt;?stdin&lt;/code&gt; and &lt;code&gt;?stdout&lt;/code&gt; and &lt;code&gt;?stderr&lt;/code&gt; are file names used to redirect the standard input, the standard output, or the standard error of the command. If &lt;code&gt;~stdin:f&lt;/code&gt; is given, a redirection &lt;code&gt;&amp;lt;&amp;nbsp;f&lt;/code&gt; is performed and the standard input of the command reads from file &lt;code&gt;f&lt;/code&gt;. If &lt;code&gt;~stdout:f&lt;/code&gt; is given, a redirection &lt;code&gt;&amp;gt;&amp;nbsp;f&lt;/code&gt; is performed and the standard output of the command is written to file &lt;code&gt;f&lt;/code&gt;. If &lt;code&gt;~stderr:f&lt;/code&gt; is given, a redirection &lt;code&gt;2&amp;gt;&amp;nbsp;f&lt;/code&gt; is performed and the standard error of the command is written to file &lt;code&gt;f&lt;/code&gt;. If both &lt;code&gt;~stdout:f&lt;/code&gt; and &lt;code&gt;~stderr:f&lt;/code&gt; are given, with the exact same file name &lt;code&gt;f&lt;/code&gt;, a &lt;code&gt;2&amp;gt;&amp;amp;1&lt;/code&gt; redirection is performed so that the standard output and the standard error of the command are interleaved and redirected to the same file &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e256823745bc0b0bb3e5fba44ec11d079e0f250" translate="yes" xml:space="preserve">
          <source>The optional type equation =&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; makes the defined type equivalent to the type expression &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;: one can be substituted for the other during typing. If no type equation is given, a new type is generated: the defined type is incompatible with any other type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4236d000dcf5d91e24113385c5dda11fb81d860b" translate="yes" xml:space="preserve">
          <source>The optional type parameters are either one type variable '&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;, for type constructors with one parameter, or a list of type variables ('&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;,&amp;hellip;,'&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;), for type constructors with several parameters. Each type parameter may be prefixed by a variance constraint + (resp. -) indicating that the parameter is covariant (resp. contravariant). These type parameters can appear in the type expressions of the right-hand side of the definition, optionally restricted by a variance constraint ; &lt;em&gt;i.e.&lt;/em&gt; a covariant parameter may only appear on the right side of a functional arrow (more precisely, follow the left branch of an even number of arrows), and a contravariant parameter only the left side (left branch of an odd number of arrows). If the type has a representation or an equation, and the parameter is free (&lt;em&gt;i.e.&lt;/em&gt; not bound via a type constraint to a constructed type), its variance constraint is checked but subtyping &lt;em&gt;etc.&lt;/em&gt; will use the inferred variance of the parameter, which may be less restrictive; otherwise (&lt;em&gt;i.e.&lt;/em&gt; for abstract types or non-free parameters), the variance must be given explicitly, and the parameter is invariant if no variance is given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dca346bd513d4a4a22688d0f639db0a9deec76c9" translate="yes" xml:space="preserve">
          <source>The optional type representation describes the data structure representing the defined type, by giving the list of associated constructors (if it is a variant type) or associated fields (if it is a record type). If no type representation is given, nothing is assumed on the structure of the type besides what is stated in the optional type equation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c913082fd743d89983385840500d287f715d0b40" translate="yes" xml:space="preserve">
          <source>The order in which the .cmo files are given to ocamlc during the linking phase determines the order in which the module definitions occur. Hence, in the example above, Aux appears first and Main can refer to it, but Aux cannot refer to Main.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9875c6ba3859a4c01a0b128c6fb6274d60da0369" translate="yes" xml:space="preserve">
          <source>The order in which the bindings are passed to &lt;code&gt;f&lt;/code&gt; is unspecified. However, if the table contains several bindings for the same key, they are passed to &lt;code&gt;f&lt;/code&gt; in reverse order of introduction, that is, the most recent binding is passed first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0038d1e71d2d22bcc5fc3fc7481009a2bb18e7e5" translate="yes" xml:space="preserve">
          <source>The order in which the expressions &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;, &lt;a href=&quot;#argument&quot;&gt;argument&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;#argument&quot;&gt;argument&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; are evaluated is not specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63c6c1451d4aeaf3a047e06c6ffd102113e24f2b" translate="yes" xml:space="preserve">
          <source>The other caveat is that by default symbolic links are a privileged operation. Administrators will always need to be running elevated (or with UAC disabled) and by default normal user accounts need to be granted the SeCreateSymbolicLinkPrivilege via Local Security Policy (secpol.msc) or via Active Directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69042c37de15f706ea13e0d0d27fbaa418b8568a" translate="yes" xml:space="preserve">
          <source>The other form of function definition is introduced by the keyword fun:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ef7b523167e57b31abccd875bb07306286ad08a" translate="yes" xml:space="preserve">
          <source>The output buffer of a symbolic pretty-printer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="197edf84eebbfd7ce0d59bc84a2b213982ad8e53" translate="yes" xml:space="preserve">
          <source>The output of the linking phase is a file containing compiled bytecode that can be executed by the OCaml bytecode interpreter: the command named ocamlrun. If a.out is the name of the file produced by the linking phase, the command</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f86bd69d544011aefe916eee4af7cd635e073e0c" translate="yes" xml:space="preserve">
          <source>The output of the linking phase is a regular Unix or Windows executable file. It does not need ocamlrun to run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ce0fa21bd7ce51645890738324e05068fce2adc" translate="yes" xml:space="preserve">
          <source>The output signature of the functor &lt;a href=&quot;ephemeron.k1.make&quot;&gt;&lt;code&gt;Ephemeron.K1.Make&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ephemeron.k2.make&quot;&gt;&lt;code&gt;Ephemeron.K2.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b888b9c1ae97afb61ed88f6dcc91b6356987780" translate="yes" xml:space="preserve">
          <source>The output signature of the functor &lt;a href=&quot;ephemeron.k1.make&quot;&gt;&lt;code&gt;Ephemeron.K1.Make&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ephemeron.k2.make&quot;&gt;&lt;code&gt;Ephemeron.K2.Make&lt;/code&gt;&lt;/a&gt;. These hash tables are weak in the keys. If all the keys of a binding are alive the binding is kept, but if one of the keys of the binding is dead then the binding is removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6df4d9df08fab00830fd043eb96f7af5ace9c32e" translate="yes" xml:space="preserve">
          <source>The output signature of the functor &lt;a href=&quot;ephemeron.k1.makeseeded&quot;&gt;&lt;code&gt;Ephemeron.K1.MakeSeeded&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ephemeron.k2.makeseeded&quot;&gt;&lt;code&gt;Ephemeron.K2.MakeSeeded&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc4f49be3b37069506238985b68b76a704e8a12" translate="yes" xml:space="preserve">
          <source>The output signature of the functor &lt;a href=&quot;hashtbl.make&quot;&gt;&lt;code&gt;Hashtbl.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acd77c5116baf2558a8ee6e7372f7c8f987c6831" translate="yes" xml:space="preserve">
          <source>The output signature of the functor &lt;a href=&quot;hashtbl.makeseeded&quot;&gt;&lt;code&gt;Hashtbl.MakeSeeded&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffa1e6deb7c02cb5fb60673b1d37d74545f296d4" translate="yes" xml:space="preserve">
          <source>The output signature of the functor &lt;a href=&quot;weak.make&quot;&gt;&lt;code&gt;Weak.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="235dcfaccc10009cd349c37e2f6b3ea0f93a7b42" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;callstack_size&lt;/code&gt; is the length of the callstack recorded at every sample. Its default is &lt;code&gt;max_int&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e070830e786df33101debf41e042d4603dc7e8c" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;sampling_rate&lt;/code&gt; is the sampling rate in samples per word (including headers). Usually, with cheap callbacks, a rate of 1e-4 has no visible effect on performance, and 1e-3 causes the program to run a few percent slower</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49970203f15065fd920f5133460488f7c2c20b5b" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;tracker&lt;/code&gt; determines how to track sampled blocks over their lifetime in the minor and major heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09fbb96897f07cf55eb54e9bcb8824b504ac0830" translate="yes" xml:space="preserve">
          <source>The parameter patterns ~&lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt; and ~(&lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt; [:&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;]) are shorthands for respectively ~&lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt;:&lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt; and ~&lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt;:(&lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt; [:&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;]), and similarly for their optional counterparts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e5974a12a7d51f44c9175604dd69a6dc4db175f" translate="yes" xml:space="preserve">
          <source>The parameter x_init is, of course, visible in the whole body of the definition, including methods. For instance, the method get_offset in the class below returns the position of the object relative to its initial position.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e95fd7cf7f4ba7d41d47acfb96f75946ad23cd79" translate="yes" xml:space="preserve">
          <source>The parser also enters error recovery mode if one of the grammar actions raises the Parsing.Parse_error exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34d65af266245e845378220e5a545186f7764e3e" translate="yes" xml:space="preserve">
          <source>The pass analyses functions to determine which arguments are unused. Removal is effected by creating a wrapper function, which will be inlined at every direct call site, that accepts the original arguments and then discards the unused ones before calling the original function. As a consequence, this transformation may be detrimental if the original function is usually indirectly called, since such calls will now bounce through the wrapper. (The technique of &lt;em&gt;direct call surrogates&lt;/em&gt; used to reduce this penalty during unboxing of closure variables (see above) does not yet apply to the pass that removes unused arguments.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddb1f22a5bac6d00f359ad560b86fb3d4abcbdd7" translate="yes" xml:space="preserve">
          <source>The pattern 'c'..'d' is a shorthand for the pattern</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78a9eb434825f2c323017a519a3d60fa9f698c76" translate="yes" xml:space="preserve">
          <source>The pattern (&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;) matches the same values as &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;. A type constraint can appear in a parenthesized pattern, as in (&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;). This constraint forces the type of &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to be compatible with &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16ae7f98de1b36c58b45270ed0fb02b7e9c6764a" translate="yes" xml:space="preserve">
          <source>The pattern (module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;) matches a package with type &lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt; and binds it to &lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;. It is not allowed in toplevel let bindings. Again &lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt; can be omitted if it can be inferred from the enclosing pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f60d5e8c331afa9fe8e1e6db86c21aacdc85acef" translate="yes" xml:space="preserve">
          <source>The pattern &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; ,&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; matches n-tuples whose components match the patterns &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; through &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;. That is, the pattern matches the tuple values (v&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, v&lt;sub&gt;n&lt;/sub&gt;) such that &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; matches v&lt;sub&gt;i&lt;/sub&gt; for i = 1,&amp;hellip; , n.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6da6c23d8212831014d6c0f7d9fd644913b7199" translate="yes" xml:space="preserve">
          <source>The pattern &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;::&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; matches non-empty lists whose heads match &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, and whose tails match &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41348db0bf142801b4dc26e958764633a28f85d6" translate="yes" xml:space="preserve">
          <source>The pattern &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;as&lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt; matches the same values as &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;. If the matching against &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; is successful, the name &lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt; is bound to the matched value, in addition to the bindings performed by the matching against &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9299c9cb5135cc2b4bedfa03f575390c8ead0e50" translate="yes" xml:space="preserve">
          <source>The pattern &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;|&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; represents the logical &amp;ldquo;or&amp;rdquo; of the two patterns &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. A value matches &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;|&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; if it matches &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; or &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. The two sub-patterns &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; must bind exactly the same identifiers to values having the same types. Matching is performed from left to right. More precisely, in case some value v matches &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;|&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;, the bindings performed are those of &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; when v matches &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;. Otherwise, value v matches &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; whose bindings are performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00b0db5a51b1f1d5c7c59b426eaf70572b94fa7f" translate="yes" xml:space="preserve">
          <source>The pattern &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;(&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; ,&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;) matches all variants whose constructor is equal to &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;, and whose arguments match &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;. It is a type error if n is not the number of arguments expected by the constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d790d4519563bbe23e283cddeb381557179c1ed8" translate="yes" xml:space="preserve">
          <source>The pattern &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;_ matches all variants whose constructor is &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c4b162c77607f7f0c96e87989be66403257ce86" translate="yes" xml:space="preserve">
          <source>The pattern [&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip; ;&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;] matches lists of length n whose elements match &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip;&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;, respectively. This pattern behaves like &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:: &amp;hellip; ::&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;::[].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5be2296eeedc0ad28df110fb34fef15f60597b6f" translate="yes" xml:space="preserve">
          <source>The pattern [|&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip; ;&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;|] matches arrays of length n such that the i-th array element matches the pattern &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt;, for i = 1,&amp;hellip; , n.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1788df79d59202a4d26aad006675bcfb219b3e5f" translate="yes" xml:space="preserve">
          <source>The pattern `&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; matches all polymorphic variants whose tag is equal to &lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;, and whose argument matches &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d78189bca7a2a4a7c7d4b24d2ca0b9ace362515e" translate="yes" xml:space="preserve">
          <source>The pattern lazy&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt; matches a value v of type Lazy.t, provided &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt; matches the result of forcing v with Lazy.force. A successful match of a pattern containing lazy sub-patterns forces the corresponding parts of the value being matched, even those that imply no test such as lazy&lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt; or lazy_. Matching a value with a &lt;a href=&quot;expr#pattern-matching&quot;&gt;pattern-matching&lt;/a&gt; where some patterns contain lazy sub-patterns may imply forcing parts of the value, even when the pattern selected in the end has no lazy sub-pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16f7adce7fddea3b9b8f86106681f2bc5fc82ba6" translate="yes" xml:space="preserve">
          <source>The pattern {&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; [=&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;] ; &amp;hellip; ;&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; [=&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;] } matches records that define at least the fields &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; through &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;, and such that the value associated to &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; matches the pattern &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt;, for i = 1,&amp;hellip; , n. A single identifier &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; stands for &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;=&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; , and a single qualified identifier &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; stands for &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;=&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; . The record value can define more fields than &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip;&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;; the values associated to these extra fields are not taken into account for matching. Optionally, a record pattern can be terminated by ;_ to convey the fact that not all fields of the record type are listed in the record pattern and that it is intentional. Optional type constraints can be added field by field with {&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;;&amp;hellip; ;&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;=&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;} to force the type of &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; to be compatible with &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28c11f2884ea2e751e90db06b713059bf8743ce8" translate="yes" xml:space="preserve">
          <source>The pointer returned by caml_named_value is constant and can safely be cached in a C variable to avoid repeated name lookups. The value pointed to cannot be changed from C. However, it might change during garbage collection, so must always be recomputed at the point of use. Here is a more efficient variant of call_caml_f above that calls caml_named_value only once:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32e4ea607d04ac6fcfc5da2a4f99be29eb749147" translate="yes" xml:space="preserve">
          <source>The policy used for allocating in the major heap. Possible values are 0, 1 and 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0575e3a19290f6df5fdcaa47a106f8449112455" translate="yes" xml:space="preserve">
          <source>The polymorphic hash functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10931e6e8e695da4d6f07c1443d2547e5cf128cc" translate="yes" xml:space="preserve">
          <source>The polymorphism may be left implicit in public method specifications: any type variable which is not bound to a class parameter and does not appear elsewhere inside the class specification will be assumed to be universal, and made polymorphic in the resulting method type. Writing an explicit polymorphic type will disable this behaviour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46f55cdbce1c396ddb68caad025838e2c114c305" translate="yes" xml:space="preserve">
          <source>The precedence declarations are used in the following way to resolve reduce/reduce and shift/reduce conflicts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1442484d01949a40882f7fd1198334b88701ef0b" translate="yes" xml:space="preserve">
          <source>The pretty-printer must split the line at this point,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e659673f1b18fb1d82b63a1c55173f87e4ba3218" translate="yes" xml:space="preserve">
          <source>The pretty-printing engine uses the concepts of pretty-printing box and break hint to drive indentation and line splitting behavior of the pretty-printer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a53dbcb487f74a0958c713e69a144733631dbfe2" translate="yes" xml:space="preserve">
          <source>The pretty-printing functions output material that is delayed in the pretty-printer queue and stacks in order to compute proper line splitting. In contrast, basic I/O output functions write directly in their output device. As a consequence, the output of a basic I/O function may appear before the output of a pretty-printing function that has been called before. For instance, &lt;code&gt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Stdlib.print_string&amp;nbsp;&quot;&amp;lt;&quot;;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Format.print_string&amp;nbsp;&quot;PRETTY&quot;;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Stdlib.print_string&amp;nbsp;&quot;&amp;gt;&quot;;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Format.print_string&amp;nbsp;&quot;TEXT&quot;;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt; leads to output &lt;code&gt;&amp;lt;&amp;gt;PRETTYTEXT&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f51978ff177538bd6acc10bb07871f9792c046ef" translate="yes" xml:space="preserve">
          <source>The pretty-printing indication characters are introduced by a &lt;code&gt;@&lt;/code&gt; character, and their meanings are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="433dda59f28a1c16b7f6ad751b61d21f14015c15" translate="yes" xml:space="preserve">
          <source>The previous coercion problem can often be avoided by first defining the abbreviation, using a class type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb0dbd05eb51d23e1a522b80e905369b8eb83ac6" translate="yes" xml:space="preserve">
          <source>The printing function printer-name should have type Format.formatter-&amp;gt;t-&amp;gt;unit, where t is the type for the values to be printed, and should output its textual representation for the value of type t on the given formatter, using the functions provided by the Format library. For backward compatibility, printer-name can also have type t-&amp;gt;unit and should then output on the standard formatter, but this usage is deprecated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8883bf4f143303eb37a391cfe05fa314bafceca6" translate="yes" xml:space="preserve">
          <source>The problem here is that SET specifies the type element abstractly, so that the type equality between element in the result of the functor and t in its argument is forgotten. Consequently, WrongStringSet.element is not the same type as string, and the operations of WrongStringSet cannot be applied to strings. As demonstrated above, it is important that the type element in the signature SET be declared equal to Elt.t; unfortunately, this is impossible above since SET is defined in a context where Elt does not exist. To overcome this difficulty, OCaml provides a with type construct over signatures that allows enriching a signature with extra type equalities:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79d5207edef86d719b23b481fee7c2e0aa2b94e6" translate="yes" xml:space="preserve">
          <source>The problem here is that quantification was wrongly located: it is not the class we want to be polymorphic, but the fold method. This can be achieved by giving an explicitly polymorphic type in the method definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d28eba679c98023f0747aaf9581f0f01fc941cfe" translate="yes" xml:space="preserve">
          <source>The process terminated normally by &lt;code&gt;exit&lt;/code&gt;; the argument is the return code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="168ecaee8748c10e62b8f47e3dcea6c8cbd65579" translate="yes" xml:space="preserve">
          <source>The process was killed by a signal; the argument is the signal number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34eaa6addd6d491cf217fc8965c116ada2b0beed" translate="yes" xml:space="preserve">
          <source>The process was stopped by a signal; the argument is the signal number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c048c9cffeb4593d3904a5383fdb63616e02e942" translate="yes" xml:space="preserve">
          <source>The produced file has the executable bit set, and it manages to launch the bytecode interpreter by itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5147f68b7fbbbd5f93868579353c15f80510e07f" translate="yes" xml:space="preserve">
          <source>The program behaves exactly as if the following phrases were entered at top-level:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f484a5296a71c426225e4ed54accc59929e24d8b" translate="yes" xml:space="preserve">
          <source>The program being executed contains a &amp;ldquo;stray&amp;rdquo; exception. That is, it raises an exception at some point, and this exception is never caught. This causes immediate termination of the program. The name of the exception is printed, along with its string, byte sequence, and integer arguments (arguments of more complex types are not correctly printed). To locate the context of the uncaught exception, compile the program with the -g option and either run it again under the ocamldebug debugger (see chapter &lt;a href=&quot;debugger#c%3Adebugger&quot;&gt;17&lt;/a&gt;), or run it with ocamlrun -b or with the OCAMLRUNPARAM environment variable set to b=1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b266af3c49a1ad66480fec482895593ef57dff7e" translate="yes" xml:space="preserve">
          <source>The program being executed requires more memory than available. Either the program builds excessively large data structures; or the program contains too many nested function calls, and the stack overflows. In some cases, your program is perfectly correct, it just requires more memory than your machine provides. In other cases, the &amp;ldquo;out of memory&amp;rdquo; message reveals an error in your program: non-terminating recursive function, allocation of an excessively large array, string or byte sequence, attempts to build an infinite list or other data structure, &amp;hellip;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a503f7e4a9e093239bc1734598a0ac0302624fc9" translate="yes" xml:space="preserve">
          <source>The program being profiled must exit normally or be caused to exit using the SIGINT signal (e.g. by pressing Ctrl+C). When the program exits files will be written in the directory that was the working directory when the program was started. One Spacetime file will be written for each process that was involved, indexed by process ID; there will normally only be one such. The Spacetime files may be substantial. The directory to which they are written may be overridden by setting the OCAML_SPACETIME_SNAPSHOT_DIR environment variable before the program is started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cc4a8046bc314aed242125f697f2a900a2c88e8" translate="yes" xml:space="preserve">
          <source>The program is run directly by the debugger. This is the default mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="869eb5aeb2fdd87b2a28ba89f60a8c2af784a6d6" translate="yes" xml:space="preserve">
          <source>The program will have to start event collection explicitly. Starting and stopping event collection programmatically can be done by calling Gc.eventlog_resume and Gc.eventlog_pause) from within the program. Refer to the &lt;a href=&quot;libref/gc&quot;&gt;Gc&lt;/a&gt; module documentation for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07c2399b10db28be424b9d95192597cf13943884" translate="yes" xml:space="preserve">
          <source>The projections from p may be replaced by uses of the variables x and y, potentially meaning that p becomes unused.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e07f245bb0c49e7a50bc84525e1cacf4689e631" translate="yes" xml:space="preserve">
          <source>The propagation can help to eliminate allocations in cases such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f79e766e028d6e095da9d529d5a9dfbe0498d920" translate="yes" xml:space="preserve">
          <source>The propagation performed by the simplification pass is also important for discovering which functions flow to indirect call sites. This can enable the transformation of such call sites into direct call sites, which makes them eligible for an inlining transformation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94c9da3eb2e38629000eda75e07fe34fd5562fd6" translate="yes" xml:space="preserve">
          <source>The reason for the error: unknown option, invalid or missing argument, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a43dbd7b9edc2247945720db7869546aded72b86" translate="yes" xml:space="preserve">
          <source>The reason is that at least one of the methods has a polymorphic type (here, the type of the value stored in the reference cell), thus either the class should be parametric, or the method type should be constrained to a monomorphic type. A monomorphic instance of the class could be defined by:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="072461fde3d0d8b6efbc5a6868695ccf66c6f021" translate="yes" xml:space="preserve">
          <source>The reason this is unsafe is because the simplification pass believes that fst a holds the value 42; and indeed it must, unless type soundness has been broken via unsafe operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c67a48b57781f36d335583c6c3fd5c675bbebd44" translate="yes" xml:space="preserve">
          <source>The recursive definition is guaranteed to behave as described above if the expressions &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; are function definitions (fun &amp;hellip; or function &amp;hellip;), and the patterns &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; are just value names, as in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be50e5ba6751e078d213ea17d81f37abaeae3a78" translate="yes" xml:space="preserve">
          <source>The registration causes the contents of the variable or memory location to be updated by the garbage collector whenever the value in such variable or location is moved within the OCaml heap. In the presence of threads care must be taken to ensure appropriate synchronisation with the OCaml runtime to avoid a race condition against the garbage collector when reading or writing the value. (See section &lt;a href=&quot;#ss%3Aparallel-execution-long-running-c-code&quot;&gt;20.12.2&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e498792eb5a8e5a1f7711c5d76148d563e2627fe" translate="yes" xml:space="preserve">
          <source>The registration mechanism described above can also be used to communicate exception identifiers from OCaml to C. The OCaml code registers the exception by evaluating Callback.register_exceptionn exn, where n is an arbitrary name and exn is an exception value of the exception to register. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e412ad57efe185f94f3f66dee663594387b73ec" translate="yes" xml:space="preserve">
          <source>The regular expressions are in the style of lex, with a more OCaml-like syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca763eb3bdb448bf22bb32fc59cd71ec5db35a9f" translate="yes" xml:space="preserve">
          <source>The representation is chosen according to the following, in decreasing order of priority:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cb9b87429c5694aec26392deb0ded32f7bf6b82" translate="yes" xml:space="preserve">
          <source>The representation of marshaled values is not human-readable, and uses bytes that are not printable characters. Therefore, input and output channels used in conjunction with &lt;code&gt;Marshal.to_channel&lt;/code&gt; and &lt;code&gt;Marshal.from_channel&lt;/code&gt; must be opened in binary mode, using e.g. &lt;code&gt;open_out_bin&lt;/code&gt; or &lt;code&gt;open_in_bin&lt;/code&gt;; channels opened in text mode will cause unmarshaling errors on platforms where text channels behave differently than binary channels, e.g. Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b30fdf8a2c0fb75299c4dafd61caaf7a19cc1857" translate="yes" xml:space="preserve">
          <source>The rest of the binding is the same for both platforms:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44c9e601546b4f760808bdd19852d33ad5355c07" translate="yes" xml:space="preserve">
          <source>The restriction can also be performed during the definition of the structure, as in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc0357393d60a0f1fa7baa5274ba71a46d90f408" translate="yes" xml:space="preserve">
          <source>The resulting P.cmx object file has sub-modules P.Q, P.Q.A and P.B.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="540f70e6d81a40f7974a7c5702a14ef36eff5dc8" translate="yes" xml:space="preserve">
          <source>The resulting benefit value is known as the &lt;em&gt;estimated benefit&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f24d01c073b212c7b11b8ff5380c3e1f163e921d" translate="yes" xml:space="preserve">
          <source>The resulting program can then be traced by running it with the environment variable OCAML_EVENTLOG_ENABLED:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0936bfa6fa4fa6c80130298ea1d5af175d858507" translate="yes" xml:space="preserve">
          <source>The resulting trace contains only one event payload, namely a &lt;em&gt;flush&lt;/em&gt; event, indicating how much time was spent flushing the trace file to disk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ed3a555a7ebebf96c3208ad39f845704f68067a" translate="yes" xml:space="preserve">
          <source>The resulting trace will contain all events encountered during the program&amp;rsquo;s execution:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76a2e5fedee04aeb14150359846ceeb930560151" translate="yes" xml:space="preserve">
          <source>The results of calling &lt;a href=&quot;string#VALmake&quot;&gt;&lt;code&gt;String.make&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bytes#VALmake&quot;&gt;&lt;code&gt;Bytes.make&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bytes#VALcreate&quot;&gt;&lt;code&gt;Bytes.create&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;array#VALmake&quot;&gt;&lt;code&gt;Array.make&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;stdlib#VALref&quot;&gt;&lt;code&gt;ref&lt;/code&gt;&lt;/a&gt; are guaranteed to be heap-allocated and non-constant except when the length argument is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dab88c1cb3eef6aab0ce452f5d3a24ee29766571" translate="yes" xml:space="preserve">
          <source>The right way to solve this problem for optional parameters is to add a type annotation to the argument bump.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="021484aa4f766fbe935de88999e6cb6d7bb47d1e" translate="yes" xml:space="preserve">
          <source>The rules may contain the special symbol error to indicate resynchronization points, as in yacc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2425e4fb8fd4780c2506baebfe7345c64646daa" translate="yes" xml:space="preserve">
          <source>The run-time library for lexers generated by &lt;code&gt;ocamllex&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d4e630606c50faf5f2e5b24a4b0bf1a04b6c5db" translate="yes" xml:space="preserve">
          <source>The run-time library for parsers generated by &lt;code&gt;ocamlyacc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b06b765c6160900806a7c7c50af837787bf9890a" translate="yes" xml:space="preserve">
          <source>The runtime overhead imposed by Spacetime varies considerably depending on the particular program being profiled. The overhead may be as low as ten percent&amp;mdash;but more usually programs should be expected to run at perhaps a third or quarter of their normal speed. It is expected that this overhead will be reduced in future versions of the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ef99f2b64955164c9593d8e632198f04c1ea43d" translate="yes" xml:space="preserve">
          <source>The runtime representation of a function. This includes pointers to the code of the function together with the values of any variables that are used in the body of the function but actually defined outside of the function, in the enclosing scope. The values of such variables, collectively known as the &lt;em&gt;environment&lt;/em&gt;, are required because the function may be invoked from a place where the original bindings of such variables are no longer in scope. A group of possibly mutually-recursive functions defined using &lt;em&gt;let rec&lt;/em&gt; all share a single closure. (Note to developers: in the Flambda source code a &lt;em&gt;closure&lt;/em&gt; always corresponds to a single function; a &lt;em&gt;set of closures&lt;/em&gt; refers to a group of such.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09e0b17c8f9005f5c598030be2554c687ccaa24d" translate="yes" xml:space="preserve">
          <source>The same feature is provided for method definitions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f69459bd2efc915e393510bd7d020112db264859" translate="yes" xml:space="preserve">
          <source>The same goes for &lt;code&gt;set_double_field&lt;/code&gt; and &lt;code&gt;set_tag&lt;/code&gt;. However, for &lt;code&gt;set_tag&lt;/code&gt;, in the case of immutable blocks where the middle-end optimizers never see code that discriminates on their tag (for example records), the operation should be safe. Such uses are nonetheless discouraged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c251a3b5f6c58244053faab7ecc98ddabddcb4f0" translate="yes" xml:space="preserve">
          <source>The same ownership discipline that makes &lt;code&gt;unsafe_to_string&lt;/code&gt; correct applies to &lt;code&gt;unsafe_of_string&lt;/code&gt;: you may use it if you were the owner of the &lt;code&gt;string&lt;/code&gt; value, and you will own the return &lt;code&gt;bytes&lt;/code&gt; in the same mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ac338637d2a5fce3a9f3793f3f8813dc5e79b82" translate="yes" xml:space="preserve">
          <source>The same shortcut is available for enumerated lists, using &amp;rsquo;+&amp;rsquo; instead of &amp;rsquo;-&amp;rsquo;. Note that only one list can be defined by this shortcut in nested lists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a96000f19b19300268f15d1d76e944ef3a1ebf04" translate="yes" xml:space="preserve">
          <source>The same syntactic form is also used to attach attributes to labels and constructors in type declarations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c56f9cdc02f4eaf0671121f748c04b2b039e6299" translate="yes" xml:space="preserve">
          <source>The scanning indications introduce slight differences in the syntax of &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt; format strings, compared to those used for the &lt;a href=&quot;printf&quot;&gt;&lt;code&gt;Printf&lt;/code&gt;&lt;/a&gt; module. However, the scanning indications are similar to those used in the &lt;a href=&quot;format&quot;&gt;&lt;code&gt;Format&lt;/code&gt;&lt;/a&gt; module; hence, when producing formatted text to be scanned by &lt;a href=&quot;scanf#VALbscanf&quot;&gt;&lt;code&gt;Scanf.bscanf&lt;/code&gt;&lt;/a&gt;, it is wise to use printing functions from the &lt;a href=&quot;format&quot;&gt;&lt;code&gt;Format&lt;/code&gt;&lt;/a&gt; module (or, if you need to use functions from &lt;a href=&quot;printf&quot;&gt;&lt;code&gt;Printf&lt;/code&gt;&lt;/a&gt;, banish or carefully double check the format strings that contain &lt;code&gt;'@'&lt;/code&gt; characters).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d497c2d6e07b975e5682bc991cd842d916c5c070" translate="yes" xml:space="preserve">
          <source>The second case is an open variant type, describing a polymorphic variant value: it gives the list of all tags the value could take, with their associated types. This type is still compatible with a variant type containing more tags. A special case is the unknown type, which does not define any tag, and is compatible with any variant type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4cd062edd42fc49d3c066f95872cdcd6b75a514" translate="yes" xml:space="preserve">
          <source>The second drawback of dynamic linking is that it complicates the construction of the library. The C compiler and linker flags to compile to position-independent code and build a shared library vary wildly between different Unix systems. Also, dynamic linking is not supported on all Unix systems, requiring a fall-back case to static linking in the Makefile for the library. The ocamlmklib command (see section &lt;a href=&quot;#s%3Aocamlmklib&quot;&gt;20.14&lt;/a&gt;) tries to hide some of these system dependencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1cce543693960e06654a40bc08d8813b14f9075" translate="yes" xml:space="preserve">
          <source>The second example is more subtle: while we intended the argument bump to be of type ?step:int -&amp;gt; int -&amp;gt; int, it is inferred as step:int -&amp;gt; int -&amp;gt; 'a. These two types being incompatible (internally normal and optional arguments are different), a type error occurs when applying bump_it to the real bump.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d4ee921aaa1ec3723cdbada30294d66c801a5b5" translate="yes" xml:space="preserve">
          <source>The second form of attributes are attached to &amp;ldquo;blocks&amp;rdquo; such as type declarations, class fields, etc:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bcf7cdc991e4c97ac21aa1c7ae7ff5801e85d37" translate="yes" xml:space="preserve">
          <source>The second major class of non-genericity is directly related to the problem of type inference for polymorphic functions. In some circumstances, the type inferred by OCaml might be not general enough to allow the definition of some recursive functions, in particular for recursive function acting on non-regular algebraic data type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddae56c7d78a1170cc9452541524e5c04728b654" translate="yes" xml:space="preserve">
          <source>The semantic tag handling functions specific to a formatter: &lt;code&gt;mark&lt;/code&gt; versions are the 'tag-marking' functions that associate a string marker to a tag in order for the pretty-printing engine to write those markers as 0 length tokens in the output device of the formatter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bff7da471def393c1b371feaa59a0379272afe47" translate="yes" xml:space="preserve">
          <source>The semantic tag handling functions specific to a formatter: &lt;code&gt;mark&lt;/code&gt; versions are the 'tag-marking' functions that associate a string marker to a tag in order for the pretty-printing engine to write those markers as 0 length tokens in the output device of the formatter. &lt;code&gt;print&lt;/code&gt; versions are the 'tag-printing' functions that can perform regular printing when a tag is closed or opened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bcc6c39a05b6e4644ddb92b4ebfbec3f0bd5823" translate="yes" xml:space="preserve">
          <source>The semantics is clear: match the scrutinee against the pattern, if it matches, test the guard, and if the guard passes, take the branch. In particular, consider the input (Consta, Constb), where a fails the test is_neutrala, while b passes the test is_neutralb. With the left-to-right semantics, the clause above is &lt;em&gt;not&lt;/em&gt; taken by its input: matching (Consta, Constb) against the or-pattern succeeds in the left branch, it returns the environment x-&amp;gt;a, and then the guard is_neutrala is tested and fails, the branch is not taken.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a1ca7a03baad7716212210f3fc88fe09e15dd50" translate="yes" xml:space="preserve">
          <source>The semantics of or-patterns in OCaml is specified with a left-to-right bias: a value v matches the pattern p|q if it matches p or q, but if it matches both, the environment captured by the match is the environment captured by p, never the one captured by q.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33bae5ab3c39edb36e6026c0e18053f2831c7697" translate="yes" xml:space="preserve">
          <source>The serialize field can be set to custom_serialize_default, in which case the Failure exception is raised when attempting to serialize the custom block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d40ce64ff61f966dff5d5f82bc2dc3bb7256bb8b" translate="yes" xml:space="preserve">
          <source>The serialize field contains a pointer to a C function that is called whenever the custom block needs to be serialized (marshaled) using the OCaml functions output_value or Marshal.to_.... For a custom block, those functions first write the identifier of the block (as given by the identifier field) to the output stream, then call the user-provided serialize function. That function is responsible for writing the data contained in the custom block, using the serialize_... functions defined in &amp;lt;caml/intext.h&amp;gt; and listed below. The user-provided serialize function must then store in its bsize_32 and bsize_64 parameters the sizes in bytes of the data part of the custom block on a 32-bit architecture and on a 64-bit architecture, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2942136b250ae1097e80c746ad490f52ed3542e" translate="yes" xml:space="preserve">
          <source>The set of command line flags relating to optimisation should typically be specified to be the same across an entire project. Flambda does not currently record the requested flags in the .cmx files. As such, inlining of functions from previously-compiled units will subject their code to the optimisation parameters of the unit currently being compiled, rather than those specified when they were previously compiled. It is hoped to rectify this deficiency in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75f7516c7000daca4e41898b962a62fb90ba554f" translate="yes" xml:space="preserve">
          <source>The set of output functions specific to a formatter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58f5c99c8953630f7d0eb9e43e64f07f7389a46f" translate="yes" xml:space="preserve">
          <source>The set of output functions specific to a formatter: the &lt;code&gt;out_string&lt;/code&gt; function performs all the pretty-printer string output. It is called with a string &lt;code&gt;s&lt;/code&gt;, a start position &lt;code&gt;p&lt;/code&gt;, and a number of characters &lt;code&gt;n&lt;/code&gt;; it is supposed to output characters &lt;code&gt;p&lt;/code&gt; to &lt;code&gt;p&amp;nbsp;+&amp;nbsp;n&amp;nbsp;-&amp;nbsp;1&lt;/code&gt; of &lt;code&gt;s&lt;/code&gt;., the &lt;code&gt;out_flush&lt;/code&gt; function flushes the pretty-printer output device., &lt;code&gt;out_newline&lt;/code&gt; is called to open a new line when the pretty-printer splits the line., the &lt;code&gt;out_spaces&lt;/code&gt; function outputs spaces when a break hint leads to spaces instead of a line split. It is called with the number of spaces to output., the &lt;code&gt;out_indent&lt;/code&gt; function performs new line indentation when the pretty-printer splits the line. It is called with the indentation value of the new line. By default: fields &lt;code&gt;out_string&lt;/code&gt; and &lt;code&gt;out_flush&lt;/code&gt; are output device specific; (e.g. &lt;a href=&quot;stdlib#VALoutput_string&quot;&gt;&lt;code&gt;output_string&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;stdlib#VALflush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; for a &lt;a href=&quot;stdlib#TYPEout_channel&quot;&gt;&lt;code&gt;out_channel&lt;/code&gt;&lt;/a&gt; device, or &lt;code&gt;Buffer.add_substring&lt;/code&gt; and &lt;a href=&quot;stdlib#VALignore&quot;&gt;&lt;code&gt;ignore&lt;/code&gt;&lt;/a&gt; for a &lt;code&gt;Buffer.t&lt;/code&gt; output device),, field &lt;code&gt;out_newline&lt;/code&gt; is equivalent to &lt;code&gt;out_string&amp;nbsp;&quot;\n&quot;&amp;nbsp;0&amp;nbsp;1&lt;/code&gt;;, fields &lt;code&gt;out_spaces&lt;/code&gt; and &lt;code&gt;out_indent&lt;/code&gt; are equivalent to &lt;code&gt;out_string&amp;nbsp;(String.make&amp;nbsp;n&amp;nbsp;'&amp;nbsp;')&amp;nbsp;0&amp;nbsp;n&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fe430d7f65b9a4115dd36213fde72e2766eb905" translate="yes" xml:space="preserve">
          <source>The short expressions are translated into calls to functions of the Bigarray module as described in the following table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ec3650bd7c2cf484db50a370f6c089d2295064a" translate="yes" xml:space="preserve">
          <source>The signature MYHASH then contains all the fields of the signature of the module Hashtbl (with strengthened type definitions), plus the new field replace. An implementation of this signature can be obtained easily by using the include construct again, but this time at the structure level:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70846c98b1e5f76d1a8eeae9357dba832f61e830" translate="yes" xml:space="preserve">
          <source>The simplification pass removes unused let bindings so long as their corresponding defining expressions have &amp;ldquo;no effects&amp;rdquo;. See the section &amp;ldquo;Treatment of effects&amp;rdquo; below for the precise definition of this term.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fef5e19c04ebce13dc54db7219bcb47397db9b0" translate="yes" xml:space="preserve">
          <source>The singleton sequence containing only the given element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4bcd7d574236ad63f44f94fc9e518268676361d" translate="yes" xml:space="preserve">
          <source>The size (in words) of the minor heap. Changing this parameter will trigger a minor collection. Default: 256k.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7507f679adbb7afe1b145bc75e44b72811c4382" translate="yes" xml:space="preserve">
          <source>The size in bits of a native integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85cc984ceaff2d2d3db71a0f154333bd58e0401c" translate="yes" xml:space="preserve">
          <source>The size in bits of a native integer. This is equal to &lt;code&gt;32&lt;/code&gt; on a 32-bit platform and to &lt;code&gt;64&lt;/code&gt; on a 64-bit platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64bd44d9e49c2e76cdcec87737e9935d12ee6bdc" translate="yes" xml:space="preserve">
          <source>The size of the block, in words, excluding the header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6050e441d76daaaf25b47ad3fafeab9c8db6155" translate="yes" xml:space="preserve">
          <source>The size of the window used by the major GC for smoothing out variations in its workload. This is an integer between 1 and 50. Default: 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e707fef1fa0d611c38a23a134e978234bf5dd431" translate="yes" xml:space="preserve">
          <source>The smallest positive, non-zero, non-denormalized value of type &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3b9782a5db6a027afd3f2671f6d34f2dca120c7" translate="yes" xml:space="preserve">
          <source>The smallest representable 32-bit integer, -2&lt;sup&gt;31&lt;/sup&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bcd225542d9f92f6251d4bb2d635ef483db75e2" translate="yes" xml:space="preserve">
          <source>The smallest representable 64-bit integer, -2&lt;sup&gt;63&lt;/sup&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e75cf5a86c7fa5d080ac26a1f47b98cef3adf163" translate="yes" xml:space="preserve">
          <source>The smallest representable integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7ad80500b883d3470a8546d7763368d6a139abd" translate="yes" xml:space="preserve">
          <source>The smallest representable native integer, either -2&lt;sup&gt;31&lt;/sup&gt; on a 32-bit platform, or -2&lt;sup&gt;63&lt;/sup&gt; on a 64-bit platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16618ca96c698ad7bfc1856d7b38af8d4e0524d6" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unix#VALgetsockopt&quot;&gt;&lt;code&gt;Unix.getsockopt&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unix#VALsetsockopt&quot;&gt;&lt;code&gt;Unix.setsockopt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67e810815e754c36f51190792dabe6b7f6d39fc1" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unix#VALgetsockopt&quot;&gt;&lt;code&gt;Unix.getsockopt&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unix#VALsetsockopt&quot;&gt;&lt;code&gt;Unix.setsockopt&lt;/code&gt;&lt;/a&gt;. These options have a boolean (&lt;code&gt;true&lt;/code&gt;/&lt;code&gt;false&lt;/code&gt;) value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6598491cb35302bb16af6b6c7a9e151f8e63d9b8" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unix#VALgetsockopt_float&quot;&gt;&lt;code&gt;Unix.getsockopt_float&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unix#VALsetsockopt_float&quot;&gt;&lt;code&gt;Unix.setsockopt_float&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2019ae655a591c32fb8f40c0b2ba647816b414ae" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unix#VALgetsockopt_float&quot;&gt;&lt;code&gt;Unix.getsockopt_float&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unix#VALsetsockopt_float&quot;&gt;&lt;code&gt;Unix.setsockopt_float&lt;/code&gt;&lt;/a&gt;. These options have a floating-point value representing a time in seconds. The value 0 means infinite timeout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e1595d080e9d78ca9f7ddffc0fd77da50d67b0c" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unix#VALgetsockopt_int&quot;&gt;&lt;code&gt;Unix.getsockopt_int&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unix#VALsetsockopt_int&quot;&gt;&lt;code&gt;Unix.setsockopt_int&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6570006f88037fbe57d746e9ffa8ebe2113c3daa" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unix#VALgetsockopt_int&quot;&gt;&lt;code&gt;Unix.getsockopt_int&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unix#VALsetsockopt_int&quot;&gt;&lt;code&gt;Unix.setsockopt_int&lt;/code&gt;&lt;/a&gt;. These options have an integer value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67cb053530374f0ae91755129be399861c2e62b8" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unix#VALgetsockopt_optint&quot;&gt;&lt;code&gt;Unix.getsockopt_optint&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unix#VALsetsockopt_optint&quot;&gt;&lt;code&gt;Unix.setsockopt_optint&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b02d9606ae3049641c3c0b7a49b93173582ba252" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unix#VALgetsockopt_optint&quot;&gt;&lt;code&gt;Unix.getsockopt_optint&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unix#VALsetsockopt_optint&quot;&gt;&lt;code&gt;Unix.setsockopt_optint&lt;/code&gt;&lt;/a&gt;. These options have a value of type &lt;code&gt;int&amp;nbsp;option&lt;/code&gt;, with &lt;code&gt;None&lt;/code&gt; meaning ``disabled''.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="773642dab704b446e24c880397ae53bf6b4f36e8" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unixlabels#VALgetsockopt&quot;&gt;&lt;code&gt;UnixLabels.getsockopt&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unixlabels#VALsetsockopt&quot;&gt;&lt;code&gt;UnixLabels.setsockopt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="127c95d87113564ad21001801dba75443274ac20" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unixlabels#VALgetsockopt&quot;&gt;&lt;code&gt;UnixLabels.getsockopt&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unixlabels#VALsetsockopt&quot;&gt;&lt;code&gt;UnixLabels.setsockopt&lt;/code&gt;&lt;/a&gt;. These options have a boolean (&lt;code&gt;true&lt;/code&gt;/&lt;code&gt;false&lt;/code&gt;) value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d121887ffb4d5fad74076fcd7a6ddb33c6b3f62" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unixlabels#VALgetsockopt_float&quot;&gt;&lt;code&gt;UnixLabels.getsockopt_float&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unixlabels#VALsetsockopt_float&quot;&gt;&lt;code&gt;UnixLabels.setsockopt_float&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03fad790fcf2b775879fa18d8ded24985ac1495f" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unixlabels#VALgetsockopt_float&quot;&gt;&lt;code&gt;UnixLabels.getsockopt_float&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unixlabels#VALsetsockopt_float&quot;&gt;&lt;code&gt;UnixLabels.setsockopt_float&lt;/code&gt;&lt;/a&gt;. These options have a floating-point value representing a time in seconds. The value 0 means infinite timeout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cd8b0a441c72f8156f95e88c710953c3fa2ced0" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unixlabels#VALgetsockopt_int&quot;&gt;&lt;code&gt;UnixLabels.getsockopt_int&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unixlabels#VALsetsockopt_int&quot;&gt;&lt;code&gt;UnixLabels.setsockopt_int&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af5931adebaf9a357ecb0df8a73e7c072f718e8d" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unixlabels#VALgetsockopt_int&quot;&gt;&lt;code&gt;UnixLabels.getsockopt_int&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unixlabels#VALsetsockopt_int&quot;&gt;&lt;code&gt;UnixLabels.setsockopt_int&lt;/code&gt;&lt;/a&gt;. These options have an integer value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55d3d9fad514eda7c3e614c6496c099599e1e6e6" translate="yes" xml:space="preserve">
          <source>The solution of this conundrum is to use an explicitly polymorphic type annotation for the type 'a:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca3eb9c8c5023c43f9da6f2e55f310ac29817523" translate="yes" xml:space="preserve">
          <source>The sort function above does not modify its input list: it builds and returns a new list containing the same elements as the input list, in ascending order. There is actually no way in OCaml to modify a list in-place once it is built: we say that lists are &lt;em&gt;immutable&lt;/em&gt; data structures. Most OCaml data structures are immutable, but a few (most notably arrays) are &lt;em&gt;mutable&lt;/em&gt;, meaning that they can be modified in-place at any time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aef2817764bb52ac263b2fae2a148fec94730b6" translate="yes" xml:space="preserve">
          <source>The space character in format strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0c0e1ff4d5efd916e94aa7b9b072f20bb6cc011" translate="yes" xml:space="preserve">
          <source>The special comment (**/**) tells OCamldoc to discard elements placed after this comment, up to the end of the current class, class type, module or module type, or up to the next stop comment. For instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cebcc58b51afa7136699d267676f15d0e280a3f4" translate="yes" xml:space="preserve">
          <source>The special comment is not already associated to the previous element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5435aaea40f8385771bfff6ba0d166cd3c0eeccb" translate="yes" xml:space="preserve">
          <source>The special comment is not the first one of a toplevel module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06de91b2368326e2f06fbc6d38cdade544c2bc74" translate="yes" xml:space="preserve">
          <source>The specification exception&lt;a href=&quot;typedecl#constr-decl&quot;&gt;constr-decl&lt;/a&gt; in a signature requires the matching structure to provide an exception with the name and arguments specified in the definition, and makes the exception available to all users of the structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc96b351853386bb44b989f2d36255658c8e97cf" translate="yes" xml:space="preserve">
          <source>The specification of a method is written method [private] &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;:&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt;, where &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; is the name of the method and &lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt; its expected type, possibly polymorphic. The flag private indicates that the method cannot be accessed from outside the object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="816c127c5b84f64b52fb9fd685c1cb4ac8a4ea85" translate="yes" xml:space="preserve">
          <source>The standard error output for the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db78c9295b1256ee8e8a6b6086c5f3651f2fa1cd" translate="yes" xml:space="preserve">
          <source>The standard formatter to write to standard output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba48c9ea4ac16d1bd2010fb99db24330d34c33b1" translate="yes" xml:space="preserve">
          <source>The standard input for the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="375db9af8a0d4dc3c0ba86650eeff121048506df" translate="yes" xml:space="preserve">
          <source>The standard input notion for the &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="464e4c58fe500861730075b12f1fb6435b04534f" translate="yes" xml:space="preserve">
          <source>The standard input notion for the &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt; module. &lt;code&gt;Scanning.stdin&lt;/code&gt; is the &lt;a href=&quot;scanf.scanning#TYPEin_channel&quot;&gt;&lt;code&gt;Scanf.Scanning.in_channel&lt;/code&gt;&lt;/a&gt; formatted input channel attached to &lt;a href=&quot;stdlib#VALstdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aecb465e5714800c091e84c331cee9577b92a018" translate="yes" xml:space="preserve">
          <source>The standard library directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="defad1b44801f55e161dc009fb41cef1fe3ba956" translate="yes" xml:space="preserve">
          <source>The standard output for the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1326096be35fcaff4666a9f746f76c98f98925e" translate="yes" xml:space="preserve">
          <source>The str library provides high-level string processing functions, some based on regular expressions. It is intended to support the kind of file processing that is usually performed with scripting languages such as awk, perl or sed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d5110986ab904812febd54df3e70e3cfe974039" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;cmd&lt;/code&gt; is the command to call. The list &lt;code&gt;args&lt;/code&gt; is the list of arguments to pass to this command. It can be empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ea036aba8bc423b44bed368aa0538f1848ee618" translate="yes" xml:space="preserve">
          <source>The string buffer in which &lt;code&gt;str_formatter&lt;/code&gt; writes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a78fd29209652bbda7cca4022b56527d5c814fe" translate="yes" xml:space="preserve">
          <source>The struct custom_operations is defined in &amp;lt;caml/custom.h&amp;gt; and contains the following fields:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a298a05448f3ad20cfa9581c95c5d1288fc8e676" translate="yes" xml:space="preserve">
          <source>The syntactic class of constants comprises literals from the four base types (integers, floating-point numbers, characters, character strings), the integer variants, and constant constructors from both normal and polymorphic variants, as well as the special constants false, true, (), [], and [||], which behave like constant constructors, and beginend, which is equivalent to ().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a830f98dedde0a3c31b9928e1164ca27920971ea" translate="yes" xml:space="preserve">
          <source>The syntax for rules is as usual:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11b8e75b70b6bcdf9c144d7d28884193fb2da070" translate="yes" xml:space="preserve">
          <source>The syntax is exactly the same as for class expressions, but the result is a single object rather than a class. All the constructs described in the rest of this section also apply to immediate objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f75ce09e5843f380505e811b0272a865314bf4e9" translate="yes" xml:space="preserve">
          <source>The syntax of the language is given in BNF-like notation. Terminal symbols are set in typewriter font (likethis). Non-terminal symbols are set in italic font (likethat). Square brackets [&amp;hellip;] denote optional components. Curly brackets {&amp;hellip;} denotes zero, one or several repetitions of the enclosed components. Curly brackets with a trailing plus sign {&amp;hellip;}&lt;sup&gt;+&lt;/sup&gt; denote one or several repetitions of the enclosed components. Parentheses (&amp;hellip;) denote grouping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa08323f8802e6d50ccec78b682ef7b93d7f7d1e" translate="yes" xml:space="preserve">
          <source>The table below lists the symbols defined in the initial environment and their initial meaning. (See the description of the core library module Stdlib in chapter &lt;a href=&quot;core#c%3Acorelib&quot;&gt;25&lt;/a&gt; for more details). Their meaning may be changed at any time using let(&lt;a href=&quot;names#infix-op&quot;&gt;infix-op&lt;/a&gt;)name&lt;sub&gt;1&lt;/sub&gt;name&lt;sub&gt;2&lt;/sub&gt;= &amp;hellip;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4265c38e98429479cc2782e5d12f7b2b292f3497" translate="yes" xml:space="preserve">
          <source>The table below shows the relative precedences and associativity of operators and non-closed constructions. The constructions with higher precedence come first. For infix and prefix symbols, we write &amp;ldquo;*&amp;hellip;&amp;rdquo; to mean &amp;ldquo;any symbol starting with *&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ca02ca74768b06f8e3e1c2b6d1dd2805e4d9dc1" translate="yes" xml:space="preserve">
          <source>The table below shows the relative precedences and associativity of operators and non-closed pattern constructions. The constructions with higher precedences come first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aaedd4906bf37d963daebc10f3ce2cae137d335" translate="yes" xml:space="preserve">
          <source>The table below shows the relative precedences and associativity of operators and non-closed type constructions. The constructions with higher precedences come first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="873780c573d904e6823105d70079b69ff6aa2a60" translate="yes" xml:space="preserve">
          <source>The tag-marking operation is the simpler tag specific operation: it simply writes a tag specific string into the output device of the formatter. Tag-marking does not interfere with line-splitting computation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e9b336647566103c9dc222eca78097e8e36a10d" translate="yes" xml:space="preserve">
          <source>The tag-printing operation is the more involved tag specific operation: it can print arbitrary material to the formatter. Tag-printing is tightly linked to the current pretty-printer operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc0467c82797c179e1082f88331fe596f582254d" translate="yes" xml:space="preserve">
          <source>The term type we have defined above is an &lt;em&gt;indexed&lt;/em&gt; type, where a type parameter reflects a property of the value contents. Another use of GADTs is &lt;em&gt;singleton&lt;/em&gt; types, where a GADT value represents exactly one type. This value can be used as runtime representation for this type, and a function receiving it can have a polytypic behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bff74d740aa663829cf4f77edbb8806d1bc466d0" translate="yes" xml:space="preserve">
          <source>The termination status of a process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0c71035b432f40f8ce6567e0659d0f94303a4bb" translate="yes" xml:space="preserve">
          <source>The termination status of a process. See module &lt;a href=&quot;sys&quot;&gt;&lt;code&gt;Sys&lt;/code&gt;&lt;/a&gt; for the definitions of the standard signal numbers. Note that they are not the numbers used by the OS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b998179643d8f25a6de4e2f828c6ab63197c25fd" translate="yes" xml:space="preserve">
          <source>The third case is a closed variant type. It gives information about all the possible tags and their associated types, and which tags are known to potentially appear in values. The exact variant type (first case) is just an abbreviation for a closed variant type where all possible tags are also potentially present.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72c73fe652e0c0e0cf068757abf72958b2266b30" translate="yes" xml:space="preserve">
          <source>The threads library allows concurrent programming in OCaml. It provides multiple threads of control (also called lightweight processes) that execute concurrently in the same memory space. Threads communicate by in-place modification of shared data structures, or by sending and receiving data on communication channels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee8a007db9b67f061741b11b1f8ef10fd7dfa6a8" translate="yes" xml:space="preserve">
          <source>The threads library is implemented by time-sharing on a single processor. It will not take advantage of multi-processor machines. Using this library will therefore never make programs run faster. However, many programs are easier to write when structured as several communicating processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5a20efffaf644d1427994b098f56c7f31e6be5e" translate="yes" xml:space="preserve">
          <source>The three kinds of interval timers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b1f416d7e4aa2468aa653df39f4953c40bbd756" translate="yes" xml:space="preserve">
          <source>The three type parameters to &lt;code&gt;Genarray.t&lt;/code&gt; identify the array element kind and layout, as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27a8084722c0c59b716ab80edd05f2b005dea978" translate="yes" xml:space="preserve">
          <source>The toplevel system does not perform line editing, but it can easily be used in conjunction with an external line editor such as ledit, or rlwrap. An improved toplevel, utop, is also available. Another option is to use ocaml under Gnu Emacs, which gives the full editing power of Emacs (command run-caml from library inf-caml).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0efc25c223657f44333e6ed3dee74d2f834fa753" translate="yes" xml:space="preserve">
          <source>The total amount of memory allocated by the program since it was started is (in words) &lt;code&gt;minor_words&amp;nbsp;+&amp;nbsp;major_words&amp;nbsp;-&amp;nbsp;promoted_words&lt;/code&gt;. Multiply by the word size (4 on a 32-bit machine, 8 on a 64-bit machine) to get the number of bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4eb40ef4dc24c3e0ad0bdb73cac37d303dc7aee" translate="yes" xml:space="preserve">
          <source>The transformation is implemented by adding a new wrapper function in the manner of that used when unboxing specialised arguments. The closure variables are still free in the wrapper, but the intention is that when the wrapper is inlined at direct call sites, the relevant values are passed directly to the main function via the new specialised arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e984d305346aebd0ab69a424dfacb7e6aa1b981" translate="yes" xml:space="preserve">
          <source>The transformation is implemented by creating a wrapper function that accepts the original arguments. Meanwhile, the original function is renamed and extra arguments are added corresponding to the unboxed specialised arguments; this new function is called from the wrapper. The wrapper will then be inlined at direct call sites. Indeed, all call sites will be direct unless -unbox-closures is being used, since they will have been generated by the compiler when originally specialising the function. (In the case of -unbox-closures other functions may appear with specialised arguments; in this case there may be indirect calls and these will incur a small penalty owing to having to bounce through the wrapper. The technique of &lt;em&gt;direct call surrogates&lt;/em&gt; used for -unbox-closures is not used by the transformation to unbox specialised arguments.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8198b57a18523f699b5f95a3eca2418108615522" translate="yes" xml:space="preserve">
          <source>The transformation replaces closure variables by specialised arguments. The aim is to cause more closures to become closed. It is particularly applicable, as a means of reducing allocation, where the function concerned cannot be inlined or specialised. For example, some non-recursive function might be too large to inline; or some recursive function might offer no opportunities for specialisation perhaps because its only argument is one of type unit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ec534b61d911e890ad6935004cee0e7049d17f2" translate="yes" xml:space="preserve">
          <source>The transformation to unbox specialised arguments never introduces extra allocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e701b3559c3cd620429a438a8bb4dcb9c99e51c" translate="yes" xml:space="preserve">
          <source>The transformation will not unbox arguments if it would result in the original function having sufficiently many arguments so as to inhibit tail-call optimisation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3231a8b466d35dcee0deec7b0a92803db2aeb3cd" translate="yes" xml:space="preserve">
          <source>The transformations in this section relate to the splitting apart of &lt;em&gt;boxed&lt;/em&gt; (that is to say, non-immediate) values. They are largely intended to reduce allocation, which tends to result in a runtime performance profile with lower variance and smaller tails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eb73189e94327227c50de51480db7a0a57ff2cd" translate="yes" xml:space="preserve">
          <source>The two arguments used and max give the GC an idea of how much out-of-heap resources are consumed by the finalized block being allocated: you give the amount of resources allocated to this object as parameter used, and the maximum amount that you want to see in floating garbage as parameter max. The units are arbitrary: the GC cares only about the ratio used / max.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de645ad92a5669480afb7be4dd3aef35389b655e" translate="yes" xml:space="preserve">
          <source>The two components of a type definition, the optional equation and the optional representation, can be combined independently, giving rise to four typical situations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed0d501a57672abb475f57d2ac37627ee51ce36b" translate="yes" xml:space="preserve">
          <source>The two parameters used and max are used to control the speed of garbage collection when the finalized object contains pointers to out-of-heap resources. Generally speaking, the OCaml incremental major collector adjusts its speed relative to the allocation rate of the program. The faster the program allocates, the harder the GC works in order to reclaim quickly unreachable blocks and avoid having large amount of &amp;ldquo;floating garbage&amp;rdquo; (unreferenced objects that the GC has not yet collected).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b4b8bfbffcea6080868e73fa6fa91ada3a5aee9" translate="yes" xml:space="preserve">
          <source>The type #&lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt; is a special kind of abbreviation. This abbreviation unifies with the type of any object belonging to a subclass of the class type &lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt;. It is handled in a special way as it usually hides a type variable (an ellipsis, representing the methods that may be added in a subclass). In particular, it vanishes when the ellipsis gets instantiated. Each type expression #&lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt; defines a new type variable, so type #&lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt;-&amp;gt;#&lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt; is usually not the same as type (#&lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt;as'&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;) -&amp;gt;'&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2098df733b38a624b57b6a1ed22bd572f1e7f4fb" translate="yes" xml:space="preserve">
          <source>The type &amp;lt; m : int &amp;gt; we see here is just the expansion of c, due to the use of a reference; we have succeeded in getting back an object of type c.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cb5a55287de7cc9d410124fb3cd96a5d5e22f24" translate="yes" xml:space="preserve">
          <source>The type &amp;lt; {&lt;a href=&quot;#method-type&quot;&gt;method-type&lt;/a&gt;;} ..&amp;gt; is the type of an object whose method names and types are described by &lt;a href=&quot;#method-type&quot;&gt;method-type&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;#method-type&quot;&gt;method-type&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;, and possibly some other methods represented by the ellipsis. This ellipsis actually is a special kind of type variable (called &lt;em&gt;row variable&lt;/em&gt; in the literature) that stands for any number of extra method types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea78845a66a3de51237a6160ba5250e692cfe066" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;'a&amp;nbsp;t&lt;/code&gt; is a &lt;b&gt;delayed list&lt;/b&gt;, i.e. a list where some evaluation is needed to access the next element. This makes it possible to build infinite sequences, to build sequences as we traverse them, and to transform them in a lazy fashion rather than upfront.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e093dd6adec72b6cbeb6815ff6a81bdec059a25" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Genarray.t&lt;/code&gt; is the type of Bigarrays with variable numbers of dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c17aafa409f735e2a7fb7b2d3ed8979e96c9a297" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Genarray.t&lt;/code&gt; is the type of Bigarrays with variable numbers of dimensions. Any number of dimensions between 0 and 16 is supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="444bb838dc88582dbd178720dcfda52e51470b21" translate="yes" xml:space="preserve">
          <source>The type N.t is incompatible with int, ensuring that nonnegative integers and regular integers are not confused. However, if x has type N.t, the coercion (x :&amp;gt; int) is legal and returns the underlying integer, just like N.to_int x. Deep coercions are also supported: if l has type N.t list, the coercion (l :&amp;gt; int list) returns the list of underlying integers, like List.map N.to_int l but without copying the list l.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa132651b99c1854c25fdf68be9f2ebc9e6e4a11" translate="yes" xml:space="preserve">
          <source>The type describing the status of an interval timer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25486382c0973b8dd5baf2bfa2b12dda90d4ed79" translate="yes" xml:space="preserve">
          <source>The type error here comes from the fact that during the definition of depth, the type checker first assigns to depth the type 'a -&amp;gt; 'b . When typing the pattern matching, 'a -&amp;gt; 'b becomes 'a nested -&amp;gt; 'b, then 'a nested -&amp;gt; int once the List branch is typed. However, when typing the application depth n in the Nested branch, the type checker encounters a problem: depth n is applied to 'a list nested, it must therefore have the type 'a list nested -&amp;gt; 'b. Unifying this constraint with the previous one leads to the impossible constraint 'a list nested = 'a nested. In other words, within its definition, the recursive function depth is applied to values of type 'a t with different types 'a due to the non-regularity of the type constructor nested. This creates a problem because the type checker had introduced a new type variable 'a only at the &lt;em&gt;definition&lt;/em&gt; of the function depth whereas, here, we need a different type variable for every &lt;em&gt;application&lt;/em&gt; of the function depth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fa9c8aa5ef431c67c6adbd4b206fd03f62c7ba9" translate="yes" xml:space="preserve">
          <source>The type expression '&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; stands for the type variable named &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;. The type expression _ stands for either an anonymous type variable or anonymous type parameters. In data type definitions, type variables are names for the data type parameters. In type constraints, they represent unspecified types that can be instantiated by any type to satisfy the type constraint. In general the scope of a named type variable is the whole top-level phrase where it appears, and it can only be generalized when leaving this scope. Anonymous variables have no such restriction. In the following cases, the scope of named type variables is restricted to the type expression where they appear: 1) for universal (explicitly polymorphic) type variables; 2) for type variables that only appear in public method specifications (as those variables will be made universal, as described in section &lt;a href=&quot;classes#sss%3Aclty-meth&quot;&gt;7.9.1&lt;/a&gt;); 3) for variables used as aliases, when the type they are aliased to would be invalid in the scope of the enclosing definition (i.e. when it contains free universal type variables, or locally defined types.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b361863db6506eaaf72bc73833dd7a710012beed" translate="yes" xml:space="preserve">
          <source>The type expression (&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;) denotes the same type as &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caf716551ec1bcc30d2653d9a50db98a601e3996" translate="yes" xml:space="preserve">
          <source>The type expression (&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;,&amp;hellip;, &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;) &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt;, where &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; is a type constructor with n parameters, denotes the application of the n-ary type constructor &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; to the types &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; through &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b1267fea7ae64838d1130ee8c9de538451b3845" translate="yes" xml:space="preserve">
          <source>The type expression &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt;, where &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; is a type constructor with one parameter, denotes the application of the unary type constructor &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; to the type &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="134280a727f04e70e93aab40360430e6a4a2edfe" translate="yes" xml:space="preserve">
          <source>The type expression &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;* &amp;hellip; *&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; denotes the type of tuples whose elements belong to types &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd49bc22f7c62d9c4ae3e943e6b56abafe95d35b" translate="yes" xml:space="preserve">
          <source>The type expression &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;-&amp;gt;&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; denotes the type of functions mapping arguments of type &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to results of type &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48f68ff9fb1de19b9947374a080e92592e2bffa5" translate="yes" xml:space="preserve">
          <source>The type expression &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;as'&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; denotes the same type as &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;, and also binds the type variable &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; to type &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt; both in &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt; and in other types. In general the scope of an alias is the same as for a named type variable, and covers the whole enclosing definition. If the type variable &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; actually occurs in &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;, a recursive type is created. Recursive types for which there exists a recursive path that does not contain an object or polymorphic variant type constructor are rejected, except when the -rectypes mode is selected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6801841411231abefa49731a3af05dc93c2d6bf" translate="yes" xml:space="preserve">
          <source>The type for Unicode characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7710723d784526bfd14ff8684cd4f3768c3a88c0" translate="yes" xml:space="preserve">
          <source>The type for integer values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9382d7daf14dbc0dd9ad2ac68253c35ad1396cc7" translate="yes" xml:space="preserve">
          <source>The type for option values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5d8396849b8d6781e4d124b104e7abf0c738fb9" translate="yes" xml:space="preserve">
          <source>The type for option values. Either &lt;code&gt;None&lt;/code&gt; or a value &lt;code&gt;Some&amp;nbsp;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d6a4f1c52488e6ba5ba76a0aea28a22e82a6300" translate="yes" xml:space="preserve">
          <source>The type for result values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93ce0c547a2cc6ec0a54327ae4897e498aad029d" translate="yes" xml:space="preserve">
          <source>The type for result values. Either a value &lt;code&gt;Ok&amp;nbsp;v&lt;/code&gt; or an error &lt;code&gt;Error&amp;nbsp;e&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c0b6a8e9537b83d5facebd9c46c52d219d5b39a" translate="yes" xml:space="preserve">
          <source>The type inferred for sort, 'a list -&amp;gt; 'a list, means that sort can actually apply to lists of any type, and returns a list of the same type. The type 'a is a &lt;em&gt;type variable&lt;/em&gt;, and stands for any given type. The reason why sort can apply to lists of any type is that the comparisons (=, &amp;lt;=, etc.) are &lt;em&gt;polymorphic&lt;/em&gt; in OCaml: they operate between any two values of the same type. This makes sort itself polymorphic over all list types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c08084fecb7e84be89d27f0d722611fa9cc32c8" translate="yes" xml:space="preserve">
          <source>The type name must be implemented by a type compatible with &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;. All users of the structure know that the type name is compatible with &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ebe16a502ab193556c30fa1d8f9ab51fb2a92a2" translate="yes" xml:space="preserve">
          <source>The type name must be implemented by a variant type or record type with exactly the constructors or fields specified. All users of the structure have access to the constructors or fields, and can use them to create or inspect values of that type. However, users of the structure consider that type as incompatible with any other type: a fresh type has been generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95162088ecc49c178a74b8a108f2f06d181cf540" translate="yes" xml:space="preserve">
          <source>The type of (read-only) character strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cb54904d6ce772d0ceeac1ee805267485217e2e" translate="yes" xml:space="preserve">
          <source>The type of (writable) byte sequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="175f1511e76274de17f3f982e04261ad9ff87edf" translate="yes" xml:space="preserve">
          <source>The type of Oo.copy is the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed9cbb3bbfa2f749813e7746851407d1f9f2830e" translate="yes" xml:space="preserve">
          <source>The type of PRNG states.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31f3bef48e012323310e56008b546bd70a23ee79" translate="yes" xml:space="preserve">
          <source>The type of a generator module depends on the kind of generated documentation. Here is the list of generator module types, with the name of the generator class in the module :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="474468ccde94e04dc6d84d6aa522d6290591ae8e" translate="yes" xml:space="preserve">
          <source>The type of arrays of weak pointers (weak arrays).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49335a2fa0da36592772610d625d9e7862131665" translate="yes" xml:space="preserve">
          <source>The type of arrays of weak pointers (weak arrays). A weak pointer is a value that the garbage collector may erase whenever the value is not used any more (through normal pointers) by the program. Note that finalisation functions are run before the weak pointers are erased, because the finalisation functions can make values alive again (before 4.03 the finalisation functions were run after).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2b210af5769dfe8a33b57a953fcf512009f49e6" translate="yes" xml:space="preserve">
          <source>The type of arrays whose elements have type 'a.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0595a4cfa984f250f4abe368aae01bbd26bbe40a" translate="yes" xml:space="preserve">
          <source>The type of booleans (truth values).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57f43364adb027e8e1ba3b2312688a97e5a4bfee" translate="yes" xml:space="preserve">
          <source>The type of characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8faa31d4f6bd583eef19e62cfd7cf4d795b85cb0" translate="yes" xml:space="preserve">
          <source>The type of commands for &lt;code&gt;shutdown&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b3f99b8924ec20003595b05b507f3dd92f84242" translate="yes" xml:space="preserve">
          <source>The type of communication channels carrying values of type &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4bee64553824e660fa6229cc5c7107b80d346c9" translate="yes" xml:space="preserve">
          <source>The type of communication events returning a result of type &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4694bbb21fec365f7f23def5ef3c32491f195566" translate="yes" xml:space="preserve">
          <source>The type of compiled regular expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf94d66ebaa6a6bac9b3992799eba28dae304024" translate="yes" xml:space="preserve">
          <source>The type of complex numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9493cdeccb2ee09d3bbc2192a85ea88bdc22d219" translate="yes" xml:space="preserve">
          <source>The type of complex numbers. &lt;code&gt;re&lt;/code&gt; is the real part and &lt;code&gt;im&lt;/code&gt; the imaginary part.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a919227d85c7433279106182e9342eaf933551d4" translate="yes" xml:space="preserve">
          <source>The type of condition variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2948f756f59cbab66ed838f1fd09d9a51206608c" translate="yes" xml:space="preserve">
          <source>The type of delayed lists containing elements of type &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19b1cace17bd70c1c864fc3ccf8d84d6aeafa3b9" translate="yes" xml:space="preserve">
          <source>The type of delayed lists containing elements of type &lt;code&gt;'a&lt;/code&gt;. Note that the concrete list node &lt;code&gt;'a&amp;nbsp;node&lt;/code&gt; is delayed under a closure, not a &lt;code&gt;lazy&lt;/code&gt; block, which means it might be recomputed every time we access it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="528bf9052fce3ac6805ffa892e89bbfb27784ec6" translate="yes" xml:space="preserve">
          <source>The type of descriptors over opened directories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="416a1434458aaedb356cff26edc4284a6edf9ec7" translate="yes" xml:space="preserve">
          <source>The type of digests: 16-character strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed7f6fa3fdb11f6e5f157b97ab1334e5206abde6" translate="yes" xml:space="preserve">
          <source>The type of error codes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="374429438a468e5405acbf7c3ebd3a8090be7716" translate="yes" xml:space="preserve">
          <source>The type of error codes. Errors defined in the POSIX standard and additional errors from UNIX98 and BSD. All other errors are mapped to EUNKNOWNERR.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90aa20107e0953510225d3286a9c720778df2ae3" translate="yes" xml:space="preserve">
          <source>The type of exception values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d9a06fd1a883a7ff59af6a47cff3a54b165e238" translate="yes" xml:space="preserve">
          <source>The type of file access rights, e.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7a1b61ab121d17826ae99852665f41b9088bb6f" translate="yes" xml:space="preserve">
          <source>The type of file access rights, e.g. &lt;code&gt;0o640&lt;/code&gt; is read and write for user, read for group, none for others</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd46f8d4353ac7fec53695a7079f8ba6a127a094" translate="yes" xml:space="preserve">
          <source>The type of float arrays with packed representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ae512fb6e68d577ece237ab0b35021285c8a32b" translate="yes" xml:space="preserve">
          <source>The type of floating-point numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="882f6167872619af22e623d191dbe06d50c3e5c8" translate="yes" xml:space="preserve">
          <source>The type of format strings. 'a is the type of the parameters of the format, 'f is the result type for the printf-style functions, 'b is the type of the first argument given to %a and %t printing functions (see module &lt;a href=&quot;libref/printf&quot;&gt;Printf&lt;/a&gt;), 'c is the result type of these functions, and also the type of the argument transmitted to the first argument of kprintf-style functions, 'd is the result type for the scanf-style functions (see module &lt;a href=&quot;libref/scanf&quot;&gt;Scanf&lt;/a&gt;), and 'e is the type of the receiver function for the scanf-style functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19c398a9ad6d40134bc9da4aab8cb49e3ed44b56" translate="yes" xml:space="preserve">
          <source>The type of formatted input scanners: &lt;code&gt;('a,&amp;nbsp;'b,&amp;nbsp;'c,&amp;nbsp;'d)&amp;nbsp;scanner&lt;/code&gt; is the type of a formatted input function that reads from some formatted input channel according to some format string; more precisely, if &lt;code&gt;scan&lt;/code&gt; is some formatted input function, then &lt;code&gt;scan&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ic&amp;nbsp;fmt&amp;nbsp;f&lt;/code&gt; applies &lt;code&gt;f&lt;/code&gt; to all the arguments specified by format string &lt;code&gt;fmt&lt;/code&gt;, when &lt;code&gt;scan&lt;/code&gt; has read those arguments from the &lt;a href=&quot;scanf.scanning#TYPEin_channel&quot;&gt;&lt;code&gt;Scanf.Scanning.in_channel&lt;/code&gt;&lt;/a&gt; formatted input channel &lt;code&gt;ic&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aea5a1b18ac88613e37414b6827c2703455101bb" translate="yes" xml:space="preserve">
          <source>The type of hash tables from type &lt;code&gt;'a&lt;/code&gt; to type &lt;code&gt;'b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="696255785a919ef1978b95f3b810845f1d5f24f3" translate="yes" xml:space="preserve">
          <source>The type of input channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2733bfc9210840c12ac529e5664090014cfaed19" translate="yes" xml:space="preserve">
          <source>The type of integer numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12a16543916e281f6e705178f7068ae7b81eabd0" translate="yes" xml:space="preserve">
          <source>The type of lexer buffers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e6ff741c03d54a16b116276f6d1b7c29c419556" translate="yes" xml:space="preserve">
          <source>The type of lexer buffers. A lexer buffer is the argument passed to the scanning functions defined by the generated scanners. The lexer buffer holds the current state of the scanner, plus a function to refill the buffer from the input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b78930ebe1ff9598f2ce1e960c8d2f960ca9edd" translate="yes" xml:space="preserve">
          <source>The type of lists whose elements have type 'a.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f4c8fdad1b3bd84e4c3cca78b35e83c55b502de" translate="yes" xml:space="preserve">
          <source>The type of location information found in backtraces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="498bd9a851a6cfafcb8f5766233f38fdc36ca792" translate="yes" xml:space="preserve">
          <source>The type of location information found in backtraces. &lt;code&gt;start_char&lt;/code&gt; and &lt;code&gt;end_char&lt;/code&gt; are positions relative to the beginning of the line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed706b6a75175b21f33900096f47f5ce25dcd56f" translate="yes" xml:space="preserve">
          <source>The type of maps from type &lt;code&gt;key&lt;/code&gt; to type &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5234180ce852e2c9add54e2a43fe30af56ce71bf" translate="yes" xml:space="preserve">
          <source>The type of metadata associated with allocations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a7ce6248520399ff389ae062f84b764cade9171" translate="yes" xml:space="preserve">
          <source>The type of metadata associated with allocations. This is the type of records passed to the callback triggered by the sampling of an allocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1e287e9bbc376eb420f29d58e9d26ead8ee6aa7" translate="yes" xml:space="preserve">
          <source>The type of mutexes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74a3a571763275675b862ae9f296a04facfd9dc7" translate="yes" xml:space="preserve">
          <source>The type of one-dimensional Bigarrays whose elements have OCaml type &lt;code&gt;'a&lt;/code&gt;, representation kind &lt;code&gt;'b&lt;/code&gt;, and memory layout &lt;code&gt;'c&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="427b82aee3c183b2b5534df6717057b224234245" translate="yes" xml:space="preserve">
          <source>The type of optional values of type 'a.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a247986af85700af0514a9a8547e14b281ce0624" translate="yes" xml:space="preserve">
          <source>The type of output channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb4593e8016738b30531d3a2d698c5003680100a" translate="yes" xml:space="preserve">
          <source>The type of queues containing elements of type &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ed3d947a75f974c4a636eeee9cca0bdcea8439d" translate="yes" xml:space="preserve">
          <source>The type of references (mutable indirection cells) containing a value of type &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c47f9a8e4ac2d5a708feb705e0eb216916eb90e" translate="yes" xml:space="preserve">
          <source>The type of scanning buffers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="641cb810f5f62717bfd7cda0a11b14f8777c6464" translate="yes" xml:space="preserve">
          <source>The type of scanning buffers. A scanning buffer is the source from which a formatted input function gets characters. The scanning buffer holds the current state of the scan, plus a function to get the next char from the input, and a token buffer to store the string matched so far.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2da9a74d002d27ad159cff07bde988e8e266d179" translate="yes" xml:space="preserve">
          <source>The type of sets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00e670e3a2a21e4cdf70bf2240d4a5a94082c733" translate="yes" xml:space="preserve">
          <source>The type of signed 32-bit integers. Literals for 32-bit integers are suffixed by l. See the &lt;a href=&quot;libref/int32&quot;&gt;Int32&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="049aa2f5e1bceacd2dc3e7900753d299e293a211" translate="yes" xml:space="preserve">
          <source>The type of signed 64-bit integers. Literals for 64-bit integers are suffixed by L. See the &lt;a href=&quot;libref/int64&quot;&gt;Int64&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14572b24035765d23bfc1ab5989635cd85be76c9" translate="yes" xml:space="preserve">
          <source>The type of signed, platform-native integers (32 bits on 32-bit processors, 64 bits on 64-bit processors). Literals for native integers are suffixed by n. See the &lt;a href=&quot;libref/nativeint&quot;&gt;Nativeint&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de5b2958f6bf6b0150e2e607a78d659c4f79eb05" translate="yes" xml:space="preserve">
          <source>The type of socket addresses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db586c580808d7d4b0a9c2a68894ac1deac9713a" translate="yes" xml:space="preserve">
          <source>The type of socket addresses. &lt;code&gt;ADDR_UNIX&amp;nbsp;name&lt;/code&gt; is a socket address in the Unix domain; &lt;code&gt;name&lt;/code&gt; is a file name in the file system. &lt;code&gt;ADDR_INET(addr,port)&lt;/code&gt; is a socket address in the Internet domain; &lt;code&gt;addr&lt;/code&gt; is the Internet address of the machine, and &lt;code&gt;port&lt;/code&gt; is the port number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="608407eaec3033fe97cbe414b0ad430f843c8db2" translate="yes" xml:space="preserve">
          <source>The type of socket domains.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57d14d79c33e13c0f239ad5001df98545855ce4a" translate="yes" xml:space="preserve">
          <source>The type of socket domains. Not all platforms support IPv6 sockets (type &lt;code&gt;PF_INET6&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b519e0b22d95beab7899e8dfff601ea38a0a80e" translate="yes" xml:space="preserve">
          <source>The type of socket domains. Not all platforms support IPv6 sockets (type &lt;code&gt;PF_INET6&lt;/code&gt;). Windows does not support &lt;code&gt;PF_UNIX&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2727d81576dab1fb5a38c8713ea564ef66856040" translate="yes" xml:space="preserve">
          <source>The type of socket kinds, specifying the semantics of communications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b3007fcdc44e3284ad3118e0dffc7d71aaf743c" translate="yes" xml:space="preserve">
          <source>The type of socket kinds, specifying the semantics of communications. &lt;code&gt;SOCK_SEQPACKET&lt;/code&gt; is included for completeness, but is rarely supported by the OS, and needs system calls that are not available in this library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="156e03b4fa592223c0c98868c0491cee08f03432" translate="yes" xml:space="preserve">
          <source>The type of stacks containing elements of type &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f65d04f78e3ceb4ae3eccd621111d1fffe7fea7" translate="yes" xml:space="preserve">
          <source>The type of streams holding values of type &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6765ffbd6cdd35348726a7b361a85542a02c62ba" translate="yes" xml:space="preserve">
          <source>The type of tables that contain elements of type &lt;code&gt;data&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d36f05d8ed34a2aeecd6a307e47d3388f2f3349d" translate="yes" xml:space="preserve">
          <source>The type of tables that contain elements of type &lt;code&gt;data&lt;/code&gt;. Note that weak hash sets cannot be marshaled using &lt;a href=&quot;stdlib#VALoutput_value&quot;&gt;&lt;code&gt;output_value&lt;/code&gt;&lt;/a&gt; or the functions of the &lt;a href=&quot;marshal&quot;&gt;&lt;code&gt;Marshal&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="376291c83380bfe855667ba5075e67da3fc440d1" translate="yes" xml:space="preserve">
          <source>The type of the elements stored in the table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27a01f06c2807810d54d563bff488d148e91f692" translate="yes" xml:space="preserve">
          <source>The type of the hashtable keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="419849ba8c429fc85eb7b7159392b7645493c383" translate="yes" xml:space="preserve">
          <source>The type of the map keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07c0446d50346f3a3a5ced32244b2b1d6aa72fb4" translate="yes" xml:space="preserve">
          <source>The type of the set elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f9b34617afb59cca236cf1ed744d053aeba331d" translate="yes" xml:space="preserve">
          <source>The type of the unit value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="558f0da7756d6b8a5e6fa053bc9e88665bde8e00" translate="yes" xml:space="preserve">
          <source>The type of this expression, t, contains type variables that cannot be generalized</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f38374ae48a76fc267fc266e7d1fb3adac8f8923" translate="yes" xml:space="preserve">
          <source>The type of thread handles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="911e648755e2ce01883554d3b0a3d8fbef08dfa3" translate="yes" xml:space="preserve">
          <source>The type of three-dimensional Bigarrays whose elements have OCaml type &lt;code&gt;'a&lt;/code&gt;, representation kind &lt;code&gt;'b&lt;/code&gt;, and memory layout &lt;code&gt;'c&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a93d7af7669a780db37d7a6a35b93628bedc91cc" translate="yes" xml:space="preserve">
          <source>The type of tokens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2fe884e37cec8d7d8dffba0f78cacab0927a183" translate="yes" xml:space="preserve">
          <source>The type of tokens. The lexical classes are: &lt;code&gt;Int&lt;/code&gt; and &lt;code&gt;Float&lt;/code&gt; for integer and floating-point numbers; &lt;code&gt;String&lt;/code&gt; for string literals, enclosed in double quotes; &lt;code&gt;Char&lt;/code&gt; for character literals, enclosed in single quotes; &lt;code&gt;Ident&lt;/code&gt; for identifiers (either sequences of letters, digits, underscores and quotes, or sequences of 'operator characters' such as &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, etc); and &lt;code&gt;Kwd&lt;/code&gt; for keywords (either identifiers or single 'special characters' such as &lt;code&gt;(&lt;/code&gt;, &lt;code&gt;}&lt;/code&gt;, etc).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a131ee154ce5805d4743ddd4e7ac6f8f0a846600" translate="yes" xml:space="preserve">
          <source>The type of two-dimensional Bigarrays whose elements have OCaml type &lt;code&gt;'a&lt;/code&gt;, representation kind &lt;code&gt;'b&lt;/code&gt;, and memory layout &lt;code&gt;'c&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb1acfc22850de31c2fb5225a9fc570f7727191c" translate="yes" xml:space="preserve">
          <source>The type of zero-dimensional Bigarrays whose elements have OCaml type &lt;code&gt;'a&lt;/code&gt;, representation kind &lt;code&gt;'b&lt;/code&gt;, and memory layout &lt;code&gt;'c&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c3babab89ffd173e9518cc78562c29d921585ef" translate="yes" xml:space="preserve">
          <source>The type parameter in the declaration may actually be constrained in the body of the class definition. In the class type, the actual value of the type parameter is displayed in the constraint clause.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5037564652e82350a92a754ff0cf691d4922b52e" translate="yes" xml:space="preserve">
          <source>The type representation = [|] &lt;a href=&quot;#constr-decl&quot;&gt;constr-decl&lt;/a&gt; { |&lt;a href=&quot;#constr-decl&quot;&gt;constr-decl&lt;/a&gt; } describes a variant type. The constructor declarations &lt;a href=&quot;#constr-decl&quot;&gt;constr-decl&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;#constr-decl&quot;&gt;constr-decl&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; describe the constructors associated to this variant type. The constructor declaration &lt;a href=&quot;names#constr-name&quot;&gt;constr-name&lt;/a&gt;of&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;* &amp;hellip; *&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; declares the name &lt;a href=&quot;names#constr-name&quot;&gt;constr-name&lt;/a&gt; as a non-constant constructor, whose arguments have types &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;. The constructor declaration &lt;a href=&quot;names#constr-name&quot;&gt;constr-name&lt;/a&gt; declares the name &lt;a href=&quot;names#constr-name&quot;&gt;constr-name&lt;/a&gt; as a constant constructor. Constructor names must be capitalized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bb673b534c3fd2e98456972d5696bd025fa4d55" translate="yes" xml:space="preserve">
          <source>The type representation ={&lt;a href=&quot;#field-decl&quot;&gt;field-decl&lt;/a&gt; { ;&lt;a href=&quot;#field-decl&quot;&gt;field-decl&lt;/a&gt; } [;] } describes a record type. The field declarations &lt;a href=&quot;#field-decl&quot;&gt;field-decl&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;#field-decl&quot;&gt;field-decl&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; describe the fields associated to this record type. The field declaration &lt;a href=&quot;names#field-name&quot;&gt;field-name&lt;/a&gt;:&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt; declares &lt;a href=&quot;names#field-name&quot;&gt;field-name&lt;/a&gt; as a field whose argument has type &lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt;. The field declaration mutable&lt;a href=&quot;names#field-name&quot;&gt;field-name&lt;/a&gt;:&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt;  behaves similarly; in addition, it allows physical modification of this field. Immutable fields are covariant, mutable fields are non-variant. Both mutable and immutable fields may have explicitly polymorphic types. The polymorphism of the contents is statically checked whenever a record value is created or modified. Extracted values may have their types instantiated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cc55907fc102b663d0673eb99112e552f4a435a" translate="yes" xml:space="preserve">
          <source>The type representing wallclock time and calendar date.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="719afb56f810f882e663e05949b4c0135dc8e565" translate="yes" xml:space="preserve">
          <source>The type variables appearing as type parameters can optionally be prefixed by + or - to indicate that the type constructor is covariant or contravariant with respect to this parameter. This variance information is used to decide subtyping relations when checking the validity of :&amp;gt; coercions (see section &lt;a href=&quot;expr#ss%3Aexpr-coercions&quot;&gt;7.7.7&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da4bb1f94026133ed9e6ee3397f9022a4a5493c7" translate="yes" xml:space="preserve">
          <source>The types and their meanings are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf539767254769cb84eb0b1abbb2be61f0f57486" translate="yes" xml:space="preserve">
          <source>The typical usage is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e2cdbd104780129e6eb6af11e6842e3411789d0" translate="yes" xml:space="preserve">
          <source>The typical use of private types is in the export signature of a module, to ensure that construction of values of the private type always go through the functions provided by the module, while still allowing pattern-matching outside the defining module. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76fc86bc826ecd117df214c518ef9dca7c54b653" translate="yes" xml:space="preserve">
          <source>The typing of immediate objects is slightly different from explicitly defining a class in two respects. First, the inferred object type may contain free type variables. Second, since the class body of an immediate object will never be extended, its self type can be unified with a closed object type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="379766838ae430347d582312c2b9bd97e93485b9" translate="yes" xml:space="preserve">
          <source>The typing of pattern matching in presence of GADT can generate many existential types. When necessary, error messages refer to these existential types using compiler-generated names. Currently, the compiler generates these names according to the following nomenclature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b139709c938696abfe6558bd71c73b15692ae467" translate="yes" xml:space="preserve">
          <source>The unit type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f157a3529b6639761d0fe3370101d0cd58a51217" translate="yes" xml:space="preserve">
          <source>The unit type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b7a079da5bd24c487f37916205b8998acfd3262" translate="yes" xml:space="preserve">
          <source>The unix library makes many Unix system calls and system-related library functions available to OCaml programs. This chapter describes briefly the functions provided. Refer to sections 2 and 3 of the Unix manual for more details on the behavior of these functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61f8335838db8a8ae9ab9030edc50991b021708a" translate="yes" xml:space="preserve">
          <source>The unrolling depth applies to calls within the same mutually-recursive group of functions. Each time an inlining of such a call is performed the depth is incremented by one when examining the resulting body. If the depth reaches the limit set by -inline-max-unroll then speculation stops.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef46466283aedcffa1e3418737dde034112c7cb9" translate="yes" xml:space="preserve">
          <source>The unused specialised argument f may now be removed, leaving:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f25fc5451b4b7e9e596e2f95c2648b7f2f987a8b" translate="yes" xml:space="preserve">
          <source>The usage for ocamlrun is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdf174ec233170184c634afe9d8c6e98683f2f9c" translate="yes" xml:space="preserve">
          <source>The user must make sure that the parameter &lt;code&gt;s&lt;/code&gt; is the same string that was passed to the matching or searching function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cc30db23fbb2629fd5d6a40fb9f9a4aa615d10c" translate="yes" xml:space="preserve">
          <source>The user starts manually the program, when asked by the debugger. Allows remote debugging (see section &lt;a href=&quot;#ss%3Adebugger-communication&quot;&gt;17.8.8&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="642aefa1c3276d4815d6372b5c2ba0e28849644d" translate="yes" xml:space="preserve">
          <source>The value of lazy_two is displayed as &amp;lt;lazy&amp;gt;, which means the expression has not been evaluated yet, and its final value is unknown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e44eeca632e1ee708a87c7d08ac7f919078da583" translate="yes" xml:space="preserve">
          <source>The value path printer-name must refer to one of the functions defined by the object files loaded using load_printer. It cannot reference the functions of the program being debugged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="213346982c2b5edd8a2868f6648a75de11f3a7a1" translate="yes" xml:space="preserve">
          <source>The value restriction combined with this generalization for covariant type parameters is called the relaxed value restriction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e457e086f638356c025d7f98eea16073334d087" translate="yes" xml:space="preserve">
          <source>The variance indicated by the + and - annotations on parameters is enforced only for abstract and private types, or when there are type constraints. Otherwise, for abbreviations, variant and record types without type constraints, the variance properties of the type constructor are inferred from its definition, and the variance annotations are only checked for conformance with the definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2c84e520b4d58847b9a0936e0ff6718cecdfce8" translate="yes" xml:space="preserve">
          <source>The variant &lt;code&gt;caml_process_pending_actions_exn&lt;/code&gt; is provided, that returns the exception instead of raising it directly into OCaml code. Its result must be tested using Is_exception_result, and followed by Extract_exception if appropriate. It is typically used for clean up before re-raising:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d3e8b9825c91e7d1c1de2e5964ef9a6faa3a9d6" translate="yes" xml:space="preserve">
          <source>The variant value `VConstr is represented by hash_variant(&quot;VConstr&quot;). The variant value `VConstr(v) is represented by a block of size 2 and tag 0, with field number 0 containing hash_variant(&quot;VConstr&quot;) and field number 1 containing v.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe7a7371cf1264e74123560fc9eaab0ccf8deadd" translate="yes" xml:space="preserve">
          <source>The version number for the element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a12195f2bfc0b341eebc2706c0f898b85f60cd39" translate="yes" xml:space="preserve">
          <source>The warning-list argument is a sequence of warning specifiers, with no separators between them. A warning specifier is one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3155774bd8f5952cba7da2b05dd2d603a1c4e3ad" translate="yes" xml:space="preserve">
          <source>The with part does pattern matching on the exception value with the same syntax and behavior as match. Thus, several exceptions can be caught by one try&amp;hellip;with construct:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bee62c92457d9c1edd0b95b70b38529cd1e173d" translate="yes" xml:space="preserve">
          <source>The workaround is easy: you should put a type constraint on the parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e5abc2079ccb81595a85c637140e96ed3e00651" translate="yes" xml:space="preserve">
          <source>Then, the following command uses custom.cma as custom generator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7da202378d7326ed462fca4e0c21921b3c299f46" translate="yes" xml:space="preserve">
          <source>There are no type expressions describing (defined) variant types nor record types, since those are always named, i.e. defined before use and referred to by name. Type definitions are described in section &lt;a href=&quot;typedecl#ss%3Atypedefs&quot;&gt;7.8.1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ed327f049e48284a0a623ce9851b6b43632572d" translate="yes" xml:space="preserve">
          <source>There are several restrictions on &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5816a972e7e95d82645db243fd7e0a0acf5b5d4" translate="yes" xml:space="preserve">
          <source>There are six CAMLparam macros: CAMLparam0 to CAMLparam5, which take zero to five arguments respectively. If your function has no more than 5 parameters of type value, use the corresponding macros with these parameters as arguments. If your function has more than 5 parameters of type value, use CAMLparam5 with five of these parameters, and use one or more calls to the CAMLxparam macros for the remaining parameters (CAMLxparam1 to CAMLxparam5).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66a70237d0ffb18913597dc8bc48a2788fdf2980" translate="yes" xml:space="preserve">
          <source>There are two drawbacks to dynamic linking. The first is that the resulting executable is not stand-alone: it requires the shared libraries, as well as ocamlrun, to be installed on the machine executing the code. If you wish to distribute a stand-alone executable, it is better to link it statically, using ocamlc -custom -ccopt -static or ocamlopt -ccopt -static. Dynamic linking also raises the &amp;ldquo;DLL hell&amp;rdquo; problem: some care must be taken to ensure that the right versions of the shared libraries are found at start-up time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b66d252bf6e5adb16a8a81b0a31bcc98e8083e8f" translate="yes" xml:space="preserve">
          <source>There are two exceptions: for constructors and record fields in type definitions, the associated comment can only be placed after the constructor or field definition, without blank lines or other comments between them. The special comment for a constructor with another constructor following must be placed before the &amp;rsquo;|&amp;rsquo; character separating the two constructors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eea4041f7bae7ed250a35d69c8993bc99a56a95" translate="yes" xml:space="preserve">
          <source>There are two valid use-cases that respect this ownership discipline:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f4c01af210fd3e27d304b7f41d713af6236e4a1" translate="yes" xml:space="preserve">
          <source>There are two ways to obtain OCaml function values (closures) to be passed to the callback functions described above. One way is to pass the OCaml function as an argument to a primitive function. For example, if the OCaml code contains the declaration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f796d8197ff409294fcb0b2b9480a2ce5fecdc08" translate="yes" xml:space="preserve">
          <source>There is a printf function in the &lt;a href=&quot;libref/printf&quot;&gt;Printf&lt;/a&gt; module (see chapter &lt;a href=&quot;moduleexamples#c%3Amoduleexamples&quot;&gt;2&lt;/a&gt;) that allows you to make formatted output more concisely. It follows the behavior of the printf function from the C standard library. The printf function takes a format string that describes the desired output as a text interspered with specifiers (for instance %d, %f). Next, the specifiers are substituted by the following arguments in their order of apparition in the format string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0926f9a5aad069ce9f290befa2171e8e69385aeb" translate="yes" xml:space="preserve">
          <source>There is a single classification for coeffects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86860c4a3904e32a0066d40f9221fe10cbd4529f" translate="yes" xml:space="preserve">
          <source>There is a single input (the string &amp;ldquo;secret code&amp;rdquo;) which causes this program to crash, but finding it by blind random search is infeasible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f530a5d8b189e6bec332a6ff74e1e85c4100c796" translate="yes" xml:space="preserve">
          <source>There is an additional lexical rule to escape the special characters &lt;code&gt;'%'&lt;/code&gt; and &lt;code&gt;'@'&lt;/code&gt; in format strings: if a special character follows a &lt;code&gt;'%'&lt;/code&gt; character, it is treated as a plain character. In other words, &lt;code&gt;&quot;%%&quot;&lt;/code&gt; is considered as a plain &lt;code&gt;'%'&lt;/code&gt; and &lt;code&gt;&quot;%@&quot;&lt;/code&gt; as a plain &lt;code&gt;'@'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89300e6e8eb5caa8716a6d136ca3ce59e33af664" translate="yes" xml:space="preserve">
          <source>There is another partial solution to the problem of unnecessary weak type, which is implemented directly within the type checker. Briefly, it is possible to prove that weak types that only appear as type parameters in covariant positions &amp;ndash;also called positive positions&amp;ndash; can be safely generalized to polymorphic types. For instance, the type 'a list is covariant in 'a:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4839904c7c8092d09c24e4a4ca03c2ca6d8ace01" translate="yes" xml:space="preserve">
          <source>There is another, more direct way to create an object: create it without going through a class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6713ccaa14a77e18cc0d165c630249a7f39edf84" translate="yes" xml:space="preserve">
          <source>There is no blank line or another special comment between the special comment and the element. However, a regular comment can occur between the special comment and the element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="420c7eecf9b88f0fd685ede8cd7d5594dccc6b10" translate="yes" xml:space="preserve">
          <source>There is no linearity restriction over as bound variables. When a variable is bound more than once, the previous rules are to be extended as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2df4086644aefdc6d4fa1daff752de72504dccd" translate="yes" xml:space="preserve">
          <source>There is nothing particular about functors that inhibits inlining compared to normal functions. To the inliner, these both look the same, except that functors are marked as such.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f7526b0137b40ba5befc330c948531d764b9b23" translate="yes" xml:space="preserve">
          <source>There is sometimes an alternative between using modules or classes for parametric data types. Indeed, there are situations when the two approaches are quite similar. For instance, a stack can be straightforwardly implemented as a class:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f6f12e3992f209be063993c601fdba9acbc537c" translate="yes" xml:space="preserve">
          <source>Therefore, after placing an int in store, we cannot use it to store any value other than an int. More generally, weak types protect the program from undue mutation of values with a polymorphic type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9c813ad0d9ef31d493524a8ea85262d92050cce" translate="yes" xml:space="preserve">
          <source>These .cmt and .cmti files are typically useful for code inspection tools.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69311f08c70520540fee4cbe4bda7e98116c0238" translate="yes" xml:space="preserve">
          <source>These annotations explicitly require the defined value to be polymorphic, and allow one to use this polymorphism in recursive occurrences (when using letrec). Note however that this is a normal polymorphic type, unifiable with any instance of itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43e7d9c598d98633999ba13a3dcc444ba12214ad" translate="yes" xml:space="preserve">
          <source>These eleven name spaces are distinguished both by the context and by the capitalization of the identifier: whether the first letter of the identifier is in lowercase (written &lt;a href=&quot;lex#lowercase-ident&quot;&gt;lowercase-ident&lt;/a&gt; below) or in uppercase (written &lt;a href=&quot;lex#capitalized-ident&quot;&gt;capitalized-ident&lt;/a&gt;). Underscore is considered a lowercase letter for this purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="870297f2b83ed8726b893d830c917d6f224b681b" translate="yes" xml:space="preserve">
          <source>These files reside in the caml/ subdirectory of the OCaml standard library directory, which is returned by the command ocamlc -where (usually /usr/local/lib/ocaml or /usr/lib/ocaml).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3be7b63190a743842c43dfb1591048d46124470c" translate="yes" xml:space="preserve">
          <source>These functions are the same as the basic functions, except that they use (and update) the given PRNG state instead of the default one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="239ea6a3f14d9dc171a9d56f5158d10f257a786d" translate="yes" xml:space="preserve">
          <source>These functions are used to traverse the slots of a raw backtrace and extract information from them in a programmer-friendly format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cf57b7b10c266fa7ea278e39e177192d8ca0786" translate="yes" xml:space="preserve">
          <source>These functions poll for pending signals by calling asynchronous callbacks (section &lt;a href=&quot;#ss%3Ac-process-pending-actions&quot;&gt;20.5.3&lt;/a&gt;) before releasing and after acquiring the lock. They can therefore execute arbitrary OCaml code including raising an asynchronous exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be1ff51841b268ac0bc83ac53b16b105790d419d" translate="yes" xml:space="preserve">
          <source>These functions return immediately &lt;code&gt;true&lt;/code&gt; in the Win32 implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ce3216765c88e5c48af00b3c110ef4d63384284" translate="yes" xml:space="preserve">
          <source>These goals are often reached not just by inlining itself but also by other optimisations that the compiler is able to perform as a result of inlining.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4386b22d00bf9e30129abfc3148f83106ab4fda2" translate="yes" xml:space="preserve">
          <source>These options are passed as is to ocamlc or ocamlopt. See the documentation of these commands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="484df2de1a8035aff891a6ad2ca2a206e2085ae8" translate="yes" xml:space="preserve">
          <source>These options are passed as is to the C compiler. Refer to the documentation of the C compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eeaa8b4b44d8ce0bdc7032fda14b43069cb254a" translate="yes" xml:space="preserve">
          <source>These options are useful when you have, for example, a type and a value with the same name. If you do not specify prefixes, L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X will complain about multiply defined labels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd109aa38e89265e3d535e5b8837cacc7cebe8b5" translate="yes" xml:space="preserve">
          <source>These parameters are ultimately bounded by the arguments provided to the corresponding command-line flags (or their default values):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="201eef9e30770a6e41dd8bf1c6f8c6e7106ea2b8" translate="yes" xml:space="preserve">
          <source>These program generators are very close to the well-known lex and yacc commands that can be found in most C programming environments. This chapter assumes a working knowledge of lex and yacc: while it describes the input syntax for ocamllex and ocamlyacc and the main differences with lex and yacc, it does not explain the basics of writing a lexer or parser description in lex and yacc. Readers unfamiliar with lex and yacc are referred to &amp;ldquo;Compilers: principles, techniques, and tools&amp;rdquo; by Aho, Sethi and Ullman (Addison-Wesley, 1986), or &amp;ldquo;Lex &amp;amp; Yacc&amp;rdquo;, by Levine, Mason and Brown (O&amp;rsquo;Reilly, 1992).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a01d3add6122970dc3dbf24500aab00b1c8c4545" translate="yes" xml:space="preserve">
          <source>These text messages are usually not stable over time: call sites building these constructors may refine the message in a future version to make it more explicit, etc. Therefore, it is dangerous to match over the precise value of the message. For example, until OCaml 4.02, Array.iter2 would raise the exception</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="056363d88c08f1781faea018bb808d8587eb9a45" translate="yes" xml:space="preserve">
          <source>These two files together define a structure named A as if the following definition was entered at top-level:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c3373b0a618202574e74bfc05210cbd553b7e77" translate="yes" xml:space="preserve">
          <source>These weakened dependencies make possible to use module aliases in place of the -pack mechanism. Suppose that you have a library Mylib composed of modules A and B. Using -pack, one would issue the command line</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5e847d2a87ac8165d8955c02fcafa07afd4fca2" translate="yes" xml:space="preserve">
          <source>They only differ by their labels. Detailed interfaces can be found in &lt;code&gt;arrayLabels.mli&lt;/code&gt;, &lt;code&gt;bytesLabels.mli&lt;/code&gt;, &lt;code&gt;listLabels.mli&lt;/code&gt; and &lt;code&gt;stringLabels.mli&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b235c592e19c9ae8ea4fa2dac4a8048ec27fa43" translate="yes" xml:space="preserve">
          <source>They only differ by their labels. They are provided to help porting from previous versions of OCaml. The contents of this module are subject to change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e865936f70f95a35530da646f08d349c8618ab8" translate="yes" xml:space="preserve">
          <source>This ability provides class constructors as can be found in other languages. Several constructors can be defined this way to build objects of the same class but with different initialization patterns; an alternative is to use initializers, as described below in section &lt;a href=&quot;#s%3Ainitializers&quot;&gt;3.4&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e4da690687d8f30331d0881e81b870c14418b6d" translate="yes" xml:space="preserve">
          <source>This allows delaying the formatting of backtraces to when they are actually printed, which may be useful if you record more backtraces than you print.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cf2b05351c309723aa496873af8b5e1e89659d8" translate="yes" xml:space="preserve">
          <source>This allows the following idiom, keeping a list of all objects belonging to a class or its subclasses:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3f29de16e9f8798d1932dbc922db0d447425dac" translate="yes" xml:space="preserve">
          <source>This approach lets you access A and B directly inside the library, and as Mylib.A and Mylib.B from outside. It also has the advantage that Mylib is no longer monolithic: if you use Mylib.A, only Mylib__A will be linked in, not Mylib__B.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1372a67563bf716e071b3b183d02ea2f598a4156" translate="yes" xml:space="preserve">
          <source>This attribute is attached to a function application and always takes an integer argument. Each time the inliner sees the attribute it behaves as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09b4b8d9fa337a2eb876a44b79cb348c9e5f0855" translate="yes" xml:space="preserve">
          <source>This box behaves as an horizontal box if it fits on a single line, otherwise it behaves as a vertical box.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7625b4398585ec56f1ee579a0692c7819ab1dcb" translate="yes" xml:space="preserve">
          <source>This box features command &lt;code&gt;set_tab&lt;/code&gt; to define cell boundaries, and command &lt;code&gt;print_tab&lt;/code&gt; to move from cell to cell and split the line when there is no more cells to print on the line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00d886ace2f3bb025615806e435389e25f058b58" translate="yes" xml:space="preserve">
          <source>This box is the general purpose pretty-printing box.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4790a08c0b8ba22758a78bbaf58c7ad274884241" translate="yes" xml:space="preserve">
          <source>This box prints lines separated into cells of fixed width.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9521c4e75869b633ff289e3509ef90a59f7e6d5f" translate="yes" xml:space="preserve">
          <source>This box prints material as much as possible on every line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4388d065629c7972988d67b92adade884cfc189" translate="yes" xml:space="preserve">
          <source>This box prints material on a single line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ed97b2eb7c12b24bf9da6774de6d18d44c03f8a" translate="yes" xml:space="preserve">
          <source>This box prints material on as many lines as break hints in the box.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bac037b45f5205c0421d44bb0a7e2d59de5d5640" translate="yes" xml:space="preserve">
          <source>This builds a runtime system with the required primitives. The OCaml linker generates bytecode for this custom runtime system. The bytecode is appended to the end of the custom runtime system, so that it will be automatically executed when the output file (custom runtime + bytecode) is launched.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b017452d5ed8ae35ceea59902e09d1ad45c8bde1" translate="yes" xml:space="preserve">
          <source>This can be used as a replacement for &lt;a href=&quot;format#VALasprintf&quot;&gt;&lt;code&gt;Format.asprintf&lt;/code&gt;&lt;/a&gt; to delay formatting decisions. Using the string returned by &lt;a href=&quot;format#VALasprintf&quot;&gt;&lt;code&gt;Format.asprintf&lt;/code&gt;&lt;/a&gt; in a formatting context forces formatting decisions to be taken in isolation, and the final string may be created prematurely. &lt;a href=&quot;format#VALdprintf&quot;&gt;&lt;code&gt;Format.dprintf&lt;/code&gt;&lt;/a&gt; allows delay of formatting decisions until the final formatting context is known. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="736b6a8d2382f934d9e36c672b75eae9562bc868" translate="yes" xml:space="preserve">
          <source>This case combines the previous two: the representation of the type is made visible to all users, and no fresh type is generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b0b9d32c2c99f0a8a9065915f71e59738d0f44f" translate="yes" xml:space="preserve">
          <source>This chapter covers more advanced questions related to the limitations of polymorphic functions and types. There are some situations in OCaml where the type inferred by the type checker may be less generic than expected. Such non-genericity can stem either from interactions between side-effect and typing or the difficulties of implicit polymorphic recursion and higher-rank polymorphism.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e99967e6f113e515abf96820acbd0c907f9ea256" translate="yes" xml:space="preserve">
          <source>This chapter describes OCamldoc, a tool that generates documentation from special comments embedded in source files. The comments used by OCamldoc are of the form (**&amp;hellip;*) and follow the format described in section &lt;a href=&quot;#s%3Aocamldoc-comments&quot;&gt;16.2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22979b22da128bdede671815a07fda413464a01f" translate="yes" xml:space="preserve">
          <source>This chapter describes how the execution of OCaml programs can be profiled, by recording how many times functions are called, branches of conditionals are taken, &amp;hellip;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc58c64bbca12c120e6be347ae738db5e914ab57" translate="yes" xml:space="preserve">
          <source>This chapter describes how user-defined primitives, written in C, can be linked with OCaml code and called from OCaml functions, and how these C functions can call back to OCaml code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="084829076e627e4169c9229a38a24e09ad828c7b" translate="yes" xml:space="preserve">
          <source>This chapter describes language extensions and convenience features that are implemented in OCaml, but not described in the OCaml reference manual.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="995a07b1158b72f353eb1ac428ac4123f6853088" translate="yes" xml:space="preserve">
          <source>This chapter describes the OCaml batch compiler ocamlc, which compiles OCaml source files to bytecode object files and links these object files to produce standalone bytecode executable files. These executable files are then run by the bytecode interpreter ocamlrun.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b065bf42750f41d77bac34c5d6dddd1489b34a0" translate="yes" xml:space="preserve">
          <source>This chapter describes the OCaml core library, which is composed of declarations for built-in types and exceptions, plus the module Stdlib that provides basic operations on these built-in types. The Stdlib module is special in two ways:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36bc4b25a8de2e3c8b0cfa69654d56ac54e08f29" translate="yes" xml:space="preserve">
          <source>This chapter describes the OCaml front-end, which declares the abstract syntax tree used by the compiler, provides a way to parse, print and pretty-print OCaml code, and ultimately allows one to write abstract syntax tree preprocessors invoked via the -ppx flag (see chapters &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt; and &lt;a href=&quot;native#c%3Anativecomp&quot;&gt;12&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c5ce841e2ff9db70cbc0f9643176a189658c748" translate="yes" xml:space="preserve">
          <source>This chapter describes the OCaml high-performance native-code compiler ocamlopt, which compiles OCaml source files to native code object files and links these object files to produce standalone executables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07729068091da08d36b2e49ba6d4e4d523bd49f5" translate="yes" xml:space="preserve">
          <source>This chapter describes the OCaml instrumented runtime, a runtime variant allowing the collection of events and metrics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69ddd94c98a17da2cbc644dd1e169145a2b86378" translate="yes" xml:space="preserve">
          <source>This chapter describes the OCaml source-level replay debugger ocamldebug.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b3bef73d988061d29d6941712ad9747d92ad9a4" translate="yes" xml:space="preserve">
          <source>This chapter describes the functions provided by the OCaml standard library. The modules from the standard library are automatically linked with the user&amp;rsquo;s object code files by the ocamlc command. Hence, these modules can be used in standalone programs without having to add any .cmo file on the command line for the linking phase. Similarly, in interactive use, these globals can be used in toplevel phrases without having to load any .cmo file in memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43ad0f253c7b2080f9dd53e8aa8d98648421148a" translate="yes" xml:space="preserve">
          <source>This chapter describes the toplevel system for OCaml, that permits interactive use of the OCaml system through a read-eval-print loop (REPL). In this mode, the system repeatedly reads OCaml phrases from the input, then typechecks, compile and evaluate them, then prints the inferred type and result value, if any. The system prints a # (sharp) prompt before reading each phrase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69c3d7e39acb1d5e622db5124a13613835b7634c" translate="yes" xml:space="preserve">
          <source>This chapter describes two program generators: ocamllex, that produces a lexical analyzer from a set of regular expressions with associated semantic actions, and ocamlyacc, that produces a parser from a grammar with associated semantic actions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="210573b7ce8135e7e064f066b6ebcd12cb7b792a" translate="yes" xml:space="preserve">
          <source>This chapter details each of these situations and, if it is possible, how to recover genericity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34e2681602b9187f866a2387ff78cec658492716" translate="yes" xml:space="preserve">
          <source>This chapter gives an overview of the new features in OCaml 3: labels, and polymorphic variants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3588c35304425734153b099a7cdbb31b7ab306d6" translate="yes" xml:space="preserve">
          <source>This chapter gives an overview of the object-oriented features of OCaml.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f743cd4aa8589a6f7ccb3236942f7a143fef8068" translate="yes" xml:space="preserve">
          <source>This chapter introduces the module system of OCaml.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="641fe4386aeca969ab9cc8d868ad085c0c8ea3bb" translate="yes" xml:space="preserve">
          <source>This construction is useful because the type constructors it introduces can be used in places where a type variable is not allowed. For instance, one can use it to define an exception in a local module within a polymorphic function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42d44fb398c8f2ad20178f128be9005c0c3a7520" translate="yes" xml:space="preserve">
          <source>This correspond to the commuting label mode of Objective Caml 3.00 through 3.02, with some additional flexibility on total applications. The so-called classic mode (-nolabels options) is now deprecated for normal use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0703f0be9e37d286e36c6f06a582f656747a10b9" translate="yes" xml:space="preserve">
          <source>This creates a new module &lt;code&gt;IntHashtbl&lt;/code&gt;, with a new type &lt;code&gt;'a&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;IntHashtbl.t&lt;/code&gt; of tables from &lt;code&gt;int&lt;/code&gt; to &lt;code&gt;'a&lt;/code&gt;. In this example, &lt;code&gt;h&lt;/code&gt; contains &lt;code&gt;string&lt;/code&gt; values so its type is &lt;code&gt;string&amp;nbsp;IntHashtbl.t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2d68deb1edda584ae4e6e7569ccd1f525a47a80" translate="yes" xml:space="preserve">
          <source>This creates a new module &lt;code&gt;PairsMap&lt;/code&gt;, with a new type &lt;code&gt;'a&amp;nbsp;PairsMap.t&lt;/code&gt; of maps from &lt;code&gt;int&amp;nbsp;*&amp;nbsp;int&lt;/code&gt; to &lt;code&gt;'a&lt;/code&gt;. In this example, &lt;code&gt;m&lt;/code&gt; contains &lt;code&gt;string&lt;/code&gt; values so its type is &lt;code&gt;string&amp;nbsp;PairsMap.t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="390961a477909cf3be486ca4a271404c23f7a126" translate="yes" xml:space="preserve">
          <source>This creates a new module &lt;code&gt;PairsSet&lt;/code&gt;, with a new type &lt;code&gt;PairsSet.t&lt;/code&gt; of sets of &lt;code&gt;int&amp;nbsp;*&amp;nbsp;int&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75cd13267b497efe97847c8300244e98191e876f" translate="yes" xml:space="preserve">
          <source>This creates the bytecode file mytoplevel, containing the OCaml toplevel system, plus the code from the three .cmo files. This toplevel is directly executable and is started by:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5b1409a54230dba201ee4c701c307570dc6eae6" translate="yes" xml:space="preserve">
          <source>This declaration does more than hiding the y method, it also makes the type c incompatible with any other closed object type, meaning that only o will be of type c. In that respect it behaves similarly to private record types. But private row types are more flexible with respect to incremental refinement. This feature can be used in combination with functors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62b4223715d06df11caf2304744d5adfa549ab4f" translate="yes" xml:space="preserve">
          <source>This declaration expresses that a value of type number is either an integer, a floating-point number, or the constant Error representing the result of an invalid operation (e.g. a division by zero).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="650dca8821c23c4d144204d01cac7fd4b83e068e" translate="yes" xml:space="preserve">
          <source>This defines name&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; name&lt;sub&gt;n&lt;/sub&gt; as mutually recursive functions local to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab9d147194e992eb8205321a938f103ca896c88b" translate="yes" xml:space="preserve">
          <source>This defines the type constructor as an abbreviation for the type expression on the right of the = sign.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="749cd341985f67a650d96523cab212ab33c78584" translate="yes" xml:space="preserve">
          <source>This defines the value name name as a function with type type that executes by calling the given C function. For instance, here is how the int_of_string primitive is declared in the standard library module Stdlib:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5ba8edf36d0fb0da29929bdb415469de948dad5" translate="yes" xml:space="preserve">
          <source>This definition reads as follows: a binary tree containing values of type 'a (an arbitrary type) is either empty, or is a node containing one value of type 'a and two subtrees also containing values of type 'a, that is, two 'a btree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d8e09fb17ca3bdcd19c8523134e3e779a73a386" translate="yes" xml:space="preserve">
          <source>This directive registers the function named printer-name (a value path) as a printer for values whose types match the argument type of the function. That is, the toplevel loop will call printer-name when it has such a value to print.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e68ea2c0517c1d20b6ed32dd8f6c253ddb6f201" translate="yes" xml:space="preserve">
          <source>This document is intended as a reference manual for the OCaml language. It lists the language constructs, and gives their precise syntax and informal semantics. It is by no means a tutorial introduction to the language: there is not a single example. A good working knowledge of OCaml is assumed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74df0e696ad77b21b87792ac16ae61fcae218478" translate="yes" xml:space="preserve">
          <source>This engine makes it possible to implement a low-overhead memory profiler as an OCaml library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3fa2a6f69f904187160e52f45b06e671158e7a1" translate="yes" xml:space="preserve">
          <source>This enters a regular toplevel loop, except that the code from foo.cmo, bar.cmo and gee.cmo is already loaded in memory, just as if you had typed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac5c02e5a2be940db6035f15a82bb532610ff549" translate="yes" xml:space="preserve">
          <source>This error appears when trying to link an incomplete or incorrectly ordered set of files. Either you have forgotten to provide an implementation for the compilation unit named mod on the command line (typically, the file named mod.cmo, or a library containing that file). Fix: add the missing .ml or .cmo file to the command line. Or, you have provided an implementation for the module named mod, but it comes too late on the command line: the implementation of mod must come before all bytecode object files that reference mod. Fix: change the order of .ml and .cmo files on the command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01feea14de8e0c629d6af124eee3f63c75a3e58e" translate="yes" xml:space="preserve">
          <source>This error appears when trying to link code that calls external functions written in C. As explained in chapter &lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;20&lt;/a&gt;, such code must be linked with C libraries that implement the required f C function. If the C libraries in question are not shared libraries (DLLs), the code must be linked in &amp;ldquo;custom runtime&amp;rdquo; mode. Fix: add the required C libraries to the command line, and possibly the -custom option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3322e1b78b0d097c04a82c8abad2b9e17591c8f" translate="yes" xml:space="preserve">
          <source>This explicit overriding annotation also works for val and inherit:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c31e1e38cacd668c448b1b245b9768d081710af" translate="yes" xml:space="preserve">
          <source>This expression evaluates to a functional value with one argument. When this function is applied to a value v, this value is matched against each pattern &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;. If one of these matchings succeeds, that is, if the value v matches the pattern &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; for some i, then the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; associated to the selected pattern is evaluated, and its value becomes the value of the function application. The evaluation of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; takes place in an environment enriched by the bindings performed during the matching.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15e34d384bc13e41a20958589d5dd84188cb9c53" translate="yes" xml:space="preserve">
          <source>This expression has type t&lt;sub&gt;1&lt;/sub&gt;, but is used with type t&lt;sub&gt;2&lt;/sub&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c752faae770745f4efadec9ad9e3c86712116bf8" translate="yes" xml:space="preserve">
          <source>This expression is equivalent to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8f6d05e23df51dd5500167d330c8fab6501e536" translate="yes" xml:space="preserve">
          <source>This extension allows user to define empty variants. Empty variant type can be eliminated by refutation case of pattern matching.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c21aac0cfc0a526fe8feeb656d5151ae30a38c66" translate="yes" xml:space="preserve">
          <source>This extension is intended to provide a convenient syntax for working with monads and applicatives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba4fa874a00f72ae6a3e4ed02825e2050e5a7719" translate="yes" xml:space="preserve">
          <source>This extension makes it possible to open any module expression in module structures and expressions. A similar mechanism is also available inside module types, but only for extended module paths (e.g. F(X).G(Y)).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bded797c2b65154bcb84bdfa2fb5ae024b3d73a" translate="yes" xml:space="preserve">
          <source>This extension provides syntactic sugar for getting and setting elements for user-defined indexed types. For instance, we can define python-like dictionaries with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ced06d009b619786712d80c35d7e9694c054e2d" translate="yes" xml:space="preserve">
          <source>This extension provides syntactic sugar for getting and setting elements in the arrays provided by the &lt;a href=&quot;libref/bigarray&quot;&gt;Bigarray&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b1d07b08e65aec904b4829d528dfb8d3dbc575e" translate="yes" xml:space="preserve">
          <source>This facility is currently available on all platforms supported by OCaml except Cygwin 64 bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aaa2dee7862002847ec215725a07465e9cee221" translate="yes" xml:space="preserve">
          <source>This filename can also be specified using the OCAML_EVENTLOG_PREFIX environment variable. The given path will be suffixed with {.PID}.eventlog.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d118477856b3c7c25f93002b3254e61bdd8c9a57" translate="yes" xml:space="preserve">
          <source>This form of attributes can also be inserted after the `&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt; in polymorphic variant type expressions (&lt;a href=&quot;types#tag-spec-first&quot;&gt;tag-spec-first&lt;/a&gt;, &lt;a href=&quot;types#tag-spec&quot;&gt;tag-spec&lt;/a&gt;, &lt;a href=&quot;types#tag-spec-full&quot;&gt;tag-spec-full&lt;/a&gt;) or after the &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; in &lt;a href=&quot;types#method-type&quot;&gt;method-type&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebb9471d9b8d494e18c82c68d8f753fc5a0fc194" translate="yes" xml:space="preserve">
          <source>This function can be applied to objects of type money or money2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45f742d762c2f337f9316533c0c01063fbc47ef8" translate="yes" xml:space="preserve">
          <source>This function conforms to the specification of POSIX.1-2008 for the &lt;code&gt;basename&lt;/code&gt; utility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6687a7963ca256cf05cde1098887f34f0c554208" translate="yes" xml:space="preserve">
          <source>This function does not allocate memory, but tries to run the postponed callbacks for already allocated memory blocks (of course, these callbacks may allocate).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68449acffb76876acb29d71c9df112633cbec2b0" translate="yes" xml:space="preserve">
          <source>This function does nothing in this implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b93512b013a1d7422171a6bb6941e6102fbeb0a" translate="yes" xml:space="preserve">
          <source>This function is safe because the byte sequence &lt;code&gt;s&lt;/code&gt; will never be accessed or mutated after &lt;code&gt;unsafe_to_string&lt;/code&gt; is called. The &lt;code&gt;string_init&lt;/code&gt; code gives up ownership of &lt;code&gt;s&lt;/code&gt;, and returns the ownership of the resulting string to its caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f9678c9920e8bd6fa3351bc87366633dae969b5" translate="yes" xml:space="preserve">
          <source>This function might be written like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9cc7e820a82b580a34f0b2bb19198a32fb2d1dc" translate="yes" xml:space="preserve">
          <source>This function will erase non-string tag formatting functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f8a6a2bcdafd5f49ba5cdcd976330cb7e69f76f" translate="yes" xml:space="preserve">
          <source>This functional, along with a number of other list and array functionals, is predefined because it is often useful, but there is nothing magic with it: it can easily be defined as follows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f98ed33477f247dffac90e7d27b65afcdf57df27" translate="yes" xml:space="preserve">
          <source>This generates a new type constructor and defines associated constructors or fields, through which values of that type can be directly built or inspected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89ad557334e8e1d878c785f430b3e375436f8b96" translate="yes" xml:space="preserve">
          <source>This idiom can in turn be used to retrieve an object whose type has been weakened:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70991f0b7fe10b4796387e57d8f588f1325f5ec1" translate="yes" xml:space="preserve">
          <source>This idiom guarantees that Myset is compatible with Set, but allows it to represent sets internally in a different way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="751a6509444b430d2b4388b31e1c9693d69713df" translate="yes" xml:space="preserve">
          <source>This is &lt;em&gt;not&lt;/em&gt; the semantics adopted by OCaml.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58da15a38848eb6e8733fd04e3d04f1485f3fce9" translate="yes" xml:space="preserve">
          <source>This is also available (since OCaml 4.06) for local opens in class expressions and class type expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9768346232217703b79f946958f318884f387d78" translate="yes" xml:space="preserve">
          <source>This is an experimental extension of OCaml: the class of recursive definitions accepted, as well as its dynamic semantics are not final and subject to change in future releases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abf0eb306419907e3403ce9f96c3ef7450a9208f" translate="yes" xml:space="preserve">
          <source>This is another instance of friend functions as seen in section &lt;a href=&quot;objectexamples#s%3Afriends&quot;&gt;3.17&lt;/a&gt;. Indeed, this is the same mechanism used in the module Set in the absence of objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c683f5551fbf795dd6f0010c7e2c94e3d36bfd7" translate="yes" xml:space="preserve">
          <source>This is because Lazy.force memoizes the result of the forced expression. In other words, every subsequent call of Lazy.force on that expression returns the result of the first computation without recomputing the lazy expression. Let us force lazy_two once again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad067981738b53b159d177a530e65b07049d0d76" translate="yes" xml:space="preserve">
          <source>This is by far the most common type error in programs. Type t&lt;sub&gt;1&lt;/sub&gt; is the type inferred for the expression (the part of the program that is displayed in the error message), by looking at the expression itself. Type t&lt;sub&gt;2&lt;/sub&gt; is the type expected by the context of the expression; it is deduced by looking at how the value of this expression is used in the rest of the program. If the two types t&lt;sub&gt;1&lt;/sub&gt; and t&lt;sub&gt;2&lt;/sub&gt; are not compatible, then the error above is produced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f82fc074dee53936731175b8537edb3c787511a9" translate="yes" xml:space="preserve">
          <source>This is done by forming judgements on the &lt;em&gt;effects&lt;/em&gt; and the &lt;em&gt;coeffects&lt;/em&gt; that might be performed were the expression to be executed. Effects talk about how the expression might affect the world; coeffects talk about how the world might affect the expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1b690baac19cb0582baf96deb9492b21952c740" translate="yes" xml:space="preserve">
          <source>This is done using first class modules (see chapter &lt;a href=&quot;firstclassmodules#s%3Afirst-class-modules&quot;&gt;8.5&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14b965549f63ae8efc2b10799321a123949f32e2" translate="yes" xml:space="preserve">
          <source>This is in any case a good practice for such global mutable variables. Otherwise, they will pick out the type of first use. If there is a mistake at this point, this can result in confusing type errors when later, correct uses are flagged as errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da8a97ff5473940dbd5590e2ac55f520f156f175" translate="yes" xml:space="preserve">
          <source>This is the counterpart in signatures of class definitions. A class specification matches a class definition if they have the same type parameters and their types match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a2f273ae05987b14e1f15ae11bcc910f3cc8e34" translate="yes" xml:space="preserve">
          <source>This manual documents the release 4.11 of the OCaml system. It is organized as follows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="949db82cf2165881bb890405414754937b92c7a0" translate="yes" xml:space="preserve">
          <source>This manual is also available in &lt;a href=&quot;https://ocaml.org/releases/4.11/ocaml-4.11-refman.pdf&quot;&gt;PDF&lt;/a&gt;. &lt;a href=&quot;https://ocaml.org/releases/4.11/ocaml-4.11-refman.txt&quot;&gt;plain text&lt;/a&gt;, as a &lt;a href=&quot;https://ocaml.org/releases/4.11/ocaml-4.11-refman-html.tar.gz&quot;&gt;bundle of HTML files&lt;/a&gt;, and as a &lt;a href=&quot;https://ocaml.org/releases/4.11/ocaml-4.11-refman.info.tar.gz&quot;&gt;bundle of Emacs Info files&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6a463aa2621012fa84bb9173c52f8aacbca9587" translate="yes" xml:space="preserve">
          <source>This may require some care: if the scrutinee may return several different cases of the same pattern, or raise distinct instances of the same exception, you may need to modify your code to separate those several cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9e169cadd5567bf33a7c94a3b1845ac6d0d1577" translate="yes" xml:space="preserve">
          <source>This meta-module provides labelized version of the &lt;a href=&quot;array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bytes&quot;&gt;&lt;code&gt;Bytes&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cda004ff3f73690b7705e7353fdb4ee3d731450" translate="yes" xml:space="preserve">
          <source>This meta-module provides labelized version of the &lt;a href=&quot;hashtbl&quot;&gt;&lt;code&gt;Hashtbl&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;set&quot;&gt;&lt;code&gt;Set&lt;/code&gt;&lt;/a&gt; modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74b7b70a1b67a465fca03531e3e7ca988aa3c7a2" translate="yes" xml:space="preserve">
          <source>This method will be called with the list of analysed and possibly merged Odoc_info.t_module structures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17cfabd3ff7747a40d003c4e1ce49d8233fcae6d" translate="yes" xml:space="preserve">
          <source>This module allows OCaml values to be registered with the C runtime under a symbolic name, so that C code can later call back registered OCaml functions, or raise registered OCaml exceptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99f88a4ac39ab2683e26258770cfb0e2d8f5fd8c" translate="yes" xml:space="preserve">
          <source>This module allows to define a type &lt;code&gt;t&lt;/code&gt; with the &lt;code&gt;immediate64&lt;/code&gt; attribute. This attribute means that the type is immediate on 64 bit architectures. On other architectures, it might or might not be immediate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e533b385e01821d7ad15e0945c07d70b1844d76" translate="yes" xml:space="preserve">
          <source>This module implements a pretty-printing facility to format values within &lt;a href=&quot;format#boxes&quot;&gt;'pretty-printing boxes'&lt;/a&gt; and &lt;a href=&quot;format#tags&quot;&gt;'semantic tags'&lt;/a&gt; combined with a set of &lt;a href=&quot;format#fpp&quot;&gt;printf-like functions&lt;/a&gt;. The pretty-printer splits lines at specified &lt;a href=&quot;format#breaks&quot;&gt;break hints&lt;/a&gt;, and indents lines according to the box structure. Similarly, &lt;a href=&quot;format#tags&quot;&gt;semantic tags&lt;/a&gt; can be used to decouple text presentation from its contents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fe9c1d1946f164dc7ea31e649282f17763c3950" translate="yes" xml:space="preserve">
          <source>This module implements a simple 'standard' lexical analyzer, presented as a function from character streams to token streams. It implements roughly the lexical conventions of OCaml, but is parameterized by the set of keywords of your language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e0125fd89be5c0e10d0ed6d49f7e1879412755c" translate="yes" xml:space="preserve">
          <source>This module implements applicative association tables, also known as finite maps or dictionaries, given a total ordering function over the keys. All operations over maps are purely applicative (no side-effects). The implementation uses balanced binary trees, and therefore searching and insertion take time logarithmic in the size of the map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce89672c48fa1f9bec12d607d59af82b35753a53" translate="yes" xml:space="preserve">
          <source>This module implements buffers that automatically expand as necessary. It provides accumulative concatenation of strings in quasi-linear time (instead of quadratic time when strings are concatenated pairwise).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da30f332376f7747f380e4c823a1b7a155244e7c" translate="yes" xml:space="preserve">
          <source>This module implements multi-dimensional arrays of integers and floating-point numbers, thereafter referred to as 'Bigarrays', to distinguish them from the standard OCaml arrays described in &lt;a href=&quot;array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c5803197dddf99e3ec90f036488d17a8b4740cf" translate="yes" xml:space="preserve">
          <source>This module implements queues (FIFOs), with in-place modification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd2b395d2566d5b178c77d76600076510ec457a8" translate="yes" xml:space="preserve">
          <source>This module implements stacks (LIFOs), with in-place modification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b90dc1cefe04c048afd0453d62a3c51d515ce8d7" translate="yes" xml:space="preserve">
          <source>This module implements synchronous inter-thread communications over channels. As in John Reppy's Concurrent ML system, the communication events are first-class values: they can be built and combined independently before being offered for communication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3849f273edf21565de6b4e420886d0b2f60b00cd" translate="yes" xml:space="preserve">
          <source>This module implements the set data structure, given a total ordering function over the set elements. All operations over sets are purely applicative (no side-effects). The implementation uses balanced binary trees, and is therefore reasonably efficient: insertion and membership take time logarithmic in the size of the set, for instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2729905361f7f59d504ab6ed9996768ff5460796" translate="yes" xml:space="preserve">
          <source>This module is automatically opened at the beginning of each compilation. All components of this module can therefore be referred by their short name, without prefixing them by &lt;code&gt;Stdlib&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0333c95ed68f95f7342e2b757b9f08ce6a149992" translate="yes" xml:space="preserve">
          <source>This module is intended to be used through &lt;a href=&quot;stdlabels&quot;&gt;&lt;code&gt;StdLabels&lt;/code&gt;&lt;/a&gt; which replaces &lt;a href=&quot;array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bytes&quot;&gt;&lt;code&gt;Bytes&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; with their labeled counterparts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0e122c356078f81e1beb90b2b6032029724c402" translate="yes" xml:space="preserve">
          <source>This module is intended to be used via &lt;a href=&quot;stdlabels&quot;&gt;&lt;code&gt;StdLabels&lt;/code&gt;&lt;/a&gt; which replaces &lt;a href=&quot;array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bytes&quot;&gt;&lt;code&gt;Bytes&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; with their labeled counterparts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64267a0e80b390a500ec96cdaa100f7adf548198" translate="yes" xml:space="preserve">
          <source>This module provides a general mechanism for extracting options and arguments from the command line to the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b609722b91ba2b158610f696a1988788495b0d03" translate="yes" xml:space="preserve">
          <source>This module provides arithmetic operations on complex numbers. Complex numbers are represented by their real and imaginary parts (cartesian representation). Each part is represented by a double-precision floating-point number (type &lt;code&gt;float&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19a26eb45fe7af4a376a6ae294864852d297cbea" translate="yes" xml:space="preserve">
          <source>This module provides functions to compute 128-bit 'digests' of arbitrary-length strings or files. The digests are of cryptographic quality: it is very hard, given a digest, to forge a string having that digest. The algorithm used is MD5. This module should not be used for secure and sensitive cryptographic applications. For these kind of applications more recent and stronger cryptographic primitives should be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc7540f10133c093c21edec4564acef90adfe177" translate="yes" xml:space="preserve">
          <source>This module provides functions to encode arbitrary data structures as sequences of bytes, which can then be written on a file or sent over a pipe or network connection. The bytes can then be read back later, possibly in another process, and decoded back into a data structure. The format for the byte sequences is compatible across all machines for a given version of OCaml.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bbb035f066ee24f4ebaaacb2368ebd643cd2d0c" translate="yes" xml:space="preserve">
          <source>This module provides operations on the type &lt;code&gt;int32&lt;/code&gt; of signed 32-bit integers. Unlike the built-in &lt;code&gt;int&lt;/code&gt; type, the type &lt;code&gt;int32&lt;/code&gt; is guaranteed to be exactly 32-bit wide on all platforms. All arithmetic operations over &lt;code&gt;int32&lt;/code&gt; are taken modulo 2&lt;sup&gt;32&lt;/sup&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5e7fe24e618c6feb78fd56d32e5512c8633a081" translate="yes" xml:space="preserve">
          <source>This module provides operations on the type &lt;code&gt;int64&lt;/code&gt; of signed 64-bit integers. Unlike the built-in &lt;code&gt;int&lt;/code&gt; type, the type &lt;code&gt;int64&lt;/code&gt; is guaranteed to be exactly 64-bit wide on all platforms. All arithmetic operations over &lt;code&gt;int64&lt;/code&gt; are taken modulo 2&lt;sup&gt;64&lt;/sup&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd560eafa9bf44786fbe70e70e377b41d3ae81e2" translate="yes" xml:space="preserve">
          <source>This module provides operations on the type &lt;code&gt;nativeint&lt;/code&gt; of signed 32-bit integers (on 32-bit platforms) or signed 64-bit integers (on 64-bit platforms). This integer type has exactly the same width as that of a pointer type in the C compiler. All arithmetic operations over &lt;code&gt;nativeint&lt;/code&gt; are taken modulo 2&lt;sup&gt;32&lt;/sup&gt; or 2&lt;sup&gt;64&lt;/sup&gt; depending on the word size of the architecture.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="288a280c92d0e752f41d14eee812057e14d86d83" translate="yes" xml:space="preserve">
          <source>This option has no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0fa776a935837d0195b8b526844f025d4e6ce93" translate="yes" xml:space="preserve">
          <source>This part of the manual is a tutorial introduction to the OCaml language. A good familiarity with programming in a conventional languages (say, C or Java) is assumed, but no prior exposure to functional languages is required. The present chapter introduces the core language. Chapter &lt;a href=&quot;moduleexamples#c%3Amoduleexamples&quot;&gt;2&lt;/a&gt; deals with the module system, chapter &lt;a href=&quot;objectexamples#c%3Aobjectexamples&quot;&gt;3&lt;/a&gt; with the object-oriented features, chapter &lt;a href=&quot;lablexamples#c%3Alabl-examples&quot;&gt;4&lt;/a&gt; with extensions to the core language (labeled arguments and polymorphic variants), and chapter &lt;a href=&quot;advexamples#c%3Aadvexamples&quot;&gt;6&lt;/a&gt; gives some advanced examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbc86cc4d49f38cd528229f18473c5150da317ea" translate="yes" xml:space="preserve">
          <source>This pretty-printing facility is implemented as an overlay on top of abstract &lt;a href=&quot;format#formatter&quot;&gt;formatters&lt;/a&gt; which provide basic output functions. Some formatters are predefined, notably:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a85ed63830f1cbd46d61e59847fbdc4998afedf8" translate="yes" xml:space="preserve">
          <source>This principle also applies to functions of several arguments whose return type is a type variable, as long as the role of each argument is not ambiguous. Labeling such functions may lead to awkward error messages when one attempts to omit labels in an application, as we have seen with ListLabels.fold_left.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="672f5a8d2001e1947d29714c5e2ccca5133a964a" translate="yes" xml:space="preserve">
          <source>This provides a convenient way to introduce local names for types and modules when defining a signature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93a45b4f1b855894d7e36f97483d0e12e2929c42" translate="yes" xml:space="preserve">
          <source>This reference is initially set to &lt;code&gt;false&lt;/code&gt; in standalone programs and to &lt;code&gt;true&lt;/code&gt; if the code is being executed under the interactive toplevel system &lt;code&gt;ocaml&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eb60a37765a751859069418a148aa8f84ee1892" translate="yes" xml:space="preserve">
          <source>This requires that programs to be tested are instrumented to communicate with afl-fuzz. The native-code compiler &amp;ldquo;ocamlopt&amp;rdquo; can generate such instrumentation, allowing afl-fuzz to be used against programs written in OCaml.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52dcd9a1729658eb0c6b106d0c414385be78c303" translate="yes" xml:space="preserve">
          <source>This result in the error message &amp;ldquo;expression C of type foo cannot be used with type foo&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3a02fce90d5e7f7129963fee4236b9d584135a5" translate="yes" xml:space="preserve">
          <source>This script expect to receive as an argument the directory containing the trace file. It will then copy the &lt;em&gt;CTF&lt;/em&gt; metadata file to the trace&amp;rsquo;s directory, and then decode the trace, printing each event in the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef9456a3c165c2c5114ee21374f6504d86e6983b" translate="yes" xml:space="preserve">
          <source>This second form also works for patterns:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fc3c124b4479b68cbf25dba521d9a1e132177df" translate="yes" xml:space="preserve">
          <source>This section contains some general guidelines for writing C stubs that use Windows Unicode APIs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f394592ed3600793f95e1254fcf350cda70b82c" translate="yes" xml:space="preserve">
          <source>This section describe how to make calling C functions cheaper.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5d9e3857acf6ed9216da0ef8ec0aa252128e3aa" translate="yes" xml:space="preserve">
          <source>This section describes a tool that is not yet officially supported but may be found useful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08aafc15cda9ee7ff87051d799ffe599afa951de" translate="yes" xml:space="preserve">
          <source>This section describes and explains in detail some warnings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffca379ae7271c0783a4ac241e377936af555ed8" translate="yes" xml:space="preserve">
          <source>This section describes and explains the most frequently encountered error messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31ad7ee467b01f5649ddd8facce322cfb81ef3ae" translate="yes" xml:space="preserve">
          <source>This section describes how OCaml data types are encoded in the value type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01693577ebb54a11b677d93676f308db58f638a4" translate="yes" xml:space="preserve">
          <source>This section describes the kinds of values that are manipulated by OCaml programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b36e7060d9bec0558c1823961541205abf1df8d6" translate="yes" xml:space="preserve">
          <source>This section describes unsafe, low-level conversion functions between &lt;code&gt;bytes&lt;/code&gt; and &lt;code&gt;string&lt;/code&gt;. They do not copy the internal data; used improperly, they can break the immutability invariant on strings provided by the &lt;code&gt;-safe-string&lt;/code&gt; option. They are available for expert library authors, but for most purposes you should use the always-correct &lt;a href=&quot;bytes#VALto_string&quot;&gt;&lt;code&gt;Bytes.to_string&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;bytes#VALof_string&quot;&gt;&lt;code&gt;Bytes.of_string&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a9f87ec885f096da88cc6ca28abd5b60c7d67fe" translate="yes" xml:space="preserve">
          <source>This section explains how C stub code that interfaces C or Fortran code with OCaml code can use Bigarrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71cdd8bac2c7a5aeee310523309d1c53e8523783" translate="yes" xml:space="preserve">
          <source>This section illustrates the callback facilities described in section &lt;a href=&quot;#s%3Ac-callback&quot;&gt;20.7&lt;/a&gt;. We are going to package some OCaml functions in such a way that they can be linked with C code and called from C just like any C functions. The OCaml functions are defined in the following mod.ml OCaml source:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="903aefdf9956fc71e923a3df9d4dd16dd0134747" translate="yes" xml:space="preserve">
          <source>This section lists the known incompatibilities between the bytecode compiler and the native-code compiler. Except on those points, the two compilers should generate code that behave identically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18b5904aff3b237cf95bcb17d1df036bc4ab134c" translate="yes" xml:space="preserve">
          <source>This section outlines how the functions from the Unix curses library can be made available to OCaml programs. First of all, here is the interface curses.ml that declares the curses primitives and data types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="254ed70371607b2c3851b67568dd926316b5ceae" translate="yes" xml:space="preserve">
          <source>This short notation for fields also works when constructing records:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8e400965e58bbfd6200a8deb63c3134ffb7098b" translate="yes" xml:space="preserve">
          <source>This short section is intended to clarify the relationship between the names of the modules corresponding to compilation units and the names of the files that contain their compiled interface and compiled implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24aa0094a26c8735b882dd7c464be2f2468ee6f8" translate="yes" xml:space="preserve">
          <source>This shows the use of modules to group several class definitions that can in fact be thought of as a single unit. This unit would be provided by a bank for both internal and external uses. This is implemented as a functor that abstracts over the currency so that the same code can be used to provide accounts in different currencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48666abb0d053a2e67948abc2515711d3c441749" translate="yes" xml:space="preserve">
          <source>This simplifies to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddd8a59e7fc768a0f67909566216bc17b9fded83" translate="yes" xml:space="preserve">
          <source>This syntax can be very useful when defining recursive functions involving GADTs, see the section &lt;a href=&quot;gadts#s%3Agadts&quot;&gt;8.10&lt;/a&gt; for a more detailed explanation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="606749beda23122ec62e2057e7b85c14c94a4118" translate="yes" xml:space="preserve">
          <source>This transformation discovers closure variables that are known to be equal to specialised arguments. Such closure variables are replaced by the specialised arguments; the closure variables may then be removed by the &amp;ldquo;removal of unused closure variables&amp;rdquo; pass (see below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3ca52136f921dd3470ad0eec8da036065e73e98" translate="yes" xml:space="preserve">
          <source>This transformation does not operate if it would cause the closure to contain more than twice as many closure variables as it did beforehand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a28d09c6743f0d934bbb9ee805f4686f7ff260e" translate="yes" xml:space="preserve">
          <source>This transformation is &lt;em&gt;not&lt;/em&gt; enabled by default. It may be enabled using the -unbox-closures flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4085b150ab05ea3b51f91b2bd36f0e92e0492fbb" translate="yes" xml:space="preserve">
          <source>This transformation is analogous to the removal of let-expressions whose defining expressions have no effects. It operates instead on symbol bindings, removing those that have no effects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98eeafe0734234bf6e061a4b30996bb7f31b9996" translate="yes" xml:space="preserve">
          <source>This transformation is coherent with the intended semantics, including side-effects. That is, if the application of optional parameters shall produce side-effects, these are delayed until the received function is really applied to an argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97f7301c5b5d5afefc26a2bd6bf09c3b5a77941d" translate="yes" xml:space="preserve">
          <source>This transformation is enabled unless -no-unbox-free-vars-of-closures is provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="107da9a0de966e43ce271c3dfca90682878bece5" translate="yes" xml:space="preserve">
          <source>This transformation is enabled unless -no-unbox-specialised-args is provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95f81958a03cd80819ec888b7dadbd9b19a9762f" translate="yes" xml:space="preserve">
          <source>This transformation is only enabled by default for specialised arguments. It may be enabled for all arguments using the -remove-unused-arguments flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3540291a552cb80b3485979aeb16719df0b1d80" translate="yes" xml:space="preserve">
          <source>This transformation performs an analysis across the whole compilation unit to determine whether there exist closure variables that are never used. Such closure variables are then eliminated. (Note that this has to be a whole-unit analysis because a projection of a closure variable from some particular closure may have propagated to an arbitrary location within the code due to inlining.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e83b36cd0eeacff2b0fcd7e5886d6aedf97ee77" translate="yes" xml:space="preserve">
          <source>This type allows direct access to raw backtrace slots, without any conversion in an OCaml-usable data-structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="130aa34f2abb76bf60b32cca15d066255d4d8d30" translate="yes" xml:space="preserve">
          <source>This type allows direct access to raw backtrace slots, without any conversion in an OCaml-usable data-structure. Being process-specific, they must absolutely not be marshalled, and are unsafe to use for this reason (marshalling them may not fail, but un-marshalling and using the result will result in undefined behavior).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5f42130deca30ae8346b504b0eec48ca9c2365c" translate="yes" xml:space="preserve">
          <source>This type is particularly useful when defining function that can fail in common situations, for instance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37b107ea9cfcc09f2b2be2c72335ef153d3c3763" translate="yes" xml:space="preserve">
          <source>This type is used to implement the &lt;a href=&quot;libref/lazy&quot;&gt;Lazy&lt;/a&gt; module. It should not be used directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2322d3b9d09a7e2ff55273a1e7e1bf51ca59dec" translate="yes" xml:space="preserve">
          <source>This value controls the GC messages on standard error output. It is a sum of some of the following flags, to print messages on the corresponding events:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="191b0eb7c35686bcb189014265a40f332069ddbd" translate="yes" xml:space="preserve">
          <source>This way, you can change the meaning of indentation (which can be something else than just printing space characters) and the meaning of new lines opening (which can be connected to any other action needed by the application at hand).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee3e48f0f7c49da9ec952c4fe9ffee5be36732e2" translate="yes" xml:space="preserve">
          <source>Those annotations are introduced in the format strings using the &lt;code&gt;@&lt;/code&gt; character. For instance, &lt;code&gt;@&amp;nbsp;&lt;/code&gt; means a space break, &lt;code&gt;@,&lt;/code&gt; means a cut, &lt;code&gt;@[&lt;/code&gt; opens a new box, and &lt;code&gt;@]&lt;/code&gt; closes the last open box.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0183ff3f98f4e87c7d8f00f861fde047cea5266" translate="yes" xml:space="preserve">
          <source>Those explicit type annotations can in fact be used anywhere. Most of the time they are unnecessary, but they are useful to guide disambiguation, to debug unexpected type errors, or combined with some of the more advanced features of OCaml described in later chapters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19021df6f2a2bbcef0c8a622652f87dbf2d6eed1" translate="yes" xml:space="preserve">
          <source>Though all examples so far were written in purely applicative style, OCaml is also equipped with full imperative features. This includes the usual while and for loops, as well as mutable data structures such as arrays. Arrays are either created by listing semicolon-separated element values between [| and |] brackets, or allocated and initialized with the Array.make function, then filled up later by assignments. For instance, the function below sums two vectors (represented as float arrays) componentwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7863f7503e5377891a3b7452c7d6cc377d443fe7" translate="yes" xml:space="preserve">
          <source>Thread</source>
          <target state="translated">Thread</target>
        </trans-unit>
        <trans-unit id="442734960d3874aabb05e4c0f886a1d056b06211" translate="yes" xml:space="preserve">
          <source>Thread creation and termination</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12f5360fcdde9c0092d8683e0065551e707bd34e" translate="yes" xml:space="preserve">
          <source>Thread-compatible system calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2045ffa4a6ae2e8ac2ea21859b137e4ac2c45ee5" translate="yes" xml:space="preserve">
          <source>ThreadUnix</source>
          <target state="translated">ThreadUnix</target>
        </trans-unit>
        <trans-unit id="013b2a2d89313d1cae51597fa10d83179b049eb7" translate="yes" xml:space="preserve">
          <source>Three-dimensional arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eade1edda0a702cf28e0ef4fd84c23f49efcdfd9" translate="yes" xml:space="preserve">
          <source>Three-dimensional arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d763c9a3cec94432c50184761fc6f2428e98860e" translate="yes" xml:space="preserve">
          <source>Three-dimensional arrays. The &lt;code&gt;Array3&lt;/code&gt; structure provides operations similar to those of &lt;a href=&quot;bigarray.genarray&quot;&gt;&lt;code&gt;Bigarray.Genarray&lt;/code&gt;&lt;/a&gt;, but specialized to the case of three-dimensional arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0398dff7b2f64839c1ab8aac932358f9c7ab5983" translate="yes" xml:space="preserve">
          <source>Thus, semantic tag handling is in some sense transparent to pretty-printing and does not interfere with usual indentation. Hence, a single pretty-printing routine can output both simple 'verbatim' material or richer decorated output depending on the treatment of tags. By default, tags are not active, hence the output is not decorated with tag information. Once &lt;code&gt;set_tags&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the pretty-printer engine honors tags and decorates the output accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c82e6dd86807ee3db07e3c82bec1ae1ce00b08b" translate="yes" xml:space="preserve">
          <source>Time</source>
          <target state="translated">Time</target>
        </trans-unit>
        <trans-unit id="a6a4546fd81b122915404e74cff9ee54a97e6c89" translate="yes" xml:space="preserve">
          <source>Time functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4c45de0fe64ac43c72a798c67faaadadfaa1b90" translate="yes" xml:space="preserve">
          <source>Timeout</source>
          <target state="translated">Timeout</target>
        </trans-unit>
        <trans-unit id="41bea1307711e3db755e8948c9ec2940bd8e5a31" translate="yes" xml:space="preserve">
          <source>Timeout for input operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14a1cbb733d9363c6f97fb603ebe07c1187f0c4b" translate="yes" xml:space="preserve">
          <source>Timeout for output operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79fb3076dc75c83c83101f40598cc392db271b82" translate="yes" xml:space="preserve">
          <source>Timeout in cpu time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bab4ed36a26f207c2e296f6a9bb7588c6211437f" translate="yes" xml:space="preserve">
          <source>Timeout in virtual time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="088594bde4f110fe47b51096bee5193b9d4cffe2" translate="yes" xml:space="preserve">
          <source>To adjust automatically the dimensions of the Bigarray to the actual size of the file, the major dimension (that is, the first dimension for an array with C layout, and the last dimension for an array with Fortran layout) can be given as &lt;code&gt;-1&lt;/code&gt;. &lt;code&gt;Genarray.map_file&lt;/code&gt; then determines the major dimension from the size of the file. The file must contain an integral number of sub-arrays as determined by the non-major dimensions, otherwise &lt;code&gt;Failure&lt;/code&gt; is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0661a33ab380eb57561703bce19cb91f7cdd834" translate="yes" xml:space="preserve">
          <source>To allow splitting long string literals across lines, the sequence \newlinespaces-or-tabs (a backslash at the end of a line followed by any number of spaces and horizontal tabulations at the beginning of the next line) is ignored inside string literals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="307acf24c4315e13fca20cd97aee6950796edc41" translate="yes" xml:space="preserve">
          <source>To avoid ambiguities, naming labels in expressions cannot just be defined syntactically as the sequence of the three tokens ~, &lt;a href=&quot;#ident&quot;&gt;ident&lt;/a&gt; and :, and have to be defined at the lexical level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e6b4ed52355b5293c6127fa5925601acaeaf11e" translate="yes" xml:space="preserve">
          <source>To build the whole program, just invoke the C compiler as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7c213abd6a15163ea6d392abe4c8d900d2d422d" translate="yes" xml:space="preserve">
          <source>To circumvent these dual difficulties, the type checker considers that any value returned by a function might rely on persistent mutable states behind the scene and should be given a weak type. This restriction on the type of mutable values and the results of function application is called the value restriction. Note that this value restriction is conservative: there are situations where the value restriction is too cautious and gives a weak type to a value that could be safely generalized to a polymorphic type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dfd9516db0a5f37b1ad909f49077e73f5c3d083" translate="yes" xml:space="preserve">
          <source>To compile and link this program, run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bde604309077235c564ef6bb992b73c29478ef2a" translate="yes" xml:space="preserve">
          <source>To compile everything, execute:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="463481e8191305706647c8346e602fd42723a3d3" translate="yes" xml:space="preserve">
          <source>To compile this interface:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32b3ccadf9cce9fa5117bc1b3bfac7cb3a873f7e" translate="yes" xml:space="preserve">
          <source>To define arithmetic operations for the number type, we use pattern-matching on the two numbers involved:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="327cad239718bab706e248d624ccb7ecb21c15f6" translate="yes" xml:space="preserve">
          <source>To dynamically link C code with OCaml code, the C code must first be compiled into a shared library (under Unix) or DLL (under Windows). This involves 1- compiling the C files with appropriate C compiler flags for producing position-independent code (when required by the operating system), and 2- building a shared library from the resulting object files. The resulting shared library or DLL file must be installed in a place where ocamlrun can find it later at program start-up time (see section &lt;a href=&quot;runtime#s%3Aocamlrun-dllpath&quot;&gt;11.3&lt;/a&gt;). Finally (step 3), execute the ocamlc command with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb4a49b6e92a580be3d1ce7213ac6573529cfb93" translate="yes" xml:space="preserve">
          <source>To each element kind is associated an OCaml type, which is the type of OCaml values that can be stored in the Bigarray or read back from it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7902cf653d3b6806a962d736420aac3556c0af2" translate="yes" xml:space="preserve">
          <source>To each element kind is associated an OCaml type, which is the type of OCaml values that can be stored in the Bigarray or read back from it. This type is not necessarily the same as the type of the array elements proper: for instance, a Bigarray whose elements are of kind &lt;code&gt;float32_elt&lt;/code&gt; contains 32-bit single precision floats, but reading or writing one of its elements from OCaml uses the OCaml type &lt;code&gt;float&lt;/code&gt;, which is 64-bit double precision floats.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec8d6d0f0d08a9fa9eb4faaf97e838ad337fba45" translate="yes" xml:space="preserve">
          <source>To facilitate interoperability with existing C and Fortran code, this library supports two different memory layouts for Bigarrays, one compatible with the C conventions, the other compatible with the Fortran conventions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9440719805fd4d3883c45311f6d371026f97469" translate="yes" xml:space="preserve">
          <source>To fuzz a large system without modifying build tools, OCaml&amp;rsquo;s configure script also accepts the afl-instrument option. If OCaml is configured with afl-instrument, then all programs compiled by ocamlopt will be instrumented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d49cf83522e4dd02edaed17398bc3794092a3e6c" translate="yes" xml:space="preserve">
          <source>To generate a bytecode executable that runs on this runtime system, do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7d984b677b59e1ba119d9e288d010f2047bf07c" translate="yes" xml:space="preserve">
          <source>To handle custom tags, you need to define a custom generator, as explained in section &lt;a href=&quot;#ss%3Aocamldoc-handling-custom-tags&quot;&gt;16.3.2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a226b13d5aac9e91dcb364c97e1b727eb95a790b" translate="yes" xml:space="preserve">
          <source>To help you diagnose this error, run your program with the -v option to ocamlrun, or with the OCAMLRUNPARAM environment variable set to v=63. If it displays lots of &amp;ldquo;Growing stack&amp;hellip;&amp;rdquo; messages, this is probably a looping recursive function. If it displays lots of &amp;ldquo;Growing heap&amp;hellip;&amp;rdquo; messages, with the heap size growing slowly, this is probably an attempt to construct a data structure with too many (infinitely many?) cells. If it displays few &amp;ldquo;Growing heap&amp;hellip;&amp;rdquo; messages, but with a huge increment in the heap size, this is probably an attempt to build an excessively large array, string or byte sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2372771b07a4d167928768e2a883bc383b6e0f5" translate="yes" xml:space="preserve">
          <source>To illustrate the rules above, here is a C function that builds and returns a list containing the two integers given as parameters. First, we write it using the simplified allocation functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9316bbb60ea8ce0b1c90bf6112d6e8ade80ba7a" translate="yes" xml:space="preserve">
          <source>To implement these functions, we just have to provide the stub code; the core functions are already implemented in the curses library. The stub code file, curses_stubs.c, looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b952e965e16326f8fe35cdcad00515932cf1d1ca" translate="yes" xml:space="preserve">
          <source>To keep the generated automata small, rewrite those definitions with only one general &amp;ldquo;identifier&amp;rdquo; rule, followed by a hashtable lookup to separate keywords from identifiers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a23cb4ea2cf58c9454eccc5177ac6f043e990101" translate="yes" xml:space="preserve">
          <source>To keep the relaxed value restriction, we need to declare the abstract type 'a COLLECTION.t as covariant in 'a:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5d11a9162bbc283c3d1d5bcb248f5b1b6ede824" translate="yes" xml:space="preserve">
          <source>To keep track of operations, we extend the class with a mutable field history and a private method trace to add an operation in the log. Then each method to be traced is redefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48e8a007425ee0f5fee02a060cc2a2384efe46e2" translate="yes" xml:space="preserve">
          <source>To know which methods to override and/or which methods are available, have a look at the different base implementations, depending on the kind of generator you are extending :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bff8eee99072881c7dd4af3c5fa1af20b5deb63a" translate="yes" xml:space="preserve">
          <source>To link in &amp;ldquo;custom runtime&amp;rdquo; mode, execute the ocamlc command with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dc12bb0039399b2211b5edf87b77c3207cbfd57" translate="yes" xml:space="preserve">
          <source>To make sure your programs can be compiled in profiling mode, avoid using any identifier that begins with __ocaml_prof.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c8e4b280c7f58e4764b54d8abccf82639d2ae14" translate="yes" xml:space="preserve">
          <source>To make this even more comfortable, you may use type definitions as abbreviations for or-patterns. That is, if you have defined type myvariant = [`Tag1 of int | `Tag2 of bool], then the pattern #myvariant is equivalent to writing (`Tag1(_ : int) | `Tag2(_ : bool)).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a622ca9104700efc8eba27769d5e6eccf540e9b" translate="yes" xml:space="preserve">
          <source>To read the byte representation of a marshaled value into a byte sequence, the program needs to read first &lt;a href=&quot;marshal#VALheader_size&quot;&gt;&lt;code&gt;Marshal.header_size&lt;/code&gt;&lt;/a&gt; bytes into the sequence, then determine the length of the remainder of the representation using &lt;a href=&quot;marshal#VALdata_size&quot;&gt;&lt;code&gt;Marshal.data_size&lt;/code&gt;&lt;/a&gt;, make sure the sequence is large enough to hold the remaining data, then read it, and finally call &lt;a href=&quot;marshal#VALfrom_bytes&quot;&gt;&lt;code&gt;Marshal.from_bytes&lt;/code&gt;&lt;/a&gt; to unmarshal the value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c72d4392ca2173a1c9eef1f69d8ad84c58d851ec" translate="yes" xml:space="preserve">
          <source>To reason about the use of &lt;code&gt;unsafe_to_string&lt;/code&gt;, it is convenient to consider an &quot;ownership&quot; discipline. A piece of code that manipulates some data &quot;owns&quot; it; there are several disjoint ownership modes, including:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a7157f5deddeacc7b51617138d7fd940b256e41" translate="yes" xml:space="preserve">
          <source>To solve our problem, we can therefore use either the record solution:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4019cbcbaea339fe27aab76ebea9127bab9094f" translate="yes" xml:space="preserve">
          <source>To solve this error, it is enough to add an explicit type annotation to specify the type at declaration time:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f25f95dc627a388c949e54ad1e4876e37a5fdec0" translate="yes" xml:space="preserve">
          <source>To speak in an &amp;ldquo;object-oriented&amp;rdquo; way, one can consider that each function has a main argument, its &lt;em&gt;object&lt;/em&gt;, and other arguments related with its action, the &lt;em&gt;parameters&lt;/em&gt;. To permit the combination of functions through functionals in commuting label mode, the object will not be labeled. Its role is clear from the function itself. The parameters are labeled with names reminding of their nature or their role. The best labels combine nature and role. When this is not possible the role is to be preferred, since the nature will often be given by the type itself. Obscure abbreviations should be avoided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="387ff33570962c3e8b5dedb0a388bccd5c1fb297" translate="yes" xml:space="preserve">
          <source>To use Spacetime it is necessary to use an OCaml compiler that was configured with the -spacetime option. It is not possible to select Spacetime on a per-source-file basis or for a subset of files in a project; all files involved in the executable being profiled must be built with the Spacetime compiler. Only native code compilation is supported (not bytecode).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed32f07860215af085ff436b7b7306a6815a9b78" translate="yes" xml:space="preserve">
          <source>To use the Flambda optimisers it is necessary to pass the -flambda option to the OCaml configure script. (There is no support for a single compiler that can operate in both Flambda and non-Flambda modes.) Code compiled with Flambda cannot be linked into the same program as code compiled without Flambda. Attempting to do this will result in a compiler error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25cebac05e12b33d1c5325eeaabd74f6b15cffcb" translate="yes" xml:space="preserve">
          <source>To use the functions in this module you must:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a3b40c35ac9b4dbb1547ab6397d847d576919f6" translate="yes" xml:space="preserve">
          <source>To use this function, one can wrap the Set.Make functor:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e279465e252c0b80c2d1a6c8e50d696d2db937f5" translate="yes" xml:space="preserve">
          <source>To write C code that operates on OCaml values, the following include files are provided:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="659d8a056102ffd377f0cdfc671961480711f61a" translate="yes" xml:space="preserve">
          <source>Together, the relaxed value restriction and type parameter covariance help to avoid eta-expansion in many situations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56dbc78473450158f36bd54d125933d056ecd869" translate="yes" xml:space="preserve">
          <source>Tokens and rules have precedences. By default, the precedence of a rule is the precedence of its rightmost terminal. You can override this default by using the %prec directive in the rule.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e0d2eef3cc8719301cd02a8aeecb9e956e88cf1" translate="yes" xml:space="preserve">
          <source>Too many levels of symbolic links</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4113b4c9ebd053469430304ab17dc16ea1d01df9" translate="yes" xml:space="preserve">
          <source>Too many links</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5736e6c11ff6d9830fab68fdeb2e9c96cdae31d6" translate="yes" xml:space="preserve">
          <source>Too many open files by the process</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="529311e8fdf6ab2db0e809d7fbb676ae1d82a50d" translate="yes" xml:space="preserve">
          <source>Too many open files in the system</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="282e2b703da2ac14021b09f04b30fd7f814e033a" translate="yes" xml:space="preserve">
          <source>Too many references: can't splice</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15521e66130383b230f739bb2fc49edfc0a24250" translate="yes" xml:space="preserve">
          <source>Toplevel</source>
          <target state="translated">Toplevel</target>
        </trans-unit>
        <trans-unit id="52271cb5a0a7ab67a42426df16b8f5309e544d7d" translate="yes" xml:space="preserve">
          <source>Toplevel let-expressions may be lifted to symbol bindings to ensure that the corresponding bound variables are not captured by closures. If the defining expression of a given binding is found to be constant, it is bound as such (the technical term is a &lt;em&gt;let-symbol&lt;/em&gt; binding).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a44cf452ae377637373f10a091314197af5f0b33" translate="yes" xml:space="preserve">
          <source>Toplevel phrases can refer to identifiers defined in compilation units with the same mechanisms as for separately compiled units: either by using qualified names (Modulename.localname), or by using the open construct and unqualified names (see section &lt;a href=&quot;names#s%3Anames&quot;&gt;7.3&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06d983275acca4ebd956f4ca99271a34f2702b6e" translate="yes" xml:space="preserve">
          <source>Total ordering between maps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d503224bdd1f64388674e9ce0a963f9f4e37ff2" translate="yes" xml:space="preserve">
          <source>Total ordering between maps. The first argument is a total ordering used to compare data associated with equal keys in the two maps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2d7c3d7b4f4e20c4b6494fc8ea71a5bcb4f2aaf" translate="yes" xml:space="preserve">
          <source>Total ordering between sets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f44baf07265ef300d210f7ea6b516756e51c1c5" translate="yes" xml:space="preserve">
          <source>Total ordering between sets. Can be used as the ordering function for doing sets of sets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34336f2b5f5540478a6b0046d27bf02690c7c02c" translate="yes" xml:space="preserve">
          <source>Total size of the major heap, in words.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75ce6b1a588e98221c2bce1023520067bc5af6c3" translate="yes" xml:space="preserve">
          <source>Trace/breakpoint trap</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24d86e87d3b5c7cc8eaa531c471cc6fe6401e236" translate="yes" xml:space="preserve">
          <source>Traces generated by the instrumented runtime can be analyzed with tooling available outside of the OCaml distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68c508431455ff22684105af9cb2ecc131f7e321" translate="yes" xml:space="preserve">
          <source>Tracing</source>
          <target state="translated">Tracing</target>
        </trans-unit>
        <trans-unit id="8a199b624500a34255a39172a77785f3c1196171" translate="yes" xml:space="preserve">
          <source>Transform a list of pairs into a pair of lists: &lt;code&gt;split&amp;nbsp;[(a1,b1);&amp;nbsp;...;&amp;nbsp;(an,bn)]&lt;/code&gt; is &lt;code&gt;([a1;&amp;nbsp;...;&amp;nbsp;an],&amp;nbsp;[b1;&amp;nbsp;...;&amp;nbsp;bn])&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32401d5fba7510cc4407d77e41ee1d2a4fb4a675" translate="yes" xml:space="preserve">
          <source>Transform a list of pairs into a pair of lists: &lt;code&gt;split&amp;nbsp;[(a1,b1);&amp;nbsp;...;&amp;nbsp;(an,bn)]&lt;/code&gt; is &lt;code&gt;([a1;&amp;nbsp;...;&amp;nbsp;an],&amp;nbsp;[b1;&amp;nbsp;...;&amp;nbsp;bn])&lt;/code&gt;. Not tail-recursive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49a801d0a362583e8d49cf49a6efc625d6c92a83" translate="yes" xml:space="preserve">
          <source>Transform a pair of lists into a list of pairs: &lt;code&gt;combine&amp;nbsp;[a1;&amp;nbsp;...;&amp;nbsp;an]&amp;nbsp;[b1;&amp;nbsp;...;&amp;nbsp;bn]&lt;/code&gt; is &lt;code&gt;[(a1,b1);&amp;nbsp;...;&amp;nbsp;(an,bn)]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50dd5a15a0cecf0dd0826019c37ba6dc26f6bc64" translate="yes" xml:space="preserve">
          <source>Traverse the sequence from left to right, combining each element with the accumulator using the given function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4688d50f3f86cb62a80baee37bcad030269d2b74" translate="yes" xml:space="preserve">
          <source>Traverse the sequence from left to right, combining each element with the accumulator using the given function. The traversal happens immediately and will not terminate on infinite sequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5951a92d20e1af5270ceec7e9317847694484ddf" translate="yes" xml:space="preserve">
          <source>Treat Ocamldoc warnings as errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="417c217dcd227caf02540a67a10ab8cd2a50b328" translate="yes" xml:space="preserve">
          <source>Treat as errors the warnings enabled by the argument and as normal warnings the warnings disabled by the argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66debbd01f97db729dc454195e358bf429f9ece9" translate="yes" xml:space="preserve">
          <source>Trigger a minor collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09b695cc0fd391daf36faf1963153e5b6cb4a3b9" translate="yes" xml:space="preserve">
          <source>Triggering finalization of allocated custom blocks (see section &lt;a href=&quot;#s%3Ac-custom&quot;&gt;20.9&lt;/a&gt;). For example, Stdlib.in_channel and Stdlib.out_channel are represented by custom blocks that enclose file descriptors, which are to be released.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6e79023b8ee1b35da3de1efb771fce6d418e7dd" translate="yes" xml:space="preserve">
          <source>Triple the default</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed552aedd0ce3f370d321354a40788014425b26f" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;Sys.os_type&amp;nbsp;=&amp;nbsp;&quot;Cygwin&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2e10371a9b7e6b5bec4cec1afb346e6fcf56c47" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;Sys.os_type&amp;nbsp;=&amp;nbsp;&quot;Unix&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c18358e3f16eb9b759e71c30fca9e2c6ee55d3a" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;Sys.os_type&amp;nbsp;=&amp;nbsp;&quot;Win32&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="532fe6ed68fa8e3a71fd02229c84119658bc5ab3" translate="yes" xml:space="preserve">
          <source>Truncate the given floating-point number to an integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a10351d651cbeb488e200041e184f6200f9b609" translate="yes" xml:space="preserve">
          <source>Truncate the given floating-point number to an integer. The result is unspecified if the argument is &lt;code&gt;nan&lt;/code&gt; or falls outside the range of representable integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93981b89548137dc81009ceab881823b9341006a" translate="yes" xml:space="preserve">
          <source>Truncate to 0 length if existing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fed15abd46a43c683f271305b8f42f5b17141ef" translate="yes" xml:space="preserve">
          <source>Truncated bytecode file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5002c1234c7b95d88482d1369e0f6d0a4591c59b" translate="yes" xml:space="preserve">
          <source>Truncates the file corresponding to the given descriptor to the given size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0347bdb2507eb59f16d15ec102ff4098f3d5b35" translate="yes" xml:space="preserve">
          <source>Truncates the named file to the given size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35c43375c1d65c34fdff7dac4166175da7ec333a" translate="yes" xml:space="preserve">
          <source>Tuples are represented by pointers to blocks, with tag 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fb08f9372966ada62d75d5d7d46f41e9ec29633" translate="yes" xml:space="preserve">
          <source>Tuples of values are written (v&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;,v&lt;sub&gt;n&lt;/sub&gt;), standing for the n-tuple of values v&lt;sub&gt;1&lt;/sub&gt; to v&lt;sub&gt;n&lt;/sub&gt;. The current implementation supports tuple of up to 2&lt;sup&gt;22&lt;/sup&gt; &amp;minus; 1 elements (4194303 elements).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec1382e4b69cd24377b95330f6e9bb58114f7bac" translate="yes" xml:space="preserve">
          <source>Turn bound checking off for array and string accesses (the v.(i) and s.[i] constructs). Programs compiled with -unsafe are therefore faster, but unsafe: anything can happen if the program accesses an array or string outside of its bounds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2a661500df8d1ec062b5d1e38538b3068fc8971" translate="yes" xml:space="preserve">
          <source>Turn bound checking off for array and string accesses (the v.(i) and s.[i] constructs). Programs compiled with -unsafe are therefore faster, but unsafe: anything can happen if the program accesses an array or string outside of its bounds. Additionally, turn off the check for zero divisor in integer division and modulus operations. With -unsafe, an integer division (or modulus) by zero can halt the program or continue with an unspecified result instead of raising a Division_by_zero exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9976aabbd5a9c1ab1aeea83f7f9166b0d664e3c3" translate="yes" xml:space="preserve">
          <source>Turn bound checking off for array and string accesses (the v.(i) and s.[i] constructs). Programs compiled with -unsafe are therefore slightly faster, but unsafe: anything can happen if the program accesses an array or string outside of its bounds. Additionally, turn off the check for zero divisor in integer division and modulus operations. With -unsafe, an integer division (or modulus) by zero can halt the program or continue with an unspecified result instead of raising a Division_by_zero exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="711678e3efb5338f51272a8b5178317c676c89f3" translate="yes" xml:space="preserve">
          <source>Two class type definitions match if they have the same type parameters and they expand to matching types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa4a19d22a2815840c01d0e4fbe627ac1ec3b2ca" translate="yes" xml:space="preserve">
          <source>Two functions are provided to raise two standard exceptions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1661242be978210d8d5a1f77691405122d60e821" translate="yes" xml:space="preserve">
          <source>Two implementations of the threads library are available, depending on the capabilities of the operating system:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8cefc13e3d298c2bb25661b6f6aa2482f697297" translate="yes" xml:space="preserve">
          <source>Two labels or constructors of the same name are defined in two mutually recursive types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48d9c23b1cb7383bf898c8101cacf467f4231973" translate="yes" xml:space="preserve">
          <source>Two parameters &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;len&lt;/code&gt; are said to designate a valid range of &lt;code&gt;s&lt;/code&gt; if &lt;code&gt;len&amp;nbsp;&amp;gt;=&amp;nbsp;0&lt;/code&gt; and &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;start+len&lt;/code&gt; are valid positions in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d67b45c324770bcbf92f640297940d5a30dc1257" translate="yes" xml:space="preserve">
          <source>Two parameters &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;len&lt;/code&gt; are said to designate a valid substring of &lt;code&gt;s&lt;/code&gt; if &lt;code&gt;len&amp;nbsp;&amp;gt;=&amp;nbsp;0&lt;/code&gt; and &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;start+len&lt;/code&gt; are valid positions in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1ad4c7ee77f98430fd3a05a3935346ecc6ed421" translate="yes" xml:space="preserve">
          <source>Two syntactic forms are provided to define functions. The first form is introduced by the keyword function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="019322ca2a87bdfa6e229ab6eaabec2277045691" translate="yes" xml:space="preserve">
          <source>Two-dimensional arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6efde7c3ec175b7e2cd302f767b8885955c43c8f" translate="yes" xml:space="preserve">
          <source>Two-dimensional arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea97efc84b08c1dfa5507328a9a5eb75811c2159" translate="yes" xml:space="preserve">
          <source>Two-dimensional arrays. The &lt;code&gt;Array2&lt;/code&gt; structure provides operations similar to those of &lt;a href=&quot;bigarray.genarray&quot;&gt;&lt;code&gt;Bigarray.Genarray&lt;/code&gt;&lt;/a&gt;, but specialized to the case of two-dimensional arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44a966b34064ea2bde71d174110a293dd3641eb6" translate="yes" xml:space="preserve">
          <source>Type abbreviation: an equation =&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;, no representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9c2db94655456061e2fda2d94f1456bf5e6dcae" translate="yes" xml:space="preserve">
          <source>Type abbreviation: an equation, no representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbd26433f35fa9fba1fb5a1c64fd536c78f13267" translate="yes" xml:space="preserve">
          <source>Type abbreviations are not expanded when determining the arity of a primitive. For instance,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ce1ff79a0b7e3f45e08e886eab851d95ab4453e" translate="yes" xml:space="preserve">
          <source>Type argument &lt;code&gt;'b&lt;/code&gt; is also the type of the first argument given to user's defined printing functions for &lt;code&gt;%a&lt;/code&gt; and &lt;code&gt;%t&lt;/code&gt; conversions, and user's defined reading functions for &lt;code&gt;%r&lt;/code&gt; conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebbbc6fe5700486ef983078c89b775200e1dfb7c" translate="yes" xml:space="preserve">
          <source>Type constraint on GADT type declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d901f4220b65f3d70d012f9e484a31bb0b370e19" translate="yes" xml:space="preserve">
          <source>Type constructor application</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="644e74ab904e55997d610fce5e77162948201c5e" translate="yes" xml:space="preserve">
          <source>Type constructors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="008b7ad7f73c68a43133ccff9ec196e28074c36f" translate="yes" xml:space="preserve">
          <source>Type constructors with no parameter, as in &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt;, are type expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41e19918330a4b7e92b3dee85f135d9b90408d4a" translate="yes" xml:space="preserve">
          <source>Type declaration defining a new &amp;rsquo;()&amp;rsquo; constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="383e22354516abb8dd98b4675030118fe6e23fbe" translate="yes" xml:space="preserve">
          <source>Type definitions are introduced by the type keyword, and consist in one or several simple definitions, possibly mutually recursive, separated by the and keyword. Each simple definition defines one type constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80012d2e3c018c87cbaf804ec7fb6ccc51f86ae0" translate="yes" xml:space="preserve">
          <source>Type definitions bind type constructors to data types: either variant types, record types, type abbreviations, or abstract data types. They also bind the value constructors and record fields associated with the definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cad2e5ed527706c404fda008c0fbc43d1739bde" translate="yes" xml:space="preserve">
          <source>Type expressions denote types in definitions of data types as well as in type constraints over patterns and expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f54858a82ae6c361b165ee97f22098dea3856f8" translate="yes" xml:space="preserve">
          <source>Type inference for GADTs is notoriously hard. This is due to the fact some types may become ambiguous when escaping from a branch. For instance, in the Int case above, n could have either type int or a, and they are not equivalent outside of that branch. As a first approximation, type inference will always work if a pattern-matching is annotated with types containing no free type variables (both on the scrutinee and the return type). This is the case in the above example, thanks to the type annotation containing only locally abstract types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c41d15644bc0e4699a63b1fcbb73b5b965f20ee" translate="yes" xml:space="preserve">
          <source>Type of formatted input functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cf6e53f9d2885b8ecaefaa805ee9c2e406ebfb7" translate="yes" xml:space="preserve">
          <source>Type representing a file that will hold a series of heap snapshots together with additional information required to interpret those snapshots.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a1fb7e38670879b0890b7b24f14acf10d4a824d" translate="yes" xml:space="preserve">
          <source>Type variables ('a, 'b, &amp;hellip;) in a type t can be in either of two states: generalized (which means that the type t is valid for all possible instantiations of the variables) and not generalized (which means that the type t is valid only for one instantiation of the variables). In a let binding let name = expr, the type-checker normally generalizes as many type variables as possible in the type of expr. However, this leads to unsoundness (a well-typed program can crash) in conjunction with polymorphic mutable data structures. To avoid this, generalization is performed at let bindings only if the bound expression expr belongs to the class of &amp;ldquo;syntactic values&amp;rdquo;, which includes constants, identifiers, functions, tuples of syntactic values, etc. In all other cases (for instance, expr is a function application), a polymorphic mutable could have been created and generalization is therefore turned off for all variables occurring in contravariant or non-variant branches of the type. For instance, if the type of a non-value is 'a list the variable is generalizable (list is a covariant type constructor), but not in 'a list -&amp;gt; 'a list (the left branch of -&amp;gt; is contravariant) or 'a ref (ref is non-variant).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e3aef53774c7f5b428263ee8017835db5f94f3b" translate="yes" xml:space="preserve">
          <source>Type without principality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7abe567be65d268f3a2696a5729946c3839700c3" translate="yes" xml:space="preserve">
          <source>Type-checking polymorphic variants is a subtle thing, and some expressions may result in more complex type information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd209f835b431620f2f7a16a1700ed3f687e554d" translate="yes" xml:space="preserve">
          <source>Type-level module aliases are used when checking module path equalities. That is, in a context where module name N is known to be an alias for P, not only these two module paths check as equal, but F (N) and F (P) are also recognized as equal. In the default compilation mode, this is the only difference with the previous approach of module aliases having just the same module type as the module they reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="482b5d3e58f932060fa84ae1f7437ed62a8c84a5" translate="yes" xml:space="preserve">
          <source>Typing an interrupt character (usually ctrl-C) will not exit the debugger, but will terminate the action of any debugger command that is in progress and return to the debugger command level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2c7c0caa10a0cca5ea7d69e54018ae0c0389dd6" translate="yes" xml:space="preserve">
          <source>U</source>
          <target state="translated">U</target>
        </trans-unit>
        <trans-unit id="c285dbae8ad75c11cf03e8d284872209563d4ef3" translate="yes" xml:space="preserve">
          <source>Uchar</source>
          <target state="translated">Uchar</target>
        </trans-unit>
        <trans-unit id="b677e5fef1be6d058b58bf6826880d3b971e64ab" translate="yes" xml:space="preserve">
          <source>Unary addition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f695fa2b2a0f97bac964e65828d440f3804af708" translate="yes" xml:space="preserve">
          <source>Unary addition. You can also write &lt;code&gt;+&amp;nbsp;e&lt;/code&gt; instead of &lt;code&gt;~+&amp;nbsp;e&lt;/code&gt;. Unary operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f4484029bc001a1c51bfcd0596481e4db8652c6" translate="yes" xml:space="preserve">
          <source>Unary addition. You can also write &lt;code&gt;+.&amp;nbsp;e&lt;/code&gt; instead of &lt;code&gt;~+.&amp;nbsp;e&lt;/code&gt;. Unary operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63b13d71007c4da2df4ac38a9e58dea596e4161f" translate="yes" xml:space="preserve">
          <source>Unary negation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95141f64f4298daa6ecac13e37d4f744cc2fc09d" translate="yes" xml:space="preserve">
          <source>Unary negation. You can also write &lt;code&gt;-&amp;nbsp;e&lt;/code&gt; instead of &lt;code&gt;~-&amp;nbsp;e&lt;/code&gt;. Unary operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a731455f59ced6b1f05e17234de09ab409ca508" translate="yes" xml:space="preserve">
          <source>Unary negation. You can also write &lt;code&gt;-.&amp;nbsp;e&lt;/code&gt; instead of &lt;code&gt;~-.&amp;nbsp;e&lt;/code&gt;. Unary operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65bc523ce5f481e4e4e3e37f7a2972ec888003bf" translate="yes" xml:space="preserve">
          <source>Unboxable type in primitive declaration.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
