<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="trio">
    <body>
      <group id="trio">
        <trans-unit id="3ebacba51b60d5a007ce59beb654e883261ff033" translate="yes" xml:space="preserve">
          <source>Memory channels are lightweight, cheap to allocate, and entirely in-memory. They don&amp;rsquo;t involve any operating-system resources, or any kind of serialization. They just pass Python objects directly between tasks (with a possible stop in an internal buffer along the way).</source>
          <target state="translated">Los canales de memoria son livianos, econ&amp;oacute;micos de asignar y est&amp;aacute;n completamente en memoria. No implican ning&amp;uacute;n recurso del sistema operativo ni ning&amp;uacute;n tipo de serializaci&amp;oacute;n. Simplemente pasan objetos de Python directamente entre tareas (con una posible parada en un b&amp;uacute;fer interno en el camino).</target>
        </trans-unit>
        <trans-unit id="3cb22c5e4eabc0e7d3ccf2b60e66f53421b63149" translate="yes" xml:space="preserve">
          <source>Module Index</source>
          <target state="translated">Índice del módulo</target>
        </trans-unit>
        <trans-unit id="8d872704047e831df65df9aed5d46fc4c57e9bb3" translate="yes" xml:space="preserve">
          <source>Most errors coming from &lt;a href=&quot;#trio.abc.Listener.accept&quot;&gt;&lt;code&gt;accept()&lt;/code&gt;&lt;/a&gt; are allowed to propagate out (crashing the server in the process). However, some errors &amp;ndash; those which indicate that the server is temporarily overloaded &amp;ndash; are handled specially. These are &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt;s with one of the following errnos:</source>
          <target state="translated">La mayor&amp;iacute;a de los errores que provienen de &lt;a href=&quot;#trio.abc.Listener.accept&quot;&gt; &lt;code&gt;accept()&lt;/code&gt; &lt;/a&gt; pueden propagarse (bloqueando el servidor en el proceso). Sin embargo, algunos errores, aquellos que indican que el servidor est&amp;aacute; sobrecargado temporalmente, se manejan de manera especial. Estos son &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; s con uno de los siguientes errnos:</target>
        </trans-unit>
        <trans-unit id="a8cd11a5ccaa1971cc54179d399d4e54a3915836" translate="yes" xml:space="preserve">
          <source>Most libraries for concurrent programming let you start new child tasks (or threads, or whatever) willy-nilly, whenever and where-ever you feel like it. Trio is a bit different: you can&amp;rsquo;t start a child task unless you&amp;rsquo;re prepared to be a responsible parent. The way you demonstrate your responsibility is by creating a nursery:</source>
          <target state="translated">La mayor&amp;iacute;a de las bibliotecas para programaci&amp;oacute;n concurrente le permiten iniciar nuevas tareas secundarias (o subprocesos, o lo que sea) de cualquier manera, cuando y donde quiera. Trio es un poco diferente: no puede iniciar una tarea secundaria a menos que est&amp;eacute; preparado para ser un padre responsable. La forma en que demuestra su responsabilidad es creando un vivero:</target>
        </trans-unit>
        <trans-unit id="faa7a87e100ccbf148f4d32180dde3f6a74122cc" translate="yes" xml:space="preserve">
          <source>Most low-level operations in Trio provide a guarantee: if they raise &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt;&lt;code&gt;trio.Cancelled&lt;/code&gt;&lt;/a&gt;, this means that they had no effect, so the system remains in a known state. This is &lt;strong&gt;not true&lt;/strong&gt; for &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt;. If this operation raises &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt;&lt;code&gt;trio.Cancelled&lt;/code&gt;&lt;/a&gt; (or any other exception for that matter), then it may have sent some, all, or none of the requested data, and there is no way to know which.</source>
          <target state="translated">La mayor&amp;iacute;a de las operaciones de bajo nivel en Trio brindan una garant&amp;iacute;a: si suben &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt; &lt;code&gt;trio.Cancelled&lt;/code&gt; &lt;/a&gt; , esto significa que no tuvieron ning&amp;uacute;n efecto, por lo que el sistema permanece en un estado conocido. Esto &lt;strong&gt;no&lt;/strong&gt; es &lt;strong&gt;cierto&lt;/strong&gt; para &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt; . Si esta operaci&amp;oacute;n genera &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt; &lt;code&gt;trio.Cancelled&lt;/code&gt; &lt;/a&gt; (o cualquier otra excepci&amp;oacute;n para el caso), entonces puede haber enviado algunos, todos o ninguno de los datos solicitados, y no hay forma de saber cu&amp;aacute;l.</target>
        </trans-unit>
        <trans-unit id="93b72a6b4349c6293f75d57aad8d0127982f3ec5" translate="yes" xml:space="preserve">
          <source>Most users won&amp;rsquo;t need this, but it may be useful on cleanup paths where you can&amp;rsquo;t afford to block, or if you want to close a resource and don&amp;rsquo;t care about handling it gracefully. For example, if &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; encounters an error and cannot perform its own graceful close, then there&amp;rsquo;s no point in waiting to gracefully shut down the underlying transport either, so it calls &lt;code&gt;await
aclose_forcefully(self.transport_stream)&lt;/code&gt;.</source>
          <target state="translated">La mayor&amp;iacute;a de los usuarios no necesitar&amp;aacute;n esto, pero puede ser &amp;uacute;til en rutas de limpieza donde no puede permitirse bloquear, o si desea cerrar un recurso y no le importa manejarlo con elegancia. Por ejemplo, si &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; encuentra un error y no puede realizar su propio cierre elegante, tampoco tiene sentido esperar para cerrar &lt;code&gt;await aclose_forcefully(self.transport_stream)&lt;/code&gt; el transporte subyacente, por lo que llama a await aclose_forcefully (self.transport_stream) .</target>
        </trans-unit>
        <trans-unit id="263333d23c256397b1932a66d3b96bed36f57e27" translate="yes" xml:space="preserve">
          <source>Move all parked tasks from one &lt;a href=&quot;#trio.hazmat.ParkingLot&quot;&gt;&lt;code&gt;ParkingLot&lt;/code&gt;&lt;/a&gt; object to another.</source>
          <target state="translated">Mueva todas las tareas estacionadas de un objeto &lt;a href=&quot;#trio.hazmat.ParkingLot&quot;&gt; &lt;code&gt;ParkingLot&lt;/code&gt; &lt;/a&gt; a otro.</target>
        </trans-unit>
        <trans-unit id="619690fbed77efc44030c3504079aab00d9bb921" translate="yes" xml:space="preserve">
          <source>Move all parked tasks from one &lt;a href=&quot;#trio.lowlevel.ParkingLot&quot;&gt;&lt;code&gt;ParkingLot&lt;/code&gt;&lt;/a&gt; object to another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7821f30476ccc057b781233fe6a409ab7b1f821" translate="yes" xml:space="preserve">
          <source>Move parked tasks from one &lt;a href=&quot;#trio.hazmat.ParkingLot&quot;&gt;&lt;code&gt;ParkingLot&lt;/code&gt;&lt;/a&gt; object to another.</source>
          <target state="translated">Mueva las tareas estacionadas de un objeto &lt;a href=&quot;#trio.hazmat.ParkingLot&quot;&gt; &lt;code&gt;ParkingLot&lt;/code&gt; &lt;/a&gt; a otro.</target>
        </trans-unit>
        <trans-unit id="7fa5abfcacdb7e2dfa0086da84bb92b17fb12649" translate="yes" xml:space="preserve">
          <source>Move parked tasks from one &lt;a href=&quot;#trio.lowlevel.ParkingLot&quot;&gt;&lt;code&gt;ParkingLot&lt;/code&gt;&lt;/a&gt; object to another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e51ee94727e41fe8b7acbe58d00c5e01c684e5b" translate="yes" xml:space="preserve">
          <source>Multi-Core/Multiprocessing</source>
          <target state="translated">Multi-Core/Multiprocessing</target>
        </trans-unit>
        <trans-unit id="8bad03d4f386e821713ff697a351c0c7fddba714" translate="yes" xml:space="preserve">
          <source>Networking with Trio</source>
          <target state="translated">La red con el Trío</target>
        </trans-unit>
        <trans-unit id="b4930210ef1616963a4cb50a56f5073c0e556155" translate="yes" xml:space="preserve">
          <source>No need to think about threads: your Trio code runs in the same thread as the host event loop, so you can freely call sync Trio APIs from the host, and call sync host APIs from Trio. For example, if you&amp;rsquo;re making a GUI app with Qt as the host loop, then making a &lt;a href=&quot;https://doc.qt.io/qt-5/qpushbutton.html&quot;&gt;cancel button&lt;/a&gt; and connecting it to a &lt;a href=&quot;reference-core#trio.CancelScope&quot;&gt;&lt;code&gt;trio.CancelScope&lt;/code&gt;&lt;/a&gt; is as easy as writing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ef93032cd6cb3e1deb49d648d00e034030e5fed" translate="yes" xml:space="preserve">
          <source>Normally, a Trio task doesn&amp;rsquo;t exit until its coroutine object exits. When you call this function, Trio acts like the coroutine object just exited and the task terminates with the given outcome. This is useful if you want to permanently switch the coroutine object over to a different coroutine runner.</source>
          <target state="translated">Normalmente, una tarea Trio no sale hasta que sale su objeto de rutina. Cuando llama a esta funci&amp;oacute;n, Trio act&amp;uacute;a como si el objeto de rutina acabara de salir y la tarea termina con el resultado dado. Esto es &amp;uacute;til si desea cambiar permanentemente el objeto de corrutina a un corredor de corrutina diferente.</target>
        </trans-unit>
        <trans-unit id="498e98b1248914319c5ba185502949174d8f34bb" translate="yes" xml:space="preserve">
          <source>Normally, in Python, only one thing happens at a time, which means that only one thing can wrong at a time. Trio has no such limitation. Consider code like:</source>
          <target state="translated">Normalmente,en Python,sólo ocurre una cosa a la vez,lo que significa que sólo una cosa puede equivocarse a la vez.El trío no tiene tal limitación.Considere el código como:</target>
        </trans-unit>
        <trans-unit id="83d1bdb0177297f4b3942b5656e2acef994da375" translate="yes" xml:space="preserve">
          <source>Not constructed directly, use &lt;a href=&quot;#trio.open_nursery&quot;&gt;&lt;code&gt;open_nursery&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">No construido directamente, use &lt;a href=&quot;#trio.open_nursery&quot;&gt; &lt;code&gt;open_nursery&lt;/code&gt; &lt;/a&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="eadd2611bf484c2f1c8acb474416269466aa9dc7" translate="yes" xml:space="preserve">
          <source>Not implemented yet!</source>
          <target state="translated">¡No se ha implementado todavía!</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="c005918e9288af566376fbbfea029bf8b6679638" translate="yes" xml:space="preserve">
          <source>Note that &amp;ldquo;closed&amp;rdquo; here means that &lt;em&gt;your&lt;/em&gt; code closed the resource, generally by calling a method with a name like &lt;code&gt;close&lt;/code&gt; or &lt;code&gt;aclose&lt;/code&gt;, or by exiting a context manager. If a problem arises elsewhere &amp;ndash; for example, because of a network failure, or because a remote peer closed their end of a connection &amp;ndash; then that should be indicated by a different exception class, like &lt;a href=&quot;#trio.BrokenResourceError&quot;&gt;&lt;code&gt;BrokenResourceError&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; subclass.</source>
          <target state="translated">Tenga en cuenta que &quot;cerrado&quot; aqu&amp;iacute; significa que &lt;em&gt;su&lt;/em&gt; c&amp;oacute;digo cerr&amp;oacute; el recurso, generalmente llamando a un m&amp;eacute;todo con un nombre como &lt;code&gt;close&lt;/code&gt; o &lt;code&gt;aclose&lt;/code&gt; , o saliendo de un administrador de contexto. Si surge un problema en otro lugar, por ejemplo, debido a una falla en la red, o porque un par remoto cerr&amp;oacute; el extremo de una conexi&amp;oacute;n, entonces eso deber&amp;iacute;a indicarse mediante una clase de excepci&amp;oacute;n diferente, como &lt;a href=&quot;#trio.BrokenResourceError&quot;&gt; &lt;code&gt;BrokenResourceError&lt;/code&gt; &lt;/a&gt; o una subclase &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e4c5fde44cdcbb0229d2ec83868918f591012895" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;cushion&lt;/code&gt; is measured in &lt;em&gt;real&lt;/em&gt; time, not the Trio clock time.</source>
          <target state="translated">Tenga en cuenta que el &lt;code&gt;cushion&lt;/code&gt; se mide en tiempo &lt;em&gt;real&lt;/em&gt; , no el tiempo del reloj Trio.</target>
        </trans-unit>
        <trans-unit id="c2f474f246c27fafa3dfbf010e4d2f00c8ffe806" translate="yes" xml:space="preserve">
          <source>Note that for efficiency, the core run loop only checks for expired deadlines every once in a while. This means that in certain cases there may be a short delay between when the clock says the deadline should have expired, and when checkpoints start raising &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;. This is a very obscure corner case that you&amp;rsquo;re unlikely to notice, but we document it for completeness. (If this &lt;em&gt;does&lt;/em&gt; cause problems for you, of course, then &lt;a href=&quot;https://github.com/python-trio/trio/issues&quot;&gt;we want to know!&lt;/a&gt;)</source>
          <target state="translated">Tenga en cuenta que, por motivos de eficiencia, el ciclo de ejecuci&amp;oacute;n del n&amp;uacute;cleo solo comprueba si hay plazos vencidos de vez en cuando. Esto significa que, en ciertos casos, puede haber una peque&amp;ntilde;a demora entre el momento en que el reloj indica que la fecha l&amp;iacute;mite deber&amp;iacute;a haber expirado y cuando los puntos de control comienzan a aumentar &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; . Este es un caso de esquina muy oscuro que es poco probable que note, pero lo documentamos para que est&amp;eacute; completo. (Si esto &lt;em&gt;le&lt;/em&gt; causa problemas, por supuesto, &lt;a href=&quot;https://github.com/python-trio/trio/issues&quot;&gt;&amp;iexcl;queremos saberlo!&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="a4da239427acde2c8d842bd9203aa10f330974e5" translate="yes" xml:space="preserve">
          <source>Note that if you leave the &lt;code&gt;with&lt;/code&gt; block while the iterator has unextracted signals still pending inside it, then they will be re-delivered using Python&amp;rsquo;s regular signal handling logic. This avoids a race condition when signals arrives just before we exit the &lt;code&gt;with&lt;/code&gt; block.</source>
          <target state="translated">Tenga en cuenta que si deja el bloque &lt;code&gt;with&lt;/code&gt; mientras el iterador tiene se&amp;ntilde;ales no extra&amp;iacute;das a&amp;uacute;n pendientes dentro de &amp;eacute;l, se volver&amp;aacute;n a enviar utilizando la l&amp;oacute;gica de manejo de se&amp;ntilde;ales regular de Python. Esto evita una condici&amp;oacute;n de carrera cuando las se&amp;ntilde;ales llegan justo antes de que salgamos del bloque &lt;code&gt;with&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e8529b79533f0b11f8453e7f61b578bff6ccac8" translate="yes" xml:space="preserve">
          <source>Note that if you pass an IPv4 &lt;code&gt;local_address&lt;/code&gt;, then you won&amp;rsquo;t be able to connect to IPv6 hosts, and vice-versa. If you want to take advantage of this to force the use of IPv4 or IPv6 without specifying an exact source address, you can use the IPv4 wildcard address &lt;code&gt;local_address=&quot;0.0.0.0&quot;&lt;/code&gt;, or the IPv6 wildcard address &lt;code&gt;local_address=&quot;::&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="712bd61d427cff2f726afa6001462d20b944b4f7" translate="yes" xml:space="preserve">
          <source>Note that it actually loads the whole directory list into memory immediately, during the initial call. (See &lt;a href=&quot;https://github.com/python-trio/trio/issues/501&quot;&gt;issue #501&lt;/a&gt; for discussion.)</source>
          <target state="translated">Tenga en cuenta que en realidad carga toda la lista de directorios en la memoria inmediatamente, durante la llamada inicial. (Consulte el &lt;a href=&quot;https://github.com/python-trio/trio/issues/501&quot;&gt;n&amp;uacute;mero 501&lt;/a&gt; para m&amp;aacute;s informaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="9ee1f76d9b8ad0707603fa7bdf72c7513bc021f3" translate="yes" xml:space="preserve">
          <source>Note that on Trio (unlike the standard library &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen&quot;&gt;&lt;code&gt;subprocess.Popen&lt;/code&gt;&lt;/a&gt;), &lt;code&gt;process.poll()&lt;/code&gt; and &lt;code&gt;process.returncode&lt;/code&gt; always give the same result. See &lt;a href=&quot;#trio.Process.returncode&quot;&gt;&lt;code&gt;returncode&lt;/code&gt;&lt;/a&gt; for more details. This method is only included to make it easier to port code from &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#module-subprocess&quot;&gt;&lt;code&gt;subprocess&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18074fc1649e3851e18407e48fba948b511fbd36" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;#trio.SocketListener&quot;&gt;&lt;code&gt;SocketListener&lt;/code&gt;&lt;/a&gt; &amp;ldquo;takes ownership&amp;rdquo; of the given socket; closing the &lt;a href=&quot;#trio.SocketListener&quot;&gt;&lt;code&gt;SocketListener&lt;/code&gt;&lt;/a&gt; will also close the socket.</source>
          <target state="translated">Tenga en cuenta que &lt;a href=&quot;#trio.SocketListener&quot;&gt; &lt;code&gt;SocketListener&lt;/code&gt; &lt;/a&gt; &quot;toma posesi&amp;oacute;n&quot; del socket dado; cerrar el &lt;a href=&quot;#trio.SocketListener&quot;&gt; &lt;code&gt;SocketListener&lt;/code&gt; &lt;/a&gt; tambi&amp;eacute;n cerrar&amp;aacute; el socket.</target>
        </trans-unit>
        <trans-unit id="2ad4e8916ad84553a99fb9d5ed08077c69f39ffa" translate="yes" xml:space="preserve">
          <source>Note that the scheduler has the option of ignoring this and continuing to run the current task if it decides this is appropriate (e.g. for increased efficiency).</source>
          <target state="translated">Tenga en cuenta que el programador tiene la opción de ignorar esto y continuar ejecutando la tarea actual si decide que es apropiado (por ejemplo,para aumentar la eficiencia).</target>
        </trans-unit>
        <trans-unit id="a870766bee2cab11ad647d758a862b70449e3239" translate="yes" xml:space="preserve">
          <source>Note that these APIs are actually in &lt;a href=&quot;reference-io#module-trio.socket&quot;&gt;&lt;code&gt;trio.socket&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;trio.abc&lt;/code&gt;, but we document them here because they&amp;rsquo;re primarily intended for testing.</source>
          <target state="translated">Tenga en cuenta que estas API est&amp;aacute;n en realidad en &lt;a href=&quot;reference-io#module-trio.socket&quot;&gt; &lt;code&gt;trio.socket&lt;/code&gt; &lt;/a&gt; y &lt;code&gt;trio.abc&lt;/code&gt; , pero las documentamos aqu&amp;iacute; porque est&amp;aacute;n destinadas principalmente a pruebas.</target>
        </trans-unit>
        <trans-unit id="5f6717e388dfea4f31cd0847c699c3d8b947978c" translate="yes" xml:space="preserve">
          <source>Note that this function is async, and that it acts as a checkpoint, but unlike most async functions it cannot block indefinitely (at least, assuming the underlying resource object is correctly implemented).</source>
          <target state="translated">Obsérvese que esta función es asíncrona,y que actúa como un punto de control,pero a diferencia de la mayoría de las funciones asíncronas no puede bloquearse indefinidamente (al menos,suponiendo que el objeto de recurso subyacente esté correctamente implementado).</target>
        </trans-unit>
        <trans-unit id="60263bbd81e421eab5c9b77a0bb97880024cfdea" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; an async function and you don&amp;rsquo;t use await when calling it. It sets up the new task, but then returns immediately, &lt;em&gt;before&lt;/em&gt; it has a chance to run. The new task won&amp;rsquo;t actually get a chance to do anything until some later point when you execute a checkpoint and the scheduler decides to run it. If you want to run a function and immediately wait for its result, then you don&amp;rsquo;t need a nursery; just use &lt;code&gt;await async_fn(*args)&lt;/code&gt;. If you want to wait for the task to initialize itself before continuing, see &lt;a href=&quot;#trio.Nursery.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Tenga en cuenta que esta &lt;em&gt;no&lt;/em&gt; es una funci&amp;oacute;n asincr&amp;oacute;nica y no usa await al llamarla. Configura la nueva tarea, pero luego regresa inmediatamente, &lt;em&gt;antes de&lt;/em&gt; que tenga la oportunidad de ejecutarse. En realidad, la nueva tarea no tendr&amp;aacute; la oportunidad de hacer nada hasta un momento posterior cuando ejecute un punto de control y el programador decida ejecutarlo. Si desea ejecutar una funci&amp;oacute;n y esperar inmediatamente su resultado, entonces no necesita un vivero; simplemente use &lt;code&gt;await async_fn(*args)&lt;/code&gt; . Si desea esperar a que la tarea se inicialice antes de continuar, consulte &lt;a href=&quot;#trio.Nursery.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e596896727edc23e1453160d700101f2cccdb2ec" translate="yes" xml:space="preserve">
          <source>Note that this is a single 30 second timeout for the entire body of the &lt;code&gt;with&lt;/code&gt; statement. This is different from what you might have seen with other Python libraries, where timeouts often refer to something &lt;a href=&quot;http://docs.python-requests.org/en/master/user/quickstart/#timeouts&quot;&gt;more complicated&lt;/a&gt;. We think this way is easier to reason about.</source>
          <target state="translated">Tenga en cuenta que este es un &amp;uacute;nico tiempo de espera de 30 segundos para todo el cuerpo de la declaraci&amp;oacute;n &lt;code&gt;with&lt;/code&gt; . Esto es diferente de lo que podr&amp;iacute;a haber visto con otras bibliotecas de Python, donde los tiempos de espera a menudo se refieren a algo &lt;a href=&quot;http://docs.python-requests.org/en/master/user/quickstart/#timeouts&quot;&gt;m&amp;aacute;s complicado&lt;/a&gt; . Creemos que es m&amp;aacute;s f&amp;aacute;cil razonar de esta manera.</target>
        </trans-unit>
        <trans-unit id="74f2efef07bc9eb1b0dde311d07fb69fa9029a53" translate="yes" xml:space="preserve">
          <source>Note that this is a single 30 second timeout for the entire body of the &lt;code&gt;with&lt;/code&gt; statement. This is different from what you might have seen with other Python libraries, where timeouts often refer to something &lt;a href=&quot;https://requests.kennethreitz.org/en/master/user/quickstart/#timeouts&quot;&gt;more complicated&lt;/a&gt;. We think this way is easier to reason about.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d90917fbab7be987474e0660b08f23d296f2c615" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;a href=&quot;reference-io#trio.socket.socket&quot;&gt;&lt;code&gt;trio.socket.socket()&lt;/code&gt;&lt;/a&gt;, this does not take a &lt;code&gt;fileno=&lt;/code&gt; argument. If a &lt;code&gt;fileno=&lt;/code&gt; is specified, then &lt;a href=&quot;reference-io#trio.socket.socket&quot;&gt;&lt;code&gt;trio.socket.socket()&lt;/code&gt;&lt;/a&gt; returns a regular Trio socket object instead of calling this method.</source>
          <target state="translated">Tenga en cuenta que, a diferencia de &lt;a href=&quot;reference-io#trio.socket.socket&quot;&gt; &lt;code&gt;trio.socket.socket()&lt;/code&gt; &lt;/a&gt; , esto no &lt;code&gt;fileno=&lt;/code&gt; un argumento fileno = . Si se especifica un &lt;code&gt;fileno=&lt;/code&gt; , entonces &lt;a href=&quot;reference-io#trio.socket.socket&quot;&gt; &lt;code&gt;trio.socket.socket()&lt;/code&gt; &lt;/a&gt; devuelve un objeto de socket Trio normal en lugar de llamar a este m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="ee9f1e467c615fa7fe75945105dc0ba02d240448" translate="yes" xml:space="preserve">
          <source>Note that what matters here is the scopes that were active when &lt;a href=&quot;#trio.open_nursery&quot;&gt;&lt;code&gt;open_nursery()&lt;/code&gt;&lt;/a&gt; was called, &lt;em&gt;not&lt;/em&gt; the scopes active when &lt;code&gt;start_soon&lt;/code&gt; is called. So for example, the timeout block below does nothing at all:</source>
          <target state="translated">Tenga en cuenta que lo que importa aqu&amp;iacute; son los &amp;aacute;mbitos que estaban activos cuando se llam&amp;oacute; a &lt;a href=&quot;#trio.open_nursery&quot;&gt; &lt;code&gt;open_nursery()&lt;/code&gt; &lt;/a&gt; , &lt;em&gt;no&lt;/em&gt; los &amp;aacute;mbitos activos cuando se llama a &lt;code&gt;start_soon&lt;/code&gt; . Entonces, por ejemplo, el bloque de tiempo de espera a continuaci&amp;oacute;n no hace nada en absoluto:</target>
        </trans-unit>
        <trans-unit id="c0dd16afc9aa65302712b5fe96789de465a014cf" translate="yes" xml:space="preserve">
          <source>Note that you&amp;rsquo;ll need to save the current &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; object to later resume; you can retrieve it with &lt;a href=&quot;#trio.hazmat.current_task&quot;&gt;&lt;code&gt;current_task()&lt;/code&gt;&lt;/a&gt;. You can also use this &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; object to retrieve the coroutine object &amp;ndash; see &lt;a href=&quot;#trio.hazmat.Task.coro&quot;&gt;&lt;code&gt;Task.coro&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Tenga en cuenta que deber&amp;aacute; guardar el objeto &lt;a href=&quot;#trio.hazmat.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; actual para reanudarlo m&amp;aacute;s tarde; puede recuperarlo con &lt;a href=&quot;#trio.hazmat.current_task&quot;&gt; &lt;code&gt;current_task()&lt;/code&gt; &lt;/a&gt; . Tambi&amp;eacute;n puede utilizar este objeto &lt;a href=&quot;#trio.hazmat.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; para recuperar el objeto de corrutina; consulte &lt;a href=&quot;#trio.hazmat.Task.coro&quot;&gt; &lt;code&gt;Task.coro&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d6c0b28dbde137e07a8b2672fcb623eb89d90210" translate="yes" xml:space="preserve">
          <source>Note that you&amp;rsquo;ll need to save the current &lt;a href=&quot;#trio.lowlevel.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; object to later resume; you can retrieve it with &lt;a href=&quot;#trio.lowlevel.current_task&quot;&gt;&lt;code&gt;current_task()&lt;/code&gt;&lt;/a&gt;. You can also use this &lt;a href=&quot;#trio.lowlevel.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; object to retrieve the coroutine object &amp;ndash; see &lt;a href=&quot;#trio.lowlevel.Task.coro&quot;&gt;&lt;code&gt;Task.coro&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b11c1cb9fa202d18d7a41126f3004fc8f01b7293" translate="yes" xml:space="preserve">
          <source>Notes on async generators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd0ce03c8decb818ff508ff8fee1d404e44208e2" translate="yes" xml:space="preserve">
          <source>Notice a small trick we use: the code in &lt;code&gt;main&lt;/code&gt; creates clone objects to pass into all the child tasks, and then closes the original objects using &lt;code&gt;async with&lt;/code&gt;. Another option is to pass clones into all-but-one of the child tasks, and then pass the original object into the last task, like:</source>
          <target state="translated">Observe un peque&amp;ntilde;o truco que usamos: el c&amp;oacute;digo en &lt;code&gt;main&lt;/code&gt; crea objetos clon para pasar a todas las tareas secundarias y luego cierra los objetos originales usando &lt;code&gt;async with&lt;/code&gt; . Otra opci&amp;oacute;n es pasar los clones a todas las tareas secundarias menos una y luego pasar el objeto original a la &amp;uacute;ltima tarea, como:</target>
        </trans-unit>
        <trans-unit id="5d6fc1814d50a5f137f3e0720ddabca9f27c56cd" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;server&lt;/code&gt; opens a nursery and passes it to &lt;code&gt;new_connection_listener&lt;/code&gt;, and then &lt;code&gt;new_connection_listener&lt;/code&gt; is able to start new tasks as &amp;ldquo;siblings&amp;rdquo; of itself. Of course, in this case, we could just as well have written:</source>
          <target state="translated">Observe que el &lt;code&gt;server&lt;/code&gt; abre un vivero y lo pasa a &lt;code&gt;new_connection_listener&lt;/code&gt; , y luego &lt;code&gt;new_connection_listener&lt;/code&gt; puede iniciar nuevas tareas como &quot;hermanos&quot; de s&amp;iacute; mismo. Por supuesto, en este caso, tambi&amp;eacute;n podr&amp;iacute;amos haber escrito:</target>
        </trans-unit>
        <trans-unit id="e37b67492b27cf2315618722132887747e63dd5f" translate="yes" xml:space="preserve">
          <source>Now suppose that the remote server stops responding, so our call to &lt;code&gt;await conn.send_hello_msg()&lt;/code&gt; hangs forever. Fortunately, we were clever enough to put a timeout around this code, so eventually the timeout will expire and &lt;code&gt;send_hello_msg&lt;/code&gt; will raise &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;. But then, in the &lt;code&gt;finally&lt;/code&gt; block, we make another blocking operation, which will also hang forever! At this point, if we were using &lt;a href=&quot;https://docs.python.org/3/library/asyncio.html#module-asyncio&quot;&gt;&lt;code&gt;asyncio&lt;/code&gt;&lt;/a&gt; or another library with &amp;ldquo;edge-triggered&amp;rdquo; cancellation, we&amp;rsquo;d be in trouble: since our timeout already fired, it wouldn&amp;rsquo;t fire again, and at this point our application would lock up forever. But in Trio, this &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; happen: the &lt;code&gt;await
conn.send_goodbye_msg()&lt;/code&gt; call is still inside the cancelled block, so it will also raise &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Ahora suponga que el servidor remoto deja de responder, por lo que nuestra llamada a &lt;code&gt;await conn.send_hello_msg()&lt;/code&gt; cuelga para siempre. Afortunadamente, fuimos lo suficientemente inteligentes como para poner un tiempo de espera alrededor de este c&amp;oacute;digo, por lo que eventualmente el tiempo de espera expirar&amp;aacute; y &lt;code&gt;send_hello_msg&lt;/code&gt; generar&amp;aacute; &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; . Pero entonces, en el &lt;code&gt;finally&lt;/code&gt; del bloque, hacemos otra operaci&amp;oacute;n de bloqueo, que tambi&amp;eacute;n se colgar&amp;aacute; para siempre! En este punto, si estuvi&amp;eacute;ramos usando &lt;a href=&quot;https://docs.python.org/3/library/asyncio.html#module-asyncio&quot;&gt; &lt;code&gt;asyncio&lt;/code&gt; &lt;/a&gt; u otra biblioteca con cancelaci&amp;oacute;n &quot;activada por borde&quot;, estar&amp;iacute;amos en problemas: dado que nuestro tiempo de espera ya se activ&amp;oacute;, no volver&amp;iacute;a a activarse , y en este punto nuestra aplicaci&amp;oacute;n se bloquear&amp;aacute; para siempre . Pero en Trio, esto &lt;em&gt;no&lt;/em&gt; sucede: el &lt;code&gt;await conn.send_goodbye_msg()&lt;/code&gt; La llamada todav&amp;iacute;a est&amp;aacute; dentro del bloque cancelado, por lo que tambi&amp;eacute;n se activar&amp;aacute; &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="02c8f6d70943a7fac1506484bdd19fd986fc4dea" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;send&lt;/code&gt; calls wait for the &lt;code&gt;receive&lt;/code&gt; calls to finish, which forces the producer to slow down to match the consumer&amp;rsquo;s speed. (It might look strange that some values are reported as &amp;ldquo;Received&amp;rdquo; before they&amp;rsquo;re reported as &amp;ldquo;Sent&amp;rdquo;; this happens because the actual send/receive happen at the same time, so which line gets printed first is random.)</source>
          <target state="translated">Ahora, las llamadas &lt;code&gt;send&lt;/code&gt; esperan a que finalicen las llamadas &lt;code&gt;receive&lt;/code&gt; , lo que obliga al productor a reducir la velocidad para igualar la velocidad del consumidor. (Puede parecer extra&amp;ntilde;o que algunos valores se informen como &quot;Recibidos&quot; antes de que se informen como &quot;Enviados&quot;; esto sucede porque el env&amp;iacute;o / recepci&amp;oacute;n real ocurre al mismo tiempo, por lo que la l&amp;iacute;nea que se imprime primero es aleatoria).</target>
        </trans-unit>
        <trans-unit id="4e56b32190bfb5370d26b04e4a28ca4757d98a90" translate="yes" xml:space="preserve">
          <source>Now try replacing &lt;code&gt;open_memory_channel(math.inf)&lt;/code&gt; with &lt;code&gt;open_memory_channel(0)&lt;/code&gt;, and run it again. We get output like:</source>
          <target state="translated">Ahora intente reemplazar &lt;code&gt;open_memory_channel(math.inf)&lt;/code&gt; con &lt;code&gt;open_memory_channel(0)&lt;/code&gt; y ejec&amp;uacute;telo nuevamente. Obtenemos resultados como:</target>
        </trans-unit>
        <trans-unit id="adc4ba48cd9ba8dfc30133e2521b610c7b62038b" translate="yes" xml:space="preserve">
          <source>Now, here&amp;rsquo;s the problem: how does the logging code know what the request identifier is? One approach would be to explicitly pass it around to every function that might want to emit logs&amp;hellip; but that&amp;rsquo;s basically every function, because you never know when you might need to add a &lt;code&gt;log.debug(...)&lt;/code&gt; call to some utility function buried deep in the call stack, and when you&amp;rsquo;re in the middle of a debugging a nasty problem that last thing you want is to have to stop first and refactor everything to pass through the request identifier! Sometimes this is the right solution, but other times it would be much more convenient if we could store the identifier in a global variable, so that the logging function could look it up whenever it needed it. Except&amp;hellip; a global variable can only have one value at a time, so if we have multiple handlers running at once then this isn&amp;rsquo;t going to work. What we need is something that&amp;rsquo;s &lt;em&gt;like&lt;/em&gt; a global variable, but that can have different values depending on which request handler is accessing it.</source>
          <target state="translated">Ahora, aqu&amp;iacute; est&amp;aacute; el problema: &amp;iquest;c&amp;oacute;mo sabe el c&amp;oacute;digo de registro cu&amp;aacute;l es el identificador de solicitud? Un enfoque ser&amp;iacute;a pasarlo expl&amp;iacute;citamente a todas las funciones que podr&amp;iacute;an querer emitir registros ... pero eso es b&amp;aacute;sicamente todas las funciones, porque nunca se sabe cu&amp;aacute;ndo es posible que deba agregar un &lt;code&gt;log.debug(...)&lt;/code&gt; llame a alguna funci&amp;oacute;n de utilidad enterrada en lo profundo de la pila de llamadas, y cuando est&amp;eacute; en medio de una depuraci&amp;oacute;n de un problema desagradable, lo &amp;uacute;ltimo que desea es tener que detenerse primero y refactorizar todo para pasar por el identificador de solicitud. A veces esta es la soluci&amp;oacute;n correcta, pero otras veces ser&amp;iacute;a mucho m&amp;aacute;s conveniente si pudi&amp;eacute;ramos almacenar el identificador en una variable global, para que la funci&amp;oacute;n de registro pudiera buscarlo cuando lo necesitara. Excepto ... una variable global solo puede tener un valor a la vez, as&amp;iacute; que si tenemos varios controladores ejecut&amp;aacute;ndose a la vez, esto no funcionar&amp;aacute;. Lo que necesitamos es algo que sea &lt;em&gt;como&lt;/em&gt; una variable global, pero que puede tener diferentes valores seg&amp;uacute;n el controlador de solicitudes que acceda a ella.</target>
        </trans-unit>
        <trans-unit id="18a97ec0e1695e28d7a8fe2a6572b4583a7001e4" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s try setting a small but nonzero buffer size, like &lt;code&gt;open_memory_channel(3)&lt;/code&gt;. what do you think will happen?</source>
          <target state="translated">Ahora, intentemos establecer un tama&amp;ntilde;o de b&amp;uacute;fer peque&amp;ntilde;o pero distinto de cero, como &lt;code&gt;open_memory_channel(3)&lt;/code&gt; . &amp;iquest;Qu&amp;eacute; piensas t&amp;uacute; que suceder&amp;aacute;?</target>
        </trans-unit>
        <trans-unit id="fd5e18f90249b8669806f325c583b198ada3d939" translate="yes" xml:space="preserve">
          <source>Nurseries and spawning</source>
          <target state="translated">Viveros y desove</target>
        </trans-unit>
        <trans-unit id="16d7703fe16bb0df95242d1426109cc4459c2e07" translate="yes" xml:space="preserve">
          <source>Nurseries ensure the absence of orphaned Tasks, since all running tasks will belong to an open Nursery.</source>
          <target state="translated">Las guarderías aseguran la ausencia de tareas huérfanas,ya que todas las tareas en curso pertenecerán a una guardería abierta.</target>
        </trans-unit>
        <trans-unit id="20dca5710da376ad5a814a1da5182bc19a89b8b0" translate="yes" xml:space="preserve">
          <source>Objects that implement this interface can be used as async context managers, i.e., you can write:</source>
          <target state="translated">Los objetos que implementan esta interfaz pueden ser usados como administradores de contexto async,es decir,pueden escribir:</target>
        </trans-unit>
        <trans-unit id="4b940f5465fbd6a31841a4291aeea0108a4130ad" translate="yes" xml:space="preserve">
          <source>Of course real producers and consumers are usually more complicated than this, and in some situations, a modest amount of buffering might improve throughput. But too much buffering wastes memory and increases latency, so if you want to tune your application you should experiment to see what value works best for you.</source>
          <target state="translated">Por supuesto,los productores y consumidores reales suelen ser más complicados que esto,y en algunas situaciones,una modesta cantidad de amortiguación podría mejorar el rendimiento.Pero demasiado buffering desperdicia la memoria y aumenta la latencia,por lo que si quiere afinar su aplicación debe experimentar para ver qué valor funciona mejor para usted.</target>
        </trans-unit>
        <trans-unit id="e5af8fe33a8522754410781a2a311fe81b69b085" translate="yes" xml:space="preserve">
          <source>Of course we don&amp;rsquo;t generally like it when programs hang. What happened? The problem is that the producer sent 3 messages and then exited, but the consumer has no way to tell that the producer is gone: for all it knows, another message might be coming along any moment. So it hangs forever waiting for the 4th message.</source>
          <target state="translated">Por supuesto, generalmente no nos gusta cuando los programas se cuelgan. &amp;iquest;Que pas&amp;oacute;? El problema es que el productor envi&amp;oacute; 3 mensajes y luego sali&amp;oacute;, pero el consumidor no tiene forma de saber que el productor se ha ido: por lo que sabe, podr&amp;iacute;a llegar otro mensaje en cualquier momento. As&amp;iacute; que se queda colgado para siempre esperando el cuarto mensaje.</target>
        </trans-unit>
        <trans-unit id="c0326ef61ce31f93eca90a3c1fc454c143eaee8a" translate="yes" xml:space="preserve">
          <source>Of course, if you really want to make another blocking call in your cleanup handler, Trio will let you; it&amp;rsquo;s trying to prevent you from accidentally shooting yourself in the foot. Intentional foot-shooting is no problem (or at least &amp;ndash; it&amp;rsquo;s not Trio&amp;rsquo;s problem). To do this, create a new scope, and set its &lt;a href=&quot;#trio.CancelScope.shield&quot;&gt;&lt;code&gt;shield&lt;/code&gt;&lt;/a&gt; attribute to &lt;a href=&quot;https://docs.python.org/3/library/constants.html#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Por supuesto, si realmente desea realizar otra llamada de bloqueo en su controlador de limpieza, Trio se lo permitir&amp;aacute;; est&amp;aacute; tratando de evitar que te dispares accidentalmente en el pie. Los disparos intencionales con el pie no son un problema (o al menos, no es un problema de Trio). Para hacer esto, cree un nuevo alcance y establezca su atributo de &lt;a href=&quot;#trio.CancelScope.shield&quot;&gt; &lt;code&gt;shield&lt;/code&gt; &lt;/a&gt; en &lt;a href=&quot;https://docs.python.org/3/library/constants.html#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="f3053b0a18145d078b6fd276d56918a38b129cb0" translate="yes" xml:space="preserve">
          <source>Of course, this rule doesn&amp;rsquo;t apply to APIs that need to impose internal timeouts. For example, if you write a &lt;code&gt;start_http_server&lt;/code&gt; function, then you probably should give your caller some way to configure timeouts on individual requests.</source>
          <target state="translated">Por supuesto, esta regla no se aplica a las API que deben imponer tiempos de espera internos. Por ejemplo, si escribe una funci&amp;oacute;n &lt;code&gt;start_http_server&lt;/code&gt; , probablemente deber&amp;iacute;a darle a la persona que llama alguna forma de configurar tiempos de espera en solicitudes individuales.</target>
        </trans-unit>
        <trans-unit id="62c759159e0d57c77aff616dd1156fb73f75ed37" translate="yes" xml:space="preserve">
          <source>Often there is no need to create &lt;a href=&quot;#trio.CancelScope&quot;&gt;&lt;code&gt;CancelScope&lt;/code&gt;&lt;/a&gt; object. Trio already includes &lt;a href=&quot;#trio.Nursery.cancel_scope&quot;&gt;&lt;code&gt;cancel_scope&lt;/code&gt;&lt;/a&gt; attribute in a task-related &lt;a href=&quot;#trio.Nursery&quot;&gt;&lt;code&gt;Nursery&lt;/code&gt;&lt;/a&gt; object. We will cover nurseries later in the manual.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fd62c1a5622fc073c28a93c33b57b2cdd713f8e" translate="yes" xml:space="preserve">
          <source>On UNIX, &lt;code&gt;sig&lt;/code&gt; may be any signal defined in the &lt;a href=&quot;https://docs.python.org/3/library/signal.html#module-signal&quot;&gt;&lt;code&gt;signal&lt;/code&gt;&lt;/a&gt; module, such as &lt;code&gt;signal.SIGINT&lt;/code&gt; or &lt;code&gt;signal.SIGTERM&lt;/code&gt;. On Windows, it may be anything accepted by the standard library &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen.send_signal&quot;&gt;&lt;code&gt;subprocess.Popen.send_signal()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">En UNIX, &lt;code&gt;sig&lt;/code&gt; puede ser cualquier se&amp;ntilde;al definida en el m&amp;oacute;dulo de &lt;a href=&quot;https://docs.python.org/3/library/signal.html#module-signal&quot;&gt; &lt;code&gt;signal&lt;/code&gt; &lt;/a&gt; , como &lt;code&gt;signal.SIGINT&lt;/code&gt; o &lt;code&gt;signal.SIGTERM&lt;/code&gt; . En Windows, puede ser cualquier cosa aceptada por el &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen.send_signal&quot;&gt; &lt;code&gt;subprocess.Popen.send_signal()&lt;/code&gt; &lt;/a&gt; biblioteca est&amp;aacute;ndar. Popen.send_signal () .</target>
        </trans-unit>
        <trans-unit id="bf6f1410af029c2960985ac658c1c9ea77c283a7" translate="yes" xml:space="preserve">
          <source>On UNIX, this is equivalent to &lt;code&gt;send_signal(signal.SIGKILL)&lt;/code&gt;. On Windows, it calls &lt;code&gt;TerminateProcess&lt;/code&gt;. In both cases, the process cannot prevent itself from being killed, but the termination will be delivered asynchronously; use &lt;a href=&quot;#trio.Process.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; if you want to ensure the process is actually dead before proceeding.</source>
          <target state="translated">En UNIX, esto es equivalente a &lt;code&gt;send_signal(signal.SIGKILL)&lt;/code&gt; . En Windows, llama a &lt;code&gt;TerminateProcess&lt;/code&gt; . En ambos casos, el proceso no puede evitar que se elimine, pero la terminaci&amp;oacute;n se entregar&amp;aacute; de forma asincr&amp;oacute;nica; use &lt;a href=&quot;#trio.Process.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; si desea asegurarse de que el proceso est&amp;eacute; realmente muerto antes de continuar.</target>
        </trans-unit>
        <trans-unit id="093bb857c24ad88054bdae99c1ac11b6ac41ad98" translate="yes" xml:space="preserve">
          <source>On UNIX, this is equivalent to &lt;code&gt;send_signal(signal.SIGTERM)&lt;/code&gt;; by convention this requests graceful termination, but a misbehaving or buggy process might ignore it. On Windows, &lt;a href=&quot;#trio.Process.terminate&quot;&gt;&lt;code&gt;terminate()&lt;/code&gt;&lt;/a&gt; forcibly terminates the process in the same manner as &lt;a href=&quot;#trio.Process.kill&quot;&gt;&lt;code&gt;kill()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">En UNIX, esto es equivalente a &lt;code&gt;send_signal(signal.SIGTERM)&lt;/code&gt; ; por convenci&amp;oacute;n, esto solicita una terminaci&amp;oacute;n ordenada, pero un proceso que se porta mal o con errores puede ignorarlo. En Windows, &lt;a href=&quot;#trio.Process.terminate&quot;&gt; &lt;code&gt;terminate()&lt;/code&gt; &lt;/a&gt; finaliza el proceso a la fuerza de la misma manera que &lt;a href=&quot;#trio.Process.kill&quot;&gt; &lt;code&gt;kill()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="63bccc32cfb24ea3be7c492da42e7d6931504b60" translate="yes" xml:space="preserve">
          <source>On Unix systems, &lt;code&gt;obj&lt;/code&gt; must either be an integer file descriptor, or else an object with a &lt;code&gt;.fileno()&lt;/code&gt; method which returns an integer file descriptor. Any kind of file descriptor can be passed, though the exact semantics will depend on your kernel. For example, this probably won&amp;rsquo;t do anything useful for on-disk files.</source>
          <target state="translated">En sistemas Unix, &lt;code&gt;obj&lt;/code&gt; debe ser un descriptor de archivo entero, o bien un objeto con un m&amp;eacute;todo &lt;code&gt;.fileno()&lt;/code&gt; que devuelve un descriptor de archivo entero. Se puede pasar cualquier tipo de descriptor de archivo, aunque la sem&amp;aacute;ntica exacta depender&amp;aacute; de su kernel. Por ejemplo, esto probablemente no har&amp;aacute; nada &amp;uacute;til para los archivos en el disco.</target>
        </trans-unit>
        <trans-unit id="5f778902d9c8c447218f9ad6fe556cf1426e9e88" translate="yes" xml:space="preserve">
          <source>On Unix-likes, the default behavior is to send a &lt;code&gt;SIGTERM&lt;/code&gt;, wait 5 seconds, and send a &lt;code&gt;SIGKILL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a969b2d9ca8b91fa9abe22200e2f4c6b06299d74" translate="yes" xml:space="preserve">
          <source>On Windows systems, &lt;code&gt;obj&lt;/code&gt; must either be an integer &lt;code&gt;SOCKET&lt;/code&gt; handle, or else an object with a &lt;code&gt;.fileno()&lt;/code&gt; method which returns an integer &lt;code&gt;SOCKET&lt;/code&gt; handle. File descriptors aren&amp;rsquo;t supported, and neither are handles that refer to anything besides a &lt;code&gt;SOCKET&lt;/code&gt;.</source>
          <target state="translated">En los sistemas Windows, &lt;code&gt;obj&lt;/code&gt; debe ser un identificador &lt;code&gt;SOCKET&lt;/code&gt; entero o bien un objeto con un m&amp;eacute;todo &lt;code&gt;.fileno()&lt;/code&gt; que devuelve un identificador &lt;code&gt;SOCKET&lt;/code&gt; entero . Los descriptores de archivo no son compatibles y tampoco lo son los identificadores que se refieren a algo m&amp;aacute;s que a &lt;code&gt;SOCKET&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc652985d9f1e9dde967ef006b4df5bdb1adee42" translate="yes" xml:space="preserve">
          <source>On Windows with &lt;code&gt;shell=True&lt;/code&gt;, things get even more chaotic. Now there are two separate sets of quoting rules applied, one by the Windows command shell &lt;code&gt;CMD.EXE&lt;/code&gt; and one by the process being spawned, and they&amp;rsquo;re &lt;em&gt;different&lt;/em&gt;. (And there&amp;rsquo;s no &lt;a href=&quot;https://docs.python.org/3/library/shlex.html#shlex.quote&quot;&gt;&lt;code&gt;shlex.quote()&lt;/code&gt;&lt;/a&gt; to save you: it uses UNIX-style quoting rules, even on Windows.) Most special characters interpreted by the shell &lt;code&gt;&amp;amp;&amp;lt;&amp;gt;()^|&lt;/code&gt; are not treated as special if the shell thinks they&amp;rsquo;re inside double quotes, but &lt;code&gt;%FOO%&lt;/code&gt; environment variable substitutions still are, and the shell doesn&amp;rsquo;t provide any way to write a double quote inside a double-quoted string. Outside double quotes, any character (including a double quote) can be escaped using a leading &lt;code&gt;^&lt;/code&gt;. But since a pipeline is processed by running each command in the pipeline in a subshell, multiple layers of escaping can be needed:</source>
          <target state="translated">En Windows con &lt;code&gt;shell=True&lt;/code&gt; , las cosas se vuelven a&amp;uacute;n m&amp;aacute;s ca&amp;oacute;ticas. Ahora hay dos conjuntos separados de reglas de cotizaci&amp;oacute;n aplicadas, una por el shell de comandos de Windows &lt;code&gt;CMD.EXE&lt;/code&gt; y otra por el proceso que se genera, y son &lt;em&gt;diferentes&lt;/em&gt; . (Y no hay &lt;a href=&quot;https://docs.python.org/3/library/shlex.html#shlex.quote&quot;&gt; &lt;code&gt;shlex.quote()&lt;/code&gt; &lt;/a&gt; para salvarlo: usa reglas de comillas estilo UNIX, incluso en Windows.) La mayor&amp;iacute;a de los caracteres especiales interpretados por el shell &lt;code&gt;&amp;amp;&amp;lt;&amp;gt;()^|&lt;/code&gt; no se tratan como especiales si el shell cree que est&amp;aacute;n entre comillas dobles, pero las sustituciones de variables de entorno &lt;code&gt;%FOO%&lt;/code&gt; todav&amp;iacute;a lo son, y el shell no proporciona ninguna forma de escribir una comilla doble dentro de una cadena entre comillas dobles. Fuera de las comillas dobles, cualquier car&amp;aacute;cter (incluidas las comillas dobles) se puede escapar usando un &lt;code&gt;^&lt;/code&gt; . Pero dado que una canalizaci&amp;oacute;n se procesa ejecutando cada comando en la canalizaci&amp;oacute;n en una subcapa, se pueden necesitar varias capas de escape:</target>
        </trans-unit>
        <trans-unit id="c24aef8753094fb445e161838d7875f71ea24d80" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;SO_REUSEADDR&lt;/code&gt; is not exported, because it&amp;rsquo;s a trap: the name is the same as Unix &lt;code&gt;SO_REUSEADDR&lt;/code&gt;, but the semantics are &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms740621(v=vs.85).aspx&quot;&gt;different and extremely broken&lt;/a&gt;. In the very rare cases where you actually want &lt;code&gt;SO_REUSEADDR&lt;/code&gt; on Windows, then it can still be accessed from the standard library&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3/library/socket.html#module-socket&quot;&gt;&lt;code&gt;socket&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">En Windows, &lt;code&gt;SO_REUSEADDR&lt;/code&gt; no se exporta, porque es una trampa: el nombre es el mismo que &lt;code&gt;SO_REUSEADDR&lt;/code&gt; de Unix , pero la sem&amp;aacute;ntica es &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms740621(v=vs.85).aspx&quot;&gt;diferente y extremadamente rota&lt;/a&gt; . En los casos muy raros en los que realmente desea &lt;code&gt;SO_REUSEADDR&lt;/code&gt; en Windows, a&amp;uacute;n se puede acceder a &amp;eacute;l desde el m&amp;oacute;dulo de &lt;a href=&quot;https://docs.python.org/3/library/socket.html#module-socket&quot;&gt; &lt;code&gt;socket&lt;/code&gt; de&lt;/a&gt; la biblioteca est&amp;aacute;ndar .</target>
        </trans-unit>
        <trans-unit id="73f86f6e5d3bd603b807b1d07a4c8bf76197ac32" translate="yes" xml:space="preserve">
          <source>On Windows, Trio calls &lt;code&gt;TerminateProcess&lt;/code&gt;, which should kill the process immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1df29ab054edbd8897c505b18471d47700563f66" translate="yes" xml:space="preserve">
          <source>On Windows, the fundamental API for process spawning (the &lt;code&gt;CreateProcess()&lt;/code&gt; system call) takes a string, not a list, and it&amp;rsquo;s actually up to the child process to decide how it wants to split that string into individual arguments. Since the C language specifies that &lt;code&gt;main()&lt;/code&gt; should take a list of arguments, &lt;em&gt;most&lt;/em&gt; programs you encounter will follow the rules used by the Microsoft C/C++ runtime. &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen&quot;&gt;&lt;code&gt;subprocess.Popen&lt;/code&gt;&lt;/a&gt;, and thus also Trio, uses these rules when it converts an argument sequence to a string, and they are &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#converting-argument-sequence&quot;&gt;documented&lt;/a&gt; alongside the &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#module-subprocess&quot;&gt;&lt;code&gt;subprocess&lt;/code&gt;&lt;/a&gt; module. There is no documented Python standard library function that can directly perform that conversion, so even on Windows, you almost always want to pass an argument sequence rather than a string. But if the program you&amp;rsquo;re spawning doesn&amp;rsquo;t split its command line back into individual arguments in the standard way, you might need to pass a string to work around this. (Or you might just be out of luck: as far as I can tell, there&amp;rsquo;s simply no way to pass an argument containing a double-quote to a Windows batch file.)</source>
          <target state="translated">En Windows, la API fundamental para la generaci&amp;oacute;n de procesos (la llamada al sistema &lt;code&gt;CreateProcess()&lt;/code&gt; ) toma una cadena, no una lista, y en realidad depende del proceso hijo decidir c&amp;oacute;mo quiere dividir esa cadena en argumentos individuales. Dado que el lenguaje C especifica que &lt;code&gt;main()&lt;/code&gt; debe tomar una lista de argumentos, la &lt;em&gt;mayor&amp;iacute;a de los&lt;/em&gt; programas que encuentre seguir&amp;aacute;n las reglas utilizadas por el tiempo de ejecuci&amp;oacute;n de Microsoft C / C ++. &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen&quot;&gt; &lt;code&gt;subprocess.Popen&lt;/code&gt; &lt;/a&gt; , y por lo tanto tambi&amp;eacute;n Trio, usa estas reglas cuando convierte una secuencia de argumentos en una cadena, y se &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#converting-argument-sequence&quot;&gt;documentan&lt;/a&gt; junto con el &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#module-subprocess&quot;&gt; &lt;code&gt;subprocess&lt;/code&gt; &lt;/a&gt;m&amp;oacute;dulo. No existe una funci&amp;oacute;n de biblioteca est&amp;aacute;ndar de Python documentada que pueda realizar directamente esa conversi&amp;oacute;n, por lo que incluso en Windows, casi siempre desea pasar una secuencia de argumentos en lugar de una cadena. Pero si el programa que est&amp;aacute; generando no divide su l&amp;iacute;nea de comando en argumentos individuales de la manera est&amp;aacute;ndar, es posible que deba pasar una cadena para solucionar esto. (O puede que no tenga suerte: por lo que puedo decir, simplemente no hay forma de pasar un argumento que contiene una comilla doble a un archivo por lotes de Windows).</target>
        </trans-unit>
        <trans-unit id="93793d84cc2eab9e78702720d98d47b6401fa3b1" translate="yes" xml:space="preserve">
          <source>On a socket, this corresponds to &lt;code&gt;shutdown(..., SHUT_WR)&lt;/code&gt; (&lt;a href=&quot;https://linux.die.net/man/2/shutdown&quot;&gt;man page&lt;/a&gt;).</source>
          <target state="translated">En un socket, esto corresponde a &lt;code&gt;shutdown(..., SHUT_WR)&lt;/code&gt; ( &lt;a href=&quot;https://linux.die.net/man/2/shutdown&quot;&gt;p&amp;aacute;gina de manual&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4577b2431790155ff289f03b1c114b916f176a26" translate="yes" xml:space="preserve">
          <source>On an SSL/TLS-encrypted connection, the protocol doesn&amp;rsquo;t provide any way to do a unidirectional shutdown without closing the connection entirely, so &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; implements &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt;, not &lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt;&lt;code&gt;HalfCloseableStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">En una conexi&amp;oacute;n cifrada con SSL / TLS, el protocolo no proporciona ninguna forma de hacer un apagado unidireccional sin cerrar la conexi&amp;oacute;n por completo, por lo que &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; implementa &lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; , no &lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt; &lt;code&gt;HalfCloseableStream&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="abbe0780aa8ff8d2c2f1e406c9e31e6c7a33bfff" translate="yes" xml:space="preserve">
          <source>On average, the producer sends ten messages per second, but the consumer only calls &lt;code&gt;receive&lt;/code&gt; once per second. That means that each second, the channel&amp;rsquo;s internal buffer has to grow to hold an extra nine items. After a minute, the buffer will have ~540 items in it; after an hour, that grows to ~32,400. Eventually, the program will run out of memory. And well before we run out of memory, our latency on handling individual messages will become abysmal. For example, at the one minute mark, the producer is sending message ~600, but the consumer is still processing message ~60. Message 600 will have to sit in the channel for ~9 minutes before the consumer catches up and processes it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d03a8ca5007fa469f6d5b1b6ccd1bc31dfaeda2f" translate="yes" xml:space="preserve">
          <source>On average, the producer sends ten messages per second, but the consumer only calls &lt;code&gt;receive&lt;/code&gt; once per second. That means that each second, the channel&amp;rsquo;s internal buffer has to grow to hold an extra nine items. After a minute, the buffer will have ~540 items in it; after an hour, that grows to ~32,400. Eventually, the program will run out of memory. And well before we run out of memory, our latency on handling individual messages will become abysmal. For example, at the one minute mark, the producer is sending message ~600, but the producer is still processing message ~60. Message 600 will have to sit in the channel for ~9 minutes before the consumer catches up and processes it.</source>
          <target state="translated">En promedio, el productor env&amp;iacute;a diez mensajes por segundo, pero el consumidor solo &lt;code&gt;receive&lt;/code&gt; llamadas una vez por segundo. Eso significa que cada segundo, el b&amp;uacute;fer interno del canal tiene que crecer para contener nueve elementos adicionales. Despu&amp;eacute;s de un minuto, el b&amp;uacute;fer tendr&amp;aacute; ~ 540 elementos; despu&amp;eacute;s de una hora, eso aumenta a ~ 32,400. Finalmente, el programa se quedar&amp;aacute; sin memoria. Y mucho antes de que nos quedemos sin memoria, nuestra latencia en el manejo de mensajes individuales se volver&amp;aacute; abismal. Por ejemplo, en la marca de un minuto, el productor est&amp;aacute; enviando el mensaje ~ 600, pero el productor todav&amp;iacute;a est&amp;aacute; procesando el mensaje ~ 60. El mensaje 600 deber&amp;aacute; permanecer en el canal durante ~ 9 minutos antes de que el consumidor lo alcance y lo procese.</target>
        </trans-unit>
        <trans-unit id="500856d82467ceb52145a512e9cd103bdc26a294" translate="yes" xml:space="preserve">
          <source>On the other hand, if your host loop doesn&amp;rsquo;t use &lt;a href=&quot;https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd&quot;&gt;&lt;code&gt;signal.set_wakeup_fd&lt;/code&gt;&lt;/a&gt;, then the only way to make everything work correctly is to &lt;em&gt;enable&lt;/em&gt; Trio&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd&quot;&gt;&lt;code&gt;signal.set_wakeup_fd&lt;/code&gt;&lt;/a&gt; support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99d0a83dc0fc994fcf4f4fc337ee0f9989b01cda" translate="yes" xml:space="preserve">
          <source>On the path where we do end up blocking, we don&amp;rsquo;t pass through any schedule points before that, which avoids some unnecessary work.</source>
          <target state="translated">En el camino donde terminamos bloqueando, no pasamos por ning&amp;uacute;n punto de programaci&amp;oacute;n antes de eso, lo que evita un trabajo innecesario.</target>
        </trans-unit>
        <trans-unit id="7ab0a659811c28a2e762a50d54ab27494f7938a1" translate="yes" xml:space="preserve">
          <source>Once a &lt;a href=&quot;#trio.SocketStream&quot;&gt;&lt;code&gt;SocketStream&lt;/code&gt;&lt;/a&gt; object is constructed, it implements the full &lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt;&lt;code&gt;trio.abc.HalfCloseableStream&lt;/code&gt;&lt;/a&gt; interface. In addition, it provides a few extra features:</source>
          <target state="translated">Una vez que se construye un objeto &lt;a href=&quot;#trio.SocketStream&quot;&gt; &lt;code&gt;SocketStream&lt;/code&gt; &lt;/a&gt; , implementa la interfaz &lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt; &lt;code&gt;trio.abc.HalfCloseableStream&lt;/code&gt; &lt;/a&gt; completa . Adem&amp;aacute;s, proporciona algunas caracter&amp;iacute;sticas adicionales:</target>
        </trans-unit>
        <trans-unit id="a64c9326dd46aad109181cb7ab1c383a9bdc1d7f" translate="yes" xml:space="preserve">
          <source>Once all the tasks have finished, then:</source>
          <target state="translated">Una vez que todas las tareas hayan terminado,entonces:</target>
        </trans-unit>
        <trans-unit id="c45afa168e0caa5cc229264e1df9c6831e79c284" translate="yes" xml:space="preserve">
          <source>Once this method completes, any other pending or future operations on this resource should generally raise &lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt;&lt;code&gt;ClosedResourceError&lt;/code&gt;&lt;/a&gt;, unless there&amp;rsquo;s a good reason to do otherwise.</source>
          <target state="translated">Una vez que se completa este m&amp;eacute;todo, cualquier otra operaci&amp;oacute;n pendiente o futura en este recurso generalmente deber&amp;iacute;a generar &lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt; &lt;code&gt;ClosedResourceError&lt;/code&gt; &lt;/a&gt; , a menos que haya una buena raz&amp;oacute;n para hacer lo contrario.</target>
        </trans-unit>
        <trans-unit id="26c7df89ffd2d387f5d5beed48542e820db53c87" translate="yes" xml:space="preserve">
          <source>One approach would be to attempt to connect to the first one, and then if that fails, attempt to connect to the second one &amp;hellip; until we&amp;rsquo;ve tried all of them. But the problem with this is that if the first IP address is unreachable (for example, because it&amp;rsquo;s an IPv6 address and our network discards IPv6 packets), then we might end up waiting tens of seconds for the first connection attempt to timeout before we try the second address.</source>
          <target state="translated">Un enfoque ser&amp;iacute;a intentar conectarse al primero, y luego, si eso falla, intentar conectarse al segundo ... hasta que hayamos probado todos. Pero el problema con esto es que si la primera direcci&amp;oacute;n IP es inalcanzable (por ejemplo, porque es una direcci&amp;oacute;n IPv6 y nuestra red descarta paquetes IPv6), entonces podr&amp;iacute;amos terminar esperando decenas de segundos para que se agote el tiempo de espera del primer intento de conexi&amp;oacute;n antes de intentarlo. la segunda direcci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="17218738b7f51d71e3bf8c24ea0d43906f5453a7" translate="yes" xml:space="preserve">
          <source>One example of where this might be is useful is if your code is trying to decide whether to begin an expensive operation like an RPC call, but wants to skip it if it knows that it can&amp;rsquo;t possibly complete in the available time. Another example would be if you&amp;rsquo;re using a protocol like gRPC that &lt;a href=&quot;http://www.grpc.io/docs/guides/concepts.html#deadlines&quot;&gt;propagates timeout information to the remote peer&lt;/a&gt;; this function gives a way to fetch that information so you can send it along.</source>
          <target state="translated">Un ejemplo de d&amp;oacute;nde esto podr&amp;iacute;a ser &amp;uacute;til es si su c&amp;oacute;digo est&amp;aacute; tratando de decidir si comenzar una operaci&amp;oacute;n costosa como una llamada RPC, pero quiere omitirla si sabe que no puede completarse en el tiempo disponible. Otro ejemplo ser&amp;iacute;a si est&amp;aacute; utilizando un protocolo como gRPC que &lt;a href=&quot;http://www.grpc.io/docs/guides/concepts.html#deadlines&quot;&gt;propaga informaci&amp;oacute;n de tiempo de espera al par remoto&lt;/a&gt; ; esta funci&amp;oacute;n proporciona una forma de obtener esa informaci&amp;oacute;n para que pueda enviarla.</target>
        </trans-unit>
        <trans-unit id="a0c0d7674af6ab050c1ac2ce111af25d5586750b" translate="yes" xml:space="preserve">
          <source>One of Trio&amp;rsquo;s core design principles is: &lt;em&gt;no implicit concurrency&lt;/em&gt;. Every function executes in a straightforward, top-to-bottom manner, finishing each operation before moving on to the next &amp;ndash; &lt;em&gt;like Guido intended&lt;/em&gt;.</source>
          <target state="translated">Uno de los principios b&amp;aacute;sicos de dise&amp;ntilde;o de Trio es: &lt;em&gt;no concurrencia impl&amp;iacute;cita&lt;/em&gt; . Cada funci&amp;oacute;n se ejecuta de manera sencilla, de arriba a abajo, terminando cada operaci&amp;oacute;n antes de pasar a la siguiente, &lt;em&gt;como lo pretend&amp;iacute;a Guido&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c5258410fd1961814ad646a55d204ab7988e49b2" translate="yes" xml:space="preserve">
          <source>One option would be to use a regular &lt;a href=&quot;#trio.Lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt;, and wrap it around every interaction with the state machine:</source>
          <target state="translated">Una opci&amp;oacute;n ser&amp;iacute;a usar un &lt;a href=&quot;#trio.Lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; &lt;/a&gt; normal y envolverlo en cada interacci&amp;oacute;n con la m&amp;aacute;quina de estado:</target>
        </trans-unit>
        <trans-unit id="7e644ae43ba1462c7a0943dedaacaa1f10e95eff" translate="yes" xml:space="preserve">
          <source>One particularly challenging problem when testing network protocols is making sure that your implementation can handle data whose flow gets broken up in weird ways and arrives with weird timings: localhost connections tend to be much better behaved than real networks, so if you only test on localhost then you might get bitten later. To help you out, Trio provides some fully in-memory implementations of the stream interfaces (see &lt;a href=&quot;reference-io#abstract-stream-api&quot;&gt;The abstract Stream API&lt;/a&gt;), that let you write all kinds of interestingly evil tests.</source>
          <target state="translated">Un problema particularmente desafiante cuando se prueban protocolos de red es asegurarse de que su implementaci&amp;oacute;n pueda manejar datos cuyo flujo se interrumpe de maneras extra&amp;ntilde;as y llegan con tiempos extra&amp;ntilde;os: las conexiones de localhost tienden a comportarse mucho mejor que las redes reales, as&amp;iacute; que si solo prueba en localhost entonces puede que te muerdan m&amp;aacute;s tarde. Para ayudarlo, Trio proporciona algunas implementaciones completamente en memoria de las interfaces de transmisi&amp;oacute;n (consulte &lt;a href=&quot;reference-io#abstract-stream-api&quot;&gt;La API&lt;/a&gt; de transmisi&amp;oacute;n abstracta ), que le permiten escribir todo tipo de pruebas curiosamente malvadas.</target>
        </trans-unit>
        <trans-unit id="70024abc1516890206e396c0d84ab876e9506524" translate="yes" xml:space="preserve">
          <source>One thing to remember, though: cancel scopes are inherited from the nursery, &lt;strong&gt;not&lt;/strong&gt; from the task that calls &lt;code&gt;start_soon&lt;/code&gt;. So in this example, the timeout does &lt;em&gt;not&lt;/em&gt; apply to &lt;code&gt;child&lt;/code&gt; (or to anything else):</source>
          <target state="translated">Sin embargo, una cosa para recordar: los &amp;aacute;mbitos de cancelaci&amp;oacute;n se heredan del vivero, &lt;strong&gt;no&lt;/strong&gt; de la tarea que llama a &lt;code&gt;start_soon&lt;/code&gt; . Entonces, en este ejemplo, el tiempo de espera no &lt;em&gt;se&lt;/em&gt; aplica al &lt;code&gt;child&lt;/code&gt; (ni a ninguna otra cosa):</target>
        </trans-unit>
        <trans-unit id="beaeb02751f65d3130fef8613eaa9d036b7b827d" translate="yes" xml:space="preserve">
          <source>Open a channel for passing objects between tasks within a process.</source>
          <target state="translated">Abrir un canal para pasar objetos entre tareas dentro de un proceso.</target>
        </trans-unit>
        <trans-unit id="6c62e1a69d21a32a529448d3d8f35daada8a1b66" translate="yes" xml:space="preserve">
          <source>Open the file pointed by this path and return a file object, as the built-in open() function does.</source>
          <target state="translated">Abre el archivo apuntado por esta ruta y devuelve un objeto de archivo,como lo hace la función open()incorporada.</target>
        </trans-unit>
        <trans-unit id="f3c5fe1c3751280d80986615a66056be1dd51489" translate="yes" xml:space="preserve">
          <source>Opens a connection to the specified &lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_domain_socket&quot;&gt;Unix domain socket&lt;/a&gt;.</source>
          <target state="translated">Abre una conexi&amp;oacute;n al &lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_domain_socket&quot;&gt;socket de dominio Unix&lt;/a&gt; especificado .</target>
        </trans-unit>
        <trans-unit id="1901a0e40a967eefcb6e5dd3df1c5f153c15dbb3" translate="yes" xml:space="preserve">
          <source>Options for starting subprocesses</source>
          <target state="translated">Opciones para iniciar los subprocesos</target>
        </trans-unit>
        <trans-unit id="07bed1666c9b3ba20e049d70aa47c6dc1b7091b8" translate="yes" xml:space="preserve">
          <source>Original worker thread: marks itself as idle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6526a011848344d0bc9ecc95ad418dd89e0a7676" translate="yes" xml:space="preserve">
          <source>Other environments might also work; give it a try and see.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efe8c1c73352ea2ed8175b8de72fc761dd83142c" translate="yes" xml:space="preserve">
          <source>Otherwise, it should return &lt;a href=&quot;#trio.hazmat.Abort.FAILED&quot;&gt;&lt;code&gt;Abort.FAILED&lt;/code&gt;&lt;/a&gt;. This means that the task can&amp;rsquo;t be cancelled at this time, and still has to make sure that &amp;ldquo;someone&amp;rdquo; eventually calls &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt;&lt;code&gt;reschedule()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">De lo contrario, deber&amp;iacute;a devolver &lt;a href=&quot;#trio.hazmat.Abort.FAILED&quot;&gt; &lt;code&gt;Abort.FAILED&lt;/code&gt; &lt;/a&gt; . Esto significa que la tarea no se puede cancelar en este momento y a&amp;uacute;n debe asegurarse de que &quot;alguien&quot; eventualmente llame a &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt; &lt;code&gt;reschedule()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6edcd77868a87ce793ce78fd085febc4dadbf0ca" translate="yes" xml:space="preserve">
          <source>Otherwise, it should return &lt;a href=&quot;#trio.lowlevel.Abort.FAILED&quot;&gt;&lt;code&gt;Abort.FAILED&lt;/code&gt;&lt;/a&gt;. This means that the task can&amp;rsquo;t be cancelled at this time, and still has to make sure that &amp;ldquo;someone&amp;rdquo; eventually calls &lt;a href=&quot;#trio.lowlevel.reschedule&quot;&gt;&lt;code&gt;reschedule()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="456165d8c54895fc6bd4ac3bf65c943f1ea85b80" translate="yes" xml:space="preserve">
          <source>Otherwise, returns a new &lt;a href=&quot;#trio.MultiError&quot;&gt;&lt;code&gt;MultiError&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">De lo contrario, devuelve un nuevo objeto &lt;a href=&quot;#trio.MultiError&quot;&gt; &lt;code&gt;MultiError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9ee75f95c72ccfd62a03a7e39dba3cd64ff33ea2" translate="yes" xml:space="preserve">
          <source>Our &lt;a href=&quot;reference-core#cancellable-primitives&quot;&gt;cancellation semantics&lt;/a&gt; say that &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; should only be raised if the operation didn&amp;rsquo;t happen. Using &lt;a href=&quot;#trio.hazmat.cancel_shielded_checkpoint&quot;&gt;&lt;code&gt;cancel_shielded_checkpoint()&lt;/code&gt;&lt;/a&gt; on the early-exit branch accomplishes this.</source>
          <target state="translated">Nuestra &lt;a href=&quot;reference-core#cancellable-primitives&quot;&gt;sem&amp;aacute;ntica de cancelaci&amp;oacute;n&lt;/a&gt; dice que &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; solo se debe generar si la operaci&amp;oacute;n no se realiz&amp;oacute;. El uso de &lt;a href=&quot;#trio.hazmat.cancel_shielded_checkpoint&quot;&gt; &lt;code&gt;cancel_shielded_checkpoint()&lt;/code&gt; &lt;/a&gt; en la rama de salida anticipada logra esto.</target>
        </trans-unit>
        <trans-unit id="2bddce36048dc439f09e479b0ca70bcb5f35d0ff" translate="yes" xml:space="preserve">
          <source>Our &lt;a href=&quot;reference-core#cancellable-primitives&quot;&gt;cancellation semantics&lt;/a&gt; say that &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; should only be raised if the operation didn&amp;rsquo;t happen. Using &lt;a href=&quot;#trio.lowlevel.cancel_shielded_checkpoint&quot;&gt;&lt;code&gt;cancel_shielded_checkpoint()&lt;/code&gt;&lt;/a&gt; on the early-exit branch accomplishes this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7db19939314aaad6d5ce1f4bdae93a6396ba0d3a" translate="yes" xml:space="preserve">
          <source>Our Pledge</source>
          <target state="translated">Nuestra promesa</target>
        </trans-unit>
        <trans-unit id="25e4d03f4e76d2bf2914327a45498edc72df108f" translate="yes" xml:space="preserve">
          <source>Our Standards</source>
          <target state="translated">Nuestros estándares</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="4f2f5f60cf5ac63db9da317a29551d539455d423" translate="yes" xml:space="preserve">
          <source>Overview: abstract base classes for I/O</source>
          <target state="translated">Resumen:clases base abstractas para E/S</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="08f9f24653915627b70d1df0f7d09b16a85dfbbf" translate="yes" xml:space="preserve">
          <source>Park the current task until woken by a call to &lt;a href=&quot;#trio.hazmat.ParkingLot.unpark&quot;&gt;&lt;code&gt;unpark()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#trio.hazmat.ParkingLot.unpark_all&quot;&gt;&lt;code&gt;unpark_all()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.hazmat.ParkingLot.unpark&quot;&gt; &lt;code&gt;unpark()&lt;/code&gt; &lt;/a&gt; la tarea actual hasta que lo despierte una llamada a unpark () o &lt;a href=&quot;#trio.hazmat.ParkingLot.unpark_all&quot;&gt; &lt;code&gt;unpark_all()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7c0b44086afe5929d11f031dba9bb4b86e014448" translate="yes" xml:space="preserve">
          <source>Park the current task until woken by a call to &lt;a href=&quot;#trio.lowlevel.ParkingLot.unpark&quot;&gt;&lt;code&gt;unpark()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#trio.lowlevel.ParkingLot.unpark_all&quot;&gt;&lt;code&gt;unpark_all()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82d438cd7980583075141b24e8673a9713c1bf85" translate="yes" xml:space="preserve">
          <source>Partial exception for async context managers: Both the entry and exit of an &lt;code&gt;async with&lt;/code&gt; block are defined as async functions; but for a particular type of async context manager, it&amp;rsquo;s often the case that only one of them is able to block, which means only that one will act as a checkpoint. This is documented on a case-by-case basis.</source>
          <target state="translated">Excepci&amp;oacute;n parcial para administradores de contexto as&amp;iacute;ncronos: tanto la entrada como la salida de un bloque &lt;code&gt;async with&lt;/code&gt; se definen como funciones as&amp;iacute;ncronas; pero para un tipo particular de administrador de contexto as&amp;iacute;ncrono, a menudo ocurre que solo uno de ellos puede bloquear, lo que significa que solo uno actuar&amp;aacute; como punto de control. Esto se documenta caso por caso.</target>
        </trans-unit>
        <trans-unit id="5a267b39a5eff3913f1dc319a58ba6d62432a28c" translate="yes" xml:space="preserve">
          <source>Pass a keyword argument, &lt;code&gt;trio_token&lt;/code&gt; specifiying a specific &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run&lt;/code&gt;&lt;/a&gt; loop to re-enter. This is useful in case you have a &amp;ldquo;foreign&amp;rdquo; thread, spawned using some other framework, and still want to enter Trio.</source>
          <target state="translated">Pase un argumento de palabra clave, &lt;code&gt;trio_token&lt;/code&gt; especificando un bucle &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run&lt;/code&gt; &lt;/a&gt; espec&amp;iacute;fico para volver a ingresar. Esto es &amp;uacute;til en caso de que tenga un subproceso &quot;externo&quot;, generado usando alg&amp;uacute;n otro marco y a&amp;uacute;n desea ingresar a Trio.</target>
        </trans-unit>
        <trans-unit id="1aa5a7ccff5d4f3757f85c40b5dbca2bf8a5358c" translate="yes" xml:space="preserve">
          <source>Pause execution of the current task for the given number of seconds.</source>
          <target state="translated">Detener la ejecución de la tarea actual por el número de segundos dado.</target>
        </trans-unit>
        <trans-unit id="792724ee650d41a2261ab590c3c964ec9b82bf03" translate="yes" xml:space="preserve">
          <source>Pause execution of the current task forever (or until cancelled).</source>
          <target state="translated">Detener la ejecución de la tarea actual para siempre (o hasta que se cancele).</target>
        </trans-unit>
        <trans-unit id="63447823632f8be015880571aa87f00f9ebeabb5" translate="yes" xml:space="preserve">
          <source>Pause execution of the current task until the given time.</source>
          <target state="translated">Detener la ejecución de la tarea actual hasta el momento dado.</target>
        </trans-unit>
        <trans-unit id="b7f07d2b14f04bdac99308eaf26585e7e40b3547" translate="yes" xml:space="preserve">
          <source>Perform a number of generic tests on a custom half-closeable stream implementation.</source>
          <target state="translated">Realizar una serie de pruebas genéricas en una implementación personalizada de corriente de medio cierre.</target>
        </trans-unit>
        <trans-unit id="c295fcaa1b20aada89b1b40cd2fbdfb23ce8e370" translate="yes" xml:space="preserve">
          <source>Perform a number of generic tests on a custom one-way stream implementation.</source>
          <target state="translated">Realizar una serie de pruebas genéricas en una implementación de corriente unidireccional personalizada.</target>
        </trans-unit>
        <trans-unit id="7a62317ddba72606ceef522c1b86d0d79ca09d82" translate="yes" xml:space="preserve">
          <source>Perform a number of generic tests on a custom two-way stream implementation.</source>
          <target state="translated">Realizar una serie de pruebas genéricas en una implementación de corriente bidireccional personalizada.</target>
        </trans-unit>
        <trans-unit id="42ff50b294fd4232d4b5ff341053088b57eb97c3" translate="yes" xml:space="preserve">
          <source>Permanently detach the current task from the Trio scheduler.</source>
          <target state="translated">Desvincular permanentemente la tarea actual del programador del Trío.</target>
        </trans-unit>
        <trans-unit id="f58fe36afb47440251499a789d28dbf3bd14b5c4" translate="yes" xml:space="preserve">
          <source>Personally, I find that events and channels are usually enough to implement most things I care about, and lead to easier to read code than the lower-level primitives discussed in this section. But if you need them, they&amp;rsquo;re here. (If you find yourself reaching for these because you&amp;rsquo;re trying to implement a new higher-level synchronization primitive, then you might also want to check out the facilities in &lt;a href=&quot;reference-hazmat#module-trio.hazmat&quot;&gt;&lt;code&gt;trio.hazmat&lt;/code&gt;&lt;/a&gt; for a more direct exposure of Trio&amp;rsquo;s underlying synchronization logic. All of classes discussed in this section are implemented on top of the public APIs in &lt;a href=&quot;reference-hazmat#module-trio.hazmat&quot;&gt;&lt;code&gt;trio.hazmat&lt;/code&gt;&lt;/a&gt;; they don&amp;rsquo;t have any special access to Trio&amp;rsquo;s internals.)</source>
          <target state="translated">Personalmente, encuentro que los eventos y canales suelen ser suficientes para implementar la mayor&amp;iacute;a de las cosas que me importan y conducen a un c&amp;oacute;digo m&amp;aacute;s f&amp;aacute;cil de leer que las primitivas de nivel inferior que se analizan en esta secci&amp;oacute;n. Pero si los necesita, est&amp;aacute;n aqu&amp;iacute;. (Si te encuentras buscando estos porque est&amp;aacute;s tratando de implementar una nueva primitiva de sincronizaci&amp;oacute;n de nivel superior, es posible que tambi&amp;eacute;n quieras revisar las instalaciones en &lt;a href=&quot;reference-hazmat#module-trio.hazmat&quot;&gt; &lt;code&gt;trio.hazmat&lt;/code&gt; &lt;/a&gt; para una exposici&amp;oacute;n m&amp;aacute;s directa de la l&amp;oacute;gica de sincronizaci&amp;oacute;n subyacente de Trio. Todo las clases que se tratan en esta secci&amp;oacute;n se implementan sobre las API p&amp;uacute;blicas en &lt;a href=&quot;reference-hazmat#module-trio.hazmat&quot;&gt; &lt;code&gt;trio.hazmat&lt;/code&gt; &lt;/a&gt; ; no tienen ning&amp;uacute;n acceso especial a los componentes internos de Trio).</target>
        </trans-unit>
        <trans-unit id="34bfe6cded6c4e328eba04147e1373f27cf558f6" translate="yes" xml:space="preserve">
          <source>Personally, I find that events and channels are usually enough to implement most things I care about, and lead to easier to read code than the lower-level primitives discussed in this section. But if you need them, they&amp;rsquo;re here. (If you find yourself reaching for these because you&amp;rsquo;re trying to implement a new higher-level synchronization primitive, then you might also want to check out the facilities in &lt;a href=&quot;reference-lowlevel#module-trio.lowlevel&quot;&gt;&lt;code&gt;trio.lowlevel&lt;/code&gt;&lt;/a&gt; for a more direct exposure of Trio&amp;rsquo;s underlying synchronization logic. All of classes discussed in this section are implemented on top of the public APIs in &lt;a href=&quot;reference-lowlevel#module-trio.lowlevel&quot;&gt;&lt;code&gt;trio.lowlevel&lt;/code&gt;&lt;/a&gt;; they don&amp;rsquo;t have any special access to Trio&amp;rsquo;s internals.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffdc860af184791cfe1b4e1db983700a5c5843f4" translate="yes" xml:space="preserve">
          <source>Places the given data into the object&amp;rsquo;s internal buffer, and then calls the &lt;a href=&quot;#trio.testing.MemorySendStream.send_all_hook&quot;&gt;&lt;code&gt;send_all_hook&lt;/code&gt;&lt;/a&gt; (if any).</source>
          <target state="translated">Coloca los datos dados en el b&amp;uacute;fer interno del objeto y luego llama al &lt;a href=&quot;#trio.testing.MemorySendStream.send_all_hook&quot;&gt; &lt;code&gt;send_all_hook&lt;/code&gt; &lt;/a&gt; (si lo hay).</target>
        </trans-unit>
        <trans-unit id="a8ca1fe734f90a81230ee63ca0ea8ac678831e87" translate="yes" xml:space="preserve">
          <source>Preparing a release</source>
          <target state="translated">Preparando una liberación</target>
        </trans-unit>
        <trans-unit id="5020bb795052d80ec813c6028081ba9c1df6120b" translate="yes" xml:space="preserve">
          <source>Preparing pull requests</source>
          <target state="translated">Preparar las solicitudes de extracción</target>
        </trans-unit>
        <trans-unit id="f302fc4ed754d1fbfb349262f16252b92e3cc560" translate="yes" xml:space="preserve">
          <source>Pretty much any code you write using Trio needs to have some strategy to handle &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exceptions &amp;ndash; even if you didn&amp;rsquo;t set a timeout, then your caller might (and probably will).</source>
          <target state="translated">Pr&amp;aacute;cticamente cualquier c&amp;oacute;digo que escriba con Trio debe tener alguna estrategia para manejar las excepciones &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; , incluso si no estableci&amp;oacute; un tiempo de espera, entonces la persona que llama podr&amp;iacute;a (y probablemente lo har&amp;aacute;).</target>
        </trans-unit>
        <trans-unit id="af578c673cdef9a60b45069a7ffe307c6ff638e0" translate="yes" xml:space="preserve">
          <source>Prioritization Only Works When There&amp;rsquo;s Pending Data to Prioritize</source>
          <target state="translated">La priorizaci&amp;oacute;n solo funciona cuando hay datos pendientes para priorizar</target>
        </trans-unit>
        <trans-unit id="c58c7b026eae377fda9c29eb4891a26769146297" translate="yes" xml:space="preserve">
          <source>Pro-tip: you can insert sleep calls (like in our example above) to manipulate the flow of data across tasks&amp;hellip; and then use &lt;a href=&quot;#trio.testing.MockClock&quot;&gt;&lt;code&gt;MockClock&lt;/code&gt;&lt;/a&gt; and its &lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt;&lt;code&gt;autojump_threshold&lt;/code&gt;&lt;/a&gt; functionality to keep your test suite running quickly.</source>
          <target state="translated">Consejo profesional: puede insertar llamadas de suspensi&amp;oacute;n (como en nuestro ejemplo anterior) para manipular el flujo de datos entre tareas ... y luego usar &lt;a href=&quot;#trio.testing.MockClock&quot;&gt; &lt;code&gt;MockClock&lt;/code&gt; &lt;/a&gt; y su funcionalidad &lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt; &lt;code&gt;autojump_threshold&lt;/code&gt; &lt;/a&gt; para mantener su conjunto de pruebas funcionando r&amp;aacute;pidamente.</target>
        </trans-unit>
        <trans-unit id="97cd9481f2b9c8a87285e30103998d87e6b076b4" translate="yes" xml:space="preserve">
          <source>Providing support</source>
          <target state="translated">Proporcionando apoyo</target>
        </trans-unit>
        <trans-unit id="c61469d5112d29c4d7b6879f0a1409fe87006118" translate="yes" xml:space="preserve">
          <source>Put a token back into the sack on behalf of &lt;code&gt;borrower&lt;/code&gt;.</source>
          <target state="translated">Vuelva a poner una ficha en el saco en nombre del &lt;code&gt;borrower&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2750887dc705834ea27dfee8c5fa086a70d9316" translate="yes" xml:space="preserve">
          <source>Put a token back into the sack.</source>
          <target state="translated">Ponga una ficha en el saco.</target>
        </trans-unit>
        <trans-unit id="a3400133bd460916e5852bc1b4deaf18a2290d3e" translate="yes" xml:space="preserve">
          <source>Put the current task to sleep, with cancellation support.</source>
          <target state="translated">Poner la tarea actual a dormir,con el apoyo de la cancelación.</target>
        </trans-unit>
        <trans-unit id="ef10b7926486af74ce7f9c3ed42b7e35c433287a" translate="yes" xml:space="preserve">
          <source>Putting blocking I/O into worker threads</source>
          <target state="translated">Poner bloqueos de E/S en los hilos de los trabajadores</target>
        </trans-unit>
        <trans-unit id="0e3da495154b52a5558a5ade984baaf547b2ab19" translate="yes" xml:space="preserve">
          <source>Putting these together: if your data is in RAM then it should be clear that using a thread is a terrible idea &amp;ndash; if you add 100 &amp;micro;s of overhead to a 1 &amp;micro;s operation, then that&amp;rsquo;s a 100x slowdown! On the other hand, if your data&amp;rsquo;s on a spinning disk, then using a thread is &lt;em&gt;great&lt;/em&gt; &amp;ndash; instead of blocking the main thread and all tasks for 10,000 &amp;micro;s, we only block them for 100 &amp;micro;s and can spend the rest of that time running other tasks to get useful work done, which can effectively be a 100x speedup.</source>
          <target state="translated">Poniendo todo esto en conjunto: si sus datos est&amp;aacute;n en la RAM, entonces deber&amp;iacute;a quedar claro que usar un hilo es una idea terrible - si agrega 100 &amp;micro;s de sobrecarga a una operaci&amp;oacute;n de 1 &amp;micro;s, entonces eso es una ralentizaci&amp;oacute;n 100x. Por otro lado, si sus datos est&amp;aacute;n en un disco giratorio, entonces usar un hilo es &lt;em&gt;genial&lt;/em&gt; ; en lugar de bloquear el hilo principal y todas las tareas por 10,000 &amp;micro;s, solo los bloqueamos por 100 &amp;micro;s y podemos pasar el resto de ese tiempo ejecutando otros tareas para realizar un trabajo &amp;uacute;til, que efectivamente puede ser una aceleraci&amp;oacute;n de 100 veces.</target>
        </trans-unit>
        <trans-unit id="9bed300b0f4824cbef5b91a6d3b95c3a8725845b" translate="yes" xml:space="preserve">
          <source>Python 3.6 added support for &lt;em&gt;async generators&lt;/em&gt;, which can use &lt;code&gt;await&lt;/code&gt;, &lt;code&gt;async for&lt;/code&gt;, and &lt;code&gt;async with&lt;/code&gt; in between their &lt;code&gt;yield&lt;/code&gt; statements. As you might expect, you use &lt;code&gt;async for&lt;/code&gt; to iterate over them. &lt;a href=&quot;https://www.python.org/dev/peps/pep-0525&quot;&gt;&lt;strong&gt;PEP 525&lt;/strong&gt;&lt;/a&gt; has many more details if you want them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fae7612ee600857e3056834499b09dfc263d2c4" translate="yes" xml:space="preserve">
          <source>Python: 3.6+ (CPython and PyPy)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa77250d0ce1f733a13fed899dc4e3331be06f66" translate="yes" xml:space="preserve">
          <source>Quoting: more than you wanted to know</source>
          <target state="translated">Citando:más de lo que querías saber</target>
        </trans-unit>
        <trans-unit id="c3282cbbcba660116d62c007822229220838a1c6" translate="yes" xml:space="preserve">
          <source>RPC</source>
          <target state="translated">RPC</target>
        </trans-unit>
        <trans-unit id="31385a56c42dea75b0abfee3d065ac3faad4e1e6" translate="yes" xml:space="preserve">
          <source>Raised by &lt;a href=&quot;#trio.fail_after&quot;&gt;&lt;code&gt;fail_after()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.fail_at&quot;&gt;&lt;code&gt;fail_at()&lt;/code&gt;&lt;/a&gt; if the timeout expires.</source>
          <target state="translated">&lt;a href=&quot;#trio.fail_after&quot;&gt; &lt;code&gt;fail_after()&lt;/code&gt; &lt;/a&gt; por fail_after () y &lt;a href=&quot;#trio.fail_at&quot;&gt; &lt;code&gt;fail_at()&lt;/code&gt; &lt;/a&gt; si expira el tiempo de espera.</target>
        </trans-unit>
        <trans-unit id="ec13ded90b55c99ffb9020ca292f5ffb665682a1" translate="yes" xml:space="preserve">
          <source>Raised by &lt;a href=&quot;#trio.from_thread.run&quot;&gt;&lt;code&gt;trio.from_thread.run&lt;/code&gt;&lt;/a&gt; and similar functions if the corresponding call to &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt; has already finished.</source>
          <target state="translated">&lt;a href=&quot;#trio.from_thread.run&quot;&gt; &lt;code&gt;trio.from_thread.run&lt;/code&gt; &lt;/a&gt; por trio.from_thread.run y funciones similares si la llamada correspondiente a &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; ya ha finalizado.</target>
        </trans-unit>
        <trans-unit id="b9a61e9f5e58cb8abe086249f57467b310df32e1" translate="yes" xml:space="preserve">
          <source>Raised by &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; if we encounter a bug in Trio, or (possibly) a misuse of one of the low-level &lt;a href=&quot;reference-hazmat#module-trio.hazmat&quot;&gt;&lt;code&gt;trio.hazmat&lt;/code&gt;&lt;/a&gt; APIs.</source>
          <target state="translated">Generado por &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; si encontramos un error en Trio, o (posiblemente) un mal uso de una de las API de &lt;a href=&quot;reference-hazmat#module-trio.hazmat&quot;&gt; &lt;code&gt;trio.hazmat&lt;/code&gt; de&lt;/a&gt; bajo nivel .</target>
        </trans-unit>
        <trans-unit id="94fb968522f128e5c0cf1083f713016fb115a4f8" translate="yes" xml:space="preserve">
          <source>Raised by &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; if we encounter a bug in Trio, or (possibly) a misuse of one of the low-level &lt;a href=&quot;reference-lowlevel#module-trio.lowlevel&quot;&gt;&lt;code&gt;trio.lowlevel&lt;/code&gt;&lt;/a&gt; APIs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8913ddb4486c40268daf092227991759027600a9" translate="yes" xml:space="preserve">
          <source>Raised by &lt;code&gt;X_nowait&lt;/code&gt; functions if &lt;code&gt;X&lt;/code&gt; would block.</source>
          <target state="translated">&lt;code&gt;X_nowait&lt;/code&gt; por las funciones X_nowait si &lt;code&gt;X&lt;/code&gt; bloqueara.</target>
        </trans-unit>
        <trans-unit id="f210751ec099645a40a15f671e5b2c8300437cce" translate="yes" xml:space="preserve">
          <source>Raised by blocking calls if the surrounding scope has been cancelled.</source>
          <target state="translated">Levantado por el bloqueo de las llamadas si el alcance circundante ha sido cancelado.</target>
        </trans-unit>
        <trans-unit id="8f507b1f0875891aee3cdb80c4efd15c0b85e4cb" translate="yes" xml:space="preserve">
          <source>Raised when a task attempts to use a resource that some other task is already using, and this would lead to bugs and nonsense.</source>
          <target state="translated">Se plantea cuando una tarea intenta utilizar un recurso que alguna otra tarea ya está utilizando,y esto llevaría a errores y tonterías.</target>
        </trans-unit>
        <trans-unit id="c8678ba88e13f646dadb26c39c02dc28761beb10" translate="yes" xml:space="preserve">
          <source>Raised when an attempt to use a resource fails due to external circumstances.</source>
          <target state="translated">Se plantea cuando un intento de utilizar un recurso falla debido a circunstancias externas.</target>
        </trans-unit>
        <trans-unit id="812be58660608d36377923c7fc9cb3158c9268d0" translate="yes" xml:space="preserve">
          <source>Raised when attempting to use a resource after it has been closed.</source>
          <target state="translated">Se plantea cuando se intenta utilizar un recurso después de que ha sido cerrado.</target>
        </trans-unit>
        <trans-unit id="e09a1bdfa7a2f8848cd0c16df3025ec969cf49ad" translate="yes" xml:space="preserve">
          <source>Raised when trying to receive from a &lt;a href=&quot;reference-io#trio.abc.ReceiveChannel&quot;&gt;&lt;code&gt;trio.abc.ReceiveChannel&lt;/code&gt;&lt;/a&gt; that has no more data to receive.</source>
          <target state="translated">Se &lt;a href=&quot;reference-io#trio.abc.ReceiveChannel&quot;&gt; &lt;code&gt;trio.abc.ReceiveChannel&lt;/code&gt; &lt;/a&gt; cuando se intenta recibir de un trio.abc.ReceiveChannel que no tiene m&amp;aacute;s datos para recibir.</target>
        </trans-unit>
        <trans-unit id="c36d9458e0d1baae7403b5ce642a78b09e4acc7f" translate="yes" xml:space="preserve">
          <source>Raises</source>
          <target state="translated">Raises</target>
        </trans-unit>
        <trans-unit id="f3b46f6055aeafb16858767d1f89c1b6e9dfb653" translate="yes" xml:space="preserve">
          <source>Raising &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; means that the operation &lt;em&gt;did not happen&lt;/em&gt;. If a Trio socket&amp;rsquo;s &lt;code&gt;send&lt;/code&gt; method raises &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;, then no data was sent. If a Trio socket&amp;rsquo;s &lt;code&gt;recv&lt;/code&gt; method raises &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; then no data was lost &amp;ndash; it&amp;rsquo;s still sitting in the socket receive buffer waiting for you to call &lt;code&gt;recv&lt;/code&gt; again. And so forth.</source>
          <target state="translated">Aumento &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; significa que la operaci&amp;oacute;n &lt;em&gt;no se realiz&amp;oacute;&lt;/em&gt; . Si el m&amp;eacute;todo de &lt;code&gt;send&lt;/code&gt; un socket Trio aumenta &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; , no se enviaron datos. Si el m&amp;eacute;todo &lt;code&gt;recv&lt;/code&gt; de un socket Trio aumenta &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; entonces no se perdi&amp;oacute; ning&amp;uacute;n dato; todav&amp;iacute;a est&amp;aacute; en el b&amp;uacute;fer de recepci&amp;oacute;n del socket esperando a que llame a &lt;code&gt;recv&lt;/code&gt; nuevamente. Etc&amp;eacute;tera.</target>
        </trans-unit>
        <trans-unit id="99957346670542dddfd38b8ffe66adc228aa621a" translate="yes" xml:space="preserve">
          <source>Read some data from the underlying transport, decrypt it, and return it.</source>
          <target state="translated">Lea algunos datos del transporte subyacente,desencríbalos y devuélvalos.</target>
        </trans-unit>
        <trans-unit id="622b17203422ddf9aae4a69b56f076465c09ce46" translate="yes" xml:space="preserve">
          <source>Read-write, &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt;, default &lt;a href=&quot;https://docs.python.org/3/library/constants.html#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;. So long as this is set to &lt;a href=&quot;https://docs.python.org/3/library/constants.html#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt;, then the code inside this scope will not receive &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exceptions from scopes that are outside this scope. They can still receive &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exceptions from (1) this scope, or (2) scopes inside this scope. You can modify this attribute:</source>
          <target state="translated">Lectura-escritura, &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt; , predeterminado &lt;a href=&quot;https://docs.python.org/3/library/constants.html#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt; . Siempre que se establezca en &lt;a href=&quot;https://docs.python.org/3/library/constants.html#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt; , el c&amp;oacute;digo dentro de este &amp;aacute;mbito no recibir&amp;aacute; excepciones &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; de &amp;aacute;mbitos que est&amp;eacute;n fuera de este &amp;aacute;mbito. Todav&amp;iacute;a pueden recibir excepciones &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; de (1) este &amp;aacute;mbito o (2) &amp;aacute;mbitos dentro de este &amp;aacute;mbito. Puede modificar este atributo:</target>
        </trans-unit>
        <trans-unit id="41af808d2970aab6923b6bc6b45b747b999598be" translate="yes" xml:space="preserve">
          <source>Read-write, &lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;. An absolute time on the current run&amp;rsquo;s clock at which this scope will automatically become cancelled. You can adjust the deadline by modifying this attribute, e.g.:</source>
          <target state="translated">Leer-escribir, &lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; . Una hora absoluta en el reloj de la ejecuci&amp;oacute;n actual en la que este alcance se cancelar&amp;aacute; autom&amp;aacute;ticamente. Puede ajustar la fecha l&amp;iacute;mite modificando este atributo, por ejemplo:</target>
        </trans-unit>
        <trans-unit id="458a6d137741ae6f23c3a174667c35e2505c63ff" translate="yes" xml:space="preserve">
          <source>Readonly &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt;. Records whether cancellation has been requested for this scope, either by an explicit call to &lt;a href=&quot;#trio.CancelScope.cancel&quot;&gt;&lt;code&gt;cancel()&lt;/code&gt;&lt;/a&gt; or by the deadline expiring.</source>
          <target state="translated">Readonly &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt; . Registra si se ha solicitado la cancelaci&amp;oacute;n para este alcance, ya sea mediante una llamada expl&amp;iacute;cita a &lt;a href=&quot;#trio.CancelScope.cancel&quot;&gt; &lt;code&gt;cancel()&lt;/code&gt; &lt;/a&gt; o antes de que expire el plazo.</target>
        </trans-unit>
        <trans-unit id="988a546c2b4be4f19c6512e225ed82a3331a45e3" translate="yes" xml:space="preserve">
          <source>Readonly &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt;. Records whether this scope caught a &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception. This requires two things: (1) the &lt;code&gt;with&lt;/code&gt; block exited with a &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception, and (2) this scope is the one that was responsible for triggering this &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">Readonly &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt; . Registra si este &amp;aacute;mbito detect&amp;oacute; una excepci&amp;oacute;n &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; . Esto requiere dos cosas: (1) el bloque &lt;code&gt;with&lt;/code&gt; sali&amp;oacute; con una excepci&amp;oacute;n &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; , y (2) este alcance es el responsable de activar esta excepci&amp;oacute;n &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7c5c60d4ed263e6221b1ceafb46f52538e92cf77" translate="yes" xml:space="preserve">
          <source>Real-time chat: &lt;a href=&quot;https://gitter.im/python-trio/general&quot;&gt;https://gitter.im/python-trio/general&lt;/a&gt;</source>
          <target state="translated">Chat en tiempo real: &lt;a href=&quot;https://gitter.im/python-trio/general&quot;&gt;https://gitter.im/python-trio/general&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="172861d12b7ad2b9f1e7aa62cc9afb504e8366c2" translate="yes" xml:space="preserve">
          <source>Really? How is that possible?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b67be12710ea8d6de91ade39424c9d45cc879ca" translate="yes" xml:space="preserve">
          <source>Reattach a coroutine object that was detached using &lt;a href=&quot;#trio.hazmat.temporarily_detach_coroutine_object&quot;&gt;&lt;code&gt;temporarily_detach_coroutine_object()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Vuelva a adjuntar un objeto de corrutina que se separ&amp;oacute; usando &lt;a href=&quot;#trio.hazmat.temporarily_detach_coroutine_object&quot;&gt; &lt;code&gt;temporarily_detach_coroutine_object()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d82d4c2d1a2b3c4402ec7189cf603fbfe9b6dae2" translate="yes" xml:space="preserve">
          <source>Reattach a coroutine object that was detached using &lt;a href=&quot;#trio.lowlevel.temporarily_detach_coroutine_object&quot;&gt;&lt;code&gt;temporarily_detach_coroutine_object()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db1c784524e1b54011a95823026161f7c8517fe0" translate="yes" xml:space="preserve">
          <source>Reference</source>
          <target state="translated">Reference</target>
        </trans-unit>
        <trans-unit id="6b2f36e5ce6c6da01323540a9b37cff6c1903ffd" translate="yes" xml:space="preserve">
          <source>Regardless of these shenanigans, from &amp;ldquo;inside&amp;rdquo; Trio the passage of time still seems normal so long as you restrict yourself to Trio&amp;rsquo;s time functions (see &lt;a href=&quot;reference-core#time-and-clocks&quot;&gt;Time and clocks&lt;/a&gt;). Below is an example demonstrating two different ways of making time pass quickly. Notice how in both cases, the two tasks keep a consistent view of reality and events happen in the expected order, despite being wildly divorced from real time:</source>
          <target state="translated">Independientemente de estas travesuras, desde &amp;ldquo;dentro&amp;rdquo; de Trio, el paso del tiempo sigue pareciendo normal siempre que te limites a las funciones de tiempo de Trio (consulta &lt;a href=&quot;reference-core#time-and-clocks&quot;&gt;Tiempo y relojes&lt;/a&gt; ). A continuaci&amp;oacute;n se muestra un ejemplo que demuestra dos formas diferentes de hacer que el tiempo pase r&amp;aacute;pidamente. Observe c&amp;oacute;mo en ambos casos, las dos tareas mantienen una visi&amp;oacute;n coherente de la realidad y los eventos ocurren en el orden esperado, a pesar de estar totalmente divorciados del tiempo real:</target>
        </trans-unit>
        <trans-unit id="795fd0408cfdff7a235327985444734ec64c8053" translate="yes" xml:space="preserve">
          <source>Regular (synchronous) functions never contain any checkpoints.</source>
          <target state="translated">Las funciones regulares (sincrónicas)nunca contienen ningún punto de control.</target>
        </trans-unit>
        <trans-unit id="5044ba0a5cf607ebea4e58623c6417cb87f682bb" translate="yes" xml:space="preserve">
          <source>Release history</source>
          <target state="translated">Historia de la liberación</target>
        </trans-unit>
        <trans-unit id="b5e4913e6b00fb0411556eedb8df5d4e15248e9e" translate="yes" xml:space="preserve">
          <source>Release the lock.</source>
          <target state="translated">Suelte el cierre.</target>
        </trans-unit>
        <trans-unit id="dfdddac609bc6525864a46420d173e2db58b56da" translate="yes" xml:space="preserve">
          <source>Release the underlying lock.</source>
          <target state="translated">Libere el cierre subyacente.</target>
        </trans-unit>
        <trans-unit id="7416201cbf641c4c1cce64a7552e96979b9781a3" translate="yes" xml:space="preserve">
          <source>Represents a stream given the file descriptor to a pipe, TTY, etc.</source>
          <target state="translated">Representa un flujo dado el descriptor de archivo a una tubería,TTY,etc.</target>
        </trans-unit>
        <trans-unit id="ffed6ffb11cd49ae283b146510b560db62b29b16" translate="yes" xml:space="preserve">
          <source>Reschedule the given task with the given &lt;a href=&quot;https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome&quot;&gt;&lt;code&gt;outcome.Outcome&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Reprogramar la tarea dada con lo dado &lt;a href=&quot;https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome&quot;&gt; &lt;code&gt;outcome.Outcome&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4b80f008c17db60050b84c4982691f26b5d7ebd4" translate="yes" xml:space="preserve">
          <source>Resource handling:</source>
          <target state="translated">Manejo de recursos:</target>
        </trans-unit>
        <trans-unit id="f49ed1f90b5319324c89fc4cdc67d98d1d4982c1" translate="yes" xml:space="preserve">
          <source>Retrieve the &lt;a href=&quot;#trio.hazmat.TrioToken&quot;&gt;&lt;code&gt;TrioToken&lt;/code&gt;&lt;/a&gt; for the current call to &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Recupere el &lt;a href=&quot;#trio.hazmat.TrioToken&quot;&gt; &lt;code&gt;TrioToken&lt;/code&gt; &lt;/a&gt; para la llamada actual a &lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="66792bcbc1473b701de71be6f42b8e92ae36b2b4" translate="yes" xml:space="preserve">
          <source>Retrieve the &lt;a href=&quot;#trio.lowlevel.TrioToken&quot;&gt;&lt;code&gt;TrioToken&lt;/code&gt;&lt;/a&gt; for the current call to &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36c54ed6ac80bc981ae8ce5652b7aa7a424a0fb5" translate="yes" xml:space="preserve">
          <source>Retrieves data from the internal buffer, blocking if necessary.</source>
          <target state="translated">Recupera los datos del buffer interno,bloqueándolos si es necesario.</target>
        </trans-unit>
        <trans-unit id="080bc476ce5968af592b5c6db511e128987c5764" translate="yes" xml:space="preserve">
          <source>Retrieves data from the internal buffer, but doesn&amp;rsquo;t block.</source>
          <target state="translated">Recupera datos del b&amp;uacute;fer interno, pero no bloquea.</target>
        </trans-unit>
        <trans-unit id="4e1a7dbd8e538a02d36f4201744cfd7c212b56c8" translate="yes" xml:space="preserve">
          <source>Return True if the path contains one of the special names reserved by the system, if any.</source>
          <target state="translated">Devuelve True si el camino contiene uno de los nombres especiales reservados por el sistema,si los hay.</target>
        </trans-unit>
        <trans-unit id="2b7de1c01e3639d70c1301781596a03564716748" translate="yes" xml:space="preserve">
          <source>Return True if this path matches the given pattern.</source>
          <target state="translated">Return True si este camino coincide con el patrón dado.</target>
        </trans-unit>
        <trans-unit id="2c683d81b2e6785afd626708cbea723554ad9f98" translate="yes" xml:space="preserve">
          <source>Return a context manager that catches and re-throws exceptions after running &lt;a href=&quot;#trio.MultiError.filter&quot;&gt;&lt;code&gt;filter()&lt;/code&gt;&lt;/a&gt; on them.</source>
          <target state="translated">Devuelve un administrador de contexto que detecta y vuelve a lanzar excepciones despu&amp;eacute;s de ejecutar &lt;a href=&quot;#trio.MultiError.filter&quot;&gt; &lt;code&gt;filter()&lt;/code&gt; &lt;/a&gt; en ellas.</target>
        </trans-unit>
        <trans-unit id="74511c6068e3de9f3c1e1c2e39a44b3f12a40aef" translate="yes" xml:space="preserve">
          <source>Return a new path with the file name changed.</source>
          <target state="translated">Devuelve una nueva ruta con el nombre del archivo cambiado.</target>
        </trans-unit>
        <trans-unit id="a4759abd8edb019bf0eb31c08f831d77c495f661" translate="yes" xml:space="preserve">
          <source>Return a new path with the file suffix changed (or added, if none).</source>
          <target state="translated">Devuelve una nueva ruta con el sufijo del archivo cambiado (o añadido,si no hay ninguno).</target>
        </trans-unit>
        <trans-unit id="ac965bd810cca2d151b9c317c0c1f717fdc23a4a" translate="yes" xml:space="preserve">
          <source>Return a new path with the file suffix changed. If the path has no suffix, add given suffix. If the given suffix is an empty string, remove the suffix from the path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ce261ae05a052a4b5be129bb11ccb492e6a1503" translate="yes" xml:space="preserve">
          <source>Return an object containing debugging information.</source>
          <target state="translated">Devolver un objeto que contenga información de depuración.</target>
        </trans-unit>
        <trans-unit id="9e2277903dc895b3ac624e58f32470f044f28fb7" translate="yes" xml:space="preserve">
          <source>Return the &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; object representing the current task.</source>
          <target state="translated">Devuelve el objeto &lt;a href=&quot;#trio.hazmat.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; que representa la tarea actual.</target>
        </trans-unit>
        <trans-unit id="ffc01c08a6086dd43715f1c09998f077de8e82d4" translate="yes" xml:space="preserve">
          <source>Return the &lt;a href=&quot;#trio.lowlevel.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; object representing the current task.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40cff98535909e183f92699de8527946109d976c" translate="yes" xml:space="preserve">
          <source>Return the current time, according to this clock.</source>
          <target state="translated">Devuelve la hora actual,según este reloj.</target>
        </trans-unit>
        <trans-unit id="b9db5a47ba6655c11616c8e26b190ca54f43e5a1" translate="yes" xml:space="preserve">
          <source>Return the current value of the internal flag.</source>
          <target state="translated">Devuelve el valor actual de la bandera interna.</target>
        </trans-unit>
        <trans-unit id="6de731f34f98b206fa3aeb0d1060258ec569f0dd" translate="yes" xml:space="preserve">
          <source>Return the path as a &amp;lsquo;file&amp;rsquo; URI.</source>
          <target state="translated">Devuelve la ruta como un URI de 'archivo'.</target>
        </trans-unit>
        <trans-unit id="b492c123430d5d95ccde60278f71b4c1ea4e2eec" translate="yes" xml:space="preserve">
          <source>Return the relative path to another path identified by the passed arguments. If the operation is not possible (because this is not a subpath of the other path), raise ValueError.</source>
          <target state="translated">Devuelve el camino relativo a otro camino identificado por los argumentos pasados.Si la operación no es posible (porque no se trata de un subcamino del otro camino),aumente el ValorError.</target>
        </trans-unit>
        <trans-unit id="8aff8be4dee4d25bccba9aa66ee0802992b16399" translate="yes" xml:space="preserve">
          <source>Return the string representation of the path with forward (/) slashes.</source>
          <target state="translated">Devuelve la representación de la cadena del camino con barras oblicuas hacia adelante (/).</target>
        </trans-unit>
        <trans-unit id="41b1fb407b7fa442b77381701968fb175362cf78" translate="yes" xml:space="preserve">
          <source>Return type</source>
          <target state="translated">Tipo de retorno</target>
        </trans-unit>
        <trans-unit id="9582a02f141fc4b345b2936eba691cd0654efebc" translate="yes" xml:space="preserve">
          <source>Returns</source>
          <target state="translated">Returns</target>
        </trans-unit>
        <trans-unit id="c96e2a604937c0e7bde09850d1e81c88f183872e" translate="yes" xml:space="preserve">
          <source>Returns an async context manager which must be used to create a new &lt;a href=&quot;#trio.Nursery&quot;&gt;&lt;code&gt;Nursery&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Devuelve un administrador de contexto asincr&amp;oacute;nico que debe usarse para crear un nuevo &lt;a href=&quot;#trio.Nursery&quot;&gt; &lt;code&gt;Nursery&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="80c3bba28aba9ac5aa2b9e543b569c7c5f7fea4f" translate="yes" xml:space="preserve">
          <source>Returns an object containing run-loop-level debugging information.</source>
          <target state="translated">Devuelve un objeto que contiene información de depuración a nivel de bucle de ejecución.</target>
        </trans-unit>
        <trans-unit id="2cb60cb3bef90903444e5b5db55efe97c53982f7" translate="yes" xml:space="preserve">
          <source>Returns or raises whatever the given function returns or raises. It can also raise exceptions of its own:</source>
          <target state="translated">Devuelve o eleva lo que sea que la función dada devuelva o eleve.También puede hacer excepciones por sí misma:</target>
        </trans-unit>
        <trans-unit id="aa20168c5bc2ca247ebd21af6add01da22b9fffa" translate="yes" xml:space="preserve">
          <source>Returns or raises whatever value or exception the new coroutine runner uses to resume the coroutine.</source>
          <target state="translated">Devuelve o aumenta cualquier valor o excepción que el nuevo corredor de corrotina utilice para reanudar la corrotina.</target>
        </trans-unit>
        <trans-unit id="20294a5b79e17adf4e2aab73007106887f91c20b" translate="yes" xml:space="preserve">
          <source>Returns the current &lt;a href=&quot;reference-core#trio.abc.Clock&quot;&gt;&lt;code&gt;Clock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Devuelve el &lt;a href=&quot;reference-core#trio.abc.Clock&quot;&gt; &lt;code&gt;Clock&lt;/code&gt; &lt;/a&gt; actual .</target>
        </trans-unit>
        <trans-unit id="679a2125dd0230bf3c09de4ff94a0c29225879ae" translate="yes" xml:space="preserve">
          <source>Returns the current effective deadline for the current task.</source>
          <target state="translated">Devuelve el plazo efectivo actual para la tarea actual.</target>
        </trans-unit>
        <trans-unit id="49f9754b2c2c4e3016fdc4a20e1aa41028fdabce" translate="yes" xml:space="preserve">
          <source>Returns the current root &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Devuelve la &lt;a href=&quot;#trio.hazmat.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; ra&amp;iacute;z actual .</target>
        </trans-unit>
        <trans-unit id="f26d907db25ce85ad64fed0bf0492134d89dd298" translate="yes" xml:space="preserve">
          <source>Returns the current root &lt;a href=&quot;#trio.lowlevel.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3612705c9bdde6883ff6d46dc9b98bfbf29c4eae" translate="yes" xml:space="preserve">
          <source>Returns the current time according to Trio&amp;rsquo;s internal clock.</source>
          <target state="translated">Devuelve la hora actual seg&amp;uacute;n el reloj interno de Trio.</target>
        </trans-unit>
        <trans-unit id="7878f5fff79cb7db6499b67fc37025bc26400d93" translate="yes" xml:space="preserve">
          <source>Returns the exit status of the process (an integer), or &lt;code&gt;None&lt;/code&gt; if it&amp;rsquo;s still running.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e44dffb19df07ef8414c3c376c6a86a1a10a965c" translate="yes" xml:space="preserve">
          <source>Run &lt;code&gt;command&lt;/code&gt; in a subprocess, wait for it to complete, and return a &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess&quot;&gt;&lt;code&gt;subprocess.CompletedProcess&lt;/code&gt;&lt;/a&gt; instance describing the results.</source>
          <target state="translated">Ejecute el &lt;code&gt;command&lt;/code&gt; en un subproceso, espere a que se complete y devuelva una instancia de &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess&quot;&gt; &lt;code&gt;subprocess.CompletedProcess&lt;/code&gt; &lt;/a&gt; describe los resultados.</target>
        </trans-unit>
        <trans-unit id="9b56c81b5d7d12e057ce71207675707f4d4076b3" translate="yes" xml:space="preserve">
          <source>Run a Trio-flavored async function, and return the result.</source>
          <target state="translated">Ejecute una función de asincronización con sabor a trío y devuelva el resultado.</target>
        </trans-unit>
        <trans-unit id="3069c0b08119487d8f7d1632a416d89c4e11b6b0" translate="yes" xml:space="preserve">
          <source>Run all the user tasks that care about whatever happened, then go back to step 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="174632bdc2efcc209e6ec485f5e4d89bb42f99f2" translate="yes" xml:space="preserve">
          <source>Run the given async function in the parent Trio thread, blocking until it is complete.</source>
          <target state="translated">Ejecutar la función de asincronización dada en el hilo padre del Trío,bloqueando hasta que se complete.</target>
        </trans-unit>
        <trans-unit id="28b11b8b05a27dee7e81c6c4786ce2373923cc39" translate="yes" xml:space="preserve">
          <source>Run the given sync function in the parent Trio thread, blocking until it is complete.</source>
          <target state="translated">Ejecutar la función de sincronización dada en el hilo del Trío padre,bloqueando hasta que se complete.</target>
        </trans-unit>
        <trans-unit id="34ee226c47ee6762c22038b1355ef784957e69c9" translate="yes" xml:space="preserve">
          <source>Running a process and waiting for it to finish</source>
          <target state="translated">Ejecutar un proceso y esperar a que termine</target>
        </trans-unit>
        <trans-unit id="406df0a14f42befaa2bb7b1d46dd4d5add32f410" translate="yes" xml:space="preserve">
          <source>Runs &lt;code&gt;deliver(outcome.capture(fn))&lt;/code&gt; in a worker thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28b93c4a93cb10440b0c2043a668f9b2550390d8" translate="yes" xml:space="preserve">
          <source>SSL / TLS support</source>
          <target state="translated">Soporte para SSL/TLS</target>
        </trans-unit>
        <trans-unit id="489409f79750bf468b370ea47ddb451641966d82" translate="yes" xml:space="preserve">
          <source>Safer KeyboardInterrupt handling</source>
          <target state="translated">Teclado más seguroManejo de interrupciones</target>
        </trans-unit>
        <trans-unit id="c1463bcfc0ca2f582b52b93c0e116a9d627535ee" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;#trio.testing.MemoryReceiveStream.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">Igual que &lt;a href=&quot;#trio.testing.MemoryReceiveStream.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; , pero asincr&amp;oacute;nico.</target>
        </trans-unit>
        <trans-unit id="78d9d80923f156d407da12642698cb124013560a" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;#trio.testing.MemorySendStream.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">Igual que &lt;a href=&quot;#trio.testing.MemorySendStream.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; , pero asincr&amp;oacute;nico.</target>
        </trans-unit>
        <trans-unit id="41dd02db4d1d296325376880af0f9c7686740d69" translate="yes" xml:space="preserve">
          <source>Schedule a call to &lt;code&gt;sync_fn(*args)&lt;/code&gt; to occur in the context of a Trio task.</source>
          <target state="translated">Programe una llamada a &lt;code&gt;sync_fn(*args)&lt;/code&gt; para que ocurra en el contexto de una tarea Trio.</target>
        </trans-unit>
        <trans-unit id="4651a34e4df9619783ad372f905d6d3b84e9d76d" translate="yes" xml:space="preserve">
          <source>Scope</source>
          <target state="translated">Scope</target>
        </trans-unit>
        <trans-unit id="43ddf283f03fda4643fe2db02659e6fb64a89999" translate="yes" xml:space="preserve">
          <source>Search Page</source>
          <target state="translated">Página de búsqueda</target>
        </trans-unit>
        <trans-unit id="80b5d0fdd320e64dcfebdd2de89e39320073fa6c" translate="yes" xml:space="preserve">
          <source>Second, it avoids a small race condition that could cause too many threads to be spawned. Consider a program that wants to run several jobs sequentially on a thread, so the main thread submits a job, waits for it to finish, submits another job, etc. In theory, this program should only need one worker thread. But what could happen is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df039209c5e4aa55542bc5803836ccf099d8bfd1" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.Nursery.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Ver &lt;a href=&quot;#trio.Nursery.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7e621a2c3de8ee6dee87fb0fe1692f8bfdce4856" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.abc.Listener.accept&quot;&gt;&lt;code&gt;trio.abc.Listener.accept()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">Consulte &lt;a href=&quot;#trio.abc.Listener.accept&quot;&gt; &lt;code&gt;trio.abc.Listener.accept()&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="73fe6c344e72648d421d8761612fae248f51b59c" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.abc.ReceiveStream.receive_some&quot;&gt;&lt;code&gt;trio.abc.ReceiveStream.receive_some()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">Consulte &lt;a href=&quot;#trio.abc.ReceiveStream.receive_some&quot;&gt; &lt;code&gt;trio.abc.ReceiveStream.receive_some()&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="c5d2965756a1219162c7b103b7912b613c75d332" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt;&lt;code&gt;trio.abc.SendStream.send_all()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">Consulte &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt; &lt;code&gt;trio.abc.SendStream.send_all()&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="6dee4e334c48c5ee0fa6e7c0ee8c33b4b0f14005" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.abc.SendStream.wait_send_all_might_not_block&quot;&gt;&lt;code&gt;trio.abc.SendStream.wait_send_all_might_not_block()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Consulte &lt;a href=&quot;#trio.abc.SendStream.wait_send_all_might_not_block&quot;&gt; &lt;code&gt;trio.abc.SendStream.wait_send_all_might_not_block()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="90cbf068fcbe2871096db617137f8324a4d715a8" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.hazmat.ParkingLot.repark&quot;&gt;&lt;code&gt;repark()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">Consulte &lt;a href=&quot;#trio.hazmat.ParkingLot.repark&quot;&gt; &lt;code&gt;repark()&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="d7d9cdee543f24de74e0f6d27ef26632818b0ba4" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.hazmat.wait_readable&quot;&gt;&lt;code&gt;wait_readable&lt;/code&gt;&lt;/a&gt; for the definition of &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">Consulte &lt;a href=&quot;#trio.hazmat.wait_readable&quot;&gt; &lt;code&gt;wait_readable&lt;/code&gt; &lt;/a&gt; para conocer la definici&amp;oacute;n de &lt;code&gt;obj&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88cef7e47405de4633e88af131cdd34ba4e03bc8" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">Consulte &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="651cf48dfdd28ee21722da4947614b8beb329452" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt; for the gory details.</source>
          <target state="translated">Vea &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; para los detalles sangrientos.</target>
        </trans-unit>
        <trans-unit id="6338a66d131ec077fd5cf4994f6ac8bc5a3607e5" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.lowlevel.ParkingLot.repark&quot;&gt;&lt;code&gt;repark()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f062d4e4c9b77a3f837df4dc406fce877af582d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.lowlevel.wait_readable&quot;&gt;&lt;code&gt;wait_readable&lt;/code&gt;&lt;/a&gt; for the definition of &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b1d56927b75db5a5d6b3b5859efab6f226dc4e5" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.lowlevel.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9cf5378d0030c81aa5834f4e0b4d32c351240ce" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.lowlevel.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt; for the gory details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="016a67642a7abe850f2386f09f565400bd916ea3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.socket.set_custom_hostname_resolver&quot;&gt;&lt;code&gt;trio.socket.set_custom_hostname_resolver()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Consulte &lt;a href=&quot;#trio.socket.set_custom_hostname_resolver&quot;&gt; &lt;code&gt;trio.socket.set_custom_hostname_resolver()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fcf3667ecc461134130b73df4a3a1d6ca1ac4046" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.socket.set_custom_socket_factory&quot;&gt;&lt;code&gt;trio.socket.set_custom_socket_factory()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Consulte &lt;a href=&quot;#trio.socket.set_custom_socket_factory&quot;&gt; &lt;code&gt;trio.socket.set_custom_socket_factory()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fc3b685f1d1be464dec386dc17d73a54dacf00d6" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.testing.MemorySendStream.get_data&quot;&gt;&lt;code&gt;get_data()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">Consulte &lt;a href=&quot;#trio.testing.MemorySendStream.get_data&quot;&gt; &lt;code&gt;get_data()&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="4f274048841d456d97381e6b6644e2472a7ccda0" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.getsockopt&quot;&gt;&lt;code&gt;socket.socket.getsockopt()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">Consulte &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.getsockopt&quot;&gt; &lt;code&gt;socket.socket.getsockopt()&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="f6839040a73e62c001a4d5d6b3a8b294c0e57bdc" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.setsockopt&quot;&gt;&lt;code&gt;socket.socket.setsockopt()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">Consulte &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.setsockopt&quot;&gt; &lt;code&gt;socket.socket.setsockopt()&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="2d72e5152dd898769a56b0fe337a4d1a861b2fea" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;reference-io#trio.abc.ReceiveChannel.receive&quot;&gt;&lt;code&gt;ReceiveChannel.receive&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Consulte &lt;a href=&quot;reference-io#trio.abc.ReceiveChannel.receive&quot;&gt; &lt;code&gt;ReceiveChannel.receive&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="58963e593c50f94f790638ce7556a275bcd204f2" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt;&lt;code&gt;SendChannel.send&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Consulte &lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt; &lt;code&gt;SendChannel.send&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">Ver también</target>
        </trans-unit>
        <trans-unit id="f42e748c32f2195bd9faf81004af69032f05fc79" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#trio.aclose_forcefully&quot;&gt;&lt;code&gt;trio.aclose_forcefully()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Vea tambi&amp;eacute;n: &lt;a href=&quot;#trio.aclose_forcefully&quot;&gt; &lt;code&gt;trio.aclose_forcefully()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="158e95efe6c006cd04a0b4b2d0f6161646c045e5" translate="yes" xml:space="preserve">
          <source>Send an end-of-file indication on this stream, if possible.</source>
          <target state="translated">Envíe una indicación de fin de archivo en este flujo,si es posible.</target>
        </trans-unit>
        <trans-unit id="85da9214bbeac1196611983abddcebb768d2fc49" translate="yes" xml:space="preserve">
          <source>Send signal &lt;code&gt;sig&lt;/code&gt; to the process.</source>
          <target state="translated">Enviar se&amp;ntilde;al &lt;code&gt;sig&lt;/code&gt; al proceso.</target>
        </trans-unit>
        <trans-unit id="e634d246bcec48e110a516c9e0d7d7b2041045d0" translate="yes" xml:space="preserve">
          <source>Sends the given data through the stream, blocking if necessary.</source>
          <target state="translated">Envía los datos dados a través de la corriente,bloqueándolos si es necesario.</target>
        </trans-unit>
        <trans-unit id="ee954ecd822c7acfded07c0cc1fd9c091103b687" translate="yes" xml:space="preserve">
          <source>Set a custom hostname resolver.</source>
          <target state="translated">Configure una resolución de nombre de host personalizada.</target>
        </trans-unit>
        <trans-unit id="62fd9617b6da2daed723cb8babe107460a7aae70" translate="yes" xml:space="preserve">
          <source>Set a custom socket object factory.</source>
          <target state="translated">Establecer una fábrica de objetos de enchufe a medida.</target>
        </trans-unit>
        <trans-unit id="5f98ea86f41a048ead986b6dc184184bdc19c8ce" translate="yes" xml:space="preserve">
          <source>Set an option on the underlying socket.</source>
          <target state="translated">Ponga una opción en el enchufe subyacente.</target>
        </trans-unit>
        <trans-unit id="d7151175b4f06e30011860dd29520ea7ed6e51f2" translate="yes" xml:space="preserve">
          <source>Set the internal flag value to True, and wake any waiting tasks.</source>
          <target state="translated">Ponga el valor de la bandera interna en Verdadero,y despierte cualquier tarea de espera.</target>
        </trans-unit>
        <trans-unit id="0ff0e99264a92cdda9a69ac291e7a0266785bdd2" translate="yes" xml:space="preserve">
          <source>Setting a custom hostname resolver affects all future calls to &lt;a href=&quot;reference-io#trio.socket.getaddrinfo&quot;&gt;&lt;code&gt;getaddrinfo()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;reference-io#trio.socket.getnameinfo&quot;&gt;&lt;code&gt;getnameinfo()&lt;/code&gt;&lt;/a&gt; within the enclosing call to &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt;. All other hostname resolution in Trio is implemented in terms of these functions.</source>
          <target state="translated">La configuraci&amp;oacute;n de un solucionador de nombre de host personalizado afecta todas las llamadas futuras a &lt;a href=&quot;reference-io#trio.socket.getaddrinfo&quot;&gt; &lt;code&gt;getaddrinfo()&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;reference-io#trio.socket.getnameinfo&quot;&gt; &lt;code&gt;getnameinfo()&lt;/code&gt; &lt;/a&gt; dentro de la llamada &lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; a trio.run () . Todas las dem&amp;aacute;s resoluciones de nombres de host en Trio se implementan en t&amp;eacute;rminos de estas funciones.</target>
        </trans-unit>
        <trans-unit id="9f5e3bbf7985a9dab01cc08204725bd79c4bf118" translate="yes" xml:space="preserve">
          <source>Setting a custom socket factory affects all future calls to &lt;a href=&quot;reference-io#trio.socket.socket&quot;&gt;&lt;code&gt;socket()&lt;/code&gt;&lt;/a&gt; within the enclosing call to &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La configuraci&amp;oacute;n de una f&amp;aacute;brica de sockets personalizada afecta a todas las futuras llamadas a &lt;a href=&quot;reference-io#trio.socket.socket&quot;&gt; &lt;code&gt;socket()&lt;/code&gt; &lt;/a&gt; dentro de la llamada &lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; a trio.run () .</target>
        </trans-unit>
        <trans-unit id="b5f69ef7d9833414a1ee8b90a0835b9fff2745ad" translate="yes" xml:space="preserve">
          <source>Shuts down the send side of the stream.</source>
          <target state="translated">Cierra el lado de envío de la corriente.</target>
        </trans-unit>
        <trans-unit id="2346a18ea3002ff04eca3a130c7f40e65c56f0c9" translate="yes" xml:space="preserve">
          <source>Signals</source>
          <target state="translated">Signals</target>
        </trans-unit>
        <trans-unit id="8b3df0abd55afcfcab7033b5dc2c6d404832e669" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.connect&quot;&gt;&lt;code&gt;socket.socket.connect()&lt;/code&gt;&lt;/a&gt;, except async.</source>
          <target state="translated">Similar a &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.connect&quot;&gt; &lt;code&gt;socket.socket.connect()&lt;/code&gt; &lt;/a&gt; , excepto async.</target>
        </trans-unit>
        <trans-unit id="ff3c0775338ca43ecdf1b17d743dad954391ca69" translate="yes" xml:space="preserve">
          <source>Simple integration and broad compatibility: pretty much every event loop offers some threadsafe &amp;ldquo;schedule a callback&amp;rdquo; operation, and that&amp;rsquo;s all you need to use it as a host loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="195fcbdedfbd716b2508e3c94ddbf5266f253623" translate="yes" xml:space="preserve">
          <source>Since all of the tasks are running concurrently inside the &lt;code&gt;async
with&lt;/code&gt; block, the block does not exit until &lt;em&gt;all&lt;/em&gt; tasks have completed. If you&amp;rsquo;ve used other concurrency frameworks, then you can think of it as, the de-indentation at the end of the &lt;code&gt;async with&lt;/code&gt; automatically &amp;ldquo;joins&amp;rdquo; (waits for) all of the tasks in the nursery.</source>
          <target state="translated">Dado que todas las tareas se ejecutan simult&amp;aacute;neamente dentro del bloque &lt;code&gt;async with&lt;/code&gt; , el bloque no se cierra hasta que se hayan completado &lt;em&gt;todas las&lt;/em&gt; tareas. Si ha utilizado otros marcos de concurrencia, puede pensar en ello como la eliminaci&amp;oacute;n de sangr&amp;iacute;a al final del &lt;code&gt;async with&lt;/code&gt; autom&amp;aacute;ticamente &quot;une&quot; (espera) todas las tareas en el vivero.</target>
        </trans-unit>
        <trans-unit id="5e123adcb2343580f3c45b40dc7e669799bca848" translate="yes" xml:space="preserve">
          <source>Since all tasks are descendents of the initial task, one consequence of this is that &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; can&amp;rsquo;t finish until all tasks have finished.</source>
          <target state="translated">Dado que todas las tareas son descendientes de la tarea inicial, una consecuencia de esto es que &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; no puede finalizar hasta que todas las tareas hayan finalizado.</target>
        </trans-unit>
        <trans-unit id="ccb2ec4f90e25bdaf10ffc4e52048eb34a6ada6d" translate="yes" xml:space="preserve">
          <source>Since process creation takes a single arguments string, &lt;code&gt;CMD.EXE&lt;/code&gt;&amp;rsquo;s quoting does not influence word splitting, and double quotes are not removed during CMD.EXE&amp;rsquo;s expansion pass. Double quotes are troublesome because CMD.EXE handles them differently from the MSVC runtime rules; in:</source>
          <target state="translated">Dado que la creaci&amp;oacute;n del proceso toma una sola cadena de argumentos, las &lt;code&gt;CMD.EXE&lt;/code&gt; de CMD.EXE no influyen en la divisi&amp;oacute;n de palabras y las comillas dobles no se eliminan durante la pasada de expansi&amp;oacute;n de CMD.EXE. Las comillas dobles son problem&amp;aacute;ticas porque CMD.EXE las maneja de manera diferente a las reglas de tiempo de ejecuci&amp;oacute;n de MSVC; en:</target>
        </trans-unit>
        <trans-unit id="0645778ef10db9cd86497528da43c38ced2e921f" translate="yes" xml:space="preserve">
          <source>Since process creation takes a single arguments string, &lt;code&gt;CMD.EXE&lt;/code&gt;'s quoting does not influence word splitting, and double quotes are not removed during CMD.EXE&amp;rsquo;s expansion pass. Double quotes are troublesome because CMD.EXE handles them differently from the MSVC runtime rules; in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e290ea0e39f01d4b842c1a165cd9781b38eb4ba" translate="yes" xml:space="preserve">
          <source>Since this hooks into Trio at a rather low level, you do have to be careful. The callbacks are run synchronously, and in many cases if they error out then there isn&amp;rsquo;t any plausible way to propagate this exception (for instance, we might be deep in the guts of the exception propagation machinery&amp;hellip;). Therefore our &lt;a href=&quot;https://github.com/python-trio/trio/issues/47&quot;&gt;current strategy&lt;/a&gt; for handling exceptions raised by instruments is to (a) log an exception to the &lt;code&gt;&quot;trio.abc.Instrument&quot;&lt;/code&gt; logger, which by default prints a stack trace to standard error and (b) disable the offending instrument.</source>
          <target state="translated">Dado que esto se engancha en Trio a un nivel bastante bajo, debes tener cuidado. Las devoluciones de llamada se ejecutan sincr&amp;oacute;nicamente y, en muchos casos, si se producen errores, no hay ninguna forma plausible de propagar esta excepci&amp;oacute;n (por ejemplo, podr&amp;iacute;amos estar metidos en las entra&amp;ntilde;as de la maquinaria de propagaci&amp;oacute;n de excepciones ...). Por lo tanto, nuestra &lt;a href=&quot;https://github.com/python-trio/trio/issues/47&quot;&gt;estrategia actual&lt;/a&gt; para manejar las excepciones generadas por los instrumentos es (a) registrar una excepci&amp;oacute;n en el registrador &lt;code&gt;&quot;trio.abc.Instrument&quot;&lt;/code&gt; , que por defecto imprime un seguimiento de la pila para el error est&amp;aacute;ndar y (b) deshabilitar el instrumento infractor.</target>
        </trans-unit>
        <trans-unit id="703d59254915506775b33344a3a18adcf8c5850f" translate="yes" xml:space="preserve">
          <source>Sleeping and waking</source>
          <target state="translated">Dormir y despertar</target>
        </trans-unit>
        <trans-unit id="79b43696209af601ceb794aac489696d99bde999" translate="yes" xml:space="preserve">
          <source>So far, so good. Unfortunately, Python provides no guarantees about &lt;em&gt;when&lt;/em&gt; this happens. It could be as soon as you break out of the &lt;code&gt;async for&lt;/code&gt; loop, or an arbitrary amount of time later. It could even be after the entire Trio run has finished! Just about the only guarantee is that it &lt;em&gt;won&amp;rsquo;t&lt;/em&gt; happen in the task that was using the generator. That task will continue on with whatever else it&amp;rsquo;s doing, and the async generator cleanup will happen &amp;ldquo;sometime later, somewhere else&amp;rdquo;: potentially with different context variables, not subject to timeouts, and/or after any nurseries you&amp;rsquo;re using have been closed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="177046c4af35e4336df197889f9ee07eb5aa6ce4" translate="yes" xml:space="preserve">
          <source>So long as you&amp;rsquo;re inside a scope with &lt;code&gt;shield = True&lt;/code&gt; set, then you&amp;rsquo;ll be protected from outside cancellations. Note though that this &lt;em&gt;only&lt;/em&gt; applies to &lt;em&gt;outside&lt;/em&gt; cancellations: if &lt;code&gt;CLEANUP_TIMEOUT&lt;/code&gt; expires then &lt;code&gt;await conn.send_goodbye_msg()&lt;/code&gt; will still be cancelled, and if &lt;code&gt;await conn.send_goodbye_msg()&lt;/code&gt; call uses any timeouts internally, then those will continue to work normally as well. This is a pretty advanced feature that most people probably won&amp;rsquo;t use, but it&amp;rsquo;s there for the rare cases where you need it.</source>
          <target state="translated">Siempre que est&amp;eacute; dentro de un alcance con &lt;code&gt;shield = True&lt;/code&gt; establecido, estar&amp;aacute; protegido de cancelaciones externas. Sin embargo, &lt;code&gt;CLEANUP_TIMEOUT&lt;/code&gt; cuenta que esto &lt;em&gt;solo se&lt;/em&gt; aplica a las cancelaciones &lt;em&gt;externas&lt;/em&gt; : si CLEANUP_TIMEOUT expira, &lt;code&gt;await conn.send_goodbye_msg()&lt;/code&gt; a&amp;uacute;n se cancelar&amp;aacute;, y si la llamada &lt;code&gt;await conn.send_goodbye_msg()&lt;/code&gt; usa alg&amp;uacute;n tiempo de espera internamente, esos continuar&amp;aacute;n funcionando normalmente tambi&amp;eacute;n. Esta es una caracter&amp;iacute;stica bastante avanzada que la mayor&amp;iacute;a de la gente probablemente no usar&amp;aacute;, pero est&amp;aacute; ah&amp;iacute; para los raros casos en que la necesita.</target>
        </trans-unit>
        <trans-unit id="eacc0cea5faa2540efcfce1aec9fc9bc5a14d8d1" translate="yes" xml:space="preserve">
          <source>So that&amp;rsquo;s great, but &amp;ndash; how do we know whether we&amp;rsquo;re in one of the sensitive parts of the program or not?</source>
          <target state="translated">Eso es genial, pero, &amp;iquest;c&amp;oacute;mo sabemos si estamos en una de las partes sensibles del programa o no?</target>
        </trans-unit>
        <trans-unit id="8a08024d671c4e56a036c4b52ad5c32416c73f48" translate="yes" xml:space="preserve">
          <source>So when you&amp;rsquo;re doing code review on a project that uses Trio, one of the things you&amp;rsquo;ll want to think about is whether there are enough checkpoints, and whether each one is handled correctly. Of course this means you need a way to recognize checkpoints. How do you do that? The underlying principle is that any operation that blocks has to be a checkpoint. This makes sense: if an operation blocks, then it might block for a long time, and you&amp;rsquo;ll want to be able to cancel it if a timeout expires; and in any case, while this task is blocked we want another task to be scheduled to run so our code can make full use of the CPU.</source>
          <target state="translated">Entonces, cuando est&amp;eacute; revisando el c&amp;oacute;digo en un proyecto que usa Trio, una de las cosas en las que querr&amp;aacute; pensar es si hay suficientes puntos de control y si cada uno se maneja correctamente. Por supuesto, esto significa que necesita una forma de reconocer los puntos de control. &amp;iquest;C&amp;oacute;mo haces eso? El principio subyacente es que cualquier operaci&amp;oacute;n que bloquee tiene que ser un punto de control. Esto tiene sentido: si una operaci&amp;oacute;n se bloquea, es posible que se bloquee durante mucho tiempo, y querr&amp;aacute; poder cancelarla si expira el tiempo de espera; y en cualquier caso, mientras esta tarea est&amp;eacute; bloqueada queremos que se programe otra tarea para que se ejecute para que nuestro c&amp;oacute;digo pueda hacer un uso completo de la CPU.</target>
        </trans-unit>
        <trans-unit id="94f1cedea7c4796760fe90eed253e295e38abb27" translate="yes" xml:space="preserve">
          <source>So you can see that the producer runs ahead by 3 messages, and then stops to wait: when the consumer reads message 1, it sends message 4, then when the consumer reads message 2, it sends message 5, and so on. Once it reaches the steady state, this version acts just like our previous version where we set the buffer size to 0, except that it uses a bit more memory and each message sits in the buffer for a bit longer before being processed (i.e., the message latency is higher).</source>
          <target state="translated">Así que puedes ver que el productor se adelanta por 3 mensajes,y luego se detiene a esperar:cuando el consumidor lee el mensaje 1,envía el mensaje 4,luego cuando el consumidor lee el mensaje 2,envía el mensaje 5,y así sucesivamente.Una vez que alcanza el estado estable,esta versión actúa igual que nuestra versión anterior,en la que fijamos el tamaño del buffer en 0,excepto que utiliza un poco más de memoria y cada mensaje permanece en el buffer durante un poco más de tiempo antes de ser procesado (es decir,la latencia del mensaje es mayor).</target>
        </trans-unit>
        <trans-unit id="daa57596ade9bdcbd1f251fa5b9ed91ad7cb1852" translate="yes" xml:space="preserve">
          <source>So, we can see that it&amp;rsquo;s important to be able to change the policy controlling the allocation of threads to jobs. But in many frameworks, this requires implementing a new thread pool from scratch, which is highly non-trivial; and if different types of jobs need different policies, then you may have to create multiple pools, which is inefficient because now you effectively have two different thread caches that aren&amp;rsquo;t sharing resources.</source>
          <target state="translated">Entonces, podemos ver que es importante poder cambiar la pol&amp;iacute;tica que controla la asignaci&amp;oacute;n de subprocesos a los trabajos. Pero en muchos frameworks, esto requiere implementar un nuevo grupo de subprocesos desde cero, lo cual no es trivial; y si diferentes tipos de trabajos necesitan diferentes pol&amp;iacute;ticas, entonces es posible que deba crear varios grupos, lo cual es ineficiente porque ahora tiene dos cach&amp;eacute;s de subprocesos diferentes que no comparten recursos.</target>
        </trans-unit>
        <trans-unit id="c798110762fd844baf0b5cdc9832d8c71d67602a" translate="yes" xml:space="preserve">
          <source>Socket objects</source>
          <target state="translated">Los objetos del enchufe</target>
        </trans-unit>
        <trans-unit id="655fcbd0fdce070ab1dd17b0f4b4d25fd50db073" translate="yes" xml:space="preserve">
          <source>SocketStream</source>
          <target state="translated">SocketStream</target>
        </trans-unit>
        <trans-unit id="33243780198fdd9e060afa427801d7aeb8d32f67" translate="yes" xml:space="preserve">
          <source>Sockets and networking</source>
          <target state="translated">Enchufes y redes de trabajo</target>
        </trans-unit>
        <trans-unit id="dc23719f0d9233246e570ccf60e98a17c7b26b0b" translate="yes" xml:space="preserve">
          <source>Some &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; methods can&amp;rsquo;t return any meaningful data until after the handshake. If you call them before the handshake, they raise this error.</source>
          <target state="translated">Algunos m&amp;eacute;todos &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; no pueden devolver ning&amp;uacute;n dato significativo hasta despu&amp;eacute;s del protocolo de enlace. Si los llama antes del apret&amp;oacute;n de manos, generan este error.</target>
        </trans-unit>
        <trans-unit id="9345ea48a5cb7e21d04b7e45c3a00560b568defe" translate="yes" xml:space="preserve">
          <source>Some event loops, like asyncio, won&amp;rsquo;t work correctly unless they win this fight. Fortunately, Trio is a little less picky: as long as &lt;em&gt;someone&lt;/em&gt; makes sure that the program wakes up when a signal arrives, it should work correctly. So if your host loop wants &lt;a href=&quot;https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd&quot;&gt;&lt;code&gt;signal.set_wakeup_fd&lt;/code&gt;&lt;/a&gt;, then you should disable Trio&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd&quot;&gt;&lt;code&gt;signal.set_wakeup_fd&lt;/code&gt;&lt;/a&gt; support, and then both loops will work correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="763dc9850c40e96a02c0a22e2cbdb9bd606c49a4" translate="yes" xml:space="preserve">
          <source>Some methods on &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; raise &lt;a href=&quot;#trio.NeedHandshakeError&quot;&gt;&lt;code&gt;NeedHandshakeError&lt;/code&gt;&lt;/a&gt; if you call them before the handshake completes:</source>
          <target state="translated">Algunos m&amp;eacute;todos de &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; aumento &lt;a href=&quot;#trio.NeedHandshakeError&quot;&gt; &lt;code&gt;NeedHandshakeError&lt;/code&gt; &lt;/a&gt; si llamas antes de que se complete el apret&amp;oacute;n de manos:</target>
        </trans-unit>
        <trans-unit id="89d3ecb4bb3fac7ce56b1e0de2d53bc6bb0d92b8" translate="yes" xml:space="preserve">
          <source>Some programs need to be able to quit at any time, for example in response to a GUI window being closed or a user selecting a &amp;ldquo;Quit&amp;rdquo; from a menu. In these cases, we recommend wrapping your whole program in a &lt;a href=&quot;reference-core#trio.CancelScope&quot;&gt;&lt;code&gt;trio.CancelScope&lt;/code&gt;&lt;/a&gt;, and cancelling it when you want to quit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b27189a11dd9d8693c1cfa882d09fc9356dcb1d5" translate="yes" xml:space="preserve">
          <source>Sometimes it doesn&amp;rsquo;t make sense for the task that starts a child to take on responsibility for watching it. For example, a server task may want to start a new task for each connection, but it can&amp;rsquo;t listen for connections and supervise children at the same time.</source>
          <target state="translated">A veces no tiene sentido que la tarea que hace que un ni&amp;ntilde;o asuma la responsabilidad de vigilarla. Por ejemplo, una tarea de servidor puede querer iniciar una nueva tarea para cada conexi&amp;oacute;n, pero no puede escuchar conexiones y supervisar a los ni&amp;ntilde;os al mismo tiempo.</target>
        </trans-unit>
        <trans-unit id="2df141e44fbf3ba214d9841f6406f0bfbb78bccb" translate="yes" xml:space="preserve">
          <source>Sometimes you need to put a limit on how many tasks can do something at the same time. For example, you might want to use some threads to run multiple blocking I/O operations in parallel&amp;hellip; but if you use too many threads at once, then your system can become overloaded and it&amp;rsquo;ll actually make things slower. One popular solution is to impose a policy like &amp;ldquo;run up to 40 threads at the same time, but no more&amp;rdquo;. But how do you implement a policy like this?</source>
          <target state="translated">A veces es necesario poner un l&amp;iacute;mite a la cantidad de tareas que se pueden realizar al mismo tiempo. Por ejemplo, es posible que desee utilizar algunos subprocesos para ejecutar m&amp;uacute;ltiples operaciones de bloqueo de E / S en paralelo ... pero si usa demasiados subprocesos a la vez, su sistema puede sobrecargarse y en realidad har&amp;aacute; las cosas m&amp;aacute;s lentas. Una soluci&amp;oacute;n popular es imponer una pol&amp;iacute;tica como &quot;ejecutar hasta 40 subprocesos al mismo tiempo, pero no m&amp;aacute;s&quot;. Pero, &amp;iquest;c&amp;oacute;mo se implementa una pol&amp;iacute;tica como esta?</target>
        </trans-unit>
        <trans-unit id="28a2722a8ff69315bc9a5705fed28a992c345e6f" translate="yes" xml:space="preserve">
          <source>Sometimes, it&amp;rsquo;s useful to be able to share some mutable sleep-related data between the sleeping task, the abort function, and the waking task. You can use the sleeping task&amp;rsquo;s &lt;a href=&quot;#trio.hazmat.Task.custom_sleep_data&quot;&gt;&lt;code&gt;custom_sleep_data&lt;/code&gt;&lt;/a&gt; attribute to store this data, and Trio won&amp;rsquo;t touch it, except to make sure that it gets cleared when the task is rescheduled.</source>
          <target state="translated">A veces, es &amp;uacute;til poder compartir algunos datos mutables relacionados con el sue&amp;ntilde;o entre la tarea de dormir, la funci&amp;oacute;n de aborto y la tarea de vigilia. Puede usar el atributo &lt;a href=&quot;#trio.hazmat.Task.custom_sleep_data&quot;&gt; &lt;code&gt;custom_sleep_data&lt;/code&gt; de&lt;/a&gt; la tarea durmiente para almacenar estos datos, y Trio no los tocar&amp;aacute;, excepto para asegurarse de que se borre cuando se reprograme la tarea.</target>
        </trans-unit>
        <trans-unit id="94edab96da73479b826a1e418978af4b76f24615" translate="yes" xml:space="preserve">
          <source>Sometimes, it&amp;rsquo;s useful to be able to share some mutable sleep-related data between the sleeping task, the abort function, and the waking task. You can use the sleeping task&amp;rsquo;s &lt;a href=&quot;#trio.lowlevel.Task.custom_sleep_data&quot;&gt;&lt;code&gt;custom_sleep_data&lt;/code&gt;&lt;/a&gt; attribute to store this data, and Trio won&amp;rsquo;t touch it, except to make sure that it gets cleared when the task is rescheduled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a64f6b1abe92a7a7b4c6478df9e8e0cd60338357" translate="yes" xml:space="preserve">
          <source>Sometimes, though if we&amp;rsquo;re lucky, the two producers might finish at the same time (or close enough), so they both make their last &lt;code&gt;send&lt;/code&gt; before either of them closes the &lt;code&gt;send_channel&lt;/code&gt;.</source>
          <target state="translated">A veces, aunque si tenemos suerte, los dos productores pueden terminar al mismo tiempo (o lo suficientemente cerca), por lo que ambos realizan su &amp;uacute;ltimo &lt;code&gt;send&lt;/code&gt; antes de que alguno de ellos cierre el &lt;code&gt;send_channel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4062e9fcc29dbf3d4f384d021b8d2f23dae68ca4" translate="yes" xml:space="preserve">
          <source>Spawn a &amp;ldquo;system&amp;rdquo; task.</source>
          <target state="translated">Genere una tarea de &quot;sistema&quot;.</target>
        </trans-unit>
        <trans-unit id="86787d141e62ea9c6e1d9ef20be7863fc8ae36cd" translate="yes" xml:space="preserve">
          <source>Spawn this thread from &lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt;&lt;code&gt;trio.to_thread.run_sync&lt;/code&gt;&lt;/a&gt;. Trio will automatically capture the relevant Trio token and use it when you want to re-enter Trio.</source>
          <target state="translated">&lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt; &lt;code&gt;trio.to_thread.run_sync&lt;/code&gt; &lt;/a&gt; este hilo de trio.to_thread.run_sync . Trio capturar&amp;aacute; autom&amp;aacute;ticamente el token de Trio relevante y lo usar&amp;aacute; cuando quieras volver a ingresar a Trio.</target>
        </trans-unit>
        <trans-unit id="62f14e7f69f0c928f3521a52d4471e369748ed2e" translate="yes" xml:space="preserve">
          <source>Spawning subprocesses</source>
          <target state="translated">Subprocesos de desove</target>
        </trans-unit>
        <trans-unit id="255e359a65128521d6223be6b31e2b8a76a94d43" translate="yes" xml:space="preserve">
          <source>Spawning tasks without becoming a parent</source>
          <target state="translated">Tareas de desove sin convertirse en padre</target>
        </trans-unit>
        <trans-unit id="9e64610f310d2efd9936d16cf28d0c33c4d6fbc9" translate="yes" xml:space="preserve">
          <source>Spawning threads</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5265bdb21e85f3aad61c94d6d966d5e82bdd52f" translate="yes" xml:space="preserve">
          <source>Special notes:</source>
          <target state="translated">Notas especiales:</target>
        </trans-unit>
        <trans-unit id="59452117c4e17f1600d8cb5a7a64e6200569cd19" translate="yes" xml:space="preserve">
          <source>Specific style guidelines</source>
          <target state="translated">Pautas de estilo específicas</target>
        </trans-unit>
        <trans-unit id="f7a9b1371562eba7427785ba394b08b92540fb8e" translate="yes" xml:space="preserve">
          <source>Standard-compliant SSL/TLS implementations always send a cryptographically signed &lt;code&gt;close_notify&lt;/code&gt; message before closing the connection. This is important because if the underlying transport were simply closed, then there wouldn&amp;rsquo;t be any way for the other side to know whether the connection was intentionally closed by the peer that they negotiated a cryptographic connection to, or by some &lt;a href=&quot;https://en.wikipedia.org/wiki/Man-in-the-middle_attack&quot;&gt;man-in-the-middle&lt;/a&gt; attacker who can&amp;rsquo;t manipulate the cryptographic stream, but can manipulate the transport layer (a so-called &amp;ldquo;truncation attack&amp;rdquo;).</source>
          <target state="translated">Las implementaciones SSL / TLS que cumplen con los est&amp;aacute;ndares siempre env&amp;iacute;an un mensaje &lt;code&gt;close_notify&lt;/code&gt; firmado criptogr&amp;aacute;ficamente antes de cerrar la conexi&amp;oacute;n. Esto es importante porque si el transporte subyacente simplemente se cerr&amp;oacute;, entonces no habr&amp;iacute;a ninguna forma de que la otra parte sepa si la conexi&amp;oacute;n fue cerrada intencionalmente por el par con el que negociaron una conexi&amp;oacute;n criptogr&amp;aacute;fica, o por alg&amp;uacute;n &lt;a href=&quot;https://en.wikipedia.org/wiki/Man-in-the-middle_attack&quot;&gt;hombre en el&lt;/a&gt; atacante intermedio que no puede manipular el flujo criptogr&amp;aacute;fico, pero puede manipular la capa de transporte (un llamado &quot;ataque de truncamiento&quot;).</target>
        </trans-unit>
        <trans-unit id="e962a9dfea2f0e0d8c3fd9ea7656b468b40b11f2" translate="yes" xml:space="preserve">
          <source>Start a &amp;ldquo;guest&amp;rdquo; run of Trio on top of some other &amp;ldquo;host&amp;rdquo; event loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="538bad610e4cd63875a6f40262577d01e06f3685" translate="yes" xml:space="preserve">
          <source>Start instrumenting the current run loop with the given instrument.</source>
          <target state="translated">Empiece a instrumentar el bucle de ejecución actual con el instrumento dado.</target>
        </trans-unit>
        <trans-unit id="27ec8cde0c460b3a817bbe9ef5ff3449e512158c" translate="yes" xml:space="preserve">
          <source>Start listening for SSL/TLS-encrypted TCP connections to the given port.</source>
          <target state="translated">Empieza a escuchar las conexiones TCP encriptadas SSL/TLS del puerto en cuestión.</target>
        </trans-unit>
        <trans-unit id="67c484a632cde0780741fc006f1a8fc9c3676b53" translate="yes" xml:space="preserve">
          <source>Start up your host loop</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2062c61bfd9457e074fe8ebdf948e44b4303be1" translate="yes" xml:space="preserve">
          <source>Stop instrumenting the current run loop with the given instrument.</source>
          <target state="translated">Deje de instrumentar el bucle de recorrido actual con el instrumento dado.</target>
        </trans-unit>
        <trans-unit id="74985da267c6803b262f117de72af2d02e48029f" translate="yes" xml:space="preserve">
          <source>Streams</source>
          <target state="translated">Streams</target>
        </trans-unit>
        <trans-unit id="ecfa6cc29e1a7d81c918ce86382e082e5b3f9aa7" translate="yes" xml:space="preserve">
          <source>String containing this &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s name. Usually the name of the function this &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; is running, but can be overridden by passing &lt;code&gt;name=&lt;/code&gt; to &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;start_soon&lt;/code&gt;.</source>
          <target state="translated">Cadena que contiene el nombre de esta &lt;a href=&quot;#trio.hazmat.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; . Por lo general, el nombre de la funci&amp;oacute;n que ejecuta esta &lt;a href=&quot;#trio.hazmat.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; , pero se puede anular pasando &lt;code&gt;name=&lt;/code&gt; to &lt;code&gt;start&lt;/code&gt; o &lt;code&gt;start_soon&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88dacce5492d183a96487fb4fd272e494398e85f" translate="yes" xml:space="preserve">
          <source>String containing this &lt;a href=&quot;#trio.lowlevel.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;'s name. Usually the name of the function this &lt;a href=&quot;#trio.lowlevel.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; is running, but can be overridden by passing &lt;code&gt;name=&lt;/code&gt; to &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;start_soon&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f4774c0e91d69d04dd6ad14a20a6dcc93957451" translate="yes" xml:space="preserve">
          <source>Supported environments: Linux, macOS, or Windows running some kind of Python 3.5-or-better (either CPython or PyPy3 is fine). *BSD and illumos likely work too, but are untested.</source>
          <target state="translated">Entornos soportados:Linux,macOS o Windows ejecutando algún tipo de Python 3.5-o mejor (ya sea CPython o PyPy3 está bien).*BSD e illumos probablemente funcionan también,pero no están probados.</target>
        </trans-unit>
        <trans-unit id="ea8914a98b4487b6e07a50764ebb50bdefa03e0c" translate="yes" xml:space="preserve">
          <source>Supported environments: We test on</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e0f9d236419d7ce4dcfde2105032675c5910961" translate="yes" xml:space="preserve">
          <source>Suppose we have a handler function that discards &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt;s:</source>
          <target state="translated">Supongamos que tenemos una funci&amp;oacute;n de controlador que descarta &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; s:</target>
        </trans-unit>
        <trans-unit id="9bcc4a70ae1d63b866c95cda6ee3ba65780eedf1" translate="yes" xml:space="preserve">
          <source>Suppose you&amp;rsquo;re writing a server that responds to network requests, and you log some information about each request as you process it. If the server is busy and there are multiple requests being handled at the same time, then you might end up with logs like this:</source>
          <target state="translated">Suponga que est&amp;aacute; escribiendo un servidor que responde a las solicitudes de la red y registra cierta informaci&amp;oacute;n sobre cada solicitud a medida que la procesa. Si el servidor est&amp;aacute; ocupado y se manejan varias solicitudes al mismo tiempo, es posible que termine con registros como este:</target>
        </trans-unit>
        <trans-unit id="19e98a8e67554960e71cb8b97f1c5ac1a004d082" translate="yes" xml:space="preserve">
          <source>Synchronizing and communicating between tasks</source>
          <target state="translated">Sincronización y comunicación entre tareas</target>
        </trans-unit>
        <trans-unit id="055926a4c90e5c08999c70c13e37e6306b9e8f0b" translate="yes" xml:space="preserve">
          <source>Synchronous attributes/methods: if any of the following attributes or methods are present, then they&amp;rsquo;re re-exported unchanged: &lt;code&gt;closed&lt;/code&gt;, &lt;code&gt;encoding&lt;/code&gt;, &lt;code&gt;errors&lt;/code&gt;, &lt;code&gt;fileno&lt;/code&gt;, &lt;code&gt;isatty&lt;/code&gt;, &lt;code&gt;newlines&lt;/code&gt;, &lt;code&gt;readable&lt;/code&gt;, &lt;code&gt;seekable&lt;/code&gt;, &lt;code&gt;writable&lt;/code&gt;, &lt;code&gt;buffer&lt;/code&gt;, &lt;code&gt;raw&lt;/code&gt;, &lt;code&gt;line_buffering&lt;/code&gt;, &lt;code&gt;closefd&lt;/code&gt;, &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;mode&lt;/code&gt;, &lt;code&gt;getvalue&lt;/code&gt;, &lt;code&gt;getbuffer&lt;/code&gt;.</source>
          <target state="translated">Atributos / m&amp;eacute;todos s&amp;iacute;ncronos: si alguno de los siguientes atributos o m&amp;eacute;todos est&amp;aacute; presente, entonces se reexportan sin cambios: &lt;code&gt;closed&lt;/code&gt; , &lt;code&gt;encoding&lt;/code&gt; , &lt;code&gt;errors&lt;/code&gt; , &lt;code&gt;fileno&lt;/code&gt; , &lt;code&gt;isatty&lt;/code&gt; , &lt;code&gt;newlines&lt;/code&gt; , &lt;code&gt;readable&lt;/code&gt; , &lt;code&gt;seekable&lt;/code&gt; , &lt;code&gt;writable&lt;/code&gt; , &lt;code&gt;buffer&lt;/code&gt; , &lt;code&gt;raw&lt;/code&gt; , &lt;code&gt;line_buffering&lt;/code&gt; , &lt;code&gt;closefd&lt;/code&gt; , &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;mode&lt;/code&gt; , &lt;code&gt;getvalue&lt;/code&gt; , &lt;code&gt;getbuffer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26f95fb839ad8c1ff05b0c8fdf998088c518fd27" translate="yes" xml:space="preserve">
          <source>Synchronous code never contains any checkpoints, but we can double-check that:</source>
          <target state="translated">El código síncrono nunca contiene ningún punto de control,pero podemos comprobarlo:</target>
        </trans-unit>
        <trans-unit id="0d3242a906ad02bf931de9a3178700e07c2be807" translate="yes" xml:space="preserve">
          <source>System tasks are automatically cancelled when the main task exits.</source>
          <target state="translated">Las tareas del sistema se cancelan automáticamente cuando la tarea principal sale.</target>
        </trans-unit>
        <trans-unit id="5c204ac92f0958e65d5735c8207842ebd1d94d97" translate="yes" xml:space="preserve">
          <source>System tasks do not inherit context variables from their creator.</source>
          <target state="translated">Las tareas del sistema no heredan las variables de contexto de su creador.</target>
        </trans-unit>
        <trans-unit id="c4f943638fe154a8226e9c578ceb1a32fb677027" translate="yes" xml:space="preserve">
          <source>System tasks have a few differences from regular tasks:</source>
          <target state="translated">Las tareas del sistema tienen algunas diferencias con las tareas regulares:</target>
        </trans-unit>
        <trans-unit id="f44fef3579bfe89f6394f4eef4837d80321d9a4a" translate="yes" xml:space="preserve">
          <source>TODO: these are implemented, but are currently more of a sketch than anything real. See &lt;a href=&quot;https://github.com/python-trio/trio/issues/26&quot;&gt;#26&lt;/a&gt; and &lt;a href=&quot;https://github.com/python-trio/trio/issues/52&quot;&gt;#52&lt;/a&gt;.</source>
          <target state="translated">TODO: estos est&amp;aacute;n implementados, pero actualmente son m&amp;aacute;s un boceto que algo real. Consulte los &lt;a href=&quot;https://github.com/python-trio/trio/issues/26&quot;&gt;n&amp;uacute;meros 26&lt;/a&gt; y &lt;a href=&quot;https://github.com/python-trio/trio/issues/52&quot;&gt;52&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="34c39842bbae3da361d13d933fa1d76993d2e5e4" translate="yes" xml:space="preserve">
          <source>TODO: these are implemented, but are currently more of a sketch than anything real. See &lt;a href=&quot;https://github.com/python-trio/trio/issues/26&quot;&gt;#26&lt;/a&gt;.</source>
          <target state="translated">TODO: estos est&amp;aacute;n implementados, pero actualmente son m&amp;aacute;s un boceto que algo real. Ver &lt;a href=&quot;https://github.com/python-trio/trio/issues/26&quot;&gt;# 26&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c6d22c008afc423d3836f670a439ca3979a41de4" translate="yes" xml:space="preserve">
          <source>Take data out of the given &lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt;&lt;code&gt;MemorySendStream&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s internal buffer, and put it into the given &lt;a href=&quot;#trio.testing.MemoryReceiveStream&quot;&gt;&lt;code&gt;MemoryReceiveStream&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s internal buffer.</source>
          <target state="translated">Tomar datos fuera de lo dado &lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt; &lt;code&gt;MemorySendStream&lt;/code&gt; &lt;/a&gt; &amp;lsquo;buffer interno s, y lo puso en lo dado &lt;a href=&quot;#trio.testing.MemoryReceiveStream&quot;&gt; &lt;code&gt;MemoryReceiveStream&lt;/code&gt; &lt;/a&gt; &amp;lsquo;buffer interno s.</target>
        </trans-unit>
        <trans-unit id="7bb0ddf9221c03b806b03c209e8366000124aa15" translate="yes" xml:space="preserve">
          <source>Task</source>
          <target state="translated">Task</target>
        </trans-unit>
        <trans-unit id="d89b8bafaae10233d3c0df964c49dfe20cf2d352" translate="yes" xml:space="preserve">
          <source>Task API</source>
          <target state="translated">Tarea API</target>
        </trans-unit>
        <trans-unit id="802a4e17ee1d8e6d0ad7403c8b75383080b8674e" translate="yes" xml:space="preserve">
          <source>Task-local storage</source>
          <target state="translated">Tareas-almacenamiento local</target>
        </trans-unit>
        <trans-unit id="f74f87f6903191022bd96d719e761e9623d8f5cb" translate="yes" xml:space="preserve">
          <source>Task-related API details</source>
          <target state="translated">Detalles de la API relacionados con la tarea</target>
        </trans-unit>
        <trans-unit id="ef1c5421122784c77c263be639d67c525ca3c3b4" translate="yes" xml:space="preserve">
          <source>Tasks let you do multiple things at once</source>
          <target state="translated">Las tareas te permiten hacer varias cosas a la vez</target>
        </trans-unit>
        <trans-unit id="a9f85d2cdf608d49f77179bec9274df48164ba4e" translate="yes" xml:space="preserve">
          <source>Technically, it is possible to use other patterns. But there are some important limitations you have to respect:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="304baf6bf4961ac71a5da0c98ab5a8d805ceefdf" translate="yes" xml:space="preserve">
          <source>Temporarily detach the current coroutine object from the Trio scheduler.</source>
          <target state="translated">Desconecte temporalmente el objeto de rutina actual del programador del Trío.</target>
        </trans-unit>
        <trans-unit id="facd1c6aeacb9718336f3aed70d13ecc4deab47b" translate="yes" xml:space="preserve">
          <source>Terminate the process, politely if possible.</source>
          <target state="translated">Termina el proceso,educadamente si es posible.</target>
        </trans-unit>
        <trans-unit id="5d4008135062fb803b7ec11f07867a7759c2e1da" translate="yes" xml:space="preserve">
          <source>Test harness integration</source>
          <target state="translated">Prueba de integración del arnés</target>
        </trans-unit>
        <trans-unit id="0820b32b206b7352858e8903a838ed14319acdfd" translate="yes" xml:space="preserve">
          <source>Testing</source>
          <target state="translated">Testing</target>
        </trans-unit>
        <trans-unit id="6b011e2bb3c834f658d616203f55717f63ba2ae6" translate="yes" xml:space="preserve">
          <source>Testing checkpoints</source>
          <target state="translated">Probando los puntos de control</target>
        </trans-unit>
        <trans-unit id="35e0ba25999f3a918e3e2952df381f71ee1accbf" translate="yes" xml:space="preserve">
          <source>Testing custom stream implementations</source>
          <target state="translated">Probando implementaciones de flujos personalizados</target>
        </trans-unit>
        <trans-unit id="341c328d3226e6e7cbcef449b2f9d2e0ef49e921" translate="yes" xml:space="preserve">
          <source>Testing made easier with &lt;code&gt;trio.testing&lt;/code&gt;</source>
          <target state="translated">Pruebas m&amp;aacute;s f&amp;aacute;ciles con &lt;code&gt;trio.testing&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2987927a1f9194d0407b8259e63f466ffac0a9e8" translate="yes" xml:space="preserve">
          <source>Testing made easier with trio.testing</source>
          <target state="translated">Las pruebas son más fáciles con el trío de pruebas</target>
        </trans-unit>
        <trans-unit id="b8fb0e142b06b7b6146922267b755a35993334c6" translate="yes" xml:space="preserve">
          <source>That is, this is OK:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08c3519cadca868f28bbb253c4e6d9baf20e199f" translate="yes" xml:space="preserve">
          <source>That world, alas, does not (yet) exist. Until it does, you may find yourself needing to interact with non-Trio APIs that do rude things like &amp;ldquo;blocking&amp;rdquo;.</source>
          <target state="translated">Ese mundo, por desgracia, no existe (todav&amp;iacute;a). Hasta que lo haga, es posible que necesite interactuar con API que no son de Trio y que hacen cosas groseras como &quot;bloquear&quot;.</target>
        </trans-unit>
        <trans-unit id="9ac747b8191150731763661dc9fc7b17a6a27a33" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s what &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt;&lt;code&gt;CapacityLimiter&lt;/code&gt;&lt;/a&gt; is for. You can think of a &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt;&lt;code&gt;CapacityLimiter&lt;/code&gt;&lt;/a&gt; object as a sack that starts out holding some fixed number of tokens:</source>
          <target state="translated">Para eso es &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt; &lt;code&gt;CapacityLimiter&lt;/code&gt; &lt;/a&gt; . Puede pensar en un objeto &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt; &lt;code&gt;CapacityLimiter&lt;/code&gt; &lt;/a&gt; como un saco que comienza con una cantidad fija de tokens:</target>
        </trans-unit>
        <trans-unit id="278998c9ff3d196df8ce725e0a4247a8f9f881ca" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s why Trio offers a fourth option: &lt;strong&gt;guest mode&lt;/strong&gt;. Guest mode lets you execute &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run&lt;/code&gt;&lt;/a&gt; on top of some other &amp;ldquo;host&amp;rdquo; event loop, like Qt. Its advantages are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa77426cfd32e308124c277026d2320b6fc9f3df" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;polling&amp;rdquo; and &amp;ldquo;pluggable backend&amp;rdquo; strategies solve this by hacking the loops so both step 1s can run at the same time in the same thread. Keeping everything in one thread is great for step 2, but the step 1 hacks create problems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f80f2be65b7c1e19f805fdd78f2b5dc2cc59217e" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;separate threads&amp;rdquo; strategy solves this by moving both steps into separate threads. This makes step 1 work, but the downside is that now the user tasks in step 2 are running separate threads as well, so users are forced to deal with inter-thread coordination.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd78edb290431455f2a37b4855817a9dffd051ef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-trio.socket&quot;&gt;&lt;code&gt;trio.socket&lt;/code&gt;&lt;/a&gt; module provides Trio&amp;rsquo;s basic low-level networking API. If you&amp;rsquo;re doing ordinary things with stream-oriented connections over IPv4/IPv6/Unix domain sockets, then you probably want to stick to the high-level API described above. If you want to use UDP, or exotic address families like &lt;code&gt;AF_BLUETOOTH&lt;/code&gt;, or otherwise get direct access to all the quirky bits of your system&amp;rsquo;s networking API, then you&amp;rsquo;re in the right place.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;a href=&quot;#module-trio.socket&quot;&gt; &lt;code&gt;trio.socket&lt;/code&gt; &lt;/a&gt; proporciona la API de red b&amp;aacute;sica de bajo nivel de Trio. Si est&amp;aacute; haciendo cosas ordinarias con conexiones orientadas a la transmisi&amp;oacute;n a trav&amp;eacute;s de sockets de dominio IPv4 / IPv6 / Unix, entonces probablemente desee ce&amp;ntilde;irse a la API de alto nivel descrita anteriormente. Si desea utilizar UDP o familias de direcciones ex&amp;oacute;ticas como &lt;code&gt;AF_BLUETOOTH&lt;/code&gt; , u obtener acceso directo a todos los bits extravagantes de la API de red de su sistema, entonces est&amp;aacute; en el lugar correcto.</target>
        </trans-unit>
        <trans-unit id="e8e0d2ab8c98abb5b0b0f5e1d4a574bebf7c6690" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-trio.testing&quot;&gt;&lt;code&gt;trio.testing&lt;/code&gt;&lt;/a&gt; module provides various utilities to make it easier to test Trio code. Unlike the other submodules in the &lt;a href=&quot;reference-core#module-trio&quot;&gt;&lt;code&gt;trio&lt;/code&gt;&lt;/a&gt; namespace, &lt;a href=&quot;#module-trio.testing&quot;&gt;&lt;code&gt;trio.testing&lt;/code&gt;&lt;/a&gt; is &lt;em&gt;not&lt;/em&gt; automatically imported when you do &lt;code&gt;import trio&lt;/code&gt;; you must &lt;code&gt;import trio.testing&lt;/code&gt; explicitly.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;a href=&quot;#module-trio.testing&quot;&gt; &lt;code&gt;trio.testing&lt;/code&gt; &lt;/a&gt; proporciona varias utilidades para facilitar la prueba del c&amp;oacute;digo Trio. A diferencia de los otros subm&amp;oacute;dulos en el &lt;a href=&quot;reference-core#module-trio&quot;&gt; &lt;code&gt;trio&lt;/code&gt; &lt;/a&gt; espacio de nombres, &lt;a href=&quot;#module-trio.testing&quot;&gt; &lt;code&gt;trio.testing&lt;/code&gt; &lt;/a&gt; est&amp;aacute; &lt;em&gt;no&lt;/em&gt; importa autom&amp;aacute;ticamente cuando lo hace &lt;code&gt;import trio&lt;/code&gt; ; debe &lt;code&gt;import trio.testing&lt;/code&gt; expl&amp;iacute;citamente.</target>
        </trans-unit>
        <trans-unit id="996e86c00c33ba5b09fce5a9fc45abb7e9e22650" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#trio.CancelScope&quot;&gt;&lt;code&gt;CancelScope&lt;/code&gt;&lt;/a&gt; constructor takes initial values for the cancel scope&amp;rsquo;s &lt;a href=&quot;#trio.CancelScope.deadline&quot;&gt;&lt;code&gt;deadline&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.CancelScope.shield&quot;&gt;&lt;code&gt;shield&lt;/code&gt;&lt;/a&gt; attributes; these may be freely modified after construction, whether or not the scope has been entered yet, and changes take immediate effect.</source>
          <target state="translated">El constructor &lt;a href=&quot;#trio.CancelScope&quot;&gt; &lt;code&gt;CancelScope&lt;/code&gt; &lt;/a&gt; toma valores iniciales para los atributos de &lt;a href=&quot;#trio.CancelScope.shield&quot;&gt; &lt;code&gt;shield&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#trio.CancelScope.deadline&quot;&gt; &lt;code&gt;deadline&lt;/code&gt; &lt;/a&gt; del alcance de cancelaci&amp;oacute;n ; Estos pueden modificarse libremente despu&amp;eacute;s de la construcci&amp;oacute;n, ya sea que se haya ingresado o no el alcance, y los cambios tienen efecto inmediato.</target>
        </trans-unit>
        <trans-unit id="f3e93c721d5334efb64815d725431dc0496846ad" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;reference-testing#module-trio.testing&quot;&gt;&lt;code&gt;trio.testing&lt;/code&gt;&lt;/a&gt; module provides a set of &lt;a href=&quot;reference-testing#testing-streams&quot;&gt;flexible in-memory stream object implementations&lt;/a&gt;, so if you have a protocol implementation to test then you can can start two tasks, set up a virtual &amp;ldquo;socket&amp;rdquo; connecting them, and then do things like inject random-but-repeatable delays into the connection.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;a href=&quot;reference-testing#module-trio.testing&quot;&gt; &lt;code&gt;trio.testing&lt;/code&gt; &lt;/a&gt; proporciona un conjunto de &lt;a href=&quot;reference-testing#testing-streams&quot;&gt;implementaciones de objetos de flujo en memoria flexibles&lt;/a&gt; , por lo que si tiene una implementaci&amp;oacute;n de protocolo para probar, puede iniciar dos tareas, configurar un &quot;socket&quot; virtual que las conecte y luego hacer cosas como inyectar retrasos aleatorios pero repetibles en la conexi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="09b5d3a08ea757fadb98a4225154f91508d3f13f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;async_fn&lt;/code&gt; must accept a &lt;code&gt;task_status&lt;/code&gt; keyword argument, and it must make sure that it (or someone) eventually calls &lt;code&gt;task_status.started()&lt;/code&gt;.</source>
          <target state="translated">El &lt;code&gt;async_fn&lt;/code&gt; debe aceptar un &lt;code&gt;task_status&lt;/code&gt; argumento de palabra clave, y debe asegurarse de que &amp;eacute;l (o alguien) que termina por llamar &lt;code&gt;task_status.started()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f895f76bf1979f9940415d53c288e42d5e8a898" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cancel_scope&lt;/code&gt; object also allows you to check or adjust this scope&amp;rsquo;s deadline, explicitly trigger a cancellation without waiting for the deadline, check if the scope has already been cancelled, and so forth &amp;ndash; see &lt;a href=&quot;#trio.CancelScope&quot;&gt;&lt;code&gt;CancelScope&lt;/code&gt;&lt;/a&gt; below for the full details.</source>
          <target state="translated">El &lt;code&gt;cancel_scope&lt;/code&gt; objetivo tambi&amp;eacute;n le permite comprobar o ajustar fecha l&amp;iacute;mite de este alcance, desencadenar expl&amp;iacute;citamente una cancelaci&amp;oacute;n sin esperar a la fecha l&amp;iacute;mite, y comprueba si el alcance ya ha sido cancelada, y as&amp;iacute; sucesivamente - ve &lt;a href=&quot;#trio.CancelScope&quot;&gt; &lt;code&gt;CancelScope&lt;/code&gt; &lt;/a&gt; a continuaci&amp;oacute;n para los detalles completos.</target>
        </trans-unit>
        <trans-unit id="69e23230a2bcee3af46d41ce7a31ade877e491f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;command&lt;/code&gt; passed at construction time, specifying the process to execute and its arguments.</source>
          <target state="translated">El &lt;code&gt;command&lt;/code&gt; pas&amp;oacute; en el momento de la construcci&amp;oacute;n, especificando el proceso a ejecutar y sus argumentos.</target>
        </trans-unit>
        <trans-unit id="063f67b92b596d191b8f84a0a83fc8f83c79740b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;detach&lt;/code&gt; method, if present, returns an async file object.</source>
          <target state="translated">El m&amp;eacute;todo de &lt;code&gt;detach&lt;/code&gt; , si est&amp;aacute; presente, devuelve un objeto de archivo as&amp;iacute;ncrono.</target>
        </trans-unit>
        <trans-unit id="1bfb97a4bbb5e07af262081e3f1c7ef329411374" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;limiter&lt;/code&gt; is only released after the thread has &lt;em&gt;actually&lt;/em&gt; finished &amp;ndash; which in the case of cancellation may be some time after this function has returned. If &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt; finishes before the thread does, then the limiter release method will never be called at all.</source>
          <target state="translated">El &lt;code&gt;limiter&lt;/code&gt; solo se libera despu&amp;eacute;s de que el hilo &lt;em&gt;realmente&lt;/em&gt; ha terminado, que en el caso de cancelaci&amp;oacute;n puede ser un tiempo despu&amp;eacute;s de que esta funci&amp;oacute;n haya regresado. Si &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; finaliza antes de que termine el hilo, nunca se llamar&amp;aacute; al m&amp;eacute;todo de liberaci&amp;oacute;n del limitador.</target>
        </trans-unit>
        <trans-unit id="39e88286f1b3b8ffdc9fa1f82e7c0888d475d325" translate="yes" xml:space="preserve">
          <source>The SSH protocol provides the ability to multiplex bidirectional &amp;ldquo;channels&amp;rdquo; on top of a single encrypted connection. A Trio implementation of SSH could expose these channels as &lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt;&lt;code&gt;HalfCloseableStream&lt;/code&gt;&lt;/a&gt; objects, and calling &lt;a href=&quot;#trio.abc.HalfCloseableStream.send_eof&quot;&gt;&lt;code&gt;send_eof()&lt;/code&gt;&lt;/a&gt; would send an &lt;code&gt;SSH_MSG_CHANNEL_EOF&lt;/code&gt; request (see &lt;a href=&quot;https://tools.ietf.org/html/rfc4254#section-5.3&quot;&gt;RFC 4254 &amp;sect;5.3&lt;/a&gt;).</source>
          <target state="translated">El protocolo SSH ofrece la capacidad de multiplexar &quot;canales&quot; bidireccionales sobre una &amp;uacute;nica conexi&amp;oacute;n cifrada. Una implementaci&amp;oacute;n Trio de SSH podr&amp;iacute;a exponer estos canales como objetos &lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt; &lt;code&gt;HalfCloseableStream&lt;/code&gt; &lt;/a&gt; , y llamar a &lt;a href=&quot;#trio.abc.HalfCloseableStream.send_eof&quot;&gt; &lt;code&gt;send_eof()&lt;/code&gt; &lt;/a&gt; enviar&amp;iacute;a una solicitud &lt;code&gt;SSH_MSG_CHANNEL_EOF&lt;/code&gt; (ver &lt;a href=&quot;https://tools.ietf.org/html/rfc4254#section-5.3&quot;&gt;RFC 4254 &amp;sect;5.3&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e14f4dc6e5377f931e4c2a51d7d47887a2aa40b7" translate="yes" xml:space="preserve">
          <source>The SSL protocol requires an initial handshake to exchange certificates, select cryptographic keys, and so forth, before any actual data can be sent or received. You don&amp;rsquo;t have to call this method; if you don&amp;rsquo;t, then &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; will automatically peform the handshake as needed, the first time you try to send or receive data. But if you want to trigger it manually &amp;ndash; for example, because you want to look at the peer&amp;rsquo;s certificate before you start talking to them &amp;ndash; then you can call this method.</source>
          <target state="translated">El protocolo SSL requiere un protocolo de enlace inicial para intercambiar certificados, seleccionar claves criptogr&amp;aacute;ficas, etc., antes de que se puedan enviar o recibir datos reales. No tiene que llamar a este m&amp;eacute;todo; si no lo hace, &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; realizar&amp;aacute;&lt;/a&gt; autom&amp;aacute;ticamente el protocolo de enlace seg&amp;uacute;n sea necesario, la primera vez que intente enviar o recibir datos. Pero si desea activarlo manualmente, por ejemplo, porque desea ver el certificado del par antes de comenzar a hablar con ellos, puede llamar a este m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="24a88fd10b6d826da9e0fd3c37c9c98e67fb3304" translate="yes" xml:space="preserve">
          <source>The Task that opened this nursery.</source>
          <target state="translated">La tarea que abrió esta guardería.</target>
        </trans-unit>
        <trans-unit id="0037b005605d9473a07d1ff9c8c58a29834eb372" translate="yes" xml:space="preserve">
          <source>The Trio &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; will continue to exist, but will be suspended until you use &lt;a href=&quot;#trio.hazmat.reattach_detached_coroutine_object&quot;&gt;&lt;code&gt;reattach_detached_coroutine_object()&lt;/code&gt;&lt;/a&gt; to resume it. In the mean time, you can use another coroutine runner to schedule the coroutine object. In fact, you have to &amp;ndash; the function doesn&amp;rsquo;t return until the coroutine is advanced from outside.</source>
          <target state="translated">La &lt;a href=&quot;#trio.hazmat.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; Trio seguir&amp;aacute; existiendo, pero se suspender&amp;aacute; hasta que use &lt;a href=&quot;#trio.hazmat.reattach_detached_coroutine_object&quot;&gt; &lt;code&gt;reattach_detached_coroutine_object()&lt;/code&gt; &lt;/a&gt; para reanudarla. Mientras tanto, puede usar otro corredor de corrutina para programar el objeto de corrutina. De hecho, debe hacerlo: la funci&amp;oacute;n no regresa hasta que la corrutina avanza desde fuera.</target>
        </trans-unit>
        <trans-unit id="ee0161a0dcc6aabacc5285c198de3ae7fd3851b2" translate="yes" xml:space="preserve">
          <source>The Trio &lt;a href=&quot;#trio.lowlevel.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; will continue to exist, but will be suspended until you use &lt;a href=&quot;#trio.lowlevel.reattach_detached_coroutine_object&quot;&gt;&lt;code&gt;reattach_detached_coroutine_object()&lt;/code&gt;&lt;/a&gt; to resume it. In the mean time, you can use another coroutine runner to schedule the coroutine object. In fact, you have to &amp;ndash; the function doesn&amp;rsquo;t return until the coroutine is advanced from outside.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91b3715a1bc1d0217b9fa263b8eb097fe34e0f6a" translate="yes" xml:space="preserve">
          <source>The Trio project&amp;rsquo;s goal is to produce a production-quality, &lt;a href=&quot;https://github.com/python-trio/trio/blob/master/LICENSE&quot;&gt;permissively licensed&lt;/a&gt;, async/await-native I/O library for Python. Like all async libraries, its main purpose is to help you write programs that do &lt;strong&gt;multiple things at the same time&lt;/strong&gt; with &lt;strong&gt;parallelized I/O&lt;/strong&gt;. A web spider that wants to fetch lots of pages in parallel, a web server that needs to juggle lots of downloads and websocket connections at the same time, a process supervisor monitoring multiple subprocesses&amp;hellip; that sort of thing. Compared to other libraries, Trio attempts to distinguish itself with an obsessive focus on &lt;strong&gt;usability&lt;/strong&gt; and &lt;strong&gt;correctness&lt;/strong&gt;. Concurrency is complicated; we try to make it &lt;em&gt;easy&lt;/em&gt; to get things &lt;em&gt;right&lt;/em&gt;.</source>
          <target state="translated">El objetivo del proyecto Trio es producir una biblioteca de E / S nativa as&amp;iacute;ncrona / en espera de calidad de producci&amp;oacute;n, con &lt;a href=&quot;https://github.com/python-trio/trio/blob/master/LICENSE&quot;&gt;licencia permisiva&lt;/a&gt; para Python. Como todas las bibliotecas as&amp;iacute;ncronas, su prop&amp;oacute;sito principal es ayudarlo a escribir programas que hagan &lt;strong&gt;varias cosas al mismo tiempo&lt;/strong&gt; con &lt;strong&gt;E / S paralelizadas&lt;/strong&gt; . Una ara&amp;ntilde;a web que quiere buscar muchas p&amp;aacute;ginas en paralelo, un servidor web que necesita hacer malabarismos con muchas descargas y conexiones de websocket al mismo tiempo, un supervisor de procesos que monitorea m&amp;uacute;ltiples subprocesos&amp;hellip; ese tipo de cosas. En comparaci&amp;oacute;n con otras bibliotecas, Trio intenta distinguirse con un enfoque obsesivo en la &lt;strong&gt;usabilidad&lt;/strong&gt; y la &lt;strong&gt;correcci&amp;oacute;n&lt;/strong&gt; . La concurrencia es complicada; intentamos que sea &lt;em&gt;f&amp;aacute;cil&lt;/em&gt; conseguir cosas&lt;em&gt;bien&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="687057d329e69f8ab7df756c5d5e8198fecaf157" translate="yes" xml:space="preserve">
          <source>The Trio socket object that this stream wraps.</source>
          <target state="translated">El objeto del enchufe del Trío que esta corriente envuelve.</target>
        </trans-unit>
        <trans-unit id="cba6eddc865e8ef02041cf8e92b113b668fdb1fa" translate="yes" xml:space="preserve">
          <source>The abstract Stream API</source>
          <target state="translated">La corriente abstracta API</target>
        </trans-unit>
        <trans-unit id="ed1ab01ce9f6eeb35a966504829dfe0650d97783" translate="yes" xml:space="preserve">
          <source>The amount of capacity that&amp;rsquo;s available to use.</source>
          <target state="translated">La cantidad de capacidad que est&amp;aacute; disponible para usar.</target>
        </trans-unit>
        <trans-unit id="27aed0b7977904cec1e146409f5e000ca057c3cc" translate="yes" xml:space="preserve">
          <source>The amount of capacity that&amp;rsquo;s currently in use.</source>
          <target state="translated">La cantidad de capacidad que est&amp;aacute; actualmente en uso.</target>
        </trans-unit>
        <trans-unit id="f05a5bfc3a671c87ae02936d446663b7d98d9b51" translate="yes" xml:space="preserve">
          <source>The async iterator blocks until a signal arrives, and then yields it.</source>
          <target state="translated">El iterador de sincronización se bloquea hasta que llega una señal,y luego la cede.</target>
        </trans-unit>
        <trans-unit id="ff85645d494e8892b98a41f73ef597d781b10cf2" translate="yes" xml:space="preserve">
          <source>The basic interface for running a subprocess start-to-finish is &lt;a href=&quot;#trio.run_process&quot;&gt;&lt;code&gt;trio.run_process()&lt;/code&gt;&lt;/a&gt;. It always waits for the subprocess to exit before returning, so there&amp;rsquo;s no need to worry about leaving a process running by mistake after you&amp;rsquo;ve gone on to do other things. &lt;a href=&quot;#trio.run_process&quot;&gt;&lt;code&gt;run_process()&lt;/code&gt;&lt;/a&gt; is similar to the standard library &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.run&quot;&gt;&lt;code&gt;subprocess.run()&lt;/code&gt;&lt;/a&gt; function, but tries to have safer defaults: with no options, the subprocess&amp;rsquo;s input is empty rather than coming from the user&amp;rsquo;s terminal, and a failure in the subprocess will be propagated as a &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError&quot;&gt;&lt;code&gt;subprocess.CalledProcessError&lt;/code&gt;&lt;/a&gt; exception. Of course, these defaults can be changed where necessary.</source>
          <target state="translated">La interfaz b&amp;aacute;sica para ejecutar un subproceso de principio a fin es &lt;a href=&quot;#trio.run_process&quot;&gt; &lt;code&gt;trio.run_process()&lt;/code&gt; &lt;/a&gt; . Siempre espera a que el subproceso salga antes de regresar, por lo que no hay necesidad de preocuparse por dejar un proceso ejecut&amp;aacute;ndose por error despu&amp;eacute;s de haber hecho otras cosas. &lt;a href=&quot;#trio.run_process&quot;&gt; &lt;code&gt;run_process()&lt;/code&gt; &lt;/a&gt; es similar a la funci&amp;oacute;n &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.run&quot;&gt; &lt;code&gt;subprocess.run()&lt;/code&gt; &lt;/a&gt; biblioteca est&amp;aacute;ndar , pero trata de tener valores predeterminados m&amp;aacute;s seguros: sin opciones, la entrada del subproceso est&amp;aacute; vac&amp;iacute;a en lugar de provenir de la terminal del usuario, y una falla en el subproceso se propagar&amp;aacute; como una excepci&amp;oacute;n &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError&quot;&gt; &lt;code&gt;subprocess.CalledProcessError&lt;/code&gt; &lt;/a&gt; . Por supuesto, estos valores predeterminados se pueden cambiar cuando sea necesario.</target>
        </trans-unit>
        <trans-unit id="b090dfb35042436a7ca99fd5410fd44306c03217" translate="yes" xml:space="preserve">
          <source>The call is effectively run as part of a system task (see &lt;a href=&quot;#trio.hazmat.spawn_system_task&quot;&gt;&lt;code&gt;spawn_system_task()&lt;/code&gt;&lt;/a&gt;). In particular this means that:</source>
          <target state="translated">La llamada se ejecuta de forma eficaz como parte de una tarea del sistema (consulte &lt;a href=&quot;#trio.hazmat.spawn_system_task&quot;&gt; &lt;code&gt;spawn_system_task()&lt;/code&gt; &lt;/a&gt; ). En particular, esto significa que:</target>
        </trans-unit>
        <trans-unit id="da0df1635f15fea0d33b44e3dee1a6acb61c81e3" translate="yes" xml:space="preserve">
          <source>The call is effectively run as part of a system task (see &lt;a href=&quot;#trio.lowlevel.spawn_system_task&quot;&gt;&lt;code&gt;spawn_system_task()&lt;/code&gt;&lt;/a&gt;). In particular this means that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e085c84fa0bd56c6a1744858621eddc3529f1ab" translate="yes" xml:space="preserve">
          <source>The call will happen &amp;ldquo;soon&amp;rdquo;, but there&amp;rsquo;s no guarantee about exactly when, and no mechanism provided for finding out when it&amp;rsquo;s happened. If you need this, you&amp;rsquo;ll have to build your own.</source>
          <target state="translated">La llamada ocurrir&amp;aacute; &quot;pronto&quot;, pero no hay garant&amp;iacute;a de cu&amp;aacute;ndo exactamente, y no se proporciona ning&amp;uacute;n mecanismo para averiguar cu&amp;aacute;ndo sucedi&amp;oacute;. Si lo necesita, tendr&amp;aacute; que crear el suyo propio.</target>
        </trans-unit>
        <trans-unit id="f65883a9e5f4663eec2ec83235e2b12a73452383" translate="yes" xml:space="preserve">
          <source>The call&amp;rsquo;s context transitions to a cancelled state (e.g. due to a timeout expiring). When this happens, the &lt;code&gt;abort_func&lt;/code&gt; is called. Its interface looks like:</source>
          <target state="translated">El contexto de la llamada pasa a un estado cancelado (por ejemplo, debido a que expira un tiempo de espera). Cuando esto sucede, se llama a &lt;code&gt;abort_func&lt;/code&gt; . Su interfaz se parece a:</target>
        </trans-unit>
        <trans-unit id="5fbb59f871095d18125dac21e3ce5f6c4a428f18" translate="yes" xml:space="preserve">
          <source>The child process runs in the same process group as the parent Trio process, so a Ctrl+C will be delivered simultaneously to both parent and child. If you don&amp;rsquo;t want this behavior, consult your platform&amp;rsquo;s documentation for starting child processes in a different process group.</source>
          <target state="translated">El proceso hijo se ejecuta en el mismo grupo de procesos que el proceso principal Trio, por lo que Ctrl + C se enviar&amp;aacute; simult&amp;aacute;neamente tanto al padre como al hijo. Si no desea este comportamiento, consulte la documentaci&amp;oacute;n de su plataforma para iniciar procesos secundarios en un grupo de procesos diferente.</target>
        </trans-unit>
        <trans-unit id="c976c6c8d5145bd4ff6affacb6c3f1362c034af5" translate="yes" xml:space="preserve">
          <source>The child task inherits its parent nursery&amp;rsquo;s cancel scopes.</source>
          <target state="translated">La tarea secundaria hereda los &amp;aacute;mbitos de cancelaci&amp;oacute;n de su guarder&amp;iacute;a principal.</target>
        </trans-unit>
        <trans-unit id="c1ab1cbf820d8f59e91b46c89d08aa0c12ea8f78" translate="yes" xml:space="preserve">
          <source>The cleanup of the generator occurs in a cancelled context, i.e., all blocking calls executed during cleanup will raise &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;. This is to compensate for the fact that any timeouts surrounding the original use of the generator have been long since forgotten.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc1f039bb2a071befdb1d5415e64c53631ab9639" translate="yes" xml:space="preserve">
          <source>The cleanup runs without access to any &lt;a href=&quot;#task-local-storage&quot;&gt;context variables&lt;/a&gt; that may have been present when the generator was originally being used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="090b8413d6d5997349650354696f3c9148019f8b" translate="yes" xml:space="preserve">
          <source>The clock keeps an eye on the run loop, and if at any point it detects that all tasks have been blocked for this many real seconds (i.e., according to the actual clock, not this clock), then the clock automatically jumps ahead to the run loop&amp;rsquo;s next scheduled timeout. Default is &lt;a href=&quot;https://docs.python.org/3/library/math.html#math.inf&quot;&gt;&lt;code&gt;math.inf&lt;/code&gt;&lt;/a&gt;, i.e., to never autojump. You can assign to this attribute to change it.</source>
          <target state="translated">El reloj mantiene un ojo en el ciclo de ejecuci&amp;oacute;n, y si en alg&amp;uacute;n momento detecta que todas las tareas se han bloqueado durante tantos segundos reales (es decir, de acuerdo con el reloj real, no este reloj), entonces el reloj salta autom&amp;aacute;ticamente al ejecutar el pr&amp;oacute;ximo tiempo de espera programado del bucle. El valor predeterminado es &lt;a href=&quot;https://docs.python.org/3/library/math.html#math.inf&quot;&gt; &lt;code&gt;math.inf&lt;/code&gt; &lt;/a&gt; , es decir, para nunca saltar autom&amp;aacute;ticamente. Puede asignar a este atributo para cambiarlo.</target>
        </trans-unit>
        <trans-unit id="bdc3a0eca08ee71b9b3549872b59ce6be02757ec" translate="yes" xml:space="preserve">
          <source>The clones all share the same underlying channel. Whenever a clone &lt;a href=&quot;#trio.MemoryReceiveChannel.receive&quot;&gt;&lt;code&gt;receive()&lt;/code&gt;&lt;/a&gt;s a value, it is removed from the channel and the other clones do &lt;em&gt;not&lt;/em&gt; receive that value. If you want to send multiple copies of the same stream of values to multiple destinations, like &lt;a href=&quot;https://docs.python.org/3/library/itertools.html#itertools.tee&quot;&gt;&lt;code&gt;itertools.tee()&lt;/code&gt;&lt;/a&gt;, then you need to find some other solution; this method does &lt;em&gt;not&lt;/em&gt; do that.</source>
          <target state="translated">Todos los clones comparten el mismo canal subyacente. Siempre que un clon &lt;a href=&quot;#trio.MemoryReceiveChannel.receive&quot;&gt; &lt;code&gt;receive()&lt;/code&gt; &lt;/a&gt; un valor, se elimina del canal y los otros clones &lt;em&gt;no&lt;/em&gt; reciben ese valor. Si desea enviar m&amp;uacute;ltiples copias del mismo flujo de valores a m&amp;uacute;ltiples destinos, como &lt;a href=&quot;https://docs.python.org/3/library/itertools.html#itertools.tee&quot;&gt; &lt;code&gt;itertools.tee()&lt;/code&gt; &lt;/a&gt; , entonces necesita encontrar alguna otra soluci&amp;oacute;n; este m&amp;eacute;todo &lt;em&gt;no&lt;/em&gt; hace eso.</target>
        </trans-unit>
        <trans-unit id="8484bcc0221be6040109ffa7d83b7570997846cf" translate="yes" xml:space="preserve">
          <source>The command to run and its arguments usually must be passed to Trio&amp;rsquo;s subprocess APIs as a sequence of strings, where the first element in the sequence specifies the command to run and the remaining elements specify its arguments, one argument per element. This form is used because it avoids potential quoting pitfalls; for example, you can run &lt;code&gt;[&quot;cp&quot;, &quot;-f&quot;, source_file, dest_file]&lt;/code&gt; without worrying about whether &lt;code&gt;source_file&lt;/code&gt; or &lt;code&gt;dest_file&lt;/code&gt; contains spaces.</source>
          <target state="translated">El comando para ejecutar y sus argumentos generalmente deben pasarse a las API de subproceso de Trio como una secuencia de cadenas, donde el primer elemento de la secuencia especifica el comando a ejecutar y los elementos restantes especifican sus argumentos, un argumento por elemento. Este formulario se utiliza porque evita posibles errores de cotizaci&amp;oacute;n; por ejemplo, puede ejecutar &lt;code&gt;[&quot;cp&quot;, &quot;-f&quot;, source_file, dest_file]&lt;/code&gt; sin preocuparse de si &lt;code&gt;source_file&lt;/code&gt; o &lt;code&gt;dest_file&lt;/code&gt; contiene espacios.</target>
        </trans-unit>
        <trans-unit id="4730db3841ecac8c8cf89e3a6be900006068c1f2" translate="yes" xml:space="preserve">
          <source>The context manager &lt;code&gt;__enter__&lt;/code&gt; returns the &lt;a href=&quot;#trio.CancelScope&quot;&gt;&lt;code&gt;CancelScope&lt;/code&gt;&lt;/a&gt; object itself, so you can also write &lt;code&gt;with trio.CancelScope() as
cancel_scope:&lt;/code&gt;.</source>
          <target state="translated">El gestor de contexto &lt;code&gt;__enter__&lt;/code&gt; devuelve el &lt;a href=&quot;#trio.CancelScope&quot;&gt; &lt;code&gt;CancelScope&lt;/code&gt; &lt;/a&gt; propio objeto, por lo que tambi&amp;eacute;n se puede escribir &lt;code&gt;with trio.CancelScope() as cancel_scope:&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc3186b88676ea5d5847e4ef990e5751bbba3807" translate="yes" xml:space="preserve">
          <source>The conventional way to define &lt;code&gt;async_fn&lt;/code&gt; is like:</source>
          <target state="translated">La forma convencional de definir &lt;code&gt;async_fn&lt;/code&gt; es como:</target>
        </trans-unit>
        <trans-unit id="285a971ece21b42e0c4e6df991ed9acdbc0ef226" translate="yes" xml:space="preserve">
          <source>The core channel API is defined by the abstract base classes &lt;a href=&quot;reference-io#trio.abc.SendChannel&quot;&gt;&lt;code&gt;trio.abc.SendChannel&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;reference-io#trio.abc.ReceiveChannel&quot;&gt;&lt;code&gt;trio.abc.ReceiveChannel&lt;/code&gt;&lt;/a&gt;. You can use these to implement your own custom channels, that do things like pass objects between processes or over the network. But in many cases, you just want to pass objects between different tasks inside a single process, and for that you can use &lt;a href=&quot;#trio.open_memory_channel&quot;&gt;&lt;code&gt;trio.open_memory_channel()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">La API del canal principal est&amp;aacute; definida por las clases base abstractas &lt;a href=&quot;reference-io#trio.abc.SendChannel&quot;&gt; &lt;code&gt;trio.abc.SendChannel&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;reference-io#trio.abc.ReceiveChannel&quot;&gt; &lt;code&gt;trio.abc.ReceiveChannel&lt;/code&gt; &lt;/a&gt; . Puede usarlos para implementar sus propios canales personalizados, que hacen cosas como pasar objetos entre procesos o en la red. Pero en muchos casos, solo desea pasar objetos entre diferentes tareas dentro de un solo proceso, y para eso puede usar &lt;a href=&quot;#trio.open_memory_channel&quot;&gt; &lt;code&gt;trio.open_memory_channel()&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="616f1878bad341382d56b04b9e33c8f93029c10b" translate="yes" xml:space="preserve">
          <source>The current clock</source>
          <target state="translated">El reloj actual</target>
        </trans-unit>
        <trans-unit id="4995ded951b2fbe16c164c4c7f4d5f2dc2fffe22" translate="yes" xml:space="preserve">
          <source>The current time.</source>
          <target state="translated">La hora actual.</target>
        </trans-unit>
        <trans-unit id="d687bbc14082046996832ddcdec42c12e4cae031" translate="yes" xml:space="preserve">
          <source>The current value of the semaphore.</source>
          <target state="translated">El valor actual del semáforo.</target>
        </trans-unit>
        <trans-unit id="3eb350ac6cebc4b1fa0724100f48143c6b0ab33d" translate="yes" xml:space="preserve">
          <source>The data received.</source>
          <target state="translated">Los datos recibidos.</target>
        </trans-unit>
        <trans-unit id="9036f43c367d4a503f60d7664967b2259da5ae52" translate="yes" xml:space="preserve">
          <source>The default behavior is nice because it means that even if you accidentally write an infinite loop that never executes any checkpoints, then you can still break out of it using control-C. The alternative behavior is nice if you&amp;rsquo;re paranoid about a &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; at just the wrong place leaving your program in an inconsistent state, because it means that you only have to worry about &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; at the exact same places where you already have to worry about &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El comportamiento predeterminado es bueno porque significa que incluso si escribe accidentalmente un bucle infinito que nunca ejecuta ning&amp;uacute;n punto de control, a&amp;uacute;n puede salir de &amp;eacute;l usando control-C. El comportamiento alternativo es bueno si est&amp;aacute; paranoico acerca de un &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; en el lugar equivocado que deja su programa en un estado inconsistente, porque significa que solo tiene que preocuparse por &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; exactamente en los mismos lugares donde ya tiene que preocuparse por &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0e55b739f210dc55513c361f9fe51be776304fc5" translate="yes" xml:space="preserve">
          <source>The default cleanup logic is often sufficient for simple cases, but what if you want a more sophisticated supervisor? For example, maybe you have &lt;a href=&quot;http://learnyousomeerlang.com/supervisors&quot;&gt;Erlang envy&lt;/a&gt; and want features like automatic restart of crashed tasks. Trio itself doesn&amp;rsquo;t provide these kinds of features, but you can build them on top; Trio&amp;rsquo;s goal is to enforce basic hygiene and then get out of your way. (Specifically: Trio won&amp;rsquo;t let you build a supervisor that exits and leaves orphaned tasks behind, and if you have an unhandled exception due to bugs or laziness then Trio will make sure they propagate.) And then you can wrap your fancy supervisor up in a library and put it on PyPI, because supervisors are tricky and there&amp;rsquo;s no reason everyone should have to write their own.</source>
          <target state="translated">La l&amp;oacute;gica de limpieza predeterminada suele ser suficiente para casos simples, pero &amp;iquest;qu&amp;eacute; sucede si desea un supervisor m&amp;aacute;s sofisticado? Por ejemplo, tal vez tenga la &lt;a href=&quot;http://learnyousomeerlang.com/supervisors&quot;&gt;envidia de Erlang&lt;/a&gt; y desee funciones como el reinicio autom&amp;aacute;tico de las tareas bloqueadas. Trio en s&amp;iacute; no proporciona este tipo de funciones, pero puede construirlas encima; El objetivo de Trio es hacer cumplir la higiene b&amp;aacute;sica y luego salir de su camino. (Espec&amp;iacute;ficamente: Trio no le permitir&amp;aacute; construir un supervisor que salga y deje atr&amp;aacute;s las tareas hu&amp;eacute;rfanas, y si tiene una excepci&amp;oacute;n no manejada debido a errores o pereza, Trio se asegurar&amp;aacute; de que se propaguen). Y luego puede envolver a su elegante supervisor en una biblioteca y ponerlo en PyPI, porque los supervisores son complicados y no hay raz&amp;oacute;n para que todos tengan que escribir los suyos.</target>
        </trans-unit>
        <trans-unit id="5c9ed5e68e8b87af228bafd594375bf1414c72bb" translate="yes" xml:space="preserve">
          <source>The default clock is currently implemented as &lt;a href=&quot;https://docs.python.org/3/library/time.html#time.perf_counter&quot;&gt;&lt;code&gt;time.perf_counter()&lt;/code&gt;&lt;/a&gt; plus a large random offset. The idea here is to catch code that accidentally uses &lt;a href=&quot;https://docs.python.org/3/library/time.html#time.perf_counter&quot;&gt;&lt;code&gt;time.perf_counter()&lt;/code&gt;&lt;/a&gt; early, which should help keep our options open for &lt;a href=&quot;https://github.com/python-trio/trio/issues/33&quot;&gt;changing the clock implementation later&lt;/a&gt;, and (more importantly) make sure you can be confident that custom clocks like &lt;a href=&quot;reference-testing#trio.testing.MockClock&quot;&gt;&lt;code&gt;trio.testing.MockClock&lt;/code&gt;&lt;/a&gt; will work with third-party libraries you don&amp;rsquo;t control.</source>
          <target state="translated">El reloj predeterminado est&amp;aacute; implementado actualmente como &lt;a href=&quot;https://docs.python.org/3/library/time.html#time.perf_counter&quot;&gt; &lt;code&gt;time.perf_counter()&lt;/code&gt; &lt;/a&gt; m&amp;aacute;s un gran desplazamiento aleatorio. La idea aqu&amp;iacute; es capturar el c&amp;oacute;digo que accidentalmente usa &lt;a href=&quot;https://docs.python.org/3/library/time.html#time.perf_counter&quot;&gt; &lt;code&gt;time.perf_counter()&lt;/code&gt; &lt;/a&gt; temprano, lo que deber&amp;iacute;a ayudar a mantener nuestras opciones abiertas para &lt;a href=&quot;https://github.com/python-trio/trio/issues/33&quot;&gt;cambiar la implementaci&amp;oacute;n del reloj m&amp;aacute;s adelante&lt;/a&gt; y (lo que es m&amp;aacute;s importante) asegurarse de que puede estar seguro de que los relojes personalizados como &lt;a href=&quot;reference-testing#trio.testing.MockClock&quot;&gt; &lt;code&gt;trio.testing.MockClock&lt;/code&gt; &lt;/a&gt; funcionar&amp;aacute; con bibliotecas de terceros que no controle.</target>
        </trans-unit>
        <trans-unit id="161d86aa18f9fc36797e67f6ae10b87299de29e3" translate="yes" xml:space="preserve">
          <source>The difference between &lt;a href=&quot;#trio.abc.HalfCloseableStream.send_eof&quot;&gt;&lt;code&gt;send_eof()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt; is that &lt;a href=&quot;#trio.abc.HalfCloseableStream.send_eof&quot;&gt;&lt;code&gt;send_eof()&lt;/code&gt;&lt;/a&gt; is a &lt;em&gt;unidirectional&lt;/em&gt; end-of-file indication. After you call this method, you shouldn&amp;rsquo;t try sending any more data on this stream, and your remote peer should receive an end-of-file indication (eventually, after receiving all the data you sent before that). But, they may continue to send data to you, and you can continue to receive it by calling &lt;a href=&quot;#trio.abc.ReceiveStream.receive_some&quot;&gt;&lt;code&gt;receive_some()&lt;/code&gt;&lt;/a&gt;. You can think of it as calling &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt; on just the &lt;a href=&quot;#trio.abc.SendStream&quot;&gt;&lt;code&gt;SendStream&lt;/code&gt;&lt;/a&gt; &amp;ldquo;half&amp;rdquo; of the stream object (and in fact that&amp;rsquo;s literally how &lt;a href=&quot;#trio.StapledStream&quot;&gt;&lt;code&gt;trio.StapledStream&lt;/code&gt;&lt;/a&gt; implements it).</source>
          <target state="translated">La diferencia entre &lt;a href=&quot;#trio.abc.HalfCloseableStream.send_eof&quot;&gt; &lt;code&gt;send_eof()&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt; es que &lt;a href=&quot;#trio.abc.HalfCloseableStream.send_eof&quot;&gt; &lt;code&gt;send_eof()&lt;/code&gt; &lt;/a&gt; es una indicaci&amp;oacute;n &lt;em&gt;unidireccional de&lt;/em&gt; fin de archivo. Despu&amp;eacute;s de llamar a este m&amp;eacute;todo, no deber&amp;iacute;a intentar enviar m&amp;aacute;s datos en este flujo, y su par remoto deber&amp;iacute;a recibir una indicaci&amp;oacute;n de fin de archivo (eventualmente, despu&amp;eacute;s de recibir todos los datos que envi&amp;oacute; antes). Sin embargo, es posible que sigan envi&amp;aacute;ndole datos y usted puede seguir &lt;a href=&quot;#trio.abc.ReceiveStream.receive_some&quot;&gt; &lt;code&gt;receive_some()&lt;/code&gt; &lt;/a&gt; llamando a receive_some () . Puede pensar en ello como llamar a &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt; solo en la &quot;mitad&quot; de &lt;a href=&quot;#trio.abc.SendStream&quot;&gt; &lt;code&gt;SendStream&lt;/code&gt; &lt;/a&gt; del objeto de flujo (y de hecho, as&amp;iacute; es literalmente como &lt;a href=&quot;#trio.StapledStream&quot;&gt; &lt;code&gt;trio.StapledStream&lt;/code&gt; &lt;/a&gt; implementa trio.StapledStream ).</target>
        </trans-unit>
        <trans-unit id="f54f20adf46b020768fc2d9699f83c2a84a5dbee" translate="yes" xml:space="preserve">
          <source>The difference between &lt;a href=&quot;#trio.sleep&quot;&gt;&lt;code&gt;sleep()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.sleep_until&quot;&gt;&lt;code&gt;sleep_until()&lt;/code&gt;&lt;/a&gt; is that the former takes a relative time and the latter takes an absolute time.</source>
          <target state="translated">La diferencia entre &lt;a href=&quot;#trio.sleep&quot;&gt; &lt;code&gt;sleep()&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#trio.sleep_until&quot;&gt; &lt;code&gt;sleep_until()&lt;/code&gt; &lt;/a&gt; es que el primero toma un tiempo relativo y el segundo toma un tiempo absoluto.</target>
        </trans-unit>
        <trans-unit id="73cc2ba69f4c206ad58a296445de0bca80474d34" translate="yes" xml:space="preserve">
          <source>The downside of this kind of thread pool is that sometimes, you need more sophisticated logic for controlling how many threads are run at once. For example, you might want a policy like &amp;ldquo;at most 20 threads total, but no more than 3 of those can be running jobs associated with the same user account&amp;rdquo;, or you might want a pool whose size is dynamically adjusted over time in response to system conditions.</source>
          <target state="translated">La desventaja de este tipo de grupo de subprocesos es que, a veces, necesita una l&amp;oacute;gica m&amp;aacute;s sofisticada para controlar cu&amp;aacute;ntos subprocesos se ejecutan a la vez. Por ejemplo, es posible que desee una pol&amp;iacute;tica como &quot;como m&amp;aacute;ximo 20 subprocesos en total, pero no m&amp;aacute;s de 3 de ellos pueden ejecutar trabajos asociados con la misma cuenta de usuario&quot;, o puede que desee un grupo cuyo tama&amp;ntilde;o se ajuste din&amp;aacute;micamente con el tiempo en respuesta a las condiciones del sistema.</target>
        </trans-unit>
        <trans-unit id="35be47a84f944c2be421f7a4c36aaf2ef2022432" translate="yes" xml:space="preserve">
          <source>The end result is that Trio has successfully cancelled exactly the work that was happening within the scope that was cancelled.</source>
          <target state="translated">El resultado final es que Trio ha cancelado con éxito exactamente el trabajo que estaba sucediendo dentro del ámbito que fue cancelado.</target>
        </trans-unit>
        <trans-unit id="0a65d9d853aa11c16016bf7c9ce9148c89cc1dcf" translate="yes" xml:space="preserve">
          <source>The end result is that data automatically flows from the &lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt;&lt;code&gt;MemorySendStream&lt;/code&gt;&lt;/a&gt; to the &lt;a href=&quot;#trio.testing.MemoryReceiveStream&quot;&gt;&lt;code&gt;MemoryReceiveStream&lt;/code&gt;&lt;/a&gt;. But you&amp;rsquo;re also free to rearrange things however you like. For example, you can temporarily set the &lt;a href=&quot;#trio.testing.MemorySendStream.send_all_hook&quot;&gt;&lt;code&gt;send_all_hook&lt;/code&gt;&lt;/a&gt; to None if you want to simulate a stall in data transmission. Or see &lt;a href=&quot;#trio.testing.memory_stream_pair&quot;&gt;&lt;code&gt;memory_stream_pair()&lt;/code&gt;&lt;/a&gt; for a more elaborate example.</source>
          <target state="translated">El resultado final es que los datos fluyen autom&amp;aacute;ticamente de &lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt; &lt;code&gt;MemorySendStream&lt;/code&gt; &lt;/a&gt; a &lt;a href=&quot;#trio.testing.MemoryReceiveStream&quot;&gt; &lt;code&gt;MemoryReceiveStream&lt;/code&gt; &lt;/a&gt; . Pero tambi&amp;eacute;n puedes reorganizar las cosas como quieras. Por ejemplo, puede establecer temporalmente &lt;a href=&quot;#trio.testing.MemorySendStream.send_all_hook&quot;&gt; &lt;code&gt;send_all_hook&lt;/code&gt; &lt;/a&gt; en Ninguno si desea simular un bloqueo en la transmisi&amp;oacute;n de datos. O vea &lt;a href=&quot;#trio.testing.memory_stream_pair&quot;&gt; &lt;code&gt;memory_stream_pair()&lt;/code&gt; &lt;/a&gt; para un ejemplo m&amp;aacute;s elaborado.</target>
        </trans-unit>
        <trans-unit id="c02286292f2ec8e799d942bfe364baa2b77891d9" translate="yes" xml:space="preserve">
          <source>The exit status of the process (an integer), or &lt;code&gt;None&lt;/code&gt; if it is not yet known to have exited.</source>
          <target state="translated">El estado de salida del proceso (un n&amp;uacute;mero entero), o &lt;code&gt;None&lt;/code&gt; si a&amp;uacute;n no se sabe que sali&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="764eaae6504831ac4ae991985061b3fff32743ff" translate="yes" xml:space="preserve">
          <source>The exit status of the process (an integer), or &lt;code&gt;None&lt;/code&gt; if it&amp;rsquo;s still running.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="125adfc9dd9147da3a2e6de16b33684508367c26" translate="yes" xml:space="preserve">
          <source>The exit status of the process, or &lt;code&gt;None&lt;/code&gt; if it is still running; see &lt;a href=&quot;#trio.Process.returncode&quot;&gt;&lt;code&gt;returncode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El estado de salida del proceso, o &lt;code&gt;None&lt;/code&gt; si a&amp;uacute;n se est&amp;aacute; ejecutando; ver &lt;a href=&quot;#trio.Process.returncode&quot;&gt; &lt;code&gt;returncode&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="56a77a4877253a18474ef745e005246f7f5751e2" translate="yes" xml:space="preserve">
          <source>The exit status of the process; see &lt;a href=&quot;#trio.Process.returncode&quot;&gt;&lt;code&gt;returncode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El estado de salida del proceso; ver &lt;a href=&quot;#trio.Process.returncode&quot;&gt; &lt;code&gt;returncode&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="64142ed18435a7e0439ede425fac64c34f741197" translate="yes" xml:space="preserve">
          <source>The following methods are identical to their equivalents in &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket&quot;&gt;&lt;code&gt;socket.socket()&lt;/code&gt;&lt;/a&gt;, except async, and the ones that take address arguments require pre-resolved addresses:</source>
          <target state="translated">Los siguientes m&amp;eacute;todos son id&amp;eacute;nticos a sus equivalentes en &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket&quot;&gt; &lt;code&gt;socket.socket()&lt;/code&gt; &lt;/a&gt; , excepto async, y los que toman argumentos de direcci&amp;oacute;n requieren direcciones resueltas previamente:</target>
        </trans-unit>
        <trans-unit id="27a7e32f93c8094ed84ed0c797a3d1d3450a48a0" translate="yes" xml:space="preserve">
          <source>The general idea is that at any given moment, &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt; maintains a set of &amp;ldquo;instruments&amp;rdquo;, which are objects that implement the &lt;a href=&quot;#trio.abc.Instrument&quot;&gt;&lt;code&gt;trio.abc.Instrument&lt;/code&gt;&lt;/a&gt; interface. When an interesting event happens, it loops over these instruments and notifies them by calling an appropriate method. The tutorial has &lt;a href=&quot;https://trio.readthedocs.io/en/v0.12.1/tutorial.html#tutorial-instrument-example&quot;&gt;a simple example of using this for tracing&lt;/a&gt;.</source>
          <target state="translated">La idea general es que en un momento dado, &lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; mantiene un conjunto de &quot;instrumentos&quot;, que son objetos que implementan la interfaz &lt;a href=&quot;#trio.abc.Instrument&quot;&gt; &lt;code&gt;trio.abc.Instrument&lt;/code&gt; &lt;/a&gt; . Cuando ocurre un evento interesante, recorre estos instrumentos y los notifica llamando al m&amp;eacute;todo apropiado. El tutorial tiene &lt;a href=&quot;https://trio.readthedocs.io/en/v0.12.1/tutorial.html#tutorial-instrument-example&quot;&gt;un ejemplo simple de c&amp;oacute;mo usar esto para rastrear&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="38f9e958d8079cb7f5d77b4f44e525926879c860" translate="yes" xml:space="preserve">
          <source>The general idea is that at any given moment, &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt; maintains a set of &amp;ldquo;instruments&amp;rdquo;, which are objects that implement the &lt;a href=&quot;#trio.abc.Instrument&quot;&gt;&lt;code&gt;trio.abc.Instrument&lt;/code&gt;&lt;/a&gt; interface. When an interesting event happens, it loops over these instruments and notifies them by calling an appropriate method. The tutorial has &lt;a href=&quot;https://trio.readthedocs.io/en/v0.18.0/tutorial.html#tutorial-instrument-example&quot;&gt;a simple example of using this for tracing&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e502d07802ec7eba2f0fb1852ed0486ee5e9106" translate="yes" xml:space="preserve">
          <source>The high-level network interface is built on top of our stream abstraction.</source>
          <target state="translated">La interfaz de la red de alto nivel está construida sobre nuestra abstracción de la corriente.</target>
        </trans-unit>
        <trans-unit id="5e3a6a65d42a4a7a54e93e2fdefe2f8b94a1ab58" translate="yes" xml:space="preserve">
          <source>The idea behind guest mode is to combine the best parts of each approach: we move Trio&amp;rsquo;s step 1 into a separate worker thread, while keeping Trio&amp;rsquo;s step 2 in the main host thread. This way, when the application is idle, both event loops do their &lt;code&gt;sleep_until_something_happens()&lt;/code&gt; at the same time in their own threads. But when the app wakes up and your code is actually running, it all happens in a single thread. The threading trickiness is all handled transparently inside Trio.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f835797b23a892cd0ec30a65a33991b78d40543" translate="yes" xml:space="preserve">
          <source>The instrument API provides a standard way to add custom instrumentation to the run loop. Want to make a histogram of scheduling latencies, log a stack trace of any task that blocks the run loop for &amp;gt;50 ms, or measure what percentage of your process&amp;rsquo;s running time is spent waiting for I/O? This is the place.</source>
          <target state="translated">La API del instrumento proporciona una forma est&amp;aacute;ndar de agregar instrumentaci&amp;oacute;n personalizada al ciclo de ejecuci&amp;oacute;n. &amp;iquest;Quiere hacer un histograma de latencias de programaci&amp;oacute;n, registrar un seguimiento de la pila de cualquier tarea que bloquee el ciclo de ejecuci&amp;oacute;n durante&amp;gt; 50 ms o medir qu&amp;eacute; porcentaje del tiempo de ejecuci&amp;oacute;n de su proceso se dedica a la espera de E / S? Este es el lugar.</target>
        </trans-unit>
        <trans-unit id="8805f7990c95db20674c8cf0adbf6a62540abaa7" translate="yes" xml:space="preserve">
          <source>The interface for custom run loop clocks.</source>
          <target state="translated">La interfaz para los relojes de bucle de funcionamiento personalizado.</target>
        </trans-unit>
        <trans-unit id="8d2a9967f7c764df943ab1556c1344b5805ebda1" translate="yes" xml:space="preserve">
          <source>The interface for run loop instrumentation.</source>
          <target state="translated">La interfaz para la instrumentación del bucle de ejecución.</target>
        </trans-unit>
        <trans-unit id="24dad175acbf711fb3b0ec0ffe0f2c174484725f" translate="yes" xml:space="preserve">
          <source>The list of exception objects that this &lt;a href=&quot;#trio.MultiError&quot;&gt;&lt;code&gt;MultiError&lt;/code&gt;&lt;/a&gt; represents.</source>
          <target state="translated">La lista de objetos de excepci&amp;oacute;n que representa este &lt;a href=&quot;#trio.MultiError&quot;&gt; &lt;code&gt;MultiError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d97d917dc061cfa035e2b53cc57e93026318973d" translate="yes" xml:space="preserve">
          <source>The local IP address or hostname to use as the source for outgoing connections. If &lt;code&gt;None&lt;/code&gt;, we let the OS pick the source IP.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1672ae196b4e642ba06023f24ab7cc43131e887" translate="yes" xml:space="preserve">
          <source>The local interface to bind to. This is passed to &lt;a href=&quot;#trio.socket.getaddrinfo&quot;&gt;&lt;code&gt;getaddrinfo()&lt;/code&gt;&lt;/a&gt; with the &lt;code&gt;AI_PASSIVE&lt;/code&gt; flag set.</source>
          <target state="translated">La interfaz local a la que enlazar. Esto se pasa a &lt;a href=&quot;#trio.socket.getaddrinfo&quot;&gt; &lt;code&gt;getaddrinfo()&lt;/code&gt; &lt;/a&gt; con la bandera &lt;code&gt;AI_PASSIVE&lt;/code&gt; activada .</target>
        </trans-unit>
        <trans-unit id="14c98d1cac25a3b78cb6648f736ac16134a060c5" translate="yes" xml:space="preserve">
          <source>The maximum allowed value. May be None to indicate no limit.</source>
          <target state="translated">El valor máximo permitido.Puede ser Ninguno para indicar que no hay límite.</target>
        </trans-unit>
        <trans-unit id="e07a666dfbfb8644fe55abda725387879d01201f" translate="yes" xml:space="preserve">
          <source>The most common reason to call this would be if you want to modify its &lt;a href=&quot;#trio.CapacityLimiter.total_tokens&quot;&gt;&lt;code&gt;total_tokens&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">La raz&amp;oacute;n m&amp;aacute;s com&amp;uacute;n para llamar a esto ser&amp;iacute;a si desea modificar su atributo &lt;a href=&quot;#trio.CapacityLimiter.total_tokens&quot;&gt; &lt;code&gt;total_tokens&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7511fb68df6cf2da5466a9d58a8996e5da043bc2" translate="yes" xml:space="preserve">
          <source>The next two functions are used &lt;em&gt;together&lt;/em&gt; to make up a checkpoint:</source>
          <target state="translated">Las siguientes dos funciones se utilizan &lt;em&gt;juntas&lt;/em&gt; para crear un punto de control:</target>
        </trans-unit>
        <trans-unit id="f81d0f7d0980e217423a2ccc40b05846cbdc06e4" translate="yes" xml:space="preserve">
          <source>The number of real seconds to sleep until the given deadline. May be &lt;a href=&quot;https://docs.python.org/3/library/math.html#math.inf&quot;&gt;&lt;code&gt;math.inf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El n&amp;uacute;mero de segundos reales para dormir hasta la fecha l&amp;iacute;mite indicada. Puede ser &lt;a href=&quot;https://docs.python.org/3/library/math.html#math.inf&quot;&gt; &lt;code&gt;math.inf&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="37eae6844d9390786325d85229c1ce9b532328ee" translate="yes" xml:space="preserve">
          <source>The nurseries this task contains.</source>
          <target state="translated">Las guarderías que contiene esta tarea.</target>
        </trans-unit>
        <trans-unit id="177a7ce78b560282b7d992c4ec3372923f31b6c2" translate="yes" xml:space="preserve">
          <source>The nursery API</source>
          <target state="translated">El API de la guardería</target>
        </trans-unit>
        <trans-unit id="8d7ae1a4a8aa454bf6b6d79e73ec598b862fddd0" translate="yes" xml:space="preserve">
          <source>The nursery is marked as &amp;ldquo;closed&amp;rdquo;, meaning that no new tasks can be started inside it.</source>
          <target state="translated">El vivero est&amp;aacute; marcado como &quot;cerrado&quot;, lo que significa que no se pueden iniciar nuevas tareas dentro de &amp;eacute;l.</target>
        </trans-unit>
        <trans-unit id="e86ba7e9365d0994757a3cc78cdf4d4a2887a4b2" translate="yes" xml:space="preserve">
          <source>The nursery this task is inside (or None if this is the &amp;ldquo;init&amp;rdquo; task).</source>
          <target state="translated">El vivero esta tarea est&amp;aacute; dentro (o None si esta es la tarea &quot;init&quot;).</target>
        </trans-unit>
        <trans-unit id="bbbe1db186ffd127db3c1b33bfa29d82594cf817" translate="yes" xml:space="preserve">
          <source>The nursery this task will be inside after it calls &lt;code&gt;task_status.started()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a61b8d74747e89d4158a137ff8a09c9922960de0" translate="yes" xml:space="preserve">
          <source>The nursery will remain open until all child tasks have completed, or until it is cancelled, at which point it will cancel all its remaining child tasks and close.</source>
          <target state="translated">La guardería permanecerá abierta hasta que todas las tareas infantiles se hayan completado,o hasta que se cancele,en cuyo momento cancelará todas las tareas infantiles restantes y cerrará.</target>
        </trans-unit>
        <trans-unit id="e74f79510a42647a66bf3c95ba615073d3c63132" translate="yes" xml:space="preserve">
          <source>The port to listen on.</source>
          <target state="translated">El puerto para escuchar.</target>
        </trans-unit>
        <trans-unit id="1121984a78f092b4bacac75ab91c9cb4d443a8c8" translate="yes" xml:space="preserve">
          <source>The previous hostname resolver (which may be None).</source>
          <target state="translated">El anterior resolutor de nombres de host (que puede ser None).</target>
        </trans-unit>
        <trans-unit id="47eb3fd202a96ce8b6174dec37d51f1fd66c70e2" translate="yes" xml:space="preserve">
          <source>The previous socket factory (which may be None).</source>
          <target state="translated">La fábrica de enchufes anterior (que puede ser None).</target>
        </trans-unit>
        <trans-unit id="00c7eb37d4f3f8b22dbe29040f3260a6ce77789e" translate="yes" xml:space="preserve">
          <source>The problem here is step 1. Two different event loops on the same thread can take turns running user tasks in step 2, but when they&amp;rsquo;re idle and nothing is happening, they can&amp;rsquo;t both invoke their own &lt;code&gt;sleep_until_something_happens()&lt;/code&gt; function at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e2b927216cbc564308d285000e1f4433a148da5" translate="yes" xml:space="preserve">
          <source>The process ID of the child process managed by this object.</source>
          <target state="translated">La identificación del proceso del niño gestionado por este objeto.</target>
        </trans-unit>
        <trans-unit id="5b93661739a17b00d39a4b1234f2fd70ed40f36e" translate="yes" xml:space="preserve">
          <source>The really important thing here is the producer&amp;rsquo;s &lt;code&gt;async with&lt;/code&gt; . When the producer exits, this closes the &lt;code&gt;send_channel&lt;/code&gt;, and that tells the consumer that no more messages are coming, so it can cleanly exit its &lt;code&gt;async for&lt;/code&gt; loop. Then the program shuts down because both tasks have exited.</source>
          <target state="translated">Lo realmente importante aqu&amp;iacute; es el &lt;code&gt;async with&lt;/code&gt; del productor con . Cuando el productor sale, esto cierra &lt;code&gt;send_channel&lt;/code&gt; , y eso le dice al consumidor que no van a llegar m&amp;aacute;s mensajes, por lo que puede salir limpiamente de su bucle &lt;code&gt;async for&lt;/code&gt; . Luego, el programa se apaga porque se han cerrado ambas tareas.</target>
        </trans-unit>
        <trans-unit id="28c2cb80c84becdc646dfd3b9efd1c7769ba197d" translate="yes" xml:space="preserve">
          <source>The reason for the restriction on cancel scopes has to do with the difficulty of noticing when a generator gets suspended and resumed. The cancel scopes inside the generator shouldn&amp;rsquo;t affect code running outside the generator, but Trio isn&amp;rsquo;t involved in the process of exiting and reentering the generator, so it would be hard pressed to keep its cancellation plumbing in the correct state. Nurseries use a cancel scope internally, so they have all the problems of cancel scopes plus a number of problems of their own: for example, when the generator is suspended, what should the background tasks do? There&amp;rsquo;s no good way to suspend them, but if they keep running and throw an exception, where can that exception be reraised?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0450c5182bceb6cce56fb0729c22a12ca6a38fb0" translate="yes" xml:space="preserve">
          <source>The reason we distinguish between Trio functions and other functions is that we can&amp;rsquo;t make any guarantees about third party code. Checkpoint-ness is a transitive property: if function A acts as a checkpoint, and you write a function that calls function A, then your function also acts as a checkpoint. If you don&amp;rsquo;t, then it isn&amp;rsquo;t. So there&amp;rsquo;s nothing stopping someone from writing a function like:</source>
          <target state="translated">La raz&amp;oacute;n por la que distinguimos entre las funciones de Trio y otras funciones es que no podemos ofrecer ninguna garant&amp;iacute;a sobre el c&amp;oacute;digo de terceros. El punto de control es una propiedad transitiva: si la funci&amp;oacute;n A act&amp;uacute;a como un punto de control y usted escribe una funci&amp;oacute;n que llama a la funci&amp;oacute;n A, entonces su funci&amp;oacute;n tambi&amp;eacute;n act&amp;uacute;a como un punto de control. Si no lo hace, entonces no lo es. Entonces, nada impide que alguien escriba una funci&amp;oacute;n como:</target>
        </trans-unit>
        <trans-unit id="5b79184643fc427f0f5451ad2bcbe471b0aff8ab" translate="yes" xml:space="preserve">
          <source>The run-local variant of a context variable.</source>
          <target state="translated">La variante run-local de una variable de contexto.</target>
        </trans-unit>
        <trans-unit id="31631f2ee19f6c9eddba1efb6808eed41e256ce1" translate="yes" xml:space="preserve">
          <source>The solution here is simple once you see it: there&amp;rsquo;s no requirement that a nursery object stay in the task that created it! We can write code like this:</source>
          <target state="translated">La soluci&amp;oacute;n aqu&amp;iacute; es simple una vez que la ve: &amp;iexcl;no es necesario que un objeto de guarder&amp;iacute;a permanezca en la tarea que lo cre&amp;oacute;! Podemos escribir c&amp;oacute;digo como este:</target>
        </trans-unit>
        <trans-unit id="f1fd21f3494165761aa268005e2e0795c5723a04" translate="yes" xml:space="preserve">
          <source>The split between &lt;code&gt;fn&lt;/code&gt; and &lt;code&gt;deliver&lt;/code&gt; serves two purposes. First, it&amp;rsquo;s convenient, since most callers need something like this anyway.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55e76f19fc0627ed9227f3fd3880048d89598e1e" translate="yes" xml:space="preserve">
          <source>The standard library synchronization primitives have a variety of mechanisms for specifying timeouts and blocking behavior, and of signaling whether an operation returned due to success versus a timeout.</source>
          <target state="translated">Las primitivas de sincronización de la biblioteca estándar tienen una variedad de mecanismos para especificar los tiempos de espera y el comportamiento de bloqueo,y para señalar si una operación regresó debido a un éxito o a un tiempo de espera.</target>
        </trans-unit>
        <trans-unit id="7effbc2fadcf7d55dbb5dff96899db6a2b1a697d" translate="yes" xml:space="preserve">
          <source>The top-level function in regular user tasks is unprotected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf0ab80440f670597aee7f57471c11affe9f36ac" translate="yes" xml:space="preserve">
          <source>The top-level function in system tasks is protected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dee7da4b40c8ed8470e444bb0b39967c3966f18" translate="yes" xml:space="preserve">
          <source>The total capacity available.</source>
          <target state="translated">La capacidad total disponible.</target>
        </trans-unit>
        <trans-unit id="1bb44cb89fd209709ecbf816f6d2cfd1b4bf8ed2" translate="yes" xml:space="preserve">
          <source>The total overhead will depend on your host loop, your platform, your application, etc. But we expect that in most cases, apps running in guest mode should only be 5-10% slower than the same code using &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run&lt;/code&gt;&lt;/a&gt;. If you find that&amp;rsquo;s not true for your app, then please let us know and we&amp;rsquo;ll see if we can fix it!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3705e62e17c05ed2a283df571e34d9194fff82e9" translate="yes" xml:space="preserve">
          <source>The tutorial has a &lt;a href=&quot;https://trio.readthedocs.io/en/v0.12.1/tutorial.html#tutorial-instrument-example&quot;&gt;fully-worked example&lt;/a&gt; of defining a custom instrument to log Trio&amp;rsquo;s internal scheduling decisions.</source>
          <target state="translated">El tutorial tiene un &lt;a href=&quot;https://trio.readthedocs.io/en/v0.12.1/tutorial.html#tutorial-instrument-example&quot;&gt;ejemplo completo&lt;/a&gt; de c&amp;oacute;mo definir un instrumento personalizado para registrar las decisiones de programaci&amp;oacute;n internas de Trio.</target>
        </trans-unit>
        <trans-unit id="91909955fecf8653c03448ca645e97c0ac1c56fe" translate="yes" xml:space="preserve">
          <source>The tutorial has a &lt;a href=&quot;https://trio.readthedocs.io/en/v0.18.0/tutorial.html#tutorial-instrument-example&quot;&gt;fully-worked example&lt;/a&gt; of defining a custom instrument to log Trio&amp;rsquo;s internal scheduling decisions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05291b85407b1a887472f9d782e55440c9965242" translate="yes" xml:space="preserve">
          <source>The two producers, A and B, send 3 messages apiece. These are then randomly distributed between the two consumers, X and Y. So we&amp;rsquo;re hoping to see some output like:</source>
          <target state="translated">Los dos productores, A y B, env&amp;iacute;an 3 mensajes cada uno. Luego, estos se distribuyen aleatoriamente entre los dos consumidores, X e Y. As&amp;iacute; que esperamos ver algunos resultados como:</target>
        </trans-unit>
        <trans-unit id="5aa97c306d0b8d930fea25557eeb4fb3eb359691" translate="yes" xml:space="preserve">
          <source>The underlying &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#trio.StapledStream.receive_some&quot;&gt;&lt;code&gt;receive_some()&lt;/code&gt;&lt;/a&gt; is delegated to this object.</source>
          <target state="translated">El &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; &lt;/a&gt; subyacente . &lt;a href=&quot;#trio.StapledStream.receive_some&quot;&gt; &lt;code&gt;receive_some()&lt;/code&gt; &lt;/a&gt; se delega a este objeto.</target>
        </trans-unit>
        <trans-unit id="f32b40ca1402eb2f4c81aefb795e70d012cce169" translate="yes" xml:space="preserve">
          <source>The underlying &lt;a href=&quot;#trio.abc.SendStream&quot;&gt;&lt;code&gt;SendStream&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#trio.StapledStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.StapledStream.wait_send_all_might_not_block&quot;&gt;&lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt;&lt;/a&gt; are delegated to this object.</source>
          <target state="translated">El &lt;a href=&quot;#trio.abc.SendStream&quot;&gt; &lt;code&gt;SendStream&lt;/code&gt; &lt;/a&gt; subyacente . &lt;a href=&quot;#trio.StapledStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#trio.StapledStream.wait_send_all_might_not_block&quot;&gt; &lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt; &lt;/a&gt; se delegan a este objeto.</target>
        </trans-unit>
        <trans-unit id="0ad23b6bb25552ac6357c4e430f7019864780286" translate="yes" xml:space="preserve">
          <source>The underlying listener that was passed to &lt;code&gt;__init__&lt;/code&gt;.</source>
          <target state="translated">El oyente subyacente que se pas&amp;oacute; a &lt;code&gt;__init__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f33f2a0c4fd84dacf0327c8790e4bf617b9f380a" translate="yes" xml:space="preserve">
          <source>The underlying stream may be unidirectional, or bidirectional. If it&amp;rsquo;s bidirectional, then you probably want to also implement &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt;, which makes your object a &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El flujo subyacente puede ser unidireccional o bidireccional. Si es bidireccional, probablemente tambi&amp;eacute;n desee implementar &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; &lt;/a&gt; , lo que convierte su objeto en &lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a6e839a070895f18f3a2d8c7670c54a0bc8fe015" translate="yes" xml:space="preserve">
          <source>The underlying stream may be unidirectional, or bidirectional. If it&amp;rsquo;s bidirectional, then you probably want to also implement &lt;a href=&quot;#trio.abc.SendStream&quot;&gt;&lt;code&gt;SendStream&lt;/code&gt;&lt;/a&gt;, which makes your object a &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El flujo subyacente puede ser unidireccional o bidireccional. Si es bidireccional, probablemente tambi&amp;eacute;n &lt;a href=&quot;#trio.abc.SendStream&quot;&gt; &lt;code&gt;SendStream&lt;/code&gt; &lt;/a&gt; implementar SendStream , lo que convierte su objeto en un &lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8a8e841a341ca779f446431b59a0fdcb153b95e2" translate="yes" xml:space="preserve">
          <source>The underlying synchronous file object.</source>
          <target state="translated">El objeto de archivo síncrono subyacente.</target>
        </trans-unit>
        <trans-unit id="8b2590649b5fca1121706db98f3737530bf8d4da" translate="yes" xml:space="preserve">
          <source>The underlying transport stream that was passed to &lt;code&gt;__init__&lt;/code&gt;. An example of when this would be useful is if you&amp;rsquo;re using &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; over a &lt;a href=&quot;#trio.SocketStream&quot;&gt;&lt;code&gt;SocketStream&lt;/code&gt;&lt;/a&gt; and want to call the &lt;a href=&quot;#trio.SocketStream&quot;&gt;&lt;code&gt;SocketStream&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s &lt;a href=&quot;#trio.SocketStream.setsockopt&quot;&gt;&lt;code&gt;setsockopt()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">El flujo de transporte subyacente que se pas&amp;oacute; a &lt;code&gt;__init__&lt;/code&gt; . Un ejemplo de cuando esto ser&amp;iacute;a &amp;uacute;til si se est&amp;aacute; utilizando &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; durante un &lt;a href=&quot;#trio.SocketStream&quot;&gt; &lt;code&gt;SocketStream&lt;/code&gt; &lt;/a&gt; y quiere llamar a la &lt;a href=&quot;#trio.SocketStream&quot;&gt; &lt;code&gt;SocketStream&lt;/code&gt; &lt;/a&gt; &amp;lsquo;s &lt;a href=&quot;#trio.SocketStream.setsockopt&quot;&gt; &lt;code&gt;setsockopt()&lt;/code&gt; &lt;/a&gt; m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="f623fc5e00614ae96a118b39b868c4f90851b815" translate="yes" xml:space="preserve">
          <source>The vast majority of Trio&amp;rsquo;s API is &lt;em&gt;not&lt;/em&gt; thread safe: it can only be used from inside a call to &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt;. This manual doesn&amp;rsquo;t bother documenting this on individual calls; unless specifically noted otherwise, you should assume that it isn&amp;rsquo;t safe to call any Trio functions from anywhere except the Trio thread. (But &lt;a href=&quot;#threads&quot;&gt;see below&lt;/a&gt; if you really do need to work with threads.)</source>
          <target state="translated">La gran mayor&amp;iacute;a de la API de Trio &lt;em&gt;no&lt;/em&gt; es segura para subprocesos: solo se puede usar desde dentro de una llamada a &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; . Este manual no se molesta en documentar esto en llamadas individuales; a menos que se indique espec&amp;iacute;ficamente lo contrario, debe asumir que no es seguro llamar a ninguna funci&amp;oacute;n de Trio desde cualquier lugar excepto el hilo de Trio. (Pero &lt;a href=&quot;#threads&quot;&gt;vea a continuaci&amp;oacute;n&lt;/a&gt; si realmente necesita trabajar con subprocesos).</target>
        </trans-unit>
        <trans-unit id="039522b69359b3e56c31de8d1e26158ab6198376" translate="yes" xml:space="preserve">
          <source>Then tasks can come along and borrow a token out of the sack:</source>
          <target state="translated">Entonces las tareas pueden venir y pedir prestado un símbolo del saco:</target>
        </trans-unit>
        <trans-unit id="8aed655f54fc986620011433879c1bf88c00c1fa" translate="yes" xml:space="preserve">
          <source>Then these both raise &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Entonces estos dos &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="26f0adbdb0fabb432f18981f6cd29877bc3d70d3" translate="yes" xml:space="preserve">
          <source>Then you call &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt;, passing in &lt;code&gt;abort_func&lt;/code&gt;, an &amp;ldquo;abort callback&amp;rdquo;.</source>
          <target state="translated">Luego llama a &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; , pasando &lt;code&gt;abort_func&lt;/code&gt; , una &quot;devoluci&amp;oacute;n de llamada cancelada &quot;.</target>
        </trans-unit>
        <trans-unit id="516276345166a708ba6074c8532f510cdbd74c34" translate="yes" xml:space="preserve">
          <source>Then you call &lt;a href=&quot;#trio.lowlevel.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt;, passing in &lt;code&gt;abort_func&lt;/code&gt;, an &amp;ldquo;abort callback&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ceaee5b77c3b473fc92d1c8284b8ba959ee04c6" translate="yes" xml:space="preserve">
          <source>There are a few idiosyncratic cases where external constraints make it impossible to fully implement these semantics. These are always documented. There is also one systematic exception:</source>
          <target state="translated">Hay algunos casos idiosincrásicos en los que las limitaciones externas hacen imposible la aplicación plena de esta semántica.Estos siempre están documentados.También hay una excepción sistemática:</target>
        </trans-unit>
        <trans-unit id="8ccaa3636c24526c51e3cf2cf4bbb0add69c1e98" translate="yes" xml:space="preserve">
          <source>There are a few pieces here, so here&amp;rsquo;s how they fit together:</source>
          <target state="translated">Aqu&amp;iacute; hay algunas piezas, as&amp;iacute; que as&amp;iacute; es como encajan:</target>
        </trans-unit>
        <trans-unit id="f9b4b72d5e37ba916870f8ebadfd56db51bbd77e" translate="yes" xml:space="preserve">
          <source>There are two possibilities for what happens next:</source>
          <target state="translated">Hay dos posibilidades para lo que sucede a continuación:</target>
        </trans-unit>
        <trans-unit id="b9b90250e8bd2eee9b2b8bf09f29e281e8809b4a" translate="yes" xml:space="preserve">
          <source>There are two versions of SSL/TLS commonly encountered in the wild: the standard version, and the version used for HTTPS (HTTP-over-SSL/TLS).</source>
          <target state="translated">Hay dos versiones de SSL/TLS que se encuentran comúnmente en la naturaleza:la versión estándar y la versión usada para HTTPS (HTTP-over-SSL/TLS).</target>
        </trans-unit>
        <trans-unit id="27e6946011051300b2bdacb518dcf327f5b5bd7b" translate="yes" xml:space="preserve">
          <source>There is a subtlety with how this method interacts with cancellation: when cancelled it will block to re-acquire the lock before raising &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;. This may cause cancellation to be less prompt than expected. The advantage is that it makes code like this work:</source>
          <target state="translated">Hay una sutileza en la forma en que este m&amp;eacute;todo interact&amp;uacute;a con la cancelaci&amp;oacute;n: cuando se cancela, se bloquear&amp;aacute; para volver a adquirir el bloqueo antes de activar &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; . Esto puede hacer que la cancelaci&amp;oacute;n sea menos r&amp;aacute;pida de lo esperado. La ventaja es que hace que un c&amp;oacute;digo como este funcione:</target>
        </trans-unit>
        <trans-unit id="bffd13f140e202626a214af6e92646e6022be490" translate="yes" xml:space="preserve">
          <source>There must be exactly one call to &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt;&lt;code&gt;reschedule()&lt;/code&gt;&lt;/a&gt; for every call to &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt;. (And when counting, keep in mind that returning &lt;a href=&quot;#trio.hazmat.Abort.SUCCEEDED&quot;&gt;&lt;code&gt;Abort.SUCCEEDED&lt;/code&gt;&lt;/a&gt; from an abort callback is equivalent to calling &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt;&lt;code&gt;reschedule()&lt;/code&gt;&lt;/a&gt; once.)</source>
          <target state="translated">Debe haber exactamente una llamada a &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt; &lt;code&gt;reschedule()&lt;/code&gt; &lt;/a&gt; por cada llamada a &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; . (Y al contar, tenga en cuenta que devolver &lt;a href=&quot;#trio.hazmat.Abort.SUCCEEDED&quot;&gt; &lt;code&gt;Abort.SUCCEEDED&lt;/code&gt; &lt;/a&gt; de una devoluci&amp;oacute;n de llamada abortada es equivalente a llamar a &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt; &lt;code&gt;reschedule()&lt;/code&gt; &lt;/a&gt; una vez).</target>
        </trans-unit>
        <trans-unit id="801d34ccb8f29fc40b1813d70b24ba24e4de1c76" translate="yes" xml:space="preserve">
          <source>There must be exactly one call to &lt;a href=&quot;#trio.lowlevel.reschedule&quot;&gt;&lt;code&gt;reschedule()&lt;/code&gt;&lt;/a&gt; for every call to &lt;a href=&quot;#trio.lowlevel.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt;. (And when counting, keep in mind that returning &lt;a href=&quot;#trio.lowlevel.Abort.SUCCEEDED&quot;&gt;&lt;code&gt;Abort.SUCCEEDED&lt;/code&gt;&lt;/a&gt; from an abort callback is equivalent to calling &lt;a href=&quot;#trio.lowlevel.reschedule&quot;&gt;&lt;code&gt;reschedule()&lt;/code&gt;&lt;/a&gt; once.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b29b5490f17425380aad05f050e2ab47d53179e" translate="yes" xml:space="preserve">
          <source>These are commonly used in cases where you have an operation that might-or-might-not block, and you want to implement Trio&amp;rsquo;s standard checkpoint semantics. Example:</source>
          <target state="translated">Estos se usan com&amp;uacute;nmente en casos en los que tiene una operaci&amp;oacute;n que podr&amp;iacute;a bloquear o no, y desea implementar la sem&amp;aacute;ntica de punto de control est&amp;aacute;ndar de Trio. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="3d0bc413452d0608c3c5668aad8331f5e3c73b1b" translate="yes" xml:space="preserve">
          <source>These classes are all guaranteed to be &amp;ldquo;fair&amp;rdquo;, meaning that when it comes time to choose who will be next to acquire a lock, get an item from a queue, etc., then it always goes to the task which has been waiting longest. It&amp;rsquo;s &lt;a href=&quot;https://github.com/python-trio/trio/issues/54&quot;&gt;not entirely clear&lt;/a&gt; whether this is the best choice, but for now that&amp;rsquo;s how it works.</source>
          <target state="translated">Se garantiza que todas estas clases ser&amp;aacute;n &quot;justas&quot;, lo que significa que cuando llega el momento de elegir qui&amp;eacute;n ser&amp;aacute; el siguiente en adquirir un candado, obtener un elemento de una cola, etc., siempre se dirigir&amp;aacute; a la tarea que ha estado esperando por m&amp;aacute;s tiempo. . No est&amp;aacute; del &lt;a href=&quot;https://github.com/python-trio/trio/issues/54&quot;&gt;todo claro&lt;/a&gt; si esta es la mejor opci&amp;oacute;n, pero por ahora as&amp;iacute; es como funciona.</target>
        </trans-unit>
        <trans-unit id="7d75ee66ff83bf4554d223bde19bf99669265ec3" translate="yes" xml:space="preserve">
          <source>These functions can also be useful in other situations. For example, when &lt;a href=&quot;reference-core#trio.to_thread.run_sync&quot;&gt;&lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt;&lt;/a&gt; schedules some work to run in a worker thread, it blocks until the work is finished (so it&amp;rsquo;s a schedule point), but by default it doesn&amp;rsquo;t allow cancellation. So to make sure that the call always acts as a checkpoint, it calls &lt;a href=&quot;#trio.hazmat.checkpoint_if_cancelled&quot;&gt;&lt;code&gt;checkpoint_if_cancelled()&lt;/code&gt;&lt;/a&gt; before starting the thread.</source>
          <target state="translated">Estas funciones tambi&amp;eacute;n pueden resultar &amp;uacute;tiles en otras situaciones. Por ejemplo, cuando &lt;a href=&quot;reference-core#trio.to_thread.run_sync&quot;&gt; &lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt; &lt;/a&gt; programa alg&amp;uacute;n trabajo para que se ejecute en un hilo de trabajo, se bloquea hasta que el trabajo finaliza (por lo que es un punto de programaci&amp;oacute;n), pero de forma predeterminada no permite la cancelaci&amp;oacute;n. Entonces, para asegurarse de que la llamada siempre act&amp;uacute;e como un punto de control, llama &lt;a href=&quot;#trio.hazmat.checkpoint_if_cancelled&quot;&gt; &lt;code&gt;checkpoint_if_cancelled()&lt;/code&gt; &lt;/a&gt; antes de iniciar el hilo.</target>
        </trans-unit>
        <trans-unit id="33c43432e709f0451deb70ea74790ca734f5561a" translate="yes" xml:space="preserve">
          <source>These functions can also be useful in other situations. For example, when &lt;a href=&quot;reference-core#trio.to_thread.run_sync&quot;&gt;&lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt;&lt;/a&gt; schedules some work to run in a worker thread, it blocks until the work is finished (so it&amp;rsquo;s a schedule point), but by default it doesn&amp;rsquo;t allow cancellation. So to make sure that the call always acts as a checkpoint, it calls &lt;a href=&quot;#trio.lowlevel.checkpoint_if_cancelled&quot;&gt;&lt;code&gt;checkpoint_if_cancelled()&lt;/code&gt;&lt;/a&gt; before starting the thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acb414aaadc5ad5c07497ec2df742e42694d9509" translate="yes" xml:space="preserve">
          <source>These transitions are accomplished using two function decorators:</source>
          <target state="translated">Estas transiciones se logran usando dos decoradores de función:</target>
        </trans-unit>
        <trans-unit id="81307d013910a4dd0f0a2b7e14e3fa3a61ebe2f2" translate="yes" xml:space="preserve">
          <source>These two lines are equivalent:</source>
          <target state="translated">Estas dos líneas son equivalentes:</target>
        </trans-unit>
        <trans-unit id="86cd05304bf90b12bb103d8aecc0cf9b07939972" translate="yes" xml:space="preserve">
          <source>They don&amp;rsquo;t need an explicit nursery; instead they go into the internal &amp;ldquo;system nursery&amp;rdquo;.</source>
          <target state="translated">No necesitan una guarder&amp;iacute;a expl&amp;iacute;cita; en su lugar, van al &amp;ldquo;vivero del sistema&amp;rdquo; interno.</target>
        </trans-unit>
        <trans-unit id="0c35b3a96ea0ec2dff743f8b5250ebd577b91e90" translate="yes" xml:space="preserve">
          <source>Third-party async functions / iterators / context managers can act as checkpoints; if you see &lt;code&gt;await &amp;lt;something&amp;gt;&lt;/code&gt; or one of its friends, then that &lt;em&gt;might&lt;/em&gt; be a checkpoint. So to be safe, you should prepare for scheduling or cancellation happening there.</source>
          <target state="translated">Las funciones as&amp;iacute;ncronas / iteradores / administradores de contexto de terceros pueden actuar como puntos de control; si ves &lt;code&gt;await &amp;lt;something&amp;gt;&lt;/code&gt; o uno de sus amigos, entonces &lt;em&gt;podr&amp;iacute;a&lt;/em&gt; ser un punto de control. Entonces, para estar seguro, debe prepararse para la programaci&amp;oacute;n o cancelaci&amp;oacute;n que ocurra all&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="153b8ef41ad99fb02fe77369052399944035c0b2" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; attribute is True if you&amp;rsquo;ve called &lt;code&gt;sock.shutdown(SHUT_WR)&lt;/code&gt; or &lt;code&gt;sock.shutdown(SHUT_RDWR)&lt;/code&gt;, and False otherwise.</source>
          <target state="translated">Este atributo &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt; es True si ha llamado a &lt;code&gt;sock.shutdown(SHUT_WR)&lt;/code&gt; o &lt;code&gt;sock.shutdown(SHUT_RDWR)&lt;/code&gt; , y False en caso contrario.</target>
        </trans-unit>
        <trans-unit id="7c6fe9ee538d951d1c429e8c8db0cf9bc028c153" translate="yes" xml:space="preserve">
          <source>This also means that if you register a SNI callback using &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext.sni_callback&quot;&gt;&lt;code&gt;sni_callback&lt;/code&gt;&lt;/a&gt;, then the first argument your callback receives will be a &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLObject&quot;&gt;&lt;code&gt;ssl.SSLObject&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esto tambi&amp;eacute;n significa que si registra una devoluci&amp;oacute;n de llamada SNI usando &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext.sni_callback&quot;&gt; &lt;code&gt;sni_callback&lt;/code&gt; &lt;/a&gt; , entonces el primer argumento que reciba su devoluci&amp;oacute;n de llamada ser&amp;aacute; un &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLObject&quot;&gt; &lt;code&gt;ssl.SSLObject&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="741317efb643cb97bdd044fc9a9acfb72ef72725" translate="yes" xml:space="preserve">
          <source>This and &lt;a href=&quot;#trio.Nursery.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; are the two fundamental methods for creating concurrent tasks in Trio.</source>
          <target state="translated">Este y &lt;a href=&quot;#trio.Nursery.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; son los dos m&amp;eacute;todos fundamentales para crear tareas concurrentes en Trio.</target>
        </trans-unit>
        <trans-unit id="8f2fdd09fd7fe021c78364cf9bb2f534396d77e1" translate="yes" xml:space="preserve">
          <source>This attribute being True does &lt;em&gt;not&lt;/em&gt; necessarily mean that the code within the scope has been, or will be, affected by the cancellation. For example, if &lt;a href=&quot;#trio.CancelScope.cancel&quot;&gt;&lt;code&gt;cancel()&lt;/code&gt;&lt;/a&gt; was called after the last checkpoint in the &lt;code&gt;with&lt;/code&gt; block, when it&amp;rsquo;s too late to deliver a &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception, then this attribute will still be True.</source>
          <target state="translated">El hecho de que este atributo sea Verdadero &lt;em&gt;no&lt;/em&gt; significa necesariamente que el c&amp;oacute;digo dentro del alcance haya sido o ser&amp;aacute; afectado por la cancelaci&amp;oacute;n. Por ejemplo, si se llam&amp;oacute; a &lt;a href=&quot;#trio.CancelScope.cancel&quot;&gt; &lt;code&gt;cancel()&lt;/code&gt; &lt;/a&gt; despu&amp;eacute;s del &amp;uacute;ltimo punto de control en el bloque &lt;code&gt;with&lt;/code&gt; , cuando es demasiado tarde para entregar una excepci&amp;oacute;n &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; , este atributo seguir&amp;aacute; siendo Verdadero.</target>
        </trans-unit>
        <trans-unit id="a48bfa0f12266fba2f040ed028628232b8e6f5e0" translate="yes" xml:space="preserve">
          <source>This attribute is mostly useful for debugging and introspection. If you want to know whether or not a chunk of code was actually cancelled, then &lt;a href=&quot;#trio.CancelScope.cancelled_caught&quot;&gt;&lt;code&gt;cancelled_caught&lt;/code&gt;&lt;/a&gt; is usually more appropriate.</source>
          <target state="translated">Este atributo es sobre todo &amp;uacute;til para la depuraci&amp;oacute;n y la introspecci&amp;oacute;n. Si desea saber si un fragmento de c&amp;oacute;digo se cancel&amp;oacute; realmente o no, &lt;a href=&quot;#trio.CancelScope.cancelled_caught&quot;&gt; &lt;code&gt;cancelled_caught&lt;/code&gt; &lt;/a&gt; suele ser m&amp;aacute;s apropiado.</target>
        </trans-unit>
        <trans-unit id="ff12646195b62ccf09f268e0dcd0a93a0a83670e" translate="yes" xml:space="preserve">
          <source>This avoids several common pitfalls:</source>
          <target state="translated">Esto evita varios escollos comunes:</target>
        </trans-unit>
        <trans-unit id="626f12244e67c7b41b46a58e659379debb57bbb8" translate="yes" xml:space="preserve">
          <source>This behavior is useful because it helps avoid race conditions and lost wakeups: it doesn&amp;rsquo;t matter whether &lt;a href=&quot;#trio.Event.set&quot;&gt;&lt;code&gt;set()&lt;/code&gt;&lt;/a&gt; gets called just before or after &lt;a href=&quot;#trio.Event.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt;. If you want a lower-level wakeup primitive that doesn&amp;rsquo;t have this protection, consider &lt;a href=&quot;#trio.Condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;reference-hazmat#trio.hazmat.ParkingLot&quot;&gt;&lt;code&gt;trio.hazmat.ParkingLot&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Este comportamiento es &amp;uacute;til porque ayuda a evitar condiciones de carrera y despertares perdidos: no importa si se llama a &lt;a href=&quot;#trio.Event.set&quot;&gt; &lt;code&gt;set()&lt;/code&gt; &lt;/a&gt; justo antes o despu&amp;eacute;s de &lt;a href=&quot;#trio.Event.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; . Si desea una primitiva de activaci&amp;oacute;n de nivel inferior que no tenga esta protecci&amp;oacute;n, considere &lt;a href=&quot;#trio.Condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;reference-hazmat#trio.hazmat.ParkingLot&quot;&gt; &lt;code&gt;trio.hazmat.ParkingLot&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1d7f0d149990683a66350e94bbe30fe0eeb1ebcc" translate="yes" xml:space="preserve">
          <source>This behavior is useful because it helps avoid race conditions and lost wakeups: it doesn&amp;rsquo;t matter whether &lt;a href=&quot;#trio.Event.set&quot;&gt;&lt;code&gt;set()&lt;/code&gt;&lt;/a&gt; gets called just before or after &lt;a href=&quot;#trio.Event.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt;. If you want a lower-level wakeup primitive that doesn&amp;rsquo;t have this protection, consider &lt;a href=&quot;#trio.Condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;reference-lowlevel#trio.lowlevel.ParkingLot&quot;&gt;&lt;code&gt;trio.lowlevel.ParkingLot&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31b0899969e7dc26177e3f97d8a67c806347e3aa" translate="yes" xml:space="preserve">
          <source>This callable should schedule &lt;code&gt;fn()&lt;/code&gt; to be run by the host on its next pass through its loop. &lt;code&gt;Must support being called from arbitrary threads.&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7212591b5e320334b3ae18061636ff4b19af84aa" translate="yes" xml:space="preserve">
          <source>This can be useful for testing flow control mechanisms in an extreme case, or for setting up &amp;ldquo;clogged&amp;rdquo; streams to use with &lt;a href=&quot;#trio.testing.check_one_way_stream&quot;&gt;&lt;code&gt;check_one_way_stream()&lt;/code&gt;&lt;/a&gt; and friends.</source>
          <target state="translated">Esto puede ser &amp;uacute;til para probar los mecanismos de control de flujo en un caso extremo, o para configurar transmisiones &quot;obstruidas&quot; para usar con &lt;a href=&quot;#trio.testing.check_one_way_stream&quot;&gt; &lt;code&gt;check_one_way_stream()&lt;/code&gt; &lt;/a&gt; y amigos.</target>
        </trans-unit>
        <trans-unit id="777508af726dca6e138c62201ae51b11dda89501" translate="yes" xml:space="preserve">
          <source>This checks for cancellation and allows other tasks to be scheduled, without otherwise blocking.</source>
          <target state="translated">Esto comprueba la cancelación y permite programar otras tareas,sin bloquearlas de otra manera.</target>
        </trans-unit>
        <trans-unit id="7eb8be825f964eeec308b47905ab5876d9c3514c" translate="yes" xml:space="preserve">
          <source>This class &lt;a href=&quot;https://en.wikipedia.org/wiki/Staple_(fastener)&quot;&gt;staples&lt;/a&gt; together two unidirectional streams to make single bidirectional stream.</source>
          <target state="translated">Esta clase &lt;a href=&quot;https://en.wikipedia.org/wiki/Staple_(fastener)&quot;&gt;grapa&lt;/a&gt; dos flujos unidireccionales para crear un flujo bidireccional &amp;uacute;nico.</target>
        </trans-unit>
        <trans-unit id="c56797f75d6a67218039122490ded779850a16ba" translate="yes" xml:space="preserve">
          <source>This class distinguishes between &amp;ldquo;graceful&amp;rdquo; closes, which may perform I/O and thus block, and a &amp;ldquo;forceful&amp;rdquo; close, which cannot. For example, cleanly shutting down a TLS-encrypted connection requires sending a &amp;ldquo;goodbye&amp;rdquo; message; but if a peer has become non-responsive, then sending this message might block forever, so we may want to just drop the connection instead. Therefore the &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt; method is unusual in that it should always close the connection (or at least make its best attempt) &lt;em&gt;even if it fails&lt;/em&gt;; failure indicates a failure to achieve grace, not a failure to close the connection.</source>
          <target state="translated">Esta clase distingue entre cierres &quot;agraciados&quot;, que pueden realizar E / S y, por lo tanto, bloquear, y un cierre &quot;forzado&quot;, que no puede. Por ejemplo, cerrar limpiamente una conexi&amp;oacute;n cifrada con TLS requiere enviar un mensaje de &quot;adi&amp;oacute;s&quot;; pero si un par no responde, el env&amp;iacute;o de este mensaje podr&amp;iacute;a bloquearse para siempre, por lo que es posible que queramos simplemente desconectar la conexi&amp;oacute;n. Por lo tanto, el m&amp;eacute;todo &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt; es inusual porque siempre debe cerrar la conexi&amp;oacute;n (o al menos hacer su mejor intento) &lt;em&gt;incluso si falla&lt;/em&gt; ; falla indica una falla para lograr la gracia, no una falla para cerrar la conexi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="28b26ebbffbe7117ea41ae0633d49c552b9155ec" translate="yes" xml:space="preserve">
          <source>This class encapsulates the tricky parts of implementing a wait queue. It&amp;rsquo;s useful for implementing higher-level synchronization primitives like queues and locks.</source>
          <target state="translated">Esta clase encapsula las partes complicadas de implementar una cola de espera. Es &amp;uacute;til para implementar primitivas de sincronizaci&amp;oacute;n de nivel superior como colas y bloqueos.</target>
        </trans-unit>
        <trans-unit id="1a47671d4bf70755645824b64fbe8633bf09f6fa" translate="yes" xml:space="preserve">
          <source>This class has no public constructor. To create a child process, use &lt;a href=&quot;#trio.open_process&quot;&gt;&lt;code&gt;open_process&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Esta clase no tiene ning&amp;uacute;n constructor p&amp;uacute;blico. Para crear un proceso hijo, use &lt;a href=&quot;#trio.open_process&quot;&gt; &lt;code&gt;open_process&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="b99db4b97b98beb51fb24c58219ced2d6f0fd5ff" translate="yes" xml:space="preserve">
          <source>This code will wait 5 seconds (for the child task to finish), and then return.</source>
          <target state="translated">Este código esperará 5 segundos (para que la tarea infantil termine),y luego regresará.</target>
        </trans-unit>
        <trans-unit id="939dd3d2d8145547e7e234d0c5f0527ad4c5c738" translate="yes" xml:space="preserve">
          <source>This dequeues &lt;code&gt;count&lt;/code&gt; tasks from one lot, and requeues them on another, preserving order. For example:</source>
          <target state="translated">Esto quita las tareas de &lt;code&gt;count&lt;/code&gt; de un lote y las coloca en otro, preservando el orden. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="c3364e26d8c76183c9b91166e249f70c062374ec" translate="yes" xml:space="preserve">
          <source>This doesn&amp;rsquo;t actually close the object &amp;ndash; you still have to do that yourself afterwards.</source>
          <target state="translated">En realidad, esto no cierra el objeto; a&amp;uacute;n debe hacerlo usted mismo despu&amp;eacute;s.</target>
        </trans-unit>
        <trans-unit id="c88cc97aad07bb8c29d3828aa64cf1f0210e8c2d" translate="yes" xml:space="preserve">
          <source>This doesn&amp;rsquo;t actually close the object &amp;ndash; you still have to do that yourself afterwards. Also, you want to be careful to make sure no new tasks start waiting on the object in between when you call this and when it&amp;rsquo;s actually closed. So to close something properly, you usually want to do these steps in order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bb2af13b8495755c9cccc1579f4a71609bc843d" translate="yes" xml:space="preserve">
          <source>This example demonstrates using the &lt;a href=&quot;#trio.MemorySendChannel.clone&quot;&gt;&lt;code&gt;MemorySendChannel.clone&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.MemoryReceiveChannel.clone&quot;&gt;&lt;code&gt;MemoryReceiveChannel.clone&lt;/code&gt;&lt;/a&gt; methods. What these do is create copies of our endpoints, that act just like the original &amp;ndash; except that they can be closed independently. And the underlying channel is only closed after &lt;em&gt;all&lt;/em&gt; the clones have been closed. So this completely solves our problem with shutdown, and if you run this program, you&amp;rsquo;ll see it print its six lines of output and then exits cleanly.</source>
          <target state="translated">Este ejemplo demuestra el uso de los m&amp;eacute;todos &lt;a href=&quot;#trio.MemorySendChannel.clone&quot;&gt; &lt;code&gt;MemorySendChannel.clone&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#trio.MemoryReceiveChannel.clone&quot;&gt; &lt;code&gt;MemoryReceiveChannel.clone&lt;/code&gt; &lt;/a&gt; . Lo que hacen es crear copias de nuestros puntos finales, que act&amp;uacute;an como el original, excepto que pueden cerrarse de forma independiente. Y el canal subyacente solo se cierra despu&amp;eacute;s de que se hayan cerrado &lt;em&gt;todos&lt;/em&gt; los clones. Entonces, esto resuelve completamente nuestro problema con el apagado, y si ejecuta este programa, ver&amp;aacute; que imprime sus seis l&amp;iacute;neas de salida y luego sale limpiamente.</target>
        </trans-unit>
        <trans-unit id="0831f123255408a3d50729ed611cfa78fde0d9f6" translate="yes" xml:space="preserve">
          <source>This exception&amp;rsquo;s &lt;code&gt;__cause__&lt;/code&gt; attribute will often contain more information about the underlying error.</source>
          <target state="translated">El atributo &lt;code&gt;__cause__&lt;/code&gt; de esta excepci&amp;oacute;n a menudo contendr&amp;aacute; m&amp;aacute;s informaci&amp;oacute;n sobre el error subyacente.</target>
        </trans-unit>
        <trans-unit id="4ec4163ea949b45f4f411608a69251c1e624bfb0" translate="yes" xml:space="preserve">
          <source>This function allows you to replace Trio&amp;rsquo;s normal socket class with a custom class. This is very useful for testing, and probably a bad idea in any other circumstance. See &lt;a href=&quot;#trio.abc.HostnameResolver&quot;&gt;&lt;code&gt;trio.abc.HostnameResolver&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">Esta funci&amp;oacute;n le permite reemplazar la clase de socket normal de Trio con una clase personalizada. Esto es muy &amp;uacute;til para realizar pruebas y probablemente una mala idea en cualquier otra circunstancia. Consulte &lt;a href=&quot;#trio.abc.HostnameResolver&quot;&gt; &lt;code&gt;trio.abc.HostnameResolver&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="8b80bf44f477a63401ffe0a86ba46937966ca016" translate="yes" xml:space="preserve">
          <source>This function and &lt;a href=&quot;#trio.move_on_after&quot;&gt;&lt;code&gt;move_on_after()&lt;/code&gt;&lt;/a&gt; are similar in that both create a cancel scope with a given timeout, and if the timeout expires then both will cause &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; to be raised within the scope. The difference is that when the &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception reaches &lt;a href=&quot;#trio.move_on_after&quot;&gt;&lt;code&gt;move_on_after()&lt;/code&gt;&lt;/a&gt;, it&amp;rsquo;s caught and discarded. When it reaches &lt;a href=&quot;#trio.fail_after&quot;&gt;&lt;code&gt;fail_after()&lt;/code&gt;&lt;/a&gt;, then it&amp;rsquo;s caught and &lt;a href=&quot;#trio.TooSlowError&quot;&gt;&lt;code&gt;TooSlowError&lt;/code&gt;&lt;/a&gt; is raised in its place.</source>
          <target state="translated">Esta funci&amp;oacute;n y &lt;a href=&quot;#trio.move_on_after&quot;&gt; &lt;code&gt;move_on_after()&lt;/code&gt; &lt;/a&gt; son similares en que ambas crean un alcance de cancelaci&amp;oacute;n con un tiempo de espera dado, y si el tiempo de espera expira, ambos har&amp;aacute;n que &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; se genere dentro del alcance. La diferencia es que cuando la excepci&amp;oacute;n &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; llega a &lt;a href=&quot;#trio.move_on_after&quot;&gt; &lt;code&gt;move_on_after()&lt;/code&gt; &lt;/a&gt; , se detecta y se descarta. Cuando llega a &lt;a href=&quot;#trio.fail_after&quot;&gt; &lt;code&gt;fail_after()&lt;/code&gt; &lt;/a&gt; , se &lt;a href=&quot;#trio.TooSlowError&quot;&gt; &lt;code&gt;TooSlowError&lt;/code&gt; &lt;/a&gt; y se genera TooSlowError en su lugar.</target>
        </trans-unit>
        <trans-unit id="6472cab9cb21c974030fc674c30dfd25631ba087" translate="yes" xml:space="preserve">
          <source>This function and &lt;a href=&quot;#trio.move_on_at&quot;&gt;&lt;code&gt;move_on_at()&lt;/code&gt;&lt;/a&gt; are similar in that both create a cancel scope with a given absolute deadline, and if the deadline expires then both will cause &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; to be raised within the scope. The difference is that when the &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception reaches &lt;a href=&quot;#trio.move_on_at&quot;&gt;&lt;code&gt;move_on_at()&lt;/code&gt;&lt;/a&gt;, it&amp;rsquo;s caught and discarded. When it reaches &lt;a href=&quot;#trio.fail_at&quot;&gt;&lt;code&gt;fail_at()&lt;/code&gt;&lt;/a&gt;, then it&amp;rsquo;s caught and &lt;a href=&quot;#trio.TooSlowError&quot;&gt;&lt;code&gt;TooSlowError&lt;/code&gt;&lt;/a&gt; is raised in its place.</source>
          <target state="translated">Esta funci&amp;oacute;n y &lt;a href=&quot;#trio.move_on_at&quot;&gt; &lt;code&gt;move_on_at()&lt;/code&gt; &lt;/a&gt; son similares en que ambas crean un alcance de cancelaci&amp;oacute;n con una fecha l&amp;iacute;mite absoluta dada, y si la fecha l&amp;iacute;mite expira, ambas causar&amp;aacute;n que &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; se plantee dentro del alcance. La diferencia es que cuando la excepci&amp;oacute;n &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; llega a &lt;a href=&quot;#trio.move_on_at&quot;&gt; &lt;code&gt;move_on_at()&lt;/code&gt; &lt;/a&gt; , se detecta y se descarta. Cuando llega a &lt;a href=&quot;#trio.fail_at&quot;&gt; &lt;code&gt;fail_at()&lt;/code&gt; &lt;/a&gt; , se &lt;a href=&quot;#trio.TooSlowError&quot;&gt; &lt;code&gt;TooSlowError&lt;/code&gt; &lt;/a&gt; y se genera TooSlowError en su lugar.</target>
        </trans-unit>
        <trans-unit id="beee03279b501d21ddabbf8f6de51961869f2389" translate="yes" xml:space="preserve">
          <source>This function does not perform the TLS handshake; you can do it manually by calling &lt;a href=&quot;#trio.SSLStream.do_handshake&quot;&gt;&lt;code&gt;do_handshake()&lt;/code&gt;&lt;/a&gt;, or else it will be performed automatically the first time you send or receive data.</source>
          <target state="translated">Esta funci&amp;oacute;n no realiza el protocolo de enlace TLS; puede hacerlo manualmente llamando a &lt;a href=&quot;#trio.SSLStream.do_handshake&quot;&gt; &lt;code&gt;do_handshake()&lt;/code&gt; &lt;/a&gt; , o de lo contrario se realizar&amp;aacute; autom&amp;aacute;ticamente la primera vez que env&amp;iacute;e o reciba datos.</target>
        </trans-unit>
        <trans-unit id="8b5f591859ac15e7667f269bbd87655ee356a2a3" translate="yes" xml:space="preserve">
          <source>This function examines all the cancellation scopes that are currently in effect (taking into account shielding), and returns the deadline that will expire first.</source>
          <target state="translated">Esta función examina todos los alcances de la cancelación que están actualmente en vigor (teniendo en cuenta el blindaje),y devuelve el plazo que expirará primero.</target>
        </trans-unit>
        <trans-unit id="781b6ba4e14238d28d4905a86d639a4f2fb4d4f6" translate="yes" xml:space="preserve">
          <source>This function never returns unless cancelled.</source>
          <target state="translated">Esta función nunca regresa a menos que se cancele.</target>
        </trans-unit>
        <trans-unit id="10fb6ede8900e518012239a45fc9a8e96195f7a8" translate="yes" xml:space="preserve">
          <source>This function only returns when cancelled.</source>
          <target state="translated">Esta función sólo vuelve cuando se cancela.</target>
        </trans-unit>
        <trans-unit id="a6ba5420ed39805adc1f6e88511ac0ce00ec14a9" translate="yes" xml:space="preserve">
          <source>This function strikes a balance between these two extremes: it works its way through the available addresses one at a time, like the first approach; but, if &lt;code&gt;happy_eyeballs_delay&lt;/code&gt; seconds have passed and it&amp;rsquo;s still waiting for an attempt to succeed or fail, then it gets impatient and starts the next connection attempt in parallel. As soon as any one connection attempt succeeds, all the other attempts are cancelled. This avoids unnecessary load because most connections will succeed after just one or two attempts, but if one of the addresses is unreachable then it doesn&amp;rsquo;t slow us down too much.</source>
          <target state="translated">Esta funci&amp;oacute;n logra un equilibrio entre estos dos extremos: se abre camino a trav&amp;eacute;s de las direcciones disponibles una a la vez, como el primer enfoque; pero, si los segundos de &lt;code&gt;happy_eyeballs_delay&lt;/code&gt; han pasado y todav&amp;iacute;a est&amp;aacute; esperando un intento de tener &amp;eacute;xito o fallar, entonces se impacienta y comienza el siguiente intento de conexi&amp;oacute;n en paralelo. Tan pronto como un intento de conexi&amp;oacute;n tenga &amp;eacute;xito, todos los dem&amp;aacute;s intentos se cancelar&amp;aacute;n. Esto evita una carga innecesaria porque la mayor&amp;iacute;a de las conexiones se realizar&amp;aacute;n correctamente despu&amp;eacute;s de uno o dos intentos, pero si una de las direcciones es inalcanzable, no nos ralentiza demasiado.</target>
        </trans-unit>
        <trans-unit id="2b428d2d2fedd87ac134d2d677f1ec40b12e6074" translate="yes" xml:space="preserve">
          <source>This function tests a &lt;em&gt;superset&lt;/em&gt; of what &lt;a href=&quot;#trio.testing.check_one_way_stream&quot;&gt;&lt;code&gt;check_one_way_stream()&lt;/code&gt;&lt;/a&gt; checks &amp;ndash; if you call this, then you don&amp;rsquo;t need to also call &lt;a href=&quot;#trio.testing.check_one_way_stream&quot;&gt;&lt;code&gt;check_one_way_stream()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n prueba un &lt;em&gt;superconjunto&lt;/em&gt; de lo que &lt;a href=&quot;#trio.testing.check_one_way_stream&quot;&gt; &lt;code&gt;check_one_way_stream()&lt;/code&gt; &lt;/a&gt; ; si llama a esto, no necesita llamar tambi&amp;eacute;n &lt;a href=&quot;#trio.testing.check_one_way_stream&quot;&gt; &lt;code&gt;check_one_way_stream()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c237272caa2b06d6e435d70b44aba945c42ded67" translate="yes" xml:space="preserve">
          <source>This function tests a &lt;em&gt;superset&lt;/em&gt; of what &lt;a href=&quot;#trio.testing.check_two_way_stream&quot;&gt;&lt;code&gt;check_two_way_stream()&lt;/code&gt;&lt;/a&gt; checks &amp;ndash; if you call this, then you don&amp;rsquo;t need to also call &lt;a href=&quot;#trio.testing.check_two_way_stream&quot;&gt;&lt;code&gt;check_two_way_stream()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n prueba un &lt;em&gt;superconjunto&lt;/em&gt; de lo que &lt;a href=&quot;#trio.testing.check_two_way_stream&quot;&gt; &lt;code&gt;check_two_way_stream()&lt;/code&gt; &lt;/a&gt; ; si llama a esto, no necesita llamar tambi&amp;eacute;n &lt;a href=&quot;#trio.testing.check_two_way_stream&quot;&gt; &lt;code&gt;check_two_way_stream()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3025b1032710d54ab53e19541456e1cb5086dfdb" translate="yes" xml:space="preserve">
          <source>This function&amp;rsquo;s behavior can be customized using &lt;a href=&quot;reference-testing#trio.socket.set_custom_hostname_resolver&quot;&gt;&lt;code&gt;set_custom_hostname_resolver()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El comportamiento de esta funci&amp;oacute;n se puede personalizar usando &lt;a href=&quot;reference-testing#trio.socket.set_custom_hostname_resolver&quot;&gt; &lt;code&gt;set_custom_hostname_resolver()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a99381ddd18455f137e888e7ce19ef7b02a6d411" translate="yes" xml:space="preserve">
          <source>This function&amp;rsquo;s behavior can be customized using &lt;a href=&quot;reference-testing#trio.socket.set_custom_socket_factory&quot;&gt;&lt;code&gt;set_custom_socket_factory()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El comportamiento de esta funci&amp;oacute;n se puede personalizar usando &lt;a href=&quot;reference-testing#trio.socket.set_custom_socket_factory&quot;&gt; &lt;code&gt;set_custom_socket_factory()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dfd660c37b7b448e29f5ca35f71daff1e3c7a98e" translate="yes" xml:space="preserve">
          <source>This includes async iterators: If you write &lt;code&gt;async for ... in &amp;lt;a
trio object&amp;gt;&lt;/code&gt;, then there will be at least one checkpoint before each iteration of the loop and one checkpoint after the last iteration.</source>
          <target state="translated">Esto incluye iteradores as&amp;iacute;ncronos: si escribe &lt;code&gt;async for ... in &amp;lt;a trio object&amp;gt;&lt;/code&gt; , habr&amp;aacute; al menos un punto de control antes de cada iteraci&amp;oacute;n del bucle y un punto de control despu&amp;eacute;s de la &amp;uacute;ltima iteraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="64fdf77f2a6948dcd1d3f395907ba3bd1b417d06" translate="yes" xml:space="preserve">
          <source>This interface extends &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; to also allow closing the send part of the stream without closing the receive part.</source>
          <target state="translated">Esta interfaz extiende &lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; para permitir tambi&amp;eacute;n cerrar la parte de env&amp;iacute;o de la secuencia sin cerrar la parte de recepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="783f9168f3a0ecf9fcc0bad0241f594953ed1653" translate="yes" xml:space="preserve">
          <source>This is &lt;em&gt;not&lt;/em&gt; a &lt;a href=&quot;reference-core#checkpoints&quot;&gt;checkpoint&lt;/a&gt;, but it is half of a checkpoint, and when combined with &lt;a href=&quot;#trio.hazmat.checkpoint_if_cancelled&quot;&gt;&lt;code&gt;checkpoint_if_cancelled()&lt;/code&gt;&lt;/a&gt; it can make a full checkpoint.</source>
          <target state="translated">Este &lt;em&gt;no&lt;/em&gt; es un &lt;a href=&quot;reference-core#checkpoints&quot;&gt;punto de control&lt;/a&gt; , pero es la mitad de un punto de control, y cuando se combina con &lt;a href=&quot;#trio.hazmat.checkpoint_if_cancelled&quot;&gt; &lt;code&gt;checkpoint_if_cancelled()&lt;/code&gt; &lt;/a&gt; puede convertirse en un punto de control completo.</target>
        </trans-unit>
        <trans-unit id="a7b92fb56091be7d8067dff05517fcf3b9f38f41" translate="yes" xml:space="preserve">
          <source>This is &lt;em&gt;not&lt;/em&gt; a &lt;a href=&quot;reference-core#checkpoints&quot;&gt;checkpoint&lt;/a&gt;, but it is half of a checkpoint, and when combined with &lt;a href=&quot;#trio.lowlevel.checkpoint_if_cancelled&quot;&gt;&lt;code&gt;checkpoint_if_cancelled()&lt;/code&gt;&lt;/a&gt; it can make a full checkpoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bfe1cdd96a28a6a95c12558fd209d1ae8e3ceb2" translate="yes" xml:space="preserve">
          <source>This is Trio&amp;rsquo;s main entry point. Almost every other function in Trio requires that you be inside a call to &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Este es el principal punto de entrada de Trio. Casi todas las dem&amp;aacute;s funciones de Trio requieren que est&amp;eacute; dentro de una llamada a &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a87c3526175efef10c92dec2e7c2b1e115230ab1" translate="yes" xml:space="preserve">
          <source>This is a convenience function that creates two one-way streams using &lt;a href=&quot;#trio.testing.lockstep_stream_one_way_pair&quot;&gt;&lt;code&gt;lockstep_stream_one_way_pair()&lt;/code&gt;&lt;/a&gt;, and then uses &lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt;&lt;code&gt;StapledStream&lt;/code&gt;&lt;/a&gt; to combine them into a single bidirectional stream.</source>
          <target state="translated">Esta es una funci&amp;oacute;n de conveniencia que crea dos flujos &lt;a href=&quot;#trio.testing.lockstep_stream_one_way_pair&quot;&gt; &lt;code&gt;lockstep_stream_one_way_pair()&lt;/code&gt; &lt;/a&gt; usando lockstep_stream_one_way_pair () , y luego usa &lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt; &lt;code&gt;StapledStream&lt;/code&gt; &lt;/a&gt; para combinarlos en un solo flujo bidireccional.</target>
        </trans-unit>
        <trans-unit id="143d075fb0db14d63e601395486d506d13fd2bb0" translate="yes" xml:space="preserve">
          <source>This is a convenience function that creates two one-way streams using &lt;a href=&quot;#trio.testing.memory_stream_one_way_pair&quot;&gt;&lt;code&gt;memory_stream_one_way_pair()&lt;/code&gt;&lt;/a&gt;, and then uses &lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt;&lt;code&gt;StapledStream&lt;/code&gt;&lt;/a&gt; to combine them into a single bidirectional stream.</source>
          <target state="translated">Esta es una funci&amp;oacute;n de conveniencia que crea dos flujos &lt;a href=&quot;#trio.testing.memory_stream_one_way_pair&quot;&gt; &lt;code&gt;memory_stream_one_way_pair()&lt;/code&gt; &lt;/a&gt; usando memory_stream_one_way_pair () , y luego usa &lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt; &lt;code&gt;StapledStream&lt;/code&gt; &lt;/a&gt; para combinarlos en un solo flujo bidireccional.</target>
        </trans-unit>
        <trans-unit id="75e832f6645c15527d0b0ace9c7c9f19af69e7f7" translate="yes" xml:space="preserve">
          <source>This is a convenience wrapper that calls &lt;a href=&quot;#trio.open_tcp_stream&quot;&gt;&lt;code&gt;open_tcp_stream()&lt;/code&gt;&lt;/a&gt; and wraps the result in an &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Este es un contenedor de conveniencia que llama a &lt;a href=&quot;#trio.open_tcp_stream&quot;&gt; &lt;code&gt;open_tcp_stream()&lt;/code&gt; &lt;/a&gt; y envuelve el resultado en un &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="31ccdd36d0e3b96050da7e039b26a2619a4c6283" translate="yes" xml:space="preserve">
          <source>This is a list, with outer nurseries before inner nurseries.</source>
          <target state="translated">Esta es una lista,con los viveros exteriores antes que los interiores.</target>
        </trans-unit>
        <trans-unit id="d572fc6e96f0524557106f4e6d07ef30f53dc792" translate="yes" xml:space="preserve">
          <source>This is a low-level, no-frills interface, very similar to using &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Thread&quot;&gt;&lt;code&gt;threading.Thread&lt;/code&gt;&lt;/a&gt; to spawn a thread directly. The main difference is that this function tries to re-use threads when possible, so it can be a bit faster than &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Thread&quot;&gt;&lt;code&gt;threading.Thread&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfdb480b2d02dfcb7a4dd0f62ee4c91790556e33" translate="yes" xml:space="preserve">
          <source>This is a non-reentrant, single-owner lock. Unlike &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Lock&quot;&gt;&lt;code&gt;threading.Lock&lt;/code&gt;&lt;/a&gt;, only the owner of the lock is allowed to release it.</source>
          <target state="translated">Se trata de una cerradura no reentrada de un solo propietario. A diferencia de &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Lock&quot;&gt; &lt;code&gt;threading.Lock&lt;/code&gt; &lt;/a&gt; , solo el propietario del candado puede liberarlo.</target>
        </trans-unit>
        <trans-unit id="c3439e00fa8a3c024670687cffe82162907494a8" translate="yes" xml:space="preserve">
          <source>This is a thin convenience wrapper around &lt;a href=&quot;#trio.open_ssl_over_tcp_listeners&quot;&gt;&lt;code&gt;open_ssl_over_tcp_listeners()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.serve_listeners&quot;&gt;&lt;code&gt;serve_listeners()&lt;/code&gt;&lt;/a&gt; &amp;ndash; see them for full details.</source>
          <target state="translated">Esta es una envoltura delgada y conveniente sobre &lt;a href=&quot;#trio.open_ssl_over_tcp_listeners&quot;&gt; &lt;code&gt;open_ssl_over_tcp_listeners()&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#trio.serve_listeners&quot;&gt; &lt;code&gt;serve_listeners()&lt;/code&gt; &lt;/a&gt; ; v&amp;eacute;alos para obtener todos los detalles.</target>
        </trans-unit>
        <trans-unit id="8686484a6ca97f02cdc1ea23ba90f658a805236b" translate="yes" xml:space="preserve">
          <source>This is a thin convenience wrapper around &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt;&lt;code&gt;open_tcp_listeners()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.serve_listeners&quot;&gt;&lt;code&gt;serve_listeners()&lt;/code&gt;&lt;/a&gt; &amp;ndash; see them for full details.</source>
          <target state="translated">Este es un envoltorio delgado y conveniente sobre &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt; &lt;code&gt;open_tcp_listeners()&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#trio.serve_listeners&quot;&gt; &lt;code&gt;serve_listeners()&lt;/code&gt; &lt;/a&gt; ; v&amp;eacute;alos para obtener todos los detalles.</target>
        </trans-unit>
        <trans-unit id="6a21f0dfe9782d121688f4156eec97c0b785ae6a" translate="yes" xml:space="preserve">
          <source>This is a tricky interface with no guard rails. If you can use &lt;a href=&quot;#trio.hazmat.ParkingLot&quot;&gt;&lt;code&gt;ParkingLot&lt;/code&gt;&lt;/a&gt; or the built-in I/O wait functions instead, then you should.</source>
          <target state="translated">Esta es una interfaz complicada sin barandillas. Si puede utilizar &lt;a href=&quot;#trio.hazmat.ParkingLot&quot;&gt; &lt;code&gt;ParkingLot&lt;/code&gt; &lt;/a&gt; o las funciones de espera de E / S integradas en su lugar, deber&amp;iacute;a hacerlo.</target>
        </trans-unit>
        <trans-unit id="ed9a8864392dee8dccae92408c25c2bcaab6e1a2" translate="yes" xml:space="preserve">
          <source>This is a tricky interface with no guard rails. If you can use &lt;a href=&quot;#trio.lowlevel.ParkingLot&quot;&gt;&lt;code&gt;ParkingLot&lt;/code&gt;&lt;/a&gt; or the built-in I/O wait functions instead, then you should.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62916f9abf44ea5131fbba3fd3fa67633fc06333" translate="yes" xml:space="preserve">
          <source>This is an async method that returns a synchronous iterator, so you use it like:</source>
          <target state="translated">Este es un método de sincronización que devuelve un iterador síncrono,así que lo usas como:</target>
        </trans-unit>
        <trans-unit id="5ef14ee7f5ae379eed9b811cf4383e8fbde52f11" translate="yes" xml:space="preserve">
          <source>This is analogous to an &amp;ldquo;end-of-file&amp;rdquo; condition, but for channels.</source>
          <target state="translated">Esto es an&amp;aacute;logo a una condici&amp;oacute;n de &quot;fin de archivo&quot;, pero para canales.</target>
        </trans-unit>
        <trans-unit id="eca5f551bc86a3707933e82043f223ee98935da8" translate="yes" xml:space="preserve">
          <source>This is called before we enter a system-specific wait function like &lt;a href=&quot;https://docs.python.org/3/library/select.html#select.select&quot;&gt;&lt;code&gt;select.select()&lt;/code&gt;&lt;/a&gt;, to get the timeout to pass.</source>
          <target state="translated">Esto se llama antes de ingresar una funci&amp;oacute;n de espera espec&amp;iacute;fica del sistema como &lt;a href=&quot;https://docs.python.org/3/library/select.html#select.select&quot;&gt; &lt;code&gt;select.select()&lt;/code&gt; &lt;/a&gt; , para que pase el tiempo de espera.</target>
        </trans-unit>
        <trans-unit id="b9eb6bfd2cfcdb8186ae558d2b498a13bca7a88f" translate="yes" xml:space="preserve">
          <source>This is cumbersome, but Python unfortunately doesn&amp;rsquo;t provide any other reliable options. If you use &lt;code&gt;aclosing()&lt;/code&gt;, then your generator&amp;rsquo;s cleanup code executes in the same context as the rest of its iterations, so timeouts, exceptions, and context variables work like you&amp;rsquo;d expect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c33a989e11aa76213cba8f2726e3fb28d36a356c" translate="yes" xml:space="preserve">
          <source>This is determined on a function-by-function basis. By default, a function is protected if its caller is, and not if its caller isn&amp;rsquo;t; this is helpful because it means you only need to override the defaults at places where you transition from protected code to unprotected code or vice-versa.</source>
          <target state="translated">Esto se determina funci&amp;oacute;n por funci&amp;oacute;n. De forma predeterminada, una funci&amp;oacute;n est&amp;aacute; protegida si su llamador lo est&amp;aacute; y no si su llamador no lo est&amp;aacute;; esto es &amp;uacute;til porque significa que solo necesita anular los valores predeterminados en los lugares donde hace la transici&amp;oacute;n de c&amp;oacute;digo protegido a c&amp;oacute;digo no protegido o viceversa.</target>
        </trans-unit>
        <trans-unit id="c56832a8eb6199cd3a4282e1874615668cbaa576" translate="yes" xml:space="preserve">
          <source>This is determined on a function-by-function basis. By default:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59d307411d32a6c006290f810ba88a7b617a32e3" translate="yes" xml:space="preserve">
          <source>This is either a no-op, or else it allow other tasks to be scheduled and then raises &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt;&lt;code&gt;trio.Cancelled&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esto es una &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt; &lt;code&gt;trio.Cancelled&lt;/code&gt; &lt;/a&gt; o permite programar otras tareas y luego aumenta el tr&amp;iacute;o .</target>
        </trans-unit>
        <trans-unit id="918fd503d30c70a4012dae526127fcf2c3cdd726" translate="yes" xml:space="preserve">
          <source>This is equivalent to calling &lt;a href=&quot;#trio.abc.ReceiveChannel.receive&quot;&gt;&lt;code&gt;receive()&lt;/code&gt;&lt;/a&gt; repeatedly. The loop exits without error when &lt;a href=&quot;#trio.abc.ReceiveChannel.receive&quot;&gt;&lt;code&gt;receive&lt;/code&gt;&lt;/a&gt; raises &lt;a href=&quot;reference-core#trio.EndOfChannel&quot;&gt;&lt;code&gt;EndOfChannel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esto es equivalente a llamar a &lt;a href=&quot;#trio.abc.ReceiveChannel.receive&quot;&gt; &lt;code&gt;receive()&lt;/code&gt; &lt;/a&gt; repetidamente. El bucle sale sin errores cuando la &lt;a href=&quot;#trio.abc.ReceiveChannel.receive&quot;&gt; &lt;code&gt;receive&lt;/code&gt; &lt;/a&gt; genera &lt;a href=&quot;reference-core#trio.EndOfChannel&quot;&gt; &lt;code&gt;EndOfChannel&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c5df3299548e7f24b6f4916386efc3494b1e0848" translate="yes" xml:space="preserve">
          <source>This is known as a &amp;ldquo;happy eyeballs&amp;rdquo; algorithm, and our particular variant is modelled after how Chrome connects to webservers; see &lt;a href=&quot;https://tools.ietf.org/html/rfc6555&quot;&gt;RFC 6555&lt;/a&gt; for more details.</source>
          <target state="translated">Esto se conoce como un algoritmo de &quot;globos oculares felices&quot;, y nuestra variante particular se basa en c&amp;oacute;mo Chrome se conecta a los servidores web; consulte &lt;a href=&quot;https://tools.ietf.org/html/rfc6555&quot;&gt;RFC 6555&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="4379e3a65b564c2c817949c6184653445cc5dfc6" translate="yes" xml:space="preserve">
          <source>This is like a no-operating-system-involved, Trio-streamsified version of &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socketpair&quot;&gt;&lt;code&gt;socket.socketpair()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esto es como una versi&amp;oacute;n trio- &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socketpair&quot;&gt; &lt;code&gt;socket.socketpair()&lt;/code&gt; &lt;/a&gt; sin sistema operativo involucrado de socket.socketpair () .</target>
        </trans-unit>
        <trans-unit id="ed8cb82fa76f8afdd017893fe6d82e0c370e3598" translate="yes" xml:space="preserve">
          <source>This is particularly useful in tests when you want to let a server pick its own port, and then connect to it:</source>
          <target state="translated">Esto es particularmente útil en las pruebas cuando se quiere dejar que un servidor escoja su propio puerto,y luego conectarse a él:</target>
        </trans-unit>
        <trans-unit id="b8d5871cda022acd530d3a2e7015027417917478" translate="yes" xml:space="preserve">
          <source>This is safe to call from the main thread, from other threads, and from signal handlers. This is the fundamental primitive used to re-enter the Trio run loop from outside of it.</source>
          <target state="translated">Es seguro llamar desde el hilo principal,desde otros hilos y desde los manejadores de señales.Esta es la primitiva fundamental utilizada para volver a entrar en el bucle de recorrido del Trío desde fuera de él.</target>
        </trans-unit>
        <trans-unit id="f1224a9af924c885f91aebaa013636dda44b62ae" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#trio.testing.check_one_way_stream&quot;&gt;&lt;code&gt;check_one_way_stream()&lt;/code&gt;&lt;/a&gt;, except that the maker functions are expected to return objects implementing the &lt;a href=&quot;reference-io#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">Esto es similar a &lt;a href=&quot;#trio.testing.check_one_way_stream&quot;&gt; &lt;code&gt;check_one_way_stream()&lt;/code&gt; &lt;/a&gt; , excepto que se espera que las funciones del fabricante devuelvan objetos que implementan la interfaz &lt;a href=&quot;reference-io#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="03be5a68c53f7c102fa36f575fc1926e2be7101e" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#trio.testing.check_two_way_stream&quot;&gt;&lt;code&gt;check_two_way_stream()&lt;/code&gt;&lt;/a&gt;, except that the maker functions are expected to return objects that implement the &lt;a href=&quot;reference-io#trio.abc.HalfCloseableStream&quot;&gt;&lt;code&gt;HalfCloseableStream&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">Esto es similar a &lt;a href=&quot;#trio.testing.check_two_way_stream&quot;&gt; &lt;code&gt;check_two_way_stream()&lt;/code&gt; &lt;/a&gt; , excepto que se espera que las funciones del fabricante devuelvan objetos que implementan la interfaz &lt;a href=&quot;reference-io#trio.abc.HalfCloseableStream&quot;&gt; &lt;code&gt;HalfCloseableStream&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43eba094a9b0b6fd7d9cb8d6b304c98507fbc7ae" translate="yes" xml:space="preserve">
          <source>This is the lowest-level API for blocking in Trio. Every time a &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; blocks, it does so by calling this function (usually indirectly via some higher-level API).</source>
          <target state="translated">Esta es la API de nivel m&amp;aacute;s bajo para bloquear en Trio. Cada vez que una &lt;a href=&quot;#trio.hazmat.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; bloquea, lo hace llamando a esta funci&amp;oacute;n (normalmente de forma indirecta a trav&amp;eacute;s de alguna API de nivel superior).</target>
        </trans-unit>
        <trans-unit id="477341b23362ad59adc031dfb5e5a613e3001da6" translate="yes" xml:space="preserve">
          <source>This is the lowest-level API for blocking in Trio. Every time a &lt;a href=&quot;#trio.lowlevel.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; blocks, it does so by calling this function (usually indirectly via some higher-level API).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea4acecf4fbb18913e774bb995c238217d6a1937" translate="yes" xml:space="preserve">
          <source>This is the task that is the ultimate parent of all other tasks.</source>
          <target state="translated">Esta es la tarea que es el padre último de todas las demás tareas.</target>
        </trans-unit>
        <trans-unit id="a22ac9eb1bb7bf57231034370b737046cb61f388" translate="yes" xml:space="preserve">
          <source>This is used to implement &lt;a href=&quot;#trio.testing.memory_stream_one_way_pair&quot;&gt;&lt;code&gt;memory_stream_one_way_pair()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.testing.memory_stream_pair&quot;&gt;&lt;code&gt;memory_stream_pair()&lt;/code&gt;&lt;/a&gt;; see the latter&amp;rsquo;s docstring for an example of how you might use it yourself.</source>
          <target state="translated">Esto se usa para implementar &lt;a href=&quot;#trio.testing.memory_stream_one_way_pair&quot;&gt; &lt;code&gt;memory_stream_one_way_pair()&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#trio.testing.memory_stream_pair&quot;&gt; &lt;code&gt;memory_stream_pair()&lt;/code&gt; &lt;/a&gt; ; consulte la cadena de documentaci&amp;oacute;n de este &amp;uacute;ltimo para ver un ejemplo de c&amp;oacute;mo podr&amp;iacute;a usarlo usted mismo.</target>
        </trans-unit>
        <trans-unit id="f48dde0527c8494ca2e28a4cd0989758ecebeabd" translate="yes" xml:space="preserve">
          <source>This is used to implement functions like &lt;a href=&quot;#trio.current_time&quot;&gt;&lt;code&gt;trio.current_time()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.move_on_after&quot;&gt;&lt;code&gt;trio.move_on_after()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esto se usa para implementar funciones como &lt;a href=&quot;#trio.current_time&quot;&gt; &lt;code&gt;trio.current_time()&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#trio.move_on_after&quot;&gt; &lt;code&gt;trio.move_on_after()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="73a3bbd0c9272d9c41b2c54752f4037caad4bd1e" translate="yes" xml:space="preserve">
          <source>This is useful for communication patterns that involve multiple consumers all receiving objects from the same underlying channel. See &lt;a href=&quot;#channel-mpmc&quot;&gt;Managing multiple producers and/or multiple consumers&lt;/a&gt; for examples.</source>
          <target state="translated">Esto es &amp;uacute;til para patrones de comunicaci&amp;oacute;n que involucran a varios consumidores que reciben todos objetos del mismo canal subyacente. Consulte &lt;a href=&quot;#channel-mpmc&quot;&gt;Gesti&amp;oacute;n de varios productores y / o varios consumidores&lt;/a&gt; para ver ejemplos.</target>
        </trans-unit>
        <trans-unit id="6332c9de89c2de2b861fb164fa12e80e53ca2924" translate="yes" xml:space="preserve">
          <source>This is useful for communication patterns that involve multiple producers all sending objects to the same destination. If you give each producer its own clone of the &lt;a href=&quot;#trio.MemorySendChannel&quot;&gt;&lt;code&gt;MemorySendChannel&lt;/code&gt;&lt;/a&gt;, and then make sure to close each &lt;a href=&quot;#trio.MemorySendChannel&quot;&gt;&lt;code&gt;MemorySendChannel&lt;/code&gt;&lt;/a&gt; when it&amp;rsquo;s finished, receivers will automatically get notified when all producers are finished. See &lt;a href=&quot;#channel-mpmc&quot;&gt;Managing multiple producers and/or multiple consumers&lt;/a&gt; for examples.</source>
          <target state="translated">Esto es &amp;uacute;til para patrones de comunicaci&amp;oacute;n que involucran a varios productores enviando objetos al mismo destino. Si le da a cada productor su propio clon de &lt;a href=&quot;#trio.MemorySendChannel&quot;&gt; &lt;code&gt;MemorySendChannel&lt;/code&gt; &lt;/a&gt; y luego se asegura de cerrar cada &lt;a href=&quot;#trio.MemorySendChannel&quot;&gt; &lt;code&gt;MemorySendChannel&lt;/code&gt; &lt;/a&gt; cuando finaliza, los receptores recibir&amp;aacute;n una notificaci&amp;oacute;n autom&amp;aacute;ticamente cuando todos los productores hayan terminado. Consulte &lt;a href=&quot;#channel-mpmc&quot;&gt;Gesti&amp;oacute;n de varios productores y / o varios consumidores&lt;/a&gt; para ver ejemplos.</target>
        </trans-unit>
        <trans-unit id="656afa48ac21a0f1af58f68661fd2f4f96313976" translate="yes" xml:space="preserve">
          <source>This is useful in some exotic networking configurations where your host has multiple IP addresses, and you want to force the use of a specific one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14371b9c7cf5540c783770ba7972ab7d26d5fd82" translate="yes" xml:space="preserve">
          <source>This is useful in testing code when you want to give other tasks a chance to &amp;ldquo;settle down&amp;rdquo;. The calling task is blocked, and doesn&amp;rsquo;t wake up until all other tasks are also blocked for at least &lt;code&gt;cushion&lt;/code&gt; seconds. (Setting a non-zero &lt;code&gt;cushion&lt;/code&gt; is intended to handle cases like two tasks talking to each other over a local socket, where we want to ignore the potential brief moment between a send and receive when all tasks are blocked.)</source>
          <target state="translated">Esto es &amp;uacute;til para probar c&amp;oacute;digo cuando desea dar a otras tareas la oportunidad de &quot;calmarse&quot;. La tarea de llamada se bloquea y no se activa hasta que todas las dem&amp;aacute;s tareas tambi&amp;eacute;n se bloquean durante al menos segundos de &lt;code&gt;cushion&lt;/code&gt; . (Establecer un &lt;code&gt;cushion&lt;/code&gt; distinto de cero est&amp;aacute; destinado a manejar casos como dos tareas que se comunican entre s&amp;iacute; a trav&amp;eacute;s de un socket local, donde queremos ignorar el breve momento potencial entre un env&amp;iacute;o y una recepci&amp;oacute;n cuando todas las tareas est&amp;aacute;n bloqueadas).</target>
        </trans-unit>
        <trans-unit id="6d9c47c65341615224be021b44bf2fd41e1eacd6" translate="yes" xml:space="preserve">
          <source>This logic is a bit convoluted, but accomplishes all of the following:</source>
          <target state="translated">Esta lógica es un poco enrevesada,pero cumple con todo lo siguiente:</target>
        </trans-unit>
        <trans-unit id="7ceffadabbbd6b876aa5cf2d79a7eb379cd975bc" translate="yes" xml:space="preserve">
          <source>This means that if you call &lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt;&lt;code&gt;wait_all_tasks_blocked()&lt;/code&gt;&lt;/a&gt; with a cushion &lt;em&gt;larger&lt;/em&gt; than your autojump threshold, then your call to &lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt;&lt;code&gt;wait_all_tasks_blocked()&lt;/code&gt;&lt;/a&gt; will never return, because the autojump task will keep waking up before your task does, and each time it does it&amp;rsquo;ll reset your task&amp;rsquo;s timer. However, if your cushion and the autojump threshold are the &lt;em&gt;same&lt;/em&gt;, then the autojump&amp;rsquo;s tiebreaker will prevent them from interfering (unless you also set your tiebreaker to infinity for some reason. Don&amp;rsquo;t do that). As an important special case: this means that if you set an autojump threshold of zero and use &lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt;&lt;code&gt;wait_all_tasks_blocked()&lt;/code&gt;&lt;/a&gt; with the default zero cushion, then everything will work fine.</source>
          <target state="translated">Esto significa que si llama a &lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt; &lt;code&gt;wait_all_tasks_blocked()&lt;/code&gt; &lt;/a&gt; con un colch&amp;oacute;n &lt;em&gt;mayor&lt;/em&gt; que su umbral de salto autom&amp;aacute;tico, entonces su llamada a &lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt; &lt;code&gt;wait_all_tasks_blocked()&lt;/code&gt; &lt;/a&gt; nunca regresar&amp;aacute;, porque la tarea de salto autom&amp;aacute;tico seguir&amp;aacute; despertando antes que su tarea, y cada vez que lo haga lo har&amp;aacute;. restablece el temporizador de tu tarea. Sin embargo, si tu colch&amp;oacute;n y el umbral de autojump son &lt;em&gt;iguales&lt;/em&gt; , entonces el desempate del autojump evitar&amp;aacute; que interfieran (a menos que tambi&amp;eacute;n establezcas tu desempate al infinito por alguna raz&amp;oacute;n. No hagas eso). Como caso especial importante: esto significa que si establece un umbral de salto autom&amp;aacute;tico de cero y usa &lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt; &lt;code&gt;wait_all_tasks_blocked()&lt;/code&gt; &lt;/a&gt; con el colch&amp;oacute;n de cero predeterminado, entonces todo funcionar&amp;aacute; bien.</target>
        </trans-unit>
        <trans-unit id="a31ec8fe7387a6f002a01fe33b6841ee026197dd" translate="yes" xml:space="preserve">
          <source>This means that tasks form a tree: when you call &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt;, then this creates an initial task, and all your other tasks will be children, grandchildren, etc. of the initial task.</source>
          <target state="translated">Esto significa que las tareas forman un &amp;aacute;rbol: cuando llamas a &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; , esto crea una tarea inicial, y todas tus otras tareas ser&amp;aacute;n hijos, nietos, etc. de la tarea inicial.</target>
        </trans-unit>
        <trans-unit id="f005299077b827c8391c3a9c98e8547fe4ad4d44" translate="yes" xml:space="preserve">
          <source>This means you only need to override the defaults at places where you transition from protected code to unprotected code or vice-versa.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="001dbbe80004bb99fc2bc2a63a98f6d83ad1c4aa" translate="yes" xml:space="preserve">
          <source>This method &lt;strong&gt;must not&lt;/strong&gt; return &lt;em&gt;late&lt;/em&gt;: if it&amp;rsquo;s possible for &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt; to complete without blocking, then it must return. When implementing it, err on the side of returning early.</source>
          <target state="translated">Este m&amp;eacute;todo &lt;strong&gt;no debe&lt;/strong&gt; regresar &lt;em&gt;tarde&lt;/em&gt; : si es posible que &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt; complete sin bloquear, entonces debe regresar. Al implementarlo, peca de regresar temprano.</target>
        </trans-unit>
        <trans-unit id="fe0ddaab4931c7368e42811a407720834ac1654f" translate="yes" xml:space="preserve">
          <source>This method handles routine errors like &lt;code&gt;ECONNABORTED&lt;/code&gt;, but passes other errors on to its caller. In particular, it does &lt;em&gt;not&lt;/em&gt; make any special effort to handle resource exhaustion errors like &lt;code&gt;EMFILE&lt;/code&gt;, &lt;code&gt;ENFILE&lt;/code&gt;, &lt;code&gt;ENOBUFS&lt;/code&gt;, &lt;code&gt;ENOMEM&lt;/code&gt;.</source>
          <target state="translated">Este m&amp;eacute;todo maneja errores de rutina como &lt;code&gt;ECONNABORTED&lt;/code&gt; , pero pasa otros errores a su llamador. En particular, &lt;em&gt;no&lt;/em&gt; hace ning&amp;uacute;n esfuerzo especial para manejar errores de agotamiento de recursos como &lt;code&gt;EMFILE&lt;/code&gt; , &lt;code&gt;ENFILE&lt;/code&gt; , &lt;code&gt;ENOBUFS&lt;/code&gt; , &lt;code&gt;ENOMEM&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc8504b3af8bb3a52e7201c66061ace528b891af" translate="yes" xml:space="preserve">
          <source>This method is idempotent, i.e., if the scope was already cancelled then this method silently does nothing.</source>
          <target state="translated">Este método es idempotente,es decir,si el alcance ya fue cancelado entonces este método silenciosamente no hace nada.</target>
        </trans-unit>
        <trans-unit id="327bcec5e9f1d8e5c9b4dfa3978e568947924437" translate="yes" xml:space="preserve">
          <source>This method is intended to aid in implementing protocols that want to delay choosing which data to send until the last moment. E.g., suppose you&amp;rsquo;re working on an implemention of a remote display server like &lt;a href=&quot;https://en.wikipedia.org/wiki/Virtual_Network_Computing&quot;&gt;VNC&lt;/a&gt;, and the network connection is currently backed up so that if you call &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt; now then it will sit for 0.5 seconds before actually sending anything. In this case it doesn&amp;rsquo;t make sense to take a screenshot, then wait 0.5 seconds, and then send it, because the screen will keep changing while you wait; it&amp;rsquo;s better to wait 0.5 seconds, then take the screenshot, and then send it, because this way the data you deliver will be more up-to-date. Using &lt;a href=&quot;#trio.abc.SendStream.wait_send_all_might_not_block&quot;&gt;&lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt;&lt;/a&gt; makes it possible to implement the better strategy.</source>
          <target state="translated">Este m&amp;eacute;todo est&amp;aacute; destinado a ayudar en la implementaci&amp;oacute;n de protocolos que desean retrasar la elecci&amp;oacute;n de qu&amp;eacute; datos enviar hasta el &amp;uacute;ltimo momento. Por ejemplo, suponga que est&amp;aacute; trabajando en una implementaci&amp;oacute;n de un servidor de visualizaci&amp;oacute;n remoto como &lt;a href=&quot;https://en.wikipedia.org/wiki/Virtual_Network_Computing&quot;&gt;VNC&lt;/a&gt; , y la conexi&amp;oacute;n de red est&amp;aacute; actualmente respaldada, de modo que si llama a &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt; ahora, se detendr&amp;aacute; durante 0,5 segundos antes de enviar algo. En este caso, no tiene sentido tomar una captura de pantalla, esperar 0.5 segundos y luego enviarla, porque la pantalla seguir&amp;aacute; cambiando mientras espera; Es mejor esperar 0.5 segundos, luego tomar la captura de pantalla y luego enviarla, porque de esta manera los datos que entregue estar&amp;aacute;n m&amp;aacute;s actualizados. El uso de &lt;a href=&quot;#trio.abc.SendStream.wait_send_all_might_not_block&quot;&gt; &lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt; &lt;/a&gt; hace posible implementar la mejor estrategia.</target>
        </trans-unit>
        <trans-unit id="11ce31115b0532c0a09e761077c91c38b3555228" translate="yes" xml:space="preserve">
          <source>This method may return early: it&amp;rsquo;s possible that after it returns, &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt; will still block. (In the worst case, if no better implementation is available, then it might always return immediately without blocking. It&amp;rsquo;s nice to do better than that when possible, though.)</source>
          <target state="translated">Este m&amp;eacute;todo puede regresar antes: es posible que despu&amp;eacute;s de que regrese, &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt; a&amp;uacute;n se bloquee. (En el peor de los casos, si no hay una mejor implementaci&amp;oacute;n disponible, entonces siempre puede regresar inmediatamente sin bloquearse. Sin embargo, es bueno hacerlo mejor cuando sea posible).</target>
        </trans-unit>
        <trans-unit id="68cd0d3fca1c3e830708ccdf82c78498e770bf02" translate="yes" xml:space="preserve">
          <source>This must be called from inside the coroutine being resumed, and yields whatever value you pass in. (Presumably you&amp;rsquo;ll pass a value that will cause the current coroutine runner to stop scheduling this task.) Then the coroutine is resumed by the Trio scheduler at the next opportunity.</source>
          <target state="translated">Esto se debe llamar desde el interior de la corrutina que se est&amp;aacute; reanudando y produce cualquier valor que ingrese. (Presumiblemente, pasar&amp;aacute; un valor que har&amp;aacute; que el ejecutor de la corrutina actual deje de programar esta tarea). Luego, el programador Trio reanuda la corrutina. en la pr&amp;oacute;xima oportunidad.</target>
        </trans-unit>
        <trans-unit id="07dd1ff7276a26efb26664ad097a141e5b97de29" translate="yes" xml:space="preserve">
          <source>This object has two uses:</source>
          <target state="translated">Este objeto tiene dos usos:</target>
        </trans-unit>
        <trans-unit id="59a2c593d37d67b4ae21874adc6716930415e309" translate="yes" xml:space="preserve">
          <source>This object&amp;rsquo;s interface is similar to, but different from, that of &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Semaphore&quot;&gt;&lt;code&gt;threading.Semaphore&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La interfaz de este objeto es similar pero diferente a la de &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Semaphore&quot;&gt; &lt;code&gt;threading.Semaphore&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a68395d90aeaf758adfebddbd727e34ea765aab" translate="yes" xml:space="preserve">
          <source>This project is young and still somewhat experimental: the overall design is solid and the existing features are fully tested and documented, but you may encounter missing functionality or rough edges. We &lt;em&gt;do&lt;/em&gt; encourage you do use it, but you should &lt;a href=&quot;https://github.com/python-trio/trio/issues/1&quot;&gt;read and subscribe to issue #1&lt;/a&gt; to get warning and a chance to give feedback about any compatibility-breaking changes.</source>
          <target state="translated">Este proyecto es joven y todav&amp;iacute;a algo experimental: el dise&amp;ntilde;o general es s&amp;oacute;lido y las caracter&amp;iacute;sticas existentes est&amp;aacute;n completamente probadas y documentadas, pero es posible que encuentre una funcionalidad faltante o asperezas. Nosotros &lt;em&gt;s&amp;iacute;&lt;/em&gt; recomendamos que lo utiliza, pero usted debe &lt;a href=&quot;https://github.com/python-trio/trio/issues/1&quot;&gt;leer y suscribirse a la edici&amp;oacute;n # 1&lt;/a&gt; para obtener la advertencia y la oportunidad de dar su opini&amp;oacute;n sobre cualquier cambio de compatibilidad sin precedentes.</target>
        </trans-unit>
        <trans-unit id="ec32d26f4a4b5dcad7771a9eee995fa9164024e5" translate="yes" xml:space="preserve">
          <source>This returns a new &lt;a href=&quot;#trio.MemoryReceiveChannel&quot;&gt;&lt;code&gt;MemoryReceiveChannel&lt;/code&gt;&lt;/a&gt; object, which acts as a duplicate of the original: receiving on the new object does exactly the same thing as receiving on the old object.</source>
          <target state="translated">Esto devuelve un nuevo objeto &lt;a href=&quot;#trio.MemoryReceiveChannel&quot;&gt; &lt;code&gt;MemoryReceiveChannel&lt;/code&gt; &lt;/a&gt; , que act&amp;uacute;a como un duplicado del original: recibir en el nuevo objeto hace exactamente lo mismo que recibir en el objeto antiguo.</target>
        </trans-unit>
        <trans-unit id="a121a762df27863607d656fedc77c458d011385f" translate="yes" xml:space="preserve">
          <source>This returns a new &lt;a href=&quot;#trio.MemorySendChannel&quot;&gt;&lt;code&gt;MemorySendChannel&lt;/code&gt;&lt;/a&gt; object, which acts as a duplicate of the original: sending on the new object does exactly the same thing as sending on the old object. (If you&amp;rsquo;re familiar with &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.dup&quot;&gt;&lt;code&gt;os.dup&lt;/code&gt;&lt;/a&gt;, then this is a similar idea.)</source>
          <target state="translated">Esto devuelve un nuevo objeto &lt;a href=&quot;#trio.MemorySendChannel&quot;&gt; &lt;code&gt;MemorySendChannel&lt;/code&gt; &lt;/a&gt; , que act&amp;uacute;a como un duplicado del original: enviar el nuevo objeto hace exactamente lo mismo que enviar el antiguo objeto. (Si est&amp;aacute; familiarizado con &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.dup&quot;&gt; &lt;code&gt;os.dup&lt;/code&gt; &lt;/a&gt; , esta es una idea similar).</target>
        </trans-unit>
        <trans-unit id="e198f11e3abc356f6bac5f79d25c297a458de712" translate="yes" xml:space="preserve">
          <source>This setting has no effect if your program has registered a custom SIGINT handler, or if &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; is called from anywhere but the main thread (this is a Python limitation), or if you use &lt;a href=&quot;reference-io#trio.open_signal_receiver&quot;&gt;&lt;code&gt;open_signal_receiver()&lt;/code&gt;&lt;/a&gt; to catch SIGINT.</source>
          <target state="translated">Esta configuraci&amp;oacute;n no tiene ning&amp;uacute;n efecto si su programa ha registrado un controlador SIGINT personalizado, o si se llama a &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; desde cualquier lugar menos el hilo principal (esto es una limitaci&amp;oacute;n de Python), o si usa &lt;a href=&quot;reference-io#trio.open_signal_receiver&quot;&gt; &lt;code&gt;open_signal_receiver()&lt;/code&gt; &lt;/a&gt; para capturar SIGINT.</target>
        </trans-unit>
        <trans-unit id="8544c29e984137341c0686f2d63ccb7f84894719" translate="yes" xml:space="preserve">
          <source>This should include all the attributes exposed by classes in &lt;a href=&quot;https://docs.python.org/3/library/io.html#module-io&quot;&gt;&lt;code&gt;io&lt;/code&gt;&lt;/a&gt;. But if you&amp;rsquo;re wrapping an object that has other attributes that aren&amp;rsquo;t on the list above, then you can access them via the &lt;code&gt;.wrapped&lt;/code&gt; attribute:</source>
          <target state="translated">Esto deber&amp;iacute;a incluir todos los atributos expuestos por clases en &lt;a href=&quot;https://docs.python.org/3/library/io.html#module-io&quot;&gt; &lt;code&gt;io&lt;/code&gt; &lt;/a&gt; . Pero si envuelve un objeto que tiene otros atributos que no est&amp;aacute;n en la lista anterior, puede acceder a ellos a trav&amp;eacute;s del atributo &lt;code&gt;.wrapped&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b75455664926a8069eb8f58115417e9cb3001585" translate="yes" xml:space="preserve">
          <source>This should never happen! If you get this error, please file a bug.</source>
          <target state="translated">¡Esto no debería pasar nunca! Si te da este error,por favor,presenta un error.</target>
        </trans-unit>
        <trans-unit id="0778ce6636c49535b569f7546a62446d88b94afe" translate="yes" xml:space="preserve">
          <source>This stream has &lt;em&gt;absolutely no&lt;/em&gt; buffering. Each call to &lt;a href=&quot;reference-io#trio.abc.SendStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt; will block until all the given data has been returned by a call to &lt;a href=&quot;reference-io#trio.abc.ReceiveStream.receive_some&quot;&gt;&lt;code&gt;receive_some()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esta secuencia no tiene &lt;em&gt;absolutamente ning&amp;uacute;n&lt;/em&gt; almacenamiento en b&amp;uacute;fer. Cada llamada a &lt;a href=&quot;reference-io#trio.abc.SendStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt; se bloquear&amp;aacute; hasta que todos los datos dados hayan sido devueltos por una llamada a &lt;a href=&quot;reference-io#trio.abc.ReceiveStream.receive_some&quot;&gt; &lt;code&gt;receive_some()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c6928d21a889dc4f82db9ebb48058b9d6fb885e" translate="yes" xml:space="preserve">
          <source>This task&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3/library/contextvars.html#contextvars.Context&quot;&gt;&lt;code&gt;contextvars.Context&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">Objeto &lt;a href=&quot;https://docs.python.org/3/library/contextvars.html#contextvars.Context&quot;&gt; &lt;code&gt;contextvars.Context&lt;/code&gt; de&lt;/a&gt; esta tarea .</target>
        </trans-unit>
        <trans-unit id="d87a62610b91ba5d469e111e2195effe428736a6" translate="yes" xml:space="preserve">
          <source>This task&amp;rsquo;s coroutine object. Example usage: extracting a stack trace:</source>
          <target state="translated">Objeto de corrutina de esta tarea. Ejemplo de uso: extracci&amp;oacute;n de un seguimiento de pila:</target>
        </trans-unit>
        <trans-unit id="6b3da9f4aca9dba70e3bde25fee8a94969706173" translate="yes" xml:space="preserve">
          <source>This wakes up &lt;code&gt;count&lt;/code&gt; tasks that are blocked in &lt;a href=&quot;#trio.hazmat.ParkingLot.park&quot;&gt;&lt;code&gt;park()&lt;/code&gt;&lt;/a&gt;. If there are fewer than &lt;code&gt;count&lt;/code&gt; tasks parked, then wakes as many tasks are available and then returns successfully.</source>
          <target state="translated">Esto despierta las tareas de &lt;code&gt;count&lt;/code&gt; que est&amp;aacute;n bloqueadas en el &lt;a href=&quot;#trio.hazmat.ParkingLot.park&quot;&gt; &lt;code&gt;park()&lt;/code&gt; &lt;/a&gt; . Si hay menos tareas estacionadas del &lt;code&gt;count&lt;/code&gt; , se activa tantas tareas como est&amp;eacute;n disponibles y luego regresa correctamente.</target>
        </trans-unit>
        <trans-unit id="0d3750a87ca97b95a41eb6cbd73385051a9b7290" translate="yes" xml:space="preserve">
          <source>This wakes up &lt;code&gt;count&lt;/code&gt; tasks that are blocked in &lt;a href=&quot;#trio.lowlevel.ParkingLot.park&quot;&gt;&lt;code&gt;park()&lt;/code&gt;&lt;/a&gt;. If there are fewer than &lt;code&gt;count&lt;/code&gt; tasks parked, then wakes as many tasks are available and then returns successfully.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aee475931b299c6d841c958af99cba9eabd02399" translate="yes" xml:space="preserve">
          <source>This way we can see that request 1 was slow: it started before request 2 but finished afterwards. (You can also get &lt;a href=&quot;https://opentracing.io/docs/&quot;&gt;much fancier&lt;/a&gt;, but this is enough for an example.)</source>
          <target state="translated">De esta manera podemos ver que la solicitud 1 fue lenta: comenz&amp;oacute; antes de la solicitud 2 pero termin&amp;oacute; despu&amp;eacute;s. (Tambi&amp;eacute;n puede ser &lt;a href=&quot;https://opentracing.io/docs/&quot;&gt;mucho m&amp;aacute;s elegante&lt;/a&gt; , pero esto es suficiente como ejemplo).</target>
        </trans-unit>
        <trans-unit id="e101192d5d657da7f6a68e046e5e6272e86645d2" translate="yes" xml:space="preserve">
          <source>This way, your two event loops have the same lifetime, and your program automatically exits when your Trio function finishes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4429c38a1975f5763a238e06f0d62b450c78494" translate="yes" xml:space="preserve">
          <source>This will probably be clearer with an example. Here we demonstrate how to spawn a child thread, and then use a &lt;a href=&quot;#channels&quot;&gt;memory channel&lt;/a&gt; to send messages between the thread and a Trio task:</source>
          <target state="translated">Probablemente esto quede m&amp;aacute;s claro con un ejemplo. Aqu&amp;iacute; demostramos c&amp;oacute;mo generar un hilo secundario y luego usar un &lt;a href=&quot;#channels&quot;&gt;canal de memoria&lt;/a&gt; para enviar mensajes entre el hilo y una tarea Trio:</target>
        </trans-unit>
        <trans-unit id="11d26ec84465ee4cd2879abd7330229b6daec696" translate="yes" xml:space="preserve">
          <source>This works by starting a set of tasks which each try to run their function, and then report back the value it returns. The main task uses &lt;code&gt;receive_channel.receive&lt;/code&gt; to wait for one to finish; as soon as the first task crosses the finish line, it cancels the rest, and then returns the winning value.</source>
          <target state="translated">Esto funciona iniciando un conjunto de tareas, cada una de las cuales intenta ejecutar su funci&amp;oacute;n y luego informa el valor que devuelve. La tarea principal usa &lt;code&gt;receive_channel.receive&lt;/code&gt; para esperar a que termine una; tan pronto como la primera tarea cruza la l&amp;iacute;nea de meta, cancela el resto y luego devuelve el valor ganador.</target>
        </trans-unit>
        <trans-unit id="47930bd9c8e42779dd9eefabccf4759ba973fe91" translate="yes" xml:space="preserve">
          <source>This wraps any file object in a wrapper that provides an asynchronous file object interface.</source>
          <target state="translated">Esto envuelve cualquier objeto de archivo en una envoltura que proporciona una interfaz de objeto de archivo asincrónica.</target>
        </trans-unit>
        <trans-unit id="d0cef5deb223649da3c92e68bafacf5c8ccd785e" translate="yes" xml:space="preserve">
          <source>Thread safety</source>
          <target state="translated">Seguridad de los hilos</target>
        </trans-unit>
        <trans-unit id="c2ae2cf32d685dc7a1f9f34c4a9d9327ffc68dbc" translate="yes" xml:space="preserve">
          <source>Threads (if you must)</source>
          <target state="translated">Hilos (si es necesario)</target>
        </trans-unit>
        <trans-unit id="0466f8bc08e10e7b99d662eae8d049fece98b184" translate="yes" xml:space="preserve">
          <source>Time and clocks</source>
          <target state="translated">El tiempo y los relojes</target>
        </trans-unit>
        <trans-unit id="c86350a7e132f385d94c48db12ed5fffe7264e2d" translate="yes" xml:space="preserve">
          <source>Time and timeouts</source>
          <target state="translated">Tiempo y tiempos muertos</target>
        </trans-unit>
        <trans-unit id="30a89cebf15d291ad9051f7d277492c668872107" translate="yes" xml:space="preserve">
          <source>To avoid this, threads mark themselves as idle &lt;em&gt;before&lt;/em&gt; calling &lt;code&gt;deliver&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9672fd790323861a273f8a756b00c40cc5fc7c09" translate="yes" xml:space="preserve">
          <source>To be used as a Trio stream, an open file must be placed in non-blocking mode. Unfortunately, this impacts all I/O that goes through the underlying open file, including I/O that uses a different file descriptor than the one that was passed to Trio. If other threads or processes are using file descriptors that are related through &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.dup&quot;&gt;&lt;code&gt;os.dup&lt;/code&gt;&lt;/a&gt; or inheritance across &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.fork&quot;&gt;&lt;code&gt;os.fork&lt;/code&gt;&lt;/a&gt; to the one that Trio is using, they are unlikely to be prepared to have non-blocking I/O semantics suddenly thrust upon them. For example, you can use &lt;code&gt;FdStream(os.dup(0))&lt;/code&gt; to obtain a stream for reading from standard input, but it is only safe to do so with heavy caveats: your stdin must not be shared by any other processes and you must not make any calls to synchronous methods of &lt;a href=&quot;https://docs.python.org/3/library/sys.html#sys.stdin&quot;&gt;&lt;code&gt;sys.stdin&lt;/code&gt;&lt;/a&gt; until the stream returned by &lt;a href=&quot;#trio.hazmat.FdStream&quot;&gt;&lt;code&gt;FdStream&lt;/code&gt;&lt;/a&gt; is closed. See &lt;a href=&quot;https://github.com/python-trio/trio/issues/174&quot;&gt;issue #174&lt;/a&gt; for a discussion of the challenges involved in relaxing this restriction.</source>
          <target state="translated">Para utilizarlo como una secuencia Trio, un archivo abierto debe colocarse en modo sin bloqueo. Desafortunadamente, esto afecta todas las E / S que pasan por el archivo abierto subyacente, incluidas las E / S que utilizan un descriptor de archivo diferente al que se pas&amp;oacute; a Trio. Si otros subprocesos o procesos est&amp;aacute;n usando descriptores de archivo que est&amp;aacute;n relacionados a trav&amp;eacute;s de &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.dup&quot;&gt; &lt;code&gt;os.dup&lt;/code&gt; &lt;/a&gt; o la herencia a trav&amp;eacute;s de &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.fork&quot;&gt; &lt;code&gt;os.fork&lt;/code&gt; &lt;/a&gt; con el que est&amp;aacute; usando Trio, es poco probable que est&amp;eacute;n preparados para tener una sem&amp;aacute;ntica de E / S sin bloqueo repentinamente. Por ejemplo, puede usar &lt;code&gt;FdStream(os.dup(0))&lt;/code&gt; para obtener un flujo de lectura de la entrada est&amp;aacute;ndar, pero solo es seguro hacerlo con advertencias importantes: su stdin no debe ser compartido por ning&amp;uacute;n otro proceso y usted debe no realizar ninguna llamada a m&amp;eacute;todos s&amp;iacute;ncronos de&lt;a href=&quot;https://docs.python.org/3/library/sys.html#sys.stdin&quot;&gt; &lt;code&gt;sys.stdin&lt;/code&gt; &lt;/a&gt; hasta que se cierre la secuencia devuelta por&lt;a href=&quot;#trio.hazmat.FdStream&quot;&gt; &lt;code&gt;FdStream&lt;/code&gt; &lt;/a&gt; . Vea el&lt;a href=&quot;https://github.com/python-trio/trio/issues/174&quot;&gt; n&amp;uacute;mero 174&lt;/a&gt; para una discusi&amp;oacute;n de los desaf&amp;iacute;os involucrados en relajar esta restricci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="abcb219546bd354d940210d5cfe8092f011774a4" translate="yes" xml:space="preserve">
          <source>To be used as a Trio stream, an open file must be placed in non-blocking mode. Unfortunately, this impacts all I/O that goes through the underlying open file, including I/O that uses a different file descriptor than the one that was passed to Trio. If other threads or processes are using file descriptors that are related through &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.dup&quot;&gt;&lt;code&gt;os.dup&lt;/code&gt;&lt;/a&gt; or inheritance across &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.fork&quot;&gt;&lt;code&gt;os.fork&lt;/code&gt;&lt;/a&gt; to the one that Trio is using, they are unlikely to be prepared to have non-blocking I/O semantics suddenly thrust upon them. For example, you can use &lt;code&gt;FdStream(os.dup(sys.stdin.fileno()))&lt;/code&gt; to obtain a stream for reading from standard input, but it is only safe to do so with heavy caveats: your stdin must not be shared by any other processes and you must not make any calls to synchronous methods of &lt;a href=&quot;https://docs.python.org/3/library/sys.html#sys.stdin&quot;&gt;&lt;code&gt;sys.stdin&lt;/code&gt;&lt;/a&gt; until the stream returned by &lt;a href=&quot;#trio.lowlevel.FdStream&quot;&gt;&lt;code&gt;FdStream&lt;/code&gt;&lt;/a&gt; is closed. See &lt;a href=&quot;https://github.com/python-trio/trio/issues/174&quot;&gt;issue #174&lt;/a&gt; for a discussion of the challenges involved in relaxing this restriction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b931c6b0d780ed8d96ccd76191352b796bd15ae7" translate="yes" xml:space="preserve">
          <source>To build a bidirectional stream, &lt;a href=&quot;#trio.testing.memory_stream_pair&quot;&gt;&lt;code&gt;memory_stream_pair()&lt;/code&gt;&lt;/a&gt; uses two unidirectional streams. It gets these by calling &lt;a href=&quot;#trio.testing.memory_stream_one_way_pair&quot;&gt;&lt;code&gt;memory_stream_one_way_pair()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para construir un flujo bidireccional, &lt;a href=&quot;#trio.testing.memory_stream_pair&quot;&gt; &lt;code&gt;memory_stream_pair()&lt;/code&gt; &lt;/a&gt; usa dos flujos unidireccionales. Los obtiene llamando a &lt;a href=&quot;#trio.testing.memory_stream_one_way_pair&quot;&gt; &lt;code&gt;memory_stream_one_way_pair()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="05516bbca026f3ec58a38804bdec50fda7847866" translate="yes" xml:space="preserve">
          <source>To solve this problem, Python 3.7 added a new module to the standard library: &lt;a href=&quot;https://docs.python.org/3/library/contextvars.html#module-contextvars&quot;&gt;&lt;code&gt;contextvars&lt;/code&gt;&lt;/a&gt;. And not only does Trio have built-in support for &lt;a href=&quot;https://docs.python.org/3/library/contextvars.html#module-contextvars&quot;&gt;&lt;code&gt;contextvars&lt;/code&gt;&lt;/a&gt;, but if you&amp;rsquo;re using an earlier version of Python, then Trio makes sure that a backported version of &lt;a href=&quot;https://docs.python.org/3/library/contextvars.html#module-contextvars&quot;&gt;&lt;code&gt;contextvars&lt;/code&gt;&lt;/a&gt; is installed. So you can assume &lt;a href=&quot;https://docs.python.org/3/library/contextvars.html#module-contextvars&quot;&gt;&lt;code&gt;contextvars&lt;/code&gt;&lt;/a&gt; is there and works regardless of what version of Python you&amp;rsquo;re using.</source>
          <target state="translated">Para resolver este problema, Python 3.7 agreg&amp;oacute; un nuevo m&amp;oacute;dulo a la biblioteca est&amp;aacute;ndar: &lt;a href=&quot;https://docs.python.org/3/library/contextvars.html#module-contextvars&quot;&gt; &lt;code&gt;contextvars&lt;/code&gt; &lt;/a&gt; . Y no solo Trio tiene soporte &lt;a href=&quot;https://docs.python.org/3/library/contextvars.html#module-contextvars&quot;&gt; &lt;code&gt;contextvars&lt;/code&gt; &lt;/a&gt; para contextvars , sino que si est&amp;aacute; utilizando una versi&amp;oacute;n anterior de Python, Trio se asegura de que est&amp;eacute; instalada una versi&amp;oacute;n backportada de &lt;a href=&quot;https://docs.python.org/3/library/contextvars.html#module-contextvars&quot;&gt; &lt;code&gt;contextvars&lt;/code&gt; &lt;/a&gt; . Por lo tanto, puede asumir que &lt;a href=&quot;https://docs.python.org/3/library/contextvars.html#module-contextvars&quot;&gt; &lt;code&gt;contextvars&lt;/code&gt; &lt;/a&gt; est&amp;aacute; ah&amp;iacute; y funciona independientemente de la versi&amp;oacute;n de Python que est&amp;eacute; usando.</target>
        </trans-unit>
        <trans-unit id="e5cd337a0a94a79ca9bf0c7b1bbc3dbf9f0f4355" translate="yes" xml:space="preserve">
          <source>To understand why, you need to know two things.</source>
          <target state="translated">Para entender por qué,necesitas saber dos cosas.</target>
        </trans-unit>
        <trans-unit id="217ae68a57b281448452f9625b7db65c0e37b492" translate="yes" xml:space="preserve">
          <source>Tools and Utilities</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db3006577395a2fbdf588f1767d5cce77ff37b7b" translate="yes" xml:space="preserve">
          <source>Top-level exports</source>
          <target state="translated">Exportaciones de alto nivel</target>
        </trans-unit>
        <trans-unit id="dbd7a0da99ea93e9335a316b4f8d8307c0645cc6" translate="yes" xml:space="preserve">
          <source>Towards the end of a call to &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt;, after the main task and all system tasks have exited, the system nursery becomes closed. At this point, new calls to &lt;a href=&quot;#trio.lowlevel.spawn_system_task&quot;&gt;&lt;code&gt;spawn_system_task()&lt;/code&gt;&lt;/a&gt; will raise &lt;code&gt;RuntimeError(&quot;Nursery
is closed to new arrivals&quot;)&lt;/code&gt; instead of creating a system task. It&amp;rsquo;s possible to encounter this state either in a &lt;code&gt;finally&lt;/code&gt; block in an async generator, or in a callback passed to &lt;a href=&quot;#trio.lowlevel.TrioToken.run_sync_soon&quot;&gt;&lt;code&gt;TrioToken.run_sync_soon()&lt;/code&gt;&lt;/a&gt; at the right moment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6b456d043430ca913d9174bb8cfc55ab351d5d3" translate="yes" xml:space="preserve">
          <source>Trio</source>
          <target state="translated">Trio</target>
        </trans-unit>
        <trans-unit id="e10ab5c8f9662b6d401524134931ffbe3ea711b3" translate="yes" xml:space="preserve">
          <source>Trio 0.1.0 (2017-03-10)</source>
          <target state="translated">Trío 0.1.0 (2017-03-10)</target>
        </trans-unit>
        <trans-unit id="74fa2c2fe4c26140ed7ec69a5902a700dc2e2288" translate="yes" xml:space="preserve">
          <source>Trio 0.10.0 (2019-01-07)</source>
          <target state="translated">Trío 0.10.0 (2019-01-07)</target>
        </trans-unit>
        <trans-unit id="69e4642ca3df5dc9d3712b14dba73397b158dcb9" translate="yes" xml:space="preserve">
          <source>Trio 0.11.0 (2019-02-09)</source>
          <target state="translated">Trío 0.11.0 (2019-02-09)</target>
        </trans-unit>
        <trans-unit id="6c74db81639abc94a5e78afb9914315a7d2e61e4" translate="yes" xml:space="preserve">
          <source>Trio 0.12.0 (2019-07-31)</source>
          <target state="translated">Trío 0.12.0 (2019-07-31)</target>
        </trans-unit>
        <trans-unit id="756c5475a93f96aff35a02be8296ff76a5362ef7" translate="yes" xml:space="preserve">
          <source>Trio 0.12.1 (2019-08-01)</source>
          <target state="translated">Trío 0.12.1 (2019-08-01)</target>
        </trans-unit>
        <trans-unit id="e489cea779a3257497b38f570ae0c2d90697d774" translate="yes" xml:space="preserve">
          <source>Trio 0.13.0 (2019-11-02)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9249af56a32c9aa8c9fbb6999729e77ac23c536" translate="yes" xml:space="preserve">
          <source>Trio 0.14.0 (2020-04-27)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abbd172ed7b62ab0dcf4703f9adad15f8dd1ec57" translate="yes" xml:space="preserve">
          <source>Trio 0.15.0 (2020-05-19)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81aee605bc36211978f52af6b146f36577e39578" translate="yes" xml:space="preserve">
          <source>Trio 0.15.1 (2020-05-22)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57e4e921b569f538a8aace5a4dee68c30a6c8011" translate="yes" xml:space="preserve">
          <source>Trio 0.16.0 (2020-06-10)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c28dea641c508e81f985e2898c1d90ce3d4f7c5" translate="yes" xml:space="preserve">
          <source>Trio 0.17.0 (2020-09-15)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e64ab757fc114329e217f19fe148df4c7478412f" translate="yes" xml:space="preserve">
          <source>Trio 0.18.0 (2021-01-11)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6e5fe42049ac788a8f0350bb9328d46cf841544" translate="yes" xml:space="preserve">
          <source>Trio 0.2.0 (2017-12-06)</source>
          <target state="translated">Trío 0.2.0 (2017-12-06)</target>
        </trans-unit>
        <trans-unit id="b3fb820f535b0b0931f359e1e3feac669d9d79ff" translate="yes" xml:space="preserve">
          <source>Trio 0.3.0 (2017-12-28)</source>
          <target state="translated">Trío 0.3.0 (2017-12-28)</target>
        </trans-unit>
        <trans-unit id="9ec0f7f2eed5ceef8d882523ec63a0688d3dee74" translate="yes" xml:space="preserve">
          <source>Trio 0.4.0 (2018-04-10)</source>
          <target state="translated">Trío 0.4.0 (2018-04-10)</target>
        </trans-unit>
        <trans-unit id="a5e71a7a8c48bb819251fac725eb027372565fc6" translate="yes" xml:space="preserve">
          <source>Trio 0.5.0 (2018-07-20)</source>
          <target state="translated">Trío 0.5.0 (2018-07-20)</target>
        </trans-unit>
        <trans-unit id="3c47332ee2a79b093d8020cb914bb8ee16c6946d" translate="yes" xml:space="preserve">
          <source>Trio 0.6.0 (2018-08-13)</source>
          <target state="translated">Trío 0.6.0 (2018-08-13)</target>
        </trans-unit>
        <trans-unit id="0b496cd9f24b90ed762a98cc2aaf2290bd868eda" translate="yes" xml:space="preserve">
          <source>Trio 0.7.0 (2018-09-03)</source>
          <target state="translated">Trío 0.7.0 (2018-09-03)</target>
        </trans-unit>
        <trans-unit id="9d34c423781f712340e29d42f4ebc34888e6c599" translate="yes" xml:space="preserve">
          <source>Trio 0.8.0 (2018-10-01)</source>
          <target state="translated">Trío 0.8.0 (2018-10-01)</target>
        </trans-unit>
        <trans-unit id="8f6bc445719269e2c3dc52746939c55d83476611" translate="yes" xml:space="preserve">
          <source>Trio 0.9.0 (2018-10-12)</source>
          <target state="translated">Trío 0.9.0 (2018-10-12)</target>
        </trans-unit>
        <trans-unit id="0adbdcfaf558ea55b373e281d4d8e2a52d952289" translate="yes" xml:space="preserve">
          <source>Trio also provides several convenience functions for the common situation of just wanting to impose a timeout on some code:</source>
          <target state="translated">Trio también proporciona varias funciones de conveniencia para la situación común de sólo querer imponer un tiempo de espera en algún código:</target>
        </trans-unit>
        <trans-unit id="63f1831f4b1f1da694680c3ac049ae563afd8ec4" translate="yes" xml:space="preserve">
          <source>Trio also provides some functions to help you test your custom stream implementations:</source>
          <target state="translated">Trio también proporciona algunas funciones para ayudarle a probar sus implementaciones de flujo personalizadas:</target>
        </trans-unit>
        <trans-unit id="f764514bda33ba237239ba96fe50aba14b67bee6" translate="yes" xml:space="preserve">
          <source>Trio also provides some specialized functions for testing completely &lt;strong&gt;un&lt;/strong&gt;buffered streams: &lt;a href=&quot;#trio.testing.lockstep_stream_one_way_pair&quot;&gt;&lt;code&gt;lockstep_stream_one_way_pair()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.testing.lockstep_stream_pair&quot;&gt;&lt;code&gt;lockstep_stream_pair()&lt;/code&gt;&lt;/a&gt;. These aren&amp;rsquo;t customizable, but they do exhibit an extreme kind of behavior that&amp;rsquo;s good at catching out edge cases in protocol implementations.</source>
          <target state="translated">Trio tambi&amp;eacute;n proporciona algunas funciones especializadas para probar transmisiones &lt;strong&gt;sin&lt;/strong&gt; b&amp;uacute;fer: &lt;a href=&quot;#trio.testing.lockstep_stream_one_way_pair&quot;&gt; &lt;code&gt;lockstep_stream_one_way_pair()&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#trio.testing.lockstep_stream_pair&quot;&gt; &lt;code&gt;lockstep_stream_pair()&lt;/code&gt; &lt;/a&gt; . Estos no son personalizables, pero exhiben un tipo extremo de comportamiento que es bueno para detectar casos extremos en implementaciones de protocolos.</target>
        </trans-unit>
        <trans-unit id="d7707add294b6ac0bac54c516a3af471b6c78a17" translate="yes" xml:space="preserve">
          <source>Trio currently provides a generic helper for writing servers that listen for connections using one or more &lt;a href=&quot;#trio.abc.Listener&quot;&gt;&lt;code&gt;Listener&lt;/code&gt;&lt;/a&gt;s, and a generic utility class for working with streams. And if you want to test code that&amp;rsquo;s written against the streams interface, you should also check out &lt;a href=&quot;reference-testing#testing-streams&quot;&gt;Streams&lt;/a&gt; in &lt;a href=&quot;reference-testing#module-trio.testing&quot;&gt;&lt;code&gt;trio.testing&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Trio actualmente proporciona un ayudante gen&amp;eacute;rico para escribir servidores que escuchan conexiones usando uno o m&amp;aacute;s &lt;a href=&quot;#trio.abc.Listener&quot;&gt; &lt;code&gt;Listener&lt;/code&gt; &lt;/a&gt; , y una clase de utilidad gen&amp;eacute;rica para trabajar con flujos. Y si quieres el c&amp;oacute;digo de prueba que est&amp;aacute; escrito en contra de la interfaz de tren, tambi&amp;eacute;n debe comprobar fuera de &lt;a href=&quot;reference-testing#testing-streams&quot;&gt;corrientes&lt;/a&gt; en &lt;a href=&quot;reference-testing#module-trio.testing&quot;&gt; &lt;code&gt;trio.testing&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1bb137836035175c111f8a48b35d84efdbd8248f" translate="yes" xml:space="preserve">
          <source>Trio doesn&amp;rsquo;t assign this variable any meaning, except that it sets it to &lt;code&gt;None&lt;/code&gt; whenever a task is rescheduled. It can be used to share data between the different tasks involved in putting a task to sleep and then waking it up again. (See &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt; for details.)</source>
          <target state="translated">Trio no asigna ning&amp;uacute;n significado a esta variable, excepto que la establece en &lt;code&gt;None&lt;/code&gt; cada vez que se reprograma una tarea. Se puede usar para compartir datos entre las diferentes tareas involucradas en poner una tarea en suspensi&amp;oacute;n y luego despertarla nuevamente. (Consulte &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s detalles).</target>
        </trans-unit>
        <trans-unit id="5a9cb290f7c7c4779bc09cea32d0d924b703fb42" translate="yes" xml:space="preserve">
          <source>Trio doesn&amp;rsquo;t assign this variable any meaning, except that it sets it to &lt;code&gt;None&lt;/code&gt; whenever a task is rescheduled. It can be used to share data between the different tasks involved in putting a task to sleep and then waking it up again. (See &lt;a href=&quot;#trio.lowlevel.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt; for details.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c621c59b80ace2edb624e5e2050d6d2698da42c" translate="yes" xml:space="preserve">
          <source>Trio doesn&amp;rsquo;t itself provide a virtual in-memory network implementation for testing &amp;ndash; but &lt;a href=&quot;reference-io#module-trio.socket&quot;&gt;&lt;code&gt;trio.socket&lt;/code&gt;&lt;/a&gt; module does provide the hooks you need to write your own! And if you&amp;rsquo;re interested in helping implement a reusable virtual network for testing, then &lt;a href=&quot;https://github.com/python-trio/trio/issues/170&quot;&gt;please get in touch&lt;/a&gt;.</source>
          <target state="translated">Trio no proporciona en s&amp;iacute; mismo una implementaci&amp;oacute;n de red virtual en memoria para realizar pruebas, &amp;iexcl;pero el m&amp;oacute;dulo &lt;a href=&quot;reference-io#module-trio.socket&quot;&gt; &lt;code&gt;trio.socket&lt;/code&gt; &lt;/a&gt; proporciona los ganchos que necesita para escribir los suyos propios! Y si est&amp;aacute; interesado en ayudar a implementar una red virtual reutilizable para realizar pruebas, &lt;a href=&quot;https://github.com/python-trio/trio/issues/170&quot;&gt;comun&amp;iacute;quese con nosotros&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a89d8834bcdebd9f608acfe93a7bb122db53b5f9" translate="yes" xml:space="preserve">
          <source>Trio has a rich, composable system for cancelling work, either explicitly or when a timeout expires.</source>
          <target state="translated">El trío tiene un sistema rico y componible para cancelar el trabajo,ya sea explícitamente o cuando un tiempo de espera expira.</target>
        </trans-unit>
        <trans-unit id="3224a6971f04b494f9517ecb8aea8b567e1c0a9e" translate="yes" xml:space="preserve">
          <source>Trio intentionally DOES NOT include some obsolete, redundant, or broken features:</source>
          <target state="translated">El trío intencionalmente NO incluye algunas características obsoletas,redundantes o rotas:</target>
        </trans-unit>
        <trans-unit id="7fb99857ba430551418d478736812a8a2d129e38" translate="yes" xml:space="preserve">
          <source>Trio provides SSL/TLS support based on the standard library &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#module-ssl&quot;&gt;&lt;code&gt;ssl&lt;/code&gt;&lt;/a&gt; module. Trio&amp;rsquo;s &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.SSLListener&quot;&gt;&lt;code&gt;SSLListener&lt;/code&gt;&lt;/a&gt; take their configuration from a &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;code&gt;ssl.SSLContext&lt;/code&gt;&lt;/a&gt;, which you can create using &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.create_default_context&quot;&gt;&lt;code&gt;ssl.create_default_context()&lt;/code&gt;&lt;/a&gt; and customize using the other constants and functions in the &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#module-ssl&quot;&gt;&lt;code&gt;ssl&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">Trio proporciona soporte SSL / TLS basado en el m&amp;oacute;dulo &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#module-ssl&quot;&gt; &lt;code&gt;ssl&lt;/code&gt; de la&lt;/a&gt; biblioteca est&amp;aacute;ndar . Tr&amp;iacute;o de &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#trio.SSLListener&quot;&gt; &lt;code&gt;SSLListener&lt;/code&gt; &lt;/a&gt; toman su configuraci&amp;oacute;n desde un &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt; &lt;code&gt;ssl.SSLContext&lt;/code&gt; &lt;/a&gt; , lo que puede crear usando &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.create_default_context&quot;&gt; &lt;code&gt;ssl.create_default_context()&lt;/code&gt; &lt;/a&gt; y personalizar el uso de las otras constantes y funciones en el &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#module-ssl&quot;&gt; &lt;code&gt;ssl&lt;/code&gt; &lt;/a&gt; m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="d817001a39f23d2d7c8a88010d0511c25864d40c" translate="yes" xml:space="preserve">
          <source>Trio provides a set of abstract base classes that define a standard interface for unidirectional and bidirectional byte streams.</source>
          <target state="translated">Trio proporciona un conjunto de clases de base abstractas que definen una interfaz estándar para flujos de bytes unidireccionales y bidireccionales.</target>
        </trans-unit>
        <trans-unit id="8e040b74b4c87ec08a16ce1813ad188d5335f33d" translate="yes" xml:space="preserve">
          <source>Trio provides a standard set of synchronization and inter-task communication primitives. These objects&amp;rsquo; APIs are generally modelled off of the analogous classes in the standard library, but with some differences.</source>
          <target state="translated">Trio proporciona un conjunto est&amp;aacute;ndar de primitivas de sincronizaci&amp;oacute;n y comunicaci&amp;oacute;n entre tareas. Las API de estos objetos generalmente se modelan a partir de clases an&amp;aacute;logas en la biblioteca est&amp;aacute;ndar, pero con algunas diferencias.</target>
        </trans-unit>
        <trans-unit id="e01d4ed6a91a5aceea04193c03b358b081f49eb7" translate="yes" xml:space="preserve">
          <source>Trio provides built-in facilities for performing asynchronous filesystem operations like reading or renaming a file. Generally, we recommend that you use these instead of Python&amp;rsquo;s normal synchronous file APIs. But the tradeoffs here are somewhat subtle: sometimes people switch to async I/O, and then they&amp;rsquo;re surprised and confused when they find it doesn&amp;rsquo;t speed up their program. The next section explains the theory behind async file I/O, to help you better understand your code&amp;rsquo;s behavior. Or, if you just want to get started, you can &lt;a href=&quot;#async-file-io-overview&quot;&gt;jump down to the API overview&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74425cde00c0b01b295243623ba0bba1679d9dc5" translate="yes" xml:space="preserve">
          <source>Trio provides built-in facilities for performing asynchronous filesystem operations like reading or renaming a file. Generally, we recommend that you use these instead of Python&amp;rsquo;s normal synchronous file APIs. But the tradeoffs here are somewhat subtle: sometimes people switch to async I/O, and then they&amp;rsquo;re surprised and confused when they find it doesn&amp;rsquo;t speed up their program. The next section explains the theory behind async file I/O, to help you better understand your code&amp;rsquo;s behavior. Or, if you just want to get started, you can &lt;a href=&quot;ref:async-file-io-overview&quot;&gt;jump down to the API overview&lt;/a&gt;.</source>
          <target state="translated">Trio proporciona funciones integradas para realizar operaciones asincr&amp;oacute;nicas del sistema de archivos, como leer o cambiar el nombre de un archivo. Generalmente, le recomendamos que utilice estos en lugar de las API de archivos s&amp;iacute;ncronos normales de Python. Pero las compensaciones aqu&amp;iacute; son algo sutiles: a veces las personas cambian a E / S as&amp;iacute;ncronas y luego se sorprenden y confunden cuando descubren que no acelera su programa. La siguiente secci&amp;oacute;n explica la teor&amp;iacute;a detr&amp;aacute;s de la E / S de archivos as&amp;iacute;ncronos, para ayudarlo a comprender mejor el comportamiento de su c&amp;oacute;digo. O, si solo desea comenzar, puede &lt;a href=&quot;ref:async-file-io-overview&quot;&gt;saltar a la descripci&amp;oacute;n general de la API&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d95788f65d0c3c8483b4904e8ba1a027a20a92c4" translate="yes" xml:space="preserve">
          <source>Trio provides support for spawning other programs as subprocesses, communicating with them via pipes, sending them signals, and waiting for them to exit. The interface for doing so consists of two layers:</source>
          <target state="translated">Trio proporciona apoyo para engendrar otros programas como subprocesos,comunicándose con ellos a través de tuberías,enviándoles señales y esperando a que salgan.La interfaz para hacerlo consiste en dos capas:</target>
        </trans-unit>
        <trans-unit id="e3e4c4f0590113b206fe27748965cb6ce85a583a" translate="yes" xml:space="preserve">
          <source>Trio socket objects are overall very similar to the &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket-objects&quot;&gt;standard library socket objects&lt;/a&gt;, with a few important differences:</source>
          <target state="translated">Los objetos de socket tr&amp;iacute;o son en general muy similares a los &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket-objects&quot;&gt;objetos de socket de biblioteca est&amp;aacute;ndar&lt;/a&gt; , con algunas diferencias importantes:</target>
        </trans-unit>
        <trans-unit id="84bf9c00f2f5bbffc7ee9b46d763db2cc451107c" translate="yes" xml:space="preserve">
          <source>Trio supports async generators, with some caveats described in this section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bb057fa930f31cd5b5ad52664f8b9bd7e4a82d9" translate="yes" xml:space="preserve">
          <source>Trio tokens</source>
          <target state="translated">Fichas de trío</target>
        </trans-unit>
        <trans-unit id="5d408b00bf8df0f0790a83ccf1901d19c622725e" translate="yes" xml:space="preserve">
          <source>Trio tries hard to provide useful hooks for debugging and instrumentation. Some are documented above (the nursery introspection attributes, &lt;a href=&quot;reference-core#trio.Lock.statistics&quot;&gt;&lt;code&gt;trio.Lock.statistics()&lt;/code&gt;&lt;/a&gt;, etc.). Here are some more.</source>
          <target state="translated">Trio se esfuerza por proporcionar enlaces &amp;uacute;tiles para la depuraci&amp;oacute;n y la instrumentaci&amp;oacute;n. Algunos est&amp;aacute;n documentados anteriormente (los atributos de introspecci&amp;oacute;n de la guarder&amp;iacute;a, &lt;a href=&quot;reference-core#trio.Lock.statistics&quot;&gt; &lt;code&gt;trio.Lock.statistics()&lt;/code&gt; &lt;/a&gt; , etc.). Aqu&amp;iacute; hay algunos m&amp;aacute;s.</target>
        </trans-unit>
        <trans-unit id="a095b9420b975351418baa59d47d28cab0b88e9d" translate="yes" xml:space="preserve">
          <source>Trio was built from the ground up to take advantage of the &lt;a href=&quot;https://www.python.org/dev/peps/pep-0492/&quot;&gt;latest Python features&lt;/a&gt;, and draws inspiration from &lt;a href=&quot;https://github.com/python-trio/trio/wiki/Reading-list&quot;&gt;many sources&lt;/a&gt;, in particular Dave Beazley&amp;rsquo;s &lt;a href=&quot;https://curio.readthedocs.io/&quot;&gt;Curio&lt;/a&gt;. The resulting design is radically simpler than older competitors like &lt;a href=&quot;https://docs.python.org/3/library/asyncio.html&quot;&gt;asyncio&lt;/a&gt; and &lt;a href=&quot;https://twistedmatrix.com/&quot;&gt;Twisted&lt;/a&gt;, yet just as capable. Trio is the Python I/O library I always wanted; I find it makes building I/O-oriented programs easier, less error-prone, and just plain more fun. Perhaps you&amp;rsquo;ll find the same.</source>
          <target state="translated">Trio se cre&amp;oacute; desde cero para aprovechar las &lt;a href=&quot;https://www.python.org/dev/peps/pep-0492/&quot;&gt;&amp;uacute;ltimas funciones de Python&lt;/a&gt; y se inspira en &lt;a href=&quot;https://github.com/python-trio/trio/wiki/Reading-list&quot;&gt;muchas fuentes&lt;/a&gt; , en particular, &lt;a href=&quot;https://curio.readthedocs.io/&quot;&gt;Curio de&lt;/a&gt; Dave Beazley . El dise&amp;ntilde;o resultante es radicalmente m&amp;aacute;s simple que el de competidores m&amp;aacute;s antiguos como &lt;a href=&quot;https://docs.python.org/3/library/asyncio.html&quot;&gt;asyncio&lt;/a&gt; y &lt;a href=&quot;https://twistedmatrix.com/&quot;&gt;Twisted&lt;/a&gt; , pero igualmente capaz. Trio es la biblioteca de E / S de Python que siempre quise; Creo que hace que la creaci&amp;oacute;n de programas orientados a E / S sea m&amp;aacute;s f&amp;aacute;cil, menos propensa a errores y simplemente m&amp;aacute;s divertida. Quiz&amp;aacute;s encuentres lo mismo.</target>
        </trans-unit>
        <trans-unit id="c846abd10c13fb3992cae8ffb8e6074c68f407e6" translate="yes" xml:space="preserve">
          <source>Trio&amp;rsquo;s answer is that it raises a &lt;a href=&quot;#trio.MultiError&quot;&gt;&lt;code&gt;MultiError&lt;/code&gt;&lt;/a&gt; object. This is a special exception which encapsulates multiple exception objects &amp;ndash; either regular exceptions or nested &lt;a href=&quot;#trio.MultiError&quot;&gt;&lt;code&gt;MultiError&lt;/code&gt;&lt;/a&gt;s. To make these easier to work with, Trio installs a custom &lt;a href=&quot;https://docs.python.org/3/library/sys.html#sys.excepthook&quot;&gt;&lt;code&gt;sys.excepthook&lt;/code&gt;&lt;/a&gt; that knows how to print nice tracebacks for unhandled &lt;a href=&quot;#trio.MultiError&quot;&gt;&lt;code&gt;MultiError&lt;/code&gt;&lt;/a&gt;s, and it also provides some helpful utilities like &lt;a href=&quot;#trio.MultiError.catch&quot;&gt;&lt;code&gt;MultiError.catch()&lt;/code&gt;&lt;/a&gt;, which allows you to catch &amp;ldquo;part of&amp;rdquo; a &lt;a href=&quot;#trio.MultiError&quot;&gt;&lt;code&gt;MultiError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La respuesta de Trio es que genera un objeto &lt;a href=&quot;#trio.MultiError&quot;&gt; &lt;code&gt;MultiError&lt;/code&gt; &lt;/a&gt; . Esta es una excepci&amp;oacute;n especial que encapsula m&amp;uacute;ltiples objetos de excepci&amp;oacute;n, ya sean excepciones regulares o &lt;a href=&quot;#trio.MultiError&quot;&gt; &lt;code&gt;MultiError&lt;/code&gt; &lt;/a&gt; s anidados . Para que sea m&amp;aacute;s f&amp;aacute;cil trabajar con ellos, Trio instala un &lt;a href=&quot;https://docs.python.org/3/library/sys.html#sys.excepthook&quot;&gt; &lt;code&gt;sys.excepthook&lt;/code&gt; &lt;/a&gt; personalizado que sabe c&amp;oacute;mo imprimir &lt;a href=&quot;#trio.MultiError&quot;&gt; &lt;code&gt;MultiError&lt;/code&gt; &lt;/a&gt; agradables para MultiError s no manejados , y tambi&amp;eacute;n proporciona algunas utilidades &amp;uacute;tiles como &lt;a href=&quot;#trio.MultiError.catch&quot;&gt; &lt;code&gt;MultiError.catch()&lt;/code&gt; &lt;/a&gt; , que le permite capturar &quot;parte de&quot; un &lt;a href=&quot;#trio.MultiError&quot;&gt; &lt;code&gt;MultiError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6d2b9708cc5b4a0aa94a8cbf018536b856ae4ed6" translate="yes" xml:space="preserve">
          <source>Trio&amp;rsquo;s asynchronous file objects have an interface that automatically adapts to the object being wrapped. Intuitively, you can mostly treat them like a regular &lt;a href=&quot;https://docs.python.org/3/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;, except adding an &lt;code&gt;await&lt;/code&gt; in front of any of methods that do I/O. The definition of &lt;a href=&quot;https://docs.python.org/3/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt; is a little vague in Python though, so here are the details:</source>
          <target state="translated">Los objetos de archivo asincr&amp;oacute;nicos de Trio tienen una interfaz que se adapta autom&amp;aacute;ticamente al objeto que se envuelve. Intuitivamente, puede tratarlos principalmente como un &lt;a href=&quot;https://docs.python.org/3/glossary.html#term-file-object&quot;&gt;objeto de archivo&lt;/a&gt; normal , excepto que agrega un &lt;code&gt;await&lt;/code&gt; delante de cualquiera de los m&amp;eacute;todos que realizan E / S. Sin embargo, la definici&amp;oacute;n de &lt;a href=&quot;https://docs.python.org/3/glossary.html#term-file-object&quot;&gt;objeto&lt;/a&gt; de archivo es un poco vaga en Python, as&amp;iacute; que aqu&amp;iacute; est&amp;aacute;n los detalles:</target>
        </trans-unit>
        <trans-unit id="e1395e9cde88f70c434acca97212f29b2fa46091" translate="yes" xml:space="preserve">
          <source>Trio&amp;rsquo;s core functionality</source>
          <target state="translated">La funcionalidad principal de Trio</target>
        </trans-unit>
        <trans-unit id="f97e2b82c90599d9b44281129e282e3a9dda83cd" translate="yes" xml:space="preserve">
          <source>Trio&amp;rsquo;s handling of control-C is designed to balance usability and safety. On the one hand, there are sensitive regions (like the core scheduling loop) where it&amp;rsquo;s simply impossible to handle arbitrary &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; exceptions while maintaining our core correctness invariants. On the other, if the user accidentally writes an infinite loop, we do want to be able to break out of that. Our solution is to install a default signal handler which checks whether it&amp;rsquo;s safe to raise &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; at the place where the signal is received. If so, then we do; otherwise, we schedule a &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; to be delivered to the main task at the next available opportunity (similar to how &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; is delivered).</source>
          <target state="translated">El manejo de control-C de Trio est&amp;aacute; dise&amp;ntilde;ado para equilibrar la usabilidad y la seguridad. Por un lado, hay regiones sensibles (como el bucle de programaci&amp;oacute;n central) donde es simplemente imposible manejar excepciones arbitrarias de &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; mientras se mantienen nuestras invariantes de correcci&amp;oacute;n central. Por otro lado, si el usuario escribe accidentalmente un bucle infinito, queremos poder salir de eso. Nuestra soluci&amp;oacute;n es instalar un controlador de se&amp;ntilde;al predeterminado que verifica si es seguro activar &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; en el lugar donde se recibe la se&amp;ntilde;al. Si es as&amp;iacute;, lo hacemos; de lo contrario, programamos &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; para que se entregue a la tarea principal en la pr&amp;oacute;xima oportunidad disponible (similar a c&amp;oacute;mo se entrega &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e4de41bd04af3ba5cdbb7231b08e1a1e6c3fe88c" translate="yes" xml:space="preserve">
          <source>Trio&amp;rsquo;s philosophy about managing worker threads</source>
          <target state="translated">Filosof&amp;iacute;a de Trio sobre la gesti&amp;oacute;n de hilos de trabajo</target>
        </trans-unit>
        <trans-unit id="0a05358999edb18564ef080ed20cf4c015b3b0fb" translate="yes" xml:space="preserve">
          <source>Trio&amp;rsquo;s solution to this problem is to split worker thread management into two layers. The lower layer is responsible for taking blocking I/O jobs and arranging for them to run immediately on some worker thread. It takes care of solving the tricky concurrency problems involved in managing threads and is responsible for optimizations like re-using threads, but has no admission control policy: if you give it 100,000 jobs, it will spawn 100,000 threads. The upper layer is responsible for providing the policy to make sure that this doesn&amp;rsquo;t happen &amp;ndash; but since it &lt;em&gt;only&lt;/em&gt; has to worry about policy, it can be much simpler. In fact, all there is to it is the &lt;code&gt;limiter=&lt;/code&gt; argument passed to &lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt;&lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt;&lt;/a&gt;. This defaults to a global &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt;&lt;code&gt;CapacityLimiter&lt;/code&gt;&lt;/a&gt; object, which gives us the classic fixed-size thread pool behavior. (See &lt;a href=&quot;#trio.to_thread.current_default_thread_limiter&quot;&gt;&lt;code&gt;trio.to_thread.current_default_thread_limiter()&lt;/code&gt;&lt;/a&gt;.) But if you want to use &amp;ldquo;separate pools&amp;rdquo; for type A jobs and type B jobs, then it&amp;rsquo;s just a matter of creating two separate &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt;&lt;code&gt;CapacityLimiter&lt;/code&gt;&lt;/a&gt; objects and passing them in when running these jobs. Or here&amp;rsquo;s an example of defining a custom policy that respects the global thread limit, while making sure that no individual user can use more than 3 threads at a time:</source>
          <target state="translated">La soluci&amp;oacute;n de Trio a este problema es dividir la gesti&amp;oacute;n de subprocesos de los trabajadores en dos capas. La capa inferior es responsable de tomar los trabajos de E / S de bloqueo y organizarlos para que se ejecuten inmediatamente en alg&amp;uacute;n hilo de trabajo. Se encarga de resolver los complicados problemas de concurrencia involucrados en la gesti&amp;oacute;n de subprocesos y es responsable de optimizaciones como reutilizar subprocesos, pero no tiene una pol&amp;iacute;tica de control de admisi&amp;oacute;n: si le da 100,000 trabajos, generar&amp;aacute; 100,000 subprocesos. La capa superior es responsable de proporcionar la pol&amp;iacute;tica para asegurarse de que esto no suceda, pero como &lt;em&gt;solo&lt;/em&gt; tiene que preocuparse por la pol&amp;iacute;tica, puede ser mucho m&amp;aacute;s simple. De hecho, todo lo que hay que hacer es el argumento &lt;code&gt;limiter=&lt;/code&gt; pasado a &lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt; &lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt; &lt;/a&gt; . Este valor predeterminado es un &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt; &lt;code&gt;CapacityLimiter&lt;/code&gt; &lt;/a&gt; globalobject, que nos da el comportamiento cl&amp;aacute;sico de grupo de subprocesos de tama&amp;ntilde;o fijo. (Consulte &lt;a href=&quot;#trio.to_thread.current_default_thread_limiter&quot;&gt; &lt;code&gt;trio.to_thread.current_default_thread_limiter()&lt;/code&gt; &lt;/a&gt; . Pero si desea utilizar &amp;ldquo;grupos separados&amp;rdquo; para trabajos de tipo A y trabajos de tipo B, entonces es solo cuesti&amp;oacute;n de crear dos objetos &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt; &lt;code&gt;CapacityLimiter&lt;/code&gt; &lt;/a&gt; separados y pasarlos al ejecutar estos trabajos. O aqu&amp;iacute; hay un ejemplo de c&amp;oacute;mo definir una pol&amp;iacute;tica personalizada que respete el l&amp;iacute;mite de subprocesos global, mientras se asegura de que ning&amp;uacute;n usuario individual pueda usar m&amp;aacute;s de 3 subprocesos a la vez:</target>
        </trans-unit>
        <trans-unit id="6bc59e1ec96bc7a2423dbce69311bcfd506df149" translate="yes" xml:space="preserve">
          <source>Trio's friendly, yet comprehensive, manual:</source>
          <target state="translated">El amigable,pero completo,manual del Trío:</target>
        </trans-unit>
        <trans-unit id="5c8cee31570dc25a817cf56add6f07570a783115" translate="yes" xml:space="preserve">
          <source>Trio/Asyncio Interoperability</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="225f97c8e66d76df4b30a947feaf0534521b0ead" translate="yes" xml:space="preserve">
          <source>Trio: a friendly Python library for async concurrency and I/O</source>
          <target state="translated">Trío:una amigable biblioteca de Python para la concurrencia y E/S de la sincronización.</target>
        </trans-unit>
        <trans-unit id="6f3b7a2bab0ca1f9fc7290da3cd87c32228ed36b" translate="yes" xml:space="preserve">
          <source>Trio’s core functionality</source>
          <target state="translated">La funcionalidad principal del Trío</target>
        </trans-unit>
        <trans-unit id="decf96be2aaef9ab02814ffa8c9f5b6de6f3b8d6" translate="yes" xml:space="preserve">
          <source>True if it successfully transferred some data, or False if there was no data to transfer.</source>
          <target state="translated">Verdadero si ha transferido con éxito algunos datos,o falso si no había datos que transferir.</target>
        </trans-unit>
        <trans-unit id="e1aaa899e304fc2f5d29d6e66a76d55ca76bd39e" translate="yes" xml:space="preserve">
          <source>True if protection is enabled, and False otherwise.</source>
          <target state="translated">Cierto si la protección está activada,y falso en caso contrario.</target>
        </trans-unit>
        <trans-unit id="93add99f412693bb50177e85ca6a9d4948b325c9" translate="yes" xml:space="preserve">
          <source>True if successful, False otherwise.</source>
          <target state="translated">Verdadero si tiene éxito,falso si no.</target>
        </trans-unit>
        <trans-unit id="5d3e9a7a494f653bcacd93456806581953a79027" translate="yes" xml:space="preserve">
          <source>True if the lock is held, False otherwise.</source>
          <target state="translated">Cierto si la cerradura se mantiene,falso si no.</target>
        </trans-unit>
        <trans-unit id="6abc79262de514fd9235a1f0c1f891c91c282949" translate="yes" xml:space="preserve">
          <source>True if the path is absolute (has both a root and, if applicable, a drive).</source>
          <target state="translated">Cierto si el camino es absoluto (tiene tanto una raíz como,en su caso,una unidad).</target>
        </trans-unit>
        <trans-unit id="2701a94c0eb55cbd958a87dff3e959673ff1bf53" translate="yes" xml:space="preserve">
          <source>Tutorial</source>
          <target state="translated">Tutorial</target>
        </trans-unit>
        <trans-unit id="8a1c6f031eca837815e374433e41a167d90dbfd8" translate="yes" xml:space="preserve">
          <source>Tutorial and reference manual: &lt;a href=&quot;https://trio.readthedocs.io&quot;&gt;https://trio.readthedocs.io&lt;/a&gt;</source>
          <target state="translated">Tutorial y manual de referencia: &lt;a href=&quot;https://trio.readthedocs.io&quot;&gt;https://trio.readthedocs.io&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="77dea2038e0265d1f2267dbda249ea9a80220f2c" translate="yes" xml:space="preserve">
          <source>Typically used together with &lt;a href=&quot;#trio.hazmat.cancel_shielded_checkpoint&quot;&gt;&lt;code&gt;cancel_shielded_checkpoint()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Normalmente se usa junto con &lt;a href=&quot;#trio.hazmat.cancel_shielded_checkpoint&quot;&gt; &lt;code&gt;cancel_shielded_checkpoint()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c6a8397644a2a504c2f5bfe44f54b8ce6f92561d" translate="yes" xml:space="preserve">
          <source>Typically used together with &lt;a href=&quot;#trio.lowlevel.cancel_shielded_checkpoint&quot;&gt;&lt;code&gt;cancel_shielded_checkpoint()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa6eb3e4b993dc224b732f0acd5cb818c8f6aedb" translate="yes" xml:space="preserve">
          <source>Unfortunately, if you get this error it also means that all bets are off &amp;ndash; Trio doesn&amp;rsquo;t know what is going on and its normal invariants may be void. (For example, we might have &amp;ldquo;lost track&amp;rdquo; of a task. Or lost track of all tasks.) Again, though, this shouldn&amp;rsquo;t happen.</source>
          <target state="translated">Desafortunadamente, si recibe este error, tambi&amp;eacute;n significa que todas las apuestas est&amp;aacute;n canceladas: Trio no sabe qu&amp;eacute; est&amp;aacute; sucediendo y sus invariantes normales pueden anularse. (Por ejemplo, podr&amp;iacute;amos haber &amp;ldquo;perdido el rastro&amp;rdquo; de una tarea. O perdido el rastro de todas las tareas). Sin embargo, esto no deber&amp;iacute;a suceder nuevamente.</target>
        </trans-unit>
        <trans-unit id="ae8e0648b8830f351c3d504a2a43201c939ebb97" translate="yes" xml:space="preserve">
          <source>Universally available API</source>
          <target state="translated">API disponible universalmente</target>
        </trans-unit>
        <trans-unit id="709023972b44e1b7a1cb1b4210e5acf432bebfd7" translate="yes" xml:space="preserve">
          <source>Unix-specific API</source>
          <target state="translated">API específico de Unix</target>
        </trans-unit>
        <trans-unit id="40df8d956184a9840bf6af7b2386e17feff526a8" translate="yes" xml:space="preserve">
          <source>Unless you or your host loop register a handler for &lt;a href=&quot;https://docs.python.org/3/library/signal.html#signal.SIGINT&quot;&gt;&lt;code&gt;signal.SIGINT&lt;/code&gt;&lt;/a&gt; before starting Trio (this is not common), then Trio will take over delivery of &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt;s. And since Trio can&amp;rsquo;t tell which host code is safe to interrupt, it will only deliver &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; into the Trio part of your code. This is fine if your program is set up to exit when the Trio part exits, because the &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; will propagate out of Trio and then trigger the shutdown of your host loop, which is just what you want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd09f3d61db7509d67bc57b83a3b0437c598cc43" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket&quot;&gt;&lt;code&gt;socket.socket()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.socket.socket&quot;&gt;&lt;code&gt;trio.socket.socket()&lt;/code&gt;&lt;/a&gt; is a function, not a class; if you want to check whether an object is a Trio socket, use &lt;code&gt;isinstance(obj, trio.socket.SocketType)&lt;/code&gt;.</source>
          <target state="translated">A diferencia de &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket&quot;&gt; &lt;code&gt;socket.socket()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#trio.socket.socket&quot;&gt; &lt;code&gt;trio.socket.socket()&lt;/code&gt; &lt;/a&gt; es una funci&amp;oacute;n, no una clase; si desea verificar si un objeto es un socket Trio, use &lt;code&gt;isinstance(obj, trio.socket.SocketType)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f85d0717922d015ead8412878c3437596480edc5" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Event&quot;&gt;&lt;code&gt;threading.Event&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.Event&quot;&gt;&lt;code&gt;trio.Event&lt;/code&gt;&lt;/a&gt; has no &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Event.clear&quot;&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/a&gt; method. In Trio, once an &lt;a href=&quot;#trio.Event&quot;&gt;&lt;code&gt;Event&lt;/code&gt;&lt;/a&gt; has happened, it cannot un-happen. If you need to represent a series of events, consider creating a new &lt;a href=&quot;#trio.Event&quot;&gt;&lt;code&gt;Event&lt;/code&gt;&lt;/a&gt; object for each one (they&amp;rsquo;re cheap!), or other synchronization methods like &lt;a href=&quot;#channels&quot;&gt;channels&lt;/a&gt; or &lt;a href=&quot;reference-hazmat#trio.hazmat.ParkingLot&quot;&gt;&lt;code&gt;trio.hazmat.ParkingLot&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">A diferencia de &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Event&quot;&gt; &lt;code&gt;threading.Event&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#trio.Event&quot;&gt; &lt;code&gt;trio.Event&lt;/code&gt; &lt;/a&gt; no tiene &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Event.clear&quot;&gt; &lt;code&gt;clear&lt;/code&gt; &lt;/a&gt; m&amp;eacute;todo claro . En Trio, una vez que ha ocurrido un &lt;a href=&quot;#trio.Event&quot;&gt; &lt;code&gt;Event&lt;/code&gt; &lt;/a&gt; , no puede volver a suceder. Si necesita representar una serie de eventos, considere la posibilidad de crear un nuevo objeto de &lt;a href=&quot;#trio.Event&quot;&gt; &lt;code&gt;Event&lt;/code&gt; &lt;/a&gt; para cada uno (&amp;iexcl;son baratos!), &lt;a href=&quot;reference-hazmat#trio.hazmat.ParkingLot&quot;&gt; &lt;code&gt;trio.hazmat.ParkingLot&lt;/code&gt; &lt;/a&gt; otros m&amp;eacute;todos de sincronizaci&amp;oacute;n como &lt;a href=&quot;#channels&quot;&gt;canales&lt;/a&gt; o trio.hazmat.ParkingLot .</target>
        </trans-unit>
        <trans-unit id="127bfa4878966712bb206326fd8368f4fcdc500a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Event&quot;&gt;&lt;code&gt;threading.Event&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.Event&quot;&gt;&lt;code&gt;trio.Event&lt;/code&gt;&lt;/a&gt; has no &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Event.clear&quot;&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/a&gt; method. In Trio, once an &lt;a href=&quot;#trio.Event&quot;&gt;&lt;code&gt;Event&lt;/code&gt;&lt;/a&gt; has happened, it cannot un-happen. If you need to represent a series of events, consider creating a new &lt;a href=&quot;#trio.Event&quot;&gt;&lt;code&gt;Event&lt;/code&gt;&lt;/a&gt; object for each one (they&amp;rsquo;re cheap!), or other synchronization methods like &lt;a href=&quot;#channels&quot;&gt;channels&lt;/a&gt; or &lt;a href=&quot;reference-lowlevel#trio.lowlevel.ParkingLot&quot;&gt;&lt;code&gt;trio.lowlevel.ParkingLot&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a64c6f580176add0dfe9ddbc8c9e0573a09c05cf" translate="yes" xml:space="preserve">
          <source>Unlike the standard library &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen.returncode&quot;&gt;&lt;code&gt;subprocess.Popen.returncode&lt;/code&gt;&lt;/a&gt;, you don&amp;rsquo;t have to call &lt;a href=&quot;#trio.Process.poll&quot;&gt;&lt;code&gt;poll&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#trio.Process.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; to update this attribute; it&amp;rsquo;s automatically updated as needed, and will always give you the latest information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="781f24017834bea0e61621255956f2c4b4ca2937" translate="yes" xml:space="preserve">
          <source>Unpark all parked tasks.</source>
          <target state="translated">Desaparece todas las tareas estacionadas.</target>
        </trans-unit>
        <trans-unit id="88158b6332d62d5ea301e652e89647b83fdbf667" translate="yes" xml:space="preserve">
          <source>Unpark one or more tasks.</source>
          <target state="translated">Desaparece una o más tareas.</target>
        </trans-unit>
        <trans-unit id="2556360321b2463e70e36fbd809cecceda61b54b" translate="yes" xml:space="preserve">
          <source>Use as a context manager to check that the code inside the &lt;code&gt;with&lt;/code&gt; block does not execute any &lt;a href=&quot;reference-core#checkpoints&quot;&gt;checkpoints&lt;/a&gt;.</source>
          <target state="translated">&amp;Uacute;selo como administrador de contexto para verificar que el c&amp;oacute;digo dentro del bloque &lt;code&gt;with&lt;/code&gt; no ejecuta ning&amp;uacute;n &lt;a href=&quot;reference-core#checkpoints&quot;&gt;punto de control&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b0d3eb180f053e32850213c6f7a3574f4f4119ea" translate="yes" xml:space="preserve">
          <source>Use as a context manager to check that the code inside the &lt;code&gt;with&lt;/code&gt; block either exits with an exception or executes at least one &lt;a href=&quot;reference-core#checkpoints&quot;&gt;checkpoint&lt;/a&gt;.</source>
          <target state="translated">Su uso como un gestor de contexto para comprobar que el c&amp;oacute;digo dentro del &lt;code&gt;with&lt;/code&gt; bloque de salidas, ya sea con una excepci&amp;oacute;n o se ejecuta al menos un &lt;a href=&quot;reference-core#checkpoints&quot;&gt;puesto de control&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="166059dea2ea131ea488e69911b917c400be45fd" translate="yes" xml:space="preserve">
          <source>Use as a context manager to create a cancel scope whose deadline is set to now + &lt;em&gt;seconds&lt;/em&gt;.</source>
          <target state="translated">&amp;Uacute;selo como administrador de contexto para crear un alcance de cancelaci&amp;oacute;n cuya fecha l&amp;iacute;mite se establece en ahora + &lt;em&gt;segundos&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3b93de5e82243cb860a3e551a41a4080f9d46f3f" translate="yes" xml:space="preserve">
          <source>Use as a context manager to create a cancel scope with the given absolute deadline.</source>
          <target state="translated">Usar como gestor de contexto para crear un ámbito de cancelación con el plazo absoluto dado.</target>
        </trans-unit>
        <trans-unit id="608e328e68b84e87a64ebe10cd8d5e7d48c917ff" translate="yes" xml:space="preserve">
          <source>User-level API principles</source>
          <target state="translated">Principios de la API a nivel de usuario</target>
        </trans-unit>
        <trans-unit id="3704428b315819383f29b5bf2ccb66cdd3c1af2f" translate="yes" xml:space="preserve">
          <source>Using &amp;ldquo;guest mode&amp;rdquo; to run Trio on top of other event loops</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21c61f26a2c50aee6d1c26b200a21f0e6eaa1d40" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#module-trio.hazmat&quot;&gt;&lt;code&gt;trio.hazmat&lt;/code&gt;&lt;/a&gt; isn&amp;rsquo;t really &lt;em&gt;that&lt;/em&gt; hazardous; in fact you&amp;rsquo;re already using it &amp;ndash; it&amp;rsquo;s how most of the functionality described in previous chapters is implemented. The APIs described here have strictly defined and carefully documented semantics, and are perfectly safe &amp;ndash; &lt;em&gt;if&lt;/em&gt; you read carefully and take proper precautions. Some of those strict semantics have &lt;a href=&quot;https://en.wikipedia.org/wiki/Rabbit_of_Caerbannog&quot;&gt;nasty big pointy teeth&lt;/a&gt;. If you make a mistake, Trio may not be able to handle it gracefully; conventions and guarantees that are followed strictly in the rest of Trio do not always apply. Using this module makes it your responsibility to think through and handle the nasty cases to expose a friendly Trio-style API to your users.</source>
          <target state="translated">Usar &lt;a href=&quot;#module-trio.hazmat&quot;&gt; &lt;code&gt;trio.hazmat&lt;/code&gt; &lt;/a&gt; no es realmente &lt;em&gt;tan&lt;/em&gt; peligroso; de hecho, ya lo est&amp;aacute; utilizando; as&amp;iacute; es como se implementa la mayor parte de la funcionalidad descrita en cap&amp;iacute;tulos anteriores. Las API descritas aqu&amp;iacute; tienen una sem&amp;aacute;ntica estrictamente definida y cuidadosamente documentada, y son perfectamente seguras, &lt;em&gt;si&lt;/em&gt; lee con atenci&amp;oacute;n y toma las precauciones adecuadas. Algunas de esas sem&amp;aacute;nticas estrictas tienen &lt;a href=&quot;https://en.wikipedia.org/wiki/Rabbit_of_Caerbannog&quot;&gt;desagradables grandes dientes puntiagudos&lt;/a&gt; . Si comete un error, es posible que Trio no pueda manejarlo con elegancia; Las convenciones y garant&amp;iacute;as que se siguen estrictamente en el resto de Trio no siempre se aplican. El uso de este m&amp;oacute;dulo hace que sea su responsabilidad pensar y manejar los casos desagradables para exponer una API amigable al estilo Trio a sus usuarios.</target>
        </trans-unit>
        <trans-unit id="3cdd95a79dc24452bdfe3ab4e7974ec8b5066bb0" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;with receive_channel:&lt;/code&gt; will close the channel object on leaving the with block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3e3eebd6130f775ef0cb1dc84296c616efc3570" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;with send_channel:&lt;/code&gt; will close the channel object on leaving the with block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b513f360a782387f728539080c7a02c20167250" translate="yes" xml:space="preserve">
          <source>Using channels to pass values between tasks</source>
          <target state="translated">Usar canales para pasar valores entre tareas</target>
        </trans-unit>
        <trans-unit id="fa493b12215c35c7f93080081bf1f16fbdb17efc" translate="yes" xml:space="preserve">
          <source>Using the same async file object from multiple tasks simultaneously: because the async methods on async file objects are implemented using threads, it&amp;rsquo;s only safe to call two of them at the same time from different tasks IF the underlying synchronous file object is thread-safe. You should consult the documentation for the object you&amp;rsquo;re wrapping. For objects returned from &lt;a href=&quot;#trio.open_file&quot;&gt;&lt;code&gt;trio.open_file()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#trio.Path.open&quot;&gt;&lt;code&gt;trio.Path.open()&lt;/code&gt;&lt;/a&gt;, it depends on whether you open the file in binary mode or text mode: &lt;a href=&quot;https://docs.python.org/3/library/io.html#multi-threading&quot;&gt;binary mode files are task-safe/thread-safe, text mode files are not&lt;/a&gt;.</source>
          <target state="translated">Usar el mismo objeto de archivo as&amp;iacute;ncrono de varias tareas simult&amp;aacute;neamente: debido a que los m&amp;eacute;todos as&amp;iacute;ncronos en objetos de archivo as&amp;iacute;ncrono se implementan mediante subprocesos, solo es seguro llamar a dos de ellos al mismo tiempo desde diferentes tareas SI el objeto de archivo s&amp;iacute;ncrono subyacente es seguro para subprocesos. Debe consultar la documentaci&amp;oacute;n del objeto que est&amp;aacute; envolviendo. Para los objetos devueltos desde &lt;a href=&quot;#trio.open_file&quot;&gt; &lt;code&gt;trio.open_file()&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;#trio.Path.open&quot;&gt; &lt;code&gt;trio.Path.open()&lt;/code&gt; &lt;/a&gt; , depende de si abre el archivo en modo binario o en modo texto: &lt;a href=&quot;https://docs.python.org/3/library/io.html#multi-threading&quot;&gt;los archivos en modo binario son seguros para tareas / seguros para subprocesos, los archivos en modo texto no&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="242accfa507e3192f6b8cb5222ee8bab6d096fde" translate="yes" xml:space="preserve">
          <source>Violating the rule described in this section will sometimes get you a useful error message, but Trio is not able to detect all such cases, so sometimes you&amp;rsquo;ll get an unhelpful &lt;a href=&quot;#trio.TrioInternalError&quot;&gt;&lt;code&gt;TrioInternalError&lt;/code&gt;&lt;/a&gt;. (And sometimes it will seem to work, which is probably the worst outcome of all, since then you might not notice the issue until you perform some minor refactoring of the generator or the code that&amp;rsquo;s iterating it, or just get unlucky. There is a &lt;a href=&quot;https://discuss.python.org/t/preventing-yield-inside-certain-context-managers/1091&quot;&gt;proposed Python enhancement&lt;/a&gt; that would at least make it fail consistently.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daef22f12350658306822e18b3055d487a63aa72" translate="yes" xml:space="preserve">
          <source>Virtual networking for testing</source>
          <target state="translated">Red virtual para la prueba</target>
        </trans-unit>
        <trans-unit id="3fe725b689c13e430fd18699fb2e95efd7595058" translate="yes" xml:space="preserve">
          <source>Virtual, controllable streams</source>
          <target state="translated">Corrientes virtuales y controlables</target>
        </trans-unit>
        <trans-unit id="d4a7534fed721d1a3033c28ee4152b82de5aae0b" translate="yes" xml:space="preserve">
          <source>Vital statistics:</source>
          <target state="translated">Estadísticas vitales:</target>
        </trans-unit>
        <trans-unit id="66bdf7f790161b995fe7eefaa4a5ae688592cf68" translate="yes" xml:space="preserve">
          <source>WWDC 2015: Your App and Next Generation Networks: &lt;a href=&quot;http://devstreaming.apple.com/videos/wwdc/2015/719ui2k57m/719/719_your_app_and_next_generation_networks.pdf?dl=1&quot;&gt;slides&lt;/a&gt;, &lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2015/719/&quot;&gt;video and transcript&lt;/a&gt;</source>
          <target state="translated">WWDC 2015: Su aplicaci&amp;oacute;n y redes de pr&amp;oacute;xima generaci&amp;oacute;n: &lt;a href=&quot;http://devstreaming.apple.com/videos/wwdc/2015/719ui2k57m/719/719_your_app_and_next_generation_networks.pdf?dl=1&quot;&gt;diapositivas&lt;/a&gt; , &lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2015/719/&quot;&gt;video y transcripci&amp;oacute;n&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ee575d9368c52e25aad8feb46a457f7983389a7b" translate="yes" xml:space="preserve">
          <source>Wait for another task to call &lt;a href=&quot;#trio.Condition.notify&quot;&gt;&lt;code&gt;notify()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#trio.Condition.notify_all&quot;&gt;&lt;code&gt;notify_all()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3436440f994f25ba01fc52315e24e50790c1aca2" translate="yes" xml:space="preserve">
          <source>Wait for another thread to call &lt;a href=&quot;#trio.Condition.notify&quot;&gt;&lt;code&gt;notify()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#trio.Condition.notify_all&quot;&gt;&lt;code&gt;notify_all()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Espere a que otro hilo llame a &lt;a href=&quot;#trio.Condition.notify&quot;&gt; &lt;code&gt;notify()&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;#trio.Condition.notify_all&quot;&gt; &lt;code&gt;notify_all()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5ccb97cb75cf101284abbbabebb91973944b50bd" translate="yes" xml:space="preserve">
          <source>Wait for the operating system to notify them that something interesting has happened, like data arriving on a socket or a timeout passing. They do this by invoking a platform-specific &lt;code&gt;sleep_until_something_happens()&lt;/code&gt; system call &amp;ndash; &lt;code&gt;select&lt;/code&gt;, &lt;code&gt;epoll&lt;/code&gt;, &lt;code&gt;kqueue&lt;/code&gt;, &lt;code&gt;GetQueuedCompletionEvents&lt;/code&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c93347a983a68108b3b1f0acbc56ebba40360c7" translate="yes" xml:space="preserve">
          <source>Wait queue abstraction</source>
          <target state="translated">Espera la abstracción de la cola</target>
        </trans-unit>
        <trans-unit id="41913a4464c21572206e30e9131c0a6aee848a95" translate="yes" xml:space="preserve">
          <source>Wait until an incoming connection arrives, and then return it.</source>
          <target state="translated">Espere hasta que llegue una conexión entrante,y luego devuélvala.</target>
        </trans-unit>
        <trans-unit id="b315f5b334c892b158d988c89293b0f0e4c16c38" translate="yes" xml:space="preserve">
          <source>Wait until there is data available on this stream, and then return some of it.</source>
          <target state="translated">Espere hasta que haya datos disponibles en esta corriente,y luego devuelva algunos de ellos.</target>
        </trans-unit>
        <trans-unit id="7de17c3c803ae3d81fa6d8c0519a268cfd929e9e" translate="yes" xml:space="preserve">
          <source>Waits 100 ms before calling &lt;code&gt;accept&lt;/code&gt; again, in hopes that the system will recover.</source>
          <target state="translated">Espera 100 ms antes de volver a llamar a &lt;code&gt;accept&lt;/code&gt; , con la esperanza de que el sistema se recupere.</target>
        </trans-unit>
        <trans-unit id="50ff1ba82f15773a71c03597ce8c1546e55713f2" translate="yes" xml:space="preserve">
          <source>Wake all tasks that are currently blocked in &lt;a href=&quot;#trio.Condition.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Despierta todas las tareas que est&amp;aacute;n actualmente bloqueadas en &lt;a href=&quot;#trio.Condition.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3af26aecfc19665d78b1a885ea21cb73c7a2f9d7" translate="yes" xml:space="preserve">
          <source>Wake one or more tasks that are blocked in &lt;a href=&quot;#trio.Condition.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Despierta una o m&amp;aacute;s tareas que est&amp;aacute;n bloqueadas en &lt;a href=&quot;#trio.Condition.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="370071229bb1fc7e23236287f51125978b32419c" translate="yes" xml:space="preserve">
          <source>Warning emitted if you use deprecated Trio functionality.</source>
          <target state="translated">Advertencia emitida si usas la funcionalidad del Trio desaprovechada.</target>
        </trans-unit>
        <trans-unit id="186f850bb584155f8a72f762be272643970d59bc" translate="yes" xml:space="preserve">
          <source>We also added an &lt;code&gt;async with&lt;/code&gt; to the consumer. This isn&amp;rsquo;t as important, but it can help us catch mistakes or other problems. For example, suppose that the consumer exited early for some reason &amp;ndash; maybe because of a bug. Then the producer would be sending messages into the void, and might get stuck indefinitely. But, if the consumer closes its &lt;code&gt;receive_channel&lt;/code&gt;, then the producer will get a &lt;a href=&quot;#trio.BrokenResourceError&quot;&gt;&lt;code&gt;BrokenResourceError&lt;/code&gt;&lt;/a&gt; to alert it that it should stop sending messages because no-one is listening.</source>
          <target state="translated">Tambi&amp;eacute;n agregamos un &lt;code&gt;async with&lt;/code&gt; al consumidor. Esto no es tan importante, pero puede ayudarnos a detectar errores u otros problemas. Por ejemplo, suponga que el consumidor sali&amp;oacute; temprano por alguna raz&amp;oacute;n, tal vez debido a un error. Entonces, el productor estar&amp;iacute;a enviando mensajes al vac&amp;iacute;o y podr&amp;iacute;a quedarse atascado indefinidamente. Pero, si el consumidor cierra su &lt;code&gt;receive_channel&lt;/code&gt; , el productor obtendr&amp;aacute; un &lt;a href=&quot;#trio.BrokenResourceError&quot;&gt; &lt;code&gt;BrokenResourceError&lt;/code&gt; &lt;/a&gt; para alertarlo de que debe dejar de enviar mensajes porque nadie est&amp;aacute; escuchando.</target>
        </trans-unit>
        <trans-unit id="9a97d4344ecae4164e40e82372a9515a0366cc17" translate="yes" xml:space="preserve">
          <source>We also keep track of an extra bit of state, because it turns out to be useful for &lt;a href=&quot;#trio.SocketStream&quot;&gt;&lt;code&gt;trio.SocketStream&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Tambi&amp;eacute;n realizamos un seguimiento de un poco de estado adicional, porque resulta ser &amp;uacute;til para &lt;a href=&quot;#trio.SocketStream&quot;&gt; &lt;code&gt;trio.SocketStream&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="3a137af56fff2042ca3e86c2acd1f2c56ae90997" translate="yes" xml:space="preserve">
          <source>We also monkey patch &lt;a href=&quot;https://docs.python.org/3/library/traceback.html#traceback.TracebackException&quot;&gt;&lt;code&gt;traceback.TracebackException&lt;/code&gt;&lt;/a&gt; to be able to handle formatting &lt;a href=&quot;#trio.MultiError&quot;&gt;&lt;code&gt;MultiError&lt;/code&gt;&lt;/a&gt;s. This means that anything that formats exception messages like &lt;a href=&quot;https://docs.python.org/3/library/logging.html#module-logging&quot;&gt;&lt;code&gt;logging&lt;/code&gt;&lt;/a&gt; will work out of the box:</source>
          <target state="translated">Tambi&amp;eacute;n mono parche &lt;a href=&quot;https://docs.python.org/3/library/traceback.html#traceback.TracebackException&quot;&gt; &lt;code&gt;traceback.TracebackException&lt;/code&gt; &lt;/a&gt; que seamos capaces de manejar el formato &lt;a href=&quot;#trio.MultiError&quot;&gt; &lt;code&gt;MultiError&lt;/code&gt; &lt;/a&gt; s. Esto significa que todo lo que formatee los mensajes de excepci&amp;oacute;n, como el &lt;a href=&quot;https://docs.python.org/3/library/logging.html#module-logging&quot;&gt; &lt;code&gt;logging&lt;/code&gt; &lt;/a&gt; , funcionar&amp;aacute; de inmediato:</target>
        </trans-unit>
        <trans-unit id="343247e5868406916a376486d6adae4b0f900926" translate="yes" xml:space="preserve">
          <source>We could avoid this by using some complicated bookkeeping to make sure that only the &lt;em&gt;last&lt;/em&gt; producer and the &lt;em&gt;last&lt;/em&gt; consumer close their channel endpoints&amp;hellip; but that would be tiresome and fragile. Fortunately, there&amp;rsquo;s a better way! Here&amp;rsquo;s a fixed version of our program above:</source>
          <target state="translated">Podr&amp;iacute;amos evitar esto utilizando una contabilidad complicada para asegurarnos de que solo el &lt;em&gt;&amp;uacute;ltimo&lt;/em&gt; productor y el &lt;em&gt;&amp;uacute;ltimo&lt;/em&gt; consumidor cierren los puntos finales de su canal ... pero eso ser&amp;iacute;a tedioso y fr&amp;aacute;gil. Afortunadamente, &amp;iexcl;hay una forma mejor! Aqu&amp;iacute; hay una versi&amp;oacute;n fija de nuestro programa anterior:</target>
        </trans-unit>
        <trans-unit id="c6301739491da2a3a7d78787414f0b6feacea46b" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t provide timeout arguments. If you want a timeout, then use a cancel scope.</source>
          <target state="translated">No proporcionamos argumentos de tiempo de espera. Si desea un tiempo de espera, utilice un alcance de cancelaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1a408f02fc2bead2788df0bed4524d5ab6823772" translate="yes" xml:space="preserve">
          <source>We refer to &lt;a href=&quot;#trio.move_on_after&quot;&gt;&lt;code&gt;move_on_after()&lt;/code&gt;&lt;/a&gt; as creating a &amp;ldquo;cancel scope&amp;rdquo;, which contains all the code that runs inside the &lt;code&gt;with&lt;/code&gt; block. If the HTTP request takes more than 30 seconds to run, then it will be cancelled: we&amp;rsquo;ll abort the request and we &lt;em&gt;won&amp;rsquo;t&lt;/em&gt; see &lt;code&gt;result is ...&lt;/code&gt; printed on the console; instead we&amp;rsquo;ll go straight to printing the &lt;code&gt;with block
finished&lt;/code&gt; message.</source>
          <target state="translated">Nos referimos a &lt;a href=&quot;#trio.move_on_after&quot;&gt; &lt;code&gt;move_on_after()&lt;/code&gt; &lt;/a&gt; como la creaci&amp;oacute;n de un &quot;alcance de cancelaci&amp;oacute;n&quot;, que contiene todo el c&amp;oacute;digo que se ejecuta dentro del bloque &lt;code&gt;with&lt;/code&gt; . Si la solicitud HTTP tarda m&amp;aacute;s de 30 segundos en ejecutarse, se cancelar&amp;aacute;: abortaremos la solicitud y &lt;em&gt;no&lt;/em&gt; veremos que el &lt;code&gt;result is ...&lt;/code&gt; impreso en la consola; en su lugar, iremos directamente a imprimir el mensaje &lt;code&gt;with block finished&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f558f9a59ef0139a2cd804b31ab3c5404a02658" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve talked a lot about what happens when an operation is cancelled, and how you need to be prepared for this whenever calling a cancellable operation&amp;hellip; but we haven&amp;rsquo;t gone into the details about which operations are cancellable, and how exactly they behave when they&amp;rsquo;re cancelled.</source>
          <target state="translated">Hemos hablado mucho sobre lo que sucede cuando se cancela una operaci&amp;oacute;n y c&amp;oacute;mo debe estar preparado para esto cada vez que llama a una operaci&amp;oacute;n cancelable ... pero no hemos entrado en detalles sobre qu&amp;eacute; operaciones se pueden cancelar y c&amp;oacute;mo se comportan exactamente. cuando se cancelan.</target>
        </trans-unit>
        <trans-unit id="991ef6d2da9180f69d7985da97799558bc5635c1" translate="yes" xml:space="preserve">
          <source>Web and HTML</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bef9db76111ae54eb0dfb86dd904a54acc62f1fd" translate="yes" xml:space="preserve">
          <source>What happens if the user hits control-C while &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; is running? If this argument is False (the default), then you get the standard Python behavior: a &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; exception will immediately interrupt whatever task is running (or if no task is running, then Trio will wake up a task to be interrupted). Alternatively, if you set this argument to True, then &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; delivery will be delayed: it will be &lt;em&gt;only&lt;/em&gt; be raised at &lt;a href=&quot;#checkpoints&quot;&gt;checkpoints&lt;/a&gt;, like a &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; sucede si el usuario pulsa control-C mientras se &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; ? Si este argumento es Falso (el valor predeterminado), entonces obtiene el comportamiento est&amp;aacute;ndar de Python: una excepci&amp;oacute;n &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; interrumpir&amp;aacute; inmediatamente cualquier tarea que se est&amp;eacute; ejecutando (o si no se est&amp;aacute; ejecutando ninguna tarea, Trio activar&amp;aacute; una tarea para ser interrumpida). Alternativamente, si se establece este argumento True, &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; entrega se retrasar&amp;aacute;: ser&amp;aacute; &lt;em&gt;solamente&lt;/em&gt; se plantear&amp;aacute; en &lt;a href=&quot;#checkpoints&quot;&gt;los puestos de control&lt;/a&gt; , como un &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; excepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="60fac7efcca9c565bad833f50e1477967aff7c88" translate="yes" xml:space="preserve">
          <source>What is &amp;ldquo;guest mode&amp;rdquo;?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b238710fedc1b59473f2e5d0f608a1b6a710f67" translate="yes" xml:space="preserve">
          <source>Whatever &lt;code&gt;afn(*args)&lt;/code&gt; returns.</source>
          <target state="translated">Lo que sea que &lt;code&gt;afn(*args)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="266ea61e53a70acfd1db0b04d0327c318baacbd6" translate="yes" xml:space="preserve">
          <source>Whatever &lt;code&gt;async_fn&lt;/code&gt; returns.</source>
          <target state="translated">Lo que &lt;code&gt;async_fn&lt;/code&gt; devuelva async_fn .</target>
        </trans-unit>
        <trans-unit id="0900e19e99ebea86826634809b1ac337300398cd" translate="yes" xml:space="preserve">
          <source>Whatever &lt;code&gt;fn(*args)&lt;/code&gt; returns.</source>
          <target state="translated">Lo que sea que devuelva &lt;code&gt;fn(*args)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7106029302bd01916d53d96d96a609813f99f07f" translate="yes" xml:space="preserve">
          <source>Whatever &lt;code&gt;sync_fn(*args)&lt;/code&gt; returns.</source>
          <target state="translated">Lo que sea que &lt;code&gt;sync_fn(*args)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73c196cbd030978c8ebe9f64bd805b220de1b08c" translate="yes" xml:space="preserve">
          <source>Whatever object was received.</source>
          <target state="translated">Cualquier objeto que se haya recibido.</target>
        </trans-unit>
        <trans-unit id="c08d6626b380b7a283be3fe01b713e7771435c33" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#trio.serve_listeners&quot;&gt;&lt;code&gt;serve_listeners()&lt;/code&gt;&lt;/a&gt; gets one of these errors, then it:</source>
          <target state="translated">Cuando &lt;a href=&quot;#trio.serve_listeners&quot;&gt; &lt;code&gt;serve_listeners()&lt;/code&gt; &lt;/a&gt; obtiene uno de estos errores, entonces:</target>
        </trans-unit>
        <trans-unit id="70c95cc62edeba47e63c58fc9085be2e8b6351ec" translate="yes" xml:space="preserve">
          <source>When Something Happens</source>
          <target state="translated">Cuando algo sucede</target>
        </trans-unit>
        <trans-unit id="ba546f26b5517c4f6e089e91b69d48fca957e868" translate="yes" xml:space="preserve">
          <source>When Trio finishes and your &lt;code&gt;done_callback&lt;/code&gt; is invoked, shut down the host loop</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fa415e76fd97b945f16a66030c2c91b43138a27" translate="yes" xml:space="preserve">
          <source>When a non-blocking method cannot succeed (the channel is empty, the lock is already held, etc.), then it raises &lt;a href=&quot;#trio.WouldBlock&quot;&gt;&lt;code&gt;trio.WouldBlock&lt;/code&gt;&lt;/a&gt;. There&amp;rsquo;s no equivalent to the &lt;a href=&quot;https://docs.python.org/3/library/queue.html#queue.Empty&quot;&gt;&lt;code&gt;queue.Empty&lt;/code&gt;&lt;/a&gt; versus &lt;a href=&quot;https://docs.python.org/3/library/queue.html#queue.Full&quot;&gt;&lt;code&gt;queue.Full&lt;/code&gt;&lt;/a&gt; distinction &amp;ndash; we just have the one exception that we use consistently.</source>
          <target state="translated">Cuando un m&amp;eacute;todo sin bloqueo no puede tener &amp;eacute;xito (el canal est&amp;aacute; vac&amp;iacute;o, la cerradura ya est&amp;aacute; retenida, etc.), se genera un &lt;a href=&quot;#trio.WouldBlock&quot;&gt; &lt;code&gt;trio.WouldBlock&lt;/code&gt; &lt;/a&gt; . No hay equivalente a la &lt;a href=&quot;https://docs.python.org/3/library/queue.html#queue.Empty&quot;&gt; &lt;code&gt;queue.Empty&lt;/code&gt; &lt;/a&gt; versus &lt;a href=&quot;https://docs.python.org/3/library/queue.html#queue.Full&quot;&gt; &lt;code&gt;queue.Full&lt;/code&gt; &lt;/a&gt; distinci&amp;oacute;n completa: solo tenemos una excepci&amp;oacute;n que usamos de manera consistente.</target>
        </trans-unit>
        <trans-unit id="0a25ccee7807a927ac0e6934a2c0dc83b30b44fd" translate="yes" xml:space="preserve">
          <source>When calling this method, you must hold the lock. It releases the lock while waiting, and then re-acquires it before waking up.</source>
          <target state="translated">Cuando llame a este método,debe mantener la cerradura.Se libera la cerradura mientras se espera,y luego se vuelve a adquirir antes de despertar.</target>
        </trans-unit>
        <trans-unit id="753c218c6f37ff70efd4c6551a5ae5088a5768f7" translate="yes" xml:space="preserve">
          <source>When the Trio run has finished, Trio will invoke this callback to let you know. The argument is an &lt;a href=&quot;https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome&quot;&gt;&lt;code&gt;outcome.Outcome&lt;/code&gt;&lt;/a&gt;, reporting what would have been returned or raised by &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run&lt;/code&gt;&lt;/a&gt;. This function can do anything you want, but commonly you&amp;rsquo;ll want it to shut down the host loop, unwrap the outcome, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="492b823ff0bfc64272d1aac26d5141c4bbf0412b" translate="yes" xml:space="preserve">
          <source>When the calling coroutine enters this function it&amp;rsquo;s running under Trio, and when the function returns it&amp;rsquo;s running under the foreign coroutine runner.</source>
          <target state="translated">Cuando la corrutina que llama ingresa a esta funci&amp;oacute;n, se ejecuta en Trio, y cuando la funci&amp;oacute;n regresa, se ejecuta en el corredor de corrutina externo.</target>
        </trans-unit>
        <trans-unit id="e7ef1b43a451a8a215f39d5c443f75b4d480e706" translate="yes" xml:space="preserve">
          <source>When the calling coroutine enters this function it&amp;rsquo;s running under the foreign coroutine runner, and when the function returns it&amp;rsquo;s running under Trio.</source>
          <target state="translated">Cuando la corrutina que llama ingresa a esta funci&amp;oacute;n, se ejecuta bajo el corredor de corrutina externo, y cuando la funci&amp;oacute;n regresa, se ejecuta en Trio.</target>
        </trans-unit>
        <trans-unit id="c43b2fd212506db181cda97f6f6177df1e6cecc9" translate="yes" xml:space="preserve">
          <source>When the child calls &lt;code&gt;task_status.started()&lt;/code&gt;, it&amp;rsquo;s moved from out from underneath &lt;a href=&quot;#trio.Nursery.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; and into the given nursery.</source>
          <target state="translated">Cuando el ni&amp;ntilde;o llama a &lt;code&gt;task_status.started()&lt;/code&gt; , se mueve desde debajo de &lt;a href=&quot;#trio.Nursery.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; hacia la guarder&amp;iacute;a dada.</target>
        </trans-unit>
        <trans-unit id="54c0737c4ecd13bf0fa970257c2d732fdc4598ce" translate="yes" xml:space="preserve">
          <source>When the child calls &lt;code&gt;task_status.started()&lt;/code&gt;, it&amp;rsquo;s moved out from underneath &lt;a href=&quot;#trio.Nursery.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; and into the given nursery.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49306f775b665fbf38ace009d3a78979b0faff07" translate="yes" xml:space="preserve">
          <source>When the process actually exits, the &lt;code&gt;deliver_cancel&lt;/code&gt; function will automatically be cancelled &amp;ndash; so if the process exits after &lt;code&gt;SIGTERM&lt;/code&gt;, then we&amp;rsquo;ll never reach the &lt;code&gt;SIGKILL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e41b82f148b817f9177e9c64a7e7139363b2ad1" translate="yes" xml:space="preserve">
          <source>When things go wrong: timeouts, cancellation and exceptions in concurrent tasks</source>
          <target state="translated">Cuando las cosas van mal:tiempos muertos,cancelación y excepciones en tareas concurrentes</target>
        </trans-unit>
        <trans-unit id="4696d67240a9e110f4a4748327c6309139ff62d8" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;nursery.start&lt;/code&gt; you get back the newly opened listeners. See the documentation for &lt;a href=&quot;#trio.serve_tcp&quot;&gt;&lt;code&gt;serve_tcp()&lt;/code&gt;&lt;/a&gt; for an example where this is useful.</source>
          <target state="translated">Cuando se usa con &lt;code&gt;nursery.start&lt;/code&gt; , recupera los oyentes reci&amp;eacute;n abiertos. Consulte la documentaci&amp;oacute;n de &lt;a href=&quot;#trio.serve_tcp&quot;&gt; &lt;code&gt;serve_tcp()&lt;/code&gt; &lt;/a&gt; para ver un ejemplo en el que esto es &amp;uacute;til.</target>
        </trans-unit>
        <trans-unit id="b0f0516af766be435ac7ae9669119313d86c471d" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;nursery.start&lt;/code&gt; you get back the newly opened listeners. So, for example, if you want to start a server in your test suite and then connect to it to check that it&amp;rsquo;s working properly, you can use something like:</source>
          <target state="translated">Cuando se usa con &lt;code&gt;nursery.start&lt;/code&gt; , recupera los oyentes reci&amp;eacute;n abiertos. Entonces, por ejemplo, si desea iniciar un servidor en su suite de prueba y luego conectarse a &amp;eacute;l para verificar que est&amp;eacute; funcionando correctamente, puede usar algo como:</target>
        </trans-unit>
        <trans-unit id="050a5caa1b8ee04b9f63b749870c3fe582322618" translate="yes" xml:space="preserve">
          <source>When writing Trio code, you need to keep track of where your checkpoints are. Why? First, because checkpoints require extra scrutiny: whenever you execute a checkpoint, you need to be prepared to handle a &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; error, or for another task to run and &lt;a href=&quot;https://glyph.twistedmatrix.com/2014/02/unyielding.html&quot;&gt;rearrange some state out from under you&lt;/a&gt;. And second, because you also need to make sure that you have &lt;em&gt;enough&lt;/em&gt; checkpoints: if your code doesn&amp;rsquo;t pass through a checkpoint on a regular basis, then it will be slow to notice and respond to cancellation and &amp;ndash; much worse &amp;ndash; since Trio is a cooperative multi-tasking system where the &lt;em&gt;only&lt;/em&gt; place the scheduler can switch tasks is at checkpoints, it&amp;rsquo;ll also prevent the scheduler from fairly allocating time between different tasks and adversely effect the response latency of all the other code running in the same process. (Informally we say that a task that does this is &amp;ldquo;hogging the run loop&amp;rdquo;.)</source>
          <target state="translated">Al escribir c&amp;oacute;digo Trio, debe realizar un seguimiento de d&amp;oacute;nde est&amp;aacute;n sus puntos de control. &amp;iquest;Por qu&amp;eacute;? Primero, porque los puntos de control requieren un escrutinio adicional: siempre que ejecute un punto de control, debe estar preparado para manejar un error &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; , o para que se ejecute otra tarea y &lt;a href=&quot;https://glyph.twistedmatrix.com/2014/02/unyielding.html&quot;&gt;reorganice alg&amp;uacute;n estado debajo de usted&lt;/a&gt; . Y, en segundo lugar, porque tambi&amp;eacute;n debe asegurarse de tener &lt;em&gt;suficientes&lt;/em&gt; puntos de control: si su c&amp;oacute;digo no pasa por un punto de control de forma regular, ser&amp;aacute; lento para darse cuenta y responder a la cancelaci&amp;oacute;n y, mucho peor, ya que Trio es un sistema cooperativo multitarea donde el &lt;em&gt;&amp;uacute;nico&lt;/em&gt;Si el programador puede cambiar las tareas en los puntos de control, tambi&amp;eacute;n evitar&amp;aacute; que el programador asigne el tiempo de manera justa entre las diferentes tareas y afectar&amp;aacute; negativamente la latencia de respuesta de todo el otro c&amp;oacute;digo que se ejecuta en el mismo proceso. (De manera informal decimos que una tarea que hace esto est&amp;aacute; &quot;acaparando el ciclo de ejecuci&amp;oacute;n&quot;).</target>
        </trans-unit>
        <trans-unit id="2bd47718f69d1078c324105f5b4a8877d159988a" translate="yes" xml:space="preserve">
          <source>When writing code using Trio, it&amp;rsquo;s very important to understand the concept of a &lt;em&gt;checkpoint&lt;/em&gt;. Many of Trio&amp;rsquo;s functions act as checkpoints.</source>
          <target state="translated">Al escribir c&amp;oacute;digo con Trio, es muy importante comprender el concepto de &lt;em&gt;punto&lt;/em&gt; de &lt;em&gt;control&lt;/em&gt; . Muchas de las funciones de Trio act&amp;uacute;an como puntos de control.</target>
        </trans-unit>
        <trans-unit id="563b04d52caf0b7947b54fd91ab7bb4c9b90eec8" translate="yes" xml:space="preserve">
          <source>When you call &lt;a href=&quot;#trio.open_memory_channel&quot;&gt;&lt;code&gt;open_memory_channel()&lt;/code&gt;&lt;/a&gt;, you have to specify how many values can be buffered internally in the channel. If the buffer is full, then any task that calls &lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt;&lt;code&gt;send()&lt;/code&gt;&lt;/a&gt; will stop and wait for another task to call &lt;a href=&quot;reference-io#trio.abc.ReceiveChannel.receive&quot;&gt;&lt;code&gt;receive()&lt;/code&gt;&lt;/a&gt;. This is useful because it produces &lt;em&gt;backpressure&lt;/em&gt;: if the channel producers are running faster than the consumers, then it forces the producers to slow down.</source>
          <target state="translated">Cuando llama a &lt;a href=&quot;#trio.open_memory_channel&quot;&gt; &lt;code&gt;open_memory_channel()&lt;/code&gt; &lt;/a&gt; , debe especificar cu&amp;aacute;ntos valores se pueden almacenar en b&amp;uacute;fer internamente en el canal. Si el b&amp;uacute;fer est&amp;aacute; lleno, cualquier tarea que llame a &lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt; &lt;code&gt;send()&lt;/code&gt; &lt;/a&gt; se detendr&amp;aacute; y esperar&amp;aacute; a que otra tarea llame a &lt;a href=&quot;reference-io#trio.abc.ReceiveChannel.receive&quot;&gt; &lt;code&gt;receive()&lt;/code&gt; &lt;/a&gt; . Esto es &amp;uacute;til porque produce &lt;em&gt;contrapresi&amp;oacute;n&lt;/em&gt; : si los productores de canales funcionan m&amp;aacute;s r&amp;aacute;pido que los consumidores, los productores se ven obligados a reducir la velocidad.</target>
        </trans-unit>
        <trans-unit id="8151ab5838ee480e5fa7b1d05a5c8fc0425cba68" translate="yes" xml:space="preserve">
          <source>Why is this so? Well, &lt;code&gt;start_soon()&lt;/code&gt; returns as soon as it has scheduled the new task to start running. The flow of execution in the parent then continues on to exit the &lt;code&gt;with move_on_after(TIMEOUT):&lt;/code&gt; block, at which point Trio forgets about the timeout entirely. In order for the timeout to apply to the child task, Trio must be able to tell that its associated cancel scope will stay open for at least as long as the child task is executing. And Trio can only know that for sure if the cancel scope block is outside the nursery block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebd5ba9c06f944e318c34cc1096bc4b580938e60" translate="yes" xml:space="preserve">
          <source>Why is this useful? Because it lets you write generic protocol implementations that can work over arbitrary transports, and easily create complex transport configurations. Here&amp;rsquo;s some examples:</source>
          <target state="translated">&amp;iquest;Por qu&amp;eacute; es &amp;uacute;til esto? Porque le permite escribir implementaciones de protocolos gen&amp;eacute;ricos que pueden funcionar sobre transportes arbitrarios y crear f&amp;aacute;cilmente configuraciones de transporte complejas. He aqu&amp;iacute; algunos ejemplos:</target>
        </trans-unit>
        <trans-unit id="1fe6956c2b57c6dcd4ba099709ab46045a14b6bf" translate="yes" xml:space="preserve">
          <source>Will properly log the inner exceptions:</source>
          <target state="translated">Registrará adecuadamente las excepciones internas:</target>
        </trans-unit>
        <trans-unit id="f5b730424dca0983602eb64b9f4309ede1c96c09" translate="yes" xml:space="preserve">
          <source>Windows, macOS, Linux (glibc and musl), FreeBSD</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6603e7873d2ee40d69b4759aabb89958cd30da76" translate="yes" xml:space="preserve">
          <source>Windows-specific API</source>
          <target state="translated">API específica de Windows</target>
        </trans-unit>
        <trans-unit id="ec261e1804785b0b785fb8d4215c0f1f49b8e343" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;shell=True&lt;/code&gt; on UNIX, you must specify the command as a single string, which will be passed to the shell as if you&amp;rsquo;d entered it at an interactive prompt. The advantage of this option is that it lets you use shell features like pipes and redirection without writing code to handle them. For example, you can write &lt;code&gt;Process(&quot;ls | grep
some_string&quot;, shell=True)&lt;/code&gt;. The disadvantage is that you must account for the shell&amp;rsquo;s quoting rules, generally by wrapping in &lt;a href=&quot;https://docs.python.org/3/library/shlex.html#shlex.quote&quot;&gt;&lt;code&gt;shlex.quote()&lt;/code&gt;&lt;/a&gt; any argument that might contain spaces, quotes, or other shell metacharacters. If you don&amp;rsquo;t do that, your safe-looking &lt;code&gt;f&quot;ls | grep {some_string}&quot;&lt;/code&gt; might end in disaster when invoked with &lt;code&gt;some_string = &quot;foo; rm -rf /&quot;&lt;/code&gt;.</source>
          <target state="translated">Con &lt;code&gt;shell=True&lt;/code&gt; en UNIX, debe especificar el comando como una sola cadena, que se pasar&amp;aacute; al shell como si lo hubiera ingresado en un indicador interactivo. La ventaja de esta opci&amp;oacute;n es que le permite usar funciones de shell como canalizaciones y redirecci&amp;oacute;n sin escribir c&amp;oacute;digo para manejarlas. Por ejemplo, puede escribir &lt;code&gt;Process(&quot;ls | grep some_string&quot;, shell=True)&lt;/code&gt; . La desventaja es que debe tener en cuenta las reglas de &lt;a href=&quot;https://docs.python.org/3/library/shlex.html#shlex.quote&quot;&gt; &lt;code&gt;shlex.quote()&lt;/code&gt; &lt;/a&gt; del shell, generalmente al incluir shlex.quote () cualquier argumento que pueda contener espacios, comillas u otros metacaracteres del shell. Si no hace eso, su &lt;code&gt;f&quot;ls | grep {some_string}&quot;&lt;/code&gt; podr&amp;iacute;a terminar en desastre cuando se invoca con &lt;code&gt;some_string = &quot;foo; rm -rf /&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1d019f8c58f9fd95bf76d9970e94c7ca4731343" translate="yes" xml:space="preserve">
          <source>Worker thread: First job finishes, and calls &lt;code&gt;deliver&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fe13ef3f5abe58005367efa1a6d4109b0187fdd" translate="yes" xml:space="preserve">
          <source>Worker threads have the &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Thread.daemon&quot;&gt;&lt;code&gt;daemon&lt;/code&gt;&lt;/a&gt; flag set, which means that if your main thread exits, worker threads will automatically be killed. If you want to make sure that your &lt;code&gt;fn&lt;/code&gt; runs to completion, then you should make sure that the main thread remains alive until &lt;code&gt;deliver&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e73f6e4aaefa27f475bc4dd6d0f2b7b7c14f78e7" translate="yes" xml:space="preserve">
          <source>Working with &lt;a href=&quot;#trio.MultiError&quot;&gt;&lt;code&gt;MultiError&lt;/code&gt;&lt;/a&gt;s</source>
          <target state="translated">Trabajar con &lt;a href=&quot;#trio.MultiError&quot;&gt; &lt;code&gt;MultiError&lt;/code&gt; &lt;/a&gt; s</target>
        </trans-unit>
        <trans-unit id="7a749c2ad89d64cc77c70606aa79cc9a9d760911" translate="yes" xml:space="preserve">
          <source>You &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; get this error if &lt;em&gt;you&lt;/em&gt; closed the resource &amp;ndash; in that case you get &lt;a href=&quot;#trio.ClosedResourceError&quot;&gt;&lt;code&gt;ClosedResourceError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Usted &lt;em&gt;no&lt;/em&gt; obtiene este error si &lt;em&gt;se&lt;/em&gt; cerr&amp;oacute; el recurso - en ese caso se obtiene &lt;a href=&quot;#trio.ClosedResourceError&quot;&gt; &lt;code&gt;ClosedResourceError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="009b360c3befaa2658cd8a4c7ce2de66315f1f24" translate="yes" xml:space="preserve">
          <source>You almost certainly don&amp;rsquo;t need this.</source>
          <target state="translated">Es casi seguro que no necesitas esto.</target>
        </trans-unit>
        <trans-unit id="b9b45820263d7fae15a81523c5569073958dee34" translate="yes" xml:space="preserve">
          <source>You can also have multiple producers, and multiple consumers, all sharing the same channel. However, this makes shutdown a little more complicated.</source>
          <target state="translated">También puedes tener múltiples productores y múltiples consumidores,todos compartiendo el mismo canal.Sin embargo,esto hace que el cierre sea un poco más complicado.</target>
        </trans-unit>
        <trans-unit id="fa7c24bdef2aeca73281561745562136ffeaa884" translate="yes" xml:space="preserve">
          <source>You can also return a new or modified exception, for example:</source>
          <target state="translated">También puede devolver una excepción nueva o modificada,por ejemplo:</target>
        </trans-unit>
        <trans-unit id="85a44c662cd47a5543d52a16cd0c311eb28f153a" translate="yes" xml:space="preserve">
          <source>You can catch &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;, but you shouldn&amp;rsquo;t! Or more precisely, if you do catch it, then you should do some cleanup and then re-raise it or otherwise let it continue propagating (unless you encounter an error, in which case it&amp;rsquo;s OK to let that propagate instead). To help remind you of this fact, &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; inherits from &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#BaseException&quot;&gt;&lt;code&gt;BaseException&lt;/code&gt;&lt;/a&gt;, like &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#SystemExit&quot;&gt;&lt;code&gt;SystemExit&lt;/code&gt;&lt;/a&gt; do, so that it won&amp;rsquo;t be caught by catch-all &lt;code&gt;except
Exception:&lt;/code&gt; blocks.</source>
          <target state="translated">Puedes atrapar &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; , &amp;iexcl;pero no deber&amp;iacute;as! O m&amp;aacute;s precisamente, si lo detecta, entonces debe hacer una limpieza y luego volver a subirlo o dejar que contin&amp;uacute;e propag&amp;aacute;ndose (a menos que encuentre un error, en cuyo caso est&amp;aacute; bien dejar que se propague). Para ayudar a recordar de este hecho, &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; hereda de &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#BaseException&quot;&gt; &lt;code&gt;BaseException&lt;/code&gt; &lt;/a&gt; , como &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#SystemExit&quot;&gt; &lt;code&gt;SystemExit&lt;/code&gt; &lt;/a&gt; hacen, por lo que no va a ser atrapado por caj&amp;oacute;n de sastre &lt;code&gt;except Exception:&lt;/code&gt; bloques.</target>
        </trans-unit>
        <trans-unit id="8b32cfc5b75f959eb500229037977131b40984b7" translate="yes" xml:space="preserve">
          <source>You can change &lt;a href=&quot;#trio.CapacityLimiter.total_tokens&quot;&gt;&lt;code&gt;total_tokens&lt;/code&gt;&lt;/a&gt; by assigning to this attribute. If you make it larger, then the appropriate number of waiting tasks will be woken immediately to take the new tokens. If you decrease total_tokens below the number of tasks that are currently using the resource, then all current tasks will be allowed to finish as normal, but no new tasks will be allowed in until the total number of tasks drops below the new total_tokens.</source>
          <target state="translated">Puede cambiar &lt;a href=&quot;#trio.CapacityLimiter.total_tokens&quot;&gt; &lt;code&gt;total_tokens&lt;/code&gt; &lt;/a&gt; asignando este atributo. Si lo agranda, la cantidad apropiada de tareas en espera se despertar&amp;aacute; inmediatamente para tomar las nuevas fichas. Si reduce total_tokens por debajo de la cantidad de tareas que est&amp;aacute;n usando actualmente el recurso, entonces todas las tareas actuales podr&amp;aacute;n finalizar con normalidad, pero no se permitir&amp;aacute;n nuevas tareas hasta que la cantidad total de tareas caiga por debajo del nuevo total_tokens.</target>
        </trans-unit>
        <trans-unit id="11cd6250779c6856022b324d11615a036ef7bd8b" translate="yes" xml:space="preserve">
          <source>You can disable buffering entirely, by doing &lt;code&gt;open_memory_channel(0)&lt;/code&gt;. In that case any task calls &lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt;&lt;code&gt;send()&lt;/code&gt;&lt;/a&gt; will wait until another task calls &lt;a href=&quot;reference-io#trio.abc.ReceiveChannel.receive&quot;&gt;&lt;code&gt;receive()&lt;/code&gt;&lt;/a&gt;, and vice versa. This is similar to how channels work in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Channel_(programming)&quot;&gt;classic Communicating Sequential Processes model&lt;/a&gt;, and is a reasonable default if you aren&amp;rsquo;t sure what size buffer to use. (That&amp;rsquo;s why we used it in the examples above.)</source>
          <target state="translated">Puede deshabilitar el almacenamiento en b&amp;uacute;fer por completo, haciendo &lt;code&gt;open_memory_channel(0)&lt;/code&gt; . En ese caso, cualquier tarea que llame a &lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt; &lt;code&gt;send()&lt;/code&gt; &lt;/a&gt; esperar&amp;aacute; hasta que otra tarea llame a &lt;a href=&quot;reference-io#trio.abc.ReceiveChannel.receive&quot;&gt; &lt;code&gt;receive()&lt;/code&gt; &lt;/a&gt; , y viceversa. Esto es similar a c&amp;oacute;mo funcionan los canales en el &lt;a href=&quot;https://en.wikipedia.org/wiki/Channel_(programming)&quot;&gt;modelo cl&amp;aacute;sico de procesos secuenciales de comunicaci&amp;oacute;n&lt;/a&gt; , y es un valor predeterminado razonable si no est&amp;aacute; seguro de qu&amp;eacute; tama&amp;ntilde;o de b&amp;uacute;fer utilizar. (Por eso lo usamos en los ejemplos anteriores).</target>
        </trans-unit>
        <trans-unit id="35229fb9115e8ecd014b6b64bf74bdc7940f514a" translate="yes" xml:space="preserve">
          <source>You can disable buffering entirely, by doing &lt;code&gt;open_memory_channel(0)&lt;/code&gt;. In that case any task that calls &lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt;&lt;code&gt;send()&lt;/code&gt;&lt;/a&gt; will wait until another task calls &lt;a href=&quot;reference-io#trio.abc.ReceiveChannel.receive&quot;&gt;&lt;code&gt;receive()&lt;/code&gt;&lt;/a&gt;, and vice versa. This is similar to how channels work in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Channel_(programming)&quot;&gt;classic Communicating Sequential Processes model&lt;/a&gt;, and is a reasonable default if you aren&amp;rsquo;t sure what size buffer to use. (That&amp;rsquo;s why we used it in the examples above.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e18f18f287b713cf7b776bf6e3148ce23b129d9" translate="yes" xml:space="preserve">
          <source>You can freely nest cancellation blocks, and each &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception &amp;ldquo;knows&amp;rdquo; which block it belongs to. So long as you don&amp;rsquo;t stop it, the exception will keep propagating until it reaches the block that raised it, at which point it will stop automatically.</source>
          <target state="translated">Puede anidar bloques de cancelaci&amp;oacute;n libremente, y cada excepci&amp;oacute;n &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; &quot;sabe&quot; a qu&amp;eacute; bloque pertenece. Mientras no la detenga, la excepci&amp;oacute;n seguir&amp;aacute; propag&amp;aacute;ndose hasta que llegue al bloque que la gener&amp;oacute;, momento en el que se detendr&amp;aacute; autom&amp;aacute;ticamente.</target>
        </trans-unit>
        <trans-unit id="8f5139697bee7e3f58dfd9f1e3d68a51bb393964" translate="yes" xml:space="preserve">
          <source>You can iterate over a &lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt;&lt;code&gt;ReceiveChannel&lt;/code&gt;&lt;/a&gt; using an &lt;code&gt;async for&lt;/code&gt; loop:</source>
          <target state="translated">Puede iterar sobre un &lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt; &lt;code&gt;ReceiveChannel&lt;/code&gt; &lt;/a&gt; utilizando un bucle &lt;code&gt;async for&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="25750c191a2273b2bed66aa7b14de5b9a4a29dc8" translate="yes" xml:space="preserve">
          <source>You can register an initial list of instruments by passing them to &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#trio.hazmat.add_instrument&quot;&gt;&lt;code&gt;add_instrument()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.hazmat.remove_instrument&quot;&gt;&lt;code&gt;remove_instrument()&lt;/code&gt;&lt;/a&gt; let you add and remove instruments at runtime.</source>
          <target state="translated">Puede registrar una lista inicial de instrumentos pas&amp;aacute;ndolos a &lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;#trio.hazmat.add_instrument&quot;&gt; &lt;code&gt;add_instrument()&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#trio.hazmat.remove_instrument&quot;&gt; &lt;code&gt;remove_instrument()&lt;/code&gt; &lt;/a&gt; permiten agregar y eliminar instrumentos en tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e4a7bdb61256f4d0af56a70b7ef3f33efecb1a8f" translate="yes" xml:space="preserve">
          <source>You can register an initial list of instruments by passing them to &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#trio.lowlevel.add_instrument&quot;&gt;&lt;code&gt;add_instrument()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.lowlevel.remove_instrument&quot;&gt;&lt;code&gt;remove_instrument()&lt;/code&gt;&lt;/a&gt; let you add and remove instruments at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72febccd38897ee2443a5e471fd47c45c93fc9ad" translate="yes" xml:space="preserve">
          <source>You can see we&amp;rsquo;re using asyncio-specific APIs to start up a loop, and then we call &lt;a href=&quot;#trio.lowlevel.start_guest_run&quot;&gt;&lt;code&gt;trio.lowlevel.start_guest_run&lt;/code&gt;&lt;/a&gt;. This function is very similar to &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run&lt;/code&gt;&lt;/a&gt;, and takes all the same arguments. But it has two differences:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4d41938cec088f1203bbaddf9eb58c835315958" translate="yes" xml:space="preserve">
          <source>You can set &lt;a href=&quot;#trio.testing.MockClock.rate&quot;&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/a&gt; to 1.0 if you want it to start running in real time like a regular clock. You can stop and start the clock within a test. You can set &lt;a href=&quot;#trio.testing.MockClock.rate&quot;&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/a&gt; to 10.0 to make clock time pass at 10x real speed (so e.g. &lt;code&gt;await
trio.sleep(10)&lt;/code&gt; returns after 1 second).</source>
          <target state="translated">Puede establecer la &lt;a href=&quot;#trio.testing.MockClock.rate&quot;&gt; &lt;code&gt;rate&lt;/code&gt; &lt;/a&gt; en 1.0 si desea que comience a funcionar en tiempo real como un reloj normal. Puede detener e iniciar el reloj dentro de una prueba. Puede establecer la &lt;a href=&quot;#trio.testing.MockClock.rate&quot;&gt; &lt;code&gt;rate&lt;/code&gt; &lt;/a&gt; en 10.0 para que el tiempo del reloj pase a 10 veces la velocidad real (por ejemplo, &lt;code&gt;await trio.sleep(10)&lt;/code&gt; regresa despu&amp;eacute;s de 1 segundo).</target>
        </trans-unit>
        <trans-unit id="73b14216af1fb4461a4eebe7cd333ac5fc89728c" translate="yes" xml:space="preserve">
          <source>You can think of this as being a no-operating-system-involved Trio-streamsified version of &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.pipe&quot;&gt;&lt;code&gt;os.pipe()&lt;/code&gt;&lt;/a&gt; (except that &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.pipe&quot;&gt;&lt;code&gt;os.pipe()&lt;/code&gt;&lt;/a&gt; returns the streams in the wrong order &amp;ndash; we follow the superior convention that data flows from left to right).</source>
          <target state="translated">Puede pensar en esto como una versi&amp;oacute;n trio- &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.pipe&quot;&gt; &lt;code&gt;os.pipe()&lt;/code&gt; &lt;/a&gt; de os.pipe () que &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.pipe&quot;&gt; &lt;code&gt;os.pipe()&lt;/code&gt; &lt;/a&gt; involucra el sistema operativo (excepto que os.pipe () devuelve las transmisiones en el orden incorrecto; seguimos la convenci&amp;oacute;n superior de la que fluyen los datos de izquierda a derecha).</target>
        </trans-unit>
        <trans-unit id="69f1b7fea9b89d2906468a78814a5a12c77ad0dd" translate="yes" xml:space="preserve">
          <source>You can use guest mode without reading this section. It&amp;rsquo;s included for those who enjoy understanding how things work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a193c819e0c34ae44aa174ef625aeb404927f6f" translate="yes" xml:space="preserve">
          <source>You cannot raise &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; yourself. Attempting to do so will produce a &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. Use &lt;a href=&quot;#trio.CancelScope.cancel&quot;&gt;&lt;code&gt;cancel_scope.cancel()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">No puede subir a &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; usted mismo. Intentar hacerlo producir&amp;aacute; un &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; . Use &lt;a href=&quot;#trio.CancelScope.cancel&quot;&gt; &lt;code&gt;cancel_scope.cancel()&lt;/code&gt; &lt;/a&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="5bce218254ad16d35879a867fed587c02c4cd3c0" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t need to be scared of &lt;a href=&quot;#module-trio.lowlevel&quot;&gt;&lt;code&gt;trio.lowlevel&lt;/code&gt;&lt;/a&gt;, as long as you take proper precautions. These are real public APIs, with strictly defined and carefully documented semantics. They&amp;rsquo;re the same tools we use to implement all the nice high-level APIs in the &lt;a href=&quot;reference-core#module-trio&quot;&gt;&lt;code&gt;trio&lt;/code&gt;&lt;/a&gt; namespace. But, be careful. Some of those strict semantics have &lt;a href=&quot;https://en.wikipedia.org/wiki/Rabbit_of_Caerbannog&quot;&gt;nasty big pointy teeth&lt;/a&gt;. If you make a mistake, Trio may not be able to handle it gracefully; conventions and guarantees that are followed strictly in the rest of Trio do not always apply. When you use this module, it&amp;rsquo;s your job to think about how you&amp;rsquo;re going to handle the tricky cases so you can expose a friendly Trio-style API to your users.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="543df5888a6f3ed554d9063bbb7beaa13887bd6f" translate="yes" xml:space="preserve">
          <source>You may not write a &lt;code&gt;yield&lt;/code&gt; statement that suspends an async generator inside a &lt;a href=&quot;#trio.CancelScope&quot;&gt;&lt;code&gt;CancelScope&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#trio.Nursery&quot;&gt;&lt;code&gt;Nursery&lt;/code&gt;&lt;/a&gt; that was entered within the generator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5562812ed84763ace42f034dbb4b06c937f902cb" translate="yes" xml:space="preserve">
          <source>You might wonder why Trio can&amp;rsquo;t just remember &amp;ldquo;this task should be cancelled in &lt;code&gt;TIMEOUT&lt;/code&gt; seconds&amp;rdquo;, even after the &lt;code&gt;with move_on_after(TIMEOUT):&lt;/code&gt; block is gone. The reason has to do with &lt;a href=&quot;#cancellation&quot;&gt;how cancellation is implemented&lt;/a&gt;. Recall that cancellation is represented by a &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception, which eventually needs to be caught by the cancel scope that caused it. (Otherwise, the exception would take down your whole program!) In order to be able to cancel the child tasks, the cancel scope has to be able to &amp;ldquo;see&amp;rdquo; the &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exceptions that they raise &amp;ndash; and those exceptions come out of the &lt;code&gt;async with open_nursery()&lt;/code&gt; block, not out of the call to &lt;code&gt;start_soon()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f1409455bb648f660eba18668fa46e8d4235d51" translate="yes" xml:space="preserve">
          <source>You must have read/write permission on the specified file to connect.</source>
          <target state="translated">Debes tener permiso de lectura/escritura en el archivo especificado para conectarte.</target>
        </trans-unit>
        <trans-unit id="9591f43d82177778fbdf8368519e3866ba04c088" translate="yes" xml:space="preserve">
          <source>You need to interoperate with a C library whose API exposes raw file descriptors.</source>
          <target state="translated">Necesitas interoperar con una biblioteca C cuya API expone descriptores de archivos en bruto.</target>
        </trans-unit>
        <trans-unit id="3328a7e6a66ef1d404c0daf69759fecee4ace50c" translate="yes" xml:space="preserve">
          <source>You probably don&amp;rsquo;t want to use this module.</source>
          <target state="translated">Probablemente no desee utilizar este m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="23c5814eb2e6178242ccbfbb5e6e94456da5ce51" translate="yes" xml:space="preserve">
          <source>You should also consider &lt;a href=&quot;#trio.testing.Sequencer&quot;&gt;&lt;code&gt;trio.testing.Sequencer&lt;/code&gt;&lt;/a&gt;, which provides a more explicit way to control execution ordering within a test, and will often produce more readable tests.</source>
          <target state="translated">Tambi&amp;eacute;n deber&amp;iacute;a considerar &lt;a href=&quot;#trio.testing.Sequencer&quot;&gt; &lt;code&gt;trio.testing.Sequencer&lt;/code&gt; &lt;/a&gt; , que proporciona una forma m&amp;aacute;s expl&amp;iacute;cita de controlar el orden de ejecuci&amp;oacute;n dentro de una prueba y, a menudo, producir&amp;aacute; pruebas m&amp;aacute;s legibles.</target>
        </trans-unit>
        <trans-unit id="204fe71dc183d56082312fe6769f541d68f0c62d" translate="yes" xml:space="preserve">
          <source>You should always let the Trio run finish before stopping the host loop; if not, it may leave Trio&amp;rsquo;s internal data structures in an inconsistent state. You might be able to get away with it if you immediately exit the program, but it&amp;rsquo;s safest not to go there in the first place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1e951ca24f73a0b917f6fa4fccd3b6e7ff5ec1d" translate="yes" xml:space="preserve">
          <source>You should let this exception propagate, to be caught by the relevant cancel scope. To remind you of this, it inherits from &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#BaseException&quot;&gt;&lt;code&gt;BaseException&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#Exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt;, just like &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#SystemExit&quot;&gt;&lt;code&gt;SystemExit&lt;/code&gt;&lt;/a&gt; do. This means that if you write something like:</source>
          <target state="translated">Debe dejar que esta excepci&amp;oacute;n se propague para que sea detectada por el &amp;aacute;mbito de cancelaci&amp;oacute;n correspondiente. Para recordarle esto, hereda de &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#BaseException&quot;&gt; &lt;code&gt;BaseException&lt;/code&gt; en&lt;/a&gt; lugar de &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#Exception&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt; , al igual que &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#SystemExit&quot;&gt; &lt;code&gt;SystemExit&lt;/code&gt; &lt;/a&gt; . Esto significa que si escribe algo como:</target>
        </trans-unit>
        <trans-unit id="fedfa7c04a142224d4bfaffbb7d5f92b503396fc" translate="yes" xml:space="preserve">
          <source>You should make sure that the coroutine object has released any Trio-specific resources it has acquired (e.g. nurseries).</source>
          <target state="translated">Debe asegurarse de que el objeto de cortinas ha liberado todos los recursos específicos del Trío que ha adquirido (por ejemplo,las guarderías).</target>
        </trans-unit>
        <trans-unit id="9de2954124a05d7144aba1d682767a02cd6925d2" translate="yes" xml:space="preserve">
          <source>You should not assume that Trio&amp;rsquo;s internal clock matches any other clock you have access to, including the clocks of simultaneous calls to &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt; happening in other processes or threads!</source>
          <target state="translated">No debe asumir que el reloj interno de Trio coincide con cualquier otro reloj al que tenga acceso, incluidos los relojes de llamadas simult&amp;aacute;neas a &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; ocurren en otros procesos o subprocesos.</target>
        </trans-unit>
        <trans-unit id="646e110f9302c40fddd2b0685842e617a4c59be2" translate="yes" xml:space="preserve">
          <source>You should not use this function to call long-running CPU-bound functions! In addition to the usual GIL-related reasons why using threads for CPU-bound work is not very effective in Python, there is an additional problem: on CPython, &lt;a href=&quot;https://bugs.python.org/issue7946&quot;&gt;CPU-bound threads tend to &amp;ldquo;starve out&amp;rdquo; IO-bound threads&lt;/a&gt;, so using threads for CPU-bound work is likely to adversely affect the main thread running Trio. If you need to do this, you&amp;rsquo;re better off using a worker process, or perhaps PyPy (which still has a GIL, but may do a better job of fairly allocating CPU time between threads).</source>
          <target state="translated">&amp;iexcl;No debe usar esta funci&amp;oacute;n para llamar a funciones vinculadas a la CPU de larga ejecuci&amp;oacute;n! Adem&amp;aacute;s de las razones habituales relacionadas con GIL por las que el uso de subprocesos para el trabajo vinculado a la CPU no es muy efectivo en Python, existe un problema adicional: en CPython, &lt;a href=&quot;https://bugs.python.org/issue7946&quot;&gt;los subprocesos vinculados a la CPU tienden a &quot;privar&quot; a los subprocesos vinculados a IO&lt;/a&gt; , por lo que usar Es probable que los subprocesos para el trabajo vinculado a la CPU afecten negativamente al subproceso principal que ejecuta Trio. Si necesita hacer esto, es mejor que utilice un proceso de trabajo, o quiz&amp;aacute;s PyPy (que todav&amp;iacute;a tiene un GIL, pero puede hacer un mejor trabajo al asignar de manera justa el tiempo de CPU entre subprocesos).</target>
        </trans-unit>
        <trans-unit id="44026b9c6a4042d112ee739a002a97d694712133" translate="yes" xml:space="preserve">
          <source>You should read the standard library&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#module-ssl&quot;&gt;&lt;code&gt;ssl&lt;/code&gt;&lt;/a&gt; documentation carefully before attempting to use this class, and probably other general documentation on SSL/TLS as well. SSL/TLS is subtle and quick to anger. Really. I&amp;rsquo;m not kidding.</source>
          <target state="translated">Debe leer detenidamente la documentaci&amp;oacute;n &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#module-ssl&quot;&gt; &lt;code&gt;ssl&lt;/code&gt; de&lt;/a&gt; la biblioteca est&amp;aacute;ndar antes de intentar utilizar esta clase, y probablemente tambi&amp;eacute;n otra documentaci&amp;oacute;n general sobre SSL / TLS. SSL / TLS es sutil y se enoja r&amp;aacute;pidamente. De Verdad. No estoy bromeando.</target>
        </trans-unit>
        <trans-unit id="af994b289b9e27ca5767229787d9d523285f5cca" translate="yes" xml:space="preserve">
          <source>You should set this to the smallest value that lets you reliably avoid &amp;ldquo;false alarms&amp;rdquo; where some I/O is in flight (e.g. between two halves of a socketpair) but the threshold gets triggered and time gets advanced anyway. This will depend on the details of your tests and test environment. If you aren&amp;rsquo;t doing any I/O (like in our sleeping example above) then just set it to zero, and the clock will jump whenever all tasks are blocked.</source>
          <target state="translated">Debe establecer esto en el valor m&amp;aacute;s peque&amp;ntilde;o que le permita evitar de manera confiable &amp;ldquo;falsas alarmas&amp;rdquo; donde algunas E / S est&amp;aacute;n en vuelo (por ejemplo, entre dos mitades de un par de conectores) pero el umbral se activa y el tiempo avanza de todos modos. Esto depender&amp;aacute; de los detalles de sus pruebas y del entorno de prueba. Si no est&amp;aacute; haciendo ninguna E / S (como en nuestro ejemplo de suspensi&amp;oacute;n anterior), simplemente aj&amp;uacute;stelo a cero y el reloj saltar&amp;aacute; cuando todas las tareas est&amp;eacute;n bloqueadas.</target>
        </trans-unit>
        <trans-unit id="04dc405c41c272f00e8f03c5e75c32fa3c6f6a3d" translate="yes" xml:space="preserve">
          <source>You want to add support for a low-level operating system interface that Trio doesn&amp;rsquo;t (yet) expose, like watching a filesystem directory for changes.</source>
          <target state="translated">Desea agregar soporte para una interfaz de sistema operativo de bajo nivel que Trio no expone (todav&amp;iacute;a), como ver cambios en un directorio del sistema de archivos.</target>
        </trans-unit>
        <trans-unit id="0428a04bb2f7e7b639617203dfc3e59ff2d8203f" translate="yes" xml:space="preserve">
          <source>You want to extract low-level metrics to monitor the health of your application.</source>
          <target state="translated">Quiere extraer métricas de bajo nivel para controlar la salud de su aplicación.</target>
        </trans-unit>
        <trans-unit id="05015afc873ec753584995707240d627d836bd52" translate="yes" xml:space="preserve">
          <source>You want to implement a new &lt;a href=&quot;reference-core#synchronization&quot;&gt;synchronization primitive&lt;/a&gt; that Trio doesn&amp;rsquo;t (yet) provide, like a reader-writer lock.</source>
          <target state="translated">Desea implementar una nueva &lt;a href=&quot;reference-core#synchronization&quot;&gt;primitiva de sincronizaci&amp;oacute;n&lt;/a&gt; que Trio no proporciona (todav&amp;iacute;a), como un bloqueo de lector-escritor.</target>
        </trans-unit>
        <trans-unit id="07a1ae0ae940498aef5bd14407e02b773ced1132" translate="yes" xml:space="preserve">
          <source>You want to implement an interface for calling between Trio and another event loop within the same process.</source>
          <target state="translated">Quieres implementar una interfaz para llamar entre Trio y otro bucle de eventos dentro del mismo proceso.</target>
        </trans-unit>
        <trans-unit id="31b2c75a30f9f7e761cebe1120ad37fa763d46c1" translate="yes" xml:space="preserve">
          <source>You want to use a low-level operating system interface that Trio doesn&amp;rsquo;t (yet) provide its own wrappers for, like watching a filesystem directory for changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1649b9e8a04484aaf903493316e5d3972b6838bd" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;re writing a debugger and want to visualize Trio&amp;rsquo;s task tree.</source>
          <target state="translated">Est&amp;aacute;s escribiendo un depurador y quieres visualizar el &amp;aacute;rbol de tareas de Trio.</target>
        </trans-unit>
        <trans-unit id="d49ab22902a8727e54d03ba7e745316cec5707a4" translate="yes" xml:space="preserve">
          <source>Your socket object must inherit from &lt;a href=&quot;reference-io#trio.socket.SocketType&quot;&gt;&lt;code&gt;trio.socket.SocketType&lt;/code&gt;&lt;/a&gt;, which is an empty class whose only purpose is to &amp;ldquo;mark&amp;rdquo; which classes should be considered valid Trio sockets.</source>
          <target state="translated">Su objeto socket debe heredar de &lt;a href=&quot;reference-io#trio.socket.SocketType&quot;&gt; &lt;code&gt;trio.socket.SocketType&lt;/code&gt; &lt;/a&gt; , que es una clase vac&amp;iacute;a cuyo &amp;uacute;nico prop&amp;oacute;sito es &quot;marcar&quot; qu&amp;eacute; clases deben considerarse sockets Trio v&amp;aacute;lidos.</target>
        </trans-unit>
        <trans-unit id="f1898341d2daec152994b3c0f65aeb8b9483cc1c" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; connected to the given file.</source>
          <target state="translated">una &lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; conectada al archivo dado.</target>
        </trans-unit>
        <trans-unit id="6da0b7c2a1148f6e2dd5916c9d16b09301bfe3e2" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; connected to the given server.</source>
          <target state="translated">un &lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; conectado al servidor dado.</target>
        </trans-unit>
        <trans-unit id="6195af02e6b73eb964ad6c05d1805ab0e1d06b46" translate="yes" xml:space="preserve">
          <source>a stream connected to the given listener.</source>
          <target state="translated">un flujo conectado al oyente dado.</target>
        </trans-unit>
        <trans-unit id="5039d155a71c0a5f7a2b2654ad49cb7ee47a8980" translate="yes" xml:space="preserve">
          <source>bool</source>
          <target state="translated">bool</target>
        </trans-unit>
        <trans-unit id="77cad0de53efabb9d859c964b7508191d55edb0e" translate="yes" xml:space="preserve">
          <source>but of course it may be different if you&amp;rsquo;re implementing some kind of virtual clock.</source>
          <target state="translated">pero, por supuesto, puede ser diferente si est&amp;aacute; implementando alg&amp;uacute;n tipo de reloj virtual.</target>
        </trans-unit>
        <trans-unit id="2a0b61e397ac4fbba6dd82cf6b66dfb129039bb7" translate="yes" xml:space="preserve">
          <source>except that &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; can (and must) be called from a synchronous context.</source>
          <target state="translated">excepto que &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; puede (y debe) ser llamado desde un contexto sincr&amp;oacute;nico.</target>
        </trans-unit>
        <trans-unit id="3154e5a3874003ada68892061573dc875458ace5" translate="yes" xml:space="preserve">
          <source>except that if &lt;code&gt;sync_fn&lt;/code&gt; takes a long time, then the first line will block the Trio loop while it runs, while the second line allows other Trio tasks to continue working while &lt;code&gt;sync_fn&lt;/code&gt; runs. This is accomplished by pushing the call to &lt;code&gt;sync_fn(*args)&lt;/code&gt; off into a worker thread.</source>
          <target state="translated">excepto que si &lt;code&gt;sync_fn&lt;/code&gt; lleva mucho tiempo, la primera l&amp;iacute;nea bloquear&amp;aacute; el bucle Trio mientras se ejecuta, mientras que la segunda l&amp;iacute;nea permitir&amp;aacute; que otras tareas de Trio contin&amp;uacute;en funcionando mientras se ejecuta &lt;code&gt;sync_fn&lt;/code&gt; . Esto se logra presionando la llamada a &lt;code&gt;sync_fn(*args)&lt;/code&gt; en un hilo de trabajo.</target>
        </trans-unit>
        <trans-unit id="685e80366130387cb75c055248326976d16fdf8d" translate="yes" xml:space="preserve">
          <source>float</source>
          <target state="translated">float</target>
        </trans-unit>
        <trans-unit id="b04aaee65bcdd5af32e5866d6ca849f2f6481299" translate="yes" xml:space="preserve">
          <source>forcibly close the socket to prevent accidental re-use</source>
          <target state="translated">cerrar por la fuerza el enchufe para evitar la reutilización accidental</target>
        </trans-unit>
        <trans-unit id="46f8ab7c0cff9df7cd124852e26022a6bf89e315" translate="yes" xml:space="preserve">
          <source>int</source>
          <target state="translated">int</target>
        </trans-unit>
        <trans-unit id="dc7c7a036e7ff86d7041348d3f5c595cf32f848b" translate="yes" xml:space="preserve">
          <source>is the equivalent of:</source>
          <target state="translated">es el equivalente de:</target>
        </trans-unit>
        <trans-unit id="cdf2a9b9770cca84cff07c07ed209cea58b77040" translate="yes" xml:space="preserve">
          <source>list of &lt;a href=&quot;#trio.SocketListener&quot;&gt;&lt;code&gt;SocketListener&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">lista de &lt;a href=&quot;#trio.SocketListener&quot;&gt; &lt;code&gt;SocketListener&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1615307cc4523f183e777df67f168c86908e8007" translate="yes" xml:space="preserve">
          <source>object</source>
          <target state="translated">object</target>
        </trans-unit>
        <trans-unit id="91c7815e33a9c610fffab6b85965803b4c38fe10" translate="yes" xml:space="preserve">
          <source>open_ssl_over_tcp_stream</source>
          <target state="translated">open_ssl_over_tcp_stream</target>
        </trans-unit>
        <trans-unit id="9a2cd608fc634f6422fae3a1601e32e93899153a" translate="yes" xml:space="preserve">
          <source>raise &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">aumento &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9fd50a36be80600cf205943240836997b4dae781" translate="yes" xml:space="preserve">
          <source>that never calls any of Trio&amp;rsquo;s async functions. This is an async function, but it&amp;rsquo;s not a checkpoint. But why make a function async if it never calls any async functions? It&amp;rsquo;s possible, but it&amp;rsquo;s a bad idea. If you have a function that&amp;rsquo;s not calling any async functions, then you should make it synchronous. The people who use your function will thank you, because it makes it obvious that your function is not a checkpoint, and their code reviews will go faster.</source>
          <target state="translated">que nunca llama a ninguna de las funciones as&amp;iacute;ncronas de Trio. Esta es una funci&amp;oacute;n asincr&amp;oacute;nica, pero no es un punto de control. Pero, &amp;iquest;por qu&amp;eacute; hacer una funci&amp;oacute;n as&amp;iacute;ncrona si nunca llama a ninguna funci&amp;oacute;n as&amp;iacute;ncrona? Es posible, pero es una mala idea. Si tiene una funci&amp;oacute;n que no llama a ninguna funci&amp;oacute;n as&amp;iacute;ncrona, entonces deber&amp;iacute;a hacerla sincr&amp;oacute;nica. Las personas que usan su funci&amp;oacute;n se lo agradecer&amp;aacute;n, porque hace obvio que su funci&amp;oacute;n no es un punto de control y sus revisiones de c&amp;oacute;digo ser&amp;aacute;n m&amp;aacute;s r&amp;aacute;pidas.</target>
        </trans-unit>
        <trans-unit id="c99061349fef0290fe3ca6468379aa7cff199037" translate="yes" xml:space="preserve">
          <source>the &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; that called &lt;a href=&quot;#trio.hazmat.current_task&quot;&gt;&lt;code&gt;current_task()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">la &lt;a href=&quot;#trio.hazmat.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; que llam&amp;oacute; &lt;a href=&quot;#trio.hazmat.current_task&quot;&gt; &lt;code&gt;current_task()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dc61f17b652e05559394881b3db364b7f6311d91" translate="yes" xml:space="preserve">
          <source>the &lt;a href=&quot;#trio.lowlevel.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; that called &lt;a href=&quot;#trio.lowlevel.current_task&quot;&gt;&lt;code&gt;current_task()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a9e69b5d794e659edb00d20d3ad49a11b127477" translate="yes" xml:space="preserve">
          <source>the effective deadline, as an absolute time.</source>
          <target state="translated">el plazo efectivo,como un tiempo absoluto.</target>
        </trans-unit>
        <trans-unit id="7c3a6f266d6247d7cd771e1c325b352794e92c00" translate="yes" xml:space="preserve">
          <source>the encrypted connection to the server.</source>
          <target state="translated">la conexión encriptada con el servidor.</target>
        </trans-unit>
        <trans-unit id="ae5091f01cda515d1f122297428e0d9d9abb842a" translate="yes" xml:space="preserve">
          <source>the newly spawned task</source>
          <target state="translated">la recién nacida tarea</target>
        </trans-unit>
        <trans-unit id="8d6554dc96924eb4d77e3e00e5aea6f1bb8ca0a8" translate="yes" xml:space="preserve">
          <source>the program will see one argument &lt;code&gt;foo &quot;bar&quot; baz&lt;/code&gt; but CMD.EXE thinks &lt;code&gt;bar\&lt;/code&gt; is not quoted while &lt;code&gt;foo \&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt; are. All of this makes it a formidable task to reliably interpolate anything into a &lt;code&gt;shell=True&lt;/code&gt; command line on Windows, and Trio falls back on the &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#module-subprocess&quot;&gt;&lt;code&gt;subprocess&lt;/code&gt;&lt;/a&gt; behavior: If you pass a sequence with &lt;code&gt;shell=True&lt;/code&gt;, it&amp;rsquo;s quoted in the same way as a sequence with &lt;code&gt;shell=False&lt;/code&gt;, and had better not contain any shell metacharacters you weren&amp;rsquo;t planning on.</source>
          <target state="translated">el programa ver&amp;aacute; un argumento &lt;code&gt;foo &quot;bar&quot; baz&lt;/code&gt; pero CMD.EXE piensa que &lt;code&gt;bar\&lt;/code&gt; no est&amp;aacute; entre comillas mientras que &lt;code&gt;foo \&lt;/code&gt; y &lt;code&gt;baz&lt;/code&gt; s&amp;iacute; . Todo esto hace que sea una tarea formidable interpolar de manera confiable cualquier cosa en una l&amp;iacute;nea de comando &lt;code&gt;shell=True&lt;/code&gt; en Windows, y Trio &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#module-subprocess&quot;&gt; &lt;code&gt;subprocess&lt;/code&gt; &lt;/a&gt; comportamiento del subproceso : si pasa una secuencia con &lt;code&gt;shell=True&lt;/code&gt; , se cita de la misma manera que una secuencia con &lt;code&gt;shell=False&lt;/code&gt; , y es mejor que no contenga metacaracteres de shell que no est&amp;eacute; planeando.</target>
        </trans-unit>
        <trans-unit id="6fa9fa819747544976a8089d6e7dc99a2e72147c" translate="yes" xml:space="preserve">
          <source>then this &lt;em&gt;won&amp;rsquo;t&lt;/em&gt; catch a &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">entonces esto &lt;em&gt;no&lt;/em&gt; detectar&amp;aacute; una excepci&amp;oacute;n &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7edd5a38751799f207ce0fb360ac04e15a80c88f" translate="yes" xml:space="preserve">
          <source>tl;dr: if &lt;a href=&quot;#trio.socket.SocketType.connect&quot;&gt;&lt;code&gt;connect()&lt;/code&gt;&lt;/a&gt; is cancelled then the socket is left in an unknown state &amp;ndash; possibly open, and possibly closed. The only reasonable thing to do is to close it.</source>
          <target state="translated">tl; dr: si se cancela &lt;a href=&quot;#trio.socket.SocketType.connect&quot;&gt; &lt;code&gt;connect()&lt;/code&gt; &lt;/a&gt; entonces el socket se deja en un estado desconocido, posiblemente abierto y posiblemente cerrado. Lo &amp;uacute;nico razonable que se puede hacer es cerrarlo.</target>
        </trans-unit>
        <trans-unit id="87741b233c2cc78262f503491f3a8495f49cdd4b" translate="yes" xml:space="preserve">
          <source>trio.BrokenResourceError</source>
          <target state="translated">trio.BrokenResourceError</target>
        </trans-unit>
        <trans-unit id="4faabd920eda171b110adb99bf1d08894a816fee" translate="yes" xml:space="preserve">
          <source>trio.BusyResourceError</source>
          <target state="translated">trio.BusyResourceError</target>
        </trans-unit>
        <trans-unit id="9b974b873fbbaf04d4cca8052a7b3d2ca60b0e98" translate="yes" xml:space="preserve">
          <source>trio.CancelScope</source>
          <target state="translated">trio.CancelScope</target>
        </trans-unit>
        <trans-unit id="4920baa45b1585116ebf73761dd11b80179ad186" translate="yes" xml:space="preserve">
          <source>trio.CancelScope.cancel</source>
          <target state="translated">trio.CancelScope.cancel</target>
        </trans-unit>
        <trans-unit id="5c083abcb3bde71d99dde3a8c0c771447e63e638" translate="yes" xml:space="preserve">
          <source>trio.CancelScope.cancel_called</source>
          <target state="translated">trio.CancelScope.cancel_called</target>
        </trans-unit>
        <trans-unit id="b65fceeea97c4d057193f169545f18bfb650937e" translate="yes" xml:space="preserve">
          <source>trio.CancelScope.cancelled_caught</source>
          <target state="translated">trio.CancelScope.cancelled_caught</target>
        </trans-unit>
        <trans-unit id="92f92711eaa71a8239922abbd8a7439a50382a9a" translate="yes" xml:space="preserve">
          <source>trio.CancelScope.deadline</source>
          <target state="translated">trio.CancelScope.deadline</target>
        </trans-unit>
        <trans-unit id="aab9bfe917a12fd4d10b5c54ca88ed322b1a43df" translate="yes" xml:space="preserve">
          <source>trio.CancelScope.shield</source>
          <target state="translated">trio.CancelScope.shield</target>
        </trans-unit>
        <trans-unit id="1495dbc0e63e50fb15f424182d80356b99071c0e" translate="yes" xml:space="preserve">
          <source>trio.Cancelled</source>
          <target state="translated">trio.Cancelled</target>
        </trans-unit>
        <trans-unit id="38532a852db8ff465708e6832163917bbddb3987" translate="yes" xml:space="preserve">
          <source>trio.CapacityLimiter</source>
          <target state="translated">trio.CapacityLimiter</target>
        </trans-unit>
        <trans-unit id="3b4e8e33e050891acdd45f38c55999072d94cb70" translate="yes" xml:space="preserve">
          <source>trio.CapacityLimiter.acquire</source>
          <target state="translated">trio.CapacityLimiter.acquire</target>
        </trans-unit>
        <trans-unit id="3052973e311095a945e302da012f4dd07bceb959" translate="yes" xml:space="preserve">
          <source>trio.CapacityLimiter.acquire_nowait</source>
          <target state="translated">trio.CapacityLimiter.acquire_nowait</target>
        </trans-unit>
        <trans-unit id="b13e58a166c12cacb75150244ed449938669b4a0" translate="yes" xml:space="preserve">
          <source>trio.CapacityLimiter.acquire_on_behalf_of</source>
          <target state="translated">trio.CapacityLimiter.acquire_on_behalf_of</target>
        </trans-unit>
        <trans-unit id="47131bee275ceed0ed6aac36620dfd39cdd4a597" translate="yes" xml:space="preserve">
          <source>trio.CapacityLimiter.acquire_on_behalf_of_nowait</source>
          <target state="translated">trio.CapacityLimiter.acquire_on_behalf_of_nowait</target>
        </trans-unit>
        <trans-unit id="46afc3cef3913298a0c33c7aa35a3bdcd7e72711" translate="yes" xml:space="preserve">
          <source>trio.CapacityLimiter.available_tokens</source>
          <target state="translated">trio.CapacityLimiter.available_tokens</target>
        </trans-unit>
        <trans-unit id="cf684025fd002abbf00d23c9233be969bf8e9f15" translate="yes" xml:space="preserve">
          <source>trio.CapacityLimiter.borrowed_tokens</source>
          <target state="translated">trio.CapacityLimiter.borrowed_tokens</target>
        </trans-unit>
        <trans-unit id="045d1df55f5452fcf6b0b4325c23468efc51d6c4" translate="yes" xml:space="preserve">
          <source>trio.CapacityLimiter.release</source>
          <target state="translated">trio.CapacityLimiter.release</target>
        </trans-unit>
        <trans-unit id="6577f1baeabe124f327be707f159bde14c072a24" translate="yes" xml:space="preserve">
          <source>trio.CapacityLimiter.release_on_behalf_of</source>
          <target state="translated">trio.CapacityLimiter.release_on_behalf_of</target>
        </trans-unit>
        <trans-unit id="c218dc105968173936e5a081bd308b738fad34a6" translate="yes" xml:space="preserve">
          <source>trio.CapacityLimiter.statistics</source>
          <target state="translated">trio.CapacityLimiter.statistics</target>
        </trans-unit>
        <trans-unit id="32428c009582b72108e9b490d9ca48bbe9401c5e" translate="yes" xml:space="preserve">
          <source>trio.CapacityLimiter.total_tokens</source>
          <target state="translated">trio.CapacityLimiter.total_tokens</target>
        </trans-unit>
        <trans-unit id="1b4a65eaae06c22bddd85d22bb1dece1cc6b08fd" translate="yes" xml:space="preserve">
          <source>trio.ClosedResourceError</source>
          <target state="translated">trio.ClosedResourceError</target>
        </trans-unit>
        <trans-unit id="03735eebe4de0fabd8f2c51569ca8eb6150edddf" translate="yes" xml:space="preserve">
          <source>trio.Condition</source>
          <target state="translated">trio.Condition</target>
        </trans-unit>
        <trans-unit id="64e0dacab0e79dfcf0bb3947eea1007bfbac924e" translate="yes" xml:space="preserve">
          <source>trio.Condition.acquire</source>
          <target state="translated">trio.Condition.acquire</target>
        </trans-unit>
        <trans-unit id="945d9cb0754c2dc3750f9d27bdc4dda459a3f6af" translate="yes" xml:space="preserve">
          <source>trio.Condition.acquire_nowait</source>
          <target state="translated">trio.Condition.acquire_nowait</target>
        </trans-unit>
        <trans-unit id="0315af336b1b481ab49b04b5f4582676818b0d83" translate="yes" xml:space="preserve">
          <source>trio.Condition.locked</source>
          <target state="translated">trio.Condition.locked</target>
        </trans-unit>
        <trans-unit id="1e7e83352ee370c2f4ea217a547acfdb1397f607" translate="yes" xml:space="preserve">
          <source>trio.Condition.notify</source>
          <target state="translated">trio.Condition.notify</target>
        </trans-unit>
        <trans-unit id="d848616c8fa2d1ec484c6581fcd878b027371e99" translate="yes" xml:space="preserve">
          <source>trio.Condition.notify_all</source>
          <target state="translated">trio.Condition.notify_all</target>
        </trans-unit>
        <trans-unit id="bcb4444ce5c2d6c94ebad0e952dacfe072eeca3f" translate="yes" xml:space="preserve">
          <source>trio.Condition.release</source>
          <target state="translated">trio.Condition.release</target>
        </trans-unit>
        <trans-unit id="1d036063c7c52b8c5bb70e76b16c752433f7be3e" translate="yes" xml:space="preserve">
          <source>trio.Condition.statistics</source>
          <target state="translated">trio.Condition.statistics</target>
        </trans-unit>
        <trans-unit id="2cab378407bebe21e3de6a5ec95b5425861725f2" translate="yes" xml:space="preserve">
          <source>trio.Condition.wait</source>
          <target state="translated">trio.Condition.wait</target>
        </trans-unit>
        <trans-unit id="01db248fe1d1e0822a01f6e8a8952aad1d62f2e5" translate="yes" xml:space="preserve">
          <source>trio.EndOfChannel</source>
          <target state="translated">trio.EndOfChannel</target>
        </trans-unit>
        <trans-unit id="0d63b4a5179b72b0ba26f9ac3be63b45d96e28a8" translate="yes" xml:space="preserve">
          <source>trio.Event</source>
          <target state="translated">trio.Event</target>
        </trans-unit>
        <trans-unit id="7749517203c365b1910f5484033b59c65640c5d6" translate="yes" xml:space="preserve">
          <source>trio.Event.is_set</source>
          <target state="translated">trio.Event.is_set</target>
        </trans-unit>
        <trans-unit id="e08b82b0c067915092294ab18a099e79642241c8" translate="yes" xml:space="preserve">
          <source>trio.Event.set</source>
          <target state="translated">trio.Event.set</target>
        </trans-unit>
        <trans-unit id="1ba4656fe573e30ec9e885d076bc40c88ab0fe5f" translate="yes" xml:space="preserve">
          <source>trio.Event.statistics</source>
          <target state="translated">trio.Event.statistics</target>
        </trans-unit>
        <trans-unit id="a7457b9c6a0c02333d051793fdf80df853391ca1" translate="yes" xml:space="preserve">
          <source>trio.Event.wait</source>
          <target state="translated">trio.Event.wait</target>
        </trans-unit>
        <trans-unit id="1cf59d5da988771020b3e0e7429ee4b79fa9f979" translate="yes" xml:space="preserve">
          <source>trio.Lock</source>
          <target state="translated">trio.Lock</target>
        </trans-unit>
        <trans-unit id="d633b948aa9f844cdf1b98ab6925e0bec1b2e453" translate="yes" xml:space="preserve">
          <source>trio.Lock.acquire</source>
          <target state="translated">trio.Lock.acquire</target>
        </trans-unit>
        <trans-unit id="7b361a3b5884f18821c59cd390b717c141f3a43f" translate="yes" xml:space="preserve">
          <source>trio.Lock.acquire_nowait</source>
          <target state="translated">trio.Lock.acquire_nowait</target>
        </trans-unit>
        <trans-unit id="f86da8dcc1fa815ba85e422458658e5f22adfaad" translate="yes" xml:space="preserve">
          <source>trio.Lock.locked</source>
          <target state="translated">trio.Lock.locked</target>
        </trans-unit>
        <trans-unit id="d6045a56b39447852827d60307fa7d35de7cec95" translate="yes" xml:space="preserve">
          <source>trio.Lock.release</source>
          <target state="translated">trio.Lock.release</target>
        </trans-unit>
        <trans-unit id="0b7d9e43e0be75f994ef953bcb3f4ffcec01f328" translate="yes" xml:space="preserve">
          <source>trio.Lock.statistics</source>
          <target state="translated">trio.Lock.statistics</target>
        </trans-unit>
        <trans-unit id="78e5f12a4f57d39a487d8ac0772abf229b3c4393" translate="yes" xml:space="preserve">
          <source>trio.MemoryReceiveChannel</source>
          <target state="translated">trio.MemoryReceiveChannel</target>
        </trans-unit>
        <trans-unit id="108d6e10855287c416ef308d84c8a07a06082ede" translate="yes" xml:space="preserve">
          <source>trio.MemoryReceiveChannel.clone</source>
          <target state="translated">trio.MemoryReceiveChannel.clone</target>
        </trans-unit>
        <trans-unit id="be9c3678e2d106615286508fddb65c7df45ce556" translate="yes" xml:space="preserve">
          <source>trio.MemoryReceiveChannel.receive</source>
          <target state="translated">trio.MemoryReceiveChannel.receive</target>
        </trans-unit>
        <trans-unit id="fce5a2406bed66b19c15633653eef1152daf5be5" translate="yes" xml:space="preserve">
          <source>trio.MemoryReceiveChannel.receive_nowait</source>
          <target state="translated">trio.MemoryReceiveChannel.receive_nowait</target>
        </trans-unit>
        <trans-unit id="2eb4b49e21017b91f2f304d22436616defad8fee" translate="yes" xml:space="preserve">
          <source>trio.MemorySendChannel</source>
          <target state="translated">trio.MemorySendChannel</target>
        </trans-unit>
        <trans-unit id="bfb678e05e31677cf1559641988c5b00c0904637" translate="yes" xml:space="preserve">
          <source>trio.MemorySendChannel.clone</source>
          <target state="translated">trio.MemorySendChannel.clone</target>
        </trans-unit>
        <trans-unit id="9d1deb18f57cd2514b5a2304be1926da71a96674" translate="yes" xml:space="preserve">
          <source>trio.MemorySendChannel.send</source>
          <target state="translated">trio.MemorySendChannel.send</target>
        </trans-unit>
        <trans-unit id="c2089f8aa644b3d080241ec8e934d7f188a59616" translate="yes" xml:space="preserve">
          <source>trio.MemorySendChannel.send_nowait</source>
          <target state="translated">trio.MemorySendChannel.send_nowait</target>
        </trans-unit>
        <trans-unit id="10efaedb6cf45fb2b8f43b87d918366df5336129" translate="yes" xml:space="preserve">
          <source>trio.MultiError</source>
          <target state="translated">trio.MultiError</target>
        </trans-unit>
        <trans-unit id="12d2a4e4998ebb25a094937b5055e57d835ebee4" translate="yes" xml:space="preserve">
          <source>trio.MultiError.catch</source>
          <target state="translated">trio.MultiError.catch</target>
        </trans-unit>
        <trans-unit id="26d8d3d3632d98e535d0f9572356901f2e8b3042" translate="yes" xml:space="preserve">
          <source>trio.MultiError.exceptions</source>
          <target state="translated">trio.MultiError.exceptions</target>
        </trans-unit>
        <trans-unit id="77441b639d5f7ad74295e114f74156b855cb3c8f" translate="yes" xml:space="preserve">
          <source>trio.MultiError.filter</source>
          <target state="translated">trio.MultiError.filter</target>
        </trans-unit>
        <trans-unit id="cf189386a700c42d73eee8c3145915ac2c7bc850" translate="yes" xml:space="preserve">
          <source>trio.NeedHandshakeError</source>
          <target state="translated">trio.NeedHandshakeError</target>
        </trans-unit>
        <trans-unit id="8b6fb9ab36e2a18a0e93b43db1cb843c1cd1f2d7" translate="yes" xml:space="preserve">
          <source>trio.Nursery</source>
          <target state="translated">trio.Nursery</target>
        </trans-unit>
        <trans-unit id="f2ccf4921c3ccceaa76ab2b6dfa6d5a4ff78280d" translate="yes" xml:space="preserve">
          <source>trio.Nursery.cancel_scope</source>
          <target state="translated">trio.Nursery.cancel_scope</target>
        </trans-unit>
        <trans-unit id="fef3dc2b89a4992e07e688c552617340e2a706d1" translate="yes" xml:space="preserve">
          <source>trio.Nursery.child_tasks</source>
          <target state="translated">trio.Nursery.child_tasks</target>
        </trans-unit>
        <trans-unit id="c028b5baa182961b20a38444729c66e3dba3550f" translate="yes" xml:space="preserve">
          <source>trio.Nursery.parent_task</source>
          <target state="translated">trio.Nursery.parent_task</target>
        </trans-unit>
        <trans-unit id="f13159076206ab5c13a120097ff142b2d5a80bfc" translate="yes" xml:space="preserve">
          <source>trio.Nursery.start</source>
          <target state="translated">trio.Nursery.start</target>
        </trans-unit>
        <trans-unit id="5c7547330bc7c3ee062a484a255d4bc816b39ca2" translate="yes" xml:space="preserve">
          <source>trio.Nursery.start_soon</source>
          <target state="translated">trio.Nursery.start_soon</target>
        </trans-unit>
        <trans-unit id="463adb0ec3c52ceb3274124651ede96c2f705a31" translate="yes" xml:space="preserve">
          <source>trio.Path</source>
          <target state="translated">trio.Path</target>
        </trans-unit>
        <trans-unit id="41e545b55bc4e503ae90042d0907674b234a820b" translate="yes" xml:space="preserve">
          <source>trio.Path.as_posix</source>
          <target state="translated">trio.Path.as_posix</target>
        </trans-unit>
        <trans-unit id="cecfda6d7930c6c32b4bafe8681bd75eb4b1ad5b" translate="yes" xml:space="preserve">
          <source>trio.Path.as_uri</source>
          <target state="translated">trio.Path.as_uri</target>
        </trans-unit>
        <trans-unit id="6d6a79998bb77febb7b551f992342e9a39ff8c32" translate="yes" xml:space="preserve">
          <source>trio.Path.chmod</source>
          <target state="translated">trio.Path.chmod</target>
        </trans-unit>
        <trans-unit id="6264ec9b15893969518beac5b8b6e1cf388f6b31" translate="yes" xml:space="preserve">
          <source>trio.Path.cwd</source>
          <target state="translated">trio.Path.cwd</target>
        </trans-unit>
        <trans-unit id="d65467140ed7ccbea8b30dd817d0736e31039418" translate="yes" xml:space="preserve">
          <source>trio.Path.exists</source>
          <target state="translated">trio.Path.exists</target>
        </trans-unit>
        <trans-unit id="30d399ac7574c17ad32e316771e23d797e793577" translate="yes" xml:space="preserve">
          <source>trio.Path.expanduser</source>
          <target state="translated">trio.Path.expanduser</target>
        </trans-unit>
        <trans-unit id="a7466bdf1da56d74761eca21b3ef2a6c73d12e4d" translate="yes" xml:space="preserve">
          <source>trio.Path.glob</source>
          <target state="translated">trio.Path.glob</target>
        </trans-unit>
        <trans-unit id="4bb91a142b4daab33d560e2283bdfe6a8d43099c" translate="yes" xml:space="preserve">
          <source>trio.Path.group</source>
          <target state="translated">trio.Path.group</target>
        </trans-unit>
        <trans-unit id="ba365a91df5c8a410ac32c3e4597a11db816203a" translate="yes" xml:space="preserve">
          <source>trio.Path.home</source>
          <target state="translated">trio.Path.home</target>
        </trans-unit>
        <trans-unit id="a23bb252840218cfa53d9491ae0042deb1182452" translate="yes" xml:space="preserve">
          <source>trio.Path.is_absolute</source>
          <target state="translated">trio.Path.is_absolute</target>
        </trans-unit>
        <trans-unit id="ba83d5209b0eb9a363f163ce8632091fa6f398f5" translate="yes" xml:space="preserve">
          <source>trio.Path.is_block_device</source>
          <target state="translated">trio.Path.is_block_device</target>
        </trans-unit>
        <trans-unit id="e8bbb29bda3f94e08ceabf6cb2251ce75c67502b" translate="yes" xml:space="preserve">
          <source>trio.Path.is_char_device</source>
          <target state="translated">trio.Path.is_char_device</target>
        </trans-unit>
        <trans-unit id="a30c97ff9404dfd5c2efac442bbdf5b03bf835f5" translate="yes" xml:space="preserve">
          <source>trio.Path.is_dir</source>
          <target state="translated">trio.Path.is_dir</target>
        </trans-unit>
        <trans-unit id="338b64de8263afc924e091a60925ba9a5cba1d8b" translate="yes" xml:space="preserve">
          <source>trio.Path.is_fifo</source>
          <target state="translated">trio.Path.is_fifo</target>
        </trans-unit>
        <trans-unit id="083283f1193a39af46a1511606528f334858e1c6" translate="yes" xml:space="preserve">
          <source>trio.Path.is_file</source>
          <target state="translated">trio.Path.is_file</target>
        </trans-unit>
        <trans-unit id="b132aa47c930d401ca40bbb05475e3967e345eed" translate="yes" xml:space="preserve">
          <source>trio.Path.is_reserved</source>
          <target state="translated">trio.Path.is_reserved</target>
        </trans-unit>
        <trans-unit id="2465eec20154630e31612cfe7c53c5cae0ccca8a" translate="yes" xml:space="preserve">
          <source>trio.Path.is_socket</source>
          <target state="translated">trio.Path.is_socket</target>
        </trans-unit>
        <trans-unit id="dedd6c61c0c4196e0c47a059c98257c0c014f902" translate="yes" xml:space="preserve">
          <source>trio.Path.is_symlink</source>
          <target state="translated">trio.Path.is_symlink</target>
        </trans-unit>
        <trans-unit id="aeea756d025c6726e8841678bf114ea9d53335c2" translate="yes" xml:space="preserve">
          <source>trio.Path.iterdir</source>
          <target state="translated">trio.Path.iterdir</target>
        </trans-unit>
        <trans-unit id="6c0c0f1510aa03f8fed405b70cde5c65c2d5b33b" translate="yes" xml:space="preserve">
          <source>trio.Path.joinpath</source>
          <target state="translated">trio.Path.joinpath</target>
        </trans-unit>
        <trans-unit id="ba4f894f44e4f0d7e258c49bdcda6493f84c0c68" translate="yes" xml:space="preserve">
          <source>trio.Path.lchmod</source>
          <target state="translated">trio.Path.lchmod</target>
        </trans-unit>
        <trans-unit id="65a04b36da154cf4291a3935b556c9b5bfb90056" translate="yes" xml:space="preserve">
          <source>trio.Path.lstat</source>
          <target state="translated">trio.Path.lstat</target>
        </trans-unit>
        <trans-unit id="e13a8010ede3fdd986f4892ec43fbfc932344413" translate="yes" xml:space="preserve">
          <source>trio.Path.match</source>
          <target state="translated">trio.Path.match</target>
        </trans-unit>
        <trans-unit id="76f7b3ec233072ba5f70bb91485bb5edb7d340b2" translate="yes" xml:space="preserve">
          <source>trio.Path.mkdir</source>
          <target state="translated">trio.Path.mkdir</target>
        </trans-unit>
        <trans-unit id="a2dd4873471dd5a6aa6b020c49300b224af01678" translate="yes" xml:space="preserve">
          <source>trio.Path.open</source>
          <target state="translated">trio.Path.open</target>
        </trans-unit>
        <trans-unit id="c8bc289f4e9cc9b014ae2e1257db083d3203ca15" translate="yes" xml:space="preserve">
          <source>trio.Path.owner</source>
          <target state="translated">trio.Path.owner</target>
        </trans-unit>
        <trans-unit id="ebf09093912c3958365d5ac83d0122d7b07504bd" translate="yes" xml:space="preserve">
          <source>trio.Path.read_bytes</source>
          <target state="translated">trio.Path.read_bytes</target>
        </trans-unit>
        <trans-unit id="cf4fe105374100baba575f8bba8ffd84bec3f78e" translate="yes" xml:space="preserve">
          <source>trio.Path.read_text</source>
          <target state="translated">trio.Path.read_text</target>
        </trans-unit>
        <trans-unit id="1ad287e9d5985a30f6c7df76e14f0197c127a554" translate="yes" xml:space="preserve">
          <source>trio.Path.relative_to</source>
          <target state="translated">trio.Path.relative_to</target>
        </trans-unit>
        <trans-unit id="27ea427591aefc0aa9e2e647c5a31adbb66d5bd6" translate="yes" xml:space="preserve">
          <source>trio.Path.rename</source>
          <target state="translated">trio.Path.rename</target>
        </trans-unit>
        <trans-unit id="67bb2789807e00f644acda7368543604c9281d14" translate="yes" xml:space="preserve">
          <source>trio.Path.replace</source>
          <target state="translated">trio.Path.replace</target>
        </trans-unit>
        <trans-unit id="4f1922abe367a78f3a37f31eac9705e8bc69b7cc" translate="yes" xml:space="preserve">
          <source>trio.Path.resolve</source>
          <target state="translated">trio.Path.resolve</target>
        </trans-unit>
        <trans-unit id="4fb7688f41df71cff26b44ef8e084023ce7339cd" translate="yes" xml:space="preserve">
          <source>trio.Path.rglob</source>
          <target state="translated">trio.Path.rglob</target>
        </trans-unit>
        <trans-unit id="a3d9f8e1ad0ffa9cb2844fd4b0e0e8b0acfe5062" translate="yes" xml:space="preserve">
          <source>trio.Path.rmdir</source>
          <target state="translated">trio.Path.rmdir</target>
        </trans-unit>
        <trans-unit id="06d43545f10c00eedfdd2f81fae56bc281c8cb1a" translate="yes" xml:space="preserve">
          <source>trio.Path.samefile</source>
          <target state="translated">trio.Path.samefile</target>
        </trans-unit>
        <trans-unit id="f4bb6ee0e047f6c279fa93dbe17ee0da353ca874" translate="yes" xml:space="preserve">
          <source>trio.Path.stat</source>
          <target state="translated">trio.Path.stat</target>
        </trans-unit>
        <trans-unit id="4f8149328b50af4c60f03d656293000dbab0a193" translate="yes" xml:space="preserve">
          <source>trio.Path.symlink_to</source>
          <target state="translated">trio.Path.symlink_to</target>
        </trans-unit>
        <trans-unit id="5b03e6f426a315a5a9738bb8c705186a179ad5e0" translate="yes" xml:space="preserve">
          <source>trio.Path.touch</source>
          <target state="translated">trio.Path.touch</target>
        </trans-unit>
        <trans-unit id="ca6540c33dd630ad6acc3cd3506ecea10a639a62" translate="yes" xml:space="preserve">
          <source>trio.Path.unlink</source>
          <target state="translated">trio.Path.unlink</target>
        </trans-unit>
        <trans-unit id="2b386dec09b8cbe1d4e9f4093f02277d57a00dd1" translate="yes" xml:space="preserve">
          <source>trio.Path.with_name</source>
          <target state="translated">trio.Path.with_name</target>
        </trans-unit>
        <trans-unit id="4416574f3d7a991d545312ef1d6b4dabeb1a8e03" translate="yes" xml:space="preserve">
          <source>trio.Path.with_suffix</source>
          <target state="translated">trio.Path.with_suffix</target>
        </trans-unit>
        <trans-unit id="c1c1d6c08945dc6cbdfa9d2aec8c880ce6ded5c4" translate="yes" xml:space="preserve">
          <source>trio.Path.write_bytes</source>
          <target state="translated">trio.Path.write_bytes</target>
        </trans-unit>
        <trans-unit id="92d9d90cef01964b23091f0a761cca59acc47fc7" translate="yes" xml:space="preserve">
          <source>trio.Path.write_text</source>
          <target state="translated">trio.Path.write_text</target>
        </trans-unit>
        <trans-unit id="b95629e12adfc03a5e7d69c785aafff955b36b24" translate="yes" xml:space="preserve">
          <source>trio.Process</source>
          <target state="translated">trio.Process</target>
        </trans-unit>
        <trans-unit id="d2f5180d7c9c7ab8cdfb057bb193fd6f44072ced" translate="yes" xml:space="preserve">
          <source>trio.Process.aclose</source>
          <target state="translated">trio.Process.aclose</target>
        </trans-unit>
        <trans-unit id="e46ef8b25a27e896bc157b8abb02ac109f95e179" translate="yes" xml:space="preserve">
          <source>trio.Process.args</source>
          <target state="translated">trio.Process.args</target>
        </trans-unit>
        <trans-unit id="20ac78b91fc5413a3d21c4fafeb78dfbcc69bee8" translate="yes" xml:space="preserve">
          <source>trio.Process.kill</source>
          <target state="translated">trio.Process.kill</target>
        </trans-unit>
        <trans-unit id="f146b8e74c1f60facca2f7c32f2e84ac347a94da" translate="yes" xml:space="preserve">
          <source>trio.Process.pid</source>
          <target state="translated">trio.Process.pid</target>
        </trans-unit>
        <trans-unit id="ff52c1030198fec8bcc8ee2ff4909a129ca802e1" translate="yes" xml:space="preserve">
          <source>trio.Process.poll</source>
          <target state="translated">trio.Process.poll</target>
        </trans-unit>
        <trans-unit id="bb5e8d251fd94df4b4f85a5862b90f20408f9f75" translate="yes" xml:space="preserve">
          <source>trio.Process.returncode</source>
          <target state="translated">trio.Process.returncode</target>
        </trans-unit>
        <trans-unit id="c354161dab84a8f646bfde68086236e96b786ae6" translate="yes" xml:space="preserve">
          <source>trio.Process.send_signal</source>
          <target state="translated">trio.Process.send_signal</target>
        </trans-unit>
        <trans-unit id="648b9349f3ca09033167dc6562019d96eac78908" translate="yes" xml:space="preserve">
          <source>trio.Process.stderr</source>
          <target state="translated">trio.Process.stderr</target>
        </trans-unit>
        <trans-unit id="d8d2a3dadfc889cd719749b131000d137557e183" translate="yes" xml:space="preserve">
          <source>trio.Process.stdin</source>
          <target state="translated">trio.Process.stdin</target>
        </trans-unit>
        <trans-unit id="c670edca33439e00eb71504aac27e335a8da489e" translate="yes" xml:space="preserve">
          <source>trio.Process.stdio</source>
          <target state="translated">trio.Process.stdio</target>
        </trans-unit>
        <trans-unit id="ac9fce0a07a87d83c7ddb69cdb8e00571eec76ff" translate="yes" xml:space="preserve">
          <source>trio.Process.stdout</source>
          <target state="translated">trio.Process.stdout</target>
        </trans-unit>
        <trans-unit id="b9036113d94a00c7647cc4ac4a41af6f403deffd" translate="yes" xml:space="preserve">
          <source>trio.Process.terminate</source>
          <target state="translated">trio.Process.terminate</target>
        </trans-unit>
        <trans-unit id="d66e22328aa943d8bc5fc842ae3b1def3c9703fa" translate="yes" xml:space="preserve">
          <source>trio.Process.wait</source>
          <target state="translated">trio.Process.wait</target>
        </trans-unit>
        <trans-unit id="b432532132175eedeadbd57ce4ced5ad6c997d18" translate="yes" xml:space="preserve">
          <source>trio.RunFinishedError</source>
          <target state="translated">trio.RunFinishedError</target>
        </trans-unit>
        <trans-unit id="bce53b871c5e108da130854e741bb4032af39c87" translate="yes" xml:space="preserve">
          <source>trio.SSLListener</source>
          <target state="translated">trio.SSLListener</target>
        </trans-unit>
        <trans-unit id="cdb4181469f12ac4791d59127a12109c868b4dfd" translate="yes" xml:space="preserve">
          <source>trio.SSLListener.accept</source>
          <target state="translated">trio.SSLListener.accept</target>
        </trans-unit>
        <trans-unit id="f302e75867185e0832e2c4c73b8eb88d8519658e" translate="yes" xml:space="preserve">
          <source>trio.SSLListener.aclose</source>
          <target state="translated">trio.SSLListener.aclose</target>
        </trans-unit>
        <trans-unit id="95dffd22046f979ad9e369f3b8f1cb10f3cd145e" translate="yes" xml:space="preserve">
          <source>trio.SSLListener.transport_listener</source>
          <target state="translated">trio.SSLListener.transport_listener</target>
        </trans-unit>
        <trans-unit id="79996c48b89942b0400eccfd6f3303a41e33a39d" translate="yes" xml:space="preserve">
          <source>trio.SSLStream</source>
          <target state="translated">trio.SSLStream</target>
        </trans-unit>
        <trans-unit id="645e98a80540d0f5fc979e4f5ab5805dca8e5f8b" translate="yes" xml:space="preserve">
          <source>trio.SSLStream.aclose</source>
          <target state="translated">trio.SSLStream.aclose</target>
        </trans-unit>
        <trans-unit id="b52305dacbf92d9d5dea65b87130c9231a4f9c89" translate="yes" xml:space="preserve">
          <source>trio.SSLStream.do_handshake</source>
          <target state="translated">trio.SSLStream.do_handshake</target>
        </trans-unit>
        <trans-unit id="89c72822574930e17ccd9f4f5f7c3b8a22702664" translate="yes" xml:space="preserve">
          <source>trio.SSLStream.receive_some</source>
          <target state="translated">trio.SSLStream.receive_some</target>
        </trans-unit>
        <trans-unit id="3002921c20ec1649587d2af55021784fbdb390ac" translate="yes" xml:space="preserve">
          <source>trio.SSLStream.send_all</source>
          <target state="translated">trio.SSLStream.send_all</target>
        </trans-unit>
        <trans-unit id="cb30fe2bb451948acff6bf45af2327c61664facb" translate="yes" xml:space="preserve">
          <source>trio.SSLStream.transport_stream</source>
          <target state="translated">trio.SSLStream.transport_stream</target>
        </trans-unit>
        <trans-unit id="9d336db7cf154af476ade7b29be45c39cc20929e" translate="yes" xml:space="preserve">
          <source>trio.SSLStream.unwrap</source>
          <target state="translated">trio.SSLStream.unwrap</target>
        </trans-unit>
        <trans-unit id="a7e6be5e068c0727f227d5863123f884f93ca79d" translate="yes" xml:space="preserve">
          <source>trio.SSLStream.wait_send_all_might_not_block</source>
          <target state="translated">trio.SSLStream.wait_send_all_might_not_block</target>
        </trans-unit>
        <trans-unit id="93fcd7f69d7379f91e3c378270b6a09b7029e021" translate="yes" xml:space="preserve">
          <source>trio.Semaphore</source>
          <target state="translated">trio.Semaphore</target>
        </trans-unit>
        <trans-unit id="446c68562b7734346b004f7ec3b67ca1f362370c" translate="yes" xml:space="preserve">
          <source>trio.Semaphore.acquire</source>
          <target state="translated">trio.Semaphore.acquire</target>
        </trans-unit>
        <trans-unit id="75b075b64d8547d3e44c126a255aa29665b23a25" translate="yes" xml:space="preserve">
          <source>trio.Semaphore.acquire_nowait</source>
          <target state="translated">trio.Semaphore.acquire_nowait</target>
        </trans-unit>
        <trans-unit id="6a53ec5da9ac229aa475f2ece4f15a9d57965fdc" translate="yes" xml:space="preserve">
          <source>trio.Semaphore.max_value</source>
          <target state="translated">trio.Semaphore.max_value</target>
        </trans-unit>
        <trans-unit id="a3288f42af1bb29dba4446fe8443ec9f9eaef81a" translate="yes" xml:space="preserve">
          <source>trio.Semaphore.release</source>
          <target state="translated">trio.Semaphore.release</target>
        </trans-unit>
        <trans-unit id="89e3bfe201338d35663c9d7e9f929dad41f15ed9" translate="yes" xml:space="preserve">
          <source>trio.Semaphore.statistics</source>
          <target state="translated">trio.Semaphore.statistics</target>
        </trans-unit>
        <trans-unit id="abd9e54f657a8cdc87a40ea57223a38d62753bfd" translate="yes" xml:space="preserve">
          <source>trio.Semaphore.value</source>
          <target state="translated">trio.Semaphore.value</target>
        </trans-unit>
        <trans-unit id="6672a59b097e19ef0087b1c3d92a05ad09477767" translate="yes" xml:space="preserve">
          <source>trio.SocketListener</source>
          <target state="translated">trio.SocketListener</target>
        </trans-unit>
        <trans-unit id="573ece5164e06e6877102aa0f01e2739a11c6b8f" translate="yes" xml:space="preserve">
          <source>trio.SocketListener.accept</source>
          <target state="translated">trio.SocketListener.accept</target>
        </trans-unit>
        <trans-unit id="051e34755bee16a84c1a0cecab08ff83338e64c6" translate="yes" xml:space="preserve">
          <source>trio.SocketListener.aclose</source>
          <target state="translated">trio.SocketListener.aclose</target>
        </trans-unit>
        <trans-unit id="d049939b5066435d7b4608aab55adbccac0087e4" translate="yes" xml:space="preserve">
          <source>trio.SocketListener.socket</source>
          <target state="translated">trio.SocketListener.socket</target>
        </trans-unit>
        <trans-unit id="c191148bb18311e87d520b759a81b1b1c927e0e2" translate="yes" xml:space="preserve">
          <source>trio.SocketStream</source>
          <target state="translated">trio.SocketStream</target>
        </trans-unit>
        <trans-unit id="58887391e1f3209066d0ddd1578b6380aef781be" translate="yes" xml:space="preserve">
          <source>trio.SocketStream.aclose</source>
          <target state="translated">trio.SocketStream.aclose</target>
        </trans-unit>
        <trans-unit id="5729999279fd58366c4bfb0b3a8c4c0a356c24fd" translate="yes" xml:space="preserve">
          <source>trio.SocketStream.getsockopt</source>
          <target state="translated">trio.SocketStream.getsockopt</target>
        </trans-unit>
        <trans-unit id="7001de0eaa68ceb88b4d87ec6024b3661d5d1d6e" translate="yes" xml:space="preserve">
          <source>trio.SocketStream.receive_some</source>
          <target state="translated">trio.SocketStream.receive_some</target>
        </trans-unit>
        <trans-unit id="006017fa57dd7c6851aceafd2e6140dfd1d4ecbf" translate="yes" xml:space="preserve">
          <source>trio.SocketStream.send_all</source>
          <target state="translated">trio.SocketStream.send_all</target>
        </trans-unit>
        <trans-unit id="0822c05eedf78bda8aa1f3129c7497ab6cde049e" translate="yes" xml:space="preserve">
          <source>trio.SocketStream.send_eof</source>
          <target state="translated">trio.SocketStream.send_eof</target>
        </trans-unit>
        <trans-unit id="fd5e5376987dcf67c8f1c1799a79178982c54aa6" translate="yes" xml:space="preserve">
          <source>trio.SocketStream.setsockopt</source>
          <target state="translated">trio.SocketStream.setsockopt</target>
        </trans-unit>
        <trans-unit id="2ccfb13b68e4da87e3f3e9169aab7bc2f28b6fb2" translate="yes" xml:space="preserve">
          <source>trio.SocketStream.socket</source>
          <target state="translated">trio.SocketStream.socket</target>
        </trans-unit>
        <trans-unit id="598874eb3242ae514a8fee6455dac8ad34885585" translate="yes" xml:space="preserve">
          <source>trio.SocketStream.wait_send_all_might_not_block</source>
          <target state="translated">trio.SocketStream.wait_send_all_might_not_block</target>
        </trans-unit>
        <trans-unit id="f0b25cbd198f0aff922ce1337411e8c599b8626e" translate="yes" xml:space="preserve">
          <source>trio.StapledStream</source>
          <target state="translated">trio.StapledStream</target>
        </trans-unit>
        <trans-unit id="b1e796a929efe32976ccbbf7f4aaf9a055be860f" translate="yes" xml:space="preserve">
          <source>trio.StapledStream.aclose</source>
          <target state="translated">trio.StapledStream.aclose</target>
        </trans-unit>
        <trans-unit id="aaf3c1d141014c9ea813151e99d94f77261dcec5" translate="yes" xml:space="preserve">
          <source>trio.StapledStream.receive_some</source>
          <target state="translated">trio.StapledStream.receive_some</target>
        </trans-unit>
        <trans-unit id="ae7a98f57b9885892f45544c9031e8005ac5e101" translate="yes" xml:space="preserve">
          <source>trio.StapledStream.receive_stream</source>
          <target state="translated">trio.StapledStream.receive_stream</target>
        </trans-unit>
        <trans-unit id="8809f5b0ad445c8c84d7ed456ee965df79feb472" translate="yes" xml:space="preserve">
          <source>trio.StapledStream.send_all</source>
          <target state="translated">trio.StapledStream.send_all</target>
        </trans-unit>
        <trans-unit id="84451f90926f20560f3cb4d17e3415df29f62100" translate="yes" xml:space="preserve">
          <source>trio.StapledStream.send_eof</source>
          <target state="translated">trio.StapledStream.send_eof</target>
        </trans-unit>
        <trans-unit id="4daeadbd28d194d8af9d83a0ed0679e6f35c1e13" translate="yes" xml:space="preserve">
          <source>trio.StapledStream.send_stream</source>
          <target state="translated">trio.StapledStream.send_stream</target>
        </trans-unit>
        <trans-unit id="58747e02691eaca63ab2cdb5597f924661356ba4" translate="yes" xml:space="preserve">
          <source>trio.StapledStream.wait_send_all_might_not_block</source>
          <target state="translated">trio.StapledStream.wait_send_all_might_not_block</target>
        </trans-unit>
        <trans-unit id="eb243569a6081f57227d8204d5218c1af273d5ac" translate="yes" xml:space="preserve">
          <source>trio.StrictFIFOLock</source>
          <target state="translated">trio.StrictFIFOLock</target>
        </trans-unit>
        <trans-unit id="a7ffc868348e2b1bb549c2955194a01ea4a32544" translate="yes" xml:space="preserve">
          <source>trio.TASK_STATUS_IGNORED</source>
          <target state="translated">trio.TASK_STATUS_IGNORED</target>
        </trans-unit>
        <trans-unit id="97a524a1c2360898f0ed8e30706be6306ef9d6fb" translate="yes" xml:space="preserve">
          <source>trio.TooSlowError</source>
          <target state="translated">trio.TooSlowError</target>
        </trans-unit>
        <trans-unit id="e6967aa9af2be65bbf540dbefc4b412f18386250" translate="yes" xml:space="preserve">
          <source>trio.TrioDeprecationWarning</source>
          <target state="translated">trio.TrioDeprecationWarning</target>
        </trans-unit>
        <trans-unit id="2b859f724e78f2eea92dbe0623732aabd5187178" translate="yes" xml:space="preserve">
          <source>trio.TrioInternalError</source>
          <target state="translated">trio.TrioInternalError</target>
        </trans-unit>
        <trans-unit id="d11cff665946ccb7c4e80132cc152036a8b543e0" translate="yes" xml:space="preserve">
          <source>trio.WouldBlock</source>
          <target state="translated">trio.WouldBlock</target>
        </trans-unit>
        <trans-unit id="fbf8caf47f2c98a730ba658809dab466258dc2a9" translate="yes" xml:space="preserve">
          <source>trio.abc.AsyncResource</source>
          <target state="translated">trio.abc.AsyncResource</target>
        </trans-unit>
        <trans-unit id="07e3ff9f796d690cd8d79f3f7784b479e27a36f0" translate="yes" xml:space="preserve">
          <source>trio.abc.AsyncResource.aclose</source>
          <target state="translated">trio.abc.AsyncResource.aclose</target>
        </trans-unit>
        <trans-unit id="d32cbf56b9c66b5bf5b84cfa7570bc5ee714ed86" translate="yes" xml:space="preserve">
          <source>trio.abc.Channel</source>
          <target state="translated">trio.abc.Channel</target>
        </trans-unit>
        <trans-unit id="cf0b67646f860ba83529d6cfca33cbd0e97dca38" translate="yes" xml:space="preserve">
          <source>trio.abc.Clock</source>
          <target state="translated">trio.abc.Clock</target>
        </trans-unit>
        <trans-unit id="d52f66c93d4495665ab26099ed7b068f6cd203e6" translate="yes" xml:space="preserve">
          <source>trio.abc.Clock.current_time</source>
          <target state="translated">trio.abc.Clock.current_time</target>
        </trans-unit>
        <trans-unit id="f1a7fef84be7807e06b8b7dd84fe96cdfbbd48f9" translate="yes" xml:space="preserve">
          <source>trio.abc.Clock.deadline_to_sleep_time</source>
          <target state="translated">trio.abc.Clock.deadline_to_sleep_time</target>
        </trans-unit>
        <trans-unit id="ff88985411e05fc4d0b682c576478f9112e54adb" translate="yes" xml:space="preserve">
          <source>trio.abc.Clock.start_clock</source>
          <target state="translated">trio.abc.Clock.start_clock</target>
        </trans-unit>
        <trans-unit id="6986a2b982b300d850b2477f83d550cffe3bc8ae" translate="yes" xml:space="preserve">
          <source>trio.abc.HalfCloseableStream</source>
          <target state="translated">trio.abc.HalfCloseableStream</target>
        </trans-unit>
        <trans-unit id="c45633c9dfa79dd633fb54068082b704754ed07b" translate="yes" xml:space="preserve">
          <source>trio.abc.HalfCloseableStream.send_eof</source>
          <target state="translated">trio.abc.HalfCloseableStream.send_eof</target>
        </trans-unit>
        <trans-unit id="630c0829d3b5cfda2a1efaebc01a6f9583ce5e32" translate="yes" xml:space="preserve">
          <source>trio.abc.HostnameResolver</source>
          <target state="translated">trio.abc.HostnameResolver</target>
        </trans-unit>
        <trans-unit id="9c26a30a634f130875e71d3a150545a949fc3cc3" translate="yes" xml:space="preserve">
          <source>trio.abc.HostnameResolver.getaddrinfo</source>
          <target state="translated">trio.abc.HostnameResolver.getaddrinfo</target>
        </trans-unit>
        <trans-unit id="518f335eed6739fe65675a4da68068cf6bdd9179" translate="yes" xml:space="preserve">
          <source>trio.abc.HostnameResolver.getnameinfo</source>
          <target state="translated">trio.abc.HostnameResolver.getnameinfo</target>
        </trans-unit>
        <trans-unit id="ca02f199a706165019ed7e899f41ae04559afcf4" translate="yes" xml:space="preserve">
          <source>trio.abc.Instrument</source>
          <target state="translated">trio.abc.Instrument</target>
        </trans-unit>
        <trans-unit id="abbd578ff4be0f40ba1220d1654182bb8dbb8609" translate="yes" xml:space="preserve">
          <source>trio.abc.Instrument.after_io_wait</source>
          <target state="translated">trio.abc.Instrument.after_io_wait</target>
        </trans-unit>
        <trans-unit id="6b4f0df1942088a8b3fde54ae3e4285cfa335df0" translate="yes" xml:space="preserve">
          <source>trio.abc.Instrument.after_run</source>
          <target state="translated">trio.abc.Instrument.after_run</target>
        </trans-unit>
        <trans-unit id="9d2a080e54970c6be1816f191d83ff6d04d0e40c" translate="yes" xml:space="preserve">
          <source>trio.abc.Instrument.after_task_step</source>
          <target state="translated">trio.abc.Instrument.after_task_step</target>
        </trans-unit>
        <trans-unit id="4361f635d71a758a9adde1728397da0822b10a13" translate="yes" xml:space="preserve">
          <source>trio.abc.Instrument.before_io_wait</source>
          <target state="translated">trio.abc.Instrument.before_io_wait</target>
        </trans-unit>
        <trans-unit id="128c7bd9c708ce137b8843bc3355cd9027f7b0bc" translate="yes" xml:space="preserve">
          <source>trio.abc.Instrument.before_run</source>
          <target state="translated">trio.abc.Instrument.before_run</target>
        </trans-unit>
        <trans-unit id="85b3a68f0879649aa55a24d2e511b418d6c4a43f" translate="yes" xml:space="preserve">
          <source>trio.abc.Instrument.before_task_step</source>
          <target state="translated">trio.abc.Instrument.before_task_step</target>
        </trans-unit>
        <trans-unit id="8f7ff4336e933b1b02b2f738ebd4bca20edc230b" translate="yes" xml:space="preserve">
          <source>trio.abc.Instrument.task_exited</source>
          <target state="translated">trio.abc.Instrument.task_exited</target>
        </trans-unit>
        <trans-unit id="0ace6f37e85d9ec3cee4794ba270896f458c271a" translate="yes" xml:space="preserve">
          <source>trio.abc.Instrument.task_scheduled</source>
          <target state="translated">trio.abc.Instrument.task_scheduled</target>
        </trans-unit>
        <trans-unit id="948d439cba0c022dd5e4d79c05ee926690872dfd" translate="yes" xml:space="preserve">
          <source>trio.abc.Instrument.task_spawned</source>
          <target state="translated">trio.abc.Instrument.task_spawned</target>
        </trans-unit>
        <trans-unit id="479b49e402879c8bb9a8813835609fe333eec049" translate="yes" xml:space="preserve">
          <source>trio.abc.Listener</source>
          <target state="translated">trio.abc.Listener</target>
        </trans-unit>
        <trans-unit id="faf59a5191994ddc91a905b69d50a6fdcb2bb91a" translate="yes" xml:space="preserve">
          <source>trio.abc.Listener.accept</source>
          <target state="translated">trio.abc.Listener.accept</target>
        </trans-unit>
        <trans-unit id="11a8ca4b2a10b40b651ee6e3e4a485c8ce5729c6" translate="yes" xml:space="preserve">
          <source>trio.abc.ReceiveChannel</source>
          <target state="translated">trio.abc.ReceiveChannel</target>
        </trans-unit>
        <trans-unit id="8f5272bbf2d6d6ea5aa8d69f5ec576bda366b97a" translate="yes" xml:space="preserve">
          <source>trio.abc.ReceiveChannel.receive</source>
          <target state="translated">trio.abc.ReceiveChannel.receive</target>
        </trans-unit>
        <trans-unit id="8ff4757b11937d63b37e8aa3d5ca5f62956f27dc" translate="yes" xml:space="preserve">
          <source>trio.abc.ReceiveStream</source>
          <target state="translated">trio.abc.ReceiveStream</target>
        </trans-unit>
        <trans-unit id="103f585fa049eb15732cd91de190ce1fb66ad415" translate="yes" xml:space="preserve">
          <source>trio.abc.ReceiveStream.receive_some</source>
          <target state="translated">trio.abc.ReceiveStream.receive_some</target>
        </trans-unit>
        <trans-unit id="ec0bf54c4a17cd287b0b6948ce1407941c029db3" translate="yes" xml:space="preserve">
          <source>trio.abc.SendChannel</source>
          <target state="translated">trio.abc.SendChannel</target>
        </trans-unit>
        <trans-unit id="4bb34e9f5441d0ab60cbc5f81d54df92d996c605" translate="yes" xml:space="preserve">
          <source>trio.abc.SendChannel.send</source>
          <target state="translated">trio.abc.SendChannel.send</target>
        </trans-unit>
        <trans-unit id="812c79fe7c4be2cda1926b1b3c68147871d92d78" translate="yes" xml:space="preserve">
          <source>trio.abc.SendStream</source>
          <target state="translated">trio.abc.SendStream</target>
        </trans-unit>
        <trans-unit id="9ea7cce2e94368540e71097dfd062909f5823556" translate="yes" xml:space="preserve">
          <source>trio.abc.SendStream.send_all</source>
          <target state="translated">trio.abc.SendStream.send_all</target>
        </trans-unit>
        <trans-unit id="74ca6d13717caddcc1355c383047884dfcf4a246" translate="yes" xml:space="preserve">
          <source>trio.abc.SendStream.wait_send_all_might_not_block</source>
          <target state="translated">trio.abc.SendStream.wait_send_all_might_not_block</target>
        </trans-unit>
        <trans-unit id="b3a30fa4477d253d399deb43c2a5cf8562308fe1" translate="yes" xml:space="preserve">
          <source>trio.abc.SocketFactory</source>
          <target state="translated">trio.abc.SocketFactory</target>
        </trans-unit>
        <trans-unit id="7c176ab4103725dd085cf08d565805a2387f9b7c" translate="yes" xml:space="preserve">
          <source>trio.abc.SocketFactory.socket</source>
          <target state="translated">trio.abc.SocketFactory.socket</target>
        </trans-unit>
        <trans-unit id="e17d6e3baeab9874433e202357ba447d3f416bc6" translate="yes" xml:space="preserve">
          <source>trio.abc.Stream</source>
          <target state="translated">trio.abc.Stream</target>
        </trans-unit>
        <trans-unit id="f7fc3bd6afe008621c22586b6a2e7b2f157bfd8b" translate="yes" xml:space="preserve">
          <source>trio.aclose_forcefully</source>
          <target state="translated">trio.aclose_forcefully</target>
        </trans-unit>
        <trans-unit id="1de4150cbe33c076476a2121992ac29e2c3f9b9d" translate="yes" xml:space="preserve">
          <source>trio.current_effective_deadline</source>
          <target state="translated">trio.current_effective_deadline</target>
        </trans-unit>
        <trans-unit id="2eed66b6fa7b295fcdfa9190b7b5631f534b593e" translate="yes" xml:space="preserve">
          <source>trio.current_time</source>
          <target state="translated">trio.current_time</target>
        </trans-unit>
        <trans-unit id="938182158eed707ca8eac00a5679e54d7f6d5b20" translate="yes" xml:space="preserve">
          <source>trio.fail_after</source>
          <target state="translated">trio.fail_after</target>
        </trans-unit>
        <trans-unit id="fc10176acce1e6bef6492d1be9c92700b8319114" translate="yes" xml:space="preserve">
          <source>trio.fail_at</source>
          <target state="translated">trio.fail_at</target>
        </trans-unit>
        <trans-unit id="68e9a720bb3ea9f731b8be00de5b43e71c78928a" translate="yes" xml:space="preserve">
          <source>trio.from_thread.run</source>
          <target state="translated">trio.from_thread.run</target>
        </trans-unit>
        <trans-unit id="582f09672f0c15e6f6f0f6e120aebcf92841eab8" translate="yes" xml:space="preserve">
          <source>trio.from_thread.run_sync</source>
          <target state="translated">trio.from_thread.run_sync</target>
        </trans-unit>
        <trans-unit id="377d7ee8dfeaa1f955cdcc0eecf94dfe241249aa" translate="yes" xml:space="preserve">
          <source>trio.hazmat.Abort</source>
          <target state="translated">trio.hazmat.Abort</target>
        </trans-unit>
        <trans-unit id="fee31b3594e531e910ebde4880eb8e586e8f3cd0" translate="yes" xml:space="preserve">
          <source>trio.hazmat.Abort.FAILED</source>
          <target state="translated">trio.hazmat.Abort.FAILED</target>
        </trans-unit>
        <trans-unit id="efd549a2453ca696b6ead7dc567431072bce92b8" translate="yes" xml:space="preserve">
          <source>trio.hazmat.Abort.SUCCEEDED</source>
          <target state="translated">trio.hazmat.Abort.SUCCEEDED</target>
        </trans-unit>
        <trans-unit id="66f4aa9273b57f40b6dcebdfb61b6cd599528994" translate="yes" xml:space="preserve">
          <source>trio.hazmat.FdStream</source>
          <target state="translated">trio.hazmat.FdStream</target>
        </trans-unit>
        <trans-unit id="55f183b8e8aa301ba8b3a72227da949e9e1e6296" translate="yes" xml:space="preserve">
          <source>trio.hazmat.ParkingLot</source>
          <target state="translated">trio.hazmat.ParkingLot</target>
        </trans-unit>
        <trans-unit id="67eee9dbc5fa3716dd2fad16fdea9e70570de9a2" translate="yes" xml:space="preserve">
          <source>trio.hazmat.ParkingLot.park</source>
          <target state="translated">trio.hazmat.ParkingLot.park</target>
        </trans-unit>
        <trans-unit id="5de001a607de1ce79a0247d9f4b2e617e0cf4e83" translate="yes" xml:space="preserve">
          <source>trio.hazmat.ParkingLot.repark</source>
          <target state="translated">trio.hazmat.ParkingLot.repark</target>
        </trans-unit>
        <trans-unit id="4a72401f77c127ac32bc77daf922333487dce815" translate="yes" xml:space="preserve">
          <source>trio.hazmat.ParkingLot.repark_all</source>
          <target state="translated">trio.hazmat.ParkingLot.repark_all</target>
        </trans-unit>
        <trans-unit id="283dd5ef0d92c78b9e243497d9151f1f44822e85" translate="yes" xml:space="preserve">
          <source>trio.hazmat.ParkingLot.statistics</source>
          <target state="translated">trio.hazmat.ParkingLot.statistics</target>
        </trans-unit>
        <trans-unit id="7fafec417f86a26523d900ff7b228b917db6f4b0" translate="yes" xml:space="preserve">
          <source>trio.hazmat.ParkingLot.unpark</source>
          <target state="translated">trio.hazmat.ParkingLot.unpark</target>
        </trans-unit>
        <trans-unit id="5c10855950b05e29e910ba2b1d95243db34992ee" translate="yes" xml:space="preserve">
          <source>trio.hazmat.ParkingLot.unpark_all</source>
          <target state="translated">trio.hazmat.ParkingLot.unpark_all</target>
        </trans-unit>
        <trans-unit id="958db2dba257a5c4b74b1715a40b00963f64ff73" translate="yes" xml:space="preserve">
          <source>trio.hazmat.RunVar</source>
          <target state="translated">trio.hazmat.RunVar</target>
        </trans-unit>
        <trans-unit id="1f93d61cfb062684edcab4666c7a9094ad92be02" translate="yes" xml:space="preserve">
          <source>trio.hazmat.Task</source>
          <target state="translated">trio.hazmat.Task</target>
        </trans-unit>
        <trans-unit id="56007a256133264ebe4115d7d758619c3a3188d7" translate="yes" xml:space="preserve">
          <source>trio.hazmat.Task.child_nurseries</source>
          <target state="translated">trio.hazmat.Task.child_nurseries</target>
        </trans-unit>
        <trans-unit id="0f2bc5c4aa63929d0a3ad363dc71ca1df17f91d2" translate="yes" xml:space="preserve">
          <source>trio.hazmat.Task.context</source>
          <target state="translated">trio.hazmat.Task.context</target>
        </trans-unit>
        <trans-unit id="959f45a936e9a2d50a91f2e723a17ed6a35c6416" translate="yes" xml:space="preserve">
          <source>trio.hazmat.Task.coro</source>
          <target state="translated">trio.hazmat.Task.coro</target>
        </trans-unit>
        <trans-unit id="313d68ca9b0270eb8d4634469d04d80cb05bd795" translate="yes" xml:space="preserve">
          <source>trio.hazmat.Task.custom_sleep_data</source>
          <target state="translated">trio.hazmat.Task.custom_sleep_data</target>
        </trans-unit>
        <trans-unit id="4cdfd05a664da3de9c44529c01c083d0ca7faa5d" translate="yes" xml:space="preserve">
          <source>trio.hazmat.Task.name</source>
          <target state="translated">trio.hazmat.Task.name</target>
        </trans-unit>
        <trans-unit id="b9e333285fe3a864a13b34b091cc530be8a15966" translate="yes" xml:space="preserve">
          <source>trio.hazmat.Task.parent_nursery</source>
          <target state="translated">trio.hazmat.Task.parent_nursery</target>
        </trans-unit>
        <trans-unit id="b19a9a96b81abb9460c908a51450e66b85e95559" translate="yes" xml:space="preserve">
          <source>trio.hazmat.TrioToken</source>
          <target state="translated">trio.hazmat.TrioToken</target>
        </trans-unit>
        <trans-unit id="37a507b84454a6d2e51a96f14c36d027ca8254c2" translate="yes" xml:space="preserve">
          <source>trio.hazmat.TrioToken.run_sync_soon</source>
          <target state="translated">trio.hazmat.TrioToken.run_sync_soon</target>
        </trans-unit>
        <trans-unit id="0a6d9b1a7e2e0e14ca83f31bf2ecbc93dbe19578" translate="yes" xml:space="preserve">
          <source>trio.hazmat.WaitForSingleObject</source>
          <target state="translated">trio.hazmat.WaitForSingleObject</target>
        </trans-unit>
        <trans-unit id="7e7ad7d21c4f47b50214ccbcc8b698c85d6fbf18" translate="yes" xml:space="preserve">
          <source>trio.hazmat.add_instrument</source>
          <target state="translated">trio.hazmat.add_instrument</target>
        </trans-unit>
        <trans-unit id="5f8c563ff87b2dc8c8567e1809ee11a4bc7a2c64" translate="yes" xml:space="preserve">
          <source>trio.hazmat.cancel_shielded_checkpoint</source>
          <target state="translated">trio.hazmat.cancel_shielded_checkpoint</target>
        </trans-unit>
        <trans-unit id="85633e0b57f589bc43be76f6e91b99ee40c1b5ff" translate="yes" xml:space="preserve">
          <source>trio.hazmat.checkpoint</source>
          <target state="translated">trio.hazmat.checkpoint</target>
        </trans-unit>
        <trans-unit id="cff2493b6d0ffc2dd73a3c90865e7edbdc9d0fd6" translate="yes" xml:space="preserve">
          <source>trio.hazmat.checkpoint_if_cancelled</source>
          <target state="translated">trio.hazmat.checkpoint_if_cancelled</target>
        </trans-unit>
        <trans-unit id="4be8b9e956d11a82d9df0d01738b7e04fbdcbe0f" translate="yes" xml:space="preserve">
          <source>trio.hazmat.current_clock</source>
          <target state="translated">trio.hazmat.current_clock</target>
        </trans-unit>
        <trans-unit id="13992abda4562f03ffaedab3ba0d10e06b9d8d0d" translate="yes" xml:space="preserve">
          <source>trio.hazmat.current_iocp</source>
          <target state="translated">trio.hazmat.current_iocp</target>
        </trans-unit>
        <trans-unit id="112caae5ed90caa79dbadc12c74111a7de07ea48" translate="yes" xml:space="preserve">
          <source>trio.hazmat.current_kqueue</source>
          <target state="translated">trio.hazmat.current_kqueue</target>
        </trans-unit>
        <trans-unit id="335b5e41a591c612c8ddf22ad88c78fd3c5d1ea6" translate="yes" xml:space="preserve">
          <source>trio.hazmat.current_root_task</source>
          <target state="translated">trio.hazmat.current_root_task</target>
        </trans-unit>
        <trans-unit id="af6409a5d25b2b2e0d63989673f5312d8a0f9cb5" translate="yes" xml:space="preserve">
          <source>trio.hazmat.current_statistics</source>
          <target state="translated">trio.hazmat.current_statistics</target>
        </trans-unit>
        <trans-unit id="c67b6b454c3d3c97bb7113fc85b6278d74a0a307" translate="yes" xml:space="preserve">
          <source>trio.hazmat.current_task</source>
          <target state="translated">trio.hazmat.current_task</target>
        </trans-unit>
        <trans-unit id="b484dd3f465efe0b9dee8c719d8199ff988ce36e" translate="yes" xml:space="preserve">
          <source>trio.hazmat.current_trio_token</source>
          <target state="translated">trio.hazmat.current_trio_token</target>
        </trans-unit>
        <trans-unit id="8138820f0643fc08460f2bb8e6511445b9034283" translate="yes" xml:space="preserve">
          <source>trio.hazmat.currently_ki_protected</source>
          <target state="translated">trio.hazmat.currently_ki_protected</target>
        </trans-unit>
        <trans-unit id="8807d9ce19d767ec2d4a0209f2bd1965a7bb6d38" translate="yes" xml:space="preserve">
          <source>trio.hazmat.disable_ki_protection</source>
          <target state="translated">trio.hazmat.disable_ki_protection</target>
        </trans-unit>
        <trans-unit id="35d42be3848d0f524edc56bc03f5ae81cdbd0e48" translate="yes" xml:space="preserve">
          <source>trio.hazmat.enable_ki_protection</source>
          <target state="translated">trio.hazmat.enable_ki_protection</target>
        </trans-unit>
        <trans-unit id="cfdb8ae674ad966b4d6f83b7a671c2961fd4e11e" translate="yes" xml:space="preserve">
          <source>trio.hazmat.monitor_completion_key</source>
          <target state="translated">trio.hazmat.monitor_completion_key</target>
        </trans-unit>
        <trans-unit id="d4385c84878e7961508daf0e399885ff854f078d" translate="yes" xml:space="preserve">
          <source>trio.hazmat.monitor_kevent</source>
          <target state="translated">trio.hazmat.monitor_kevent</target>
        </trans-unit>
        <trans-unit id="4fb524c029651259b6fac24963efdbc39d2d5810" translate="yes" xml:space="preserve">
          <source>trio.hazmat.notify_closing</source>
          <target state="translated">trio.hazmat.notify_closing</target>
        </trans-unit>
        <trans-unit id="58d9922fc01e695e176b3398900c1620474e05c0" translate="yes" xml:space="preserve">
          <source>trio.hazmat.permanently_detach_coroutine_object</source>
          <target state="translated">trio.hazmat.permanently_detach_coroutine_object</target>
        </trans-unit>
        <trans-unit id="8c6ec7a98ae29137ac6d5e2456a2ace284513d5f" translate="yes" xml:space="preserve">
          <source>trio.hazmat.reattach_detached_coroutine_object</source>
          <target state="translated">trio.hazmat.reattach_detached_coroutine_object</target>
        </trans-unit>
        <trans-unit id="c0ba6fb9beaafb11725d65a4d0264cf061506303" translate="yes" xml:space="preserve">
          <source>trio.hazmat.register_with_iocp</source>
          <target state="translated">trio.hazmat.register_with_iocp</target>
        </trans-unit>
        <trans-unit id="039dfbc898635052d0b99cd4c0854c35ced8d62a" translate="yes" xml:space="preserve">
          <source>trio.hazmat.remove_instrument</source>
          <target state="translated">trio.hazmat.remove_instrument</target>
        </trans-unit>
        <trans-unit id="21cb4fca281bd3691ebdd610cf7380b46b8d9c95" translate="yes" xml:space="preserve">
          <source>trio.hazmat.reschedule</source>
          <target state="translated">trio.hazmat.reschedule</target>
        </trans-unit>
        <trans-unit id="31c9a34db2dedb44f9338528684664cc72019f27" translate="yes" xml:space="preserve">
          <source>trio.hazmat.spawn_system_task</source>
          <target state="translated">trio.hazmat.spawn_system_task</target>
        </trans-unit>
        <trans-unit id="2e93cd9997ade187a201b987881484fcdf10252d" translate="yes" xml:space="preserve">
          <source>trio.hazmat.temporarily_detach_coroutine_object</source>
          <target state="translated">trio.hazmat.temporarily_detach_coroutine_object</target>
        </trans-unit>
        <trans-unit id="01e35385fad5b8340d4043e9ea3ab8e8e3501272" translate="yes" xml:space="preserve">
          <source>trio.hazmat.wait_kevent</source>
          <target state="translated">trio.hazmat.wait_kevent</target>
        </trans-unit>
        <trans-unit id="ec1925b3d06a473de1bbb73be3a3249a85084112" translate="yes" xml:space="preserve">
          <source>trio.hazmat.wait_overlapped</source>
          <target state="translated">trio.hazmat.wait_overlapped</target>
        </trans-unit>
        <trans-unit id="5c765a44e4d626e47e9d5612642e37cd06f7ab07" translate="yes" xml:space="preserve">
          <source>trio.hazmat.wait_readable</source>
          <target state="translated">trio.hazmat.wait_readable</target>
        </trans-unit>
        <trans-unit id="74f4e8f2e74570c40c909004495b6b1bc32b9f59" translate="yes" xml:space="preserve">
          <source>trio.hazmat.wait_task_rescheduled</source>
          <target state="translated">trio.hazmat.wait_task_rescheduled</target>
        </trans-unit>
        <trans-unit id="e180f2ed412288cb211c9350ccba8227a3b316f2" translate="yes" xml:space="preserve">
          <source>trio.hazmat.wait_writable</source>
          <target state="translated">trio.hazmat.wait_writable</target>
        </trans-unit>
        <trans-unit id="9f444e9cbb8a420ba7ff593b384dc73e7d19fdef" translate="yes" xml:space="preserve">
          <source>trio.move_on_after</source>
          <target state="translated">trio.move_on_after</target>
        </trans-unit>
        <trans-unit id="a63324b5d22beb567290f5e13959b101ac7e184d" translate="yes" xml:space="preserve">
          <source>trio.move_on_at</source>
          <target state="translated">trio.move_on_at</target>
        </trans-unit>
        <trans-unit id="b597ce79b7ab201268d48e583367c8625ba81ee7" translate="yes" xml:space="preserve">
          <source>trio.open_file</source>
          <target state="translated">trio.open_file</target>
        </trans-unit>
        <trans-unit id="335505d82feadb66202dab64fbaea820c83950a3" translate="yes" xml:space="preserve">
          <source>trio.open_memory_channel</source>
          <target state="translated">trio.open_memory_channel</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
